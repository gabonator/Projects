<script src="https://cdn.jsdelivr.net/npm/rete@1.5.2/build/rete.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.14/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-vue-render-plugin@0.5.1/build/vue-render-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-connection-plugin@0.9.0/build/connection-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-lifecycle-plugin@1.0.0-beta.1/build/lifecycle-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/alight@0.14.1/alight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-area-plugin@0.2.1/build/area-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-context-menu-plugin@0.6.0/build/context-menu-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-comment-plugin@0.3.0/build/comment-plugin.min.js"></script>           	
<script src="https://cdn.jsdelivr.net/npm/rete-history-plugin@0.1.0/build/history-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-connection-mastery-plugin@0.1.0/build/connection-mastery-plugin.min.js"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/modules/histogram-bellcurve.js"></script>
<style>
html, body {
  height: 100%;
  width: 100%;
  margin: 0;
  overflow: hidden;
}

.node .control input, .node .input-control input {
  width: 140px;
}
select, input {
  width: 100%;
  border-radius: 30px;
  background-color: white;
  padding: 2px 6px;
  border: 1px solid #999;
  font-size: 110%;
  width: 170px;
}

.note {
  position: absolute;
  top: 0;
  left: 0;
  background: #7ca2ba;
  color: white;
  width: 100%;
  text-align: center;
  padding: 0.5em;
  font-family: sans-serif;
  z-index: 1;
  a {
    color: #eee;
  }
}

#chart {
  width: 800px;
  height: 400px;
  position: absolute;
  left: 800px;
  top: 200px;
  border:3px #04b solid;
  border-radius:10px;
  display: none;
}

input:disabled { background: #ddd; color: #888}
</style>


<div id="rete"></div>
<div id="chart"></div>

<script>
class Signal
{
  constructor(signal)
  {
    if (!signal)
    {
      this.data = [];
      this.level = []
      this.type = "none";
      this.history = []
    }
    else if (Array.isArray(signal))
    {
      this.data = signal;
      this.level = this.data.map((s, i) => (i % 2 == 0) ? "h" : "l")
      this.type = "signal";
      this.history = ["constructor"]
    } else
    {
      this.data = [...signal.data];
      this.level = [...signal.level];
      this.type = signal.type;
      this.history = [...signal.history];
    }
  }

  getInfo()
  {
    if (this.type == "signal")
    {
      var duration = this.data.reduce((a,b)=>a+b, 0);
      return `Signal ${this.data.length}p / ${(duration/1000).toFixed(1)}ms`;
    }
    if (this.type == "pairs")
      return `Array of ${this.data.length} pairs`;
    if (this.type == "symbols")
      return `Array of ${this.data.length} symbols`;

    throw "wrong type"
    return this.type;
  }

  // exports
  makeQuantized(q)
  {
    var copy = new Signal(this);
    for (var i=0; i<copy.data.length; i++)
      copy.data[i] = Math.floor((copy.data[i]+q/2)/q)*q;
    copy.history.push(["quantize", q])
    return copy;
  }
  makeSlice(begin, len, tillEnd)
  {
    var copy = new Signal(this);
    if (tillEnd)
    {
      copy.data = copy.data.slice(begin)
      copy.level = copy.level.slice(begin)
    } else {
      copy.data = copy.data.slice(begin, begin+len)
      copy.level = copy.level.slice(begin, begin+len)
    }
    if (tillEnd)
      copy.history.push(["slice", begin])
    else
      copy.history.push(["slice", begin, len])
    return copy
  }
  makeSplitByCondition(cond, brk)
  {
    // TODO: split
    var copy = new Signal(this);
    var filterCode = eval(`(x, i) => ${cond}`);
    copy.data = [];
    copy.level = [];
    for (var i=0; i<this.data.length; i++)
    {
      if (filterCode(this.data[i], i))
      {
        copy.data.push(this.data[i]);
        copy.level.push(this.level[i]);
      }
      else if (brk)
        break;
    }
    copy.history.push(["splitbycond", cond, brk])
    return copy;
  }
  makePairs()
  {
    var copy = new Signal(this);
    var arrout = []
    for (var i=0; i<this.data.length; i+=2)
      arrout.push(`${this.data[i]} ${this.data[i+1]}`);
    copy.data = arrout;
    copy.level = [];
    copy.type = "pairs";
    copy.history.push("pairs");
    return copy;
  }
  makeLookupTable(assign, invalid)
  {
    var copy = new Signal(this);
    copy.data = [];
    copy.level = [];
    copy.type = "symbols";
    copy.history.push(["lookuptable", assign, invalid])

    for (var i=0; i<this.data.length; i++)
    {
      var symbol = invalid;
      for (var j=0; j<assign.length; j++)
        if (this.data[i] == assign[j][0])
          symbol = assign[j][1];
      copy.data.push(symbol);
    }
    return copy;
  }
  checkAssertion(cond)
  {
    var result = false;
    try {
      var arr = this.data;
      result = eval(`${cond}`);
    } catch (e) {
      result = false;
    }
    return result;
  }
}

var numSocket = new Rete.Socket('Number value');
var arrSocket = new Rete.Socket('Array value');
var attrSocket = new Rete.Socket('Attributes');

var VueNumControl = {
  props: ['readonly', 'defaultVal', 'emitter', 'ikey', 'getData', 'putData', 'isVisible', 'title'],
  template: '<div v-if="isVisible" style="font-family: sans-serif; font-size:14px; color:#444;">{{title}}<br><input type="number" :readonly="readonly" :value="value" @input="change($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""/></div>',
  data() {
    return {
      value: 0,
      isVisible: true,
      title: ""
    }
  },
  methods: {
    change(e){
      this.value = +e.target.value;
      this.update();
    },
    update() {
      if (this.ikey)
        this.putData(this.ikey, this.value)
      this.emitter.trigger('process');
    }
  },
  mounted() {
    this.value = this.getData(this.ikey);;
    this.update();
  }
}

var VueStaticControl = {
  props: ['readonly', 'emitter', 'ikey', 'getData', 'putData'],
  template: '<div style="font-family: sans-serif; font-size:14px; color:#444;" v-html="value"></div>',
  data() {
    return {
      value: ""
    }
  },
  methods: {
  },
  mounted() {
    this.value = this.getData(this.ikey);
  }
}

var VueStrControl = {
  props: ['readonly', /*'defaultVal',*/ 'emitter', 'ikey', 'getData', 'putData', 'title'],
  template: '<div style="font-family: sans-serif; font-size:14px; color:#444;">{{title}}<br><input :readonly="readonly" :value="value" @input="change($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""/></div>',
  data() {
    return {
      value: "",
      title: ""
    }
  },
  methods: {
    change(e){
      this.value = e.target.value;
      this.update();
    },
    update() {
      if (this.ikey)
        this.putData(this.ikey, this.value)
      this.emitter.trigger('process');
    }
  },
  mounted() {
    let val = this.getData(this.ikey);
    this.value = val;// val === undefined ? this.defaultVal : val;
    this.update();
  }
}

var VueStrDoubleControl = {
  props: ['readonly', /*'defaultVal',*/ 'emitter', 'ikey', 'getData', 'putData', 'isVisible', 'width1', 'width2', 'disabled1', 'disabled2'],
  template: '<div v-if="isVisible"><input :style="{width:width1}" :readonly="readonly" :disabled="disabled1" :value="value1" @input="change1($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""/><input :style="{width:width2}" :readonly="readonly" :disabled="disabled2" :value="value2" @input="change2($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""/></div>',
  data() {
    return {
      width1: "120px",
      width2: "60px",
      isVisible: true,
      value1: "",
      value2: "",
      disabled1: false,
      disabled2: false,
    }
  },
  methods: {
    change1(e){
      this.value1 = e.target.value;
      this.update();
    },
    change2(e){
      this.value2 = e.target.value;
      this.update();
    },
    update() {
      if (this.ikey)
        this.putData(this.ikey, [this.value1, this.value2])
      this.emitter.trigger('process');
    }
  },
  mounted() {
    let val = this.getData(this.ikey);
    if (val && val.length >= 2)
    {
      this.value1 = val[0];
      this.value2 = val[1];
    }
    this.update();
  }
}

var VueCheckControl = {
  props: ['readonly', 'title', 'label', 'emitter', 'ikey', 'getData', 'putData'],
  template: '<div style="font-family: sans-serif; font-size:14px; color:#444;"><input style="width:32px" type="checkbox" :checked="value" :readonly="readonly" @input="change($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""/>{{title}}</div>',
  data() {
    return {
      value: false,
      title: "",
    }
  },
  methods: {
    change(e){
      this.value = e.target.checked;
      this.update();
    },
    update() {
      if (this.	ikey)
        this.putData(this.ikey, this.value)
      this.emitter.trigger('process');
    }
  },
  mounted() {
    this.value = this.getData(this.ikey);
    this.update();
  }
}

var VueOptionControl = {
  props: ['readonly', 'emitter', 'ikey', 'getData', 'putData'],
  template: `<div>
    <div style="font-family: sans-serif; font-size:14px; color:#444;">{{title}}</div>
    <label v-for="(val, key) in options" :key="val" style="font-family: sans-serif; font-size:14px; color:#444;">
      <input style="width:24px" type="radio" 
        :name="name" 
        :value="val" 
        :checked="val == value" 
        @input="change($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""> 
      {{ key }}<br>
    </label>
  </div>`,
  data() {
    return {
      value: 0,
      options: {},
      title: ""
    }
  },
  methods: {
    change(e){
      this.value = e.target.value;
      this.update();
    },
    update() {
      if (this.ikey)
        this.putData(this.ikey, {value:this.value, options:this.options, title:this.title})
      this.emitter.trigger('process');
    }
  },
  mounted() {
    let val = this.getData(this.ikey);
    this.options = val.options;
    this.value = val.value;
    this.title = val.title;
    this.update();
  }
}

var VueTextControl = {
  props: ['readonly', 'emitter', 'ikey', 'getData', 'putData'],
  template: '<textarea style="width:100%; height:80px" :readonly="readonly" :value="value" @input="change($event)" @dblclick.stop="" @pointerdown.stop="" @pointermove.stop=""/>',
  data() {
    return {
      value: "init text",
    }
  },
  methods: {
    change(e){
      this.value = e.target.value;
      this.update();
    },
    update() {
      if (this.ikey)
        this.putData(this.ikey, this.value)
      this.emitter.trigger('process');
    }
  },
  mounted() {
    this.value = this.getData(this.ikey);
    this.update();
  }
}

class StaticControl extends Rete.Control {
  constructor(emitter, key, value) {
    super(key);
    this.component = VueStaticControl;
    this.props = { emitter, ikey: key };
  }
  setValue(val) {
    this.vueContext.value = val;
  }
}

class NumControl extends Rete.Control {
  constructor(emitter, key, readonly, title) {
    super(key);
    var isVisible = true;
    this.component = VueNumControl;
    this.props = { emitter, ikey: key, readonly, isVisible, title };
  }
  setValue(val) {
    this.vueContext.value = val;
  }
  setVisible(vis)
  {
    this.vueContext.isVisible = vis;
  }
}

class StrControl extends Rete.Control {
  constructor(emitter, key, readonly, title) {
    super(key);
    this.component = VueStrControl;
    this.props = { emitter, ikey: key, readonly, title };
  }

  setValue(val) {
    this.vueContext.value = val;
  }
  setVisible(vis)
  {
    this.vueContext.isVisible = vis;
  }
}

class StrDoubleControl extends Rete.Control {
  constructor(emitter, key, attrs) {
    super(key);
    this.component = VueStrDoubleControl;
    this.props = { emitter, ikey: key, readonly:false, isVisible: true, ...attrs };
  }
  setValue(val) {
    this.vueContext.value = val;
  }
  setVisible(vis) {
    this.vueContext.isVisible = vis;
  }
}

class CheckControl extends Rete.Control {
  constructor(emitter, key, readonly, title) {
    super(key);
    this.component = VueCheckControl;
    this.props = { emitter, ikey: key, readonly, title };
  }
  setValue(val) {
    this.vueContext.value = val;
  }
  setVisible(vis)
  {
    this.vueContext.isVisible = vis;
  }
}

class OptionControl extends Rete.Control {
  constructor(emitter, key, readonly, options) {
    super(key);
    this.component = VueOptionControl;
    this.props = { emitter, ikey: key, readonly, options };
  }
  setValue(val) {
    this.vueContext.value = val;
  }
  setVisible(vis)
  {
    this.vueContext.isVisible = vis;
  }
}

class TextControl extends Rete.Control {

  constructor(emitter, key, readonly) {
    super(key);
    this.component = VueTextControl;
    this.props = { emitter, ikey: key, readonly};
  }

  setValue(val) {
    this.vueContext.value = val;
  }
}

class InputSignal extends Rete.Component {
    constructor(){
        super("Input signal");
    }
    builder(node) {
        var out = new Rete.Output('out', "Signal", arrSocket);
        node.data.out = new Signal([300,600,280,600,320,560,320,600,320,600,320,580,320,600,280,600,320,580,320,580,300,640,280,600,320,580,280,340,580,320,600,580,300,620,300,600,300,600,300,320,600,580,320,580,320,600,320,300,560,22580,300,580,280,600,320,620,300,580,320,580,300,600,320,600,300,600,300,600,300,600,300,620,300,600,300,600,300,300,620,280,640,560,300,620,280,620,280,620,280,340,600,580,320,580,340,560,320,300,600,23000,280,580,300,620,260,640,280,600,300,600,300,600,320,600,300,600,320,580,320,600,280,620,280,600,300,640,280,320,580,320,580,600,300,620,260,620,300,600,300,340,580,600,300,600,320,580,320,320,580,22540,320,580,280,620,300,600,300,620,300,580,300,600,300,620,300,600,300,600,280,600,320,620,300,580,300,600,340,280,600,300,620,580,300,620,300,580,320,600,280,320,580,620,320,600,280,600,320,300,580,498500,280,620,280,580,340,600,300,600,300,600,300,600,320,580,340,580,320,560,300,620,280,620,300,600,300,580,340,300,600,320,580,580,320,600,300,600,300,620,300,300,580,620,320,560,320,320,580,600,320,22600,260,600,300,620,300,580,320,600,300,620,280,620,280,620,260,620,300,600,340,560,320,600,300,600,300,620,300,300,600,320,600,580,300,600,280,620,300,620,280,340,580,600,280,620,280,340,580,580,320,23060,280,600,280,600,300,600,320,560,320,600,320,580,320,580,300,620,300,600,300,600,320,580,320,600,280,620,280,340,600,280,600,600,320,560,320,600,320,580,320,300,600,600,320,560,320,340,580,600,280,22580,280,600,280,620,300,600,300,600,320,580,300,620,280,620,280,600,300,600,320,580,340,580,300,620,280,620,300,320,580,340,560,600,300,600,320,600,280,600,300,340,600,600,280,600,300,320,580,620,300]);
        var static1 = new StaticControl(this.editor, "static1")
        node.data.static1 = "Double click to set...";
        return node.addControl(static1).addOutput(out);
    }
    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        outputs['out'] = node.data.out;
        _node.outputs.get("out").name = node.data.out.getInfo();
        _node.outputs.get("out").node.update();
    }
}

class Quantize extends Rete.Component {
    constructor(){
        super("Quantize");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        this.out = new Rete.Output('out', "Signal", arrSocket);
        var len = new NumControl(this.editor, 'len');
        node.data.len = 300;
        return node
            .addInput(inp)
            .addControl(len)
            .addOutput(this.out);
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var input = inputs['in'].length ? inputs['in'][0] : new Signal();
        outputs['out'] = input.makeQuantized(node.data.len);
        _node.outputs.get("out").name = outputs['out'].getInfo();
        _node.outputs.get("out").node.update();
    }
}

class Filter extends Rete.Component {
    constructor(){
        super("Filter");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        this.out = new Rete.Output('out', "Signal", arrSocket);
        var condition = new StrControl(this.editor, 'condition', false, 'Condition');
        var breakOn = new CheckControl(this.editor, 'break', false, "Break on first");
        node.data.condition = "x < 5000";
        node.data.break = true;
        return node
            .addInput(inp)
            .addControl(condition)
            .addControl(breakOn)
            .addOutput(this.out);
    }

    worker(node, inputs, outputs) {
        var input = inputs['in'].length ? inputs['in'][0] : new Signal();
        outputs['out'] = input.makeSplitByCondition(node.data.condition, node.data.break);
        this.out.name = outputs['out'].getInfo();
        this.out.node.update();
    }
}

class If extends Rete.Component {
    constructor(){
        super("If signal...");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        var out = new Rete.Output('out', "Number", numSocket);
        var condition = new StrControl(this.editor, 'condition', false, 'If condition is true');
        var static1 = new StaticControl(this.editor, "static1")
        var retValues = new StrDoubleControl(this.editor, 'retValues', {width1: "70px", width2: "70px"});
        node.data.retValues = ["1", "0"]
        node.data.static1 = "Return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return"
        node.data.condition = "arr[0] < 800 && arr[1] > 5000";

        var aux = node
            .addInput(inp)
            .addControl(condition)
            .addControl(static1)
            .addControl(retValues)
            .addOutput(out);
        return aux;
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var arr = inputs['in'].length ? inputs['in'][0] : new Signal();
        var q = node.data.len;
        var newarr = [];
        var result;
        try {
          result = eval(`${node.data.condition}`);
        } catch (e) {
          _node.outputs.get("out").name = `Error`;
          _node.outputs.get("out").node.update();
          return;
        }
        var resultValue = result ? node.data.retValues[0] : node.data.retValues[1];
        outputs['out'] = [resultValue];
        _node.outputs.get("out").name = `Number ${resultValue}`;
        _node.outputs.get("out").node.update();
    }
}

class Histogram extends Rete.Component {
    constructor(){
        super("Histogram");
    }

    builder(node) {
        var inp1 = new Rete.Input('in', "Signal", arrSocket);

        return node
            .addInput(inp1);
    }

    worker(node, inputs, outputs) {
        var n1 = inputs['in'].length ? inputs['in'][0].data : [];
        ShowHistogram(n1);
    }
}


class SubArray extends Rete.Component {
    constructor(){
        super("SubArray");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        var _begin = new Rete.Input('_begin', "(Number: Index of first)", numSocket);
        var _length = new Rete.Input('_len', "(Number: Length)", numSocket);
        var out = new Rete.Output('out', "Signal", arrSocket);
        var begin = new NumControl(this.editor, 'begin', false, "Index of first");
        var len = new NumControl(this.editor, 'len', false, "Length");
        var tillEnd = new CheckControl(this.editor, 'tillEnd', false, "Everything till end");

        node.data.begin = 1;
        node.data.len = 10;
        node.data.tillEnd = true;
        return node
            .addInput(inp)
            .addInput(_begin)
            .addInput(_length)
            .addControl(begin)
            .addControl(len)
            .addControl(tillEnd)
            .addOutput(out);
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var arr = inputs['in'].length ? inputs['in'][0] : new Signal();
        if (inputs['_begin'].length == 1 && inputs['_begin'][0] !== undefined)
        {
          node.data.begin = inputs['_begin'][0][0]
          _node.controls.get('begin').setValue(node.data.begin)
          _node.controls.get('begin').setVisible(false)
        } else
          _node.controls.get('begin').setVisible(true)

        if (inputs['_len'].length == 1 && inputs['_len'][0] !== undefined)
        {
          node.data.len = inputs['_len'][0][0]
          _node.controls.get('len').setValue(inputs['_len'][0])
          _node.controls.get('len').setVisible(false)
        } else
          _node.controls.get('len').setVisible(true && !node.data.tillEnd)

        arr = arr.makeSlice(node.data.begin, node.data.len, node.data.tillEnd)

        outputs['out'] = arr;
        _node.outputs.get("out").name = arr.getInfo();
        _node.outputs.get("out").node.update();
    }
}

class Pairs extends Rete.Component {
    constructor(){
        super("Pairs");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        this.out = new Rete.Output('out', "Signal", arrSocket);
        return node
            .addInput(inp)
            .addOutput(this.out);
    }

    worker(node, inputs, outputs) {
        var arr = inputs['in'].length ? inputs['in'][0] : new Signal();
        if (arr.data.length % 2 != 0)
        {
          outputs['out'] = new Signal([])
          this.out.name = `Error!`;
          this.out.node.update();
          throw "not pairs!"
        }

        outputs['out'] = arr.makePairs();

        this.out.name = outputs['out'].getInfo()
        this.out.node.update();
    }
}

class LookupTable extends Rete.Component {
    constructor(){
        super("Lookup table");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        this.out = new Rete.Output('out', "Signal", arrSocket);
        var assignment1 = new StrDoubleControl(this.editor, 'assign1', {width1: 120, width2: 60});
        var assignment2 = new StrDoubleControl(this.editor, 'assign2', {width1: 120, width2: 60});
        var assignment3 = new StrDoubleControl(this.editor, 'assign3', {width1: 120, width2: 60});
        var assignment4 = new StrDoubleControl(this.editor, 'assign4', {width1: 120, width2: 60});
        var assignment5 = new StrDoubleControl(this.editor, 'assign5', {width1: 120, width2: 60, disabled1: true, disabled2: false});
        node.data.assign1 = ["300 600", "1"]
        node.data.assign2 = ["600 300", "0"]
        node.data.assign3 = ["", ""]
        node.data.assign4 = ["", ""]
        node.data.assign5 = ["Other", "?"]
        var static1 = new StaticControl(this.editor, "static1")
        node.data.static1 = "Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output"

        return node
            .addInput(inp)
            .addControl(static1)
            .addControl(assignment1)
            .addControl(assignment2)
            .addControl(assignment3)
            .addControl(assignment4)
            .addControl(assignment5)
            .addOutput(this.out);
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var arr = inputs['in'].length ? inputs['in'][0] : new Signal();

        _node.controls.get('assign1').setVisible(true) // first
        _node.controls.get('assign2').setVisible(node.data.assign1.join("") != "")
        _node.controls.get('assign3').setVisible(node.data.assign2.join("") != "")
        _node.controls.get('assign4').setVisible(node.data.assign3.join("") != "")
        _node.controls.get('assign5').setVisible(true) // default

        outputs['out'] = arr.makeLookupTable([node.data.assign1,
          node.data.assign2, node.data.assign3, node.data.assign4],
          node.data.assign5[1]);
        this.out.name = outputs['out'].getInfo()
        this.out.node.update();
    }
}

class ToInteger extends Rete.Component {
    constructor(){
        super("Bits to integer");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        this.out = new Rete.Output('out', "Signal", arrSocket);

        var firstbit = new OptionControl(this.editor, 'firstbit');
        node.data.firstbit = {options: {"MSB": 0, "LSB": 1}, value:0, title:"First bit"}
        var datatype = new OptionControl(this.editor, 'datatype');
        node.data.datatype = {options: {"uint8_t": 0, "uint16_t": 1, "uint32_t": 2}, value:2, title:"Data type"}

        return node
            .addInput(inp)
            .addControl(firstbit)
            .addControl(datatype)
            .addOutput(this.out);
    }

    worker(node, inputs, outputs) {
        var arr = [];
        if (inputs['in'].length && inputs['in'][0]?.data)
          arr = [...inputs['in'][0].data];

        var uint = 0;
        var msb = node.data.firstbit.value == 0
        var databits = [8*1, 8*2, 8*4][node.data.datatype.value]
        var arrout = [];

        var bitsToInt = (a, count, msb) => {
          var uint = 0;
          for (var i=0; i<a.length; i++)
          {
            if (a[i] === "0" || a[i] === 0)
            {
            } else if (a[i] === "1" || a[i] === 1)
            {
              if (msb)
                uint |= 1<<(count-1-i)
              else
                uint |= 1<<i
            } else {
              outputs['out'] = {data:[]}
              this.out.name = `Error!`;
              this.out.node.update();
              throw "wrong data"
            }
          }

          var digits = (count+3)>>2;
          var hex = "0x"+(("00000000"+uint.toString(16)).substr(-digits));
          return hex;
        }

        if (arr.length < databits)
        {
          arrout.push(bitsToInt(arr, arr.length, msb));
        } else {
          while (arr.length % databits != 0)
            arr.unshift(0);

          while (arr.length >= databits)
          {
            var part = arr.splice(0, databits);
            arrout.push(bitsToInt(part, databits, msb));
          }
          if (arr.length)
            arrout.push(bitsToInt(arr, databits, msb));
        }
        if (!msb)
          arrout.reverse();
        outputs['out'] = {data:arrout}
        this.out.name = `uint32_t [${arrout.length}]`; // TODO: signal
        this.out.node.update();
    }
}

class Attributes extends Rete.Component {
    constructor(){
        super("Attributes");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Array", arrSocket);
        this.out = new Rete.Output('out', "Attributes", arrSocket);
        var attribute1 = new StrDoubleControl(this.editor, 'attribute1', {width1: 60, width2: 140});
        var attribute2 = new StrDoubleControl(this.editor, 'attribute2', {width1: 60, width2: 140});
        var attribute3 = new StrDoubleControl(this.editor, 'attribute3', {width1: 60, width2: 140});
        var attribute4 = new StrDoubleControl(this.editor, 'attribute4', {width1: 60, width2: 140});
        node.data.attribute1 = ["id", "\"Came 001unip\""]
        node.data.attribute2 = ["code", "arr[0]"]
        node.data.attribute3 = ["", ""]
        node.data.attribute4 = ["", ""]
        var static1 = new StaticControl(this.editor, "static1")
        node.data.static1 = "Atribute&nbsp;&nbsp;&nbsp;Value"

        return node
            .addInput(inp)
            .addControl(static1)
            .addControl(attribute1)
            .addControl(attribute2)
            .addControl(attribute3)
            .addControl(attribute4)
            .addOutput(this.out);
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var arr = inputs['in'].length ? [...inputs['in'][0].data] : [];

        _node.controls.get('attribute1').setVisible(true)
        _node.controls.get('attribute2').setVisible(node.data.attribute1.join("") != "")
        _node.controls.get('attribute3').setVisible(node.data.attribute2.join("") != "")
        _node.controls.get('attribute4').setVisible(node.data.attribute3.join("") != "")
        var attrs = [node.data.attribute1, node.data.attribute2, node.data.attribute3, node.data.attribute4]
        var arrout = [];
        for (var attr of attrs)
        {
          if (attr[0] == "")
            continue;
          if (attr[1][0] == "\"")
            arrout.push([attr[0], attr[1]]);
          else
            arrout.push([attr[0], eval(attr[1])]);
        }
        outputs['out'] = {data:arrout, type:"attributes"};

        this.out.name = `Array of ${arrout.length} attributes`;
        this.out.node.update();
    }
}

class DisplaySignal extends Rete.Component {
    constructor(){
        super("Display signal");
    }

    builder(node) {
        var inp1 = new Rete.Input('in', "Signal", arrSocket);
        return node.addInput(inp1);
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var n1 = inputs['in'].length ? inputs['in'][0] : new Signal();
        if (n1.data.length == 0)
          _node.window.hide();
        else
          _node.window.show(n1, 0.12);
    }

    created(node)
    {
      node.window = new DetailCanvas(900, 100);
    }
    destroyed(node)
    {
      node.window.remove();
    }
}

class Print extends Rete.Component {
    constructor(){
        super("Print");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        this.print = new TextControl(this.editor, 'print');
        return node.addInput(inp).addControl(this.print);
    }
    worker(node, inputs, outputs) {
        var input = inputs['in'].length ? inputs['in'][0] : {data:[]}
        var arr = input.data;
        var p = "";
        if (input?.type == "attributes")
          p = arr.map(pair => `${pair[0]}: ${pair[1]}`).join("\n")
        else
          p = arr.join(", ");
        console.log(arr);
        this.editor.nodes.find(n => n.id == node.id).controls.get('print').setValue(p);
    }         
}

class Assert extends Rete.Component {
    constructor(){
        super("Assertion");
    }

    builder(node) {
        var inp = new Rete.Input('in', "Signal", arrSocket);
        var condition = new StrControl(this.editor, 'condition', false, 'Condition');
        var static1 = new StaticControl(this.editor, "static1")
        node.data.condition = "arr.length == 24";
        node.data.static1 = ""
        return node
            .addInput(inp)
            .addControl(condition)
            .addControl(static1);
    }

    worker(node, inputs, outputs) {
        var _node = this.editor.nodes.find(n => n.id == node.id)
        var input = inputs['in'].length ? inputs['in'][0] : new Signal();
        var result;
        if (input.checkAssertion(node.data.condition))
          result = "OK";
        else
          result = "Error!";
        _node.controls.get('static1').setValue(result)
    }
}

(async () => {
    var container = document.querySelector('#rete');
    var components = [new InputSignal(), new SubArray(), new Quantize(),
      new Histogram(), new Filter(), new Pairs(), new LookupTable(), new Print(), new ToInteger(), new If(),
      new Attributes(), new DisplaySignal(), new Assert()];

    var getComponent = name => components.find(c=>c.constructor.name == name)
    var editor = new Rete.NodeEditor('demo@0.1.0', container);
    editor.use(ConnectionPlugin.default);
    editor.use(VueRenderPlugin.default);    
    editor.use(ContextMenuPlugin.default);
    editor.use(AreaPlugin);
    editor.use(CommentPlugin.default);
    editor.use(HistoryPlugin);
    editor.use(ConnectionMasteryPlugin.default);
    editor.use(LifecyclePlugin.default);

    var engine = new Rete.Engine('demo@0.1.0');
    
    components.map(c => {
      editor.register(c);
      engine.register(c);
    });

    var model = {
      // signal extraction
      input: {id:"InputSignal"},
      preamble: {id:"If"},
      subarray: {id:"SubArray"},
      filter: {id:"Filter"},
      // signal conditioning
      quantize: {id:"Quantize"},
      // signal processing
      pairs: {id:"Pairs"},
      lut: {id:"LookupTable"},
      convert: {id:"ToInteger"},
      // result
      attributes: {id:"Attributes"},
      // debugging
      print: {id:"Print"},
      histogram: {id:"Histogram"},
      display: {id:"DisplaySignal"},
      assert: {id:"Assert"},
    }

    var connections = [ 
      ["input.out", "preamble.in"],
      ["input.out", "subarray.in"],
      ["preamble.out", "subarray._begin"],
      ["subarray.out", "filter.in"],
      ["filter.out", "quantize.in"],
      ["quantize.out", "pairs.in"],
      ["pairs.out", "lut.in"],
      ["lut.out", "convert.in"],
      ["convert.out", "attributes.in"],
      ["attributes.out", "print.in"],
      ["filter.out", "histogram.in"],
      ["filter.out", "display.in"],
      ["lut.out", "assert.in"],
    ]

    for (var i in model)
    {
      model[i].component = await getComponent(model[i].id).createNode() 
      model[i].data = model[i].component.data;
    }

    model.preamble.data.condition = "arr[0] < 800 && arr[1] > 5000"
    model.preamble.data.retValues = ["3", "1"]
//    model.preamble.data.false = "1"
    model.subarray.data.tillEnd = true
    model.filter.data.condition = "x < 5000"
    model.filter.data.break = true;
    model.quantize.data.len = "300"
    model.lut.data.assign1 = ["300 600", "1"]
    model.lut.data.assign2 = ["600 300", "0"]
//    model.attributes.data.attribute1 = [?] TODO 
//    model.attributes.data.attribute2 = [?] TODO: Convert

    var i = 0;
    for (var m in model)
    {
      model[m].component.position = [100 + (i%4)*250, 200 + Math.floor(i/4)*280]
      editor.addNode(model[m].component);
      i++;
    }
    for (var c of connections)
    {
      var connOut = c[0].split(".");
      var connIn = c[1].split(".");
      var out = model[connOut[0]].component.outputs.get(connOut[1]);
      var inp = model[connIn[0]].component.inputs.get(connIn[1]);
      editor.connect(out, inp);      
    }

    editor.on('process nodecreated noderemoved connectioncreated connectionremoved', async () => {
      console.log('process');
        await engine.abort();
        await engine.process(editor.toJSON());
    });

    editor.on('zoom', (e) => {
        if (e.source === 'dblclick' && editor.selected?.list[0]?.name == "Input signal")
        {
          var node = editor.selected?.list[0];
          var _node = editor.nodes.find(n => n.id == node.id)
          var newsignal = prompt("Enter new signal", JSON.stringify(node.data.out.data));
          if (newsignal)
          {
            node.data.out = new Signal(JSON.parse(newsignal))
            editor.trigger('process');
          }
          return false;
        }
        return e.source !== 'dblclick';
    });

    editor.view.resize();
    //AreaPlugin.zoomAt(editor);
    editor.view.area.zoom(0.75, 0, -120);
    editor.trigger('process');
})();


function ShowHistogram(data)
{
  if (data.length == 0)
  {
    document.querySelector("#chart").style.display = "none";
    return;
  } else {
    document.querySelector("#chart").style.display = "block";
  }
  
  var data1 = [];
  var data2 = [];
  for (var i=0; i<data.length; i++)
  {
    if (i%2 == 0)
      data1.push(data[i]);
    else
      data2.push(data[i]);
  }

  Highcharts.chart('chart', {
    plotOptions: {series: {animation: false} },
    title: { text: null },
    xAxis: [{ title: { text: 'Data' }, alignTicks: false }, { title: { text: 'Histogram' }, alignTicks: false, opposite: true }],
    yAxis: [{ title: { text: 'Data' } }, { title: { text: 'Histogram' }, opposite: true }],
    series: [
    { name: 'Histogram', type: 'histogram', xAxis: 1, yAxis: 1, baseSeries: "s1", zIndex: -1, color: "rgba(255, 0, 0, 0.5)", binsNumber:20 },
    { name: 'Histogram', type: 'histogram', xAxis: 1, yAxis: 1, baseSeries: "s2", zIndex: -1, color: "rgba(0, 0, 255, 0.5)", binsNumber:20 },
    { name: 'Data', type: 'scatter', data: data1, id: 's1', marker: { radius: 1.5 }, visible:false },
    { name: 'Data', type: 'scatter', data: data2, id: 's2', marker: { radius: 1.5 }, visible:false }]
  });

  (function(H) {
   H.Pointer.prototype.drag = function(e) {
     var container = this.chart.container.parentElement;
     container.style.left = container.offsetLeft + e.movementX + 'px';
     container.style.top = container.offsetTop + e.movementY + 'px';
   }
  })(Highcharts);
}

class DetailCanvas
{
  constructor(w, h)
  {
    this.width = w;
    this.height = h;
    this.container = document.createElement("div");
    this.container.style = "position:absolute; top:50px; left:800px; width:800px; display:block; border:1px gray solid;" +
      "background:#f8f8f8; border:3px #04b solid; border-radius:10px; ";

    this.container.addEventListener('mousedown', (e) => {
      var drag = {x: e.clientX, y: e.clientY, e:e.currentTarget}
      var mouseMoveHandler = o => {
        const dx = o.clientX - drag.x;
        const dy = o.clientY - drag.y;
        drag.e.style.top = `${drag.e.offsetTop + dy}px`;
        drag.e.style.left = `${drag.e.offsetLeft + dx}px`;
        drag.x = o.clientX;
        drag.y = o.clientY;
      }
      var mouseUpHandler = e => {
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
      }
      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler);
    });

    document.documentElement.appendChild(this.container);

    this.scrollContainer = document.createElement("div");
    this.scrollContainer.style = "overflow:auto; overflow-y: scroll; white-space:nowrap";
    this.scrollContainer.width = w;
    this.scrollContainer.height = h;
    this.container.appendChild(this.scrollContainer);

    this.elems = [];
    for (var i=0; i<10; i++)
    {
      var elem = document.createElement("canvas");
      elem.style = " background:" + (i==1 ? "red": "blue");
      elem.width = 1024;
      elem.height = h;
      this.scrollContainer.appendChild(elem);
      this.elems.push(elem);
    }

    this.pulse = [];
    this.level = [];
  }
  remove()
  {
    for (var i=0; i<10; i++)
      this.scrollContainer.removeChild(this.elems[i]);
    this.container.removeChild(this.scrollContainer);
    document.documentElement.removeChild(this.container);
  }
  Clear(elem)
  {
    elem.getContext("2d").clearRect(0, 0, elem.width, elem.height);
    elem.style = "display:inline-block";
  }

  Line(elem, x1, y1, x2, y2)
  {
    var ctx = elem.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  Text(elem, x, y, text)
  {
    var ctx = elem.getContext("2d");
    ctx.font = "12px Arial";
    ctx.fillStyle = "#000000";
    ctx.textAlign = "center";
    ctx.fillText(text, x, y+10);
  }

  hide(elem)
  {
    if (!elem)
      this.container.style.display = "none";
    else
      elem.style="display: none;";
  }

  show(pulse, zoom)
  {
    this.container.style.display = "block";
    if (pulse.type != "signal")
      throw "wrong type"

    this.pulse = [...pulse.data];
    this.level = [...pulse.level];

    var sum = this.pulse.reduce((a,b) => a+b, 0)*zoom;
    for (var e of this.elems)
      this.hide(e);

    var scroll = 0;
    for (var i=0; i<this.elems.length; i++)
    {
      var curWidth = Math.min(2048, sum-scroll);
      if (curWidth <= 0)
        break;
      this.redraw(this.elems[i], curWidth, scroll, zoom);
      scroll += curWidth;
    }
  }

  redraw(elem, w, ofs, zoom)
  {
    this.Clear(elem);

    elem.width = w;

    var x = -ofs;
    var y = 80;
    var c = "rgba(0, 0, 0, 0.5)";
    var ctx = elem.getContext("2d");
    ctx.strokeStyle = c;
    var sum = 0;

    for (var i=0; i<this.pulse.length; i++)
    {
      if (i==0 && this.pulse[i] == 0)
        continue;

      sum += this.pulse[i];

      var nx = x + this.pulse[i] * zoom;
      var ny = (i&1) ? 80 : 20;
      var flag = 0;
      if (this.level.length)
      {
        switch (this.level[i])
        {
          case "h":
            ny = 20;
            flag = 1;
            break;
          case "l":
            ny = 80;
            flag = 2;
            break;
          default:
            throw "bad flag"
        }
      }

      ctx.strokeStyle = c;
      ctx.lineWidth = 1;
      this.Line(elem, x, y, x, ny);

      if (flag)
      {
        ctx.strokeStyle = ["rgba(0, 0, 0, 0.5)", "#ff0000", "#0000ff", "#00ff00", "#ff00ff", "#ffff00", "#00ffff"][flag];
        ctx.lineWidth = 3;
      }
      else
        ctx.strokeStyle = c;

      this.Line(elem, x, ny, nx, ny);

      // draw text?
      if (nx-x > 30)
        this.Text(elem, (x+nx)/2, 50-4, this.pulse[i] & 0xffffff);
      x = nx;
      y = ny;
    }

    if (y != 80)
    {
      ny = 80;
      this.Line(elem, x, ny, x, ny);
    }

    ctx.strokeStyle = "rgba(0, 0, 0, 0.9)";
  }

  zoomIn()
  {
    this.zoom *= 2;
    this.redraw();
  }

  zoomOut()
  {
    this.zoom /= 2;
    this.redraw();
  }
}
</script>