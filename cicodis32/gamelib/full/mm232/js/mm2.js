const mm2_skipIntro1 = true;
const mm2_skipIntro2 = true;
const mm2_skipMenuItem = 0;
const mm2_skipMenuChangeControls = true;
const mm2_skipMenuGameMode = true;
const mm2_skipMenuChangePlayer = true;
const mm2_skipLevelBanner = false;
const mm2_skipLevelGetReady = false;
const mm2_jumpToLevel = -1;

function init()
{
ds = 0x0168;
    cs = 0x0160;
    es = 0x0028;
    ss = 0x0168;
    fs = 0;
    gs = 0;
    r32[esp] = 0x318570;
    r32[ebp] = 0x318570;
    loadOverlay("MM2_1.bin", 0x1a8000);
    loadOverlay("MM2_2.bin", 0x1ec000);

}

function* start()
{
    yield* sub_1e36e8();
}

function* sub_1a8010() // 0160:1a8010 +long +returnCarry
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c8794();
    flags.carry = r32[eax] < 0x00000001;
    if (!flags.carry)
        { pc = 0x1a801c; break; }
    r8[al] = 0x08;
  case 0x1a801c: // 0160:1a801c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1a801e() // 0160:1a801e +long
{
    r32[esp] -= 4;
    push32(r32[ebp]);
    push32(flagAsReg32());
    flags.interrupts = 0;
    r8[al] = 0x34;
    out8(0x43, r8[al]);
    r32[eax] = 0;
    out8(0x40, r8[al]);
    r8[al] = r8[ah];
    out8(0x40, r8[al]);
    flagsFromReg32(pop32());
    push(ds);
    r32[edx] = memoryAGet32(ds, 0x2eebdc); ds = memoryAGet32(ds, 0x2eebde);
    r32[eax] = 0x00002508;
    interrupt(0x21);
    ds = pop();
    yield* sub_1a8044();
    r32[ebp] = pop32();
    r32[esp] += 4;
}
function* sub_1a8044() // 0160:1a8044 +long
{
    r32[esp] -= 4;
    push(ds);
    r32[edx] = memoryAGet32(ds, 0x2eebe2); ds = memoryAGet32(ds, 0x2eebe4);
    r32[eax] = 0x00002509;
    interrupt(0x21);
    ds = pop();
    r32[esp] += 4;
}
function* sub_1a8054() // 0160:1a8054 +long
{
    r32[esp] -= 4;
    flags.direction = 0;
    push(ds);
    es = pop();
    r32[edi] = 0x0030b070;
    r32[ecx] = 0x00000030;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8a9b;
    r32[eax] = 0x00002509;
    interrupt(0x21);
    ds = pop();
    memoryASet16(ds, 0x417, memoryAGet16(ds, 0x417) & 0x00f0);
    r32[esp] += 4;
}
function* sub_1a807e() // 0160:1a807e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20eead, 0x0000);
    push32(r32[ebp]);
    r32[eax] = 0x00003509;
    interrupt(0x21);
    memoryASet32(ds, 0x2eebe2, r32[ebx]);
    memoryASet16(ds, 0x2eebe6, es);
    r32[eax] = 0x00003508;
    interrupt(0x21);
    memoryASet32(ds, 0x2eebdc, r32[ebx]);
    memoryASet16(ds, 0x2eebe0, es);
    yield* sub_1a8054();
    push32(flagAsReg32());
    flags.interrupts = 0;
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a88e4;
    r32[eax] = 0x00002508;
    interrupt(0x21);
    ds = pop();
    r8[al] = 0x34;
    out8(0x43, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x1f1d3c);
    out8(0x40, r8[al]);
    r8[al] = r8[ah];
    out8(0x40, r8[al]);
    memoryASet32(ds, 0x2eebd4, 0x00000011);
    flagsFromReg32(pop32());
    r16[ax] = 0x0013;
    interrupt(0x10);
    r32[ebp] = pop32();
    push32(r32[ebp]);
    r32[edx] = 0x001ecad8;
    yield* sub_1aa484();
    r32[esi] = 0x0023f52c;
    r16[bx] = 0x0000;
  case 0x1a80fd: // 0160:1a80fd
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[al] != 0x0d)
        { pc = 0x1a80fd; break; }
    r32[esi]++;
    r16[bx]++;
    if (r16[bx] != 0x0002)
        { pc = 0x1a80fd; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x41)
        { pc = 0x1a8127; break; }
    if (r8[al] == 0x31)
        { pc = 0x1a8127; break; }
  case 0x1a8117: // 0160:1a8117
    stop("should not happen");
    memoryASet16(ds, 0x1f1ccc, 0x0001);
    yield* sub_1c7260();
    { pc = 0x1a8130; break; }
  case 0x1a8127: // 0160:1a8127
    memoryASet16(ds, 0x1f1ccc, 0x0000);
  case 0x1a8130: // 0160:1a8130
    r32[eax] = 0x00060e94;
    yield* sub_1a8010();
    if (flags.carry)
        { pc = 0x1a8147; break; }
    memoryASet32(ds, 0x20b800, r32[eax]);
    { pc = 0x1a816a; break; }
  case 0x1a8147: // 0160:1a8147
    r32[eax] = 0x00000000;
    r16[ax] = 0x0100;
    r32[ebx] = 0x000060ea;
    interrupt(0x31);
    if (flags.carry)
        { pc = 0x1a81bd; break; }
    r32[eax] &= 0x0000ffff;
    r32[eax] <<= 4;
    memoryASet32(ds, 0x20b800, r32[eax]);
  case 0x1a816a: // 0160:1a816a
    r32[eax] = 0x00010ad4;
    yield* sub_1a8010();
    if (flags.carry)
        { pc = 0x1a818b; break; }
    memoryASet32(ds, 0x20b804, r32[eax]);
    r32[eax] += 0x00006d44;
    memoryASet32(ds, 0x20b808, r32[eax]);
    { pc = 0x1a81db; break; }
  case 0x1a818b: // 0160:1a818b
    r32[eax] = 0x00000000;
    r16[ax] = 0x0100;
    r32[ebx] = 0x000010ae;
    interrupt(0x31);
    if (flags.carry)
        { pc = 0x1a81bd; break; }
    r32[eax] &= 0x0000ffff;
    r32[eax] <<= 4;
    memoryASet32(ds, 0x20b804, r32[eax]);
    r32[eax] += 0x00006d44;
    memoryASet32(ds, 0x20b808, r32[eax]);
    { pc = 0x1a81db; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1a81bd: // 0160:1a81bd
    if (!memoryAGet32(ds, 0x30b134))
        { pc = 0x1a81d9; break; }
    memoryASet32(ds, 0x30b134, 0x00000000);
    { pc = 0x1a8117; break; }
  case 0x1a81d9: // 0160:1a81d9
    r32[ebp] = pop32();
    r32[esp] += 4; return;
  case 0x1a81db: // 0160:1a81db
    r32[ebp] = pop32();
    push32(r32[ebp]);
    yield* sub_1a81f3();
    if (memoryAGet16(ds, 0x1f1ccc) != 0x0001)
        { pc = 0x1a81f1; break; }
    yield* sub_1c727c();
  case 0x1a81f1: // 0160:1a81f1
    r32[ebp] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1a81f3() // 0160:1a81f3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b10ec();
    memoryASet32(ds, 0x20c84e, 0xe7190345);
    memoryASet32(ds, 0x20c852, 0xe7190345);
    r32[eax] = 0;
    r8[ah] = 0x02;
    interrupt(0x1a);
    memoryASet(ds, 0x20c84e, r8[dh]);
    memoryASet(ds, 0x20c84f, r8[cl]);
    memoryASet(ds, 0x20c850, r8[ch]);
    yield* sub_1b10c5();
    r8[al] = 0x00;
    memoryASet(ds, 0x20eea1, r8[al]);
    memoryASet(ds, 0x20eea3, r8[al]);
    r8[al] = 0x03;
    memoryASet(ds, 0x20eea2, r8[al]);
    memoryASet(ds, 0x20eea4, r8[al]);
    r16[ax] = 0x0140;
    r16[bx] = 0x00e0;
    memoryASet16(ds, 0x20ee53, r16[ax]);
    memoryASet16(ds, 0x20ee55, r16[bx]);
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1a8289; break; }
    yield* sub_1c7b00();
    memoryASet32(ds, 0x1f1cdc, 0x00000000);
    memoryASet32(ds, 0x1f1ce0, 0x00000001);
    memoryASet32(ds, 0x1f1ce4, 0x0000007f);
    yield* sub_1aa64a();
  case 0x1a8289: // 0160:1a8289
    if (mm2_skipIntro1) {
      pc = 0x1a82b1;
      break;
    }
    yield* sub_1b2a07();
    r32[ecx] = 0x00000064;
  case 0x1a8293: // 0160:1a8293
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
  case 0x1a8298: // 0160:1a8298
    yield* sync(); // gabo intro1
    if (memoryAGet32(ds, 0x2eebd0) == r32[eax])
        { pc = 0x1a8298; break; }
    if (--r32[ecx])
        { pc = 0x1a8293; break; }
    if (memoryAGet16(ds, 0x1f1ccc) != 0x0001)
        { pc = 0x1a82b1; break; }
    yield* sub_1c8474();
  case 0x1a82b1: // 0160:1a82b1
    if (!mm2_skipIntro2)
      yield* sub_1cde9e(); // gabo - intro2
    memoryASet16(ds, 0x20d8b9, 0x00ff);
    memoryASet16(ds, 0x20d8bb, 0x00ff);
    memoryASet16(ds, 0x20d8b7, 0x0000);
    if (memoryAGet32(ds, 0x22479c) != 0x68617372)
        { pc = 0x1a82ed; break; }
    if (memoryAGet32(ds, 0x2247a0) == 0x65736574)
        { pc = 0x1a8343; break; }
  case 0x1a82ed: // 0160:1a82ed
    r32[esi] = 0x002246d2;
    r32[ecx] = 0x00000060;
  case 0x1a82f7: // 0160:1a82f7
    memoryASet(ds, r32[esi], 0xff);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1a82f7; break; }
    yield* sub_1b2f18();
    memoryASet16(ds, 0x22479a, r16[ax]);
    if (r16[ax])
        { pc = 0x1a832c; break; }
    r32[esi] = 0x002247a6;
    r32[ecx] = 0x00000010;
  case 0x1a8319: // 0160:1a8319
    memoryASet16(ds, r32[esi] + 0x8, 0x00ff);
    memoryASet16(ds, r32[esi] + 0xa, 0x00ff);
    r32[esi] += 0x0000000c;
    if (--r32[ecx])
        { pc = 0x1a8319; break; }
    { pc = 0x1a8343; break; }
  case 0x1a832c: // 0160:1a832c
    yield* sub_1b2df9();
    r32[esi] = 0x002246d2;
    r32[ecx] = 0x00000060;
  case 0x1a833b: // 0160:1a833b
    memoryASet(ds, r32[esi], 0xff);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1a833b; break; }
  case 0x1a8343: // 0160:1a8343
    yield* sub_1bafa9();
    yield* sub_1b7477();
    if (memoryAGet16(ds, 0x20eead) == 0x0001)
        { pc = 0x1b6be8; break; }
    { pc = 0x1a8360; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1a8360: // 0160:1a8360
    if (memoryAGet16(ds, 0x20eead) == 0x0001)
        { pc = 0x1b6be8; break; }
    yield* sub_1a841e();
    r8[al] = memoryAGet(ds, 0x224ba8);
    if (r8[al] == 0x01)
        { pc = 0x1a8380; break; }
    if (r8[al])
        { pc = 0x1a83d6; break; }
  case 0x1a8380: // 0160:1a8380
    r16[ax] = memoryAGet16(ds, 0x224ba4);
    r16[bx] = memoryAGet16(ds, 0x224ba6);
    if (r16[ax] != 0x0140)
        { pc = 0x1a839c; break; }
    if (r16[bx] != 0x00e0)
        { pc = 0x1a83d6; break; }
    { pc = 0x1a83db; break; }
  case 0x1a839c: // 0160:1a839c
    if (r16[ax] != 0x0120)
        { pc = 0x1a83ab; break; }
    if (r16[bx] != 0x00c8)
        { pc = 0x1a83d6; break; }
    { pc = 0x1a83db; break; }
  case 0x1a83ab: // 0160:1a83ab
    if (r16[ax] != 0x0100)
        { pc = 0x1a83ba; break; }
    if (r16[bx] != 0x00b4)
        { pc = 0x1a83d6; break; }
    { pc = 0x1a83db; break; }
  case 0x1a83ba: // 0160:1a83ba
    if (r16[ax] != 0x00f0)
        { pc = 0x1a83c9; break; }
    if (r16[bx] != 0x00a8)
        { pc = 0x1a83d6; break; }
    { pc = 0x1a83db; break; }
  case 0x1a83c9: // 0160:1a83c9
    if (r16[ax] != 0x00e0)
        { pc = 0x1a83d6; break; }
    if (r16[bx] == 0x009c)
        { pc = 0x1a83db; break; }
  case 0x1a83d6: // 0160:1a83d6
    yield* sub_1b63d3();
  case 0x1a83db: // 0160:1a83db
    r16[ax] = memoryAGet16(ds, 0x224ba4);
    memoryASet16(ds, 0x20ee53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x224ba6);
    memoryASet16(ds, 0x20ee55, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x224baa);
    memoryASet16(ds, 0x20ee77, r16[ax]);
    r8[al] = memoryAGet(ds, 0x224ba8);
    memoryASet(ds, 0x1f1cbf, r8[al]);
    { pc = 0x1aa659; break; }
    // gap 8779 bytes // gap 8779 bytes
  case 0x1aa659: // 0160:1aa659
    memoryASet16(ds, 0x20eda7, 0x0001);
    yield* sub_1acfa2();
    if (mm2_skipMenuItem == -1)
      yield* sub_1b3b47(); // gabo-game
    else
      memoryASet16(ds, 0x20e82f, mm2_skipMenuItem);
    if (memoryAGet16(ds, 0x20eead) == 0x0001)
        { pc = 0x1b6be8; break; }
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
  case 0x1aa684: // 0160:1aa684
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    memoryASet16(ds, 0x20e90d, 0x0002);
    if (signed16(memoryAGet16(ds, 0x22464a)) < signed16(0x0001))
        { pc = 0x1aaa24; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1aa76c; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1aa6ed; break; }
    memoryASet16(ds, 0x22464e, 0x0000);
    yield* sub_1b191a();
    r8[al] = 0x82;
    yield* sub_1b18a6();
    yield* sub_1c0f92();
    { pc = 0x1aa741; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1aa6ed: // 0160:1aa6ed
    memoryASet16(ds, 0x22464e, 0x0001);
    memoryASet16(ds, 0x20ed4d, 0x0006);
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    yield* sub_1c1c1d();
    yield* sub_1b191a();
    r8[al] = 0x82;
    yield* sub_1b18a6();
    yield* sub_1c103c();
  case 0x1aa741: // 0160:1aa741
    yield* sub_1c13c0();
    yield* sub_1acfa2();
    memoryASet16(ds, 0x22464a, 0x0001);
    yield* sub_1b3b3d();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    { pc = 0x1aa684; break; }
  case 0x1aa76c: // 0160:1aa76c
    if (memoryAGet16(ds, 0x22464a) != 0x0002)
        { pc = 0x1aa8c9; break; }
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1aa81d; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (r16[ax] != 0x0003)
        { pc = 0x1aa7a0; break; }
    memoryASet16(ds, 0x20d7d5, 0x0001);
    r16[ax]--;
  case 0x1aa7a0: // 0160:1aa7a0
    r16[ax] += 0x0002;
    memoryASet16(ds, 0x20d7f5, r16[ax]);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    yield* sub_1b66fb();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20ed4d, 0x0006);
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
  case 0x1aa7e8: // 0160:1aa7e8
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    memoryASet16(ds, 0x20d8ab, 0x0004);
    memoryASet16(ds, 0x20d8ad, 0x0000);
  case 0x1aa81d: // 0160:1aa81d
    memoryASet16(ds, 0x22466a, 0x0001);
    yield* sub_1c1c26();
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1aa84d; break; }
    memoryASet16(ds, 0x22464a, 0x0001);
    yield* sub_1b3b3d();
    { pc = 0x1aa684; break; }
  case 0x1aa84d: // 0160:1aa84d
    yield* sub_1ba9f5();
    yield* sub_1c58cb();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20d7a5, 0x02bd);
    yield* sub_1d04a1();
    yield* sub_1aafe3();
    memoryASet16(ds, 0x20eda9, 0x0000);
    yield* sub_1b88fc();
    memoryASet16(ds, 0x20ecbd, 0x0000);
    yield* sub_1ba2f6();
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1aa7e8; break; }
    { pc = 0x1aa659; break; }
  case 0x1aa8a8: // 0160:1aa8a8
    memoryASet16(ds, 0x22466a, 0x0001);
    yield* sub_1c1c26();
    memoryASet16(ds, 0x22464a, 0x0001);
    yield* sub_1b3b3d();
    { pc = 0x1aa684; break; }
  case 0x1aa8c9: // 0160:1aa8c9
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1aa8a8; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax]++;
    memoryASet16(ds, 0x20d7f5, r16[ax]);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    yield* sub_1b66fb();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20eda1, 0xffff);
    memoryASet16(ds, 0x20ed4d, 0x0004);
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1aa960; break; }
    memoryASet16(ds, 0x20ed41, 0x0001);
    yield* sub_1b9020();
    memoryASet16(ds, 0x20ed41, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8c1);
    memoryASet16(ds, 0x20e8e1, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8c3);
    memoryASet16(ds, 0x20e8e7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8c5);
    memoryASet16(ds, 0x20e8ed, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8c7);
    memoryASet16(ds, 0x20e8f3, r16[ax]);
    { pc = 0x1aa96e; break; }
  case 0x1aa960: // 0160:1aa960
    memoryASet16(ds, 0x20ecb5, 0x0003);
    yield* sub_1b9017();
  case 0x1aa96e: // 0160:1aa96e
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    memoryASet16(ds, 0x2247a4, 0x0016);
    memoryASet16(ds, 0x20d7d5, 0x0000);
    memoryASet16(ds, 0x20ec87, 0x0000);
    memoryASet16(ds, 0x20ec89, 0x0001);
    yield* sub_1aa9d7();
    yield* sub_1bb4ed();
    yield* sub_1b191a();
    { pc = 0x1aa659; break; }
    // gap 77 bytes // gap 77 bytes
  case 0x1aaa24: // 0160:1aaa24
    r16[ax] = memoryAGet16(ds, 0x20e82f); // menu item
    if (r16s[ax] <= signed16(0x0003))
        { pc = 0x1aaa64; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1ab3f2; break; }
    if (r16[ax] != 0x0006)
        { pc = 0x1aaa57; break; }
    memoryASet16(ds, 0x20e90d, 0x0001);
    yield* sub_1b8f8f();
    { pc = 0x1aa659; break; }
  case 0x1aaa57: // 0160:1aaa57
    memoryASet16(ds, 0x20d7d5, 0x0001);
    r16[ax] = 0x0003;
  case 0x1aaa64: // 0160:1aaa64
    r16[ax]++;
    memoryASet16(ds, 0x20d7f5, r16[ax]);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    if (r16[ax] == 0x0001)
        { pc = 0x1ab4cc; break; }
    yield* sub_1b66fb();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20ed4d, 0x0004);
    yield* sub_1b3199();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    r16[ax] = memoryAGet16(ds, 0x20edf9);
    if (r16[ax] == 0x00ff)
        { pc = 0x1aaac7; break; }
    if (!r16[ax])
        { pc = 0x1aaaf3; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1aaae7; break; }
    { pc = 0x1aaadb; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1aaac7: // 0160:1aaac7
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (!r16[ax])
        { pc = 0x1aaf24; break; }
    { pc = 0x1aae6a; break; }
  case 0x1aaadb: // 0160:1aaadb
    r32[eax] = 0x001ec0e4;
    memoryASet32(ds, 0x20ecd1, r32[eax]);
    { pc = 0x1aaafd; break; }
  case 0x1aaae7: // 0160:1aaae7
    r32[eax] = 0x001ec0de;
    memoryASet32(ds, 0x20ecd1, r32[eax]);
    { pc = 0x1aaafd; break; }
  case 0x1aaaf3: // 0160:1aaaf3
    r32[eax] = 0x001ec0d8;
    memoryASet32(ds, 0x20ecd1, r32[eax]);
  case 0x1aaafd: // 0160:1aaafd
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20d8ab, 0x0004);
    memoryASet16(ds, 0x20d8ad, 0x0000);
  case 0x1aab2b: // 0160:1aab2b
    memoryASet16(ds, 0x20e8e3, 0x0000);
    memoryASet16(ds, 0x20e8e9, 0x0000);
    memoryASet16(ds, 0x20e8ef, 0x0000);
    memoryASet16(ds, 0x20e8f5, 0x0000);
    memoryASet(ds, 0x20e9b9, 0x01);
  case 0x1aab56: // 0160:1aab56
    memoryASet16(ds, 0x20ec8f, 0x0000);
  case 0x1aab5f: // 0160:1aab5f
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    r32[esi] = memoryAGet32(ds, 0x20ecd1);
    memoryASet16(ds, 0x20ec9d, 0x0000);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[bl] != 0x80)
        { pc = 0x1aabd0; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20ec8f);
    r16[bx] <<= 2;
    r16[ax] += r16[bx];
    if (r16s[ax] < signed16(0x001b))
        { pc = 0x1aabc3; break; }
    r16[ax] = 0;
  case 0x1aabc3: // 0160:1aabc3
    r32[esi] = 0x001ec0bc;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
  case 0x1aabd0: // 0160:1aabd0
    if (r8[bl] == 0xff)
        { pc = 0x1aab56; break; }
    memoryASet16(ds, 0x20d7b9, r16[bx]);
    yield* sub_1b8241();
    yield* sub_1ba9f5();
    yield* sub_1abc11();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20d7a5, 0x02bd);
    yield* sub_1d04a1();
    yield* sub_1b191a();
    r8[al] = 0x8a;
    yield* sub_1b18a6();
    yield* sub_1aafe3();
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1aac53; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b7);
    if (r16[ax] == 0x0001)
        { pc = 0x1aac41; break; }
    memoryASet16(ds, 0x20e8e9, memoryAGet16(ds, 0x20e8e9) + 0x0001);
    memoryASet16(ds, 0x20e8f5, memoryAGet16(ds, 0x20e8f5) + 0x0001);
    { pc = 0x1aac77; break; }
  case 0x1aac41: // 0160:1aac41
    memoryASet16(ds, 0x20e8e3, memoryAGet16(ds, 0x20e8e3) + 0x0001);
    memoryASet16(ds, 0x20e8ef, memoryAGet16(ds, 0x20e8ef) + 0x0001);
    { pc = 0x1aac77; break; }
  case 0x1aac53: // 0160:1aac53
    r16[ax] = memoryAGet16(ds, 0x20d7b7);
    r16[ax]--;
    r16[ax] += r16[ax];
    r16[bx] = r16[ax];
    r16[ax] += r16[ax];
    r16[ax] += r16[bx];
    r32[esi] = 0x0020e8e1;
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, r32[esi] + r32[eax] + 0x2, memoryAGet16(ds, r32[esi] + r32[eax] + 0x2) + 0x0001);
  case 0x1aac77: // 0160:1aac77
    memoryASet16(ds, 0x20ecbd, 0x0001);
    yield* sub_1ba2f6();
    if (memoryAGet16(ds, 0x20e8e3) == 0x0003)
        { pc = 0x1aacc1; break; }
    if (memoryAGet16(ds, 0x20e8e9) == 0x0003)
        { pc = 0x1aacc1; break; }
    if (memoryAGet16(ds, 0x20e8ef) == 0x0003)
        { pc = 0x1aacc1; break; }
    if (memoryAGet16(ds, 0x20e8f5) == 0x0003)
        { pc = 0x1aacc1; break; }
    memoryASet(ds, 0x20e9b9, memoryAGet(ds, 0x20e9b9) + 0x01);
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + 0x0001);
    { pc = 0x1aab5f; break; }
  case 0x1aacc1: // 0160:1aacc1
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1aad40; break; }
    if (memoryAGet16(ds, 0x20d7b7) == 0x0001)
        { pc = 0x1aad0b; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    { pc = 0x1aae0a; break; }
  case 0x1aad0b: // 0160:1aad0b
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    { pc = 0x1aae0a; break; }
  case 0x1aad40: // 0160:1aad40
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20e8e3);
    r16[cx] = memoryAGet16(ds, 0x20e8e9);
    r16[dx] = memoryAGet16(ds, 0x20e8ef);
    r16[bp] = memoryAGet16(ds, 0x20e8f5);
  case 0x1aad8c: // 0160:1aad8c
    if (r16s[cx] > r16s[bx])
        { pc = 0x1aade5; break; }
    if (r16s[dx] > r16s[cx])
        { pc = 0x1aadc0; break; }
    if (r16s[bp] <= r16s[dx])
        { pc = 0x1aae0a; break; }
    r16[ax] = r16[dx];
    r16[dx] = r16[bp];
    r16[bp] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb9);
    r16[di] = memoryAGet16(ds, 0x20cebb);
    memoryASet16(ds, 0x20ceb9, r16[di]);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    { pc = 0x1aad8c; break; }
  case 0x1aadc0: // 0160:1aadc0
    r16[ax] = r16[cx];
    r16[cx] = r16[dx];
    r16[dx] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[di] = memoryAGet16(ds, 0x20ceb9);
    memoryASet16(ds, 0x20ceb7, r16[di]);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    { pc = 0x1aad8c; break; }
  case 0x1aade5: // 0160:1aade5
    r16[ax] = r16[bx];
    r16[bx] = r16[cx];
    r16[cx] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb5);
    r16[di] = memoryAGet16(ds, 0x20ceb7);
    memoryASet16(ds, 0x20ceb5, r16[di]);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    { pc = 0x1aad8c; break; }
  case 0x1aae0a: // 0160:1aae0a
    r16[ax] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20e843, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    memoryASet16(ds, 0x20e845, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb9);
    memoryASet16(ds, 0x20e847, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cebb);
    memoryASet16(ds, 0x20e849, r16[ax]);
    memoryASet16(ds, 0x20eda9, 0x0001);
    yield* sub_1b88fc();
    memoryASet16(ds, 0x20ecbd, 0x0000);
    yield* sub_1ba2f6();
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1aab2b; break; }
    { pc = 0x1aa659; break; }
  case 0x1aae6a: // 0160:1aae6a
    memoryASet16(ds, 0x20ed41, 0x0001);
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b9020();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20d8ab, 0x0002);
    memoryASet16(ds, 0x20d8ad, 0x0000);
    memoryASet16(ds, 0x20d8a9, 0x0000);
    memoryASet16(ds, 0x20ed41, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8c1);
    memoryASet16(ds, 0x20e8e1, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8c3);
    memoryASet16(ds, 0x20e8e7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8c5);
    memoryASet16(ds, 0x20e8ed, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8c7);
    memoryASet16(ds, 0x20e8f3, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d7d5);
    push32(r32[eax]);
    memoryASet16(ds, 0x2247a4, 0x0016);
    memoryASet16(ds, 0x20d7d5, 0x0000);
    memoryASet16(ds, 0x20ec87, 0x0000);
    memoryASet16(ds, 0x20ec89, 0x0001);
    yield* sub_1bb4ed();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20d7d5, r16[ax]);
    yield* sub_1b191a();
    { pc = 0x1aa659; break; }
  case 0x1aaf24: // 0160:1aaf24
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
  case 0x1aaf40: // 0160:1aaf40
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    memoryASet16(ds, 0x20d8ab, 0x0004);
    memoryASet16(ds, 0x20d8ad, 0x0000);
    yield* sub_1abb6f();
    if (memoryAGet16(ds, 0x20ee81) == 0x0001)
        { pc = 0x1aa659; break; }
    yield* sub_1ba9f5();
    yield* sub_1abc11();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20d7a5, 0x02bd);
    yield* sub_1d04a1();
    yield* sub_1aafe3();
    memoryASet16(ds, 0x20eda9, 0x0000);
    yield* sub_1b88fc();
    memoryASet16(ds, 0x20ecbd, 0x0000);
    yield* sub_1ba2f6();
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1aaf40; break; }
    { pc = 0x1aa659; break; }
    // gap 1039 bytes // gap 1039 bytes
  case 0x1ab3f2: // 0160:1ab3f2
    r32[esi] = 0x00224866;
    r32[edi] = 0x00224732;
    r32[ecx] = 0x00000018;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    if (memoryAGet(ds, 0x2246d2) == 0xff)
        { pc = 0x1ab41d; break; }
    r32[esi] = 0x002246d2;
    r32[edi] = 0x00224866;
    r32[ecx] = 0x00000018;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
  case 0x1ab41d: // 0160:1ab41d
    memoryASet16(ds, 0x20ed4d, 0x0005);
    yield* sub_1b781c();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0x20ecd7, r16[ax]);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    memoryASet16(ds, 0x20d7f5, r16[ax]);
    memoryASet16(ds, 0x20ed41, 0x0001);
    memoryASet16(ds, 0x20eda1, 0xffff);
    memoryASet16(ds, 0x20ee45, 0x0001);
    yield* sub_1b9020();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20ee45, 0x0000);
    r32[esi] = 0x0020ece3;
    r32[ecx] = 0x0000002f;
  case 0x1ab496: // 0160:1ab496
    memoryASet16(ds, r32[esi], 0x00ff);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1ab496; break; }
    yield* sub_1b7afd();
    r32[esi] = 0x00224866;
    r32[edi] = 0x002246d2;
    r32[ecx] = 0x00000018;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] = 0x00224732;
    r32[edi] = 0x00224866;
    r32[ecx] = 0x00000018;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    { pc = 0x1aa659; break; }
  case 0x1ab4cc: // 0160:1ab4cc
    if (!mm2_skipMenuChangeControls)
      yield* sub_1b66fb();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    if (!mm2_skipMenuGameMode)
      yield* sub_1b3602();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x20ecb5, r16[ax]);
    if (!r16[ax])
        { pc = 0x1ab5b6; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1ab896; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1ab588; break; }
    memoryASet16(ds, 0x2247a4, 0x0016);
    memoryASet16(ds, 0x20ed4d, 0x0004);
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    memoryASet16(ds, 0x20ec87, 0x0000);
    memoryASet16(ds, 0x20ec89, 0x0001);
    yield* sub_1bb4ed();
    { pc = 0x1aa659; break; }
  case 0x1ab588: // 0160:1ab588
    memoryASet16(ds, 0x20eda1, 0xffff);
    memoryASet16(ds, 0x20ed4d, 0x0002);
    memoryASet16(ds, 0x20edfb, 0x0001);
    yield* sub_1bc63b();
    memoryASet16(ds, 0x20edfb, 0x0000);
    { pc = 0x1aa659; break; }
  case 0x1ab5b6: // 0160:1ab5b6
    memoryASet16(ds, 0x20edcb, 0x0000);
    memoryASet16(ds, 0x20edcd, 0x0000);
    memoryASet16(ds, 0x20d863, 0x0000);
    memoryASet16(ds, 0x20eda1, 0xffff);
    if (!mm2_skipMenuChangePlayer)
      yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
  case 0x1ab609: // 0160:1ab609
    if (memoryAGet16(ds, 0x20edcd) != 0x0003)
        { pc = 0x1ab67c; break; }
    memoryASet16(ds, 0x20edcd, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20edcb);
    r16[ax] += 0x0037;
    memoryASet16(ds, 0x20d7b9, r16[ax]);
    memoryASet16(ds, 0x20ed4d, 0x0004);
    yield* sub_1b191a();
    r8[al] = 0x80;
    yield* sub_1b18a6();
    yield* sub_1b8241();
    r16[ax] = memoryAGet16(ds, 0x20e90b);
    push32(r32[eax]);
    yield* sub_1ac839();
    r32[eax] = pop32();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20e90b))
        { pc = 0x1ab67c; break; }
    if (memoryAGet16(ds, 0x20edcb) == 0x0004)
        { pc = 0x1ab67c; break; }
    memoryASet16(ds, 0x20edcb, memoryAGet16(ds, 0x20edcb) + 0x0001);
  case 0x1ab67c: // 0160:1ab67c
    memoryASet16(ds, 0x20ed4d, 0x0000);
    r32[esi] = 0x00203e42;
    r16[bx] = memoryAGet16(ds, 0x2247a4);
    r16[ax] = memoryAGet16(ds, 0x20d863);
    if (r16s[bx] >= r16s[ax])
        { pc = 0x1ab6a2; break; }
    memoryASet16(ds, 0x2247a4, r16[ax]);
  case 0x1ab6a2: // 0160:1ab6a2
    r16[cx] = 0x000e;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    if (mm2_jumpToLevel != -1)
      r16[dx] = mm2_jumpToLevel;


//pc = 0x1ab754; break; // jump to "you failed to qualify!"

if  (0)
{
    // gabo: ax = level
//r16[ax] = 19; 
// 2 = sand castles 3 = pinball pursuit 4 = ? challenge
// 5 = ? circuits
// 6 = mini cars, 7= atv action, 8 = lights out , 9 = ball chaser? (billiard), 10 = (trucks, peas)
// 11 = roller coaster, 12 = bury my body, 13 = piano panic, 14 = bathtub burnoff, 15 = beach? oval
// 16 = treehouse tiles, 17 = vice squad? 18 = musical kits, 19 = toaster trouble?, 20 =ball chase
// 21 = crossing chaos? 22 = ups and downs, 23 = bricks and trees 24=(trucks)? 25=atv action, 26=crash

// 0x20e995?
// gabo skip level:
  let o = 0x002084b8;
  let names = [];
  for (let p=0; p<60; p++)
  {
    let len = memoryAGet(0, o++);
    let n = ""
    for (let q=0; q<len; q++)
      n += String.fromCharCode(memoryAGet(0, o+q));
    o += len;

    let fn = "";
    let fptr = memoryAGet32(ds, 0x00208058+p*4);
    for (let q=0; q<32 && memoryAGet(0, fptr+q); q++)
      fn += String.fromCharCode(memoryAGet(0, fptr+q));

    let fn2 = "";
    fptr = memoryAGet32(ds, 0x00207c0a+p*4);
    for (let q=0; q<32 && memoryAGet(0, fptr+q); q++)
      fn2 += String.fromCharCode(memoryAGet(0, fptr+q));

    names.push([n, fn, fn2]);
  }
  console.log(names);
  for (let p=0; p<26; p++)
  {
    console.log("index", p, memoryAGet16(ds, r32[esi] + p * 0x0e), names[memoryAGet16(ds, r32[esi] + p * 0x0e)],
     memoryAGet16(ds, r32[esi] + p * 0x0e + 2),
     memoryAGet16(ds, r32[esi] + p * 0x0e + 8),
     memoryAGet32(ds, r32[esi] + p * 0x0e + 0xa).toString(16),
 )
/*
0-1  level name index
2-3 ?
4
5
6
7
8 9 - ?
a b c d - ?
e

*/
/*
    let basedx = 0x0020196c*0+0x002084b8 + memoryAGet16(ds, r32[esi] + p*0x0e);
    let name = "";
    for (var q=0; q<32 && memoryAGet(0, basedx+q); q++)
      name += String.fromCharCode(memoryAGet(0, basedx+q));
    console.log(p, name);
*/
  }
}
    memoryASet16(ds, 0x20d7b9, r16[dx]); // level name offset
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[eax] + 0xa);
    memoryASet32(ds, 0x20d859, r32[edx]);
    memoryASet16(ds, 0x20d865, 0x0003);
    memoryASet16(ds, 0x20e8bb, 0x0003);
    r32[edi] = 0x0020e8c1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x8);
    r16[dx] = 0x0003;
  case 0x1ab6e3: // 0160:1ab6e3
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    if (r16[bx] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1ab6f4; break; }
    r16[bx] = r16[cx];
  case 0x1ab6f4: // 0160:1ab6f4
    memoryASet16(ds, r32[edi], r16[bx]);
    r32[edi] += 0x00000002;
    r32[eax] += 0x00000002;
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1ab6e3; break; }
    yield* sub_1b191a();
    r8[al] = 0x80;
    yield* sub_1b18a6();
    if (!mm2_skipLevelBanner)
      yield* sub_1b8241();
    yield* sub_1ba9f5();
    memoryASet16(ds, 0x20edef, 0x0001);
    yield* sub_1abc11();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20edef, 0x0000);
    if (!(memoryAGet16(ds, 0x20d87f) & 0xffff))
        { pc = 0x1ab754; break; }
    memoryASet16(ds, 0x20edcd, memoryAGet16(ds, 0x20edcd) + 0x0001);
    { pc = 0x1ab821; break; }
  case 0x1ab754: // 0160:1ab754
    r32[esi] = 0x0020e843;
    r32[edi] = 0x0020e8c1;
    r16[ax] = memoryAGet16(ds, 0x20d1f7);
    r16[ax]--;
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[dx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[dx]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d1f9);
    r16[ax]--;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[dx]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d1fb);
    r16[ax]--;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[dx]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d1fd);
    r16[ax]--;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[dx]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e9a7, 0x0001);
    yield* sub_1b88fc();  // gabo: you have qualified screen
    if (memoryAGet16(ds, 0x20d1f7) != 0x0001)
        { pc = 0x1ab7d9; break; }
    memoryASet16(ds, 0x20edcd, memoryAGet16(ds, 0x20edcd) + 0x0001);
    { pc = 0x1ab821; break; }
  case 0x1ab7d9: // 0160:1ab7d9
    memoryASet16(ds, 0x20edcd, 0x0000);
    r16[dx] = memoryAGet16(ds, 0x20d863);
    r16[dx]++;
    if (r16[dx] == 0x0019)
        { pc = 0x1ab7fb; break; }
    if (memoryAGet16(ds, 0x20d1f9) == 0x0001)
        { pc = 0x1ab821; break; }
  case 0x1ab7fb: // 0160:1ab7fb
    yield* sub_1b2f96();
    memoryASet16(ds, 0x20e90b, memoryAGet16(ds, 0x20e90b) - 0x0001);
    if (!(memoryAGet16(ds, 0x20e90b) & 32768))
        { pc = 0x1ab67c; break; }
    yield* sub_1ba001();
    { pc = 0x1aa659; break; }
  case 0x1ab821: // 0160:1ab821
    memoryASet16(ds, 0x20d863, memoryAGet16(ds, 0x20d863) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20d863);
    r32[esi] = 0x002247a6;
    r16[bx] = memoryAGet16(ds, 0x20e8e1);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[bp] = r16[bx];
    r16[bx] <<= 1;
    r16[bx] += r16[bp];
    r32[ebx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    if (r16[cx] == 0x00ff)
        { pc = 0x1ab860; break; }
    if (r16s[ax] <= r16s[cx])
        { pc = 0x1ab869; break; }
  case 0x1ab860: // 0160:1ab860
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    yield* sub_1b2d91();
  case 0x1ab869: // 0160:1ab869
    if (memoryAGet16(ds, 0x20d863) != 0x0019)
        { pc = 0x1ab609; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e9c1, r16[ax]);
    memoryASet16(ds, 0x20e9c3, 0x0002);
    yield* sub_1b9ca1();
    { pc = 0x1aa659; break; }
  case 0x1ab896: // 0160:1ab896
    memoryASet16(ds, 0x20edcb, 0x0000);
    memoryASet16(ds, 0x20edcd, 0x0000);
    memoryASet16(ds, 0x20eda1, 0xffff);
    yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
  case 0x1ab8e0: // 0160:1ab8e0
    if (memoryAGet16(ds, 0x20edcd) != 0x0003)
        { pc = 0x1ab945; break; }
    memoryASet16(ds, 0x20edcd, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20edcb);
    r16[ax] += 0x0037;
    memoryASet16(ds, 0x20d7b9, r16[ax]);
    memoryASet16(ds, 0x20ed4d, 0x0004);
    yield* sub_1b191a();
    r8[al] = 0x80;
    yield* sub_1b18a6();
    yield* sub_1b8241();
    r16[ax] = memoryAGet16(ds, 0x20e90b);
    push32(r32[eax]);
    yield* sub_1ac839();
    r32[eax] = pop32();
    if (r16[ax] == memoryAGet16(ds, 0x20e90b))
        { pc = 0x1ab945; break; }
    if (memoryAGet16(ds, 0x20edcb) == 0x0004)
        { pc = 0x1ab945; break; }
    memoryASet16(ds, 0x20edcb, memoryAGet16(ds, 0x20edcb) + 0x0001);
  case 0x1ab945: // 0160:1ab945
    memoryASet16(ds, 0x20ed4d, 0x0001);
    r32[esi] = 0x00203e42;
    r16[bx] = memoryAGet16(ds, 0x2247a4);
    r16[ax] = memoryAGet16(ds, 0x20d863);
    if (r16s[bx] >= r16s[ax])
        { pc = 0x1ab96b; break; }
    memoryASet16(ds, 0x2247a4, r16[ax]);
  case 0x1ab96b: // 0160:1ab96b
    r32[ebx] = 0;
    r32[eax] &= 0x0000ffff;
    r16[bx] = r16[ax];
    r16[dx] = 0x000e;
    mul16(r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d7b9, r16[dx]);
    r16[bx] <<= 1;
    r16[dx] = r16[bx];
    r16[bx] <<= 3;
    r16[bx] += r16[dx];
    r32[ecx] = 0x00203fa0;
    r32[ebx] += r32[ecx];
    memoryASet32(ds, 0x20d859, r32[ebx]);
    memoryASet16(ds, 0x20d865, 0x0003);
    memoryASet16(ds, 0x20e8bb, 0x0003);
    r32[edi] = 0x0020e8c1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x8);
    r16[dx] = 0x0003;
  case 0x1ab9c1: // 0160:1ab9c1
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    if (r16[bx] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1ab9d2; break; }
    r16[bx] = r16[cx];
  case 0x1ab9d2: // 0160:1ab9d2
    memoryASet16(ds, r32[edi], r16[bx]);
    r32[edi] += 0x00000002;
    r32[eax] += 0x00000002;
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1ab9c1; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8c1);
    memoryASet16(ds, 0x20e8e7, r16[ax]);
    yield* sub_1b191a();
    r8[al] = 0x80;
    yield* sub_1b18a6();
    yield* sub_1b8241();
    memoryASet16(ds, 0x20d7f5, 0x0002);
    memoryASet16(ds, 0x20e90d, 0x0002);
    memoryASet16(ds, 0x20d89f, 0x0001);
    yield* sub_1ba9f5();
    yield* sub_1abc11();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1aa659; break; }
    memoryASet16(ds, 0x20d7f5, 0x0001);
    memoryASet16(ds, 0x20e90d, 0x0001);
    r32[esi] = 0x0020e843;
    r32[edi] = 0x0020e8c1;
    r16[ax] = memoryAGet16(ds, 0x20d7b7);
    if (r16[ax] == 0x0001)
        { pc = 0x1aba89; break; }
    r16[dx] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, r32[esi], r16[dx]);
    r16[dx] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, r32[esi] + 0x2, r16[dx]);
    memoryASet16(ds, 0x20d1f7, 0x0000);
    memoryASet16(ds, 0x20d1f9, 0x0000);
    memoryASet16(ds, 0x20edcd, 0x0000);
    { pc = 0x1abaaf; break; }
  case 0x1aba89: // 0160:1aba89
    r16[dx] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, r32[esi], r16[dx]);
    r16[dx] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, r32[esi] + 0x2, r16[dx]);
    memoryASet16(ds, 0x20d1f7, 0x0001);
    memoryASet16(ds, 0x20edcd, memoryAGet16(ds, 0x20edcd) + 0x0001);
  case 0x1abaaf: // 0160:1abaaf
    memoryASet16(ds, 0x20e9a7, 0x0002);
    yield* sub_1b88fc();
    memoryASet16(ds, 0x20d89f, 0x0000);
    if (memoryAGet16(ds, 0x20d7b7) == 0x0001)
        { pc = 0x1abaf6; break; }
    yield* sub_1b2f96();
    memoryASet16(ds, 0x20e90b, memoryAGet16(ds, 0x20e90b) - 0x0001);
    if (!(memoryAGet16(ds, 0x20e90b) & 32768))
        { pc = 0x1ab945; break; }
    yield* sub_1ba001();
    { pc = 0x1aa659; break; }
  case 0x1abaf6: // 0160:1abaf6
    memoryASet16(ds, 0x20d863, memoryAGet16(ds, 0x20d863) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20d863);
    r32[esi] = 0x002247a6;
    r16[bx] = memoryAGet16(ds, 0x20e8e1);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[dx] = r16[bx];
    r16[bx] <<= 1;
    r16[bx] += r16[dx];
    r16[bx] += 0x0002;
    r32[ebx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    if (r16[cx] == 0x00ff)
        { pc = 0x1abb39; break; }
    if (r16s[ax] <= r16s[cx])
        { pc = 0x1abb42; break; }
  case 0x1abb39: // 0160:1abb39
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    yield* sub_1b2d91();
  case 0x1abb42: // 0160:1abb42
    if (memoryAGet16(ds, 0x20d863) != 0x0019)
        { pc = 0x1ab8e0; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e9c1, r16[ax]);
    memoryASet16(ds, 0x20e9c3, 0x0001);
    yield* sub_1b9ca1();
    { pc = 0x1aa659; break; }
    // gap 45177 bytes // gap 45177 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
console.log("ggggggggg======3");
    return;
  }
}
function* sub_1a840e() // 0160:1a840e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
  case 0x1a8414: // 0160:1a8414
    yield* sync();
    if (memoryAGet32(ds, 0x2eebd0) == r32[eax])
        { pc = 0x1a8414; break; }
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1a841e() // 0160:1a841e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c1cf3();
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1a8498; break; }
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00002ed4;
    memoryASet16(ds, 0x20ec8f, 0x0000);
    r32[ebx] = 0;
  case 0x1a8449: // 0160:1a8449
    push32(r32[edi]);
    push32(r32[ebx]);
    memoryASet32(ds, 0x224670, 0x00000010);
    r32[eax] = 0x0023c4e0;
    memoryASet32(ds, 0x224674, r32[eax]);
    yield* sub_1c1d74();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    if (!r16[ax])
        { pc = 0x1a846f; break; }
    r16[bx]++;
    { pc = 0x1a847b; break; }
  case 0x1a846f: // 0160:1a846f
    r32[esi] = 0x0023c4e0;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
  case 0x1a847b: // 0160:1a847b
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x22464c))
        { pc = 0x1a8449; break; }
    memoryASet16(ds, 0x22464c, memoryAGet16(ds, 0x22464c) - r16[bx]);
  case 0x1a8498: // 0160:1a8498
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1a8499() // 0160:1a8499 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    r32[ebx] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    memoryASet32(ds, 0x1f1c48, r32[eax]);
    memoryASet32(ds, 0x1f1c4c, r32[ebx]);
    if (memoryAGet16(ds, 0x20ee5d) == 0x0001)
        { pc = 0x1a852d; break; }
    yield* sub_1a86b0();
    yield* sub_1a862c();
    yield* sub_1a861d();
    yield* sub_1a8596();
    r32[edi] = 0x002eebec;
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000014;
    r32[ecx] = 0x00000080;
    r32[ebp] = r32[ecx];
    if (memoryAGet(ds, 0x1f1c44) & 0xff)
        { pc = 0x1a84f1; break; }
  case 0x1a84f1: // 0160:1a84f1
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[edx] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[eax] += r32[eax];
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
    r32[eax] += r32[ebx];
    r32[ebx] <<= 3;
    r32[eax] += r32[ebx];
    r8[dl] = memoryAGet(ds, r32[esi] + 0x2);
    r32[eax] += r32[edx];
    r32[edx] <<= 2;
    r32[eax] += r32[edx];
    r16[bx] = 0x0155;
    r32[edx] = 0;
    div16(r16[bx]);
    r8[al] += 0x90;
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000003;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1a84f1; break; }
    r32[ecx] = r32[ebp];
  case 0x1a8524: // 0160:1a8524
    r8[al] = 0;
    r8[al] -= r8[cl];
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1a8524; break; }
  case 0x1a852d: // 0160:1a852d
    yield* sub_1a8b3c();
    r16[dx] = 0x03d4;
    r8[al] = 0x13;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x2a;
    out8(r16[dx], r8[al]);
    if (memoryAGet16(ds, 0x20ee5b) == 0x0001)
        { pc = 0x1a857a; break; }
    r32[eax] = memoryAGet32(ds, 0x2eeb8c);
    r32[eax] += 0x00000014;
    yield* sub_1aa5d6();
    if (memoryAGet16(ds, 0x20d7b9) != 0x000e)
        { pc = 0x1a857a; break; }
    r32[edx] = 0x001ecae4;
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0x00;
    yield* sub_1b5442();
  case 0x1a857a: // 0160:1a857a
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r32[edi] = 0x000a0000;
    r32[ecx] = 0x00004000;
    r32[eax] = 0;
    push(ds);
    es = pop();
    flags.direction = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1a84d3() // 0160:1a84d3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x002eebec;
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000014;
    r32[ecx] = 0x00000080;
    r32[ebp] = r32[ecx];
    if (memoryAGet(ds, 0x1f1c44) & 0xff)
        { pc = 0x1a84f1; break; }
  case 0x1a84f1: // 0160:1a84f1
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[edx] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[eax] += r32[eax];
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
    r32[eax] += r32[ebx];
    r32[ebx] <<= 3;
    r32[eax] += r32[ebx];
    r8[dl] = memoryAGet(ds, r32[esi] + 0x2);
    r32[eax] += r32[edx];
    r32[edx] <<= 2;
    r32[eax] += r32[edx];
    r16[bx] = 0x0155;
    r32[edx] = 0;
    div16(r16[bx]);
    r8[al] += 0x90;
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000003;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1a84f1; break; }
    r32[ecx] = r32[ebp];
  case 0x1a8524: // 0160:1a8524
    r8[al] = 0;
    r8[al] -= r8[cl];
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1a8524; break; }
    yield* sub_1a8b3c();
    r16[dx] = 0x03d4;
    r8[al] = 0x13;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x2a;
    out8(r16[dx], r8[al]);
    if (memoryAGet16(ds, 0x20ee5b) == 0x0001)
        { pc = 0x1a857a; break; }
    r32[eax] = memoryAGet32(ds, 0x2eeb8c);
    r32[eax] += 0x00000014;
    yield* sub_1aa5d6();
    if (memoryAGet16(ds, 0x20d7b9) != 0x000e)
        { pc = 0x1a857a; break; }
    r32[edx] = 0x001ecae4;
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0x00;
    yield* sub_1b5442();
  case 0x1a857a: // 0160:1a857a
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r32[edi] = 0x000a0000;
    r32[ecx] = 0x00004000;
    r32[eax] = 0;
    push(ds);
    es = pop();
    flags.direction = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1a8596() // 0160:1a8596 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00204d14;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[eax]);
    r32[ecx] = 0;
    memoryASet32(ds, 0x2eeb5c, r32[ecx]);
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    push32(r32[eax]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    r32[ebx] = pop32();
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[eax] = 0x00231cd8;
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[edx] = r32[eax];
    push32(r32[edx]);
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ebx] = pop32();
    r32[eax] = 0x00003e00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ecx] = pop32();
    r32[ecx] += memoryAGet32(ds, 0x2eeb5c);
    r32[edx] = pop32();
    r32[esp] += 4; return;
    // gap 131531 bytes // gap 131531 bytes
  case 0x1c87e8: // 0160:1c87e8
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    push32(r32[eax]);
    r32[eax] = 0x0020aaa8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
    yield* sub_1e3645();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e3663();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1a85aa() // 0160:1a85aa +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0;
    memoryASet32(ds, 0x2eeb5c, r32[ecx]);
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    push32(r32[eax]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    r32[ebx] = pop32();
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[eax] = 0x00231cd8;
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[edx] = r32[eax];
    push32(r32[edx]);
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ebx] = pop32();
    r32[eax] = 0x00003e00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ecx] = pop32();
    r32[ecx] += memoryAGet32(ds, 0x2eeb5c);
    r32[edx] = pop32();
    r32[esp] += 4; return;
    // gap 131531 bytes // gap 131531 bytes
  case 0x1c87e8: // 0160:1c87e8
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    push32(r32[eax]);
    r32[eax] = 0x0020aaa8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
    yield* sub_1e3645();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e3663();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1a861d() // 0160:1a861d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b0c88();
    yield* sub_1b0ee3();
    { pc = 0x1b0dfd; break; }
    // gap 34678 bytes // gap 34678 bytes
  case 0x1b0da2: // 0160:1b0da2
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
  case 0x1b0dfd: // 0160:1b0dfd
    r32[esi] = 0x00206adc;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax]);
    if (!r32[eax])
        { pc = 0x1b0ee2; break; }
    r32[esi] = r32[eax];
    memoryASet32(ds, 0x20cecb, r32[esi]);
    r32[edx] = memoryAGet32(ds, r32[esi]);
    yield* sub_1aa484();
    r32[edi] = 0x002da260;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x002d9f4c;
    memoryASet32(ds, 0x2eebc0, r32[ecx]);
    memoryASet32(ds, 0x2eebc4, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebc4);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0e6a: // 0160:1b0e6a
    r32[ecx] = 0x00000014;
  case 0x1b0e6f: // 0160:1b0e6f
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0e6f; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0e6a; break; }
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r32[eax] = 0x002da3a0;
    { pc = 0x1b0da2; break; }
  case 0x1b0ee2: // 0160:1b0ee2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1a862c() // 0160:1a862c +long
{
    r32[esp] -= 4;
    r32[esi] = 0x00207c0a;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r32[eax] <<= 2;
    r32[esi] += r32[eax];
    r32[edx] = memoryAGet32(ds, r32[esi]);  // load map - duel
    r32[eax] = 0x00232cd8;
    yield* sub_1aa4e9();
    memoryASet32(ds, 0x2eeb90, r32[ecx]);
    memoryASet32(ds, 0x2eeb94, r32[edx]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx] + 0x1);
    memoryASet32(ds, 0x1f1cb0, r32[eax]);
    memoryASet16(ds, 0x20cef3, r16[ax]);
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[edx] + 0x3);
    memoryASet32(ds, 0x1f1cb4, r32[ebx]);
    memoryASet16(ds, 0x20cef7, r16[bx]);
    mul8(r8[bl]);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeba4, r32[eax]);
    r32[eax] += memoryAGet32(ds, 0x2eeb94);
    r32[eax] += 0x00000004;
    memoryASet32(ds, 0x2eeba0, r32[eax]);
    r32[ecx] = 0;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cef7);
    r16[cx] = memoryAGet16(ds, 0x20cef3);
    r32[edx] = 0;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    memoryASet32(ds, 0x20cefb, r32[eax]);
    r32[esp] += 4;
}
function* sub_1a86b0() // 0160:1a86b0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00208058;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[eax]); // load map - challenge
    if (!r32[edx])
        { pc = 0x1a86de; break; }
    r32[eax] = 0x002390dc;
    yield* sub_1aa4e9();
    memoryASet32(ds, 0x2eeb98, r32[ecx]);
    memoryASet32(ds, 0x2eeb9c, r32[edx]);
  case 0x1a86de: // 0160:1a86de
    r32[esi] = 0x002079fa;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r32[eax] <<= 2;
    r32[esi] += r32[eax];
    r32[edx] = memoryAGet32(ds, r32[esi]);
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    if (memoryAGet16(ds, 0x20d7b9) != 0x0022)
        { pc = 0x1a8745; break; }
    r32[edi] = 0x002971d4;
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00051714;
    r32[ecx] = 0x00000060;
  case 0x1a872c: // 0160:1a872c
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x000000a0;
  case 0x1a8733: // 0160:1a8733
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1a8733; break; }
    r32[esi] = pop32();
    r32[esi] += 0x00000140;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1a872c; break; }
  case 0x1a8745: // 0160:1a8745
    r32[esi] = 0x00201a98;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d867, r16[ax]);
    memoryASet32(ds, 0x1f1c40, r32[eax]);
    r32[ecx] = 0x00060e94;
    r32[edx] = memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x2eeb88, r32[ecx]);
    memoryASet32(ds, 0x2eeb8c, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000314;
    r32[ebp] = 0x000060b8;
  case 0x1a8788: // 0160:1a8788
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    r8[bl] = memoryAGet(ds, r32[esi] + 0x9);
    r8[bh] = memoryAGet(ds, r32[esi] + 0xd);
    r32[ebx] <<= 16;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
    r8[bh] = memoryAGet(ds, r32[esi] + 0x5);
    r8[cl] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ch] = memoryAGet(ds, r32[esi] + 0xe);
    r32[ecx] <<= 16;
    r8[cl] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ch] = memoryAGet(ds, r32[esi] + 0x6);
    r8[dl] = memoryAGet(ds, r32[esi] + 0xb);
    r8[dh] = memoryAGet(ds, r32[esi] + 0xf);
    r32[edx] <<= 16;
    r8[dl] = memoryAGet(ds, r32[esi] + 0x3);
    r8[dh] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[esi], r32[eax]);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[esi] + 0x8, r32[ecx]);
    memoryASet32(ds, r32[esi] + 0xc, r32[edx]);
    r32[esi] += 0x00000010;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a8788; break; }
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000314;
    r32[edi] = 0x0030acec;
    r32[edx] = 0x002eecec;
    memoryASet32(ds, 0x2eeb68, 0x00000027);
  case 0x1a87f4: // 0160:1a87f4
    memoryASet32(ds, 0x2eeb64, 0x0000000a);
  case 0x1a87fe: // 0160:1a87fe
    r16[bx] = 0x00ff;
    memoryASet32(ds, 0x2eeb60, 0x00000004);
  case 0x1a880c: // 0160:1a880c
    memoryASet32(ds, 0x2eeb58, r32[esi]);
    memoryASet32(ds, 0x2eeb6c, r32[edx]);
    memoryASet32(ds, 0x2eeb5c, 0x00000020);
    if (!(memoryAGet(ds, 0x1f1c40) & 0xff))
        { pc = 0x1a8835; break; }
    memoryASet32(ds, 0x2eeb5c, 0x00000010);
  case 0x1a8835: // 0160:1a8835
    r32[ecx] = 0x00000004;
  case 0x1a883a: // 0160:1a883a
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a8846; break; }
    r8[al] = 0xff;
  case 0x1a8846: // 0160:1a8846
    r8[al] = ~r8[al];
    r16[ax] = ror16(r16[ax], 0x0001);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1a883a; break; }
    r32[esi] += 0x0000000c;
    r32[ecx] = 0x00000004;
  case 0x1a8856: // 0160:1a8856
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a8862; break; }
    r8[al] = 0xff;
  case 0x1a8862: // 0160:1a8862
    r8[al] = ~r8[al];
    r16[ax] = ror16(r16[ax], 0x0001);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1a8856; break; }
    if (!(memoryAGet(ds, 0x1f1c40) & 0xff))
        { pc = 0x1a887d; break; }
    r8[ah] &= 0x0f;
    r8[al] = r8[ah];
    r8[al] <<= 4;
    r8[ah] |= r8[al];
  case 0x1a887d: // 0160:1a887d
    memoryASet(ds, r32[edx], r8[ah]);
    r8[bl] &= r8[ah];
    r8[bh] |= r8[ah];
    r32[edx]++;
    r32[esi] += 0x0000012c;
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) - 1);
    if (memoryAGet32(ds, 0x2eeb5c))
        { pc = 0x1a8835; break; }
    r32[esi] = memoryAGet32(ds, 0x2eeb58);
    r32[edx] = memoryAGet32(ds, 0x2eeb6c);
    r32[edx] += 0x00000020;
    r32[esi] += 0x00000004;
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - 1);
    if (memoryAGet32(ds, 0x2eeb60))
        { pc = 0x1a880c; break; }
    r8[al] = 0;
    if (r8[bl] != 0xff)
        { pc = 0x1a88b9; break; }
    r8[al] = 0x02;
  case 0x1a88b9: // 0160:1a88b9
    if (r8[bh])
        { pc = 0x1a88bf; break; }
    r8[al] = 0x01;
  case 0x1a88bf: // 0160:1a88bf
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi] += 0x00000010;
    memoryASet32(ds, 0x2eeb64, memoryAGet32(ds, 0x2eeb64) - 1);
    if (memoryAGet32(ds, 0x2eeb64))
        { pc = 0x1a87fe; break; }
    r32[esi] += 0x000026c0;
    memoryASet32(ds, 0x2eeb68, memoryAGet32(ds, 0x2eeb68) - 1);
    if (memoryAGet32(ds, 0x2eeb68))
        { pc = 0x1a87f4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1a8760() // 0160:1a8760 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00060e94;
    r32[edx] = memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x2eeb88, r32[ecx]);
    memoryASet32(ds, 0x2eeb8c, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000314;
    r32[ebp] = 0x000060b8;
  case 0x1a8788: // 0160:1a8788
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    r8[bl] = memoryAGet(ds, r32[esi] + 0x9);
    r8[bh] = memoryAGet(ds, r32[esi] + 0xd);
    r32[ebx] <<= 16;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
    r8[bh] = memoryAGet(ds, r32[esi] + 0x5);
    r8[cl] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ch] = memoryAGet(ds, r32[esi] + 0xe);
    r32[ecx] <<= 16;
    r8[cl] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ch] = memoryAGet(ds, r32[esi] + 0x6);
    r8[dl] = memoryAGet(ds, r32[esi] + 0xb);
    r8[dh] = memoryAGet(ds, r32[esi] + 0xf);
    r32[edx] <<= 16;
    r8[dl] = memoryAGet(ds, r32[esi] + 0x3);
    r8[dh] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[esi], r32[eax]);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[esi] + 0x8, r32[ecx]);
    memoryASet32(ds, r32[esi] + 0xc, r32[edx]);
    r32[esi] += 0x00000010;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a8788; break; }
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000314;
    r32[edi] = 0x0030acec;
    r32[edx] = 0x002eecec;
    memoryASet32(ds, 0x2eeb68, 0x00000027);
  case 0x1a87f4: // 0160:1a87f4
    memoryASet32(ds, 0x2eeb64, 0x0000000a);
  case 0x1a87fe: // 0160:1a87fe
    r16[bx] = 0x00ff;
    memoryASet32(ds, 0x2eeb60, 0x00000004);
  case 0x1a880c: // 0160:1a880c
    memoryASet32(ds, 0x2eeb58, r32[esi]);
    memoryASet32(ds, 0x2eeb6c, r32[edx]);
    memoryASet32(ds, 0x2eeb5c, 0x00000020);
    if (!(memoryAGet(ds, 0x1f1c40) & 0xff))
        { pc = 0x1a8835; break; }
    memoryASet32(ds, 0x2eeb5c, 0x00000010);
  case 0x1a8835: // 0160:1a8835
    r32[ecx] = 0x00000004;
  case 0x1a883a: // 0160:1a883a
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a8846; break; }
    r8[al] = 0xff;
  case 0x1a8846: // 0160:1a8846
    r8[al] = ~r8[al];
    r16[ax] = ror16(r16[ax], 0x0001);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1a883a; break; }
    r32[esi] += 0x0000000c;
    r32[ecx] = 0x00000004;
  case 0x1a8856: // 0160:1a8856
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a8862; break; }
    r8[al] = 0xff;
  case 0x1a8862: // 0160:1a8862
    r8[al] = ~r8[al];
    r16[ax] = ror16(r16[ax], 0x0001);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1a8856; break; }
    if (!(memoryAGet(ds, 0x1f1c40) & 0xff))
        { pc = 0x1a887d; break; }
    r8[ah] &= 0x0f;
    r8[al] = r8[ah];
    r8[al] <<= 4;
    r8[ah] |= r8[al];
  case 0x1a887d: // 0160:1a887d
    memoryASet(ds, r32[edx], r8[ah]);
    r8[bl] &= r8[ah];
    r8[bh] |= r8[ah];
    r32[edx]++;
    r32[esi] += 0x0000012c;
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) - 1);
    if (memoryAGet32(ds, 0x2eeb5c))
        { pc = 0x1a8835; break; }
    r32[esi] = memoryAGet32(ds, 0x2eeb58);
    r32[edx] = memoryAGet32(ds, 0x2eeb6c);
    r32[edx] += 0x00000020;
    r32[esi] += 0x00000004;
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - 1);
    if (memoryAGet32(ds, 0x2eeb60))
        { pc = 0x1a880c; break; }
    r8[al] = 0;
    if (r8[bl] != 0xff)
        { pc = 0x1a88b9; break; }
    r8[al] = 0x02;
  case 0x1a88b9: // 0160:1a88b9
    if (r8[bh])
        { pc = 0x1a88bf; break; }
    r8[al] = 0x01;
  case 0x1a88bf: // 0160:1a88bf
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi] += 0x00000010;
    memoryASet32(ds, 0x2eeb64, memoryAGet32(ds, 0x2eeb64) - 1);
    if (memoryAGet32(ds, 0x2eeb64))
        { pc = 0x1a87fe; break; }
    r32[esi] += 0x000026c0;
    memoryASet32(ds, 0x2eeb68, memoryAGet32(ds, 0x2eeb68) - 1);
    if (memoryAGet32(ds, 0x2eeb68))
        { pc = 0x1a87f4; break; }
    r32[esp] += 4;
    return;
  }
}
function sub_1a88e4() // 0160:1a88e4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    push(es);
    push(ds);
    r16[ax] = 0x0168;
    ds = r32[eax];
    memoryASet32(ds, 0x2eebd4, memoryAGet32(ds, 0x2eebd4) + 1);
    r8[al] = memoryAGet(ds, 0x2eebd4);
    if (r8[al] == 0x10)
        { pc = 0x1a8a19; break; }
    if (r8[al] < 0x10)
        { pc = 0x1a89db; break; }
    r16[dx] = 0x03d4;
    r16[bx] = memoryAGet16(ds, 0x1f1cb8);
    r8[ah] = r8[bh];
    r8[al] = 0x0c;
    out16(r16[dx], r16[ax]);
    r8[al]++;
    r8[ah] = r8[bl];
    out16(r16[dx], r16[ax]);
    r8[dl] = 0xc0;
    r8[al] = 0x33;
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, 0x1f1cba);
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, 0x1f1cbe);
    memoryASet(ds, 0x1f1cba, r8[al]);
    memoryASet32(ds, 0x2eebd4, 0x00000000);
    memoryASet32(ds, 0x2eebd0, memoryAGet32(ds, 0x2eebd0) + 1);
    r8[al] = 0x34;
    out8(0x43, r8[al]);
    r8[al] = 0;
    out8(0x40, r8[al]);
    out8(0x40, r8[al]);
  case 0x1a894c: // 0160:1a894c
    r8[al] = 0x04;
    out8(0x43, r8[al]);
    r8[al] = in8(0x40);
    r8[bl] = r8[al];
    r8[al] = in8(0x40);
    r8[bh] = r8[al];
    if (r16s[bx] > signed16(0xff38))
        { pc = 0x1a894c; break; }
    r16[bx] = 0x0064;
    r8[dl] = 0xda;
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x1a8993; break; }
  case 0x1a896a: // 0160:1a896a
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x08))
        { pc = 0x1a896a; break; }
    r8[al] = 0x04;
    out8(0x43, r8[al]);
    r8[al] = in8(0x40);
    r8[bl] = r8[al];
    r8[al] = in8(0x40);
    r8[bh] = r8[al];
    r16[ax] = r16[bx];
    r16[bx] = 0x02bc;
    if (r16[ax] < 0xe026)
        { pc = 0x1a8993; break; }
    r16[bx] = r16[ax];
    r16[bx] = sar16(r16[bx], 0x0001);
    r16[bx] += 0x00c8;
  case 0x1a8993: // 0160:1a8993
    memoryASet16(ds, 0x1f1d3c, memoryAGet16(ds, 0x1f1d3c) - r16[bx]);
    r8[al] = 0x34;
    out8(0x43, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x1f1d38);
    out8(0x40, r8[al]);
    r8[al] = r8[ah];
    out8(0x40, r8[al]);
    r16[dx] = 0x0201;
    r32[eax] = 0;
    out8(r16[dx], r8[al]);
    memoryASet32(ds, 0x1f1cc8, r32[eax]);
    memoryASet(ds, 0x1f1cc2, r8[al]);
    memoryASet(ds, 0x1f1cc1, 0xf0);
    if (memoryAGet16(ds, 0x224666) >= 0x0100)
        { pc = 0x1a89d2; break; }
    sub_1b4f37();
  case 0x1a89d2: // 0160:1a89d2
    memoryASet16(ds, 0x20ee4f, memoryAGet16(ds, 0x20ee4f) + 1);
    { pc = 0x1a8a11; break; }
  case 0x1a89db: // 0160:1a89db
    r16[dx] = 0x0201;
    r8[al] = in8(r16[dx]);
    memoryASet(ds, 0x1f1cc1, memoryAGet(ds, 0x1f1cc1) & r8[al]);
    memoryASet(ds, 0x1f1cc2, memoryAGet(ds, 0x1f1cc2) | r8[al]);
    flags.carry = !!(r8[al] & 0x08);
    r8[al] <<= 5;
    memoryASet(ds, 0x1f1ccb, memoryAGet(ds, 0x1f1ccb) + (0x00 + flags.carry));
    flags.carry = r8[al] + r8[al] >= 0x100;
    r8[al] += r8[al];
    memoryASet(ds, 0x1f1cca, memoryAGet(ds, 0x1f1cca) + (0x00 + flags.carry));
    flags.carry = r8[al] + r8[al] >= 0x100;
    r8[al] += r8[al];
    memoryASet(ds, 0x1f1cc9, memoryAGet(ds, 0x1f1cc9) + (0x00 + flags.carry));
    flags.carry = r8[al] + r8[al] >= 0x100;
    r8[al] += r8[al];
    memoryASet(ds, 0x1f1cc8, memoryAGet(ds, 0x1f1cc8) + (0x00 + flags.carry));
  case 0x1a8a11: // 0160:1a8a11
    r8[al] = 0x20;
    out8(0x20, r8[al]);
    ds = pop();
    es = pop();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r32[esp] += 4; return;
    stop("iretd");
  case 0x1a8a19: // 0160:1a8a19
    r8[al] = 0x34;
    out8(0x43, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x1f1d3c);
    out8(0x40, r8[al]);
    r8[al] = r8[ah];
    out8(0x40, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x1f1cc8);
    memoryASet32(ds, 0x1f1cc4, r32[eax]);
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] |= memoryAGet(ds, 0x1f1cc1);
    r8[al] &= memoryAGet(ds, 0x1f1cc2);
    memoryASet(ds, 0x1f1cc3, r8[al]);
    push(fs);
    push(gs);
    sub_1b4f8f();
    memoryASet32(ds, 0x1f1c54, memoryAGet32(ds, 0x1f1c54) + 1);
    gs = pop();
    fs = pop();
    r32[eax] = memoryAGet32(ds, 0x1f1d38);
    r32[eax] <<= 4;
    r32[eax] += memoryAGet32(ds, 0x1f1d3c);
    r32[eax] += memoryAGet32(ds, 0x2eebd8);
    r32[eax] += 0x0000000f;
    memoryASet32(ds, 0x2eebd8, r32[eax]);
    flags.carry = r32[eax] < 0x00010000;
    r32[eax] -= 0x00010000;
    if (!flags.carry)
        { pc = 0x1a8a8b; break; }
    r8[al] = 0x20;
    out8(0x20, r8[al]);
    { pc = 0x1a8a97; break; }
  case 0x1a8a8b: // 0160:1a8a8b
    memoryASet32(ds, 0x2eebd8, r32[eax]);
  case 0x1a8a97: // 0160:1a8a97
    ds = pop();
    es = pop();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r32[esp] += 4; return;
    stop("iretd");
    return;
  }
}
function* sub_1a8a9b() // 0160:1a8a9b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[edx]);
    push(ds);
    r16[ax] = 0xc000;
    ds = r32[eax];
    r8[al] = in8(0x60);
    if (r8[al] == 0xe0)
        { pc = 0x1a8b0c; break; }
    if (r8[al] == 0xe1)
        { pc = 0x1a8b0c; break; }
    r32[ebx] = 0x0000007f;
    r8[bl] &= r8[al];
    r8[dl] = r8[bl];
    if (r8[bl] >= 0x60)
        { pc = 0x1a8b03; break; }
    r8[bl] += memoryAGet(ds, 0x2eebe8);
    memoryASet(ds, 0x2eebe8, 0x00);
    r8[al] = ~r8[al];
    r8[al] >>>= 7;
    memoryASet(ds, r32[ebx] + 0x30b070, r8[al]);
    r8[ah] = memoryAGet(ds, 0x30b0a8);
    r8[ah] |= memoryAGet(ds, 0x30b108);
    r8[ah] += r8[ah];
    r8[ah] |= memoryAGet(ds, 0x30b08d);
    r8[ah] |= memoryAGet(ds, 0x30b0ed);
    r8[ah] += r8[ah];
    r8[ah] |= memoryAGet(ds, 0x30b09a);
    r8[ah] |= memoryAGet(ds, 0x30b0a6);
    memoryASet(ds, 0x1f1cc0, r8[ah]);
  case 0x1a8b03: // 0160:1a8b03
    r8[al] = 0x20;
    out8(0x20, r8[al]);
    ds = pop();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    stop("iretd");
  case 0x1a8b0c: // 0160:1a8b0c
    memoryASet(ds, 0x2eebe8, 0x60);
    { pc = 0x1a8b03; break; }
    return;
  }
}
function* sub_1a8b3c() // 0160:1a8b3c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[dx] = 0x03d4;
    r8[al] = 0x11;
    out8(r16[dx], r8[al]);
    r8[al] = 0x0c;
    r16[dx]++;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03ce;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = in8(r16[dx]);
    r8[al] &= 0xef;
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x06;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = in8(r16[dx]);
    r8[al] &= 0xfd;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03c4;
    r8[al] = 0x04;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = in8(r16[dx]);
    r8[al] &= 0xf7;
    r8[al] |= 0x04;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03d4;
    r8[al] = 0x14;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = in8(r16[dx]);
    r8[al] &= 0xbf;
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x17;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = in8(r16[dx]);
    r8[al] |= 0x40;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03d4;
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r32[eax] = memoryAGet32(ds, 0x1f1c48);
    r32[eax] >>>= 2;
    r32[eax]--;
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x12;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r32[eax] = memoryAGet32(ds, 0x1f1c4c);
    r32[eax] += r32[eax];
    r32[eax]--;
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x02;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = memoryAGet(ds, 0x1f1cbb);
    if (r8[al] != 0x99)
        { pc = 0x1a8bc0; break; }
    r8[al] = in8(r16[dx]);
    memoryASet(ds, 0x1f1cbb, r8[al]);
  case 0x1a8bc0: // 0160:1a8bc0
    r32[ebx] = 0x00000140;
    r32[ebx] -= memoryAGet32(ds, 0x1f1c48);
    r32[ebx] >>>= 2;
    r8[al] -= r8[bl];
    out8(r16[dx], r8[al]);
    r32[eax] = 0x00000140;
    r32[eax] -= memoryAGet32(ds, 0x1f1c48);
    r32[eax] >>>= 3;
    r8[ch] = r8[al];
    r16[dx]--;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = memoryAGet(ds, 0x1f1cbc);
    if (r8[al] != 0x99)
        { pc = 0x1a8bf7; break; }
    r8[al] = in8(r16[dx]);
    memoryASet(ds, 0x1f1cbc, r8[al]);
  case 0x1a8bf7: // 0160:1a8bf7
    r8[cl] = r8[al];
    r8[cl] &= 0xe0;
    r8[al] -= r8[ch];
    r8[al] &= 0x1f;
    r8[al] |= r8[cl];
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x04;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = memoryAGet(ds, 0x1f1cbd);
    if (r8[al] != 0x99)
        { pc = 0x1a8c19; break; }
    r8[al] = in8(r16[dx]);
    memoryASet(ds, 0x1f1cbd, r8[al]);
  case 0x1a8c19: // 0160:1a8c19
    r32[ebx] >>>= 1;
    r8[al] -= r8[bl];
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x10;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r32[ebx] = 0x000000f0;
    r32[ebx] -= memoryAGet32(ds, 0x1f1c4c);
    r8[al] = 0xea;
    r8[al] -= r8[bl];
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x15;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r32[eax] = memoryAGet32(ds, 0x1f1c4c);
    r32[eax] += r32[eax];
    r32[eax] += 0x00000007;
    r8[ch] = r8[ah];
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x07;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r32[eax] = memoryAGet32(ds, 0x1f1c4c);
    r32[eax] += r32[eax];
    r32[eax]--;
    r32[eax] >>>= 7;
    r8[al] &= 0x02;
    r8[ch] &= 0x01;
    r8[ch] <<= 3;
    r8[al] |= r8[ch];
    r8[al] |= 0x34;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03c2;
    r8[al] = 0xe3;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03d4;
    r8[al] = 0x06;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x0d;
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x11;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x8c;
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x16;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x06;
    out8(r16[dx], r8[al]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1a8c90() // 0160:1a8c90 +long
{
    r32[esp] -= 4;
    r8[al] = 0x02;
    yield* sub_1a9055();
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[ebx] = memoryAGet32(ds, 0x1f1c3c);
    memoryASet32(ds, 0x1f1ca8, r32[eax]);
    memoryASet32(ds, 0x1f1cac, r32[ebx]);
    r32[esp] += 4;
}
function* sub_1a8cae() // 0160:1a8cae +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20c832, memoryAGet16(ds, 0x20c832) + 0x0001);
    if (!memoryAGet16(ds, 0x20ee85))
        { pc = 0x1a8cc8; break; }
    memoryASet16(ds, 0x20ee85, memoryAGet16(ds, 0x20ee85) - 0x0001);
  case 0x1a8cc8: // 0160:1a8cc8
    memoryASet16(ds, 0x20ee85, memoryAGet16(ds, 0x20ee85) & 0x00ff);
    if (!memoryAGet16(ds, 0x20ee83))
        { pc = 0x1a8ce3; break; }
    memoryASet16(ds, 0x20ee83, memoryAGet16(ds, 0x20ee83) - 0x0001);
  case 0x1a8ce3: // 0160:1a8ce3
    memoryASet16(ds, 0x20ee83, memoryAGet16(ds, 0x20ee83) & 0x00ff);
    if (memoryAGet16(ds, 0x20d7bf) & 0xffff)
        { pc = 0x1a8d0f; break; }
    memoryASet16(ds, 0x20c830, memoryAGet16(ds, 0x20c830) + 0x0001);
    r8[al] = memoryAGet(ds, 0x20c82e);
    r8[al] <<= 1;
    if (r8[al])
        { pc = 0x1a8d0a; break; }
    r8[al] = 0x01;
  case 0x1a8d0a: // 0160:1a8d0a
    memoryASet(ds, 0x20c82e, r8[al]);
  case 0x1a8d0f: // 0160:1a8d0f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1a8d10() // 0160:1a8d10 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    r32[ebx] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    memoryASet32(ds, 0x1f1c38, r32[eax]);
    memoryASet32(ds, 0x1f1c3c, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, 0x1f1c34);
    r32[eax] = memoryAGet32(ds, 0x1f1ca8);
    r8[bl] = 0x0f;
    r8[bl] &= r8[al];
    r8[bl] >>>= 2;
    memoryASet16(ds, 0x1f1cb8, r16[bx]);
    r32[eax] = memoryAGet32(ds, 0x1f1ca8);
    r8[al] &= 0x03;
    r8[al] += r8[al];
    memoryASet(ds, 0x1f1cbe, r8[al]);
    if (memoryAGet(ds, 0x1f1cbf))
        { pc = 0x1a8d61; break; }
    memoryASet(ds, 0x1f1cba, r8[al]);
  case 0x1a8d61: // 0160:1a8d61
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
  case 0x1a8d66: // 0160:1a8d66
    yield* sync();
    if (memoryAGet32(ds, 0x2eebd0) == r32[eax])
        { pc = 0x1a8d66; break; }
    if (!(memoryAGet(ds, 0x1f1d34) & 0x01))
        { pc = 0x1a8d78; break; }
    r32[esp] += 4; return;
  case 0x1a8d78: // 0160:1a8d78
    r32[eax] = memoryAGet32(ds, 0x1f1c34);
    r32[eax] += 0x00005500;
    if (r32[eax] < 0x000aff00)
        { pc = 0x1a8d8e; break; }
    r32[eax] -= 0x0000ff00;
  case 0x1a8d8e: // 0160:1a8d8e
    memoryASet32(ds, 0x1f1c34, r32[eax]);
    if (memoryAGet(ds, 0x1f1c44) & 0xff)
        { pc = 0x1a8e20; break; }
    r32[ebp] = memoryAGet32(ds, 0x1f1c38);
    if (!(memoryAGet16(ds, 0x20d867) & 0xffff))
        { pc = 0x1a8db7; break; }
    r32[ebp] >>>= 1;
  case 0x1a8db7: // 0160:1a8db7
    r32[eax] = memoryAGet32(ds, 0x1f1ca8);
    r32[ebp] >>>= 1;
    r32[eax] >>>= 1;
    r32[ebp] -= r32[eax];
    r32[ebp] &= 0x0000001f;
    if (!r32[ebp])
        { pc = 0x1a8de0; break; }
    r32[ebp] -= 0x00000010;
    if (r32s[ebp] >= 0)
        { pc = 0x1a8dd6; break; }
    r32[ebp] += 0x00000010;
    yield* sub_1a9c89();
    { pc = 0x1a8de0; break; }
  case 0x1a8dd6: // 0160:1a8dd6
    r32[ebp] = -r32[ebp];
    r32[ebp] += 0x00000010;
    yield* sub_1a9cdc();
  case 0x1a8de0: // 0160:1a8de0
    r32[ebp] = memoryAGet32(ds, 0x1f1c3c);
    r32[eax] = memoryAGet32(ds, 0x1f1cac);
    r32[ebp] >>>= 1;
    r32[eax] >>>= 1;
    r32[ebp] -= r32[eax];
    if (!(memoryAGet16(ds, 0x20d867) & 0xffff))
        { pc = 0x1a8e02; break; }
    r32[ebp] >>>= 1;
  case 0x1a8e02: // 0160:1a8e02
    r32[ebp] &= 0x0000001f;
    if (!r32[ebp])
        { pc = 0x1a8e20; break; }
    r32[ebp] -= 0x00000010;
    if (r32s[ebp] >= 0)
        { pc = 0x1a8e16; break; }
    r32[ebp] += 0x00000010;
    yield* sub_1a9c1f();
    { pc = 0x1a8e20; break; }
  case 0x1a8e16: // 0160:1a8e16
    r32[ebp] = -r32[ebp];
    r32[ebp] += 0x00000010;
    yield* sub_1a9c54();
  case 0x1a8e20: // 0160:1a8e20
    if (!(memoryAGet(ds, 0x1f1c40) & 0xff))
        { pc = 0x1a8e30; break; }
    yield* sub_1a8f63();
    { pc = 0x1a8e35; break; }
  case 0x1a8e30: // 0160:1a8e30
    yield* sub_1a8e36();
  case 0x1a8e35: // 0160:1a8e35
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1a8e36() // 0160:1a8e36 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = signed16(memoryAGet16(ds, 0x1f1c38));
    r32[eax] = sar32(r32[eax], 0x05);
  case 0x1a8e40: // 0160:1a8e40
    r32[eax] -= memoryAGet32(ds, 0x1f1cb0);
    if (r32s[eax] >= 0)
        { pc = 0x1a8e40; break; }
  case 0x1a8e48: // 0160:1a8e48
    r32[eax] += memoryAGet32(ds, 0x1f1cb0);
    if (r32s[eax] < 0)
        { pc = 0x1a8e48; break; }
    mul16(memoryAGet16(ds, 0x1f1cb4));
    r32[esi] = signed16(memoryAGet16(ds, 0x1f1c3c));
    r32[esi] = sar32(r32[esi], 0x05);
  case 0x1a8e61: // 0160:1a8e61
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
    if (r32s[esi] >= 0)
        { pc = 0x1a8e61; break; }
  case 0x1a8e69: // 0160:1a8e69
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    if (r32s[esi] < 0)
        { pc = 0x1a8e69; break; }
    r32[ebx] = memoryAGet32(ds, 0x1f1cb4);
    r32[ebx] -= r32[esi];
    memoryASet32(ds, 0x2eeb7c, r32[ebx]);
    r32[esi] += r32[eax];
    r32[esi] += r32[esi];
    r32[esi] += memoryAGet32(ds, 0x2eeb94);
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x1f1c34);
    if (!(memoryAGet(ds, 0x1f1c38) & 0x10))
        { pc = 0x1a8ede; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c3c);
    r32[eax] &= 0x0000001f;
    r32[ecx] = memoryAGet32(ds, 0x1f1c4c);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ebx] = 0x00000010;
    r32[edx] = memoryAGet32(ds, 0x2eeb7c);
    yield* sub_1aa00c();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edi] += 0x00000004;
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    if (r32[esi] < memoryAGet32(ds, 0x2eeba0))
        { pc = 0x1a8ede; break; }
    r32[esi] -= memoryAGet32(ds, 0x2eeba4);
  case 0x1a8ede: // 0160:1a8ede
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[eax] = ~r32[eax];
    r32[eax] &= 0x00000010;
    r32[eax] += memoryAGet32(ds, 0x1f1c48);
    r32[eax] >>>= 5;
    memoryASet32(ds, 0x2eeb68, r32[eax]);
  case 0x1a8ef6: // 0160:1a8ef6
    r32[eax] = memoryAGet32(ds, 0x1f1c3c);
    r32[eax] &= 0x0000001f;
    r32[ecx] = memoryAGet32(ds, 0x1f1c4c);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edx] = memoryAGet32(ds, 0x2eeb7c);
    yield* sub_1a9d2f();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edi] += 0x00000008;
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    if (r32[esi] < memoryAGet32(ds, 0x2eeba0))
        { pc = 0x1a8f30; break; }
    r32[esi] -= memoryAGet32(ds, 0x2eeba4);
  case 0x1a8f30: // 0160:1a8f30
    memoryASet32(ds, 0x2eeb68, memoryAGet32(ds, 0x2eeb68) - 1);
    if (memoryAGet32(ds, 0x2eeb68))
        { pc = 0x1a8ef6; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[eax] ^= memoryAGet32(ds, 0x1f1c48);
    if (r8[al] & 0x10)
        { pc = 0x1a8f62; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c3c);
    r32[eax] &= 0x0000001f;
    r32[ecx] = memoryAGet32(ds, 0x1f1c4c);
    r32[ebx] = 0;
    r32[edx] = memoryAGet32(ds, 0x2eeb7c);
    yield* sub_1aa00c();
  case 0x1a8f62: // 0160:1a8f62
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1a8f63() // 0160:1a8f63 +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x1f1c38);
    r16[bx] = memoryAGet16(ds, 0x1f1c3c);
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] >>>= 1;
    r16[bx] >>>= 1;
    memoryASet16(ds, 0x1f1c38, r16[ax]);
    memoryASet16(ds, 0x1f1c3c, r16[bx]);
    yield* sub_1a8f94();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x1f1c3c, r16[bx]);
    r32[esp] += 4;
}
function* sub_1a8f94() // 0160:1a8f94 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = signed16(memoryAGet16(ds, 0x1f1c38));
    r32[eax] = sar32(r32[eax], 0x04);
  case 0x1a8f9e: // 0160:1a8f9e
    r32[eax] -= memoryAGet32(ds, 0x1f1cb0);
    if (r32s[eax] >= 0)
        { pc = 0x1a8f9e; break; }
  case 0x1a8fa6: // 0160:1a8fa6
    r32[eax] += memoryAGet32(ds, 0x1f1cb0);
    if (r32s[eax] < 0)
        { pc = 0x1a8fa6; break; }
    mul16(memoryAGet16(ds, 0x1f1cb4));
    r32[esi] = signed16(memoryAGet16(ds, 0x1f1c3c));
    r32[esi] = sar32(r32[esi], 0x04);
  case 0x1a8fbf: // 0160:1a8fbf
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
    if (r32s[esi] >= 0)
        { pc = 0x1a8fbf; break; }
  case 0x1a8fc7: // 0160:1a8fc7
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    if (r32s[esi] < 0)
        { pc = 0x1a8fc7; break; }
    r32[ebx] = memoryAGet32(ds, 0x1f1cb4);
    r32[ebx] -= r32[esi];
    memoryASet32(ds, 0x2eeb7c, r32[ebx]);
    r32[esi] += r32[eax];
    r32[esi] += r32[esi];
    r32[esi] += memoryAGet32(ds, 0x2eeb94);
    r32[esi] += 0x00000004;
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[eax] &= 0x00000010;
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r32[edi] = memoryAGet32(ds, 0x1f1c34);
    r32[eax] = memoryAGet32(ds, 0x1f1c48);
    r32[eax] >>>= 4;
    r32[eax]++;
    memoryASet32(ds, 0x2eeb68, r32[eax]);
  case 0x1a900b: // 0160:1a900b
    r32[eax] = memoryAGet32(ds, 0x1f1c3c);
    r32[eax] &= 0x0000001f;
    r32[ecx] = memoryAGet32(ds, 0x1f1c4c);
    r32[edx] = memoryAGet32(ds, 0x2eeb7c);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1aa260();
    r32[edi] = pop32();
    r32[esi] = pop32();
    memoryASet(ds, 0x2eeb74, memoryAGet(ds, 0x2eeb74) ^ 0x10);
    r32[edi] += 0x00000004;
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    r32[esi] += memoryAGet32(ds, 0x1f1cb4);
    if (r32[esi] < memoryAGet32(ds, 0x2eeba0))
        { pc = 0x1a904c; break; }
    r32[esi] -= memoryAGet32(ds, 0x2eeba4);
  case 0x1a904c: // 0160:1a904c
    memoryASet32(ds, 0x2eeb68, memoryAGet32(ds, 0x2eeb68) - 1);
    if (memoryAGet32(ds, 0x2eeb68))
        { pc = 0x1a900b; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1a9055() // 0160:1a9055 +long
{
    r32[esp] -= 4;
    r8[ah] = r8[al];
    r32[esp] += 4;
}
function* sub_1a9c1f() // 0160:1a9c1f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1a9c1f: // 0160:1a9c1f
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00041294;
    r8[dl] = 0x08;
  case 0x1a9c2d: // 0160:1a9c2d
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[ecx] = 0x0000001f;
  case 0x1a9c34: // 0160:1a9c34
    r32[eax] = memoryAGet32(ds, r32[esi] - 320);
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[esi] -= 0x00000140;
    if (--r32[ecx])
        { pc = 0x1a9c34; break; }
    memoryASet32(ds, r32[esi], r32[ebx]);
    r32[esi] += 0x000026c4;
    r8[dl]--;
    if (r8[dl])
        { pc = 0x1a9c2d; break; }
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9c1f; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1a9c54() // 0160:1a9c54 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1a9c54: // 0160:1a9c54
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x0003ebd4;
    r8[dl] = 0x08;
  case 0x1a9c62: // 0160:1a9c62
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[ecx] = 0x0000001f;
  case 0x1a9c69: // 0160:1a9c69
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x140);
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[esi] += 0x00000140;
    if (--r32[ecx])
        { pc = 0x1a9c69; break; }
    memoryASet32(ds, r32[esi], r32[ebx]);
    r32[esi] += 0xffffd944;
    r8[dl]--;
    if (r8[dl])
        { pc = 0x1a9c62; break; }
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9c54; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1a9c89() // 0160:1a9c89 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1a9c89: // 0160:1a9c89
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x0003ebd4;
    r32[ecx] = 0x00000020;
  case 0x1a9c9a: // 0160:1a9c9a
    r32[eax] = memoryAGet32(ds, r32[esi] + 0xc);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    memoryASet32(ds, r32[esi] + 0xc, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[esi] + 0x8, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x1c);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x18);
    memoryASet32(ds, r32[esi] + 0x1c, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x14);
    memoryASet32(ds, r32[esi] + 0x18, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x10);
    memoryASet32(ds, r32[esi] + 0x14, r32[edx]);
    r32[eax] = rol32(r32[eax], 0x08);
    r32[ebx] = rol32(r32[ebx], 0x08);
    r8[tl] = r8[bl]; r8[bl] = r8[al]; r8[al] = r8[tl];
    memoryASet32(ds, r32[esi], r32[eax]);
    memoryASet32(ds, r32[esi] + 0x10, r32[ebx]);
    r32[esi] += 0x00000140;
    if (--r32[ecx])
        { pc = 0x1a9c9a; break; }
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9c89; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1a9cdc() // 0160:1a9cdc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1a9cdc: // 0160:1a9cdc
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x0003ebd4;
    r32[ecx] = 0x00000020;
  case 0x1a9ced: // 0160:1a9ced
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[esi], r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, r32[esi] + 0x8, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x10);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x14);
    memoryASet32(ds, r32[esi] + 0x10, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x18);
    memoryASet32(ds, r32[esi] + 0x14, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x1c);
    memoryASet32(ds, r32[esi] + 0x18, r32[edx]);
    r8[tl] = r8[bl]; r8[bl] = r8[al]; r8[al] = r8[tl];
    r32[eax] = ror32(r32[eax], 0x08);
    r32[ebx] = ror32(r32[ebx], 0x08);
    memoryASet32(ds, r32[esi] + 0xc, r32[eax]);
    memoryASet32(ds, r32[esi] + 0x1c, r32[ebx]);
    r32[esi] += 0x00000140;
    if (--r32[ecx])
        { pc = 0x1a9ced; break; }
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9cdc; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1a9d2f() // 0160:1a9d2f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x2eeb78, r32[edx]);
    r32[edx] = 0x00000020;
    r32[edx] -= r32[eax];
    r8[bl] = 0x0a;
    mul8(r8[bl]);
    r32[ebp] = r32[eax];
  case 0x1a9d42: // 0160:1a9d42
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r8[bl] = memoryAGet(ds, r32[eax] + 0x30acec);
    memoryASet(ds, 0x2eeb84, r8[bl]);
    if (r8[bl] == 0x02)
        { pc = 0x1a9d8d; break; }
    r32[ebx] = r32[eax];
    r32[ebx] <<= 7;
    r32[ebx] += 0x00000020;
    r32[ebx] -= r32[edx];
    r32[ebx] += 0x002eecec;
    memoryASet32(ds, 0x2eeb58, r32[ebx]);
    r32[ebx] = 0x0000000a;
    div8(r8[bl]);
    r32[eax] >>>= 8;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[ebx] -= r32[eax];
    r32[ebx] <<= 5;
    r32[ebx] += r32[eax];
    r32[ebx] += r32[ebp];
    r32[ebx] <<= 5;
    r32[ebx] += memoryAGet32(ds, 0x2eeb8c);
  case 0x1a9d8d: // 0160:1a9d8d
    r32[esi] += 0x00000002;
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a9da4; break; }
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
  case 0x1a9da4: // 0160:1a9da4
    r32[ebx] += 0x00000314;
    memoryASet32(ds, 0x2eeb60, r32[esi]);
    r32[esi] = 0x00000020;
    r32[esi] -= r32[edx];
    r32[esi] <<= 6;
    r32[eax] = r32[esi];
    r32[esi] <<= 2;
    r32[esi] += r32[eax];
    r32[esi] += memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x0003ebd4;
    flags.carry = r32[ecx] < r32[edx];
    r32[ecx] -= r32[edx];
    if (!flags.carry)
        { pc = 0x1a9dd5; break; }
    r32[edx] += r32[ecx];
    r32[ecx] = 0;
  case 0x1a9dd5: // 0160:1a9dd5
    memoryASet32(ds, 0x2eeb6c, r32[edi]);
    memoryASet32(ds, 0x2eeb70, r32[edx]);
    r16[ax] = 0x0102;
  case 0x1a9de5: // 0160:1a9de5
    memoryASet32(ds, 0x2eeb5c, r32[esi]);
    memoryASet32(ds, 0x2eeb64, r32[ebx]);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x2eeb58);
    r32[ebp] = memoryAGet32(ds, 0x2eeb70);
    if (memoryAGet(ds, 0x2eeb84) == 0x01)
        { pc = 0x1a9f02; break; }
    if (memoryAGet(ds, 0x2eeb84) == 0x02)
        { pc = 0x1a9f87; break; }
  case 0x1a9e22: // 0160:1a9e22
    r8[al] = memoryAGet(ds, r32[edx]);
    r8[al]++;
    if (!r8[al])
        { pc = 0x1a9eb9; break; }
    r8[al]--;
    if (!r8[al])
        { pc = 0x1a9edc; break; }
    r32[eax] &= 0x0000000f;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x1f1c68);
    r32[eax] &= memoryAGet32(ds, r32[esi]);
    r32[eax] |= memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[eax] &= 0x000000f0;
    r32[eax] >>>= 2;
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x1f1c68);
    r32[eax] &= memoryAGet32(ds, r32[esi] + 0x10);
    r32[eax] |= memoryAGet32(ds, r32[ebx] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edx]++;
    r32[edi] += 0x00000054;
    r32[esi] += 0x00000140;
    r32[ebx] += 0x00000140;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9e22; break; }
  case 0x1a9e70: // 0160:1a9e70
    r32[eax] = memoryAGet32(ds, 0x2eeb54);
    r8[ah] += r8[ah];
    if (r8[ah] >= 0x10)
        { pc = 0x1a9ea5; break; }
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    r32[esi] = memoryAGet32(ds, 0x2eeb5c);
    r32[esi] += 0x00000004;
    r32[ebx] = memoryAGet32(ds, 0x2eeb64);
    r32[ebx] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb58, memoryAGet32(ds, 0x2eeb58) + 0x00000020);
    { pc = 0x1a9de5; break; }
  case 0x1a9ea5: // 0160:1a9ea5
    r32[esi] = memoryAGet32(ds, 0x2eeb60);
    r32[edx] = 0x00000020;
    if (r32[ecx])
        { pc = 0x1a9d42; break; }
    r32[esp] += 4; return;
  case 0x1a9eb9: // 0160:1a9eb9
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edx]++;
    r32[edi] += 0x00000054;
    r32[esi] += 0x00000140;
    r32[ebx] += 0x00000140;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9e22; break; }
    { pc = 0x1a9e70; break; }
  case 0x1a9edc: // 0160:1a9edc
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edx]++;
    r32[edi] += 0x00000054;
    r32[esi] += 0x00000140;
    r32[ebx] += 0x00000140;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9e22; break; }
    { pc = 0x1a9e70; break; }
  case 0x1a9f02: // 0160:1a9f02
    if (!(r32[ebp] & 0x00000003))
        { pc = 0x1a9f25; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[ebx] += 0x00000140;
    r32[edi] += 0x00000054;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9f02; break; }
    { pc = 0x1a9e70; break; }
  case 0x1a9f25: // 0160:1a9f25
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x140);
    memoryASet32(ds, r32[edi] + 0x54, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x150);
    memoryASet32(ds, r32[edi] + 0x58, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x280);
    memoryASet32(ds, r32[edi] + 0xa8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x290);
    memoryASet32(ds, r32[edi] + 0xac, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x3c0);
    memoryASet32(ds, r32[edi] + 0xfc, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x3d0);
    memoryASet32(ds, r32[edi] + 0x100, r32[eax]);
    r32[ebx] += 0x00000500;
    r32[edi] += 0x00000150;
    r32[ebp] -= 0x00000004;
    if (r32[ebp])
        { pc = 0x1a9f25; break; }
    { pc = 0x1a9e70; break; }
  case 0x1a9f87: // 0160:1a9f87
    if (!(r32[ebp] & 0x00000003))
        { pc = 0x1a9faa; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[esi] += 0x00000140;
    r32[edi] += 0x00000054;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1a9f87; break; }
    { pc = 0x1a9e70; break; }
  case 0x1a9faa: // 0160:1a9faa
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x10);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x140);
    memoryASet32(ds, r32[edi] + 0x54, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x150);
    memoryASet32(ds, r32[edi] + 0x58, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x280);
    memoryASet32(ds, r32[edi] + 0xa8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x290);
    memoryASet32(ds, r32[edi] + 0xac, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x3c0);
    memoryASet32(ds, r32[edi] + 0xfc, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x3d0);
    memoryASet32(ds, r32[edi] + 0x100, r32[eax]);
    r32[esi] += 0x00000500;
    r32[edi] += 0x00000150;
    r32[ebp] -= 0x00000004;
    if (r32[ebp])
        { pc = 0x1a9faa; break; }
    { pc = 0x1a9e70; break; }
    return;
  }
}
function* sub_1aa00c() // 0160:1aa00c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x2eeb78, r32[edx]);
    memoryASet32(ds, 0x2eeb74, r32[ebx]);
    r32[edx] = 0x00000020;
    r32[edx] -= r32[eax];
    r8[bl] = 0x0a;
    mul8(r8[bl]);
    r32[ebp] = r32[eax];
  case 0x1aa025: // 0160:1aa025
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r8[bl] = memoryAGet(ds, r32[eax] + 0x30acec);
    memoryASet(ds, 0x2eeb84, r8[bl]);
    if (r8[bl] == 0x02)
        { pc = 0x1aa076; break; }
    r32[ebx] = r32[eax];
    r32[ebx] <<= 7;
    r32[ebx] += 0x00000020;
    r32[ebx] -= r32[edx];
    r32[ebx] += 0x002eecec;
    memoryASet32(ds, 0x2eeb58, r32[ebx]);
    r32[ebx] = 0x0000000a;
    div8(r8[bl]);
    r32[eax] >>>= 8;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[ebx] -= r32[eax];
    r32[ebx] <<= 5;
    r32[ebx] += r32[eax];
    r32[ebx] += r32[ebp];
    r32[ebx] <<= 5;
    r32[ebx] += memoryAGet32(ds, 0x2eeb8c);
    r32[ebx] += memoryAGet32(ds, 0x2eeb74);
  case 0x1aa076: // 0160:1aa076
    r32[esi] += 0x00000002;
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1aa08d; break; }
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
  case 0x1aa08d: // 0160:1aa08d
    r32[ebx] += 0x00000314;
    memoryASet32(ds, 0x2eeb60, r32[esi]);
    r32[esi] = 0x00000020;
    r32[esi] -= r32[edx];
    r32[esi] <<= 6;
    r32[eax] = r32[esi];
    r32[esi] <<= 2;
    r32[esi] += r32[eax];
    r32[esi] += memoryAGet32(ds, 0x2eeb74);
    r32[esi] += memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x0003ebd4;
    flags.carry = r32[ecx] < r32[edx];
    r32[ecx] -= r32[edx];
    if (!flags.carry)
        { pc = 0x1aa0c4; break; }
    r32[edx] += r32[ecx];
    r32[ecx] = 0;
  case 0x1aa0c4: // 0160:1aa0c4
    memoryASet32(ds, 0x2eeb6c, r32[edi]);
    memoryASet32(ds, 0x2eeb70, r32[edx]);
    r16[ax] = 0x0102;
  case 0x1aa0d4: // 0160:1aa0d4
    memoryASet32(ds, 0x2eeb5c, r32[esi]);
    memoryASet32(ds, 0x2eeb64, r32[ebx]);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[ebp] = memoryAGet32(ds, 0x2eeb70);
    r32[edx] = memoryAGet32(ds, 0x2eeb58);
    if (memoryAGet(ds, 0x2eeb84) == 0x01)
        { pc = 0x1aa1b3; break; }
    if (memoryAGet(ds, 0x2eeb84) == 0x02)
        { pc = 0x1aa208; break; }
    if (!(memoryAGet(ds, 0x2eeb74) & 0x10))
        { pc = 0x1aa145; break; }
  case 0x1aa11a: // 0160:1aa11a
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[eax] &= 0x000000f0;
    r32[eax] >>>= 2;
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x1f1c68);
    r32[eax] &= memoryAGet32(ds, r32[esi]);
    r32[eax] |= memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[edx]++;
    r32[edi] += 0x00000054;
    r32[esi] += 0x00000140;
    r32[ebx] += 0x00000140;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa11a; break; }
    { pc = 0x1aa16a; break; }
  case 0x1aa145: // 0160:1aa145
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[eax] &= 0x0000000f;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x1f1c68);
    r32[eax] &= memoryAGet32(ds, r32[esi]);
    r32[eax] |= memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[edx]++;
    r32[edi] += 0x00000054;
    r32[esi] += 0x00000140;
    r32[ebx] += 0x00000140;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa145; break; }
  case 0x1aa16a: // 0160:1aa16a
    r32[eax] = memoryAGet32(ds, 0x2eeb54);
    r8[ah] += r8[ah];
    if (r8[ah] >= 0x10)
        { pc = 0x1aa19f; break; }
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    r32[esi] = memoryAGet32(ds, 0x2eeb5c);
    r32[esi] += 0x00000004;
    r32[ebx] = memoryAGet32(ds, 0x2eeb64);
    r32[ebx] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb58, memoryAGet32(ds, 0x2eeb58) + 0x00000020);
    { pc = 0x1aa0d4; break; }
  case 0x1aa19f: // 0160:1aa19f
    r32[esi] = memoryAGet32(ds, 0x2eeb60);
    r32[edx] = 0x00000020;
    if (r32[ecx])
        { pc = 0x1aa025; break; }
    r32[esp] += 4; return;
  case 0x1aa1b3: // 0160:1aa1b3
    if (!(r32[ebp] & 0x00000003))
        { pc = 0x1aa1cd; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[ebx] += 0x00000140;
    r32[edi] += 0x00000054;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa1b3; break; }
    { pc = 0x1aa16a; break; }
  case 0x1aa1cd: // 0160:1aa1cd
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x140);
    memoryASet32(ds, r32[edi] + 0x54, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x280);
    memoryASet32(ds, r32[edi] + 0xa8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x3c0);
    memoryASet32(ds, r32[edi] + 0xfc, r32[eax]);
    r32[ebx] += 0x00000500;
    r32[edi] += 0x00000150;
    r32[ebp] -= 0x00000004;
    if (r32[ebp])
        { pc = 0x1aa1cd; break; }
    { pc = 0x1aa16a; break; }
  case 0x1aa208: // 0160:1aa208
    if (!(r32[ebp] & 0x00000003))
        { pc = 0x1aa225; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000140;
    r32[edi] += 0x00000054;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa208; break; }
    { pc = 0x1aa16a; break; }
  case 0x1aa225: // 0160:1aa225
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x140);
    memoryASet32(ds, r32[edi] + 0x54, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x280);
    memoryASet32(ds, r32[edi] + 0xa8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x3c0);
    memoryASet32(ds, r32[edi] + 0xfc, r32[eax]);
    r32[esi] += 0x00000500;
    r32[edi] += 0x00000150;
    r32[ebp] -= 0x00000004;
    if (r32[ebp])
        { pc = 0x1aa225; break; }
    { pc = 0x1aa16a; break; }
    return;
  }
}
function* sub_1aa260() // 0160:1aa260 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x2eeb78, r32[edx]);
    memoryASet32(ds, 0x2eeb80, r32[eax]);
    r8[al] &= 0x0f;
    r32[edx] = 0x00000010;
    r32[edx] -= r32[eax];
    r8[bl] = 0x0a;
    mul8(r8[bl]);
    r32[ebp] = r32[eax];
  case 0x1aa27a: // 0160:1aa27a
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r8[bl] = memoryAGet(ds, r32[eax] + 0x30acec);
    memoryASet(ds, 0x2eeb84, r8[bl]);
    if (r8[bl] == 0x02)
        { pc = 0x1aa2c5; break; }
    r32[ebx] = r32[eax];
    r32[ebx] <<= 7;
    r32[ebx] += 0x00000010;
    r32[ebx] -= r32[edx];
    r32[ebx] += 0x002eecec;
    memoryASet32(ds, 0x2eeb58, r32[ebx]);
    r32[ebx] = 0x0000000a;
    div8(r8[bl]);
    r32[eax] >>>= 8;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[ebx] -= r32[eax];
    r32[ebx] <<= 5;
    r32[ebx] += r32[eax];
    r32[ebx] += r32[ebp];
    r32[ebx] <<= 5;
    r32[ebx] += memoryAGet32(ds, 0x2eeb8c);
  case 0x1aa2c5: // 0160:1aa2c5
    r32[esi] += 0x00000002;
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1aa2dc; break; }
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
    r32[esi] -= memoryAGet32(ds, 0x1f1cb4);
  case 0x1aa2dc: // 0160:1aa2dc
    r32[ebx] += 0x00000314;
    memoryASet32(ds, 0x2eeb60, r32[esi]);
    r32[esi] = memoryAGet32(ds, 0x2eeb80);
    r32[eax] = 0x00000010;
    r32[eax] &= r32[esi];
    r8[al] ^= 0x10;
    memoryASet32(ds, 0x2eeb80, r32[eax]);
    r32[esi] <<= 6;
    r32[eax] = r32[esi];
    r32[esi] <<= 2;
    r32[esi] += r32[eax];
    r32[esi] += memoryAGet32(ds, 0x2eeb74);
    r32[esi] += memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x0003ebd4;
    flags.carry = r32[ecx] < r32[edx];
    r32[ecx] -= r32[edx];
    if (!flags.carry)
        { pc = 0x1aa320; break; }
    r32[edx] += r32[ecx];
    r32[ecx] = 0;
  case 0x1aa320: // 0160:1aa320
    memoryASet32(ds, 0x2eeb6c, r32[edi]);
    memoryASet32(ds, 0x2eeb70, r32[edx]);
    r16[ax] = 0x0102;
  case 0x1aa330: // 0160:1aa330
    memoryASet32(ds, 0x2eeb5c, r32[esi]);
    memoryASet32(ds, 0x2eeb64, r32[ebx]);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[ebp] = memoryAGet32(ds, 0x2eeb70);
    r32[edx] = memoryAGet32(ds, 0x2eeb58);
    if (memoryAGet(ds, 0x2eeb84) == 0x01)
        { pc = 0x1aa3d7; break; }
    if (memoryAGet(ds, 0x2eeb84) == 0x02)
        { pc = 0x1aa42c; break; }
  case 0x1aa369: // 0160:1aa369
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[eax] &= 0x0000000f;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x1f1c68);
    r32[eax] &= memoryAGet32(ds, r32[esi]);
    r32[eax] |= memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[edx]++;
    r32[edi] += 0x00000054;
    r32[esi] += 0x00000140;
    r32[ebx] += 0x00000140;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa369; break; }
  case 0x1aa38e: // 0160:1aa38e
    r32[eax] = memoryAGet32(ds, 0x2eeb54);
    r8[ah] += r8[ah];
    if (r8[ah] >= 0x10)
        { pc = 0x1aa3c3; break; }
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    r32[esi] = memoryAGet32(ds, 0x2eeb5c);
    r32[esi] += 0x00000004;
    r32[ebx] = memoryAGet32(ds, 0x2eeb64);
    r32[ebx] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb58, memoryAGet32(ds, 0x2eeb58) + 0x00000020);
    { pc = 0x1aa330; break; }
  case 0x1aa3c3: // 0160:1aa3c3
    r32[esi] = memoryAGet32(ds, 0x2eeb60);
    r32[edx] = 0x00000010;
    if (r32[ecx])
        { pc = 0x1aa27a; break; }
    r32[esp] += 4; return;
  case 0x1aa3d7: // 0160:1aa3d7
    if (!(r32[ebp] & 0x00000003))
        { pc = 0x1aa3f1; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[ebx] += 0x00000140;
    r32[edi] += 0x00000054;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa3d7; break; }
    { pc = 0x1aa38e; break; }
  case 0x1aa3f1: // 0160:1aa3f1
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x140);
    memoryASet32(ds, r32[edi] + 0x54, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x280);
    memoryASet32(ds, r32[edi] + 0xa8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x3c0);
    memoryASet32(ds, r32[edi] + 0xfc, r32[eax]);
    r32[ebx] += 0x00000500;
    r32[edi] += 0x00000150;
    r32[ebp] -= 0x00000004;
    if (r32[ebp])
        { pc = 0x1aa3f1; break; }
    { pc = 0x1aa38e; break; }
  case 0x1aa42c: // 0160:1aa42c
    if (!(r32[ebp] & 0x00000003))
        { pc = 0x1aa449; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000140;
    r32[edi] += 0x00000054;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1aa42c; break; }
    { pc = 0x1aa38e; break; }
  case 0x1aa449: // 0160:1aa449
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x140);
    memoryASet32(ds, r32[edi] + 0x54, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x280);
    memoryASet32(ds, r32[edi] + 0xa8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x3c0);
    memoryASet32(ds, r32[edi] + 0xfc, r32[eax]);
    r32[esi] += 0x00000500;
    r32[edi] += 0x00000150;
    r32[ebp] -= 0x00000004;
    if (r32[ebp])
        { pc = 0x1aa449; break; }
    { pc = 0x1aa38e; break; }
    return;
  }
}
function* sub_1aa484() // 0160:1aa484 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    push32(r32[eax]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    r32[ebx] = pop32();
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[eax] = 0x0023f52c;
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[edx] = r32[eax];
    push32(r32[edx]);
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ebx] = pop32();
    r32[eax] = 0x00003e00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ecx] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4; return;
    // gap 123647 bytes // gap 123647 bytes
  case 0x1c87e8: // 0160:1c87e8
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    push32(r32[eax]);
    r32[eax] = 0x0020aaa8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
    yield* sub_1e3645();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e3663();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1aa4e9() // 0160:1aa4e9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x20ce9d, r32[eax]);
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    push32(r32[eax]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    r32[ebx] = pop32();
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[eax] = memoryAGet32(ds, 0x20ce9d);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[edx] = r32[eax];
    push32(r32[edx]);
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ebx] = pop32();
    r32[eax] = 0x00003e00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c87e8; break; }
    r32[ecx] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4; return;
    // gap 123541 bytes // gap 123541 bytes
  case 0x1c87e8: // 0160:1c87e8
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    push32(r32[eax]);
    r32[eax] = 0x0020aaa8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
    yield* sub_1e3645();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e3663();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1aa553() // 0160:1aa553 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push(r16[ax]);
    r32[esi] = 0x0023f52c;
    r32[edx] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[bx]++;
    mul16(r16[bx]);
    r32[edx] <<= 16;
    r32[eax] &= 0x0000ffff;
    r32[eax] |= r32[edx];
    r32[ecx] = r32[eax];
    r32[esi] = 0x0023f5ac;
  case 0x1aa580: // 0160:1aa580
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xc0)
        { pc = 0x1aa598; break; }
    r8[al] -= 0xc0;
    r32[esi]++;
    r8[bl] = memoryAGet(ds, r32[esi]);
  case 0x1aa58b: // 0160:1aa58b
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1aa59f; break; }
    r8[al]--;
    if (r8[al])
        { pc = 0x1aa58b; break; }
    r32[esi]++;
    { pc = 0x1aa580; break; }
  case 0x1aa598: // 0160:1aa598
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1aa580; break; }
    r32[esi]--;
  case 0x1aa59f: // 0160:1aa59f
    r32[esi]++;
    r16[ax] = pop();
    if (!r16[ax])
        { pc = 0x1aa5d2; break; }
    r32[esi]++;
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000014;
    r32[ecx] = 0x00000100;
  case 0x1aa5ba: // 0160:1aa5ba
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1aa5ba; break; }
  case 0x1aa5d2: // 0160:1aa5d2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1aa5d3() // 0160:1aa5d3 +long
{
    r32[esp] -= 4;
    interrupt(0x10);
    r32[esp] += 4;
}
function* sub_1aa5d6() // 0160:1aa5d6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edx]);
    push32(r32[ecx]);
    push32(r32[edi]);
    r32[esi] = r32[eax];
    r16[dx] = 0x03c8;
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r32[ecx] = 0x00000100;
    r32[edi] = 0x0020c88f;
  case 0x1aa5ef: // 0160:1aa5ef
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1aa5ef; break; }
    memoryASet(ds, 0x20c88f, 0x00);
    memoryASet(ds, 0x20c890, 0x00);
    memoryASet(ds, 0x20c891, 0x00);
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1aa645; break; }
    r32[esi] = 0x001ecaa8;
    r32[edi] = 0x0020ca0f;
    r32[ecx] = 0x00000030;
  case 0x1aa63d: // 0160:1aa63d
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1aa63d; break; }
  case 0x1aa645: // 0160:1aa645
    r32[edi] = pop32();
    r32[ecx] = pop32();
    r32[edx] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1aa64a() // 0160:1aa64a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 120019 bytes // gap 120019 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1aa9d7() // 0160:1aa9d7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ed0a1;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0023f52c;
    r32[ecx] = 0x00002ed4;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (r32[eax] != 0x00002ed4)
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1c1e87; break; }
    // gap 95298 bytes // gap 95298 bytes
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1aafe3() // 0160:1aafe3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    yield* sub_1ab386();
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    yield* sub_1ab386();
    if (signed16(memoryAGet16(ds, 0x20e90d)) < signed16(0x0003))
        { pc = 0x1ab023; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    yield* sub_1ab386();
    if (memoryAGet16(ds, 0x20e90d) != 0x0004)
        { pc = 0x1ab023; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    yield* sub_1ab386();
  case 0x1ab023: // 0160:1ab023
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1ab0d4; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b7);
    if (r16[ax] == 0x0001)
        { pc = 0x1ab089; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e843, r16[ax]);
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20e845, r16[ax]);
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
    r16[di] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e847, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20e849, r16[di]);
    { pc = 0x1ab385; break; }
  case 0x1ab089: // 0160:1ab089
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e843, r16[ax]);
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20e845, r16[ax]);
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
    r16[di] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e847, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20e849, r16[di]);
    { pc = 0x1ab385; break; }
  case 0x1ab0d4: // 0160:1ab0d4
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] == 0x0002)
        { pc = 0x1ab33a; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1ab2af; break; }
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1ab183; break; }
    r16[ax] = memoryAGet16(ds, 0x20ce93);
    if (r16s[ax] >= signed16(0x0004))
        { pc = 0x1ab146; break; }
    r16[di] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e843, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20e845, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e847, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20e849, r16[di]);
    { pc = 0x1ab385; break; }
  case 0x1ab146: // 0160:1ab146
    r16[di] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e843, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20e845, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e847, r16[di]);
    r16[di] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20e849, r16[di]);
    { pc = 0x1ab385; break; }
  case 0x1ab183: // 0160:1ab183
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20ce95);
    r16[cx] = memoryAGet16(ds, 0x20ce97);
    r16[dx] = memoryAGet16(ds, 0x20ce99);
    r16[bp] = memoryAGet16(ds, 0x20ce9b);
  case 0x1ab1cf: // 0160:1ab1cf
    if (r16s[cx] > r16s[bx])
        { pc = 0x1ab228; break; }
    if (r16s[dx] > r16s[cx])
        { pc = 0x1ab203; break; }
    if (r16s[bp] <= r16s[dx])
        { pc = 0x1ab24d; break; }
    r16[ax] = r16[dx];
    r16[dx] = r16[bp];
    r16[bp] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb9);
    r16[di] = memoryAGet16(ds, 0x20cebb);
    memoryASet16(ds, 0x20ceb9, r16[di]);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    { pc = 0x1ab1cf; break; }
  case 0x1ab203: // 0160:1ab203
    r16[ax] = r16[cx];
    r16[cx] = r16[dx];
    r16[dx] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[di] = memoryAGet16(ds, 0x20ceb9);
    memoryASet16(ds, 0x20ceb7, r16[di]);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    { pc = 0x1ab1cf; break; }
  case 0x1ab228: // 0160:1ab228
    r16[ax] = r16[bx];
    r16[bx] = r16[cx];
    r16[cx] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb5);
    r16[di] = memoryAGet16(ds, 0x20ceb7);
    memoryASet16(ds, 0x20ceb5, r16[di]);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    { pc = 0x1ab1cf; break; }
  case 0x1ab24d: // 0160:1ab24d
    r16[ax] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20e843, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    memoryASet16(ds, 0x20e845, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb9);
    memoryASet16(ds, 0x20e847, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cebb);
    memoryASet16(ds, 0x20e849, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] = 0x0014;
    yield* sub_1ab3d2();
    r16[ax] = memoryAGet16(ds, 0x20ceb9);
    r16[bx] = 0x000a;
    yield* sub_1ab3d2();
    { pc = 0x1ab385; break; }
  case 0x1ab2af: // 0160:1ab2af
    r16[bp] = memoryAGet16(ds, 0x20e8e1);
    r16[si] = memoryAGet16(ds, 0x20e8e7);
    r16[di] = memoryAGet16(ds, 0x20e8ed);
    r16[bx] = memoryAGet16(ds, 0x20ce95);
    r16[cx] = memoryAGet16(ds, 0x20ce97);
    r16[dx] = memoryAGet16(ds, 0x20ce99);
  case 0x1ab2d9: // 0160:1ab2d9
    if (r16s[cx] > r16s[bx])
        { pc = 0x1ab2f7; break; }
    if (r16s[dx] <= r16s[cx])
        { pc = 0x1ab30b; break; }
    r16[ax] = r16[cx];
    r16[cx] = r16[dx];
    r16[dx] = r16[ax];
    r16[ax] = r16[si];
    r16[si] = r16[di];
    r16[di] = r16[ax];
    { pc = 0x1ab2d9; break; }
  case 0x1ab2f7: // 0160:1ab2f7
    r16[ax] = r16[bx];
    r16[bx] = r16[cx];
    r16[cx] = r16[ax];
    r16[ax] = r16[bp];
    r16[bp] = r16[si];
    r16[si] = r16[ax];
    { pc = 0x1ab2d9; break; }
  case 0x1ab30b: // 0160:1ab30b
    memoryASet16(ds, 0x20e843, r16[di]);
    memoryASet16(ds, 0x20e845, r16[si]);
    memoryASet16(ds, 0x20e847, r16[bp]);
    r16[ax] = r16[di];
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
    r16[ax] = r16[si];
    r16[bx] = 0x000f;
    yield* sub_1ab3d2();
    { pc = 0x1ab385; break; }
  case 0x1ab33a: // 0160:1ab33a
    if (memoryAGet16(ds, 0x20d7b7) == 0x0001)
        { pc = 0x1ab35e; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e843, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e845, r16[ax]);
    { pc = 0x1ab376; break; }
  case 0x1ab35e: // 0160:1ab35e
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e843, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e845, r16[ax]);
  case 0x1ab376: // 0160:1ab376
    r16[ax] = memoryAGet16(ds, 0x20e843);
    r16[bx] = 0x001e;
    yield* sub_1ab3d2();
  case 0x1ab385: // 0160:1ab385
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ab386() // 0160:1ab386 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x002247ae;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[cx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[cx];
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    if (r16[cx] != 0x00ff)
        { pc = 0x1ab3c3; break; }
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    if (r16[cx] != 0x00ff)
        { pc = 0x1ab3c3; break; }
    memoryASet16(ds, r32[esi] + r32[eax], 0x0000);
    memoryASet16(ds, r32[esi] + r32[eax] + 0x2, 0x0000);
  case 0x1ab3c3: // 0160:1ab3c3
    if (memoryAGet16(ds, r32[esi] + r32[eax] + 0x2) == 0x0063)
        { pc = 0x1ab3d1; break; }
    memoryASet16(ds, r32[esi] + r32[eax] + 0x2, memoryAGet16(ds, r32[esi] + r32[eax] + 0x2) + 0x0001);
  case 0x1ab3d1: // 0160:1ab3d1
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ab3d2() // 0160:1ab3d2 +long
{
    r32[esp] -= 4;
    push32(r32[esi]);
    r32[esi] = 0x002247ae;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + r16[bx]);
    r32[esi] = pop32();
    r32[esp] += 4;
}
function* sub_1abb6f() // 0160:1abb6f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001ec0bc;
    memoryASet16(ds, 0x20ec9d, 0x0000);
  case 0x1abb7d: // 0160:1abb7d
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[bx] = 0;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]); // level name offset for duel, eax =0,1,2...
    memoryASet16(ds, 0x20d7b9, r16[bx]);
    push32(r32[esi]);
    memoryASet16(ds, 0x20eca9, 0x0001);
    yield* sub_1b8253();
    r32[esi] = pop32();
    if (memoryAGet16(ds, 0x20ee81) == 0x0001)
        { pc = 0x1bb88b; break; }
    memoryASet16(ds, 0x20ec9d, 0x0001);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1abbd2; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (!r8[al])
        { pc = 0x1abc10; break; }
  case 0x1abbd2: // 0160:1abbd2
    r16[ax] = memoryAGet16(ds, 0x20ecab);
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + r16[ax]);
    if (memoryAGet16(ds, 0x20ec8f) & 32768)
        { pc = 0x1abc02; break; }
    if (memoryAGet16(ds, 0x20ec8f) != 0x001b)
        { pc = 0x1abb7d; break; }
    memoryASet16(ds, 0x20ec8f, 0x0000);
    { pc = 0x1abb7d; break; }
  case 0x1abc02: // 0160:1abc02
    memoryASet16(ds, 0x20ec8f, 0x001a);
    { pc = 0x1abb7d; break; }
  case 0x1abc10: // 0160:1abc10
    r32[esp] += 4; return;
    // gap 64634 bytes // gap 64634 bytes
  case 0x1bb88b: // 0160:1bb88b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1abc11() // 0160:1abc11 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1abc93(); // main game loop
    memoryASet16(ds, 0x2231d0, 0x0000);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0000);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x224644, 0x0000);
    if (memoryAGet16(ds, 0x20ee5b) == 0x0001)
        { pc = 0x1abc92; break; }
    r32[eax] = 0x000000ff;
    if (memoryAGet32(ds, 0x30b13c) == 0x00000001)
        { pc = 0x1abc6e; break; }
    r32[eax] = 0x000000a0;
    if (memoryAGet32(ds, 0x30b13c) == 0x00000002)
        { pc = 0x1abc6e; break; }
    r32[eax] = 0x00000050;
  case 0x1abc6e: // 0160:1abc6e
    memoryASet32(ds, 0x30b144, r32[eax]);
    push32(r32[eax]);
  case 0x1abc74: // 0160:1abc74
    yield* sub_1ad600();
    yield* sub_1c86d0();
    memoryASet32(ds, 0x30b144, memoryAGet32(ds, 0x30b144) - 0x00000005);
    if (signed32(memoryAGet32(ds, 0x30b144)) >= 0)
        { pc = 0x1abc74; break; }
    r32[eax] = pop32();
    memoryASet32(ds, 0x30b144, r32[eax]);
    { pc = 0x1c8704; break; }
  case 0x1abc92: // 0160:1abc92
    r32[esp] += 4; return;
    // gap 117361 bytes // gap 117361 bytes
  case 0x1c8704: // 0160:1c8704
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8724; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c8726; break; }
  case 0x1c8724: // 0160:1c8724
    { pc = 0x1c872b; break; }
  case 0x1c8726: // 0160:1c8726
    yield* sub_1e0d80();
  case 0x1c872b: // 0160:1c872b
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1abc93() // 0160:1abc93 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4eda();
    yield* sub_1b0063();
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1abcd5; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1abcd5; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1abcd5; break; }
  case 0x1abcbe: // 0160:1abcbe
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
    r32[eax] -= memoryAGet32(ds, 0x20ee7b);
    if (r32s[eax] < signed32(0x0000008c))
        { pc = 0x1abcbe; break; }
    yield* sub_1c79ac();
  case 0x1abcd5: // 0160:1abcd5
    yield* sub_1ac7de();
    if (memoryAGet16(ds, 0x20ee5b) == 0x0001)
        { pc = 0x1abd39; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1abd39; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
  case 0x1abcf5: // 0160:1abcf5
    if (r16s[ax] < signed16(0x0005))
        { pc = 0x1abd01; break; }
    r16[ax] -= 0x0005;
    { pc = 0x1abcf5; break; }
  case 0x1abd01: // 0160:1abd01
    if (!r16[ax])
        { pc = 0x1abd34; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1abd2d; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1abd26; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1abd1f; break; }
    yield* sub_1c8664();
    { pc = 0x1abd39; break; }
  case 0x1abd1f: // 0160:1abd1f
    yield* sub_1c85f8();
    { pc = 0x1abd39; break; }
  case 0x1abd26: // 0160:1abd26
    yield* sub_1c858c();
    { pc = 0x1abd39; break; }
  case 0x1abd2d: // 0160:1abd2d
    yield* sub_1c8520();
    { pc = 0x1abd39; break; }
  case 0x1abd34: // 0160:1abd34
    yield* sub_1c84b4();
  case 0x1abd39: // 0160:1abd39
    if (memoryAGet16(ds, 0x20ee5b))
        { pc = 0x1abd5e; break; }
    if (signed16(memoryAGet16(ds, 0x20ee77)) >= signed16(0x0003))
        { pc = 0x1abd59; break; }
    memoryASet32(ds, 0x2246cc, 0x00000001);
    { pc = 0x1abd5e; break; }
  case 0x1abd59: // 0160:1abd59
    yield* sub_1b4f0e();
  case 0x1abd5e: // 0160:1abd5e
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    memoryASet16(ds, 0x20ee51, r16[ax]);
    push32(r32[eax]);
    yield* sub_1a8d10();
    memoryASet32(ds, 0x20c80c, 0x00000000);
    yield* sub_1ad031();
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    yield* sub_1b1ca2();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20ee4f, r16[ax]);
    yield* sub_1abe5b();
    if (!r16[ax])
        { pc = 0x1abda6; break; }
    r32[eax] = pop32();
    { pc = 0x1abe5a; break; }
  case 0x1abda6: // 0160:1abda6
    yield* sub_1a8c90();
    r32[eax] = pop32();
  case 0x1abdac: // 0160:1abdac
    r16[bx] = memoryAGet16(ds, 0x20ee4f);
    r16[bx] -= r16[ax];
    if (!r16[bx])
        { pc = 0x1abdf5; break; }
    r16[bx]--;
    if (!r16[bx])
        { pc = 0x1abdf5; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    memoryASet16(ds, 0x20ee59, 0x0001);
    r32[ecx] = 0;
    r16[cx] = r16[bx];
  case 0x1abdd9: // 0160:1abdd9
    push32(r32[ecx]);
    yield* sub_1abe5b();
    if (!r16[ax])
        { pc = 0x1abdef; break; }
    r32[ecx] = pop32();
    r32[eax] = pop32();
    { pc = 0x1abe5a; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1abdef: // 0160:1abdef
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1abdd9; break; }
    r32[eax] = pop32();
    { pc = 0x1abdac; break; }
  case 0x1abdf5: // 0160:1abdf5
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    r16[ax] -= memoryAGet16(ds, 0x20ee51);
    memoryASet16(ds, 0x20ee57, r16[ax]);
    memoryASet16(ds, 0x20ee59, 0x0000);
    if (!memoryAGet32(ds, 0x2246cc))
        { pc = 0x1abe4c; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1abe4c; break; }
    memoryASet32(ds, 0x2246cc, memoryAGet32(ds, 0x2246cc) + 1);
    if (memoryAGet32(ds, 0x2246cc) != 0x00000008)
        { pc = 0x1abe4c; break; }
    memoryASet32(ds, 0x2246cc, 0x00000001);
    yield* sub_1cea28();
    memoryASet32(ds, 0x2246cc, 0x00000000);
  case 0x1abe4c: // 0160:1abe4c
    if (memoryAGet16(ds, 0x20ee5b) != 0x0001)
        { pc = 0x1abd5e; break; }
  case 0x1abe5a: // 0160:1abe5a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1abd5e() // 0160:1abd5e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1abd5e: // 0160:1abd5e
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    memoryASet16(ds, 0x20ee51, r16[ax]);
    push32(r32[eax]);
    yield* sub_1a8d10();
    memoryASet32(ds, 0x20c80c, 0x00000000);
    yield* sub_1ad031();
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    yield* sub_1b1ca2();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20ee4f, r16[ax]);
    yield* sub_1abe5b();
    if (!r16[ax])
        { pc = 0x1abda6; break; }
    r32[eax] = pop32();
    { pc = 0x1abe5a; break; }
  case 0x1abda6: // 0160:1abda6
    yield* sub_1a8c90();
    r32[eax] = pop32();
  case 0x1abdac: // 0160:1abdac
    r16[bx] = memoryAGet16(ds, 0x20ee4f);
    r16[bx] -= r16[ax];
    if (!r16[bx])
        { pc = 0x1abdf5; break; }
    r16[bx]--;
    if (!r16[bx])
        { pc = 0x1abdf5; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    memoryASet16(ds, 0x20ee59, 0x0001);
    r32[ecx] = 0;
    r16[cx] = r16[bx];
  case 0x1abdd9: // 0160:1abdd9
    push32(r32[ecx]);
    yield* sub_1abe5b();
    if (!r16[ax])
        { pc = 0x1abdef; break; }
    r32[ecx] = pop32();
    r32[eax] = pop32();
    { pc = 0x1abe5a; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1abdef: // 0160:1abdef
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1abdd9; break; }
    r32[eax] = pop32();
    { pc = 0x1abdac; break; }
  case 0x1abdf5: // 0160:1abdf5
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    r16[ax] -= memoryAGet16(ds, 0x20ee51);
    memoryASet16(ds, 0x20ee57, r16[ax]);
    memoryASet16(ds, 0x20ee59, 0x0000);
    if (!memoryAGet32(ds, 0x2246cc))
        { pc = 0x1abe4c; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1abe4c; break; }
    memoryASet32(ds, 0x2246cc, memoryAGet32(ds, 0x2246cc) + 1);
    if (memoryAGet32(ds, 0x2246cc) != 0x00000008)
        { pc = 0x1abe4c; break; }
    memoryASet32(ds, 0x2246cc, 0x00000001);
    yield* sub_1cea28();
    memoryASet32(ds, 0x2246cc, 0x00000000);
  case 0x1abe4c: // 0160:1abe4c
    if (memoryAGet16(ds, 0x20ee5b) != 0x0001)
        { pc = 0x1abd5e; break; }
  case 0x1abe5a: // 0160:1abe5a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1abe5b() // 0160:1abe5b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1a8cae();
    if (!(memoryAGet16(ds, 0x20d87f) & 0xffff))
        { pc = 0x1abf18; break; }
    if (memoryAGet16(ds, 0x20d7bb) != 0xffff)
        { pc = 0x1abe86; break; }
    r16[ax] = memoryAGet16(ds, 0x20edf1);
    memoryASet16(ds, 0x20d7bb, r16[ax]);
  case 0x1abe86: // 0160:1abe86
    memoryASet(ds, 0x20c840, 0x00);
    memoryASet16(ds, 0x20d87f, memoryAGet16(ds, 0x20d87f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] >>>= 1;
    r16[ax] += 0x0054;
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] += 0x007e;
    r16[bx] -= memoryAGet16(ds, 0x20d87f);
    r16[bx] -= memoryAGet16(ds, 0x20d87f);
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[dx] >>>= 1;
    r16[dx] += 0x0094;
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1abed2; break; }
    r16[bx] = r16[dx];
  case 0x1abed2: // 0160:1abed2
    r16[cx] = 0;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    if (memoryAGet16(ds, 0x20ee35) == 0x0001)
        { pc = 0x1abf18; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1abefd; break; }
    yield* sub_1b191a();
    r8[al] = 0xa5;
    yield* sub_1b18a6();
  case 0x1abefd: // 0160:1abefd
    memoryASet16(ds, 0x20ee35, 0x0001);
    memoryASet16(ds, 0x20ee85, 0x0000);
    r16[ax] = 0x013a;
    yield* sub_1b1715();
  case 0x1abf18: // 0160:1abf18
    if (memoryAGet16(ds, 0x20eddb) & 0xffff)
        { pc = 0x1abf30; break; }
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1abf79; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1abf6f; break; }
  case 0x1abf30: // 0160:1abf30
    memoryASet16(ds, 0x20d7bf, 0x0000);
    r8[al] = 0x05;
    memoryASet(ds, 0x20d77b, r8[al]);
    memoryASet(ds, 0x20d793, r8[al]);
    r16[ax] = 0;
    memoryASet(ds, 0x20d77c, r8[al]);
    memoryASet(ds, 0x20d794, r8[al]);
    memoryASet16(ds, 0x20d77d, r16[ax]);
    memoryASet16(ds, 0x20d77f, r16[ax]);
    memoryASet16(ds, 0x20d795, r16[ax]);
    memoryASet16(ds, 0x20d797, r16[ax]);
    { pc = 0x1ac07a; break; }
  case 0x1abf6f: // 0160:1abf6f
    yield* sub_1cd896();
    yield* sub_1cd830();
  case 0x1abf79: // 0160:1abf79
    if (!(memoryAGet16(ds, 0x20d7a3) & 0xffff))
        { pc = 0x1ac028; break; }
    memoryASet16(ds, 0x20d7c1, 0x0001);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    if (signed16(memoryAGet16(ds, 0x20d7a3)) <= signed16(0x001e))
        { pc = 0x1abfad; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1abfd7; break; }
  case 0x1abfad: // 0160:1abfad
    memoryASet16(ds, 0x20d7a3, memoryAGet16(ds, 0x20d7a3) + 0x0001);
    if (memoryAGet16(ds, 0x20ee35) != 0x0001)
        { pc = 0x1abfcc; break; }
    if (memoryAGet16(ds, 0x20d7a3) != 0x015e)
        { pc = 0x1ac028; break; }
    { pc = 0x1abfd7; break; }
  case 0x1abfcc: // 0160:1abfcc
    if (memoryAGet16(ds, 0x20d7a3) != 0x00fa)
        { pc = 0x1ac028; break; }
  case 0x1abfd7: // 0160:1abfd7
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ac026; break; }
    r32[ecx] = 0x00000004;
    r16[ax] = 0;
    r32[esi] = 0x0020d1f7;
  case 0x1abfee: // 0160:1abfee
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1ac01d; break; }
    r16[bx] = 0x0001;
    r32[edi] = 0x0020d16d;
    r16[dx] = 0x0004;
  case 0x1ac002: // 0160:1ac002
    if (r16[ax] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1ac017; break; }
    r32[edi] += 0x00000002;
    r16[bx]++;
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1ac002; break; }
    r32[edi] -= 0x00000002;
  case 0x1ac017: // 0160:1ac017
    r32[edi] += 0x00000002;
    memoryASet16(ds, r32[esi], r16[bx]);
  case 0x1ac01d: // 0160:1ac01d
    r16[ax] += 0x0002;
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1abfee; break; }
  case 0x1ac026: // 0160:1ac026
    { pc = 0x1ac07a; break; }
  case 0x1ac028: // 0160:1ac028
    if (!(memoryAGet16(ds, 0x20d7b7) & 0xffff))
        { pc = 0x1ac08f; break; }
    memoryASet16(ds, 0x20d7c1, 0x0001);
    if (memoryAGet16(ds, 0x20d7a5) != 0x0005)
        { pc = 0x1ac06f; break; }
    yield* sub_1b191a();
    r8[al] = 0xa5;
    yield* sub_1b18a6();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0002)
        { pc = 0x1ac06f; break; }
    if (memoryAGet16(ds, 0x20d081) != 0x0003)
        { pc = 0x1ac06f; break; }
    r16[ax] = 0x013b;
    yield* sub_1b1715();
  case 0x1ac06f: // 0160:1ac06f
    if (signed16(memoryAGet16(ds, 0x20d7a5)) <= signed16(0x0226))
        { pc = 0x1ac08f; break; }
  case 0x1ac07a: // 0160:1ac07a
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1ac08e; break; }
    yield* sub_1b191a();
    r16[ax] = 0x0001;
  case 0x1ac08e: // 0160:1ac08e
    r32[esp] += 4; return;
  case 0x1ac08f: // 0160:1ac08f
    if (!(memoryAGet16(ds, 0x20ed7f) & 0xffff))
        { pc = 0x1ac0e8; break; }
    memoryASet16(ds, 0x20d7c1, 0x0001);
    memoryASet16(ds, 0x20ed81, memoryAGet16(ds, 0x20ed81) - 0x0001);
    if (!memoryAGet16(ds, 0x20ed81))
        { pc = 0x1ac07a; break; }
    if (memoryAGet(ds, 0x30b071))
        { pc = 0x1ac07a; break; }
    if (memoryAGet(ds, 0x30b08c))
        { pc = 0x1ac07a; break; }
    if (memoryAGet(ds, 0x30b118))
        { pc = 0x1ac07a; break; }
    if (memoryAGet(ds, 0x30b120))
        { pc = 0x1ac07a; break; }
    if (memoryAGet(ds, 0x30b11d))
        { pc = 0x1ac07a; break; }
    if (memoryAGet(ds, 0x30b11b))
        { pc = 0x1ac07a; break; }
    yield* sub_1cd100();
  case 0x1ac0e8: // 0160:1ac0e8
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1ac124; break; }
    r16[ax] = 0;
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c843, r8[al]);
  case 0x1ac124: // 0160:1ac124
    yield* sub_1cb6fa();
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1ac139; break; }
    yield* sub_1ce269();
  case 0x1ac139: // 0160:1ac139
    yield* sub_1ce6b7();
    if (memoryAGet16(ds, 0x2246cc))
        { pc = 0x1ac1fd; break; }
    yield* sub_1d0dda();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0004)
        { pc = 0x1ac17e; break; }
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1ac1f8; break; }
    yield* sub_1cc428();
    yield* sub_1cc73b();
    yield* sub_1d0261();
    { pc = 0x1ac1f8; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ac17e: // 0160:1ac17e
    if (memoryAGet16(ds, 0x20d7f5) != 0x0003)
        { pc = 0x1ac19c; break; }
    yield* sub_1cc428();
    yield* sub_1cc73b();
    yield* sub_1d03dc();
    { pc = 0x1ac1f8; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ac19c: // 0160:1ac19c
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ac1da; break; }
    yield* sub_1cc428();
    yield* sub_1cc73b();
    yield* sub_1cc7d8();
    yield* sub_1cc875();
    yield* sub_1cf9db();
    yield* sub_1cff9b();
    if (memoryAGet16(ds, 0x20d89f) & 0xffff)
        { pc = 0x1ac1f3; break; }
    yield* sub_1cfb7c();
    { pc = 0x1ac1f3; break; }
  case 0x1ac1da: // 0160:1ac1da
    yield* sub_1cc428();
    yield* sub_1cc73b();
    yield* sub_1cc7d8();
    yield* sub_1cc875();
    yield* sub_1cf9db();
  case 0x1ac1f3: // 0160:1ac1f3
    yield* sub_1d18c0();
  case 0x1ac1f8: // 0160:1ac1f8
    yield* sub_1d198c();
  case 0x1ac1fd: // 0160:1ac1fd
    if (!(memoryAGet16(ds, 0x20d2c3) & 0xffff))
        { pc = 0x1ac4ba; break; }
    memoryASet16(ds, 0x20d2c3, memoryAGet16(ds, 0x20d2c3) - 0x0001);
    if (memoryAGet16(ds, 0x20d2c3) == 0x003c)
        { pc = 0x1ac228; break; }
    if (memoryAGet16(ds, 0x20d2c3) != 0x001e)
        { pc = 0x1ac231; break; }
  case 0x1ac228: // 0160:1ac228
    r8[al] = 0xaa;
    yield* sub_1b17b7();
    { pc = 0x1ac242; break; }
  case 0x1ac231: // 0160:1ac231
    if (memoryAGet16(ds, 0x20d2c3) != 0x0001)
        { pc = 0x1ac242; break; }
    r8[al] = 0xab;
    yield* sub_1b17b7();
  case 0x1ac242: // 0160:1ac242
    if (!(memoryAGet16(ds, 0x20d2bb) & 0xffff))
        { pc = 0x1ac255; break; }
    memoryASet16(ds, 0x20d2bb, memoryAGet16(ds, 0x20d2bb) - 0x0001);
  case 0x1ac255: // 0160:1ac255
    if (!(memoryAGet16(ds, 0x20d2bd) & 0xffff))
        { pc = 0x1ac268; break; }
    memoryASet16(ds, 0x20d2bd, memoryAGet16(ds, 0x20d2bd) - 0x0001);
  case 0x1ac268: // 0160:1ac268
    if (!(memoryAGet16(ds, 0x20d2bf) & 0xffff))
        { pc = 0x1ac27b; break; }
    memoryASet16(ds, 0x20d2bf, memoryAGet16(ds, 0x20d2bf) - 0x0001);
  case 0x1ac27b: // 0160:1ac27b
    if (!(memoryAGet16(ds, 0x20d2c1) & 0xffff))
        { pc = 0x1ac28e; break; }
    memoryASet16(ds, 0x20d2c1, memoryAGet16(ds, 0x20d2c1) - 0x0001);
  case 0x1ac28e: // 0160:1ac28e
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ac29f; break; }
    memoryASet16(ds, 0x20d2bb, memoryAGet16(ds, 0x20d2bb) + 0x0002);
  case 0x1ac29f: // 0160:1ac29f
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ac2cf; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1ac2fb; break; }
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ac2c5; break; }
    memoryASet16(ds, 0x20d2bd, memoryAGet16(ds, 0x20d2bd) + 0x0002);
  case 0x1ac2c5: // 0160:1ac2c5
    if (signed16(memoryAGet16(ds, 0x20d7f5)) <= signed16(0x0002))
        { pc = 0x1ac2fb; break; }
  case 0x1ac2cf: // 0160:1ac2cf
    r8[al] = memoryAGet(ds, 0x20c842);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ac2e0; break; }
    memoryASet16(ds, 0x20d2bf, memoryAGet16(ds, 0x20d2bf) + 0x0002);
  case 0x1ac2e0: // 0160:1ac2e0
    if (signed16(memoryAGet16(ds, 0x20d7f5)) <= signed16(0x0003))
        { pc = 0x1ac2fb; break; }
    r8[al] = memoryAGet(ds, 0x20c843);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ac2fb; break; }
    memoryASet16(ds, 0x20d2c1, memoryAGet16(ds, 0x20d2c1) + 0x0002);
  case 0x1ac2fb: // 0160:1ac2fb
    if (signed16(memoryAGet16(ds, 0x20d2bb)) <= signed16(0x0032))
        { pc = 0x1ac31e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    r16[bx] = memoryAGet16(ds, 0x20cf4f);
    r16[cx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1b0c20();
  case 0x1ac31e: // 0160:1ac31e
    if (signed16(memoryAGet16(ds, 0x20d2bd)) <= signed16(0x0032))
        { pc = 0x1ac341; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf75);
    r16[bx] = memoryAGet16(ds, 0x20cf51);
    r16[cx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1b0c20();
  case 0x1ac341: // 0160:1ac341
    if (signed16(memoryAGet16(ds, 0x20d2bf)) <= signed16(0x0032))
        { pc = 0x1ac364; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf77);
    r16[bx] = memoryAGet16(ds, 0x20cf53);
    r16[cx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1b0c20();
  case 0x1ac364: // 0160:1ac364
    if (signed16(memoryAGet16(ds, 0x20d2c1)) <= signed16(0x0032))
        { pc = 0x1ac387; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf79);
    r16[bx] = memoryAGet16(ds, 0x20cf55);
    r16[cx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1b0c20();
  case 0x1ac387: // 0160:1ac387
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    memoryASet(ds, 0x20c840, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x80;
    memoryASet(ds, 0x20c841, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c842);
    r8[al] &= 0x80;
    memoryASet(ds, 0x20c842, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c843);
    r8[al] &= 0x80;
    memoryASet(ds, 0x20c843, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20d2bb);
    r16[ax] <<= 2;
    r16[ax] += memoryAGet16(ds, 0x20d2bb);
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d2bd);
    r16[ax] <<= 2;
    r16[ax] += memoryAGet16(ds, 0x20d2bd);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d2bf);
    r16[ax] <<= 2;
    r16[ax] += memoryAGet16(ds, 0x20d2bf);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d2c1);
    r16[ax] <<= 2;
    r16[ax] += memoryAGet16(ds, 0x20d2c1);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    yield* sub_1ce269();
    r16[ax] = 0;
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1ac4ba; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2bb);
    if (r16s[ax] >= signed16(0x0032))
        { pc = 0x1ac456; break; }
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    { pc = 0x1ac460; break; }
  case 0x1ac456: // 0160:1ac456
    r16[ax] -= 0x0032;
    memoryASet16(ds, 0x20d217, r16[ax]);
  case 0x1ac460: // 0160:1ac460
    r16[ax] = memoryAGet16(ds, 0x20d2bd);
    if (r16s[ax] >= signed16(0x0032))
        { pc = 0x1ac474; break; }
    memoryASet16(ds, 0x20cfab, r16[ax]);
    { pc = 0x1ac47e; break; }
  case 0x1ac474: // 0160:1ac474
    r16[ax] -= 0x0032;
    memoryASet16(ds, 0x20d219, r16[ax]);
  case 0x1ac47e: // 0160:1ac47e
    r16[ax] = memoryAGet16(ds, 0x20d2bf);
    if (r16s[ax] >= signed16(0x0032))
        { pc = 0x1ac492; break; }
    memoryASet16(ds, 0x20cfad, r16[ax]);
    { pc = 0x1ac49c; break; }
  case 0x1ac492: // 0160:1ac492
    r16[ax] -= 0x0032;
    memoryASet16(ds, 0x20d21b, r16[ax]);
  case 0x1ac49c: // 0160:1ac49c
    r16[ax] = memoryAGet16(ds, 0x20d2c1);
    if (r16s[ax] >= signed16(0x0032))
        { pc = 0x1ac4b0; break; }
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    { pc = 0x1ac4ba; break; }
  case 0x1ac4b0: // 0160:1ac4b0
    r16[ax] -= 0x0032;
    memoryASet16(ds, 0x20d21d, r16[ax]);
  case 0x1ac4ba: // 0160:1ac4ba
    r32[eax] = memoryAGet32(ds, 0x20cf0b);
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r32[esi] = 0x00231cd8;
    memoryASet32(ds, 0x20e821, r32[esi]);
    r32[esi] = 0x00200a10;
    memoryASet32(ds, 0x20e819, r32[esi]);
    if (!(memoryAGet16(ds, 0x20cf3d) & 0xffff))
        { pc = 0x1ac4ef; break; }
    yield* sub_1ad60e();
    yield* sub_1c9d42();
  case 0x1ac4ef: // 0160:1ac4ef
    if (!(memoryAGet16(ds, 0x20cf3f) & 0xffff))
        { pc = 0x1ac527; break; }
    r32[eax] = memoryAGet32(ds, 0x20cf0f);
    memoryASet32(ds, 0x20e81d, r32[eax]);
    if (memoryAGet16(ds, 0x20d89f) == 0x0001)
        { pc = 0x1ac518; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ac51d; break; }
  case 0x1ac518: // 0160:1ac518
    yield* sub_1cd1f5();
  case 0x1ac51d: // 0160:1ac51d
    yield* sub_1ad86e();
    yield* sub_1ca12c();
  case 0x1ac527: // 0160:1ac527
    if (!(memoryAGet16(ds, 0x20cf41) & 0xffff))
        { pc = 0x1ac57d; break; }
    r32[eax] = memoryAGet32(ds, 0x20cf13);
    memoryASet32(ds, 0x20e81d, r32[eax]);
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ac556; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ac556; break; }
    yield* sub_1cd336();
  case 0x1ac556: // 0160:1ac556
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1ac56a; break; }
    memoryASet16(ds, 0x20eda7, 0x0000);
  case 0x1ac56a: // 0160:1ac56a
    yield* sub_1adaba();
    yield* sub_1ca3e8();
    memoryASet16(ds, 0x20eda7, 0x0001);
  case 0x1ac57d: // 0160:1ac57d
    if (!(memoryAGet16(ds, 0x20cf43) & 0xffff))
        { pc = 0x1ac5ab; break; }
    r32[eax] = memoryAGet32(ds, 0x20cf17);
    memoryASet32(ds, 0x20e81d, r32[eax]);
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ac5a1; break; }
    yield* sub_1cd445();
  case 0x1ac5a1: // 0160:1ac5a1
    yield* sub_1add06();
    yield* sub_1ca6b3();
  case 0x1ac5ab: // 0160:1ac5ab
    yield* sub_1b1e81();
    yield* sub_1cd927();
    if (memoryAGet32(ds, 0x20d85d) == 0x00204c2a)
        { pc = 0x1ac5cc; break; }
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ac61d; break; }
  case 0x1ac5cc: // 0160:1ac5cc
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    memoryASet16(ds, 0x20c810, r16[ax]);
    memoryASet16(ds, 0x20c812, r16[bx]);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[ebx] = memoryAGet32(ds, 0x1f1c3c);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    yield* sub_1d71ce();
    r16[ax] = memoryAGet16(ds, 0x20c810);
    r16[bx] = memoryAGet16(ds, 0x20c812);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
  case 0x1ac61d: // 0160:1ac61d
    yield* sub_1c8ae0();
    if (!(memoryAGet16(ds, 0x20cf41) & 0xffff))
        { pc = 0x1ac641; break; }
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1ac641; break; }
    yield* sub_1cef93();
  case 0x1ac641: // 0160:1ac641
    if (!(memoryAGet16(ds, 0x20cf3d) & 0xffff))
        { pc = 0x1ac67b; break; }
    yield* sub_1cec8a();
    yield* sub_1cc919();
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1ac676; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] &= 0x00ff;
    if (r16[ax])
        { pc = 0x1ac676; break; }
    memoryASet16(ds, 0x20d89d, 0x0001);
  case 0x1ac676: // 0160:1ac676
    yield* sub_1caa0d();
  case 0x1ac67b: // 0160:1ac67b
    if (!(memoryAGet16(ds, 0x20cf3f) & 0xffff))
        { pc = 0x1ac695; break; }
    yield* sub_1cee0a();
    yield* sub_1cca0a();
    yield* sub_1caf91();
  case 0x1ac695: // 0160:1ac695
    if (!(memoryAGet16(ds, 0x20cf41) & 0xffff))
        { pc = 0x1ac6be; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ac6b4; break; }
    yield* sub_1cef93();
  case 0x1ac6b4: // 0160:1ac6b4
    yield* sub_1ccafb();
    yield* sub_1cb1e2();
  case 0x1ac6be: // 0160:1ac6be
    if (!(memoryAGet16(ds, 0x20cf43) & 0xffff))
        { pc = 0x1ac6d8; break; }
    yield* sub_1cf13b();
    yield* sub_1ccbec();
    yield* sub_1cb3f3();
  case 0x1ac6d8: // 0160:1ac6d8
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    memoryASet16(ds, 0x20c810, r16[ax]);
    memoryASet16(ds, 0x20c812, r16[bx]);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[ebx] = memoryAGet32(ds, 0x1f1c3c);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    yield* sub_1cfebb();
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1ac72b; break; }
    if (memoryAGet32(ds, 0x20d85d) == 0x00204c2a)
        { pc = 0x1ac72b; break; }
    yield* sub_1d71ce();
  case 0x1ac72b: // 0160:1ac72b
    yield* sub_1d1d9b();
    yield* sub_1d04a1();
    r16[ax] = memoryAGet16(ds, 0x20c810);
    r16[bx] = memoryAGet16(ds, 0x20c812);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    yield* sub_1b1113();
    yield* sub_1ac75e();
    r16[ax] = 0x0000;
    r32[esp] += 4;
    return;
  }
}
function* sub_1ac75e() // 0160:1ac75e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20ee59) & 0xffff))
        { pc = 0x1ac778; break; }
    memoryASet32(ds, 0x20c80c, 0x00000000);
    { pc = 0x1ac7d4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ac778: // 0160:1ac778
    r32[eax] = memoryAGet32(ds, 0x20c80c);
    if (!r32[eax])
        { pc = 0x1ac7d4; break; }
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) - 0x0000000c);
    r32[eax] = memoryAGet32(ds, 0x20c80c);
    r32[esi] = 0x0020c00c;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    memoryASet16(ds, 0x20ce8f, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    if (!memoryAGet16(ds, r32[esi] + 0xa))
        { pc = 0x1ac7c6; break; }
    if (memoryAGet16(ds, r32[esi] + 0xa) == 0x0001)
        { pc = 0x1ac7cd; break; }
    yield* sub_1b1b7c();
    { pc = 0x1ac7d2; break; }
  case 0x1ac7c6: // 0160:1ac7c6
    yield* sub_1b1a48();
    { pc = 0x1ac7d2; break; }
  case 0x1ac7cd: // 0160:1ac7cd
    yield* sub_1b1ad6();
  case 0x1ac7d2: // 0160:1ac7d2
    { pc = 0x1ac778; break; }
  case 0x1ac7d4: // 0160:1ac7d4
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r32[esp] += 4;
    return;
  }
}
function* sub_1ac7de() // 0160:1ac7de +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d7bb, 0x0000);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c5, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0001);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x20d7cf, 0x0014);
    memoryASet16(ds, 0x20c830, 0xfffc);
    memoryASet16(ds, 0x20ee9f, 0xfffc);
    memoryASet16(ds, 0x20eddb, 0x0000);
    memoryASet16(ds, 0x20d2c3, 0x0064);
    r32[esp] += 4;
}
function* sub_1ac839() // 0160:1ac839 +long
{
    r32[esp] -= 4;
    yield* sub_1ac863();
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0000);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x224644, 0x0000);
    r32[esp] += 4;
}
function* sub_1ac863() // 0160:1ac863 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b191a();
    r8[al] = 0x82;
    yield* sub_1b18a6();
    yield* sub_1b4eda();
    yield* sub_1b0063();
  case 0x1ac879: // 0160:1ac879
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1ac89b; break; }
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
    r32[eax] -= memoryAGet32(ds, 0x20ee7b);
    if (r32s[eax] < signed32(0x0000008c))
        { pc = 0x1ac879; break; }
    yield* sub_1c7a40();
  case 0x1ac89b: // 0160:1ac89b
    yield* sub_1b4f0e();
    memoryASet16(ds, 0x20d7bb, 0x0009);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c5, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0001);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x20d7cf, 0x0014);
    memoryASet(ds, 0x20d77c, 0x03);
    memoryASet16(ds, 0x20d877, 0x0000);
    memoryASet32(ds, 0x20d879, 0x0020d36d);
    memoryASet16(ds, 0x20d87d, 0x00c8);
    memoryASet16(ds, 0x20d87f, 0x0000);
    if (memoryAGet16(ds, 0x20d7b9) == 0x0038)
        { pc = 0x1ac920; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x003a)
        { pc = 0x1ac920; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x003b)
        { pc = 0x1ac930; break; }
  case 0x1ac920: // 0160:1ac920
    memoryASet16(ds, 0x20d869, 0x0001);
    memoryASet(ds, 0x1f1c44, 0x01);
  case 0x1ac930: // 0160:1ac930
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20d0b7, r16[ax]);
    memoryASet16(ds, 0x20d0b9, r16[bx]);
    memoryASet16(ds, 0x20d0bb, r16[ax]);
    memoryASet16(ds, 0x20d0bd, r16[bx]);
  case 0x1ac957: // 0160:1ac957
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    memoryASet16(ds, 0x20ee51, r16[ax]);
    push32(r32[eax]);
    yield* sub_1a8d10();
    memoryASet32(ds, 0x20c80c, 0x00000000);
    yield* sub_1ad031();
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    yield* sub_1b1ca2();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20ee4f, r16[ax]);
    if (memoryAGet16(ds, 0x20eddb) == 0x0001)
        { pc = 0x1ac9a3; break; }
    yield* sub_1aca1a();
    if (!r16[ax])
        { pc = 0x1ac9a9; break; }
  case 0x1ac9a3: // 0160:1ac9a3
    r32[eax] = pop32();
    { pc = 0x1aca19; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ac9a9: // 0160:1ac9a9
    yield* sub_1a8c90();
    r32[eax] = pop32();
  case 0x1ac9af: // 0160:1ac9af
    r16[bx] = memoryAGet16(ds, 0x20ee4f);
    r16[bx] -= r16[ax];
    if (!r16[bx])
        { pc = 0x1ac9f8; break; }
    r16[bx]--;
    if (!r16[bx])
        { pc = 0x1ac9f8; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    memoryASet16(ds, 0x20ee59, 0x0001);
    r32[ecx] = 0;
    r16[cx] = r16[bx];
  case 0x1ac9dc: // 0160:1ac9dc
    push32(r32[ecx]);
    yield* sub_1aca1a();
    if (!r16[ax])
        { pc = 0x1ac9f2; break; }
    r32[ecx] = pop32();
    r32[eax] = pop32();
    { pc = 0x1aca19; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ac9f2: // 0160:1ac9f2
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1ac9dc; break; }
    r32[eax] = pop32();
    { pc = 0x1ac9af; break; }
  case 0x1ac9f8: // 0160:1ac9f8
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    r16[ax] -= memoryAGet16(ds, 0x20ee51);
    memoryASet16(ds, 0x20ee57, r16[ax]);
    memoryASet16(ds, 0x20ee59, 0x0000);
    { pc = 0x1ac957; break; }
  case 0x1aca19: // 0160:1aca19
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1aca1a() // 0160:1aca1a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1aca1a; break; }
  case 0x1ac07a: // 0160:1ac07a
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1ac08e; break; }
    yield* sub_1b191a();
    r16[ax] = 0x0001;
  case 0x1ac08e: // 0160:1ac08e
    r32[esp] += 4; return;
    // gap 2443 bytes // gap 2443 bytes
  case 0x1aca1a: // 0160:1aca1a
    yield* sub_1a8cae();
    if (memoryAGet16(ds, 0x20eddb) & 0xffff)
        { pc = 0x1ac07a; break; }
    if (signed16(memoryAGet16(ds, 0x20c830)) <= signed16(0x00c8))
        { pc = 0x1aca8e; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] >>>= 8;
    r16[bx] += 0x002a;
    if (r16s[bx] <= signed16(0x003c))
        { pc = 0x1aca52; break; }
    r16[bx] = 0x003c;
  case 0x1aca52: // 0160:1aca52
    r8[al] = 0xa8;
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1aca8e; break; }
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1aca8e; break; }
    if (memoryAGet16(ds, 0x20d87f) & 0xffff)
        { pc = 0x1aca8e; break; }
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1aca85; break; }
    r8[al] = 0xa8;
    yield* sub_1b18a6();
  case 0x1aca85: // 0160:1aca85
    memoryASet16(ds, 0x20d897, 0x0001);
  case 0x1aca8e: // 0160:1aca8e
    if (!(memoryAGet16(ds, 0x20d7a3) & 0xffff))
        { pc = 0x1acab8; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    memoryASet16(ds, 0x20d7a3, memoryAGet16(ds, 0x20d7a3) + 0x0001);
    if (memoryAGet16(ds, 0x20d7a3) == 0x00fa)
        { pc = 0x1acac3; break; }
    { pc = 0x1acadb; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1acab8: // 0160:1acab8
    if (signed16(memoryAGet16(ds, 0x20d7a5)) <= signed16(0x0226))
        { pc = 0x1acadb; break; }
  case 0x1acac3: // 0160:1acac3
    if (!(memoryAGet16(ds, 0x20d7b7) & 0xffff))
        { pc = 0x1acad6; break; }
    memoryASet16(ds, 0x20e90b, memoryAGet16(ds, 0x20e90b) + 0x0001);
  case 0x1acad6: // 0160:1acad6
    r16[ax] = 0x0001;
    r32[esp] += 4; return;
  case 0x1acadb: // 0160:1acadb
    yield* sub_1cfdfb();
    if (!(memoryAGet16(ds, 0x20d87f) & 0xffff))
        { pc = 0x1acb71; break; }
    if (memoryAGet16(ds, 0x20d87f) != 0x0001)
        { pc = 0x1acb20; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x012c;
    yield* sub_1b1715();
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1acb20; break; }
    yield* sub_1b191a();
    r8[al] = 0x06;
    yield* sub_1b18a6();
  case 0x1acb20: // 0160:1acb20
    memoryASet16(ds, 0x20d87f, memoryAGet16(ds, 0x20d87f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] >>>= 1;
    r16[ax] += 0x0054;
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] += 0x007e;
    r16[bx] -= memoryAGet16(ds, 0x20d87f);
    r16[bx] -= memoryAGet16(ds, 0x20d87f);
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[dx] >>>= 1;
    r16[dx] += 0x0094;
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1acb65; break; }
    r16[bx] = r16[dx];
  case 0x1acb65: // 0160:1acb65
    r16[dx] = 0;
    r16[cx] = 0x005d;
    yield* sub_1b19e0();
  case 0x1acb71: // 0160:1acb71
    yield* sub_1ce269();
    yield* sub_1ce6b7();
    yield* sub_1d198c();
    if (!(memoryAGet16(ds, 0x20d7b7) & 0xffff))
        { pc = 0x1acc14; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    r16[bx] = 0x01f6;
    r16[ax] = memoryAGet16(ds, 0x20d7a5);
    r16[bx] -= r16[ax];
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[dx] >>>= 1;
    r16[dx] += 0x00a8;
    if (r16s[bx] > r16s[dx])
        { pc = 0x1acbba; break; }
    r16[bx] = r16[dx];
  case 0x1acbba: // 0160:1acbba
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] >>>= 1;
    r16[ax] += 0x0058;
    r16[dx] = 0x0010;
    r16[cx] = 0x005c;
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20cfa9, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1acc14; break; }
    if (memoryAGet16(ds, 0x20d06f) & 0xffff)
        { pc = 0x1acc14; break; }
    memoryASet16(ds, 0x20d06f, 0x0014);
  case 0x1acc14: // 0160:1acc14
    if (memoryAGet16(ds, 0x20d87d) & 0xffff)
        { pc = 0x1acc49; break; }
    r32[eax] = memoryAGet32(ds, 0x20cf07);
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r32[esi] = 0x00231cd8;
    memoryASet32(ds, 0x20e821, r32[esi]);
    r32[esi] = 0x00200a10;
    memoryASet32(ds, 0x20e819, r32[esi]);
    yield* sub_1ad60e();
    yield* sub_1c9d42();
  case 0x1acc49: // 0160:1acc49
    yield* sub_1b1e81();
    yield* sub_1acdb4();
    yield* sub_1cec8a();
    yield* sub_1caa0d();
    yield* sub_1ace94();
    if (memoryAGet16(ds, 0x20d87d) == 0x0001)
        { pc = 0x1acd36; break; }
    if (memoryAGet16(ds, 0x20d87d) & 0xffff)
        { pc = 0x1acd5c; break; }
    if (memoryAGet16(ds, 0x20d87f) & 0xffff)
        { pc = 0x1acd5c; break; }
    r32[esi] = memoryAGet32(ds, 0x20d879);
    r32[esi] -= 0x00000006;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] -= memoryAGet16(ds, 0x20cf4f);
    r16[ax] -= 0x0074;
    if (r16s[ax] < 0)
        { pc = 0x1acd5c; break; }
    if (r16s[ax] >= signed16(0x0020))
        { pc = 0x1acd5c; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] -= memoryAGet16(ds, 0x20cf61);
    r16[ax] -= 0x0074;
    if (r16s[ax] < 0)
        { pc = 0x1acd5c; break; }
    if (r16s[ax] >= signed16(0x0020))
        { pc = 0x1acd5c; break; }
    memoryASet16(ds, r32[esi] + 0x4, 0x0014);
    memoryASet16(ds, 0x20d877, memoryAGet16(ds, 0x20d877) + 0x0001);
    push32(r32[esi]);
    r8[al] = 0x07;
    yield* sub_1b17b7();
    r32[esi] = pop32();
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] -= 0x0080;
    r16[bx] -= 0x0080;
    r16[ax] &= 0xfff8;
    r16[bx] &= 0xfff8;
    memoryASet16(ds, 0x20d0b7, r16[ax]);
    memoryASet16(ds, 0x20d0b9, r16[bx]);
    memoryASet16(ds, 0x20d0bb, r16[ax]);
    memoryASet16(ds, 0x20d0bd, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    r16[ax] &= 0x001f;
    r16[ax] >>>= 2;
    r16[ax] <<= 8;
    memoryASet16(ds, 0x20d04b, r16[ax]);
  case 0x1acd36: // 0160:1acd36
    r32[esi] = memoryAGet32(ds, 0x20d879);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16s[ax] < 0)
        { pc = 0x1acd5c; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    if (r16[ax])
        { pc = 0x1acd5c; break; }
    memoryASet16(ds, r32[esi] + 0x4, 0x0005);
    r32[esi] += 0x00000006;
    memoryASet32(ds, 0x20d879, r32[esi]);
  case 0x1acd5c: // 0160:1acd5c
    if (memoryAGet16(ds, 0x20d877) != 0x001e)
        { pc = 0x1acdaa; break; }
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1acdaa; break; }
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1acd86; break; }
    yield* sub_1b191a();
    r8[al] = 0xa5;
    yield* sub_1b18a6();
  case 0x1acd86: // 0160:1acd86
    r16[ax] = 0x013a;
    yield* sub_1b1715();
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20d7b7, 0x0001);
  case 0x1acdaa: // 0160:1acdaa
    yield* sub_1ac75e();
    r16[ax] = 0x0000;
    r32[esp] += 4;
    return;
  }
}
function* sub_1acdb4() // 0160:1acdb4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x0096;
    r16[bx] = 0x008c;
    r16[cx] = 0x005a;
    r16[dx] = 0;
    yield* sub_1b19e0();
    r16[cx] = memoryAGet16(ds, 0x20d877);
    memoryASet16(ds, 0x20ceb3, 0x0000);
  case 0x1acdd8: // 0160:1acdd8
    if (r16s[cx] < signed16(0x000a))
        { pc = 0x1acdec; break; }
    r16[cx] -= 0x000a;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    { pc = 0x1acdd8; break; }
  case 0x1acdec: // 0160:1acdec
    r16[ax] = 0x00a8;
    r16[bx] = 0x0096;
    r16[cx] += 0x0005;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    r16[ax] = 0x009c;
    r16[bx] = 0x0096;
    r16[cx] = memoryAGet16(ds, 0x20ceb3);
    if (flags.zero)
        { pc = 0x1ace1f; break; }
    r16[cx] += 0x0005;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
  case 0x1ace1f: // 0160:1ace1f
    r16[ax] = 0x00b0;
    r16[bx] = 0x0093;
    r32[ebp] = 0;
    r32[esi] = 0x002050bc;
    r16[bp] <<= 3;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ebp]);
    r16[cx] += 0x0050;
    r16[ax] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x2);
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x4);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[ebp] + 0x6);
    r16[dx] |= 0x0010;
    yield* sub_1b19e0();
    if (!(memoryAGet16(ds, 0x20d87d) & 0xffff))
        { pc = 0x1ace93; break; }
    memoryASet16(ds, 0x20d87d, memoryAGet16(ds, 0x20d87d) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x000f;
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1ace93; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] >>>= 1;
    r16[ax] += 0x0014;
    r16[bx] = 0x0108;
    r16[dx] = 0x0010;
    r16[cx] = 0x005b;
    yield* sub_1b19e0();
  case 0x1ace93: // 0160:1ace93
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ace94() // 0160:1ace94 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020d36d;
  case 0x1ace99: // 0160:1ace99
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16s[ax] < 0)
        { pc = 0x1aceb9; break; }
    if (!(memoryAGet16(ds, r32[esi] + 0x4) & 0xffff))
        { pc = 0x1aceb4; break; }
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    push32(r32[esi]);
    yield* sub_1acec3();
    r32[esi] = pop32();
  case 0x1aceb4: // 0160:1aceb4
    r32[esi] += 0x00000006;
    { pc = 0x1ace99; break; }
  case 0x1aceb9: // 0160:1aceb9
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r32[esp] += 4;
    return;
  }
}
function* sub_1acec3() // 0160:1acec3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1aced9; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1acefc; break; }
  case 0x1aced9: // 0160:1aced9
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1aceeb; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1acefc; break; }
  case 0x1aceeb: // 0160:1aceeb
    if (r16[bx] >= 0x0160)
        { pc = 0x1acefc; break; }
    if (r16s[ax] <= signed16(0x01c0))
        { pc = 0x1acefd; break; }
  case 0x1acefc: // 0160:1acefc
    r32[esp] += 4; return;
  case 0x1acefd: // 0160:1acefd
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    if (r16[cx] == 0x0001)
        { pc = 0x1acf60; break; }
    if (r16s[cx] < signed16(0x0014))
        { pc = 0x1acf42; break; }
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0003;
    if (r16[bp])
        { pc = 0x1acf2c; break; }
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) + 0x0001);
    if (memoryAGet16(ds, r32[esi] + 0x4) != 0x0019)
        { pc = 0x1acf2c; break; }
    memoryASet16(ds, r32[esi] + 0x4, 0x0000);
  case 0x1acf2c: // 0160:1acf2c
    r16[cx] += 0x004c;
    if (r16s[cx] < signed16(0x0043))
        { pc = 0x1acfa1; break; }
    r16[dx] = 0;
    { pc = 0x1b19e0; break; }
  case 0x1acf42: // 0160:1acf42
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0003;
    if (r16[bp])
        { pc = 0x1acf54; break; }
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) - 0x0001);
  case 0x1acf54: // 0160:1acf54
    r16[cx] += 0x0060;
    r16[dx] = 0;
    { pc = 0x1b19e0; break; }
  case 0x1acf60: // 0160:1acf60
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r32[ebp] += r32[esi];
    memoryASet16(ds, 0x20ceb5, r16[bp]);
    r32[ebp] &= 0x0000003e;
    r16[bp] >>>= 1;
    r32[esi] = 0x002050bc;
    r16[bp] <<= 3;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ebp]);
    r16[cx] += 0x0050;
    r16[ax] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x2);
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x4);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[ebp] + 0x6);
    r16[dx] |= 0x0010;
    { pc = 0x1b19e0; break; }
  case 0x1acfa1: // 0160:1acfa1
    r32[esp] += 4; return;
    // gap 19006 bytes // gap 19006 bytes
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4;
    return;
  }
}
function* sub_1acfa2() // 0160:1acfa2 +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20eda1, 0x0000);
    memoryASet(ds, 0x20eda3, 0xe0);
    yield* sub_1b191a();
    r8[al] = 0x79;
    yield* sub_1b18a6();
    r16[ax] = 0;
    memoryASet16(ds, 0x20ee45, r16[ax]);
    memoryASet16(ds, 0x20edfb, r16[ax]);
    memoryASet16(ds, 0x20ed7f, r16[ax]);
    memoryASet16(ds, 0x20ee49, r16[ax]);
    memoryASet16(ds, 0x20ed81, r16[ax]);
    memoryASet16(ds, 0x20ecb9, r16[ax]);
    memoryASet16(ds, 0x20ec8f, r16[ax]);
    memoryASet16(ds, 0x20eccf, r16[ax]);
    memoryASet16(ds, 0x20d89f, r16[ax]);
    memoryASet16(ds, 0x20edef, r16[ax]);
    memoryASet16(ds, 0x20ed41, r16[ax]);
    memoryASet16(ds, 0x20eda9, r16[ax]);
    memoryASet16(ds, 0x20ee15, r16[ax]);
    memoryASet16(ds, 0x20ee33, r16[ax]);
    memoryASet16(ds, 0x20d863, r16[ax]);
    memoryASet16(ds, 0x20d7d5, r16[ax]);
    memoryASet16(ds, 0x20d89b, r16[ax]);
    memoryASet16(ds, 0x20e90b, 0x0002);
    r32[esp] += 4;
}
function* sub_1ad031() // 0160:1ad031 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0;
    memoryASet(ds, 0x20c840, r8[al]);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c843, r8[al]);
    if (memoryAGet16(ds, 0x20d89f) == 0x0001)
        { pc = 0x1ad136; break; }
    if (memoryAGet16(ds, 0x20d89b) != 0x0001)
        { pc = 0x1ad107; break; }
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1ad136; break; }
    if (memoryAGet16(ds, 0x20e90d) != 0x0002)
        { pc = 0x1ad09e; break; }
    yield* sub_1ad149();
    if (memoryAGet16(ds, 0x20ec89) == 0x0001)
        { pc = 0x1ad106; break; }
  case 0x1ad093: // 0160:1ad093
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c840, r8[al]);
    r32[esp] += 4; return;
  case 0x1ad09e: // 0160:1ad09e
    if (memoryAGet16(ds, 0x20e90d) != 0x0003)
        { pc = 0x1ad0d4; break; }
    yield* sub_1ad188();
    if (memoryAGet16(ds, 0x20ec89) == 0x0001)
        { pc = 0x1ad106; break; }
    if (memoryAGet16(ds, 0x20ec89) == 0x0002)
        { pc = 0x1ad093; break; }
  case 0x1ad0c9: // 0160:1ad0c9
    r8[al] = memoryAGet(ds, 0x20c842);
    memoryASet(ds, 0x20c840, r8[al]);
    r32[esp] += 4; return;
  case 0x1ad0d4: // 0160:1ad0d4
    yield* sub_1ad258();
    if (memoryAGet16(ds, 0x20ec89) == 0x0001)
        { pc = 0x1ad106; break; }
    if (memoryAGet16(ds, 0x20ec89) == 0x0002)
        { pc = 0x1ad093; break; }
    if (memoryAGet16(ds, 0x20ec89) == 0x0003)
        { pc = 0x1ad0c9; break; }
    r8[al] = memoryAGet(ds, 0x20c843);
    memoryASet(ds, 0x20c840, r8[al]);
    r32[esp] += 4; return;
  case 0x1ad106: // 0160:1ad106
    r32[esp] += 4; return;
  case 0x1ad107: // 0160:1ad107
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1ad136; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1ad149; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1ad188; break; }
    { pc = 0x1ad258; break; }
  case 0x1ad136: // 0160:1ad136
    if (memoryAGet16(ds, 0x224b9c) == 0x0001)
        { pc = 0x1ad34b; break; }
    { pc = 0x1ad394; break; }
  case 0x1ad149: // 0160:1ad149
    r16[ax] = memoryAGet16(ds, 0x224b9e);
    if (r16[ax])
        { pc = 0x1ad15e; break; }
    yield* sub_1ad47f();
    { pc = 0x1ad4d0; break; }
  case 0x1ad15e: // 0160:1ad15e
    if (r16[ax] != 0x0001)
        { pc = 0x1ad16e; break; }
    yield* sub_1ad521();
    { pc = 0x1ad572; break; }
  case 0x1ad16e: // 0160:1ad16e
    if (r16[ax] != 0x0002)
        { pc = 0x1ad17e; break; }
    yield* sub_1ad34b();
    { pc = 0x1ad42e; break; }
  case 0x1ad17e: // 0160:1ad17e
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad188: // 0160:1ad188
    r16[ax] = memoryAGet16(ds, 0x224ba0);
    if (r16[ax])
        { pc = 0x1ad1bd; break; }
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    { pc = 0x1ad34b; break; }
  case 0x1ad1bd: // 0160:1ad1bd
    if (r16[ax] != 0x0001)
        { pc = 0x1ad1ed; break; }
    yield* sub_1ad572();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    yield* sub_1ad521();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    { pc = 0x1ad34b; break; }
  case 0x1ad1ed: // 0160:1ad1ed
    if (r16[ax] != 0x0002)
        { pc = 0x1ad213; break; }
    yield* sub_1ad42e();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c841, 0x00);
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad213: // 0160:1ad213
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad228; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad228: // 0160:1ad228
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad244; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad244: // 0160:1ad244
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
    yield* sub_1ad5c3();
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x10);
    r32[esp] += 4; return;
  case 0x1ad258: // 0160:1ad258
    r16[ax] = memoryAGet16(ds, 0x224ba2);
    if (r16[ax])
        { pc = 0x1ad299; break; }
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c843, r8[al]);
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    memoryASet(ds, 0x20c841, 0x00);
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad299: // 0160:1ad299
    if (r16[ax] != 0x0001)
        { pc = 0x1ad2d5; break; }
    yield* sub_1ad572();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c843, r8[al]);
    yield* sub_1ad521();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    memoryASet(ds, 0x20c841, 0x00);
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad2d5: // 0160:1ad2d5
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad2ea; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad2ea: // 0160:1ad2ea
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad306; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad306: // 0160:1ad306
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
    yield* sub_1ad5c3();
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x10);
    r8[al] = memoryAGet(ds, 0x20c842);
    memoryASet(ds, 0x20c843, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    yield* sub_1ad34b();
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
    r32[esp] += 4; return;
  case 0x1ad34b: // 0160:1ad34b
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x10;
    if (r8[al])
        { pc = 0x1ad35b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1ad35b: // 0160:1ad35b
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x20;
    if (r8[al])
        { pc = 0x1ad36b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad36b: // 0160:1ad36b
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea2)))
        { pc = 0x1ad37f; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1ad37f: // 0160:1ad37f
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    if (r8[al] != memoryAGet(ds, 0x20eea1))
        { pc = 0x1ad393; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1ad393: // 0160:1ad393
    r32[esp] += 4; return;
  case 0x1ad394: // 0160:1ad394
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1ad3a8; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1ad3a8: // 0160:1ad3a8
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad3bc; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1ad3bc: // 0160:1ad3bc
    r8[al] = memoryAGet(ds, 0x30b089);
    if (!r8[al])
        { pc = 0x1ad3d0; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1ad3d0: // 0160:1ad3d0
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1ad3e4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad3e4: // 0160:1ad3e4
    r32[esp] += 4; return;
  case 0x1ad3e5: // 0160:1ad3e5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x40;
    if (r8[al])
        { pc = 0x1ad3f5; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad3f5: // 0160:1ad3f5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1ad405; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad405: // 0160:1ad405
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea4)))
        { pc = 0x1ad419; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad419: // 0160:1ad419
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8[al] != memoryAGet(ds, 0x20eea3))
        { pc = 0x1ad42d; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad42d: // 0160:1ad42d
    r32[esp] += 4; return;
  case 0x1ad42e: // 0160:1ad42e
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1ad442; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad442: // 0160:1ad442
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad456; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad456: // 0160:1ad456
    r8[al] = memoryAGet(ds, 0x30b089);
    if (!r8[al])
        { pc = 0x1ad46a; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad46a: // 0160:1ad46a
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1ad47e; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad47e: // 0160:1ad47e
    r32[esp] += 4; return;
    // gap 81 bytes // gap 81 bytes
  case 0x1ad4d0: // 0160:1ad4d0
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad4e4; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad4e4: // 0160:1ad4e4
    r8[al] = memoryAGet(ds, 0x30b08a);
    if (!r8[al])
        { pc = 0x1ad4f8; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad4f8: // 0160:1ad4f8
    r8[al] = memoryAGet(ds, 0x30b08b);
    if (!r8[al])
        { pc = 0x1ad50c; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad50c: // 0160:1ad50c
    r8[al] = memoryAGet(ds, 0x30b096);
    if (!r8[al])
        { pc = 0x1ad520; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad520: // 0160:1ad520
    r32[esp] += 4; return;
    // gap 81 bytes // gap 81 bytes
  case 0x1ad572: // 0160:1ad572
    r8[al] = memoryAGet(ds, 0x30b0a6);
    if (!r8[al])
        { pc = 0x1ad586; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad586: // 0160:1ad586
    r8[al] = memoryAGet(ds, 0x30b097);
    if (!r8[al])
        { pc = 0x1ad59a; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad59a: // 0160:1ad59a
    r8[al] = memoryAGet(ds, 0x30b098);
    if (!r8[al])
        { pc = 0x1ad5ae; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad5ae: // 0160:1ad5ae
    r8[al] = memoryAGet(ds, 0x30b0ed);
    if (!r8[al])
        { pc = 0x1ad5c2; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad5c2: // 0160:1ad5c2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad149() // 0160:1ad149 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x224b9e);
    if (r16[ax])
        { pc = 0x1ad15e; break; }
    yield* sub_1ad47f();
    { pc = 0x1ad4d0; break; }
  case 0x1ad15e: // 0160:1ad15e
    if (r16[ax] != 0x0001)
        { pc = 0x1ad16e; break; }
    yield* sub_1ad521();
    { pc = 0x1ad572; break; }
  case 0x1ad16e: // 0160:1ad16e
    if (r16[ax] != 0x0002)
        { pc = 0x1ad17e; break; }
    yield* sub_1ad34b();
    { pc = 0x1ad42e; break; }
  case 0x1ad17e: // 0160:1ad17e
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
    // gap 605 bytes // gap 605 bytes
  case 0x1ad3e5: // 0160:1ad3e5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x40;
    if (r8[al])
        { pc = 0x1ad3f5; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad3f5: // 0160:1ad3f5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1ad405; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad405: // 0160:1ad405
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea4)))
        { pc = 0x1ad419; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad419: // 0160:1ad419
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8[al] != memoryAGet(ds, 0x20eea3))
        { pc = 0x1ad42d; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad42d: // 0160:1ad42d
    r32[esp] += 4; return;
  case 0x1ad42e: // 0160:1ad42e
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1ad442; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad442: // 0160:1ad442
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad456; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad456: // 0160:1ad456
    r8[al] = memoryAGet(ds, 0x30b089);
    if (!r8[al])
        { pc = 0x1ad46a; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad46a: // 0160:1ad46a
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1ad47e; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad47e: // 0160:1ad47e
    r32[esp] += 4; return;
    // gap 81 bytes // gap 81 bytes
  case 0x1ad4d0: // 0160:1ad4d0
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad4e4; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad4e4: // 0160:1ad4e4
    r8[al] = memoryAGet(ds, 0x30b08a);
    if (!r8[al])
        { pc = 0x1ad4f8; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad4f8: // 0160:1ad4f8
    r8[al] = memoryAGet(ds, 0x30b08b);
    if (!r8[al])
        { pc = 0x1ad50c; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad50c: // 0160:1ad50c
    r8[al] = memoryAGet(ds, 0x30b096);
    if (!r8[al])
        { pc = 0x1ad520; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad520: // 0160:1ad520
    r32[esp] += 4; return;
    // gap 81 bytes // gap 81 bytes
  case 0x1ad572: // 0160:1ad572
    r8[al] = memoryAGet(ds, 0x30b0a6);
    if (!r8[al])
        { pc = 0x1ad586; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad586: // 0160:1ad586
    r8[al] = memoryAGet(ds, 0x30b097);
    if (!r8[al])
        { pc = 0x1ad59a; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad59a: // 0160:1ad59a
    r8[al] = memoryAGet(ds, 0x30b098);
    if (!r8[al])
        { pc = 0x1ad5ae; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad5ae: // 0160:1ad5ae
    r8[al] = memoryAGet(ds, 0x30b0ed);
    if (!r8[al])
        { pc = 0x1ad5c2; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad5c2: // 0160:1ad5c2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad188() // 0160:1ad188 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x224ba0);
    if (r16[ax])
        { pc = 0x1ad1bd; break; }
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    { pc = 0x1ad34b; break; }
  case 0x1ad1bd: // 0160:1ad1bd
    if (r16[ax] != 0x0001)
        { pc = 0x1ad1ed; break; }
    yield* sub_1ad572();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    yield* sub_1ad521();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    { pc = 0x1ad34b; break; }
  case 0x1ad1ed: // 0160:1ad1ed
    if (r16[ax] != 0x0002)
        { pc = 0x1ad213; break; }
    yield* sub_1ad42e();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c841, 0x00);
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad213: // 0160:1ad213
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad228; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad228: // 0160:1ad228
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad244; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad244: // 0160:1ad244
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
    yield* sub_1ad5c3();
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x10);
    r32[esp] += 4; return;
    // gap 243 bytes // gap 243 bytes
  case 0x1ad34b: // 0160:1ad34b
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x10;
    if (r8[al])
        { pc = 0x1ad35b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1ad35b: // 0160:1ad35b
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x20;
    if (r8[al])
        { pc = 0x1ad36b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad36b: // 0160:1ad36b
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea2)))
        { pc = 0x1ad37f; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1ad37f: // 0160:1ad37f
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    if (r8[al] != memoryAGet(ds, 0x20eea1))
        { pc = 0x1ad393; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1ad393: // 0160:1ad393
    r32[esp] += 4; return;
    // gap 81 bytes // gap 81 bytes
  case 0x1ad3e5: // 0160:1ad3e5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x40;
    if (r8[al])
        { pc = 0x1ad3f5; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad3f5: // 0160:1ad3f5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1ad405; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad405: // 0160:1ad405
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea4)))
        { pc = 0x1ad419; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad419: // 0160:1ad419
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8[al] != memoryAGet(ds, 0x20eea3))
        { pc = 0x1ad42d; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad42d: // 0160:1ad42d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad258() // 0160:1ad258 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x224ba2);
    if (r16[ax])
        { pc = 0x1ad299; break; }
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c843, r8[al]);
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    memoryASet(ds, 0x20c841, 0x00);
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad299: // 0160:1ad299
    if (r16[ax] != 0x0001)
        { pc = 0x1ad2d5; break; }
    yield* sub_1ad572();
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c843, r8[al]);
    yield* sub_1ad521();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c842, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    memoryASet(ds, 0x20c841, 0x00);
    yield* sub_1ad34b();
    { pc = 0x1ad3e5; break; }
  case 0x1ad2d5: // 0160:1ad2d5
    yield* sub_1ad47f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad2ea; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad2ea: // 0160:1ad2ea
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
    yield* sub_1ad4d0();
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x10;
    if (!r8[al])
        { pc = 0x1ad306; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad306: // 0160:1ad306
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
    yield* sub_1ad5c3();
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x10);
    r8[al] = memoryAGet(ds, 0x20c842);
    memoryASet(ds, 0x20c843, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c842, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c841, r8[al]);
    memoryASet(ds, 0x20c840, 0x00);
    yield* sub_1ad34b();
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
    r32[esp] += 4; return;
    // gap 154 bytes // gap 154 bytes
  case 0x1ad3e5: // 0160:1ad3e5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x40;
    if (r8[al])
        { pc = 0x1ad3f5; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad3f5: // 0160:1ad3f5
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1ad405; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad405: // 0160:1ad405
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea4)))
        { pc = 0x1ad419; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad419: // 0160:1ad419
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    if (r8[al] != memoryAGet(ds, 0x20eea3))
        { pc = 0x1ad42d; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad42d: // 0160:1ad42d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad34b() // 0160:1ad34b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x10;
    if (r8[al])
        { pc = 0x1ad35b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1ad35b: // 0160:1ad35b
    r8[al] = memoryAGet(ds, 0x1f1cc3);
    r8[al] &= 0x20;
    if (r8[al])
        { pc = 0x1ad36b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad36b: // 0160:1ad36b
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    if (r8s[al] < signed8(memoryAGet(ds, 0x20eea2)))
        { pc = 0x1ad37f; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1ad37f: // 0160:1ad37f
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    if (r8[al] != memoryAGet(ds, 0x20eea1))
        { pc = 0x1ad393; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1ad393: // 0160:1ad393
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad42e() // 0160:1ad42e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1ad442; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad442: // 0160:1ad442
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad456; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad456: // 0160:1ad456
    r8[al] = memoryAGet(ds, 0x30b089);
    if (!r8[al])
        { pc = 0x1ad46a; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad46a: // 0160:1ad46a
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1ad47e; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad47e: // 0160:1ad47e
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad47f() // 0160:1ad47f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x30b09a);
    if (!r8[al])
        { pc = 0x1ad493; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1ad493: // 0160:1ad493
    r8[al] = memoryAGet(ds, 0x30b09c);
    if (!r8[al])
        { pc = 0x1ad4a7; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1ad4a7: // 0160:1ad4a7
    r8[al] = memoryAGet(ds, 0x30b09d);
    if (!r8[al])
        { pc = 0x1ad4bb; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1ad4bb: // 0160:1ad4bb
    r8[al] = memoryAGet(ds, 0x30b08d);
    if (!r8[al])
        { pc = 0x1ad4cf; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad4cf: // 0160:1ad4cf
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad4d0() // 0160:1ad4d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1ad4e4; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad4e4: // 0160:1ad4e4
    r8[al] = memoryAGet(ds, 0x30b08a);
    if (!r8[al])
        { pc = 0x1ad4f8; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad4f8: // 0160:1ad4f8
    r8[al] = memoryAGet(ds, 0x30b08b);
    if (!r8[al])
        { pc = 0x1ad50c; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad50c: // 0160:1ad50c
    r8[al] = memoryAGet(ds, 0x30b096);
    if (!r8[al])
        { pc = 0x1ad520; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad520: // 0160:1ad520
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad521() // 0160:1ad521 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x30b091);
    if (!r8[al])
        { pc = 0x1ad535; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1ad535: // 0160:1ad535
    r8[al] = memoryAGet(ds, 0x30b09c);
    if (!r8[al])
        { pc = 0x1ad549; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1ad549: // 0160:1ad549
    r8[al] = memoryAGet(ds, 0x30b09d);
    if (!r8[al])
        { pc = 0x1ad55d; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1ad55d: // 0160:1ad55d
    r8[al] = memoryAGet(ds, 0x30b09e);
    if (!r8[al])
        { pc = 0x1ad571; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1ad571: // 0160:1ad571
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad572() // 0160:1ad572 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x30b0a6);
    if (!r8[al])
        { pc = 0x1ad586; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x10);
  case 0x1ad586: // 0160:1ad586
    r8[al] = memoryAGet(ds, 0x30b097);
    if (!r8[al])
        { pc = 0x1ad59a; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x04);
  case 0x1ad59a: // 0160:1ad59a
    r8[al] = memoryAGet(ds, 0x30b098);
    if (!r8[al])
        { pc = 0x1ad5ae; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x08);
  case 0x1ad5ae: // 0160:1ad5ae
    r8[al] = memoryAGet(ds, 0x30b0ed);
    if (!r8[al])
        { pc = 0x1ad5c2; break; }
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) | 0x40);
  case 0x1ad5c2: // 0160:1ad5c2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad5c3() // 0160:1ad5c3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x30b0c0);
    if (!r8[al])
        { pc = 0x1ad5d7; break; }
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x04);
  case 0x1ad5d7: // 0160:1ad5d7
    r8[al] = memoryAGet(ds, 0x30b0c1);
    if (!r8[al])
        { pc = 0x1ad5eb; break; }
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x08);
  case 0x1ad5eb: // 0160:1ad5eb
    r8[al] = memoryAGet(ds, 0x30b0bb);
    if (!r8[al])
        { pc = 0x1ad5ff; break; }
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) | 0x40);
  case 0x1ad5ff: // 0160:1ad5ff
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad600() // 0160:1ad600 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
  case 0x1ad605: // 0160:1ad605
    yield* sync();
    if (memoryAGet32(ds, 0x2eebd0) == r32[eax])
        { pc = 0x1ad605; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ad60e() // 0160:1ad60e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d081) & 0xffff)
        { pc = 0x1ad677; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ad677; break; }
    if (memoryAGet16(ds, 0x20d7a3) & 0xffff)
        { pc = 0x1ad637; break; }
    memoryASet16(ds, 0x20d7a3, 0x0001);
  case 0x1ad637: // 0160:1ad637
    r32[eax] = 0x00000001;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d1f7;
  case 0x1ad646: // 0160:1ad646
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1ad65a; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1ad65a; break; }
    r32[esi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1ad646; break; }
  case 0x1ad65a: // 0160:1ad65a
    memoryASet16(ds, r32[esi], r16[ax]);
    if (!(memoryAGet16(ds, 0x20cfa9) & 0xffff))
        { pc = 0x1ad670; break; }
    memoryASet16(ds, 0x20cfa9, memoryAGet16(ds, 0x20cfa9) - 0x0004);
  case 0x1ad670: // 0160:1ad670
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x8f);
  case 0x1ad677: // 0160:1ad677
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1ad695; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0023)
        { pc = 0x1ad695; break; }
    memoryASet16(ds, 0x20cf85, 0x002e);
  case 0x1ad695: // 0160:1ad695
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0024))
        { pc = 0x1ad86d; break; }
    if (memoryAGet16(ds, 0x20cf85) < 0x0020)
        { pc = 0x1ad6db; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf4f);
    r16[cx] = memoryAGet16(ds, 0x20cf61);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    r8[dl] = memoryAGet(ds, 0x20d123);
    yield* sub_1cd983();
    memoryASet16(ds, 0x20cf4f, r16[bx]);
    memoryASet16(ds, 0x20cf61, r16[cx]);
    r32[esp] += 4; return;
  case 0x1ad6db: // 0160:1ad6db
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    memoryASet16(ds, 0x20d10f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d06f);
    memoryASet16(ds, 0x20e801, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    memoryASet16(ds, 0x20e805, r16[ax]);
    yield* sub_1adf52();
    r16[ax] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20d05d, r16[ax]);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d06f, r16[ax]);
    memoryASet16(ds, 0x20d07f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf85);
    memoryASet16(ds, 0x20cf95, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfbb);
    memoryASet16(ds, 0x20cfcb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfcd);
    memoryASet16(ds, 0x20cfdd, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfdf);
    memoryASet16(ds, 0x20cfef, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cff1);
    memoryASet16(ds, 0x20d001, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d003);
    memoryASet16(ds, 0x20d013, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d015);
    memoryASet16(ds, 0x20d025, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d027);
    memoryASet16(ds, 0x20d037, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d039);
    memoryASet16(ds, 0x20d049, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d217);
    memoryASet16(ds, 0x20d21f, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d123);
    memoryASet(ds, 0x20d133, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c848, r8[al]);
    yield* sub_1ae073();
    r16[ax] = memoryAGet16(ds, 0x20d21f);
    memoryASet16(ds, 0x20d217, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf61, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    memoryASet16(ds, 0x20cf85, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    memoryASet16(ds, 0x20cf97, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfcb);
    memoryASet16(ds, 0x20cfbb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfdd);
    memoryASet16(ds, 0x20cfcd, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d049);
    memoryASet16(ds, 0x20d039, r16[ax]);
  case 0x1ad86d: // 0160:1ad86d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ad86e() // 0160:1ad86e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d083) & 0xffff)
        { pc = 0x1ad8c3; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ad8c3; break; }
    r32[eax] = 0x00000002;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d1f7;
  case 0x1ad892: // 0160:1ad892
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1ad8a6; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1ad8a6; break; }
    r32[esi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1ad892; break; }
  case 0x1ad8a6: // 0160:1ad8a6
    memoryASet16(ds, r32[esi], r16[ax]);
    if (!(memoryAGet16(ds, 0x20cfab) & 0xffff))
        { pc = 0x1ad8bc; break; }
    memoryASet16(ds, 0x20cfab, memoryAGet16(ds, 0x20cfab) - 0x0004);
  case 0x1ad8bc: // 0160:1ad8bc
    memoryASet(ds, 0x20c841, memoryAGet(ds, 0x20c841) & 0x8f);
  case 0x1ad8c3: // 0160:1ad8c3
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1ad8e1; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x0023)
        { pc = 0x1ad8e1; break; }
    memoryASet16(ds, 0x20cf87, 0x002e);
  case 0x1ad8e1: // 0160:1ad8e1
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0024))
        { pc = 0x1adab9; break; }
    if (memoryAGet16(ds, 0x20cf87) < 0x0020)
        { pc = 0x1ad927; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf51);
    r16[cx] = memoryAGet16(ds, 0x20cf63);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    r8[dl] = memoryAGet(ds, 0x20d125);
    yield* sub_1cd983();
    memoryASet16(ds, 0x20cf51, r16[bx]);
    memoryASet16(ds, 0x20cf63, r16[cx]);
    r32[esp] += 4; return;
  case 0x1ad927: // 0160:1ad927
    r16[ax] = memoryAGet16(ds, 0x20d101);
    memoryASet16(ds, 0x20d10f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d071);
    memoryASet16(ds, 0x20e801, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d05f);
    memoryASet16(ds, 0x20e805, r16[ax]);
    yield* sub_1adf52();
    r16[ax] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20d05f, r16[ax]);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d071, r16[ax]);
    memoryASet16(ds, 0x20d07f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf75);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf87);
    memoryASet16(ds, 0x20cf95, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfbd);
    memoryASet16(ds, 0x20cfcb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfcf);
    memoryASet16(ds, 0x20cfdd, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfe1);
    memoryASet16(ds, 0x20cfef, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cff3);
    memoryASet16(ds, 0x20d001, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d005);
    memoryASet16(ds, 0x20d013, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d017);
    memoryASet16(ds, 0x20d025, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d029);
    memoryASet16(ds, 0x20d037, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d03b);
    memoryASet16(ds, 0x20d049, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d219);
    memoryASet16(ds, 0x20d21f, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d125);
    memoryASet(ds, 0x20d133, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c848, r8[al]);
    yield* sub_1ae073();
    r16[ax] = memoryAGet16(ds, 0x20d21f);
    memoryASet16(ds, 0x20d219, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf51, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf63, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    memoryASet16(ds, 0x20cf99, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfcb);
    memoryASet16(ds, 0x20cfbd, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfdd);
    memoryASet16(ds, 0x20cfcf, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d049);
    memoryASet16(ds, 0x20d03b, r16[ax]);
  case 0x1adab9: // 0160:1adab9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1adaba() // 0160:1adaba +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d085) & 0xffff)
        { pc = 0x1adb0f; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1adb0f; break; }
    r32[eax] = 0x00000003;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d1f7;
  case 0x1adade: // 0160:1adade
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1adaf2; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1adaf2; break; }
    r32[esi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1adade; break; }
  case 0x1adaf2: // 0160:1adaf2
    memoryASet16(ds, r32[esi], r16[ax]);
    if (!(memoryAGet16(ds, 0x20cfad) & 0xffff))
        { pc = 0x1adb08; break; }
    memoryASet16(ds, 0x20cfad, memoryAGet16(ds, 0x20cfad) - 0x0004);
  case 0x1adb08: // 0160:1adb08
    memoryASet(ds, 0x20c842, memoryAGet(ds, 0x20c842) & 0x8f);
  case 0x1adb0f: // 0160:1adb0f
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1adb2d; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x0023)
        { pc = 0x1adb2d; break; }
    memoryASet16(ds, 0x20cf89, 0x002e);
  case 0x1adb2d: // 0160:1adb2d
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0024))
        { pc = 0x1add05; break; }
    if (memoryAGet16(ds, 0x20cf89) < 0x0020)
        { pc = 0x1adb73; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf53);
    r16[cx] = memoryAGet16(ds, 0x20cf65);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    r8[dl] = memoryAGet(ds, 0x20d127);
    yield* sub_1cd983();
    memoryASet16(ds, 0x20cf53, r16[bx]);
    memoryASet16(ds, 0x20cf65, r16[cx]);
    r32[esp] += 4; return;
  case 0x1adb73: // 0160:1adb73
    r16[ax] = memoryAGet16(ds, 0x20d103);
    memoryASet16(ds, 0x20d10f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d073);
    memoryASet16(ds, 0x20e801, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d061);
    memoryASet16(ds, 0x20e805, r16[ax]);
    yield* sub_1adf52();
    r16[ax] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20d061, r16[ax]);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d073, r16[ax]);
    memoryASet16(ds, 0x20d07f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf77);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf89);
    memoryASet16(ds, 0x20cf95, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfbf);
    memoryASet16(ds, 0x20cfcb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfd1);
    memoryASet16(ds, 0x20cfdd, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfe3);
    memoryASet16(ds, 0x20cfef, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cff5);
    memoryASet16(ds, 0x20d001, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d007);
    memoryASet16(ds, 0x20d013, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d019);
    memoryASet16(ds, 0x20d025, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d02b);
    memoryASet16(ds, 0x20d037, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d03d);
    memoryASet16(ds, 0x20d049, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d21b);
    memoryASet16(ds, 0x20d21f, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d127);
    memoryASet(ds, 0x20d133, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c842);
    memoryASet(ds, 0x20c848, r8[al]);
    yield* sub_1ae073();
    r16[ax] = memoryAGet16(ds, 0x20d21f);
    memoryASet16(ds, 0x20d21b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    memoryASet16(ds, 0x20cf9b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfcb);
    memoryASet16(ds, 0x20cfbf, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfdd);
    memoryASet16(ds, 0x20cfd1, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d049);
    memoryASet16(ds, 0x20d03d, r16[ax]);
  case 0x1add05: // 0160:1add05
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1add06() // 0160:1add06 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d087) & 0xffff)
        { pc = 0x1add5b; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1add5b; break; }
    r32[eax] = 0x00000004;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d1f7;
  case 0x1add2a: // 0160:1add2a
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1add3e; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1add3e; break; }
    r32[esi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1add2a; break; }
  case 0x1add3e: // 0160:1add3e
    memoryASet16(ds, r32[esi], r16[ax]);
    if (!(memoryAGet16(ds, 0x20cfaf) & 0xffff))
        { pc = 0x1add54; break; }
    memoryASet16(ds, 0x20cfaf, memoryAGet16(ds, 0x20cfaf) - 0x0004);
  case 0x1add54: // 0160:1add54
    memoryASet(ds, 0x20c843, memoryAGet(ds, 0x20c843) & 0x8f);
  case 0x1add5b: // 0160:1add5b
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1add79; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x0023)
        { pc = 0x1add79; break; }
    memoryASet16(ds, 0x20cf8b, 0x002e);
  case 0x1add79: // 0160:1add79
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0024))
        { pc = 0x1adf51; break; }
    if (memoryAGet16(ds, 0x20cf8b) < 0x0020)
        { pc = 0x1addbf; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf55);
    r16[cx] = memoryAGet16(ds, 0x20cf67);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    r8[dl] = memoryAGet(ds, 0x20d129);
    yield* sub_1cd983();
    memoryASet16(ds, 0x20cf55, r16[bx]);
    memoryASet16(ds, 0x20cf67, r16[cx]);
    r32[esp] += 4; return;
  case 0x1addbf: // 0160:1addbf
    r16[ax] = memoryAGet16(ds, 0x20d105);
    memoryASet16(ds, 0x20d10f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d075);
    memoryASet16(ds, 0x20e801, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d063);
    memoryASet16(ds, 0x20e805, r16[ax]);
    yield* sub_1adf52();
    r16[ax] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20d063, r16[ax]);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d075, r16[ax]);
    memoryASet16(ds, 0x20d07f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf79);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf8b);
    memoryASet16(ds, 0x20cf95, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfc1);
    memoryASet16(ds, 0x20cfcb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfd3);
    memoryASet16(ds, 0x20cfdd, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfe5);
    memoryASet16(ds, 0x20cfef, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cff7);
    memoryASet16(ds, 0x20d001, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d009);
    memoryASet16(ds, 0x20d013, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d01b);
    memoryASet16(ds, 0x20d025, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d02d);
    memoryASet16(ds, 0x20d037, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d03f);
    memoryASet16(ds, 0x20d049, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d21d);
    memoryASet16(ds, 0x20d21f, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d129);
    memoryASet(ds, 0x20d133, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c843);
    memoryASet(ds, 0x20c848, r8[al]);
    yield* sub_1ae073();
    r16[ax] = memoryAGet16(ds, 0x20d21f);
    memoryASet16(ds, 0x20d21d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf55, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf67, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    memoryASet16(ds, 0x20cf9d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfcb);
    memoryASet16(ds, 0x20cfc1, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfdd);
    memoryASet16(ds, 0x20cfd3, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d049);
    memoryASet16(ds, 0x20d03f, r16[ax]);
  case 0x1adf51: // 0160:1adf51
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1adf52() // 0160:1adf52 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20e801) & 0xffff)
        { pc = 0x1adf6c; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1ae072; break; }
  case 0x1adf6c: // 0160:1adf6c
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    if (r16s[ax] >= 0)
        { pc = 0x1adfa4; break; }
    r16[ax] = -r16[ax];
    if (r16s[ax] <= signed16(0x003f))
        { pc = 0x1adf8e; break; }
    r16[ax] = 0xfff8;
    { pc = 0x1adfc1; break; }
  case 0x1adf8e: // 0160:1adf8e
    r32[esi] = 0x00204f38;
    r32[eax] &= 0x0000ffff;
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r16[ax] &= 0x00ff;
    r16[ax] = -r16[ax];
    { pc = 0x1adfc1; break; }
  case 0x1adfa4: // 0160:1adfa4
    if (r16s[ax] <= signed16(0x003f))
        { pc = 0x1adfb0; break; }
    r16[ax] = 0x0008;
    { pc = 0x1adfc1; break; }
  case 0x1adfb0: // 0160:1adfb0
    r32[esi] = 0x00204f38;
    r32[eax] &= 0x0000ffff;
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r16[ax] &= 0x00ff;
  case 0x1adfc1: // 0160:1adfc1
    r16[bx] = memoryAGet16(ds, 0x20e805);
    r16[bx] += r16[ax];
    if (r16s[bx] >= 0)
        { pc = 0x1adffe; break; }
    r16[ax] = memoryAGet16(ds, 0x20e801);
    r16[ax] = -r16[ax];
    r16[bx] = r16[ax];
    if (memoryAGet16(ds, 0x20edcf) & 0xffff)
        { pc = 0x1adfea; break; }
    r16[ax] >>>= 2;
    { pc = 0x1adfee; break; }
  case 0x1adfea: // 0160:1adfea
    r16[ax] >>>= 5;
  case 0x1adfee: // 0160:1adfee
    r16[bx] >>>= 1;
    r16[bx] -= r16[ax];
    memoryASet16(ds, 0x20e801, r16[bx]);
    r16[bx] = 0;
  case 0x1adffe: // 0160:1adffe
    memoryASet16(ds, 0x20e805, r16[bx]);
    if (r16[bx])
        { pc = 0x1ae072; break; }
    if (signed16(memoryAGet16(ds, 0x20e801)) <= signed16(0x0002))
        { pc = 0x1ae072; break; }
    if (!(memoryAGet16(ds, 0x20d10f) & 0xffff))
        { pc = 0x1ae072; break; }
    push(memoryAGet16(ds, 0x20e801));
    push(memoryAGet16(ds, 0x20e805));
    r8[al] = 0x57;
    if (memoryAGet16(ds, 0x20d7b9) == 0x002b)
        { pc = 0x1ae04d; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x000f)
        { pc = 0x1ae051; break; }
    if (signed16(memoryAGet16(ds, 0x20e801)) <= signed16(0x0004))
        { pc = 0x1ae05f; break; }
  case 0x1ae04d: // 0160:1ae04d
    r8[al] = 0x86;
    { pc = 0x1ae05f; break; }
  case 0x1ae051: // 0160:1ae051
    r8[al] = 0x55;
    if (signed16(memoryAGet16(ds, 0x20e801)) <= signed16(0x0004))
        { pc = 0x1ae05f; break; }
    r8[al] = 0x6d;
  case 0x1ae05f: // 0160:1ae05f
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20e805, pop());
    memoryASet16(ds, 0x20e801, pop());
  case 0x1ae072: // 0160:1ae072
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ae073() // 0160:1ae073 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20ee47) & 0xffff))
        { pc = 0x1ae0bb; break; }
    memoryASet(ds, 0x20c848, 0x00);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] <<= 5;
    r16[bx] = r16[ax];
    r16[ax] -= memoryAGet16(ds, 0x20cfa7);
    r16[ax] &= 0x03ff;
    if (r16s[ax] <= signed16(0x0160))
        { pc = 0x1ae0a9; break; }
    if (r16s[ax] <= signed16(0x02a0))
        { pc = 0x1ae0bb; break; }
  case 0x1ae0a9: // 0160:1ae0a9
    if (!(memoryAGet16(ds, 0x20cfb9) & 0xffff))
        { pc = 0x1ae0bb; break; }
    memoryASet(ds, 0x20c840, 0x40);
  case 0x1ae0bb: // 0160:1ae0bb
    memoryASet32(ds, 0x20d805, 0x00000000);
    memoryASet32(ds, 0x20d809, 0x00000000);
    r8[al] = memoryAGet(ds, 0x20d133);
    if (!r8[al])
        { pc = 0x1ae166; break; }
    if (r8[al] == 0x10)
        { pc = 0x1ae198; break; }
    if (r8[al] == 0x18)
        { pc = 0x1ae12d; break; }
    if (r8[al] != 0x08)
        { pc = 0x1ae29d; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] += 0x0008;
    r16[ax] &= 0x001f;
    r16[ax] <<= 3;
    r32[esi] = 0x00204f78;
    r32[ebp] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d809, r32[ebp]);
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax] + 0x4);
    r32[eax] = -r32[eax];
    memoryASet32(ds, 0x20d805, r32[eax]);
    r16[cx] = memoryAGet16(ds, 0x20cf83);
    r16[cx] -= 0x0008;
    { pc = 0x1ae1cb; break; }
  case 0x1ae12d: // 0160:1ae12d
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] += 0x0008;
    r16[ax] &= 0x001f;
    r16[ax] <<= 3;
    r32[esi] = 0x00204f78;
    r32[ebp] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d809, r32[ebp]);
    r32[ebp] = memoryAGet32(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x20d805, r32[ebp]);
    r16[cx] = memoryAGet16(ds, 0x20cf83);
    r16[cx] -= 0x0018;
    { pc = 0x1ae1cb; break; }
  case 0x1ae166: // 0160:1ae166
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] &= 0x001f;
    r16[ax] <<= 3;
    r32[esi] = 0x00204f78;
    r32[ebp] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d805, r32[ebp]);
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax] + 0x4);
    r32[eax] = -r32[eax];
    memoryASet32(ds, 0x20d809, r32[eax]);
    r16[cx] = memoryAGet16(ds, 0x20cf83);
    { pc = 0x1ae1cb; break; }
  case 0x1ae198: // 0160:1ae198
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] &= 0x001f;
    r16[ax] <<= 3;
    r32[esi] = 0x00204f78;
    r32[ebp] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d805, r32[ebp]);
    r32[ebp] = memoryAGet32(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x20d809, r32[ebp]);
    r16[cx] = memoryAGet16(ds, 0x20cf83);
    r16[cx] -= 0x0010;
  case 0x1ae1cb: // 0160:1ae1cb
    r16[cx] &= 0x001f;
    if (r16s[cx] < signed16(0x0010))
        { pc = 0x1ae1df; break; }
    r16[dx] = 0x0020;
    r16[dx] -= r16[cx];
    r16[cx] = r16[dx];
  case 0x1ae1df: // 0160:1ae1df
    r16[dx] = 0x0010;
    r16[dx] -= r16[cx];
    if (r16s[dx] <= signed16(0x0008))
        { pc = 0x1ae1fb; break; }
    r16[dx] -= 0x0008;
    r16[dx] <<= 4;
    memoryASet16(ds, 0x20d001, memoryAGet16(ds, 0x20d001) + r16[dx]);
  case 0x1ae1fb: // 0160:1ae1fb
    if (!(memoryAGet16(ds, 0x20cfb9) & 0xffff))
        { pc = 0x1ae29d; break; }
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x0c;
    if (r8[al])
        { pc = 0x1ae29d; break; }
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x20d133);
    r16[bx] = memoryAGet16(ds, 0x20cf83);
    if (r16s[bx] >= signed16(0x0020))
        { pc = 0x1ae29d; break; }
    if (r16[bx] == r16[ax])
        { pc = 0x1ae29d; break; }
    r16[ax] -= r16[bx];
    r16[ax] &= 0x001f;
    if (r16[ax] == 0x0010)
        { pc = 0x1ae29d; break; }
    r16[cx] = memoryAGet16(ds, 0x20c830);
    if (r16s[cx] < signed16(0x0004))
        { pc = 0x1ae280; break; }
    if (r16s[ax] > signed16(0x001c))
        { pc = 0x1ae280; break; }
    if (r16s[ax] < signed16(0x0008))
        { pc = 0x1ae278; break; }
    if (r16s[ax] > signed16(0x0018))
        { pc = 0x1ae278; break; }
    if (r16s[ax] < signed16(0x000c))
        { pc = 0x1ae270; break; }
    if (r16s[ax] > signed16(0x0014))
        { pc = 0x1ae270; break; }
    r16[cx] &= 0x001f;
    if (r16[cx])
        { pc = 0x1ae29d; break; }
    if (!r16[cx])
        { pc = 0x1ae286; break; }
  case 0x1ae270: // 0160:1ae270
    r16[cx] &= 0x000f;
    if (r16[cx])
        { pc = 0x1ae29d; break; }
    if (!r16[cx])
        { pc = 0x1ae286; break; }
  case 0x1ae278: // 0160:1ae278
    r16[cx] &= 0x0007;
    if (r16[cx])
        { pc = 0x1ae29d; break; }
    if (!r16[cx])
        { pc = 0x1ae286; break; }
  case 0x1ae280: // 0160:1ae280
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1ae29d; break; }
  case 0x1ae286: // 0160:1ae286
    if (r16s[ax] < signed16(0x0010))
        { pc = 0x1ae290; break; }
    r16[bx] -= 0x0002;
  case 0x1ae290: // 0160:1ae290
    r16[bx]++;
    r16[bx] &= 0x001f;
    memoryASet16(ds, 0x20cf83, r16[bx]);
  case 0x1ae29d: // 0160:1ae29d
    r16[bp] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20d2cb, r16[bp]);
    if (!(memoryAGet16(ds, 0x20d21f) & 0xffff))
        { pc = 0x1ae2d9; break; }
    memoryASet16(ds, 0x20d21f, memoryAGet16(ds, 0x20d21f) - 0x0001);
    memoryASet16(ds, 0x20d013, 0x0006);
    memoryASet16(ds, 0x20d025, 0x0001);
    memoryASet16(ds, 0x20d037, 0x0002);
  case 0x1ae2d9: // 0160:1ae2d9
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (r16s[ax] <= signed16(0x0200))
        { pc = 0x1ae2e9; break; }
    r16[ax] = 0x0200;
  case 0x1ae2e9: // 0160:1ae2e9
    r16[ax] >>>= 1;
    r16[bx] = 0x0100;
    r16[bx] -= r16[ax];
    r16[bx] >>>= 3;
    r16[bx] += 0x000a;
    memoryASet16(ds, 0x20ceb3, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] <<= 5;
    r16[bx] = r16[ax];
    r16[ax] -= memoryAGet16(ds, 0x20cfa7);
    r16[ax] &= 0x03ff;
    if (r16s[ax] <= signed16(0x0160))
        { pc = 0x1ae33c; break; }
    if (r16s[ax] >= signed16(0x02a0))
        { pc = 0x1ae33c; break; }
    memoryASet16(ds, 0x20d7d1, 0x0001);
    r16[ax] = r16[bx];
    r16[ax] += 0x0200;
    r16[ax] &= 0x03ff;
    { pc = 0x1ae348; break; }
  case 0x1ae33c: // 0160:1ae33c
    memoryASet16(ds, 0x20d7d1, 0x0000);
    r16[ax] = r16[bx];
  case 0x1ae348: // 0160:1ae348
    r16[bx] = memoryAGet16(ds, 0x20d049);
    r16[cx] = r16[bx];
    r16[cx] -= r16[ax];
    if (!r16[cx])
        { pc = 0x1ae3fa; break; }
    r16[cx] &= 0x03ff;
    if (r16s[cx] >= signed16(0x0200))
        { pc = 0x1ae3aa; break; }
    if (r16s[cx] <= signed16(0x0080))
        { pc = 0x1ae38a; break; }
    r16[bx] -= memoryAGet16(ds, 0x20ceb3);
    if (r16s[cx] <= signed16(0x0100))
        { pc = 0x1ae38a; break; }
    r16[bx] -= memoryAGet16(ds, 0x20ceb3);
    if (r16s[cx] >= signed16(0x0180))
        { pc = 0x1ae3eb; break; }
  case 0x1ae38a: // 0160:1ae38a
    r16[bx] -= memoryAGet16(ds, 0x20ceb3);
    r16[bx] &= 0x03ff;
    r16[cx] = r16[bx];
    r16[cx] -= r16[ax];
    r16[cx] &= 0x03ff;
    if (r16s[cx] <= signed16(0x0200))
        { pc = 0x1ae3ee; break; }
    { pc = 0x1ae3eb; break; }
  case 0x1ae3aa: // 0160:1ae3aa
    if (r16s[cx] >= signed16(0x0380))
        { pc = 0x1ae3cd; break; }
    r16[bx] += memoryAGet16(ds, 0x20ceb3);
    if (r16s[cx] >= signed16(0x0300))
        { pc = 0x1ae3cd; break; }
    r16[bx] += memoryAGet16(ds, 0x20ceb3);
    if (r16s[cx] <= signed16(0x0280))
        { pc = 0x1ae3eb; break; }
  case 0x1ae3cd: // 0160:1ae3cd
    r16[bx] += memoryAGet16(ds, 0x20ceb3);
    r16[bx] &= 0x03ff;
    r16[cx] = r16[bx];
    r16[cx] -= r16[ax];
    r16[cx] &= 0x03ff;
    if (r16s[cx] >= signed16(0x0200))
        { pc = 0x1ae3ee; break; }
  case 0x1ae3eb: // 0160:1ae3eb
    r16[bx] = r16[ax];
  case 0x1ae3ee: // 0160:1ae3ee
    r16[bx] &= 0x03ff;
    memoryASet16(ds, 0x20d049, r16[bx]);
  case 0x1ae3fa: // 0160:1ae3fa
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x40;
    if (!r8[al])
        { pc = 0x1ae40e; break; }
    if (!(memoryAGet16(ds, 0x20d7d1) & 0xffff))
        { pc = 0x1ae452; break; }
  case 0x1ae40e: // 0160:1ae40e
    if (memoryAGet16(ds, 0x20d7b9) == 0x000f)
        { pc = 0x1ae452; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0004)
        { pc = 0x1ae46b; break; }
    r16[bx] -= memoryAGet16(ds, 0x20cfa7);
    if (r16[bx] >= memoryAGet16(ds, 0x20d7f7))
        { pc = 0x1ae46b; break; }
    if (r16[bx] < memoryAGet16(ds, 0x20d7f9))
        { pc = 0x1ae46b; break; }
    if (memoryAGet16(ds, 0x20d06d) & 0xffff)
        { pc = 0x1ae46b; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1ae46b; break; }
  case 0x1ae452: // 0160:1ae452
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[bx] = memoryAGet16(ds, 0x20cf5f);
    r16[cx] = memoryAGet16(ds, 0x20cf71);
    yield* sub_1b0c20();
  case 0x1ae46b: // 0160:1ae46b
    r16[cx] = memoryAGet16(ds, 0x20cf95);
    r16[bp] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20cf95, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cfef);
    r16[bx] = memoryAGet16(ds, 0x20cfdd);
    r16[bx]++;
    if (r16[bx] != r16[ax])
        { pc = 0x1ae4a2; break; }
    memoryASet16(ds, 0x20cfdd, 0x0000);
    { pc = 0x1ae578; break; }
  case 0x1ae4a2: // 0160:1ae4a2
    memoryASet16(ds, 0x20cfdd, r16[bx]);
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1ae4eb; break; }
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) + 0x0001);
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) & 0x001f);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    yield* sub_1afd83();
    if (!r16[ax])
        { pc = 0x1ae615; break; }
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) - 0x0001);
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) & 0x001f);
    { pc = 0x1ae615; break; }
  case 0x1ae4eb: // 0160:1ae4eb
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1ae52d; break; }
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) - 0x0001);
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) & 0x001f);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    yield* sub_1afd83();
    if (!r16[ax])
        { pc = 0x1ae615; break; }
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) + 0x0001);
    memoryASet16(ds, 0x20cf95, memoryAGet16(ds, 0x20cf95) & 0x001f);
    { pc = 0x1ae615; break; }
  case 0x1ae52d: // 0160:1ae52d
    if (r16[cx] == memoryAGet16(ds, 0x20cf83))
        { pc = 0x1ae634; break; }
    if (!(memoryAGet16(ds, 0x20edff) & 0xffff))
        { pc = 0x1ae634; break; }
    r16[ax] = r16[cx];
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1ae634; break; }
    r16[ax] = r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x20cf83);
    if (r16[ax] == 0x0001)
        { pc = 0x1ae56c; break; }
    if (r16[ax] != 0xffff)
        { pc = 0x1ae573; break; }
  case 0x1ae56c: // 0160:1ae56c
    memoryASet16(ds, 0x20cf83, r16[cx]);
  case 0x1ae573: // 0160:1ae573
    { pc = 0x1ae634; break; }
  case 0x1ae578: // 0160:1ae578
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1ae5b3; break; }
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) + 0x0001);
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) & 0x001f);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    yield* sub_1afd83();
    if (!r16[ax])
        { pc = 0x1ae5ec; break; }
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) - 0x0001);
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) & 0x001f);
    { pc = 0x1ae5ec; break; }
  case 0x1ae5b3: // 0160:1ae5b3
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1ae634; break; }
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) - 0x0001);
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) & 0x001f);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    yield* sub_1afd83();
    if (!r16[ax])
        { pc = 0x1ae5ec; break; }
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) + 0x0001);
    memoryASet16(ds, 0x20cf83, memoryAGet16(ds, 0x20cf83) & 0x001f);
  case 0x1ae5ec: // 0160:1ae5ec
    r16[bp] = memoryAGet16(ds, 0x20cf83);
    memoryASet16(ds, 0x20cf95, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20d013);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20cfb9, memoryAGet16(ds, 0x20cfb9) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20cfb9)) >= 0)
        { pc = 0x1ae615; break; }
    memoryASet16(ds, 0x20cfb9, 0x0000);
  case 0x1ae615: // 0160:1ae615
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (r16[ax])
        { pc = 0x1ae634; break; }
    r16[bx] = memoryAGet16(ds, 0x20d013);
    r16[bx] <<= 2;
    r16[ax] += r16[bx];
    memoryASet16(ds, 0x20cfb9, r16[ax]);
  case 0x1ae634: // 0160:1ae634
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    r16[bx] = memoryAGet16(ds, 0x20cfb9);
    if (memoryAGet16(ds, 0x20d06d) & 0xffff)
        { pc = 0x1ae66c; break; }
    r16[dx] = memoryAGet16(ds, 0x20cfb9);
    r16[dx] >>>= 7;
    memoryASet16(ds, 0x20cec5, r16[dx]);
    r16[dx] += memoryAGet16(ds, 0x20d037);
    r16[bx] -= r16[dx];
    if (r16s[bx] >= 0)
        { pc = 0x1ae66c; break; }
    r32[ebx] = 0;
  case 0x1ae66c: // 0160:1ae66c
    yield* sub_1cdb0a();
    memoryASet32(ds, 0x20cecb, r32[eax]);
    memoryASet32(ds, 0x20cecf, r32[ebx]);
    if (memoryAGet16(ds, 0x20d06d) & 0xffff)
        { pc = 0x1ae77e; break; }
    r16[cx] = memoryAGet16(ds, 0x20cfb9);
    r16[cx] -= memoryAGet16(ds, 0x20d025);
    if (r16s[cx] >= 0)
        { pc = 0x1ae69e; break; }
    r16[cx] = 0;
  case 0x1ae69e: // 0160:1ae69e
    memoryASet16(ds, 0x20cfb9, r16[cx]);
    r16[ax] = memoryAGet16(ds, 0x20d049);
    r16[bx] = memoryAGet16(ds, 0x20d037);
    r16[bx] -= memoryAGet16(ds, 0x20d025);
    r16[bx] += memoryAGet16(ds, 0x20cec5);
    if (r16[bx] < r16[cx])
        { pc = 0x1ae6c8; break; }
    r16[bx] = r16[cx];
  case 0x1ae6c8: // 0160:1ae6c8
    yield* sub_1cdb0a();
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[eax]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[ebx]);
    r8[cl] = memoryAGet(ds, 0x20c848);
    r8[cl] &= 0x40;
    if (r8[cl])
        { pc = 0x1ae717; break; }
    r8[cl] = memoryAGet(ds, 0x20c848);
    r8[cl] &= 0x10;
    if (!r8[cl])
        { pc = 0x1ae77e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 5;
    r16[bx] = memoryAGet16(ds, 0x20d013);
    yield* sub_1cdb0a();
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[eax]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[ebx]);
    { pc = 0x1ae77e; break; }
  case 0x1ae717: // 0160:1ae717
    r16[ax] = memoryAGet16(ds, 0x20d001);
    r16[ax] >>>= 1;
    if (r16[ax] >= memoryAGet16(ds, 0x20cfb9))
        { pc = 0x1ae74a; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 5;
    r16[ax] -= memoryAGet16(ds, 0x20cfa7);
    r16[ax] &= 0x03ff;
    if (r16s[ax] <= signed16(0x00ff))
        { pc = 0x1ae74a; break; }
    if (r16s[ax] <= signed16(0x0301))
        { pc = 0x1ae77e; break; }
  case 0x1ae74a: // 0160:1ae74a
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 5;
    r16[ax] += 0x0200;
    r16[ax] &= 0x03ff;
    r16[bx] = memoryAGet16(ds, 0x20d013);
    r16[cx] = r16[bx];
    r16[cx] >>>= 2;
    r16[bx] -= r16[cx];
    yield* sub_1cdb0a();
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[eax]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[ebx]);
  case 0x1ae77e: // 0160:1ae77e
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x1ae793; break; }
    r8[al] = memoryAGet(ds, 0x20c848);
    r8[al] &= 0x10;
    if (r8[al])
        { pc = 0x1ae7aa; break; }
  case 0x1ae793: // 0160:1ae793
    r32[eax] = memoryAGet32(ds, 0x20d805);
    r32[ecx] = memoryAGet32(ds, 0x20d809);
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[eax]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[ecx]);
  case 0x1ae7aa: // 0160:1ae7aa
    yield* sub_1cdb89();
    r32[eax] = memoryAGet32(ds, 0x20d7fb);
    if (r32[eax])
        { pc = 0x1ae7c2; break; }
    r32[ecx] = memoryAGet32(ds, 0x20d7ff);
    if (!r32[ecx])
        { pc = 0x1ae7ff; break; }
  case 0x1ae7c2: // 0160:1ae7c2
    r32[ecx] = memoryAGet32(ds, 0x20d7ff);
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x20cfb9);
    mul16(r16[bx]);
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[eax]);
    r32[eax] = r32[ecx];
    mul16(r16[bx]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    push32(r32[eax]);
    yield* sub_1cdb89();
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20cfb9, r16[bx]);
  case 0x1ae7ff: // 0160:1ae7ff
    if (memoryAGet16(ds, 0x20d803) & 0xffff)
        { pc = 0x1ae8ae; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    r16[bx] = r16[ax];
    r16[bx] >>>= 6;
    r16[ax] &= 0x003f;
    r16[ax] <<= 3;
    r32[esi] = 0x00201220;
    r32[eax] &= 0x0000ffff;
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r8[al] &= memoryAGet(ds, 0x20c82e);
    if (!r8[al])
        { pc = 0x1ae83a; break; }
    r8[al] = 0x01;
  case 0x1ae83a: // 0160:1ae83a
    r8[al] += r8[bl];
    if (!r8[al])
        { pc = 0x1ae8ad; break; }
    r8[al]--;
    memoryASet32(ds, 0x20e809, 0x00000000);
    memoryASet(ds, 0x20e809, r8[al]);
    r32[esi] = 0x00200910;
    yield* sub_1ae99b();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    if (r16s[ax] >= 0)
        { pc = 0x1ae86d; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    { pc = 0x1ae87d; break; }
  case 0x1ae86d: // 0160:1ae86d
    if (r16[ax] < memoryAGet16(ds, 0x20cef5))
        { pc = 0x1ae883; break; }
    r16[ax] -= memoryAGet16(ds, 0x20cef5);
  case 0x1ae87d: // 0160:1ae87d
    memoryASet16(ds, 0x20cf5f, r16[ax]);
  case 0x1ae883: // 0160:1ae883
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    if (r16s[ax] >= 0)
        { pc = 0x1ae897; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
    { pc = 0x1ae8a7; break; }
  case 0x1ae897: // 0160:1ae897
    if (r16[ax] < memoryAGet16(ds, 0x20cef9))
        { pc = 0x1ae8ad; break; }
    r16[ax] -= memoryAGet16(ds, 0x20cef9);
  case 0x1ae8a7: // 0160:1ae8a7
    memoryASet16(ds, 0x20cf71, r16[ax]);
  case 0x1ae8ad: // 0160:1ae8ad
    r32[esp] += 4; return;
  case 0x1ae8ae: // 0160:1ae8ae
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    r16[bx] = memoryAGet16(ds, 0x20cfb9);
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + 0xfffe0000);
    yield* sub_1cdb89();
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    r16[bx] = r16[ax];
    r16[bx] >>>= 6;
    r16[ax] &= 0x003f;
    r16[ax] <<= 3;
    r32[esi] = 0x00201220;
    r32[eax] &= 0x0000ffff;
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r8[al] &= memoryAGet(ds, 0x20c82e);
    if (!r8[al])
        { pc = 0x1ae8f8; break; }
    r8[al] = 0x01;
  case 0x1ae8f8: // 0160:1ae8f8
    r8[al] += r8[bl];
    if (r8[al])
        { pc = 0x1ae90d; break; }
    r32[ebx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    memoryASet16(ds, 0x20cfb9, r16[bx]);
    { pc = 0x1ae8ad; break; }
  case 0x1ae90d: // 0160:1ae90d
    r8[al]--;
    memoryASet32(ds, 0x20e809, 0x00000000);
    memoryASet(ds, 0x20e809, r8[al]);
    r32[esi] = 0x00200910;
    yield* sub_1ae99b();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    if (memoryAGet16(ds, 0x20d889) & 0xffff)
        { pc = 0x1ae942; break; }
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    memoryASet16(ds, 0x20cfb9, r16[bx]);
  case 0x1ae942: // 0160:1ae942
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    if (r16s[ax] >= 0)
        { pc = 0x1ae956; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    { pc = 0x1ae966; break; }
  case 0x1ae956: // 0160:1ae956
    if (r16[ax] < memoryAGet16(ds, 0x20cef5))
        { pc = 0x1ae96c; break; }
    r16[ax] -= memoryAGet16(ds, 0x20cef5);
  case 0x1ae966: // 0160:1ae966
    memoryASet16(ds, 0x20cf5f, r16[ax]);
  case 0x1ae96c: // 0160:1ae96c
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    if (r16s[ax] >= 0)
        { pc = 0x1ae980; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
    { pc = 0x1ae994; break; }
  case 0x1ae980: // 0160:1ae980
    if (r16[ax] < memoryAGet16(ds, 0x20cef9))
        { pc = 0x1ae8ad; break; }
    r16[ax] -= memoryAGet16(ds, 0x20cef9);
  case 0x1ae994: // 0160:1ae994
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1ae99b() // 0160:1ae99b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20ee15) & 0xffff))
        { pc = 0x1ae9c3; break; }
    r16[ax] = memoryAGet16(ds, 0x20d06d);
    push32(r32[eax]);
    memoryASet16(ds, 0x20d06d, 0x0014);
    yield* sub_1ae9c3();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r32[esp] += 4; return;
  case 0x1ae9c3: // 0160:1ae9c3
    r32[eax] = 0;
    memoryASet16(ds, 0x20d889, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 2;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r32[edi] = 0x00200410;
    r16[ax] -= memoryAGet16(ds, 0x20cf95);
    r16[ax] -= memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 2;
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20e815, r32[edi]);
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    r16[ax] >>>= 2;
    if (r16s[ax] <= signed16(0x003f))
        { pc = 0x1aefb6; break; }
    if (r16s[ax] <= signed16(0x007f))
        { pc = 0x1aeddc; break; }
    if (r16s[ax] <= signed16(0x00bf))
        { pc = 0x1aec02; break; }
    r16[ax] -= 0x00c0;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] >= signed16(0x000e))
        { pc = 0x1aeb60; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1aeb60; break; }
  case 0x1aea67: // 0160:1aea67
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aeb19; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeafc; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aeafc; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1aeb57; break; }
  case 0x1aeafc: // 0160:1aeafc
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aeb40; break; }
    yield* sub_1af190();
    if (!flags.zero)
        { pc = 0x1aeb57; break; }
    if (flags.zero)
        { pc = 0x1aeb40; break; }
  case 0x1aeb19: // 0160:1aeb19
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeb40; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aeb40; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1aeb57; break; }
  case 0x1aeb40: // 0160:1aeb40
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aea67; break; }
    r32[esp] += 4; return;
  case 0x1aeb57: // 0160:1aeb57
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1aeb60: // 0160:1aeb60
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aebda; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
  case 0x1aebda: // 0160:1aebda
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aebeb; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
  case 0x1aebeb: // 0160:1aebeb
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aeb60; break; }
    r32[esp] += 4; return;
  case 0x1aec02: // 0160:1aec02
    r16[ax] -= 0x0080;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] >= signed16(0x000e))
        { pc = 0x1aed3a; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1aed3a; break; }
  case 0x1aec3e: // 0160:1aec3e
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aecf3; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aecd3; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aecd3; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aed31; break; }
  case 0x1aecd3: // 0160:1aecd3
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aed1a; break; }
    yield* sub_1af190();
    if (r16[ax])
        { pc = 0x1aed31; break; }
    if (!r16[ax])
        { pc = 0x1aed1a; break; }
  case 0x1aecf3: // 0160:1aecf3
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aed1a; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aed1a; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aed31; break; }
  case 0x1aed1a: // 0160:1aed1a
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aec3e; break; }
    r32[esp] += 4; return;
  case 0x1aed31: // 0160:1aed31
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1aed3a: // 0160:1aed3a
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aedb4; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
  case 0x1aedb4: // 0160:1aedb4
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aedc5; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
  case 0x1aedc5: // 0160:1aedc5
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aed3a; break; }
    r32[esp] += 4; return;
  case 0x1aeddc: // 0160:1aeddc
    r16[ax] -= 0x0040;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] >= signed16(0x000e))
        { pc = 0x1aef14; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1aef14; break; }
  case 0x1aee18: // 0160:1aee18
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aeecd; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeead; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aeead; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aef0b; break; }
  case 0x1aeead: // 0160:1aeead
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aeef4; break; }
    yield* sub_1af488();
    if (r16[ax])
        { pc = 0x1aef0b; break; }
    if (!r16[ax])
        { pc = 0x1aeef4; break; }
  case 0x1aeecd: // 0160:1aeecd
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeef4; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aeef4; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aef0b; break; }
  case 0x1aeef4: // 0160:1aeef4
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aee18; break; }
    r32[esp] += 4; return;
  case 0x1aef0b: // 0160:1aef0b
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1aef14: // 0160:1aef14
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aef8e; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
  case 0x1aef8e: // 0160:1aef8e
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aef9f; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
  case 0x1aef9f: // 0160:1aef9f
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aef14; break; }
    r32[esp] += 4; return;
  case 0x1aefb6: // 0160:1aefb6
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (signed16(memoryAGet16(ds, 0x20e805)) >= signed16(0x000e))
        { pc = 0x1af0ee; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1af0ee; break; }
  case 0x1aeff2: // 0160:1aeff2
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1af0a7; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1af087; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1af087; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1af0e5; break; }
  case 0x1af087: // 0160:1af087
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1af0ce; break; }
    yield* sub_1af488();
    if (r16[ax])
        { pc = 0x1af0e5; break; }
    if (!r16[ax])
        { pc = 0x1af0ce; break; }
  case 0x1af0a7: // 0160:1af0a7
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1af0ce; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1af0ce; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1af0e5; break; }
  case 0x1af0ce: // 0160:1af0ce
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aeff2; break; }
    r32[esp] += 4; return;
  case 0x1af0e5: // 0160:1af0e5
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1af0ee: // 0160:1af0ee
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1af168; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
  case 0x1af168: // 0160:1af168
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1af179; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
  case 0x1af179: // 0160:1af179
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1af0ee; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ae9c3() // 0160:1ae9c3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    memoryASet16(ds, 0x20d889, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 2;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r32[edi] = 0x00200410;
    r16[ax] -= memoryAGet16(ds, 0x20cf95);
    r16[ax] -= memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 2;
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20e815, r32[edi]);
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    r16[ax] >>>= 2;
    if (r16s[ax] <= signed16(0x003f))
        { pc = 0x1aefb6; break; }
    if (r16s[ax] <= signed16(0x007f))
        { pc = 0x1aeddc; break; }
    if (r16s[ax] <= signed16(0x00bf))
        { pc = 0x1aec02; break; }
    r16[ax] -= 0x00c0;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] >= signed16(0x000e))
        { pc = 0x1aeb60; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1aeb60; break; }
  case 0x1aea67: // 0160:1aea67
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aeb19; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeafc; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aeafc; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1aeb57; break; }
  case 0x1aeafc: // 0160:1aeafc
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aeb40; break; }
    yield* sub_1af190();
    if (!flags.zero)
        { pc = 0x1aeb57; break; }
    if (flags.zero)
        { pc = 0x1aeb40; break; }
  case 0x1aeb19: // 0160:1aeb19
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeb40; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aeb40; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1aeb57; break; }
  case 0x1aeb40: // 0160:1aeb40
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aea67; break; }
    r32[esp] += 4; return;
  case 0x1aeb57: // 0160:1aeb57
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1aeb60: // 0160:1aeb60
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aebda; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
  case 0x1aebda: // 0160:1aebda
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aebeb; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
  case 0x1aebeb: // 0160:1aebeb
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aeb60; break; }
    r32[esp] += 4; return;
  case 0x1aec02: // 0160:1aec02
    r16[ax] -= 0x0080;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] >= signed16(0x000e))
        { pc = 0x1aed3a; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1aed3a; break; }
  case 0x1aec3e: // 0160:1aec3e
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aecf3; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aecd3; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aecd3; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aed31; break; }
  case 0x1aecd3: // 0160:1aecd3
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1aed1a; break; }
    yield* sub_1af190();
    if (r16[ax])
        { pc = 0x1aed31; break; }
    if (!r16[ax])
        { pc = 0x1aed1a; break; }
  case 0x1aecf3: // 0160:1aecf3
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aed1a; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aed1a; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aed31; break; }
  case 0x1aed1a: // 0160:1aed1a
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aec3e; break; }
    r32[esp] += 4; return;
  case 0x1aed31: // 0160:1aed31
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1aed3a: // 0160:1aed3a
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aedb4; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0001);
  case 0x1aedb4: // 0160:1aedb4
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aedc5; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
  case 0x1aedc5: // 0160:1aedc5
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aed3a; break; }
    r32[esp] += 4; return;
  case 0x1aeddc: // 0160:1aeddc
    r16[ax] -= 0x0040;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] >= signed16(0x000e))
        { pc = 0x1aef14; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1aef14; break; }
  case 0x1aee18: // 0160:1aee18
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aeecd; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeead; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aeead; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aef0b; break; }
  case 0x1aeead: // 0160:1aeead
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aeef4; break; }
    yield* sub_1af488();
    if (r16[ax])
        { pc = 0x1aef0b; break; }
    if (!r16[ax])
        { pc = 0x1aeef4; break; }
  case 0x1aeecd: // 0160:1aeecd
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aeef4; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1aeef4; break; }
    yield* sub_1afa78();
    if (r16[ax])
        { pc = 0x1aef0b; break; }
  case 0x1aeef4: // 0160:1aeef4
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aee18; break; }
    r32[esp] += 4; return;
  case 0x1aef0b: // 0160:1aef0b
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1aef14: // 0160:1aef14
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1aef8e; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
  case 0x1aef8e: // 0160:1aef8e
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1aef9f; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0001);
  case 0x1aef9f: // 0160:1aef9f
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aef14; break; }
    r32[esp] += 4; return;
  case 0x1aefb6: // 0160:1aefb6
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bp] = memoryAGet16(ds, 0x20d06d);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (signed16(memoryAGet16(ds, 0x20e805)) >= signed16(0x000e))
        { pc = 0x1af0ee; break; }
    if (signed16(memoryAGet16(ds, 0x20d07f)) >= signed16(0x0006))
        { pc = 0x1af0ee; break; }
  case 0x1aeff2: // 0160:1aeff2
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1af0a7; break; }
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1af087; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1af087; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1af0e5; break; }
  case 0x1af087: // 0160:1af087
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1af0ce; break; }
    yield* sub_1af488();
    if (r16[ax])
        { pc = 0x1af0e5; break; }
    if (!r16[ax])
        { pc = 0x1af0ce; break; }
  case 0x1af0a7: // 0160:1af0a7
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1af0ce; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1af0ce; break; }
    yield* sub_1af780();
    if (r16[ax])
        { pc = 0x1af0e5; break; }
  case 0x1af0ce: // 0160:1af0ce
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1aeff2; break; }
    r32[esp] += 4; return;
  case 0x1af0e5: // 0160:1af0e5
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1af0ee: // 0160:1af0ee
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(memoryAGet32(ds, 0x20e809));
    memoryASet16(ds, 0x20cfcb, memoryAGet16(ds, 0x20cfcb) + 0x0001);
    r16[bp] = memoryAGet16(ds, 0x20cfcb);
    r16[ax] = r16[bx];
    push32(r32[eax]);
    push32(r32[ecx]);
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[bx] = r16[ax];
    r16[ax] = r16[cx];
    r32[edx] = 0;
    mul16(r16[bp]);
    r16[cx] = r16[ax];
    r32[edx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, r16[bx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - r16[ax]);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0xff00);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) & 0xff00);
    r16[bx] &= 0xff00;
    r16[cx] &= 0xff00;
    if (r16[bx] == memoryAGet16(ds, 0x20e801))
        { pc = 0x1af168; break; }
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0001);
  case 0x1af168: // 0160:1af168
    if (r16[cx] == memoryAGet16(ds, 0x20e805))
        { pc = 0x1af179; break; }
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0001);
  case 0x1af179: // 0160:1af179
    memoryASet32(ds, 0x20e809, pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= 0)
        { pc = 0x1af0ee; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1af190() // 0160:1af190 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x001ec60c;
    memoryASet32(ds, 0x20d7d7, r32[eax]);
    r32[esi] = 0x00200290;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r32[esi] += r32[eax];
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af1fe; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af209; break; }
  case 0x1af1fe: // 0160:1af1fe
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af3fd; break; }
  case 0x1af209: // 0160:1af209
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af25f; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af26a; break; }
  case 0x1af25f: // 0160:1af25f
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af3fd; break; }
  case 0x1af26a: // 0160:1af26a
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af2c0; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af2cb; break; }
  case 0x1af2c0: // 0160:1af2c0
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af3fd; break; }
  case 0x1af2cb: // 0160:1af2cb
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16s[bp] < 0)
        { pc = 0x1af3f8; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af32a; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af335; break; }
  case 0x1af32a: // 0160:1af32a
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af3fd; break; }
  case 0x1af335: // 0160:1af335
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x8);
    if (r16s[bp] < 0)
        { pc = 0x1af3f8; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af394; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af39b; break; }
  case 0x1af394: // 0160:1af394
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af3fd; break; }
  case 0x1af39b: // 0160:1af39b
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xa);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af3f1; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af3f8; break; }
  case 0x1af3f1: // 0160:1af3f1
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af3fd; break; }
  case 0x1af3f8: // 0160:1af3f8
    r32[eax] = 0;
    flags.zero = !(r32[eax] | r32[eax]);
    r32[esp] += 4; return;
  case 0x1af3fd: // 0160:1af3fd
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) + 0x0003);
    memoryASet16(ds, 0x20d7dd, r16[bx]);
    r16[ax] = r16[bx];
    r16[bx] -= memoryAGet16(ds, 0x20cfa7);
    r16[bx] += r16[ax];
    r16[bx] &= 0x03ff;
    memoryASet16(ds, 0x20cfa7, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (!(memoryAGet16(ds, 0x20d7dd) & 0xffff))
        { pc = 0x1af441; break; }
    if (memoryAGet16(ds, 0x20d7dd) != 0x0100)
        { pc = 0x1af450; break; }
  case 0x1af441: // 0160:1af441
    r16[bx] = r16[ax];
    r16[bx] >>>= 2;
    r16[ax] -= r16[bx];
    if (r16s[ax] >= 0)
        { pc = 0x1af450; break; }
    r16[ax] = 0;
  case 0x1af450: // 0160:1af450
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20d88f)))
        { pc = 0x1af45f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d88f);
  case 0x1af45f: // 0160:1af45f
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20d2cb);
    memoryASet16(ds, 0x20cf83, r16[bp]);
    yield* sub_1afd70();
    memoryASet16(ds, 0x20d889, 0x0001);
    r16[ax] = 0x0001;
    flags.zero = !(r8[al] | r8[al]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1af488() // 0160:1af488 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x001ec660;
    memoryASet32(ds, 0x20d7d7, r32[eax]);
    r32[esi] = 0x001fff90;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r32[esi] += r32[eax];
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af4f6; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af501; break; }
  case 0x1af4f6: // 0160:1af4f6
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af6f5; break; }
  case 0x1af501: // 0160:1af501
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af557; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af562; break; }
  case 0x1af557: // 0160:1af557
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af6f5; break; }
  case 0x1af562: // 0160:1af562
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af5b8; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af5c3; break; }
  case 0x1af5b8: // 0160:1af5b8
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af6f5; break; }
  case 0x1af5c3: // 0160:1af5c3
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16s[bp] < 0)
        { pc = 0x1af6f0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af622; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af62d; break; }
  case 0x1af622: // 0160:1af622
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af6f5; break; }
  case 0x1af62d: // 0160:1af62d
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x8);
    if (r16s[bp] < 0)
        { pc = 0x1af6f0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af68c; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af693; break; }
  case 0x1af68c: // 0160:1af68c
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af6f5; break; }
  case 0x1af693: // 0160:1af693
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xa);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af6e9; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af6f0; break; }
  case 0x1af6e9: // 0160:1af6e9
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af6f5; break; }
  case 0x1af6f0: // 0160:1af6f0
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1af6f5: // 0160:1af6f5
    memoryASet16(ds, 0x20cf5f, memoryAGet16(ds, 0x20cf5f) - 0x0003);
    memoryASet16(ds, 0x20d7dd, r16[bx]);
    r16[ax] = r16[bx];
    r16[bx] -= memoryAGet16(ds, 0x20cfa7);
    r16[bx] += r16[ax];
    r16[bx] &= 0x03ff;
    memoryASet16(ds, 0x20cfa7, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (!(memoryAGet16(ds, 0x20d7dd) & 0xffff))
        { pc = 0x1af739; break; }
    if (memoryAGet16(ds, 0x20d7dd) != 0x0100)
        { pc = 0x1af748; break; }
  case 0x1af739: // 0160:1af739
    r16[bx] = r16[ax];
    r16[bx] >>>= 2;
    r16[ax] -= r16[bx];
    if (r16s[ax] >= 0)
        { pc = 0x1af748; break; }
    r16[ax] = 0;
  case 0x1af748: // 0160:1af748
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20d893)))
        { pc = 0x1af757; break; }
    r16[ax] = memoryAGet16(ds, 0x20d893);
  case 0x1af757: // 0160:1af757
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20d2cb);
    memoryASet16(ds, 0x20cf83, r16[bp]);
    yield* sub_1afd70();
    memoryASet16(ds, 0x20d889, 0x0001);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1af780() // 0160:1af780 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x001ec6b4;
    memoryASet32(ds, 0x20d7d7, r32[eax]);
    r32[esi] = 0x001ffe10;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r32[esi] += r32[eax];
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af7ee; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af7f9; break; }
  case 0x1af7ee: // 0160:1af7ee
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af9ed; break; }
  case 0x1af7f9: // 0160:1af7f9
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af84f; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af85a; break; }
  case 0x1af84f: // 0160:1af84f
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af9ed; break; }
  case 0x1af85a: // 0160:1af85a
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af8b0; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af8bb; break; }
  case 0x1af8b0: // 0160:1af8b0
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af9ed; break; }
  case 0x1af8bb: // 0160:1af8bb
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16s[bp] < 0)
        { pc = 0x1af9e8; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af91a; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af925; break; }
  case 0x1af91a: // 0160:1af91a
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af9ed; break; }
  case 0x1af925: // 0160:1af925
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x8);
    if (r16s[bp] < 0)
        { pc = 0x1af9e8; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af984; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af98b; break; }
  case 0x1af984: // 0160:1af984
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af9ed; break; }
  case 0x1af98b: // 0160:1af98b
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xa);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1af9e1; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1af9e8; break; }
  case 0x1af9e1: // 0160:1af9e1
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1af9ed; break; }
  case 0x1af9e8: // 0160:1af9e8
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1af9ed: // 0160:1af9ed
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) + 0x0003);
    memoryASet16(ds, 0x20d7dd, r16[bx]);
    r16[ax] = r16[bx];
    r16[bx] -= memoryAGet16(ds, 0x20cfa7);
    r16[bx] += r16[ax];
    r16[bx] &= 0x03ff;
    memoryASet16(ds, 0x20cfa7, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (!(memoryAGet16(ds, 0x20d7dd) & 0xffff))
        { pc = 0x1afa31; break; }
    if (memoryAGet16(ds, 0x20d7dd) != 0x0100)
        { pc = 0x1afa40; break; }
  case 0x1afa31: // 0160:1afa31
    r16[bx] = r16[ax];
    r16[bx] >>>= 2;
    r16[ax] -= r16[bx];
    if (r16s[ax] >= 0)
        { pc = 0x1afa40; break; }
    r16[ax] = 0;
  case 0x1afa40: // 0160:1afa40
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20d891)))
        { pc = 0x1afa4f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d891);
  case 0x1afa4f: // 0160:1afa4f
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20d2cb);
    memoryASet16(ds, 0x20cf83, r16[bp]);
    yield* sub_1afd70();
    memoryASet16(ds, 0x20d889, 0x0001);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1afa78() // 0160:1afa78 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x001ec708;
    memoryASet32(ds, 0x20d7d7, r32[eax]);
    r32[esi] = 0x00200110;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r32[esi] += r32[eax];
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afae6; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afaf1; break; }
  case 0x1afae6: // 0160:1afae6
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1afce5; break; }
  case 0x1afaf1: // 0160:1afaf1
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afb47; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afb52; break; }
  case 0x1afb47: // 0160:1afb47
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1afce5; break; }
  case 0x1afb52: // 0160:1afb52
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afba8; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afbb3; break; }
  case 0x1afba8: // 0160:1afba8
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1afce5; break; }
  case 0x1afbb3: // 0160:1afbb3
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16s[bp] < 0)
        { pc = 0x1afce0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afc12; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afc1d; break; }
  case 0x1afc12: // 0160:1afc12
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1afce5; break; }
  case 0x1afc1d: // 0160:1afc1d
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x8);
    if (r16s[bp] < 0)
        { pc = 0x1afce0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afc7c; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afc83; break; }
  case 0x1afc7c: // 0160:1afc7c
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1afce5; break; }
  case 0x1afc83: // 0160:1afc83
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xa);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebp] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afcd9; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afce0; break; }
  case 0x1afcd9: // 0160:1afcd9
    yield* sub_1cd75c();
    if (!flags.zero)
        { pc = 0x1afce5; break; }
  case 0x1afce0: // 0160:1afce0
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1afce5: // 0160:1afce5
    memoryASet16(ds, 0x20cf71, memoryAGet16(ds, 0x20cf71) - 0x0003);
    memoryASet16(ds, 0x20d7dd, r16[bx]);
    r16[ax] = r16[bx];
    r16[bx] -= memoryAGet16(ds, 0x20cfa7);
    r16[bx] += r16[ax];
    r16[bx] &= 0x03ff;
    memoryASet16(ds, 0x20cfa7, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (!(memoryAGet16(ds, 0x20d7dd) & 0xffff))
        { pc = 0x1afd29; break; }
    if (memoryAGet16(ds, 0x20d7dd) != 0x0100)
        { pc = 0x1afd38; break; }
  case 0x1afd29: // 0160:1afd29
    r16[bx] = r16[ax];
    r16[bx] >>>= 2;
    r16[ax] -= r16[bx];
    if (r16s[ax] >= 0)
        { pc = 0x1afd38; break; }
    r16[ax] = 0;
  case 0x1afd38: // 0160:1afd38
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20d895)))
        { pc = 0x1afd47; break; }
    r16[ax] = memoryAGet16(ds, 0x20d895);
  case 0x1afd47: // 0160:1afd47
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20d2cb);
    memoryASet16(ds, 0x20cf83, r16[bp]);
    yield* sub_1afd70();
    memoryASet16(ds, 0x20d889, 0x0001);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1afd70() // 0160:1afd70 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20d10f) & 0xffff))
        { pc = 0x1afd82; break; }
    r8[al] = 0x6c;
    yield* sub_1b17b7();
  case 0x1afd82: // 0160:1afd82
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1afd83() // 0160:1afd83 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20ee15) & 0xffff)
        { pc = 0x1aff04; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r32[ebx] = 0;
    r32[ebx] = r32[eax];
    r16[bx] <<= 3;
    r16[ax] = r16[bx];
    r16[bx] <<= 2;
    r16[bx] += r16[ax];
    r32[edi] = 0x00200410;
    r32[edi] += r32[ebx];
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x4);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x6);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[esi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afdff; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afe0a; break; }
  case 0x1afdff: // 0160:1afdff
    yield* sub_1aff13();
    if (!flags.zero)
        { pc = 0x1aff0b; break; }
  case 0x1afe0a: // 0160:1afe0a
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x10);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x12);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[esi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afe53; break; }
    if (r8s[al] < signed8(0x20))
        { pc = 0x1afe5e; break; }
  case 0x1afe53: // 0160:1afe53
    yield* sub_1aff13();
    if (!flags.zero)
        { pc = 0x1aff0b; break; }
  case 0x1afe5e: // 0160:1afe5e
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x18);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x1a);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    r32[esi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8s[al] < 0)
        { pc = 0x1afea7; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1afeb2; break; }
  case 0x1afea7: // 0160:1afea7
    yield* sub_1aff13();
    if (!flags.zero)
        { pc = 0x1aff0b; break; }
  case 0x1afeb2: // 0160:1afeb2
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x24);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x26);
    r16[ax] += memoryAGet16(ds, 0x20cf5f);
    r16[bx] += memoryAGet16(ds, 0x20cf71);
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    push(r16[dx]);
    mul16(memoryAGet16(ds, 0x20cef7));
    r16[dx] = pop();
    r16[ax] += r16[bx];
    flags.sign = r16s[ax] < 0;
    r32[esi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (flags.sign)
        { pc = 0x1afef9; break; }
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1aff04; break; }
  case 0x1afef9: // 0160:1afef9
    yield* sub_1aff13();
    if (!flags.zero)
        { pc = 0x1aff0b; break; }
  case 0x1aff04: // 0160:1aff04
    r16[ax] = 0;
    r32[esp] += 4; return;
  case 0x1aff0b: // 0160:1aff0b
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1aff13() // 0160:1aff13 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] &= 0x00ff;
    r16[ax] <<= 4;
    r16[cx] &= 0x0018;
    r16[cx] >>>= 1;
    r16[dx] &= 0x0018;
    r16[dx] >>>= 3;
    r16[cx] += r16[dx];
    r16[ax] += r16[cx];
    r32[esi] = memoryAGet32(ds, 0x20e821);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[al] == 0x20)
        { pc = 0x1aff45; break; }
    if (r8s[al] < signed8(0x2c))
        { pc = 0x1aff4d; break; }
    if (r8s[al] >= signed8(0x38))
        { pc = 0x1aff4d; break; }
  case 0x1aff45: // 0160:1aff45
    r16[ax] = 0x0001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1aff4d: // 0160:1aff4d
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1aff53() // 0160:1aff53 +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d7f5, 0x0001);
    r32[esi] = 0x00203e42;
    r16[ax] = 0x0010;
    r16[cx] = 0x000e;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d7b9, r16[dx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[eax] + 0xa);
    memoryASet32(ds, 0x20d859, r32[edx]);
    memoryASet16(ds, 0x20ee5b, 0x0001);
    memoryASet16(ds, 0x20ee5d, 0x0000);
    memoryASet16(ds, 0x20ee53, 0x0140);
    memoryASet16(ds, 0x20ee55, 0x00e0);
    yield* sub_1abc11();
    r16[ax] = memoryAGet16(ds, 0x20ee57);
    memoryASet16(ds, 0x20d80d, r16[ax]);
    memoryASet16(ds, 0x20ee5d, 0x0001);
    memoryASet16(ds, 0x20ee53, 0x0120);
    memoryASet16(ds, 0x20ee55, 0x00c8);
    yield* sub_1abc11();
    r16[ax] = memoryAGet16(ds, 0x20ee57);
    memoryASet16(ds, 0x20d811, r16[ax]);
    memoryASet16(ds, 0x20ee53, 0x0100);
    memoryASet16(ds, 0x20ee55, 0x00b4);
    yield* sub_1abc11();
    r16[ax] = memoryAGet16(ds, 0x20ee57);
    memoryASet16(ds, 0x20d815, r16[ax]);
    memoryASet16(ds, 0x20ee53, 0x00f0);
    memoryASet16(ds, 0x20ee55, 0x00a8);
    yield* sub_1abc11();
    r16[ax] = memoryAGet16(ds, 0x20ee57);
    memoryASet16(ds, 0x20d819, r16[ax]);
    memoryASet16(ds, 0x20ee53, 0x00e0);
    memoryASet16(ds, 0x20ee55, 0x009c);
    yield* sub_1abc11();
    r16[ax] = memoryAGet16(ds, 0x20ee57);
    memoryASet16(ds, 0x20d81d, r16[ax]);
    memoryASet16(ds, 0x20ee5b, 0x0000);
    memoryASet16(ds, 0x20ee5d, 0x0000);
    r32[esp] += 4;
}
function* sub_1b0063() // 0160:1b0063 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20cef5, 0x0000);
    r32[esi] = 0x00201a20;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20edfd, r16[ax]);
    yield* sub_1a8499();
    r32[eax] = 0;
    memoryASet(ds, 0x1f1c44, r8[al]);
    memoryASet16(ds, 0x20d2bb, r16[ax]);
    memoryASet16(ds, 0x20d2bd, r16[ax]);
    memoryASet16(ds, 0x20d2bf, r16[ax]);
    memoryASet16(ds, 0x20d2c1, r16[ax]);
    memoryASet16(ds, 0x20eda7, 0x0001);
    r32[esi] = 0x0020cf39;
    r32[eax] = 0x0020d2c7;
    r32[eax] -= r32[esi];
    r32[eax] >>>= 2;
  case 0x1b00be: // 0160:1b00be
    memoryASet32(ds, r32[esi], 0x00000000);
    r32[esi] += 0x00000004;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b00be; break; }
    r32[eax] = 0;
    memoryASet16(ds, 0x20d89d, r16[ax]);
    r32[esi] = 0x002019a8;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r16[ax] &= 0x00ff;
    memoryASet16(ds, 0x20ed9d, r16[ax]);
    r32[esi] = 0x002018f4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20edcf, r16[ax]);
    r32[esi] = 0x00201930;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20edff, r16[ax]);
    r32[esi] = 0x002019e4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ed9f, r16[ax]);
    r16[bx] = 0x00b0;
    r16[cx] = 0x000e;
    r16[dx] = 0xfff2;
    memoryASet16(ds, 0x20e7fd, 0x00a2);
    memoryASet16(ds, 0x20e801, 0xff5e);
    r32[esi] = 0x00201da4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (!r16[ax])
        { pc = 0x1b0181; break; }
    r16[bx] = 0x0058;
    r16[cx] = 0x001c;
    r16[dx] = 0xffe4;
    memoryASet16(ds, 0x20e7fd, 0x0094);
    memoryASet16(ds, 0x20e801, 0xff6c);
  case 0x1b0181: // 0160:1b0181
    memoryASet16(ds, 0x20d7e7, r16[bx]);
    memoryASet16(ds, 0x20d7e9, r16[cx]);
    memoryASet16(ds, 0x20d7eb, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20d7ed, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d7ef, r16[ax]);
    r32[eax] = 0;
    r32[esi] = 0x001ec130;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d76f, r32[eax]);
    yield* sub_1b29b6();
    r32[ecx] = 0;
    r32[esi] = 0x00201cb4;
    r16[cx] = memoryAGet16(ds, 0x20d7b9);
    r16[cx] <<= 2;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    memoryASet16(ds, 0x20ce93, 0x0004);
    r32[eax] = 0;
    memoryASet32(ds, 0x20d77b, r32[eax]);
    memoryASet16(ds, 0x20d77f, r16[ax]);
    memoryASet32(ds, 0x20d799, r32[eax]);
    memoryASet16(ds, 0x20d79d, r16[ax]);
    memoryASet(ds, 0x20d793, 0x09);
    memoryASet(ds, 0x20d794, 0x05);
    memoryASet(ds, 0x20d795, 0x09);
    memoryASet(ds, 0x20d796, 0x09);
    memoryASet(ds, 0x20d797, 0x09);
    memoryASet16(ds, 0x20d79f, r16[ax]);
    memoryASet16(ds, 0x20d7a1, 0x0057);
    memoryASet16(ds, 0x20d7d3, r16[ax]);
    r16[ax] = 0x0003;
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1b0262; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec8d);
  case 0x1b0262: // 0160:1b0262
    memoryASet16(ds, 0x20d081, r16[ax]);
    memoryASet16(ds, 0x20d083, r16[ax]);
    memoryASet16(ds, 0x20d085, r16[ax]);
    memoryASet16(ds, 0x20d087, r16[ax]);
    r16[ax] = 0x0042;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    r16[ax] = 0x00af;
    if (memoryAGet16(ds, 0x20d7b9) == 0x002b)
        { pc = 0x1b02c6; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x0007)
        { pc = 0x1b02ca; break; }
  case 0x1b02c6: // 0160:1b02c6
    r16[ax] = 0x04af;
  case 0x1b02ca: // 0160:1b02ca
    memoryASet16(ds, 0x20d04b, r16[ax]);
    memoryASet16(ds, 0x20d04d, r16[ax]);
    memoryASet16(ds, 0x20d04f, r16[ax]);
    memoryASet16(ds, 0x20d051, r16[ax]);
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20d0ff, r16[ax]);
    memoryASet16(ds, 0x20d101, r16[ax]);
    memoryASet16(ds, 0x20d103, r16[ax]);
    memoryASet16(ds, 0x20d105, r16[ax]);
    memoryASet16(ds, 0x20d111, r16[ax]);
    memoryASet16(ds, 0x20d113, r16[ax]);
    memoryASet16(ds, 0x20d115, r16[ax]);
    memoryASet16(ds, 0x20d117, r16[ax]);
    r32[esi] = 0x00201ad4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 3;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20cf4f, r16[bx]);
    memoryASet16(ds, 0x20cf53, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20cf61, r16[bx]);
    memoryASet16(ds, 0x20cf63, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet16(ds, 0x20cf51, r16[bx]);
    memoryASet16(ds, 0x20cf55, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    memoryASet16(ds, 0x20cf65, r16[bx]);
    memoryASet16(ds, 0x20cf67, r16[bx]);
    if (memoryAGet16(ds, 0x20d7b9) == 0x0015)
        { pc = 0x1b0388; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0013)
        { pc = 0x1b0388; break; }
    { pc = 0x1b03e4; break; }
  case 0x1b0388: // 0160:1b0388
    r32[esi] = 0x00201ad4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 3;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20cf4f, r16[bx]);
    memoryASet16(ds, 0x20cf51, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20cf61, r16[bx]);
    memoryASet16(ds, 0x20cf65, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet16(ds, 0x20cf53, r16[bx]);
    memoryASet16(ds, 0x20cf55, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    memoryASet16(ds, 0x20cf63, r16[bx]);
    memoryASet16(ds, 0x20cf67, r16[bx]);
  case 0x1b03e4: // 0160:1b03e4
    r32[esi] = 0x00204a3e;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d85d, r32[esi]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xa);
    memoryASet16(ds, 0x20e7cf, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xc);
    memoryASet16(ds, 0x20e7d1, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xe);
    memoryASet16(ds, 0x20e7d3, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x10);
    memoryASet16(ds, 0x20e7d5, r16[bp]);
    memoryASet16(ds, 0x20e7d7, 0x0000);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20d003, r16[ax]);
    memoryASet16(ds, 0x20d005, r16[ax]);
    memoryASet16(ds, 0x20d007, r16[ax]);
    memoryASet16(ds, 0x20d009, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20d015, r16[ax]);
    memoryASet16(ds, 0x20d017, r16[ax]);
    memoryASet16(ds, 0x20d019, r16[ax]);
    memoryASet16(ds, 0x20d01b, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20d027, r16[ax]);
    memoryASet16(ds, 0x20d029, r16[ax]);
    memoryASet16(ds, 0x20d02b, r16[ax]);
    memoryASet16(ds, 0x20d02d, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20cff1, r16[ax]);
    memoryASet16(ds, 0x20cff3, r16[ax]);
    memoryASet16(ds, 0x20cff5, r16[ax]);
    memoryASet16(ds, 0x20cff7, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20cfdf, r16[ax]);
    memoryASet16(ds, 0x20cfe1, r16[ax]);
    memoryASet16(ds, 0x20cfe3, r16[ax]);
    memoryASet16(ds, 0x20cfe5, r16[ax]);
    memoryASet16(ds, 0x20cf3d, 0x0001);
    memoryASet16(ds, 0x20cf3f, 0x0005);
    memoryASet16(ds, 0x20cf41, 0x0006);
    memoryASet16(ds, 0x20cf43, 0x0007);
    memoryASet16(ds, 0x20cf45, 0x0008);
    memoryASet16(ds, 0x20cf47, 0x0009);
    memoryASet16(ds, 0x20cf49, 0x000a);
    memoryASet16(ds, 0x20cf4b, 0x000b);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d217, r16[ax]);
    memoryASet16(ds, 0x20d219, r16[ax]);
    memoryASet16(ds, 0x20d21b, r16[ax]);
    memoryASet16(ds, 0x20d21d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] == 0x0001)
        { pc = 0x1b0715; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b06f5; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1b064a; break; }
    memoryASet16(ds, 0x20d7d3, 0x0001);
    memoryASet16(ds, 0x20cf3f, 0x0002);
    memoryASet16(ds, 0x20cf41, 0x0003);
    memoryASet16(ds, 0x20cf43, 0x0004);
    if (memoryAGet16(ds, 0x20d7b9) == 0x0015)
        { pc = 0x1b05d9; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0013)
        { pc = 0x1b05d9; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) - 0x000f);
    memoryASet16(ds, 0x20cf51, memoryAGet16(ds, 0x20cf51) - 0x001e);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf67, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf55, r16[ax]);
    memoryASet16(ds, 0x20cf53, memoryAGet16(ds, 0x20cf53) + 0x0032);
    memoryASet16(ds, 0x20cf55, memoryAGet16(ds, 0x20cf55) + 0x004b);
    { pc = 0x1b0629; break; }
  case 0x1b05d9: // 0160:1b05d9
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) - 0x000f);
    memoryASet16(ds, 0x20cf63, memoryAGet16(ds, 0x20cf63) - 0x001e);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf67, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf55, r16[ax]);
    memoryASet16(ds, 0x20cf65, memoryAGet16(ds, 0x20cf65) + 0x0032);
    memoryASet16(ds, 0x20cf67, memoryAGet16(ds, 0x20cf67) + 0x004b);
  case 0x1b0629: // 0160:1b0629
    r16[ax] = 0x0006;
    memoryASet16(ds, 0x20ce95, r16[ax]);
    memoryASet16(ds, 0x20ce97, r16[ax]);
    memoryASet16(ds, 0x20ce99, r16[ax]);
    memoryASet16(ds, 0x20ce9b, r16[ax]);
    { pc = 0x1b0715; break; }
  case 0x1b064a: // 0160:1b064a
    memoryASet16(ds, 0x20d7d3, 0x0001);
    if (memoryAGet16(ds, 0x20d7b9) == 0x0015)
        { pc = 0x1b0699; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0013)
        { pc = 0x1b0699; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) - 0x000a);
    memoryASet16(ds, 0x20cf51, memoryAGet16(ds, 0x20cf51) - 0x0014);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    memoryASet16(ds, 0x20cf53, memoryAGet16(ds, 0x20cf53) + 0x003c);
    { pc = 0x1b06c9; break; }
  case 0x1b0699: // 0160:1b0699
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) - 0x000a);
    memoryASet16(ds, 0x20cf63, memoryAGet16(ds, 0x20cf63) - 0x0014);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    memoryASet16(ds, 0x20cf65, memoryAGet16(ds, 0x20cf65) + 0x003c);
  case 0x1b06c9: // 0160:1b06c9
    memoryASet16(ds, 0x20cf3f, 0x0002);
    memoryASet16(ds, 0x20cf41, 0x0003);
    r16[ax] = 0x0004;
    memoryASet16(ds, 0x20ce95, r16[ax]);
    memoryASet16(ds, 0x20ce97, r16[ax]);
    memoryASet16(ds, 0x20ce99, r16[ax]);
    r32[eax] = 0;
    { pc = 0x1b070f; break; }
  case 0x1b06f5: // 0160:1b06f5
    memoryASet16(ds, 0x20d7d3, 0x0001);
    memoryASet16(ds, 0x20cf3f, 0x0002);
    r32[eax] = 0;
    memoryASet16(ds, 0x20cf41, r16[ax]);
  case 0x1b070f: // 0160:1b070f
    memoryASet16(ds, 0x20cf43, r16[ax]);
  case 0x1b0715: // 0160:1b0715
    r32[eax] = 0;
    memoryASet16(ds, 0x20cf45, r16[ax]);
    memoryASet16(ds, 0x20cf47, r16[ax]);
    memoryASet16(ds, 0x20cf49, r16[ax]);
    memoryASet16(ds, 0x20cf4b, r16[ax]);
    if (memoryAGet16(ds, 0x20d89f) == 0x0001)
        { pc = 0x1b078c; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1b08ea; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1b08ea; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[cx] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20cf4f, r16[cx]);
    r16[cx] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20cf61, r16[cx]);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    memoryASet16(ds, 0x20cf65, r16[bx]);
  case 0x1b078c: // 0160:1b078c
    r32[esi] = memoryAGet32(ds, 0x20d859);
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d005, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d017, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d029, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cff3, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cfe1, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d83b, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d843, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d84b, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d853, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d007, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d019, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d02b, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cff5, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cfe3, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d83d, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d845, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d84d, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d855, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d009, r16[bp]);
    r32[esi] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d01b, r16[bp]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d02d, r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cff7, r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cfe5, r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d83f, r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d847, r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d84f, r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20d857, r16[ax]);
    r32[esi] += 0x00000002;
  case 0x1b08ea: // 0160:1b08ea
    r32[eax] = 0;
    memoryASet32(ds, 0x20d773, r32[eax]);
    memoryASet32(ds, 0x20d777, r32[eax]);
    memoryASet(ds, 0x20d773, 0x01);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1b0930; break; }
    memoryASet(ds, 0x20d774, 0x01);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1b0930; break; }
    memoryASet(ds, 0x20d775, 0x01);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1b0930; break; }
    memoryASet(ds, 0x20d776, 0x01);
  case 0x1b0930: // 0160:1b0930
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1b09c2; break; }
    r32[eax] = 0;
    memoryASet16(ds, 0x20cf3f, r16[ax]);
    memoryASet16(ds, 0x20cf41, r16[ax]);
    memoryASet16(ds, 0x20cf43, r16[ax]);
    if (memoryAGet16(ds, 0x20d7b9) == 0x0013)
        { pc = 0x1b0967; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x0015)
        { pc = 0x1b0971; break; }
  case 0x1b0967: // 0160:1b0967
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) + 0x0014);
    { pc = 0x1b09a1; break; }
  case 0x1b0971: // 0160:1b0971
    if (memoryAGet16(ds, 0x20d7b9) != 0x0007)
        { pc = 0x1b0985; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) + 0x0014);
    { pc = 0x1b09a1; break; }
  case 0x1b0985: // 0160:1b0985
    if (memoryAGet16(ds, 0x20d7b9) != 0x000d)
        { pc = 0x1b0999; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) + 0x0014);
    { pc = 0x1b09a1; break; }
  case 0x1b0999: // 0160:1b0999
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) + 0x0014);
  case 0x1b09a1: // 0160:1b09a1
    memoryASet16(ds, 0x20cf41, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
  case 0x1b09c2: // 0160:1b09c2
    r32[eax] = 0;
    memoryASet16(ds, 0x20d2b9, r16[ax]);
    memoryASet16(ds, 0x20d7a9, r16[ax]);
    memoryASet16(ds, 0x20d7ad, r16[ax]);
    memoryASet16(ds, 0x20d7af, r16[ax]);
    r32[esi] = 0x0020d221;
    r32[ecx] = 0x00000008;
  case 0x1b09e6: // 0160:1b09e6
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b09e6; break; }
    memoryASet16(ds, 0x20d7ab, r16[ax]);
    memoryASet16(ds, 0x20d7a3, r16[ax]);
    memoryASet16(ds, 0x20d7a7, r16[ax]);
    memoryASet16(ds, 0x20d7a5, r16[ax]);
    memoryASet16(ds, 0x20d7b1, r16[ax]);
    memoryASet16(ds, 0x20d7b5, r16[ax]);
    memoryASet16(ds, 0x20d7b7, r16[ax]);
    r32[esi] = 0x0020d251;
    r32[ecx] = 0x00000030;
  case 0x1b0a22: // 0160:1b0a22
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b0a22; break; }
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000100;
  case 0x1b0a34: // 0160:1b0a34
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b0a34; break; }
    r32[esi] = 0x00201de0;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax]);
    if (!r32[eax])
        { pc = 0x1b0a6d; break; }
    r32[esi] = r32[eax];
    r32[edi] = 0x0020d36d;
  case 0x1b0a5b: // 0160:1b0a5b
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    if (r16[ax] != 0xffff)
        { pc = 0x1b0a5b; break; }
  case 0x1b0a6d: // 0160:1b0a6d
    memoryASet16(ds, 0x20d16d, 0x0000);
    memoryASet16(ds, 0x20d16f, 0x0002);
    memoryASet16(ds, 0x20d171, 0x0004);
    memoryASet16(ds, 0x20d173, 0x0006);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d803, r16[ax]);
    memoryASet32(ds, 0x20d7fb, r32[eax]);
    memoryASet32(ds, 0x20d7ff, r32[eax]);
    memoryASet16(ds, 0x20d7f7, 0xffb0);
    memoryASet16(ds, 0x20d7f9, 0x0050);
    memoryASet16(ds, 0x20d825, 0x0005);
    memoryASet16(ds, 0x20d869, r16[ax]);
    memoryASet16(ds, 0x20d861, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    memoryASet16(ds, 0x20d881, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    memoryASet16(ds, 0x20d883, r16[ax]);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d885, r16[ax]);
    memoryASet16(ds, 0x20d887, r16[ax]);
    memoryASet16(ds, 0x20d897, r16[ax]);
    r32[esi] = 0x00201a5c;
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7b9);
    r8[al] = memoryAGet(ds, r32[esi] + r32[ecx]);
    memoryASet(ds, 0x20d88b, r8[al]);
    memoryASet(ds, 0x20d88d, r8[al]);
    memoryASet16(ds, 0x20d88f, 0x003c);
    memoryASet16(ds, 0x20d891, 0x003c);
    memoryASet16(ds, 0x20d893, 0x003c);
    memoryASet16(ds, 0x20d895, 0x003c);
    memoryASet16(ds, 0x20dcc3, 0xffff);
    memoryASet16(ds, 0x20d8bd, 0xffff);
    memoryASet(ds, 0x20d8c0, 0x00);
    memoryASet(ds, 0x20d8bf, 0x00);
    r32[esi] = 0x0020dcc5;
    r32[ecx] = 0x000001ff;
  case 0x1b0b5f: // 0160:1b0b5f
    memoryASet16(ds, r32[esi], 0xffff);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b0b5f; break; }
    r32[eax] = 0;
    memoryASet16(ds, 0x20ee3b, r16[ax]);
    memoryASet16(ds, 0x20ed97, r16[ax]);
    memoryASet16(ds, 0x20ed99, r16[ax]);
    memoryASet16(ds, 0x20ed9b, r16[ax]);
    r32[eax] = 0;
    memoryASet16(ds, 0x20ed95, r16[ax]);
    memoryASet16(ds, 0x20ed93, r16[ax]);
    memoryASet32(ds, 0x20c84e, 0xe7190345);
    memoryASet32(ds, 0x20c852, 0xe7190345);
    memoryASet16(ds, 0x20c830, r16[ax]);
    memoryASet16(ds, 0x20c82e, r16[ax]);
    memoryASet16(ds, 0x20d87f, r16[ax]);
    memoryASet16(ds, 0x20eddd, r16[ax]);
    memoryASet16(ds, 0x20ede1, r16[ax]);
    memoryASet16(ds, 0x20ede5, r16[ax]);
    memoryASet16(ds, 0x20ede7, r16[ax]);
    memoryASet16(ds, 0x20ede9, r16[ax]);
    memoryASet16(ds, 0x20ee31, r16[ax]);
    memoryASet16(ds, 0x20ee35, r16[ax]);
    memoryASet16(ds, 0x20ee47, r16[ax]);
    memoryASet16(ds, 0x20ee37, 0x008c);
    memoryASet16(ds, 0x20e7df, r16[ax]);
    memoryASet16(ds, 0x20e7e1, r16[ax]);
    memoryASet16(ds, 0x20e7e3, r16[ax]);
    memoryASet16(ds, 0x20e7e5, 0x0008);
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1b0c1f; break; }
    memoryASet16(ds, 0x20e7e5, 0x0010);
  case 0x1b0c1f: // 0160:1b0c1f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b0c20() // 0160:1b0c20 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20ee15) & 0xffff)
        { pc = 0x1b0c44; break; }
    r32[edi] = 0x0020d251;
    r16[bp] = r16[cx];
    r32[ecx] = 0x00000004;
  case 0x1b0c38: // 0160:1b0c38
    if (!(memoryAGet16(ds, r32[edi]) & 0xffff))
        { pc = 0x1b0c45; break; }
    r32[edi] += 0x0000000c;
    if (--r32[ecx])
        { pc = 0x1b0c38; break; }
  case 0x1b0c44: // 0160:1b0c44
    r32[esp] += 4; return;
  case 0x1b0c45: // 0160:1b0c45
    r16[cx] = r16[bp];
    r32[esi] = 0x00204e38;
    r32[eax] &= 0x0000001f;
    r32[eax] <<= 3;
    r16[dx] = r16[bx];
    r16[bp] = r16[cx];
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] += memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, r32[edi], 0x0001);
    memoryASet16(ds, r32[edi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[edi] + 0x4, r16[cx]);
    r16[dx] += memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    r16[bp] += memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    memoryASet16(ds, r32[edi] + 0x6, 0x0001);
    memoryASet16(ds, r32[edi] + 0x8, r16[dx]);
    memoryASet16(ds, r32[edi] + 0xa, r16[bp]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b0c88() // 0160:1b0c88 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020b80c;
    memoryASet32(ds, 0x20c85f, r32[esi]);
    r32[esi] = 0x001ec90c;
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1b0cdb; break; }
    r32[esi] = 0x001ec900;
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1b0cdb; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1b0cdb; break; }
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1b0cdb; break; }
    r32[esi] = 0x001ec918;
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1b0cdb; break; }
    r32[esi] = 0x001ec924;
  case 0x1b0cdb: // 0160:1b0cdb
    memoryASet32(ds, 0x20cecb, r32[esi]);
    r32[edx] = memoryAGet32(ds, r32[esi]);
    yield* sub_1aa484();
    r32[edi] = 0x002c5658;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x002c5344;
    memoryASet32(ds, 0x2eebb8, r32[ecx]);
    memoryASet32(ds, 0x2eebbc, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebbc);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0d2a: // 0160:1b0d2a
    r32[ecx] = 0x00000014;
  case 0x1b0d2f: // 0160:1b0d2f
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0d2f; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0d2a; break; }
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r32[eax] = 0x002c5798;
    { pc = 0x1b0da2; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b0da2: // 0160:1b0da2
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b0da2() // 0160:1b0da2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b0dfd() // 0160:1b0dfd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b0dfd; break; }
  case 0x1b0da2: // 0160:1b0da2
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
  case 0x1b0dfd: // 0160:1b0dfd
    r32[esi] = 0x00206adc;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax]);
    if (!r32[eax])
        { pc = 0x1b0ee2; break; }
    r32[esi] = r32[eax];
    memoryASet32(ds, 0x20cecb, r32[esi]);
    r32[edx] = memoryAGet32(ds, r32[esi]);
    yield* sub_1aa484();
    r32[edi] = 0x002da260;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x002d9f4c;
    memoryASet32(ds, 0x2eebc0, r32[ecx]);
    memoryASet32(ds, 0x2eebc4, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebc4);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0e6a: // 0160:1b0e6a
    r32[ecx] = 0x00000014;
  case 0x1b0e6f: // 0160:1b0e6f
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0e6f; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0e6a; break; }
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r32[eax] = 0x002da3a0;
    { pc = 0x1b0da2; break; }
  case 0x1b0ee2: // 0160:1b0ee2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b0ee3() // 0160:1b0ee3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b0ee3; break; }
  case 0x1b0da2: // 0160:1b0da2
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
    // gap 230 bytes // gap 230 bytes
  case 0x1b0ee3: // 0160:1b0ee3
    r32[esi] = 0x001ec24c;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 4;
    r32[esi] += r32[eax];
    r32[edx] = memoryAGet32(ds, r32[esi]);
    yield* sub_1aa484();
    r32[edi] = 0x0029be48;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x0029bb34;
    memoryASet32(ds, 0x2eeba8, r32[ecx]);
    memoryASet32(ds, 0x2eebac, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebac);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0f3f: // 0160:1b0f3f
    r32[ecx] = 0x00000014;
  case 0x1b0f44: // 0160:1b0f44
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0f44; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0f3f; break; }
    r32[edx] = 0x001ec8d6;
    yield* sub_1aa484();
    r32[edi] = 0x002b0a50;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x002b073c;
    memoryASet32(ds, 0x2eebb0, r32[ecx]);
    memoryASet32(ds, 0x2eebb4, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebb4);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0ff3: // 0160:1b0ff3
    r32[ecx] = 0x00000014;
  case 0x1b0ff8: // 0160:1b0ff8
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0ff8; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0ff3; break; }
    r32[esi] = 0x001ec24c;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 4;
    r32[esi] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, 0x20d82b, r32[ebx]);
    r32[eax] = 0x0029bf88;
    yield* sub_1b0da2();
    if (memoryAGet16(ds, 0x20d7b9) == 0x001e)
        { pc = 0x1b10be; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0013)
        { pc = 0x1b10be; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0032)
        { pc = 0x1b10be; break; }
    r32[esi] = 0x001ec228;
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1b10b4; break; }
    r32[esi] = 0x001ec234;
  case 0x1b10b4: // 0160:1b10b4
    r32[eax] = 0x002b0b90;
    { pc = 0x1b0da2; break; }
  case 0x1b10be: // 0160:1b10be
    r32[esi] = 0x001ec240;
    { pc = 0x1b10b4; break; }
    return;
  }
}
function* sub_1b0f0a() // 0160:1b0f0a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b0f0a; break; }
  case 0x1b0da2: // 0160:1b0da2
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
    // gap 269 bytes // gap 269 bytes
  case 0x1b0f0a: // 0160:1b0f0a
    r32[ecx] = 0x00014314;
    r32[edx] = 0x0029bb34;
    memoryASet32(ds, 0x2eeba8, r32[ecx]);
    memoryASet32(ds, 0x2eebac, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebac);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0f3f: // 0160:1b0f3f
    r32[ecx] = 0x00000014;
  case 0x1b0f44: // 0160:1b0f44
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0f44; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0f3f; break; }
    r32[edx] = 0x001ec8d6;
    yield* sub_1aa484();
    r32[edi] = 0x002b0a50;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x002b073c;
    memoryASet32(ds, 0x2eebb0, r32[ecx]);
    memoryASet32(ds, 0x2eebb4, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebb4);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1b0ff3: // 0160:1b0ff3
    r32[ecx] = 0x00000014;
  case 0x1b0ff8: // 0160:1b0ff8
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b0ff8; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1b0ff3; break; }
    r32[esi] = 0x001ec24c;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 4;
    r32[esi] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, 0x20d82b, r32[ebx]);
    r32[eax] = 0x0029bf88;
    yield* sub_1b0da2();
    if (memoryAGet16(ds, 0x20d7b9) == 0x001e)
        { pc = 0x1b10be; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0013)
        { pc = 0x1b10be; break; }
    if (memoryAGet16(ds, 0x20d7b9) == 0x0032)
        { pc = 0x1b10be; break; }
    r32[esi] = 0x001ec228;
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1b10b4; break; }
    r32[esi] = 0x001ec234;
  case 0x1b10b4: // 0160:1b10b4
    r32[eax] = 0x002b0b90;
    { pc = 0x1b0da2; break; }
  case 0x1b10be: // 0160:1b10be
    r32[esi] = 0x001ec240;
    { pc = 0x1b10b4; break; }
    return;
  }
}
function* sub_1b10c5() // 0160:1b10c5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020c858;
    r32[eax] = 0x002246d0;
    r32[eax] -= r32[esi];
    r32[eax] >>>= 2;
  case 0x1b10d4: // 0160:1b10d4
    memoryASet32(ds, r32[esi], 0x00000000);
    r32[esi] += 0x00000004;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b10d4; break; }
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b10ec() // 0160:1b10ec +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020c814;
    r32[eax] = 0x002246d0;
    r32[eax] -= r32[esi];
    r32[eax] >>>= 2;
  case 0x1b10fb: // 0160:1b10fb
    memoryASet32(ds, r32[esi], 0x00000000);
    r32[esi] += 0x00000004;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b10fb; break; }
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b1113() // 0160:1b1113 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b16f9; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x0022)
        { pc = 0x1b1168; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0224)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    yield* sub_1b1c25();
    if (r8s[al] < signed8(0x40))
        { pc = 0x1b1703; break; }
    r16[ax] = 0x00f9;
    { pc = 0x1b1715; break; }
  case 0x1b1168: // 0160:1b1168
    if (memoryAGet16(ds, 0x20d7b9) != 0x0006)
        { pc = 0x1b11dd; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0215)
        { pc = 0x1b11a3; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8d) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8d, r16[ax]);
    r16[ax] = 0x0101;
    { pc = 0x1b1715; break; }
  case 0x1b11a3: // 0160:1b11a3
    if (memoryAGet16(ds, 0x20d04b) != 0x0453)
        { pc = 0x1b16f9; break; }
  case 0x1b11b2: // 0160:1b11b2
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x00ff;
    { pc = 0x1b1715; break; }
  case 0x1b11dd: // 0160:1b11dd
    if (memoryAGet16(ds, 0x20d7b9) != 0x0021)
        { pc = 0x1b11f8; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0647)
        { pc = 0x1b16f9; break; }
    { pc = 0x1b11b2; break; }
  case 0x1b11f8: // 0160:1b11f8
    if (memoryAGet16(ds, 0x20d7b9) != 0x001a)
        { pc = 0x1b1242; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x8e)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    r16[ax] = 0x0102;
    { pc = 0x1b1715; break; }
  case 0x1b1242: // 0160:1b1242
    if (memoryAGet16(ds, 0x20d7b9) != 0x0005)
        { pc = 0x1b12bc; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x057c)
        { pc = 0x1b127d; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    r16[ax] = 0x0103;
    { pc = 0x1b1715; break; }
  case 0x1b127d: // 0160:1b127d
    if (memoryAGet16(ds, 0x20d04b) != 0x0096)
        { pc = 0x1b16f9; break; }
    if (memoryAGet16(ds, 0x20d89b) == 0x0001)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8d) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8d, r16[ax]);
    r16[ax] = 0x0104;
    { pc = 0x1b1715; break; }
  case 0x1b12bc: // 0160:1b12bc
    if (memoryAGet16(ds, 0x20d7b9) != 0x002f)
        { pc = 0x1b1304; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0462)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    yield* sub_1b1c25();
    if (r8s[al] < signed8(0x40))
        { pc = 0x1b16fa; break; }
    r16[ax] = 0x0106;
    { pc = 0x1b1715; break; }
  case 0x1b1304: // 0160:1b1304
    if (memoryAGet16(ds, 0x20d7b9) != 0x0030)
        { pc = 0x1b1348; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0440)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    yield* sub_1b1c25();
    if (r8s[al] < signed8(0x40))
        { pc = 0x1b1703; break; }
    { pc = 0x1b16fa; break; }
  case 0x1b1348: // 0160:1b1348
    if (memoryAGet16(ds, 0x20d7b9) != 0x000a)
        { pc = 0x1b13b4; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0312)
        { pc = 0x1b1383; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    r16[ax] = 0x010b;
    { pc = 0x1b1715; break; }
  case 0x1b1383: // 0160:1b1383
    if (memoryAGet16(ds, 0x20d04b) != 0x0676)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8d) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8d, r16[ax]);
    r16[ax] = 0x010a;
    { pc = 0x1b1715; break; }
  case 0x1b13b4: // 0160:1b13b4
    if (memoryAGet16(ds, 0x20d7b9) != 0x0008)
        { pc = 0x1b1426; break; }
    if (memoryAGet16(ds, 0x20d04b) != 0x0222)
        { pc = 0x1b13e8; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    { pc = 0x1b1410; break; }
  case 0x1b13e8: // 0160:1b13e8
    if (memoryAGet16(ds, 0x20d04b) != 0x066e)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8d) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8d, r16[ax]);
  case 0x1b1410: // 0160:1b1410
    yield* sub_1b1c25();
    if (r8s[al] < signed8(0x40))
        { pc = 0x1b1703; break; }
    r16[ax] = 0x010b;
    { pc = 0x1b1715; break; }
  case 0x1b1426: // 0160:1b1426
    if (memoryAGet16(ds, 0x20d7b9) != 0x0016)
        { pc = 0x1b1460; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x64)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    r16[ax] = 0x0118;
    { pc = 0x1b1715; break; }
  case 0x1b1460: // 0160:1b1460
    if (memoryAGet16(ds, 0x20d7b9) != 0x0012)
        { pc = 0x1b14a7; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x22)
        { pc = 0x1b16f9; break; }
  case 0x1b1478: // 0160:1b1478
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    yield* sub_1b1c25();
    r8[al] &= 0x03;
    if (!r8[al])
        { pc = 0x1b1703; break; }
    r16[ax] = 0x011a;
    { pc = 0x1b1715; break; }
  case 0x1b14a7: // 0160:1b14a7
    if (memoryAGet16(ds, 0x20d7b9) != 0x0014)
        { pc = 0x1b14c1; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x64)
        { pc = 0x1b16f9; break; }
    { pc = 0x1b1478; break; }
  case 0x1b14c1: // 0160:1b14c1
    if (memoryAGet16(ds, 0x20d7b9) != 0x0019)
        { pc = 0x1b14fb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x28)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    r16[ax] = 0x0120;
    { pc = 0x1b1715; break; }
  case 0x1b14fb: // 0160:1b14fb
    if (memoryAGet16(ds, 0x20d7b9) != 0x0004)
        { pc = 0x1b1535; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x1c)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    r16[ax] = 0x0124;
    { pc = 0x1b1715; break; }
  case 0x1b1535: // 0160:1b1535
    if (memoryAGet16(ds, 0x20d7b9) != 0x002a)
        { pc = 0x1b1597; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x30)
        { pc = 0x1b1564; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    { pc = 0x1b1585; break; }
  case 0x1b1564: // 0160:1b1564
    if (r8[al] != 0x78)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8d) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8d, r16[ax]);
  case 0x1b1585: // 0160:1b1585
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x0140;
    { pc = 0x1b1715; break; }
  case 0x1b1597: // 0160:1b1597
    if (memoryAGet16(ds, 0x20d7b9) != 0x0009)
        { pc = 0x1b15da; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x9c)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x0142;
    { pc = 0x1b1715; break; }
  case 0x1b15da: // 0160:1b15da
    if (memoryAGet16(ds, 0x20d7b9) != 0x0025)
        { pc = 0x1b16f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    if (r8[al] != 0x36)
        { pc = 0x1b1614; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8b) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8b, r16[ax]);
  case 0x1b160b: // 0160:1b160b
    r16[ax] = 0x0146;
    { pc = 0x1b1715; break; }
  case 0x1b1614: // 0160:1b1614
    if (r8[al] != 0x40)
        { pc = 0x1b1647; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8d) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8d, r16[ax]);
  case 0x1b1635: // 0160:1b1635
    memoryASet16(ds, 0x20ee85, 0x0000);
    r16[ax] = 0x0147;
    { pc = 0x1b1715; break; }
  case 0x1b1647: // 0160:1b1647
    if (r8[al] != 0x5c)
        { pc = 0x1b1666; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee8f) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee8f, r16[ax]);
    { pc = 0x1b160b; break; }
  case 0x1b1666: // 0160:1b1666
    if (r8[al] != 0x66)
        { pc = 0x1b1689; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee91) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee91, r16[ax]);
    { pc = 0x1b1635; break; }
  case 0x1b1689: // 0160:1b1689
    if (r8[al] != 0x88)
        { pc = 0x1b16ac; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee95) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee95, r16[ax]);
    { pc = 0x1b1635; break; }
  case 0x1b16ac: // 0160:1b16ac
    if (r8[al] != 0x06)
        { pc = 0x1b16ce; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee97) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee97, r16[ax]);
    { pc = 0x1b160b; break; }
  case 0x1b16ce: // 0160:1b16ce
    if (r8[al] != 0x0e)
        { pc = 0x1b16f4; break; }
    r16[ax] = memoryAGet16(ds, 0x20d081);
    if (memoryAGet16(ds, 0x20ee99) == r16[ax])
        { pc = 0x1b16f9; break; }
    memoryASet16(ds, 0x20ee99, r16[ax]);
    { pc = 0x1b1635; break; }
  case 0x1b16f4: // 0160:1b16f4
    { pc = 0x1b16f9; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b16f9: // 0160:1b16f9
    r32[esp] += 4; return;
  case 0x1b16fa: // 0160:1b16fa
    r16[ax] = 0x0108;
    { pc = 0x1b1715; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b1703: // 0160:1b1703
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x00fa;
    { pc = 0x1b1715; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
    // gap 91257 bytes // gap 91257 bytes
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b1715() // 0160:1b1715 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
    // gap 91257 bytes // gap 91257 bytes
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b17b7() // 0160:1b17b7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b17b7; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b18a6() // 0160:1b18a6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b1919; break; }
    if (r8[al] != 0x79)
        { pc = 0x1b18be; break; }
    { pc = 0x1c72ac; break; }
  case 0x1b18be: // 0160:1b18be
    if (r8[al] != 0x8a)
        { pc = 0x1b18c7; break; }
    { pc = 0x1c735c; break; }
  case 0x1b18c7: // 0160:1b18c7
    if (r8[al] != 0x80)
        { pc = 0x1b18d0; break; }
    { pc = 0x1c740c; break; }
  case 0x1b18d0: // 0160:1b18d0
    if (r8[al] != 0x82)
        { pc = 0x1b18e3; break; }
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
    memoryASet32(ds, 0x20ee7b, r32[eax]);
    { pc = 0x1c74bc; break; }
  case 0x1b18e3: // 0160:1b18e3
    if (r8[al] != 0xa5)
        { pc = 0x1b18ec; break; }
    { pc = 0x1c7784; break; }
  case 0x1b18ec: // 0160:1b18ec
    if (r8[al] != 0x8b)
        { pc = 0x1b18f5; break; }
    { pc = 0x1c76d4; break; }
  case 0x1b18f5: // 0160:1b18f5
    if (r8[al] != 0x06)
        { pc = 0x1b18fe; break; }
    { pc = 0x1c756c; break; }
  case 0x1b18fe: // 0160:1b18fe
    if (r8[al] != 0x09)
        { pc = 0x1b1907; break; }
    { pc = 0x1c7624; break; }
  case 0x1b1907: // 0160:1b1907
    if (r8[al] != 0xa8)
        { pc = 0x1b1910; break; }
    { pc = 0x1c783c; break; }
  case 0x1b1910: // 0160:1b1910
    if (r8[al] != 0x81)
        { pc = 0x1b1919; break; }
    { pc = 0x1c78ec; break; }
  case 0x1b1919: // 0160:1b1919
    r32[esp] += 4; return;
    // gap 88466 bytes // gap 88466 bytes
  case 0x1c72ac: // 0160:1c72ac
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c72ff; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c72fd; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c72e4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c72e4: // 0160:1c72e4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c72fd: // 0160:1c72fd
    { pc = 0x1c7336; break; }
  case 0x1c72ff: // 0160:1c72ff
    if (!memoryAGet32(ds, 0x1f1cd8))
        { pc = 0x1c7336; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7320; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7320: // 0160:1c7320
    yield* sub_1c82bc();
    r32[eax] = 0;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000000);
  case 0x1c7336: // 0160:1c7336
    memoryASet32(ss, r32[ebp] - 8, 0x0020a9f4);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 3 bytes // gap 3 bytes
  case 0x1c735c: // 0160:1c735c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c73af; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c73ad; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7394; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7394: // 0160:1c7394
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c73ad: // 0160:1c73ad
    { pc = 0x1c73e9; break; }
  case 0x1c73af: // 0160:1c73af
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c73e9; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c73d0; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c73d0: // 0160:1c73d0
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c73e9: // 0160:1c73e9
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa00);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c740c: // 0160:1c740c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c745f; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c745d; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7444; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7444: // 0160:1c7444
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c745d: // 0160:1c745d
    { pc = 0x1c7499; break; }
  case 0x1c745f: // 0160:1c745f
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c7499; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7480; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7480: // 0160:1c7480
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c7499: // 0160:1c7499
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa08);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c74bc: // 0160:1c74bc
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c750f; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c750d; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c74f4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c74f4: // 0160:1c74f4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c750d: // 0160:1c750d
    { pc = 0x1c7549; break; }
  case 0x1c750f: // 0160:1c750f
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c7549; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7530; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7530: // 0160:1c7530
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c7549: // 0160:1c7549
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa14);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 3 bytes // gap 3 bytes
  case 0x1c756c: // 0160:1c756c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c75bf; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c75bd; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c75a4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c75a4: // 0160:1c75a4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c75bd: // 0160:1c75bd
    { pc = 0x1c7604; break; }
  case 0x1c75bf: // 0160:1c75bf
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c75d1; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c75d3; break; }
  case 0x1c75d1: // 0160:1c75d1
    { pc = 0x1c7604; break; }
  case 0x1c75d3: // 0160:1c75d3
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c75eb; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c75eb: // 0160:1c75eb
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c7604: // 0160:1c7604
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa24);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7624: // 0160:1c7624
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7677; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c7675; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c765c; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c765c: // 0160:1c765c
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c7675: // 0160:1c7675
    { pc = 0x1c76b1; break; }
  case 0x1c7677: // 0160:1c7677
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c76b1; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7698; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7698: // 0160:1c7698
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c76b1: // 0160:1c76b1
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa30);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 3 bytes // gap 3 bytes
  case 0x1c76d4: // 0160:1c76d4
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7727; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c7725; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c770c; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c770c: // 0160:1c770c
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c7725: // 0160:1c7725
    { pc = 0x1c777b; break; }
  case 0x1c7727: // 0160:1c7727
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7761; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7748; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7748: // 0160:1c7748
    yield* sub_1c82bc();
    r32[eax] = 0x00000002;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000002);
  case 0x1c7761: // 0160:1c7761
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa3c);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
  case 0x1c777b: // 0160:1c777b
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7784: // 0160:1c7784
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c77d7; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c77d5; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c77bc; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c77bc: // 0160:1c77bc
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c77d5: // 0160:1c77d5
    { pc = 0x1c781c; break; }
  case 0x1c77d7: // 0160:1c77d7
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c77e9; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c77eb; break; }
  case 0x1c77e9: // 0160:1c77e9
    { pc = 0x1c781c; break; }
  case 0x1c77eb: // 0160:1c77eb
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7803; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7803: // 0160:1c7803
    yield* sub_1c82bc();
    r32[eax] = 0x00000002;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000002);
  case 0x1c781c: // 0160:1c781c
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa44);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c783c: // 0160:1c783c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c788f; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c788d; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7874; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7874: // 0160:1c7874
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c788d: // 0160:1c788d
    { pc = 0x1c78e3; break; }
  case 0x1c788f: // 0160:1c788f
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000003)
        { pc = 0x1c78c9; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c78b0; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c78b0: // 0160:1c78b0
    yield* sub_1c82bc();
    r32[eax] = 0x00000003;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000003);
  case 0x1c78c9: // 0160:1c78c9
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa4c);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
  case 0x1c78e3: // 0160:1c78e3
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c78ec: // 0160:1c78ec
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000004)
        { pc = 0x1c7934; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c791b; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c791b: // 0160:1c791b
    yield* sub_1c82bc();
    r32[eax] = 0x00000004;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000004);
  case 0x1c7934: // 0160:1c7934
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa58);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b191a() // 0160:1b191a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b191a; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29377 bytes // gap 29377 bytes
  case 0x1b191a: // 0160:1b191a
    memoryASet16(ds, 0x20d897, 0x0000);
    memoryASet16(ds, 0x20e7d7, 0x0000);
    memoryASet16(ds, 0x20e7d9, 0x0000);
    memoryASet16(ds, 0x20e7db, 0x0000);
    memoryASet16(ds, 0x20e7dd, 0x0000);
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b6be8; break; }
    r32[eax] = 0x00000000;
    yield* sub_1b198d();
    r32[eax] = 0x00000001;
    yield* sub_1b198d();
    r32[eax] = 0x00000002;
    yield* sub_1b198d();
    r32[eax] = 0x00000003;
    yield* sub_1b198d();
    r32[eax] = 0x00000004;
    yield* sub_1b198d();
    r32[eax] = 0x00000005;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    memoryASet32(ds, 0x1f1ce0, 0x00000000);
    memoryASet32(ds, 0x1f1ce4, 0x00000140);
    { pc = 0x1aa64a; break; }
    // gap 21053 bytes // gap 21053 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 69443 bytes // gap 69443 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b198d() // 0160:1b198d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b198d; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29492 bytes // gap 29492 bytes
  case 0x1b198d: // 0160:1b198d
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    memoryASet32(ds, 0x1f1ce0, 0x00000000);
    memoryASet32(ds, 0x1f1ce4, 0x00000140);
    { pc = 0x1aa64a; break; }
    // gap 90497 bytes // gap 90497 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b19ac() // 0160:1b19ac +long
{
    r32[esp] -= 4;
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4;
}
function* sub_1b19e0() // 0160:1b19e0 +long +returnZero
{
    r32[esp] -= 4;
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    flags.zero = memoryAGet32(ds, 0x20c80c) == 0;
    r32[esp] += 4;
}
function* sub_1b1a14() // 0160:1b1a14 +long
{
    r32[esp] -= 4;
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0002);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4;
}
function* sub_1b1a48() // 0160:1b1a48 +long
{
  var pc = 0;
  var temp_cond0;
  var temp_cond1;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b1a48; break; }
  case 0x1a9519: // 0160:1a9519
    memoryASet(ds, 0x2eeb58, r8[ch]);
    r8[ch] = r8[cl];
    memoryASet16(ds, 0x2eebc8, r16[cx]);
    r32[ecx] = 0;
    r8[cl] = r8[bl];
    memoryASet32(ds, 0x2eeb64, r32[ecx]);
    r8[cl] = r8[bh];
    memoryASet32(ds, 0x2eeb68, r32[ecx]);
    memoryASet16(ds, 0x2eeb54, r16[ax]);
    r32[eax] = 0;
    r32[ecx]--;
    r32[ecx] >>>= 1;
    r32[edx] -= r32[ecx];
    if (r32s[edx] >= 0)
        { pc = 0x1a954b; break; }
    r32[eax] -= r32[edx];
  case 0x1a954b: // 0160:1a954b
    memoryASet32(ds, 0x2eeb70, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    r32[eax] += r32[edx];
    r32[eax] -= memoryAGet32(ds, 0x1f1c4c);
    if (r32s[eax] >= 0)
        { pc = 0x1a9561; break; }
    r32[eax] = 0;
  case 0x1a9561: // 0160:1a9561
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r32[eax] = 0;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx] <<= 2;
    r32[ecx]--;
    r32[edi] -= r32[ecx];
    if (r32s[edi] >= 0)
        { pc = 0x1a957b; break; }
    r32[eax] -= r32[edi];
    r32[eax] >>>= 3;
  case 0x1a957b: // 0160:1a957b
    memoryASet32(ds, 0x2eeb78, r32[eax]);
    r32[ecx]++;
    r32[ecx] += r32[ecx];
    r32[eax] = r32[ecx];
    r32[eax] += r32[edi];
    r32[eax] -= memoryAGet32(ds, 0x1f1c48);
    if (r32s[eax] >= 0)
        { pc = 0x1a9591; break; }
    r32[eax] = 0;
  case 0x1a9591: // 0160:1a9591
    r32[eax] >>>= 3;
    memoryASet32(ds, 0x2eeb7c, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb78);
    r32[eax] <<= 3;
    r32[edi] += r32[eax];
    r32[edx] += memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[eax] &= 0x0000000f;
    r32[edi] += r32[eax];
    r32[eax] = r32[edi];
    r32[eax] &= 0x00000003;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x1f1c58);
    memoryASet32(ds, 0x2eeb6c, r32[eax]);
    r32[edi] = sar32(r32[edi], 0x02);
    r32[edi] += memoryAGet32(ds, 0x1f1c34);
    r32[eax] = 0x00000054;
    mul8(r8[dl]);
    r32[edi] += r32[eax];
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    r32[ecx] = r32[eax];
    r32[eax] -= memoryAGet32(ds, 0x2eeb70);
    temp_cond0 = r32s[eax] <= signed32(memoryAGet32(ds, 0x2eeb74));
    r32[eax] -= memoryAGet32(ds, 0x2eeb74);
    if (temp_cond0)
        { pc = 0x1a975a; break; }
    memoryASet32(ds, 0x2eeb68, r32[eax]);
    r32[ebx] = 0x00000140;
    r32[eax] = memoryAGet32(ds, 0x2eeb70);
    if (!(memoryAGet(ds, 0x2eeb55) & 0xff))
        { pc = 0x1a9612; break; }
    r32[eax] = r32[ecx];
    r32[eax] -= memoryAGet32(ds, 0x2eeb70);
    r32[eax]--;
    r32[ebx] = -r32[ebx];
  case 0x1a9612: // 0160:1a9612
    r32[eax] <<= 6;
    r32[esi] += r32[eax];
    r32[eax] <<= 2;
    r32[esi] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, r32[ebx]);
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] = r32[ecx];
    r32[ecx] -= memoryAGet32(ds, 0x2eeb78);
    temp_cond1 = r32s[ecx] <= signed32(memoryAGet32(ds, 0x2eeb7c));
    r32[ecx] -= memoryAGet32(ds, 0x2eeb7c);
    if (temp_cond1)
        { pc = 0x1a975a; break; }
    memoryASet32(ds, 0x2eeb64, r32[ecx]);
    memoryASet32(ds, 0x2eeb60, 0x00000054);
    if (memoryAGet(ds, 0x2eeb54) & 0xff)
        { pc = 0x1a97ea; break; }
    r32[eax] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) - r32[eax]);
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb78);
    r32[eax] += r32[eax];
    r32[esi] += r32[eax];
    r32[eax] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb78, 0x00000004);
    if (!(memoryAGet(ds, 0x2eeb58) & 0xff))
        { pc = 0x1a998d; break; }
  case 0x1a9691: // 0160:1a9691
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = ror32(r32[eax], 0x10);
    r8[dl] = 0xce;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a975b; break; }
  case 0x1a96c5: // 0160:1a96c5
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a96cb: // 0160:1a96cb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[al])
        { pc = 0x1a96ff; break; }
    if (r8[bh] >= r8[ah])
        { pc = 0x1a96ed; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a96cb; break; }
    { pc = 0x1a9714; break; }
  case 0x1a96ed: // 0160:1a96ed
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a96cb; break; }
    { pc = 0x1a9714; break; }
  case 0x1a96ff: // 0160:1a96ff
    if (r8[bh] >= r8[ah])
        { pc = 0x1a970c; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a970c: // 0160:1a970c
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a96cb; break; }
  case 0x1a9714: // 0160:1a9714
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a96c5; break; }
  case 0x1a9728: // 0160:1a9728
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] += 0x00000050;
    r8[ah] += r8[ah];
    r32[eax] += 0x01000000;
    if (r8[ah] < 0x10)
        { pc = 0x1a974e; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c58);
    r32[edi]++;
  case 0x1a974e: // 0160:1a974e
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a9691; break; }
  case 0x1a975a: // 0160:1a975a
    r32[esp] += 4; return;
  case 0x1a975b: // 0160:1a975b
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a9769; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9769: // 0160:1a9769
    r32[edi]++;
    r32[esi]++;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a97bd; break; }
  case 0x1a9774: // 0160:1a9774
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[al])
        { pc = 0x1a97a8; break; }
    if (r8[bh] >= r8[ah])
        { pc = 0x1a9796; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9774; break; }
    { pc = 0x1a97bd; break; }
  case 0x1a9796: // 0160:1a9796
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9774; break; }
    { pc = 0x1a97bd; break; }
  case 0x1a97a8: // 0160:1a97a8
    if (r8[bh] >= r8[ah])
        { pc = 0x1a97b5; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a97b5: // 0160:1a97b5
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9774; break; }
  case 0x1a97bd: // 0160:1a97bd
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a97cb; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a97cb: // 0160:1a97cb
    r32[esi]++;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a975b; break; }
    { pc = 0x1a9728; break; }
  case 0x1a97ea: // 0160:1a97ea
    r32[eax] -= memoryAGet32(ds, 0x2eeb78);
    r32[eax] += r32[eax];
    r32[eax]--;
    r32[esi] += r32[eax];
    r32[esi] += 0x000000f0;
    r32[eax] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) + r32[eax]);
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb78, 0x00000004);
    if (!(memoryAGet(ds, 0x2eeb58) & 0xff))
        { pc = 0x1a9ad1; break; }
  case 0x1a982a: // 0160:1a982a
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = ror32(r32[eax], 0x10);
    r8[dl] = 0xce;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a98f9; break; }
  case 0x1a985e: // 0160:1a985e
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a9864: // 0160:1a9864
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[ah])
        { pc = 0x1a989d; break; }
    if (r8[bh] >= r8[al])
        { pc = 0x1a988b; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9864; break; }
    { pc = 0x1a98b2; break; }
  case 0x1a988b: // 0160:1a988b
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9864; break; }
    { pc = 0x1a98b2; break; }
  case 0x1a989d: // 0160:1a989d
    if (r8[bh] >= r8[al])
        { pc = 0x1a98aa; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a98aa: // 0160:1a98aa
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9864; break; }
  case 0x1a98b2: // 0160:1a98b2
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a985e; break; }
  case 0x1a98c6: // 0160:1a98c6
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] -= 0x00000050;
    r32[eax] += 0x01000000;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a98ec; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c58);
    r32[edi]++;
  case 0x1a98ec: // 0160:1a98ec
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a982a; break; }
    r32[esp] += 4; return;
  case 0x1a98f9: // 0160:1a98f9
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a9907; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9907: // 0160:1a9907
    r32[edi]++;
    r32[esi]--;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a9960; break; }
  case 0x1a9912: // 0160:1a9912
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[ah])
        { pc = 0x1a994b; break; }
    if (r8[bh] >= r8[al])
        { pc = 0x1a9939; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9912; break; }
    { pc = 0x1a9960; break; }
  case 0x1a9939: // 0160:1a9939
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9912; break; }
    { pc = 0x1a9960; break; }
  case 0x1a994b: // 0160:1a994b
    if (r8[bh] >= r8[al])
        { pc = 0x1a9958; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9958: // 0160:1a9958
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9912; break; }
  case 0x1a9960: // 0160:1a9960
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a996e; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a996e: // 0160:1a996e
    r32[esi]--;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a98f9; break; }
    { pc = 0x1a98c6; break; }
  case 0x1a998d: // 0160:1a998d
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a9a45; break; }
  case 0x1a99ba: // 0160:1a99ba
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a99c0: // 0160:1a99c0
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a99f1; break; }
    if (!r8[ah])
        { pc = 0x1a99df; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a99c0; break; }
    { pc = 0x1a9a06; break; }
  case 0x1a99df: // 0160:1a99df
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a99c0; break; }
    { pc = 0x1a9a06; break; }
  case 0x1a99f1: // 0160:1a99f1
    if (!r8[ah])
        { pc = 0x1a99fe; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a99fe: // 0160:1a99fe
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a99c0; break; }
  case 0x1a9a06: // 0160:1a9a06
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a99ba; break; }
  case 0x1a9a1a: // 0160:1a9a1a
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] += 0x00000050;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a9a38; break; }
    r8[ah] = 0x01;
    r32[edi]++;
  case 0x1a9a38: // 0160:1a9a38
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a998d; break; }
    r32[esp] += 4; return;
  case 0x1a9a45: // 0160:1a9a45
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9a53; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9a53: // 0160:1a9a53
    r32[edi]++;
    r32[esi]++;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a9aa4; break; }
  case 0x1a9a5e: // 0160:1a9a5e
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9a8f; break; }
    if (!r8[ah])
        { pc = 0x1a9a7d; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9a5e; break; }
    { pc = 0x1a9aa4; break; }
  case 0x1a9a7d: // 0160:1a9a7d
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9a5e; break; }
    { pc = 0x1a9aa4; break; }
  case 0x1a9a8f: // 0160:1a9a8f
    if (!r8[ah])
        { pc = 0x1a9a9c; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a9a9c: // 0160:1a9a9c
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9a5e; break; }
  case 0x1a9aa4: // 0160:1a9aa4
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9ab2; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9ab2: // 0160:1a9ab2
    r32[esi]++;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9a45; break; }
    { pc = 0x1a9a1a; break; }
  case 0x1a9ad1: // 0160:1a9ad1
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a9b8e; break; }
  case 0x1a9afe: // 0160:1a9afe
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a9b04: // 0160:1a9b04
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    if (!r8[ah])
        { pc = 0x1a9b3a; break; }
    if (!r8[al])
        { pc = 0x1a9b28; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9b04; break; }
    { pc = 0x1a9b4f; break; }
  case 0x1a9b28: // 0160:1a9b28
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9b04; break; }
    { pc = 0x1a9b4f; break; }
  case 0x1a9b3a: // 0160:1a9b3a
    if (!r8[al])
        { pc = 0x1a9b47; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9b47: // 0160:1a9b47
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9b04; break; }
  case 0x1a9b4f: // 0160:1a9b4f
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9afe; break; }
  case 0x1a9b63: // 0160:1a9b63
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] -= 0x00000050;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a9b81; break; }
    r8[ah] = 0x01;
    r32[edi]++;
  case 0x1a9b81: // 0160:1a9b81
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a9ad1; break; }
    r32[esp] += 4; return;
  case 0x1a9b8e: // 0160:1a9b8e
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9b9c; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9b9c: // 0160:1a9b9c
    r32[edi]++;
    r32[esi]--;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a9bf2; break; }
  case 0x1a9ba7: // 0160:1a9ba7
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    if (!r8[ah])
        { pc = 0x1a9bdd; break; }
    if (!r8[al])
        { pc = 0x1a9bcb; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9ba7; break; }
    { pc = 0x1a9bf2; break; }
  case 0x1a9bcb: // 0160:1a9bcb
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9ba7; break; }
    { pc = 0x1a9bf2; break; }
  case 0x1a9bdd: // 0160:1a9bdd
    if (!r8[al])
        { pc = 0x1a9bea; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9bea: // 0160:1a9bea
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9ba7; break; }
  case 0x1a9bf2: // 0160:1a9bf2
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9c00; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9c00: // 0160:1a9c00
    r32[esi]--;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9b8e; break; }
    { pc = 0x1a9b63; break; }
    // gap 32297 bytes // gap 32297 bytes
  case 0x1b1a48: // 0160:1b1a48
    push32(r32[ebx]);
    r32[edi] = 0x0020b80c;
    r16[cx] <<= 3;
    r32[ecx] &= 0x0000ffff;
    r32[edi] += r32[ecx];
    r32[esi] = memoryAGet32(ds, r32[edi]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x4);
    r8[bh] = memoryAGet(ds, r32[edi] + 0x6);
    r32[eax] &= 0x0000ffff;
    r32[edi] = r32[eax];
    r32[edi] -= 0x00000080;
    r16[ax] = r16[dx];
    r16[ax] &= 0x0003;
    r16[cx] = r16[dx];
    if (r16[ax] == 0x0001)
        { pc = 0x1b1a99; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1a93; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1b1a8d; break; }
    { pc = 0x1b1a9d; break; }
  case 0x1b1a8d: // 0160:1b1a8d
    r8[al] = 0x01;
    r8[ah] = 0x01;
    { pc = 0x1b1a9d; break; }
  case 0x1b1a93: // 0160:1b1a93
    r8[al] = 0x00;
    r8[ah] = 0x01;
    { pc = 0x1b1a9d; break; }
  case 0x1b1a99: // 0160:1b1a99
    r8[al] = 0x01;
    r8[ah] = 0x00;
  case 0x1b1a9d: // 0160:1b1a9d
    r32[edx] = pop32();
    r32[edx] &= 0x0000ffff;
    r32[edx] -= 0x00000080;
    if (r16[cx] < 0x0010)
        { pc = 0x1b1ab5; break; }
    r16[cx] = 0;
    { pc = 0x1b1ab9; break; }
  case 0x1b1ab5: // 0160:1b1ab5
    r8[ch] = 0x01;
    r8[cl] = 0;
  case 0x1b1ab9: // 0160:1b1ab9
    if (memoryAGet16(ds, 0x20ce8f) == 0xffff)
        { pc = 0x1b1ad1; break; }
    r8[cl] = memoryAGet(ds, 0x20ce8f);
    r8[cl] <<= 2;
  case 0x1b1ad1: // 0160:1b1ad1
    { pc = 0x1a9519; break; }
    return;
  }
}
function* sub_1b1ad6() // 0160:1b1ad6 +long
{
  var pc = 0;
  var temp_cond0;
  var temp_cond1;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b1ad6; break; }
  case 0x1a9519: // 0160:1a9519
    memoryASet(ds, 0x2eeb58, r8[ch]);
    r8[ch] = r8[cl];
    memoryASet16(ds, 0x2eebc8, r16[cx]);
    r32[ecx] = 0;
    r8[cl] = r8[bl];
    memoryASet32(ds, 0x2eeb64, r32[ecx]);
    r8[cl] = r8[bh];
    memoryASet32(ds, 0x2eeb68, r32[ecx]);
    memoryASet16(ds, 0x2eeb54, r16[ax]);
    r32[eax] = 0;
    r32[ecx]--;
    r32[ecx] >>>= 1;
    r32[edx] -= r32[ecx];
    if (r32s[edx] >= 0)
        { pc = 0x1a954b; break; }
    r32[eax] -= r32[edx];
  case 0x1a954b: // 0160:1a954b
    memoryASet32(ds, 0x2eeb70, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    r32[eax] += r32[edx];
    r32[eax] -= memoryAGet32(ds, 0x1f1c4c);
    if (r32s[eax] >= 0)
        { pc = 0x1a9561; break; }
    r32[eax] = 0;
  case 0x1a9561: // 0160:1a9561
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r32[eax] = 0;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx] <<= 2;
    r32[ecx]--;
    r32[edi] -= r32[ecx];
    if (r32s[edi] >= 0)
        { pc = 0x1a957b; break; }
    r32[eax] -= r32[edi];
    r32[eax] >>>= 3;
  case 0x1a957b: // 0160:1a957b
    memoryASet32(ds, 0x2eeb78, r32[eax]);
    r32[ecx]++;
    r32[ecx] += r32[ecx];
    r32[eax] = r32[ecx];
    r32[eax] += r32[edi];
    r32[eax] -= memoryAGet32(ds, 0x1f1c48);
    if (r32s[eax] >= 0)
        { pc = 0x1a9591; break; }
    r32[eax] = 0;
  case 0x1a9591: // 0160:1a9591
    r32[eax] >>>= 3;
    memoryASet32(ds, 0x2eeb7c, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb78);
    r32[eax] <<= 3;
    r32[edi] += r32[eax];
    r32[edx] += memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[eax] &= 0x0000000f;
    r32[edi] += r32[eax];
    r32[eax] = r32[edi];
    r32[eax] &= 0x00000003;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x1f1c58);
    memoryASet32(ds, 0x2eeb6c, r32[eax]);
    r32[edi] = sar32(r32[edi], 0x02);
    r32[edi] += memoryAGet32(ds, 0x1f1c34);
    r32[eax] = 0x00000054;
    mul8(r8[dl]);
    r32[edi] += r32[eax];
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    r32[ecx] = r32[eax];
    r32[eax] -= memoryAGet32(ds, 0x2eeb70);
    temp_cond0 = r32s[eax] <= signed32(memoryAGet32(ds, 0x2eeb74));
    r32[eax] -= memoryAGet32(ds, 0x2eeb74);
    if (temp_cond0)
        { pc = 0x1a975a; break; }
    memoryASet32(ds, 0x2eeb68, r32[eax]);
    r32[ebx] = 0x00000140;
    r32[eax] = memoryAGet32(ds, 0x2eeb70);
    if (!(memoryAGet(ds, 0x2eeb55) & 0xff))
        { pc = 0x1a9612; break; }
    r32[eax] = r32[ecx];
    r32[eax] -= memoryAGet32(ds, 0x2eeb70);
    r32[eax]--;
    r32[ebx] = -r32[ebx];
  case 0x1a9612: // 0160:1a9612
    r32[eax] <<= 6;
    r32[esi] += r32[eax];
    r32[eax] <<= 2;
    r32[esi] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, r32[ebx]);
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] = r32[ecx];
    r32[ecx] -= memoryAGet32(ds, 0x2eeb78);
    temp_cond1 = r32s[ecx] <= signed32(memoryAGet32(ds, 0x2eeb7c));
    r32[ecx] -= memoryAGet32(ds, 0x2eeb7c);
    if (temp_cond1)
        { pc = 0x1a975a; break; }
    memoryASet32(ds, 0x2eeb64, r32[ecx]);
    memoryASet32(ds, 0x2eeb60, 0x00000054);
    if (memoryAGet(ds, 0x2eeb54) & 0xff)
        { pc = 0x1a97ea; break; }
    r32[eax] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) - r32[eax]);
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb78);
    r32[eax] += r32[eax];
    r32[esi] += r32[eax];
    r32[eax] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb78, 0x00000004);
    if (!(memoryAGet(ds, 0x2eeb58) & 0xff))
        { pc = 0x1a998d; break; }
  case 0x1a9691: // 0160:1a9691
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = ror32(r32[eax], 0x10);
    r8[dl] = 0xce;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a975b; break; }
  case 0x1a96c5: // 0160:1a96c5
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a96cb: // 0160:1a96cb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[al])
        { pc = 0x1a96ff; break; }
    if (r8[bh] >= r8[ah])
        { pc = 0x1a96ed; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a96cb; break; }
    { pc = 0x1a9714; break; }
  case 0x1a96ed: // 0160:1a96ed
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a96cb; break; }
    { pc = 0x1a9714; break; }
  case 0x1a96ff: // 0160:1a96ff
    if (r8[bh] >= r8[ah])
        { pc = 0x1a970c; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a970c: // 0160:1a970c
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a96cb; break; }
  case 0x1a9714: // 0160:1a9714
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a96c5; break; }
  case 0x1a9728: // 0160:1a9728
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] += 0x00000050;
    r8[ah] += r8[ah];
    r32[eax] += 0x01000000;
    if (r8[ah] < 0x10)
        { pc = 0x1a974e; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c58);
    r32[edi]++;
  case 0x1a974e: // 0160:1a974e
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a9691; break; }
  case 0x1a975a: // 0160:1a975a
    r32[esp] += 4; return;
  case 0x1a975b: // 0160:1a975b
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a9769; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9769: // 0160:1a9769
    r32[edi]++;
    r32[esi]++;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a97bd; break; }
  case 0x1a9774: // 0160:1a9774
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[al])
        { pc = 0x1a97a8; break; }
    if (r8[bh] >= r8[ah])
        { pc = 0x1a9796; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9774; break; }
    { pc = 0x1a97bd; break; }
  case 0x1a9796: // 0160:1a9796
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9774; break; }
    { pc = 0x1a97bd; break; }
  case 0x1a97a8: // 0160:1a97a8
    if (r8[bh] >= r8[ah])
        { pc = 0x1a97b5; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a97b5: // 0160:1a97b5
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9774; break; }
  case 0x1a97bd: // 0160:1a97bd
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a97cb; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a97cb: // 0160:1a97cb
    r32[esi]++;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a975b; break; }
    { pc = 0x1a9728; break; }
  case 0x1a97ea: // 0160:1a97ea
    r32[eax] -= memoryAGet32(ds, 0x2eeb78);
    r32[eax] += r32[eax];
    r32[eax]--;
    r32[esi] += r32[eax];
    r32[esi] += 0x000000f0;
    r32[eax] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) + r32[eax]);
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb78, 0x00000004);
    if (!(memoryAGet(ds, 0x2eeb58) & 0xff))
        { pc = 0x1a9ad1; break; }
  case 0x1a982a: // 0160:1a982a
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = ror32(r32[eax], 0x10);
    r8[dl] = 0xce;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a98f9; break; }
  case 0x1a985e: // 0160:1a985e
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a9864: // 0160:1a9864
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[ah])
        { pc = 0x1a989d; break; }
    if (r8[bh] >= r8[al])
        { pc = 0x1a988b; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9864; break; }
    { pc = 0x1a98b2; break; }
  case 0x1a988b: // 0160:1a988b
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9864; break; }
    { pc = 0x1a98b2; break; }
  case 0x1a989d: // 0160:1a989d
    if (r8[bh] >= r8[al])
        { pc = 0x1a98aa; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a98aa: // 0160:1a98aa
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9864; break; }
  case 0x1a98b2: // 0160:1a98b2
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a985e; break; }
  case 0x1a98c6: // 0160:1a98c6
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] -= 0x00000050;
    r32[eax] += 0x01000000;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a98ec; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c58);
    r32[edi]++;
  case 0x1a98ec: // 0160:1a98ec
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a982a; break; }
    r32[esp] += 4; return;
  case 0x1a98f9: // 0160:1a98f9
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a9907; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9907: // 0160:1a9907
    r32[edi]++;
    r32[esi]--;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a9960; break; }
  case 0x1a9912: // 0160:1a9912
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    r16[bx] = memoryAGet16(ds, r32[edi]);
    if (r8[bl] >= r8[ah])
        { pc = 0x1a994b; break; }
    if (r8[bh] >= r8[al])
        { pc = 0x1a9939; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9912; break; }
    { pc = 0x1a9960; break; }
  case 0x1a9939: // 0160:1a9939
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9912; break; }
    { pc = 0x1a9960; break; }
  case 0x1a994b: // 0160:1a994b
    if (r8[bh] >= r8[al])
        { pc = 0x1a9958; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9958: // 0160:1a9958
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9912; break; }
  case 0x1a9960: // 0160:1a9960
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] <= memoryAGet(ds, r32[edi]))
        { pc = 0x1a996e; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a996e: // 0160:1a996e
    r32[esi]--;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a98f9; break; }
    { pc = 0x1a98c6; break; }
  case 0x1a998d: // 0160:1a998d
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a9a45; break; }
  case 0x1a99ba: // 0160:1a99ba
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a99c0: // 0160:1a99c0
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a99f1; break; }
    if (!r8[ah])
        { pc = 0x1a99df; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a99c0; break; }
    { pc = 0x1a9a06; break; }
  case 0x1a99df: // 0160:1a99df
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a99c0; break; }
    { pc = 0x1a9a06; break; }
  case 0x1a99f1: // 0160:1a99f1
    if (!r8[ah])
        { pc = 0x1a99fe; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a99fe: // 0160:1a99fe
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a99c0; break; }
  case 0x1a9a06: // 0160:1a9a06
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a99ba; break; }
  case 0x1a9a1a: // 0160:1a9a1a
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] += 0x00000050;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a9a38; break; }
    r8[ah] = 0x01;
    r32[edi]++;
  case 0x1a9a38: // 0160:1a9a38
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a998d; break; }
    r32[esp] += 4; return;
  case 0x1a9a45: // 0160:1a9a45
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9a53; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9a53: // 0160:1a9a53
    r32[edi]++;
    r32[esi]++;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a9aa4; break; }
  case 0x1a9a5e: // 0160:1a9a5e
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9a8f; break; }
    if (!r8[ah])
        { pc = 0x1a9a7d; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9a5e; break; }
    { pc = 0x1a9aa4; break; }
  case 0x1a9a7d: // 0160:1a9a7d
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9a5e; break; }
    { pc = 0x1a9aa4; break; }
  case 0x1a9a8f: // 0160:1a9a8f
    if (!r8[ah])
        { pc = 0x1a9a9c; break; }
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a9a9c: // 0160:1a9a9c
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9a5e; break; }
  case 0x1a9aa4: // 0160:1a9aa4
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9ab2; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9ab2: // 0160:1a9ab2
    r32[esi]++;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9a45; break; }
    { pc = 0x1a9a1a; break; }
  case 0x1a9ad1: // 0160:1a9ad1
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a9b8e; break; }
  case 0x1a9afe: // 0160:1a9afe
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a9b04: // 0160:1a9b04
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    if (!r8[ah])
        { pc = 0x1a9b3a; break; }
    if (!r8[al])
        { pc = 0x1a9b28; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9b04; break; }
    { pc = 0x1a9b4f; break; }
  case 0x1a9b28: // 0160:1a9b28
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9b04; break; }
    { pc = 0x1a9b4f; break; }
  case 0x1a9b3a: // 0160:1a9b3a
    if (!r8[al])
        { pc = 0x1a9b47; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9b47: // 0160:1a9b47
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9b04; break; }
  case 0x1a9b4f: // 0160:1a9b4f
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9afe; break; }
  case 0x1a9b63: // 0160:1a9b63
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] -= 0x00000050;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a9b81; break; }
    r8[ah] = 0x01;
    r32[edi]++;
  case 0x1a9b81: // 0160:1a9b81
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a9ad1; break; }
    r32[esp] += 4; return;
  case 0x1a9b8e: // 0160:1a9b8e
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9b9c; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9b9c: // 0160:1a9b9c
    r32[edi]++;
    r32[esi]--;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a9bf2; break; }
  case 0x1a9ba7: // 0160:1a9ba7
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    if (!r8[ah])
        { pc = 0x1a9bdd; break; }
    if (!r8[al])
        { pc = 0x1a9bcb; break; }
    r16[ax] |= memoryAGet16(ds, 0x2eebc8);
    r16[ax] = rol16(r16[ax], 0x08);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9ba7; break; }
    { pc = 0x1a9bf2; break; }
  case 0x1a9bcb: // 0160:1a9bcb
    r8[ah] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9ba7; break; }
    { pc = 0x1a9bf2; break; }
  case 0x1a9bdd: // 0160:1a9bdd
    if (!r8[al])
        { pc = 0x1a9bea; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9bea: // 0160:1a9bea
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9ba7; break; }
  case 0x1a9bf2: // 0160:1a9bf2
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9c00; break; }
    r8[al] |= memoryAGet(ds, 0x2eebc8);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9c00: // 0160:1a9c00
    r32[esi]--;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9b8e; break; }
    { pc = 0x1a9b63; break; }
    // gap 32439 bytes // gap 32439 bytes
  case 0x1b1ad6: // 0160:1b1ad6
    push32(r32[ebx]);
    r32[edi] = 0x0020b80c;
    r16[cx] <<= 3;
    r32[ecx] &= 0x0000ffff;
    r32[edi] += r32[ecx];
    r32[esi] = memoryAGet32(ds, r32[edi]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x4);
    r8[bl] <<= 2;
    r8[bh] = 0;
    r16[ax] += r16[bx];
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[edi] + 0x6);
    r8[bl] >>>= 1;
    r32[ebp] = pop32();
    r16[bp] += r16[bx];
    push32(r32[ebp]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x4);
    r8[bh] = memoryAGet(ds, r32[edi] + 0x6);
    r32[eax] &= 0x0000ffff;
    r32[edi] = r32[eax];
    r32[edi] -= 0x00000080;
    r16[ax] = r16[dx];
    r16[ax] &= 0x0003;
    r16[cx] = r16[dx];
    if (r16[ax] == 0x0001)
        { pc = 0x1b1b3f; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1b39; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1b1b33; break; }
    { pc = 0x1b1b43; break; }
  case 0x1b1b33: // 0160:1b1b33
    r8[al] = 0x01;
    r8[ah] = 0x01;
    { pc = 0x1b1b43; break; }
  case 0x1b1b39: // 0160:1b1b39
    r8[al] = 0x00;
    r8[ah] = 0x01;
    { pc = 0x1b1b43; break; }
  case 0x1b1b3f: // 0160:1b1b3f
    r8[al] = 0x01;
    r8[ah] = 0x00;
  case 0x1b1b43: // 0160:1b1b43
    r32[edx] = pop32();
    r32[edx] &= 0x0000ffff;
    r32[edx] -= 0x00000080;
    if (r16[cx] < 0x0010)
        { pc = 0x1b1b5b; break; }
    r16[cx] = 0;
    { pc = 0x1b1b5f; break; }
  case 0x1b1b5b: // 0160:1b1b5b
    r8[ch] = 0x01;
    r8[cl] = 0;
  case 0x1b1b5f: // 0160:1b1b5f
    if (memoryAGet16(ds, 0x20ce8f) == 0xffff)
        { pc = 0x1b1b77; break; }
    r8[cl] = memoryAGet(ds, 0x20ce8f);
    r8[cl] <<= 2;
  case 0x1b1b77: // 0160:1b1b77
    { pc = 0x1a9519; break; }
    return;
  }
}
function* sub_1b1b7c() // 0160:1b1b7c +long
{
  var pc = 0;
  var temp_cond0;
  var temp_cond1;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b1b7c; break; }
  case 0x1a9094: // 0160:1a9094
    r32[ecx] = 0;
    r8[cl] = r8[bl];
    memoryASet32(ds, 0x2eeb64, r32[ecx]);
    r8[cl] = r8[bh];
    memoryASet32(ds, 0x2eeb68, r32[ecx]);
    memoryASet16(ds, 0x2eeb54, r16[ax]);
    r32[eax] = 0;
    r32[ecx]--;
    r32[ecx] >>>= 1;
    r32[edx] -= r32[ecx];
    if (r32s[edx] >= 0)
        { pc = 0x1a90b7; break; }
    r32[eax] -= r32[edx];
  case 0x1a90b7: // 0160:1a90b7
    memoryASet32(ds, 0x2eeb70, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    r32[eax] += r32[edx];
    r32[eax] -= memoryAGet32(ds, 0x1f1c4c);
    if (r32s[eax] >= 0)
        { pc = 0x1a90cd; break; }
    r32[eax] = 0;
  case 0x1a90cd: // 0160:1a90cd
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r32[eax] = 0;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx] <<= 2;
    r32[ecx]--;
    r32[edi] -= r32[ecx];
    if (r32s[edi] >= 0)
        { pc = 0x1a90e7; break; }
    r32[eax] -= r32[edi];
    r32[eax] >>>= 3;
  case 0x1a90e7: // 0160:1a90e7
    memoryASet32(ds, 0x2eeb78, r32[eax]);
    r32[ecx]++;
    r32[ecx] += r32[ecx];
    r32[eax] = r32[ecx];
    r32[eax] += r32[edi];
    r32[eax] -= memoryAGet32(ds, 0x1f1c48);
    if (r32s[eax] >= 0)
        { pc = 0x1a90fd; break; }
    r32[eax] = 0;
  case 0x1a90fd: // 0160:1a90fd
    r32[eax] >>>= 3;
    memoryASet32(ds, 0x2eeb7c, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb78);
    r32[eax] <<= 3;
    r32[edi] += r32[eax];
    r32[edx] += memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[eax] &= 0x0000000f;
    r32[edi] += r32[eax];
    r32[eax] = r32[edi];
    r32[eax] &= 0x00000003;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x1f1c58);
    memoryASet32(ds, 0x2eeb6c, r32[eax]);
    r32[edi] = sar32(r32[edi], 0x02);
    r32[edi] += memoryAGet32(ds, 0x1f1c34);
    r32[eax] = 0x00000054;
    mul8(r8[dl]);
    r32[edi] += r32[eax];
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    r32[ecx] = r32[eax];
    r32[eax] -= memoryAGet32(ds, 0x2eeb70);
    temp_cond0 = r32s[eax] <= signed32(memoryAGet32(ds, 0x2eeb74));
    r32[eax] -= memoryAGet32(ds, 0x2eeb74);
    if (temp_cond0)
        { pc = 0x1a92c9; break; }
    memoryASet32(ds, 0x2eeb68, r32[eax]);
    r32[ebx] = 0x00000140;
    r32[eax] = memoryAGet32(ds, 0x2eeb70);
    if (!(memoryAGet(ds, 0x2eeb55) & 0xff))
        { pc = 0x1a917e; break; }
    r32[eax] = r32[ecx];
    r32[eax] -= memoryAGet32(ds, 0x2eeb70);
    r32[eax]--;
    r32[ebx] = -r32[ebx];
  case 0x1a917e: // 0160:1a917e
    r32[eax] <<= 6;
    r32[esi] += r32[eax];
    r32[eax] <<= 2;
    r32[esi] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, r32[ebx]);
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] = r32[ecx];
    r32[ecx] -= memoryAGet32(ds, 0x2eeb78);
    temp_cond1 = r32s[ecx] <= signed32(memoryAGet32(ds, 0x2eeb7c));
    r32[ecx] -= memoryAGet32(ds, 0x2eeb7c);
    if (temp_cond1)
        { pc = 0x1a92c9; break; }
    memoryASet32(ds, 0x2eeb64, r32[ecx]);
    memoryASet32(ds, 0x2eeb60, 0x00000054);
    r32[ebx] = 0;
    if (memoryAGet(ds, 0x2eeb54) & 0xff)
        { pc = 0x1a936b; break; }
    r32[eax] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) - r32[eax]);
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb78);
    r32[eax] += r32[eax];
    r32[esi] += r32[eax];
    r32[eax] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb78, 0x00000004);
  case 0x1a91f2: // 0160:1a91f2
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = ror32(r32[eax], 0x10);
    r8[dl] = 0xce;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a92ca; break; }
  case 0x1a9226: // 0160:1a9226
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a922c: // 0160:1a922c
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a926b; break; }
    if (!r8[ah])
        { pc = 0x1a9257; break; }
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r8[bl] = r8[al];
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    r8[bl] = r8[ah];
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a922c; break; }
    { pc = 0x1a9283; break; }
  case 0x1a9257: // 0160:1a9257
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a922c; break; }
    { pc = 0x1a9283; break; }
  case 0x1a926b: // 0160:1a926b
    if (!r8[ah])
        { pc = 0x1a927b; break; }
    r8[bl] = memoryAGet(ds, r32[edi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a927b: // 0160:1a927b
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a922c; break; }
  case 0x1a9283: // 0160:1a9283
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9226; break; }
  case 0x1a9297: // 0160:1a9297
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] += 0x00000050;
    r8[ah] += r8[ah];
    r32[eax] += 0x01000000;
    if (r8[ah] < 0x10)
        { pc = 0x1a92bd; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c58);
    r32[edi]++;
  case 0x1a92bd: // 0160:1a92bd
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a91f2; break; }
  case 0x1a92c9: // 0160:1a92c9
    r32[esp] += 4; return;
  case 0x1a92ca: // 0160:1a92ca
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a92da; break; }
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a92da: // 0160:1a92da
    r32[edi]++;
    r32[esi]++;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a933c; break; }
  case 0x1a92e5: // 0160:1a92e5
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9324; break; }
    if (!r8[ah])
        { pc = 0x1a9310; break; }
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r8[bl] = r8[al];
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    r8[bl] = r8[ah];
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a92e5; break; }
    { pc = 0x1a933c; break; }
  case 0x1a9310: // 0160:1a9310
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a92e5; break; }
    { pc = 0x1a933c; break; }
  case 0x1a9324: // 0160:1a9324
    if (!r8[ah])
        { pc = 0x1a9334; break; }
    r8[bl] = memoryAGet(ds, r32[edi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi] + 0x1, r8[ah]);
  case 0x1a9334: // 0160:1a9334
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a92e5; break; }
  case 0x1a933c: // 0160:1a933c
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a934c; break; }
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a934c: // 0160:1a934c
    r32[esi]++;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a92ca; break; }
    { pc = 0x1a9297; break; }
  case 0x1a936b: // 0160:1a936b
    r32[eax] -= memoryAGet32(ds, 0x2eeb78);
    r32[eax] += r32[eax];
    r32[eax]--;
    r32[esi] += r32[eax];
    r32[esi] += 0x000000f0;
    r32[eax] = memoryAGet32(ds, 0x2eeb64);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) + r32[eax]);
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb6c);
    memoryASet32(ds, 0x2eeb78, 0x00000004);
  case 0x1a939e: // 0160:1a939e
    memoryASet32(ds, 0x2eeb6c, r32[esi]);
    memoryASet32(ds, 0x2eeb70, r32[edi]);
    memoryASet32(ds, 0x2eeb74, r32[eax]);
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r32[eax] = ror32(r32[eax], 0x10);
    r8[dl] = 0xce;
    out16(r16[dx], r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x2eeb68);
    memoryASet32(ds, 0x2eeb54, r32[eax]);
    if (r32[edi] & 0x00000001)
        { pc = 0x1a9477; break; }
  case 0x1a93d2: // 0160:1a93d2
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
  case 0x1a93d8: // 0160:1a93d8
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    if (!r8[ah])
        { pc = 0x1a9418; break; }
    if (!r8[al])
        { pc = 0x1a9404; break; }
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r8[bl] = r8[al];
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    r8[bl] = r8[ah];
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a93d8; break; }
    { pc = 0x1a9430; break; }
  case 0x1a9404: // 0160:1a9404
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a93d8; break; }
    { pc = 0x1a9430; break; }
  case 0x1a9418: // 0160:1a9418
    if (!r8[al])
        { pc = 0x1a9428; break; }
    r8[bl] = memoryAGet(ds, r32[edi] + 0x1);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a9428: // 0160:1a9428
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a93d8; break; }
  case 0x1a9430: // 0160:1a9430
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a93d2; break; }
  case 0x1a9444: // 0160:1a9444
    r32[esi] = memoryAGet32(ds, 0x2eeb6c);
    r32[edi] = memoryAGet32(ds, 0x2eeb70);
    r32[eax] = memoryAGet32(ds, 0x2eeb74);
    r32[esi] -= 0x00000050;
    r32[eax] += 0x01000000;
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1a946a; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c58);
    r32[edi]++;
  case 0x1a946a: // 0160:1a946a
    memoryASet32(ds, 0x2eeb78, memoryAGet32(ds, 0x2eeb78) - 1);
    if (memoryAGet32(ds, 0x2eeb78))
        { pc = 0x1a939e; break; }
    r32[esp] += 4; return;
  case 0x1a9477: // 0160:1a9477
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a9487; break; }
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a9487: // 0160:1a9487
    r32[edi]++;
    r32[esi]--;
    r32[ecx] = memoryAGet32(ds, 0x2eeb64);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1a94ea; break; }
  case 0x1a9492: // 0160:1a9492
    r16[ax] = memoryAGet16(ds, r32[esi] - 1);
    if (!r8[ah])
        { pc = 0x1a94d2; break; }
    if (!r8[al])
        { pc = 0x1a94be; break; }
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r8[bl] = r8[al];
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    r8[bl] = r8[ah];
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9492; break; }
    { pc = 0x1a94ea; break; }
  case 0x1a94be: // 0160:1a94be
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[ah]);
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9492; break; }
    { pc = 0x1a94ea; break; }
  case 0x1a94d2: // 0160:1a94d2
    if (!r8[al])
        { pc = 0x1a94e2; break; }
    r8[bl] = memoryAGet(ds, r32[edi] + 0x1);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
  case 0x1a94e2: // 0160:1a94e2
    r32[esi] -= 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1a9492; break; }
  case 0x1a94ea: // 0160:1a94ea
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1a94fa; break; }
    r8[bl] = memoryAGet(ds, r32[edi]);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x2eebec);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1a94fa: // 0160:1a94fa
    r32[esi]--;
    r32[edi]++;
    r32[esi] += memoryAGet32(ds, 0x2eeb5c);
    r32[edi] += memoryAGet32(ds, 0x2eeb60);
    memoryASet32(ds, 0x2eeb54, memoryAGet32(ds, 0x2eeb54) - 1);
    if (memoryAGet32(ds, 0x2eeb54))
        { pc = 0x1a9477; break; }
    { pc = 0x1a9444; break; }
    // gap 34403 bytes // gap 34403 bytes
  case 0x1b1b7c: // 0160:1b1b7c
    push32(r32[ebx]);
    r32[edi] = 0x0020b80c;
    r16[cx] <<= 3;
    r32[ecx] &= 0x0000ffff;
    r32[edi] += r32[ecx];
    r32[esi] = memoryAGet32(ds, r32[edi]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x4);
    r8[bl] <<= 2;
    r8[bh] = 0;
    r16[ax] += r16[bx];
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[edi] + 0x6);
    r8[bl] >>>= 1;
    r32[ebp] = pop32();
    r16[bp] += r16[bx];
    push32(r32[ebp]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x4);
    r8[bh] = memoryAGet(ds, r32[edi] + 0x6);
    r32[eax] &= 0x0000ffff;
    r32[edi] = r32[eax];
    r32[edi] -= 0x00000080;
    r16[ax] = r16[dx];
    r16[ax] &= 0x0003;
    r16[cx] = r16[dx];
    if (r16[ax] == 0x0001)
        { pc = 0x1b1be5; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1bdf; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1b1bd9; break; }
    { pc = 0x1b1be9; break; }
  case 0x1b1bd9: // 0160:1b1bd9
    r8[al] = 0x01;
    r8[ah] = 0x01;
    { pc = 0x1b1be9; break; }
  case 0x1b1bdf: // 0160:1b1bdf
    r8[al] = 0x00;
    r8[ah] = 0x01;
    { pc = 0x1b1be9; break; }
  case 0x1b1be5: // 0160:1b1be5
    r8[al] = 0x01;
    r8[ah] = 0x00;
  case 0x1b1be9: // 0160:1b1be9
    r32[edx] = pop32();
    r32[edx] &= 0x0000ffff;
    r32[edx] -= 0x00000080;
    if (r16[cx] < 0x0010)
        { pc = 0x1b1c01; break; }
    r16[cx] = 0;
    { pc = 0x1b1c05; break; }
  case 0x1b1c01: // 0160:1b1c01
    r8[ch] = 0x01;
    r8[cl] = 0;
  case 0x1b1c05: // 0160:1b1c05
    if (memoryAGet16(ds, 0x20ce8f) == 0xffff)
        { pc = 0x1b1c1d; break; }
    r8[cl] = memoryAGet(ds, 0x20ce8f);
    r8[cl] <<= 2;
  case 0x1b1c1d: // 0160:1b1c1d
    { pc = 0x1a9094; break; }
    return;
  }
}
function* sub_1b1c22() // 0160:1b1c22 +long
{
    r32[esp] -= 4;
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, 0x20c84e);
    r8[bl] = memoryAGet(ds, 0x20c84f);
    r8[cl] = memoryAGet(ds, 0x20c850);
    r8[al]--;
    r8[al] ^= r8[bl];
    r8[al] = rol8(r8[al], 0x01);
    r8[cl] = ror8(r8[cl], 0x01);
    memoryASet(ds, 0x20c84e, r8[al]);
    r8[al] ^= 0xff;
    r8[al] = rol8(r8[al], 0x01);
    r8[al] ^= 0x30;
    r8[al] ^= r8[bl];
    r8[bl] = r8[al];
    r8[al] ^= r8[cl];
    memoryASet(ds, 0x20c850, r8[cl]);
    memoryASet(ds, 0x20c84f, r8[bl]);
    r32[esp] += 4;
}
function* sub_1b1c25() // 0160:1b1c25 +long
{
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x20c84e);
    r8[bl] = memoryAGet(ds, 0x20c84f);
    r8[cl] = memoryAGet(ds, 0x20c850);
    r8[al]--;
    r8[al] ^= r8[bl];
    r8[al] = rol8(r8[al], 0x01);
    r8[cl] = ror8(r8[cl], 0x01);
    memoryASet(ds, 0x20c84e, r8[al]);
    r8[al] ^= 0xff;
    r8[al] = rol8(r8[al], 0x01);
    r8[al] ^= 0x30;
    r8[al] ^= r8[bl];
    r8[bl] = r8[al];
    r8[al] ^= r8[cl];
    memoryASet(ds, 0x20c850, r8[cl]);
    memoryASet(ds, 0x20c84f, r8[bl]);
    r32[esp] += 4;
}
function* sub_1b1c5c() // 0160:1b1c5c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b1c5c; break; }
  case 0x1b1c25: // 0160:1b1c25
    r8[al] = memoryAGet(ds, 0x20c84e);
    r8[bl] = memoryAGet(ds, 0x20c84f);
    r8[cl] = memoryAGet(ds, 0x20c850);
    r8[al]--;
    r8[al] ^= r8[bl];
    r8[al] = rol8(r8[al], 0x01);
    r8[cl] = ror8(r8[cl], 0x01);
    memoryASet(ds, 0x20c84e, r8[al]);
    r8[al] ^= 0xff;
    r8[al] = rol8(r8[al], 0x01);
    r8[al] ^= 0x30;
    r8[al] ^= r8[bl];
    r8[bl] = r8[al];
    r8[al] ^= r8[cl];
    memoryASet(ds, 0x20c850, r8[cl]);
    memoryASet(ds, 0x20c84f, r8[bl]);
    r32[esp] += 4; return;
  case 0x1b1c5c: // 0160:1b1c5c
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1b1c25; break; }
    r16[ax] = 0;
    r32[esp] += 4;
    return;
  }
}
function* sub_1b1c6b() // 0160:1b1c6b +long
{
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x20c852);
    r8[bl] = memoryAGet(ds, 0x20c853);
    r8[cl] = memoryAGet(ds, 0x20c854);
    r8[al]--;
    r8[al] ^= r8[bl];
    r8[al] = rol8(r8[al], 0x01);
    r8[cl] = ror8(r8[cl], 0x01);
    memoryASet(ds, 0x20c852, r8[al]);
    r8[al] ^= 0xff;
    r8[al] = rol8(r8[al], 0x01);
    r8[al] ^= 0x30;
    r8[al] ^= r8[bl];
    r8[bl] = r8[al];
    r8[al] ^= r8[cl];
    memoryASet(ds, 0x20c854, r8[cl]);
    memoryASet(ds, 0x20c853, r8[bl]);
    r32[esp] += 4;
}
function* sub_1b1ca2() // 0160:1b1ca2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b1ca2; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 654 bytes // gap 654 bytes
  case 0x1b1ca2: // 0160:1b1ca2
    if (!(memoryAGet16(ds, 0x20d7cf) & 0xffff))
        { pc = 0x1b1cd0; break; }
    memoryASet16(ds, 0x20d7cf, memoryAGet16(ds, 0x20d7cf) - 0x0001);
    if (memoryAGet16(ds, 0x20d7cf))
        { pc = 0x1b1cd0; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b1cc7; break; }
    yield* sub_1b191a();
  case 0x1b1cc7: // 0160:1b1cc7
    memoryASet16(ds, 0x20d7c1, 0x0000);
  case 0x1b1cd0: // 0160:1b1cd0
    if (memoryAGet16(ds, 0x20d7c1) & 0xffff)
        { pc = 0x1b1e80; break; }
    r8[bl] = memoryAGet(ds, 0x20e82d);
    r8[al] = memoryAGet(ds, 0x30b071);
    if (memoryAGet16(ds, 0x20d7bf))
        { pc = 0x1b1d05; break; }
    memoryASet(ds, 0x20e82d, r8[al]);
    if (!r8[al])
        { pc = 0x1b1d05; break; }
    if (!r8[bl])
        { pc = 0x1b1d25; break; }
  case 0x1b1d05: // 0160:1b1d05
    r8[bl] = memoryAGet(ds, 0x20d7c7);
    r8[al] = memoryAGet(ds, 0x30b0ab);
    memoryASet(ds, 0x20d7c7, r8[al]);
    if (!r8[al])
        { pc = 0x1b1d9d; break; }
    if (r8[bl])
        { pc = 0x1b1d9d; break; }
  case 0x1b1d25: // 0160:1b1d25
    r8[al] = memoryAGet(ds, 0x30b071);
    memoryASet(ds, 0x20e82d, r8[al]);
    memoryASet16(ds, 0x20d7bf, memoryAGet16(ds, 0x20d7bf) + 0x0001);
    memoryASet16(ds, 0x20d7bf, memoryAGet16(ds, 0x20d7bf) & 0x0001);
    if (memoryAGet16(ds, 0x20d7bf) & 0xffff)
        { pc = 0x1b1d83; break; }
    yield* sub_1c8764();
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x20d897, 0x0000);
    r8[al] = 0x7a;
    yield* sub_1b17b7();
    if (!(memoryAGet16(ds, 0x20d7b5) & 0xffff))
        { pc = 0x1b1e68; break; }
    r8[al] = 0x8b;
    yield* sub_1b18a6();
    { pc = 0x1b1e68; break; }
  case 0x1b1d83: // 0160:1b1d83
    yield* sub_1c8734();
    memoryASet16(ds, 0x20d7c3, 0x0001);
    yield* sub_1b191a();
    r8[al] = 0x4e;
    yield* sub_1b17b7();
  case 0x1b1d9d: // 0160:1b1d9d
    if (!(memoryAGet16(ds, 0x20d7bf) & 0xffff))
        { pc = 0x1b1e80; break; }
    r8[bl] = memoryAGet(ds, 0x20e82d);
    r8[al] = memoryAGet(ds, 0x30b071);
    memoryASet(ds, 0x20e82d, r8[al]);
    if (!r8[al])
        { pc = 0x1b1de0; break; }
    if (r8[bl])
        { pc = 0x1b1de0; break; }
    memoryASet16(ds, 0x20ee81, 0x0001);
    memoryASet16(ds, 0x20eddb, 0x0001);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    r32[esp] += 4; return;
  case 0x1b1de0: // 0160:1b1de0
    memoryASet16(ds, 0x20d7c3, memoryAGet16(ds, 0x20d7c3) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20d7c3);
    if (r16[ax] < 0x0002)
        { pc = 0x1b1e80; break; }
    if (r16[ax] == 0x0065)
        { pc = 0x1b1e04; break; }
    if (r16[ax] != 0x0028)
        { pc = 0x1b1e0b; break; }
  case 0x1b1e04: // 0160:1b1e04
    yield* sub_1b191a();
    { pc = 0x1b1e51; break; }
  case 0x1b1e0b: // 0160:1b1e0b
    if (r16[ax] != 0x0003)
        { pc = 0x1b1e51; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] -= 0x0030;
    r16[ax] >>>= 1;
    r16[ax] += 0x0080;
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] >>>= 1;
    r16[bx] -= 0x0028;
    r16[bx] += 0x0080;
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1b1e44; break; }
    r16[bx] -= 0x0020;
  case 0x1b1e44: // 0160:1b1e44
    r16[cx] = 0x001f;
    r16[dx] = 0x0010;
    { pc = 0x1b19e0; break; }
  case 0x1b1e51: // 0160:1b1e51
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
  case 0x1b1e57: // 0160:1b1e57
    r16[bx] = memoryAGet16(ds, 0x20ee4f);
    if (r16[bx] == r16[ax])
        { pc = 0x1b1e57; break; }
    { pc = 0x1b1cd0; break; }
  case 0x1b1e68: // 0160:1b1e68
    memoryASet16(ds, 0x20c830, memoryAGet16(ds, 0x20c830) + 0x0001);
    r8[al] = memoryAGet(ds, 0x20c82e);
    r8[al] <<= 1;
    if (r8[al])
        { pc = 0x1b1e7b; break; }
    r8[al] = 0x01;
  case 0x1b1e7b: // 0160:1b1e7b
    memoryASet(ds, 0x20c82e, r8[al]);
  case 0x1b1e80: // 0160:1b1e80
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b1e81() // 0160:1b1e81 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d7f1, 0x0000);
    memoryASet16(ds, 0x20d7f3, 0x0000);
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1b1ee8; break; }
    memoryASet16(ds, 0x20d7b3, 0x0003);
    r32[eax] = 0x0020cf4f;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020cf61;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x20d7a7);
    r16[dx] <<= 1;
    r32[edi] = memoryAGet32(ds, 0x20e811);
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[edx]);
    r16[ax] += 0x0010;
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[edx]);
    r16[bx] += 0x0010;
    { pc = 0x1b2008; break; }
  case 0x1b1ee8: // 0160:1b1ee8
    memoryASet16(ds, 0x20d7b3, 0x0010);
    r32[esi] = 0x0020d773;
    r32[eax] = 0x0020cf4f;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020cf61;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[eax] = 0x0020cf3d;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[eax] = 0x0020cf85;
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r32[eax] = 0;
    r16[cx] = 0;
    r16[dx] = 0;
    r16[ax] = 0xffff;
    r16[bx] = 0xffff;
    memoryASet16(ds, 0x20e7fd, 0x0000);
    memoryASet16(ds, 0x20e809, 0x0008);
  case 0x1b1f40: // 0160:1b1f40
    push(r16[ax]);
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20e801, r8[al]);
    r32[esi]++;
    r16[ax] = pop();
    if (!(memoryAGet(ds, 0x20e801) & 0xff))
        { pc = 0x1b1fd0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e819);
    r16[bp] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x20e819, memoryAGet32(ds, 0x20e819) + 0x00000002);
    if (r16[bp] > 0x0004)
        { pc = 0x1b1fd0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r16[bp] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x20e81d, memoryAGet32(ds, 0x20e81d) + 0x00000002);
    if (r16s[bp] >= signed16(0x0049))
        { pc = 0x1b1fd0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e811);
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    if (r16[bp] > r16[ax])
        { pc = 0x1b1f9e; break; }
    r16[ax] = r16[bp];
  case 0x1b1f9e: // 0160:1b1f9e
    if (r16[bp] < r16[cx])
        { pc = 0x1b1fa6; break; }
    r16[cx] = r16[bp];
  case 0x1b1fa6: // 0160:1b1fa6
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    if (r16[bp] > r16[bx])
        { pc = 0x1b1fc8; break; }
    r16[bx] = r16[bp];
  case 0x1b1fc8: // 0160:1b1fc8
    if (r16[bp] < r16[dx])
        { pc = 0x1b1fd0; break; }
    r16[dx] = r16[bp];
  case 0x1b1fd0: // 0160:1b1fd0
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) + 0x0002);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1b1f40; break; }
    r16[ax] += r16[cx];
    r16[ax] >>>= 1;
    r16[ax] += 0x0008;
    r16[bx] += r16[dx];
    r16[bx] >>>= 1;
    r16[bx] += 0x0008;
    r16[bp] = memoryAGet16(ds, 0x20d2b3);
    memoryASet16(ds, 0x20e805, r16[bp]);
  case 0x1b2008: // 0160:1b2008
    memoryASet16(ds, 0x20d2b1, r16[ax]);
    memoryASet16(ds, 0x20d2b3, r16[bx]);
    memoryASet16(ds, 0x20d2b5, 0x0000);
    if (!(memoryAGet16(ds, 0x20d867) & 0xffff))
        { pc = 0x1b206b; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] -= 0x0008;
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b1)) >= 0)
        { pc = 0x1b2049; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef5);
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) + r16[ax]);
  case 0x1b2049: // 0160:1b2049
    r16[ax] = memoryAGet16(ds, 0x20ee55);
    r16[ax] -= 0x0010;
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b3)) >= 0)
        { pc = 0x1b20b1; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) + r16[ax]);
    { pc = 0x1b20b1; break; }
  case 0x1b206b: // 0160:1b206b
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] -= 0x0010;
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b1)) >= 0)
        { pc = 0x1b208e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef5);
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) + r16[ax]);
  case 0x1b208e: // 0160:1b208e
    r16[ax] = memoryAGet16(ds, 0x20ee55);
    r16[ax] -= 0x0010;
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b3)) >= 0)
        { pc = 0x1b20b1; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) + r16[ax]);
  case 0x1b20b1: // 0160:1b20b1
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1b210c; break; }
    r16[bp] = memoryAGet16(ds, 0x20e805);
    r16[bp] -= memoryAGet16(ds, 0x20d2b3);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] <= signed16(0x0708))
        { pc = 0x1b210c; break; }
    if (r16[bp] >= 0xf8f8)
        { pc = 0x1b210c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b3);
    if (r16[ax] <= 0x0708)
        { pc = 0x1b210c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cef9);
    r16[bx] -= 0x0708;
    if (r16[bx] <= r16[ax])
        { pc = 0x1b210c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) + r16[ax]);
  case 0x1b210c: // 0160:1b210c
    r16[bx] = memoryAGet16(ds, 0x20cef5);
    r16[bx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d7f5) & 0xffff))
        { pc = 0x1b2148; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[ax] -= memoryAGet16(ds, 0x20d2b1);
    if (!r16[ax])
        { pc = 0x1b2253; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b213d; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
  case 0x1b213d: // 0160:1b213d
    if (r16s[bx] < r16s[ax])
        { pc = 0x1b21e4; break; }
    { pc = 0x1b216a; break; }
  case 0x1b2148: // 0160:1b2148
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[ax] -= memoryAGet16(ds, 0x20d2b1);
    if (!r16[ax])
        { pc = 0x1b2253; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b216a; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
    { pc = 0x1b21e4; break; }
  case 0x1b216a: // 0160:1b216a
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b219c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (r16s[bx] < signed16(memoryAGet16(ds, 0x20d2b1)))
        { pc = 0x1b219c; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b1);
    r16[bx] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[bx] > signed16(0x0028))
        { pc = 0x1b219c; break; }
    { pc = 0x1b2221; break; }
  case 0x1b219c: // 0160:1b219c
    r16[ax] -= memoryAGet16(ds, 0x20cef5);
    r16[ax] = -r16[ax];
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b21bd; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b21bd: // 0160:1b21bd
    memoryASet16(ds, 0x20d7f1, r16[ax]);
    memoryASet16(ds, 0x20d7f1, memoryAGet16(ds, 0x20d7f1) + 0x0001);
    memoryASet16(ds, 0x20d7f1, -memoryAGet16(ds, 0x20d7f1));
  case 0x1b21d2: // 0160:1b21d2
    push32(r32[eax]);
    yield* sub_1b242c();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b21d2; break; }
    { pc = 0x1b2253; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b21e4: // 0160:1b21e4
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b2221; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (r16s[bx] > signed16(memoryAGet16(ds, 0x20d2b1)))
        { pc = 0x1b2221; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b1);
    r16[bx] -= memoryAGet16(ds, 0x20cf23);
    r16[cx] = memoryAGet16(ds, 0x20cef5);
    r16[cx] -= r16[bx];
    if (r16s[cx] < signed16(0x00a0))
        { pc = 0x1b2221; break; }
    { pc = 0x1b219c; break; }
  case 0x1b2221: // 0160:1b2221
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b2238; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b2238: // 0160:1b2238
    memoryASet16(ds, 0x20d7f1, r16[ax]);
    memoryASet16(ds, 0x20d7f1, memoryAGet16(ds, 0x20d7f1) + 0x0001);
  case 0x1b2246: // 0160:1b2246
    push32(r32[eax]);
    yield* sub_1b24f5();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b2246; break; }
  case 0x1b2253: // 0160:1b2253
    if (memoryAGet16(ds, 0x20d7b9) != 0x0015)
        { pc = 0x1b228a; break; }
    if (!(memoryAGet16(ds, 0x20d861) & 0xffff))
        { pc = 0x1b228a; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    r16[ax] -= memoryAGet16(ds, 0x20d2b3);
    if (!r16[ax])
        { pc = 0x1b239e; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b232f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
    { pc = 0x1b22b5; break; }
  case 0x1b228a: // 0160:1b228a
    r16[bx] = memoryAGet16(ds, 0x20cef9);
    r16[bx] >>>= 1;
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    r16[ax] -= memoryAGet16(ds, 0x20d2b3);
    if (!r16[ax])
        { pc = 0x1b239e; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b22b0; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
  case 0x1b22b0: // 0160:1b22b0
    if (r16s[bx] >= r16s[ax])
        { pc = 0x1b232f; break; }
  case 0x1b22b5: // 0160:1b22b5
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b22e7; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] < signed16(memoryAGet16(ds, 0x20d2b3)))
        { pc = 0x1b22e7; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b3);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] > signed16(0x0028))
        { pc = 0x1b22e7; break; }
    { pc = 0x1b236c; break; }
  case 0x1b22e7: // 0160:1b22e7
    r16[ax] -= memoryAGet16(ds, 0x20cef9);
    r16[ax] = -r16[ax];
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b2308; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b2308: // 0160:1b2308
    memoryASet16(ds, 0x20d7f3, r16[ax]);
    memoryASet16(ds, 0x20d7f3, memoryAGet16(ds, 0x20d7f3) + 0x0001);
    memoryASet16(ds, 0x20d7f3, -memoryAGet16(ds, 0x20d7f3));
  case 0x1b231d: // 0160:1b231d
    push32(r32[eax]);
    yield* sub_1b2598();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b231d; break; }
    { pc = 0x1b239e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b232f: // 0160:1b232f
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b236c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] > signed16(memoryAGet16(ds, 0x20d2b3)))
        { pc = 0x1b236c; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b3);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    r16[cx] = memoryAGet16(ds, 0x20cef9);
    r16[cx] -= r16[bx];
    if (r16s[cx] < signed16(0x00a0))
        { pc = 0x1b236c; break; }
    { pc = 0x1b22e7; break; }
  case 0x1b236c: // 0160:1b236c
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b2383; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b2383: // 0160:1b2383
    memoryASet16(ds, 0x20d7f3, r16[ax]);
    memoryASet16(ds, 0x20d7f3, memoryAGet16(ds, 0x20d7f3) + 0x0001);
  case 0x1b2391: // 0160:1b2391
    push32(r32[eax]);
    yield* sub_1b266d();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b2391; break; }
  case 0x1b239e: // 0160:1b239e
    if (memoryAGet16(ds, 0x20d88d) & 0xffff)
        { pc = 0x1b2404; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b1);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16[ax])
        { pc = 0x1b23c7; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b3);
    r16[ax] -= memoryAGet16(ds, 0x20cf25);
    if (!r16[ax])
        { pc = 0x1b2422; break; }
  case 0x1b23c7: // 0160:1b23c7
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    if (!r16[ax])
        { pc = 0x1b2422; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (!r16[bx])
        { pc = 0x1b2422; break; }
    r16[bx] += memoryAGet16(ds, 0x20ee53);
    r16[bx]++;
    if (r16[bx] == memoryAGet16(ds, 0x20cef5))
        { pc = 0x1b2422; break; }
    r16[ax] += memoryAGet16(ds, 0x20ee55);
    r16[ax]++;
    if (r16[ax] == memoryAGet16(ds, 0x20cef9))
        { pc = 0x1b2422; break; }
    { pc = 0x1b242b; break; }
  case 0x1b2404: // 0160:1b2404
    r16[ax] = memoryAGet16(ds, 0x20d2b1);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16[ax])
        { pc = 0x1b242b; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b3);
    r16[ax] -= memoryAGet16(ds, 0x20cf25);
    if (r16[ax])
        { pc = 0x1b242b; break; }
  case 0x1b2422: // 0160:1b2422
    memoryASet16(ds, 0x20d2b5, 0x0001);
  case 0x1b242b: // 0160:1b242b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b1ef1() // 0160:1b1ef1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020d773;
    r32[eax] = 0x0020cf4f;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020cf61;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[eax] = 0x0020cf3d;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[eax] = 0x0020cf85;
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r32[eax] = 0;
    r16[cx] = 0;
    r16[dx] = 0;
    r16[ax] = 0xffff;
    r16[bx] = 0xffff;
    memoryASet16(ds, 0x20e7fd, 0x0000);
    memoryASet16(ds, 0x20e809, 0x0008);
  case 0x1b1f40: // 0160:1b1f40
    push(r16[ax]);
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20e801, r8[al]);
    r32[esi]++;
    r16[ax] = pop();
    if (!(memoryAGet(ds, 0x20e801) & 0xff))
        { pc = 0x1b1fd0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e819);
    r16[bp] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x20e819, memoryAGet32(ds, 0x20e819) + 0x00000002);
    if (r16[bp] > 0x0004)
        { pc = 0x1b1fd0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    r16[bp] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x20e81d, memoryAGet32(ds, 0x20e81d) + 0x00000002);
    if (r16s[bp] >= signed16(0x0049))
        { pc = 0x1b1fd0; break; }
    r32[edi] = memoryAGet32(ds, 0x20e811);
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    if (r16[bp] > r16[ax])
        { pc = 0x1b1f9e; break; }
    r16[ax] = r16[bp];
  case 0x1b1f9e: // 0160:1b1f9e
    if (r16[bp] < r16[cx])
        { pc = 0x1b1fa6; break; }
    r16[cx] = r16[bp];
  case 0x1b1fa6: // 0160:1b1fa6
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[ebp]);
    if (r16[bp] > r16[bx])
        { pc = 0x1b1fc8; break; }
    r16[bx] = r16[bp];
  case 0x1b1fc8: // 0160:1b1fc8
    if (r16[bp] < r16[dx])
        { pc = 0x1b1fd0; break; }
    r16[dx] = r16[bp];
  case 0x1b1fd0: // 0160:1b1fd0
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) + 0x0002);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1b1f40; break; }
    r16[ax] += r16[cx];
    r16[ax] >>>= 1;
    r16[ax] += 0x0008;
    r16[bx] += r16[dx];
    r16[bx] >>>= 1;
    r16[bx] += 0x0008;
    r16[bp] = memoryAGet16(ds, 0x20d2b3);
    memoryASet16(ds, 0x20e805, r16[bp]);
    memoryASet16(ds, 0x20d2b1, r16[ax]);
    memoryASet16(ds, 0x20d2b3, r16[bx]);
    memoryASet16(ds, 0x20d2b5, 0x0000);
    if (!(memoryAGet16(ds, 0x20d867) & 0xffff))
        { pc = 0x1b206b; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] -= 0x0008;
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b1)) >= 0)
        { pc = 0x1b2049; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef5);
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) + r16[ax]);
  case 0x1b2049: // 0160:1b2049
    r16[ax] = memoryAGet16(ds, 0x20ee55);
    r16[ax] -= 0x0010;
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b3)) >= 0)
        { pc = 0x1b20b1; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) + r16[ax]);
    { pc = 0x1b20b1; break; }
  case 0x1b206b: // 0160:1b206b
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] -= 0x0010;
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b1)) >= 0)
        { pc = 0x1b208e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef5);
    memoryASet16(ds, 0x20d2b1, memoryAGet16(ds, 0x20d2b1) + r16[ax]);
  case 0x1b208e: // 0160:1b208e
    r16[ax] = memoryAGet16(ds, 0x20ee55);
    r16[ax] -= 0x0010;
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d2b3)) >= 0)
        { pc = 0x1b20b1; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) + r16[ax]);
  case 0x1b20b1: // 0160:1b20b1
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1b210c; break; }
    r16[bp] = memoryAGet16(ds, 0x20e805);
    r16[bp] -= memoryAGet16(ds, 0x20d2b3);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] <= signed16(0x0708))
        { pc = 0x1b210c; break; }
    if (r16[bp] >= 0xf8f8)
        { pc = 0x1b210c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b3);
    if (r16[ax] <= 0x0708)
        { pc = 0x1b210c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cef9);
    r16[bx] -= 0x0708;
    if (r16[bx] <= r16[ax])
        { pc = 0x1b210c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d2b3, memoryAGet16(ds, 0x20d2b3) + r16[ax]);
  case 0x1b210c: // 0160:1b210c
    r16[bx] = memoryAGet16(ds, 0x20cef5);
    r16[bx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d7f5) & 0xffff))
        { pc = 0x1b2148; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[ax] -= memoryAGet16(ds, 0x20d2b1);
    if (!r16[ax])
        { pc = 0x1b2253; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b213d; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
  case 0x1b213d: // 0160:1b213d
    if (r16s[bx] < r16s[ax])
        { pc = 0x1b21e4; break; }
    { pc = 0x1b216a; break; }
  case 0x1b2148: // 0160:1b2148
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[ax] -= memoryAGet16(ds, 0x20d2b1);
    if (!r16[ax])
        { pc = 0x1b2253; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b216a; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
    { pc = 0x1b21e4; break; }
  case 0x1b216a: // 0160:1b216a
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b219c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (r16s[bx] < signed16(memoryAGet16(ds, 0x20d2b1)))
        { pc = 0x1b219c; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b1);
    r16[bx] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[bx] > signed16(0x0028))
        { pc = 0x1b219c; break; }
    { pc = 0x1b2221; break; }
  case 0x1b219c: // 0160:1b219c
    r16[ax] -= memoryAGet16(ds, 0x20cef5);
    r16[ax] = -r16[ax];
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b21bd; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b21bd: // 0160:1b21bd
    memoryASet16(ds, 0x20d7f1, r16[ax]);
    memoryASet16(ds, 0x20d7f1, memoryAGet16(ds, 0x20d7f1) + 0x0001);
    memoryASet16(ds, 0x20d7f1, -memoryAGet16(ds, 0x20d7f1));
  case 0x1b21d2: // 0160:1b21d2
    push32(r32[eax]);
    yield* sub_1b242c();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b21d2; break; }
    { pc = 0x1b2253; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b21e4: // 0160:1b21e4
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b2221; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (r16s[bx] > signed16(memoryAGet16(ds, 0x20d2b1)))
        { pc = 0x1b2221; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b1);
    r16[bx] -= memoryAGet16(ds, 0x20cf23);
    r16[cx] = memoryAGet16(ds, 0x20cef5);
    r16[cx] -= r16[bx];
    if (r16s[cx] < signed16(0x00a0))
        { pc = 0x1b2221; break; }
    { pc = 0x1b219c; break; }
  case 0x1b2221: // 0160:1b2221
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b2238; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b2238: // 0160:1b2238
    memoryASet16(ds, 0x20d7f1, r16[ax]);
    memoryASet16(ds, 0x20d7f1, memoryAGet16(ds, 0x20d7f1) + 0x0001);
  case 0x1b2246: // 0160:1b2246
    push32(r32[eax]);
    yield* sub_1b24f5();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b2246; break; }
  case 0x1b2253: // 0160:1b2253
    if (memoryAGet16(ds, 0x20d7b9) != 0x0015)
        { pc = 0x1b228a; break; }
    if (!(memoryAGet16(ds, 0x20d861) & 0xffff))
        { pc = 0x1b228a; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    r16[ax] -= memoryAGet16(ds, 0x20d2b3);
    if (!r16[ax])
        { pc = 0x1b239e; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b232f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
    { pc = 0x1b22b5; break; }
  case 0x1b228a: // 0160:1b228a
    r16[bx] = memoryAGet16(ds, 0x20cef9);
    r16[bx] >>>= 1;
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    r16[ax] -= memoryAGet16(ds, 0x20d2b3);
    if (!r16[ax])
        { pc = 0x1b239e; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1b22b0; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef9);
  case 0x1b22b0: // 0160:1b22b0
    if (r16s[bx] >= r16s[ax])
        { pc = 0x1b232f; break; }
  case 0x1b22b5: // 0160:1b22b5
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b22e7; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] < signed16(memoryAGet16(ds, 0x20d2b3)))
        { pc = 0x1b22e7; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b3);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] > signed16(0x0028))
        { pc = 0x1b22e7; break; }
    { pc = 0x1b236c; break; }
  case 0x1b22e7: // 0160:1b22e7
    r16[ax] -= memoryAGet16(ds, 0x20cef9);
    r16[ax] = -r16[ax];
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b2308; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b2308: // 0160:1b2308
    memoryASet16(ds, 0x20d7f3, r16[ax]);
    memoryASet16(ds, 0x20d7f3, memoryAGet16(ds, 0x20d7f3) + 0x0001);
    memoryASet16(ds, 0x20d7f3, -memoryAGet16(ds, 0x20d7f3));
  case 0x1b231d: // 0160:1b231d
    push32(r32[eax]);
    yield* sub_1b2598();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b231d; break; }
    { pc = 0x1b239e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b232f: // 0160:1b232f
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b236c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] > signed16(memoryAGet16(ds, 0x20d2b3)))
        { pc = 0x1b236c; break; }
    r16[bx] = memoryAGet16(ds, 0x20d2b3);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    r16[cx] = memoryAGet16(ds, 0x20cef9);
    r16[cx] -= r16[bx];
    if (r16s[cx] < signed16(0x00a0))
        { pc = 0x1b236c; break; }
    { pc = 0x1b22e7; break; }
  case 0x1b236c: // 0160:1b236c
    r16[ax]--;
    if (r16[ax] < memoryAGet16(ds, 0x20d7b3))
        { pc = 0x1b2383; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b3);
    r16[ax]--;
  case 0x1b2383: // 0160:1b2383
    memoryASet16(ds, 0x20d7f3, r16[ax]);
    memoryASet16(ds, 0x20d7f3, memoryAGet16(ds, 0x20d7f3) + 0x0001);
  case 0x1b2391: // 0160:1b2391
    push32(r32[eax]);
    yield* sub_1b266d();
    r32[eax] = pop32();
    r16[ax]--;
    if (r16s[ax] >= 0)
        { pc = 0x1b2391; break; }
  case 0x1b239e: // 0160:1b239e
    if (memoryAGet16(ds, 0x20d88d) & 0xffff)
        { pc = 0x1b2404; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b1);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16[ax])
        { pc = 0x1b23c7; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b3);
    r16[ax] -= memoryAGet16(ds, 0x20cf25);
    if (!r16[ax])
        { pc = 0x1b2422; break; }
  case 0x1b23c7: // 0160:1b23c7
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    if (!r16[ax])
        { pc = 0x1b2422; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (!r16[bx])
        { pc = 0x1b2422; break; }
    r16[bx] += memoryAGet16(ds, 0x20ee53);
    r16[bx]++;
    if (r16[bx] == memoryAGet16(ds, 0x20cef5))
        { pc = 0x1b2422; break; }
    r16[ax] += memoryAGet16(ds, 0x20ee55);
    r16[ax]++;
    if (r16[ax] == memoryAGet16(ds, 0x20cef9))
        { pc = 0x1b2422; break; }
    { pc = 0x1b242b; break; }
  case 0x1b2404: // 0160:1b2404
    r16[ax] = memoryAGet16(ds, 0x20d2b1);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16[ax])
        { pc = 0x1b242b; break; }
    r16[ax] = memoryAGet16(ds, 0x20d2b3);
    r16[ax] -= memoryAGet16(ds, 0x20cf25);
    if (r16[ax])
        { pc = 0x1b242b; break; }
  case 0x1b2422: // 0160:1b2422
    memoryASet16(ds, 0x20d2b5, 0x0001);
  case 0x1b242b: // 0160:1b242b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b242c() // 0160:1b242c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1b2482; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    r16[bx]++;
    r16[cx] = memoryAGet16(ds, 0x20cef5);
    r16[cx] -= memoryAGet16(ds, 0x20ee53);
    if (r16[bx] != r16[cx])
        { pc = 0x1b246e; break; }
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b246e; break; }
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b246e; break; }
    r32[esp] += 4; return;
  case 0x1b246e: // 0160:1b246e
    if (r16[bx] != memoryAGet16(ds, 0x20cef5))
        { pc = 0x1b247a; break; }
    r16[bx] = 0;
  case 0x1b247a: // 0160:1b247a
    memoryASet16(ds, 0x20cf23, r16[bx]);
    r32[esp] += 4; return;
  case 0x1b2482: // 0160:1b2482
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    r16[bx]++;
    memoryASet16(ds, 0x20cf23, r16[bx]);
    r16[bx] &= 0x0001;
    if (r16[bx])
        { pc = 0x1b24f4; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    r16[cx] = memoryAGet16(ds, 0x20cef5);
    r16[cx] -= memoryAGet16(ds, 0x20ee53);
    r16[cx] -= memoryAGet16(ds, 0x20ee53);
    if (r16[bx] != r16[cx])
        { pc = 0x1b24e1; break; }
    memoryASet16(ds, 0x20d2b5, 0x0001);
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b24e1; break; }
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b24e1; break; }
    memoryASet16(ds, 0x20cf23, memoryAGet16(ds, 0x20cf23) - 0x0001);
    r32[esp] += 4; return;
  case 0x1b24e1: // 0160:1b24e1
    if (r16[bx] != memoryAGet16(ds, 0x20cef5))
        { pc = 0x1b24ed; break; }
    r16[bx] = 0;
  case 0x1b24ed: // 0160:1b24ed
    memoryASet16(ds, 0x20cf23, r16[bx]);
  case 0x1b24f4: // 0160:1b24f4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b24f5() // 0160:1b24f5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1b253d; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    r16[bx]--;
    if (r16[bx] != 0xffff)
        { pc = 0x1b2535; break; }
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b252a; break; }
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b252a; break; }
    r32[esp] += 4; return;
  case 0x1b252a: // 0160:1b252a
    r16[bx] = memoryAGet16(ds, 0x20cef5);
    r16[bx]--;
  case 0x1b2535: // 0160:1b2535
    memoryASet16(ds, 0x20cf23, r16[bx]);
    r32[esp] += 4; return;
  case 0x1b253d: // 0160:1b253d
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    r16[bx]--;
    memoryASet16(ds, 0x20cf23, r16[bx]);
    r16[bx] &= 0x0001;
    if (!r16[bx])
        { pc = 0x1b2597; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf23);
    if (r16[bx] != 0xffff)
        { pc = 0x1b2590; break; }
    memoryASet16(ds, 0x20d2b5, 0x0001);
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b258d; break; }
    if (memoryAGet(ds, 0x20d88b) & 0xff)
        { pc = 0x1b258d; break; }
    memoryASet16(ds, 0x20cf23, memoryAGet16(ds, 0x20cf23) + 0x0001);
    r32[esp] += 4; return;
  case 0x1b258d: // 0160:1b258d
    r16[bx] = 0;
  case 0x1b2590: // 0160:1b2590
    memoryASet16(ds, 0x20cf23, r16[bx]);
  case 0x1b2597: // 0160:1b2597
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b2598() // 0160:1b2598 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1b25f2; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    r16[bx]++;
    r16[cx] = memoryAGet16(ds, 0x20cef9);
    r16[cx] -= memoryAGet16(ds, 0x20ee55);
    if (r16[bx] != r16[cx])
        { pc = 0x1b25da; break; }
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b25da; break; }
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b25da; break; }
    r32[esp] += 4; return;
  case 0x1b25da: // 0160:1b25da
    if (r16[bx] < memoryAGet16(ds, 0x20cef9))
        { pc = 0x1b25ea; break; }
    r16[bx] -= memoryAGet16(ds, 0x20cef9);
  case 0x1b25ea: // 0160:1b25ea
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r32[esp] += 4; return;
  case 0x1b25f2: // 0160:1b25f2
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    r16[bx]++;
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r16[bx] &= 0x0001;
    if (r16[bx])
        { pc = 0x1b266c; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    r16[cx] = memoryAGet16(ds, 0x20cef9);
    r16[cx] -= memoryAGet16(ds, 0x20ee55);
    r16[cx] -= memoryAGet16(ds, 0x20ee55);
    if (r16[bx] != r16[cx])
        { pc = 0x1b2655; break; }
    memoryASet16(ds, 0x20d2b5, 0x0001);
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b2655; break; }
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b2655; break; }
    memoryASet16(ds, 0x20cf25, memoryAGet16(ds, 0x20cf25) - 0x0001);
    r32[esp] += 4; return;
  case 0x1b2655: // 0160:1b2655
    if (r16[bx] < memoryAGet16(ds, 0x20cef9))
        { pc = 0x1b2665; break; }
    r16[bx] -= memoryAGet16(ds, 0x20cef9);
  case 0x1b2665: // 0160:1b2665
    memoryASet16(ds, 0x20cf25, r16[bx]);
  case 0x1b266c: // 0160:1b266c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b266d() // 0160:1b266d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1b26b5; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    r16[bx]--;
    if (r16[bx] != 0xffff)
        { pc = 0x1b26ad; break; }
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b26a2; break; }
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b26a2; break; }
    r32[esp] += 4; return;
  case 0x1b26a2: // 0160:1b26a2
    r16[bx] = memoryAGet16(ds, 0x20cef9);
    r16[bx]--;
  case 0x1b26ad: // 0160:1b26ad
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r32[esp] += 4; return;
  case 0x1b26b5: // 0160:1b26b5
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    r16[bx]--;
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r16[bx] &= 0x0001;
    if (!r16[bx])
        { pc = 0x1b270f; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    if (r16[bx] != 0xffff)
        { pc = 0x1b2708; break; }
    memoryASet16(ds, 0x20d2b5, 0x0001);
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1b2704; break; }
    if (memoryAGet(ds, 0x20d88d) & 0xff)
        { pc = 0x1b2704; break; }
    memoryASet16(ds, 0x20cf25, memoryAGet16(ds, 0x20cf25) + 0x0001);
    r32[esp] += 4; return;
  case 0x1b2704: // 0160:1b2704
    r16[bx] = 0x0001;
  case 0x1b2708: // 0160:1b2708
    memoryASet16(ds, 0x20cf25, r16[bx]);
  case 0x1b270f: // 0160:1b270f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b29b6() // 0160:1b29b6 +long
{
    r32[esp] -= 4;
    r32[esi] = memoryAGet32(ds, 0x2eeb94);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x3);
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] <<= 5;
    r16[bx] <<= 5;
    memoryASet16(ds, 0x20cef9, r16[bx]);
    r32[ebx] = pop32();
    r32[eax] = pop32();
    mul16(r16[bx]);
    r32[eax] <<= 1;
    memoryASet32(ds, 0x20ceff, r32[eax]);
    r32[esi] += 0x00000004;
    r32[esi] += r32[eax];
    memoryASet32(ds, 0x20cf07, r32[esi]);
    memoryASet32(ds, 0x20cf0b, r32[esi]);
    memoryASet32(ds, 0x20cf0f, r32[esi]);
    memoryASet32(ds, 0x20cf13, r32[esi]);
    memoryASet32(ds, 0x20cf17, r32[esi]);
    r32[esp] += 4;
}
function* sub_1b2a07() // 0160:1b2a07 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    memoryASet16(ds, 0x224644, 0x0000);
    memoryASet32(ds, 0x1f1c48, 0x00000140);
    memoryASet32(ds, 0x1f1c4c, 0x000000f0);
    yield* sub_1a8b3c();
    r32[edx] = 0x001ecb03;
    r32[eax] = 0x0023c4e0;
    yield* sub_1aa4e9();
    r32[esi] = 0x0023c4e0;
    r32[edi] = 0x0020c88f;
    r32[ecx] = 0x00000300;
  case 0x1b2a4c: // 0160:1b2a4c
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b2a4c; break; }
    memoryASet16(ds, 0x224666, 0x0000);
    r32[eax] = 0x000a5000;
    r32[edx] = 0x0023c7e0;
    memoryASet16(ds, 0x20d80d, 0x0000);
  case 0x1b2a89: // 0160:1b2a89
    r32[ecx] = memoryAGet32(ds, 0x2eebd0);
    push32(r32[ecx]);
    r32[ebx] = memoryAGet32(ds, 0x20b800);
    r32[ebx] += 0x00030d40;
    push32(r32[eax]);
    yield* sub_1da2a8();
    r32[eax] = pop32();
    memoryASet16(ds, 0x1f1cb8, r16[ax]);
    r16[ax] += 0x5000;
    if (r16[ax] < 0xf000)
        { pc = 0x1b2ab6; break; }
    r16[ax] = 0;
  case 0x1b2ab6: // 0160:1b2ab6
    r32[ecx] = pop32();
    r32[ecx] += 0x00000003;
  case 0x1b2aba: // 0160:1b2aba
    yield* sync();
    if (memoryAGet32(ds, 0x2eebd0) < r32[ecx])
        { pc = 0x1b2aba; break; }
    if (memoryAGet16(ds, r32[edx]) != 0xffff)
        { pc = 0x1b2a89; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2aca() // 0160:1b2aca +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    r32[edx] = 0x001ed0b5;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edx] = 0x001ed0c9;
    r32[edi] = 0x000a4800;
    yield* sub_1b524f();
    memoryASet16(ds, 0x224648, 0x0000);
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b2b0d: // 0160:1b2b0d
    yield* sub_1b2b87();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b2b25; break; }
    memoryASet16(ds, 0x20cec3, memoryAGet16(ds, 0x20cec3) + 1);
  case 0x1b2b25: // 0160:1b2b25
    if (memoryAGet16(ds, 0x20cec3) != 0x0006)
        { pc = 0x1b2b70; break; }
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    yield* sub_1b4edf();
    yield* sub_1b4ec6();
    r32[edi] = 0x0020c88f;
    r32[esi] = 0x0020e9c5;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    yield* sub_1b4f0e();
    memoryASet16(ds, 0x224648, 0x0001);
    memoryASet16(ds, 0x20cec3, memoryAGet16(ds, 0x20cec3) + 1);
  case 0x1b2b70: // 0160:1b2b70
    if (memoryAGet16(ds, 0x20cec3) != 0x000d)
        { pc = 0x1b2b7b; break; }
    r32[esp] += 4; return;
  case 0x1b2b7b: // 0160:1b2b7b
    if (memoryAGet(ds, 0x20c840) & 0xff)
        { pc = 0x1b2b86; break; }
    { pc = 0x1b2b0d; break; }
  case 0x1b2b86: // 0160:1b2b86
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b2b87() // 0160:1b2b87 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = 0;
    if (!(memoryAGet16(ds, 0x224648) & 0xffff))
        { pc = 0x1b2b99; break; }
    r16[bx] = 0x4800;
  case 0x1b2b99: // 0160:1b2b99
    memoryASet16(ds, 0x1f1cb8, r16[bx]);
    yield* sub_1a840e();
    memoryASet16(ds, 0x20eeb0, memoryAGet16(ds, 0x20eeb0) + 1);
    { pc = 0x1bdf30; break; }
    // gap 45951 bytes // gap 45951 bytes
  case 0x1bdf30: // 0160:1bdf30
    memoryASet(ds, 0x20c840, 0x00);
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1bdf4b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1bdf4b: // 0160:1bdf4b
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1bdf5f; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x20);
  case 0x1bdf5f: // 0160:1bdf5f
    r8[al] = memoryAGet(ds, 0x30b0ec);
    if (r8[al])
        { pc = 0x1bdf79; break; }
    r8[al] = memoryAGet(ds, 0x30b08c);
    if (!r8[al])
        { pc = 0x1bdf80; break; }
  case 0x1bdf79: // 0160:1bdf79
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1bdf80: // 0160:1bdf80
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1bdf94; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1bdf94: // 0160:1bdf94
    if (!memoryAGet(ds, 0x30b118))
        { pc = 0x1bdfa4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x01);
  case 0x1bdfa4: // 0160:1bdfa4
    if (!memoryAGet(ds, 0x30b120))
        { pc = 0x1bdfb4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x02);
  case 0x1bdfb4: // 0160:1bdfb4
    if (!memoryAGet(ds, 0x30b11d))
        { pc = 0x1bdfc4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1bdfc4: // 0160:1bdfc4
    if (!memoryAGet(ds, 0x30b11b))
        { pc = 0x1bdfd4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1bdfd4: // 0160:1bdfd4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b2bb1() // 0160:1b2bb1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed7f, 0x0001);
    memoryASet16(ds, 0x20ee49, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20ed83);
    r16[ax]++;
    if (r16[ax] != 0x000c)
        { pc = 0x1b2bd3; break; }
    r32[eax] = 0;
  case 0x1b2bd3: // 0160:1b2bd3
    memoryASet16(ds, 0x20ed83, r16[ax]);
    r16[ax] <<= 1;
    r32[esi] = 0x001ef528;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    if (r16[ax] == 0x00ff)
        { pc = 0x1b2caa; break; }
    memoryASet16(ds, 0x20ed4d, 0x0004);
    r32[esi] = 0x00203e42;
    r16[cx] = 0x000e;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d7b9, r16[cx]);
    r32[ecx] = memoryAGet32(ds, r32[esi] + r32[eax] + 0xa);
    memoryASet32(ds, 0x20d859, r32[ecx]);
    r16[bx] = 0x0003;
    memoryASet16(ds, 0x20d865, r16[bx]);
    memoryASet16(ds, 0x20e8bb, r16[bx]);
    r32[edi] = 0x0020e8c1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x8);
    r32[ebp] = 0x00000003;
  case 0x1b2c44: // 0160:1b2c44
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    if (r16[bx] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1b2c55; break; }
    r16[bx] = r16[cx];
  case 0x1b2c55: // 0160:1b2c55
    memoryASet16(ds, r32[edi], r16[bx]);
    r32[edi] += 0x00000002;
    r32[eax] += 0x00000002;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1b2c44; break; }
    memoryASet16(ds, 0x20ed81, 0x0078);
    yield* sub_1b8241();
    if (memoryAGet16(ds, 0x20ed81) & 0xffff)
        { pc = 0x1b2cb9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    push32(r32[eax]);
    memoryASet16(ds, 0x20d7f5, 0x0001);
    memoryASet16(ds, 0x20d89f, 0x0000);
    memoryASet16(ds, 0x20ed81, 0x028a);
    yield* sub_1abc11();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20d7f5, r16[ax]);
    { pc = 0x1b2cb9; break; }
  case 0x1b2caa: // 0160:1b2caa
    yield* sub_1b2a07();
    yield* sub_1cdeae();
    yield* sub_1b2aca();
  case 0x1b2cb9: // 0160:1b2cb9
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b2ccb; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b2ccb: // 0160:1b2ccb
    memoryASet16(ds, 0x20ed7f, 0x0000);
    memoryASet16(ds, 0x20ed81, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2cde() // 0160:1b2cde +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ed0a1;
    r32[eax] = 0x00003d02;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    { pc = 0x1b2d10; break; }
    // gap 25 bytes // gap 25 bytes
  case 0x1b2d10: // 0160:1b2d10
    r32[edx] = 0x0023f52c;
    r32[ecx] = 0x00002ed4;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
    // gap 144 bytes // gap 144 bytes
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    // gap 393 bytes // gap 393 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2cf7() // 0160:1b2cf7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ed0a1;
    r32[ecx] = 0;
    r32[eax] = 0x00003c00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0023f52c;
    r32[ecx] = 0x00002ed4;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
    // gap 144 bytes // gap 144 bytes
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    // gap 393 bytes // gap 393 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2d91() // 0160:1b2d91 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ed08d;
    r32[eax] = 0x00003d02;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0022479c;
    r32[ecx] = 0x00000410;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    // gap 393 bytes // gap 393 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2df9() // 0160:1b2df9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b2df9; break; }
  case 0x1b2d3b: // 0160:1b2d3b
    memoryASet32(ds, 0x224b7a, 0x53757065);
    memoryASet32(ds, 0x224b7e, 0x72736f6e);
    memoryASet32(ds, 0x224b82, 0x69632053);
    memoryASet32(ds, 0x224b86, 0x6f667477);
    memoryASet32(ds, 0x224b8a, 0x61726520);
    memoryASet32(ds, 0x224b8e, 0x4c74642e);
    r32[edx] = 0x001ed08d;
    r32[ecx] = 0;
    r32[eax] = 0x00003c00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    { pc = 0x1b2da4; break; }
    // gap 22 bytes // gap 22 bytes
  case 0x1b2da4: // 0160:1b2da4
    r32[edx] = 0x0022479c;
    r32[ecx] = 0x00000410;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
  case 0x1b2df9: // 0160:1b2df9
    memoryASet32(ds, 0x22479c, 0x68617372);
    memoryASet32(ds, 0x2247a0, 0x65736574);
    memoryASet16(ds, 0x2247a4, 0x0000);
    memoryASet16(ds, 0x20ee3d, 0x0000);
    memoryASet16(ds, 0x20ee3f, 0x0000);
    memoryASet16(ds, 0x20ee41, 0x0000);
    memoryASet16(ds, 0x20ee43, 0x0000);
    push(ds);
    es = pop();
    r32[edi] = 0x00224866;
    r32[esi] = 0x001ec010;
    r32[ecx] = 0x00000060;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x0020edbd;
    memoryASet(ds, r32[esi], 0x04);
    memoryASet(ds, r32[esi] + 0x1, 0x05);
    memoryASet(ds, r32[esi] + 0x2, 0x09);
    memoryASet(ds, r32[esi] + 0x3, 0x09);
    memoryASet(ds, r32[esi] + 0x4, 0x09);
    memoryASet(ds, r32[esi] + 0x5, 0x00);
    r32[eax] = memoryAGet32(ds, 0x224866);
    r16[bx] = memoryAGet16(ds, 0x22486a);
    push32(r32[eax]);
    push32(r32[ebx]);
    r32[esi] = 0x00224866;
    r32[ecx] = 0x00000006;
  case 0x1b2e81: // 0160:1b2e81
    memoryASet(ds, r32[esi], 0x5b);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1b2e81; break; }
    memoryASet16(ds, 0x20e809, 0x001d);
    r32[edi] = 0x002248c6;
  case 0x1b2e95: // 0160:1b2e95
    yield* sub_1be4a2();
    yield* sub_1be4a2();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 1);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1b2e95; break; }
    memoryASet16(ds, 0x20e809, 0x001b);
    r32[edi] = 0x002249f6;
  case 0x1b2eb6: // 0160:1b2eb6
    yield* sub_1be4a2();
    yield* sub_1be4a2();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 1);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1b2eb6; break; }
    memoryASet16(ds, 0x20e809, 0x03e7);
    r32[edi] = 0x0023f52c;
  case 0x1b2ed7: // 0160:1b2ed7
    yield* sub_1be4a2();
    yield* sub_1be4a2();
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 1);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1b2ed7; break; }
    yield* sub_1b2cf7();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    memoryASet32(ds, 0x224866, r32[eax]);
    memoryASet16(ds, 0x22486a, r16[bx]);
    r32[esi] = 0x002247a6;
    r16[ax] = 0x00ff;
    r32[ecx] = 0x00000060;
  case 0x1b2f0b: // 0160:1b2f0b
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b2f0b; break; }
    { pc = 0x1b2d3b; break; }
    // gap 106 bytes // gap 106 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2f18() // 0160:1b2f18 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ed08d;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2f77; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0022479c;
    r32[ecx] = 0x00000410;
    memoryASet32(ds, 0x20ceeb, r32[ecx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2f6c; break; }
    if (memoryAGet32(ds, 0x20ceeb) != r32[eax])
        { pc = 0x1b2f61; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1b2f61: // 0160:1b2f61
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f82; break; }
  case 0x1b2f6c: // 0160:1b2f6c
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1b2f82; break; }
  case 0x1b2f77: // 0160:1b2f77
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b2f82() // 0160:1b2f82 +long
{
    r32[esp] -= 4;
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
}
function* sub_1b2f96() // 0160:1b2f96 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    r32[edx] = 0x001ecd32;
    yield* sub_1bd863();
    yield* sub_1b55c7();
    yield* sub_1bd478();
    r32[esi] = 0x0020e8e1;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    memoryASet16(ds, 0x20ecbb, 0x0001);
    yield* sub_1bd346();
    memoryASet16(ds, 0x20e909, 0x0000);
    memoryASet16(ds, 0x20e8fb, 0x0002);
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x20e8fd, 0x0114);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
    yield* sub_1b191a();
    r8[al] = 0x06;
    yield* sub_1b18a6();
  case 0x1b3019: // 0160:1b3019
    yield* sub_1b5096();
    yield* sub_1b531f();
    if (signed16(memoryAGet16(ds, 0x20e909)) <= signed16(0x001e))
        { pc = 0x1b302e; break; }
    r32[esp] += 4; return;
  case 0x1b302e: // 0160:1b302e
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1b3041; break; }
    memoryASet16(ds, 0x20e909, memoryAGet16(ds, 0x20e909) + 1);
  case 0x1b3041: // 0160:1b3041
    yield* sub_1b3052();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b3019; break; }
    return;
  }
}
function* sub_1b3052() // 0160:1b3052 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231d2, 0x0001);
    r32[esi] = 0x002245f0;
    memoryASet16(ds, r32[esi], 0x00b0);
    memoryASet16(ds, r32[esi] + 0x2, 0x009c);
    memoryASet16(ds, r32[esi] + 0x4, 0x0010);
    memoryASet16(ds, r32[esi] + 0x6, 0x0010);
    r16[ax] = memoryAGet16(ds, 0x20e8fb);
    if (r16[ax] == 0x0102)
        { pc = 0x1b308d; break; }
    r16[ax] += 0x0008;
    memoryASet16(ds, 0x20e8fb, r16[ax]);
  case 0x1b308d: // 0160:1b308d
    r16[bx] = 0x0114;
    r16[cx] = 0;
    r16[dx] = 0x0005;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    yield* sub_1bd7dd();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0034;
    if (signed16(memoryAGet16(ds, 0x20e909)) < signed16(0x0008))
        { pc = 0x1b3107; break; }
    if (signed16(memoryAGet16(ds, 0x20e909)) < signed16(0x000a))
        { pc = 0x1b30e8; break; }
    if (signed16(memoryAGet16(ds, 0x20e909)) < signed16(0x0014))
        { pc = 0x1b3107; break; }
    if (memoryAGet16(ds, 0x20e8fd) == 0x0114)
        { pc = 0x1b3107; break; }
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x0001;
    if (!r16[bp])
        { pc = 0x1b3107; break; }
    memoryASet16(ds, 0x20e8fd, memoryAGet16(ds, 0x20e8fd) - 1);
    { pc = 0x1b3107; break; }
  case 0x1b30e8: // 0160:1b30e8
    if (memoryAGet16(ds, 0x20e8fd) == 0x011c)
        { pc = 0x1b3107; break; }
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x0001;
    if (!r16[bp])
        { pc = 0x1b3107; break; }
    memoryASet16(ds, 0x20e8fd, memoryAGet16(ds, 0x20e8fd) + 1);
  case 0x1b3107: // 0160:1b3107
    r16[bx] = memoryAGet16(ds, 0x20e8fd);
    r16[bp] = memoryAGet16(ds, 0x20e90b);
    if (memoryAGet16(ds, 0x20e909) > 0x0013)
        { pc = 0x1b3121; break; }
    r16[bp]++;
  case 0x1b3121: // 0160:1b3121
    if (r16s[bp] < signed16(0x000a))
        { pc = 0x1b312b; break; }
    r16[bp] = 0x0009;
  case 0x1b312b: // 0160:1b312b
    r16[bp]++;
    r16[cx] += r16[bp];
    yield* sub_1bd7dd();
    r16[ax] = 0x0108;
    r16[bx] = 0x00d8;
    r16[cx] = 0;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x003f;
    r16[bp] >>>= 5;
    if (!r16[bp])
        { pc = 0x1b3153; break; }
    r16[cx]++;
  case 0x1b3153: // 0160:1b3153
    r16[cx] &= 0x0001;
    r16[cx] += 0x000b;
    r16[dx] = 0x0004;
    yield* sub_1bd50f();
    r16[cx] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20cec3, r16[cx]);
    r16[cx] += 0x0012;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r16[bx] += 0x0030;
    yield* sub_1bd51f();
    yield* sub_1bd50f();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[cx] = 0x000d;
    r16[dx] = 0x0008;
    { pc = 0x1bd507; break; }
    // gap 41838 bytes // gap 41838 bytes
  case 0x1bd507: // 0160:1bd507
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3199() // 0160:1b3199 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b34c8();
    yield* sub_1b3af9();
  case 0x1b31a3: // 0160:1b31a3
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    yield* sub_1b531f();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b31cb; break; }
    memoryASet16(ds, 0x20ed5b, memoryAGet16(ds, 0x20ed5b) + 1);
  case 0x1b31cb: // 0160:1b31cb
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b31dd; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b31dd: // 0160:1b31dd
    if (memoryAGet16(ds, 0x20ee49) & 0xffff)
        { pc = 0x1b31f4; break; }
    if (memoryAGet16(ds, 0x20ed5b) == 0x0018)
        { pc = 0x1b31fe; break; }
    if (memoryAGet16(ds, 0x20ed5b) != 0x0018)
        { pc = 0x1b3222; break; }
  case 0x1b31f4: // 0160:1b31f4
    if (memoryAGet16(ds, 0x20ed5b) != 0x0003)
        { pc = 0x1b3222; break; }
  case 0x1b31fe: // 0160:1b31fe
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x20ed5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e90d);
    memoryASet16(ds, 0x20ed61, r16[ax]);
    yield* sub_1b2bb1();
    yield* sub_1b34bd();
    { pc = 0x1b31a3; break; }
  case 0x1b3222: // 0160:1b3222
    r8[al] = memoryAGet(ds, 0x20c840);
    if (!r8[al])
        { pc = 0x1b3234; break; }
    memoryASet16(ds, 0x20ed5b, 0x0000);
  case 0x1b3234: // 0160:1b3234
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b329a; break; }
    if (!(memoryAGet16(ds, 0x20edf7) & 0xffff))
        { pc = 0x1b3260; break; }
    memoryASet16(ds, 0x20edf7, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x20edf9, r16[ax]);
    r32[esp] += 4; return;
  case 0x1b3260: // 0160:1b3260
    if (memoryAGet16(ds, 0x20e82f) != 0x0001)
        { pc = 0x1b3290; break; }
    memoryASet16(ds, 0x20edf7, 0x0001);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    { pc = 0x1b329a; break; }
  case 0x1b3290: // 0160:1b3290
    memoryASet16(ds, 0x20edf9, 0x00ff);
    r32[esp] += 4; return;
  case 0x1b329a: // 0160:1b329a
    yield* sub_1b4941();
    if (memoryAGet16(ds, 0x20edf7) & 0xffff)
        { pc = 0x1b330a; break; }
    if (!memoryAGet16(ds, 0x20d7d5))
        { pc = 0x1b32c8; break; }
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    { pc = 0x1b32da; break; }
  case 0x1b32c8: // 0160:1b32c8
    memoryASet16(ds, 0x20e805, 0x0003);
    memoryASet16(ds, 0x20e809, 0x0002);
  case 0x1b32da: // 0160:1b32da
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4b3b();
    yield* sub_1b39c3();
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b3308; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    yield* sub_1b35a6();
  case 0x1b3308: // 0160:1b3308
    { pc = 0x1b3358; break; }
  case 0x1b330a: // 0160:1b330a
    memoryASet16(ds, 0x20e805, 0x0003);
    memoryASet16(ds, 0x20e809, 0x0002);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4b8c();
    yield* sub_1b3470();
    r32[esi] = 0x001ee8da;
    r8[al] = 0xc2;
    r8[bl] = 0xc6;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b3358; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    yield* sub_1b35db();
  case 0x1b3358: // 0160:1b3358
    yield* sub_1b336c();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b31a3; break; }
    // gap 14460 bytes // gap 14460 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b336c() // 0160:1b336c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20edf7) & 0xffff))
        { pc = 0x1b33a7; break; }
    r16[ax] = 0x013b;
    r16[bx] = 0x010d;
    r16[cx] = 0x0016;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    memoryASet16(ds, 0x20ceb1, 0x000c);
    yield* sub_1b38a1();
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    { pc = 0x1b340a; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b33a7: // 0160:1b33a7
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b33e6; break; }
    r16[ax] = 0x013b;
    r16[bx] = 0x010d;
    r16[cx] = 0x0016;
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1b33ca; break; }
    r16[cx]--;
  case 0x1b33ca: // 0160:1b33ca
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    memoryASet16(ds, 0x20ceb1, 0x000c);
    yield* sub_1b38a1();
    { pc = 0x1b33f4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b33e6: // 0160:1b33e6
    memoryASet16(ds, 0x20ceb1, 0x0003);
    yield* sub_1b38ea();
  case 0x1b33f4: // 0160:1b33f4
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x0002;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b3467; break; }
  case 0x1b340a: // 0160:1b340a
    memoryASet16(ds, 0x2231d2, 0x0002);
    r32[esi] = 0x002245f0;
    memoryASet16(ds, r32[esi], 0x00b8);
    memoryASet16(ds, r32[esi] + 0x2, 0x0068);
    memoryASet16(ds, r32[esi] + 0x4, 0x0060);
    memoryASet16(ds, r32[esi] + 0x6, 0x0018);
    memoryASet16(ds, r32[esi] + 0x8, 0x00b8);
    memoryASet16(ds, r32[esi] + 0xa, 0x00c0);
    memoryASet16(ds, r32[esi] + 0xc, 0x0060);
    memoryASet16(ds, r32[esi] + 0xe, 0x0018);
    r32[esi] = 0x0020ec43;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x0001;
    if (r16[bp])
        { pc = 0x1b3460; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 1);
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) & 0x0007);
  case 0x1b3460: // 0160:1b3460
    r16[bx] -= memoryAGet16(ds, r32[esi]);
    r16[cx] = 0x0001;
  case 0x1b3467: // 0160:1b3467
    r16[dx] = 0x0009;
    { pc = 0x1bd7dd; break; }
    // gap 41837 bytes // gap 41837 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3470() // 0160:1b3470 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ebx] = 0;
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b3489; break; }
    r32[ebx]++;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b3489; break; }
    r32[ebx]++;
  case 0x1b3489: // 0160:1b3489
    r32[eax] = r32[ebx];
    r32[ecx] = r32[ebx];
    r32[ecx] <<= 2;
    r32[ebx] <<= 4;
    r32[ebx] += r32[eax];
    r32[ebx] += r32[ecx];
    r32[esi] = 0x001ef11b;
    r32[esi] += r32[ebx];
    r32[ecx] = 0x00000007;
    r8[al] = 0x22;
    r16[dx] = 0x03c8;
    out8(r16[dx], r8[al]);
    r16[dx]++;
  case 0x1b34ac: // 0160:1b34ac
    r8[al] = memoryAGet(ds, r32[esi]);
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    out8(r16[dx], r8[al]);
    r32[esi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b34ac; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b34bd() // 0160:1b34bd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0001);
    { pc = 0x1b34d1; break; }
    // gap 9 bytes // gap 9 bytes
  case 0x1b34d1: // 0160:1b34d1
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5585();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b3552; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ed61);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ed61);
    memoryASet16(ds, 0x20d7f5, r16[ax]);
  case 0x1b3552: // 0160:1b3552
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ec43, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008f);
    memoryASet16(ds, 0x20ec3f, 0x0106);
    memoryASet16(ds, 0x20e97f, 0x015c);
    memoryASet(ds, 0x20e981, 0x0d);
    memoryASet(ds, 0x20ceb7, 0x0f);
    yield* sub_1b385b();
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 6504 bytes // gap 6504 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b34c8() // 0160:1b34c8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5585();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b3552; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ed61);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ed61);
    memoryASet16(ds, 0x20d7f5, r16[ax]);
  case 0x1b3552: // 0160:1b3552
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ec43, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008f);
    memoryASet16(ds, 0x20ec3f, 0x0106);
    memoryASet16(ds, 0x20e97f, 0x015c);
    memoryASet(ds, 0x20e981, 0x0d);
    memoryASet(ds, 0x20ceb7, 0x0f);
    yield* sub_1b385b();
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 6504 bytes // gap 6504 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b35a6() // 0160:1b35a6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee92c;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee93b;
    yield* sub_1b60d3();
    if (memoryAGet16(ds, 0x20d7d5))
        { pc = 0x1b6be8; break; }
    r32[esi] = 0x001ee94a;
    { pc = 0x1b60d3; break; }
    // gap 11000 bytes // gap 11000 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 2079 bytes // gap 2079 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b35db() // 0160:1b35db +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee8fb;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee90b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee91a;
    { pc = 0x1b60d3; break; }
    // gap 10961 bytes // gap 10961 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3602() // 0160:1b3602 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b39dc();
    yield* sub_1b3af9();
  case 0x1b360c: // 0160:1b360c
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b362f; break; }
    memoryASet16(ds, 0x20ed5b, memoryAGet16(ds, 0x20ed5b) + 1);
  case 0x1b362f: // 0160:1b362f
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b3641; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b3641: // 0160:1b3641
    if (memoryAGet16(ds, 0x20ee49) & 0xffff)
        { pc = 0x1b3658; break; }
    if (memoryAGet16(ds, 0x20ed5b) == 0x0018)
        { pc = 0x1b3662; break; }
    if (memoryAGet16(ds, 0x20ed5b) != 0x0018)
        { pc = 0x1b3686; break; }
  case 0x1b3658: // 0160:1b3658
    if (memoryAGet16(ds, 0x20ed5b) != 0x0003)
        { pc = 0x1b3686; break; }
  case 0x1b3662: // 0160:1b3662
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x20ed5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e90d);
    memoryASet16(ds, 0x20ed61, r16[ax]);
    yield* sub_1b2bb1();
    yield* sub_1b39d1();
    { pc = 0x1b360c; break; }
  case 0x1b3686: // 0160:1b3686
    r8[al] = memoryAGet(ds, 0x20c840);
    if (!r8[al])
        { pc = 0x1b3698; break; }
    memoryASet16(ds, 0x20ed5b, 0x0000);
  case 0x1b3698: // 0160:1b3698
    yield* sub_1b531f();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b36a9; break; }
    r32[esp] += 4; return;
  case 0x1b36a9: // 0160:1b36a9
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4b02();
    yield* sub_1b36ec();
    yield* sub_1b39c3();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b360c; break; }
    // gap 13564 bytes // gap 13564 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b36ec() // 0160:1b36ec +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b37e1; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b3791; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0002)
        { pc = 0x1b3831; break; }
    r32[edi] = 0x0020ec45;
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1b372f; break; }
    memoryASet16(ds, r32[edi], memoryAGet16(ds, r32[edi]) + 1);
    memoryASet16(ds, r32[edi], memoryAGet16(ds, r32[edi]) & 0x0003);
  case 0x1b372f: // 0160:1b372f
    r32[esi] = 0x001ef0f5;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    if (r16[ax] != 0x0003)
        { pc = 0x1b3741; break; }
    r16[ax] = 0x0001;
  case 0x1b3741: // 0160:1b3741
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = 0x0137;
    r16[cx] = 0x0005;
    r16[dx] = 0x0004;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0048;
    if (!(memoryAGet16(ds, r32[edi]) & 0xffff))
        { pc = 0x1b3787; break; }
    r16[ax] -= 0x0017;
    if (memoryAGet16(ds, r32[edi]) == 0x0001)
        { pc = 0x1b3787; break; }
    if (memoryAGet16(ds, r32[edi]) == 0x0003)
        { pc = 0x1b3787; break; }
    r16[ax] -= 0x0017;
  case 0x1b3787: // 0160:1b3787
    yield* sub_1bd7dd();
    { pc = 0x1b383f; break; }
  case 0x1b3791: // 0160:1b3791
    r32[esi] = 0x0020ec45;
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b37b9; break; }
    yield* sub_1b1c22();
    if (r8[al] > 0x0a)
        { pc = 0x1b383f; break; }
    memoryASet16(ds, r32[esi], 0x000f);
    yield* sub_1b1c22();
    r8[al] &= 0x0f;
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + r16[ax]);
  case 0x1b37b9: // 0160:1b37b9
    r16[ax] = 0x0001;
    yield* sub_1b4925();
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x000a))
        { pc = 0x1b383f; break; }
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[dx] = 0x0009;
    r16[cx] = 0x0006;
    { pc = 0x1bd7dd; break; }
  case 0x1b37e1: // 0160:1b37e1
    memoryASet16(ds, 0x2231d2, 0x0002);
    r32[esi] = 0x002245f0;
    memoryASet16(ds, r32[esi], 0x00d0);
    memoryASet16(ds, r32[esi] + 0x2, 0x0068);
    memoryASet16(ds, r32[esi] + 0x4, 0x0038);
    memoryASet16(ds, r32[esi] + 0x6, 0x0018);
    memoryASet16(ds, r32[esi] + 0x8, 0x00d0);
    memoryASet16(ds, r32[esi] + 0xa, 0x00c0);
    memoryASet16(ds, r32[esi] + 0xc, 0x0038);
    memoryASet16(ds, r32[esi] + 0xe, 0x0018);
    memoryASet16(ds, 0x20ceb1, 0x0010);
    yield* sub_1b38a1();
    { pc = 0x1b383f; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3831: // 0160:1b3831
    memoryASet16(ds, 0x20ceb1, 0x0007);
    yield* sub_1b38ea();
  case 0x1b383f: // 0160:1b383f
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x0001;
    r16[cx] += memoryAGet16(ds, 0x20e82f);
    r16[dx] = 0x0009;
    { pc = 0x1bd7dd; break; }
    // gap 40834 bytes // gap 40834 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b385b() // 0160:1b385b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bp] = 0x0010;
    r32[esi] = 0x0020ebc5;
    r32[edi] = 0x001ef0fb;
  case 0x1b3869: // 0160:1b3869
    yield* sub_1b1c22();
    r8[al] &= 0x07;
    r8[al] += memoryAGet(ds, 0x20e981);
    memoryASet16(ds, r32[esi], r16[ax]);
    yield* sub_1b1c25();
    r8[al] &= memoryAGet(ds, 0x20ceb7);
    r16[ax] += memoryAGet16(ds, 0x20e97f);
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet16(ds, r32[esi] + 0x4, r16[ax]);
    r32[esi] += 0x00000006;
    r32[edi] += 0x00000002;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b3869; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b38a1() // 0160:1b38a1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00000010;
    r32[esi] = 0x0020ebc5;
  case 0x1b38ab: // 0160:1b38ab
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) + 0x0003);
    if (signed16(memoryAGet16(ds, r32[esi] + 0x4)) < signed16(0x0280))
        { pc = 0x1b38be; break; }
    memoryASet16(ds, r32[esi] + 0x4, 0x0000);
  case 0x1b38be: // 0160:1b38be
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x4);
    if (r16s[bx] < signed16(0x00e4))
        { pc = 0x1b38e2; break; }
    if (r16[bx] > 0x0140)
        { pc = 0x1b38e2; break; }
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
  case 0x1b38e2: // 0160:1b38e2
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1b38ab; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b38ea() // 0160:1b38ea +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020ec45;
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) + 1);
    r16[cx] = 0x0001;
    yield* sub_1b3905();
    r32[esi] = 0x0020ec47;
    r16[cx] = 0x003f;
    r16[ax] = memoryAGet16(ds, 0x20ec49);
    r16[ax] &= r16[cx];
    if (r16[ax])
        { pc = 0x1b3913; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 1);
  case 0x1b3913: // 0160:1b3913
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r16[bp] = r16[cx];
    r16[cx] &= 0x000f;
    if (r16s[cx] < signed16(0x0009))
        { pc = 0x1b3930; break; }
    r16[bx] = r16[cx];
    r16[bx] -= 0x0008;
    r16[bx] <<= 1;
    r16[cx] -= r16[bx];
  case 0x1b3930: // 0160:1b3930
    r16[cx] += memoryAGet16(ds, 0x20ceb1);
    r16[ax] = 0x0177;
    r16[bp] &= 0x001f;
    if (r16s[bp] < signed16(0x0011))
        { pc = 0x1b396d; break; }
    r16[ax]--;
    if (r16[bp] == 0x0011)
        { pc = 0x1b396d; break; }
    if (r16[bp] == 0x001f)
        { pc = 0x1b396d; break; }
    r16[ax] -= 0x0008;
    if (r16s[bp] < signed16(0x0016))
        { pc = 0x1b396d; break; }
    if (r16[bp] == 0x0018)
        { pc = 0x1b3969; break; }
    if (r16[bp] > 0x001a)
        { pc = 0x1b396d; break; }
  case 0x1b3969: // 0160:1b3969
    r16[ax] -= 0x0008;
  case 0x1b396d: // 0160:1b396d
    r16[bx] = 0x010d;
    if (r16s[bp] < signed16(0x0004))
        { pc = 0x1b399f; break; }
    if (r16[bp] > 0x001c)
        { pc = 0x1b399f; break; }
    r16[bx] += 0x0008;
    if (r16s[bp] < signed16(0x0007))
        { pc = 0x1b399f; break; }
    if (r16[bp] > 0x0019)
        { pc = 0x1b399f; break; }
    r16[bx] += 0x0008;
    if (r16s[bp] < signed16(0x0009))
        { pc = 0x1b399f; break; }
    if (r16[bp] == 0x0019)
        { pc = 0x1b399f; break; }
    r16[bx]++;
  case 0x1b399f: // 0160:1b399f
    r16[dx] = 0;
    if (r16s[bp] < signed16(0x0009))
        { pc = 0x1b39be; break; }
    r16[dx] += 0x0002;
    if (r16s[bp] < signed16(0x0011))
        { pc = 0x1b39be; break; }
    r16[dx]++;
    if (r16s[bp] < signed16(0x0019))
        { pc = 0x1b39be; break; }
    r16[dx] -= 0x0002;
  case 0x1b39be: // 0160:1b39be
    { pc = 0x1bd7dd; break; }
    // gap 40474 bytes // gap 40474 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3905() // 0160:1b3905 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20ec49);
    r16[ax] &= r16[cx];
    if (r16[ax])
        { pc = 0x1b3913; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 1);
  case 0x1b3913: // 0160:1b3913
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r16[bp] = r16[cx];
    r16[cx] &= 0x000f;
    if (r16s[cx] < signed16(0x0009))
        { pc = 0x1b3930; break; }
    r16[bx] = r16[cx];
    r16[bx] -= 0x0008;
    r16[bx] <<= 1;
    r16[cx] -= r16[bx];
  case 0x1b3930: // 0160:1b3930
    r16[cx] += memoryAGet16(ds, 0x20ceb1);
    r16[ax] = 0x0177;
    r16[bp] &= 0x001f;
    if (r16s[bp] < signed16(0x0011))
        { pc = 0x1b396d; break; }
    r16[ax]--;
    if (r16[bp] == 0x0011)
        { pc = 0x1b396d; break; }
    if (r16[bp] == 0x001f)
        { pc = 0x1b396d; break; }
    r16[ax] -= 0x0008;
    if (r16s[bp] < signed16(0x0016))
        { pc = 0x1b396d; break; }
    if (r16[bp] == 0x0018)
        { pc = 0x1b3969; break; }
    if (r16[bp] > 0x001a)
        { pc = 0x1b396d; break; }
  case 0x1b3969: // 0160:1b3969
    r16[ax] -= 0x0008;
  case 0x1b396d: // 0160:1b396d
    r16[bx] = 0x010d;
    if (r16s[bp] < signed16(0x0004))
        { pc = 0x1b399f; break; }
    if (r16[bp] > 0x001c)
        { pc = 0x1b399f; break; }
    r16[bx] += 0x0008;
    if (r16s[bp] < signed16(0x0007))
        { pc = 0x1b399f; break; }
    if (r16[bp] > 0x0019)
        { pc = 0x1b399f; break; }
    r16[bx] += 0x0008;
    if (r16s[bp] < signed16(0x0009))
        { pc = 0x1b399f; break; }
    if (r16[bp] == 0x0019)
        { pc = 0x1b399f; break; }
    r16[bx]++;
  case 0x1b399f: // 0160:1b399f
    r16[dx] = 0;
    if (r16s[bp] < signed16(0x0009))
        { pc = 0x1b39be; break; }
    r16[dx] += 0x0002;
    if (r16s[bp] < signed16(0x0011))
        { pc = 0x1b39be; break; }
    r16[dx]++;
    if (r16s[bp] < signed16(0x0019))
        { pc = 0x1b39be; break; }
    r16[dx] -= 0x0002;
  case 0x1b39be: // 0160:1b39be
    { pc = 0x1bd7dd; break; }
    // gap 40474 bytes // gap 40474 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b39c3() // 0160:1b39c3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001ee884;
    r8[al] = 0xc2;
    r8[bl] = 0xc9;
    { pc = 0x1b60a7; break; }
    // gap 9942 bytes // gap 9942 bytes
  case 0x1b60a7: // 0160:1b60a7
    memoryASet16(ds, 0x20e905, 0x0002);
    { pc = 0x1b60bb; break; }
    // gap 9 bytes // gap 9 bytes
  case 0x1b60bb: // 0160:1b60bb
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[dx] = memoryAGet16(ds, 0x20eeb0);
    r16[dx] &= 0x001f;
    if (r16s[dx] >= signed16(0x0014))
        { pc = 0x1b60e3; break; }
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 1 bytes // gap 1 bytes
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b39d1() // 0160:1b39d1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0001);
    { pc = 0x1b39e5; break; }
    // gap 9 bytes // gap 9 bytes
  case 0x1b39e5: // 0160:1b39e5
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5561();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b3ac8();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b3ac8();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1b3ac8();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b3a7d; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ed61);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    memoryASet16(ds, 0x20d7f5, r16[ax]);
  case 0x1b3a7d: // 0160:1b3a7d
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e97f, 0x0154);
    memoryASet(ds, 0x20e981, 0x11);
    memoryASet(ds, 0x20ceb7, 0x1f);
    yield* sub_1b385b();
    memoryASet16(ds, 0x20ec3d, 0x008f);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 5190 bytes // gap 5190 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b39dc() // 0160:1b39dc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5561();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b3ac8();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b3ac8();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1b3ac8();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b3a7d; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ed61);
    memoryASet16(ds, 0x20e90d, r16[ax]);
    memoryASet16(ds, 0x20d7f5, r16[ax]);
  case 0x1b3a7d: // 0160:1b3a7d
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e97f, 0x0154);
    memoryASet(ds, 0x20e981, 0x11);
    memoryASet(ds, 0x20ceb7, 0x1f);
    yield* sub_1b385b();
    memoryASet16(ds, 0x20ec3d, 0x008f);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 5190 bytes // gap 5190 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3ac8() // 0160:1b3ac8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee8af;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee89f;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee8bc;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee8cc;
    { pc = 0x1b60d3; break; }
    // gap 9690 bytes // gap 9690 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3af9() // 0160:1b3af9 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    memoryASet16(ds, 0x20ee81, 0x0000);
    r8[al] = memoryAGet(ds, 0x30b071);
    memoryASet(ds, 0x20ee7f, r8[al]);
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1b3b0f() // 0160:1b3b0f +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!memoryAGet(ds, 0x30b071))
        { pc = 0x1b3b2e; break; }
    if (memoryAGet(ds, 0x20ee7f))
        { pc = 0x1b3b2e; break; }
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20ee81, r16[ax]);
    flags.zero = !(r8[al] | r8[al]);
    r32[esp] += 4; return;
  case 0x1b3b2e: // 0160:1b3b2e
    r8[al] = memoryAGet(ds, 0x30b071);
    memoryASet(ds, 0x20ee7f, r8[al]);
    r8[al] = 0;
    flags.zero = !(r8[al] | r8[al]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b3b3d() // 0160:1b3b3d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4c53();
    { pc = 0x1b3b51; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3b47: // 0160:1b3b47
    yield* sub_1b4c6f();
    yield* sub_1b3af9();
  case 0x1b3b51: // 0160:1b3b51
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (flags.zero)
        { pc = 0x1b3b74; break; }
    if (!memoryAGet16(ds, 0x22464a))
        { pc = 0x1b63c9; break; }
    { pc = 0x1b6be8; break; }
  case 0x1b3b74: // 0160:1b3b74
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b3b87; break; }
    memoryASet16(ds, 0x20ed5b, memoryAGet16(ds, 0x20ed5b) + 1);
  case 0x1b3b87: // 0160:1b3b87
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b3b99; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b3b99: // 0160:1b3b99
    if (memoryAGet16(ds, 0x20ee49) & 0xffff)
        { pc = 0x1b3bb0; break; }
    if (memoryAGet16(ds, 0x20ed5b) == 0x0018)
        { pc = 0x1b3bba; break; }
    if (memoryAGet16(ds, 0x20ed5b) != 0x0018)
        { pc = 0x1b3bf5; break; }
  case 0x1b3bb0: // 0160:1b3bb0
    if (memoryAGet16(ds, 0x20ed5b) != 0x0003)
        { pc = 0x1b3bf5; break; }
  case 0x1b3bba: // 0160:1b3bba
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x20ed5f, r16[ax]);
    yield* sub_1b2bb1();
    if (memoryAGet16(ds, 0x22464a) == 0x0001)
        { pc = 0x1b3be1; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1b3beb; break; }
    yield* sub_1b4c48();
    { pc = 0x1b3b51; break; }
  case 0x1b3be1: // 0160:1b3be1
    yield* sub_1b4c53();
    { pc = 0x1b3b51; break; }
  case 0x1b3beb: // 0160:1b3beb
    yield* sub_1b4c61();
    { pc = 0x1b3b51; break; }
  case 0x1b3bf5: // 0160:1b3bf5
    r8[al] = memoryAGet(ds, 0x20c840);
    if (!r8[al])
        { pc = 0x1b3c07; break; }
    memoryASet16(ds, 0x20ed5b, 0x0000);
  case 0x1b3c07: // 0160:1b3c07
    if (!memoryAGet16(ds, 0x22464a))
        { pc = 0x1b3c18; break; }
    yield* sub_1c6ff7();
    { pc = 0x1b3c1d; break; }
  case 0x1b3c18: // 0160:1b3c18
    yield* sub_1b531f();
  case 0x1b3c1d: // 0160:1b3c1d
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1b3c3a; break; }
    if (memoryAGet16(ds, 0x20ec41) == 0x0032)
        { pc = 0x1b3c3a; break; }
    memoryASet16(ds, 0x20ec41, memoryAGet16(ds, 0x20ec41) + 1);
  case 0x1b3c3a: // 0160:1b3c3a
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b3d5d; break; }
    if (signed16(memoryAGet16(ds, 0x22464a)) < signed16(0x0001))
        { pc = 0x1b3d09; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1b3d5c; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b3cce; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0001)
        { pc = 0x1b3d5c; break; }
    memoryASet16(ds, 0x22464a, 0x0002);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < signed16(0x0001))
        { pc = 0x1b3c8d; break; }
    memoryASet16(ds, 0x22464a, 0x0003);
  case 0x1b3c8d: // 0160:1b3c8d
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1b3d5c; break; }
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b3d5d; break; }
  case 0x1b3cce: // 0160:1b3cce
    memoryASet16(ds, 0x22464a, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
    { pc = 0x1b3d5d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3d09: // 0160:1b3d09
    if (memoryAGet16(ds, 0x20e82f) == 0x0006)
        { pc = 0x1b4316; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0007)
        { pc = 0x1b3d5c; break; }
    memoryASet16(ds, 0x22464a, 0x0001);
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00ae);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b3d5d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3d5c: // 0160:1b3d5c
    r32[esp] += 4; return;
  case 0x1b3d5d: // 0160:1b3d5d
    yield* sub_1b4941();
    if (signed16(memoryAGet16(ds, 0x22464a)) < signed16(0x0001))
        { pc = 0x1b3df2; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1b3da1; break; }
    memoryASet16(ds, 0x20e805, 0x0005);
    memoryASet16(ds, 0x20e809, 0x0004);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4a91();
    yield* sub_1b41f7();
    { pc = 0x1b3e1c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3da1: // 0160:1b3da1
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4ad8();
    if (memoryAGet16(ds, 0x22464a) != 0x0002)
        { pc = 0x1b3de8; break; }
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + 1);
    yield* sub_1b3eb2();
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) - 1);
    { pc = 0x1b3e1c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3de8: // 0160:1b3de8
    yield* sub_1b3eb2();
    { pc = 0x1b3e1c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3df2: // 0160:1b3df2
    memoryASet16(ds, 0x20e805, 0x0008);
    memoryASet16(ds, 0x20e809, 0x0007);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4a47();
    yield* sub_1b3eb2();
  case 0x1b3e1c: // 0160:1b3e1c
    r8[al] = 0xc3;
    r8[bl] = 0x0e;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r32[esi] = 0x001ee673;
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1b3e6b; break; }
    memoryASet16(ds, 0x20e905, 0x0000);
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r32[esi] = 0x001ee65b;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    if (memoryAGet16(ds, 0x22464a) == 0x0001)
        { pc = 0x1b3e6b; break; }
    r32[esi] = 0x001ef00d;
    r8[al] = 0xc2;
    r8[bl] = 0xc8;
  case 0x1b3e6b: // 0160:1b3e6b
    memoryASet16(ds, 0x20e905, 0x0002);
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b3ea3; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    if (memoryAGet16(ds, 0x22464a) != 0x0001)
        { pc = 0x1b3e9e; break; }
    yield* sub_1b4263();
    { pc = 0x1b3ea3; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3e9e: // 0160:1b3e9e
    yield* sub_1b42c5();
  case 0x1b3ea3: // 0160:1b3ea3
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b3b51; break; }
    // gap 1124 bytes // gap 1124 bytes
  case 0x1b4316: // 0160:1b4316
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b426d();
    yield* sub_1b486a();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b426d();
    yield* sub_1b486a();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    yield* sub_1b3af9();
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b4385; break; }
    memoryASet16(ds, 0x20ec3f, 0x0106);
  case 0x1b4385: // 0160:1b4385
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b43a8; break; }
    memoryASet16(ds, 0x20ed5b, memoryAGet16(ds, 0x20ed5b) + 1);
  case 0x1b43a8: // 0160:1b43a8
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b43ba; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b43ba: // 0160:1b43ba
    if (memoryAGet16(ds, 0x20ee49) & 0xffff)
        { pc = 0x1b43d1; break; }
    if (memoryAGet16(ds, 0x20ed5b) == 0x0018)
        { pc = 0x1b43db; break; }
    if (memoryAGet16(ds, 0x20ed5b) != 0x0018)
        { pc = 0x1b43fc; break; }
  case 0x1b43d1: // 0160:1b43d1
    if (memoryAGet16(ds, 0x20ed5b) != 0x0003)
        { pc = 0x1b43fc; break; }
  case 0x1b43db: // 0160:1b43db
    yield* sub_1b2bb1();
    yield* sub_1b4c6f();
    memoryASet16(ds, 0x20e831, 0x0001);
    memoryASet16(ds, 0x20e82f, 0x0006);
    { pc = 0x1b3b51; break; }
  case 0x1b43fc: // 0160:1b43fc
    r8[al] = memoryAGet(ds, 0x20c840);
    if (!r8[al])
        { pc = 0x1b440e; break; }
    memoryASet16(ds, 0x20ed5b, 0x0000);
  case 0x1b440e: // 0160:1b440e
    yield* sub_1b531f();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1b4430; break; }
    if (memoryAGet16(ds, 0x20ec41) == 0x0032)
        { pc = 0x1b4430; break; }
    memoryASet16(ds, 0x20ec41, memoryAGet16(ds, 0x20ec41) + 1);
  case 0x1b4430: // 0160:1b4430
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b465e; break; }
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1b4454; break; }
    memoryASet16(ds, 0x20e82f, 0x0006);
    r32[esp] += 4; return;
  case 0x1b4454: // 0160:1b4454
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b447b; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b44e2; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0001)
        { pc = 0x1b45d3; break; }
    { pc = 0x1b44d8; break; }
  case 0x1b447b: // 0160:1b447b
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b44be; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b44ec; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b44d8; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b4573; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b44e2; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0004)
        { pc = 0x1b45d3; break; }
  case 0x1b44be: // 0160:1b44be
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b44e2; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0002)
        { pc = 0x1b45d3; break; }
    if (signed16(memoryAGet16(ds, 0x20e82f)) < signed16(0x0002))
        { pc = 0x1b44ec; break; }
  case 0x1b44d8: // 0160:1b44d8
    yield* sub_1b63d3();
    { pc = 0x1b3b47; break; }
  case 0x1b44e2: // 0160:1b44e2
    yield* sub_1b7680();
    { pc = 0x1b3b47; break; }
  case 0x1b44ec: // 0160:1b44ec
    memoryASet32(ds, 0x30b13c, memoryAGet32(ds, 0x30b13c) + 1);
    memoryASet32(ds, 0x30b13c, memoryAGet32(ds, 0x30b13c) & 0x00000003);
    r32[eax] = memoryAGet32(ds, 0x30b13c);
    if (!r32[eax])
        { pc = 0x1b4507; break; }
    r32[eax] = 0x00000001;
  case 0x1b4507: // 0160:1b4507
    memoryASet32(ds, 0x30b140, r32[eax]);
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001ee7a8;
    r32[eax] = memoryAGet32(ds, 0x30b13c);
    if (r32[eax] == 0x00000001)
        { pc = 0x1b4549; break; }
    r32[esi] = 0x001ee7b8;
    if (r32[eax] == 0x00000002)
        { pc = 0x1b4549; break; }
    r32[esi] = 0x001ee7c8;
    if (r32[eax] == 0x00000003)
        { pc = 0x1b4549; break; }
    r32[esi] = 0x001ee7d8;
  case 0x1b4549: // 0160:1b4549
    push32(r32[esi]);
    yield* sub_1b60d3();
    r32[esi] = pop32();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b60d3();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b4385; break; }
  case 0x1b4573: // 0160:1b4573
    memoryASet32(ds, 0x30b130, memoryAGet32(ds, 0x30b130) + 1);
    memoryASet32(ds, 0x30b130, memoryAGet32(ds, 0x30b130) & 0x00000001);
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001ee819;
    r32[eax] = memoryAGet32(ds, 0x30b130);
    if (r32[eax] == 0x00000001)
        { pc = 0x1b45a9; break; }
    r32[esi] = 0x001ee827;
  case 0x1b45a9: // 0160:1b45a9
    push32(r32[esi]);
    yield* sub_1b60d3();
    r32[esi] = pop32();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b60d3();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b4385; break; }
  case 0x1b45d3: // 0160:1b45d3
    yield* sub_1b5096();
    memoryASet16(ds, 0x20ed5d, 0x0000);
    memoryASet16(ds, 0x22464a, 0x0000);
    memoryASet16(ds, 0x20ed4d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4814();
    yield* sub_1b4dc7();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b4814();
    yield* sub_1b4dc7();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
    yield* sub_1b4bb8();
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b3b51; break; }
  case 0x1b465e: // 0160:1b465e
    yield* sub_1b46ff();
    yield* sub_1b4941();
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b469b; break; }
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b47cb();
    { pc = 0x1b46d7; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b469b: // 0160:1b469b
    memoryASet16(ds, 0x20e805, 0x0005);
    memoryASet16(ds, 0x20e809, 0x0004);
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b46c4; break; }
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) + 1);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 1);
  case 0x1b46c4: // 0160:1b46c4
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4714();
  case 0x1b46d7: // 0160:1b46d7
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r32[esi] = 0x001ee65b;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b4385; break; }
    // gap 7370 bytes // gap 7370 bytes
  case 0x1b63c9: // 0160:1b63c9
    memoryASet16(ds, 0x20eead, 0x0001);
    r32[esp] += 4; return;
    // gap 2069 bytes // gap 2069 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b3b47() // 0160:1b3b47 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1b3b47: // 0160:1b3b47
    yield* sub_1b4c6f();
    yield* sub_1b3af9();
  case 0x1b3b51: // 0160:1b3b51
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (flags.zero)
        { pc = 0x1b3b74; break; }
    if (!memoryAGet16(ds, 0x22464a))
        { pc = 0x1b63c9; break; }
    { pc = 0x1b6be8; break; }
  case 0x1b3b74: // 0160:1b3b74
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b3b87; break; }
    memoryASet16(ds, 0x20ed5b, memoryAGet16(ds, 0x20ed5b) + 1);
  case 0x1b3b87: // 0160:1b3b87
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b3b99; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b3b99: // 0160:1b3b99
    if (memoryAGet16(ds, 0x20ee49) & 0xffff)
        { pc = 0x1b3bb0; break; }
    if (memoryAGet16(ds, 0x20ed5b) == 0x0018)
        { pc = 0x1b3bba; break; }
    if (memoryAGet16(ds, 0x20ed5b) != 0x0018)
        { pc = 0x1b3bf5; break; }
  case 0x1b3bb0: // 0160:1b3bb0
    if (memoryAGet16(ds, 0x20ed5b) != 0x0003)
        { pc = 0x1b3bf5; break; }
  case 0x1b3bba: // 0160:1b3bba
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x20ed5f, r16[ax]);
    yield* sub_1b2bb1();
    if (memoryAGet16(ds, 0x22464a) == 0x0001)
        { pc = 0x1b3be1; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1b3beb; break; }
    yield* sub_1b4c48();
    { pc = 0x1b3b51; break; }
  case 0x1b3be1: // 0160:1b3be1
    yield* sub_1b4c53();
    { pc = 0x1b3b51; break; }
  case 0x1b3beb: // 0160:1b3beb
    yield* sub_1b4c61();
    { pc = 0x1b3b51; break; }
  case 0x1b3bf5: // 0160:1b3bf5
    r8[al] = memoryAGet(ds, 0x20c840);
    if (!r8[al])
        { pc = 0x1b3c07; break; }
    memoryASet16(ds, 0x20ed5b, 0x0000);
  case 0x1b3c07: // 0160:1b3c07
    if (!memoryAGet16(ds, 0x22464a))
        { pc = 0x1b3c18; break; }
    yield* sub_1c6ff7();
    { pc = 0x1b3c1d; break; }
  case 0x1b3c18: // 0160:1b3c18
    yield* sub_1b531f();
  case 0x1b3c1d: // 0160:1b3c1d
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1b3c3a; break; }
    if (memoryAGet16(ds, 0x20ec41) == 0x0032)
        { pc = 0x1b3c3a; break; }
    memoryASet16(ds, 0x20ec41, memoryAGet16(ds, 0x20ec41) + 1);
  case 0x1b3c3a: // 0160:1b3c3a
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b3d5d; break; }
    if (signed16(memoryAGet16(ds, 0x22464a)) < signed16(0x0001))
        { pc = 0x1b3d09; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1b3d5c; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b3cce; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0001)
        { pc = 0x1b3d5c; break; }
    memoryASet16(ds, 0x22464a, 0x0002);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < signed16(0x0001))
        { pc = 0x1b3c8d; break; }
    memoryASet16(ds, 0x22464a, 0x0003);
  case 0x1b3c8d: // 0160:1b3c8d
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1b3d5c; break; }
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b3d5d; break; }
  case 0x1b3cce: // 0160:1b3cce
    memoryASet16(ds, 0x22464a, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
    { pc = 0x1b3d5d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3d09: // 0160:1b3d09
    if (memoryAGet16(ds, 0x20e82f) == 0x0006)
        { pc = 0x1b4316; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0007)
        { pc = 0x1b3d5c; break; }
    memoryASet16(ds, 0x22464a, 0x0001);
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00ae);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b3d5d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3d5c: // 0160:1b3d5c
    r32[esp] += 4; return;
  case 0x1b3d5d: // 0160:1b3d5d
    yield* sub_1b4941();
    if (signed16(memoryAGet16(ds, 0x22464a)) < signed16(0x0001))
        { pc = 0x1b3df2; break; }
    if (memoryAGet16(ds, 0x22464a) > 0x0001)
        { pc = 0x1b3da1; break; }
    memoryASet16(ds, 0x20e805, 0x0005);
    memoryASet16(ds, 0x20e809, 0x0004);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4a91();
    yield* sub_1b41f7();
    { pc = 0x1b3e1c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3da1: // 0160:1b3da1
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4ad8();
    if (memoryAGet16(ds, 0x22464a) != 0x0002)
        { pc = 0x1b3de8; break; }
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + 1);
    yield* sub_1b3eb2();
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) - 1);
    { pc = 0x1b3e1c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3de8: // 0160:1b3de8
    yield* sub_1b3eb2();
    { pc = 0x1b3e1c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3df2: // 0160:1b3df2
    memoryASet16(ds, 0x20e805, 0x0008);
    memoryASet16(ds, 0x20e809, 0x0007);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4a47();
    yield* sub_1b3eb2();
  case 0x1b3e1c: // 0160:1b3e1c
    r8[al] = 0xc3;
    r8[bl] = 0x0e;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r32[esi] = 0x001ee673;
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1b3e6b; break; }
    memoryASet16(ds, 0x20e905, 0x0000);
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r32[esi] = 0x001ee65b;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    if (memoryAGet16(ds, 0x22464a) == 0x0001)
        { pc = 0x1b3e6b; break; }
    r32[esi] = 0x001ef00d;
    r8[al] = 0xc2;
    r8[bl] = 0xc8;
  case 0x1b3e6b: // 0160:1b3e6b
    memoryASet16(ds, 0x20e905, 0x0002);
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b3ea3; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    if (memoryAGet16(ds, 0x22464a) != 0x0001)
        { pc = 0x1b3e9e; break; }
    yield* sub_1b4263();
    { pc = 0x1b3ea3; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b3e9e: // 0160:1b3e9e
    yield* sub_1b42c5();
  case 0x1b3ea3: // 0160:1b3ea3
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b3b51; break; }
    // gap 1124 bytes // gap 1124 bytes
  case 0x1b4316: // 0160:1b4316
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b426d();
    yield* sub_1b486a();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b426d();
    yield* sub_1b486a();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    yield* sub_1b3af9();
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b4385; break; }
    memoryASet16(ds, 0x20ec3f, 0x0106);
  case 0x1b4385: // 0160:1b4385
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b43a8; break; }
    memoryASet16(ds, 0x20ed5b, memoryAGet16(ds, 0x20ed5b) + 1);
  case 0x1b43a8: // 0160:1b43a8
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b43ba; break; }
    memoryASet16(ds, 0x20ee49, 0x0000);
  case 0x1b43ba: // 0160:1b43ba
    if (memoryAGet16(ds, 0x20ee49) & 0xffff)
        { pc = 0x1b43d1; break; }
    if (memoryAGet16(ds, 0x20ed5b) == 0x0018)
        { pc = 0x1b43db; break; }
    if (memoryAGet16(ds, 0x20ed5b) != 0x0018)
        { pc = 0x1b43fc; break; }
  case 0x1b43d1: // 0160:1b43d1
    if (memoryAGet16(ds, 0x20ed5b) != 0x0003)
        { pc = 0x1b43fc; break; }
  case 0x1b43db: // 0160:1b43db
    yield* sub_1b2bb1();
    yield* sub_1b4c6f();
    memoryASet16(ds, 0x20e831, 0x0001);
    memoryASet16(ds, 0x20e82f, 0x0006);
    { pc = 0x1b3b51; break; }
  case 0x1b43fc: // 0160:1b43fc
    r8[al] = memoryAGet(ds, 0x20c840);
    if (!r8[al])
        { pc = 0x1b440e; break; }
    memoryASet16(ds, 0x20ed5b, 0x0000);
  case 0x1b440e: // 0160:1b440e
    yield* sub_1b531f();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1b4430; break; }
    if (memoryAGet16(ds, 0x20ec41) == 0x0032)
        { pc = 0x1b4430; break; }
    memoryASet16(ds, 0x20ec41, memoryAGet16(ds, 0x20ec41) + 1);
  case 0x1b4430: // 0160:1b4430
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b465e; break; }
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1b4454; break; }
    memoryASet16(ds, 0x20e82f, 0x0006);
    r32[esp] += 4; return;
  case 0x1b4454: // 0160:1b4454
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b447b; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b44e2; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0001)
        { pc = 0x1b45d3; break; }
    { pc = 0x1b44d8; break; }
  case 0x1b447b: // 0160:1b447b
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b44be; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b44ec; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b44d8; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b4573; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b44e2; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0004)
        { pc = 0x1b45d3; break; }
  case 0x1b44be: // 0160:1b44be
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b44e2; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0002)
        { pc = 0x1b45d3; break; }
    if (signed16(memoryAGet16(ds, 0x20e82f)) < signed16(0x0002))
        { pc = 0x1b44ec; break; }
  case 0x1b44d8: // 0160:1b44d8
    yield* sub_1b63d3();
    { pc = 0x1b3b47; break; }
  case 0x1b44e2: // 0160:1b44e2
    yield* sub_1b7680();
    { pc = 0x1b3b47; break; }
  case 0x1b44ec: // 0160:1b44ec
    memoryASet32(ds, 0x30b13c, memoryAGet32(ds, 0x30b13c) + 1);
    memoryASet32(ds, 0x30b13c, memoryAGet32(ds, 0x30b13c) & 0x00000003);
    r32[eax] = memoryAGet32(ds, 0x30b13c);
    if (!r32[eax])
        { pc = 0x1b4507; break; }
    r32[eax] = 0x00000001;
  case 0x1b4507: // 0160:1b4507
    memoryASet32(ds, 0x30b140, r32[eax]);
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001ee7a8;
    r32[eax] = memoryAGet32(ds, 0x30b13c);
    if (r32[eax] == 0x00000001)
        { pc = 0x1b4549; break; }
    r32[esi] = 0x001ee7b8;
    if (r32[eax] == 0x00000002)
        { pc = 0x1b4549; break; }
    r32[esi] = 0x001ee7c8;
    if (r32[eax] == 0x00000003)
        { pc = 0x1b4549; break; }
    r32[esi] = 0x001ee7d8;
  case 0x1b4549: // 0160:1b4549
    push32(r32[esi]);
    yield* sub_1b60d3();
    r32[esi] = pop32();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b60d3();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b4385; break; }
  case 0x1b4573: // 0160:1b4573
    memoryASet32(ds, 0x30b130, memoryAGet32(ds, 0x30b130) + 1);
    memoryASet32(ds, 0x30b130, memoryAGet32(ds, 0x30b130) & 0x00000001);
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001ee819;
    r32[eax] = memoryAGet32(ds, 0x30b130);
    if (r32[eax] == 0x00000001)
        { pc = 0x1b45a9; break; }
    r32[esi] = 0x001ee827;
  case 0x1b45a9: // 0160:1b45a9
    push32(r32[esi]);
    yield* sub_1b60d3();
    r32[esi] = pop32();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b60d3();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b4385; break; }
  case 0x1b45d3: // 0160:1b45d3
    yield* sub_1b5096();
    memoryASet16(ds, 0x20ed5d, 0x0000);
    memoryASet16(ds, 0x22464a, 0x0000);
    memoryASet16(ds, 0x20ed4d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4814();
    yield* sub_1b4dc7();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b4814();
    yield* sub_1b4dc7();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
    yield* sub_1b4bb8();
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b3b51; break; }
  case 0x1b465e: // 0160:1b465e
    yield* sub_1b46ff();
    yield* sub_1b4941();
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b469b; break; }
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b47cb();
    { pc = 0x1b46d7; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b469b: // 0160:1b469b
    memoryASet16(ds, 0x20e805, 0x0005);
    memoryASet16(ds, 0x20e809, 0x0004);
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b46c4; break; }
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) + 1);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 1);
  case 0x1b46c4: // 0160:1b46c4
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b4714();
  case 0x1b46d7: // 0160:1b46d7
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r32[esi] = 0x001ee65b;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b4385; break; }
    // gap 7370 bytes // gap 7370 bytes
  case 0x1b63c9: // 0160:1b63c9
    memoryASet16(ds, 0x20eead, 0x0001);
    r32[esp] += 4; return;
    // gap 2069 bytes // gap 2069 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b3eb2() // 0160:1b3eb2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20e82f) == 0x0007)
        { pc = 0x1b41f7; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0006)
        { pc = 0x1b41f5; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0005)
        { pc = 0x1b4208; break; }
    if (signed16(memoryAGet16(ds, 0x20ec41)) < signed16(0x0006))
        { pc = 0x1b4229; break; }
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4007; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4051; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b40c3; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b4196; break; }
    r32[esi] = 0x0020ec45;
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b3f60; break; }
    yield* sub_1b1c22();
    if (r8[al] > 0x05)
        { pc = 0x1b3fa9; break; }
    yield* sub_1b1c25();
    memoryASet16(ds, r32[esi], 0x0035);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1b3f4b; break; }
    memoryASet16(ds, r32[esi], 0x0029);
  case 0x1b3f4b: // 0160:1b3f4b
    yield* sub_1b1c25();
    memoryASet16(ds, r32[esi] + 0x2, 0x0000);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1b3f60; break; }
    memoryASet16(ds, r32[esi] + 0x2, 0x0002);
  case 0x1b3f60: // 0160:1b3f60
    r16[ax] = 0x0004;
    yield* sub_1b4925();
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x000c))
        { pc = 0x1b3fa9; break; }
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r8[bl] = 0x06;
    div8(r8[bl]);
    r16[ax] &= 0x0001;
    r16[dx] += r16[ax];
    r16[cx] = r16[dx];
    r32[edi] = 0x001ef0d5;
    r16[dx] <<= 2;
    r32[edx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[edx] + 0x2);
    r16[cx] += 0x0014;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
  case 0x1b3fa9: // 0160:1b3fa9
    r32[esi] = 0x0020ec4f;
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b3fc7; break; }
    yield* sub_1b1c22();
    if (r8[al] > 0x03)
        { pc = 0x1b4002; break; }
    memoryASet16(ds, r32[esi], 0x001a);
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
  case 0x1b3fc7: // 0160:1b3fc7
    r16[ax] = 0x0004;
    yield* sub_1b4925();
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x0014))
        { pc = 0x1b4002; break; }
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = r16[bx];
    r16[bx] <<= 2;
    r32[edi] = 0x001ef0e5;
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[ebx] + 0x2);
    r16[cx] += 0x0018;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
  case 0x1b4002: // 0160:1b4002
    { pc = 0x1b4229; break; }
  case 0x1b4007: // 0160:1b4007
    r32[esi] = 0x0020ec45;
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b4025; break; }
    yield* sub_1b1c22();
    if (r8[al] > 0x0f)
        { pc = 0x1b4229; break; }
    memoryASet16(ds, r32[esi], 0x0014);
  case 0x1b4025: // 0160:1b4025
    r16[ax] = 0;
    yield* sub_1b4925();
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x000a))
        { pc = 0x1b4229; break; }
    r16[ax] = 0x0138;
    r16[bx] = 0x0120;
    r16[cx] = 0x0006;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    { pc = 0x1b4229; break; }
  case 0x1b4051: // 0160:1b4051
    r16[ax] = 0;
    r32[esi] = 0x0020ec45;
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b407f; break; }
    yield* sub_1b1c25();
    if (r8[al] > 0x0a)
        { pc = 0x1b4229; break; }
    memoryASet16(ds, r32[esi], 0x0014);
    yield* sub_1b1c25();
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1b407f; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x000a);
  case 0x1b407f: // 0160:1b407f
    r16[ax] = 0x0001;
    yield* sub_1b4925();
    if (memoryAGet16(ds, r32[esi]) != 0x0015)
        { pc = 0x1b4093; break; }
    memoryASet16(ds, r32[esi], 0x0009);
  case 0x1b4093: // 0160:1b4093
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x000a))
        { pc = 0x1b4229; break; }
    r16[ax] = 0x0140;
    r16[bx] = 0x0118;
    r16[cx] = 0x0007;
    r16[dx] = 0x0004;
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x0015))
        { pc = 0x1b40b9; break; }
    r16[ax] += 0x0008;
    r16[cx]++;
  case 0x1b40b9: // 0160:1b40b9
    yield* sub_1bd7dd();
    { pc = 0x1b4229; break; }
  case 0x1b40c3: // 0160:1b40c3
    r32[esi] = 0x0020ec45;
    yield* sub_1b1c22();
    if (r8[al] > 0x0f)
        { pc = 0x1b4103; break; }
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b4103; break; }
    memoryASet16(ds, r32[esi], 0x001e);
    yield* sub_1b1c22();
    if (r8[al] > 0x3c)
        { pc = 0x1b4103; break; }
    r8[al] &= 0x03;
    if (r8[al] == 0x03)
        { pc = 0x1b4103; break; }
    r8[al] <<= 1;
    r32[eax] &= 0x000000ff;
    if (memoryAGet16(ds, r32[esi] + r32[eax] + 0x8) & 0xffff)
        { pc = 0x1b4103; break; }
    memoryASet16(ds, r32[esi] + r32[eax] + 0x8, 0x001e);
  case 0x1b4103: // 0160:1b4103
    yield* sub_1b1c22();
    if (r8[al] > 0x02)
        { pc = 0x1b4123; break; }
    r8[al] <<= 1;
    r32[eax] &= 0x000000ff;
    if (memoryAGet16(ds, r32[esi] + r32[eax] + 0x2) & 0xffff)
        { pc = 0x1b4123; break; }
    memoryASet16(ds, r32[esi] + r32[eax] + 0x2, 0x0010);
  case 0x1b4123: // 0160:1b4123
    memoryASet32(ds, 0x20e7fd, 0x00000007);
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[edi] = 0x001ef0a9;
  case 0x1b413b: // 0160:1b413b
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1b417c; break; }
    r16[ax] = 0x0002;
    yield* sub_1b4925();
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x000b))
        { pc = 0x1b417c; break; }
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x2);
    r16[cx] = 0x0009;
    r16[cx] += memoryAGet16(ds, 0x20e887);
    r16[dx] = 0x0004;
    push32(memoryAGet32(ds, 0x20e7fd));
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    memoryASet32(ds, 0x20e7fd, pop32());
  case 0x1b417c: // 0160:1b417c
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r32[edi] += 0x00000004;
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) - 1);
    if (memoryAGet32(ds, 0x20e7fd))
        { pc = 0x1b413b; break; }
    { pc = 0x1b4229; break; }
  case 0x1b4196: // 0160:1b4196
    r32[edi] = 0x001ef0c5;
    r32[esi] = 0x0020ec45;
    if (memoryAGet16(ds, r32[esi]) & 0xffff)
        { pc = 0x1b41b9; break; }
    yield* sub_1b1c22();
    if (r8[al] > 0x03)
        { pc = 0x1b41f0; break; }
    memoryASet16(ds, r32[esi], 0x0012);
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
  case 0x1b41b9: // 0160:1b41b9
    r16[ax] = 0x0003;
    yield* sub_1b4925();
    if (signed16(memoryAGet16(ds, r32[esi])) < signed16(0x000c))
        { pc = 0x1b41f0; break; }
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 2;
    r32[edx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[edi] + r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[edx] + 0x2);
    r16[cx] = 0x0010;
    r16[cx] += memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
  case 0x1b41f0: // 0160:1b41f0
    { pc = 0x1b4229; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b41f5: // 0160:1b41f5
    { pc = 0x1b4229; break; }
  case 0x1b41f7: // 0160:1b41f7
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x001f;
    { pc = 0x1b425a; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4208: // 0160:1b4208
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x001d;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x001f;
    r16[bp] >>>= 4;
    if (!r16[bp])
        { pc = 0x1b425a; break; }
    r16[cx]++;
    { pc = 0x1b425a; break; }
  case 0x1b4229: // 0160:1b4229
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x0001;
    r16[cx] += memoryAGet16(ds, 0x20e82f);
    if (memoryAGet16(ds, 0x20e82f) != 0x0005)
        { pc = 0x1b424c; break; }
    r16[cx] = 0x001d;
    { pc = 0x1b425a; break; }
  case 0x1b424c: // 0160:1b424c
    if (memoryAGet16(ds, 0x20e82f) != 0x0006)
        { pc = 0x1b425a; break; }
    r16[cx] = 0x001c;
  case 0x1b425a: // 0160:1b425a
    r16[dx] = 0x0009;
    { pc = 0x1bd7dd; break; }
    // gap 38266 bytes // gap 38266 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b41f7() // 0160:1b41f7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x001f;
    { pc = 0x1b425a; break; }
    // gap 85 bytes // gap 85 bytes
  case 0x1b425a: // 0160:1b425a
    r16[dx] = 0x0009;
    { pc = 0x1bd7dd; break; }
    // gap 38266 bytes // gap 38266 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4263() // 0160:1b4263 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b426d();
    { pc = 0x1b4e20; break; }
    // gap 2995 bytes // gap 2995 bytes
  case 0x1b4e20: // 0160:1b4e20
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee700;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee70f;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee71d;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee725;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee72c;
    { pc = 0x1b60d3; break; }
    // gap 4728 bytes // gap 4728 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b426d() // 0160:1b426d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = 0xc3;
    r8[bl] = 0x04;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x04;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x04;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x04;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    { pc = 0x1b60e3; break; }
    // gap 7710 bytes // gap 7710 bytes
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b42c5() // 0160:1b42c5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = 0xc4;
    r8[bl] = 0x08;
    r8[cl] = 0x0c;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x88;
    r8[cl] = 0x0a;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x08;
    r8[cl] = 0x04;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x88;
    r8[cl] = 0x04;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x08;
    r8[cl] = 0x04;
    yield* sub_1b60e3();
    if (memoryAGet16(ds, 0x22464a) >= 0x0002)
        { pc = 0x1b430b; break; }
    { pc = 0x1b4dc7; break; }
  case 0x1b430b: // 0160:1b430b
    if (memoryAGet16(ds, 0x22464a) == 0x0002)
        { pc = 0x1b4e5b; break; }
    { pc = 0x1b4e8c; break; }
    // gap 2737 bytes // gap 2737 bytes
  case 0x1b4dc7: // 0160:1b4dc7
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee68b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee697;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6a3;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6af;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6bb;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6cd;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6db;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6ec;
    { pc = 0x1b60d3; break; }
    // gap 59 bytes // gap 59 bytes
  case 0x1b4e5b: // 0160:1b4e5b
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee734;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee740;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee74c;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee758;
    { pc = 0x1b60d3; break; }
  case 0x1b4e8c: // 0160:1b4e8c
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet16(ds, 0x20ee81, 0x0000);
    r32[esi] = 0x001ee76a;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee776;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee782;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee78e;
    { pc = 0x1b60d3; break; }
    // gap 4621 bytes // gap 4621 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b46ff() // 0160:1b46ff +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x001c;
    r16[dx] = 0x0009;
    { pc = 0x1bd7dd; break; }
    // gap 37065 bytes // gap 37065 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4714() // 0160:1b4714 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0063;
    if (!r16[bp])
        { pc = 0x1b4721; break; }
    r16[ax] += 0x0002;
  case 0x1b4721: // 0160:1b4721
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b4b56; break; }
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b478c; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0005)
        { pc = 0x1b47c2; break; }
    r16[ax] += 0x0048;
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b47c2; break; }
    r16[ax] -= 0x0048;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b47b0; break; }
    r16[ax] -= 0x0010;
    if (memoryAGet32(ds, 0x30b130) == 0x00000001)
        { pc = 0x1b47bd; break; }
    r16[ax] += 0x0008;
    { pc = 0x1b47bd; break; }
  case 0x1b478c: // 0160:1b478c
    r16[ax] += 0x0048;
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b47c2; break; }
    r16[ax] -= 0x0048;
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b47c2; break; }
  case 0x1b47b0: // 0160:1b47b0
    if (memoryAGet32(ds, 0x30b13c) == 0x00000001)
        { pc = 0x1b47bd; break; }
    r16[ax] += 0x0008;
  case 0x1b47bd: // 0160:1b47bd
    { pc = 0x1b4b56; break; }
  case 0x1b47c2: // 0160:1b47c2
    r16[ax] -= 0x0038;
    { pc = 0x1b4b56; break; }
    // gap 907 bytes // gap 907 bytes
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b47cb() // 0160:1b47cb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0063;
    if (!r16[bp])
        { pc = 0x1b47d8; break; }
    r16[ax] += 0x0002;
  case 0x1b47d8: // 0160:1b47d8
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0010;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0048;
    { pc = 0x1b4b56; break; }
    // gap 834 bytes // gap 834 bytes
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4814() // 0160:1b4814 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b483e; break; }
    r8[al] = 0xc4;
    r8[bl] = 0x44;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0xc4;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x44;
    r8[cl] = 0x10;
    { pc = 0x1b60e3; break; }
  case 0x1b483e: // 0160:1b483e
    r8[al] = 0xc4;
    r8[bl] = 0x04;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x04;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    { pc = 0x1b60e3; break; }
    // gap 6265 bytes // gap 6265 bytes
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b486a() // 0160:1b486a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet32(ds, 0x30b138))
        { pc = 0x1b489b; break; }
    r32[esi] = 0x001ee84e;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee85c;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee86b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee87c;
    { pc = 0x1b60d3; break; }
  case 0x1b489b: // 0160:1b489b
    r32[esi] = 0x001ee79a;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee7a8;
    r32[eax] = memoryAGet32(ds, 0x30b13c);
    if (r32[eax] == 0x00000001)
        { pc = 0x1b48cd; break; }
    r32[esi] = 0x001ee7b8;
    if (r32[eax] == 0x00000002)
        { pc = 0x1b48cd; break; }
    r32[esi] = 0x001ee7c8;
    if (r32[eax] == 0x00000003)
        { pc = 0x1b48cd; break; }
    r32[esi] = 0x001ee7d8;
  case 0x1b48cd: // 0160:1b48cd
    yield* sub_1b60d3();
    r32[esi] = 0x001ee7e8;
    yield* sub_1b60d3();
    if (!memoryAGet32(ds, 0x30b158))
        { pc = 0x1b4911; break; }
    r32[esi] = 0x001ee819;
    if (memoryAGet32(ds, 0x30b130) == 0x00000001)
        { pc = 0x1b48f8; break; }
    r32[esi] = 0x001ee827;
  case 0x1b48f8: // 0160:1b48f8
    yield* sub_1b60d3();
    r32[esi] = 0x001ee835;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee846;
    { pc = 0x1b60d3; break; }
  case 0x1b4911: // 0160:1b4911
    r32[esi] = 0x001ee7f7;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee808;
    { pc = 0x1b60d3; break; }
    // gap 6062 bytes // gap 6062 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4925() // 0160:1b4925 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = memoryAGet16(ds, 0x20e82f);
    if (r16[ax] != r16[bx])
        { pc = 0x1b4940; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1b4940; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 1);
  case 0x1b4940: // 0160:1b4940
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b4941() // 0160:1b4941 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = 0;
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b496b; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b496b; break; }
    r8[al] = 0x88;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20e831, 0x0001);
    r32[esp] += 4; return;
  case 0x1b496b: // 0160:1b496b
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1b498c; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b498c; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    r16[cx] = 0xffff;
  case 0x1b498c: // 0160:1b498c
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1b49ad; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b49ad; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    r16[cx] = 0x0001;
  case 0x1b49ad: // 0160:1b49ad
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b49ae() // 0160:1b49ae +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20ee75, r16[ax]);
    r32[eax] = pop32();
    if (!r16[cx])
        { pc = 0x1b49c8; break; }
    push32(r32[ecx]);
    yield* sub_1b4bb8();
    r32[ecx] = pop32();
  case 0x1b49c8: // 0160:1b49c8
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + r16[cx]);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < 0)
        { pc = 0x1b49eb; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (memoryAGet16(ds, 0x20e805) != r16[ax])
        { pc = 0x1b49f7; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    { pc = 0x1b49f7; break; }
  case 0x1b49eb: // 0160:1b49eb
    r16[ax] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b49f7: // 0160:1b49f7
    r16[bp] = 0x0000;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[si] = memoryAGet16(ds, 0x20eeb0);
    r16[si] &= 0x0007;
    r16[si] >>>= 2;
    if (!r16[si])
        { pc = 0x1b4a18; break; }
    r16[ax]--;
    r16[bp] = 0x0001;
  case 0x1b4a18: // 0160:1b4a18
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[si] = memoryAGet16(ds, 0x20e82f);
    r16[si] <<= 4;
    r16[bx] += r16[si];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b49c8() // 0160:1b49c8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + r16[cx]);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < 0)
        { pc = 0x1b49eb; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (memoryAGet16(ds, 0x20e805) != r16[ax])
        { pc = 0x1b49f7; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    { pc = 0x1b49f7; break; }
  case 0x1b49eb: // 0160:1b49eb
    r16[ax] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b49f7: // 0160:1b49f7
    r16[bp] = 0x0000;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[si] = memoryAGet16(ds, 0x20eeb0);
    r16[si] &= 0x0007;
    r16[si] >>>= 2;
    if (!r16[si])
        { pc = 0x1b4a18; break; }
    r16[ax]--;
    r16[bp] = 0x0001;
  case 0x1b4a18: // 0160:1b4a18
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[si] = memoryAGet16(ds, 0x20e82f);
    r16[si] <<= 4;
    r16[bx] += r16[si];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4a47() // 0160:1b4a47 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0054;
    if (!r16[bp])
        { pc = 0x1b4a54; break; }
    r16[ax] += 0x0002;
  case 0x1b4a54: // 0160:1b4a54
    if (signed16(memoryAGet16(ds, 0x20e82f)) <= signed16(0x0003))
        { pc = 0x1b4a8c; break; }
    r16[ax] += 0x0030;
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b4a8c; break; }
    r16[ax] -= 0x0020;
    if (memoryAGet16(ds, 0x20e82f) == 0x0005)
        { pc = 0x1b4a8c; break; }
    r16[ax] += 0x0018;
    if (signed16(memoryAGet16(ds, 0x20e82f)) < signed16(0x0007))
        { pc = 0x1b4a8c; break; }
    r16[ax] += 0x0018;
  case 0x1b4a8c: // 0160:1b4a8c
    { pc = 0x1b4b56; break; }
    // gap 197 bytes // gap 197 bytes
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4a91() // 0160:1b4a91 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x006b;
    if (!r16[bp])
        { pc = 0x1b4a9e; break; }
    r16[ax] += 0x0002;
  case 0x1b4a9e: // 0160:1b4a9e
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4ad3; break; }
    r16[ax] -= 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4ad3; break; }
    r16[ax] -= 0x0030;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b4ad3; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b4ad3; break; }
    r16[ax] -= 0x0008;
  case 0x1b4ad3: // 0160:1b4ad3
    { pc = 0x1b4b56; break; }
    // gap 126 bytes // gap 126 bytes
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4ad8() // 0160:1b4ad8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0054;
    if (!r16[bp])
        { pc = 0x1b4ae5; break; }
    r16[ax] += 0x0002;
  case 0x1b4ae5: // 0160:1b4ae5
    if (memoryAGet16(ds, 0x20e82f) != 0x0003)
        { pc = 0x1b4afd; break; }
    if (memoryAGet16(ds, 0x22464a) == 0x0003)
        { pc = 0x1b4afd; break; }
    r16[ax] += 0x0030;
  case 0x1b4afd: // 0160:1b4afd
    { pc = 0x1b4b56; break; }
    // gap 87 bytes // gap 87 bytes
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4b02() // 0160:1b4b02 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x005a;
    if (!r16[bp])
        { pc = 0x1b4b0f; break; }
    r16[ax] += 0x0002;
  case 0x1b4b0f: // 0160:1b4b0f
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b36; break; }
    r16[ax] += 0x0018;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b36; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b4b36; break; }
    r16[ax] -= 0x0010;
  case 0x1b4b36: // 0160:1b4b36
    { pc = 0x1b4b56; break; }
    // gap 30 bytes // gap 30 bytes
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4b3b() // 0160:1b4b3b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x006a;
    if (!r16[bp])
        { pc = 0x1b4b48; break; }
    r16[ax] += 0x0002;
  case 0x1b4b48: // 0160:1b4b48
    if (signed16(memoryAGet16(ds, 0x20e82f)) <= signed16(0x0001))
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0008;
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4b5a() // 0160:1b4b5a +long
{
    yield* sub_1bd7dd();
}
function* sub_1b4b5f() // 0160:1b4b5f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b4b5f; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
  case 0x1b4b5f: // 0160:1b4b5f
    r16[ax] += 0x0020;
    if (!r16[bp])
        { pc = 0x1b4b6c; break; }
    r16[ax] += 0x0002;
  case 0x1b4b6c: // 0160:1b4b6c
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    { pc = 0x1b4b56; break; }
    // gap 35936 bytes // gap 35936 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4b7d() // 0160:1b4b7d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b4b7d; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 30 bytes // gap 30 bytes
  case 0x1b4b7d: // 0160:1b4b7d
    r16[ax] += 0x0060;
    if (!r16[bp])
        { pc = 0x1b4b8a; break; }
    r16[ax] += 0x0002;
  case 0x1b4b8a: // 0160:1b4b8a
    { pc = 0x1b4b56; break; }
    // gap 35921 bytes // gap 35921 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4b8c() // 0160:1b4b8c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b4b8c; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 45 bytes // gap 45 bytes
  case 0x1b4b8c: // 0160:1b4b8c
    r16[ax] += 0x0072;
    if (!r16[bp])
        { pc = 0x1b4b99; break; }
    r16[ax] += 0x0002;
  case 0x1b4b99: // 0160:1b4b99
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0020;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0030;
    { pc = 0x1b4b56; break; }
    // gap 35877 bytes // gap 35877 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4bb8() // 0160:1b4bb8 +long
{
    r32[esp] -= 4;
    r32[edi] = 0x0020ec45;
    r32[ecx] = 0x00000020;
    r16[ax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosw_ESEDI(r16[ax]);
    r32[esp] += 4;
}
function* sub_1b4bc9() // 0160:1b4bc9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4eda();
    memoryASet16(ds, 0x224646, 0x0000);
    memoryASet(ds, 0x1f1cba, 0x00);
    memoryASet(ds, 0x1f1cbe, 0x00);
    if (memoryAGet16(ds, 0x224644) & 0xffff)
        { pc = 0x1b4c1e; break; }
    memoryASet32(ds, 0x1f1c48, 0x00000140);
    memoryASet32(ds, 0x1f1c4c, 0x000000e0);
    yield* sub_1a8b3c();
    r16[dx] = 0x03d4;
    r8[al] = 0x13;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x28;
    out8(r16[dx], r8[al]);
    memoryASet16(ds, 0x224644, 0x0001);
  case 0x1b4c1e: // 0160:1b4c1e
    yield* sub_1b51f4();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x22463a, 0x0000);
    memoryASet16(ds, 0x22463c, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4c48() // 0160:1b4c48 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0001);
    { pc = 0x1b4c81; break; }
    // gap 46 bytes // gap 46 bytes
  case 0x1b4c81: // 0160:1b4c81
    memoryASet16(ds, 0x20ed4d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4d22; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4cee; break; }
    yield* sub_1b4e20();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e20();
    { pc = 0x1b4d35; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4cee: // 0160:1b4cee
    if (memoryAGet16(ds, 0x22464a) == 0x0002)
        { pc = 0x1b4d0d; break; }
    yield* sub_1b4e8c();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e8c();
    { pc = 0x1b4d35; break; }
  case 0x1b4d0d: // 0160:1b4d0d
    yield* sub_1b4e5b();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e5b();
    { pc = 0x1b4d35; break; }
  case 0x1b4d22: // 0160:1b4d22
    yield* sub_1b4dc7();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4dc7();
  case 0x1b4d35: // 0160:1b4d35
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b4d5e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b4d5e: // 0160:1b4d5e
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4da2; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4d8b; break; }
    memoryASet16(ds, 0x20ec3d, 0x00ae);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4d8b: // 0160:1b4d8b
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4da2: // 0160:1b4da2
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
  case 0x1b4db4: // 0160:1b4db4
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 327 bytes // gap 327 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4c53() // 0160:1b4c53 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0002);
    { pc = 0x1b4c81; break; }
    // gap 35 bytes // gap 35 bytes
  case 0x1b4c81: // 0160:1b4c81
    memoryASet16(ds, 0x20ed4d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4d22; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4cee; break; }
    yield* sub_1b4e20();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e20();
    { pc = 0x1b4d35; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4cee: // 0160:1b4cee
    if (memoryAGet16(ds, 0x22464a) == 0x0002)
        { pc = 0x1b4d0d; break; }
    yield* sub_1b4e8c();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e8c();
    { pc = 0x1b4d35; break; }
  case 0x1b4d0d: // 0160:1b4d0d
    yield* sub_1b4e5b();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e5b();
    { pc = 0x1b4d35; break; }
  case 0x1b4d22: // 0160:1b4d22
    yield* sub_1b4dc7();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4dc7();
  case 0x1b4d35: // 0160:1b4d35
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b4d5e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b4d5e: // 0160:1b4d5e
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4da2; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4d8b; break; }
    memoryASet16(ds, 0x20ec3d, 0x00ae);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4d8b: // 0160:1b4d8b
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4da2: // 0160:1b4da2
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
  case 0x1b4db4: // 0160:1b4db4
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 327 bytes // gap 327 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4c61() // 0160:1b4c61 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0003);
    { pc = 0x1b4c81; break; }
    // gap 21 bytes // gap 21 bytes
  case 0x1b4c81: // 0160:1b4c81
    memoryASet16(ds, 0x20ed4d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4d22; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4cee; break; }
    yield* sub_1b4e20();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e20();
    { pc = 0x1b4d35; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4cee: // 0160:1b4cee
    if (memoryAGet16(ds, 0x22464a) == 0x0002)
        { pc = 0x1b4d0d; break; }
    yield* sub_1b4e8c();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e8c();
    { pc = 0x1b4d35; break; }
  case 0x1b4d0d: // 0160:1b4d0d
    yield* sub_1b4e5b();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e5b();
    { pc = 0x1b4d35; break; }
  case 0x1b4d22: // 0160:1b4d22
    yield* sub_1b4dc7();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4dc7();
  case 0x1b4d35: // 0160:1b4d35
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b4d5e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b4d5e: // 0160:1b4d5e
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4da2; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4d8b; break; }
    memoryASet16(ds, 0x20ec3d, 0x00ae);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4d8b: // 0160:1b4d8b
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4da2: // 0160:1b4da2
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
  case 0x1b4db4: // 0160:1b4db4
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 327 bytes // gap 327 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4c6f() // 0160:1b4c6f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ed5d, 0x0000);
    memoryASet16(ds, 0x22464a, 0x0000);
    memoryASet16(ds, 0x20ed4d, 0x0000);
    memoryASet16(ds, 0x20ed5b, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4d22; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4cee; break; }
    yield* sub_1b4e20();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e20();
    { pc = 0x1b4d35; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4cee: // 0160:1b4cee
    if (memoryAGet16(ds, 0x22464a) == 0x0002)
        { pc = 0x1b4d0d; break; }
    yield* sub_1b4e8c();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e8c();
    { pc = 0x1b4d35; break; }
  case 0x1b4d0d: // 0160:1b4d0d
    yield* sub_1b4e5b();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4e5b();
    { pc = 0x1b4d35; break; }
  case 0x1b4d22: // 0160:1b4d22
    yield* sub_1b4dc7();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b4dc7();
  case 0x1b4d35: // 0160:1b4d35
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed5d) & 0xffff))
        { pc = 0x1b4d5e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed5f);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b4d5e: // 0160:1b4d5e
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    if (signed16(memoryAGet16(ds, 0x20ed5d)) < signed16(0x0002))
        { pc = 0x1b4da2; break; }
    if (memoryAGet16(ds, 0x20ed5d) > 0x0002)
        { pc = 0x1b4d8b; break; }
    memoryASet16(ds, 0x20ec3d, 0x00ae);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4d8b: // 0160:1b4d8b
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    { pc = 0x1b4db4; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b4da2: // 0160:1b4da2
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
  case 0x1b4db4: // 0160:1b4db4
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4bb8();
    { pc = 0x1b4f0e; break; }
    // gap 327 bytes // gap 327 bytes
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4dc7() // 0160:1b4dc7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee68b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee697;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6a3;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6af;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6bb;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6cd;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6db;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee6ec;
    { pc = 0x1b60d3; break; }
    // gap 4787 bytes // gap 4787 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4e20() // 0160:1b4e20 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee700;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee70f;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee71d;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee725;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee72c;
    { pc = 0x1b60d3; break; }
    // gap 4728 bytes // gap 4728 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4e5b() // 0160:1b4e5b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee734;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee740;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee74c;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee758;
    { pc = 0x1b60d3; break; }
    // gap 4679 bytes // gap 4679 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4e8c() // 0160:1b4e8c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet16(ds, 0x20ee81, 0x0000);
    r32[esi] = 0x001ee76a;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee776;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee782;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee78e;
    { pc = 0x1b60d3; break; }
    // gap 4621 bytes // gap 4621 bytes
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4ec6() // 0160:1b4ec6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00000100;
    r32[eax] = 0;
    r16[dx] = 0x03c8;
    out8(r16[dx], r8[al]);
    r16[dx]++;
  case 0x1b4ed4: // 0160:1b4ed4
    out8(r16[dx], r8[al]);
    out8(r16[dx], r8[al]);
    out8(r16[dx], r8[al]);
    if (--r32[ecx])
        { pc = 0x1b4ed4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4eda() // 0160:1b4eda +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b5126();
    r32[ecx] = 0x00000010;
  case 0x1b4ee4: // 0160:1b4ee4
    push32(r32[ecx]);
    yield* sub_1a840e();
    r32[ecx] = 0x00000300;
    r32[esi] = 0x0020c88f;
  case 0x1b4ef4: // 0160:1b4ef4
    r8[al] = memoryAGet(ds, r32[esi]);
    flags.carry = r8[al] < 0x04;
    r8[al] -= 0x04;
    if (!flags.carry)
        { pc = 0x1b4efc; break; }
    r8[al] = 0;
  case 0x1b4efc: // 0160:1b4efc
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1b4ef4; break; }
    memoryASet16(ds, 0x224666, 0x0000);
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b4ee4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4edf() // 0160:1b4edf +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00000010;
  case 0x1b4ee4: // 0160:1b4ee4
    push32(r32[ecx]);
    yield* sub_1a840e();
    r32[ecx] = 0x00000300;
    r32[esi] = 0x0020c88f;
  case 0x1b4ef4: // 0160:1b4ef4
    r8[al] = memoryAGet(ds, r32[esi]);
    flags.carry = r8[al] < 0x04;
    r8[al] -= 0x04;
    if (!flags.carry)
        { pc = 0x1b4efc; break; }
    r8[al] = 0;
  case 0x1b4efc: // 0160:1b4efc
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1b4ef4; break; }
    memoryASet16(ds, 0x224666, 0x0000);
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b4ee4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b4f0e() // 0160:1b4f0e +long
{
    r32[esp] -= 4;
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4;
}
function sub_1b4f37() // 0160:1b4f37 +long
{
  var pc = 0;
  var temp_cond0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00000100;
    r32[eax] = memoryAGet16(ds, 0x224666);
    memoryASet16(ds, 0x224666, r16[cx]);
    temp_cond0 = r32[ecx] <= r32[eax];
    r32[ecx] -= r32[eax];
    if (temp_cond0)
        { pc = 0x1b4f8e; break; }
    if (memoryAGet16(ds, 0x20eeab) != 0x0001)
        { pc = 0x1b4f6a; break; }
    r32[ecx] = 0x00000010;
    memoryASet16(ds, 0x20eeab, 0x0000);
  case 0x1b4f6a: // 0160:1b4f6a
    r32[esi] = (r32[eax] + (r32[eax] * 2)) + 2148495;
    r8[bl] = r8[al];
  case 0x1b4f73: // 0160:1b4f73
    r16[dx] = 0x03c8;
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[bl]++;
    r8[al] = memoryAGet(ds, r32[esi]);
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    out8(r16[dx], r8[al]);
    r32[esi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b4f73; break; }
  case 0x1b4f8e: // 0160:1b4f8e
    r32[esp] += 4; return;
    return;
  }
}
function sub_1b4f8f() // 0160:1b4f8f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20ce91) >= 0x0010)
        { pc = 0x1b4ff6; break; }
    memoryASet16(ds, 0x20ce91, memoryAGet16(ds, 0x20ce91) + 1);
    memoryASet32(ds, 0x1f1cc4, 0x00000000);
    r32[ecx] = 0x00000100;
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
  case 0x1b4fb9: // 0160:1b4fb9
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] += 0x04;
    if (r8s[al] < signed8(memoryAGet(ds, r32[edi])))
        { pc = 0x1b4fc3; break; }
    r8[al] = memoryAGet(ds, r32[edi]);
  case 0x1b4fc3: // 0160:1b4fc3
    memoryASet(ds, r32[esi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] += 0x04;
    if (r8s[al] < signed8(memoryAGet(ds, r32[edi] + 0x1)))
        { pc = 0x1b4fd2; break; }
    r8[al] = memoryAGet(ds, r32[edi] + 0x1);
  case 0x1b4fd2: // 0160:1b4fd2
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] += 0x04;
    if (r8s[al] < signed8(memoryAGet(ds, r32[edi] + 0x2)))
        { pc = 0x1b4fe2; break; }
    r8[al] = memoryAGet(ds, r32[edi] + 0x2);
  case 0x1b4fe2: // 0160:1b4fe2
    memoryASet(ds, r32[esi] + 0x2, r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b4fb9; break; }
    memoryASet16(ds, 0x224666, 0x0000);
  case 0x1b4ff6: // 0160:1b4ff6
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b4ff7() // 0160:1b4ff7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1bd825();
    r16[ax] = memoryAGet16(ds, 0x2231d2);
    r32[eax] &= 0x0000ffff;
    r32[ecx] = r32[eax];
    r32[esi] = 0x002245e8;
    r32[eax] <<= 3;
    r32[esi] += r32[eax];
  case 0x1b5013: // 0160:1b5013
    push32(r32[ecx]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx] = r16[ax];
    r16[ax] <<= 6;
    r16[bx] <<= 4;
    r16[ax] += r16[bx];
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r16[bx] >>>= 2;
    r16[ax] += r16[bx];
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx] >>>= 2;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    push32(r32[esi]);
    r32[esi] = 0x000a9000;
    r32[esi] += r32[eax];
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b5059; break; }
    r32[edi] = 0x000a0000;
  case 0x1b5059: // 0160:1b5059
    r32[edi] += r32[eax];
    push(ds);
    es = pop();
    r32[ebx] = 0x00000050;
    r16[bx] -= r16[cx];
    r32[ecx] &= 0x0000ffff;
  case 0x1b506b: // 0160:1b506b
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b506b; break; }
    r32[esi] = pop32();
    r32[esi] -= 0x00000008;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b5085; break; }
    { pc = 0x1b5087; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5085: // 0160:1b5085
    { pc = 0x1b5013; break; }
  case 0x1b5087: // 0160:1b5087
    yield* sub_1bd849();
    memoryASet16(ds, 0x2231d2, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5096() // 0160:1b5096 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b5126();
    if (!(memoryAGet16(ds, 0x2231d2) & 0xffff))
        { pc = 0x1b50ab; break; }
    yield* sub_1b4ff7();
  case 0x1b50ab: // 0160:1b50ab
    memoryASet16(ds, 0x20eeb0, memoryAGet16(ds, 0x20eeb0) + 1);
    r16[bx] = 0x4800;
    r16[cx] = 0x4800;
    if (!memoryAGet(ds, 0x1f1cbf))
        { pc = 0x1b50da; break; }
    r16[cx] = 0;
    if (memoryAGet16(ds, 0x2231c4) & 0xffff)
        { pc = 0x1b50ef; break; }
    r16[bx] = 0;
    r16[cx] = 0x4800;
    { pc = 0x1b50ef; break; }
  case 0x1b50da: // 0160:1b50da
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b50ef; break; }
    r16[bx] = 0;
    r16[cx] = 0;
  case 0x1b50ef: // 0160:1b50ef
    memoryASet16(ds, 0x2231c4, r16[cx]);
    memoryASet16(ds, 0x1f1cb8, r16[bx]);
    yield* sub_1a840e();
    yield* sub_1b5329();
    if (!memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b511c; break; }
    yield* sub_1b5f59();
    { pc = 0x1b5121; break; }
  case 0x1b511c: // 0160:1b511c
    yield* sub_1b5f91();
  case 0x1b5121: // 0160:1b5121
    { pc = 0x1bdf30; break; }
    // gap 36362 bytes // gap 36362 bytes
  case 0x1bdf30: // 0160:1bdf30
    memoryASet(ds, 0x20c840, 0x00);
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1bdf4b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1bdf4b: // 0160:1bdf4b
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1bdf5f; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x20);
  case 0x1bdf5f: // 0160:1bdf5f
    r8[al] = memoryAGet(ds, 0x30b0ec);
    if (r8[al])
        { pc = 0x1bdf79; break; }
    r8[al] = memoryAGet(ds, 0x30b08c);
    if (!r8[al])
        { pc = 0x1bdf80; break; }
  case 0x1bdf79: // 0160:1bdf79
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1bdf80: // 0160:1bdf80
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1bdf94; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1bdf94: // 0160:1bdf94
    if (!memoryAGet(ds, 0x30b118))
        { pc = 0x1bdfa4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x01);
  case 0x1bdfa4: // 0160:1bdfa4
    if (!memoryAGet(ds, 0x30b120))
        { pc = 0x1bdfb4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x02);
  case 0x1bdfb4: // 0160:1bdfb4
    if (!memoryAGet(ds, 0x30b11d))
        { pc = 0x1bdfc4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1bdfc4: // 0160:1bdfc4
    if (!memoryAGet(ds, 0x30b11b))
        { pc = 0x1bdfd4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1bdfd4: // 0160:1bdfd4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5126() // 0160:1b5126 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x002231e8;
    r16[cx] = memoryAGet16(ds, 0x2231d0);
    r32[ecx] &= 0x0000ffff;
    if (!r32[ecx])
        { pc = 0x1b51f3; break; }
    r32[ecx] <<= 3;
    r32[esi] += r32[ecx];
    r32[ecx] >>>= 3;
  case 0x1b5146: // 0160:1b5146
    push32(r32[ecx]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    // draw sprite
    if (!r16[dx])
        { pc = 0x1b51a8; break; }
    if (r16[dx] == 0x0001)
        { pc = 0x1b519d; break; }
    if (r16[dx] == 0x0002)
        { pc = 0x1b5195; break; }
    if (r16[dx] == 0x0003)
        { pc = 0x1b518d; break; }
    if (r16[dx] == 0x0004)
        { pc = 0x1b51b0; break; }
    if (r16[dx] == 0x0005)
        { pc = 0x1b51b8; break; }
    if (r16[dx] == 0x0006)
        { pc = 0x1b51c0; break; }
    if (r16[dx] == 0x0007)
        { pc = 0x1b51c8; break; }
    if (r16[dx] == 0x0008)
        { pc = 0x1b51d0; break; }
    if (r16[dx] != 0x0008)
        { pc = 0x1b51d8; break; }
  case 0x1b518d: // 0160:1b518d
    push32(r32[esi]);
    yield* sub_1b5bf5();
    { pc = 0x1b51de; break; }
  case 0x1b5195: // 0160:1b5195
    push32(r32[esi]);
    yield* sub_1b5b7c();
    { pc = 0x1b51de; break; }
  case 0x1b519d: // 0160:1b519d
    push32(r32[esi]);
    yield* sub_1b5af4();
    { pc = 0x1b51de; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b51a8: // 0160:1b51a8
    push32(r32[esi]);
    yield* sub_1b5d9c();
    { pc = 0x1b51de; break; }
  case 0x1b51b0: // 0160:1b51b0
    push32(r32[esi]);
    yield* sub_1b5c89();
    { pc = 0x1b51de; break; }
  case 0x1b51b8: // 0160:1b51b8
    push32(r32[esi]);
    yield* sub_1bd56b();
    { pc = 0x1b51de; break; }
  case 0x1b51c0: // 0160:1b51c0
    push32(r32[esi]);
    yield* sub_1bd70e();
    { pc = 0x1b51de; break; }
  case 0x1b51c8: // 0160:1b51c8
    push32(r32[esi]);
    yield* sub_1bdb00();
    { pc = 0x1b51de; break; }
  case 0x1b51d0: // 0160:1b51d0
    push32(r32[esi]);
    yield* sub_1bd6c9();
    { pc = 0x1b51de; break; }
  case 0x1b51d8: // 0160:1b51d8
    push32(r32[esi]);
    yield* sub_1bd9e7();
  case 0x1b51de: // 0160:1b51de
    r32[esi] = pop32();
    r32[esi] -= 0x00000008;
    r32[ecx] = pop32();
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1b5146; break; }
    memoryASet16(ds, 0x2231d0, 0x0000);
  case 0x1b51f3: // 0160:1b51f3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b51f4() // 0160:1b51f4 +long
{
    r32[esp] -= 4;
    r32[edi] = 0x000a0000;
    push(ds);
    es = pop();
    r32[ecx] = 0x00004000;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    r32[esp] += 4;
}
function* sub_1b5205() // 0160:1b5205 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000060;
    r8[al] = 0xa0;
    yield* sub_1b5442();
    r32[edi] = pop32();
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b522f: // 0160:1b522f
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b523c: // 0160:1b523c
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b523c; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b522f; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b521d() // 0160:1b521d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b522f: // 0160:1b522f
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b523c: // 0160:1b523c
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b523c; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b522f; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b524f() // 0160:1b524f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x000000a0;
    r8[al] = 0;
    yield* sub_1b5442();
    r32[edi] = pop32();
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b5279: // 0160:1b5279
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b5286: // 0160:1b5286
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5295; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5295: // 0160:1b5295
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5286; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5279; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5267() // 0160:1b5267 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b5279: // 0160:1b5279
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b5286: // 0160:1b5286
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5295; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5295: // 0160:1b5295
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5286; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5279; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b52a1() // 0160:1b52a1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1aa484();
    { pc = 0x1b52ab; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b52ab: // 0160:1b52ab
    r32[edi] = 0x0020f1c4;
    r32[esi] = 0x0023f52c;
    r32[edx] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[bx]++;
    mul16(r16[bx]);
    r32[edx] <<= 16;
    r32[eax] &= 0x0000ffff;
    r32[eax] |= r32[edx];
    r32[ecx] = r32[eax];
    r32[esi] = 0x0023f5ac;
  case 0x1b52db: // 0160:1b52db
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xc0)
        { pc = 0x1b52f3; break; }
    r8[al] -= 0xc0;
    r32[esi]++;
    r8[bl] = memoryAGet(ds, r32[esi]);
  case 0x1b52e6: // 0160:1b52e6
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b52fa; break; }
    r8[al]--;
    if (r8[al])
        { pc = 0x1b52e6; break; }
    r32[esi]++;
    { pc = 0x1b52db; break; }
  case 0x1b52f3: // 0160:1b52f3
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1b52db; break; }
    r32[esi]--;
  case 0x1b52fa: // 0160:1b52fa
    r32[esi]++;
    r32[esi]++;
    r32[edi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
  case 0x1b5306: // 0160:1b5306
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5306; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b531f() // 0160:1b531f +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x224646, 0x0001);
    r32[esp] += 4;
}
function* sub_1b5329() // 0160:1b5329 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x224646) & 0xffff))
        { pc = 0x1b5421; break; }
    r8[al] = 0xc0;
    r32[edx] = 0x0020cb8f;
    if (memoryAGet16(ds, 0x20ce91) < 0x0010)
        { pc = 0x1b5352; break; }
    r32[edx] = 0x0020c88f;
  case 0x1b5352: // 0160:1b5352
    r32[edi] = r32[edx] + 576;
    r16[bp] = 0x0008;
  case 0x1b535c: // 0160:1b535c
    push32(r32[ebp]);
    r32[esi] = 0x001ed284;
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] <<= 3;
    r16[bx] += r16[bp];
    r16[bx] &= 0x003e;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    r16[bx] >>>= 5;
    r32[ecx] = 0x00000004;
  case 0x1b5383: // 0160:1b5383
    r32[esi] = r32[edx] + 573;
    if (r16s[bx] >= r16s[cx])
        { pc = 0x1b5394; break; }
    r32[esi] = r32[edx] + 570;
  case 0x1b5394: // 0160:1b5394
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5383; break; }
    r32[ebp] = pop32();
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b535c; break; }
    r16[bp] = 0x0008;
  case 0x1b53b2: // 0160:1b53b2
    push32(r32[ebp]);
    r32[esi] = 0x001ed284;
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] <<= 3;
    r16[bx] += r16[bp];
    r16[bx] &= 0x003e;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    r16[bx] >>>= 5;
    r32[ecx] = 0x00000004;
  case 0x1b53d9: // 0160:1b53d9
    r32[esi] = r32[edx] + 570;
    if (r16s[bx] >= r16s[cx])
        { pc = 0x1b53ea; break; }
    r32[esi] = r32[edx] + 573;
  case 0x1b53ea: // 0160:1b53ea
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b53d9; break; }
    r32[ebp] = pop32();
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b53b2; break; }
    memoryASet16(ds, 0x224646, 0x0000);
    if (memoryAGet16(ds, 0x224666) <= 0x00c0)
        { pc = 0x1b5421; break; }
    memoryASet16(ds, 0x224666, 0x00c0);
  case 0x1b5421: // 0160:1b5421
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5442() // 0160:1b5442 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x0020c88f;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[ebp] = r32[edx];
    r32[edx] += r32[edx];
    r32[edx] += r32[ebp];
    r32[esi] += r32[edx];
    r32[edi] += r32[edx];
  case 0x1b5455: // 0160:1b5455
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5455; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5477() // 0160:1b5477 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed6a8;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed752;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed7a4;
    { pc = 0x1b5a2d; break; }
    // gap 1406 bytes // gap 1406 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b54af() // 0160:1b54af +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed658;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed66a;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed67c;
    { pc = 0x1b5a2d; break; }
    // gap 1350 bytes // gap 1350 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b54e7() // 0160:1b54e7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed696;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed66a;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed67c;
    { pc = 0x1b5a2d; break; }
    // gap 1294 bytes // gap 1294 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b551f() // 0160:1b551f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed658;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed66a;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed67c;
    yield* sub_1b5a2d();
    r32[esi] = 0x001edd70;
    { pc = 0x1b5a2d; break; }
    // gap 1228 bytes // gap 1228 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5561() // 0160:1b5561 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed586;
    { pc = 0x1b5a2d; break; }
    // gap 1192 bytes // gap 1192 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5585() // 0160:1b5585 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed7c6;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed7e0;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed7f2;
    yield* sub_1b5a3a();
    r32[esi] = 0x001ed7fa;
    { pc = 0x1b5a2d; break; }
    // gap 1126 bytes // gap 1126 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b55c7() // 0160:1b55c7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001ed814;
    yield* sub_1b5a2d();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001ed876;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed890;
    yield* sub_1b5a3a();
    { pc = 0x1b5a1d; break; }
    // gap 1043 bytes // gap 1043 bytes
  case 0x1b5a1d: // 0160:1b5a1d
    memoryASet32(ds, 0x2231e4, r32[ebx]);
    r32[esi] = 0x001ed8f4;
    { pc = 0x1b5a2d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b560a() // 0160:1b560a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001eda5e;
    yield* sub_1b5a2d();
    yield* sub_1b5a1d();
    r32[esi] = 0x001edb76;
    { pc = 0x1b5a2d; break; }
    // gap 1002 bytes // gap 1002 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5643() // 0160:1b5643 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001edaf8;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed890;
    yield* sub_1b5a2d();
    yield* sub_1b5a1d();
    r32[esi] = 0x001edb52;
    yield* sub_1b5a3a();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    r32[ecx] &= 0x0000ffff;
  case 0x1b5693: // 0160:1b5693
    push32(r32[ecx]);
    r32[esi] = 0x001ed876;
    yield* sub_1b5a3a();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b5693; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b56a2() // 0160:1b56a2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001edb9a;
    yield* sub_1b5a2d();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001ed876;
    yield* sub_1b5a2d();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    r32[esi] = 0x001edb88;
    { pc = 0x1b5a2d; break; }
    // gap 819 bytes // gap 819 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b56fa() // 0160:1b56fa +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001edbec;
    yield* sub_1b5a2d();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001ed876;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed890;
    yield* sub_1b5a3a();
    yield* sub_1b5a1d();
    r32[esi] = 0x001edbfe;
    { pc = 0x1b5a2d; break; }
    // gap 742 bytes // gap 742 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5747() // 0160:1b5747 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001eda56;
    yield* sub_1b5a2d();
    r32[esi] = 0x001edccc;
    yield* sub_1b5a2d();
    yield* sub_1b5a1d();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001ed876;
    yield* sub_1b5a3a();
    r32[esi] = 0x001ed890;
    yield* sub_1b5a3a();
    r32[esi] = 0x001edc90;
    yield* sub_1b5a3a();
    memoryASet32(ds, 0x2231ec, r32[ebx]);
    r32[esi] = 0x001edcb2;
    { pc = 0x1b5a3a; break; }
    // gap 652 bytes // gap 652 bytes
  case 0x1b5a3a: // 0160:1b5a3a
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b57ae() // 0160:1b57ae +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001eda56;
    yield* sub_1b5a2d();
    yield* sub_1b5a1d();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001ed876;
    yield* sub_1b5a3a();
    r32[esi] = 0x001ed890;
    yield* sub_1b5a3a();
    r32[esi] = 0x001ed67c;
    { pc = 0x1b5a2d; break; }
    // gap 562 bytes // gap 562 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b57fb() // 0160:1b57fb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001eda66;
    yield* sub_1b5a2d();
    yield* sub_1b5a1d();
    r32[esi] = 0x001ed8c2;
    yield* sub_1b5a3a();
    r32[esi] = 0x001edcde;
    { pc = 0x1b5a2d; break; }
    // gap 495 bytes // gap 495 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b583e() // 0160:1b583e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231e0;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002239f0;
    r32[ebx] = 0x0028890c;
    r32[esi] = 0x001ed2c4;
    yield* sub_1b5a2d();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    if (!(memoryAGet16(ds, 0x20eca9) & 0xffff))
        { pc = 0x1b5891; break; }
    r32[esi] = 0x001edeea;
    { pc = 0x1b5a2d; break; }
  case 0x1b5891: // 0160:1b5891
    r32[esi] = 0x001edf1c;
    { pc = 0x1b5a2d; break; }
    // gap 402 bytes // gap 402 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b589b() // 0160:1b589b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231e0;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002239f0;
    r32[ebx] = 0x0028890c;
    r32[esi] = 0x001ed2c4;
    yield* sub_1b5a2d();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001edeea;
    yield* sub_1b5a2d();
    memoryASet32(ds, 0x20ee67, r32[ebx]);
    r32[esi] = 0x001edd78;
    { pc = 0x1b5a2d; break; }
    // gap 314 bytes // gap 314 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b58f3() // 0160:1b58f3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231e0;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002239f0;
    r32[ebx] = 0x0028890c;
    r32[esi] = 0x001ed2c4;
    yield* sub_1b5a2d();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001edfe4;
    yield* sub_1b5a3a();
    memoryASet32(ds, 0x2231e8, r32[ebx]);
    r32[esi] = 0x001eda5e;
    yield* sub_1b5a2d();
    r32[esi] = 0x001ed890;
    yield* sub_1b5a3a();
    r32[esi] = 0x001ed8ec;
    memoryASet32(ds, 0x2231e4, r32[ebx]);
    yield* sub_1b5a3a();
    r32[esi] = 0x001edb64;
    { pc = 0x1b5a3a; break; }
    // gap 203 bytes // gap 203 bytes
  case 0x1b5a3a: // 0160:1b5a3a
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b596f() // 0160:1b596f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    yield* sub_1b5a1d();
    r32[esi] = 0x001edf52;
    { pc = 0x1b5a2d; break; }
    // gap 149 bytes // gap 149 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5998() // 0160:1b5998 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001edb52;
    { pc = 0x1b5a2d; break; }
    // gap 116 bytes // gap 116 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b59bc() // 0160:1b59bc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20eca9, 0x0000);
    yield* sub_1b583e();
    r32[esi] = 0x001ee07e;
    { pc = 0x1b5a2d; break; }
    // gap 92 bytes // gap 92 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b59d4() // 0160:1b59d4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x001eccf9;
    memoryASet32(ds, 0x20ee05, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r32[esi] = 0x001ee0b0;
    r16[ax] <<= 1;
    r16[dx] = r16[ax];
    r16[ax] <<= 2;
    r16[ax] += r16[dx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet32(ds, 0x20ee09, r32[esi]);
    r32[esi] = 0x0020ee05;
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1b5a18; break; }
    { pc = 0x1b5a2d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5a18: // 0160:1b5a18
    { pc = 0x1b5a3a; break; }
    // gap 19 bytes // gap 19 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
  case 0x1b5a3a: // 0160:1b5a3a
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5a1d() // 0160:1b5a1d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x2231e4, r32[ebx]);
    r32[esi] = 0x001ed8f4;
    { pc = 0x1b5a2d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5a2d() // 0160:1b5a2d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5a3a() // 0160:1b5a3a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b5af4() // 0160:1b5af4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x2231d8, r32[eax]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[esi] += memoryAGet32(ds, 0x2231d8);
    r32[esi] -= 0x00000004;
    r32[edi] = 0x002915ac;
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[ecx] = 0;
    r32[ebx] = 0;
    r32[ebp] = memoryAGet32(ds, 0x2231d8);
    r32[ebp] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x224636);
  case 0x1b5b4b: // 0160:1b5b4b
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5b52: // 0160:1b5b52
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet(ds, r32[edi] + 0x2, r8[ah]);
    memoryASet(ds, r32[edi] + 0x3, r8[al]);
    r32[eax] >>>= 16;
    memoryASet(ds, r32[edi], r8[ah]);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r32[esi] -= 0x00000004;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5b52; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5b4b; break; }
    r32[ebx] = pop32();
    r32[ecx] = pop32();
    r32[esi] = 0x002915ac;
    { pc = 0x1b5dcb; break; }
    // gap 591 bytes // gap 591 bytes
  case 0x1b5dcb: // 0160:1b5dcb
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5b7c() // 0160:1b5b7c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x2231d8, r32[eax]);
    r16[dx] = r16[ax];
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    mul16(r16[dx]);
    r32[esi] += r32[eax];
    r32[esi] -= memoryAGet32(ds, 0x2231d8);
    r32[edi] = 0x002915ac;
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[ebx] = 0;
    r32[ecx] = 0;
    push(ds);
    es = pop();
    r32[ebp] = memoryAGet32(ds, 0x2231d8);
    r32[ebp] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x224636);
  case 0x1b5bda: // 0160:1b5bda
    r16[cx] = memoryAGet16(ds, 0x224634);
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] -= r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5bda; break; }
    r32[ebx] = pop32();
    r32[ecx] = pop32();
    r32[esi] = 0x002915ac;
    { pc = 0x1b5dcb; break; }
    // gap 470 bytes // gap 470 bytes
  case 0x1b5dcb: // 0160:1b5dcb
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5bf5() // 0160:1b5bf5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b5bf5; break; }
  case 0x1b5bb6: // 0160:1b5bb6
    r32[esi] += r32[eax];
    r32[esi] -= memoryAGet32(ds, 0x2231d8);
    r32[edi] = 0x002915ac;
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[ebx] = 0;
    r32[ecx] = 0;
    push(ds);
    es = pop();
    r32[ebp] = memoryAGet32(ds, 0x2231d8);
    r32[ebp] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x224636);
  case 0x1b5bda: // 0160:1b5bda
    r16[cx] = memoryAGet16(ds, 0x224634);
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] -= r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5bda; break; }
    r32[ebx] = pop32();
    r32[ecx] = pop32();
    r32[esi] = 0x002915ac;
    { pc = 0x1b5dcb; break; }
  case 0x1b5bf5: // 0160:1b5bf5
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x2231d8, r32[eax]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[esi] += memoryAGet32(ds, 0x2231d8);
    r32[esi] -= 0x00000004;
    r32[edi] = 0x00293cbc;
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[ecx] = 0;
    r32[ebx] = 0;
    r32[ebp] = memoryAGet32(ds, 0x2231d8);
    r32[ebp] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x224636);
  case 0x1b5c4c: // 0160:1b5c4c
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5c53: // 0160:1b5c53
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet(ds, r32[edi] + 0x2, r8[ah]);
    memoryASet(ds, r32[edi] + 0x3, r8[al]);
    r32[eax] >>>= 16;
    memoryASet(ds, r32[edi], r8[ah]);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r32[esi] -= 0x00000004;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5c53; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5c4c; break; }
    r32[ebx] = pop32();
    r32[ecx] = pop32();
    r32[esi] = 0x00293cbc;
    r32[eax] = memoryAGet32(ds, 0x2231d8);
    mul16(memoryAGet16(ds, 0x224636));
    { pc = 0x1b5bb6; break; }
    // gap 322 bytes // gap 322 bytes
  case 0x1b5dcb: // 0160:1b5dcb
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5c89() // 0160:1b5c89 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5ce0; break; }
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x224640) & 0xffff))
        { pc = 0x1b5ce0; break; }
    r32[edi] = 0x000a9000;
  case 0x1b5ce0: // 0160:1b5ce0
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5d3b: // 0160:1b5d3b
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5d52: // 0160:1b5d52
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5d59: // 0160:1b5d59
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5d68; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5d68: // 0160:1b5d68
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5d59; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5d52; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5d95; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5d3b; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5d3b; break; }
  case 0x1b5d95: // 0160:1b5d95
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5d9c() // 0160:1b5d9c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5ec4() // 0160:1b5ec4 +long
{
    r32[esp] -= 4;
    push32(r32[edi]);
    r16[ax] = memoryAGet16(ds, 0x22463a);
    r16[ax] <<= 3;
    r32[edi] = 0x00223df0;
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    memoryASet16(ds, r32[edi], r16[bx]);
    memoryASet16(ds, r32[edi] + 0x2, r16[cx]);
    memoryASet16(ds, 0x224634, memoryAGet16(ds, 0x224634) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x224634);
    memoryASet16(ds, r32[edi] + 0x4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x224636);
    memoryASet16(ds, r32[edi] + 0x6, r16[ax]);
    r32[edi] = pop32();
    memoryASet16(ds, 0x22463a, memoryAGet16(ds, 0x22463a) + 1);
    memoryASet16(ds, 0x224634, memoryAGet16(ds, 0x224634) - 0x0001);
    r32[esp] += 4;
}
function* sub_1b5f0f() // 0160:1b5f0f +long
{
    r32[esp] -= 4;
    push32(r32[edi]);
    r16[ax] = memoryAGet16(ds, 0x22463c);
    r16[ax] <<= 3;
    r32[edi] = 0x002241f0;
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    memoryASet16(ds, r32[edi], r16[bx]);
    memoryASet16(ds, r32[edi] + 0x2, r16[cx]);
    memoryASet16(ds, 0x224634, memoryAGet16(ds, 0x224634) + 1);
    r16[ax] = memoryAGet16(ds, 0x224634);
    memoryASet16(ds, r32[edi] + 0x4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x224636);
    memoryASet16(ds, r32[edi] + 0x6, r16[ax]);
    r32[edi] = pop32();
    memoryASet16(ds, 0x22463c, memoryAGet16(ds, 0x22463c) + 1);
    memoryASet16(ds, 0x224634, memoryAGet16(ds, 0x224634) - 0x0001);
    r32[esp] += 4;
}
function* sub_1b5f59() // 0160:1b5f59 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x22463a);
    if (!r16[ax])
        { pc = 0x1b5f8f; break; }
    r32[ebx] = 0x00223de8;
    memoryASet32(ds, 0x20ceeb, 0x000a9000);
    memoryASet32(ds, 0x20ceef, 0x000a0000);
    yield* sub_1b5fc9();
    memoryASet16(ds, 0x22463a, 0x0000);
  case 0x1b5f8f: // 0160:1b5f8f
    flags.interrupts = 1;
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5f91() // 0160:1b5f91 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x22463c);
    if (!r16[ax])
        { pc = 0x1b5fc7; break; }
    r32[ebx] = 0x002241e8;
    memoryASet32(ds, 0x20ceeb, 0x000a9000);
    memoryASet32(ds, 0x20ceef, 0x000a4800);
    yield* sub_1b5fc9();
    memoryASet16(ds, 0x22463c, 0x0000);
  case 0x1b5fc7: // 0160:1b5fc7
    flags.interrupts = 1;
    r32[esp] += 4;
    return;
  }
}
function* sub_1b5fc9() // 0160:1b5fc9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1bd825();
    memoryASet32(ds, 0x2246c8, r32[ebx]);
    r32[eax] &= 0x0000ffff;
    r32[ecx] = r32[eax];
  case 0x1b5fdb: // 0160:1b5fdb
    push32(r32[ecx]);
    r32[ebx] = memoryAGet32(ds, 0x2246c8);
    r32[edx] = r32[ecx];
    r32[edx] <<= 3;
    r16[bp] = memoryAGet16(ds, r32[ebx] + r32[edx]);
    memoryASet16(ds, 0x2231cc, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[ebx] + r32[edx] + 0x2);
    memoryASet16(ds, 0x2231ce, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[ebx] + r32[edx] + 0x4);
    memoryASet16(ds, 0x224634, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[ebx] + r32[edx] + 0x6);
    memoryASet16(ds, 0x224636, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x2231ce);
    r16[bx] = r16[ax];
    r16[ax] <<= 6;
    r16[bx] <<= 4;
    r16[ax] += r16[bx];
    r16[bx] = memoryAGet16(ds, 0x2231cc);
    r16[bx] >>>= 2;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] = r32[eax];
    r32[esi] += memoryAGet32(ds, 0x20ceeb);
    r32[edi] = r32[eax];
    r32[edi] += memoryAGet32(ds, 0x20ceef);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    r16[dx] = memoryAGet16(ds, 0x224636);
    r16[bp] = memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
  case 0x1b6069: // 0160:1b6069
    r16[cx] = r16[bp];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] += r32[ebx];
    r32[esi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b6069; break; }
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b607e; break; }
    { pc = 0x1bd849; break; }
  case 0x1b607e: // 0160:1b607e
    { pc = 0x1b5fdb; break; }
    // gap 30662 bytes // gap 30662 bytes
  case 0x1bd849: // 0160:1bd849
    push32(r32[edx]);
    push32(r32[eax]);
    r16[dx] = 0x03ce;
    r16[ax] = memoryAGet16(ds, 0x22463e);
    r8[ah] = r8[al];
    r8[al] = 0x05;
    out16(r16[dx], r16[ax]);
    r32[eax] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b6083() // 0160:1b6083 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b6083; break; }
  case 0x1b5a2d: // 0160:1b5a2d
    r32[edx] = memoryAGet32(ds, r32[esi]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    yield* sub_1b52a1();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
  case 0x1b5a3d: // 0160:1b5a3d
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b5af3; break; }
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[ebp] = r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] <<= 3;
    r32[ecx] = r32[eax];
    r32[eax] <<= 8;
    r32[ecx] <<= 6;
    r32[eax] += r32[ecx];
    r32[ebp] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231c8, r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] <<= 3;
    memoryASet16(ds, 0x2231ca, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20ceef);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    push32(r32[esi]);
    r32[esi] = 0x0020f1c4;
    r32[esi] += r32[ebp];
    r32[ecx] = 0;
    r32[ebp] = 0x00000140;
    r16[bp] -= memoryAGet16(ds, 0x2231c8);
    r16[dx] = memoryAGet16(ds, 0x2231ca);
  case 0x1b5ab9: // 0160:1b5ab9
    r16[cx] = memoryAGet16(ds, 0x2231c8);
    r16[cx] >>>= 2;
  case 0x1b5ac4: // 0160:1b5ac4
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1b5ac4; break; }
    r32[esi] += r32[ebp];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b5ab9; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x2231c8);
    mul16(memoryAGet16(ds, 0x2231ca));
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) + r32[eax]);
    r32[esi] = pop32();
    { pc = 0x1b5a3d; break; }
  case 0x1b5af3: // 0160:1b5af3
    r32[esp] += 4; return;
    // gap 1423 bytes // gap 1423 bytes
  case 0x1b6083: // 0160:1b6083
    r32[eax] = 0x002231e0;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002239f0;
    r32[ebx] = 0x0028890c;
    r32[esi] = 0x001ed2cc;
    { pc = 0x1b5a2d; break; }
    return;
  }
}
function* sub_1b60a7() // 0160:1b60a7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    { pc = 0x1b60bb; break; }
    // gap 9 bytes // gap 9 bytes
  case 0x1b60bb: // 0160:1b60bb
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[dx] = memoryAGet16(ds, 0x20eeb0);
    r16[dx] &= 0x001f;
    if (r16s[dx] >= signed16(0x0014))
        { pc = 0x1b60e3; break; }
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 1 bytes // gap 1 bytes
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b60d3() // 0160:1b60d3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b60e3() // 0160:1b60e3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b60f2() // 0160:1b60f2 +long
{
    r32[esp] -= 4;
    r32[edi] = 0x0020e9c5;
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet(ds, r32[edi] + 0x1, r8[bl]);
    memoryASet(ds, r32[edi] + 0x2, 0xf0);
    memoryASet(ds, r32[edi] + 0x3, r8[cl]);
    r32[edi] += 0x00000004;
    r32[ecx] &= 0x000000ff;
    r8[al] = 0xff;
    memoryASet(ds, r32[edi], r8[al]);
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    r32[esp] += 4;
}
function* sub_1b6113() // 0160:1b6113 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x0020e9c5;
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[ecx] = 0;
    r8[cl] = memoryAGet(ds, r32[edi] + 0x3);
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000004;
    if (memoryAGet16(ds, 0x20e905) != 0x0002)
        { pc = 0x1b61b6; break; }
  case 0x1b6135: // 0160:1b6135
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[al] != 0x20)
        { pc = 0x1b6147; break; }
    r8[al] = 0xff;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6147: // 0160:1b6147
    if (r8s[al] < signed8(0x30))
        { pc = 0x1b6171; break; }
    if (r8s[al] < signed8(0x3a))
        { pc = 0x1b6168; break; }
    if (r8s[al] < signed8(0x41))
        { pc = 0x1b6171; break; }
    r8[al] -= 0x41;
    r8[al] += 0x29;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6168: // 0160:1b6168
    r8[al] -= 0x30;
    r8[al] += 0x43;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6171: // 0160:1b6171
    if (r8[al] != 0x2e)
        { pc = 0x1b6180; break; }
    r8[al] = 0x4d;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6180: // 0160:1b6180
    if (r8[al] != 0x2d)
        { pc = 0x1b618f; break; }
    r8[al] = 0x4e;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b618f: // 0160:1b618f
    if (r8[al] != 0x3a)
        { pc = 0x1b619e; break; }
    r8[al] = 0x4f;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b619e: // 0160:1b619e
    if (r8[al] != 0x21)
        { pc = 0x1b61ad; break; }
    r8[al] = 0x50;
    { pc = 0x1b61af; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b61ad: // 0160:1b61ad
    r8[al] = 0x51;
  case 0x1b61af: // 0160:1b61af
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1b6135; break; }
    r32[esp] += 4; return;
  case 0x1b61b6: // 0160:1b61b6
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[al] == 0x5b)
        { pc = 0x1b6250; break; }
    if (r8[al] == 0x5d)
        { pc = 0x1b6254; break; }
    if (r8[al] == 0x3b)
        { pc = 0x1b6258; break; }
    if (r8[al] == 0x40)
        { pc = 0x1b625c; break; }
    if (r8[al] != 0x20)
        { pc = 0x1b61e8; break; }
    r8[al] = 0xff;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b61e8: // 0160:1b61e8
    if (r8s[al] < signed8(0x30))
        { pc = 0x1b6210; break; }
    if (r8s[al] < signed8(0x3a))
        { pc = 0x1b6207; break; }
    if (r8s[al] < signed8(0x41))
        { pc = 0x1b6210; break; }
    r8[al] -= 0x41;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6207: // 0160:1b6207
    r8[al] -= 0x30;
    r8[al] += 0x1a;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6210: // 0160:1b6210
    if (r8[al] != 0x2e)
        { pc = 0x1b621f; break; }
    r8[al] = 0x24;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b621f: // 0160:1b621f
    if (r8[al] != 0x16)
        { pc = 0x1b622e; break; }
    r8[al] = 0x25;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b622e: // 0160:1b622e
    if (r8[al] != 0x3a)
        { pc = 0x1b623d; break; }
    r8[al] = 0x26;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b623d: // 0160:1b623d
    if (r8[al] != 0x21)
        { pc = 0x1b624c; break; }
    r8[al] = 0x27;
    { pc = 0x1b625e; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b624c: // 0160:1b624c
    r8[al] = 0x28;
    { pc = 0x1b625e; break; }
  case 0x1b6250: // 0160:1b6250
    r8[al] = 0x52;
    { pc = 0x1b625e; break; }
  case 0x1b6254: // 0160:1b6254
    r8[al] = 0x53;
    { pc = 0x1b625e; break; }
  case 0x1b6258: // 0160:1b6258
    r8[al] = 0x54;
    { pc = 0x1b625e; break; }
  case 0x1b625c: // 0160:1b625c
    r8[al] = 0x55;
  case 0x1b625e: // 0160:1b625e
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1b61b6; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b6269() // 0160:1b6269 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b63d3() // 0160:1b63d3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b63d3; break; }
  case 0x1b2d91: // 0160:1b2d91
    r32[edx] = 0x001ed08d;
    r32[eax] = 0x00003d02;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0022479c;
    r32[ecx] = 0x00000410;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    // gap 393 bytes // gap 393 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 13373 bytes // gap 13373 bytes
  case 0x1b63d3: // 0160:1b63d3
    yield* sub_1b191a();
    r16[ax] = memoryAGet16(ds, 0x1f1ccc);
    push32(r32[eax]);
    memoryASet16(ds, 0x1f1ccc, 0x0000);
    yield* sub_1b6427();
    r32[eax] = pop32();
    memoryASet16(ds, 0x1f1ccc, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    memoryASet16(ds, 0x224ba4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee55);
    memoryASet16(ds, 0x224ba6, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee77);
    memoryASet16(ds, 0x224baa, r16[ax]);
    r8[al] = memoryAGet(ds, 0x1f1cbf);
    memoryASet(ds, 0x224ba8, r8[al]);
    { pc = 0x1b2d91; break; }
    return;
  }
}
function* sub_1b6427() // 0160:1b6427 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b734c();
    yield* sub_1aff53();
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5998();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b65e6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b65e6();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d81d;
    r16[ax] = memoryAGet16(ds, r32[esi]);
  case 0x1b6496: // 0160:1b6496
    r32[esi] -= 0x00000004;
    if (r16[ax] != memoryAGet16(ds, r32[esi]))
        { pc = 0x1b64a0; break; }
    if (--r32[ecx])
        { pc = 0x1b6496; break; }
  case 0x1b64a0: // 0160:1b64a0
    memoryASet16(ds, 0x20e82f, r16[cx]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec3d, 0x00a6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b64d1: // 0160:1b64d1
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0005);
    memoryASet16(ds, 0x20e809, 0x0004);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b66e5();
    r32[esi] = 0x001ef5b3;
    r8[al] = 0xc2;
    r8[bl] = 0xc8;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1b652a; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b64d1; break; }
  case 0x1b652a: // 0160:1b652a
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (!r16[ax])
        { pc = 0x1b65c7; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b65a8; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b6589; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1b656a; break; }
    memoryASet16(ds, 0x20ee53, 0x00e0);
    memoryASet16(ds, 0x20ee55, 0x009c);
    r16[ax] = memoryAGet16(ds, 0x20d81d);
    memoryASet16(ds, 0x20ee77, r16[ax]);
    r32[esp] += 4; return;
  case 0x1b656a: // 0160:1b656a
    memoryASet16(ds, 0x20ee53, 0x00f0);
    memoryASet16(ds, 0x20ee55, 0x00a8);
    r16[ax] = memoryAGet16(ds, 0x20d819);
    memoryASet16(ds, 0x20ee77, r16[ax]);
    r32[esp] += 4; return;
  case 0x1b6589: // 0160:1b6589
    memoryASet16(ds, 0x20ee53, 0x0100);
    memoryASet16(ds, 0x20ee55, 0x00b4);
    r16[ax] = memoryAGet16(ds, 0x20d815);
    memoryASet16(ds, 0x20ee77, r16[ax]);
    r32[esp] += 4; return;
  case 0x1b65a8: // 0160:1b65a8
    memoryASet16(ds, 0x20ee53, 0x0120);
    memoryASet16(ds, 0x20ee55, 0x00c8);
    r16[ax] = memoryAGet16(ds, 0x20d811);
    memoryASet16(ds, 0x20ee77, r16[ax]);
    r32[esp] += 4; return;
  case 0x1b65c7: // 0160:1b65c7
    memoryASet16(ds, 0x20ee53, 0x0140);
    memoryASet16(ds, 0x20ee55, 0x00e0);
    r16[ax] = memoryAGet16(ds, 0x20d80d);
    memoryASet16(ds, 0x20ee77, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b65e6() // 0160:1b65e6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b65e6; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 541 bytes // gap 541 bytes
  case 0x1b65e6: // 0160:1b65e6
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ef5d0;
    yield* sub_1be816();
    r32[esi] = 0x001ef5f1;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef605;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef619;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef62d;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef641;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20d80d);
    yield* sub_1b66b7();
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20d811);
    yield* sub_1b66b7();
    memoryASet(ds, 0x20ea2a, 0x99);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20d815);
    yield* sub_1b66b7();
    memoryASet(ds, 0x20ea29, 0xc5);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20d819);
    yield* sub_1b66b7();
    memoryASet(ds, 0x20ea29, 0xc5);
    memoryASet(ds, 0x20ea2a, 0x99);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20d81d);
    yield* sub_1b66b7();
    memoryASet(ds, 0x20ea29, 0xc6);
    r32[esi] = 0x0020ea29;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b66b7() // 0160:1b66b7 +long
{
    r32[esp] -= 4;
    r32[edi] = 0x0020ea29;
    r32[esi] = 0x001ef655;
    r32[ecx] = 0x0000000d;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r8[al]--;
    r8[al] += r8[al];
    r32[eax] &= 0x000000ff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, 0x20ea2d, r8[bl]);
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    memoryASet(ds, 0x20ea2e, r8[bl]);
    r32[esp] += 4;
}
function* sub_1b66e5() // 0160:1b66e5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[bp])
        { pc = 0x1b66ee; break; }
    r16[ax] += 0x0002;
  case 0x1b66ee: // 0160:1b66ee
    r16[ax] += 0x00ec;
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 28898 bytes // gap 28898 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b66fb() // 0160:1b66fb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5998();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b6be9();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b6be9();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x0136);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4f0e();
    yield* sub_1b3af9();
  case 0x1b678b: // 0160:1b678b
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    yield* sub_1b531f();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1b7018();
    r32[esi] = 0x001ef68c;
    r8[al] = 0xc5;
    r8[bl] = 0x0d;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1b67ef; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b678b; break; }
  case 0x1b67ef: // 0160:1b67ef
    memoryASet16(ds, 0x20e831, 0x0000);
    if (memoryAGet16(ds, 0x20e82f) != 0x0001)
        { pc = 0x1b6be8; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1b68dc; break; }
    memoryASet16(ds, 0x20ec3d, 0x00ce);
    memoryASet16(ds, 0x20ec3f, 0x00f6);
    yield* sub_1b5096();
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b6fce();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b6fce();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
  case 0x1b686d: // 0160:1b686d
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b70ba();
    yield* sub_1b703c();
    r32[esi] = 0x001efae1;
    r8[al] = 0xc3;
    r8[bl] = 0x05;
    yield* sub_1b60a7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b68d0; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x224b9c, r16[ax]);
    yield* sub_1b2d91();
    { pc = 0x1b6be8; break; }
  case 0x1b68d0: // 0160:1b68d0
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b686d; break; }
  case 0x1b68dc: // 0160:1b68dc
    if (memoryAGet16(ds, 0x20d7f5) != 0x0002)
        { pc = 0x1b69e5; break; }
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecc1d;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1bd85e();
    yield* sub_1b7140();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b7140();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00be);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b697a: // 0160:1b697a
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b70ba();
    yield* sub_1b7060();
    r32[esi] = 0x001efb02;
    r8[al] = 0xc0;
    r8[bl] = 0x85;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1b69d3; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b697a; break; }
  case 0x1b69d3: // 0160:1b69d3
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x224b9e, r16[ax]);
    yield* sub_1b2d91();
    r32[esp] += 4; return;
  case 0x1b69e5: // 0160:1b69e5
    if (memoryAGet16(ds, 0x20d7f5) != 0x0003)
        { pc = 0x1b6aee; break; }
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecc1d;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1bd85e();
    yield* sub_1b71fc();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b71fc();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec3d, 0x009e);
    memoryASet16(ds, 0x20ec3f, 0x00be);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b6a83: // 0160:1b6a83
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b70ba();
    yield* sub_1b707e();
    r32[esi] = 0x001efb23;
    r8[al] = 0xc0;
    r8[bl] = 0x85;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1b6adc; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b6a83; break; }
  case 0x1b6adc: // 0160:1b6adc
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x224ba0, r16[ax]);
    yield* sub_1b2d91();
    r32[esp] += 4; return;
  case 0x1b6aee: // 0160:1b6aee
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5477();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecc1d;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1bd85e();
    yield* sub_1b72b8();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b72b8();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec3d, 0x0086);
    memoryASet16(ds, 0x20ec3f, 0x00be);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b6b7e: // 0160:1b6b7e
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0003);
    memoryASet16(ds, 0x20e809, 0x0002);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b70ba();
    yield* sub_1b709c();
    r32[esi] = 0x001efb44;
    r8[al] = 0xc0;
    r8[bl] = 0x85;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1b6bd7; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b6b7e; break; }
  case 0x1b6bd7: // 0160:1b6bd7
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    memoryASet16(ds, 0x224ba2, r16[ax]);
    yield* sub_1b2d91();
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b6be9() // 0160:1b6be9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b6be9; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 2080 bytes // gap 2080 bytes
  case 0x1b6be9: // 0160:1b6be9
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ef69f;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef6a5;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] != 0x0001)
        { pc = 0x1b6c84; break; }
    r32[esi] = 0x001ef6ac;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20e905, 0x0000);
    if (memoryAGet16(ds, 0x224b9c) & 0xffff)
        { pc = 0x1b6c5c; break; }
    r32[esi] = 0x001efa66;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa72;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa7e;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa8a;
    { pc = 0x1b60d3; break; }
  case 0x1b6c5c: // 0160:1b6c5c
    r32[esi] = 0x001efa96;
    yield* sub_1b60d3();
    r32[esi] = 0x001efaa7;
    yield* sub_1b60d3();
    r32[esi] = 0x001efab8;
    yield* sub_1b60d3();
    r32[esi] = 0x001efacc;
    { pc = 0x1b60d3; break; }
  case 0x1b6c84: // 0160:1b6c84
    if (r16[ax] != 0x0002)
        { pc = 0x1b6da2; break; }
    r32[esi] = 0x001ef6c6;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef714;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001ef72b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef734;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef73d;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef745;
    yield* sub_1b60d3();
    if (memoryAGet16(ds, 0x224b9e) & 0xffff)
        { pc = 0x1b6d0b; break; }
    r32[esi] = 0x001ef74e;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef761;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef774;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef787;
    yield* sub_1b60d3();
    { pc = 0x1b6da1; break; }
  case 0x1b6d0b: // 0160:1b6d0b
    if (memoryAGet16(ds, 0x224b9e) != 0x0001)
        { pc = 0x1b6d42; break; }
    r32[esi] = 0x001ef79a;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef7ad;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef7bf;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef7ce;
    yield* sub_1b60d3();
    { pc = 0x1b6da1; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6d42: // 0160:1b6d42
    if (memoryAGet16(ds, 0x224b9e) != 0x0002)
        { pc = 0x1b6d79; break; }
    r32[esi] = 0x001ef7dd;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef7ef;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef801;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef813;
    yield* sub_1b60d3();
    { pc = 0x1b6da1; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6d79: // 0160:1b6d79
    r32[esi] = 0x001ef825;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef83a;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef84f;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef864;
    yield* sub_1b60d3();
  case 0x1b6da1: // 0160:1b6da1
    r32[esp] += 4; return;
  case 0x1b6da2: // 0160:1b6da2
    if (r16[ax] != 0x0003)
        { pc = 0x1b6ec0; break; }
    r32[esi] = 0x001ef6e0;
    yield* sub_1b60d3();
    r32[esi] = 0x001efbc0;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001efbe0;
    yield* sub_1b60d3();
    r32[esi] = 0x001efbe9;
    yield* sub_1b60d3();
    r32[esi] = 0x001efbf2;
    yield* sub_1b60d3();
    r32[esi] = 0x001efbfa;
    yield* sub_1b60d3();
    if (memoryAGet16(ds, 0x224ba0) & 0xffff)
        { pc = 0x1b6e29; break; }
    r32[esi] = 0x001efc03;
    yield* sub_1b60d3();
    r32[esi] = 0x001efc1f;
    yield* sub_1b60d3();
    r32[esi] = 0x001efc3b;
    yield* sub_1b60d3();
    r32[esi] = 0x001efc57;
    yield* sub_1b60d3();
    { pc = 0x1b6ebf; break; }
  case 0x1b6e29: // 0160:1b6e29
    if (memoryAGet16(ds, 0x224ba0) != 0x0001)
        { pc = 0x1b6e60; break; }
    r32[esi] = 0x001efc73;
    yield* sub_1b60d3();
    r32[esi] = 0x001efc91;
    yield* sub_1b60d3();
    r32[esi] = 0x001efcae;
    yield* sub_1b60d3();
    r32[esi] = 0x001efcc8;
    yield* sub_1b60d3();
    { pc = 0x1b6ebf; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6e60: // 0160:1b6e60
    if (memoryAGet16(ds, 0x224ba0) != 0x0002)
        { pc = 0x1b6e97; break; }
    r32[esi] = 0x001efce2;
    yield* sub_1b60d3();
    r32[esi] = 0x001efcfe;
    yield* sub_1b60d3();
    r32[esi] = 0x001efd1a;
    yield* sub_1b60d3();
    r32[esi] = 0x001efd36;
    yield* sub_1b60d3();
    { pc = 0x1b6ebf; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6e97: // 0160:1b6e97
    r32[esi] = 0x001efd52;
    yield* sub_1b60d3();
    r32[esi] = 0x001efd6e;
    yield* sub_1b60d3();
    r32[esi] = 0x001efd8b;
    yield* sub_1b60d3();
    r32[esi] = 0x001efda8;
    yield* sub_1b60d3();
  case 0x1b6ebf: // 0160:1b6ebf
    r32[esp] += 4; return;
  case 0x1b6ec0: // 0160:1b6ec0
    r32[esi] = 0x001ef6fa;
    yield* sub_1b60d3();
    r32[esi] = 0x001effbc;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001effdc;
    yield* sub_1b60d3();
    r32[esi] = 0x001effe5;
    yield* sub_1b60d3();
    r32[esi] = 0x001effee;
    yield* sub_1b60d3();
    r32[esi] = 0x001efff6;
    yield* sub_1b60d3();
    if (memoryAGet16(ds, 0x224ba2) & 0xffff)
        { pc = 0x1b6f3d; break; }
    r32[esi] = 0x001effff;
    yield* sub_1b60d3();
    r32[esi] = 0x001f001c;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0039;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0056;
    yield* sub_1b60d3();
    { pc = 0x1b6f9c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6f3d: // 0160:1b6f3d
    if (memoryAGet16(ds, 0x224ba2) != 0x0001)
        { pc = 0x1b6f74; break; }
    r32[esi] = 0x001f0073;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0094;
    yield* sub_1b60d3();
    r32[esi] = 0x001f00b4;
    yield* sub_1b60d3();
    r32[esi] = 0x001f00d1;
    yield* sub_1b60d3();
    { pc = 0x1b6f9c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b6f74: // 0160:1b6f74
    r32[esi] = 0x001f00ee;
    yield* sub_1b60d3();
    r32[esi] = 0x001f010e;
    yield* sub_1b60d3();
    r32[esi] = 0x001f012e;
    yield* sub_1b60d3();
    r32[esi] = 0x001f014e;
    { pc = 0x1b60d3; break; }
  case 0x1b6f9c: // 0160:1b6f9c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b6f9d() // 0160:1b6f9d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b6f9d; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 3028 bytes // gap 3028 bytes
  case 0x1b6f9d: // 0160:1b6f9d
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001efa1b;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa2c;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa3d;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa51;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b6fce() // 0160:1b6fce +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b6fce; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 3077 bytes // gap 3077 bytes
  case 0x1b6fce: // 0160:1b6fce
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001efbb3;
    yield* sub_1b60d3();
    r32[esi] = 0x001efbb9;
    yield* sub_1b60d3();
    yield* sub_1b6f9d();
    r32[esi] = 0x001efb65;
    yield* sub_1b60d3();
    r32[esi] = 0x001efb76;
    yield* sub_1b60d3();
    r32[esi] = 0x001efb8a;
    yield* sub_1b60d3();
    r32[esi] = 0x001efb9e;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b7018() // 0160:1b7018 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[bp])
        { pc = 0x1b7021; break; }
    r16[ax] += 0x0002;
  case 0x1b7021: // 0160:1b7021
    r16[ax] += 0x002c;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b7033; break; }
    r16[ax] -= 0x0008;
  case 0x1b7033: // 0160:1b7033
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 26529 bytes // gap 26529 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b703c() // 0160:1b703c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[bp])
        { pc = 0x1b7045; break; }
    r16[ax] += 0x0002;
  case 0x1b7045: // 0160:1b7045
    r16[ax] += 0x0094;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b7057; break; }
    r16[ax] -= 0x0040;
  case 0x1b7057: // 0160:1b7057
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 26493 bytes // gap 26493 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b7060() // 0160:1b7060 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[bp])
        { pc = 0x1b7069; break; }
    r16[ax] += 0x0002;
  case 0x1b7069: // 0160:1b7069
    r16[ax] += 0x00bc;
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 26463 bytes // gap 26463 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b707e() // 0160:1b707e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[bp])
        { pc = 0x1b7087; break; }
    r16[ax] += 0x0002;
  case 0x1b7087: // 0160:1b7087
    r16[ax] += 0x00e4;
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 26433 bytes // gap 26433 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b709c() // 0160:1b709c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[bp])
        { pc = 0x1b70a5; break; }
    r16[ax] += 0x0002;
  case 0x1b70a5: // 0160:1b70a5
    r16[ax] += 0x011c;
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 26403 bytes // gap 26403 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b70ba() // 0160:1b70ba +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + r16[cx]);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < 0)
        { pc = 0x1b70dd; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (memoryAGet16(ds, 0x20e805) != r16[ax])
        { pc = 0x1b70e9; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    { pc = 0x1b70e9; break; }
  case 0x1b70dd: // 0160:1b70dd
    r16[ax] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20e82f, r16[ax]);
  case 0x1b70e9: // 0160:1b70e9
    r16[bp] = 0x0000;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[si] = memoryAGet16(ds, 0x20eeb0);
    r16[si] &= 0x0007;
    r16[si] >>>= 2;
    if (!r16[si])
        { pc = 0x1b710a; break; }
    r16[ax]--;
    r16[bp] = 0x0001;
  case 0x1b710a: // 0160:1b710a
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[si] = memoryAGet16(ds, 0x20e82f);
    r16[si] <<= 3;
    r16[bx] += r16[si];
    r16[si] <<= 2;
    r16[bx] += r16[si];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b7140() // 0160:1b7140 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b7140; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 3447 bytes // gap 3447 bytes
  case 0x1b7140: // 0160:1b7140
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ef879;
    yield* sub_1be816();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001ef88b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef8a4;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef8bd;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef8d6;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef8ef;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef908;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef921;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef93a;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef953;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef96c;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef985;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef99e;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef9b7;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef9d0;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef9e9;
    yield* sub_1b60d3();
    r32[esi] = 0x001efa02;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b71fc() // 0160:1b71fc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b71fc; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 3635 bytes // gap 3635 bytes
  case 0x1b71fc: // 0160:1b71fc
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001efdc5;
    yield* sub_1be816();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001efddc;
    yield* sub_1b60d3();
    r32[esi] = 0x001efdfa;
    yield* sub_1b60d3();
    r32[esi] = 0x001efe18;
    yield* sub_1b60d3();
    r32[esi] = 0x001efe36;
    yield* sub_1b60d3();
    r32[esi] = 0x001efe54;
    yield* sub_1b60d3();
    r32[esi] = 0x001efe72;
    yield* sub_1b60d3();
    r32[esi] = 0x001efe90;
    yield* sub_1b60d3();
    r32[esi] = 0x001efeae;
    yield* sub_1b60d3();
    r32[esi] = 0x001efecc;
    yield* sub_1b60d3();
    r32[esi] = 0x001efeea;
    yield* sub_1b60d3();
    r32[esi] = 0x001eff08;
    yield* sub_1b60d3();
    r32[esi] = 0x001eff26;
    yield* sub_1b60d3();
    r32[esi] = 0x001eff44;
    yield* sub_1b60d3();
    r32[esi] = 0x001eff62;
    yield* sub_1b60d3();
    r32[esi] = 0x001eff80;
    yield* sub_1b60d3();
    r32[esi] = 0x001eff9e;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b72b8() // 0160:1b72b8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b72b8; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 3823 bytes // gap 3823 bytes
  case 0x1b72b8: // 0160:1b72b8
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001f016e;
    yield* sub_1be816();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001f018c;
    yield* sub_1b60d3();
    r32[esi] = 0x001f01af;
    yield* sub_1b60d3();
    r32[esi] = 0x001f01d2;
    yield* sub_1b60d3();
    r32[esi] = 0x001f01f5;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0218;
    yield* sub_1b60d3();
    r32[esi] = 0x001f023d;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0262;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0285;
    yield* sub_1b60d3();
    r32[esi] = 0x001f02a8;
    yield* sub_1b60d3();
    r32[esi] = 0x001f02cd;
    yield* sub_1b60d3();
    r32[esi] = 0x001f02f2;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0317;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b734c() // 0160:1b734c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001f18f2;
    yield* sub_1be816();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001f1909;
    yield* sub_1be816();
    yield* sub_1b7445();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b7445();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1b73d4: // 0160:1b73d4
    yield* sub_1b5096();
    yield* sub_1b531f();
    r8[bl] = 0;
    if (memoryAGet(ds, 0x30b080))
        { pc = 0x1b743e; break; }
    r8[bl] = 0x01;
    if (memoryAGet(ds, 0x30b089))
        { pc = 0x1b743e; break; }
    r8[al] = memoryAGet(ds, 0x1f1c54);
  case 0x1b73f9: // 0160:1b73f9
    yield* sync();
    if (r8[al] == memoryAGet(ds, 0x1f1c54))
        { pc = 0x1b73f9; break; }
    r16[bx] = 0x4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b7417; break; }
    r16[bx] = 0;
  case 0x1b7417: // 0160:1b7417
    memoryASet16(ds, 0x2231c4, r16[bx]);
    memoryASet16(ds, 0x1f1cb8, r16[bx]);
    r16[dx] = 0x03d4;
    r16[bx] = memoryAGet16(ds, 0x1f1cb8);
    r8[ah] = r8[bh];
    r8[al] = 0x0c;
    out16(r16[dx], r16[ax]);
    r8[al]++;
    r8[ah] = r8[bl];
    out16(r16[dx], r16[ax]);
    { pc = 0x1b73d4; break; }
  case 0x1b743e: // 0160:1b743e
    memoryASet(ds, 0x1f1cbf, r8[bl]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b7445() // 0160:1b7445 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b7445; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 4220 bytes // gap 4220 bytes
  case 0x1b7445: // 0160:1b7445
    r32[esi] = 0x001f1920;
    yield* sub_1be816();
    r32[esi] = 0x001f1933;
    yield* sub_1b60d3();
    r32[esi] = 0x001f195b;
    yield* sub_1b60d3();
    r32[esi] = 0x001f1983;
    yield* sub_1b60d3();
    r32[esi] = 0x001f19a5;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b7477() // 0160:1b7477 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b7477; break; }
  case 0x1b63c9: // 0160:1b63c9
    memoryASet16(ds, 0x20eead, 0x0001);
    r32[esp] += 4; return;
    // gap 4260 bytes // gap 4260 bytes
  case 0x1b7477: // 0160:1b7477
    r32[edx] = 0x001f19c6;
    r32[eax] = 0x0023f52c;
    memoryASet32(ds, 0x20ce9d, r32[eax]);
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b7608; break; }
    push32(r32[eax]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b7608; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    r32[ebx] = pop32();
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b7608; break; }
    r32[eax] = memoryAGet32(ds, 0x20ce9d);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[edx] = r32[eax];
    push32(r32[edx]);
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b7608; break; }
    r32[ebx] = pop32();
    r32[eax] = 0x00003e00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b7608; break; }
    r32[ecx] = pop32();
    r32[edx] = pop32();
  case 0x1b74ea: // 0160:1b74ea
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x0d)
        { pc = 0x1b7527; break; }
    if (r8[al] == 0x65)
        { pc = 0x1b7501; break; }
    if (r8[al] == 0x45)
        { pc = 0x1b7501; break; }
    r32[edx]++;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1b74ea; break; }
    { pc = 0x1b7608; break; }
  case 0x1b7501: // 0160:1b7501
    r32[edx]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b7608; break; }
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x6d)
        { pc = 0x1b7513; break; }
    if (r8[al] != 0x4d)
        { pc = 0x1b74ea; break; }
  case 0x1b7513: // 0160:1b7513
    r32[edx]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b7608; break; }
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x6d)
        { pc = 0x1b7578; break; }
    if (r8[al] == 0x4d)
        { pc = 0x1b7578; break; }
    { pc = 0x1b74ea; break; }
  case 0x1b7527: // 0160:1b7527
    r32[edx]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b7608; break; }
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x0a)
        { pc = 0x1b7527; break; }
    if (r8[al] == 0x20)
        { pc = 0x1b7527; break; }
    if (r8[al] == 0x72)
        { pc = 0x1b7541; break; }
    if (r8[al] != 0x52)
        { pc = 0x1b74ea; break; }
  case 0x1b7541: // 0160:1b7541
    r32[edx]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b7608; break; }
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x65)
        { pc = 0x1b7553; break; }
    if (r8[al] != 0x45)
        { pc = 0x1b74ea; break; }
  case 0x1b7553: // 0160:1b7553
    r32[edx]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b7608; break; }
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x6d)
        { pc = 0x1b7565; break; }
    if (r8[al] != 0x4d)
        { pc = 0x1b74ea; break; }
  case 0x1b7565: // 0160:1b7565
    r32[edx]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1b7608; break; }
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] != 0x0d)
        { pc = 0x1b7565; break; }
    { pc = 0x1b74ea; break; }
  case 0x1b7578: // 0160:1b7578
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5998();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    yield* sub_1b7609();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b7609();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b75c5: // 0160:1b75c5
    yield* sub_1b5096();
    yield* sub_1b531f();
    r32[esi] = 0x001f19d2;
    r8[al] = 0xc0;
    r8[bl] = 0x4f;
    yield* sub_1b60a7();
    if (memoryAGet(ds, 0x30b071))
        { pc = 0x1b63c9; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b75fc; break; }
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1b7608; break; }
  case 0x1b75fc: // 0160:1b75fc
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b75c5; break; }
  case 0x1b7608: // 0160:1b7608
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b7609() // 0160:1b7609 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b7609; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 4672 bytes // gap 4672 bytes
  case 0x1b7609: // 0160:1b7609
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001f19e0;
    yield* sub_1be816();
    r32[esi] = 0x001f1a01;
    yield* sub_1be816();
    r32[esi] = 0x001f1a26;
    yield* sub_1be816();
    r32[esi] = 0x001f1a4e;
    yield* sub_1be816();
    r32[esi] = 0x001f1a6b;
    yield* sub_1be816();
    r32[esi] = 0x001f1a91;
    yield* sub_1be816();
    r32[esi] = 0x001f1aba;
    yield* sub_1be816();
    r32[esi] = 0x001f1ae1;
    yield* sub_1be816();
    r32[esi] = 0x001f1b08;
    yield* sub_1be816();
    r32[esi] = 0x001f1b2b;
    yield* sub_1be816();
    r32[esi] = 0x001f1b51;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b7680() // 0160:1b7680 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b77c2();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b77c2();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
    memoryASet16(ds, 0x20ce9d, 0x0000);
  case 0x1b76eb: // 0160:1b76eb
    yield* sub_1b5096();
    yield* sub_1b531f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b77b2; break; }
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1b77b2; break; }
    r16[ax] = memoryAGet16(ds, 0x20ce9d);
    memoryASet16(ds, 0x20ce9d, memoryAGet16(ds, 0x20ce9d) + 1);
    if (!r16[ax])
        { pc = 0x1b778c; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b7764; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b773c; break; }
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    memoryASet(ds, 0x20eea4, r8[al]);
    { pc = 0x1b77c1; break; }
  case 0x1b773c: // 0160:1b773c
    r8[al] = memoryAGet(ds, 0x1f1cc6);
    memoryASet(ds, 0x20eea3, r8[al]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b7808();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b7808();
    { pc = 0x1b77b2; break; }
  case 0x1b7764: // 0160:1b7764
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    memoryASet(ds, 0x20eea2, r8[al]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b77f4();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b77f4();
    { pc = 0x1b77b2; break; }
  case 0x1b778c: // 0160:1b778c
    r8[al] = memoryAGet(ds, 0x1f1cc4);
    memoryASet(ds, 0x20eea1, r8[al]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b77e0();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b77e0();
  case 0x1b77b2: // 0160:1b77b2
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b76eb; break; }
  case 0x1b77c1: // 0160:1b77c1
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b77c2() // 0160:1b77c2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b77c2; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 5113 bytes // gap 5113 bytes
  case 0x1b77c2: // 0160:1b77c2
    r32[esi] = 0x001f1b78;
    yield* sub_1be816();
    r32[esi] = 0x001f1b90;
    yield* sub_1b60d3();
    r32[esi] = 0x001f1c0f;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b77e0() // 0160:1b77e0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001f1baf;
    yield* sub_1be816();
    r32[esi] = 0x001f1c0f;
    { pc = 0x1be816; break; }
    // gap 28706 bytes // gap 28706 bytes
  case 0x1be816: // 0160:1be816
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b77f4() // 0160:1b77f4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b77f4; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 5163 bytes // gap 5163 bytes
  case 0x1b77f4: // 0160:1b77f4
    r32[esi] = 0x001f1bcf;
    yield* sub_1b60d3();
    r32[esi] = 0x001f1c0f;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b7808() // 0160:1b7808 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001f1bef;
    yield* sub_1be816();
    r32[esi] = 0x001f1c0f;
    { pc = 0x1be816; break; }
    // gap 28666 bytes // gap 28666 bytes
  case 0x1be816: // 0160:1be816
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b781c() // 0160:1b781c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b781c; break; }
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 3123 bytes // gap 3123 bytes
  case 0x1b781c: // 0160:1b781c
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b7a6e();
    yield* sub_1b5998();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00e7);
    memoryASet16(ds, 0x20ec3f, 0x00ed);
    yield* sub_1b4f0e();
    yield* sub_1b3af9();
  case 0x1b788b: // 0160:1b788b
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    yield* sub_1b531f();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b78ac; break; }
    r32[esp] += 4; return;
  case 0x1b78ac: // 0160:1b78ac
    r32[esi] = 0x001ef00d;
    r8[al] = 0xc2;
    r8[bl] = 0xc8;
    yield* sub_1b60a7();
    yield* sub_1b7945();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + r16[cx]);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < 0)
        { pc = 0x1b78e2; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x000d)
        { pc = 0x1b78eb; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    { pc = 0x1b78eb; break; }
  case 0x1b78e2: // 0160:1b78e2
    memoryASet16(ds, 0x20e82f, 0x000c);
  case 0x1b78eb: // 0160:1b78eb
    r32[ebp] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[si] = memoryAGet16(ds, 0x20eeb0);
    r16[si] &= 0x0007;
    r16[si] >>>= 2;
    if (!r16[si])
        { pc = 0x1b790a; break; }
    r16[ax]--;
    r16[bp] = 0x0001;
  case 0x1b790a: // 0160:1b790a
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[si] = memoryAGet16(ds, 0x20e82f);
    r16[si] <<= 3;
    r16[bx] += r16[si];
    r32[ecx] = 0;
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    yield* sub_1b4b7d();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b788b; break; }
    return;
  }
}
function* sub_1b7945() // 0160:1b7945 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x0000000e;
    r32[esi] = 0x001ef029;
    r32[edi] = 0x0020ea5b;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[eax] = 0x0000000d;
    r32[ebx] = 0;
    r8[bl] = 0x04;
  case 0x1b7968: // 0160:1b7968
    push32(r32[eax]);
    push32(r32[ebx]);
    r8[dl] = r8[bl];
    r32[esi] = 0x0020ea5f;
    r32[ecx] = 0;
  case 0x1b7973: // 0160:1b7973
    if (r8s[bl] < signed8(0x0a))
        { pc = 0x1b797f; break; }
    r8[cl]++;
    r8[bl] -= 0x0a;
    { pc = 0x1b7973; break; }
  case 0x1b797f: // 0160:1b797f
    if (!r8[cl])
        { pc = 0x1b7989; break; }
    r8[cl] += 0x30;
    memoryASet(ds, r32[esi], r8[cl]);
    r32[esi]++;
  case 0x1b7989: // 0160:1b7989
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi], r8[bl]);
    memoryASet16(ds, 0x20e90f, 0x0000);
    r32[eax] = 0;
    r8[al] = r8[dl];
    r16[ax] -= 0x0004;
    if (r16[ax] != memoryAGet16(ds, 0x20e82f))
        { pc = 0x1b79b1; break; }
    memoryASet16(ds, 0x20e90f, 0x0001);
  case 0x1b79b1: // 0160:1b79b1
    r32[esi] = 0x0020ea5b;
    yield* sub_1b79d3();
    flags.carry = memoryAGet(ds, 0x20ea5c) + 0x40 >= 0x100;
    memoryASet(ds, 0x20ea5c, memoryAGet(ds, 0x20ea5c) + 0x40);
    if (!flags.carry)
        { pc = 0x1b79cb; break; }
    memoryASet(ds, 0x20ea5b, memoryAGet(ds, 0x20ea5b) + 0x01);
  case 0x1b79cb: // 0160:1b79cb
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r8[bl]++;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b7968; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b79d3() // 0160:1b79d3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20e90f) & 0xffff)
        { pc = 0x1b7a40; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax] += 0x0003;
    if (r16[ax] != 0x0003)
        { pc = 0x1b79f2; break; }
    r16[ax] = 0x0010;
  case 0x1b79f2: // 0160:1b79f2
    if (r8[al] == r8[dl])
        { pc = 0x1b7a0e; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax] += 0x0005;
    if (r16[ax] != 0x0011)
        { pc = 0x1b7a0a; break; }
    r16[ax] = 0x0004;
  case 0x1b7a0a: // 0160:1b7a0a
    if (r8[al] != r8[dl])
        { pc = 0x1b7a6d; break; }
  case 0x1b7a0e: // 0160:1b7a0e
    push32(memoryAGet32(ds, 0x2231c4));
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b60d3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x0020ea5b;
    yield* sub_1b60d3();
    memoryASet32(ds, 0x2231c4, pop32());
    { pc = 0x1b7a6d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b7a40: // 0160:1b7a40
    push32(memoryAGet32(ds, 0x2231c4));
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1be816();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x0020ea5b;
    yield* sub_1be816();
    memoryASet32(ds, 0x2231c4, pop32());
  case 0x1b7a6d: // 0160:1b7a6d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b7a6e() // 0160:1b7a6e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x0000000e;
    r32[esi] = 0x001ef029;
    r32[edi] = 0x0020ea5b;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[eax] = 0x0000000d;
    r32[ebx] = 0;
    r8[bl] = 0x04;
  case 0x1b7a91: // 0160:1b7a91
    push32(r32[eax]);
    push32(r32[ebx]);
    r32[esi] = 0x0020ea5f;
    r32[ecx] = 0;
  case 0x1b7a9a: // 0160:1b7a9a
    if (r8s[bl] < signed8(0x0a))
        { pc = 0x1b7aa6; break; }
    r8[cl]++;
    r8[bl] -= 0x0a;
    { pc = 0x1b7a9a; break; }
  case 0x1b7aa6: // 0160:1b7aa6
    if (!r8[cl])
        { pc = 0x1b7ab0; break; }
    r8[cl] += 0x30;
    memoryASet(ds, r32[esi], r8[cl]);
    r32[esi]++;
  case 0x1b7ab0: // 0160:1b7ab0
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1b7af3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b7af3();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1b7af3();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    flags.carry = memoryAGet(ds, 0x20ea5c) + 0x40 >= 0x100;
    memoryASet(ds, 0x20ea5c, memoryAGet(ds, 0x20ea5c) + 0x40);
    if (!flags.carry)
        { pc = 0x1b7aeb; break; }
    memoryASet(ds, 0x20ea5b, memoryAGet(ds, 0x20ea5b) + 0x01);
  case 0x1b7aeb: // 0160:1b7aeb
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r8[bl]++;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b7a91; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b7af3() // 0160:1b7af3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b7af3; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 5930 bytes // gap 5930 bytes
  case 0x1b7af3: // 0160:1b7af3
    r32[esi] = 0x0020ea5b;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1b7afd() // 0160:1b7afd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b7afd; break; }
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 3860 bytes // gap 3860 bytes
  case 0x1b7afd: // 0160:1b7afd
    memoryASet16(ds, 0x20ecd5, 0x0000);
    r32[esi] = 0x0020ece3;
  case 0x1b7b0b: // 0160:1b7b0b
    r32[edi] = 0x0020e8c1;
    yield* sub_1b1c22();
    r8[al] &= 0x0f;
    r16[bp] = memoryAGet16(ds, 0x20ecd7);
  case 0x1b7b1e: // 0160:1b7b1e
    if (r16[ax] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1b7b2c; break; }
    r32[edi] += 0x00000002;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b7b1e; break; }
    { pc = 0x1b7b0b; break; }
  case 0x1b7b2c: // 0160:1b7b2c
    r32[edx] = 0x0020ece3;
    r16[bp] = memoryAGet16(ds, 0x20ecd7);
  case 0x1b7b38: // 0160:1b7b38
    if (r16[ax] == memoryAGet16(ds, r32[edx]))
        { pc = 0x1b7b0b; break; }
    r32[edx] += 0x00000002;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b7b38; break; }
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20ecd5, memoryAGet16(ds, 0x20ecd5) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ecd7);
    if (r16[ax] != memoryAGet16(ds, 0x20ecd5))
        { pc = 0x1b7b0b; break; }
    yield* sub_1b81c4();
    memoryASet16(ds, 0x20ecdd, r16[bx]);
    r32[edx] = 0x0020ece3;
  case 0x1b7b71: // 0160:1b7b71
    r16[bx] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    r16[bx] <<= 1;
    r32[ebx] &= 0x0000ffff;
    r16[bp] = memoryAGet16(ds, r32[edx] + r32[ebx]);
    memoryASet16(ds, r32[esi], r16[bp]);
    r32[esi] += 0x00000002;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b7b71; break; }
    if (memoryAGet16(ds, 0x20ecd9) == 0x0002)
        { pc = 0x1b7bc4; break; }
    yield* sub_1b81c4();
    r32[ebx] = 0;
    r16[ax] >>>= 1;
    r32[esi] += 0x00000002;
  case 0x1b7ba4: // 0160:1b7ba4
    if (memoryAGet16(ds, r32[esi]) != 0x00ff)
        { pc = 0x1b7bbb; break; }
    r16[cx] = memoryAGet16(ds, r32[esi] - 2);
    push32(r32[esi]);
    r32[esi] = memoryAGet32(ds, 0x20e819);
    memoryASet16(ds, r32[esi] + r32[ebx], r16[cx]);
    r32[esi] = pop32();
  case 0x1b7bbb: // 0160:1b7bbb
    r32[ebx] += 0x00000002;
    r32[esi] += 0x00000004;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1b7ba4; break; }
  case 0x1b7bc4: // 0160:1b7bc4
    memoryASet16(ds, 0x20ed51, 0x0001);
    memoryASet16(ds, 0x20edf3, 0x0000);
  case 0x1b7bd6: // 0160:1b7bd6
    memoryASet16(ds, 0x20ecdf, 0x0000);
  case 0x1b7bdf: // 0160:1b7bdf
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    if (memoryAGet16(ds, 0x20edf3) & 0xffff)
        { pc = 0x1b7c49; break; }
    r16[ax] = memoryAGet16(ds, 0x20d8ab);
    push32(r32[eax]);
    memoryASet16(ds, 0x20d8ab, 0x0000);
    memoryASet16(ds, 0x20ec8f, 0x0000);
    yield* sub_1abb6f();
    r32[eax] = pop32();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1b6be8; break; }
    memoryASet16(ds, 0x20d8ab, r16[ax]);
    memoryASet16(ds, 0x20edf3, 0x0001);
  case 0x1b7c49: // 0160:1b7c49
    r32[esi] = 0x0020ed03;
    r32[edi] = 0x0020ed23;
    memoryASet16(ds, 0x20ece1, 0x0008);
    if (!(memoryAGet16(ds, 0x20ecd9) & 0xffff))
        { pc = 0x1b7cb4; break; }
    r32[esi] = 0x0020ed23;
    r32[edi] = 0x0020ed33;
    memoryASet16(ds, 0x20ece1, 0x0004);
    if (memoryAGet16(ds, 0x20ecd9) == 0x0001)
        { pc = 0x1b7cb4; break; }
    r32[esi] = 0x0020ed33;
    r32[edi] = 0x0020ed3b;
    memoryASet16(ds, 0x20ece1, 0x0002);
    if (memoryAGet16(ds, 0x20ecd9) == 0x0002)
        { pc = 0x1b7cb4; break; }
    r32[esi] = 0x0020ed3b;
    r32[edi] = 0x0020ed3f;
    memoryASet16(ds, 0x20ece1, 0x0001);
  case 0x1b7cb4: // 0160:1b7cb4
    r16[ax] = memoryAGet16(ds, 0x20ecdf);
    r32[eax] &= 0x0000ffff;
    if (memoryAGet16(ds, r32[esi] + r32[eax] + 0x2) == 0x00ff)
        { pc = 0x1b7d5e; break; }
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20e8e1, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20e8e7, r16[bp]);
    memoryASet16(ds, 0x20e90d, 0x0002);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1b7dc1();
    yield* sub_1ba9f5();
    memoryASet16(ds, 0x20d8ab, 0x0004);
    memoryASet16(ds, 0x20d7f5, 0x0002);
    yield* sub_1abc11();
    if (!memoryAGet16(ds, 0x20ee81))
        { pc = 0x1b7d24; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    { pc = 0x1b6be8; break; }
  case 0x1b7d24: // 0160:1b7d24
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    if (memoryAGet16(ds, 0x20d7b7) == 0x0001)
        { pc = 0x1b7d3a; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
  case 0x1b7d3a: // 0160:1b7d3a
    r32[edi] = pop32();
    r32[esi] = pop32();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1b6be8; break; }
    r16[bx] = memoryAGet16(ds, 0x20ecdf);
    r16[bx] >>>= 1;
    r32[ebx] &= 0x0000ffff;
    memoryASet16(ds, r32[edi] + r32[ebx], r16[ax]);
  case 0x1b7d5e: // 0160:1b7d5e
    memoryASet16(ds, 0x20ecdf, memoryAGet16(ds, 0x20ecdf) + 0x0004);
    r16[ax] = memoryAGet16(ds, 0x20ecdf);
    r16[ax] >>>= 2;
    if (r16[ax] != memoryAGet16(ds, 0x20ece1))
        { pc = 0x1b7bdf; break; }
    memoryASet16(ds, 0x20edf3, 0x0000);
    memoryASet16(ds, 0x20ed51, memoryAGet16(ds, 0x20ed51) + 1);
    memoryASet16(ds, 0x20ecd9, memoryAGet16(ds, 0x20ecd9) + 1);
    if (memoryAGet16(ds, 0x20ecd9) != 0x0004)
        { pc = 0x1b7bd6; break; }
    yield* sub_1b7dc1();
    r16[ax] = memoryAGet16(ds, 0x20ed3f);
    memoryASet16(ds, 0x20e9c1, r16[ax]);
    memoryASet16(ds, 0x20e9c3, 0x0003);
    { pc = 0x1b9ca1; break; }
    // gap 7904 bytes // gap 7904 bytes
  case 0x1b9ca1: // 0160:1b9ca1
    yield* sub_1b191a();
    r8[al] = 0x81;
    yield* sub_1b18a6();
    yield* sub_1b4bc9();
    yield* sub_1bd3c8();
    yield* sub_1b56fa();
    yield* sub_1bd478();
    r32[edx] = 0x001ece20;
    r32[edi] = 0x000a0000;
    yield* sub_1b5205();
    r32[edi] = 0x000a4800;
    yield* sub_1b521d();
    r32[edi] = 0x000a9000;
    yield* sub_1b521d();
    r32[edx] = 0x001ece32;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r32[esi] = 0x0020e9c1;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    yield* sub_1bd346();
    memoryASet16(ds, 0x20ceb7, 0x00c8);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e9c5, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e9c3);
    r16[ax] <<= 1;
    r32[esi] = 0x001ef2c8;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20e9c7, r16[ax]);
    memoryASet16(ds, 0x20e887, 0x0000);
    if (!(memoryAGet16(ds, 0x20e9c3) & 0xffff))
        { pc = 0x1b9d83; break; }
    memoryASet16(ds, 0x20e887, 0x0005);
    if (memoryAGet16(ds, 0x20e9c3) == 0x0001)
        { pc = 0x1b9d83; break; }
    memoryASet16(ds, 0x20e887, 0x0008);
  case 0x1b9d83: // 0160:1b9d83
    yield* sub_1b4f0e();
  case 0x1b9d88: // 0160:1b9d88
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1b9da0; break; }
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
  case 0x1b9da0: // 0160:1b9da0
    yield* sub_1b9dce();
    if (signed16(memoryAGet16(ds, 0x20e887)) <= signed16(0x0028))
        { pc = 0x1b9dc2; break; }
    if (memoryAGet(ds, 0x20c840) != 0x80)
        { pc = 0x1b9dc2; break; }
    if (memoryAGet(ds, 0x20e837) == 0x80)
        { pc = 0x1b9dc2; break; }
    r32[esp] += 4; return;
  case 0x1b9dc2: // 0160:1b9dc2
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b9d88; break; }
    return;
  }
}
function* sub_1b7dc1() // 0160:1b7dc1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1bd3c8();
    yield* sub_1b59bc();
    r32[edx] = 0x001ed07a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r32[edx] = 0x001ed019;
    yield* sub_1bd87e();
    yield* sub_1b4f0e();
    memoryASet16(ds, 0x20d8ab, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
  case 0x1b7e27: // 0160:1b7e27
    yield* sub_1b5096();
    yield* sub_1b7e59();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b7e48; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b7e48; break; }
    r32[esp] += 4; return;
  case 0x1b7e48: // 0160:1b7e48
    yield* sub_1b8075();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b7e27; break; }
    return;
  }
}
function* sub_1b7e59() // 0160:1b7e59 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020ed03;
    if (!(memoryAGet16(ds, 0x20ecd9) & 0xffff))
        { pc = 0x1b7e8c; break; }
    r32[esi] = 0x0020ed23;
    if (memoryAGet16(ds, 0x20ecd9) == 0x0001)
        { pc = 0x1b7e8c; break; }
    r32[esi] = 0x0020ed33;
    if (memoryAGet16(ds, 0x20ecd9) == 0x0002)
        { pc = 0x1b7e8c; break; }
    r32[esi] = 0x0020ed3b;
  case 0x1b7e8c: // 0160:1b7e8c
    r16[ax] = memoryAGet16(ds, 0x20ecdf);
    r32[eax] &= 0x0000ffff;
    if (memoryAGet16(ds, r32[esi] + r32[eax] + 0x2) == 0x00ff)
        { pc = 0x1b7eb7; break; }
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ed43, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20ed45, r16[bp]);
  case 0x1b7eb7: // 0160:1b7eb7
    r32[esi] = 0x001ef4ea;
    r32[ecx] = 0x0020ed03;
    memoryASet16(ds, 0x20ecdb, 0x0000);
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[eax] = 0x00000010;
    yield* sub_1b7f70();
    r32[esi] = 0x001ef50a;
    r32[ecx] = 0x0020ed23;
    memoryASet16(ds, 0x20ecdb, 0x0001);
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[eax] = 0x00000008;
    yield* sub_1b7f70();
    r32[esi] = 0x001ef51a;
    r32[ecx] = 0x0020ed33;
    memoryASet16(ds, 0x20ecdb, 0x0002);
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[eax] = 0x00000004;
    yield* sub_1b7f70();
    r32[esi] = 0x001ef522;
    r32[ecx] = 0x0020ed3b;
    memoryASet16(ds, 0x20ecdb, 0x0003);
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[eax] = 0x00000002;
    yield* sub_1b7f70();
    r32[esi] = 0x001ef526;
    r32[ecx] = 0x0020ed3f;
    memoryASet16(ds, 0x20ecdb, 0x0004);
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[eax] = 0x00000001;
  case 0x1b7f70: // 0160:1b7f70
    push32(r32[eax]);
    r32[edx] = 0x0020ea5b;
    r16[ax] = memoryAGet16(ds, 0x20e887);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edx], r8[bl]);
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    memoryASet(ds, r32[edx] + 0x1, r8[bl]);
    memoryASet(ds, r32[edx] + 0x2, 0xf0);
    memoryASet(ds, r32[edx] + 0x3, 0x06);
    r32[edx] += 0x00000004;
    r16[ax] = memoryAGet16(ds, r32[ecx]);
    r32[ecx] += 0x00000002;
    memoryASet16(ds, 0x20ed47, r16[ax]);
    if (r16[ax] != 0x00ff)
        { pc = 0x1b7fc9; break; }
    r32[edi] = 0x001ef4e4;
    r16[bx] = memoryAGet16(ds, 0x20ecdb);
    if (r16s[bx] <= signed16(memoryAGet16(ds, 0x20ecd9)))
        { pc = 0x1b7fe1; break; }
    r32[edi] = 0x001ef4de;
    { pc = 0x1b7fe1; break; }
  case 0x1b7fc9: // 0160:1b7fc9
    r32[edi] = 0x00224866;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
  case 0x1b7fe1: // 0160:1b7fe1
    r32[ebx] = 0x00000003;
  case 0x1b7fe6: // 0160:1b7fe6
    r16[bp] = memoryAGet16(ds, r32[edi]);
    memoryASet16(ds, r32[edx], r16[bp]);
    r32[edi] += 0x00000002;
    r32[edx] += 0x00000002;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1b7fe6; break; }
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ecx]);
    push32(r32[edx]);
    memoryASet16(ds, 0x20e905, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20ecd9);
    if (r16[ax] != memoryAGet16(ds, 0x20ecdb))
        { pc = 0x1b804d; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed47);
    if (r16[ax] == memoryAGet16(ds, 0x20ed43))
        { pc = 0x1b8029; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20ed45))
        { pc = 0x1b804d; break; }
  case 0x1b8029: // 0160:1b8029
    memoryASet16(ds, 0x20e90f, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x001f;
    r16[ax] >>>= 4;
    if (!r16[ax])
        { pc = 0x1b8056; break; }
    memoryASet16(ds, 0x20e90f, 0x0001);
    { pc = 0x1b8056; break; }
  case 0x1b804d: // 0160:1b804d
    memoryASet16(ds, 0x20e90f, 0x0000);
  case 0x1b8056: // 0160:1b8056
    r32[esi] = 0x0020ea5b;
    yield* sub_1b818f();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r32[eax] = pop32();
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1b7f70; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b7f70() // 0160:1b7f70 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1b7f70: // 0160:1b7f70
    push32(r32[eax]);
    r32[edx] = 0x0020ea5b;
    r16[ax] = memoryAGet16(ds, 0x20e887);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edx], r8[bl]);
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    memoryASet(ds, r32[edx] + 0x1, r8[bl]);
    memoryASet(ds, r32[edx] + 0x2, 0xf0);
    memoryASet(ds, r32[edx] + 0x3, 0x06);
    r32[edx] += 0x00000004;
    r16[ax] = memoryAGet16(ds, r32[ecx]);
    r32[ecx] += 0x00000002;
    memoryASet16(ds, 0x20ed47, r16[ax]);
    if (r16[ax] != 0x00ff)
        { pc = 0x1b7fc9; break; }
    r32[edi] = 0x001ef4e4;
    r16[bx] = memoryAGet16(ds, 0x20ecdb);
    if (r16s[bx] <= signed16(memoryAGet16(ds, 0x20ecd9)))
        { pc = 0x1b7fe1; break; }
    r32[edi] = 0x001ef4de;
    { pc = 0x1b7fe1; break; }
  case 0x1b7fc9: // 0160:1b7fc9
    r32[edi] = 0x00224866;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
  case 0x1b7fe1: // 0160:1b7fe1
    r32[ebx] = 0x00000003;
  case 0x1b7fe6: // 0160:1b7fe6
    r16[bp] = memoryAGet16(ds, r32[edi]);
    memoryASet16(ds, r32[edx], r16[bp]);
    r32[edi] += 0x00000002;
    r32[edx] += 0x00000002;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1b7fe6; break; }
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ecx]);
    push32(r32[edx]);
    memoryASet16(ds, 0x20e905, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20ecd9);
    if (r16[ax] != memoryAGet16(ds, 0x20ecdb))
        { pc = 0x1b804d; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed47);
    if (r16[ax] == memoryAGet16(ds, 0x20ed43))
        { pc = 0x1b8029; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20ed45))
        { pc = 0x1b804d; break; }
  case 0x1b8029: // 0160:1b8029
    memoryASet16(ds, 0x20e90f, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x001f;
    r16[ax] >>>= 4;
    if (!r16[ax])
        { pc = 0x1b8056; break; }
    memoryASet16(ds, 0x20e90f, 0x0001);
    { pc = 0x1b8056; break; }
  case 0x1b804d: // 0160:1b804d
    memoryASet16(ds, 0x20e90f, 0x0000);
  case 0x1b8056: // 0160:1b8056
    r32[esi] = 0x0020ea5b;
    yield* sub_1b818f();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r32[eax] = pop32();
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1b7f70; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b8075() // 0160:1b8075 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x0148;
    r16[bx] = 0x0128;
    r32[ecx] = 0;
    r16[dx] = 0x0004;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] += 0x0020;
    r16[ax] += 0x0028;
    r16[dx] = 0x0004;
    r16[cx] = 0x0001;
    yield* sub_1bd7dd();
    r16[ax] = 0x0158;
    r16[bx] = 0x0088;
    r16[cx] = 0x0005;
    r16[dx] = 0x0004;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] += 0x0010;
    r16[ax] += 0x0004;
    r16[dx] = 0x0004;
    r16[cx] = 0x0006;
    yield* sub_1bd7dd();
    r32[ebp] = 0x00000008;
    memoryASet16(ds, 0x20e887, 0x0002);
    memoryASet16(ds, 0x20cec1, 0x00c0);
    memoryASet16(ds, 0x20cec3, 0x0003);
    memoryASet16(ds, 0x20cec5, 0x0007);
    yield* sub_1b8154();
    r32[ebp] = 0x00000004;
    memoryASet16(ds, 0x20e887, 0x0003);
    memoryASet16(ds, 0x20cec1, 0x0100);
    memoryASet16(ds, 0x20cec3, 0x0006);
    memoryASet16(ds, 0x20cec5, 0x0008);
    yield* sub_1b8154();
    r32[ebp] = 0x00000002;
    memoryASet16(ds, 0x20e887, 0x0004);
    memoryASet16(ds, 0x20cec1, 0x0140);
    memoryASet16(ds, 0x20cec3, 0x000c);
    memoryASet16(ds, 0x20cec5, 0x0009);
  case 0x1b8154: // 0160:1b8154
    r16[ax] = memoryAGet16(ds, 0x20cec1);
    r16[bx] = 0x0080;
    r16[dx] = memoryAGet16(ds, 0x20e887);
    r16[dx] <<= 3;
    r16[bx] += r16[dx];
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[dx] = 0x0004;
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + r16[ax]);
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1b8154; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b8154() // 0160:1b8154 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1b8154: // 0160:1b8154
    r16[ax] = memoryAGet16(ds, 0x20cec1);
    r16[bx] = 0x0080;
    r16[dx] = memoryAGet16(ds, 0x20e887);
    r16[dx] <<= 3;
    r16[bx] += r16[dx];
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[dx] = 0x0004;
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + r16[ax]);
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1b8154; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b818f() // 0160:1b818f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b818f; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 7622 bytes // gap 7622 bytes
  case 0x1b818f: // 0160:1b818f
    if (!(memoryAGet16(ds, 0x20e90f) & 0xffff))
        { pc = 0x1b81ad; break; }
    if (memoryAGet16(ds, 0x20e90f) == 0x0001)
        { pc = 0x1b60d3; break; }
    { pc = 0x1be816; break; }
  case 0x1b81ad: // 0160:1b81ad
    if (memoryAGet16(ds, 0x2231d4) == 0x003f)
        { pc = 0x1b81c3; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    { pc = 0x1b60d3; break; }
  case 0x1b81c3: // 0160:1b81c3
    r32[esp] += 4; return;
    // gap 26194 bytes // gap 26194 bytes
  case 0x1be816: // 0160:1be816
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b81c4() // 0160:1b81c4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020ed03;
    r32[eax] = 0x0020ed23;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[edi] = 0x001ef4a6;
    memoryASet16(ds, 0x20ecd9, 0x0000);
    r32[eax] = 0x00000010;
    r16[bx] = 0x0200;
    if (memoryAGet16(ds, 0x20ecd7) > 0x0008)
        { pc = 0x1b8240; break; }
    r32[esi] = 0x0020ed23;
    r32[eax] = 0x0020ed33;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[edi] = 0x001ef4c6;
    memoryASet16(ds, 0x20ecd9, 0x0001);
    r32[eax] = 0x00000008;
    r16[bx] = 0x01c0;
    if (memoryAGet16(ds, 0x20ecd7) > 0x0004)
        { pc = 0x1b8240; break; }
    r32[esi] = 0x0020ed33;
    r32[edi] = 0x001ef4d6;
    memoryASet16(ds, 0x20ecd9, 0x0002);
    r32[eax] = 0x00000004;
    r16[bx] = 0x0180;
  case 0x1b8240: // 0160:1b8240
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b8241() // 0160:1b8241 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b8241; break; }
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 5720 bytes // gap 5720 bytes
  case 0x1b8241: // 0160:1b8241
    memoryASet16(ds, 0x20ec9d, 0x0000);
    memoryASet16(ds, 0x20eca9, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    memoryASet16(ds, 0x20e995, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b3af9();
    if (!(memoryAGet16(ds, 0x20ec9d) & 0xffff))
        { pc = 0x1b8285; break; }
    yield* sub_1b84d2();
    yield* sub_1b4f0e();
    { pc = 0x1b82aa; break; }
  case 0x1b8285: // 0160:1b8285
    memoryASet16(ds, 0x20eca3, 0x0090);
    memoryASet16(ds, 0x20eca5, 0x0148);
    memoryASet16(ds, 0x20eca7, 0x0200);
    yield* sub_1b8511();
    yield* sub_1b4f0e();
  case 0x1b82aa: // 0160:1b82aa
    yield* sub_1b5096();
    if (!memoryAGet16(ds, 0x20eca9))
        { pc = 0x1b82c4; break; }
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
  case 0x1b82c4: // 0160:1b82c4
    if (!(memoryAGet16(ds, 0x20ed7f) & 0xffff))
        { pc = 0x1b82e9; break; }
    memoryASet16(ds, 0x20ed81, memoryAGet16(ds, 0x20ed81) - 1);
    if (!memoryAGet16(ds, 0x20ed81))
        { pc = 0x1b8358; break; }
    if (memoryAGet(ds, 0x20c840) & 0xff)
        { pc = 0x1b8358; break; }
  case 0x1b82e9: // 0160:1b82e9
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b830a; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b830a; break; }
    memoryASet16(ds, 0x20ecab, 0x0000);
    { pc = 0x1b8358; break; }
  case 0x1b830a: // 0160:1b830a
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1b8332; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b8332; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20ecab, 0xffff);
    { pc = 0x1b8358; break; }
  case 0x1b8332: // 0160:1b8332
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1b8359; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b8359; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20ecab, 0x0001);
  case 0x1b8358: // 0160:1b8358
    r32[esp] += 4; return;
  case 0x1b8359: // 0160:1b8359
    yield* sub_1b836d();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b82aa; break; }
    return;
  }
}
function* sub_1b8253() // 0160:1b8253 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b8253; break; }
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 5738 bytes // gap 5738 bytes
  case 0x1b8253: // 0160:1b8253
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    memoryASet16(ds, 0x20e995, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b3af9();
    if (!(memoryAGet16(ds, 0x20ec9d) & 0xffff))
        { pc = 0x1b8285; break; }
    yield* sub_1b84d2();
    yield* sub_1b4f0e();
    { pc = 0x1b82aa; break; }
  case 0x1b8285: // 0160:1b8285
    memoryASet16(ds, 0x20eca3, 0x0090);
    memoryASet16(ds, 0x20eca5, 0x0148);
    memoryASet16(ds, 0x20eca7, 0x0200);
    yield* sub_1b8511();
    yield* sub_1b4f0e();
  case 0x1b82aa: // 0160:1b82aa
    yield* sub_1b5096();
    if (!memoryAGet16(ds, 0x20eca9))
        { pc = 0x1b82c4; break; }
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
  case 0x1b82c4: // 0160:1b82c4
    if (!(memoryAGet16(ds, 0x20ed7f) & 0xffff))
        { pc = 0x1b82e9; break; }
    memoryASet16(ds, 0x20ed81, memoryAGet16(ds, 0x20ed81) - 1);
    if (!memoryAGet16(ds, 0x20ed81))
        { pc = 0x1b8358; break; }
    if (memoryAGet(ds, 0x20c840) & 0xff)
        { pc = 0x1b8358; break; }
  case 0x1b82e9: // 0160:1b82e9
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b830a; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b830a; break; }
    memoryASet16(ds, 0x20ecab, 0x0000);
    { pc = 0x1b8358; break; }
  case 0x1b830a: // 0160:1b830a
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1b8332; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b8332; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20ecab, 0xffff);
    { pc = 0x1b8358; break; }
  case 0x1b8332: // 0160:1b8332
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1b8359; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b8359; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20ecab, 0x0001);
  case 0x1b8358: // 0160:1b8358
    r32[esp] += 4; return;
  case 0x1b8359: // 0160:1b8359
    yield* sub_1b836d();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b82aa; break; }
    return;
  }
}
function* sub_1b836d() // 0160:1b836d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001eed71;
    yield* sub_1b60d3();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0040;
    if (!r16[ax])
        { pc = 0x1b838a; break; }
    yield* sub_1b85c3();
    { pc = 0x1b83b1; break; }
  case 0x1b838a: // 0160:1b838a
    r32[esi] = 0x0020196c;
    r16[bx] = memoryAGet16(ds, 0x20e995);
    r32[eax] = 0;
    r32[ebx] &= 0x0000ffff;
    r8[al] = memoryAGet(ds, r32[esi] + r32[ebx]);
    r32[eax] <<= 2;
    r32[esi] = 0x001eed85;
    r32[esi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    yield* sub_1b60d3();
  case 0x1b83b1: // 0160:1b83b1
    if (memoryAGet16(ds, 0x20eca9) & 0xffff)
        { pc = 0x1b8405; break; }
    r32[esi] = 0x001ef434;
    r16[dx] = memoryAGet16(ds, 0x20e99d);
    r16[dx] <<= 2;
    r32[edx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[edx] + 0x2);
    r16[cx] = 0;
    r16[dx] = 0x0004;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] += 0x0020;
    r16[ax] += 0x0028;
    r16[dx] = 0x0004;
    r16[cx] = 0x0001;
    yield* sub_1bd7dd();
    { pc = 0x1b84d1; break; }
  case 0x1b8405: // 0160:1b8405
    r32[ecx] = 0x00000003;
    r32[esi] = 0x0020eca3;
  case 0x1b840f: // 0160:1b840f
    push32(r32[ecx]);
    r32[ebp] = 0x00000004;
    memoryASet16(ds, 0x20e887, 0x0000);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0002);
    if (memoryAGet16(ds, r32[esi]) != 0xffd4)
        { pc = 0x1b8430; break; }
    memoryASet16(ds, r32[esi], 0x0200);
  case 0x1b8430: // 0160:1b8430
    r32[esi] += 0x00000002;
  case 0x1b8433: // 0160:1b8433
    r16[bx] = 0x0090;
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r16[dx] = 0x0005;
    if (r16s[ax] <= signed16(0x0068))
        { pc = 0x1b845d; break; }
    if (r16[ax] >= 0x01c0)
        { pc = 0x1b845d; break; }
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1b845d: // 0160:1b845d
    r16[ax] += 0x0018;
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1b8433; break; }
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b840f; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x001c;
    r16[ax] >>>= 1;
    r32[esi] = 0x001ef464;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] += 0x008c;
    r16[bx] = 0x00fa;
    r16[cx] = 0x0004;
    r16[dx] = 0x0001;
    yield* sub_1bd7dd();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] += 0x0010;
    r16[ax] &= 0x001c;
    r16[ax] >>>= 1;
    r32[esi] = 0x001ef464;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] += 0x01a4;
    r16[bx] = 0x00fa;
    r16[cx] = 0x0004;
    r16[dx] = 0;
    yield* sub_1bd7dd();
  case 0x1b84d1: // 0160:1b84d1
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b84d2() // 0160:1b84d2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    { pc = 0x1b851b; break; }
    // gap 66 bytes // gap 66 bytes
  case 0x1b851b: // 0160:1b851b
    r32[edx] = 0x001ed019;
    yield* sub_1bd87e();
    r32[esi] = 0x00201804;
    r16[ax] = memoryAGet16(ds, 0x20e995);
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    memoryASet16(ds, 0x20e99d, r16[cx]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20e99f, r16[cx]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x3);
    memoryASet16(ds, 0x20e9a1, r16[cx]);
    r32[esi] = 0x001ec0ec;
    r32[ebx] <<= 2;
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[ebx]);
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b85c3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b85c3();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    memoryASet16(ds, 0x224642, 0x0001);
    yield* sub_1b85c3();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b8511() // 0160:1b8511 +long
{
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b583e();
    r32[edx] = 0x001ed019;
    yield* sub_1bd87e();
    r32[esi] = 0x00201804;
    r16[ax] = memoryAGet16(ds, 0x20e995);
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    memoryASet16(ds, 0x20e99d, r16[cx]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20e99f, r16[cx]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x3);
    memoryASet16(ds, 0x20e9a1, r16[cx]);
    r32[esi] = 0x001ec0ec;
    r32[ebx] <<= 2;
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[ebx]);
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1b85c3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1b85c3();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    memoryASet16(ds, 0x224642, 0x0001);
    yield* sub_1b85c3();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esp] += 4;
}
function* sub_1b85c3() // 0160:1b85c3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b85c3; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 8698 bytes // gap 8698 bytes
  case 0x1b85c3: // 0160:1b85c3
    r32[esi] = 0x0020ea5b;
    if (memoryAGet16(ds, 0x20ed4d) != 0x0006)
        { pc = 0x1b85f0; break; }
    r32[edi] = 0x0023c4e0;
    memoryASet(ds, r32[esi], 0xc6);
    memoryASet(ds, r32[esi] + 0x1, 0x08);
    memoryASet(ds, r32[esi] + 0x2, 0xf0);
    memoryASet(ds, r32[esi] + 0x3, 0x10);
    r32[esi] += 0x00000004;
    r32[ecx] = 0x00000010;
    { pc = 0x1b862a; break; }
  case 0x1b85f0: // 0160:1b85f0
    r32[edi] = 0x002084b8;
    r16[cx] = memoryAGet16(ds, 0x20e995);
    if (!r16[cx])
        { pc = 0x1b8610; break; }
    r32[ebx] = 0;
    r32[ecx] &= 0x0000ffff;
  case 0x1b8609: // 0160:1b8609
    r8[bl] = memoryAGet(ds, r32[edi]);
    r32[edi]++;
    r32[edi] += r32[ebx];
    if (--r32[ecx])
        { pc = 0x1b8609; break; }
  case 0x1b8610: // 0160:1b8610
    memoryASet(ds, r32[esi], 0xc6);
    memoryASet(ds, r32[esi] + 0x1, 0x02);
    memoryASet(ds, r32[esi] + 0x2, 0xf0);
    r8[cl] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[esi] + 0x3, r8[cl]);
    r32[esi] += 0x00000004;
    r32[edi]++;
    r32[ecx] &= 0x000000ff;
  case 0x1b862a: // 0160:1b862a
    r32[etx] = r32[edi]; r32[edi] = r32[esi]; r32[esi] = r32[etx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20e905, 0x0002);
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1b865f; break; }
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1b86cb; break; }
    if (memoryAGet16(ds, 0x20ed41) & 0xffff)
        { pc = 0x1b86cb; break; }
  case 0x1b865f: // 0160:1b865f
    r32[esi] = 0x0020ea5b;
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 0x02);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[ax]++;
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1b8679; break; }
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
  case 0x1b8679: // 0160:1b8679
    yield* sub_1b60d3();
    r32[esi] = 0x0020ea5b;
    memoryASet(ds, r32[esi] + 0x3, 0x02);
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) - 0x02);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[ax]++;
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1b869f; break; }
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) - 1);
    memoryASet(ds, r32[esi] + 0x3, memoryAGet(ds, r32[esi] + 0x3) + 1);
  case 0x1b869f: // 0160:1b869f
    r32[ebx] = 0;
  case 0x1b86a1: // 0160:1b86a1
    if (r8s[al] < signed8(0x0a))
        { pc = 0x1b86ad; break; }
    r8[bl]++;
    r16[ax] -= 0x000a;
    { pc = 0x1b86a1; break; }
  case 0x1b86ad: // 0160:1b86ad
    if (!r8[bl])
        { pc = 0x1b86c2; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi] + 0x4, r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, r32[esi] + 0x5, r8[al]);
    memoryASet(ds, r32[esi] + 0x6, 0x20);
    { pc = 0x1b86cb; break; }
  case 0x1b86c2: // 0160:1b86c2
    r8[al] += 0x30;
    memoryASet(ds, r32[esi] + 0x4, r8[al]);
    memoryASet(ds, r32[esi] + 0x5, 0x20);
  case 0x1b86cb: // 0160:1b86cb
    r32[esi] = 0x0020ea5b;
    yield* sub_1b60d3();
    if (memoryAGet16(ds, 0x224642) & 0xffff)
        { pc = 0x1b8898; break; }
    r32[edi] = 0x001eeca5;
    if (!(memoryAGet16(ds, 0x20ed4d) & 0xffff))
        { pc = 0x1b8788; break; }
    r32[edi] = 0x001eecc6;
    if (memoryAGet16(ds, 0x20ed4d) == 0x0001)
        { pc = 0x1b87c6; break; }
    r32[edi] = 0x001eecd1;
    if (memoryAGet16(ds, 0x20ed4d) == 0x0002)
        { pc = 0x1b87e3; break; }
    if (memoryAGet16(ds, 0x20ed4d) == 0x0003)
        { pc = 0x1b880e; break; }
    if (memoryAGet16(ds, 0x20ed4d) == 0x0004)
        { pc = 0x1b885a; break; }
    if (memoryAGet16(ds, 0x20ed4d) == 0x0006)
        { pc = 0x1b8859; break; }
    if (memoryAGet16(ds, 0x20ecd9) != 0x0003)
        { pc = 0x1b8768; break; }
    r32[edi] = 0x001eecf4;
    yield* sub_1b88a2();
    memoryASet(ds, 0x20ea5c, memoryAGet(ds, 0x20ea5c) + 0x04);
    { pc = 0x1b8885; break; }
  case 0x1b8768: // 0160:1b8768
    r32[edi] = 0x001eece3;
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 0x02);
    r16[ax] = memoryAGet16(ds, 0x20ed51);
    r16[ax] += 0x0030;
    memoryASet(ds, r32[esi] + 0x13, r8[al]);
    { pc = 0x1b8885; break; }
  case 0x1b8788: // 0160:1b8788
    r16[bp] = memoryAGet16(ds, 0x20d863);
    r16[bp]++;
    if (r16[bp] != 0x0019)
        { pc = 0x1b87aa; break; }
    r32[edi] = 0x001eecb7;
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 0x04);
    { pc = 0x1b8885; break; }
  case 0x1b87aa: // 0160:1b87aa
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
    r32[edi] = r32[esi];
    r32[edi] += 0x00000013;
    r32[edx] = r32[esi];
    r32[edx] += 0x00000014;
    yield* sub_1b88cb();
    { pc = 0x1b8885; break; }
  case 0x1b87c6: // 0160:1b87c6
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 0x08);
    r32[edi] = r32[esi];
    r32[edx] = r32[esi];
    r32[edi] += 0x0000000c;
    r32[edx] += 0x0000000d;
    yield* sub_1b88cb();
    { pc = 0x1b8885; break; }
  case 0x1b87e3: // 0160:1b87e3
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e913);
    r16[ax] += 0x0031;
    memoryASet(ds, r32[esi] + 0xd, r8[al]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ed4f);
    r16[ax] += 0x0031;
    memoryASet(ds, r32[esi] + 0x14, r8[al]);
    { pc = 0x1b8885; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b880e: // 0160:1b880e
    if (signed16(memoryAGet16(ds, 0x20ec8f)) <= signed16(0x0003))
        { pc = 0x1b8840; break; }
    r32[edi] = 0x001eeca5;
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
    r32[edi] = r32[esi];
    r32[edx] = r32[esi];
    r32[edi] += 0x00000013;
    r32[edx] += 0x00000014;
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[ax] -= 0x0003;
    yield* sub_1b88d3();
    { pc = 0x1b8857; break; }
  case 0x1b8840: // 0160:1b8840
    yield* sub_1b88a2();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[ax] += 0x0031;
    memoryASet(ds, r32[esi] + 0x14, r8[al]);
  case 0x1b8857: // 0160:1b8857
    { pc = 0x1b8885; break; }
  case 0x1b8859: // 0160:1b8859
    r32[esp] += 4; return;
  case 0x1b885a: // 0160:1b885a
    r16[ax] = memoryAGet16(ds, 0x20e9a1);
    r16[ax] <<= 2;
    r32[ecx] = 0x001eed03;
    r32[eax] &= 0x0000ffff;
    r32[edi] = memoryAGet32(ds, r32[ecx] + r32[eax]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edi]);
    r32[ebx] = 0;
    r8[bl] = 0x12;
    r8[bl] -= r8[al];
    push32(r32[ebx]);
    yield* sub_1b88a2();
    r32[ebx] = pop32();
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + r8[bl]);
  case 0x1b8885: // 0160:1b8885
    r32[esi] = 0x0020ea5b;
    memoryASet16(ds, 0x20e905, 0x0002);
    { pc = 0x1b60d3; break; }
  case 0x1b8898: // 0160:1b8898
    memoryASet16(ds, 0x224642, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b88a2() // 0160:1b88a2 +long
{
    r32[esp] -= 4;
    r32[esi] = 0x0020ea5b;
    memoryASet(ds, r32[esi], 0xc6);
    memoryASet(ds, r32[esi] + 0x1, 0x14);
    memoryASet(ds, r32[esi] + 0x2, 0xf0);
    r8[cl] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[esi] + 0x3, r8[cl]);
    r32[edi]++;
    r32[esi] += 0x00000004;
    r32[ecx] &= 0x000000ff;
    r32[etx] = r32[edi]; r32[edi] = r32[esi]; r32[esi] = r32[etx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x0020ea5b;
    r32[esp] += 4;
}
function* sub_1b88cb() // 0160:1b88cb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d863);
    r16[ax]++;
    if (r16[ax] >= 0x000a)
        { pc = 0x1b88dc; break; }
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
  case 0x1b88dc: // 0160:1b88dc
    r32[ebx] = 0;
  case 0x1b88de: // 0160:1b88de
    if (r8s[al] < signed8(0x0a))
        { pc = 0x1b88e8; break; }
    r8[al] -= 0x0a;
    r8[bl]++;
    { pc = 0x1b88de; break; }
  case 0x1b88e8: // 0160:1b88e8
    if (!r8[bl])
        { pc = 0x1b88f7; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[edi], r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, r32[edx], r8[al]);
    { pc = 0x1b88fb; break; }
  case 0x1b88f7: // 0160:1b88f7
    r8[al] += 0x30;
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b88fb: // 0160:1b88fb
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b88d3() // 0160:1b88d3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r16[ax] >= 0x000a)
        { pc = 0x1b88dc; break; }
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + 1);
  case 0x1b88dc: // 0160:1b88dc
    r32[ebx] = 0;
  case 0x1b88de: // 0160:1b88de
    if (r8s[al] < signed8(0x0a))
        { pc = 0x1b88e8; break; }
    r8[al] -= 0x0a;
    r8[bl]++;
    { pc = 0x1b88de; break; }
  case 0x1b88e8: // 0160:1b88e8
    if (!r8[bl])
        { pc = 0x1b88f7; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[edi], r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, r32[edx], r8[al]);
    { pc = 0x1b88fb; break; }
  case 0x1b88f7: // 0160:1b88f7
    r8[al] += 0x30;
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b88fb: // 0160:1b88fb
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b88fc() // 0160:1b88fc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    r32[edx] = 0x001ece68;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1bd879();
    yield* sub_1b57fb();
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e843);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e845);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e847);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1b89b4; break; }
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e849);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1b89b4; break; }
    yield* sub_1b59d4();
  case 0x1b89b4: // 0160:1b89b4
    yield* sub_1bd478();
    yield* sub_1b8f52();
    r16[ax] = memoryAGet16(ds, 0x20e903);
    r32[esi] = 0x001ef31c;
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1b89ef; break; }
    r32[esi] = 0x001ef32c;
    if (r16[ax] == 0x0004)
        { pc = 0x1b89ef; break; }
    r32[esi] = 0x001ef33c;
    if (r16[ax] == 0x0003)
        { pc = 0x1b89ef; break; }
    r32[esi] = 0x001ef348;
  case 0x1b89ef: // 0160:1b89ef
    r32[edi] = 0x0020ea8d;
    memoryASet16(ds, r32[edi], 0x0001);
    r32[edi] += 0x00000002;
    { pc = 0x1b8a06; break; }
  case 0x1b89fe: // 0160:1b89fe
    memoryASet16(ds, r32[edi], 0x0000);
    r32[edi] += 0x00000002;
  case 0x1b8a06: // 0160:1b8a06
    movsw_ESEDI_DSESI();
    memoryASet16(ds, r32[edi], 0x0040);
    r32[edi] += 0x00000002;
    movsw_ESEDI_DSESI();
    memoryASet16(ds, r32[edi], 0x0000);
    memoryASet16(ds, r32[edi] + 0x2, 0x0020);
    memoryASet16(ds, r32[edi] + 0x4, 0x0020);
    r32[edi] += 0x00000006;
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1b89fe; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1b8a89; break; }
    if (memoryAGet16(ds, 0x20e9a7) == 0x0003)
        { pc = 0x1b8acf; break; }
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1b8acf; break; }
    r32[esi] = 0x0020e843;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    yield* sub_1bd346();
    memoryASet16(ds, 0x20ecbb, 0x0001);
    r32[esi] = 0x0020e845;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    yield* sub_1bd346();
    { pc = 0x1b8afe; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b8a89: // 0160:1b8a89
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1b8acf; break; }
    r32[esi] = 0x0020e843;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    yield* sub_1bd346();
    memoryASet16(ds, 0x20ecbb, 0x0001);
    r32[esi] = 0x0020e845;
    r16[ax] = memoryAGet16(ds, 0x20e903);
    memoryASet16(ds, 0x20ceb1, r16[ax]);
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) - 1);
    yield* sub_1bd346();
    { pc = 0x1b8afe; break; }
  case 0x1b8acf: // 0160:1b8acf
    r32[esi] = 0x0020e843;
    memoryASet16(ds, 0x20ceb1, 0x0002);
    yield* sub_1bd346();
    memoryASet16(ds, 0x20ecbb, 0x0001);
    r32[esi] = 0x0020e847;
    memoryASet16(ds, 0x20ceb1, 0x0002);
    yield* sub_1bd346();
  case 0x1b8afe: // 0160:1b8afe
    memoryASet16(ds, 0x20e831, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x224640, 0x0001);
    yield* sub_1b8ec1();
    yield* sub_1b5126();
    memoryASet16(ds, 0x224640, 0x0000);
    yield* sub_1b8ec1();
    yield* sub_1b5126();
    memoryASet16(ds, 0x2231c4, 0x0001);
    yield* sub_1b8ec1();
    yield* sub_1b5126();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1b191a();
    r8[al] = 0x8a;
    yield* sub_1b18a6();
    yield* sub_1b4f0e();
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x20ee13, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
  case 0x1b8b7d: // 0160:1b8b7d
    yield* sub_1b5096();
    r8[al] = 0xc0;
    if (!(memoryAGet16(ds, 0x20eda9) & 0xffff))
        { pc = 0x1b8b98; break; }
    r32[esi] = 0x001eec27;
    r8[bl] = 0x87;
    { pc = 0x1b8bfa; break; }
  case 0x1b8b98: // 0160:1b8b98
    r32[esi] = 0x001eec10;
    r8[bl] = 0x8b;
    if (memoryAGet16(ds, 0x20e90d) != 0x0001)
        { pc = 0x1b8bfa; break; }
    if (memoryAGet16(ds, 0x20e9a7) != 0x0001)
        { pc = 0x1b8bfa; break; }
    r16[bp] = memoryAGet16(ds, 0x20d863);
    r16[bp]++;
    if (r16[bp] != 0x0019)
        { pc = 0x1b8bd8; break; }
    r32[esi] = 0x001eec5c;
    if (memoryAGet16(ds, 0x20d1f7) == 0x0001)
        { pc = 0x1b8bfa; break; }
    r32[esi] = 0x001eec8c;
    { pc = 0x1b8bf6; break; }
  case 0x1b8bd8: // 0160:1b8bd8
    r32[esi] = 0x001eec45;
    if (memoryAGet16(ds, 0x20d1f7) == 0x0001)
        { pc = 0x1b8bfa; break; }
    if (memoryAGet16(ds, 0x20d1f9) == 0x0001)
        { pc = 0x1b8bfa; break; }
    r32[esi] = 0x001eec73;
  case 0x1b8bf6: // 0160:1b8bf6
    r8[al] = 0xc0;
    r8[bl] = 0x8a;
  case 0x1b8bfa: // 0160:1b8bfa
    yield* sub_1b60a7();
    yield* sub_1b8c45();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    if (r16[ax] == 0x0bb8)
        { pc = 0x1b8c2e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee13);
    if (r16s[ax] <= signed16(0x00fa))
        { pc = 0x1b8c2f; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b8c36; break; }
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1b8c36; break; }
  case 0x1b8c2e: // 0160:1b8c2e
    r32[esp] += 4; return;
  case 0x1b8c2f: // 0160:1b8c2f
    memoryASet16(ds, 0x20ee13, memoryAGet16(ds, 0x20ee13) + 1);
  case 0x1b8c36: // 0160:1b8c36
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b8b7d; break; }
    return;
  }
}
function* sub_1b8c45() // 0160:1b8c45 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20e903);
    memoryASet16(ds, 0x20e887, r16[ax]);
    r32[esi] = 0x0020ea8d;
  case 0x1b8c56: // 0160:1b8c56
    if (memoryAGet16(ds, r32[esi]) == 0x0002)
        { pc = 0x1b8caa; break; }
    if (memoryAGet16(ds, r32[esi]) > 0x0002)
        { pc = 0x1b8c94; break; }
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1b8ca5; break; }
    if (memoryAGet16(ds, r32[esi] + 0x4) != 0x0080)
        { pc = 0x1b8c7d; break; }
    if (memoryAGet16(ds, 0x20e887) == 0x0001)
        { pc = 0x1b8c7d; break; }
    memoryASet16(ds, r32[esi] + 0xe, 0x0001);
  case 0x1b8c7d: // 0160:1b8c7d
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + 0x4, r16[ax]);
    if (r16[ax] != memoryAGet16(ds, r32[esi] + 0x6))
        { pc = 0x1b8c94; break; }
    memoryASet16(ds, r32[esi], 0x0002);
  case 0x1b8c94: // 0160:1b8c94
    yield* sub_1b8d12();
    r32[esi] += 0x0000000e;
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) - 1);
    if (memoryAGet16(ds, 0x20e887))
        { pc = 0x1b8c56; break; }
  case 0x1b8ca5: // 0160:1b8ca5
    { pc = 0x1b8ec0; break; }
  case 0x1b8caa: // 0160:1b8caa
    memoryASet16(ds, r32[esi] + 0x8, memoryAGet16(ds, r32[esi] + 0x8) + 1);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0xc);
    if (r16s[ax] >= 0)
        { pc = 0x1b8cc7; break; }
    r16[ax] = -r16[ax];
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0xa))
        { pc = 0x1b8ea4; break; }
    r16[ax] = -r16[ax];
  case 0x1b8cc7: // 0160:1b8cc7
    r16[ax]--;
    memoryASet16(ds, r32[esi] + 0xc, r16[ax]);
    if (r16s[ax] >= 0)
        { pc = 0x1b8cd2; break; }
    r16[ax] = -r16[ax];
  case 0x1b8cd2: // 0160:1b8cd2
    if (r16s[ax] < signed16(0x0008))
        { pc = 0x1b8ce3; break; }
    r16[ax] -= 0x0008;
    yield* sub_1b8f3e();
    { pc = 0x1b8cd2; break; }
  case 0x1b8ce3: // 0160:1b8ce3
    if (!r16[ax])
        { pc = 0x1b8d10; break; }
    r16[ax] <<= 3;
    r16[ax] &= 0x0038;
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[bx] &= 0x0007;
    r16[ax] += r16[bx];
    r32[edi] = 0x001ef3f4;
    r32[eax] &= 0x0000ffff;
    if (!(memoryAGet(ds, r32[edi] + r32[eax]) & 0xff))
        { pc = 0x1b8d10; break; }
    yield* sub_1b8f3e();
  case 0x1b8d10: // 0160:1b8d10
    { pc = 0x1b8c94; break; }
    // gap 392 bytes // gap 392 bytes
  case 0x1b8e9a: // 0160:1b8e9a
    memoryASet16(ds, r32[esi], 0x0003);
    { pc = 0x1b8c94; break; }
  case 0x1b8ea4: // 0160:1b8ea4
    r16[ax] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[ax] >>>= 1;
    if (!r16[ax])
        { pc = 0x1b8e9a; break; }
    memoryASet16(ds, r32[esi] + 0xa, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xc, r16[ax]);
    memoryASet16(ds, r32[esi] + 0x8, 0x0000);
    { pc = 0x1b8c94; break; }
  case 0x1b8ec0: // 0160:1b8ec0
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b8d12() // 0160:1b8d12 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x20ced3, r32[esi]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r16[cx]--;
    r16[cx] <<= 1;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x003f;
    r16[bp] >>>= 5;
    if (!r16[bp])
        { pc = 0x1b8d3f; break; }
    r16[cx]++;
  case 0x1b8d3f: // 0160:1b8d3f
    if (signed16(memoryAGet16(ds, 0x20eeb0)) < signed16(0x00fa))
        { pc = 0x1b8d55; break; }
    r16[cx] = 0x002c;
    r16[cx] += memoryAGet16(ds, 0x20e887);
  case 0x1b8d55: // 0160:1b8d55
    r16[dx] = 0x0007;
    yield* sub_1bd50f();
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[esi]);
    r32[esi] = 0x0020e843;
    r16[bp] = memoryAGet16(ds, 0x20e887);
    r16[bp]--;
    r16[bp] <<= 1;
    r32[ebp] &= 0x0000ffff;
    r32[esi] += r32[ebp];
    r16[cx] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20cec3, r16[cx]);
    r16[cx] += 0x0008;
    r16[bx] += 0x0030;
    r32[esi] = memoryAGet32(ds, 0x20ced3);
    if (memoryAGet16(ds, r32[esi]) != 0x0003)
        { pc = 0x1b8e7b; break; }
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x0040;
    if (!r16[bp])
        { pc = 0x1b8dbc; break; }
  case 0x1b8da9: // 0160:1b8da9
    yield* sub_1bd51f();
    r16[dx] = 0x0004;
    yield* sub_1bd50f();
    { pc = 0x1b8e7b; break; }
  case 0x1b8dbc: // 0160:1b8dbc
    r16[dx] = memoryAGet16(ds, 0x20d7f5);
    if (r16[dx] == 0x0001)
        { pc = 0x1b8e29; break; }
    if (memoryAGet16(ds, 0x20eda9) & 0xffff)
        { pc = 0x1b8da9; break; }
    if (r16[dx] == 0x0002)
        { pc = 0x1b8e60; break; }
    if (r16[dx] == 0x0003)
        { pc = 0x1b8e44; break; }
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1b8dff; break; }
    r16[cx] = 0x0024;
    if (signed16(memoryAGet16(ds, 0x20e887)) <= signed16(0x0002))
        { pc = 0x1b8e72; break; }
    { pc = 0x1b8e6e; break; }
  case 0x1b8dff: // 0160:1b8dff
    r16[cx] = 0x0024;
    if (memoryAGet16(ds, 0x20e887) == 0x0001)
        { pc = 0x1b8e72; break; }
    r16[cx] = 0x0025;
    if (memoryAGet16(ds, 0x20e887) == 0x0002)
        { pc = 0x1b8e72; break; }
    r16[cx] = 0x0027;
    flags.zero = memoryAGet16(ds, 0x20e887) == 0x0003;
    { pc = 0x1b8e6c; break; }
  case 0x1b8e29: // 0160:1b8e29
    if (memoryAGet16(ds, 0x20ecb5) != 0x0002)
        { pc = 0x1b8da9; break; }
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r16[cx] += 0x0028;
    { pc = 0x1b8e72; break; }
  case 0x1b8e44: // 0160:1b8e44
    r16[cx] = 0x0024;
    if (memoryAGet16(ds, 0x20e887) == 0x0001)
        { pc = 0x1b8e72; break; }
    r16[cx] = 0x0026;
    flags.zero = memoryAGet16(ds, 0x20e887) == 0x0002;
    { pc = 0x1b8e6c; break; }
  case 0x1b8e60: // 0160:1b8e60
    r16[cx] = 0x0024;
    flags.zero = memoryAGet16(ds, 0x20e887) == 0x0001;
  case 0x1b8e6c: // 0160:1b8e6c
    if (flags.zero)
        { pc = 0x1b8e72; break; }
  case 0x1b8e6e: // 0160:1b8e6e
    r16[cx] = 0x0028;
  case 0x1b8e72: // 0160:1b8e72
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
  case 0x1b8e7b: // 0160:1b8e7b
    r32[esi] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[cx] = 0x0018;
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    r16[dx] = 0x0008;
    yield* sub_1bd50f();
    r32[esi] = memoryAGet32(ds, 0x20ced3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b8ec1() // 0160:1b8ec1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001ef350;
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1b8ef4; break; }
    r32[esi] = 0x001ef382;
    if (memoryAGet16(ds, 0x20e903) == 0x0004)
        { pc = 0x1b8ef4; break; }
    r32[esi] = 0x001ef3b4;
    if (memoryAGet16(ds, 0x20e903) == 0x0003)
        { pc = 0x1b8ef4; break; }
    r32[esi] = 0x001ef3da;
  case 0x1b8ef4: // 0160:1b8ef4
    r16[bp] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
  case 0x1b8efa: // 0160:1b8efa
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[esi] += 0x00000006;
    r16[dx] = 0x0004;
    push32(r32[ebp]);
    push32(r32[esi]);
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1b8f1e; break; }
    yield* sub_1bd7dd();
  case 0x1b8f1e: // 0160:1b8f1e
    r32[esi] = pop32();
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[esi] += 0x00000006;
    r16[dx] = 0x0004;
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b8efa; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b8f3e() // 0160:1b8f3e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, r32[esi] + 0xc) & 0xffff))
        { pc = 0x1b8f51; break; }
    if (memoryAGet16(ds, r32[esi] + 0xc) & 32768)
        { pc = 0x1b8f4d; break; }
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) - 0x0002);
  case 0x1b8f4d: // 0160:1b8f4d
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) + 1);
  case 0x1b8f51: // 0160:1b8f51
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b8f52() // 0160:1b8f52 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20e90d);
    memoryASet16(ds, 0x20e903, r16[ax]);
    if (memoryAGet16(ds, 0x20e90d) != 0x0001)
        { pc = 0x1b8f8e; break; }
    memoryASet16(ds, 0x20e903, 0x0004);
    if (memoryAGet16(ds, 0x20e9a7) == 0x0001)
        { pc = 0x1b8f8e; break; }
    if (memoryAGet16(ds, 0x20e9a7) == 0x0003)
        { pc = 0x1b8f8e; break; }
    memoryASet16(ds, 0x20e903, 0x0002);
  case 0x1b8f8e: // 0160:1b8f8e
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b8f8f() // 0160:1b8f8f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b8f8f; break; }
  case 0x1a81dc: // 0160:1a81dc
    push32(r32[ebp]);
    yield* sub_1a81f3();
    if (memoryAGet16(ds, 0x1f1ccc) != 0x0001)
        { pc = 0x1a81f1; break; }
    yield* sub_1c727c();
  case 0x1a81f1: // 0160:1a81f1
    r32[ebp] = pop32();
    r32[esp] += 4; return;
    // gap 59893 bytes // gap 59893 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 9126 bytes // gap 9126 bytes
  case 0x1b8f8f: // 0160:1b8f8f
    memoryASet16(ds, 0x20ed41, 0x0000);
    memoryASet16(ds, 0x20edd1, 0x0001);
    r32[ebx] = 0x002967b4;
    memoryASet32(ds, 0x20cee7, r32[ebx]);
    r32[ecx] = 0x0000001d;
    r32[esi] = 0x002248c6;
  case 0x1b8fb6: // 0160:1b8fb6
    push32(r32[ecx]);
    yield* sub_1be39c();
    yield* sub_1b8ff7();
    yield* sub_1be39c();
    yield* sub_1b8ff7();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b8fb6; break; }
    r32[ecx] = 0x0000001b;
    r32[esi] = 0x002249f6;
  case 0x1b8fd8: // 0160:1b8fd8
    push32(r32[ecx]);
    yield* sub_1be39c();
    yield* sub_1b8ff7();
    yield* sub_1be39c();
    yield* sub_1b8ff7();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1b8fd8; break; }
    yield* sub_1b9b3d();
    { pc = 0x1b902e; break; }
    // gap 55 bytes // gap 55 bytes
  case 0x1b902e: // 0160:1b902e
    memoryASet16(ds, 0x20d897, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    yield* sub_1b3af9();
  case 0x1b9045: // 0160:1b9045
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    yield* sub_1b531f();
    memoryASet16(ds, 0x20edab, memoryAGet16(ds, 0x20edab) + 1);
    if (memoryAGet16(ds, 0x20edab) != 0x2ee0)
        { pc = 0x1b9071; break; }
    { pc = 0x1a81dc; break; }
  case 0x1b9071: // 0160:1b9071
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b9083; break; }
    memoryASet16(ds, 0x20edab, 0x0000);
  case 0x1b9083: // 0160:1b9083
    memoryASet16(ds, 0x20ecaf, memoryAGet16(ds, 0x20ecaf) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ecaf);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b90b7; break; }
    memoryASet16(ds, 0x20ecad, memoryAGet16(ds, 0x20ecad) + 1);
    memoryASet16(ds, 0x20ecb7, memoryAGet16(ds, 0x20ecb7) + 1);
    if (memoryAGet16(ds, 0x20ecb7) != 0x0003)
        { pc = 0x1b90b7; break; }
    memoryASet16(ds, 0x20ecb7, 0x0000);
  case 0x1b90b7: // 0160:1b90b7
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b937c; break; }
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b90d2; break; }
    r32[esp] += 4; return;
  case 0x1b90d2: // 0160:1b90d2
    memoryASet16(ds, 0x20e8af, 0x0002);
    yield* sub_1b97b1();
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1b9139; break; }
    memoryASet16(ds, 0x20d897, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[esi] = 0x00224866;
    r32[edi] = 0x001ec010;
    r32[ecx] = 0x00000006;
    r32[eax] &= 0x0000ffff;
  case 0x1b911a: // 0160:1b911a
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[bl] != memoryAGet(ds, r32[edi] + r32[eax]))
        { pc = 0x1b9130; break; }
    r32[eax]++;
    if (--r32[ecx])
        { pc = 0x1b911a; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1b9139; break; }
  case 0x1b9130: // 0160:1b9130
    memoryASet16(ds, 0x20e82f, 0x0000);
  case 0x1b9139: // 0160:1b9139
    if (memoryAGet16(ds, 0x2231d4) == 0x0003)
        { pc = 0x1b9160; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc3;
    r8[bl] = 0x51;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0xd1;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
  case 0x1b9160: // 0160:1b9160
    r32[esi] = 0x001ee9f9;
    r8[al] = 0xc2;
    r8[bl] = 0xd4;
    yield* sub_1b60a7();
    r32[esi] = 0x001eea10;
    yield* sub_1b60d3();
    r32[esi] = 0x001eea09;
    yield* sub_1b60d3();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0029);
    yield* sub_1b49ae();
    yield* sub_1b4b5f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b95e7; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b95e7; break; }
    memoryASet16(ds, 0x20d897, 0x0000);
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b9291; break; }
    yield* sub_1bdfd5();
    memoryASet16(ds, 0x20d897, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e887);
    r16[ax]++;
    if (r16[ax] != memoryAGet16(ds, 0x20e90d))
        { pc = 0x1b9227; break; }
    memoryASet16(ds, 0x20e8af, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20e9b3);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000006;
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    { pc = 0x1b937b; break; }
  case 0x1b9227: // 0160:1b9227
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb66;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b5747();
    yield* sub_1bd478();
    memoryASet16(ds, 0x20e8bb, 0x0003);
    memoryASet16(ds, 0x20ec3d, 0x0130);
    memoryASet16(ds, 0x20ec3f, 0x00ee);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b9291: // 0160:1b9291
    memoryASet16(ds, 0x20e8af, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20e9b3);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b92ba; break; }
    r32[esi] -= 0x00000004;
  case 0x1b92ba: // 0160:1b92ba
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r16[ax] = memoryAGet16(ds, 0x20e887);
    if (r16[ax] == memoryAGet16(ds, 0x20e90d))
        { pc = 0x1b937b; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[bx] = r16[ax];
  case 0x1b92ec: // 0160:1b92ec
    r16[ax]--;
    r16[bx]++;
    r16[ax] &= 0x000f;
    r16[bx] &= 0x000f;
    memoryASet(ds, 0x20c840, 0x01);
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r32[ecx] &= 0x0000ffff;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1b936c; break; }
    r16[dx] = r16[cx];
    r32[esi] = 0x0020e8db;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b9328; break; }
    r32[esi] = 0x0020e8bf;
  case 0x1b9328: // 0160:1b9328
    r32[edi] = r32[esi];
  case 0x1b932a: // 0160:1b932a
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b933b; break; }
    r32[esi] -= 0x00000004;
  case 0x1b933b: // 0160:1b933b
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1b934b; break; }
    if (--r32[ecx])
        { pc = 0x1b932a; break; }
    memoryASet(ds, 0x20c840, 0x01);
    { pc = 0x1b936c; break; }
  case 0x1b934b: // 0160:1b934b
    r32[edi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b935c; break; }
    r32[edi] -= 0x00000004;
  case 0x1b935c: // 0160:1b935c
    if (r16[bx] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1b92ec; break; }
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b934b; break; }
    memoryASet(ds, 0x20c840, 0x02);
  case 0x1b936c: // 0160:1b936c
    yield* sub_1b95f6();
    yield* sub_1b96d5();
    { pc = 0x1b94e8; break; }
  case 0x1b937b: // 0160:1b937b
    r32[esp] += 4; return;
  case 0x1b937c: // 0160:1b937c
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b9473; break; }
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b9473; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    yield* sub_1be5a6();
    r32[esi] = 0x001ef037;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1b60d3();
    r8[al] = 0xc6;
    r8[bl] = 0x8e;
    r8[cl] = 0x0d;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1b60e3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001eeb09;
    r16[bx] = 0;
    r16[cx] = 0x0014;
    memoryASet16(ds, 0x20cebb, 0x0001);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb1f;
    r16[bx] = 0x0002;
    r16[cx] = 0x0017;
    memoryASet16(ds, 0x20cebb, 0x0001);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb38;
    r16[bx] = 0x0004;
    r16[cx] = 0x0015;
    memoryASet16(ds, 0x20cebb, 0x0002);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb4e;
    r16[bx] = 0x0006;
    r16[cx] = 0x0007;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    memoryASet16(ds, 0x20ceb7, 0x0001);
    yield* sub_1be67e();
    r32[esi] = 0x001eeb5f;
    r16[bx] = memoryAGet16(ds, 0x20edd9);
    r16[cx] = 0x0004;
    yield* sub_1be64f();
    r32[esi] = 0x001eeb65;
    r16[bx] = memoryAGet16(ds, 0x20edd7);
    r16[cx] = 0x0004;
    yield* sub_1be64f();
  case 0x1b9473: // 0160:1b9473
    if (memoryAGet16(ds, 0x20e8af) != 0x0002)
        { pc = 0x1b94d4; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    yield* sub_1bd90e();
    memoryASet16(ds, 0x20e8af, 0x0003);
    memoryASet16(ds, 0x20ecad, 0x0000);
    memoryASet16(ds, 0x20ecaf, 0x0000);
    memoryASet16(ds, 0x20ecb7, 0x0000);
    memoryASet16(ds, 0x20e8b5, 0x0000);
    memoryASet16(ds, 0x20e8b3, 0x0000);
    memoryASet16(ds, 0x20ec45, 0x000c);
    memoryASet16(ds, 0x2231d4, 0x0000);
  case 0x1b94d4: // 0160:1b94d4
    yield* sub_1bdc88();
    yield* sub_1b95f6();
    yield* sub_1b96d5();
    yield* sub_1b97b1();
  case 0x1b94e8: // 0160:1b94e8
    if (memoryAGet16(ds, 0x20edd1) & 0xffff)
        { pc = 0x1b95e7; break; }
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b9513; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc2;
    r8[bl] = 0xd4;
    r8[cl] = 0x0c;
    yield* sub_1b60e3();
  case 0x1b9513: // 0160:1b9513
    r32[esi] = 0x001eea16;
    r8[al] = 0xc3;
    r8[bl] = 0x53;
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1b95b1; break; }
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1b9565; break; }
    r8[bl] = 0x51;
    r32[esi] = 0x001eea3d;
    r16[bp] = memoryAGet16(ds, 0x20e887);
    if (!r16[bp])
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea67;
    if (r16[bp] == 0x0001)
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea52;
    if (r16[bp] == 0x0002)
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea7d;
    { pc = 0x1b95b1; break; }
  case 0x1b9565: // 0160:1b9565
    r8[bl] = 0x56;
    r32[esi] = 0x001eea93;
    r32[edi] = 0x0020ea5b;
    r32[ecx] = 0x00000015;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = 0x0020ea5b;
    r16[dx] = memoryAGet16(ds, 0x20e887);
    r16[dx]++;
    r8[dh] = 0;
  case 0x1b9588: // 0160:1b9588
    if (r8s[dl] < signed8(0x0a))
        { pc = 0x1b9594; break; }
    r8[dl] -= 0x0a;
    r8[dh]++;
    { pc = 0x1b9588; break; }
  case 0x1b9594: // 0160:1b9594
    if (!r8[dh])
        { pc = 0x1b95a6; break; }
    r8[dh] += 0x30;
    memoryASet(ds, r32[edi] + 0xb, r8[dh]);
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi] + 0xc, r8[dl]);
    { pc = 0x1b95ac; break; }
  case 0x1b95a6: // 0160:1b95a6
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi] + 0xb, r8[dl]);
  case 0x1b95ac: // 0160:1b95ac
    r32[esi] = 0x0020ea5b;
  case 0x1b95b1: // 0160:1b95b1
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1b95cb; break; }
    r32[esi] = 0x001eeaa0;
    r8[al] = 0xc3;
    r8[bl] = 0xd1;
    { pc = 0x1b95d4; break; }
  case 0x1b95cb: // 0160:1b95cb
    r32[esi] = 0x001eea27;
    r8[al] = 0xc3;
    r8[bl] = 0xd4;
  case 0x1b95d4: // 0160:1b95d4
    yield* sub_1b60a7();
    r32[esi] = 0x001eea36;
    r8[al] = 0xc4;
    r8[bl] = 0x58;
    yield* sub_1b60a7();
  case 0x1b95e7: // 0160:1b95e7
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b9045; break; }
    return;
  }
}
function* sub_1b8ff7() // 0160:1b8ff7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x0000000c;
    r32[edi] = 0x0020edb1;
    r32[ebx] = memoryAGet32(ds, 0x20cee7);
  case 0x1b9007: // 0160:1b9007
    r8[al] = memoryAGet(ds, r32[edi]);
    r32[edi]++;
    memoryASet(ds, r32[ebx], r8[al]);
    r32[ebx]++;
    if (--r32[ecx])
        { pc = 0x1b9007; break; }
    memoryASet32(ds, 0x20cee7, memoryAGet32(ds, 0x20cee7) + 0x0000000c);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b9017() // 0160:1b9017 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b9017; break; }
  case 0x1a81dc: // 0160:1a81dc
    push32(r32[ebp]);
    yield* sub_1a81f3();
    if (memoryAGet16(ds, 0x1f1ccc) != 0x0001)
        { pc = 0x1a81f1; break; }
    yield* sub_1c727c();
  case 0x1a81f1: // 0160:1a81f1
    r32[ebp] = pop32();
    r32[esp] += 4; return;
    // gap 59893 bytes // gap 59893 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 9262 bytes // gap 9262 bytes
  case 0x1b9017: // 0160:1b9017
    memoryASet16(ds, 0x20ed41, 0x0000);
    memoryASet16(ds, 0x20edd1, 0x0000);
    yield* sub_1b9b3d();
    memoryASet16(ds, 0x20d897, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    yield* sub_1b3af9();
  case 0x1b9045: // 0160:1b9045
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    yield* sub_1b531f();
    memoryASet16(ds, 0x20edab, memoryAGet16(ds, 0x20edab) + 1);
    if (memoryAGet16(ds, 0x20edab) != 0x2ee0)
        { pc = 0x1b9071; break; }
    { pc = 0x1a81dc; break; }
  case 0x1b9071: // 0160:1b9071
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b9083; break; }
    memoryASet16(ds, 0x20edab, 0x0000);
  case 0x1b9083: // 0160:1b9083
    memoryASet16(ds, 0x20ecaf, memoryAGet16(ds, 0x20ecaf) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ecaf);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b90b7; break; }
    memoryASet16(ds, 0x20ecad, memoryAGet16(ds, 0x20ecad) + 1);
    memoryASet16(ds, 0x20ecb7, memoryAGet16(ds, 0x20ecb7) + 1);
    if (memoryAGet16(ds, 0x20ecb7) != 0x0003)
        { pc = 0x1b90b7; break; }
    memoryASet16(ds, 0x20ecb7, 0x0000);
  case 0x1b90b7: // 0160:1b90b7
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b937c; break; }
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b90d2; break; }
    r32[esp] += 4; return;
  case 0x1b90d2: // 0160:1b90d2
    memoryASet16(ds, 0x20e8af, 0x0002);
    yield* sub_1b97b1();
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1b9139; break; }
    memoryASet16(ds, 0x20d897, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[esi] = 0x00224866;
    r32[edi] = 0x001ec010;
    r32[ecx] = 0x00000006;
    r32[eax] &= 0x0000ffff;
  case 0x1b911a: // 0160:1b911a
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[bl] != memoryAGet(ds, r32[edi] + r32[eax]))
        { pc = 0x1b9130; break; }
    r32[eax]++;
    if (--r32[ecx])
        { pc = 0x1b911a; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1b9139; break; }
  case 0x1b9130: // 0160:1b9130
    memoryASet16(ds, 0x20e82f, 0x0000);
  case 0x1b9139: // 0160:1b9139
    if (memoryAGet16(ds, 0x2231d4) == 0x0003)
        { pc = 0x1b9160; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc3;
    r8[bl] = 0x51;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0xd1;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
  case 0x1b9160: // 0160:1b9160
    r32[esi] = 0x001ee9f9;
    r8[al] = 0xc2;
    r8[bl] = 0xd4;
    yield* sub_1b60a7();
    r32[esi] = 0x001eea10;
    yield* sub_1b60d3();
    r32[esi] = 0x001eea09;
    yield* sub_1b60d3();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0029);
    yield* sub_1b49ae();
    yield* sub_1b4b5f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b95e7; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b95e7; break; }
    memoryASet16(ds, 0x20d897, 0x0000);
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b9291; break; }
    yield* sub_1bdfd5();
    memoryASet16(ds, 0x20d897, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e887);
    r16[ax]++;
    if (r16[ax] != memoryAGet16(ds, 0x20e90d))
        { pc = 0x1b9227; break; }
    memoryASet16(ds, 0x20e8af, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20e9b3);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000006;
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    { pc = 0x1b937b; break; }
  case 0x1b9227: // 0160:1b9227
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb66;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b5747();
    yield* sub_1bd478();
    memoryASet16(ds, 0x20e8bb, 0x0003);
    memoryASet16(ds, 0x20ec3d, 0x0130);
    memoryASet16(ds, 0x20ec3f, 0x00ee);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b9291: // 0160:1b9291
    memoryASet16(ds, 0x20e8af, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20e9b3);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b92ba; break; }
    r32[esi] -= 0x00000004;
  case 0x1b92ba: // 0160:1b92ba
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r16[ax] = memoryAGet16(ds, 0x20e887);
    if (r16[ax] == memoryAGet16(ds, 0x20e90d))
        { pc = 0x1b937b; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[bx] = r16[ax];
  case 0x1b92ec: // 0160:1b92ec
    r16[ax]--;
    r16[bx]++;
    r16[ax] &= 0x000f;
    r16[bx] &= 0x000f;
    memoryASet(ds, 0x20c840, 0x01);
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r32[ecx] &= 0x0000ffff;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1b936c; break; }
    r16[dx] = r16[cx];
    r32[esi] = 0x0020e8db;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b9328; break; }
    r32[esi] = 0x0020e8bf;
  case 0x1b9328: // 0160:1b9328
    r32[edi] = r32[esi];
  case 0x1b932a: // 0160:1b932a
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b933b; break; }
    r32[esi] -= 0x00000004;
  case 0x1b933b: // 0160:1b933b
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1b934b; break; }
    if (--r32[ecx])
        { pc = 0x1b932a; break; }
    memoryASet(ds, 0x20c840, 0x01);
    { pc = 0x1b936c; break; }
  case 0x1b934b: // 0160:1b934b
    r32[edi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b935c; break; }
    r32[edi] -= 0x00000004;
  case 0x1b935c: // 0160:1b935c
    if (r16[bx] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1b92ec; break; }
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b934b; break; }
    memoryASet(ds, 0x20c840, 0x02);
  case 0x1b936c: // 0160:1b936c
    yield* sub_1b95f6();
    yield* sub_1b96d5();
    { pc = 0x1b94e8; break; }
  case 0x1b937b: // 0160:1b937b
    r32[esp] += 4; return;
  case 0x1b937c: // 0160:1b937c
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b9473; break; }
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b9473; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    yield* sub_1be5a6();
    r32[esi] = 0x001ef037;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1b60d3();
    r8[al] = 0xc6;
    r8[bl] = 0x8e;
    r8[cl] = 0x0d;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1b60e3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001eeb09;
    r16[bx] = 0;
    r16[cx] = 0x0014;
    memoryASet16(ds, 0x20cebb, 0x0001);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb1f;
    r16[bx] = 0x0002;
    r16[cx] = 0x0017;
    memoryASet16(ds, 0x20cebb, 0x0001);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb38;
    r16[bx] = 0x0004;
    r16[cx] = 0x0015;
    memoryASet16(ds, 0x20cebb, 0x0002);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb4e;
    r16[bx] = 0x0006;
    r16[cx] = 0x0007;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    memoryASet16(ds, 0x20ceb7, 0x0001);
    yield* sub_1be67e();
    r32[esi] = 0x001eeb5f;
    r16[bx] = memoryAGet16(ds, 0x20edd9);
    r16[cx] = 0x0004;
    yield* sub_1be64f();
    r32[esi] = 0x001eeb65;
    r16[bx] = memoryAGet16(ds, 0x20edd7);
    r16[cx] = 0x0004;
    yield* sub_1be64f();
  case 0x1b9473: // 0160:1b9473
    if (memoryAGet16(ds, 0x20e8af) != 0x0002)
        { pc = 0x1b94d4; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    yield* sub_1bd90e();
    memoryASet16(ds, 0x20e8af, 0x0003);
    memoryASet16(ds, 0x20ecad, 0x0000);
    memoryASet16(ds, 0x20ecaf, 0x0000);
    memoryASet16(ds, 0x20ecb7, 0x0000);
    memoryASet16(ds, 0x20e8b5, 0x0000);
    memoryASet16(ds, 0x20e8b3, 0x0000);
    memoryASet16(ds, 0x20ec45, 0x000c);
    memoryASet16(ds, 0x2231d4, 0x0000);
  case 0x1b94d4: // 0160:1b94d4
    yield* sub_1bdc88();
    yield* sub_1b95f6();
    yield* sub_1b96d5();
    yield* sub_1b97b1();
  case 0x1b94e8: // 0160:1b94e8
    if (memoryAGet16(ds, 0x20edd1) & 0xffff)
        { pc = 0x1b95e7; break; }
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b9513; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc2;
    r8[bl] = 0xd4;
    r8[cl] = 0x0c;
    yield* sub_1b60e3();
  case 0x1b9513: // 0160:1b9513
    r32[esi] = 0x001eea16;
    r8[al] = 0xc3;
    r8[bl] = 0x53;
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1b95b1; break; }
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1b9565; break; }
    r8[bl] = 0x51;
    r32[esi] = 0x001eea3d;
    r16[bp] = memoryAGet16(ds, 0x20e887);
    if (!r16[bp])
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea67;
    if (r16[bp] == 0x0001)
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea52;
    if (r16[bp] == 0x0002)
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea7d;
    { pc = 0x1b95b1; break; }
  case 0x1b9565: // 0160:1b9565
    r8[bl] = 0x56;
    r32[esi] = 0x001eea93;
    r32[edi] = 0x0020ea5b;
    r32[ecx] = 0x00000015;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = 0x0020ea5b;
    r16[dx] = memoryAGet16(ds, 0x20e887);
    r16[dx]++;
    r8[dh] = 0;
  case 0x1b9588: // 0160:1b9588
    if (r8s[dl] < signed8(0x0a))
        { pc = 0x1b9594; break; }
    r8[dl] -= 0x0a;
    r8[dh]++;
    { pc = 0x1b9588; break; }
  case 0x1b9594: // 0160:1b9594
    if (!r8[dh])
        { pc = 0x1b95a6; break; }
    r8[dh] += 0x30;
    memoryASet(ds, r32[edi] + 0xb, r8[dh]);
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi] + 0xc, r8[dl]);
    { pc = 0x1b95ac; break; }
  case 0x1b95a6: // 0160:1b95a6
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi] + 0xb, r8[dl]);
  case 0x1b95ac: // 0160:1b95ac
    r32[esi] = 0x0020ea5b;
  case 0x1b95b1: // 0160:1b95b1
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1b95cb; break; }
    r32[esi] = 0x001eeaa0;
    r8[al] = 0xc3;
    r8[bl] = 0xd1;
    { pc = 0x1b95d4; break; }
  case 0x1b95cb: // 0160:1b95cb
    r32[esi] = 0x001eea27;
    r8[al] = 0xc3;
    r8[bl] = 0xd4;
  case 0x1b95d4: // 0160:1b95d4
    yield* sub_1b60a7();
    r32[esi] = 0x001eea36;
    r8[al] = 0xc4;
    r8[bl] = 0x58;
    yield* sub_1b60a7();
  case 0x1b95e7: // 0160:1b95e7
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b9045; break; }
    return;
  }
}
function* sub_1b9020() // 0160:1b9020 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1b9020; break; }
  case 0x1a81dc: // 0160:1a81dc
    push32(r32[ebp]);
    yield* sub_1a81f3();
    if (memoryAGet16(ds, 0x1f1ccc) != 0x0001)
        { pc = 0x1a81f1; break; }
    yield* sub_1c727c();
  case 0x1a81f1: // 0160:1a81f1
    r32[ebp] = pop32();
    r32[esp] += 4; return;
    // gap 59893 bytes // gap 59893 bytes
  case 0x1b6be8: // 0160:1b6be8
    r32[esp] += 4; return;
    // gap 9271 bytes // gap 9271 bytes
  case 0x1b9020: // 0160:1b9020
    memoryASet16(ds, 0x20edd1, 0x0000);
    yield* sub_1b9b3d();
    memoryASet16(ds, 0x20d897, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    yield* sub_1b3af9();
  case 0x1b9045: // 0160:1b9045
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1b6be8; break; }
    yield* sub_1b531f();
    memoryASet16(ds, 0x20edab, memoryAGet16(ds, 0x20edab) + 1);
    if (memoryAGet16(ds, 0x20edab) != 0x2ee0)
        { pc = 0x1b9071; break; }
    { pc = 0x1a81dc; break; }
  case 0x1b9071: // 0160:1b9071
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1b9083; break; }
    memoryASet16(ds, 0x20edab, 0x0000);
  case 0x1b9083: // 0160:1b9083
    memoryASet16(ds, 0x20ecaf, memoryAGet16(ds, 0x20ecaf) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ecaf);
    r16[ax] &= 0x003f;
    if (r16[ax])
        { pc = 0x1b90b7; break; }
    memoryASet16(ds, 0x20ecad, memoryAGet16(ds, 0x20ecad) + 1);
    memoryASet16(ds, 0x20ecb7, memoryAGet16(ds, 0x20ecb7) + 1);
    if (memoryAGet16(ds, 0x20ecb7) != 0x0003)
        { pc = 0x1b90b7; break; }
    memoryASet16(ds, 0x20ecb7, 0x0000);
  case 0x1b90b7: // 0160:1b90b7
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b937c; break; }
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b90d2; break; }
    r32[esp] += 4; return;
  case 0x1b90d2: // 0160:1b90d2
    memoryASet16(ds, 0x20e8af, 0x0002);
    yield* sub_1b97b1();
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1b9139; break; }
    memoryASet16(ds, 0x20d897, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[esi] = 0x00224866;
    r32[edi] = 0x001ec010;
    r32[ecx] = 0x00000006;
    r32[eax] &= 0x0000ffff;
  case 0x1b911a: // 0160:1b911a
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[bl] != memoryAGet(ds, r32[edi] + r32[eax]))
        { pc = 0x1b9130; break; }
    r32[eax]++;
    if (--r32[ecx])
        { pc = 0x1b911a; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1b9139; break; }
  case 0x1b9130: // 0160:1b9130
    memoryASet16(ds, 0x20e82f, 0x0000);
  case 0x1b9139: // 0160:1b9139
    if (memoryAGet16(ds, 0x2231d4) == 0x0003)
        { pc = 0x1b9160; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc3;
    r8[bl] = 0x51;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0xd1;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
  case 0x1b9160: // 0160:1b9160
    r32[esi] = 0x001ee9f9;
    r8[al] = 0xc2;
    r8[bl] = 0xd4;
    yield* sub_1b60a7();
    r32[esi] = 0x001eea10;
    yield* sub_1b60d3();
    r32[esi] = 0x001eea09;
    yield* sub_1b60d3();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0029);
    yield* sub_1b49ae();
    yield* sub_1b4b5f();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1b95e7; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b95e7; break; }
    memoryASet16(ds, 0x20d897, 0x0000);
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b9291; break; }
    yield* sub_1bdfd5();
    memoryASet16(ds, 0x20d897, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e887);
    r16[ax]++;
    if (r16[ax] != memoryAGet16(ds, 0x20e90d))
        { pc = 0x1b9227; break; }
    memoryASet16(ds, 0x20e8af, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20e9b3);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000006;
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    { pc = 0x1b937b; break; }
  case 0x1b9227: // 0160:1b9227
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb66;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b5747();
    yield* sub_1bd478();
    memoryASet16(ds, 0x20e8bb, 0x0003);
    memoryASet16(ds, 0x20ec3d, 0x0130);
    memoryASet16(ds, 0x20ec3f, 0x00ee);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1b9291: // 0160:1b9291
    memoryASet16(ds, 0x20e8af, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20e9b3);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b92ba; break; }
    r32[esi] -= 0x00000004;
  case 0x1b92ba: // 0160:1b92ba
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r16[ax] = memoryAGet16(ds, 0x20e887);
    if (r16[ax] == memoryAGet16(ds, 0x20e90d))
        { pc = 0x1b937b; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[bx] = r16[ax];
  case 0x1b92ec: // 0160:1b92ec
    r16[ax]--;
    r16[bx]++;
    r16[ax] &= 0x000f;
    r16[bx] &= 0x000f;
    memoryASet(ds, 0x20c840, 0x01);
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r32[ecx] &= 0x0000ffff;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1b936c; break; }
    r16[dx] = r16[cx];
    r32[esi] = 0x0020e8db;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b9328; break; }
    r32[esi] = 0x0020e8bf;
  case 0x1b9328: // 0160:1b9328
    r32[edi] = r32[esi];
  case 0x1b932a: // 0160:1b932a
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b933b; break; }
    r32[esi] -= 0x00000004;
  case 0x1b933b: // 0160:1b933b
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1b934b; break; }
    if (--r32[ecx])
        { pc = 0x1b932a; break; }
    memoryASet(ds, 0x20c840, 0x01);
    { pc = 0x1b936c; break; }
  case 0x1b934b: // 0160:1b934b
    r32[edi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b935c; break; }
    r32[edi] -= 0x00000004;
  case 0x1b935c: // 0160:1b935c
    if (r16[bx] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1b92ec; break; }
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b934b; break; }
    memoryASet(ds, 0x20c840, 0x02);
  case 0x1b936c: // 0160:1b936c
    yield* sub_1b95f6();
    yield* sub_1b96d5();
    { pc = 0x1b94e8; break; }
  case 0x1b937b: // 0160:1b937b
    r32[esp] += 4; return;
  case 0x1b937c: // 0160:1b937c
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b9473; break; }
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b9473; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    yield* sub_1be5a6();
    r32[esi] = 0x001ef037;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1b60d3();
    r8[al] = 0xc6;
    r8[bl] = 0x8e;
    r8[cl] = 0x0d;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1b60e3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001eeb09;
    r16[bx] = 0;
    r16[cx] = 0x0014;
    memoryASet16(ds, 0x20cebb, 0x0001);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb1f;
    r16[bx] = 0x0002;
    r16[cx] = 0x0017;
    memoryASet16(ds, 0x20cebb, 0x0001);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb38;
    r16[bx] = 0x0004;
    r16[cx] = 0x0015;
    memoryASet16(ds, 0x20cebb, 0x0002);
    yield* sub_1be66c();
    r32[esi] = 0x001eeb4e;
    r16[bx] = 0x0006;
    r16[cx] = 0x0007;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    memoryASet16(ds, 0x20ceb7, 0x0001);
    yield* sub_1be67e();
    r32[esi] = 0x001eeb5f;
    r16[bx] = memoryAGet16(ds, 0x20edd9);
    r16[cx] = 0x0004;
    yield* sub_1be64f();
    r32[esi] = 0x001eeb65;
    r16[bx] = memoryAGet16(ds, 0x20edd7);
    r16[cx] = 0x0004;
    yield* sub_1be64f();
  case 0x1b9473: // 0160:1b9473
    if (memoryAGet16(ds, 0x20e8af) != 0x0002)
        { pc = 0x1b94d4; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    yield* sub_1bd90e();
    memoryASet16(ds, 0x20e8af, 0x0003);
    memoryASet16(ds, 0x20ecad, 0x0000);
    memoryASet16(ds, 0x20ecaf, 0x0000);
    memoryASet16(ds, 0x20ecb7, 0x0000);
    memoryASet16(ds, 0x20e8b5, 0x0000);
    memoryASet16(ds, 0x20e8b3, 0x0000);
    memoryASet16(ds, 0x20ec45, 0x000c);
    memoryASet16(ds, 0x2231d4, 0x0000);
  case 0x1b94d4: // 0160:1b94d4
    yield* sub_1bdc88();
    yield* sub_1b95f6();
    yield* sub_1b96d5();
    yield* sub_1b97b1();
  case 0x1b94e8: // 0160:1b94e8
    if (memoryAGet16(ds, 0x20edd1) & 0xffff)
        { pc = 0x1b95e7; break; }
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1b9513; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc2;
    r8[bl] = 0xd4;
    r8[cl] = 0x0c;
    yield* sub_1b60e3();
  case 0x1b9513: // 0160:1b9513
    r32[esi] = 0x001eea16;
    r8[al] = 0xc3;
    r8[bl] = 0x53;
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1b95b1; break; }
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1b9565; break; }
    r8[bl] = 0x51;
    r32[esi] = 0x001eea3d;
    r16[bp] = memoryAGet16(ds, 0x20e887);
    if (!r16[bp])
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea67;
    if (r16[bp] == 0x0001)
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea52;
    if (r16[bp] == 0x0002)
        { pc = 0x1b95b1; break; }
    r32[esi] = 0x001eea7d;
    { pc = 0x1b95b1; break; }
  case 0x1b9565: // 0160:1b9565
    r8[bl] = 0x56;
    r32[esi] = 0x001eea93;
    r32[edi] = 0x0020ea5b;
    r32[ecx] = 0x00000015;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = 0x0020ea5b;
    r16[dx] = memoryAGet16(ds, 0x20e887);
    r16[dx]++;
    r8[dh] = 0;
  case 0x1b9588: // 0160:1b9588
    if (r8s[dl] < signed8(0x0a))
        { pc = 0x1b9594; break; }
    r8[dl] -= 0x0a;
    r8[dh]++;
    { pc = 0x1b9588; break; }
  case 0x1b9594: // 0160:1b9594
    if (!r8[dh])
        { pc = 0x1b95a6; break; }
    r8[dh] += 0x30;
    memoryASet(ds, r32[edi] + 0xb, r8[dh]);
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi] + 0xc, r8[dl]);
    { pc = 0x1b95ac; break; }
  case 0x1b95a6: // 0160:1b95a6
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi] + 0xb, r8[dl]);
  case 0x1b95ac: // 0160:1b95ac
    r32[esi] = 0x0020ea5b;
  case 0x1b95b1: // 0160:1b95b1
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1b95cb; break; }
    r32[esi] = 0x001eeaa0;
    r8[al] = 0xc3;
    r8[bl] = 0xd1;
    { pc = 0x1b95d4; break; }
  case 0x1b95cb: // 0160:1b95cb
    r32[esi] = 0x001eea27;
    r8[al] = 0xc3;
    r8[bl] = 0xd4;
  case 0x1b95d4: // 0160:1b95d4
    yield* sub_1b60a7();
    r32[esi] = 0x001eea36;
    r8[al] = 0xc4;
    r8[bl] = 0x58;
    yield* sub_1b60a7();
  case 0x1b95e7: // 0160:1b95e7
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b9045; break; }
    return;
  }
}
function* sub_1b95f6() // 0160:1b95f6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e833, 0x0000);
    memoryASet16(ds, 0x20e835, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8a9);
    if (r16[ax] != memoryAGet16(ds, 0x20e889))
        { pc = 0x1b964f; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    if (r8[al] != 0x80)
        { pc = 0x1b9650; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1b9650; break; }
    r8[al] = 0x88;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20e831, 0x0001);
    memoryASet16(ds, 0x2231d4, 0x0000);
  case 0x1b964f: // 0160:1b964f
    r32[esp] += 4; return;
  case 0x1b9650: // 0160:1b9650
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1b9664; break; }
    r32[edi] = 0x0020e833;
    r16[ax] = 0xffff;
    { pc = 0x1b9676; break; }
  case 0x1b9664: // 0160:1b9664
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1b964f; break; }
    r32[edi] = 0x0020e835;
    r16[ax] = 0x0001;
  case 0x1b9676: // 0160:1b9676
    memoryASet16(ds, 0x20e8af, 0x0001);
  case 0x1b967f: // 0160:1b967f
    memoryASet16(ds, 0x20e8ad, memoryAGet16(ds, 0x20e8ad) + r16[ax]);
    memoryASet16(ds, r32[edi], memoryAGet16(ds, r32[edi]) + 1);
    memoryASet16(ds, 0x20e8ad, memoryAGet16(ds, 0x20e8ad) & 0x000f);
    r16[bx] = memoryAGet16(ds, 0x20e90d);
    if (r16[bx] == 0x0001)
        { pc = 0x1b964f; break; }
    r32[esi] = 0x0020e8db;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b96b3; break; }
    r32[esi] = 0x0020e8bf;
  case 0x1b96b3: // 0160:1b96b3
    r32[esi] += 0x00000006;
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b96c4; break; }
    r32[esi] -= 0x00000004;
  case 0x1b96c4: // 0160:1b96c4
    r16[cx] = memoryAGet16(ds, r32[esi]);
    if (r16[cx] == memoryAGet16(ds, 0x20e8ad))
        { pc = 0x1b967f; break; }
    r16[bx]--;
    if (r16[bx])
        { pc = 0x1b96b3; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1b96d5() // 0160:1b96d5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20e833);
    if (!r16[cx])
        { pc = 0x1b9710; break; }
    memoryASet16(ds, 0x20e8ab, 0x0006);
    r32[ecx] &= 0x0000ffff;
  case 0x1b96f0: // 0160:1b96f0
    memoryASet16(ds, 0x20e8a9, memoryAGet16(ds, 0x20e8a9) + 0x0048);
    if (memoryAGet16(ds, 0x20e8a9) != 0x0358)
        { pc = 0x1b970c; break; }
    memoryASet16(ds, 0x20e8a9, 0xfed8);
  case 0x1b970c: // 0160:1b970c
    if (--r32[ecx])
        { pc = 0x1b96f0; break; }
    { pc = 0x1b9749; break; }
  case 0x1b9710: // 0160:1b9710
    r16[cx] = memoryAGet16(ds, 0x20e835);
    if (!r16[cx])
        { pc = 0x1b9749; break; }
    memoryASet16(ds, 0x20e8ab, 0xfffa);
    r32[ecx] &= 0x0000ffff;
  case 0x1b972b: // 0160:1b972b
    memoryASet16(ds, 0x20e8a9, memoryAGet16(ds, 0x20e8a9) + 0xffb8);
    if (memoryAGet16(ds, 0x20e8a9) != 0xfe90)
        { pc = 0x1b9747; break; }
    memoryASet16(ds, 0x20e8a9, 0x0310);
  case 0x1b9747: // 0160:1b9747
    if (--r32[ecx])
        { pc = 0x1b972b; break; }
  case 0x1b9749: // 0160:1b9749
    r32[esi] = 0x0020e889;
    r16[ax] = memoryAGet16(ds, 0x20e8a9);
    if (r16[ax] == memoryAGet16(ds, r32[esi]))
        { pc = 0x1b9789; break; }
    r32[ecx] = 0x00000010;
  case 0x1b975e: // 0160:1b975e
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r16[bx] += memoryAGet16(ds, 0x20e8ab);
    if (r16[bx] != 0x0358)
        { pc = 0x1b9775; break; }
    r16[bx] = 0xfed8;
    { pc = 0x1b9780; break; }
  case 0x1b9775: // 0160:1b9775
    if (r16[bx] != 0xfe90)
        { pc = 0x1b9780; break; }
    r16[bx] = 0x0310;
  case 0x1b9780: // 0160:1b9780
    memoryASet16(ds, r32[esi], r16[bx]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b975e; break; }
  case 0x1b9788: // 0160:1b9788
    r32[esp] += 4; return;
  case 0x1b9789: // 0160:1b9789
    r16[ax] = memoryAGet16(ds, 0x20e8af);
    if (r16[ax] == 0x0003)
        { pc = 0x1b9788; break; }
    memoryASet16(ds, 0x20e8af, 0x0002);
    memoryASet16(ds, 0x20e8b3, 0x0000);
    memoryASet16(ds, 0x20e8b5, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1b97b1() // 0160:1b97b1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20e90d) > 0x0001)
        { pc = 0x1b9891; break; }
    if (memoryAGet16(ds, 0x20e8af) != 0x0003)
        { pc = 0x1b9891; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[ax] <<= 2;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] = 0x002247a6;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    if (memoryAGet16(ds, 0x20edd1) == 0x0001)
        { pc = 0x1b983d; break; }
    r16[ax] = memoryAGet16(ds, 0x20ecb5);
    if (!r16[ax])
        { pc = 0x1b9832; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b9827; break; }
    if (r16[ax] != 0x0002)
        { pc = 0x1b9891; break; }
    if (!r16[dx])
        { pc = 0x1b9877; break; }
    { pc = 0x1b9891; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b9827: // 0160:1b9827
    if (r16[cx] == 0x0019)
        { pc = 0x1b9877; break; }
    { pc = 0x1b9891; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b9832: // 0160:1b9832
    if (r16[bx] == 0x0019)
        { pc = 0x1b9877; break; }
    { pc = 0x1b9891; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b983d: // 0160:1b983d
    if (r16[bx] != 0x0019)
        { pc = 0x1b9850; break; }
    r16[ax] = 0x01a0;
    r16[bx] = 0x0110;
    yield* sub_1b9afb();
  case 0x1b9850: // 0160:1b9850
    if (r16[cx] != 0x0019)
        { pc = 0x1b9863; break; }
    r16[ax] = 0x01a0;
    r16[bx] = 0x012a;
    yield* sub_1b9afb();
  case 0x1b9863: // 0160:1b9863
    if (r16[dx])
        { pc = 0x1b9891; break; }
    r16[ax] = 0x01a0;
    r16[bx] = 0x0144;
    yield* sub_1b9afb();
    { pc = 0x1b9891; break; }
  case 0x1b9877: // 0160:1b9877
    r16[ax] = 0x0090;
    r16[bx] = 0x00e7;
    yield* sub_1b9afb();
    r16[ax] = 0x00d9;
    r16[bx] = 0x00e7;
    yield* sub_1b9afb();
  case 0x1b9891: // 0160:1b9891
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1b98bd; break; }
    yield* sub_1bd930();
    memoryASet16(ds, 0x20ceb1, 0x0038);
    memoryASet16(ds, 0x20ceb7, 0x003b);
    r32[esi] = 0x001ef318;
    yield* sub_1bd96a();
  case 0x1b98bd: // 0160:1b98bd
    if (memoryAGet16(ds, 0x20e8af) != 0x0003)
        { pc = 0x1b9954; break; }
    r16[ax] = 0x00a8;
    r16[bx] = 0x0108;
    r16[cx] = memoryAGet16(ds, 0x20e8ad);
    r16[cx] += 0x0012;
    if (memoryAGet16(ds, 0x20edd1) & 0xffff)
        { pc = 0x1b9938; break; }
    if (memoryAGet16(ds, 0x20ed41) & 0xffff)
        { pc = 0x1b9938; break; }
    if (!(memoryAGet16(ds, 0x20ecb3) & 0xffff))
        { pc = 0x1b9938; break; }
    if (memoryAGet16(ds, 0x20e90d) != 0x0001)
        { pc = 0x1b9922; break; }
    if (memoryAGet16(ds, 0x20ecb5) > 0x0001)
        { pc = 0x1b9922; break; }
    r16[bp] = memoryAGet16(ds, 0x20ecad);
    r16[bp] &= 0x0001;
    if (!r16[bp])
        { pc = 0x1b9938; break; }
    { pc = 0x1b992d; break; }
  case 0x1b9922: // 0160:1b9922
    if (!(memoryAGet16(ds, 0x20ecb7) & 0xffff))
        { pc = 0x1b9938; break; }
  case 0x1b992d: // 0160:1b992d
    r16[cx] = 0x002c;
    yield* sub_1b9b10();
    { pc = 0x1b994b; break; }
  case 0x1b9938: // 0160:1b9938
    r16[bp] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, 0x20cec3, r16[bp]);
    yield* sub_1bd51f();
  case 0x1b994b: // 0160:1b994b
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
  case 0x1b9954: // 0160:1b9954
    r32[esi] = 0x0020e889;
    memoryASet16(ds, 0x20e8b9, 0x0000);
  case 0x1b9962: // 0160:1b9962
    r16[ax] = 0x00a6;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    r16[bx] += 0x0008;
    if (r16s[bx] < signed16(0x0040))
        { pc = 0x1b9a82; break; }
    if (r16[bx] >= 0x0158)
        { pc = 0x1b9a82; break; }
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    if (memoryAGet16(ds, 0x20ed41) & 0xffff)
        { pc = 0x1b99ba; break; }
    r16[bp] = memoryAGet16(ds, 0x20e90d);
    r32[edi] = 0x0020e8db;
  case 0x1b99a3: // 0160:1b99a3
    r32[edi] += 0x00000006;
    if (r16[cx] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1b99b1; break; }
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b99a3; break; }
    { pc = 0x1b99da; break; }
  case 0x1b99b1: // 0160:1b99b1
    r16[cx] = 0x0028;
    { pc = 0x1b9a74; break; }
  case 0x1b99ba: // 0160:1b99ba
    r16[bp] = 0x0010;
    r32[edi] = 0x0020e8c1;
  case 0x1b99c3: // 0160:1b99c3
    if (r16[cx] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1b99d1; break; }
    r32[edi] += 0x00000002;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b99c3; break; }
    { pc = 0x1b99da; break; }
  case 0x1b99d1: // 0160:1b99d1
    r16[cx] = 0x0028;
    { pc = 0x1b9a74; break; }
  case 0x1b99da: // 0160:1b99da
    r16[bp] = r16[cx];
    r16[cx]++;
    if (r16[bp] != memoryAGet16(ds, 0x20e8ad))
        { pc = 0x1b9a51; break; }
    if (memoryAGet16(ds, 0x20e8af) != 0x0003)
        { pc = 0x1b9a51; break; }
    memoryASet16(ds, 0x20e8b5, memoryAGet16(ds, 0x20e8b5) + 1);
    memoryASet16(ds, 0x20e8b5, memoryAGet16(ds, 0x20e8b5) & 0x000f);
    if (memoryAGet16(ds, 0x20e8b5))
        { pc = 0x1b9a12; break; }
    memoryASet16(ds, 0x20e8b3, memoryAGet16(ds, 0x20e8b3) + 1);
    memoryASet16(ds, 0x20e8b3, memoryAGet16(ds, 0x20e8b3) & 0x0001);
  case 0x1b9a12: // 0160:1b9a12
    r16[cx] = memoryAGet16(ds, 0x20e8b3);
    r16[cx] += 0x0022;
    if (memoryAGet16(ds, 0x20ec45) & 0xffff)
        { pc = 0x1b9a2a; break; }
    { pc = 0x1b9a48; break; }
  case 0x1b9a2a: // 0160:1b9a2a
    r16[di] = memoryAGet16(ds, 0x20e8b5);
    r16[di] &= 0x000f;
    if (r16[di])
        { pc = 0x1b9a3e; break; }
    memoryASet16(ds, 0x20ec45, memoryAGet16(ds, 0x20ec45) - 1);
  case 0x1b9a3e: // 0160:1b9a3e
    if (memoryAGet16(ds, 0x20ec45) >= 0x000a)
        { pc = 0x1b9a51; break; }
  case 0x1b9a48: // 0160:1b9a48
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    r16[cx]++;
  case 0x1b9a51: // 0160:1b9a51
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1b9a74; break; }
    if (r16[bp] != memoryAGet16(ds, 0x20e8ad))
        { pc = 0x1b9a74; break; }
    if (memoryAGet16(ds, 0x20edd1) & 0xffff)
        { pc = 0x1b9a74; break; }
    r16[cx] = 0x0028;
  case 0x1b9a74: // 0160:1b9a74
    r16[dx] = 0x0007;
    yield* sub_1bd50f();
    yield* sub_1bd4ff();
  case 0x1b9a82: // 0160:1b9a82
    memoryASet16(ds, 0x20e8b9, memoryAGet16(ds, 0x20e8b9) + 1);
    if (memoryAGet16(ds, 0x20e8b9) != 0x0010)
        { pc = 0x1b9962; break; }
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b9aa3; break; }
    r32[esp] += 4; return;
  case 0x1b9aa3: // 0160:1b9aa3
    r16[ax] = 0x0134;
    r16[bx] = 0x0120;
    r16[cx] = 0x0011;
    r16[dx] = 0;
    r16[bp] = memoryAGet16(ds, 0x20e831);
    if (!r16[bp])
        { pc = 0x1b9afa; break; }
    r16[cx] = memoryAGet16(ds, 0x20e8ad);
    r16[cx]++;
    yield* sub_1bd7dd();
    r16[ax] = 0x0134;
    r16[bx] = 0x0150;
    r16[cx] = memoryAGet16(ds, 0x20e8ad);
    r16[cx] += 0x0012;
    r16[bp] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, 0x20cec3, r16[bp]);
    yield* sub_1bd51f();
    r16[dx] = 0;
    yield* sub_1bd7dd();
  case 0x1b9afa: // 0160:1b9afa
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1b9afb() // 0160:1b9afb +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r16[dx] = 0;
    r16[cx] = 0x002d;
    yield* sub_1bd7dd();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1b9b10() // 0160:1b9b10 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[ebp]);
    r16[ax] -= 0x0008;
    r16[bp] = 0x000c;
    r32[ecx] = 0x0020ed53;
    r8[dl] = memoryAGet(ds, r32[ecx] + 0x5);
    if (r8[dl] == 0x20)
        { pc = 0x1b9b37; break; }
    r16[bp] = 0x0003;
    r8[dl] = memoryAGet(ds, r32[ecx] + 0x6);
    if (r8[dl] != 0x20)
        { pc = 0x1b9b37; break; }
    r16[bp] = 0x0008;
  case 0x1b9b37: // 0160:1b9b37
    r16[ax] += r16[bp];
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b9b3d() // 0160:1b9b3d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20edab, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b9b8d; break; }
    r32[edx] = 0x001ecb8e;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    { pc = 0x1b9bb0; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b9b8d: // 0160:1b9b8d
    r32[edx] = 0x001ecb66;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
  case 0x1b9bb0: // 0160:1b9bb0
    yield* sub_1b5747();
    yield* sub_1bd478();
    r32[esi] = 0x0020e889;
    r16[ax] = 0xfed8;
    r32[ecx] = 0x00000010;
  case 0x1b9bc8: // 0160:1b9bc8
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    r16[ax] += 0x0048;
    if (--r32[ecx])
        { pc = 0x1b9bc8; break; }
    memoryASet16(ds, 0x20e8a9, 0xfed8);
    memoryASet16(ds, 0x20e8ad, 0x0007);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e9a3, 0x0000);
    r32[esi] = 0x0020e8e1;
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    r32[ecx] = 0x00000004;
  case 0x1b9c08: // 0160:1b9c08
    memoryASet16(ds, r32[esi], 0x00ff);
    memoryASet32(ds, r32[esi] + 0x2, 0x00000000);
    r32[esi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1b9c08; break; }
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1b9c3e; break; }
    r32[esi] = 0x0020e8c1;
    memoryASet32(ds, 0x20e9b3, r32[esi]);
    r32[ecx] = 0x00000010;
  case 0x1b9c34: // 0160:1b9c34
    memoryASet16(ds, r32[esi], 0x00ff);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1b9c34; break; }
  case 0x1b9c3e: // 0160:1b9c3e
    memoryASet16(ds, 0x20e887, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ecad, 0x0000);
    memoryASet16(ds, 0x20ecaf, 0x0000);
    memoryASet16(ds, 0x20ecb7, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x0130);
    memoryASet16(ds, 0x20ec3f, 0x00ee);
    memoryASet16(ds, 0x20e8af, 0x0002);
    if (!(memoryAGet16(ds, 0x20edd1) & 0xffff))
        { pc = 0x1b9c96; break; }
    yield* sub_1be796();
  case 0x1b9c96: // 0160:1b9c96
    yield* sub_1bd8b7();
    yield* sub_1b4f0e();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b9ca1() // 0160:1b9ca1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b191a();
    r8[al] = 0x81;
    yield* sub_1b18a6();
    yield* sub_1b4bc9();
    yield* sub_1bd3c8();
    yield* sub_1b56fa();
    yield* sub_1bd478();
    r32[edx] = 0x001ece20;
    r32[edi] = 0x000a0000;
    yield* sub_1b5205();
    r32[edi] = 0x000a4800;
    yield* sub_1b521d();
    r32[edi] = 0x000a9000;
    yield* sub_1b521d();
    r32[edx] = 0x001ece32;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r32[esi] = 0x0020e9c1;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    yield* sub_1bd346();
    memoryASet16(ds, 0x20ceb7, 0x00c8);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e9c5, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e9c3);
    r16[ax] <<= 1;
    r32[esi] = 0x001ef2c8;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20e9c7, r16[ax]);
    memoryASet16(ds, 0x20e887, 0x0000);
    if (!(memoryAGet16(ds, 0x20e9c3) & 0xffff))
        { pc = 0x1b9d83; break; }
    memoryASet16(ds, 0x20e887, 0x0005);
    if (memoryAGet16(ds, 0x20e9c3) == 0x0001)
        { pc = 0x1b9d83; break; }
    memoryASet16(ds, 0x20e887, 0x0008);
  case 0x1b9d83: // 0160:1b9d83
    yield* sub_1b4f0e();
  case 0x1b9d88: // 0160:1b9d88
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1b9da0; break; }
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
  case 0x1b9da0: // 0160:1b9da0
    yield* sub_1b9dce();
    if (signed16(memoryAGet16(ds, 0x20e887)) <= signed16(0x0028))
        { pc = 0x1b9dc2; break; }
    if (memoryAGet(ds, 0x20c840) != 0x80)
        { pc = 0x1b9dc2; break; }
    if (memoryAGet(ds, 0x20e837) == 0x80)
        { pc = 0x1b9dc2; break; }
    r32[esp] += 4; return;
  case 0x1b9dc2: // 0160:1b9dc2
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1b9d88; break; }
    return;
  }
}
function* sub_1b9dce() // 0160:1b9dce +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x00f8;
    r16[bx] = 0x00c0;
    r16[cx] = 0;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r16[ax] = 0x0108;
    if (memoryAGet16(ds, 0x20ceb7) == 0x008e)
        { pc = 0x1b9e02; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0019))
        { pc = 0x1b9e02; break; }
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
  case 0x1b9e02: // 0160:1b9e02
    r16[bx] = memoryAGet16(ds, 0x20ceb7);
    r16[cx] = 0x0001;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x001f;
    r16[bp] >>>= 4;
    if (!r16[bp])
        { pc = 0x1b9e20; break; }
    r16[cx]++;
  case 0x1b9e20: // 0160:1b9e20
    r16[dx] = 0x0004;
    push32(r32[ecx]);
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[cx] = memoryAGet16(ds, 0x20e9c1);
    memoryASet16(ds, 0x20cec3, r16[cx]);
    r16[cx] += 0x0008;
    r16[bx] += 0x0030;
    yield* sub_1bd51f();
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[cx] = 0x0003;
    r16[dx] = 0x0008;
    yield* sub_1bd507();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[ecx] = pop32();
    r16[dx] = 0x0007;
    yield* sub_1bd7dd();
    r32[edi] = 0x001ef2b8;
    memoryASet16(ds, 0x20ceb1, 0x0000);
    memoryASet16(ds, 0x20cebb, 0x0100);
    memoryASet16(ds, 0x20cebd, 0x0118);
  case 0x1b9e84: // 0160:1b9e84
    r16[ax] = memoryAGet16(ds, 0x20ceb1);
    if (r16[ax] == memoryAGet16(ds, r32[edi] - 2))
        { pc = 0x1b9e9e; break; }
    yield* sub_1b9fb2();
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) + 1);
    { pc = 0x1b9e84; break; }
  case 0x1b9e9e: // 0160:1b9e9e
    r32[esi] = 0x0020e9c5;
    r32[edi] = 0x001ef25e;
    if (!(memoryAGet16(ds, 0x20e9c3) & 0xffff))
        { pc = 0x1b9ed6; break; }
    r32[edi] = 0x001ef278;
    if (memoryAGet16(ds, 0x20e9c3) == 0x0001)
        { pc = 0x1b9ed6; break; }
    r32[edi] = 0x001ef292;
    if (memoryAGet16(ds, 0x20e9c3) == 0x0002)
        { pc = 0x1b9ed6; break; }
    r32[edi] = 0x001ef2a6;
  case 0x1b9ed6: // 0160:1b9ed6
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e9c3);
    r16[ax] <<= 1;
    r32[edx] = 0x001ef2d0;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[edx] + r32[eax]);
    memoryASet16(ds, 0x20cebb, r16[ax]);
    memoryASet16(ds, 0x20cebd, 0x0108);
  case 0x1b9f05: // 0160:1b9f05
    r16[ax] = memoryAGet16(ds, 0x20ceb1);
    if (r16[ax] == memoryAGet16(ds, r32[edi] - 2))
        { pc = 0x1b9fa6; break; }
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == memoryAGet16(ds, 0x20ceb1))
        { pc = 0x1b9f35; break; }
    if (r16s[ax] < signed16(memoryAGet16(ds, 0x20ceb1)))
        { pc = 0x1b9fa6; break; }
    yield* sub_1b9fb2();
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) + 1);
    { pc = 0x1b9f05; break; }
  case 0x1b9f35: // 0160:1b9f35
    r16[ax] = memoryAGet16(ds, 0x20ceb1);
    r16[ax] <<= 3;
    r16[ax] += memoryAGet16(ds, 0x20cebb);
    if (r16[ax] != memoryAGet16(ds, r32[esi] + 0x2))
        { pc = 0x1b9fa7; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    yield* sub_1b9fc3();
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 1);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    if (r16[bx] != 0x00ff)
        { pc = 0x1b9f78; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 1);
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) + 1);
  case 0x1b9f78: // 0160:1b9f78
    r16[bx] = memoryAGet16(ds, 0x20e9c3);
    r16[bx] <<= 1;
    r32[ebx] &= 0x0000ffff;
    r32[edx] = 0x001ef2c8;
    r16[ax] = memoryAGet16(ds, r32[edx] + r32[ebx]);
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ceb1);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1b9fa6; break; }
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) + 0x0008);
  case 0x1b9fa6: // 0160:1b9fa6
    r32[esp] += 4; return;
  case 0x1b9fa7: // 0160:1b9fa7
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) - 0x0010);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    { pc = 0x1b9fc3; break; }
    // gap 17 bytes // gap 17 bytes
  case 0x1b9fc3: // 0160:1b9fc3
    r16[bx] = memoryAGet16(ds, 0x20cebd);
    r32[edx] = r32[edi];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] <<= 1;
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[edx] + r32[ecx]);
    push32(r32[edx]);
    r16[dx] = 0x0005;
    if (r16[cx] == 0x00ff)
        { pc = 0x1b9fff; break; }
    r16[cx] += 0x0018;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1b9fff: // 0160:1b9fff
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b9fb2() // 0160:1b9fb2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20ceb1);
    r16[ax] <<= 3;
    r16[ax] += memoryAGet16(ds, 0x20cebb);
    r16[bx] = memoryAGet16(ds, 0x20cebd);
    r32[edx] = r32[edi];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] <<= 1;
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[edx] + r32[ecx]);
    push32(r32[edx]);
    r16[dx] = 0x0005;
    if (r16[cx] == 0x00ff)
        { pc = 0x1b9fff; break; }
    r16[cx] += 0x0018;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1b9fff: // 0160:1b9fff
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1b9fc3() // 0160:1b9fc3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = memoryAGet16(ds, 0x20cebd);
    r32[edx] = r32[edi];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] <<= 1;
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[edx] + r32[ecx]);
    push32(r32[edx]);
    r16[dx] = 0x0005;
    if (r16[cx] == 0x00ff)
        { pc = 0x1b9fff; break; }
    r16[cx] += 0x0018;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1b9fff: // 0160:1b9fff
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ba001() // 0160:1ba001 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b56a2();
    r32[edx] = 0x001ece0b;
    r32[edi] = 0x000a0000;
    yield* sub_1b5205();
    r32[edi] = 0x000a4800;
    yield* sub_1b521d();
    r32[edi] = 0x000a9000;
    yield* sub_1b521d();
    r32[edx] = 0x001ecdf6;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r32[esi] = 0x0020c8ec;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, r32[esi] - 6, r8[al]);
    memoryASet(ds, r32[esi] - 5, r8[bl]);
    memoryASet(ds, r32[esi] - 4, r8[cl]);
    memoryASet(ds, r32[esi] - 3, r8[al]);
    memoryASet(ds, r32[esi] - 2, r8[bl]);
    memoryASet(ds, r32[esi] - 1, r8[cl]);
    memoryASet(ds, r32[esi] + 0x3, r8[al]);
    memoryASet(ds, r32[esi] + 0x4, r8[bl]);
    memoryASet(ds, r32[esi] + 0x5, r8[cl]);
    memoryASet(ds, r32[esi] + 0x6, r8[al]);
    memoryASet(ds, r32[esi] + 0x7, r8[bl]);
    memoryASet(ds, r32[esi] + 0x8, r8[cl]);
    r32[esi] = 0x0020e8e1;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    memoryASet16(ds, 0x20ecbb, 0x0001);
    yield* sub_1bd346();
    r32[esi] = 0x0020e889;
    r32[ecx] = 0x00000008;
    memoryASet16(ds, r32[esi], 0x0001);
    memoryASet16(ds, r32[esi] + 0x2, 0x01c0);
    r32[esi] += 0x00000004;
    r32[edx] = 0;
  case 0x1ba0bd: // 0160:1ba0bd
    r16[dx]++;
    memoryASet16(ds, r32[esi], 0x0000);
    memoryASet16(ds, r32[esi] + 0x2, 0x01c8);
    if (r16[dx] == 0x0001)
        { pc = 0x1ba0db; break; }
    if (r16[dx] == 0x0008)
        { pc = 0x1ba0db; break; }
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) - 0x0008);
  case 0x1ba0db: // 0160:1ba0db
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1ba0bd; break; }
    memoryASet16(ds, 0x20e887, 0x0000);
    memoryASet(ds, 0x20e837, 0x80);
    yield* sub_1b191a();
    r8[al] = 0x09;
    yield* sub_1b18a6();
    memoryASet16(ds, 0x2231d4, 0x0000);
    yield* sub_1b4f0e();
  case 0x1ba10a: // 0160:1ba10a
    yield* sub_1b5096();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1ba122; break; }
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
  case 0x1ba122: // 0160:1ba122
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1ba20d; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ee9d3;
    r32[edi] = 0x0020ea5b;
    r32[ecx] = 0x00000026;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x0020ea5b;
    r32[edi] = r32[esi];
    r32[edi] += 0x00000011;
    r32[edx] = r32[esi];
    r32[edx] += 0x00000012;
    r16[ax] = memoryAGet16(ds, 0x20d863);
    r8[al]++;
    r8[bl] = 0;
  case 0x1ba16a: // 0160:1ba16a
    if (r8s[al] < signed8(0x0a))
        { pc = 0x1ba174; break; }
    r8[bl]++;
    r8[al] -= 0x0a;
    { pc = 0x1ba16a; break; }
  case 0x1ba174: // 0160:1ba174
    if (!r8[bl])
        { pc = 0x1ba18f; break; }
    r32[ecx] = r32[esi];
    r32[ecx] += 0x00000014;
    memoryASet(ds, 0x20e7fd, 0x11);
    r8[bl] += 0x30;
    memoryASet(ds, r32[edi], r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, r32[edx], r8[al]);
    { pc = 0x1ba19f; break; }
  case 0x1ba18f: // 0160:1ba18f
    r32[ecx] = r32[esi];
    r32[ecx] += 0x00000013;
    memoryASet(ds, 0x20e7fd, 0x10);
    r8[al] += 0x30;
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1ba19f: // 0160:1ba19f
    memoryASet(ds, r32[ecx], 0x2d);
    r32[ecx] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d863);
    r32[esi] = 0x00203e42;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 2;
    r16[ax] += r16[bx];
    r16[ax] += r16[bx];
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r32[edi] = 0x002084b8;
    if (!r16[bx])
        { pc = 0x1ba1e1; break; }
    r32[eax] = 0;
  case 0x1ba1d8: // 0160:1ba1d8
    r8[al] = memoryAGet(ds, r32[edi]);
    r32[edi]++;
    r32[edi] += r32[eax];
    r16[bx]--;
    if (r16[bx])
        { pc = 0x1ba1d8; break; }
  case 0x1ba1e1: // 0160:1ba1e1
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edi]);
    r32[edi]++;
    memoryASet(ds, 0x20e7fd, memoryAGet(ds, 0x20e7fd) + r8[al]);
    r8[dl] = 0x28;
    r8[dl] -= memoryAGet(ds, 0x20e7fd);
    r8[dl] >>>= 1;
  case 0x1ba1f6: // 0160:1ba1f6
    r8[bl] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[ecx], r8[bl]);
    r32[edi]++;
    r32[ecx]++;
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1ba1f6; break; }
    r32[esi] = 0x0020ea5b;
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + r8[dl]);
    yield* sub_1b60d3();
  case 0x1ba20d: // 0160:1ba20d
    yield* sub_1ba249();
    if (memoryAGet16(ds, 0x20e887) == 0x0640)
        { pc = 0x1ba239; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x001e))
        { pc = 0x1ba23a; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1ba23a; break; }
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1ba23a; break; }
  case 0x1ba239: // 0160:1ba239
    r32[esp] += 4; return;
  case 0x1ba23a: // 0160:1ba23a
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1ba10a; break; }
    return;
  }
}
function* sub_1ba249() // 0160:1ba249 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x0100;
    r16[bx] = 0x00f8;
    r16[cx] = 0x000c;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r16[ax] = 0x0108;
    r16[bx] = 0x00df;
    r16[cx] = 0x0009;
    r16[dx] = 0x0004;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x001f;
    r16[bp] >>>= 4;
    if (!r16[bp])
        { pc = 0x1ba281; break; }
    r16[cx]++;
  case 0x1ba281: // 0160:1ba281
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x001e))
        { pc = 0x1ba28f; break; }
    r16[cx] = 0x000b;
  case 0x1ba28f: // 0160:1ba28f
    yield* sub_1bd7dd();
    r32[ebp] = 0x00000009;
    r16[cx] = 0;
    r32[esi] = 0x001ef238;
    r32[edi] = 0x0020e889;
  case 0x1ba2a6: // 0160:1ba2a6
    if (!(memoryAGet16(ds, r32[edi]) & 0xffff))
        { pc = 0x1ba2f5; break; }
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    if (r16[ax] != memoryAGet16(ds, r32[esi]))
        { pc = 0x1ba2c2; break; }
    memoryASet16(ds, r32[edi] + 0x2, 0x0001);
    r16[ax] += 0x0010;
  case 0x1ba2c2: // 0160:1ba2c2
    r32[esi] += 0x00000002;
    r16[ax] -= 0x0010;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    push32(r32[ecx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    if (r16[cx] != 0x0003)
        { pc = 0x1ba2e3; break; }
    r16[ax] += 0x0004;
  case 0x1ba2e3: // 0160:1ba2e3
    r16[dx] = 0x0005;
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r16[cx]++;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1ba2a6; break; }
  case 0x1ba2f5: // 0160:1ba2f5
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ba2f6() // 0160:1ba2f6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    memoryASet16(ds, 0x20eeb0, 0x0000);
    yield* sub_1b5643();
    push32(r32[ebx]);
    push32(r32[edi]);
    yield* sub_1bd478();
    r32[edi] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1ba398; break; }
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1ba398; break; }
    yield* sub_1b59d4();
  case 0x1ba398: // 0160:1ba398
    r32[esi] = 0x0020e8e1;
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    r32[ecx] &= 0x0000ffff;
  case 0x1ba3aa: // 0160:1ba3aa
    push32(r32[ecx]);
    memoryASet16(ds, 0x20ceb1, 0x0001);
    yield* sub_1bd346();
    r32[esi] += 0x00000004;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1ba3aa; break; }
    yield* sub_1bd894();
    r32[edx] = 0x001ecd44;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0004)
        { pc = 0x1ba3e7; break; }
    r32[edx] = 0x001ecd57;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0003)
        { pc = 0x1ba3e7; break; }
    r32[edx] = 0x001ecd6a;
  case 0x1ba3e7: // 0160:1ba3e7
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x0108);
    memoryASet16(ds, 0x20ec3f, 0x00e6);
    memoryASet16(ds, 0x20e82f, 0x0001);
    memoryASet16(ds, 0x20e887, 0x0000);
    memoryASet(ds, 0x20e837, 0x80);
    memoryASet16(ds, 0x20ec45, 0x0000);
    memoryASet16(ds, 0x20edab, 0x0000);
    memoryASet16(ds, 0x2231d4, 0x0000);
    yield* sub_1b4f0e();
  case 0x1ba459: // 0160:1ba459
    yield* sub_1b5096();
    memoryASet16(ds, 0x20ec45, memoryAGet16(ds, 0x20ec45) + 1);
    memoryASet16(ds, 0x20edab, memoryAGet16(ds, 0x20edab) + 1);
    if (memoryAGet16(ds, 0x20edab) != 0x0bb8)
        { pc = 0x1ba48b; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0001);
    { pc = 0x1ba49d; break; }
  case 0x1ba48b: // 0160:1ba48b
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1ba49d; break; }
    memoryASet16(ds, 0x20edab, 0x0000);
  case 0x1ba49d: // 0160:1ba49d
    yield* sub_1b531f();
    yield* sub_1ba572();
    yield* sub_1ba4c9();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1ba4b8; break; }
    r32[esp] += 4; return;
  case 0x1ba4b8: // 0160:1ba4b8
    yield* sub_1ba724();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1ba459; break; }
    return;
  }
}
function* sub_1ba4c9() // 0160:1ba4c9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ba4c9; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
  case 0x1b4b5f: // 0160:1b4b5f
    r16[ax] += 0x0020;
    if (!r16[bp])
        { pc = 0x1b4b6c; break; }
    r16[ax] += 0x0002;
  case 0x1b4b6c: // 0160:1b4b6c
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    { pc = 0x1b4b56; break; }
    // gap 22860 bytes // gap 22860 bytes
  case 0x1ba4c9: // 0160:1ba4c9
    if (memoryAGet16(ds, 0x20ecbd) & 0xffff)
        { pc = 0x1ba520; break; }
    r32[esi] = 0x001ee97c;
    r8[al] = 0xc2;
    r8[bl] = 0xcf;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee98b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee992;
    yield* sub_1b60d3();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x001f);
    yield* sub_1b49c8();
    { pc = 0x1b4b5f; break; }
  case 0x1ba520: // 0160:1ba520
    r32[esi] = 0x001ee962;
    r32[edi] = 0x0020ea45;
    r32[ebx] = r32[edi];
    r32[ecx] = 0x00000009;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, r32[ebx] + 0x3, memoryAGet(ds, r32[ebx] + 0x3) + 1);
    r16[dx] = 0;
    r8[dl] = memoryAGet(ds, 0x20e9b9);
    r8[dl] += 0x30;
    memoryASet(ds, r32[ebx] + 0x9, r8[dl]);
    r32[esi] = r32[ebx];
    yield* sub_1b60d3();
    r32[esi] = 0x001ee96b;
    yield* sub_1b60d3();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1ba571; break; }
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1ba571; break; }
    memoryASet16(ds, 0x20e831, 0x0001);
  case 0x1ba571: // 0160:1ba571
    r32[esp] += 4; return;
    // gap 12907 bytes // gap 12907 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1ba572() // 0160:1ba572 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20ecbd) & 0xffff))
        { pc = 0x1ba683; break; }
    r32[esi] = 0x001ef210;
    yield* sub_1ba9cd();
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    r32[edi] = r32[esi];
    memoryASet16(ds, 0x20e905, 0x0000);
    memoryASet16(ds, 0x20ce9d, 0x0001);
    r32[ecx] &= 0x0000ffff;
  case 0x1ba5ac: // 0160:1ba5ac
    r32[esi] = 0x001ee9a7;
    push32(r32[ecx]);
    push32(r32[edi]);
    yield* sub_1b6113();
    r32[edi] = pop32();
    r32[esi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    push32(r32[edi]);
    yield* sub_1b6269();
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1ba5f8; break; }
    r16[ax] = memoryAGet16(ds, 0x20ce9d);
    r16[bx] = memoryAGet16(ds, 0x20d7b7);
    if (r16[ax] == r16[bx])
        { pc = 0x1ba607; break; }
    r16[bx] += 0x0002;
    if (r16[ax] == r16[bx])
        { pc = 0x1ba607; break; }
    { pc = 0x1ba66b; break; }
  case 0x1ba5f8: // 0160:1ba5f8
    r16[ax] = memoryAGet16(ds, 0x20ce9d);
    if (r16[ax] != memoryAGet16(ds, 0x20d7b7))
        { pc = 0x1ba66b; break; }
  case 0x1ba607: // 0160:1ba607
    r8[al] = memoryAGet(ds, 0x20e9c5);
    r8[bl] = memoryAGet(ds, 0x20e9c6);
    r32[esi] = 0x001ee9af;
    r16[cx] = memoryAGet16(ds, 0x20eeb0);
    r16[cx] &= 0x000f;
    if (r16[cx] > 0x0003)
        { pc = 0x1ba63d; break; }
    r32[esi] = 0x001ee9c1;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b6113();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1ba65a; break; }
  case 0x1ba63d: // 0160:1ba63d
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b6113();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esi] = 0x0020e9c5;
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20e9b9);
    r8[cl] += 0x1a;
    memoryASet(ds, r32[esi] + 0x9, r8[cl]);
  case 0x1ba65a: // 0160:1ba65a
    flags.carry = r8[bl] < 0x44;
    r8[bl] -= 0x44;
    if (!flags.carry)
        { pc = 0x1ba661; break; }
    r8[al]--;
  case 0x1ba661: // 0160:1ba661
    memoryASet(ds, r32[esi], r8[al]);
    memoryASet(ds, r32[esi] + 0x1, r8[bl]);
    yield* sub_1b6269();
  case 0x1ba66b: // 0160:1ba66b
    memoryASet16(ds, 0x20ce9d, memoryAGet16(ds, 0x20ce9d) + 1);
    r32[edi] = pop32();
    r32[ecx] = pop32();
    r32[edi] += 0x00000004;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1ba5ac; break; }
    { pc = 0x1ba723; break; }
  case 0x1ba683: // 0160:1ba683
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1ba723; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r32[esi] = 0x001ef1e8;
    yield* sub_1ba9cd();
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    r32[edi] = r32[esi];
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[ecx] &= 0x0000ffff;
  case 0x1ba6ba: // 0160:1ba6ba
    r32[esi] = 0x001ee998;
    push32(r32[ecx]);
    push32(r32[edi]);
    yield* sub_1b6113();
    r32[edi] = pop32();
    r32[esi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    push32(r32[edi]);
    yield* sub_1b6269();
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) - 0x40);
    memoryASet(ds, r32[esi] + 0x4, 0x13);
    memoryASet(ds, r32[esi] + 0x5, 0x0e);
    memoryASet(ds, r32[esi] + 0x6, 0x13);
    yield* sub_1b6269();
    r32[esi] = 0x001ee99f;
    yield* sub_1b6113();
    r32[edi] = pop32();
    r32[esi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    r8[al] += 0x0b;
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    push32(r32[edi]);
    yield* sub_1b6269();
    r32[edi] = pop32();
    r32[edi] += 0x00000004;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1ba6ba; break; }
  case 0x1ba723: // 0160:1ba723
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ba724() // 0160:1ba724 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1ba9c8();
    r16[bp] = memoryAGet16(ds, 0x20e90d);
    memoryASet16(ds, 0x20e8b9, 0x0000);
  case 0x1ba739: // 0160:1ba739
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[esi] += 0x00000004;
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    r16[cx] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x20eeb0);
    r16[dx] &= 0x001f;
    r16[dx] >>>= 4;
    if (!r16[dx])
        { pc = 0x1ba760; break; }
    r16[cx]++;
  case 0x1ba760: // 0160:1ba760
    r16[cx] += 0x0020;
    r16[dx] = 0x0004;
    if (signed16(memoryAGet16(ds, 0x20ec45)) < signed16(0x00c8))
        { pc = 0x1ba788; break; }
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    r16[cx] <<= 1;
    r16[cx] += memoryAGet16(ds, 0x20e8b9);
    r16[cx] += 0x0020;
  case 0x1ba788: // 0160:1ba788
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esi] = 0x0020e8e1;
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    r16[cx] <<= 1;
    r16[dx] = r16[cx];
    r16[cx] <<= 1;
    r16[cx] += r16[dx];
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    memoryASet16(ds, 0x20cec3, r16[cx]);
    r16[cx] += 0x000f;
    r16[bx] += 0x0030;
    yield* sub_1bd51f();
    r16[dx] = 0x0004;
    r16[ax]++;
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e8b9, memoryAGet16(ds, 0x20e8b9) + 1);
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1ba739; break; }
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    r32[edi] = 0x0020ecbf;
    if (!(memoryAGet16(ds, 0x20ecbd) & 0xffff))
        { pc = 0x1ba81f; break; }
    r32[esi] = 0x0020e8e3;
    r32[ecx] &= 0x0000ffff;
  case 0x1ba807: // 0160:1ba807
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r32[esi] += 0x00000006;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1ba807; break; }
    { pc = 0x1ba857; break; }
  case 0x1ba81f: // 0160:1ba81f
    r32[esi] = 0x0020e8e1;
    r32[ebx] = 0x002247a6;
  case 0x1ba829: // 0160:1ba829
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] <<= 2;
    r16[dx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[dx];
    r32[eax] &= 0x0000ffff;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x8);
    memoryASet16(ds, r32[edi], r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0xa);
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
    r32[edi] += 0x00000004;
    r32[esi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1ba829; break; }
  case 0x1ba857: // 0160:1ba857
    yield* sub_1ba9c8();
    r16[bp] = memoryAGet16(ds, 0x20e90d);
    memoryASet16(ds, 0x20e8b9, 0x0000);
    r32[edi] = 0x0020ecbf;
  case 0x1ba871: // 0160:1ba871
    yield* sub_1ba8b8();
    r16[ax] -= 0x0018;
    if (!(memoryAGet16(ds, 0x20ecbd) & 0xffff))
        { pc = 0x1ba88d; break; }
    r16[ax] += 0x0040;
    r16[bx] += 0x002e;
  case 0x1ba88d: // 0160:1ba88d
    yield* sub_1ba934();
    if (!(memoryAGet16(ds, 0x20ecbd) & 0xffff))
        { pc = 0x1ba8a2; break; }
    r32[edi] += 0x00000002;
    { pc = 0x1ba8b0; break; }
  case 0x1ba8a2: // 0160:1ba8a2
    yield* sub_1ba8b8();
    r16[ax] += 0x0044;
    yield* sub_1ba934();
  case 0x1ba8b0: // 0160:1ba8b0
    r32[esi] += 0x00000004;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1ba871; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ba8b8() // 0160:1ba8b8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    memoryASet16(ds, 0x20ceb1, 0x0000);
    memoryASet16(ds, 0x20ceb7, 0x0000);
    memoryASet16(ds, 0x20ceb9, 0x0000);
    memoryASet16(ds, 0x20cebb, 0x0000);
  case 0x1ba8e2: // 0160:1ba8e2
    if (r16s[ax] < signed16(0x03e8))
        { pc = 0x1ba8f5; break; }
    r16[ax] -= 0x03e8;
    memoryASet16(ds, 0x20cebb, memoryAGet16(ds, 0x20cebb) + 1);
    { pc = 0x1ba8e2; break; }
  case 0x1ba8f5: // 0160:1ba8f5
    if (r16s[ax] < signed16(0x0064))
        { pc = 0x1ba908; break; }
    r16[ax] -= 0x0064;
    memoryASet16(ds, 0x20ceb9, memoryAGet16(ds, 0x20ceb9) + 1);
    { pc = 0x1ba8f5; break; }
  case 0x1ba908: // 0160:1ba908
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1ba91b; break; }
    r16[ax] -= 0x000a;
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) + 1);
    { pc = 0x1ba908; break; }
  case 0x1ba91b: // 0160:1ba91b
    memoryASet16(ds, 0x20ceb1, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx] += 0x0012;
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1ba934() // 0160:1ba934 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    if (!(memoryAGet16(ds, 0x20cebb) & 0xffff))
        { pc = 0x1ba960; break; }
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] -= 0x000e;
    r16[cx] = memoryAGet16(ds, 0x20cebb);
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0003;
    { pc = 0x1ba96b; break; }
  case 0x1ba960: // 0160:1ba960
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1ba989; break; }
  case 0x1ba96b: // 0160:1ba96b
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] -= 0x0009;
    r16[cx] = memoryAGet16(ds, 0x20ceb9);
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0003;
    { pc = 0x1ba994; break; }
  case 0x1ba989: // 0160:1ba989
    if (!(memoryAGet16(ds, 0x20ceb7) & 0xffff))
        { pc = 0x1ba9b0; break; }
  case 0x1ba994: // 0160:1ba994
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] -= 0x0004;
    r16[cx] = memoryAGet16(ds, 0x20ceb7);
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0004;
  case 0x1ba9b0: // 0160:1ba9b0
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ba9c8() // 0160:1ba9c8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001ef1c0;
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1ba9f4; break; }
    r32[esi] += 0x00000004;
    if (memoryAGet16(ds, 0x20e90d) == 0x0002)
        { pc = 0x1ba9f4; break; }
    r32[esi] += 0x00000008;
    if (memoryAGet16(ds, 0x20e90d) == 0x0003)
        { pc = 0x1ba9f4; break; }
    r32[esi] += 0x0000000c;
  case 0x1ba9f4: // 0160:1ba9f4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ba9cd() // 0160:1ba9cd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1ba9f4; break; }
    r32[esi] += 0x00000004;
    if (memoryAGet16(ds, 0x20e90d) == 0x0002)
        { pc = 0x1ba9f4; break; }
    r32[esi] += 0x00000008;
    if (memoryAGet16(ds, 0x20e90d) == 0x0003)
        { pc = 0x1ba9f4; break; }
    r32[esi] += 0x0000000c;
  case 0x1ba9f4: // 0160:1ba9f4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ba9f5() // 0160:1ba9f5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ba9f5; break; }
  case 0x1b18a6: // 0160:1b18a6
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b1919; break; }
    if (r8[al] != 0x79)
        { pc = 0x1b18be; break; }
    { pc = 0x1c72ac; break; }
  case 0x1b18be: // 0160:1b18be
    if (r8[al] != 0x8a)
        { pc = 0x1b18c7; break; }
    { pc = 0x1c735c; break; }
  case 0x1b18c7: // 0160:1b18c7
    if (r8[al] != 0x80)
        { pc = 0x1b18d0; break; }
    { pc = 0x1c740c; break; }
  case 0x1b18d0: // 0160:1b18d0
    if (r8[al] != 0x82)
        { pc = 0x1b18e3; break; }
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
    memoryASet32(ds, 0x20ee7b, r32[eax]);
    { pc = 0x1c74bc; break; }
  case 0x1b18e3: // 0160:1b18e3
    if (r8[al] != 0xa5)
        { pc = 0x1b18ec; break; }
    { pc = 0x1c7784; break; }
  case 0x1b18ec: // 0160:1b18ec
    if (r8[al] != 0x8b)
        { pc = 0x1b18f5; break; }
    { pc = 0x1c76d4; break; }
  case 0x1b18f5: // 0160:1b18f5
    if (r8[al] != 0x06)
        { pc = 0x1b18fe; break; }
    { pc = 0x1c756c; break; }
  case 0x1b18fe: // 0160:1b18fe
    if (r8[al] != 0x09)
        { pc = 0x1b1907; break; }
    { pc = 0x1c7624; break; }
  case 0x1b1907: // 0160:1b1907
    if (r8[al] != 0xa8)
        { pc = 0x1b1910; break; }
    { pc = 0x1c783c; break; }
  case 0x1b1910: // 0160:1b1910
    if (r8[al] != 0x81)
        { pc = 0x1b1919; break; }
    { pc = 0x1c78ec; break; }
  case 0x1b1919: // 0160:1b1919
    r32[esp] += 4; return;
    // gap 37083 bytes // gap 37083 bytes
  case 0x1ba9f5: // 0160:1ba9f5
    yield* sub_1baa06();
    yield* sub_1b191a();
    r8[al] = 0x82;
    { pc = 0x1b18a6; break; }
    // gap 51366 bytes // gap 51366 bytes
  case 0x1c72ac: // 0160:1c72ac
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c72ff; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c72fd; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c72e4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c72e4: // 0160:1c72e4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c72fd: // 0160:1c72fd
    { pc = 0x1c7336; break; }
  case 0x1c72ff: // 0160:1c72ff
    if (!memoryAGet32(ds, 0x1f1cd8))
        { pc = 0x1c7336; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7320; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7320: // 0160:1c7320
    yield* sub_1c82bc();
    r32[eax] = 0;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000000);
  case 0x1c7336: // 0160:1c7336
    memoryASet32(ss, r32[ebp] - 8, 0x0020a9f4);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 3 bytes // gap 3 bytes
  case 0x1c735c: // 0160:1c735c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c73af; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c73ad; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7394; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7394: // 0160:1c7394
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c73ad: // 0160:1c73ad
    { pc = 0x1c73e9; break; }
  case 0x1c73af: // 0160:1c73af
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c73e9; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c73d0; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c73d0: // 0160:1c73d0
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c73e9: // 0160:1c73e9
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa00);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c740c: // 0160:1c740c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c745f; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c745d; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7444; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7444: // 0160:1c7444
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c745d: // 0160:1c745d
    { pc = 0x1c7499; break; }
  case 0x1c745f: // 0160:1c745f
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c7499; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7480; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7480: // 0160:1c7480
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c7499: // 0160:1c7499
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa08);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c74bc: // 0160:1c74bc
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c750f; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c750d; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c74f4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c74f4: // 0160:1c74f4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c750d: // 0160:1c750d
    { pc = 0x1c7549; break; }
  case 0x1c750f: // 0160:1c750f
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c7549; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7530; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7530: // 0160:1c7530
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c7549: // 0160:1c7549
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa14);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 3 bytes // gap 3 bytes
  case 0x1c756c: // 0160:1c756c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c75bf; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c75bd; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c75a4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c75a4: // 0160:1c75a4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c75bd: // 0160:1c75bd
    { pc = 0x1c7604; break; }
  case 0x1c75bf: // 0160:1c75bf
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c75d1; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c75d3; break; }
  case 0x1c75d1: // 0160:1c75d1
    { pc = 0x1c7604; break; }
  case 0x1c75d3: // 0160:1c75d3
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c75eb; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c75eb: // 0160:1c75eb
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c7604: // 0160:1c7604
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa24);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7624: // 0160:1c7624
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7677; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c7675; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c765c; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c765c: // 0160:1c765c
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c7675: // 0160:1c7675
    { pc = 0x1c76b1; break; }
  case 0x1c7677: // 0160:1c7677
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000001)
        { pc = 0x1c76b1; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7698; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7698: // 0160:1c7698
    yield* sub_1c82bc();
    r32[eax] = 0x00000001;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000001);
  case 0x1c76b1: // 0160:1c76b1
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa30);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 3 bytes // gap 3 bytes
  case 0x1c76d4: // 0160:1c76d4
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7727; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c7725; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c770c; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c770c: // 0160:1c770c
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c7725: // 0160:1c7725
    { pc = 0x1c777b; break; }
  case 0x1c7727: // 0160:1c7727
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7761; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7748; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7748: // 0160:1c7748
    yield* sub_1c82bc();
    r32[eax] = 0x00000002;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000002);
  case 0x1c7761: // 0160:1c7761
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa3c);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
  case 0x1c777b: // 0160:1c777b
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7784: // 0160:1c7784
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c77d7; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c77d5; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c77bc; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c77bc: // 0160:1c77bc
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c77d5: // 0160:1c77d5
    { pc = 0x1c781c; break; }
  case 0x1c77d7: // 0160:1c77d7
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c77e9; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c77eb; break; }
  case 0x1c77e9: // 0160:1c77e9
    { pc = 0x1c781c; break; }
  case 0x1c77eb: // 0160:1c77eb
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7803; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7803: // 0160:1c7803
    yield* sub_1c82bc();
    r32[eax] = 0x00000002;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000002);
  case 0x1c781c: // 0160:1c781c
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa44);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c783c: // 0160:1c783c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c788f; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c788d; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7874; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7874: // 0160:1c7874
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c788d: // 0160:1c788d
    { pc = 0x1c78e3; break; }
  case 0x1c788f: // 0160:1c788f
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000003)
        { pc = 0x1c78c9; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c78b0; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c78b0: // 0160:1c78b0
    yield* sub_1c82bc();
    r32[eax] = 0x00000003;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000003);
  case 0x1c78c9: // 0160:1c78c9
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa4c);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
  case 0x1c78e3: // 0160:1c78e3
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c78ec: // 0160:1c78ec
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000004)
        { pc = 0x1c7934; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c791b; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c791b: // 0160:1c791b
    yield* sub_1c82bc();
    r32[eax] = 0x00000004;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000004);
  case 0x1c7934: // 0160:1c7934
    memoryASet32(ss, r32[ebp] - 8, 0x0020aa58);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1c7de8();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1baa06() // 0160:1baa06 +long
{
  if (mm2_skipLevelGetReady)
  {
    yield* sub_1b4bc9();
    return;
  }

  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1b560a();
    push32(r32[ebx]);
    push32(r32[edi]);
    yield* sub_1bd478();
    r16[cx] = memoryAGet16(ds, 0x20e90d);
    if (r16[cx] == 0x0001)
        { pc = 0x1baa59; break; }
    r16[cx]--;
    memoryASet16(ds, 0x20e8bb, r16[cx]);
    r32[esi] = 0x0020e8db;
    r32[edi] = 0x0020e8c1;
    r16[cx]++;
    r32[ecx] &= 0x0000ffff;
  case 0x1baa49: // 0160:1baa49
    r32[esi] += 0x00000006;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1baa49; break; }
    { pc = 0x1baa93; break; }
  case 0x1baa59: // 0160:1baa59
    r32[esi] = 0x0020e8c1;
    r16[ax] = memoryAGet16(ds, 0x20e8bb);
    r16[cx] = r16[ax];
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = r32[esi];
    r32[esi] -= 0x00000002;
    r32[ecx] &= 0x0000ffff;
  case 0x1baa7c: // 0160:1baa7c
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] -= 0x00000002;
    r32[edi] -= 0x00000002;
    if (--r32[ecx])
        { pc = 0x1baa7c; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, r32[edi], r16[ax]);
  case 0x1baa93: // 0160:1baa93
    yield* sub_1bae42();
    r32[edi] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e8c1);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8c3);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8c5);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1bab16; break; }
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8c7);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1bab16; break; }
    yield* sub_1b59d4();
  case 0x1bab16: // 0160:1bab16
    r32[esi] = 0x0020e8c1;
    r16[ax] = memoryAGet16(ds, 0x20e8bb);
    r16[ax]++;
    memoryASet16(ds, 0x20ceb1, r16[ax]);
    yield* sub_1bd346();
    r16[ax] = memoryAGet16(ds, 0x20e8bb);
    r16[ax]++;
    memoryASet16(ds, 0x20e8ff, r16[ax]);
    r16[ax] >>>= 1;
    if (memoryAGet16(ds, 0x20e90d) != 0x0003)
        { pc = 0x1bab4b; break; }
    r16[ax]++;
  case 0x1bab4b: // 0160:1bab4b
    memoryASet16(ds, 0x20e901, r16[ax]);
    yield* sub_1bd894();
    r32[edx] = 0x001ecd0e;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0004)
        { pc = 0x1bab79; break; }
    r32[edx] = 0x001ecd20;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0003)
        { pc = 0x1bab79; break; }
    r32[edx] = 0x001ecd32;
  case 0x1bab79: // 0160:1bab79
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1bac4e; break; }
    memoryASet(ds, 0x20c98e, 0x31);
    memoryASet(ds, 0x20c98f, 0x15);
    memoryASet(ds, 0x20c990, 0x15);
    memoryASet(ds, 0x20c991, 0x38);
    memoryASet(ds, 0x20c992, 0x1e);
    memoryASet(ds, 0x20c993, 0x1e);
    memoryASet(ds, 0x20c99a, 0x0c);
    memoryASet(ds, 0x20c99b, 0x0c);
    memoryASet(ds, 0x20c99c, 0x31);
    memoryASet(ds, 0x20c99d, 0x1e);
    memoryASet(ds, 0x20c99e, 0x1e);
    memoryASet(ds, 0x20c99f, 0x38);
    memoryASet(ds, 0x20c9a6, 0x25);
    memoryASet(ds, 0x20c9a7, 0x05);
    memoryASet(ds, 0x20c9a8, 0x05);
    memoryASet(ds, 0x20c9a9, 0x2b);
    memoryASet(ds, 0x20c9aa, 0x0c);
    memoryASet(ds, 0x20c9ab, 0x0c);
    memoryASet(ds, 0x20c9a0, 0x05);
    memoryASet(ds, 0x20c9a1, 0x05);
    memoryASet(ds, 0x20c9a2, 0x25);
    memoryASet(ds, 0x20c9a3, 0x0c);
    memoryASet(ds, 0x20c9a4, 0x0c);
    memoryASet(ds, 0x20c9a5, 0x2b);
  case 0x1bac4e: // 0160:1bac4e
    memoryASet16(ds, 0x20e8bd, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e965, 0x0000);
    memoryASet16(ds, 0x20e8fb, 0x0200);
    r32[esi] = 0x001ef19c;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0004)
        { pc = 0x1bac95; break; }
    r32[esi] = 0x001ef1aa;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0002)
        { pc = 0x1bac95; break; }
    r32[esi] = 0x001ef1a4;
  case 0x1bac95: // 0160:1bac95
    memoryASet32(ds, 0x20e83f, r32[esi]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec45, 0x0000);
    memoryASet16(ds, 0x20ee13, 0x0000);
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1baccb; break; }
    memoryASet16(ds, 0x20ceaf, 0x0000);
  case 0x1baccb: // 0160:1baccb
    yield* sub_1b4f0e();
  case 0x1bacd0: // 0160:1bacd0
    yield* sub_1b5096();
    memoryASet16(ds, 0x20ec45, memoryAGet16(ds, 0x20ec45) + 1);
    yield* sub_1b531f();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bad56; break; }
    memoryASet16(ds, 0x20e965, memoryAGet16(ds, 0x20e965) + 1);
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    memoryASet16(ds, 0x20cec5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e965);
    memoryASet16(ds, 0x20eeb0, r16[ax]);
    if (memoryAGet16(ds, 0x20ed41) & 0xffff)
        { pc = 0x1bad28; break; }
    r32[esi] = 0x001ee958;
    r8[al] = 0xc3;
    r8[bl] = 0x51;
    yield* sub_1b60a7();
  case 0x1bad28: // 0160:1bad28
    r16[ax] = memoryAGet16(ds, 0x20cec5);
    memoryASet16(ds, 0x20eeb0, r16[ax]);
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1bad56; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    if (r8[al] != 0x80)
        { pc = 0x1bad56; break; }
    memoryASet16(ds, 0x20ceaf, 0x0002);
    r32[esp] += 4; return;
  case 0x1bad56: // 0160:1bad56
    r16[bx] = memoryAGet16(ds, 0x20e8bd);
    if (memoryAGet16(ds, 0x20e8ff) != r16[bx])
        { pc = 0x1bad74; break; }
    memoryASet16(ds, 0x20e831, 0x0001);
    { pc = 0x1badf3; break; }
  case 0x1bad74: // 0160:1bad74
    r16[bx] <<= 1;
    r16[cx] = memoryAGet16(ds, 0x20e8fb);
    r32[esi] = memoryAGet32(ds, 0x20e83f);
    r32[ebx] &= 0x0000ffff;
    if (memoryAGet16(ds, r32[esi] + r32[ebx]) != r16[cx])
        { pc = 0x1badd4; break; }
    r32[esi] = 0x001ef1ae;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0004)
        { pc = 0x1badb3; break; }
    r32[esi] += 0x00000008;
    if (memoryAGet16(ds, 0x20e8ff) == 0x0003)
        { pc = 0x1badb3; break; }
    r32[esi] += 0x00000006;
  case 0x1badb3: // 0160:1badb3
    memoryASet16(ds, 0x20e8bd, memoryAGet16(ds, 0x20e8bd) + 1);
    r16[ax] = memoryAGet16(ds, 0x20e8bd);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20e8fb, r16[ax]);
    { pc = 0x1badf3; break; }
  case 0x1badd4: // 0160:1badd4
    memoryASet16(ds, 0x20e8fb, memoryAGet16(ds, 0x20e8fb) + 0xfff0);
    r16[ax] = memoryAGet16(ds, 0x20e901);
    if (signed16(memoryAGet16(ds, 0x20e8bd)) < r16s[ax])
        { pc = 0x1badf3; break; }
    memoryASet16(ds, 0x20e8fb, memoryAGet16(ds, 0x20e8fb) + 0x0020);
  case 0x1badf3: // 0160:1badf3
    yield* sub_1bae67();
    if (!(memoryAGet16(ds, 0x20ed41) & 0xffff))
        { pc = 0x1bae05; break; }
    { pc = 0x1bae27; break; }
  case 0x1bae05: // 0160:1bae05
    if (memoryAGet16(ds, 0x20ee13) != 0x003c)
        { pc = 0x1bae27; break; }
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1bae2e; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (!r8[al])
        { pc = 0x1bae3d; break; }
    { pc = 0x1bae2e; break; }
  case 0x1bae27: // 0160:1bae27
    memoryASet16(ds, 0x20ee13, memoryAGet16(ds, 0x20ee13) + 1);
  case 0x1bae2e: // 0160:1bae2e
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bacd0; break; }
  case 0x1bae3d: // 0160:1bae3d
    { pc = 0x1bae42; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bae42: // 0160:1bae42
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1bae66; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8c5);
    r16[bx] = memoryAGet16(ds, 0x20e8c7);
    memoryASet16(ds, 0x20e8c5, r16[bx]);
    memoryASet16(ds, 0x20e8c7, r16[ax]);
  case 0x1bae66: // 0160:1bae66
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bae42() // 0160:1bae42 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1bae66; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8c5);
    r16[bx] = memoryAGet16(ds, 0x20e8c7);
    memoryASet16(ds, 0x20e8c5, r16[bx]);
    memoryASet16(ds, 0x20e8c7, r16[ax]);
  case 0x1bae66: // 0160:1bae66
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bae67() // 0160:1bae67 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e8b9, 0x0000);
  case 0x1bae70: // 0160:1bae70
    r16[bx] = memoryAGet16(ds, 0x20e8bd);
    if (r16s[bx] < signed16(memoryAGet16(ds, 0x20e8b9)))
        { pc = 0x1baf76; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20e8b9))
        { pc = 0x1baeab; break; }
    r32[esi] = memoryAGet32(ds, 0x20e83f);
    r16[bx] = memoryAGet16(ds, 0x20e8b9);
    r16[bx] <<= 1;
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    memoryASet16(ds, 0x20e9b5, 0x0001);
    { pc = 0x1baeba; break; }
  case 0x1baeab: // 0160:1baeab
    memoryASet16(ds, 0x20e9b5, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8fb);
  case 0x1baeba: // 0160:1baeba
    r16[bx] = 0x00a0;
    r16[bp] = memoryAGet16(ds, 0x20e901);
    if (r16[bp] > memoryAGet16(ds, 0x20e8b9))
        { pc = 0x1baed2; break; }
    r16[bx] = 0x0110;
  case 0x1baed2: // 0160:1baed2
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    r16[cx] <<= 1;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x001f;
    r16[bp] >>>= 4;
    if (!r16[bp])
        { pc = 0x1baeef; break; }
    r16[cx]++;
  case 0x1baeef: // 0160:1baeef
    r16[dx] = 0x0005;
    if (signed16(memoryAGet16(ds, 0x20ec45)) < signed16(0x00c8))
        { pc = 0x1baf0d; break; }
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    r16[cx] += 0x0021;
    r16[dx] = 0x0004;
  case 0x1baf0d: // 0160:1baf0d
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[edx]);
    yield* sub_1bd7dd();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    if (!(memoryAGet16(ds, 0x20e9b5) & 0xffff))
        { pc = 0x1baf5b; break; }
    r16[bx] += 0x0030;
    r16[cx] = memoryAGet16(ds, 0x20e8b9);
    r16[cx] <<= 1;
    r32[esi] = 0x0020e8c1;
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    memoryASet16(ds, 0x20cec3, r16[cx]);
    r16[cx] += 0x0010;
    r16[dx] = 0x0004;
    yield* sub_1bd51f();
    r16[ax]++;
    yield* sub_1bd7dd();
  case 0x1baf5b: // 0160:1baf5b
    memoryASet16(ds, 0x20e8b9, memoryAGet16(ds, 0x20e8b9) + 1);
    r16[ax] = memoryAGet16(ds, 0x20e8b9);
    if (r16[ax] == memoryAGet16(ds, 0x20e8ff))
        { pc = 0x1baf76; break; }
    { pc = 0x1bae70; break; }
  case 0x1baf76: // 0160:1baf76
    if (memoryAGet16(ds, 0x20e8ff) != 0x0002)
        { pc = 0x1bafa8; break; }
    r16[ax] = 0x0090;
    r16[bx] = 0x0108;
    r16[cx] = 0x0020;
    r16[dx] = 0x0004;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    yield* sub_1bd7dd();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r16[ax] = 0x0140;
    r16[bx] -= 0x0050;
    yield* sub_1bd7dd();
  case 0x1bafa8: // 0160:1bafa8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bafa9() // 0160:1bafa9 +long
{
    r32[esp] -= 4;
    r32[eax] = 0;
    interrupt(0x33);
    memoryASet16(ds, 0x22465e, r16[ax]);
    r32[eax] = 0x0000000f;
    r16[cx] = 0x0008;
    r16[dx] = 0x000a;
    interrupt(0x33);
    r32[esp] += 4;
}
function* sub_1bafc3() // 0160:1bafc3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    r16[ax] += 0x0080;
    r16[bx] += 0x0080;
    r16[dx] = 0;
    { pc = 0x1bd7dd; break; }
    // gap 10236 bytes // gap 10236 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bafe1() // 0160:1bafe1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x22465e) & 0xffff))
        { pc = 0x1bb00c; break; }
    r16[cx] = memoryAGet16(ds, 0x224656);
    r16[cx] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x224658);
    r16[dx] -= 0x0008;
    r32[eax] = 0x00000004;
    interrupt(0x33);
  case 0x1bb00c: // 0160:1bb00c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bb00d() // 0160:1bb00d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x22465a, 0x0000);
    memoryASet16(ds, 0x22465c, 0x0000);
    if (!(memoryAGet16(ds, 0x22465e) & 0xffff))
        { pc = 0x1bb07e; break; }
    r32[eax] = 0x00000003;
    interrupt(0x33);
    r16[cx] >>>= 1;
    if (r16s[cx] >= signed16(0x0008))
        { pc = 0x1bb044; break; }
    r16[cx] = 0x0008;
    { pc = 0x1bb04f; break; }
  case 0x1bb044: // 0160:1bb044
    if (r16s[cx] <= signed16(0x0130))
        { pc = 0x1bb04f; break; }
    r16[cx] = 0x0130;
  case 0x1bb04f: // 0160:1bb04f
    memoryASet16(ds, 0x224656, r16[cx]);
    flags.carry = r16[dx] + 0x0008 >= 0x10000;
    r16[dx] += 0x0008;
    memoryASet16(ds, 0x224658, r16[dx]);
    r16[bx] = rcr16(r16[bx], 0x0001);
    if (!flags.carry)
        { pc = 0x1bb070; break; }
    memoryASet16(ds, 0x22465a, 0x0001);
    r32[esp] += 4; return;
  case 0x1bb070: // 0160:1bb070
    r16[bx] = rcr16(r16[bx], 0x0001);
    if (!flags.carry)
        { pc = 0x1bb07e; break; }
    memoryASet16(ds, 0x22465c, 0x0001);
  case 0x1bb07e: // 0160:1bb07e
    if (signed16(memoryAGet16(ds, 0x224656)) >= signed16(0x0008))
        { pc = 0x1bb093; break; }
    memoryASet16(ds, 0x224656, 0x0008);
    { pc = 0x1bb0a7; break; }
  case 0x1bb093: // 0160:1bb093
    if (signed16(memoryAGet16(ds, 0x224656)) <= signed16(0x0130))
        { pc = 0x1bb0a7; break; }
    memoryASet16(ds, 0x224656, 0x0130);
  case 0x1bb0a7: // 0160:1bb0a7
    if (signed16(memoryAGet16(ds, 0x224658)) >= signed16(0x0008))
        { pc = 0x1bb0bc; break; }
    memoryASet16(ds, 0x224658, 0x0008);
    { pc = 0x1bb0d0; break; }
  case 0x1bb0bc: // 0160:1bb0bc
    if (signed16(memoryAGet16(ds, 0x224658)) <= signed16(0x00d4))
        { pc = 0x1bb0d0; break; }
    memoryASet16(ds, 0x224658, 0x00d4);
  case 0x1bb0d0: // 0160:1bb0d0
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bb4ed() // 0160:1bb4ed +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bb4ed; break; }
  case 0x1bb4bc: // 0160:1bb4bc
    memoryASet16(ds, 0x22466a, 0x0001);
    memoryASet16(ds, 0x20ed4d, 0x0006);
    yield* sub_1c1c26();
    if (memoryAGet16(ds, 0x20ee81) == 0x0001)
        { pc = 0x1bb4ec; break; }
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1bb5f3; break; }
  case 0x1bb4ec: // 0160:1bb4ec
    r32[esp] += 4; return;
  case 0x1bb4ed: // 0160:1bb4ed
    memoryASet16(ds, 0x20d89b, 0x0001);
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
  case 0x1bb514: // 0160:1bb514
    if (memoryAGet16(ds, 0x20ec87) & 0xffff)
        { pc = 0x1bb614; break; }
    if (memoryAGet16(ds, 0x22464a) & 0xffff)
        { pc = 0x1bb4bc; break; }
    r32[esi] = 0x00203e0a;
    r32[edi] = 0x001ec0bc;
    memoryASet16(ds, 0x20ec9d, 0x0000);
  case 0x1bb541: // 0160:1bb541
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r32[ebx] = 0;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8[bl] == 0x37)
        { pc = 0x1bb5a1; break; }
    if (r8[bl] == 0x38)
        { pc = 0x1bb5a1; break; }
    memoryASet16(ds, 0x20d7b9, r16[bx]);
    push32(r32[esi]);
    push32(r32[edi]);
    memoryASet16(ds, 0x20eca9, 0x0001);
    yield* sub_1b8253();
    r32[edi] = pop32();
    r32[esi] = pop32();
    if (memoryAGet16(ds, 0x20ee81) == 0x0001)
        { pc = 0x1bb88b; break; }
    memoryASet16(ds, 0x20ec9d, 0x0001);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1bb5a1; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (!r8[al])
        { pc = 0x1bb5f3; break; }
  case 0x1bb5a1: // 0160:1bb5a1
    r16[ax] = memoryAGet16(ds, 0x20ecab);
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + r16[ax]);
    if (memoryAGet16(ds, 0x20ec8f) & 32768)
        { pc = 0x1bb5de; break; }
    r16[ax] = memoryAGet16(ds, 0x2247a4);
    r16[ax] += 0x0005;
    if (r16[ax] != memoryAGet16(ds, 0x20ec8f))
        { pc = 0x1bb541; break; }
    memoryASet16(ds, 0x20ec8f, 0x0000);
    { pc = 0x1bb541; break; }
  case 0x1bb5de: // 0160:1bb5de
    r16[ax] = memoryAGet16(ds, 0x2247a4);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0x20ec8f, r16[ax]);
    { pc = 0x1bb541; break; }
  case 0x1bb5f3: // 0160:1bb5f3
    memoryASet16(ds, 0x20ec9d, 0x0000);
    yield* sub_1bb8eb();
    if (memoryAGet16(ds, 0x20ee81) == 0x0001)
        { pc = 0x1bb88b; break; }
    { pc = 0x1bb8a4; break; }
  case 0x1bb614: // 0160:1bb614
    if (memoryAGet16(ds, 0x20ec87) == 0x0001)
        { pc = 0x1bb88c; break; }
    if (memoryAGet16(ds, 0x20ec87) != 0x0002)
        { pc = 0x1bb831; break; }
    r32[esi] = 0x002249f6;
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bb69f; break; }
    yield* sub_1aa9d7();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] -= 0x0030;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x6);
    r16[ax] -= 0x0030;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x7);
    r16[ax] -= 0x0030;
    r16[ax] += r16[bx];
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] = 0x0023f52c;
    { pc = 0x1bb6ac; break; }
  case 0x1bb69f: // 0160:1bb69f
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
  case 0x1bb6ac: // 0160:1bb6ac
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    yield* sub_1be39c();
    r32[edx] = 0x0020edb1;
    r32[edi] = 0x0020d787;
    r32[ecx] = 0x00000006;
  case 0x1bb6c7: // 0160:1bb6c7
    r8[al] = memoryAGet(ds, r32[edx]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edx]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1bb6c7; break; }
    yield* sub_1be39c();
    r32[edx] = 0x0020edb1;
    r32[edi] = 0x0020d78d;
    r32[ebx] = 0x0020d793;
    r32[ecx] = 0x00000006;
  case 0x1bb6e8: // 0160:1bb6e8
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[edx]++;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    memoryASet(ds, r32[ebx], r8[al]);
    r32[ebx]++;
    if (--r32[ecx])
        { pc = 0x1bb6e8; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    push32(r32[eax]);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1bb70d; break; }
    memoryASet16(ds, 0x20d8ab, 0x0005);
  case 0x1bb70d: // 0160:1bb70d
    memoryASet16(ds, 0x20d7f5, 0x0001);
    r8[al] = 0x82;
    yield* sub_1b18a6();
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bb734; break; }
    yield* sub_1bebdd();
    yield* sub_1c58cb();
    { pc = 0x1bb73e; break; }
  case 0x1bb734: // 0160:1bb734
    yield* sub_1bec59();
    yield* sub_1abc11();
  case 0x1bb73e: // 0160:1bb73e
    r32[eax] = pop32();
    memoryASet16(ds, 0x20d7f5, r16[ax]);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1bb758; break; }
    memoryASet16(ds, 0x20d8ab, 0x0000);
  case 0x1bb758: // 0160:1bb758
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    if (memoryAGet16(ds, 0x20d77b) != 0x0504)
        { pc = 0x1bb79f; break; }
    if (memoryAGet16(ds, 0x20d77d) != 0x0909)
        { pc = 0x1bb79f; break; }
    if (memoryAGet(ds, 0x20d77f) != 0x09)
        { pc = 0x1bb79f; break; }
    yield* sub_1bb8a9();
    yield* sub_1bb8ca();
  case 0x1bb79f: // 0160:1bb79f
    if (memoryAGet16(ds, 0x20ec8d) != 0x0001)
        { pc = 0x1bb7b0; break; }
    yield* sub_1bb8a9();
    { pc = 0x1bb7b5; break; }
  case 0x1bb7b0: // 0160:1bb7b0
    yield* sub_1bb8ca();
  case 0x1bb7b5: // 0160:1bb7b5
    r32[eax] = memoryAGet32(ds, 0x20d77b);
    memoryASet32(ds, 0x20ec91, r32[eax]);
    r8[al] = memoryAGet(ds, 0x20d77f);
    memoryASet(ds, 0x20ec95, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    r16[bx] = memoryAGet16(ds, 0x20ec89);
    if (r16[bx] == 0x0001)
        { pc = 0x1bb7fa; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    if (r16[bx] == 0x0002)
        { pc = 0x1bb7fa; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    if (r16[bx] == 0x0003)
        { pc = 0x1bb7fa; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
  case 0x1bb7fa: // 0160:1bb7fa
    memoryASet(ds, 0x20ec96, r8[al]);
    r32[edx] = memoryAGet32(ds, 0x20d793);
    memoryASet32(ds, 0x20ec97, r32[edx]);
    r8[dl] = memoryAGet(ds, 0x20d797);
    memoryASet(ds, 0x20ec9b, r8[dl]);
    memoryASet(ds, 0x20ec9c, r8[al]);
    memoryASet(ds, 0x20ec95, memoryAGet(ds, 0x20ec95) & 0xfe);
    memoryASet(ds, 0x20ec9b, memoryAGet(ds, 0x20ec9b) & 0xfe);
    memoryASet16(ds, 0x20ec87, memoryAGet16(ds, 0x20ec87) + 1);
  case 0x1bb831: // 0160:1bb831
    if (memoryAGet16(ds, 0x20ec87) == 0x0003)
        { pc = 0x1bb5f3; break; }
    if (memoryAGet16(ds, 0x20ec87) != 0x0004)
        { pc = 0x1bb86a; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec89);
    if (r16[ax] == memoryAGet16(ds, 0x20e90d))
        { pc = 0x1bb88c; break; }
    memoryASet16(ds, 0x20ec87, 0x0001);
    memoryASet16(ds, 0x20ec89, memoryAGet16(ds, 0x20ec89) + 1);
    { pc = 0x1bb88c; break; }
  case 0x1bb86a: // 0160:1bb86a
    if (memoryAGet16(ds, 0x20ec87) != 0x0005)
        { pc = 0x1bb88b; break; }
    memoryASet16(ds, 0x20ec87, 0x0000);
    memoryASet16(ds, 0x20ec89, 0x0001);
    { pc = 0x1bb514; break; }
  case 0x1bb88b: // 0160:1bb88b
    r32[esp] += 4; return;
  case 0x1bb88c: // 0160:1bb88c
    memoryASet16(ds, 0x20ec9d, 0x0001);
    yield* sub_1bba0a();
    if (memoryAGet16(ds, 0x20ee81) == 0x0001)
        { pc = 0x1bb88b; break; }
  case 0x1bb8a4: // 0160:1bb8a4
    { pc = 0x1bb514; break; }
    return;
  }
}
function* sub_1bb8a9() // 0160:1bb8a9 +long
{
    r32[esp] -= 4;
    memoryASet(ds, 0x20d77b, 0x05);
    memoryASet(ds, 0x20d77c, 0x00);
    memoryASet16(ds, 0x20d77d, 0x0000);
    memoryASet16(ds, 0x20d77f, 0x0000);
    r32[esp] += 4;
}
function* sub_1bb8ca() // 0160:1bb8ca +long
{
    r32[esp] -= 4;
    memoryASet(ds, 0x20d793, 0x05);
    memoryASet(ds, 0x20d794, 0x00);
    memoryASet16(ds, 0x20d795, 0x0000);
    memoryASet16(ds, 0x20d797, 0x0000);
    r32[esp] += 4;
}
function* sub_1bb8eb() // 0160:1bb8eb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    r32[edx] = 0x001ed055;
    r32[edi] = 0x000a0000;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0;
    yield* sub_1b5442();
    r32[edi] = pop32();
    yield* sub_1b5267();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b58f3();
    push32(r32[ebx]);
    push32(r32[edi]);
    r32[esi] = 0x0020e8e1;
    yield* sub_1bc288();
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1bb982; break; }
    r32[esi] = 0x0020e8e7;
    yield* sub_1bc288();
    if (memoryAGet16(ds, 0x20e90d) == 0x0002)
        { pc = 0x1bb982; break; }
    r32[esi] = 0x0020e8ed;
    yield* sub_1bc288();
    if (memoryAGet16(ds, 0x20e90d) == 0x0003)
        { pc = 0x1bb982; break; }
    r32[esi] = 0x0020e8f3;
    yield* sub_1bc288();
  case 0x1bb982: // 0160:1bb982
    r32[edi] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1bba0a; break; }
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8ed);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1bba0a; break; }
    yield* sub_1b59d4();
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8f3);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    if (memoryAGet16(ds, 0x20ceb7) >= 0x0010)
        { pc = 0x1bba0a; break; }
    yield* sub_1b59d4();
  case 0x1bba0a: // 0160:1bba0a
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20ec41, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (memoryAGet16(ds, 0x20ec87) & 0xffff)
        { pc = 0x1bba67; break; }
    if (!(memoryAGet16(ds, 0x20eccf) & 0xffff))
        { pc = 0x1bba52; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec8d);
    if (r16[ax] == 0x0001)
        { pc = 0x1bba7e; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1bba7e; break; }
  case 0x1bba52: // 0160:1bba52
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1bba7e; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1bba7e; break; }
  case 0x1bba67: // 0160:1bba67
    if (memoryAGet16(ds, 0x20ec87) != 0x0004)
        { pc = 0x1bba7e; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    r32[ebx] = 0;
    { pc = 0x1bba87; break; }
  case 0x1bba7e: // 0160:1bba7e
    r16[bx] = memoryAGet16(ds, 0x20ec89);
    r16[bx]--;
  case 0x1bba87: // 0160:1bba87
    r16[bx] <<= 1;
    r16[cx] = r16[bx];
    r16[bx] <<= 1;
    r16[bx] += r16[cx];
    r32[esi] = 0x0020e8e1;
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    memoryASet16(ds, 0x20ec9f, r16[ax]);
    yield* sub_1bd406();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e999, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x0160);
    memoryASet16(ds, 0x20ec3f, 0x0120);
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bbb00; break; }
    r32[esi] = 0x0023c4ef;
    r32[ecx] = 0x00000010;
  case 0x1bbae6: // 0160:1bbae6
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1bbaee; break; }
    r32[esi]--;
    if (--r32[ecx])
        { pc = 0x1bbae6; break; }
  case 0x1bbaee: // 0160:1bbaee
    r8[cl] += 0x02;
    if (r16[cx] >= 0x000b)
        { pc = 0x1bbafb; break; }
    r16[cx] = 0x000b;
  case 0x1bbafb: // 0160:1bbafb
    r16[bx] = r16[cx];
    { pc = 0x1bbb2b; break; }
  case 0x1bbb00: // 0160:1bbb00
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r32[esi] = 0x00203e0a;
    r32[edi] = 0x001ec0bc;
    r32[ebx] = 0;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[edi] + r32[eax]);
    r8[al] = r8[bl];
    r16[ax] <<= 2;
    r32[esi] = 0x00201804;
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x2);
  case 0x1bbb2b: // 0160:1bbb2b
    memoryASet16(ds, 0x20e99f, r16[bx]);
    r32[esi] = 0x001ec0a4;
    r32[ecx] = 0;
  case 0x1bbb39: // 0160:1bbb39
    if (r8[bl] == memoryAGet(ds, r32[esi]))
        { pc = 0x1bbb4e; break; }
    r32[esi] += 0x00000002;
    r16[cx]++;
    if (r16[cx] != 0x000b)
        { pc = 0x1bbb39; break; }
    r16[bx] = 0x0001;
    { pc = 0x1bbb53; break; }
  case 0x1bbb4e: // 0160:1bbb4e
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1bbb53: // 0160:1bbb53
    memoryASet16(ds, 0x20e9a1, r16[bx]);
    memoryASet16(ds, 0x224640, 0x0001);
    yield* sub_1bc4ef();
    yield* sub_1b5126();
    memoryASet16(ds, 0x224640, 0x0000);
    yield* sub_1bc4ef();
    yield* sub_1b5126();
    memoryASet16(ds, 0x2231c4, 0x0001);
    yield* sub_1bc4ef();
    yield* sub_1b5126();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[eax] = 0x001ec090;
    memoryASet32(ds, 0x20e843, r32[eax]);
    yield* sub_1bc40e();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bc40e();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bc40e();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bc274();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bc274();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bc274();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esi] = 0x002249f6;
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bbc5f; break; }
    yield* sub_1aa9d7();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] -= 0x0030;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x6);
    r16[ax] -= 0x0030;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x7);
    r16[ax] -= 0x0030;
    r16[ax] += r16[bx];
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] = 0x0023f52c;
    { pc = 0x1bbc6c; break; }
  case 0x1bbc5f: // 0160:1bbc5f
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
  case 0x1bbc6c: // 0160:1bbc6c
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, 0x20cebf, 0x0000);
    yield* sub_1bc3a9();
    if (memoryAGet16(ds, 0x20ceb1) & 0xffff)
        { pc = 0x1bbcb2; break; }
    yield* sub_1be39c();
    memoryASet(ds, 0x20ea29, 0xc2);
    memoryASet(ds, 0x20ea2a, 0x14);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x0e);
    yield* sub_1bc31a();
  case 0x1bbcb2: // 0160:1bbcb2
    memoryASet16(ds, 0x20cebf, 0x0001);
    yield* sub_1bc3a9();
    if (memoryAGet16(ds, 0x20ceb1) & 0xffff)
        { pc = 0x1bbcf1; break; }
    yield* sub_1be39c();
    memoryASet(ds, 0x20ea29, 0xc3);
    memoryASet(ds, 0x20ea2a, 0x54);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x0e);
    yield* sub_1bc31a();
  case 0x1bbcf1: // 0160:1bbcf1
    if (memoryAGet16(ds, 0x20ec9d) & 0xffff)
        { pc = 0x1bbd31; break; }
    if (memoryAGet16(ds, 0x20ec87) != 0x0003)
        { pc = 0x1bbd0b; break; }
    yield* sub_1bbd8b();
  case 0x1bbd0b: // 0160:1bbd0b
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1bbd1e; break; }
    memoryASet16(ds, 0x20d8ab, 0x0000);
  case 0x1bbd1e: // 0160:1bbd1e
    memoryASet16(ds, 0x20edab, 0x0000);
    yield* sub_1b4f0e();
    yield* sub_1b3af9();
  case 0x1bbd31: // 0160:1bbd31
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1bbee7; break; }
    memoryASet16(ds, 0x20ec41, memoryAGet16(ds, 0x20ec41) + 1);
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bbd54; break; }
    r32[esp] += 4; return;
  case 0x1bbd54: // 0160:1bbd54
    r32[eax] = 0x001ec090;
    memoryASet32(ds, 0x20e843, r32[eax]);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    memoryASet16(ds, 0x20ceb7, 0x0006);
    yield* sub_1bc57d();
    yield* sub_1bbee8();
    yield* sub_1bc1bf();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bbd31; break; }
    // gap 348 bytes // gap 348 bytes
  case 0x1bbee7: // 0160:1bbee7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bba0a() // 0160:1bba0a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231d4, 0x0000);
    memoryASet16(ds, 0x20ec41, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (memoryAGet16(ds, 0x20ec87) & 0xffff)
        { pc = 0x1bba67; break; }
    if (!(memoryAGet16(ds, 0x20eccf) & 0xffff))
        { pc = 0x1bba52; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec8d);
    if (r16[ax] == 0x0001)
        { pc = 0x1bba7e; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1bba7e; break; }
  case 0x1bba52: // 0160:1bba52
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1bba7e; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    { pc = 0x1bba7e; break; }
  case 0x1bba67: // 0160:1bba67
    if (memoryAGet16(ds, 0x20ec87) != 0x0004)
        { pc = 0x1bba7e; break; }
    memoryASet16(ds, 0x20e82f, 0x0001);
    r32[ebx] = 0;
    { pc = 0x1bba87; break; }
  case 0x1bba7e: // 0160:1bba7e
    r16[bx] = memoryAGet16(ds, 0x20ec89);
    r16[bx]--;
  case 0x1bba87: // 0160:1bba87
    r16[bx] <<= 1;
    r16[cx] = r16[bx];
    r16[bx] <<= 1;
    r16[bx] += r16[cx];
    r32[esi] = 0x0020e8e1;
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    memoryASet16(ds, 0x20ec9f, r16[ax]);
    yield* sub_1bd406();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e999, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x0160);
    memoryASet16(ds, 0x20ec3f, 0x0120);
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bbb00; break; }
    r32[esi] = 0x0023c4ef;
    r32[ecx] = 0x00000010;
  case 0x1bbae6: // 0160:1bbae6
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1bbaee; break; }
    r32[esi]--;
    if (--r32[ecx])
        { pc = 0x1bbae6; break; }
  case 0x1bbaee: // 0160:1bbaee
    r8[cl] += 0x02;
    if (r16[cx] >= 0x000b)
        { pc = 0x1bbafb; break; }
    r16[cx] = 0x000b;
  case 0x1bbafb: // 0160:1bbafb
    r16[bx] = r16[cx];
    { pc = 0x1bbb2b; break; }
  case 0x1bbb00: // 0160:1bbb00
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r32[esi] = 0x00203e0a;
    r32[edi] = 0x001ec0bc;
    r32[ebx] = 0;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[edi] + r32[eax]);
    r8[al] = r8[bl];
    r16[ax] <<= 2;
    r32[esi] = 0x00201804;
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x2);
  case 0x1bbb2b: // 0160:1bbb2b
    memoryASet16(ds, 0x20e99f, r16[bx]);
    r32[esi] = 0x001ec0a4;
    r32[ecx] = 0;
  case 0x1bbb39: // 0160:1bbb39
    if (r8[bl] == memoryAGet(ds, r32[esi]))
        { pc = 0x1bbb4e; break; }
    r32[esi] += 0x00000002;
    r16[cx]++;
    if (r16[cx] != 0x000b)
        { pc = 0x1bbb39; break; }
    r16[bx] = 0x0001;
    { pc = 0x1bbb53; break; }
  case 0x1bbb4e: // 0160:1bbb4e
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1bbb53: // 0160:1bbb53
    memoryASet16(ds, 0x20e9a1, r16[bx]);
    memoryASet16(ds, 0x224640, 0x0001);
    yield* sub_1bc4ef();
    yield* sub_1b5126();
    memoryASet16(ds, 0x224640, 0x0000);
    yield* sub_1bc4ef();
    yield* sub_1b5126();
    memoryASet16(ds, 0x2231c4, 0x0001);
    yield* sub_1bc4ef();
    yield* sub_1b5126();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[eax] = 0x001ec090;
    memoryASet32(ds, 0x20e843, r32[eax]);
    yield* sub_1bc40e();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bc40e();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bc40e();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bc274();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bc274();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bc274();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esi] = 0x002249f6;
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bbc5f; break; }
    yield* sub_1aa9d7();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] -= 0x0030;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x6);
    r16[ax] -= 0x0030;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x7);
    r16[ax] -= 0x0030;
    r16[ax] += r16[bx];
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] = 0x0023f52c;
    { pc = 0x1bbc6c; break; }
  case 0x1bbc5f: // 0160:1bbc5f
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
  case 0x1bbc6c: // 0160:1bbc6c
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, 0x20cebf, 0x0000);
    yield* sub_1bc3a9();
    if (memoryAGet16(ds, 0x20ceb1) & 0xffff)
        { pc = 0x1bbcb2; break; }
    yield* sub_1be39c();
    memoryASet(ds, 0x20ea29, 0xc2);
    memoryASet(ds, 0x20ea2a, 0x14);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x0e);
    yield* sub_1bc31a();
  case 0x1bbcb2: // 0160:1bbcb2
    memoryASet16(ds, 0x20cebf, 0x0001);
    yield* sub_1bc3a9();
    if (memoryAGet16(ds, 0x20ceb1) & 0xffff)
        { pc = 0x1bbcf1; break; }
    yield* sub_1be39c();
    memoryASet(ds, 0x20ea29, 0xc3);
    memoryASet(ds, 0x20ea2a, 0x54);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x0e);
    yield* sub_1bc31a();
  case 0x1bbcf1: // 0160:1bbcf1
    if (memoryAGet16(ds, 0x20ec9d) & 0xffff)
        { pc = 0x1bbd31; break; }
    if (memoryAGet16(ds, 0x20ec87) != 0x0003)
        { pc = 0x1bbd0b; break; }
    yield* sub_1bbd8b();
  case 0x1bbd0b: // 0160:1bbd0b
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1bbd1e; break; }
    memoryASet16(ds, 0x20d8ab, 0x0000);
  case 0x1bbd1e: // 0160:1bbd1e
    memoryASet16(ds, 0x20edab, 0x0000);
    yield* sub_1b4f0e();
    yield* sub_1b3af9();
  case 0x1bbd31: // 0160:1bbd31
    yield* sub_1b5096();
    yield* sub_1b3b0f();
    if (!flags.zero)
        { pc = 0x1bbee7; break; }
    memoryASet16(ds, 0x20ec41, memoryAGet16(ds, 0x20ec41) + 1);
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bbd54; break; }
    r32[esp] += 4; return;
  case 0x1bbd54: // 0160:1bbd54
    r32[eax] = 0x001ec090;
    memoryASet32(ds, 0x20e843, r32[eax]);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    memoryASet16(ds, 0x20ceb7, 0x0006);
    yield* sub_1bc57d();
    yield* sub_1bbee8();
    yield* sub_1bc1bf();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bbd31; break; }
    // gap 348 bytes // gap 348 bytes
  case 0x1bbee7: // 0160:1bbee7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bbd8b() // 0160:1bbd8b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ec8b, 0x0000);
    r32[esi] = 0x0020ec91;
    r32[edi] = 0x0020ec45;
    yield* sub_1be4a7();
    r32[esi] = 0x0020ec97;
    r32[edi] = 0x0020ec4b;
    yield* sub_1be4a7();
    r32[edi] = 0x002249f6;
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bbe21; break; }
    yield* sub_1aa9d7();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] -= 0x0030;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x6);
    r16[ax] -= 0x0030;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x7);
    r16[ax] -= 0x0030;
    r16[ax] += r16[bx];
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[edi] = 0x0023f52c;
    { pc = 0x1bbe2e; break; }
  case 0x1bbe21: // 0160:1bbe21
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
  case 0x1bbe2e: // 0160:1bbe2e
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    r16[ax] = memoryAGet16(ds, 0x20ec45);
    r16[ax] &= 0x3fff;
    r16[bx] = memoryAGet16(ds, r32[edi]);
    r16[bx] &= 0x3fff;
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1bbe55; break; }
    memoryASet16(ds, 0x20ec8b, 0x0001);
  case 0x1bbe55: // 0160:1bbe55
    r16[ax] = memoryAGet16(ds, 0x20ec4b);
    r16[ax] &= 0x3fff;
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x6);
    r16[bx] &= 0x3fff;
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1bbe8c; break; }
    if (!(memoryAGet16(ds, 0x20ec8b) & 0xffff))
        { pc = 0x1bbe83; break; }
    memoryASet16(ds, 0x20ec8b, 0x0003);
    { pc = 0x1bbe8c; break; }
  case 0x1bbe83: // 0160:1bbe83
    memoryASet16(ds, 0x20ec8b, 0x0002);
  case 0x1bbe8c: // 0160:1bbe8c
    if (!(memoryAGet16(ds, 0x20ec8b) & 0xffff))
        { pc = 0x1bbee7; break; }
    r32[esi] = 0x0020ec45;
    r32[ecx] = 0x0000000c;
    if (memoryAGet16(ds, 0x20ec8b) == 0x0003)
        { pc = 0x1bbec4; break; }
    r32[ecx] = 0x00000006;
    if (memoryAGet16(ds, 0x20ec8b) == 0x0001)
        { pc = 0x1bbec4; break; }
    r32[edi] += 0x00000006;
    r32[esi] += 0x00000006;
  case 0x1bbec4: // 0160:1bbec4
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bbedd; break; }
    yield* sub_1b2cde();
    yield* sub_1bea97();
    { pc = 0x1bbee7; break; }
  case 0x1bbedd: // 0160:1bbedd
    yield* sub_1b2d91();
    yield* sub_1beae9();
  case 0x1bbee7: // 0160:1bbee7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bbee8() // 0160:1bbee8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20ec87) & 0xffff))
        { pc = 0x1bc0e6; break; }
    if (memoryAGet16(ds, 0x20ec87) == 0x0001)
        { pc = 0x1bc0b7; break; }
    if (memoryAGet16(ds, 0x20ec87) == 0x0003)
        { pc = 0x1bbfb8; break; }
    memoryASet16(ds, 0x20edab, memoryAGet16(ds, 0x20edab) + 1);
    if (memoryAGet16(ds, 0x20edab) != 0x0bb8)
        { pc = 0x1bbf39; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0001);
    { pc = 0x1bbf4b; break; }
  case 0x1bbf39: // 0160:1bbf39
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1bbf4b; break; }
    memoryASet16(ds, 0x20edab, 0x0000);
  case 0x1bbf4b: // 0160:1bbf4b
    memoryASet16(ds, 0x20eccf, 0x0001);
    yield* sub_1bc2af();
    memoryASet16(ds, 0x20ec89, 0x0001);
    r32[esi] = 0x001eef26;
    r8[al] = 0xc4;
    r8[bl] = 0x14;
    yield* sub_1b60a7();
    r32[esi] = 0x001eefdc;
    yield* sub_1b60d3();
    r32[esi] = 0x001eefe2;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20cebb, 0x002a);
    yield* sub_1bc168();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bbfb7; break; }
    memoryASet16(ds, 0x20ec87, memoryAGet16(ds, 0x20ec87) + 0x0002);
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1bbfb7; break; }
    memoryASet16(ds, 0x20ec87, memoryAGet16(ds, 0x20ec87) - 1);
  case 0x1bbfb7: // 0160:1bbfb7
    r32[esp] += 4; return;
  case 0x1bbfb8: // 0160:1bbfb8
    yield* sub_1bc2af();
    if (!(memoryAGet16(ds, 0x20ec8b) & 0xffff))
        { pc = 0x1bbff1; break; }
    if (memoryAGet16(ds, 0x20ec8b) == 0x0001)
        { pc = 0x1bbfea; break; }
    if (memoryAGet16(ds, 0x20ec8b) == 0x0002)
        { pc = 0x1bbfe3; break; }
    r32[esi] = 0x001eef4b;
    { pc = 0x1bbff6; break; }
  case 0x1bbfe3: // 0160:1bbfe3
    r32[esi] = 0x001eef5a;
    { pc = 0x1bbff6; break; }
  case 0x1bbfea: // 0160:1bbfea
    r32[esi] = 0x001eef6c;
    { pc = 0x1bbff6; break; }
  case 0x1bbff1: // 0160:1bbff1
    r32[esi] = 0x001eef39;
  case 0x1bbff6: // 0160:1bbff6
    r8[al] = 0xc4;
    r8[bl] = 0x14;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20ec8d) == 0x0001)
        { pc = 0x1bc055; break; }
    r32[esi] = 0x001eef7f;
    yield* sub_1b60d3();
    r32[edx] = 0x0020ec91;
    if (memoryAGet(ds, r32[edx]) != 0x05)
        { pc = 0x1bc029; break; }
    r32[esi] = 0x001eef9b;
    yield* sub_1b60d3();
    { pc = 0x1bc09f; break; }
  case 0x1bc029: // 0160:1bc029
    memoryASet(ds, 0x20ea29, 0xc5);
    memoryASet(ds, 0x20ea2a, 0xdd);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x07);
    memoryASet16(ds, 0x20ceb9, 0x0000);
    yield* sub_1bc34a();
    { pc = 0x1bc09f; break; }
  case 0x1bc055: // 0160:1bc055
    r32[esi] = 0x001eef8d;
    yield* sub_1b60d3();
    r32[edx] = 0x0020ec97;
    if (memoryAGet(ds, r32[edx]) != 0x05)
        { pc = 0x1bc075; break; }
    r32[esi] = 0x001eef9b;
    yield* sub_1b60d3();
    { pc = 0x1bc09f; break; }
  case 0x1bc075: // 0160:1bc075
    memoryASet(ds, 0x20ea29, 0xc5);
    memoryASet(ds, 0x20ea2a, 0xdd);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x07);
    memoryASet16(ds, 0x20ceb9, 0x0000);
    yield* sub_1bc34a();
  case 0x1bc09f: // 0160:1bc09f
    yield* sub_1bc2de();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bc0b6; break; }
    memoryASet16(ds, 0x20ec87, memoryAGet16(ds, 0x20ec87) + 1);
  case 0x1bc0b6: // 0160:1bc0b6
    r32[esp] += 4; return;
  case 0x1bc0b7: // 0160:1bc0b7
    yield* sub_1bc2af();
    r32[esi] = 0x001eeff8;
    r8[al] = 0xc4;
    r8[bl] = 0x14;
    yield* sub_1b60a7();
    yield* sub_1bc2fe();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bc167; break; }
    memoryASet16(ds, 0x20ec87, memoryAGet16(ds, 0x20ec87) + 1);
    r32[esp] += 4; return;
  case 0x1bc0e6: // 0160:1bc0e6
    yield* sub_1bc2af();
    r32[esi] = 0x001eefe9;
    r8[al] = 0xc4;
    r8[bl] = 0x14;
    yield* sub_1b60a7();
    r32[esi] = 0x001eefc1;
    yield* sub_1b60d3();
    r32[esi] = 0x001eefca;
    yield* sub_1b60d3();
    r32[esi] = 0x001eefd4;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20cebb, 0x0042);
    yield* sub_1bc1a6();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bc167; break; }
    memoryASet16(ds, 0x20ec8d, 0x0001);
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1bc160; break; }
    memoryASet16(ds, 0x20ec8d, memoryAGet16(ds, 0x20ec8d) + 0x0002);
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1bc160; break; }
    memoryASet16(ds, 0x20ec87, 0x0005);
    r32[esp] += 4; return;
  case 0x1bc160: // 0160:1bc160
    memoryASet16(ds, 0x20ec87, memoryAGet16(ds, 0x20ec87) + 1);
  case 0x1bc167: // 0160:1bc167
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bc168() // 0160:1bc168 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0028);
    yield* sub_1b49c8();
    r16[ax] += memoryAGet16(ds, 0x20cebb);
    if (!r16[bp])
        { pc = 0x1bc19d; break; }
    r16[ax] += 0x0002;
  case 0x1bc19d: // 0160:1bc19d
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 5687 bytes // gap 5687 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc1a6() // 0160:1bc1a6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bc1a6; break; }
  case 0x1bc17f: // 0160:1bc17f
    memoryASet16(ds, 0x20ceb1, 0x0028);
    yield* sub_1b49c8();
    r16[ax] += memoryAGet16(ds, 0x20cebb);
    if (!r16[bp])
        { pc = 0x1bc19d; break; }
    r16[ax] += 0x0002;
  case 0x1bc19d: // 0160:1bc19d
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
  case 0x1bc1a6: // 0160:1bc1a6
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0003);
    memoryASet16(ds, 0x20e809, 0x0002);
    { pc = 0x1bc17f; break; }
    // gap 5662 bytes // gap 5662 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc1bf() // 0160:1bc1bf +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20ec87) != 0x0004)
        { pc = 0x1bc1cd; break; }
    r32[ecx] = 0;
    { pc = 0x1bc1da; break; }
  case 0x1bc1cd: // 0160:1bc1cd
    r16[cx] = memoryAGet16(ds, 0x20ec89);
    r16[cx]--;
    r16[cx] <<= 2;
  case 0x1bc1da: // 0160:1bc1da
    r16[cx] += 0x0012;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x001f;
    r16[bp] >>>= 4;
    if (!r16[bp])
        { pc = 0x1bc1f1; break; }
    r16[cx]++;
  case 0x1bc1f1: // 0160:1bc1f1
    if (memoryAGet16(ds, 0x20ec87) != 0x0003)
        { pc = 0x1bc20a; break; }
    if (memoryAGet16(ds, 0x20ec8b) & 0xffff)
        { pc = 0x1bc20a; break; }
    r16[cx] += 0x0002;
  case 0x1bc20a: // 0160:1bc20a
    r16[ax] = 0x0128;
    r16[bx] = 0x011e;
    r16[dx] = 0x0004;
    if (signed16(memoryAGet16(ds, 0x20ec41)) < signed16(0x00c8))
        { pc = 0x1bc22c; break; }
    r16[cx] = 0x0028;
    r16[cx] += memoryAGet16(ds, 0x20ec89);
  case 0x1bc22c: // 0160:1bc22c
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r16[bx] += 0x0030;
    r16[cx] = 0x0027;
    r16[bp] = memoryAGet16(ds, 0x20ec9f);
    memoryASet16(ds, 0x20cec3, r16[bp]);
    yield* sub_1bd51f();
    r16[ax]++;
    r16[dx] = 0x0004;
    yield* sub_1bd7dd();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[cx] = 0x0022;
    r16[dx] = 0x0008;
    { pc = 0x1bd507; break; }
    // gap 4755 bytes // gap 4755 bytes
  case 0x1bd507: // 0160:1bd507
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc274() // 0160:1bc274 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bc274; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 24235 bytes // gap 24235 bytes
  case 0x1bc274: // 0160:1bc274
    r32[esi] = 0x001eefa3;
    yield* sub_1b60d3();
    r32[esi] = 0x001eefb2;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1bc288() // 0160:1bc288 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    push32(r32[esi]);
    yield* sub_1bd346();
    r32[esi] = pop32();
    memoryASet16(ds, 0x20ceb1, 0x0001);
    memoryASet16(ds, 0x20ecbb, 0x0001);
    { pc = 0x1bd346; break; }
    // gap 4247 bytes // gap 4247 bytes
  case 0x1bd346: // 0160:1bd346
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x001ef15c;
    r32[edx] = memoryAGet32(ds, r32[edi] + r32[eax]);
    push32(r32[esi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020f1c4;
    r32[edi] = memoryAGet32(ds, 0x2231e8);
    if (!(memoryAGet16(ds, 0x20ecbb) & 0xffff))
        { pc = 0x1bd379; break; }
    r32[esi] += 0x00000060;
  case 0x1bd379: // 0160:1bd379
    r32[ebp] = r32[esi];
    memoryASet16(ds, 0x20ceb7, 0x0002);
  case 0x1bd384: // 0160:1bd384
    r32[esi] = r32[ebp];
    r32[edx] = 0x00000030;
  case 0x1bd38b: // 0160:1bd38b
    r32[ecx] = 0x0000000c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] += 0x00000110;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd38b; break; }
    r32[ebp] += 0x00000030;
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1bd384; break; }
    r32[esi] = pop32();
    r32[esi] += 0x00000002;
    memoryASet32(ds, 0x2231e8, memoryAGet32(ds, 0x2231e8) + 0x00001200);
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) - 1);
    if (memoryAGet16(ds, 0x20ceb1))
        { pc = 0x1bd346; break; }
    memoryASet16(ds, 0x20ecbb, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc2af() // 0160:1bc2af +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bc2af; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 24294 bytes // gap 24294 bytes
  case 0x1bc2af: // 0160:1bc2af
    if (memoryAGet16(ds, 0x2231d4) == 0x0002)
        { pc = 0x1bc2dd; break; }
    memoryASet16(ds, 0x2231d4, memoryAGet16(ds, 0x2231d4) + 1);
    r8[al] = 0xc5;
    r8[bl] = 0x1d;
    yield* sub_1bc2d6();
    r8[al] = 0xc5;
    r8[bl] = 0x9d;
    yield* sub_1bc2d6();
    r8[al] = 0xc6;
    r8[bl] = 0x1d;
    r8[cl] = 0x0b;
    { pc = 0x1b60e3; break; }
  case 0x1bc2dd: // 0160:1bc2dd
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bc2d6() // 0160:1bc2d6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bc2d6; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 24333 bytes // gap 24333 bytes
  case 0x1bc2d6: // 0160:1bc2d6
    r8[cl] = 0x0b;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1bc2de() // 0160:1bc2de +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1bc2fd; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1bc2fd; break; }
    memoryASet16(ds, 0x20e831, 0x0001);
  case 0x1bc2fd: // 0160:1bc2fd
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bc2fe() // 0160:1bc2fe +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x20c840);
    if (r8[al] != 0x80)
        { pc = 0x1bc319; break; }
    r8[al] = memoryAGet(ds, 0x20e837);
    if (r8[al] == 0x80)
        { pc = 0x1bc319; break; }
    memoryASet16(ds, 0x20e831, 0x0001);
  case 0x1bc319: // 0160:1bc319
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bc31a() // 0160:1bc31a +long
{
    r32[esp] -= 4;
    yield* sub_1bc33c();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bc33c();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esp] += 4;
}
function* sub_1bc33c() // 0160:1bc33c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x0020edb1;
    memoryASet16(ds, 0x20ceb9, 0x0001);
    r32[edi] = 0x0020ea2d;
    r32[ecx] = 0x00000001;
    yield* sub_1bc39e();
    memoryASet(ds, r32[edi], 0x2e);
    r32[edi]++;
    r32[ecx] = 0x00000002;
    yield* sub_1bc39e();
    memoryASet(ds, r32[edi], 0x2e);
    r32[edi]++;
    r32[ecx] = 0x00000002;
    yield* sub_1bc39e();
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1bc391; break; }
    memoryASet(ds, r32[edi], 0x20);
    r32[edi]++;
    r32[ecx] = 0x00000006;
  case 0x1bc389: // 0160:1bc389
    r8[al] = memoryAGet(ds, r32[edx]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edx]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1bc389; break; }
  case 0x1bc391: // 0160:1bc391
    push32(r32[esi]);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc34a() // 0160:1bc34a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x0020ea2d;
    r32[ecx] = 0x00000001;
    yield* sub_1bc39e();
    memoryASet(ds, r32[edi], 0x2e);
    r32[edi]++;
    r32[ecx] = 0x00000002;
    yield* sub_1bc39e();
    memoryASet(ds, r32[edi], 0x2e);
    r32[edi]++;
    r32[ecx] = 0x00000002;
    yield* sub_1bc39e();
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1bc391; break; }
    memoryASet(ds, r32[edi], 0x20);
    r32[edi]++;
    r32[ecx] = 0x00000006;
  case 0x1bc389: // 0160:1bc389
    r8[al] = memoryAGet(ds, r32[edx]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edx]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1bc389; break; }
  case 0x1bc391: // 0160:1bc391
    push32(r32[esi]);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc39e() // 0160:1bc39e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1bc39e: // 0160:1bc39e
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[edx]++;
    r8[al] += 0x30;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1bc39e; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc3a9() // 0160:1bc3a9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] &= 0x3fff;
    if (r16[ax] != 0x3a97)
        { pc = 0x1bc3e7; break; }
    push32(r32[esi]);
    r32[esi] = 0x001eef0a;
    if (!(memoryAGet16(ds, 0x20cebf) & 0xffff))
        { pc = 0x1bc3d5; break; }
    r32[esi] = 0x001eef18;
  case 0x1bc3d5: // 0160:1bc3d5
    yield* sub_1bc3e8();
    r32[esi] = pop32();
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r32[esi] += 0x00000006;
  case 0x1bc3e7: // 0160:1bc3e7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bc3e8() // 0160:1bc3e8 +long
{
    r32[esp] -= 4;
    push32(r32[esi]);
    yield* sub_1b60d3();
    r32[esi] = pop32();
    memoryASet16(ds, 0x2231c4, 0x0002);
    push32(r32[esi]);
    yield* sub_1b60d3();
    r32[esi] = pop32();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esp] += 4;
}
function* sub_1bc40e() // 0160:1bc40e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bc40e; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 24645 bytes // gap 24645 bytes
  case 0x1bc40e: // 0160:1bc40e
    if (!(memoryAGet16(ds, 0x22464a) & 0xffff))
        { pc = 0x1bc44a; break; }
    r32[esi] = 0x0023c4e0;
    r32[edi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, 0x20e99f);
    r16[ax] -= 0x0002;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r16[cx] = r16[ax];
    r32[ecx] &= 0x0000ffff;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x0020ea5b;
    r32[edi] = 0x0020e9c5;
    { pc = 0x1bc46f; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bc44a: // 0160:1bc44a
    r32[esi] = 0x0020ea5b;
    r32[edi] = 0x002084b8;
    r16[cx] = memoryAGet16(ds, 0x20e995);
    if (!r16[cx])
        { pc = 0x1bc46f; break; }
    r32[ebx] = 0;
    r32[ecx] &= 0x0000ffff;
  case 0x1bc468: // 0160:1bc468
    r8[bl] = memoryAGet(ds, r32[edi]);
    r32[edi]++;
    r32[edi] += r32[ebx];
    if (--r32[ecx])
        { pc = 0x1bc468; break; }
  case 0x1bc46f: // 0160:1bc46f
    r32[edx] = memoryAGet32(ds, 0x20e843);
    r16[ax] = memoryAGet16(ds, 0x20e9a1);
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[edx] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[edx] + r32[eax] + 0x2);
    r16[cx] += 0x0008;
    r16[cx] -= 0x0080;
    r16[cx] >>>= 3;
    r16[dx] = r16[cx];
    r16[dx] >>>= 2;
    r16[cx] &= 0x0003;
    r8[al] = 0xc0;
    r8[al] += r8[dl];
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    r16[bx] -= 0x0080;
    r16[bx] >>>= 3;
    r16[ax] = r16[cx];
    r16[cx] = 0x0040;
    mul16(r16[cx]);
    r8[bl] += r8[al];
    r8[bl] += 0x05;
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    memoryASet(ds, r32[esi], 0xf0);
    r32[esi]++;
    r8[al] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    r32[eax] &= 0x000000ff;
    r32[edi]++;
    r32[ecx] = r32[eax];
    r32[etx] = r32[esi]; r32[esi] = r32[edi]; r32[edi] = r32[etx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x0020ea5b;
    memoryASet16(ds, 0x20e905, 0x0002);
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1bc4ef() // 0160:1bc4ef +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x001ec090;
    memoryASet32(ds, 0x20e843, r32[eax]);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    memoryASet16(ds, 0x20ceb7, 0x0006);
    r32[esi] = memoryAGet32(ds, 0x20e843);
    r16[dx] = memoryAGet16(ds, 0x20e9a1);
    r16[dx] <<= 2;
    r32[edx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[edx] + 0x2);
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] += memoryAGet16(ds, 0x20e999);
    r32[ebp] = 0x00000002;
    r16[ax] += 0x001c;
    r16[cx] = memoryAGet16(ds, 0x20ceb7);
    r16[dx] = 0x0004;
    yield* sub_1bc566();
    r16[bp] = memoryAGet16(ds, 0x20e99f);
    r16[bp] -= 0x0009;
    r16[ax] += 0x0038;
    { pc = 0x1bc566; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bc566: // 0160:1bc566
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0008;
    r16[cx]++;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bc566; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc566() // 0160:1bc566 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1bc566: // 0160:1bc566
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0008;
    r16[cx]++;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bc566; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc57d() // 0160:1bc57d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1bc5a3; break; }
    memoryASet16(ds, 0x20e999, memoryAGet16(ds, 0x20e999) + 1);
    if (memoryAGet16(ds, 0x20e999) != 0x0006)
        { pc = 0x1bc5a3; break; }
    memoryASet16(ds, 0x20e999, 0x0000);
  case 0x1bc5a3: // 0160:1bc5a3
    r32[esi] = memoryAGet32(ds, 0x20e843);
    r16[dx] = memoryAGet16(ds, 0x20e9a1);
    r16[dx] <<= 2;
    r32[edx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[edx] + 0x2);
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] += memoryAGet16(ds, 0x20e999);
    r16[dx] = 0x0001;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[ebp] = 0x00000002;
    r16[ax] += 0x001c;
    r16[cx] = memoryAGet16(ds, 0x20ceb7);
    r16[dx] = 0x0004;
    yield* sub_1bc633();
    r16[bp] = memoryAGet16(ds, 0x20e99f);
    r16[bp] -= 0x0009;
    r16[ax] += 0x0038;
    yield* sub_1bc633();
    r16[ax] -= 0x0006;
    if (memoryAGet16(ds, 0x20e99f) != 0x0013)
        { pc = 0x1bc61d; break; }
    r16[ax] -= 0x0004;
  case 0x1bc61d: // 0160:1bc61d
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] += memoryAGet16(ds, 0x20e999);
    r16[dx] = 0;
    { pc = 0x1bd7dd; break; }
    // gap 4522 bytes // gap 4522 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc633() // 0160:1bc633 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1bc633: // 0160:1bc633
    r16[ax] += 0x0008;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bc633; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc63b() // 0160:1bc63b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b9017();
    if (memoryAGet16(ds, 0x20ee81))
        { pc = 0x1bc96a; break; }
    memoryASet16(ds, 0x20eda1, 0x0001);
    memoryASet16(ds, 0x20e8bb, 0x000f);
    memoryASet(ds, 0x20e82f, 0x0f);
    yield* sub_1bd2bb();
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e8df, r16[ax]);
    memoryASet16(ds, 0x20e913, 0x0003);
    r32[esi] = 0x0020e8c1;
    r32[edi] = 0x0020e915;
    r32[ecx] = 0x00000010;
  case 0x1bc690: // 0160:1bc690
    movsw_ESEDI_DSESI();
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1bc690; break; }
    yield* sub_1bc9ea();
    memoryASet16(ds, 0x20e955, 0x0001);
    yield* sub_1bcf73();
  case 0x1bc6aa: // 0160:1bc6aa
    r32[esi] = 0x0020e915;
    r32[edi] = 0x0020e989;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e913);
    r32[eax] <<= 4;
    r32[esi] += r32[eax];
    r32[ecx] = 0x00000004;
  case 0x1bc6c6: // 0160:1bc6c6
    r16[bx] = memoryAGet16(ds, r32[esi]);
    if (r16[bx] == memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bc6d8; break; }
    memoryASet16(ds, r32[edi], r16[bx]);
    r32[edi] += 0x00000002;
  case 0x1bc6d8: // 0160:1bc6d8
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1bc6c6; break; }
    r32[eax] = 0x00000004;
  case 0x1bc6e2: // 0160:1bc6e2
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 1);
    push32(r32[eax]);
    r32[ecx] = 0x00000003;
    r32[esi] = 0x0020e989;
    r32[edi] = 0x0020e8c1;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESEDI_DSESI();
    memoryASet16(ds, 0x20e8bb, 0x0003);
    r32[esi] = 0x00203d62;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e913);
    r16[cx] = 0x0038;
    mul16(r16[cx]);
    r16[bx] = 0x0003;
    r16[bx] -= memoryAGet16(ds, 0x20ceb3);
    memoryASet16(ds, 0x20ed4f, r16[bx]);
    r16[tx] = r16[bx]; r16[bx] = r16[ax]; r16[ax] = r16[tx];
    r16[cx] = 0x000e;
    mul16(r16[cx]);
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d7b9, r16[cx]);
    r32[ecx] = memoryAGet32(ds, r32[esi] + r32[eax] + 0xa);
    memoryASet32(ds, 0x20d859, r32[ecx]);
    yield* sub_1b191a();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    r8[al] = 0x80;
    yield* sub_1b18a6();
    yield* sub_1b8241();
    yield* sub_1ba9f5();
    yield* sub_1abc11();
    if (!memoryAGet16(ds, 0x20ee81))
        { pc = 0x1bc79d; break; }
    r32[eax] = pop32();
    { pc = 0x1bc96a; break; }
  case 0x1bc79d: // 0160:1bc79d
    r32[esi] = 0x0020e843;
    r32[edi] = 0x0020e8c1;
    r16[ax] = memoryAGet16(ds, 0x20d1f7);
    r16[ax]--;
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[bx]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d1f9);
    if (r16[ax])
        { pc = 0x1bc7fa; break; }
    r16[ax] = 0x0001;
    if (memoryAGet16(ds, 0x20d16d) == 0x0002)
        { pc = 0x1bc7fa; break; }
    r16[ax] = 0x0002;
    if (memoryAGet16(ds, 0x20d16f) == 0x0002)
        { pc = 0x1bc7fa; break; }
    r16[ax] = 0x0003;
    if (memoryAGet16(ds, 0x20d171) == 0x0002)
        { pc = 0x1bc7fa; break; }
    r16[ax] = 0x0004;
  case 0x1bc7fa: // 0160:1bc7fa
    r16[ax]--;
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[bx]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d1fb);
    if (r16[ax])
        { pc = 0x1bc847; break; }
    r16[ax] = 0x0001;
    if (memoryAGet16(ds, 0x20d16d) == 0x0004)
        { pc = 0x1bc847; break; }
    r16[ax] = 0x0002;
    if (memoryAGet16(ds, 0x20d16f) == 0x0004)
        { pc = 0x1bc847; break; }
    r16[ax] = 0x0003;
    if (memoryAGet16(ds, 0x20d171) == 0x0004)
        { pc = 0x1bc847; break; }
    r16[ax] = 0x0004;
  case 0x1bc847: // 0160:1bc847
    r16[ax]--;
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[bx]);
    r32[esi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, 0x20d1fd);
    if (r32[esi])
        { pc = 0x1bc891; break; }
    r16[ax] = 0x0001;
    if (memoryAGet16(ds, 0x20d16d) == 0x0006)
        { pc = 0x1bc891; break; }
    r16[ax] = 0x0002;
    if (memoryAGet16(ds, 0x20d16f) == 0x0006)
        { pc = 0x1bc891; break; }
    r16[ax] = 0x0003;
    if (memoryAGet16(ds, 0x20d171) == 0x0006)
        { pc = 0x1bc891; break; }
    r16[ax] = 0x0004;
  case 0x1bc891: // 0160:1bc891
    r16[ax]--;
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[esi], r16[bx]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e9a7, 0x0003);
    yield* sub_1b88fc();
    yield* sub_1b191a();
    r8[al] = 0x79;
    yield* sub_1b18a6();
    memoryASet(ds, 0x20e805, 0xe0);
    memoryASet(ds, 0x20eda3, 0xe0);
    memoryASet16(ds, 0x20eda1, 0x0000);
    yield* sub_1bcf73();
    r32[eax] = pop32();
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1bc6e2; break; }
    if (memoryAGet16(ds, 0x20ecb9) == 0x0063)
        { pc = 0x1bc8f4; break; }
    memoryASet16(ds, 0x20ecb9, memoryAGet16(ds, 0x20ecb9) + 1);
  case 0x1bc8f4: // 0160:1bc8f4
    r16[ax] = memoryAGet16(ds, 0x20e915);
    if (r16[ax] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bc96b; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e9c1, r16[ax]);
    memoryASet16(ds, 0x20e9c3, 0x0000);
    yield* sub_1b9ca1();
    r32[esi] = 0x002247a6;
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    r8[cl] = 0x0c;
    mul8(r8[cl]);
    r32[eax] &= 0x0000ffff;
    if (!(memoryAGet16(ds, r32[esi] + r32[eax] + 0x4) & 0xffff))
        { pc = 0x1bc94f; break; }
    memoryASet16(ds, r32[esi] + r32[eax] + 0x4, 0x0000);
    r16[bx] = memoryAGet16(ds, 0x20ecb9);
    memoryASet16(ds, r32[esi] + r32[eax] + 0x6, r16[bx]);
    { pc = 0x1bc965; break; }
  case 0x1bc94f: // 0160:1bc94f
    r16[bx] = memoryAGet16(ds, 0x20ecb9);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    if (r16s[cx] <= r16s[bx])
        { pc = 0x1bc96a; break; }
    memoryASet16(ds, r32[esi] + r32[eax] + 0x6, r16[bx]);
  case 0x1bc965: // 0160:1bc965
    yield* sub_1b2d91();
  case 0x1bc96a: // 0160:1bc96a
    r32[esp] += 4; return;
  case 0x1bc96b: // 0160:1bc96b
    yield* sub_1bc9ff();
    r32[esi] = 0x002247a6;
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    r8[cl] = 0x0c;
    mul8(r8[cl]);
    r16[ax] += 0x0004;
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[dx] = memoryAGet16(ds, 0x20e913);
    r16[dx]++;
    if (r16[cx] == 0x00ff)
        { pc = 0x1bc9b1; break; }
    if (r16s[cx] < r16s[dx])
        { pc = 0x1bc9c6; break; }
    if (r16[cx] > r16[dx])
        { pc = 0x1bc9b1; break; }
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    if (r16s[bp] <= signed16(memoryAGet16(ds, 0x20ecb9)))
        { pc = 0x1bc9c6; break; }
  case 0x1bc9b1: // 0160:1bc9b1
    memoryASet16(ds, r32[esi] + r32[eax], r16[dx]);
    r16[dx] = memoryAGet16(ds, 0x20ecb9);
    memoryASet16(ds, r32[esi] + r32[eax] + 0x2, r16[dx]);
    yield* sub_1b2d91();
  case 0x1bc9c6: // 0160:1bc9c6
    yield* sub_1bc9ea();
    if (!(memoryAGet16(ds, 0x20e9b1) & 0xffff))
        { pc = 0x1bc9e9; break; }
    memoryASet16(ds, 0x20e955, 0x0001);
    yield* sub_1bcf73();
    { pc = 0x1bc6aa; break; }
  case 0x1bc9e9: // 0160:1bc9e9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bc9ea() // 0160:1bc9ea +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020e917;
    r32[ecx] = 0x00000010;
  case 0x1bc9f4: // 0160:1bc9f4
    memoryASet16(ds, r32[esi], 0x0000);
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1bc9f4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bc9ff() // 0160:1bc9ff +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    r32[edx] = 0x0020e889;
    r32[edi] = 0x001ef454;
    r32[esi] = 0x001ef486;
    r32[ecx] = 0x00000006;
  case 0x1bca1d: // 0160:1bca1d
    r16[ax] = lodsw_DSESI();
    r16[bx] = r16[ax];
    r16[ax] &= 0x00fc;
    r16[bx] &= 0x0003;
    r16[bx] <<= 3;
    r32[eax] &= 0x0000ffff;
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[eax]);
    memoryASet16(ds, r32[edx], r16[bp]);
    r32[edx] += 0x00000002;
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[eax] + 0x2);
    memoryASet16(ds, r32[edx], r16[bp]);
    memoryASet16(ds, r32[edx], memoryAGet16(ds, r32[edx]) + r16[bx]);
    r32[edx] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1bca1d; break; }
    memoryASet16(ds, 0x2231c4, 0x0000);
    r8[al] = 0xc0;
    r8[bl] = 0xce;
    r8[cl] = 0x0c;
    memoryASet16(ds, 0x20e905, 0x0002);
    yield* sub_1b60e3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r8[al] = 0xc0;
    r8[bl] = 0xce;
    r8[cl] = 0x0c;
    yield* sub_1b60e3();
    memoryASet16(ds, 0x20e887, 0x0000);
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x20e9a9, 0x01c4);
    memoryASet16(ds, 0x20e9ab, 0x01c4);
    memoryASet16(ds, 0x20e9ad, 0x01c4);
    memoryASet16(ds, 0x20e9b1, 0x0001);
  case 0x1bcab4: // 0160:1bcab4
    yield* sub_1b5096();
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x004e))
        { pc = 0x1bcb6d; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0xf0;
    if (!r8[al])
        { pc = 0x1bcadd; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (!r8[al])
        { pc = 0x1bcb08; break; }
  case 0x1bcadd: // 0160:1bcadd
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1bcb6d; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1bcb6d; break; }
    memoryASet16(ds, 0x20e9b1, memoryAGet16(ds, 0x20e9b1) + 1);
    memoryASet16(ds, 0x20e9b1, memoryAGet16(ds, 0x20e9b1) & 0x0001);
    { pc = 0x1bcb6d; break; }
  case 0x1bcb08: // 0160:1bcb08
    memoryASet16(ds, 0x20e955, 0x0000);
    r32[esi] = 0x0020e921;
    r32[edi] = 0x0020e925;
    r32[ecx] = 0x00000003;
  case 0x1bcb20: // 0160:1bcb20
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bcb3d; break; }
    if (memoryAGet16(ds, 0x20e913) == 0x0003)
        { pc = 0x1bcb3d; break; }
    memoryASet16(ds, 0x20e913, memoryAGet16(ds, 0x20e913) + 1);
  case 0x1bcb3d: // 0160:1bcb3d
    r16[dx] = memoryAGet16(ds, r32[edi]);
    memoryASet16(ds, r32[esi], r16[dx]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bcb64; break; }
    if (!(memoryAGet16(ds, 0x20e913) & 0xffff))
        { pc = 0x1bcb64; break; }
    memoryASet16(ds, 0x20e913, memoryAGet16(ds, 0x20e913) - 1);
  case 0x1bcb64: // 0160:1bcb64
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000010;
    if (--r32[ecx])
        { pc = 0x1bcb20; break; }
    r32[esp] += 4; return;
  case 0x1bcb6d: // 0160:1bcb6d
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1bcb8a; break; }
    if (memoryAGet16(ds, 0x20e887) == 0x0064)
        { pc = 0x1bcb8a; break; }
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
  case 0x1bcb8a: // 0160:1bcb8a
    yield* sub_1bcb9e();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bcab4; break; }
    return;
  }
}
function* sub_1bcb9e() // 0160:1bcb9e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0002))
        { pc = 0x1bcc62; break; }
    if (memoryAGet16(ds, 0x20e887) > 0x0018)
        { pc = 0x1bcbdd; break; }
    if (memoryAGet16(ds, 0x20e9a9) == 0x00dc)
        { pc = 0x1bcbc9; break; }
  case 0x1bcbc1: // 0160:1bcbc1
    memoryASet16(ds, 0x20e9a9, memoryAGet16(ds, 0x20e9a9) - 0x0008);
  case 0x1bcbc9: // 0160:1bcbc9
    r16[ax] = memoryAGet16(ds, 0x20e9a9);
    r16[cx] = 0x001a;
    yield* sub_1bcee8();
    { pc = 0x1bcc62; break; }
  case 0x1bcbdd: // 0160:1bcbdd
    if (signed16(memoryAGet16(ds, 0x20e887)) <= signed16(0x001c))
        { pc = 0x1bcbc1; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0020))
        { pc = 0x1bcc62; break; }
    if (memoryAGet16(ds, 0x20e887) > 0x003a)
        { pc = 0x1bcc1f; break; }
    if (memoryAGet16(ds, 0x20e9ab) == 0x00dc)
        { pc = 0x1bcc0e; break; }
  case 0x1bcc06: // 0160:1bcc06
    memoryASet16(ds, 0x20e9ab, memoryAGet16(ds, 0x20e9ab) - 0x0008);
  case 0x1bcc0e: // 0160:1bcc0e
    r16[ax] = memoryAGet16(ds, 0x20e9ab);
    r16[cx] = 0x001b;
    yield* sub_1bcee8();
    { pc = 0x1bcc62; break; }
  case 0x1bcc1f: // 0160:1bcc1f
    if (signed16(memoryAGet16(ds, 0x20e887)) <= signed16(0x003e))
        { pc = 0x1bcc06; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0049))
        { pc = 0x1bcc62; break; }
    if (memoryAGet16(ds, 0x20e9ad) == 0x00bc)
        { pc = 0x1bcc46; break; }
    memoryASet16(ds, 0x20e9ad, memoryAGet16(ds, 0x20e9ad) - 0x0008);
  case 0x1bcc46: // 0160:1bcc46
    r16[ax] = memoryAGet16(ds, 0x20e9ad);
    r16[cx] = 0x001d;
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r16[bx] = 0x0090;
    yield* sub_1bcef5();
  case 0x1bcc62: // 0160:1bcc62
    r32[esi] = 0x0020e915;
    r32[edi] = 0x001ef486;
    r32[edx] = 0x001ef454;
    memoryASet32(ds, 0x20e815, r32[edx]);
    r32[edx] = 0x0020e889;
    memoryASet32(ds, 0x20e819, r32[edx]);
    memoryASet16(ds, 0x20e8b9, 0x0000);
    memoryASet16(ds, 0x20e7fd, 0x0010);
  case 0x1bcc94: // 0160:1bcc94
    memoryASet16(ds, 0x20e9af, 0x0000);
    if (memoryAGet16(ds, 0x20e8b9) > 0x0005)
        { pc = 0x1bccae; break; }
    yield* sub_1bcd1f();
    { pc = 0x1bccf4; break; }
  case 0x1bccae: // 0160:1bccae
    r16[dx] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    r16[cx] = r16[dx];
    r16[cx] <<= 2;
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bp] = r16[dx];
    r16[dx] &= 0x00fc;
    r16[bp] &= 0x0003;
    r16[bp] <<= 3;
    r32[edx] &= 0x0000ffff;
    r32[edx] += memoryAGet32(ds, 0x20e815);
    r16[ax] = memoryAGet16(ds, r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[edx] + 0x2);
    r16[bx] += r16[bp];
    r16[dx] = 0x0004;
    { pc = 0x1bccf8; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bccf4: // 0160:1bccf4
    r16[dx] = 0x0005;
  case 0x1bccf8: // 0160:1bccf8
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    if (memoryAGet16(ds, 0x20e9af) & 0xffff)
        { pc = 0x1bcd09; break; }
    yield* sub_1bd7dd();
  case 0x1bcd09: // 0160:1bcd09
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    memoryASet16(ds, 0x20e8b9, memoryAGet16(ds, 0x20e8b9) + 1);
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) - 1);
    if (memoryAGet16(ds, 0x20e7fd))
        { pc = 0x1bcc94; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bcd1f() // 0160:1bcd1f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0007))
        { pc = 0x1bcdca; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0013))
        { pc = 0x1bcdf1; break; }
    if (memoryAGet16(ds, 0x20e887) == 0x0013)
        { pc = 0x1bcdec; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0019))
        { pc = 0x1bcdcc; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0025))
        { pc = 0x1bcdec; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0030))
        { pc = 0x1bce06; break; }
    if (memoryAGet16(ds, 0x20e887) == 0x0030)
        { pc = 0x1bcd91; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0039))
        { pc = 0x1bce25; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0042))
        { pc = 0x1bcdec; break; }
    if (signed16(memoryAGet16(ds, 0x20e887)) < signed16(0x0047))
        { pc = 0x1bcdcc; break; }
    { pc = 0x1bcdec; break; }
  case 0x1bcd91: // 0160:1bcd91
    if (memoryAGet16(ds, 0x20e8b9) > 0x0002)
        { pc = 0x1bcdec; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8b9);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = 0x001ef47a;
    r32[edi] = 0x0020e889;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, r32[edi] + r32[eax], r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, r32[edi] + r32[eax] + 0x2, r16[dx]);
    r32[edi] = pop32();
    r32[esi] = pop32();
  case 0x1bcdca: // 0160:1bcdca
    { pc = 0x1bcdec; break; }
  case 0x1bcdcc: // 0160:1bcdcc
    if (memoryAGet16(ds, 0x20e8b9) > 0x0002)
        { pc = 0x1bcdec; break; }
    r32[edx] = memoryAGet32(ds, 0x20e819);
    memoryASet32(ds, r32[edx], memoryAGet32(ds, r32[edx]) + 0xfffffffc);
    if (memoryAGet16(ds, 0x20e8b9) != 0x0001)
        { pc = 0x1bcdec; break; }
    memoryASet32(ds, r32[edx], memoryAGet32(ds, r32[edx]) + 0x00000008);
  case 0x1bcdec: // 0160:1bcdec
    { pc = 0x1bce9a; break; }
  case 0x1bcdf1: // 0160:1bcdf1
    if (memoryAGet16(ds, 0x20e8b9) > 0x0002)
        { pc = 0x1bcdec; break; }
    memoryASet16(ds, 0x20e9af, 0x0001);
    { pc = 0x1bcdec; break; }
  case 0x1bce06: // 0160:1bce06
    if (signed16(memoryAGet16(ds, 0x20e8b9)) < signed16(0x0003))
        { pc = 0x1bcdec; break; }
    if (memoryAGet16(ds, 0x20e8b9) > 0x0005)
        { pc = 0x1bcdec; break; }
    memoryASet16(ds, 0x20e9af, 0x0001);
    { pc = 0x1bcdec; break; }
  case 0x1bce25: // 0160:1bce25
    if (signed16(memoryAGet16(ds, 0x20e8b9)) < signed16(0x0003))
        { pc = 0x1bce9a; break; }
    if (memoryAGet16(ds, 0x20e8b9) > 0x0005)
        { pc = 0x1bce9a; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8b9);
    r16[bx] = r16[ax];
    r16[ax] -= 0x0003;
    r16[ax] <<= 1;
    r16[bx] <<= 2;
    push32(r32[esi]);
    push32(r32[edi]);
    r32[eax] &= 0x0000ffff;
    r32[ebx] &= 0x0000ffff;
    r32[esi] = 0x001ef474;
    r32[edi] = 0x0020e889;
    memoryASet16(ds, r32[edi] + r32[ebx], memoryAGet16(ds, r32[edi] + r32[ebx]) - 0x0002);
    if (memoryAGet16(ds, 0x20e8b9) != 0x0004)
        { pc = 0x1bce78; break; }
    memoryASet16(ds, r32[edi] + r32[ebx], memoryAGet16(ds, r32[edi] + r32[ebx]) + 0x0004);
  case 0x1bce78: // 0160:1bce78
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    if (r16[cx] == memoryAGet16(ds, r32[edi] + r32[ebx] + 0x2))
        { pc = 0x1bce98; break; }
    memoryASet16(ds, r32[edi] + r32[ebx] + 0x2, memoryAGet16(ds, r32[edi] + r32[ebx] + 0x2) + 1);
    if (memoryAGet16(ds, 0x20e8b9) != 0x0004)
        { pc = 0x1bce98; break; }
    memoryASet16(ds, r32[edi] + r32[ebx] + 0x2, memoryAGet16(ds, r32[edi] + r32[ebx] + 0x2) - 0x0002);
  case 0x1bce98: // 0160:1bce98
    r32[edi] = pop32();
    r32[esi] = pop32();
  case 0x1bce9a: // 0160:1bce9a
    r16[cx] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    r16[cx] <<= 2;
    r32[ecx] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    if (!(memoryAGet16(ds, 0x20e9af) & 0xffff))
        { pc = 0x1bced3; break; }
    r16[dx] = memoryAGet16(ds, 0x20eeb0);
    r16[dx] &= 0x001f;
    r16[dx] >>>= 4;
    if (r16[dx])
        { pc = 0x1bced3; break; }
    memoryASet16(ds, 0x20e9af, 0x0000);
  case 0x1bced3: // 0160:1bced3
    r32[edx] = memoryAGet32(ds, 0x20e819);
    r16[ax] = memoryAGet16(ds, r32[edx]);
    r16[bx] = memoryAGet16(ds, r32[edx] + 0x2);
    memoryASet32(ds, 0x20e819, memoryAGet32(ds, 0x20e819) + 0x00000004);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bcee8() // 0160:1bcee8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r16[bx] = 0x0098;
    r16[dx] = 0x0005;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    if (memoryAGet16(ds, 0x20ceb1) & 0xffff)
        { pc = 0x1bcf18; break; }
    r16[cx] = 0x001c;
    r16[ax] += 0x0050;
    { pc = 0x1bd7dd; break; }
  case 0x1bcf18: // 0160:1bcf18
    r16[bx] += 0x0010;
    r16[ax] += 0x0044;
    r16[cx] = 0x001f;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r16[ax] += 0x0030;
    r16[cx]--;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r16[ax] -= 0x0018;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x000f;
    r16[bp] >>>= 2;
    if (r16[bp] != 0x0003)
        { pc = 0x1bcf55; break; }
    r16[bp] = 0x0001;
  case 0x1bcf55: // 0160:1bcf55
    if (memoryAGet16(ds, 0x20e9b1) & 0xffff)
        { pc = 0x1bcf67; break; }
    r16[bp] = -r16[bp];
    r16[dx] = 0x0001;
  case 0x1bcf67: // 0160:1bcf67
    r16[ax] += r16[bp];
    r16[cx] += 0x0002;
    { pc = 0x1bd7dd; break; }
    // gap 2154 bytes // gap 2154 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bcef5() // 0160:1bcef5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[dx] = 0x0005;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    if (memoryAGet16(ds, 0x20ceb1) & 0xffff)
        { pc = 0x1bcf18; break; }
    r16[cx] = 0x001c;
    r16[ax] += 0x0050;
    { pc = 0x1bd7dd; break; }
  case 0x1bcf18: // 0160:1bcf18
    r16[bx] += 0x0010;
    r16[ax] += 0x0044;
    r16[cx] = 0x001f;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r16[ax] += 0x0030;
    r16[cx]--;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r16[ax] -= 0x0018;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x000f;
    r16[bp] >>>= 2;
    if (r16[bp] != 0x0003)
        { pc = 0x1bcf55; break; }
    r16[bp] = 0x0001;
  case 0x1bcf55: // 0160:1bcf55
    if (memoryAGet16(ds, 0x20e9b1) & 0xffff)
        { pc = 0x1bcf67; break; }
    r16[bp] = -r16[bp];
    r16[dx] = 0x0001;
  case 0x1bcf67: // 0160:1bcf67
    r16[ax] += r16[bp];
    r16[cx] += 0x0002;
    { pc = 0x1bd7dd; break; }
    // gap 2154 bytes // gap 2154 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bcf73() // 0160:1bcf73 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1b596f();
    yield* sub_1bd478();
    r32[edx] = 0x001ed040;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1bd879();
    yield* sub_1bd1ac();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bd1ac();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1bd1ac();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
    if (memoryAGet16(ds, 0x20e955) & 0xffff)
        { pc = 0x1bcff9; break; }
    yield* sub_1bd042();
  case 0x1bcff9: // 0160:1bcff9
    yield* sub_1b5096();
    if (!(memoryAGet(ds, 0x20c840) & 0xff))
        { pc = 0x1bd01e; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1bd01e; break; }
    memoryASet16(ds, 0x20e955, 0x0000);
    r32[esp] += 4; return;
  case 0x1bd01e: // 0160:1bd01e
    r32[esi] = 0x001eeefa;
    memoryASet16(ds, 0x20e905, 0x0002);
    yield* sub_1b60d3();
    yield* sub_1bd1d4();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bcff9; break; }
    return;
  }
}
function* sub_1bd042() // 0160:1bd042 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e8bb, 0x0004);
    memoryASet(ds, 0x20e82f, 0x03);
    r16[ax] = memoryAGet16(ds, 0x20e8e1);
    memoryASet16(ds, 0x20e8e7, r16[ax]);
    memoryASet16(ds, 0x20e8e1, 0x00ff);
    r32[edx] = 0x0020e917;
    memoryASet16(ds, 0x20e887, 0x0000);
    r32[ecx] = 0x00000004;
  case 0x1bd07a: // 0160:1bd07a
    r16[bp] = memoryAGet16(ds, 0x20e913);
    if (r16[bp] != memoryAGet16(ds, 0x20e887))
        { pc = 0x1bd094; break; }
    yield* sub_1bd124();
    r32[edx] += 0x00000010;
    { pc = 0x1bd0c9; break; }
  case 0x1bd094: // 0160:1bd094
    push32(r32[ecx]);
    push32(r32[edx]);
    yield* sub_1bd2c7();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = 0x00000004;
    r32[esi] = 0x0020e8c1;
  case 0x1bd0a7: // 0160:1bd0a7
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 1);
    r32[esi] += 0x00000002;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bd0a7; break; }
    r32[ebx] = 0x00000004;
    r32[edi] = 0x0020e8c1;
  case 0x1bd0ba: // 0160:1bd0ba
    r16[bp] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    memoryASet16(ds, r32[edx], memoryAGet16(ds, r32[edx]) + r16[bp]);
    r32[edx] += 0x00000004;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bd0ba; break; }
  case 0x1bd0c9: // 0160:1bd0c9
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    if (--r32[ecx])
        { pc = 0x1bd07a; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8e7);
    memoryASet16(ds, 0x20e8e1, r16[ax]);
    memoryASet16(ds, 0x20e809, 0x0004);
    r32[eax] = 0x0020e917;
    memoryASet32(ds, 0x20e877, r32[eax]);
    r32[eax] = 0x0020e91b;
    memoryASet32(ds, 0x20e87b, r32[eax]);
  case 0x1bd0fb: // 0160:1bd0fb
    push32(memoryAGet32(ds, 0x20e809));
    yield* sub_1bd15a();
    memoryASet32(ds, 0x20e877, memoryAGet32(ds, 0x20e877) + 0x00000010);
    memoryASet32(ds, 0x20e87b, memoryAGet32(ds, 0x20e87b) + 0x00000010);
    memoryASet32(ds, 0x20e809, pop32());
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 1);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1bd0fb; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd124() // 0160:1bd124 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    r32[edx] -= 0x00000006;
    r32[edi] = r32[edx];
    r32[eax] = 0x00000004;
    r32[ebx] = 0x00000004;
    r32[esi] = 0x0020e843;
  case 0x1bd139: // 0160:1bd139
    r32[edx] = r32[edi];
    r16[bp] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    r32[ecx] = 0x00000004;
  case 0x1bd146: // 0160:1bd146
    r32[edx] += 0x00000004;
    if (r16[bp] == memoryAGet16(ds, r32[edx]))
        { pc = 0x1bd150; break; }
    if (--r32[ecx])
        { pc = 0x1bd146; break; }
  case 0x1bd150: // 0160:1bd150
    memoryASet16(ds, r32[edx] + 0x2, memoryAGet16(ds, r32[edx] + 0x2) + r16[ax]);
    r32[eax]--;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bd139; break; }
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd15a() // 0160:1bd15a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x00000003;
  case 0x1bd15f: // 0160:1bd15f
    r32[esi] = memoryAGet32(ds, 0x20e877);
    r32[edi] = memoryAGet32(ds, 0x20e87b);
    yield* sub_1bd184();
    yield* sub_1bd17e();
    yield* sub_1bd17e();
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1bd15f; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd17e() // 0160:1bd17e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000004;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r16[cx] = memoryAGet16(ds, r32[edi]);
    if (r16s[bx] < r16s[cx])
        { pc = 0x1bd19f; break; }
    if (r16[bx] > r16[cx])
        { pc = 0x1bd19e; break; }
    r16[bp] = memoryAGet16(ds, r32[edi] - 2);
    if (r16[bp] == memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd19f; break; }
  case 0x1bd19e: // 0160:1bd19e
    r32[esp] += 4; return;
  case 0x1bd19f: // 0160:1bd19f
    r32[edx] = memoryAGet32(ds, r32[esi] - 2);
    r32[ebp] = memoryAGet32(ds, r32[edi] - 2);
    memoryASet32(ds, r32[esi] - 2, r32[ebp]);
    memoryASet32(ds, r32[edi] - 2, r32[edx]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd184() // 0160:1bd184 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r16[cx] = memoryAGet16(ds, r32[edi]);
    if (r16s[bx] < r16s[cx])
        { pc = 0x1bd19f; break; }
    if (r16[bx] > r16[cx])
        { pc = 0x1bd19e; break; }
    r16[bp] = memoryAGet16(ds, r32[edi] - 2);
    if (r16[bp] == memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd19f; break; }
  case 0x1bd19e: // 0160:1bd19e
    r32[esp] += 4; return;
  case 0x1bd19f: // 0160:1bd19f
    r32[edx] = memoryAGet32(ds, r32[esi] - 2);
    r32[ebp] = memoryAGet32(ds, r32[edi] - 2);
    memoryASet32(ds, r32[esi] - 2, r32[ebp]);
    memoryASet32(ds, r32[edi] - 2, r32[edx]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd1ac() // 0160:1bd1ac +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x001eeeba;
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[eax] = 0x00000004;
  case 0x1bd1bf: // 0160:1bd1bf
    r32[esi] = r32[edi];
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[edi] + 0x3);
    r32[edi] += r32[ebx];
    r32[edi] += 0x00000004;
    yield* sub_1bd2a7();
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1bd1bf; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd1d4() // 0160:1bd1d4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020e915;
    r32[edi] = 0x001ef454;
    r32[ebp] = 0x00000004;
  case 0x1bd1e3: // 0160:1bd1e3
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x2);
    r32[edi] += 0x00000004;
    memoryASet16(ds, 0x20e801, 0x0004);
  case 0x1bd1f6: // 0160:1bd1f6
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16[cx] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd21b; break; }
    r16[dx] = memoryAGet16(ds, 0x20eeb0);
    r16[dx] &= 0x001f;
    r16[dx] >>>= 4;
    if (!r16[dx])
        { pc = 0x1bd230; break; }
    r16[dx] = 0;
    { pc = 0x1bd21f; break; }
  case 0x1bd21b: // 0160:1bd21b
    r16[dx] = 0x0004;
  case 0x1bd21f: // 0160:1bd21f
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1bd230: // 0160:1bd230
    r16[dx] = 0x0004;
    yield* sub_1bd24a();
    r16[bx] += 0x0008;
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - 1);
    if (memoryAGet16(ds, 0x20e801))
        { pc = 0x1bd1f6; break; }
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bd1e3; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd24a() // 0160:1bd24a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    r16[cx] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20ceb1, 0x0000);
  case 0x1bd257: // 0160:1bd257
    if (r16s[cx] < signed16(0x000a))
        { pc = 0x1bd26a; break; }
    r16[cx] -= 0x000a;
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) + 1);
    { pc = 0x1bd257; break; }
  case 0x1bd26a: // 0160:1bd26a
    r16[ax] += 0x0058;
    r16[cx] += 0x0010;
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1bd7dd();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1bd2a2; break; }
    r16[ax] -= 0x0008;
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    r16[cx] += 0x0010;
    r16[dx] = 0;
    yield* sub_1bd7dd();
  case 0x1bd2a2: // 0160:1bd2a2
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r32[esi] += 0x00000002;
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd2a7() // 0160:1bd2a7 +long
{
    r32[esp] -= 4;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1b6113();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r32[esi] = 0x0020e9c5;
    r32[etx] = r32[esp]; push32(r32[eax]); push32(r32[ecx]); push32(r32[edx]); push32(r32[ebx]); push32(r32[etx]); push32(r32[ebp]); push32(r32[esi]); push32(r32[edi]);
    yield* sub_1b6269();
    r32[edi] = pop32(); r32[esi] = pop32(); r32[ebp] = pop32(); r32[esp] = r32[esp] + 4; r32[ebx] = pop32(); r32[edx] = pop32(); r32[ecx] = pop32(); r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1bd2bb() // 0160:1bd2bb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    memoryASet16(ds, 0x20c84e, r16[ax]);
    memoryASet16(ds, 0x20e8bd, 0x0000);
    r32[esi] = 0x0020e8c1;
  case 0x1bd2d5: // 0160:1bd2d5
    r16[ax] = memoryAGet16(ds, 0x20e8bd);
    if (r16[ax] == memoryAGet16(ds, 0x20e8bb))
        { pc = 0x1bd345; break; }
    yield* sub_1b1c22();
    r8[al] &= memoryAGet(ds, 0x20e82f);
    if (memoryAGet16(ds, 0x20e8bd) & 0xffff)
        { pc = 0x1bd31a; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd30b; break; }
    r8[al]++;
    r8[al] &= memoryAGet(ds, 0x20e82f);
  case 0x1bd30b: // 0160:1bd30b
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e8bd, memoryAGet16(ds, 0x20e8bd) + 1);
    { pc = 0x1bd2d5; break; }
  case 0x1bd31a: // 0160:1bd31a
    r16[bx] = memoryAGet16(ds, 0x20e8bd);
    r32[edi] = 0x0020e8c1;
  case 0x1bd326: // 0160:1bd326
    if (r16[ax] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1bd33b; break; }
    r32[edi] += 0x00000002;
    r16[bx]--;
    if (r16[bx])
        { pc = 0x1bd326; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd30b; break; }
  case 0x1bd33b: // 0160:1bd33b
    r8[al]++;
    r8[al] &= memoryAGet(ds, 0x20e82f);
    { pc = 0x1bd31a; break; }
  case 0x1bd345: // 0160:1bd345
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bd2c7() // 0160:1bd2c7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e8bd, 0x0000);
    r32[esi] = 0x0020e8c1;
  case 0x1bd2d5: // 0160:1bd2d5
    r16[ax] = memoryAGet16(ds, 0x20e8bd);
    if (r16[ax] == memoryAGet16(ds, 0x20e8bb))
        { pc = 0x1bd345; break; }
    yield* sub_1b1c22();
    r8[al] &= memoryAGet(ds, 0x20e82f);
    if (memoryAGet16(ds, 0x20e8bd) & 0xffff)
        { pc = 0x1bd31a; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd30b; break; }
    r8[al]++;
    r8[al] &= memoryAGet(ds, 0x20e82f);
  case 0x1bd30b: // 0160:1bd30b
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e8bd, memoryAGet16(ds, 0x20e8bd) + 1);
    { pc = 0x1bd2d5; break; }
  case 0x1bd31a: // 0160:1bd31a
    r16[bx] = memoryAGet16(ds, 0x20e8bd);
    r32[edi] = 0x0020e8c1;
  case 0x1bd326: // 0160:1bd326
    if (r16[ax] == memoryAGet16(ds, r32[edi]))
        { pc = 0x1bd33b; break; }
    r32[edi] += 0x00000002;
    r16[bx]--;
    if (r16[bx])
        { pc = 0x1bd326; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20e8e1))
        { pc = 0x1bd30b; break; }
  case 0x1bd33b: // 0160:1bd33b
    r8[al]++;
    r8[al] &= memoryAGet(ds, 0x20e82f);
    { pc = 0x1bd31a; break; }
  case 0x1bd345: // 0160:1bd345
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bd346() // 0160:1bd346 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1bd346: // 0160:1bd346
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x001ef15c;
    r32[edx] = memoryAGet32(ds, r32[edi] + r32[eax]);
    push32(r32[esi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020f1c4;
    r32[edi] = memoryAGet32(ds, 0x2231e8);
    if (!(memoryAGet16(ds, 0x20ecbb) & 0xffff))
        { pc = 0x1bd379; break; }
    r32[esi] += 0x00000060;
  case 0x1bd379: // 0160:1bd379
    r32[ebp] = r32[esi];
    memoryASet16(ds, 0x20ceb7, 0x0002);
  case 0x1bd384: // 0160:1bd384
    r32[esi] = r32[ebp];
    r32[edx] = 0x00000030;
  case 0x1bd38b: // 0160:1bd38b
    r32[ecx] = 0x0000000c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] += 0x00000110;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd38b; break; }
    r32[ebp] += 0x00000030;
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1bd384; break; }
    r32[esi] = pop32();
    r32[esi] += 0x00000002;
    memoryASet32(ds, 0x2231e8, memoryAGet32(ds, 0x2231e8) + 0x00001200);
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) - 1);
    if (memoryAGet16(ds, 0x20ceb1))
        { pc = 0x1bd346; break; }
    memoryASet16(ds, 0x20ecbb, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd3c8() // 0160:1bd3c8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ecccf;
    yield* sub_1b52a1();
    r32[esi] = 0x0020f1c4;
    r32[edi] = 0x0029b134;
    r32[ebx] = r32[esi];
    r32[edx] = 0x00000027;
  case 0x1bd3e3: // 0160:1bd3e3
    r32[esi] = r32[ebx];
    r32[ecx] = 0x00000008;
  case 0x1bd3ea: // 0160:1bd3ea
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000140;
    if (--r32[ecx])
        { pc = 0x1bd3ea; break; }
    r32[ebx] += 0x00000008;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd3e3; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd406() // 0160:1bd406 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bp] = r16[ax];
    r32[esi] = 0x00224866;
    r16[ax] <<= 1;
    r16[dx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[dx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[ebp] = memoryAGet32(ds, 0x2231e4);
    memoryASet16(ds, 0x20ceb1, 0x0001);
    { pc = 0x1bd48e; break; }
    // gap 92 bytes // gap 92 bytes
  case 0x1bd48e: // 0160:1bd48e
    r32[edi] = r32[ebp];
    r32[edx] = 0x00000006;
  case 0x1bd495: // 0160:1bd495
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] >= 0x40)
        { pc = 0x1bd4bd; break; }
    if (r8[al] == 0x20)
        { pc = 0x1bd4b9; break; }
    if (r8s[al] < signed8(0x30))
        { pc = 0x1bd4a7; break; }
    if (r8s[al] <= signed8(0x39))
        { pc = 0x1bd4b3; break; }
  case 0x1bd4a7: // 0160:1bd4a7
    if (r8[al] == 0x2f)
        { pc = 0x1bd4af; break; }
    r8[al] = 0x26;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4af: // 0160:1bd4af
    r8[al] = 0x25;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4b3: // 0160:1bd4b3
    r8[al] -= 0x30;
    r8[al] += 0x1b;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4b9: // 0160:1bd4b9
    r8[al] = 0;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4bd: // 0160:1bd4bd
    r8[al] -= 0x40;
  case 0x1bd4bf: // 0160:1bd4bf
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 6;
    r32[ebx] = 0x0029b134;
    r32[ebx] += r32[eax];
    r32[ecx] = 0x00000008;
  case 0x1bd4d3: // 0160:1bd4d3
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[ebx] += 0x00000008;
    r32[edi] += 0x00000030;
    if (--r32[ecx])
        { pc = 0x1bd4d3; break; }
    r32[edi] -= 0x00000178;
    r32[esi]++;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd495; break; }
    r32[ebp] += 0x00000180;
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) - 1);
    if (memoryAGet16(ds, 0x20ceb1))
        { pc = 0x1bd48e; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd478() // 0160:1bd478 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00224866;
    r32[edi] = memoryAGet32(ds, 0x2231e4);
    r32[ebp] = r32[edi];
    memoryASet16(ds, 0x20ceb1, 0x0010);
  case 0x1bd48e: // 0160:1bd48e
    r32[edi] = r32[ebp];
    r32[edx] = 0x00000006;
  case 0x1bd495: // 0160:1bd495
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] >= 0x40)
        { pc = 0x1bd4bd; break; }
    if (r8[al] == 0x20)
        { pc = 0x1bd4b9; break; }
    if (r8s[al] < signed8(0x30))
        { pc = 0x1bd4a7; break; }
    if (r8s[al] <= signed8(0x39))
        { pc = 0x1bd4b3; break; }
  case 0x1bd4a7: // 0160:1bd4a7
    if (r8[al] == 0x2f)
        { pc = 0x1bd4af; break; }
    r8[al] = 0x26;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4af: // 0160:1bd4af
    r8[al] = 0x25;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4b3: // 0160:1bd4b3
    r8[al] -= 0x30;
    r8[al] += 0x1b;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4b9: // 0160:1bd4b9
    r8[al] = 0;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4bd: // 0160:1bd4bd
    r8[al] -= 0x40;
  case 0x1bd4bf: // 0160:1bd4bf
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 6;
    r32[ebx] = 0x0029b134;
    r32[ebx] += r32[eax];
    r32[ecx] = 0x00000008;
  case 0x1bd4d3: // 0160:1bd4d3
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[ebx] += 0x00000008;
    r32[edi] += 0x00000030;
    if (--r32[ecx])
        { pc = 0x1bd4d3; break; }
    r32[edi] -= 0x00000178;
    r32[esi]++;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd495; break; }
    r32[ebp] += 0x00000180;
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) - 1);
    if (memoryAGet16(ds, 0x20ceb1))
        { pc = 0x1bd48e; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd4ff() // 0160:1bd4ff +long
{
    r32[esp] -= 4;
    r16[dx] = 0x0008;
    r16[cx] = 0x0024;
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1bd507() // 0160:1bd507 +long
{
    r32[esp] -= 4;
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1bd50f() // 0160:1bd50f +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1bd51f() // 0160:1bd51f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[esi] = 0x00224866;
    r16[bx] = r16[ax];
    r16[ax] <<= 2;
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[ebp] = 0x00000006;
  case 0x1bd54c: // 0160:1bd54c
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1bd552; break; }
    r32[edx]++;
  case 0x1bd552: // 0160:1bd552
    r32[esi]++;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bd54c; break; }
    flags.carry = 0;
    r32[edx] = rcr32(r32[edx], 0x00000001);
    if (!flags.carry)
        { pc = 0x1bd55e; break; }
    r32[ecx] += 0x00000004;
  case 0x1bd55e: // 0160:1bd55e
    r32[eax] = pop32();
    r32[eax] += r32[ecx];
    r32[edx] <<= 3;
    r32[eax] += r32[edx];
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd56b() // 0160:1bd56b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd56b; break; }
  case 0x1b5dcb: // 0160:1b5dcb
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 30375 bytes // gap 30375 bytes
  case 0x1bd56b: // 0160:1bd56b
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x2231d8, r32[eax]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    if (r16s[bx] >= 0)
        { pc = 0x1bd630; break; }
    r16[bx] = -r16[bx];
    if (signed16(memoryAGet16(ds, r32[edi])) <= r16s[bx])
        { pc = 0x1bd6c8; break; }
    r16[dx] = memoryAGet16(ds, r32[edi]);
    r16[dx] -= r16[bx];
    r32[ebx] &= 0x0000ffff;
    r32[edx] &= 0x0000ffff;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x2);
    r32[edi] = 0x002915ac;
    push32(r32[ecx]);
    r16[cx] = r16[dx];
    r16[cx] &= 0x0003;
    r16[ax] = 0x0004;
    r16[ax] -= r16[cx];
    memoryASet16(ds, 0x20ceb1, r16[ax]);
    r32[ebp] = r32[esi];
  case 0x1bd5e8: // 0160:1bd5e8
    r32[esi] = r32[ebp];
    r32[ecx] = r32[edx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    if (r16[cx] == 0x0004)
        { pc = 0x1bd5ff; break; }
    r8[al] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
  case 0x1bd5ff: // 0160:1bd5ff
    r32[ebp] += memoryAGet32(ds, 0x2231d8);
    r16[bx]--;
    if (r16[bx])
        { pc = 0x1bd5e8; break; }
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) & 0x0003);
    r16[dx] += memoryAGet16(ds, 0x20ceb1);
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    r32[esi] = 0x002915ac;
    r32[ecx] = pop32();
    r32[ebx] = 0;
  case 0x1bd62b: // 0160:1bd62b
    { pc = 0x1b5dcb; break; }
  case 0x1bd630: // 0160:1bd630
    r16[dx] = r16[bx];
    r16[dx] += memoryAGet16(ds, r32[edi]);
    if (r16s[dx] < signed16(0x0140))
        { pc = 0x1bd62b; break; }
    if (r16[bx] >= 0x0140)
        { pc = 0x1bd6c8; break; }
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] += r16[bx];
    r16[ax] -= 0x0140;
    r16[dx] = memoryAGet16(ds, r32[edi]);
    r16[dx] -= r16[ax];
    push32(r32[ecx]);
    r16[cx] = r16[dx];
    r16[cx] &= 0x0003;
    r16[ax] = 0x0004;
    r16[ax] -= r16[cx];
    memoryASet16(ds, 0x20ceb1, r16[ax]);
    r16[bx] = memoryAGet16(ds, r32[edi] + 0x2);
    r32[edi] = 0x002915ac;
    r32[ecx] = 0;
    r32[ebp] = r32[esi];
  case 0x1bd67a: // 0160:1bd67a
    r32[esi] = r32[ebp];
    r16[cx] = memoryAGet16(ds, 0x20ceb1);
    if (r16[cx] == 0x0004)
        { pc = 0x1bd68d; break; }
    r8[al] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
  case 0x1bd68d: // 0160:1bd68d
    r16[cx] = r16[dx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ebp] += memoryAGet32(ds, 0x2231d8);
    r16[bx]--;
    if (r16[bx])
        { pc = 0x1bd67a; break; }
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) & 0x0003);
    r16[dx] += memoryAGet16(ds, 0x20ceb1);
    r16[bx] = 0x0140;
    r16[bx] -= r16[dx];
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    r32[ecx] = pop32();
    r32[esi] = 0x002915ac;
    { pc = 0x1b5dcb; break; }
  case 0x1bd6c8: // 0160:1bd6c8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bd6c9() // 0160:1bd6c9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd6c9; break; }
  case 0x1b5dcb: // 0160:1b5dcb
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 30725 bytes // gap 30725 bytes
  case 0x1bd6c9: // 0160:1bd6c9
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r32[esi] += 0x000000e0;
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x2231d8, r32[eax]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x2, 0x003c);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    { pc = 0x1bd742; break; }
    // gap 55 bytes // gap 55 bytes
  case 0x1bd742: // 0160:1bd742
    if (r16s[cx] >= 0)
        { pc = 0x1bd790; break; }
    r16[cx] = -r16[cx];
    if (signed16(memoryAGet16(ds, r32[edi] + 0x2)) <= r16s[cx])
        { pc = 0x1bd7dc; break; }
    r32[edi] = 0x002915ac;
    r32[eax] = memoryAGet32(ds, 0x2231d8);
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r16[dx] = memoryAGet16(ds, 0x224636);
    r16[dx] -= r16[cx];
    memoryASet16(ds, 0x224636, r16[dx]);
    r32[ecx] = 0;
  case 0x1bd776: // 0160:1bd776
    r16[cx] = memoryAGet16(ds, 0x224634);
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1bd776; break; }
    r16[cx] = 0;
    r32[esi] = 0x002915ac;
  case 0x1bd78b: // 0160:1bd78b
    { pc = 0x1b5dcb; break; }
  case 0x1bd790: // 0160:1bd790
    if (r16[cx] >= 0x00e0)
        { pc = 0x1bd7dc; break; }
    r16[dx] = memoryAGet16(ds, r32[edi] + 0x2);
    r16[dx] += r16[cx];
    if (r16s[dx] < signed16(0x00e0))
        { pc = 0x1bd78b; break; }
    r16[dx] = 0x00e0;
    r16[dx] -= r16[cx];
    memoryASet16(ds, 0x224636, r16[dx]);
    r32[edi] = 0x002915ac;
    r32[ecx] = 0;
  case 0x1bd7ba: // 0160:1bd7ba
    r16[cx] = memoryAGet16(ds, 0x224634);
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1bd7ba; break; }
    r16[cx] = 0x00e0;
    r16[cx] -= memoryAGet16(ds, 0x224636);
    r32[esi] = 0x002915ac;
    { pc = 0x1b5dcb; break; }
  case 0x1bd7dc: // 0160:1bd7dc
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bd70e() // 0160:1bd70e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd70e; break; }
  case 0x1b5dcb: // 0160:1b5dcb
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1b5de3; break; }
    r32[edi] = 0x000a4800;
  case 0x1b5de3: // 0160:1b5de3
    memoryASet32(ds, 0x224630, r32[edi]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    if (memoryAGet32(ds, 0x224630) != 0x000a0000)
        { pc = 0x1b5e26; break; }
    yield* sub_1b5ec4();
    { pc = 0x1b5e2b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1b5e26: // 0160:1b5e26
    yield* sub_1b5f0f();
  case 0x1b5e2b: // 0160:1b5e2b
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1b5e63: // 0160:1b5e63
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1b5e7a: // 0160:1b5e7a
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1b5e81: // 0160:1b5e81
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5e90; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5e90: // 0160:1b5e90
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5e81; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b5e7a; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1b5ebd; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5e63; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1b5e63; break; }
  case 0x1b5ebd: // 0160:1b5ebd
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 30794 bytes // gap 30794 bytes
  case 0x1bd70e: // 0160:1bd70e
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet32(ds, 0x2231d8, r32[eax]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    if (r16s[cx] >= 0)
        { pc = 0x1bd790; break; }
    r16[cx] = -r16[cx];
    if (signed16(memoryAGet16(ds, r32[edi] + 0x2)) <= r16s[cx])
        { pc = 0x1bd7dc; break; }
    r32[edi] = 0x002915ac;
    r32[eax] = memoryAGet32(ds, 0x2231d8);
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r16[dx] = memoryAGet16(ds, 0x224636);
    r16[dx] -= r16[cx];
    memoryASet16(ds, 0x224636, r16[dx]);
    r32[ecx] = 0;
  case 0x1bd776: // 0160:1bd776
    r16[cx] = memoryAGet16(ds, 0x224634);
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1bd776; break; }
    r16[cx] = 0;
    r32[esi] = 0x002915ac;
  case 0x1bd78b: // 0160:1bd78b
    { pc = 0x1b5dcb; break; }
  case 0x1bd790: // 0160:1bd790
    if (r16[cx] >= 0x00e0)
        { pc = 0x1bd7dc; break; }
    r16[dx] = memoryAGet16(ds, r32[edi] + 0x2);
    r16[dx] += r16[cx];
    if (r16s[dx] < signed16(0x00e0))
        { pc = 0x1bd78b; break; }
    r16[dx] = 0x00e0;
    r16[dx] -= r16[cx];
    memoryASet16(ds, 0x224636, r16[dx]);
    r32[edi] = 0x002915ac;
    r32[ecx] = 0;
  case 0x1bd7ba: // 0160:1bd7ba
    r16[cx] = memoryAGet16(ds, 0x224634);
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1bd7ba; break; }
    r16[cx] = 0x00e0;
    r16[cx] -= memoryAGet16(ds, 0x224636);
    r32[esi] = 0x002915ac;
    { pc = 0x1b5dcb; break; }
  case 0x1bd7dc: // 0160:1bd7dc
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bd7dd() // 0160:1bd7dd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd825() // 0160:1bd825 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    push32(r32[eax]);
    r16[dx] = 0x03ce;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = in8(r16[dx]);
    memoryASet16(ds, 0x22463e, r16[ax]);
    r8[al] &= 0xfc;
    r8[al] |= 0x01;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x0f;
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[eax] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1bd849() // 0160:1bd849 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    push32(r32[eax]);
    r16[dx] = 0x03ce;
    r16[ax] = memoryAGet16(ds, 0x22463e);
    r8[ah] = r8[al];
    r8[al] = 0x05;
    out16(r16[dx], r16[ax]);
    r32[eax] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1bd85e() // 0160:1bd85e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd85e; break; }
  case 0x1b5442: // 0160:1b5442
    r32[edi] = 0x0020c88f;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[ebp] = r32[edx];
    r32[edx] += r32[edx];
    r32[edx] += r32[ebp];
    r32[esi] += r32[edx];
    r32[edi] += r32[edx];
  case 0x1b5455: // 0160:1b5455
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5455; break; }
    r32[esp] += 4; return;
    // gap 33767 bytes // gap 33767 bytes
  case 0x1bd85e: // 0160:1bd85e
    r32[edx] = 0x001ecb53;
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x000000a0;
    r8[al] = 0;
    { pc = 0x1b5442; break; }
    return;
  }
}
function* sub_1bd863() // 0160:1bd863 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd863; break; }
  case 0x1b5442: // 0160:1b5442
    r32[edi] = 0x0020c88f;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[ebp] = r32[edx];
    r32[edx] += r32[edx];
    r32[edx] += r32[ebp];
    r32[esi] += r32[edx];
    r32[edi] += r32[edx];
  case 0x1b5455: // 0160:1b5455
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5455; break; }
    r32[esp] += 4; return;
    // gap 33772 bytes // gap 33772 bytes
  case 0x1bd863: // 0160:1bd863
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x000000a0;
    r8[al] = 0;
    { pc = 0x1b5442; break; }
    return;
  }
}
function* sub_1bd879() // 0160:1bd879 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd879; break; }
  case 0x1b5442: // 0160:1b5442
    r32[edi] = 0x0020c88f;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[ebp] = r32[edx];
    r32[edx] += r32[edx];
    r32[edx] += r32[ebp];
    r32[esi] += r32[edx];
    r32[edi] += r32[edx];
  case 0x1b5455: // 0160:1b5455
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5455; break; }
    r32[esp] += 4; return;
    // gap 33794 bytes // gap 33794 bytes
  case 0x1bd879: // 0160:1bd879
    r32[edx] = 0x001ecc1d;
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000060;
    r8[al] = 0xa0;
    { pc = 0x1b5442; break; }
    return;
  }
}
function* sub_1bd87e() // 0160:1bd87e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd87e; break; }
  case 0x1b5442: // 0160:1b5442
    r32[edi] = 0x0020c88f;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[ebp] = r32[edx];
    r32[edx] += r32[edx];
    r32[edx] += r32[ebp];
    r32[esi] += r32[edx];
    r32[edi] += r32[edx];
  case 0x1b5455: // 0160:1b5455
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi], r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1b5455; break; }
    r32[esp] += 4; return;
    // gap 33799 bytes // gap 33799 bytes
  case 0x1bd87e: // 0160:1bd87e
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000060;
    r8[al] = 0xa0;
    { pc = 0x1b5442; break; }
    return;
  }
}
function* sub_1bd894() // 0160:1bd894 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd894; break; }
  case 0x1b521d: // 0160:1b521d
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b522f: // 0160:1b522f
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b523c: // 0160:1b523c
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b523c; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b522f; break; }
    r32[esp] += 4; return;
    // gap 34373 bytes // gap 34373 bytes
  case 0x1bd894: // 0160:1bd894
    r32[edx] = 0x001ecc1d;
    r32[edi] = 0x000a0000;
    yield* sub_1b5205();
    r32[edi] = 0x000a4800;
    yield* sub_1b521d();
    r32[edi] = 0x000a9000;
    { pc = 0x1b521d; break; }
    return;
  }
}
function* sub_1bd899() // 0160:1bd899 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bd899; break; }
  case 0x1b521d: // 0160:1b521d
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b522f: // 0160:1b522f
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b523c: // 0160:1b523c
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b523c; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b522f; break; }
    r32[esp] += 4; return;
    // gap 34378 bytes // gap 34378 bytes
  case 0x1bd899: // 0160:1bd899
    r32[edi] = 0x000a0000;
    yield* sub_1b5205();
    r32[edi] = 0x000a4800;
    yield* sub_1b521d();
    r32[edi] = 0x000a9000;
    { pc = 0x1b521d; break; }
    return;
  }
}
function* sub_1bd8b7() // 0160:1bd8b7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x001ed214;
    yield* sub_1b52a1();
    r32[edi] = 0x0027508c;
    yield* sub_1bd8d7();
    r32[edx] = 0x001ed229;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[edi] = pop32();
    r32[esi] = 0x0020f1c4;
    r32[ebp] = 0x00000004;
  case 0x1bd8e1: // 0160:1bd8e1
    r32[ebx] = 0x00000004;
  case 0x1bd8e6: // 0160:1bd8e6
    r32[edx] = 0x00000030;
  case 0x1bd8eb: // 0160:1bd8eb
    r32[ecx] = 0x0000000c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] += 0x00000110;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd8eb; break; }
    r32[esi] -= 0x00003bd0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bd8e6; break; }
    r32[esi] += 0x00003b40;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bd8e1; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd8d7() // 0160:1bd8d7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020f1c4;
    r32[ebp] = 0x00000004;
  case 0x1bd8e1: // 0160:1bd8e1
    r32[ebx] = 0x00000004;
  case 0x1bd8e6: // 0160:1bd8e6
    r32[edx] = 0x00000030;
  case 0x1bd8eb: // 0160:1bd8eb
    r32[ecx] = 0x0000000c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] += 0x00000110;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd8eb; break; }
    r32[esi] -= 0x00003bd0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bd8e6; break; }
    r32[esi] += 0x00003b40;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bd8e1; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd90e() // 0160:1bd90e +long
{
    r32[esp] -= 4;
    r32[eax] &= 0x0000000f;
    r32[ebx] = r32[eax];
    r32[eax] <<= 12;
    r32[ebx] <<= 9;
    r32[eax] += r32[ebx];
    r32[esi] = 0x0027508c;
    r32[esi] += r32[eax];
    r32[edi] = memoryAGet32(ds, 0x2231e8);
    r32[ecx] = 0x00000480;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esp] += 4;
}
function* sub_1bd930() // 0160:1bd930 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x0003;
    if (r16[bp])
        { pc = 0x1bd94c; break; }
    memoryASet16(ds, 0x20e9a3, memoryAGet16(ds, 0x20e9a3) + 1);
    memoryASet16(ds, 0x20e9a3, memoryAGet16(ds, 0x20e9a3) & 0x0003);
  case 0x1bd94c: // 0160:1bd94c
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, 0x20e9a3);
    if (r16[bp] != 0x0003)
        { pc = 0x1bd95f; break; }
    r16[bp] = 0x0001;
  case 0x1bd95f: // 0160:1bd95f
    r32[edi] = 0x001ef2d8;
    r32[ebp] <<= 4;
    r32[edi] += r32[ebp];
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd96a() // 0160:1bd96a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ebp] = 0x00000004;
    memoryASet16(ds, 0x20e9a5, 0x0000);
  case 0x1bd978: // 0160:1bd978
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] = 0;
    if (!(memoryAGet16(ds, 0x20e9a5) & 0xffff))
        { pc = 0x1bd9c4; break; }
    if (memoryAGet16(ds, 0x20e9a5) != 0x0001)
        { pc = 0x1bd99d; break; }
    r16[dx] += 0x0002;
    { pc = 0x1bd9bd; break; }
  case 0x1bd99d: // 0160:1bd99d
    if (memoryAGet16(ds, 0x20e9a5) != 0x0002)
        { pc = 0x1bd9b2; break; }
    r16[dx]++;
    r16[ax] += memoryAGet16(ds, 0x20ceb1);
    { pc = 0x1bd9c4; break; }
  case 0x1bd9b2: // 0160:1bd9b2
    r16[dx] += 0x0003;
    r16[ax] += memoryAGet16(ds, 0x20ceb1);
  case 0x1bd9bd: // 0160:1bd9bd
    r16[bx] += memoryAGet16(ds, 0x20ceb7);
  case 0x1bd9c4: // 0160:1bd9c4
    r16[ax] += memoryAGet16(ds, r32[edi]);
    r16[bx] += memoryAGet16(ds, r32[edi] + 0x2);
    r32[edi] += 0x00000004;
    r16[cx] = 0;
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1bd7dd();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e9a5, memoryAGet16(ds, 0x20e9a5) + 1);
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1bd978; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bd9e7() // 0160:1bd9e7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1bda2e; break; }
    r32[edi] = 0x000a4800;
  case 0x1bda2e: // 0160:1bda2e
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
    r8[al] = 0x02;
  case 0x1bda8b: // 0160:1bda8b
    memoryASet16(ds, 0x20ceb1, r16[ax]);
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1bdaa6: // 0160:1bdaa6
    r16[cx] = memoryAGet16(ds, 0x224634);
    r16[cx] >>>= 2;
  case 0x1bdab1: // 0160:1bdab1
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1bdab1; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1bdaa6; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1bdaf9; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ceb1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1bda8b; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1bda8b; break; }
  case 0x1bdaf9: // 0160:1bdaf9
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bdb00() // 0160:1bdb00 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    if (r16s[cx] >= 0)
        { pc = 0x1bdb69; break; }
    r16[cx] = -r16[cx];
    if (signed16(memoryAGet16(ds, r32[edi] + 0x2)) <= r16s[cx])
        { pc = 0x1bdbb1; break; }
    r32[edi] = 0x002915ac;
    r32[eax] = 0x00000030;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r16[dx] = memoryAGet16(ds, 0x224636);
    r16[dx] -= r16[cx];
    memoryASet16(ds, 0x224636, r16[dx]);
  case 0x1bdb54: // 0160:1bdb54
    r32[ecx] = 0x0000000c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1bdb54; break; }
    r32[esi] = 0x002915ac;
  case 0x1bdb64: // 0160:1bdb64
    { pc = 0x1bdbb2; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bdb69: // 0160:1bdb69
    if (r16[cx] >= 0x00e0)
        { pc = 0x1bdbb1; break; }
    r16[dx] = memoryAGet16(ds, r32[edi] + 0x2);
    r16[dx] += r16[cx];
    if (r16s[dx] < signed16(0x00e0))
        { pc = 0x1bdb64; break; }
    r16[dx] = 0x00e0;
    r16[dx] -= r16[cx];
    memoryASet16(ds, 0x224636, r16[dx]);
    r32[edi] = 0x002915ac;
  case 0x1bdb91: // 0160:1bdb91
    r32[ecx] = 0x0000000c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1bdb91; break; }
    r16[cx] = 0x00e0;
    r16[cx] -= memoryAGet16(ds, 0x224636);
    r32[esi] = 0x002915ac;
    { pc = 0x1bdbb2; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bdbb1: // 0160:1bdbb1
    r32[esp] += 4; return;
  case 0x1bdbb2: // 0160:1bdbb2
    r32[edi] = 0x000a0000;
    if (memoryAGet16(ds, 0x2231c4))
        { pc = 0x1bdbca; break; }
    r32[edi] = 0x000a4800;
  case 0x1bdbca: // 0160:1bdbca
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    r32[ebp] = 0x00000004;
    r32[ecx] = 0;
    r8[al] = 0x02;
  case 0x1bdc11: // 0160:1bdc11
    out16(r16[dx], r16[ax]);
    r16[cx] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
    push32(r32[eax]);
  case 0x1bdc27: // 0160:1bdc27
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x18);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x1c);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x10);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x14);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x28);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x2c);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x20);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x24);
    memoryASet32(ds, r32[edi] + 0x8, r32[eax]);
    r32[esi] += 0x00000030;
    r32[edi] += r32[ebx];
    if (--r32[ecx])
        { pc = 0x1bdc27; break; }
    r32[eax] = pop32();
    r32[ebp]--;
    if (!r32[ebp])
        { pc = 0x1bdc81; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1bdc11; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1bdc11; break; }
  case 0x1bdc81: // 0160:1bdc81
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bdc88() // 0160:1bdc88 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ecb3, 0x0000);
    if (memoryAGet16(ds, 0x20e90d) == 0x0001)
        { pc = 0x1bdd06; break; }
    r16[bp] = 0;
    memoryASet16(ds, 0x20e805, 0x0008);
    yield* sub_1bdee4();
    r32[esi] = 0x001eeaf1;
    if (!(memoryAGet16(ds, 0x20e809) & 0xffff))
        { pc = 0x1bdcd0; break; }
    r32[esi] = 0x001eeaf9;
    if (memoryAGet16(ds, 0x20e809) == 0x0001)
        { pc = 0x1bdcd0; break; }
    r32[esi] = 0x001eeb01;
  case 0x1bdcd0: // 0160:1bdcd0
    if (memoryAGet16(ds, 0x20ecb7) == 0x0001)
        { pc = 0x1bddbe; break; }
    r16[bp] = 0x0005;
    memoryASet16(ds, 0x20e805, 0x000a);
    yield* sub_1bdee4();
    r32[esi] = 0x001eeac9;
    if (memoryAGet16(ds, 0x20e809) != 0x0002)
        { pc = 0x1bdd01; break; }
    r16[bp]--;
  case 0x1bdd01: // 0160:1bdd01
    { pc = 0x1bddbe; break; }
  case 0x1bdd06: // 0160:1bdd06
    if (memoryAGet16(ds, 0x20ecb5) == 0x0003)
        { pc = 0x1bdee3; break; }
    r16[bp] = 0x0005;
    memoryASet16(ds, 0x20e805, 0x0000);
    if (!(memoryAGet16(ds, 0x20ecb5) & 0xffff))
        { pc = 0x1bdd3f; break; }
    memoryASet16(ds, 0x20e805, 0x0002);
    if (memoryAGet16(ds, 0x20ecb5) != 0x0001)
        { pc = 0x1bdd51; break; }
  case 0x1bdd3f: // 0160:1bdd3f
    yield* sub_1bdee4();
    r32[esi] = 0x001eeac9;
    if (r16[bx] != 0x0019)
        { pc = 0x1bddbe; break; }
    if (r16[bx] == 0x0019)
        { pc = 0x1bdd6e; break; }
  case 0x1bdd51: // 0160:1bdd51
    if (memoryAGet16(ds, 0x20ecb7) == 0x0002)
        { pc = 0x1bdd98; break; }
    memoryASet16(ds, 0x20e805, 0x0004);
    yield* sub_1bdee4();
    if (r16[bx])
        { pc = 0x1bdd84; break; }
  case 0x1bdd6e: // 0160:1bdd6e
    r32[esi] = 0x001eead9;
    r32[ecx] = 0x00000002;
    r32[edi] = 0x0020ed53;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    { pc = 0x1bde6c; break; }
  case 0x1bdd84: // 0160:1bdd84
    r32[esi] = 0x001eead1;
    r16[bp] = 0x0004;
    memoryASet16(ds, 0x20e805, 0x0004);
    { pc = 0x1bddbe; break; }
  case 0x1bdd98: // 0160:1bdd98
    r16[bp] = 0;
    memoryASet16(ds, 0x20e805, 0x0006);
    yield* sub_1bdee4();
    r32[esi] = 0x001eeae1;
    if (!(memoryAGet16(ds, 0x20e809) & 0xffff))
        { pc = 0x1bddbe; break; }
    r32[esi] = 0x001eeae9;
  case 0x1bddbe: // 0160:1bddbe
    r32[ecx] = 0x00000002;
    r32[edi] = 0x0020ed53;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    yield* sub_1bdee4();
    if (r16[bx] == 0x00ff)
        { pc = 0x1bdee3; break; }
    memoryASet16(ds, 0x20e801, 0x0000);
    r8[al] = 0;
    r8[cl] = 0;
    r8[dl] = 0;
  case 0x1bdde9: // 0160:1bdde9
    if (r16s[bx] < signed16(0x03e8))
        { pc = 0x1bddf9; break; }
    r8[al]++;
    r16[bx] -= 0x03e8;
    { pc = 0x1bdde9; break; }
  case 0x1bddf9: // 0160:1bddf9
    if (r16s[bx] < signed16(0x0064))
        { pc = 0x1bde07; break; }
    r8[cl]++;
    r16[bx] -= 0x0064;
    { pc = 0x1bddf9; break; }
  case 0x1bde07: // 0160:1bde07
    if (r16s[bx] < signed16(0x000a))
        { pc = 0x1bde15; break; }
    r8[dl]++;
    r16[bx] -= 0x000a;
    { pc = 0x1bde07; break; }
  case 0x1bde15: // 0160:1bde15
    r32[edi] = 0x0020ed53;
    r32[ebp] &= 0x0000ffff;
    r32[edi] += r32[ebp];
    if (!r8[al])
        { pc = 0x1bde34; break; }
    r8[al] += 0x30;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    memoryASet16(ds, 0x20e801, 0x0001);
  case 0x1bde34: // 0160:1bde34
    if (memoryAGet16(ds, 0x20e801) & 0xffff)
        { pc = 0x1bde43; break; }
    if (!r8[cl])
        { pc = 0x1bde52; break; }
  case 0x1bde43: // 0160:1bde43
    r8[cl] += 0x30;
    memoryASet(ds, r32[edi], r8[cl]);
    r32[edi]++;
    memoryASet16(ds, 0x20e801, 0x0001);
  case 0x1bde52: // 0160:1bde52
    if (memoryAGet16(ds, 0x20e801) & 0xffff)
        { pc = 0x1bde61; break; }
    if (!r8[dl])
        { pc = 0x1bde67; break; }
  case 0x1bde61: // 0160:1bde61
    r8[dl] += 0x30;
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
  case 0x1bde67: // 0160:1bde67
    r8[bl] += 0x30;
    memoryASet(ds, r32[edi], r8[bl]);
  case 0x1bde6c: // 0160:1bde6c
    r32[esi] = 0x0020ed53;
    r32[edi] = memoryAGet32(ds, 0x2231ec);
    r32[ebp] = r32[edi];
    r32[edi] = r32[ebp];
    r32[edx] = 0x00000008;
  case 0x1bde80: // 0160:1bde80
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] >= 0x40)
        { pc = 0x1bdea8; break; }
    if (r8[al] == 0x20)
        { pc = 0x1bdea4; break; }
    if (r8s[al] < signed8(0x30))
        { pc = 0x1bde92; break; }
    if (r8s[al] <= signed8(0x39))
        { pc = 0x1bde9e; break; }
  case 0x1bde92: // 0160:1bde92
    if (r8[al] == 0x2f)
        { pc = 0x1bde9a; break; }
    r8[al] = 0x26;
    { pc = 0x1bdeaa; break; }
  case 0x1bde9a: // 0160:1bde9a
    r8[al] = 0x25;
    { pc = 0x1bdeaa; break; }
  case 0x1bde9e: // 0160:1bde9e
    r8[al] -= 0x30;
    r8[al] += 0x1b;
    { pc = 0x1bdeaa; break; }
  case 0x1bdea4: // 0160:1bdea4
    r32[eax] = 0;
    { pc = 0x1bdeaf; break; }
  case 0x1bdea8: // 0160:1bdea8
    r8[al] -= 0x40;
  case 0x1bdeaa: // 0160:1bdeaa
    r32[eax] &= 0x000000ff;
  case 0x1bdeaf: // 0160:1bdeaf
    r32[eax] <<= 6;
    r32[ebx] = 0x0029b134;
    r32[ebx] += r32[eax];
    r32[ecx] = 0x00000008;
  case 0x1bdebe: // 0160:1bdebe
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[ebx] += 0x00000008;
    r32[edi] += 0x00000040;
    if (--r32[ecx])
        { pc = 0x1bdebe; break; }
    r32[edi] -= 0x000001f8;
    r32[esi]++;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bde80; break; }
    memoryASet16(ds, 0x20ecb3, 0x0001);
  case 0x1bdee3: // 0160:1bdee3
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bdee4() // 0160:1bdee4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[ax] <<= 2;
    r16[si] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[si];
    r16[ax] += memoryAGet16(ds, 0x20e805);
    r32[esi] = 0x002247a6;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20e809, 0x0000);
    if (r16s[bx] < signed16(0x000a))
        { pc = 0x1bdf2f; break; }
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 1);
    if (r16s[bx] < signed16(0x0064))
        { pc = 0x1bdf2f; break; }
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 1);
  case 0x1bdf2f: // 0160:1bdf2f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bdf30() // 0160:1bdf30 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet(ds, 0x20c840, 0x00);
    r8[al] = memoryAGet(ds, 0x30b080);
    if (!r8[al])
        { pc = 0x1bdf4b; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x40);
  case 0x1bdf4b: // 0160:1bdf4b
    r8[al] = memoryAGet(ds, 0x30b088);
    if (!r8[al])
        { pc = 0x1bdf5f; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x20);
  case 0x1bdf5f: // 0160:1bdf5f
    r8[al] = memoryAGet(ds, 0x30b0ec);
    if (r8[al])
        { pc = 0x1bdf79; break; }
    r8[al] = memoryAGet(ds, 0x30b08c);
    if (!r8[al])
        { pc = 0x1bdf80; break; }
  case 0x1bdf79: // 0160:1bdf79
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1bdf80: // 0160:1bdf80
    r8[al] = memoryAGet(ds, 0x30b08e);
    if (!r8[al])
        { pc = 0x1bdf94; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x10);
  case 0x1bdf94: // 0160:1bdf94
    if (!memoryAGet(ds, 0x30b118))
        { pc = 0x1bdfa4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x01);
  case 0x1bdfa4: // 0160:1bdfa4
    if (!memoryAGet(ds, 0x30b120))
        { pc = 0x1bdfb4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x02);
  case 0x1bdfb4: // 0160:1bdfb4
    if (!memoryAGet(ds, 0x30b11d))
        { pc = 0x1bdfc4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
  case 0x1bdfc4: // 0160:1bdfc4
    if (!memoryAGet(ds, 0x30b11b))
        { pc = 0x1bdfd4; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
  case 0x1bdfd4: // 0160:1bdfd4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bdfd5() // 0160:1bdfd5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bdfd5; break; }
  case 0x1b2d91: // 0160:1b2d91
    r32[edx] = 0x001ed08d;
    r32[eax] = 0x00003d02;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0022479c;
    r32[ecx] = 0x00000410;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    // gap 393 bytes // gap 393 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 45119 bytes // gap 45119 bytes
  case 0x1bdfd5: // 0160:1bdfd5
    yield* sub_1be01a();
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1be019; break; }
    if (memoryAGet16(ds, 0x20ee45) & 0xffff)
        { pc = 0x1be019; break; }
    r32[esi] = 0x002247a6;
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r8[bl] = 0x0c;
    mul8(r8[bl]);
    r32[ecx] = 0x00000006;
    r32[eax] &= 0x0000ffff;
  case 0x1be009: // 0160:1be009
    memoryASet16(ds, r32[esi] + r32[eax], 0x00ff);
    r32[eax] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1be009; break; }
    { pc = 0x1b2d91; break; }
  case 0x1be019: // 0160:1be019
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1be01a() // 0160:1be01a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d897, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1bd3c8();
    yield* sub_1bd894();
    r32[edx] = 0x001ecba2;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1b57ae();
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r32[esi] = 0x00224866;
    r16[bx] = r16[ax];
    r16[ax] <<= 2;
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020ce9d;
    r32[ecx] = 0x00000006;
  case 0x1be088: // 0160:1be088
    movsb_ESEDI_DSESI();
    memoryASet(ds, r32[esi] - 1, 0x20);
    if (--r32[ecx])
        { pc = 0x1be088; break; }
    yield* sub_1bd478();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20eca1, 0x0000);
    yield* sub_1a8044();
    yield* sub_1b4f0e();
  case 0x1be0b0: // 0160:1be0b0
    yield* sub_1b5096();
    yield* sub_1b531f();
    memoryASet16(ds, 0x20edab, memoryAGet16(ds, 0x20edab) + 1);
    if (memoryAGet16(ds, 0x20edab) == 0x2ee0)
        { pc = 0x1be0df; break; }
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1be132; break; }
  case 0x1be0df: // 0160:1be0df
    yield* sub_1a8054();
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r32[esi] = 0x00224866;
    r16[bx] = r16[ax];
    r16[ax] <<= 2;
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020ce9d;
    r16[bx] = 0;
    r32[ecx] = 0x00000006;
    r32[ebx] &= 0x0000ffff;
  case 0x1be116: // 0160:1be116
    if (memoryAGet(ds, r32[esi] + r32[ebx]) != 0x20)
        { pc = 0x1be131; break; }
    r32[ebx]++;
    if (--r32[ecx])
        { pc = 0x1be116; break; }
    r32[ecx] = 0x00000006;
    r32[etx] = r32[edi]; r32[edi] = r32[esi]; r32[esi] = r32[etx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20d897, 0x0001);
  case 0x1be131: // 0160:1be131
    r32[esp] += 4; return;
  case 0x1be132: // 0160:1be132
    yield* sub_1be14f();
    yield* sub_1be2c6();
    r32[esi] = 0x001eeab6;
    r8[al] = 0xc3;
    r8[bl] = 0x0d;
    yield* sub_1b60a7();
    { pc = 0x1be0b0; break; }
    return;
  }
}
function* sub_1be14f() // 0160:1be14f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1be14f; break; }
  case 0x1bd435: // 0160:1bd435
    r16[bp] = r16[ax];
    r32[esi] = 0x00224866;
    r16[ax] <<= 1;
    r16[dx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[dx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = memoryAGet32(ds, 0x2231e4);
    r16[ax] = r16[bp];
    r16[ax] <<= 8;
    r16[bp] <<= 7;
    r32[ebp] &= 0x0000ffff;
    r32[eax] += r32[ebp];
    r32[edi] += r32[eax];
    r32[ebp] = r32[edi];
    memoryASet16(ds, 0x20ceb1, 0x0001);
    { pc = 0x1bd48e; break; }
    // gap 22 bytes // gap 22 bytes
  case 0x1bd48e: // 0160:1bd48e
    r32[edi] = r32[ebp];
    r32[edx] = 0x00000006;
  case 0x1bd495: // 0160:1bd495
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] >= 0x40)
        { pc = 0x1bd4bd; break; }
    if (r8[al] == 0x20)
        { pc = 0x1bd4b9; break; }
    if (r8s[al] < signed8(0x30))
        { pc = 0x1bd4a7; break; }
    if (r8s[al] <= signed8(0x39))
        { pc = 0x1bd4b3; break; }
  case 0x1bd4a7: // 0160:1bd4a7
    if (r8[al] == 0x2f)
        { pc = 0x1bd4af; break; }
    r8[al] = 0x26;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4af: // 0160:1bd4af
    r8[al] = 0x25;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4b3: // 0160:1bd4b3
    r8[al] -= 0x30;
    r8[al] += 0x1b;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4b9: // 0160:1bd4b9
    r8[al] = 0;
    { pc = 0x1bd4bf; break; }
  case 0x1bd4bd: // 0160:1bd4bd
    r8[al] -= 0x40;
  case 0x1bd4bf: // 0160:1bd4bf
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 6;
    r32[ebx] = 0x0029b134;
    r32[ebx] += r32[eax];
    r32[ecx] = 0x00000008;
  case 0x1bd4d3: // 0160:1bd4d3
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[ebx] += 0x00000008;
    r32[edi] += 0x00000030;
    if (--r32[ecx])
        { pc = 0x1bd4d3; break; }
    r32[edi] -= 0x00000178;
    r32[esi]++;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1bd495; break; }
    r32[ebp] += 0x00000180;
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) - 1);
    if (memoryAGet16(ds, 0x20ceb1))
        { pc = 0x1bd48e; break; }
    r32[esp] += 4; return;
    // gap 3152 bytes // gap 3152 bytes
  case 0x1be14f: // 0160:1be14f
    memoryASet16(ds, 0x20cec1, 0x0000);
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1be2c5; break; }
    r32[eax] = 0;
    interrupt(0x16);
    if (r8[ah] != 0x1c)
        { pc = 0x1be17c; break; }
  case 0x1be16e: // 0160:1be16e
    memoryASet16(ds, 0x20e831, 0x0001);
    { pc = 0x1be2b1; break; }
  case 0x1be17c: // 0160:1be17c
    if (r8[ah] == 0x01)
        { pc = 0x1be16e; break; }
    if (r8[ah] != 0x53)
        { pc = 0x1be1a9; break; }
  case 0x1be186: // 0160:1be186
    if (!(memoryAGet16(ds, 0x20eca1) & 0xffff))
        { pc = 0x1be2b1; break; }
    memoryASet16(ds, 0x20eca1, memoryAGet16(ds, 0x20eca1) - 1);
    r8[al] = 0x20;
    memoryASet16(ds, 0x20cec1, 0x0001);
    { pc = 0x1be1f6; break; }
  case 0x1be1a9: // 0160:1be1a9
    if (r8[ah] == 0x0e)
        { pc = 0x1be186; break; }
    if (memoryAGet16(ds, 0x20eca1) == 0x0006)
        { pc = 0x1be2b1; break; }
    if (r8[al] == 0x20)
        { pc = 0x1be1f6; break; }
    if (r8[al] < 0x30)
        { pc = 0x1be2b1; break; }
    if (r8[al] < 0x3a)
        { pc = 0x1be1f6; break; }
    if (r8[al] < 0x41)
        { pc = 0x1be2b1; break; }
    if (r8[al] < 0x5b)
        { pc = 0x1be1f6; break; }
    if (r8[al] < 0x61)
        { pc = 0x1be2b1; break; }
    if (r8[al] > 0x7a)
        { pc = 0x1be2b1; break; }
    r8[al] -= 0x20;
  case 0x1be1f6: // 0160:1be1f6
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet(ds, 0x20ea29, 0xc6);
    r16[bx] = 0x0011;
    r16[bx] += memoryAGet16(ds, 0x20eca1);
    memoryASet(ds, 0x20ea2a, r8[bl]);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x01);
    memoryASet(ds, 0x20ea2d, r8[al]);
    r16[dx] = memoryAGet16(ds, 0x2231c4);
    push32(r32[edx]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r32[edx] = pop32();
    memoryASet16(ds, 0x2231c4, r16[dx]);
    if (memoryAGet16(ds, 0x20cec1) & 0xffff)
        { pc = 0x1be272; break; }
    memoryASet16(ds, 0x20eca1, memoryAGet16(ds, 0x20eca1) + 1);
  case 0x1be272: // 0160:1be272
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r32[esi] = 0x00224866;
    r16[bx] = r16[ax];
    r16[ax] <<= 2;
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet16(ds, 0x20eca1);
    r32[eax] &= 0x0000ffff;
    if (memoryAGet16(ds, 0x20cec1) & 0xffff)
        { pc = 0x1be2a8; break; }
    r32[eax]--;
  case 0x1be2a8: // 0160:1be2a8
    r8[bl] = memoryAGet(ds, 0x20ea2d);
    memoryASet(ds, r32[esi] + r32[eax], r8[bl]);
  case 0x1be2b1: // 0160:1be2b1
    memoryASet16(ds, 0x20edab, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    { pc = 0x1bd435; break; }
  case 0x1be2c5: // 0160:1be2c5
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1be2c6() // 0160:1be2c6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1be2c6; break; }
  case 0x1bd507: // 0160:1bd507
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4; return;
    // gap 3495 bytes // gap 3495 bytes
  case 0x1be2c6: // 0160:1be2c6
    if (memoryAGet16(ds, 0x20eca1) == 0x0006)
        { pc = 0x1be340; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0008;
    if (!r16[ax])
        { pc = 0x1be307; break; }
    r32[eax] = 0x00000108;
    r16[dx] = memoryAGet16(ds, 0x20eca1);
    r16[dx] <<= 3;
    r16[ax] += r16[dx];
    r32[ebx] = 0x00000144;
    r32[ecx] = 0x00000029;
    r32[edx] = 0x00000004;
    yield* sub_1bd7dd();
  case 0x1be307: // 0160:1be307
    r16[dx] = memoryAGet16(ds, 0x20eca1);
    r16[bp] = r16[dx];
    r32[eax] = 0x00000108;
    r16[dx] <<= 3;
    r16[ax] += r16[dx];
  case 0x1be31d: // 0160:1be31d
    r32[ebx] = 0x00000144;
    r32[ecx] = 0x00000028;
    r32[edx] = 0x00000004;
    push32(r32[eax]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[eax] = pop32();
    r32[eax] += 0x00000008;
    r16[bp]++;
    if (r16[bp] != 0x0006)
        { pc = 0x1be31d; break; }
  case 0x1be340: // 0160:1be340
    r16[ax] = 0x0108;
    r16[bx] = 0x00fe;
    r16[bx] += 0x0030;
    r16[cx] = memoryAGet16(ds, 0x20e8ad);
    r16[cx] += 0x0011;
    r16[bp] = memoryAGet16(ds, 0x20e8ad);
    memoryASet16(ds, 0x20cec3, r16[bp]);
    yield* sub_1bd51f();
    r16[ax]++;
    r16[dx] = 0x0004;
    yield* sub_1bd50f();
    r16[ax] = 0x0108;
    r16[bx] = 0x00fe;
    r16[cx] = memoryAGet16(ds, 0x20e8ad);
    r16[cx]++;
    r16[dx] = 0x0007;
    yield* sub_1bd50f();
    r16[dx] = 0x0008;
    r16[cx] = 0x0023;
    { pc = 0x1bd507; break; }
    return;
  }
}
function* sub_1be39c() // 0160:1be39c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x0020edb1;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    r16[cx] = r16[ax];
    flags.carry = false;
    r16[bx] = 0;
    r16[cx] = rcl16(r16[cx], 0x0001);
    r8[bl] = rcl8(r8[bl], 0x01);
    r16[cx] = rcl16(r16[cx], 0x0001);
    r8[bl] = rcl8(r8[bl], 0x01);
    r16[ax] &= 0x3fff;
    r16[ax] <<= 1;
    memoryASet(ds, 0x20ceb1, r8[bl]);
    r8[bl] = 0;
  case 0x1be3c8: // 0160:1be3c8
    if (r16s[ax] < signed16(0x1770))
        { pc = 0x1be3d6; break; }
    r8[bl]++;
    r16[ax] -= 0x1770;
    { pc = 0x1be3c8; break; }
  case 0x1be3d6: // 0160:1be3d6
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r8[bl] = 0;
  case 0x1be3db: // 0160:1be3db
    if (r16s[ax] < signed16(0x03e8))
        { pc = 0x1be3e9; break; }
    r8[bl]++;
    r16[ax] -= 0x03e8;
    { pc = 0x1be3db; break; }
  case 0x1be3e9: // 0160:1be3e9
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r8[bl] = 0;
  case 0x1be3ee: // 0160:1be3ee
    if (r16s[ax] < signed16(0x0064))
        { pc = 0x1be3fc; break; }
    r8[bl]++;
    r16[ax] -= 0x0064;
    { pc = 0x1be3ee; break; }
  case 0x1be3fc: // 0160:1be3fc
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r8[bl] = 0;
  case 0x1be401: // 0160:1be401
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1be40f; break; }
    r8[bl]++;
    r16[ax] -= 0x000a;
    { pc = 0x1be401; break; }
  case 0x1be40f: // 0160:1be40f
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r8[al] &= 0x03;
    r8[bl] = memoryAGet(ds, 0x20ceb1);
    r8[bl] <<= 2;
    r8[bl] |= r8[al];
    memoryASet(ds, 0x20ceb1, r8[bl]);
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    yield* sub_1be455();
    yield* sub_1be455();
    yield* sub_1be455();
    yield* sub_1be455();
    yield* sub_1be455();
    yield* sub_1be455();
    r8[al] = memoryAGet(ds, 0x20ceb1);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1be455() // 0160:1be455 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00000005;
    flags.carry = false;
    r8[bl] = 0;
  case 0x1be45c: // 0160:1be45c
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r8[bl] = rcl8(r8[bl], 0x01);
    if (--r32[ecx])
        { pc = 0x1be45c; break; }
    if (r8[bl])
        { pc = 0x1be46b; break; }
    r8[bl] += 0x20;
    { pc = 0x1be46e; break; }
  case 0x1be46b: // 0160:1be46b
    r8[bl] += 0x40;
  case 0x1be46e: // 0160:1be46e
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r32[esp] += 4;
    return;
  }
}
function* sub_1be4a2() // 0160:1be4a2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020edbd;
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x1770;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x03e8;
    mul16(r16[cx]);
    r16[bp] = r16[ax];
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[ax] += r16[bp];
    r16[bx] += r16[ax];
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[ax] += r16[bx];
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[ax] += r16[bx];
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20ceb1, r8[bl]);
    r16[bx] <<= 12;
    r16[bx] &= 0xc000;
    r16[ax] >>>= 1;
    r16[ax] |= r16[bx];
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r32[ebx] = 0x00224866;
    r32[edx] = 0x0020edc3;
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[ax] <<= 1;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[eax] &= 0x0000ffff;
    r32[ebx] += r32[eax];
    r32[ecx] = 0x00000006;
  case 0x1be53b: // 0160:1be53b
    r8[al] = memoryAGet(ds, r32[ebx]);
    r32[ebx]++;
    if (r8[al] != 0x20)
        { pc = 0x1be546; break; }
    r8[al] -= 0x20;
    { pc = 0x1be548; break; }
  case 0x1be546: // 0160:1be546
    r8[al] -= 0x40;
  case 0x1be548: // 0160:1be548
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1be53b; break; }
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edi] = 0x0020edc3;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[ebp] = 0;
    r32[esi] = 0;
    r8[al] = memoryAGet(ds, r32[edi]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x1);
    r8[cl] = memoryAGet(ds, r32[edi] + 0x2);
    r8[dl] = memoryAGet(ds, r32[edi] + 0x4);
    r16[bp] = r16[dx];
    r8[dl] = memoryAGet(ds, r32[edi] + 0x5);
    r16[si] = r16[dx];
    r8[dl] = memoryAGet(ds, r32[edi] + 0x3);
    r32[eax] <<= 27;
    r32[ebx] <<= 22;
    r32[ecx] <<= 17;
    r32[edx] <<= 12;
    r32[ebp] <<= 7;
    r32[esi] <<= 2;
    r32[eax] |= r32[ebx];
    r32[eax] |= r32[ecx];
    r32[eax] |= r32[edx];
    r32[eax] |= r32[ebp];
    r32[eax] |= r32[esi];
    r8[bl] = memoryAGet(ds, 0x20ceb1);
    r32[ebx] &= 0x00000003;
    r32[eax] |= r32[ebx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[edi] += 0x00000004;
    r32[esp] += 4;
    return;
  }
}
function* sub_1be4a7() // 0160:1be4a7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x1770;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x03e8;
    mul16(r16[cx]);
    r16[bp] = r16[ax];
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[ax] += r16[bp];
    r16[bx] += r16[ax];
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[ax] += r16[bx];
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[ax] += r16[bx];
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20ceb1, r8[bl]);
    r16[bx] <<= 12;
    r16[bx] &= 0xc000;
    r16[ax] >>>= 1;
    r16[ax] |= r16[bx];
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r32[ebx] = 0x00224866;
    r32[edx] = 0x0020edc3;
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r16[ax] <<= 1;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[eax] &= 0x0000ffff;
    r32[ebx] += r32[eax];
    r32[ecx] = 0x00000006;
  case 0x1be53b: // 0160:1be53b
    r8[al] = memoryAGet(ds, r32[ebx]);
    r32[ebx]++;
    if (r8[al] != 0x20)
        { pc = 0x1be546; break; }
    r8[al] -= 0x20;
    { pc = 0x1be548; break; }
  case 0x1be546: // 0160:1be546
    r8[al] -= 0x40;
  case 0x1be548: // 0160:1be548
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1be53b; break; }
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edi] = 0x0020edc3;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[ebp] = 0;
    r32[esi] = 0;
    r8[al] = memoryAGet(ds, r32[edi]);
    r8[bl] = memoryAGet(ds, r32[edi] + 0x1);
    r8[cl] = memoryAGet(ds, r32[edi] + 0x2);
    r8[dl] = memoryAGet(ds, r32[edi] + 0x4);
    r16[bp] = r16[dx];
    r8[dl] = memoryAGet(ds, r32[edi] + 0x5);
    r16[si] = r16[dx];
    r8[dl] = memoryAGet(ds, r32[edi] + 0x3);
    r32[eax] <<= 27;
    r32[ebx] <<= 22;
    r32[ecx] <<= 17;
    r32[edx] <<= 12;
    r32[ebp] <<= 7;
    r32[esi] <<= 2;
    r32[eax] |= r32[ebx];
    r32[eax] |= r32[ecx];
    r32[eax] |= r32[edx];
    r32[eax] |= r32[ebp];
    r32[eax] |= r32[esi];
    r8[bl] = memoryAGet(ds, 0x20ceb1);
    r32[ebx] &= 0x00000003;
    r32[eax] |= r32[ebx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[edi] += 0x00000004;
    r32[esp] += 4;
    return;
  }
}
function* sub_1be5a6() // 0160:1be5a6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20edd3, 0x0000);
    memoryASet16(ds, 0x20edd5, 0x0000);
    memoryASet16(ds, 0x20edd7, 0x0000);
    memoryASet16(ds, 0x20edd9, 0x0000);
    r32[esi] = 0x00224866;
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[ecx] = 0x0000001d;
    r32[edi] = 0x002967b4;
  case 0x1be5f2: // 0160:1be5f2
    push32(r32[ecx]);
    r32[ebx] = 0x0020edd3;
    yield* sub_1be628();
    r32[ebx] = 0x0020edd5;
    yield* sub_1be628();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1be5f2; break; }
    r32[ecx] = 0x0000001b;
  case 0x1be60f: // 0160:1be60f
    push32(r32[ecx]);
    r32[ebx] = 0x0020edd7;
    yield* sub_1be628();
    r32[ebx] = 0x0020edd9;
    yield* sub_1be628();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1be60f; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1be628() // 0160:1be628 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = r32[edi];
    r32[ecx] += 0x00000005;
    r32[edx] = r32[esi];
    r32[ebp] = 0x00000006;
  case 0x1be634: // 0160:1be634
    r8[al] = memoryAGet(ds, r32[ecx]);
    if (r8[al] != memoryAGet(ds, r32[edx]))
        { pc = 0x1be64b; break; }
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1be634; break; }
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    if (r8[al] != memoryAGet(ds, r32[edi] + 0xb))
        { pc = 0x1be64b; break; }
    memoryASet16(ds, r32[ebx], memoryAGet16(ds, r32[ebx]) + 1);
  case 0x1be64b: // 0160:1be64b
    r32[edi] += 0x0000000c;
    r32[esp] += 4;
    return;
  }
}
function* sub_1be64f() // 0160:1be64f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1be64f; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 33414 bytes // gap 33414 bytes
  case 0x1be64f: // 0160:1be64f
    memoryASet16(ds, 0x20ceb7, 0x0001);
    memoryASet16(ds, 0x20ceb9, 0x0001);
    memoryASet16(ds, 0x20cebb, 0x0000);
    { pc = 0x1be687; break; }
    // gap 27 bytes // gap 27 bytes
  case 0x1be687: // 0160:1be687
    r32[edi] = 0x0020ea5b;
    r32[edx] = r32[edi];
    push32(r32[ecx]);
    r32[ecx] = 0x0000000a;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[ecx] = pop32();
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1be6a7; break; }
    r16[ax] = r16[bx];
    { pc = 0x1be6fe; break; }
  case 0x1be6a7: // 0160:1be6a7
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r32[esi] = 0x002247a6;
    r16[ax] <<= 2;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    if (r16[ax] != 0x00ff)
        { pc = 0x1be6fe; break; }
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1be6e2; break; }
    r32[esp] += 4; return;
  case 0x1be6e2: // 0160:1be6e2
    memoryASet(ds, r32[edx] + 0x3, 0x15);
    r32[ecx] = 0x00000015;
    r32[esi] = 0x001eeb80;
    r32[edi] = r32[edx];
    r32[edi] += 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = r32[edx];
    { pc = 0x1b60d3; break; }
  case 0x1be6fe: // 0160:1be6fe
    if (!(memoryAGet16(ds, 0x20cebb) & 0xffff))
        { pc = 0x1be73c; break; }
    if (memoryAGet16(ds, 0x20cebb) != 0x0001)
        { pc = 0x1be71b; break; }
    if (r16[ax] != 0x0019)
        { pc = 0x1be73c; break; }
    { pc = 0x1be720; break; }
  case 0x1be71b: // 0160:1be71b
    if (r16[ax])
        { pc = 0x1be73c; break; }
  case 0x1be720: // 0160:1be720
    memoryASet(ds, r32[edx] + 0x3, 0x15);
    r32[ecx] = 0x00000015;
    r32[esi] = 0x001eeb6b;
    r32[edi] = r32[edx];
    r32[edi] += 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = r32[edx];
    { pc = 0x1b60d3; break; }
  case 0x1be73c: // 0160:1be73c
    r32[ecx] &= 0x0000ffff;
    r8[bl] = 0;
  case 0x1be744: // 0160:1be744
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1be752; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1be744; break; }
  case 0x1be752: // 0160:1be752
    if (!r8[bl])
        { pc = 0x1be75d; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[edx] + r32[ecx], r8[bl]);
    r32[ecx]++;
  case 0x1be75d: // 0160:1be75d
    r8[al] += 0x30;
    memoryASet(ds, r32[edx] + r32[ecx], r8[al]);
    r32[esi] = r32[edx];
    if (!(memoryAGet16(ds, 0x20ceb7) & 0xffff))
        { pc = 0x1be791; break; }
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1be783; break; }
    if (r8[bl])
        { pc = 0x1be791; break; }
    memoryASet(ds, r32[edx] + 0x1, memoryAGet(ds, r32[edx] + 0x1) + 1);
    { pc = 0x1be791; break; }
  case 0x1be783: // 0160:1be783
    if (r8[bl])
        { pc = 0x1be791; break; }
    r8[al] -= 0x30;
    if (r8[al] != 0x01)
        { pc = 0x1be791; break; }
    memoryASet(ds, r32[edx] + 0x10, 0x20);
  case 0x1be791: // 0160:1be791
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1be66c() // 0160:1be66c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1be66c; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 33443 bytes // gap 33443 bytes
  case 0x1be66c: // 0160:1be66c
    memoryASet16(ds, 0x20ceb1, 0x0000);
    memoryASet16(ds, 0x20ceb7, 0x0000);
    memoryASet16(ds, 0x20ceb9, 0x0000);
    r32[edi] = 0x0020ea5b;
    r32[edx] = r32[edi];
    push32(r32[ecx]);
    r32[ecx] = 0x0000000a;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[ecx] = pop32();
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1be6a7; break; }
    r16[ax] = r16[bx];
    { pc = 0x1be6fe; break; }
  case 0x1be6a7: // 0160:1be6a7
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r32[esi] = 0x002247a6;
    r16[ax] <<= 2;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    if (r16[ax] != 0x00ff)
        { pc = 0x1be6fe; break; }
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1be6e2; break; }
    r32[esp] += 4; return;
  case 0x1be6e2: // 0160:1be6e2
    memoryASet(ds, r32[edx] + 0x3, 0x15);
    r32[ecx] = 0x00000015;
    r32[esi] = 0x001eeb80;
    r32[edi] = r32[edx];
    r32[edi] += 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = r32[edx];
    { pc = 0x1b60d3; break; }
  case 0x1be6fe: // 0160:1be6fe
    if (!(memoryAGet16(ds, 0x20cebb) & 0xffff))
        { pc = 0x1be73c; break; }
    if (memoryAGet16(ds, 0x20cebb) != 0x0001)
        { pc = 0x1be71b; break; }
    if (r16[ax] != 0x0019)
        { pc = 0x1be73c; break; }
    { pc = 0x1be720; break; }
  case 0x1be71b: // 0160:1be71b
    if (r16[ax])
        { pc = 0x1be73c; break; }
  case 0x1be720: // 0160:1be720
    memoryASet(ds, r32[edx] + 0x3, 0x15);
    r32[ecx] = 0x00000015;
    r32[esi] = 0x001eeb6b;
    r32[edi] = r32[edx];
    r32[edi] += 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = r32[edx];
    { pc = 0x1b60d3; break; }
  case 0x1be73c: // 0160:1be73c
    r32[ecx] &= 0x0000ffff;
    r8[bl] = 0;
  case 0x1be744: // 0160:1be744
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1be752; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1be744; break; }
  case 0x1be752: // 0160:1be752
    if (!r8[bl])
        { pc = 0x1be75d; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[edx] + r32[ecx], r8[bl]);
    r32[ecx]++;
  case 0x1be75d: // 0160:1be75d
    r8[al] += 0x30;
    memoryASet(ds, r32[edx] + r32[ecx], r8[al]);
    r32[esi] = r32[edx];
    if (!(memoryAGet16(ds, 0x20ceb7) & 0xffff))
        { pc = 0x1be791; break; }
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1be783; break; }
    if (r8[bl])
        { pc = 0x1be791; break; }
    memoryASet(ds, r32[edx] + 0x1, memoryAGet(ds, r32[edx] + 0x1) + 1);
    { pc = 0x1be791; break; }
  case 0x1be783: // 0160:1be783
    if (r8[bl])
        { pc = 0x1be791; break; }
    r8[al] -= 0x30;
    if (r8[al] != 0x01)
        { pc = 0x1be791; break; }
    memoryASet(ds, r32[edx] + 0x10, 0x20);
  case 0x1be791: // 0160:1be791
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1be67e() // 0160:1be67e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1be67e; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 33461 bytes // gap 33461 bytes
  case 0x1be67e: // 0160:1be67e
    memoryASet16(ds, 0x20ceb9, 0x0000);
    r32[edi] = 0x0020ea5b;
    r32[edx] = r32[edi];
    push32(r32[ecx]);
    r32[ecx] = 0x0000000a;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[ecx] = pop32();
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1be6a7; break; }
    r16[ax] = r16[bx];
    { pc = 0x1be6fe; break; }
  case 0x1be6a7: // 0160:1be6a7
    r16[ax] = memoryAGet16(ds, 0x20e8ad);
    r32[esi] = 0x002247a6;
    r16[ax] <<= 2;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[ebx] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebx]);
    if (r16[ax] != 0x00ff)
        { pc = 0x1be6fe; break; }
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1be6e2; break; }
    r32[esp] += 4; return;
  case 0x1be6e2: // 0160:1be6e2
    memoryASet(ds, r32[edx] + 0x3, 0x15);
    r32[ecx] = 0x00000015;
    r32[esi] = 0x001eeb80;
    r32[edi] = r32[edx];
    r32[edi] += 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = r32[edx];
    { pc = 0x1b60d3; break; }
  case 0x1be6fe: // 0160:1be6fe
    if (!(memoryAGet16(ds, 0x20cebb) & 0xffff))
        { pc = 0x1be73c; break; }
    if (memoryAGet16(ds, 0x20cebb) != 0x0001)
        { pc = 0x1be71b; break; }
    if (r16[ax] != 0x0019)
        { pc = 0x1be73c; break; }
    { pc = 0x1be720; break; }
  case 0x1be71b: // 0160:1be71b
    if (r16[ax])
        { pc = 0x1be73c; break; }
  case 0x1be720: // 0160:1be720
    memoryASet(ds, r32[edx] + 0x3, 0x15);
    r32[ecx] = 0x00000015;
    r32[esi] = 0x001eeb6b;
    r32[edi] = r32[edx];
    r32[edi] += 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = r32[edx];
    { pc = 0x1b60d3; break; }
  case 0x1be73c: // 0160:1be73c
    r32[ecx] &= 0x0000ffff;
    r8[bl] = 0;
  case 0x1be744: // 0160:1be744
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1be752; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1be744; break; }
  case 0x1be752: // 0160:1be752
    if (!r8[bl])
        { pc = 0x1be75d; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[edx] + r32[ecx], r8[bl]);
    r32[ecx]++;
  case 0x1be75d: // 0160:1be75d
    r8[al] += 0x30;
    memoryASet(ds, r32[edx] + r32[ecx], r8[al]);
    r32[esi] = r32[edx];
    if (!(memoryAGet16(ds, 0x20ceb7) & 0xffff))
        { pc = 0x1be791; break; }
    if (!(memoryAGet16(ds, 0x20ceb9) & 0xffff))
        { pc = 0x1be783; break; }
    if (r8[bl])
        { pc = 0x1be791; break; }
    memoryASet(ds, r32[edx] + 0x1, memoryAGet(ds, r32[edx] + 0x1) + 1);
    { pc = 0x1be791; break; }
  case 0x1be783: // 0160:1be783
    if (r8[bl])
        { pc = 0x1be791; break; }
    r8[al] -= 0x30;
    if (r8[al] != 0x01)
        { pc = 0x1be791; break; }
    memoryASet(ds, r32[edx] + 0x10, 0x20);
  case 0x1be791: // 0160:1be791
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1be796() // 0160:1be796 +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0000);
    yield* sub_1be7c6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1be7c6();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    yield* sub_1be7c6();
    memoryASet16(ds, 0x2231c4, memoryAGet16(ds, 0x2231c4) - 1);
    r32[esp] += 4;
}
function* sub_1be7c6() // 0160:1be7c6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001eeb95;
    yield* sub_1be816();
    r32[esi] = 0x001eeb9e;
    yield* sub_1be816();
    r32[esi] = 0x001eeba9;
    yield* sub_1be816();
    r32[esi] = 0x001eebb2;
    yield* sub_1be816();
    r32[esi] = 0x001eebbd;
    yield* sub_1be816();
    r32[esi] = 0x001eebcb;
    yield* sub_1be816();
    r32[esi] = 0x001eebe2;
    yield* sub_1be816();
    r32[esi] = 0x001eebfc;
    { pc = 0x1be816; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1be816: // 0160:1be816
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1be816() // 0160:1be816 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1be986() // 0160:1be986 +long
{
    r32[esp] -= 4;
    r32[esi] = 0x001ecb29;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[edx] = 0x0020e9c5;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    memoryASet(ds, r32[edx] + 0xd, r8[bl]);
    memoryASet16(ds, r32[edx] + 0xe, r16[ax]);
    yield* sub_1be9d2();
    r32[edx] = 0x0020e9c5;
    memoryASet(ds, r32[edx] + 0x13, 0x72);
    r32[eax] = 0x00004100;
    interrupt(0x21);
    r32[esp] += 4;
}
function* sub_1be9d2() // 0160:1be9d2 +long
{
    r32[esp] -= 4;
    r32[eax] = 0x00004100;
    interrupt(0x21);
    r32[esp] += 4;
}
function* sub_1be9da() // 0160:1be9da +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1be9da; break; }
  case 0x1b2cde: // 0160:1b2cde
    r32[edx] = 0x001ed0a1;
    r32[eax] = 0x00003d02;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dcb; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    { pc = 0x1b2d10; break; }
    // gap 25 bytes // gap 25 bytes
  case 0x1b2d10: // 0160:1b2d10
    r32[edx] = 0x0023f52c;
    r32[ecx] = 0x00002ed4;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1b2dd9; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
    // gap 144 bytes // gap 144 bytes
  case 0x1b2dcb: // 0160:1b2dcb
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1b2dd9: // 0160:1b2dd9
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    // gap 393 bytes // gap 393 bytes
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 47684 bytes // gap 47684 bytes
  case 0x1be9da: // 0160:1be9da
    yield* sub_1aa9d7();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] -= 0x0030;
    r16[cx] = 0x0064;
    mul16(r16[cx]);
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x6);
    r16[ax] -= 0x0030;
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet(ds, r32[esi] + 0x7);
    r16[ax] -= 0x0030;
    r16[ax] += r16[bx];
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] = 0x0023f52c;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020edbd;
    memoryASet(ds, r32[edi], 0x04);
    memoryASet(ds, r32[edi] + 0x1, 0x05);
    memoryASet(ds, r32[edi] + 0x2, 0x09);
    memoryASet(ds, r32[edi] + 0x3, 0x09);
    memoryASet(ds, r32[edi] + 0x4, 0x09);
    memoryASet(ds, r32[edi] + 0x5, 0x00);
    r32[eax] = memoryAGet32(ds, 0x224866);
    r16[bx] = memoryAGet16(ds, 0x22486a);
    push32(r32[eax]);
    push32(r32[ebx]);
    r32[edx] = 0x00224866;
    r32[ecx] = 0x00000006;
  case 0x1bea72: // 0160:1bea72
    memoryASet(ds, r32[edx], 0x5b);
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1bea72; break; }
    r32[edi] = r32[esi];
    yield* sub_1be4a2();
    yield* sub_1be4a2();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    memoryASet32(ds, 0x224866, r32[eax]);
    memoryASet16(ds, 0x22486a, r16[bx]);
    { pc = 0x1b2cde; break; }
    return;
  }
}
function* sub_1bea97() // 0160:1bea97 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bea97; break; }
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 47873 bytes // gap 47873 bytes
  case 0x1bea97: // 0160:1bea97
    r32[esi] = 0x001ecb29;
    if (memoryAGet16(ds, 0x20ec8d) != 0x0003)
        { pc = 0x1beaab; break; }
    r32[esi] = 0x001ecb3e;
  case 0x1beaab: // 0160:1beaab
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x5);
    memoryASet16(ds, r32[edi] + 0xd, r16[ax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet(ds, r32[edi] + 0xf, r8[al]);
    { pc = 0x1beb72; break; }
    // gap 137 bytes // gap 137 bytes
  case 0x1beb72: // 0160:1beb72
    r32[edx] = 0x0020e9c5;
    r32[ecx] = 0;
    r32[eax] = 0x00003c00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bebae; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0020dcc5;
    r32[ecx] = 0x00000400;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bebbc; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1bebae: // 0160:1bebae
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1bebbc: // 0160:1bebbc
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
    return;
  }
}
function* sub_1beae9() // 0160:1beae9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1beae9; break; }
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 47955 bytes // gap 47955 bytes
  case 0x1beae9: // 0160:1beae9
    r16[cx] = memoryAGet16(ds, 0x20d7b9);
    if (r16[cx] == 0x0002)
        { pc = 0x1bebdc; break; }
    if (r16[cx] == 0x0012)
        { pc = 0x1bebdc; break; }
    if (r16[cx] == 0x001d)
        { pc = 0x1bebdc; break; }
    if (r16[cx] == 0x0022)
        { pc = 0x1bebdc; break; }
    r32[esi] = 0x001ecb14;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20ec8d);
    if (r16[ax] != 0x0003)
        { pc = 0x1beb4a; break; }
    memoryASet(ds, 0x20e9d6, 0x52);
    memoryASet(ds, 0x20e9d7, 0x41);
    memoryASet(ds, 0x20e9d8, 0x43);
  case 0x1beb4a: // 0160:1beb4a
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[bl] = 0x30;
  case 0x1beb52: // 0160:1beb52
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1beb65; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1beb52; break; }
  case 0x1beb65: // 0160:1beb65
    memoryASet(ds, 0x20e9d3, r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, 0x20e9d4, r8[al]);
    r32[edx] = 0x0020e9c5;
    r32[ecx] = 0;
    r32[eax] = 0x00003c00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bebae; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0020dcc5;
    r32[ecx] = 0x00000400;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bebbc; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    { pc = 0x1b2f82; break; }
  case 0x1bebae: // 0160:1bebae
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f8f; break; }
  case 0x1bebbc: // 0160:1bebbc
    memoryASet16(ds, 0x20cec3, 0x0002);
    if (r32[eax] == 0x00000005)
        { pc = 0x1b2f8f; break; }
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
  case 0x1bebdc: // 0160:1bebdc
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bebdd() // 0160:1bebdd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bebdd; break; }
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 48199 bytes // gap 48199 bytes
  case 0x1bebdd: // 0160:1bebdd
    memoryASet16(ds, 0x20d8b7, 0x0000);
    r32[esi] = 0x0020d793;
    r32[edi] = 0x001ecb29;
    if (memoryAGet16(ds, 0x20ec8d) == 0x0001)
        { pc = 0x1bec04; break; }
    r32[esi] = 0x0020d787;
    r32[edi] = 0x001ecb3e;
  case 0x1bec04: // 0160:1bec04
    if (memoryAGet(ds, r32[esi]) != 0x04)
        { pc = 0x1bec19; break; }
    if (memoryAGet(ds, r32[esi] + 0x1) != 0x05)
        { pc = 0x1bec19; break; }
    if (memoryAGet(ds, r32[esi] + 0x2) == 0x09)
        { pc = 0x1bed9d; break; }
  case 0x1bec19: // 0160:1bec19
    r32[esi] = r32[edi];
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x5);
    memoryASet16(ds, r32[edi] + 0xd, r16[ax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet(ds, r32[edi] + 0xf, r8[al]);
    { pc = 0x1bed1e; break; }
    // gap 197 bytes // gap 197 bytes
  case 0x1bed1e: // 0160:1bed1e
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bed8f; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0020d8c1;
    r32[ecx] = 0x00000400;
    memoryASet32(ds, 0x20ceeb, r32[ecx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bed81; break; }
    if (memoryAGet32(ds, 0x20ceeb) != r32[eax])
        { pc = 0x1bed73; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    memoryASet16(ds, 0x20d8b7, 0x0001);
    { pc = 0x1b2f82; break; }
  case 0x1bed73: // 0160:1bed73
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f82; break; }
  case 0x1bed81: // 0160:1bed81
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1b2f82; break; }
  case 0x1bed8f: // 0160:1bed8f
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
  case 0x1bed9d: // 0160:1bed9d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bec59() // 0160:1bec59 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bec59; break; }
  case 0x1b2f82: // 0160:1b2f82
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1b2f8f: // 0160:1b2f8f
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 48323 bytes // gap 48323 bytes
  case 0x1bec59: // 0160:1bec59
    memoryASet16(ds, 0x20d8b7, 0x0000);
    r16[cx] = memoryAGet16(ds, 0x20d7b9);
    if (r16[cx] == 0x0002)
        { pc = 0x1bed9d; break; }
    if (r16[cx] == 0x0012)
        { pc = 0x1bed9d; break; }
    if (r16[cx] == 0x001d)
        { pc = 0x1bed9d; break; }
    if (r16[cx] == 0x0022)
        { pc = 0x1bed9d; break; }
    if (r16[cx] == 0x0036)
        { pc = 0x1bed9d; break; }
    r32[esi] = 0x0020d793;
    if (memoryAGet16(ds, 0x20ec8d) == 0x0001)
        { pc = 0x1becaf; break; }
    r32[esi] = 0x0020d787;
  case 0x1becaf: // 0160:1becaf
    if (memoryAGet(ds, r32[esi]) != 0x04)
        { pc = 0x1becc4; break; }
    if (memoryAGet(ds, r32[esi] + 0x1) != 0x05)
        { pc = 0x1becc4; break; }
    if (memoryAGet(ds, r32[esi] + 0x2) == 0x09)
        { pc = 0x1bed9d; break; }
  case 0x1becc4: // 0160:1becc4
    r32[esi] = 0x001ecb14;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20ec8d);
    if (r16[ax] != 0x0003)
        { pc = 0x1becf6; break; }
    memoryASet(ds, 0x20e9d6, 0x52);
    memoryASet(ds, 0x20e9d7, 0x41);
    memoryASet(ds, 0x20e9d8, 0x43);
  case 0x1becf6: // 0160:1becf6
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r8[bl] = 0x30;
  case 0x1becfe: // 0160:1becfe
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1bed11; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1becfe; break; }
  case 0x1bed11: // 0160:1bed11
    memoryASet(ds, 0x20e9d3, r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, 0x20e9d4, r8[al]);
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bed8f; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    r32[edx] = 0x0020d8c1;
    r32[ecx] = 0x00000400;
    memoryASet32(ds, 0x20ceeb, r32[ecx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bed81; break; }
    if (memoryAGet32(ds, 0x20ceeb) != r32[eax])
        { pc = 0x1bed73; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    memoryASet16(ds, 0x20d8b7, 0x0001);
    { pc = 0x1b2f82; break; }
  case 0x1bed73: // 0160:1bed73
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1b2f82; break; }
  case 0x1bed81: // 0160:1bed81
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1b2f82; break; }
  case 0x1bed8f: // 0160:1bed8f
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1b2f8f; break; }
  case 0x1bed9d: // 0160:1bed9d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bed9e() // 0160:1bed9e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1bed9e: // 0160:1bed9e
    yield* sub_1c0f4d();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bee9c();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bee9c();
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x0106);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1bedf2: // 0160:1bedf2
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bee55; break; }
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1bee37; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1bee41; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1bee4b; break; }
    r32[esp] += 4; return;
  case 0x1bee37: // 0160:1bee37
    yield* sub_1bef0c();
    { pc = 0x1bed9e; break; }
  case 0x1bee41: // 0160:1bee41
    yield* sub_1bf077();
    { pc = 0x1bed9e; break; }
  case 0x1bee4b: // 0160:1bee4b
    yield* sub_1bf07d();
    { pc = 0x1bed9e; break; }
  case 0x1bee55: // 0160:1bee55
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0004);
    memoryASet16(ds, 0x20e809, 0x0003);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1beec4();
    r32[esi] = 0x001ee1b2;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bedf2; break; }
    return;
  }
}
function* sub_1bee9c() // 0160:1bee9c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bee9c; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 35539 bytes // gap 35539 bytes
  case 0x1bee9c: // 0160:1bee9c
    r32[esi] = 0x001ee620;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee632;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee643;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee653;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1beec4() // 0160:1beec4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1beec4; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 5791 bytes // gap 5791 bytes
  case 0x1beec4: // 0160:1beec4
    r16[ax] += 0x0083;
    if (!r16[bp])
        { pc = 0x1beed1; break; }
    r16[ax] += 0x0002;
  case 0x1beed1: // 0160:1beed1
    if (!memoryAGet16(ds, 0x20e82f))
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0040;
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1bef0c() // 0160:1bef0c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x224660, 0x0000);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b54af();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001f0c84;
    yield* sub_1b5a2d();
    r32[edx] = 0x001ecbf4;
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1bef67; break; }
    r32[edx] = 0x001ecc08;
  case 0x1bef67: // 0160:1bef67
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fc);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1befb8: // 0160:1befb8
    yield* sub_1b5096();
    yield* sub_1c7113();
    yield* sub_1c3224();
    r32[esi] = 0x001f0398;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1befe2; break; }
    r32[esi] = 0x001f03b1;
    r8[bl]--;
  case 0x1befe2: // 0160:1befe2
    yield* sub_1b60a7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf068; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1bf00a; break; }
    memoryASet(ds, 0x23c4f9, r8[al]);
    { pc = 0x1bf00f; break; }
  case 0x1bf00a: // 0160:1bf00a
    memoryASet(ds, 0x23c4f8, r8[al]);
  case 0x1bf00f: // 0160:1bf00f
    r32[edi] = 0x001f0ec8;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1bf046; break; }
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0003ebd4;
  case 0x1bf046: // 0160:1bf046
    r32[ebx] = 0x00000020;
  case 0x1bf04b: // 0160:1bf04b
    r32[ecx] = 0x00000020;
  case 0x1bf050: // 0160:1bf050
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1bf050; break; }
    r32[edi] += 0x00000120;
    r32[esi] += 0x00000120;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bf04b; break; }
    r32[esp] += 4; return;
  case 0x1bf068: // 0160:1bf068
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1befb8; break; }
    return;
  }
}
function* sub_1bef15() // 0160:1bef15 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b54af();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001f0c84;
    yield* sub_1b5a2d();
    r32[edx] = 0x001ecbf4;
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1bef67; break; }
    r32[edx] = 0x001ecc08;
  case 0x1bef67: // 0160:1bef67
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fc);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1befb8: // 0160:1befb8
    yield* sub_1b5096();
    yield* sub_1c7113();
    yield* sub_1c3224();
    r32[esi] = 0x001f0398;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1befe2; break; }
    r32[esi] = 0x001f03b1;
    r8[bl]--;
  case 0x1befe2: // 0160:1befe2
    yield* sub_1b60a7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf068; break; }
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1bf00a; break; }
    memoryASet(ds, 0x23c4f9, r8[al]);
    { pc = 0x1bf00f; break; }
  case 0x1bf00a: // 0160:1bf00a
    memoryASet(ds, 0x23c4f8, r8[al]);
  case 0x1bf00f: // 0160:1bf00f
    r32[edi] = 0x001f0ec8;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    if (!(memoryAGet16(ds, 0x224660) & 0xffff))
        { pc = 0x1bf046; break; }
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0003ebd4;
  case 0x1bf046: // 0160:1bf046
    r32[ebx] = 0x00000020;
  case 0x1bf04b: // 0160:1bf04b
    r32[ecx] = 0x00000020;
  case 0x1bf050: // 0160:1bf050
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1bf050; break; }
    r32[edi] += 0x00000120;
    r32[esi] += 0x00000120;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1bf04b; break; }
    r32[esp] += 4; return;
  case 0x1bf068: // 0160:1bf068
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1befb8; break; }
    return;
  }
}
function* sub_1bf077() // 0160:1bf077 +long
{
    r32[esp] -= 4;
    yield* sub_1c34c4();
    r32[esp] += 4;
}
function* sub_1bf07d() // 0160:1bf07d +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x224660, 0x0001);
    yield* sub_1bef15();
    r32[esp] += 4;
}
function* sub_1bf08c() // 0160:1bf08c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1bf08c: // 0160:1bf08c
    yield* sub_1c0f4d();
    yield* sub_1bfedb();
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1bf0c9: // 0160:1bf0c9
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf1cd; break; }
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1bf131; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1bf17f; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1bf189; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1bf1c3; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1bf12a; break; }
    r32[esp] += 4; return;
  case 0x1bf12a: // 0160:1bf12a
    yield* sub_1bf269();
    { pc = 0x1bf0c9; break; }
  case 0x1bf131: // 0160:1bf131
    yield* sub_1bf4ea();
    if (memoryAGet16(ds, 0x20ce9f) != 0x0001)
        { pc = 0x1bf0c9; break; }
    memoryASet16(ds, 0x22464e, 0x0001);
    memoryASet16(ds, 0x20ed4d, 0x0006);
    yield* sub_1c1c1d();
    yield* sub_1c103c();
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1bf08c; break; }
    if (!(memoryAGet16(ds, 0x20cec3) & 0xffff))
        { pc = 0x1bf08c; break; }
    { pc = 0x1bf214; break; }
  case 0x1bf17f: // 0160:1bf17f
    yield* sub_1bf5ae();
    { pc = 0x1bf0c9; break; }
  case 0x1bf189: // 0160:1bf189
    r32[esi] = 0x0023c4e0;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00006d44;
    r32[ecx] = 0x0000304c;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    yield* sub_1bf9f2();
    r32[edi] = 0x0023c4e0;
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[esi] += 0x00006d44;
    r32[ecx] = 0x0000304c;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    { pc = 0x1bf0c9; break; }
  case 0x1bf1c3: // 0160:1bf1c3
    yield* sub_1bfc08();
    { pc = 0x1bf0c9; break; }
  case 0x1bf1cd: // 0160:1bf1cd
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0006);
    memoryASet16(ds, 0x20e809, 0x0005);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1bff3d();
    r32[esi] = 0x001ee1b2;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf0c9; break; }
  case 0x1bf214: // 0160:1bf214
    yield* sub_1c0f4d();
    memoryASet16(ds, 0x20e831, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1bf231: // 0160:1bf231
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    r32[esi] = 0x001ee318;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf231; break; }
    // gap 911 bytes // gap 911 bytes
  case 0x1bf5f8: // 0160:1bf5f8
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf9c6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf9c6();
    yield* sub_1bfedb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bf269() // 0160:1bf269 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bf269; break; }
  case 0x1bf214: // 0160:1bf214
    yield* sub_1c0f4d();
    memoryASet16(ds, 0x20e831, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1bf231: // 0160:1bf231
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    r32[esi] = 0x001ee318;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf231; break; }
  case 0x1bf269: // 0160:1bf269
    memoryASet16(ds, 0x22464e, 0x0001);
    memoryASet16(ds, 0x20ed4d, 0x0006);
    yield* sub_1c1c1d();
    yield* sub_1c103c();
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1bf2a3; break; }
    yield* sub_1c0f4d();
    yield* sub_1b4f0e();
    { pc = 0x1bf5f8; break; }
  case 0x1bf2a3: // 0160:1bf2a3
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1bf214; break; }
    yield* sub_1c0f4d();
    memoryASet16(ds, 0x20cea5, 0x0001);
    memoryASet16(ds, 0x20cea7, 0x0020);
    memoryASet16(ds, 0x20e831, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
    yield* sub_1bfc33();
    if (memoryAGet16(ds, 0x20cea5) != 0x00ff)
        { pc = 0x1bf2f2; break; }
    r32[esp] += 4; return;
  case 0x1bf2f2: // 0160:1bf2f2
    memoryASet16(ds, 0x224680, 0xffff);
    r32[eax] = 0x00003524;
    interrupt(0x21);
    memoryASet32(ds, 0x224678, r32[ebx]);
    memoryASet16(ds, 0x22467c, es);
    push(ds);
    es = pop();
    push32(flagAsReg32());
    flags.interrupts = 0;
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8b2a;
    r32[eax] = 0x00002524;
    interrupt(0x21);
    ds = pop();
    flagsFromReg32(pop32());
    if (memoryAGet16(ds, 0x20cea7) == 0x0041)
        { pc = 0x1bf350; break; }
    if (memoryAGet16(ds, 0x20cea7) != 0x0042)
        { pc = 0x1bf37b; break; }
    r32[eax] = 0x00001500;
    r32[edx] = 0x00000001;
    interrupt(0x13);
    if (r8[ah])
        { pc = 0x1bf37b; break; }
  case 0x1bf350: // 0160:1bf350
    r32[eax] = 0x0000440e;
    r8[bl] = 0x01;
    interrupt(0x21);
    if (!r8[al])
        { pc = 0x1bf37b; break; }
    memoryASet16(ds, 0x20cea7, 0x0041);
    if (r8[al] != 0x02)
        { pc = 0x1bf37b; break; }
    memoryASet16(ds, 0x20cea7, 0x0042);
  case 0x1bf37b: // 0160:1bf37b
    r32[ecx] = 0x0000000a;
    r32[esi] = 0x001ef58b;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9cf, 0x00);
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, 0x20e9c5, r8[al]);
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003900;
    interrupt(0x21);
    if (memoryAGet16(ds, 0x224680))
        { pc = 0x1bf3c2; break; }
    yield* sub_1bf49e();
    { pc = 0x1bf40b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bf3c2: // 0160:1bf3c2
    yield* sub_1bf456();
    yield* sub_1bf923();
    yield* sub_1bf49e();
    push32(flagAsReg32());
    push(ds);
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x224678);
    ds = memoryAGet16(ds, 0x22467c);
    r32[eax] = 0x00002524;
    interrupt(0x21);
    ds = pop();
    flagsFromReg32(pop32());
    if (!memoryAGet16(ds, 0x224680))
        { pc = 0x1bf40b; break; }
    if (!(memoryAGet16(ds, 0x20cec3) & 0xffff))
        { pc = 0x1c066b; break; }
    { pc = 0x1bf97b; break; }
  case 0x1bf40b: // 0160:1bf40b
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bf414: // 0160:1bf414
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    yield* sub_1bf9c6();
    yield* sub_1bf9d1();
    r32[esi] = 0x001ee27a;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf414; break; }
    // gap 418 bytes // gap 418 bytes
  case 0x1bf5f8: // 0160:1bf5f8
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf9c6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf9c6();
    yield* sub_1bfedb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r32[esp] += 4; return;
    // gap 810 bytes // gap 810 bytes
  case 0x1bf97b: // 0160:1bf97b
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bf984: // 0160:1bf984
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    yield* sub_1bf9c6();
    yield* sub_1bf9d1();
    r32[esi] = 0x001ee260;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf984; break; }
    // gap 1301 bytes // gap 1301 bytes
  case 0x1bfedb: // 0160:1bfedb
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4; return;
    // gap 1898 bytes // gap 1898 bytes
  case 0x1c066b: // 0160:1c066b
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b5096();
    { pc = 0x1bfedb; break; }
    return;
  }
}
function* sub_1bf456() // 0160:1bf456 +long
{
    r32[esp] -= 4;
    r32[ecx] = 0x00000018;
    r32[esi] = 0x001ef58b;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[eax] = memoryAGet16(ds, 0x20ec8f);
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[ecx] = 0x0000000c;
    mul16(r16[cx]);
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x5);
    memoryASet(ds, 0x20e9d5, r8[bl]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    memoryASet16(ds, 0x20e9d6, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, 0x20e9c5, r8[al]);
    r32[esp] += 4;
}
function* sub_1bf49e() // 0160:1bf49e +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf4c9();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf4c9();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1bf4c9() // 0160:1bf4c9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bf4c9; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 37120 bytes // gap 37120 bytes
  case 0x1bf4c9: // 0160:1bf4c9
    r8[al] = 0xc3;
    r8[bl] = 0x08;
    r8[cl] = 0x19;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x8d;
    r8[cl] = 0x0e;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x90;
    r8[cl] = 0x08;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1bf4ea() // 0160:1bf4ea +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1bffce();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c003b();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c003b();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
  case 0x1bf53d: // 0160:1bf53d
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf56a; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0001)
        { pc = 0x1bf5ae; break; }
    memoryASet16(ds, 0x20ce9f, 0x0001);
    r32[esp] += 4; return;
  case 0x1bf56a: // 0160:1bf56a
    r32[esi] = 0x001ee1cc;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1bffa9();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf53d; break; }
  case 0x1bf5ae: // 0160:1bf5ae
    memoryASet16(ds, 0x20ce9f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1bffce();
    if (memoryAGet16(ds, 0x22464c) == 0x03e7)
        { pc = 0x1bf681; break; }
    if (memoryAGet16(ds, 0x224650) & 0xffff)
        { pc = 0x1bf6d0; break; }
  case 0x1bf5e3: // 0160:1bf5e3
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf651; break; }
  case 0x1bf5f8: // 0160:1bf5f8
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf9c6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf9c6();
    yield* sub_1bfedb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r32[esp] += 4; return;
  case 0x1bf651: // 0160:1bf651
    r32[esi] = 0x001ee1f3;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee20d;
    r8[al] = 0xc3;
    r8[bl] = 0x8b;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf5e3; break; }
  case 0x1bf681: // 0160:1bf681
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bf68a: // 0160:1bf68a
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    r32[esi] = 0x001ee294;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee2ae;
    r8[al] = 0xc3;
    r8[bl] = 0x88;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf68a; break; }
  case 0x1bf6d0: // 0160:1bf6d0
    r32[esi] = 0x00224684;
    r32[edi] = 0x0023c4e0;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1bf6f7; break; }
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
    { pc = 0x1bf87b; break; }
  case 0x1bf6f7: // 0160:1bf6f7
    memoryASet16(ds, 0x20ec8f, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[esi] += 0x00002ed4;
  case 0x1bf70c: // 0160:1bf70c
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    push32(r32[esi]);
  case 0x1bf717: // 0160:1bf717
    cmpsb_DSESI_ESEDI();
    if (!flags.zero)
        { pc = 0x1bf722; break; }
    if (--r32[ecx])
        { pc = 0x1bf717; break; }
    r32[esi] = pop32();
    { pc = 0x1bf741; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bf722: // 0160:1bf722
    r32[esi] = pop32();
    r32[esi] += 0x00000010;
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x22464c))
        { pc = 0x1bf70c; break; }
    { pc = 0x1bf83c; break; }
  case 0x1bf741: // 0160:1bf741
    yield* sub_1c004f();
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20e82f, 0x0001);
  case 0x1bf761: // 0160:1bf761
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf789; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1bf5f8; break; }
    { pc = 0x1bf7db; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bf789: // 0160:1bf789
    r32[esi] = 0x001ee223;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee23d;
    r8[al] = 0xc3;
    r8[bl] = 0x8b;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1bffa9();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf761; break; }
  case 0x1bf7db: // 0160:1bf7db
    yield* sub_1be986();
    yield* sub_1be9da();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[bl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    yield* sub_1bf923();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1bf97b; break; }
    { pc = 0x1bf5f8; break; }
  case 0x1bf83c: // 0160:1bf83c
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
  case 0x1bf842: // 0160:1bf842
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[bx] = 0;
  case 0x1bf84b: // 0160:1bf84b
    if (r8[dl] != memoryAGet(ds, r32[esi] + 0x5))
        { pc = 0x1bf856; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x6))
        { pc = 0x1bf866; break; }
  case 0x1bf856: // 0160:1bf856
    r16[bx]++;
    if (r16[bx] == memoryAGet16(ds, 0x22464c))
        { pc = 0x1bf87b; break; }
    r32[esi] += 0x0000000c;
    { pc = 0x1bf84b; break; }
  case 0x1bf866: // 0160:1bf866
    r8[ah]++;
    if (r8[ah] != 0x3a)
        { pc = 0x1bf842; break; }
    r8[ah] = 0x30;
    r8[al]++;
    if (r8[al] != 0x3a)
        { pc = 0x1bf842; break; }
    r8[al] = 0x30;
    r8[dl]++;
    { pc = 0x1bf842; break; }
  case 0x1bf87b: // 0160:1bf87b
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[dl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    memoryASet(ds, 0x20ec45, r8[dl]);
    memoryASet16(ds, 0x20ec46, r16[ax]);
    yield* sub_1bf923();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1bf97b; break; }
    r32[ecx] = 0x0000000c;
    r32[esi] = 0x001ef56a;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    push32(r32[edi]);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r8[dl] = memoryAGet(ds, 0x20ec45);
    r16[ax] = memoryAGet16(ds, 0x20ec46);
    memoryASet(ds, r32[edi] + 0x5, r8[dl]);
    memoryASet16(ds, r32[edi] + 0x6, r16[ax]);
    r32[esi] = 0x00224684;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00002ed4;
    r32[ecx] = 0x00000010;
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x22464c, memoryAGet16(ds, 0x22464c) + 1);
    { pc = 0x1bf5f8; break; }
    // gap 88 bytes // gap 88 bytes
  case 0x1bf97b: // 0160:1bf97b
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bf984: // 0160:1bf984
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    yield* sub_1bf9c6();
    yield* sub_1bf9d1();
    r32[esi] = 0x001ee260;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf984; break; }
    return;
  }
}
function* sub_1bf5ae() // 0160:1bf5ae +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ce9f, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    yield* sub_1bffce();
    if (memoryAGet16(ds, 0x22464c) == 0x03e7)
        { pc = 0x1bf681; break; }
    if (memoryAGet16(ds, 0x224650) & 0xffff)
        { pc = 0x1bf6d0; break; }
  case 0x1bf5e3: // 0160:1bf5e3
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf651; break; }
  case 0x1bf5f8: // 0160:1bf5f8
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf9c6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf9c6();
    yield* sub_1bfedb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r32[esp] += 4; return;
  case 0x1bf651: // 0160:1bf651
    r32[esi] = 0x001ee1f3;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee20d;
    r8[al] = 0xc3;
    r8[bl] = 0x8b;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf5e3; break; }
  case 0x1bf681: // 0160:1bf681
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bf68a: // 0160:1bf68a
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    r32[esi] = 0x001ee294;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee2ae;
    r8[al] = 0xc3;
    r8[bl] = 0x88;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf68a; break; }
  case 0x1bf6d0: // 0160:1bf6d0
    r32[esi] = 0x00224684;
    r32[edi] = 0x0023c4e0;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1bf6f7; break; }
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
    { pc = 0x1bf87b; break; }
  case 0x1bf6f7: // 0160:1bf6f7
    memoryASet16(ds, 0x20ec8f, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[esi] += 0x00002ed4;
  case 0x1bf70c: // 0160:1bf70c
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    push32(r32[esi]);
  case 0x1bf717: // 0160:1bf717
    cmpsb_DSESI_ESEDI();
    if (!flags.zero)
        { pc = 0x1bf722; break; }
    if (--r32[ecx])
        { pc = 0x1bf717; break; }
    r32[esi] = pop32();
    { pc = 0x1bf741; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bf722: // 0160:1bf722
    r32[esi] = pop32();
    r32[esi] += 0x00000010;
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x22464c))
        { pc = 0x1bf70c; break; }
    { pc = 0x1bf83c; break; }
  case 0x1bf741: // 0160:1bf741
    yield* sub_1c004f();
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20e82f, 0x0001);
  case 0x1bf761: // 0160:1bf761
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bf789; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1bf5f8; break; }
    { pc = 0x1bf7db; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bf789: // 0160:1bf789
    r32[esi] = 0x001ee223;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee23d;
    r8[al] = 0xc3;
    r8[bl] = 0x8b;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1bffa9();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf761; break; }
  case 0x1bf7db: // 0160:1bf7db
    yield* sub_1be986();
    yield* sub_1be9da();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[bl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    yield* sub_1bf923();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1bf97b; break; }
    { pc = 0x1bf5f8; break; }
  case 0x1bf83c: // 0160:1bf83c
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
  case 0x1bf842: // 0160:1bf842
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[bx] = 0;
  case 0x1bf84b: // 0160:1bf84b
    if (r8[dl] != memoryAGet(ds, r32[esi] + 0x5))
        { pc = 0x1bf856; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x6))
        { pc = 0x1bf866; break; }
  case 0x1bf856: // 0160:1bf856
    r16[bx]++;
    if (r16[bx] == memoryAGet16(ds, 0x22464c))
        { pc = 0x1bf87b; break; }
    r32[esi] += 0x0000000c;
    { pc = 0x1bf84b; break; }
  case 0x1bf866: // 0160:1bf866
    r8[ah]++;
    if (r8[ah] != 0x3a)
        { pc = 0x1bf842; break; }
    r8[ah] = 0x30;
    r8[al]++;
    if (r8[al] != 0x3a)
        { pc = 0x1bf842; break; }
    r8[al] = 0x30;
    r8[dl]++;
    { pc = 0x1bf842; break; }
  case 0x1bf87b: // 0160:1bf87b
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[dl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    memoryASet(ds, 0x20ec45, r8[dl]);
    memoryASet16(ds, 0x20ec46, r16[ax]);
    yield* sub_1bf923();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1bf97b; break; }
    r32[ecx] = 0x0000000c;
    r32[esi] = 0x001ef56a;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    push32(r32[edi]);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r8[dl] = memoryAGet(ds, 0x20ec45);
    r16[ax] = memoryAGet16(ds, 0x20ec46);
    memoryASet(ds, r32[edi] + 0x5, r8[dl]);
    memoryASet16(ds, r32[edi] + 0x6, r16[ax]);
    r32[esi] = 0x00224684;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00002ed4;
    r32[ecx] = 0x00000010;
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x22464c, memoryAGet16(ds, 0x22464c) + 1);
    { pc = 0x1bf5f8; break; }
    // gap 88 bytes // gap 88 bytes
  case 0x1bf97b: // 0160:1bf97b
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bf984: // 0160:1bf984
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bf5f8; break; }
    yield* sub_1bf9c6();
    yield* sub_1bf9d1();
    r32[esi] = 0x001ee260;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bf984; break; }
    return;
  }
}
function* sub_1bf923() // 0160:1bf923 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x0020e9c5;
    r32[ecx] = 0;
    r32[eax] = 0x00003c00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bf971; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    yield* sub_1c451f();
    r32[edx] += 0x0000304c;
    r32[ecx] = r32[edx];
    r32[edx] = 0x0023c4e0;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00004000;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1bf971; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1b2f82();
    memoryASet16(ds, 0x20ce9f, 0x0001);
    r32[esp] += 4; return;
  case 0x1bf971: // 0160:1bf971
    memoryASet16(ds, 0x20cec3, 0x0001);
    r32[esp] += 4;
    return;
  }
}
function* sub_1bf9c6() // 0160:1bf9c6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bf9c6; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 38397 bytes // gap 38397 bytes
  case 0x1bf9c6: // 0160:1bf9c6
    r8[al] = 0xc3;
    r8[bl] = 0x88;
    r8[cl] = 0x18;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1bf9d1() // 0160:1bf9d1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bf9d1; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 38408 bytes // gap 38408 bytes
  case 0x1bf9d1: // 0160:1bf9d1
    r8[al] = 0xc4;
    r8[bl] = 0x92;
    r8[cl] = 0x03;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x12;
    r8[cl] = 0x02;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1bf9e7() // 0160:1bf9e7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bf9e7; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 38430 bytes // gap 38430 bytes
  case 0x1bf9e7: // 0160:1bf9e7
    r8[al] = 0xc3;
    r8[bl] = 0xcc;
    r8[cl] = 0x10;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1bf9f2() // 0160:1bf9f2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bf9f2; break; }
  case 0x1bf5f8: // 0160:1bf5f8
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf9c6();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf9c6();
    yield* sub_1bfedb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r32[esp] += 4; return;
    // gap 929 bytes // gap 929 bytes
  case 0x1bf9f2: // 0160:1bf9f2
    memoryASet16(ds, 0x22464e, 0x0001);
    memoryASet16(ds, 0x20ed4d, 0x0006);
    yield* sub_1c1c1d();
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1bfa23; break; }
    yield* sub_1c0f4d();
    yield* sub_1b4f0e();
    { pc = 0x1bfb76; break; }
  case 0x1bfa23: // 0160:1bfa23
    yield* sub_1c0f4d();
    yield* sub_1bfe41();
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0001);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1bfa60: // 0160:1bfa60
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1bfa8c; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1bfb76; break; }
    { pc = 0x1bfad0; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bfa8c: // 0160:1bfa8c
    r32[esi] = 0x001ee2ca;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1bffa9();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bfa60; break; }
  case 0x1bfad0: // 0160:1bfad0
    yield* sub_1be986();
    yield* sub_1be9da();
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x00000016;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[edx] = 0x0020e9c5;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    memoryASet(ds, r32[edx] + 0xe, r8[bl]);
    memoryASet16(ds, r32[edx] + 0xf, r16[ax]);
    r32[eax] = 0x00004100;
    interrupt(0x21);
    if (!flags.carry)
        { pc = 0x1bfb68; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1bfb2a: // 0160:1bfb2a
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1bfb76; break; }
    yield* sub_1bf9d1();
    yield* sub_1bf9e7();
    r32[esi] = 0x001ee2e4;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1bfb2a; break; }
  case 0x1bfb68: // 0160:1bfb68
    yield* sub_1a841e();
    memoryASet16(ds, 0x20ec8f, 0x0000);
  case 0x1bfb76: // 0160:1bfb76
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bf9e7();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bf9e7();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    { pc = 0x1bf5f8; break; }
    return;
  }
}
function* sub_1bfc08() // 0160:1bfc08 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bfc08; break; }
  case 0x1bfba5: // 0160:1bfba5
    yield* sub_1bffce();
    yield* sub_1a8044();
  case 0x1bfbaf: // 0160:1bfbaf
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1bfbea; break; }
    r32[eax] = 0;
    interrupt(0x16);
    r8[al] = 0xc3;
    r8[bl] = 0x89;
    r8[cl] = 0x16;
    yield* sub_1b60e3();
    yield* sub_1b5096();
    r8[al] = 0xc3;
    r8[bl] = 0x89;
    r8[cl] = 0x16;
    yield* sub_1b60e3();
    { pc = 0x1c0666; break; }
  case 0x1bfbea: // 0160:1bfbea
    r32[esi] = 0x001ee294;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee34d;
    r8[al] = 0xc3;
    r8[bl] = 0x89;
    yield* sub_1b60a7();
    { pc = 0x1bfbaf; break; }
  case 0x1bfc08: // 0160:1bfc08
    memoryASet16(ds, 0x20cea5, 0x0000);
    if (memoryAGet16(ds, 0x22464c) == 0x03e7)
        { pc = 0x1bfba5; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20cea7, 0x0020);
    yield* sub_1bffce();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esi] = 0x001ee3a7;
    yield* sub_1be816();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001ee3a7;
    yield* sub_1be816();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    yield* sub_1a8044();
  case 0x1bfc6c: // 0160:1bfc6c
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    yield* sub_1bfd0f();
    yield* sub_1bfd3e();
    if (memoryAGet16(ds, 0x20e831) < 0x0001)
        { pc = 0x1bfcd0; break; }
    if (memoryAGet16(ds, 0x20e831) == 0x0001)
        { pc = 0x1bfcc6; break; }
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bfcbb();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bfcbb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    { pc = 0x1c01b4; break; }
    // gap 11 bytes // gap 11 bytes
  case 0x1bfcc6: // 0160:1bfcc6
    yield* sub_1a8054();
    { pc = 0x1c008e; break; }
  case 0x1bfcd0: // 0160:1bfcd0
    r32[esi] = 0x001ee367;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20cea5) & 0xffff)
        { pc = 0x1bfcfc; break; }
    r32[esi] = 0x001ee381;
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    yield* sub_1b60a7();
    { pc = 0x1bfd0a; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bfcfc: // 0160:1bfcfc
    r32[esi] = 0x001ee395;
    r8[al] = 0xc3;
    r8[bl] = 0x8d;
    yield* sub_1b60a7();
  case 0x1bfd0a: // 0160:1bfd0a
    { pc = 0x1bfc6c; break; }
    // gap 460 bytes // gap 460 bytes
  case 0x1bfedb: // 0160:1bfedb
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4; return;
    // gap 397 bytes // gap 397 bytes
  case 0x1c008e: // 0160:1c008e
    memoryASet16(ds, 0x224680, 0xffff);
    r32[eax] = 0x00003524;
    interrupt(0x21);
    memoryASet32(ds, 0x224678, r32[ebx]);
    memoryASet16(ds, 0x22467c, es);
    push(ds);
    es = pop();
    push32(flagAsReg32());
    flags.interrupts = 0;
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8b2a;
    r32[eax] = 0x00002524;
    interrupt(0x21);
    ds = pop();
    flagsFromReg32(pop32());
    if (memoryAGet16(ds, 0x20cea7) == 0x0041)
        { pc = 0x1c00ec; break; }
    if (memoryAGet16(ds, 0x20cea7) != 0x0042)
        { pc = 0x1c0117; break; }
    r32[eax] = 0x00001500;
    r32[edx] = 0x00000001;
    interrupt(0x13);
    if (r8[ah])
        { pc = 0x1c0117; break; }
  case 0x1c00ec: // 0160:1c00ec
    r32[eax] = 0x0000440e;
    r8[bl] = 0x01;
    interrupt(0x21);
    if (!r8[al])
        { pc = 0x1c0117; break; }
    memoryASet16(ds, 0x20cea7, 0x0041);
    if (r8[al] != 0x02)
        { pc = 0x1c0117; break; }
    memoryASet16(ds, 0x20cea7, 0x0042);
  case 0x1c0117: // 0160:1c0117
    r32[esi] = 0x001ef5a3;
    r32[edi] = 0x0020e9c5;
    r32[edx] = r32[edi];
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edx], r8[al]);
    memoryASet32(ds, 0x224670, 0x00000010);
    memoryASet32(ds, 0x224674, 0x0020eeb2);
    yield* sub_1c1db9();
    push32(flagAsReg32());
    push(ds);
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x224678);
    ds = memoryAGet16(ds, 0x22467c);
    r32[eax] = 0x00002524;
    interrupt(0x21);
    ds = pop();
    flagsFromReg32(pop32());
    if (memoryAGet16(ds, 0x224680) == 0xffff)
        { pc = 0x1c023e; break; }
    if (memoryAGet16(ds, 0x224680) == 0x0002)
        { pc = 0x1c01e8; break; }
    if (memoryAGet16(ds, 0x224680) == 0x000b)
        { pc = 0x1c01e8; break; }
    r32[eax] = 0;
    r32[edx] = 0;
    interrupt(0x13);
    yield* sub_1a8044();
  case 0x1c0199: // 0160:1c0199
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c01c2; break; }
    r32[eax] = 0;
    interrupt(0x16);
  case 0x1c01b4: // 0160:1c01b4
    memoryASet16(ds, 0x20cea5, 0x00ff);
    { pc = 0x1c0666; break; }
  case 0x1c01c2: // 0160:1c01c2
    r32[esi] = 0x001ee40e;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x90;
    r8[cl] = 0x08;
    yield* sub_1b60e3();
    { pc = 0x1c0199; break; }
  case 0x1c01e8: // 0160:1c01e8
    r32[eax] = 0;
    r32[edx] = 0;
    interrupt(0x13);
    yield* sub_1a8044();
  case 0x1c01f3: // 0160:1c01f3
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c0218; break; }
    r32[eax] = 0;
    interrupt(0x16);
    yield* sub_1a8054();
    { pc = 0x1c008e; break; }
  case 0x1c0218: // 0160:1c0218
    r32[esi] = 0x001ee3b1;
    r8[al] = 0xc3;
    r8[bl] = 0x08;
    yield* sub_1b60a7();
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x90;
    r8[cl] = 0x08;
    yield* sub_1b60e3();
    { pc = 0x1c01f3; break; }
  case 0x1c023e: // 0160:1c023e
    if (!(memoryAGet16(ds, 0x20cea5) & 0xffff))
        { pc = 0x1c024e; break; }
    r32[esp] += 4; return;
  case 0x1c024e: // 0160:1c024e
    r32[ecx] = 0x00000018;
    r32[esi] = 0x001ef576;
    r32[edi] = 0x0020ea5b;
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    yield* sub_1c09ca();
    yield* sub_1b5096();
    yield* sub_1c0a16();
    if (!(memoryAGet16(ds, 0x224662) & 0xffff))
        { pc = 0x1c0646; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x224668, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1c04e6();
    yield* sub_1c049d();
  case 0x1c02c7: // 0160:1c02c7
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c0392; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0001)
        { pc = 0x1c0445; break; }
    if (memoryAGet16(ds, 0x20e82f) < 0x0001)
        { pc = 0x1c0350; break; }
    yield* sub_1c52c2();
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c06b3();
    yield* sub_1c52c2();
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20ceb1, 0x0001);
    { pc = 0x1c0359; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c0350: // 0160:1c0350
    memoryASet16(ds, 0x20ceb1, 0x0000);
  case 0x1c0359: // 0160:1c0359
    r16[ax] = memoryAGet16(ds, 0x224668);
    r16[ax]++;
    if (memoryAGet16(ds, 0x224662) == r16[ax])
        { pc = 0x1c0445; break; }
    memoryASet16(ds, 0x224668, r16[ax]);
    yield* sub_1c04e6();
    memoryASet16(ds, 0x20e831, 0x0000);
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1c0392; break; }
    yield* sub_1c049d();
  case 0x1c0392: // 0160:1c0392
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0003);
    memoryASet16(ds, 0x20e809, 0x0002);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1c0466();
    r32[esi] = 0x001f14f0;
    r8[al] = 0xc3;
    r8[bl] = 0x0c;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee3e8;
    yield* sub_1b60d3();
    r32[esi] = memoryAGet32(ds, 0x20b804);
    r32[esi] += 0x00002ed4;
    r32[eax] = memoryAGet16(ds, 0x224668);
    r32[eax] <<= 4;
    r32[esi] += r32[eax];
    push32(r32[esi]);
    r32[edx] = 0x00000010;
    r32[esi] += 0x0000000f;
  case 0x1c03f5: // 0160:1c03f5
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1c03fe; break; }
    r32[esi]--;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c03f5; break; }
  case 0x1c03fe: // 0160:1c03fe
    r32[ebx] = 0x00000028;
    r32[ebx] -= r32[edx];
    memoryASet32(ds, 0x20ced3, r32[edx]);
    r32[ebx] >>>= 1;
    r32[esi] = pop32();
    r32[edi] = 0x0020ea2d;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] = 0x0020ea29;
    memoryASet(ds, r32[esi], 0xc3);
    memoryASet(ds, r32[esi] + 0x1, 0x80);
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + r8[bl]);
    memoryASet(ds, r32[esi] + 0x2, 0xf0);
    memoryASet(ds, r32[esi] + 0x3, 0x10);
    yield* sub_1be816();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c02c7; break; }
  case 0x1c0445: // 0160:1c0445
    yield* sub_1b5096();
    yield* sub_1c52c2();
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x2231c4, 0x0000);
    { pc = 0x1c066b; break; }
    // gap 480 bytes // gap 480 bytes
  case 0x1c0646: // 0160:1c0646
    yield* sub_1a8044();
  case 0x1c064b: // 0160:1c064b
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c06a3; break; }
    r32[eax] = 0;
    interrupt(0x16);
  case 0x1c0666: // 0160:1c0666
    yield* sub_1a8054();
  case 0x1c066b: // 0160:1c066b
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b5096();
    { pc = 0x1bfedb; break; }
  case 0x1c06a3: // 0160:1c06a3
    r32[esi] = 0x001ee3ce;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c064b; break; }
    return;
  }
}
function* sub_1bfc33() // 0160:1bfc33 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esi] = 0x001ee3a7;
    yield* sub_1be816();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x001ee3a7;
    yield* sub_1be816();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    yield* sub_1a8044();
  case 0x1bfc6c: // 0160:1bfc6c
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    yield* sub_1bfd0f();
    yield* sub_1bfd3e();
    if (memoryAGet16(ds, 0x20e831) < 0x0001)
        { pc = 0x1bfcd0; break; }
    if (memoryAGet16(ds, 0x20e831) == 0x0001)
        { pc = 0x1bfcc6; break; }
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bfcbb();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bfcbb();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    { pc = 0x1c01b4; break; }
    // gap 11 bytes // gap 11 bytes
  case 0x1bfcc6: // 0160:1bfcc6
    yield* sub_1a8054();
    { pc = 0x1c008e; break; }
  case 0x1bfcd0: // 0160:1bfcd0
    r32[esi] = 0x001ee367;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20cea5) & 0xffff)
        { pc = 0x1bfcfc; break; }
    r32[esi] = 0x001ee381;
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    yield* sub_1b60a7();
    { pc = 0x1bfd0a; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bfcfc: // 0160:1bfcfc
    r32[esi] = 0x001ee395;
    r8[al] = 0xc3;
    r8[bl] = 0x8d;
    yield* sub_1b60a7();
  case 0x1bfd0a: // 0160:1bfd0a
    { pc = 0x1bfc6c; break; }
    // gap 460 bytes // gap 460 bytes
  case 0x1bfedb: // 0160:1bfedb
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4; return;
    // gap 397 bytes // gap 397 bytes
  case 0x1c008e: // 0160:1c008e
    memoryASet16(ds, 0x224680, 0xffff);
    r32[eax] = 0x00003524;
    interrupt(0x21);
    memoryASet32(ds, 0x224678, r32[ebx]);
    memoryASet16(ds, 0x22467c, es);
    push(ds);
    es = pop();
    push32(flagAsReg32());
    flags.interrupts = 0;
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8b2a;
    r32[eax] = 0x00002524;
    interrupt(0x21);
    ds = pop();
    flagsFromReg32(pop32());
    if (memoryAGet16(ds, 0x20cea7) == 0x0041)
        { pc = 0x1c00ec; break; }
    if (memoryAGet16(ds, 0x20cea7) != 0x0042)
        { pc = 0x1c0117; break; }
    r32[eax] = 0x00001500;
    r32[edx] = 0x00000001;
    interrupt(0x13);
    if (r8[ah])
        { pc = 0x1c0117; break; }
  case 0x1c00ec: // 0160:1c00ec
    r32[eax] = 0x0000440e;
    r8[bl] = 0x01;
    interrupt(0x21);
    if (!r8[al])
        { pc = 0x1c0117; break; }
    memoryASet16(ds, 0x20cea7, 0x0041);
    if (r8[al] != 0x02)
        { pc = 0x1c0117; break; }
    memoryASet16(ds, 0x20cea7, 0x0042);
  case 0x1c0117: // 0160:1c0117
    r32[esi] = 0x001ef5a3;
    r32[edi] = 0x0020e9c5;
    r32[edx] = r32[edi];
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edx], r8[al]);
    memoryASet32(ds, 0x224670, 0x00000010);
    memoryASet32(ds, 0x224674, 0x0020eeb2);
    yield* sub_1c1db9();
    push32(flagAsReg32());
    push(ds);
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x224678);
    ds = memoryAGet16(ds, 0x22467c);
    r32[eax] = 0x00002524;
    interrupt(0x21);
    ds = pop();
    flagsFromReg32(pop32());
    if (memoryAGet16(ds, 0x224680) == 0xffff)
        { pc = 0x1c023e; break; }
    if (memoryAGet16(ds, 0x224680) == 0x0002)
        { pc = 0x1c01e8; break; }
    if (memoryAGet16(ds, 0x224680) == 0x000b)
        { pc = 0x1c01e8; break; }
    r32[eax] = 0;
    r32[edx] = 0;
    interrupt(0x13);
    yield* sub_1a8044();
  case 0x1c0199: // 0160:1c0199
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c01c2; break; }
    r32[eax] = 0;
    interrupt(0x16);
  case 0x1c01b4: // 0160:1c01b4
    memoryASet16(ds, 0x20cea5, 0x00ff);
    { pc = 0x1c0666; break; }
  case 0x1c01c2: // 0160:1c01c2
    r32[esi] = 0x001ee40e;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x90;
    r8[cl] = 0x08;
    yield* sub_1b60e3();
    { pc = 0x1c0199; break; }
  case 0x1c01e8: // 0160:1c01e8
    r32[eax] = 0;
    r32[edx] = 0;
    interrupt(0x13);
    yield* sub_1a8044();
  case 0x1c01f3: // 0160:1c01f3
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c0218; break; }
    r32[eax] = 0;
    interrupt(0x16);
    yield* sub_1a8054();
    { pc = 0x1c008e; break; }
  case 0x1c0218: // 0160:1c0218
    r32[esi] = 0x001ee3b1;
    r8[al] = 0xc3;
    r8[bl] = 0x08;
    yield* sub_1b60a7();
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x90;
    r8[cl] = 0x08;
    yield* sub_1b60e3();
    { pc = 0x1c01f3; break; }
  case 0x1c023e: // 0160:1c023e
    if (!(memoryAGet16(ds, 0x20cea5) & 0xffff))
        { pc = 0x1c024e; break; }
    r32[esp] += 4; return;
  case 0x1c024e: // 0160:1c024e
    r32[ecx] = 0x00000018;
    r32[esi] = 0x001ef576;
    r32[edi] = 0x0020ea5b;
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    yield* sub_1c09ca();
    yield* sub_1b5096();
    yield* sub_1c0a16();
    if (!(memoryAGet16(ds, 0x224662) & 0xffff))
        { pc = 0x1c0646; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x224668, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1c04e6();
    yield* sub_1c049d();
  case 0x1c02c7: // 0160:1c02c7
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c0392; break; }
    if (memoryAGet16(ds, 0x20e82f) > 0x0001)
        { pc = 0x1c0445; break; }
    if (memoryAGet16(ds, 0x20e82f) < 0x0001)
        { pc = 0x1c0350; break; }
    yield* sub_1c52c2();
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c06b3();
    yield* sub_1c52c2();
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00fe);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20ceb1, 0x0001);
    { pc = 0x1c0359; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c0350: // 0160:1c0350
    memoryASet16(ds, 0x20ceb1, 0x0000);
  case 0x1c0359: // 0160:1c0359
    r16[ax] = memoryAGet16(ds, 0x224668);
    r16[ax]++;
    if (memoryAGet16(ds, 0x224662) == r16[ax])
        { pc = 0x1c0445; break; }
    memoryASet16(ds, 0x224668, r16[ax]);
    yield* sub_1c04e6();
    memoryASet16(ds, 0x20e831, 0x0000);
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1c0392; break; }
    yield* sub_1c049d();
  case 0x1c0392: // 0160:1c0392
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0003);
    memoryASet16(ds, 0x20e809, 0x0002);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1c0466();
    r32[esi] = 0x001f14f0;
    r8[al] = 0xc3;
    r8[bl] = 0x0c;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee3e8;
    yield* sub_1b60d3();
    r32[esi] = memoryAGet32(ds, 0x20b804);
    r32[esi] += 0x00002ed4;
    r32[eax] = memoryAGet16(ds, 0x224668);
    r32[eax] <<= 4;
    r32[esi] += r32[eax];
    push32(r32[esi]);
    r32[edx] = 0x00000010;
    r32[esi] += 0x0000000f;
  case 0x1c03f5: // 0160:1c03f5
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1c03fe; break; }
    r32[esi]--;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c03f5; break; }
  case 0x1c03fe: // 0160:1c03fe
    r32[ebx] = 0x00000028;
    r32[ebx] -= r32[edx];
    memoryASet32(ds, 0x20ced3, r32[edx]);
    r32[ebx] >>>= 1;
    r32[esi] = pop32();
    r32[edi] = 0x0020ea2d;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] = 0x0020ea29;
    memoryASet(ds, r32[esi], 0xc3);
    memoryASet(ds, r32[esi] + 0x1, 0x80);
    memoryASet(ds, r32[esi] + 0x1, memoryAGet(ds, r32[esi] + 0x1) + r8[bl]);
    memoryASet(ds, r32[esi] + 0x2, 0xf0);
    memoryASet(ds, r32[esi] + 0x3, 0x10);
    yield* sub_1be816();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c02c7; break; }
  case 0x1c0445: // 0160:1c0445
    yield* sub_1b5096();
    yield* sub_1c52c2();
    memoryASet16(ds, 0x1f1cb8, 0x0000);
    memoryASet16(ds, 0x2231c4, 0x0000);
    { pc = 0x1c066b; break; }
    // gap 480 bytes // gap 480 bytes
  case 0x1c0646: // 0160:1c0646
    yield* sub_1a8044();
  case 0x1c064b: // 0160:1c064b
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c06a3; break; }
    r32[eax] = 0;
    interrupt(0x16);
  case 0x1c0666: // 0160:1c0666
    yield* sub_1a8054();
  case 0x1c066b: // 0160:1c066b
    memoryASet16(ds, 0x20ec3d, 0x00be);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b5096();
    { pc = 0x1bfedb; break; }
  case 0x1c06a3: // 0160:1c06a3
    r32[esi] = 0x001ee3ce;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c064b; break; }
    return;
  }
}
function* sub_1bfcbb() // 0160:1bfcbb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bfcbb; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 39154 bytes // gap 39154 bytes
  case 0x1bfcbb: // 0160:1bfcbb
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    r8[cl] = 0x10;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1bfd0f() // 0160:1bfd0f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bfd0f; break; }
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 9450 bytes // gap 9450 bytes
  case 0x1bfd0f: // 0160:1bfd0f
    if (memoryAGet16(ds, 0x20cea7) != 0x0020)
        { pc = 0x1bfd3d; break; }
    r16[ax] = 0x0138;
    r16[bx] = 0x0114;
    r16[cx] = 0x0002;
    r16[dx] = 0x0004;
    r16[bp] = memoryAGet16(ds, 0x20eeb0);
    r16[bp] &= 0x0008;
    if (!r16[bp])
        { pc = 0x1bfd38; break; }
    r16[cx]++;
  case 0x1bfd38: // 0160:1bfd38
    { pc = 0x1bd7dd; break; }
  case 0x1bfd3d: // 0160:1bfd3d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1bfd3e() // 0160:1bfd3e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1bfe36; break; }
    r32[eax] = 0;
    interrupt(0x16);
    if (r8[ah] != 0x1c)
        { pc = 0x1bfd70; break; }
    if (memoryAGet16(ds, 0x20cea7) == 0x0020)
        { pc = 0x1bfe36; break; }
    memoryASet16(ds, 0x20e831, 0x0001);
    { pc = 0x1bfdcf; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bfd70: // 0160:1bfd70
    if (r8[ah] != 0x01)
        { pc = 0x1bfd7f; break; }
    memoryASet16(ds, 0x20e831, 0x00ff);
    r32[esp] += 4; return;
  case 0x1bfd7f: // 0160:1bfd7f
    if (r8[ah] != 0x53)
        { pc = 0x1bfda0; break; }
  case 0x1bfd84: // 0160:1bfd84
    if (memoryAGet16(ds, 0x20cea7) == 0x0020)
        { pc = 0x1bfe36; break; }
    memoryASet16(ds, 0x20cea7, 0x0020);
    { pc = 0x1bfdcf; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1bfda0: // 0160:1bfda0
    if (r8[ah] == 0x0e)
        { pc = 0x1bfd84; break; }
    if (r8[al] < 0x41)
        { pc = 0x1bfe36; break; }
    if (r8[al] < 0x5b)
        { pc = 0x1bfdc7; break; }
    r8[al] -= 0x20;
    if (r8[al] < 0x41)
        { pc = 0x1bfe36; break; }
    if (r8[al] > 0x5a)
        { pc = 0x1bfe36; break; }
  case 0x1bfdc7: // 0160:1bfdc7
    r8[ah] = 0;
    memoryASet16(ds, 0x20cea7, r16[ax]);
  case 0x1bfdcf: // 0160:1bfdcf
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet(ds, 0x20ea29, 0xc4);
    memoryASet(ds, 0x20ea2a, 0x97);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x01);
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, 0x20ea2d, r8[al]);
    r16[dx] = memoryAGet16(ds, 0x2231c4);
    push32(r32[edx]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esi] = 0x0020ea29;
    yield* sub_1be816();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x0020ea29;
    yield* sub_1be816();
    r32[edx] = pop32();
    memoryASet16(ds, 0x2231c4, r16[dx]);
    r32[esp] += 4; return;
  case 0x1bfe36: // 0160:1bfe36
    if (memoryAGet16(ds, 0x20cea7) != 0x0020)
        { pc = 0x1bfdcf; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1bfe41() // 0160:1bfe41 +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bfe67();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bfe67();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4;
}
function* sub_1bfe67() // 0160:1bfe67 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bfe67; break; }
  case 0x1be816: // 0160:1be816
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 5345 bytes // gap 5345 bytes
  case 0x1bfe67: // 0160:1bfe67
    yield* sub_1c007a();
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x0010;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[esi] += 0x00002ed4;
    r32[esi] += r32[eax];
    push32(r32[esi]);
    r8[bl] = 0x10;
    r32[esi] += 0x0000000f;
  case 0x1bfe92: // 0160:1bfe92
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1bfe9c; break; }
    r8[bl]--;
    r32[esi]--;
    { pc = 0x1bfe92; break; }
  case 0x1bfe9c: // 0160:1bfe9c
    r8[dl] = 0x28;
    r8[dl] -= r8[bl];
    r8[dl] >>>= 1;
    r32[esi] = pop32();
    r32[edi] = 0x0020e9c9;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    memoryASet(ds, 0x20e9c5, 0xc3);
    memoryASet(ds, 0x20e9c6, 0xc0);
    memoryASet(ds, 0x20e9c6, memoryAGet(ds, 0x20e9c6) + r8[dl]);
    memoryASet(ds, 0x20e9c7, 0xf0);
    memoryASet(ds, 0x20e9c8, 0x10);
    r32[esi] = 0x0020e9c5;
    { pc = 0x1be816; break; }
    return;
  }
}
function* sub_1bfedb() // 0160:1bfedb +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bff01();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4;
}
function* sub_1bff01() // 0160:1bff01 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bff01; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 39736 bytes // gap 39736 bytes
  case 0x1bff01: // 0160:1bff01
    r32[esi] = 0x001ee150;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee15f;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee176;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee187;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee199;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee1aa;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1bff3d() // 0160:1bff3d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bff3d; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 10008 bytes // gap 10008 bytes
  case 0x1bff3d: // 0160:1bff3d
    r16[ax] += 0x006b;
    if (!r16[bp])
        { pc = 0x1bff4a; break; }
    r16[ax] += 0x0002;
  case 0x1bff4a: // 0160:1bff4a
    if (!memoryAGet16(ds, 0x20e82f))
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0040;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0030;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1b4b56; break; }
    r16[ax] -= 0x0048;
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1bffa9() // 0160:1bffa9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bffa9; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 10116 bytes // gap 10116 bytes
  case 0x1bffa9: // 0160:1bffa9
    r16[ax] += 0x0023;
    if (!r16[bp])
        { pc = 0x1bffb6; break; }
    r16[ax] += 0x0002;
  case 0x1bffb6: // 0160:1bffb6
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1bffce() // 0160:1bffce +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1bfff9();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1bfff9();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1bfff9() // 0160:1bfff9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1bfff9; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 39984 bytes // gap 39984 bytes
  case 0x1bfff9: // 0160:1bfff9
    r8[al] = 0xc4;
    r8[bl] = 0x0a;
    r8[cl] = 0x0b;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x8a;
    r8[cl] = 0x13;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x0a;
    r8[cl] = 0x0d;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x8a;
    r8[cl] = 0x0e;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x0a;
    r8[cl] = 0x0d;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x8a;
    r8[cl] = 0x04;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c003b() // 0160:1c003b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c003b; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 40050 bytes // gap 40050 bytes
  case 0x1c003b: // 0160:1c003b
    r32[esi] = 0x001ee1e6;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee1ed;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c004f() // 0160:1c004f +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c007a();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c007a();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1c007a() // 0160:1c007a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c007a; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 40113 bytes // gap 40113 bytes
  case 0x1c007a: // 0160:1c007a
    r32[esi] = 0x001ee253;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee25a;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c0466() // 0160:1c0466 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c0466; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 11329 bytes // gap 11329 bytes
  case 0x1c0466: // 0160:1c0466
    r16[ax] += 0x0024;
    if (!r16[bp])
        { pc = 0x1c0473; break; }
    r16[ax] += 0x0002;
  case 0x1c0473: // 0160:1c0473
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1b4b56; break; }
    r16[ax] += 0x0008;
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1c049d() // 0160:1c049d +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c04c8();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c04c8();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1c04c8() // 0160:1c04c8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c04c8; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 41215 bytes // gap 41215 bytes
  case 0x1c04c8: // 0160:1c04c8
    r32[esi] = 0x001f1504;
    yield* sub_1b60d3();
    r32[esi] = 0x001f150a;
    yield* sub_1b60d3();
    r32[esi] = 0x001f1511;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c04e6() // 0160:1c04e6 +long
{
    r32[esp] -= 4;
    push(ds);
    es = pop();
    r32[ecx] = 0x00000018;
    r32[esi] = 0x001ef58b;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20b804);
    r32[eax] = memoryAGet16(ds, 0x224668);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r32[edx] = 0x0020e9c5;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet(ds, r32[edx] + 0x10, r8[bl]);
    memoryASet16(ds, r32[edx] + 0x11, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edx], r8[al]);
    memoryASet32(ds, 0x224670, 0x0000304c);
    memoryASet32(ds, 0x224674, 0x0023c4e0);
    yield* sub_1c1db9();
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c05ef();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c05ef();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r8[al] = memoryAGet(ds, 0x23c4f9);
    r32[eax] &= 0x000000ff;
    r32[esi] = 0x001f1476;
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r32[edi] = 0x0020c99a;
    yield* sub_1c2296();
    r32[edi] = 0x0020c9a0;
    yield* sub_1c2296();
    r32[edi] = 0x0020c9a6;
    r32[ecx] = 0x00000006;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r8[al] = memoryAGet(ds, 0x23c4f8);
    r32[eax] &= 0x000000ff;
    r32[esi] = 0x001f13fe;
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r32[edi] = 0x0020c985;
    yield* sub_1c2296();
    r32[edi] = 0x0020c991;
    yield* sub_1c2296();
    r32[edi] = 0x0020c997;
    yield* sub_1c2296();
    r32[edi] = 0x0020c99d;
    yield* sub_1c2296();
    memoryASet16(ds, 0x224666, 0x0050);
    r32[esp] += 4;
}
function* sub_1c05ef() // 0160:1c05ef +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x00000098;
    r32[ebp] = 0x00000271;
    r32[esi] = 0x0023c4fb;
  case 0x1c05fe: // 0160:1c05fe
    r32[ebx] = 0x00000108;
    r32[edi] = 0x00000019;
  case 0x1c0608: // 0160:1c0608
    r32[ecx] = memoryAGet(ds, r32[esi]);
    r32[ecx] += 0x00000004;
    r32[edx] = 0x00000004;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi]++;
    r32[ebp]--;
    if (!r32[ebp])
        { pc = 0x1c0636; break; }
    r32[ebx] += 0x00000003;
    r32[edi]--;
    if (r32[edi])
        { pc = 0x1c0608; break; }
    yield* sub_1c0636();
    r32[eax] += 0x00000003;
    { pc = 0x1c05fe; break; }
  case 0x1c0636: // 0160:1c0636
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1b5126();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c0636() // 0160:1c0636 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1b5126();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c06b3() // 0160:1c06b3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c06b3; break; }
  case 0x1a8054: // 0160:1a8054
    flags.direction = 0;
    push(ds);
    es = pop();
    r32[edi] = 0x0030b070;
    r32[ecx] = 0x00000030;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8a9b;
    r32[eax] = 0x00002509;
    interrupt(0x21);
    ds = pop();
    memoryASet16(ds, 0x417, memoryAGet16(ds, 0x417) & 0x00f0);
    r32[esp] += 4; return;
    // gap 99893 bytes // gap 99893 bytes
  case 0x1c06b3: // 0160:1c06b3
    r32[esi] = memoryAGet32(ds, 0x20b804);
    r32[esi] += 0x00002ed4;
    r32[eax] = memoryAGet16(ds, 0x224668);
    r32[eax] <<= 4;
    r32[esi] += r32[eax];
    memoryASet32(ds, 0x20ced3, r32[esi]);
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1c072f; break; }
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x00000010;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00002ed4;
    memoryASet32(ds, 0x20cecf, r32[edi]);
    r32[edx] = 0;
  case 0x1c0700: // 0160:1c0700
    r32[esi] = 0x0020e9c5;
    r32[edi] = memoryAGet32(ds, 0x20cecf);
    r32[ecx] = 0x00000004;
  case 0x1c0710: // 0160:1c0710
    cmpsd_DSESI_ESEDI();
    if (!flags.zero)
        { pc = 0x1c071c; break; }
    if (--r32[ecx])
        { pc = 0x1c0710; break; }
    yield* sub_1c098b();
    { pc = 0x1c06b3; break; }
  case 0x1c071c: // 0160:1c071c
    r32[edx]++;
    if (memoryAGet16(ds, 0x22464c) == r16[dx])
        { pc = 0x1c072f; break; }
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + 0x00000010);
    { pc = 0x1c0700; break; }
  case 0x1c072f: // 0160:1c072f
    push(ds);
    es = pop();
    r32[ecx] = 0x00000018;
    r32[esi] = 0x001ef58b;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20b804);
    r32[eax] = memoryAGet16(ds, 0x224668);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r32[edx] = 0x0020e9c5;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet(ds, r32[edx] + 0x10, r8[bl]);
    memoryASet16(ds, r32[edx] + 0x11, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edx], r8[al]);
    memoryASet32(ds, 0x224670, 0xffffffff);
    r32[eax] = 0x0023c4e0;
    memoryASet32(ds, 0x224674, r32[eax]);
    yield* sub_1c1db9();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1c0910; break; }
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1c07b1; break; }
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
    { pc = 0x1c07f0; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c07b1: // 0160:1c07b1
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
  case 0x1c07b7: // 0160:1c07b7
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[bx] = 0;
  case 0x1c07c0: // 0160:1c07c0
    if (r8[dl] != memoryAGet(ds, r32[esi] + 0x5))
        { pc = 0x1c07cb; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x6))
        { pc = 0x1c07db; break; }
  case 0x1c07cb: // 0160:1c07cb
    r16[bx]++;
    if (r16[bx] == memoryAGet16(ds, 0x22464c))
        { pc = 0x1c07f0; break; }
    r32[esi] += 0x0000000c;
    { pc = 0x1c07c0; break; }
  case 0x1c07db: // 0160:1c07db
    r8[ah]++;
    if (r8[ah] != 0x3a)
        { pc = 0x1c07b7; break; }
    r8[ah] = 0x30;
    r8[al]++;
    if (r8[al] != 0x3a)
        { pc = 0x1c07b7; break; }
    r8[al] = 0x30;
    r8[dl]++;
    { pc = 0x1c07b7; break; }
  case 0x1c07f0: // 0160:1c07f0
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[dl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    memoryASet(ds, 0x20ec45, r8[dl]);
    memoryASet16(ds, 0x20ec46, r16[ax]);
    r32[esi] = memoryAGet32(ds, 0x20ced3);
    r32[edi] = 0x0023c4e0;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    yield* sub_1bf923();
    r32[esi] = memoryAGet32(ds, 0x20ced3);
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20ced3);
    r32[esi] += 0x0000000f;
    r32[edx] = 0x00000010;
  case 0x1c0850: // 0160:1c0850
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1c0859; break; }
    r32[esi]--;
    r32[edx]--;
    { pc = 0x1c0850; break; }
  case 0x1c0859: // 0160:1c0859
    memoryASet16(ds, 0x224650, r16[dx]);
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1c08d6; break; }
    r32[ecx] = 0x0000000c;
    r32[esi] = 0x001ef56a;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    push32(r32[edi]);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r8[dl] = memoryAGet(ds, 0x20ec45);
    r16[ax] = memoryAGet16(ds, 0x20ec46);
    memoryASet(ds, r32[edi] + 0x5, r8[dl]);
    memoryASet16(ds, r32[edi] + 0x6, r16[ax]);
    r32[esi] = 0x0023c4e0;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00002ed4;
    r32[ecx] = 0x00000010;
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x22464c, memoryAGet16(ds, 0x22464c) + 1);
    r32[esp] += 4; return;
  case 0x1c08d6: // 0160:1c08d6
    yield* sub_1a8044();
    yield* sub_1c094a();
  case 0x1c08e0: // 0160:1c08e0
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c0900; break; }
    r32[eax] = 0;
    interrupt(0x16);
    { pc = 0x1a8054; break; }
  case 0x1c0900: // 0160:1c0900
    r32[esi] = 0x001ee260;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c08e0; break; }
  case 0x1c0910: // 0160:1c0910
    yield* sub_1a8044();
    yield* sub_1c094a();
  case 0x1c091a: // 0160:1c091a
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c093a; break; }
    r32[eax] = 0;
    interrupt(0x16);
    { pc = 0x1a8054; break; }
  case 0x1c093a: // 0160:1c093a
    r32[esi] = 0x001ee3f4;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c091a; break; }
    return;
  }
}
function* sub_1c094a() // 0160:1c094a +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c0975();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c0975();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1c0975() // 0160:1c0975 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c0975; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 42412 bytes // gap 42412 bytes
  case 0x1c0975: // 0160:1c0975
    r8[al] = 0xc4;
    r8[bl] = 0x0c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x08;
    r8[cl] = 0x18;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c098b() // 0160:1c098b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1a8044();
    yield* sub_1c094a();
  case 0x1c0995: // 0160:1c0995
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c09ba; break; }
    r32[eax] = 0;
    interrupt(0x16);
    yield* sub_1a8054();
    { pc = 0x1c108f; break; }
  case 0x1c09ba: // 0160:1c09ba
    r32[esi] = 0x001ee2fe;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c0995; break; }
    // gap 1733 bytes // gap 1733 bytes
  case 0x1c108f: // 0160:1c108f
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x224650, 0x0000);
    r8[al] = 0x20;
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    yield* sub_1a8044();
    yield* sub_1c11a3();
    yield* sub_1c10ee();
    if (!(memoryAGet16(ds, 0x224650) & 0xffff))
        { pc = 0x1c108f; break; }
    r32[esi] = 0x00224684;
    r32[edi] = memoryAGet32(ds, 0x20b804);
    r32[edi] += 0x00002ed4;
    r32[eax] = memoryAGet16(ds, 0x224668);
    r32[eax] <<= 4;
    r32[edi] += r32[eax];
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c09ca() // 0160:1c09ca +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c09f5();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c09f5();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1c09f5() // 0160:1c09f5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c09f5; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 42540 bytes // gap 42540 bytes
  case 0x1c09f5: // 0160:1c09f5
    r8[al] = 0xc3;
    r8[bl] = 0x08;
    r8[cl] = 0x19;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x8c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x90;
    r8[cl] = 0x08;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c0a16() // 0160:1c0a16 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x224662, 0x0000);
    r32[eax] = 0x00002f00;
    interrupt(0x21);
    memoryASet32(ds, 0x20ceef, r32[ebx]);
    r32[eax] = 0x00001a00;
    r32[edx] = 0x00224694;
    interrupt(0x21);
    r32[eax] = 0x00004e00;
    r32[ecx] = 0x00000000;
    r32[edx] = 0x0020ea5b;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c0a90; break; }
    r32[edi] = memoryAGet32(ds, 0x20b804);
    memoryASet32(ds, 0x20ceeb, r32[edi]);
  case 0x1c0a57: // 0160:1c0a57
    memoryASet16(ds, 0x224662, memoryAGet16(ds, 0x224662) + 1);
    if (memoryAGet16(ds, 0x224662) == 0x03e7)
        { pc = 0x1c0a90; break; }
    r32[esi] = 0x002246b2;
    r32[edi] = memoryAGet32(ds, 0x20ceeb);
    push(ds);
    es = pop();
    r32[ecx] = 0x00000003;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    memoryASet32(ds, 0x20ceeb, r32[edi]);
    r32[eax] = 0x00004f00;
    interrupt(0x21);
    if (!flags.carry)
        { pc = 0x1c0a57; break; }
  case 0x1c0a90: // 0160:1c0a90
    r32[eax] = 0x00001a00;
    r32[edx] = memoryAGet32(ds, 0x20ceef);
    interrupt(0x21);
    if (!(memoryAGet16(ds, 0x224662) & 0xffff))
        { pc = 0x1c0b02; break; }
    r32[edi] = memoryAGet32(ds, 0x20b804);
    r32[edi] += 0x00002ed4;
    memoryASet32(ds, 0x20ced3, r32[edi]);
    memoryASet16(ds, 0x20ec8f, 0x0000);
    r32[ebx] = 0;
  case 0x1c0ac9: // 0160:1c0ac9
    push32(r32[ebx]);
    yield* sub_1c0b03();
    r32[ebx] = pop32();
    memoryASet32(ds, 0x20ced3, memoryAGet32(ds, 0x20ced3) + 0x00000010);
    if (!r16[ax])
        { pc = 0x1c0ae5; break; }
    r16[bx]++;
    memoryASet32(ds, 0x20ced3, memoryAGet32(ds, 0x20ced3) - 0x00000010);
  case 0x1c0ae5: // 0160:1c0ae5
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x224662))
        { pc = 0x1c0ac9; break; }
    memoryASet16(ds, 0x224662, memoryAGet16(ds, 0x224662) - r16[bx]);
  case 0x1c0b02: // 0160:1c0b02
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c0b03() // 0160:1c0b03 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push(ds);
    es = pop();
    r32[ecx] = 0x00000018;
    r32[esi] = 0x001ef58b;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20b804);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edx] = 0x0020e9c5;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet(ds, r32[edx] + 0x10, r8[bl]);
    memoryASet16(ds, r32[edx] + 0x11, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cea7);
    memoryASet(ds, r32[edx], r8[al]);
    memoryASet32(ds, 0x224670, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x20ced3);
    memoryASet32(ds, 0x224674, r32[eax]);
    { pc = 0x1c1db9; break; }
    // gap 4693 bytes // gap 4693 bytes
  case 0x1c1db9: // 0160:1c1db9
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e16; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e16; break; }
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, 0x224670, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
  case 0x1c1e16: // 0160:1c1e16
    r32[edx] = memoryAGet32(ds, 0x224674);
    r32[ecx] = memoryAGet32(ds, 0x224670);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (memoryAGet32(ds, 0x224670) != r32[eax])
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1c1e87();
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e65; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e65; break; }
    yield* sub_1c4573();
  case 0x1c1e65: // 0160:1c1e65
    r32[esp] += 4; return;
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c0b64() // 0160:1c0b64 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c0f4d();
    yield* sub_1c0eff();
    memoryASet16(ds, 0x20ec3d, 0x00d6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
    memoryASet16(ds, 0x20ee75, 0x0003);
  case 0x1c0baa: // 0160:1c0baa
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    yield* sub_1c0d29();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c0cff; break; }
    r32[esi] = 0x001ee428;
    r8[al] = 0xc3;
    r8[bl] = 0x0d;
    yield* sub_1b60a7();
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi], 0xc4);
    memoryASet(ds, r32[esi] + 0x1, 0x14);
    r32[esi] += 0x00000004;
    r8[bl] = 0;
    r8[cl] = 0x07;
    r16[ax] = memoryAGet16(ds, 0x23c4f1);
    r16[ax] >>>= 1;
    r16[ax] -= 0x0038;
  case 0x1c0bf6: // 0160:1c0bf6
    if (r16[ax] < 0x0064)
        { pc = 0x1c0c04; break; }
    r16[ax] -= 0x0064;
    r8[bl]++;
    { pc = 0x1c0bf6; break; }
  case 0x1c0c04: // 0160:1c0c04
    if (!r8[bl])
        { pc = 0x1c0c12; break; }
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    r8[cl]++;
    r8[bl] = 0;
  case 0x1c0c12: // 0160:1c0c12
    if (r16[ax] < 0x000a)
        { pc = 0x1c0c20; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1c0c12; break; }
  case 0x1c0c20: // 0160:1c0c20
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi], r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    memoryASet(ds, r32[esi] + 0x2, 0x20);
    memoryASet(ds, r32[esi] + 0x3, 0x4d);
    memoryASet(ds, r32[esi] + 0x4, 0x50);
    memoryASet(ds, r32[esi] + 0x5, 0x48);
    memoryASet(ds, r32[esi] + 0x6, 0x20);
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi] + 0x3, r8[cl]);
    if (memoryAGet16(ds, 0x20e82f) & 0xffff)
        { pc = 0x1c0c5b; break; }
    yield* sub_1be816();
    { pc = 0x1c0c60; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c0c5b: // 0160:1c0c5b
    yield* sub_1b60d3();
  case 0x1c0c60: // 0160:1c0c60
    r8[al] = 0xc4;
    r8[bl] = 0xdb;
    r8[cl] = memoryAGet(ds, 0x23c4f3);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    if (memoryAGet16(ds, 0x20e82f) != 0x0001)
        { pc = 0x1c0c84; break; }
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) + 1);
  case 0x1c0c84: // 0160:1c0c84
    yield* sub_1c0d00();
    r8[al] = 0xc5;
    r8[bl] = 0x93;
    r8[cl] = memoryAGet(ds, 0x23c4f4);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    if (memoryAGet16(ds, 0x20e82f) != 0x0002)
        { pc = 0x1c0cad; break; }
    memoryASet16(ds, 0x20ceb1, memoryAGet16(ds, 0x20ceb1) + 1);
  case 0x1c0cad: // 0160:1c0cad
    yield* sub_1c0d00();
    r8[al] = memoryAGet(ds, 0x23c4f0);
    r32[esi] = 0x001ee46b;
    if (!r8[al])
        { pc = 0x1c0cd7; break; }
    r32[esi] = 0x001ee475;
    if (r8[al] == 0x01)
        { pc = 0x1c0cd7; break; }
    r32[esi] = 0x001ee47f;
    if (r8[al] == 0x02)
        { pc = 0x1c0cd7; break; }
    r32[esi] = 0x001ee489;
  case 0x1c0cd7: // 0160:1c0cd7
    if (memoryAGet16(ds, 0x20e82f) != 0x0003)
        { pc = 0x1c0ceb; break; }
    yield* sub_1be816();
    { pc = 0x1c0cf0; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c0ceb: // 0160:1c0ceb
    yield* sub_1b60d3();
  case 0x1c0cf0: // 0160:1c0cf0
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c0baa; break; }
  case 0x1c0cff: // 0160:1c0cff
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c0d00() // 0160:1c0d00 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c0d00; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 33869 bytes // gap 33869 bytes
  case 0x1be816: // 0160:1be816
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1be833: // 0160:1be833
    if (r8[al] < 0x40)
        { pc = 0x1be83d; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1be833; break; }
  case 0x1be83d: // 0160:1be83d
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1be89a; break; }
    r32[edi] = 0x000a0000;
  case 0x1be89a: // 0160:1be89a
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1be8b8; break; }
    r16[dx] = 0x0008;
  case 0x1be8b8: // 0160:1be8b8
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1be8c6: // 0160:1be8c6
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1be8c6; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1be8e9: // 0160:1be8e9
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1be966; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1be918: // 0160:1be918
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1be92f: // 0160:1be92f
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1be93e; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be93e: // 0160:1be93e
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1be94f; break; }
    r8[cl] += 0x10;
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1be94f: // 0160:1be94f
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1be92f; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1be918; break; }
  case 0x1be966: // 0160:1be966
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1be97f; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1be8e9; break; }
  case 0x1be97f: // 0160:1be97f
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 9082 bytes // gap 9082 bytes
  case 0x1c0d00: // 0160:1c0d00
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi], r8[al]);
    memoryASet(ds, r32[esi] + 0x1, r8[bl]);
    memoryASet(ds, r32[esi] + 0x3, 0x01);
    r8[cl] += 0x30;
    memoryASet(ds, r32[esi] + 0x4, r8[cl]);
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1c0d24; break; }
    { pc = 0x1be816; break; }
  case 0x1c0d24: // 0160:1c0d24
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c0d29() // 0160:1c0d29 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e82f, memoryAGet16(ds, 0x20e82f) + r16[cx]);
    if (signed16(memoryAGet16(ds, 0x20e82f)) < 0)
        { pc = 0x1c0d4c; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0004)
        { pc = 0x1c0d55; break; }
    memoryASet16(ds, 0x20e82f, 0x0000);
    { pc = 0x1c0d55; break; }
  case 0x1c0d4c: // 0160:1c0d4c
    memoryASet16(ds, 0x20e82f, 0x0003);
  case 0x1c0d55: // 0160:1c0d55
    memoryASet16(ds, 0x20cec5, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[dx] = memoryAGet16(ds, 0x20eeb0);
    r16[dx] &= 0x0007;
    r16[dx] >>>= 2;
    if (!r16[dx])
        { pc = 0x1c0d80; break; }
    r16[ax]--;
    memoryASet16(ds, 0x20cec5, 0x0001);
  case 0x1c0d80: // 0160:1c0d80
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[dx] = memoryAGet16(ds, 0x20e82f);
    r16[dx] <<= 3;
    r16[cx] = r16[dx];
    r16[dx] <<= 1;
    r16[dx] += r16[cx];
    r16[bx] += r16[dx];
    r16[cx] = 0;
    r16[dx] = 0x0001;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bd7dd();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0084;
    r16[ax] += memoryAGet16(ds, 0x20cec5);
    r16[ax] += memoryAGet16(ds, 0x20cec5);
    if (!memoryAGet16(ds, 0x20e82f))
        { pc = 0x1c0ddc; break; }
    r16[ax] -= 0x0038;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1c0ddc; break; }
    r16[ax] += 0x0040;
  case 0x1c0ddc: // 0160:1c0ddc
    r16[dx] = 0;
    yield* sub_1b4b5a();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c0e42; break; }
    memoryASet16(ds, 0x20ceb1, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c0e1a; break; }
    memoryASet16(ds, 0x224652, 0x0000);
    memoryASet16(ds, 0x224654, 0x0000);
    { pc = 0x1c0e8b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c0e1a: // 0160:1c0e1a
    if (memoryAGet16(ds, 0x224652) != 0x0050)
        { pc = 0x1c0e3a; break; }
    memoryASet16(ds, 0x224654, memoryAGet16(ds, 0x224654) + 1);
    memoryASet16(ds, 0x224654, memoryAGet16(ds, 0x224654) & 0x0003);
    if (!memoryAGet16(ds, 0x224654))
        { pc = 0x1c0e8b; break; }
    r32[esp] += 4; return;
  case 0x1c0e3a: // 0160:1c0e3a
    memoryASet16(ds, 0x224652, memoryAGet16(ds, 0x224652) + 1);
    r32[esp] += 4; return;
  case 0x1c0e42: // 0160:1c0e42
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c0e78; break; }
    memoryASet16(ds, 0x20ceb1, 0x0001);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c0e1a; break; }
    memoryASet16(ds, 0x224652, 0x0000);
    memoryASet16(ds, 0x224654, 0x0000);
    { pc = 0x1c0e8b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c0e78: // 0160:1c0e78
    memoryASet16(ds, 0x224652, 0x0000);
    memoryASet16(ds, 0x224654, 0x0000);
    r32[esp] += 4; return;
  case 0x1c0e8b: // 0160:1c0e8b
    r32[esi] = 0x0023c4f0;
    r8[al] = 0;
    r8[bl] = 0x03;
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1c0ec3; break; }
    r16[ax] = 0x00d4;
    r16[bx] = 0x0200;
    r32[esi]++;
    if (!memoryAGet16(ds, 0x20e82f))
        { pc = 0x1c0ee0; break; }
    r32[esi] += 0x00000002;
    r8[al] = 0x01;
    r8[bl] = 0x09;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1c0ec3; break; }
    r32[esi]++;
  case 0x1c0ec3: // 0160:1c0ec3
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1c0ed9; break; }
    if (memoryAGet(ds, r32[esi]) == r8[al])
        { pc = 0x1c0efe; break; }
    memoryASet(ds, r32[esi], memoryAGet(ds, r32[esi]) - 1);
    r32[esp] += 4; return;
  case 0x1c0ed9: // 0160:1c0ed9
    if (memoryAGet(ds, r32[esi]) == r8[bl])
        { pc = 0x1c0efe; break; }
    memoryASet(ds, r32[esi], memoryAGet(ds, r32[esi]) + 1);
    r32[esp] += 4; return;
  case 0x1c0ee0: // 0160:1c0ee0
    if (!(memoryAGet16(ds, 0x20ceb1) & 0xffff))
        { pc = 0x1c0ef5; break; }
    if (memoryAGet16(ds, r32[esi]) == r16[ax])
        { pc = 0x1c0efe; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0002);
    r32[esp] += 4; return;
  case 0x1c0ef5: // 0160:1c0ef5
    if (memoryAGet16(ds, r32[esi]) == r16[bx])
        { pc = 0x1c0efe; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x0002);
  case 0x1c0efe: // 0160:1c0efe
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c0eff() // 0160:1c0eff +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c0f25();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c0f25();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4;
}
function* sub_1c0f25() // 0160:1c0f25 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c0f25; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 43868 bytes // gap 43868 bytes
  case 0x1c0f25: // 0160:1c0f25
    r32[esi] = 0x001ee43b;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee445;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee456;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee45f;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c0f4d() // 0160:1c0f4d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c0f4d; break; }
  case 0x1b5267: // 0160:1b5267
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1b5279: // 0160:1b5279
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r32[ecx] = 0x00004600;
  case 0x1b5286: // 0160:1b5286
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1b5295; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1b5295: // 0160:1b5295
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1b5286; break; }
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b5279; break; }
    r32[esp] += 4; return;
    // gap 48300 bytes // gap 48300 bytes
  case 0x1c0f4d: // 0160:1c0f4d
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    memoryASet16(ds, 0x20e905, 0x0002);
    yield* sub_1b551f();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    { pc = 0x1b5267; break; }
    return;
  }
}
function* sub_1c0f92() // 0160:1c0f92 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x0023c76c;
    r32[ecx] = 0x00002dc0;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    memoryASet16(ds, 0x224650, 0x0000);
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    r8[al] = 0x20;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    r32[esi] = 0x0023c4e0;
    memoryASet(ds, r32[esi] + 0x10, 0x00);
    memoryASet16(ds, r32[esi] + 0x11, 0x0140);
    memoryASet(ds, r32[esi] + 0x13, 0x05);
    memoryASet(ds, r32[esi] + 0x14, 0x05);
    memoryASet(ds, r32[esi] + 0x18, 0x04);
    memoryASet(ds, r32[esi] + 0x19, 0x06);
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[ecx] = 0x00000271;
    r32[esi] = 0x0023c4fb;
  case 0x1c0fff: // 0160:1c0fff
    memoryASet(ds, r32[esi], 0x05);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c0fff; break; }
    r32[ecx] = 0x00000019;
    r32[esi] = 0x0023c4fb;
    r32[edi] = 0x0023c753;
  case 0x1c1014: // 0160:1c1014
    memoryASet(ds, r32[esi], 0x06);
    memoryASet(ds, r32[edi], 0x06);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c1014; break; }
    r32[ecx] = 0x00000019;
    r32[esi] = 0x0023c4fb;
    r32[edi] = 0x0023c513;
  case 0x1c102d: // 0160:1c102d
    memoryASet(ds, r32[esi], 0x06);
    memoryASet(ds, r32[edi], 0x06);
    r32[esi] += 0x00000019;
    r32[edi] += 0x00000019;
    if (--r32[ecx])
        { pc = 0x1c102d; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c103c() // 0160:1c103c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c103c; break; }
  case 0x1c0f92: // 0160:1c0f92
    r32[edi] = 0x0023c76c;
    r32[ecx] = 0x00002dc0;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    memoryASet16(ds, 0x224650, 0x0000);
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    r8[al] = 0x20;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    r32[esi] = 0x0023c4e0;
    memoryASet(ds, r32[esi] + 0x10, 0x00);
    memoryASet16(ds, r32[esi] + 0x11, 0x0140);
    memoryASet(ds, r32[esi] + 0x13, 0x05);
    memoryASet(ds, r32[esi] + 0x14, 0x05);
    memoryASet(ds, r32[esi] + 0x18, 0x04);
    memoryASet(ds, r32[esi] + 0x19, 0x06);
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[ecx] = 0x00000271;
    r32[esi] = 0x0023c4fb;
  case 0x1c0fff: // 0160:1c0fff
    memoryASet(ds, r32[esi], 0x05);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c0fff; break; }
    r32[ecx] = 0x00000019;
    r32[esi] = 0x0023c4fb;
    r32[edi] = 0x0023c753;
  case 0x1c1014: // 0160:1c1014
    memoryASet(ds, r32[esi], 0x06);
    memoryASet(ds, r32[edi], 0x06);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c1014; break; }
    r32[ecx] = 0x00000019;
    r32[esi] = 0x0023c4fb;
    r32[edi] = 0x0023c513;
  case 0x1c102d: // 0160:1c102d
    memoryASet(ds, r32[esi], 0x06);
    memoryASet(ds, r32[edi], 0x06);
    r32[esi] += 0x00000019;
    r32[edi] += 0x00000019;
    if (--r32[ecx])
        { pc = 0x1c102d; break; }
    r32[esp] += 4; return;
  case 0x1c103c: // 0160:1c103c
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1c0f92; break; }
    memoryASet32(ds, 0x224670, 0xffffffff);
    r32[eax] = 0x0023c4e0;
    memoryASet32(ds, 0x224674, r32[eax]);
    yield* sub_1c1d74();
    r32[esi] = 0x0023c4e0;
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x00224693;
    r16[ax] = 0x0010;
  case 0x1c107e: // 0160:1c107e
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1c1088; break; }
    r32[esi]--;
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1c107e; break; }
  case 0x1c1088: // 0160:1c1088
    memoryASet16(ds, 0x224650, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c10ee() // 0160:1c10ee +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c1122();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c1122();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1c1122() // 0160:1c1122 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1122; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 44377 bytes // gap 44377 bytes
  case 0x1c1122: // 0160:1c1122
    r8[al] = 0xc4;
    r8[bl] = 0x4c;
    r8[cl] = 0x10;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c112d() // 0160:1c112d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c112d; break; }
  case 0x1a8054: // 0160:1a8054
    flags.direction = 0;
    push(ds);
    es = pop();
    r32[edi] = 0x0030b070;
    r32[ecx] = 0x00000030;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8a9b;
    r32[eax] = 0x00002509;
    interrupt(0x21);
    ds = pop();
    memoryASet16(ds, 0x417, memoryAGet16(ds, 0x417) & 0x00f0);
    r32[esp] += 4; return;
    // gap 102575 bytes // gap 102575 bytes
  case 0x1c112d: // 0160:1c112d
    yield* sub_1c0f4d();
    if (!(memoryAGet16(ds, 0x224650) & 0x0fff))
        { pc = 0x1c1199; break; }
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet(ds, 0x20ea29, 0xc4);
    memoryASet(ds, 0x20ea2a, 0x4c);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x10);
    r32[edi] = 0x0020ea2d;
    r32[esi] = 0x00224684;
    r32[ecx] = 0x00000010;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
  case 0x1c1199: // 0160:1c1199
    yield* sub_1a8044();
    yield* sub_1b4f0e();
  case 0x1c11a3: // 0160:1c11a3
    yield* sub_1b5096();
    yield* sub_1b531f();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c11da; break; }
    r32[esi] = 0x00224693;
    r16[ax] = 0x0010;
  case 0x1c11c5: // 0160:1c11c5
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1c11cf; break; }
    r32[esi]--;
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1c11c5; break; }
  case 0x1c11cf: // 0160:1c11cf
    memoryASet16(ds, 0x224650, r16[ax]);
    { pc = 0x1a8054; break; }
  case 0x1c11da: // 0160:1c11da
    yield* sub_1c126f();
    yield* sub_1c11f4();
    r32[esi] = 0x001ee332;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c11a3; break; }
    return;
  }
}
function* sub_1c11a3() // 0160:1c11a3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c11a3; break; }
  case 0x1a8054: // 0160:1a8054
    flags.direction = 0;
    push(ds);
    es = pop();
    r32[edi] = 0x0030b070;
    r32[ecx] = 0x00000030;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    push(ds);
    push(cs);
    ds = pop();
    r32[edx] = 0x001a8a9b;
    r32[eax] = 0x00002509;
    interrupt(0x21);
    ds = pop();
    memoryASet16(ds, 0x417, memoryAGet16(ds, 0x417) & 0x00f0);
    r32[esp] += 4; return;
    // gap 102693 bytes // gap 102693 bytes
  case 0x1c11a3: // 0160:1c11a3
    yield* sub_1b5096();
    yield* sub_1b531f();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c11da; break; }
    r32[esi] = 0x00224693;
    r16[ax] = 0x0010;
  case 0x1c11c5: // 0160:1c11c5
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1c11cf; break; }
    r32[esi]--;
    r16[ax]--;
    if (r16[ax])
        { pc = 0x1c11c5; break; }
  case 0x1c11cf: // 0160:1c11cf
    memoryASet16(ds, 0x224650, r16[ax]);
    { pc = 0x1a8054; break; }
  case 0x1c11da: // 0160:1c11da
    yield* sub_1c126f();
    yield* sub_1c11f4();
    r32[esi] = 0x001ee332;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    { pc = 0x1c11a3; break; }
    return;
  }
}
function* sub_1c11f4() // 0160:1c11f4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x224650) == 0x0010)
        { pc = 0x1c126e; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0008;
    if (!r16[ax])
        { pc = 0x1c1235; break; }
    r32[eax] = 0x000000e0;
    r16[dx] = memoryAGet16(ds, 0x224650);
    r16[dx] <<= 3;
    r16[ax] += r16[dx];
    r32[ebx] = 0x0000010c;
    r32[ecx] = 0x00000003;
    r32[edx] = 0x00000004;
    yield* sub_1bd7dd();
  case 0x1c1235: // 0160:1c1235
    r16[dx] = memoryAGet16(ds, 0x224650);
    r16[bp] = r16[dx];
    r32[eax] = 0x000000e0;
    r16[dx] <<= 3;
    r16[ax] += r16[dx];
  case 0x1c124b: // 0160:1c124b
    r32[ebx] = 0x0000010c;
    r32[ecx] = 0x00000002;
    r32[edx] = 0x00000004;
    push32(r32[eax]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[eax] = pop32();
    r32[eax] += 0x00000008;
    r16[bp]++;
    if (r16[bp] != 0x0010)
        { pc = 0x1c124b; break; }
  case 0x1c126e: // 0160:1c126e
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c126f() // 0160:1c126f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20cec1, 0x0000);
    r32[eax] = 0x00000100;
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x1c13b7; break; }
    r32[eax] = 0;
    interrupt(0x16);
    if (r8[ah] != 0x1c)
        { pc = 0x1c129c; break; }
  case 0x1c128e: // 0160:1c128e
    memoryASet16(ds, 0x20e831, 0x0001);
    { pc = 0x1c13b7; break; }
  case 0x1c129c: // 0160:1c129c
    if (r8[ah] == 0x01)
        { pc = 0x1c128e; break; }
    if (r8[ah] != 0x53)
        { pc = 0x1c12c9; break; }
  case 0x1c12a6: // 0160:1c12a6
    if (!(memoryAGet16(ds, 0x224650) & 0xffff))
        { pc = 0x1c13b7; break; }
    memoryASet16(ds, 0x224650, memoryAGet16(ds, 0x224650) - 1);
    r8[al] = 0x20;
    memoryASet16(ds, 0x20cec1, 0x0001);
    { pc = 0x1c1316; break; }
  case 0x1c12c9: // 0160:1c12c9
    if (r8[ah] == 0x0e)
        { pc = 0x1c12a6; break; }
    if (memoryAGet16(ds, 0x224650) == 0x0010)
        { pc = 0x1c13b7; break; }
    if (r8[al] == 0x20)
        { pc = 0x1c1316; break; }
    if (r8[al] < 0x30)
        { pc = 0x1c13b7; break; }
    if (r8[al] < 0x3a)
        { pc = 0x1c1316; break; }
    if (r8[al] < 0x41)
        { pc = 0x1c13b7; break; }
    if (r8[al] < 0x5b)
        { pc = 0x1c1316; break; }
    if (r8[al] < 0x61)
        { pc = 0x1c13b7; break; }
    if (r8[al] > 0x7a)
        { pc = 0x1c13b7; break; }
    r8[al] -= 0x20;
  case 0x1c1316: // 0160:1c1316
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet(ds, 0x20ea29, 0xc4);
    r16[bx] = 0x004c;
    r16[bx] += memoryAGet16(ds, 0x224650);
    memoryASet(ds, 0x20ea2a, r8[bl]);
    memoryASet(ds, 0x20ea2b, 0xf0);
    memoryASet(ds, 0x20ea2c, 0x01);
    memoryASet(ds, 0x20ea2d, r8[al]);
    r16[dx] = memoryAGet16(ds, 0x2231c4);
    push32(r32[edx]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x2231c4, 0x0002);
    r32[esi] = 0x0020ea29;
    yield* sub_1b60d3();
    r32[edx] = pop32();
    memoryASet16(ds, 0x2231c4, r16[dx]);
    if (memoryAGet16(ds, 0x20cec1) & 0xffff)
        { pc = 0x1c1392; break; }
    memoryASet16(ds, 0x224650, memoryAGet16(ds, 0x224650) + 1);
  case 0x1c1392: // 0160:1c1392
    r32[esi] = 0x00224684;
    r16[ax] = memoryAGet16(ds, 0x224650);
    r32[eax] &= 0x0000ffff;
    if (memoryAGet16(ds, 0x20cec1) & 0xffff)
        { pc = 0x1c13ae; break; }
    r32[eax]--;
  case 0x1c13ae: // 0160:1c13ae
    r8[bl] = memoryAGet(ds, 0x20ea2d);
    memoryASet(ds, r32[esi] + r32[eax], r8[bl]);
  case 0x1c13b7: // 0160:1c13b7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c13b8() // 0160:1c13b8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    { pc = 0x1c5215; break; }
    // gap 15958 bytes // gap 15958 bytes
  case 0x1c5215: // 0160:1c5215
    memoryASet16(ds, 0x20d80d, r16[ax]);
    if (r16[ax])
        { pc = 0x1c524a; break; }
    r16[ax] = 0x0000;
    r16[bx] = 0x0000;
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r16[ax] += 0x0020;
    r16[bx] += 0x0020;
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    memoryASet16(ds, 0x20cf61, r16[bx]);
  case 0x1c524a: // 0160:1c524a
    memoryASet16(ds, 0x20d7f5, 0x0000);
    memoryASet(ds, 0x232cd8, 0x00);
    memoryASet(ds, 0x232cda, 0x00);
    memoryASet(ds, 0x232cd9, 0x19);
    memoryASet(ds, 0x232cdb, 0x19);
    r32[edi] = 0x00232cdc;
    r32[esi] = 0x0023c4fb;
    r32[ecx] = 0x00000271;
  case 0x1c527e: // 0160:1c527e
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c527e; break; }
  case 0x1c528c: // 0160:1c528c
    yield* sub_1c459c();
    if (r16[ax])
        { pc = 0x1c529d; break; }
    yield* sub_1c49d6();
    { pc = 0x1c528c; break; }
  case 0x1c529d: // 0160:1c529d
    if (r16[ax] == 0x00ff)
        { pc = 0x1c52c1; break; }
    r32[esi] = 0x00232cdc;
    r32[edi] = 0x0023c4fb;
    r32[ecx] = 0x00000271;
  case 0x1c52b6: // 0160:1c52b6
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c52b6; break; }
  case 0x1c52c1: // 0160:1c52c1
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c13c0() // 0160:1c13c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1c13c0: // 0160:1c13c0
    yield* sub_1c1ad8();
    r16[ax] = 0;
    memoryASet16(ds, 0x20ee71, r16[ax]);
    memoryASet16(ds, 0x20ee73, r16[ax]);
    memoryASet16(ds, 0x224656, 0x0064);
    memoryASet16(ds, 0x224658, 0x0064);
    yield* sub_1bafe1();
  case 0x1c13eb: // 0160:1c13eb
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c1631; break; }
    memoryASet16(ds, 0x20e831, 0x0000);
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1c15eb; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1c15f5; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1c15ff; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1c1609; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1c1613; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0005)
        { pc = 0x1c161d; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0006)
        { pc = 0x1c1627; break; }
    yield* sub_1c151e();
    memoryASet16(ds, 0x20ec3d, 0x00bf);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20e82f, 0x0000);
  case 0x1c1490: // 0160:1c1490
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c14c9; break; }
    if (memoryAGet16(ds, 0x20e82f) != 0x0001)
        { pc = 0x1c14b4; break; }
  case 0x1c14b3: // 0160:1c14b3
    r32[esp] += 4; return;
  case 0x1c14b4: // 0160:1c14b4
    yield* sub_1c1692();
    if (!(memoryAGet16(ds, 0x20ceaf) & 0xffff))
        { pc = 0x1c14b3; break; }
    { pc = 0x1c13c0; break; }
  case 0x1c14c9: // 0160:1c14c9
    r32[esi] = 0x001ee551;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee569;
    r8[al] = 0xc3;
    r8[bl] = 0x4c;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1c1567();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c1490; break; }
    // gap 205 bytes // gap 205 bytes
  case 0x1c15eb: // 0160:1c15eb
    yield* sub_1c112d();
    { pc = 0x1c13c0; break; }
  case 0x1c15f5: // 0160:1c15f5
    yield* sub_1c13b8();
    { pc = 0x1c13c0; break; }
  case 0x1c15ff: // 0160:1c15ff
    yield* sub_1bed9e();
    { pc = 0x1c13c0; break; }
  case 0x1c1609: // 0160:1c1609
    yield* sub_1c2599();
    { pc = 0x1c13c0; break; }
  case 0x1c1613: // 0160:1c1613
    yield* sub_1c0b64();
    { pc = 0x1c13c0; break; }
  case 0x1c161d: // 0160:1c161d
    yield* sub_1c52fc();
    { pc = 0x1c13c0; break; }
  case 0x1c1627: // 0160:1c1627
    yield* sub_1bf08c();
    { pc = 0x1c13c0; break; }
  case 0x1c1631: // 0160:1c1631
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0008);
    memoryASet16(ds, 0x20e809, 0x0007);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1c1a63();
    yield* sub_1c167d();
    r32[esi] = 0x001ee493;
    r8[al] = 0xc2;
    r8[bl] = 0x87;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c13eb; break; }
    return;
  }
}
function* sub_1c151e() // 0160:1c151e +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c1588();
    yield* sub_1c1553();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c1588();
    yield* sub_1c1553();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1c1553() // 0160:1c1553 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1553; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 45450 bytes // gap 45450 bytes
  case 0x1c1553: // 0160:1c1553
    r32[esi] = 0x001ee57d;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee584;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c1567() // 0160:1c1567 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1567; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 15682 bytes // gap 15682 bytes
  case 0x1c1567: // 0160:1c1567
    r16[ax] += 0x002b;
    if (!r16[bp])
        { pc = 0x1c1574; break; }
    r16[ax] += 0x0002;
  case 0x1c1574: // 0160:1c1574
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1c1583; break; }
    r16[ax] -= 0x0008;
  case 0x1c1583: // 0160:1c1583
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1c1588() // 0160:1c1588 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1588; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 45503 bytes // gap 45503 bytes
  case 0x1c1588: // 0160:1c1588
    r8[al] = 0xc2;
    r8[bl] = 0x87;
    r8[cl] = 0x1a;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x04;
    r8[cl] = 0x0b;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x84;
    r8[cl] = 0x0d;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x04;
    r8[cl] = 0x0f;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x84;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x04;
    r8[cl] = 0x0a;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x84;
    r8[cl] = 0x0b;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x04;
    r8[cl] = 0x0c;
    yield* sub_1b60e3();
    r8[al] = 0xc6;
    r8[bl] = 0x84;
    r8[cl] = 0x09;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c167d() // 0160:1c167d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c167d; break; }
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 15960 bytes // gap 15960 bytes
  case 0x1c167d: // 0160:1c167d
    r16[ax] = 0x0138;
    r16[bx] = 0x0100;
    r16[cx] = 0x0001;
    r16[dx] = 0x0004;
    { pc = 0x1bd7dd; break; }
    return;
  }
}
function* sub_1c1692() // 0160:1c1692 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ceaf, 0x0000);
    memoryASet16(ds, 0x20e831, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x2231c4);
    push32(r32[eax]);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c1a0b();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c1a0b();
    r32[eax] = pop32();
    memoryASet16(ds, 0x2231c4, r16[ax]);
    if (memoryAGet16(ds, 0x22464c) == 0x03e7)
        { pc = 0x1c1738; break; }
    if (memoryAGet16(ds, 0x224650) & 0xffff)
        { pc = 0x1c177a; break; }
  case 0x1c16ec: // 0160:1c16ec
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c170b; break; }
  case 0x1c1701: // 0160:1c1701
    memoryASet16(ds, 0x20ceaf, 0x0001);
    r32[esp] += 4; return;
  case 0x1c170b: // 0160:1c170b
    r32[esi] = 0x001ee5c0;
    r8[al] = 0xc2;
    r8[bl] = 0xc9;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee5da;
    r8[al] = 0xc3;
    r8[bl] = 0x4b;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c16ec; break; }
  case 0x1c1738: // 0160:1c1738
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c1701; break; }
    r32[esi] = 0x001ee58a;
    r8[al] = 0xc2;
    r8[bl] = 0xc9;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee5a4;
    r8[al] = 0xc3;
    r8[bl] = 0x48;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c1738; break; }
  case 0x1c177a: // 0160:1c177a
    r32[esi] = 0x00224684;
    r32[edi] = 0x0023c4e0;
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    if (memoryAGet16(ds, 0x22464c) & 0xffff)
        { pc = 0x1c17a5; break; }
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
    { pc = 0x1c1915; break; }
  case 0x1c17a5: // 0160:1c17a5
    memoryASet16(ds, 0x20ec8f, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r32[esi] += 0x00002ed4;
  case 0x1c17ba: // 0160:1c17ba
    r32[edi] = 0x00224684;
    r32[ecx] = 0x00000010;
    push32(r32[esi]);
  case 0x1c17c5: // 0160:1c17c5
    cmpsb_DSESI_ESEDI();
    if (!flags.zero)
        { pc = 0x1c17d0; break; }
    if (--r32[ecx])
        { pc = 0x1c17c5; break; }
    r32[esi] = pop32();
    { pc = 0x1c17ef; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c17d0: // 0160:1c17d0
    r32[esi] = pop32();
    r32[esi] += 0x00000010;
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + 1);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x22464c))
        { pc = 0x1c17ba; break; }
    { pc = 0x1c18d6; break; }
  case 0x1c17ef: // 0160:1c17ef
    yield* sub_1c151e();
    memoryASet16(ds, 0x20ec3d, 0x00bf);
    memoryASet16(ds, 0x20ec3f, 0x010e);
    memoryASet16(ds, 0x20e82f, 0x0001);
  case 0x1c180f: // 0160:1c180f
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (!(memoryAGet16(ds, 0x20e831) & 0xffff))
        { pc = 0x1c1837; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1c1701; break; }
    { pc = 0x1c1889; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c1837: // 0160:1c1837
    r32[esi] = 0x001ee5f0;
    r8[al] = 0xc2;
    r8[bl] = 0xc9;
    yield* sub_1b60a7();
    r32[esi] = 0x001ee60a;
    r8[al] = 0xc3;
    r8[bl] = 0x4b;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1c1567();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c180f; break; }
  case 0x1c1889: // 0160:1c1889
    yield* sub_1be986();
    yield* sub_1be9da();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x5);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[dl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    { pc = 0x1c19b0; break; }
  case 0x1c18d6: // 0160:1c18d6
    r8[dl] = 0x30;
    r8[al] = 0x30;
    r8[ah] = 0x31;
  case 0x1c18dc: // 0160:1c18dc
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[bx] = 0;
  case 0x1c18e5: // 0160:1c18e5
    if (r8[dl] != memoryAGet(ds, r32[esi] + 0x5))
        { pc = 0x1c18f0; break; }
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x6))
        { pc = 0x1c1900; break; }
  case 0x1c18f0: // 0160:1c18f0
    r16[bx]++;
    if (r16[bx] == memoryAGet16(ds, 0x22464c))
        { pc = 0x1c1915; break; }
    r32[esi] += 0x0000000c;
    { pc = 0x1c18e5; break; }
  case 0x1c1900: // 0160:1c1900
    r8[ah]++;
    if (r8[ah] != 0x3a)
        { pc = 0x1c18dc; break; }
    r8[ah] = 0x30;
    r8[al]++;
    if (r8[al] != 0x3a)
        { pc = 0x1c18dc; break; }
    r8[al] = 0x30;
    r8[dl]++;
    { pc = 0x1c18dc; break; }
  case 0x1c1915: // 0160:1c1915
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet(ds, 0x20e9d3, r8[dl]);
    memoryASet16(ds, 0x20e9d4, r16[ax]);
    memoryASet(ds, 0x20ec45, r8[dl]);
    memoryASet16(ds, 0x20ec46, r16[ax]);
    yield* sub_1c19b0();
    if (memoryAGet16(ds, 0x20ceaf) & 0xffff)
        { pc = 0x1c19af; break; }
    r32[ecx] = 0x0000000c;
    r32[esi] = 0x001ef56a;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x22464c);
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[edi] += r32[eax];
    push32(r32[edi]);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r8[al] = memoryAGet(ds, 0x20ec45);
    memoryASet(ds, r32[edi] + 0x5, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20ec46);
    memoryASet16(ds, r32[edi] + 0x6, r16[ax]);
    r32[esi] = 0x00224684;
    r32[edi] = memoryAGet32(ds, 0x20b808);
    r32[edi] += 0x00002ed4;
    r32[eax] = memoryAGet16(ds, 0x22464c);
    r32[eax] <<= 4;
    r32[edi] += r32[eax];
    r32[ecx] = 0x00000004;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    memoryASet16(ds, 0x22464c, memoryAGet16(ds, 0x22464c) + 1);
  case 0x1c19af: // 0160:1c19af
    r32[esp] += 4; return;
  case 0x1c19b0: // 0160:1c19b0
    yield* sub_1bf923();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1c19c5; break; }
    r32[esp] += 4; return;
  case 0x1c19c5: // 0160:1c19c5
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1c19ce: // 0160:1c19ce
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c1701; break; }
    yield* sub_1c1a37();
    r32[esi] = 0x001ee260;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c19ce; break; }
    return;
  }
}
function* sub_1c19b0() // 0160:1c19b0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c19b0; break; }
  case 0x1c1701: // 0160:1c1701
    memoryASet16(ds, 0x20ceaf, 0x0001);
    r32[esp] += 4; return;
    // gap 677 bytes // gap 677 bytes
  case 0x1c19b0: // 0160:1c19b0
    yield* sub_1bf923();
    if (memoryAGet16(ds, 0x20cec3) & 0xffff)
        { pc = 0x1c19c5; break; }
    r32[esp] += 4; return;
  case 0x1c19c5: // 0160:1c19c5
    memoryASet16(ds, 0x20e831, 0x0000);
  case 0x1c19ce: // 0160:1c19ce
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c1701; break; }
    yield* sub_1c1a37();
    r32[esi] = 0x001ee260;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    yield* sub_1b4941();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c19ce; break; }
    return;
  }
}
function* sub_1c1a0b() // 0160:1c1a0b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1a0b; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 46658 bytes // gap 46658 bytes
  case 0x1c1a0b: // 0160:1c1a0b
    r8[al] = 0xc2;
    r8[bl] = 0x8a;
    r8[cl] = 0x14;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x0c;
    r8[cl] = 0x10;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x8a;
    r8[cl] = 0x03;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x0a;
    r8[cl] = 0x02;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c1a37() // 0160:1c1a37 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1a37; break; }
  case 0x1b60e3: // 0160:1b60e3
    yield* sub_1b60f2();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 375 bytes // gap 375 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 46702 bytes // gap 46702 bytes
  case 0x1c1a37: // 0160:1c1a37
    r8[al] = 0xc2;
    r8[bl] = 0xc9;
    r8[cl] = 0x16;
    yield* sub_1b60e3();
    r8[al] = 0xc3;
    r8[bl] = 0x4b;
    r8[cl] = 0x12;
    yield* sub_1b60e3();
    r8[al] = 0xc4;
    r8[bl] = 0x8a;
    r8[cl] = 0x03;
    yield* sub_1b60e3();
    r8[al] = 0xc5;
    r8[bl] = 0x0a;
    r8[cl] = 0x02;
    { pc = 0x1b60e3; break; }
    return;
  }
}
function* sub_1c1a63() // 0160:1c1a63 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1a63; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 16958 bytes // gap 16958 bytes
  case 0x1c1a63: // 0160:1c1a63
    r16[ax] += 0x006b;
    if (!r16[bp])
        { pc = 0x1c1a70; break; }
    r16[ax] += 0x0002;
  case 0x1c1a70: // 0160:1c1a70
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1c1ad3; break; }
    r16[ax] += 0x0010;
    if (memoryAGet16(ds, 0x20e82f) == 0x0001)
        { pc = 0x1c1ad3; break; }
    r16[ax] += 0x0010;
    if (memoryAGet16(ds, 0x20e82f) == 0x0002)
        { pc = 0x1c1ad3; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0003)
        { pc = 0x1c1ad3; break; }
    r16[ax] -= 0x0030;
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1c1ad3; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0005)
        { pc = 0x1c1ad3; break; }
    r16[ax] += 0x0008;
    if (memoryAGet16(ds, 0x20e82f) == 0x0006)
        { pc = 0x1c1ad3; break; }
    r16[ax] -= 0x0018;
  case 0x1c1ad3: // 0160:1c1ad3
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1c1ad8() // 0160:1c1ad8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c1ad8; break; }
  case 0x1b4f0e: // 0160:1b4f0e
    r32[esi] = 0x0020c88f;
    r32[edi] = 0x0020cb8f;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = 0x0020c88f;
    r32[eax] = 0;
    r32[ecx] = 0x000000c0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    memoryASet16(ds, 0x20ce91, 0x0000);
    r32[esp] += 4; return;
    // gap 52129 bytes // gap 52129 bytes
  case 0x1c1ad8: // 0160:1c1ad8
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b54e7();
    yield* sub_1bd894();
    r32[edx] = 0x001ecb53;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1c1b47();
    memoryASet16(ds, 0x20e82f, 0x0000);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20ec3d, 0x008e);
    memoryASet16(ds, 0x20ec3f, 0x00de);
    memoryASet16(ds, 0x20e831, 0x0000);
    { pc = 0x1b4f0e; break; }
    return;
  }
}
function* sub_1c1b47() // 0160:1c1b47 +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e905, 0x0002);
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c1b76();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c1b76();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[esp] += 4;
}
function* sub_1c1b76() // 0160:1c1b76 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x001ee4b1;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee4c0;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee4d1;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee4e4;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee4f8;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee506;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee515;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee525;
    yield* sub_1b60d3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001ee532;
    yield* sub_1b60d3();
    r32[esi] = 0x001ee545;
    if (!(memoryAGet16(ds, 0x224650) & 0xffff))
        { pc = 0x1c1c0e; break; }
    r32[esi] = 0x00224684;
    r32[edi] = 0x0020ea2d;
    r32[ecx] = 0x00000010;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x0020ea29;
    memoryASet(ds, r32[esi], 0xc6);
    memoryASet(ds, r32[esi] + 0x1, 0x97);
    memoryASet(ds, r32[esi] + 0x2, 0xf0);
    memoryASet(ds, r32[esi] + 0x3, 0x10);
  case 0x1c1c0e: // 0160:1c1c0e
    yield* sub_1be816();
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c1c1d() // 0160:1c1c1d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x22466a, 0x0000);
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1c1e9b; break; }
    memoryASet16(ds, 0x20ec9d, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x22464c);
    r16[ax]--;
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20ec8f)))
        { pc = 0x1c1c58; break; }
    memoryASet16(ds, 0x20ec8f, 0x0000);
  case 0x1c1c58: // 0160:1c1c58
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    memoryASet16(ds, 0x20d7b9, r16[ax]);
    memoryASet16(ds, 0x20eca9, 0x0001);
    memoryASet32(ds, 0x224670, 0x0000304c);
    r32[eax] = 0x0023c4e0;
    memoryASet32(ds, 0x224674, r32[eax]);
    yield* sub_1c1d74();
    yield* sub_1c1f2e();
    memoryASet16(ds, 0x20ec9d, 0x0001);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c1caa; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (!r8[al])
        { pc = 0x1c1cf2; break; }
  case 0x1c1caa: // 0160:1c1caa
    r16[ax] = memoryAGet16(ds, 0x20ecab);
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + r16[ax]);
    if (memoryAGet16(ds, 0x20ec8f) & 32768)
        { pc = 0x1c1cdf; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x22464c))
        { pc = 0x1c1c58; break; }
    memoryASet16(ds, 0x20ec8f, 0x0000);
    { pc = 0x1c1c58; break; }
  case 0x1c1cdf: // 0160:1c1cdf
    r16[ax] = memoryAGet16(ds, 0x22464c);
    r16[ax]--;
    memoryASet16(ds, 0x20ec8f, r16[ax]);
    { pc = 0x1c1c58; break; }
  case 0x1c1cf2: // 0160:1c1cf2
    r32[esp] += 4; return;
    // gap 424 bytes // gap 424 bytes
  case 0x1c1e9b: // 0160:1c1e9b
    yield* sub_1b4bc9();
    yield* sub_1b589b();
    r32[edx] = 0x001ed23e;
    r32[edi] = 0x000a0000;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0;
    yield* sub_1b5442();
    r32[edi] = pop32();
    yield* sub_1b5267();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1c1eef: // 0160:1c1eef
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ef089;
    r8[al] = 0xc5;
    r8[bl] = 0x0a;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c1f22; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c1f22; break; }
    r32[esp] += 4; return;
  case 0x1c1f22: // 0160:1c1f22
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c1eef; break; }
    return;
  }
}
function* sub_1c1c26() // 0160:1c1c26 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x22464c) & 0xffff))
        { pc = 0x1c1e9b; break; }
    memoryASet16(ds, 0x20ec9d, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x22464c);
    r16[ax]--;
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20ec8f)))
        { pc = 0x1c1c58; break; }
    memoryASet16(ds, 0x20ec8f, 0x0000);
  case 0x1c1c58: // 0160:1c1c58
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    memoryASet16(ds, 0x20d7b9, r16[ax]);
    memoryASet16(ds, 0x20eca9, 0x0001);
    memoryASet32(ds, 0x224670, 0x0000304c);
    r32[eax] = 0x0023c4e0;
    memoryASet32(ds, 0x224674, r32[eax]);
    yield* sub_1c1d74();
    yield* sub_1c1f2e();
    memoryASet16(ds, 0x20ec9d, 0x0001);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c1caa; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (!r8[al])
        { pc = 0x1c1cf2; break; }
  case 0x1c1caa: // 0160:1c1caa
    r16[ax] = memoryAGet16(ds, 0x20ecab);
    memoryASet16(ds, 0x20ec8f, memoryAGet16(ds, 0x20ec8f) + r16[ax]);
    if (memoryAGet16(ds, 0x20ec8f) & 32768)
        { pc = 0x1c1cdf; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    if (r16[ax] != memoryAGet16(ds, 0x22464c))
        { pc = 0x1c1c58; break; }
    memoryASet16(ds, 0x20ec8f, 0x0000);
    { pc = 0x1c1c58; break; }
  case 0x1c1cdf: // 0160:1c1cdf
    r16[ax] = memoryAGet16(ds, 0x22464c);
    r16[ax]--;
    memoryASet16(ds, 0x20ec8f, r16[ax]);
    { pc = 0x1c1c58; break; }
  case 0x1c1cf2: // 0160:1c1cf2
    r32[esp] += 4; return;
    // gap 424 bytes // gap 424 bytes
  case 0x1c1e9b: // 0160:1c1e9b
    yield* sub_1b4bc9();
    yield* sub_1b589b();
    r32[edx] = 0x001ed23e;
    r32[edi] = 0x000a0000;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0;
    yield* sub_1b5442();
    r32[edi] = pop32();
    yield* sub_1b5267();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    yield* sub_1b4f0e();
  case 0x1c1eef: // 0160:1c1eef
    yield* sub_1b5096();
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001ef089;
    r8[al] = 0xc5;
    r8[bl] = 0x0a;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c1f22; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c1f22; break; }
    r32[esp] += 4; return;
  case 0x1c1f22: // 0160:1c1f22
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c1eef; break; }
    return;
  }
}
function* sub_1c1cf3() // 0160:1c1cf3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x22464c, 0x0000);
    r32[eax] = 0x00002f00;
    interrupt(0x21);
    memoryASet32(ds, 0x20ceef, r32[ebx]);
    r32[eax] = 0x00001a00;
    r32[edx] = 0x00224694;
    interrupt(0x21);
    r32[eax] = 0x00004e00;
    r32[ecx] = 0x00000000;
    r32[edx] = 0x001ef540;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1d66; break; }
    r32[edi] = memoryAGet32(ds, 0x20b808);
    memoryASet32(ds, 0x20ceeb, r32[edi]);
  case 0x1c1d34: // 0160:1c1d34
    memoryASet16(ds, 0x22464c, memoryAGet16(ds, 0x22464c) + 1);
    r32[esi] = 0x002246b2;
    r32[edi] = memoryAGet32(ds, 0x20ceeb);
    r32[ecx] = 0x00000003;
  case 0x1c1d4b: // 0160:1c1d4b
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c1d4b; break; }
    memoryASet32(ds, 0x20ceeb, r32[edi]);
    r32[eax] = 0x00004f00;
    interrupt(0x21);
    if (!flags.carry)
        { pc = 0x1c1d34; break; }
  case 0x1c1d66: // 0160:1c1d66
    r32[eax] = 0x00001a00;
    r32[edx] = memoryAGet32(ds, 0x20ceef);
    interrupt(0x21);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c1d74() // 0160:1c1d74 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push(ds);
    es = pop();
    r32[ecx] = 0x00000016;
    r32[esi] = 0x001ef554;
    r32[edi] = 0x0020e9c5;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = memoryAGet32(ds, 0x20b808);
    r16[ax] = memoryAGet16(ds, 0x20ec8f);
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020e9c5;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x5);
    memoryASet16(ds, r32[edi] + 0xe, r16[ax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet(ds, r32[edi] + 0x10, r8[al]);
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e16; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e16; break; }
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, 0x224670, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
  case 0x1c1e16: // 0160:1c1e16
    r32[edx] = memoryAGet32(ds, 0x224674);
    r32[ecx] = memoryAGet32(ds, 0x224670);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (memoryAGet32(ds, 0x224670) != r32[eax])
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1c1e87();
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e65; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e65; break; }
    yield* sub_1c4573();
  case 0x1c1e65: // 0160:1c1e65
    r32[esp] += 4; return;
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c1db4() // 0160:1c1db4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e16; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e16; break; }
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, 0x224670, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
  case 0x1c1e16: // 0160:1c1e16
    r32[edx] = memoryAGet32(ds, 0x224674);
    r32[ecx] = memoryAGet32(ds, 0x224670);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (memoryAGet32(ds, 0x224670) != r32[eax])
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1c1e87();
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e65; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e65; break; }
    yield* sub_1c4573();
  case 0x1c1e65: // 0160:1c1e65
    r32[esp] += 4; return;
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c1db9() // 0160:1c1db9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e16; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e16; break; }
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, 0x224670, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
  case 0x1c1e16: // 0160:1c1e16
    r32[edx] = memoryAGet32(ds, 0x224674);
    r32[ecx] = memoryAGet32(ds, 0x224670);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (memoryAGet32(ds, 0x224670) != r32[eax])
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1c1e87();
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e65; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e65; break; }
    yield* sub_1c4573();
  case 0x1c1e65: // 0160:1c1e65
    r32[esp] += 4; return;
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c1e87() // 0160:1c1e87 +long
{
    r32[esp] -= 4;
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4;
}
function* sub_1c1f2e() // 0160:1c1f2e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    memoryASet16(ds, 0x20e995, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    if (memoryAGet16(ds, 0x20ec9d) & 0xffff)
        { pc = 0x1c1f79; break; }
    memoryASet16(ds, 0x20eca3, 0x0090);
    memoryASet16(ds, 0x20eca5, 0x0148);
    memoryASet16(ds, 0x20eca7, 0x0200);
    yield* sub_1c2315();
    yield* sub_1c2205();
    { pc = 0x1c1f88; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c1f79: // 0160:1c1f79
    yield* sub_1c52c2();
    yield* sub_1c235a();
    yield* sub_1c2205();
  case 0x1c1f88: // 0160:1c1f88
    yield* sub_1c229e();
    r32[edi] = memoryAGet32(ds, 0x20ee67);
    r32[esi] = 0x0023c76c;
    r32[ecx] = 0x00000870;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    if (memoryAGet16(ds, 0x20ec9d) & 0xffff)
        { pc = 0x1c1faf; break; }
    yield* sub_1b4f0e();
  case 0x1c1faf: // 0160:1c1faf
    yield* sub_1b5096();
    if (!(memoryAGet16(ds, 0x20ed7f) & 0xffff))
        { pc = 0x1c2000; break; }
    memoryASet16(ds, 0x20ed81, memoryAGet16(ds, 0x20ed81) - 1);
    if (!memoryAGet16(ds, 0x20ed81))
        { pc = 0x1c2085; break; }
    if (memoryAGet(ds, 0x20c840) & 0xff)
        { pc = 0x1c2085; break; }
    if (memoryAGet(ds, 0x20c841) & 0xff)
        { pc = 0x1c2085; break; }
    if (memoryAGet(ds, 0x20c842) & 0xff)
        { pc = 0x1c2085; break; }
    if (memoryAGet(ds, 0x20c843) & 0xff)
        { pc = 0x1c2085; break; }
  case 0x1c2000: // 0160:1c2000
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c2037; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c2037; break; }
    if (memoryAGet16(ds, 0x23c4f6) != 0xffff)
        { pc = 0x1c202c; break; }
    if (memoryAGet16(ds, 0x22466a) & 0xffff)
        { pc = 0x1c2037; break; }
  case 0x1c202c: // 0160:1c202c
    memoryASet16(ds, 0x20ecab, 0x0000);
    { pc = 0x1c2085; break; }
  case 0x1c2037: // 0160:1c2037
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c205f; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c205f; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20ecab, 0xffff);
    { pc = 0x1c2085; break; }
  case 0x1c205f: // 0160:1c205f
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c2086; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c2086; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20ecab, 0x0001);
  case 0x1c2085: // 0160:1c2085
    r32[esp] += 4; return;
  case 0x1c2086: // 0160:1c2086
    yield* sub_1c209a();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c1faf; break; }
    return;
  }
}
function* sub_1c209a() // 0160:1c209a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00000003;
    r32[esi] = 0x0020eca3;
  case 0x1c20a4: // 0160:1c20a4
    push32(r32[ecx]);
    r32[ebp] = 0x00000004;
    memoryASet16(ds, 0x20e887, 0x0000);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0002);
    if (memoryAGet16(ds, r32[esi]) != 0xffd4)
        { pc = 0x1c20c5; break; }
    memoryASet16(ds, r32[esi], 0x0200);
  case 0x1c20c5: // 0160:1c20c5
    r32[esi] += 0x00000002;
  case 0x1c20c8: // 0160:1c20c8
    r16[bx] = 0x00b4;
    r16[cx] = memoryAGet16(ds, 0x20e887);
    r16[dx] = 0x0005;
    if (r16s[ax] <= signed16(0x0068))
        { pc = 0x1c20f2; break; }
    if (r16[ax] >= 0x01c0)
        { pc = 0x1c20f2; break; }
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    yield* sub_1bd7dd();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1c20f2: // 0160:1c20f2
    r16[ax] += 0x0018;
    memoryASet16(ds, 0x20e887, memoryAGet16(ds, 0x20e887) + 1);
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1c20c8; break; }
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c20a4; break; }
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x001c;
    r16[ax] >>>= 1;
    r32[esi] = 0x001ef464;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] += 0x008c;
    r16[bx] = 0x00fa;
    r16[cx] = 0x0004;
    r16[dx] = 0x0001;
    yield* sub_1bd7dd();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] += 0x0010;
    r16[ax] &= 0x001c;
    r16[ax] >>>= 1;
    r32[esi] = 0x001ef464;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] += 0x01a4;
    r16[bx] = 0x00fa;
    r16[cx] = 0x0004;
    r16[dx] = 0;
    yield* sub_1bd7dd();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1c2181; break; }
    memoryASet16(ds, 0x224664, memoryAGet16(ds, 0x224664) + 1);
    memoryASet16(ds, 0x224664, memoryAGet16(ds, 0x224664) & 0x001f);
  case 0x1c2181: // 0160:1c2181
    r16[dx] = 0;
    r16[ax] = memoryAGet16(ds, 0x224664);
    r16[bp] = r16[ax];
    if (r16[ax] < 0x0009)
        { pc = 0x1c21d6; break; }
    if (r16[ax] > 0x0010)
        { pc = 0x1c21b1; break; }
    r16[bp] = 0x0010;
    r16[bp] -= r16[ax];
    r16[dx] = 0x0002;
    { pc = 0x1c21d6; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c21b1: // 0160:1c21b1
    if (r16[ax] > 0x0018)
        { pc = 0x1c21cb; break; }
    r16[ax] -= 0x0010;
    r16[bp] = r16[ax];
    r16[dx] = 0x0003;
    { pc = 0x1c21d6; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c21cb: // 0160:1c21cb
    r16[bp] = 0x0020;
    r16[bp] -= r16[ax];
    r16[dx] = 0x0001;
  case 0x1c21d6: // 0160:1c21d6
    r16[ax] = 0x00a4;
    r16[bx] = 0x013c;
    r16[cx] = 0x0005;
    r16[cx] += r16[bp];
    yield* sub_1bd7dd();
    r16[ax] = memoryAGet16(ds, 0x23c4f6);
    if (r16[ax] != 0xffff)
        { pc = 0x1c2204; break; }
    r32[esi] = 0x001ed268;
    r8[al] = 0xc2;
    r8[bl] = 0x93;
    yield* sub_1b60a7();
  case 0x1c2204: // 0160:1c2204
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c2205() // 0160:1c2205 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x23c4f9);
    r32[eax] &= 0x000000ff;
    r32[esi] = 0x001f1476;
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r32[edi] = 0x0020cb4a;
    yield* sub_1c2296();
    r32[edi] = 0x0020cb50;
    yield* sub_1c2296();
    r32[edi] = 0x0020cb56;
    r32[ecx] = 0x00000006;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r8[al] = memoryAGet(ds, 0x23c4f8);
    r32[eax] &= 0x000000ff;
    r32[esi] = 0x001f13fe;
    r16[cx] = 0x000c;
    mul16(r16[cx]);
    r32[esi] += r32[eax];
    r32[edi] = 0x0020cb35;
    yield* sub_1c2296();
    r32[edi] = 0x0020cb41;
    yield* sub_1c2296();
    r32[edi] = 0x0020cb47;
    yield* sub_1c2296();
    r32[edi] = 0x0020cb4d;
    yield* sub_1c2296();
    if (!(memoryAGet16(ds, 0x20ec9d) & 0xffff))
        { pc = 0x1c2295; break; }
    memoryASet16(ds, 0x224666, 0x0090);
  case 0x1c2295: // 0160:1c2295
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c2296() // 0160:1c2296 +long
{
    r32[esp] -= 4;
    r32[ecx] = 0x00000003;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esp] += 4;
}
function* sub_1c229e() // 0160:1c229e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c22b5();
    memoryASet16(ds, 0x2231c4, 0x0000);
    r32[eax] = 0x000000a8;
    r32[ebp] = 0x00000271;
    r32[esi] = 0x0023c4fb;
  case 0x1c22c4: // 0160:1c22c4
    r32[ebx] = 0x000000ec;
    r32[edi] = 0x00000019;
  case 0x1c22ce: // 0160:1c22ce
    r32[ecx] = 0x00000014;
    r8[dl] = memoryAGet(ds, r32[esi]);
    r32[edx] &= 0x000000ff;
    r32[ecx] += r32[edx];
    r32[edx] = 0x00000004;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi]++;
    r32[ebp]--;
    if (!r32[ebp])
        { pc = 0x1c2305; break; }
    r32[ebx] += 0x00000003;
    r32[edi]--;
    if (r32[edi])
        { pc = 0x1c22ce; break; }
    yield* sub_1c2305();
    r32[eax] += 0x00000003;
    { pc = 0x1c22c4; break; }
  case 0x1c2305: // 0160:1c2305
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1b5126();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c22b5() // 0160:1c22b5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0x000000a8;
    r32[ebp] = 0x00000271;
    r32[esi] = 0x0023c4fb;
  case 0x1c22c4: // 0160:1c22c4
    r32[ebx] = 0x000000ec;
    r32[edi] = 0x00000019;
  case 0x1c22ce: // 0160:1c22ce
    r32[ecx] = 0x00000014;
    r8[dl] = memoryAGet(ds, r32[esi]);
    r32[edx] &= 0x000000ff;
    r32[ecx] += r32[edx];
    r32[edx] = 0x00000004;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi]++;
    r32[ebp]--;
    if (!r32[ebp])
        { pc = 0x1c2305; break; }
    r32[ebx] += 0x00000003;
    r32[edi]--;
    if (r32[edi])
        { pc = 0x1c22ce; break; }
    yield* sub_1c2305();
    r32[eax] += 0x00000003;
    { pc = 0x1c22c4; break; }
  case 0x1c2305: // 0160:1c2305
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1b5126();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2305() // 0160:1c2305 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    push32(r32[esi]);
    push32(r32[edi]);
    yield* sub_1b5126();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c2315() // 0160:1c2315 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b589b();
    r32[edx] = 0x001ed23e;
    r32[edi] = 0x000a0000;
    push32(r32[edi]);
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0;
    yield* sub_1b5442();
    r32[edi] = pop32();
    yield* sub_1b5267();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c2388();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c2388();
    r16[ax] = 0x0001;
    yield* sub_1c24a8();
    r16[ax] = 0x0002;
    { pc = 0x1c24a8; break; }
    // gap 288 bytes // gap 288 bytes
  case 0x1c24a8: // 0160:1c24a8
    r32[esi] = 0x0023e92c;
    r16[bx] = 0x0078;
    r16[cx] = 0x007a;
    r16[dx] = 0x0030;
    r16[bp] = 0x003e;
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[edi] = 0x000a0000;
    if (r16s[ax] <= signed16(0x0001))
        { pc = 0x1c24ea; break; }
    r32[edi] = 0x000a4800;
    if (r16[ax] == 0x0002)
        { pc = 0x1c24ea; break; }
    r32[edi] = 0x000a9000;
  case 0x1c24ea: // 0160:1c24ea
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c253c: // 0160:1c253c
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c2553: // 0160:1c2553
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c255a: // 0160:1c255a
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c2565; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2565: // 0160:1c2565
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c255a; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c2553; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c2592; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c253c; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c253c; break; }
  case 0x1c2592: // 0160:1c2592
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c235a() // 0160:1c235a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c2388();
    memoryASet16(ds, 0x2231c4, 0x0000);
    yield* sub_1c2388();
    r16[ax] = 0x0001;
    yield* sub_1c24a8();
    r16[ax] = 0x0002;
    { pc = 0x1c24a8; break; }
    // gap 288 bytes // gap 288 bytes
  case 0x1c24a8: // 0160:1c24a8
    r32[esi] = 0x0023e92c;
    r16[bx] = 0x0078;
    r16[cx] = 0x007a;
    r16[dx] = 0x0030;
    r16[bp] = 0x003e;
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[edi] = 0x000a0000;
    if (r16s[ax] <= signed16(0x0001))
        { pc = 0x1c24ea; break; }
    r32[edi] = 0x000a4800;
    if (r16[ax] == 0x0002)
        { pc = 0x1c24ea; break; }
    r32[edi] = 0x000a9000;
  case 0x1c24ea: // 0160:1c24ea
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c253c: // 0160:1c253c
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c2553: // 0160:1c2553
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c255a: // 0160:1c255a
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c2565; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2565: // 0160:1c2565
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c255a; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c2553; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c2592; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c253c; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c253c; break; }
  case 0x1c2592: // 0160:1c2592
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2388() // 0160:1c2388 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c2388; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 49087 bytes // gap 49087 bytes
  case 0x1c2388: // 0160:1c2388
    yield* sub_1b85c3();
    memoryASet16(ds, 0x20e905, 0x0000);
    r32[esi] = 0x001ef044;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef04e;
    yield* sub_1b60d3();
    r32[esi] = 0x001ef058;
    yield* sub_1b60d3();
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi], 0xc2);
    memoryASet(ds, r32[esi] + 0x1, 0x4c);
    r32[esi] += 0x00000004;
    r8[bl] = 0;
    r8[cl] = 0x02;
    r16[ax] = memoryAGet16(ds, 0x23c4f1);
    r16[ax] >>>= 1;
    r16[ax] -= 0x0038;
  case 0x1c23d4: // 0160:1c23d4
    if (r16[ax] < 0x0064)
        { pc = 0x1c23e2; break; }
    r16[ax] -= 0x0064;
    r8[bl]++;
    { pc = 0x1c23d4; break; }
  case 0x1c23e2: // 0160:1c23e2
    if (r8[bl])
        { pc = 0x1c23ee; break; }
    memoryASet(ds, 0x20e9c6, memoryAGet(ds, 0x20e9c6) + 1);
    { pc = 0x1c23f8; break; }
  case 0x1c23ee: // 0160:1c23ee
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    r8[cl]++;
    r8[bl] = 0;
  case 0x1c23f8: // 0160:1c23f8
    if (r16[ax] < 0x000a)
        { pc = 0x1c2406; break; }
    r16[ax] -= 0x000a;
    r8[bl]++;
    { pc = 0x1c23f8; break; }
  case 0x1c2406: // 0160:1c2406
    r8[bl] += 0x30;
    memoryASet(ds, r32[esi], r8[bl]);
    r8[al] += 0x30;
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi] + 0x3, r8[cl]);
    yield* sub_1b60d3();
    r8[al] = 0xc2;
    r8[bl] = 0x8e;
    r8[cl] = memoryAGet(ds, 0x23c4f3);
    yield* sub_1c2465();
    r8[al] = 0xc2;
    r8[bl] = 0xce;
    r8[cl] = memoryAGet(ds, 0x23c4f4);
    yield* sub_1c2465();
    r8[al] = memoryAGet(ds, 0x23c4f0);
    r32[esi] = 0x001ef07f;
    if (!r8[al])
        { pc = 0x1c2460; break; }
    r32[esi] = 0x001ef061;
    if (r8[al] == 0x01)
        { pc = 0x1c2460; break; }
    r32[esi] = 0x001ef06b;
    if (r8[al] == 0x02)
        { pc = 0x1c2460; break; }
    r32[esi] = 0x001ef075;
  case 0x1c2460: // 0160:1c2460
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c2465() // 0160:1c2465 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c2465; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 49308 bytes // gap 49308 bytes
  case 0x1c2465: // 0160:1c2465
    r32[esi] = 0x0020e9c5;
    memoryASet(ds, r32[esi], r8[al]);
    memoryASet(ds, r32[esi] + 0x1, r8[bl]);
    memoryASet(ds, r32[esi] + 0x3, 0x01);
    r8[cl] += 0x30;
    memoryASet(ds, r32[esi] + 0x4, r8[cl]);
    yield* sub_1b60d3();
    if (!(memoryAGet16(ds, 0x23e92c) & 0xffff))
        { pc = 0x1c24a7; break; }
    r32[esi] = 0x0023f4cc;
    yield* sub_1b60d3();
    r32[esi] = 0x0023f4ea;
    yield* sub_1b60d3();
    r32[esi] = 0x0023f508;
    { pc = 0x1b60d3; break; }
  case 0x1c24a7: // 0160:1c24a7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c24a8() // 0160:1c24a8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0023e92c;
    r16[bx] = 0x0078;
    r16[cx] = 0x007a;
    r16[dx] = 0x0030;
    r16[bp] = 0x003e;
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[edi] = 0x000a0000;
    if (r16s[ax] <= signed16(0x0001))
        { pc = 0x1c24ea; break; }
    r32[edi] = 0x000a4800;
    if (r16[ax] == 0x0002)
        { pc = 0x1c24ea; break; }
    r32[edi] = 0x000a9000;
  case 0x1c24ea: // 0160:1c24ea
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c253c: // 0160:1c253c
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c2553: // 0160:1c2553
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c255a: // 0160:1c255a
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c2565; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2565: // 0160:1c2565
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c255a; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c2553; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c2592; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c253c; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c253c; break; }
  case 0x1c2592: // 0160:1c2592
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2599() // 0160:1c2599 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0023c76c;
    r32[ecx] = 0x00000090;
  case 0x1c25a3: // 0160:1c25a3
    r32[eax] = memoryAGet32(ds, r32[esi]);
    if (r32[eax])
        { pc = 0x1c25b0; break; }
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c25a3; break; }
    { pc = 0x1c25d3; break; }
  case 0x1c25b0: // 0160:1c25b0
    yield* sub_1c33a1();
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    if (r16[ax])
        { pc = 0x1c25d3; break; }
    r32[esi] = 0x0023c76c;
    r32[edi] = 0x00232cd8;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    { pc = 0x1c25d8; break; }
  case 0x1c25d3: // 0160:1c25d3
    yield* sub_1c312e();
  case 0x1c25d8: // 0160:1c25d8
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001f0bf0;
    yield* sub_1b5a2d();
    r32[esi] = 0x00232cd8;
    r32[edi] = 0x00224cd4;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001f033c;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ceaf, 0x0000);
    memoryASet16(ds, 0x20cead, 0x0000);
    yield* sub_1b4f0e();
    yield* sub_1c30b4();
  case 0x1c2673: // 0160:1c2673
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1bb00d();
    if (!(memoryAGet16(ds, 0x22465a) & 0xffff))
        { pc = 0x1c2694; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1c2694: // 0160:1c2694
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    r16[ax] += 0x0002;
    r16[bx] += 0x0002;
    memoryASet16(ds, 0x20ec3d, r16[ax]);
    memoryASet16(ds, 0x20ec3f, r16[bx]);
    yield* sub_1c2d80();
    yield* sub_1c2aaf();
    r16[ax] = 0x0138;
    r16[bx] = 0x0108;
    r16[cx] = 0x0001;
    r16[dx] = 0x0000;
    yield* sub_1bd7dd();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 3;
    r32[esi] = 0x002050bc;
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x6);
    r16[cx] = 0x015c;
    r16[cx] += memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[bx] = 0x0104;
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    r16[ax] = r16[cx];
    r16[cx] = 0x0002;
    yield* sub_1bd7dd();
    yield* sub_1c2df3();
    r16[ax] = memoryAGet16(ds, 0x20eeb0);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1c272c; break; }
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20ceaf, r16[ax]);
  case 0x1c272c: // 0160:1c272c
    r32[esi] = 0x001f0364;
    r8[al] = 0xc2;
    r8[bl] = 0xc9;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c27c7; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] < signed16(0x009c))
        { pc = 0x1c2781; break; }
    if (r16s[ax] > signed16(0x00a4))
        { pc = 0x1c2781; break; }
    if (r16s[bx] < signed16(0x007b))
        { pc = 0x1c2781; break; }
    if (r16s[bx] > signed16(0x00c2))
        { pc = 0x1c2781; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] -= 0x007b;
    r16[ax] >>>= 3;
    memoryASet16(ds, 0x20cead, r16[ax]);
  case 0x1c2781: // 0160:1c2781
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] <= signed16(0x00b4))
        { pc = 0x1c27a8; break; }
    if (r16s[ax] > signed16(0x00d0))
        { pc = 0x1c27a8; break; }
    if (r16s[bx] <= signed16(0x00bc))
        { pc = 0x1c27a8; break; }
    if (r16s[bx] <= signed16(0x00c8))
        { pc = 0x1c27e2; break; }
  case 0x1c27a8: // 0160:1c27a8
    if (r16s[ax] <= signed16(0x00dc))
        { pc = 0x1c27c7; break; }
    if (r16s[ax] > signed16(0x00f8))
        { pc = 0x1c27c7; break; }
    if (r16s[bx] <= signed16(0x00bc))
        { pc = 0x1c27c7; break; }
    if (r16s[bx] > signed16(0x00c8))
        { pc = 0x1c27c7; break; }
    { pc = 0x1c2aae; break; }
  case 0x1c27c7: // 0160:1c27c7
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c27e1; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c2673; break; }
  case 0x1c27e1: // 0160:1c27e1
    r32[esp] += 4; return;
  case 0x1c27e2: // 0160:1c27e2
    r32[esi] = 0x00224cd4;
    r32[edi] = 0x0023c76c;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, 0x0001);
    r32[edi] = 0x0023c9ac;
    r32[ecx] = 0x00000008;
  case 0x1c2806: // 0160:1c2806
    push32(r32[ecx]);
    push32(r32[edi]);
    yield* sub_1c2df3();
    r32[esi] = 0x00224f14;
    r32[edi] = pop32();
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, memoryAGet16(ds, 0x20ceaf) + 1);
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c2806; break; }
    memoryASet16(ds, 0x20ceaf, 0x0004);
    yield* sub_1c2df3();
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0023dbac;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, 0x0008);
    yield* sub_1c2df3();
    r16[ax] = 0x0008;
    yield* sub_1c29ab();
    r16[ax] = 0x0010;
    yield* sub_1c29ab();
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0023ddec;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, 0x0004);
    yield* sub_1c2df3();
    yield* sub_1c2984();
    r32[ecx] = 0x00000004;
    r16[ax] = 0x0003;
  case 0x1c2890: // 0160:1c2890
    yield* sub_1c29ab();
    r16[ax] += 0x0006;
    if (--r32[ecx])
        { pc = 0x1c2890; break; }
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0023e02c;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, 0x0000);
    yield* sub_1c2df3();
    yield* sub_1c2984();
    r32[ecx] = 0x00000006;
    r16[ax] = 0x0002;
  case 0x1c28c8: // 0160:1c28c8
    yield* sub_1c29ab();
    r16[ax] += 0x0004;
    if (--r32[ecx])
        { pc = 0x1c28c8; break; }
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0023e26c;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, 0x0004);
    yield* sub_1c2df3();
    yield* sub_1c2984();
    yield* sub_1c295a();
    r32[ecx] = 0x00000008;
    r16[ax] = 0x0001;
  case 0x1c2905: // 0160:1c2905
    yield* sub_1c29ab();
    r16[ax] += 0x0003;
    if (--r32[ecx])
        { pc = 0x1c2905; break; }
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0023e4ac;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet16(ds, 0x20ceaf, 0x0008);
    yield* sub_1c2df3();
    yield* sub_1c295a();
    r32[ecx] = 0x0000000c;
    r16[ax] = 0x0001;
  case 0x1c293d: // 0160:1c293d
    yield* sub_1c29ab();
    r16[ax] += 0x0002;
    if (--r32[ecx])
        { pc = 0x1c293d; break; }
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0023e6ec;
    r32[ecx] = 0x00000240;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esp] += 4; return;
    // gap 340 bytes // gap 340 bytes
  case 0x1c2aae: // 0160:1c2aae
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c295a() // 0160:1c295a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00224f14;
    r32[edi] = 0x00224f2b;
    r32[edx] = 0x00000018;
  case 0x1c2969: // 0160:1c2969
    r32[ecx] = 0x0000000c;
  case 0x1c296e: // 0160:1c296e
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[bl] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    r32[edi]--;
    if (--r32[ecx])
        { pc = 0x1c296e; break; }
    r32[esi] += 0x0000000c;
    r32[edi] += 0x00000024;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c2969; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2984() // 0160:1c2984 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0022513c;
    r32[edx] = 0x0000000c;
  case 0x1c2993: // 0160:1c2993
    r32[ecx] = 0x00000018;
  case 0x1c2998: // 0160:1c2998
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[bl] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c2998; break; }
    r32[edi] -= 0x00000030;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c2993; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c29ab() // 0160:1c29ab +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[eax]);
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x00224f14;
    r16[ax] <<= 3;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[ebx] = r32[eax];
    r32[edi] += r32[eax];
    r32[eax] = pop32();
    push32(r32[eax]);
    r32[esi] = r32[edi];
    r32[esi] -= 0x00000018;
    if (r16s[ax] < signed16(0x000c))
        { pc = 0x1c29fd; break; }
    r32[esi] += 0x00000030;
    r32[ecx] = 0x00000240;
    r32[ecx] -= r32[ebx];
    if (!r32[ecx])
        { pc = 0x1c29eb; break; }
  case 0x1c29e3: // 0160:1c29e3
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c29e3; break; }
  case 0x1c29eb: // 0160:1c29eb
    r32[esi] = 0x0022513c;
    r32[ecx] = 0x00000018;
  case 0x1c29f5: // 0160:1c29f5
    memoryASet(ds, r32[esi], 0x00);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c29f5; break; }
    { pc = 0x1c2a1d; break; }
  case 0x1c29fd: // 0160:1c29fd
    r32[esi] += 0x00000017;
    r32[edi] += 0x00000017;
    r32[ecx] = r32[ebx];
  case 0x1c2a05: // 0160:1c2a05
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]--;
    r32[edi]--;
    if (--r32[ecx])
        { pc = 0x1c2a05; break; }
    r32[esi] = 0x00224f14;
    r32[ecx] = 0x00000018;
  case 0x1c2a17: // 0160:1c2a17
    memoryASet(ds, r32[esi], 0x00);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c2a17; break; }
  case 0x1c2a1d: // 0160:1c2a1d
    r32[eax] = pop32();
    push32(r32[eax]);
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x00224f14;
    r32[ebx] = r32[eax];
    r32[edi] += r32[eax];
    r32[esi] = r32[edi];
    r32[esi]--;
    if (r16s[ax] < signed16(0x000c))
        { pc = 0x1c2a78; break; }
    r32[esi] += 0x00000002;
    r32[ecx] = 0x00000018;
    r32[ecx] -= r32[ebx];
    if (!r32[ecx])
        { pc = 0x1c2a64; break; }
  case 0x1c2a44: // 0160:1c2a44
    r32[ebx] = 0x00000018;
  case 0x1c2a49: // 0160:1c2a49
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000018;
    r32[edi] += 0x00000018;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c2a49; break; }
    r32[esi] -= 0x0000023f;
    r32[edi] -= 0x0000023f;
    if (--r32[ecx])
        { pc = 0x1c2a44; break; }
  case 0x1c2a64: // 0160:1c2a64
    r32[esi] = 0x00224f2b;
    r32[ecx] = 0x00000018;
  case 0x1c2a6e: // 0160:1c2a6e
    memoryASet(ds, r32[esi], 0x00);
    r32[esi] += 0x00000018;
    if (--r32[ecx])
        { pc = 0x1c2a6e; break; }
    { pc = 0x1c2aac; break; }
  case 0x1c2a78: // 0160:1c2a78
    r32[ecx] = r32[ebx];
  case 0x1c2a7a: // 0160:1c2a7a
    r32[ebx] = 0x00000018;
  case 0x1c2a7f: // 0160:1c2a7f
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000018;
    r32[edi] += 0x00000018;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c2a7f; break; }
    r32[esi] -= 0x00000241;
    r32[edi] -= 0x00000241;
    if (--r32[ecx])
        { pc = 0x1c2a7a; break; }
    r32[esi] = 0x00224f14;
    r32[ecx] = 0x00000018;
  case 0x1c2aa4: // 0160:1c2aa4
    memoryASet(ds, r32[esi], 0x00);
    r32[esi] += 0x00000018;
    if (--r32[ecx])
        { pc = 0x1c2aa4; break; }
  case 0x1c2aac: // 0160:1c2aac
    r32[eax] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2aaf() // 0160:1c2aaf +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] &= 0xfffc;
    r16[bx] &= 0xfffc;
    r16[ax] += 0x007c;
    r16[bx] += 0x007c;
    if (r16s[ax] <= signed16(0x00bc))
        { pc = 0x1c2c56; break; }
    if (r16s[ax] >= signed16(0x010c))
        { pc = 0x1c2c56; break; }
    if (r16s[bx] <= signed16(0x00ec))
        { pc = 0x1c2c56; break; }
    if (r16s[bx] >= signed16(0x0148))
        { pc = 0x1c2c56; break; }
    r16[cx] = memoryAGet16(ds, 0x20cead);
    r16[cx] += 0x0003;
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1bd7dd();
    r32[eax] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r8[dl] = memoryAGet(ds, 0x20c840);
    r8[dl] &= 0x80;
    if (!r8[dl])
        { pc = 0x1c2b8b; break; }
    r16[bx] -= 0x0080;
    r16[cx] -= 0x0080;
    yield* sub_1c2c57();
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] &= 0xfffc;
    r16[bx] &= 0xfffc;
    r16[ax] -= 0x0040;
    r16[bx] -= 0x0070;
    r16[ax] >>>= 2;
    r16[bx] >>>= 2;
    r16[ax] += 0x0002;
    r32[esi] = 0x00224cd4;
    r32[eax] &= 0x0000ffff;
    r32[ebx] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[bx] <<= 3;
    r16[ax] = r16[bx];
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    r32[esi] += r32[eax];
    r32[edi] = 0x001f0c78;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cead);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    memoryASet(ds, r32[esi], r8[al]);
  case 0x1c2b8b: // 0160:1c2b8b
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] &= 0xfffc;
    r16[bx] &= 0xfffc;
    r16[ax] += 0x007c;
    r16[bx] += 0x007c;
    r16[cx] = 0x00e4;
    r16[cx] -= r16[ax];
    r16[cx] += 0x00e4;
    r16[ax] = r16[cx];
    r16[cx] = memoryAGet16(ds, 0x20cead);
    r16[cx] += 0x0003;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r16[dx] = 0;
    yield* sub_1bd7dd();
    r32[eax] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r8[dl] = memoryAGet(ds, 0x20c840);
    r8[dl] &= 0x80;
    if (!r8[dl])
        { pc = 0x1c2c56; break; }
    r16[bx] -= 0x0080;
    r16[cx] -= 0x0080;
    yield* sub_1c2c57();
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] &= 0xfffc;
    r16[bx] &= 0xfffc;
    r16[cx] = 0x0068;
    r16[cx] -= r16[ax];
    r16[cx] += 0x0068;
    r16[ax] = r16[cx];
    r16[ax] -= 0x0040;
    r16[bx] -= 0x0070;
    r16[ax] >>>= 2;
    r16[bx] >>>= 2;
    r16[ax] += 0x0002;
    r32[esi] = 0x00224cd4;
    r32[eax] &= 0x0000ffff;
    r32[ebx] &= 0x0000ffff;
    r32[esi] += r32[eax];
    r16[bx] <<= 3;
    r16[ax] = r16[bx];
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    r32[esi] += r32[eax];
    r32[edi] = 0x001f0c78;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cead);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    memoryASet(ds, r32[esi], r8[al]);
  case 0x1c2c56: // 0160:1c2c56
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c2c57() // 0160:1c2c57 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[edi] = 0x000a9000;
    yield* sub_1c2c7c();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[edi] = 0x000a4800;
    yield* sub_1c2c7c();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[edi] = 0x000a0000;
    push32(r32[edi]);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r32[edi] = pop32();
    r16[ax] = 0x0002;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = 0x0008;
    memoryASet16(ds, 0x224636, r16[ax]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c2d05: // 0160:1c2d05
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    push32(r32[edx]);
    r8[al] = 0x04;
    r8[ah] >>>= 1;
    if (r8[ah] != 0x04)
        { pc = 0x1c2d16; break; }
    r8[ah] = 0x03;
  case 0x1c2d16: // 0160:1c2d16
    r16[dx] = 0x03ce;
    out16(r16[dx], r16[ax]);
    r32[edx] = pop32();
    r32[eax] = pop32();
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c2d31: // 0160:1c2d31
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c2d38: // 0160:1c2d38
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c2d4c; break; }
    if (memoryAGet(ds, r32[edi]) == 0x05)
        { pc = 0x1c2d4c; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2d4c: // 0160:1c2d4c
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c2d38; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c2d31; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c2d79; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c2d05; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c2d05; break; }
  case 0x1c2d79: // 0160:1c2d79
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2c7c() // 0160:1c2c7c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edi]);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r32[edi] = pop32();
    r16[ax] = 0x0002;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = 0x0008;
    memoryASet16(ds, 0x224636, r16[ax]);
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c2d05: // 0160:1c2d05
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    push32(r32[edx]);
    r8[al] = 0x04;
    r8[ah] >>>= 1;
    if (r8[ah] != 0x04)
        { pc = 0x1c2d16; break; }
    r8[ah] = 0x03;
  case 0x1c2d16: // 0160:1c2d16
    r16[dx] = 0x03ce;
    out16(r16[dx], r16[ax]);
    r32[edx] = pop32();
    r32[eax] = pop32();
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c2d31: // 0160:1c2d31
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c2d38: // 0160:1c2d38
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c2d4c; break; }
    if (memoryAGet(ds, r32[edi]) == 0x05)
        { pc = 0x1c2d4c; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2d4c: // 0160:1c2d4c
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c2d38; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c2d31; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c2d79; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c2d05; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c2d05; break; }
  case 0x1c2d79: // 0160:1c2d79
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2d80() // 0160:1c2d80 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c2d80; break; }
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 21851 bytes // gap 21851 bytes
  case 0x1c2d80: // 0160:1c2d80
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c2d91; break; }
    memoryASet16(ds, 0x224656, memoryAGet16(ds, 0x224656) - 0x0002);
  case 0x1c2d91: // 0160:1c2d91
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c2da2; break; }
    memoryASet16(ds, 0x224656, memoryAGet16(ds, 0x224656) + 0x0002);
  case 0x1c2da2: // 0160:1c2da2
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1c2db3; break; }
    memoryASet16(ds, 0x224658, memoryAGet16(ds, 0x224658) - 0x0002);
  case 0x1c2db3: // 0160:1c2db3
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1c2dc4; break; }
    memoryASet16(ds, 0x224658, memoryAGet16(ds, 0x224658) + 0x0002);
  case 0x1c2dc4: // 0160:1c2dc4
    yield* sub_1bafe1();
    r16[cx] = 0x0000;
    yield* sub_1bafc3();
    r16[ax] = 0x011a;
    r16[bx] = memoryAGet16(ds, 0x20cead);
    r16[bx] <<= 3;
    r16[bx] += 0x00f8;
    r16[cx] = 0x000c;
    r16[dx] = 0x0000;
    { pc = 0x1bd7dd; break; }
    return;
  }
}
function* sub_1c2df3() // 0160:1c2df3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = 0x00224f14;
    r32[ecx] = 0x00000090;
    r32[eax] = 0;
  case 0x1c2dff: // 0160:1c2dff
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c2dff; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 3;
    r32[esi] = 0x002050bc;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    if (!r16[ax])
        { pc = 0x1c2ea9; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1c2e9f; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1c2e95; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1c2e8b; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1c2e81; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1c2e72; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1c2e63; break; }
    if (r16[ax] == 0x0007)
        { pc = 0x1c2e54; break; }
    if (r16[ax] == 0x0008)
        { pc = 0x1c2ec7; break; }
  case 0x1c2e54: // 0160:1c2e54
    r32[edx] = 0x001f03cc;
    yield* sub_1c2f5a();
    { pc = 0x1c2ef0; break; }
  case 0x1c2e63: // 0160:1c2e63
    r32[edx] = 0x001f05f2;
    yield* sub_1c2f5a();
    { pc = 0x1c2ef0; break; }
  case 0x1c2e72: // 0160:1c2e72
    r32[edx] = 0x001f07fe;
    yield* sub_1c2f5a();
    { pc = 0x1c2ef0; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c2e81: // 0160:1c2e81
    r32[edx] = 0x001f09f6;
    { pc = 0x1c2f5a; break; }
  case 0x1c2e8b: // 0160:1c2e8b
    r32[edx] = 0x001f07fe;
    { pc = 0x1c2f5a; break; }
  case 0x1c2e95: // 0160:1c2e95
    r32[edx] = 0x001f05f2;
    { pc = 0x1c2f5a; break; }
  case 0x1c2e9f: // 0160:1c2e9f
    r32[edx] = 0x001f03cc;
    { pc = 0x1c2f5a; break; }
  case 0x1c2ea9: // 0160:1c2ea9
    r32[esi] = 0x00224cd4;
    r32[edi] = 0x00224f14;
    r32[ecx] = 0x00000090;
    r32[eax] = 0;
  case 0x1c2eba: // 0160:1c2eba
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c2eba; break; }
    r32[esp] += 4; return;
  case 0x1c2ec7: // 0160:1c2ec7
    r32[esi] = 0x00224cd4;
    r32[edi] = 0x00224f2b;
    r32[ecx] = 0x00000018;
  case 0x1c2ed6: // 0160:1c2ed6
    push32(r32[ecx]);
    r32[ecx] = 0x00000018;
  case 0x1c2edc: // 0160:1c2edc
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi] += 0x00000018;
    if (--r32[ecx])
        { pc = 0x1c2edc; break; }
    r32[ecx] = pop32();
    r32[edi] -= 0x00000241;
    if (--r32[ecx])
        { pc = 0x1c2ed6; break; }
    r32[esp] += 4; return;
  case 0x1c2ef0: // 0160:1c2ef0
    r32[esi] = 0x00224f14;
    r32[edi] = 0x00232cd8;
    r32[ecx] = 0x00000090;
  case 0x1c2eff: // 0160:1c2eff
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c2eff; break; }
    r32[esi] = 0x00232cd8;
    r32[edi] = 0x00224f2b;
    r32[ecx] = 0x00000018;
  case 0x1c2f1a: // 0160:1c2f1a
    push32(r32[ecx]);
    r32[ecx] = 0x00000018;
  case 0x1c2f20: // 0160:1c2f20
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi] += 0x00000018;
    if (--r32[ecx])
        { pc = 0x1c2f20; break; }
    r32[ecx] = pop32();
    r32[edi] -= 0x00000241;
    if (--r32[ecx])
        { pc = 0x1c2f1a; break; }
    r32[esi] = 0x00224f14;
    r32[edi] = 0x0022513c;
    r32[edx] = 0x0000000c;
  case 0x1c2f42: // 0160:1c2f42
    r32[ecx] = 0x00000018;
  case 0x1c2f47: // 0160:1c2f47
    r8[al] = memoryAGet(ds, r32[edi]);
    r8[bl] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[bl]);
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c2f47; break; }
    r32[edi] -= 0x00000030;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c2f42; break; }
    r32[esp] += 4; return;
  case 0x1c2f5a: // 0160:1c2f5a
    memoryASet32(ds, 0x20cecf, r32[edx]);
    r32[esi] = 0x00224cd4;
    r32[ecx] = 0x0000000c;
  case 0x1c2f6a: // 0160:1c2f6a
    push32(r32[ecx]);
    r32[ecx] = 0x0000000c;
  case 0x1c2f70: // 0160:1c2f70
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c2fa7; break; }
    r32[edi] = 0x00224f14;
    r32[eax] &= 0x000000ff;
    r32[edi] += r32[eax];
    r32[edx]++;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] += r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c2fa4; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2fa4: // 0160:1c2fa4
    r32[edx]++;
    { pc = 0x1c2f70; break; }
  case 0x1c2fa7: // 0160:1c2fa7
    r32[esi]++;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c2f70; break; }
    r32[esi] += 0x0000000c;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c2f6a; break; }
    r32[edx] = memoryAGet32(ds, 0x20cecf);
    r32[esi] = 0x00224ceb;
    r32[ecx] = 0x0000000c;
  case 0x1c2fc1: // 0160:1c2fc1
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x0000000c;
  case 0x1c2fc8: // 0160:1c2fc8
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c2ffc; break; }
    r32[edi] = 0x00224f2b;
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] += r32[eax];
    r32[eax] = 0;
    r32[edx]++;
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[edi] -= r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c2ff9; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2ff9: // 0160:1c2ff9
    r32[edx]++;
    { pc = 0x1c2fc8; break; }
  case 0x1c2ffc: // 0160:1c2ffc
    r32[esi] += 0x00000018;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c2fc8; break; }
    r32[esi] = pop32();
    r32[esi]--;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c2fc1; break; }
    r32[edx] = memoryAGet32(ds, 0x20cecf);
    r32[esi] = 0x00224f13;
    r32[ecx] = 0x0000000c;
  case 0x1c3017: // 0160:1c3017
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x0000000c;
  case 0x1c301e: // 0160:1c301e
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c3052; break; }
    r32[edi] = 0x00225153;
    r32[edi] -= r32[eax];
    r32[edx]++;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] -= r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c304f; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c304f: // 0160:1c304f
    r32[edx]++;
    { pc = 0x1c301e; break; }
  case 0x1c3052: // 0160:1c3052
    r32[esi]--;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c301e; break; }
    r32[esi] = pop32();
    r32[esi] -= 0x00000018;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c3017; break; }
    r32[edx] = memoryAGet32(ds, 0x20cecf);
    r32[esi] = 0x00224efc;
    r32[ecx] = 0x0000000c;
  case 0x1c306d: // 0160:1c306d
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x0000000c;
  case 0x1c3074: // 0160:1c3074
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c30a8; break; }
    r32[edi] = 0x0022513c;
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] -= r32[eax];
    r32[edx]++;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[edi] += r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c30a5; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c30a5: // 0160:1c30a5
    r32[edx]++;
    { pc = 0x1c3074; break; }
  case 0x1c30a8: // 0160:1c30a8
    r32[esi] -= 0x00000018;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c3074; break; }
    r32[esi] = pop32();
    r32[esi]++;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c306d; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c2f5a() // 0160:1c2f5a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x20cecf, r32[edx]);
    r32[esi] = 0x00224cd4;
    r32[ecx] = 0x0000000c;
  case 0x1c2f6a: // 0160:1c2f6a
    push32(r32[ecx]);
    r32[ecx] = 0x0000000c;
  case 0x1c2f70: // 0160:1c2f70
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c2fa7; break; }
    r32[edi] = 0x00224f14;
    r32[eax] &= 0x000000ff;
    r32[edi] += r32[eax];
    r32[edx]++;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] += r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c2fa4; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2fa4: // 0160:1c2fa4
    r32[edx]++;
    { pc = 0x1c2f70; break; }
  case 0x1c2fa7: // 0160:1c2fa7
    r32[esi]++;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c2f70; break; }
    r32[esi] += 0x0000000c;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c2f6a; break; }
    r32[edx] = memoryAGet32(ds, 0x20cecf);
    r32[esi] = 0x00224ceb;
    r32[ecx] = 0x0000000c;
  case 0x1c2fc1: // 0160:1c2fc1
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x0000000c;
  case 0x1c2fc8: // 0160:1c2fc8
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c2ffc; break; }
    r32[edi] = 0x00224f2b;
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] += r32[eax];
    r32[eax] = 0;
    r32[edx]++;
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[edi] -= r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c2ff9; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c2ff9: // 0160:1c2ff9
    r32[edx]++;
    { pc = 0x1c2fc8; break; }
  case 0x1c2ffc: // 0160:1c2ffc
    r32[esi] += 0x00000018;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c2fc8; break; }
    r32[esi] = pop32();
    r32[esi]--;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c2fc1; break; }
    r32[edx] = memoryAGet32(ds, 0x20cecf);
    r32[esi] = 0x00224f13;
    r32[ecx] = 0x0000000c;
  case 0x1c3017: // 0160:1c3017
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x0000000c;
  case 0x1c301e: // 0160:1c301e
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c3052; break; }
    r32[edi] = 0x00225153;
    r32[edi] -= r32[eax];
    r32[edx]++;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] -= r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c304f; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c304f: // 0160:1c304f
    r32[edx]++;
    { pc = 0x1c301e; break; }
  case 0x1c3052: // 0160:1c3052
    r32[esi]--;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c301e; break; }
    r32[esi] = pop32();
    r32[esi] -= 0x00000018;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c3017; break; }
    r32[edx] = memoryAGet32(ds, 0x20cecf);
    r32[esi] = 0x00224efc;
    r32[ecx] = 0x0000000c;
  case 0x1c306d: // 0160:1c306d
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = 0x0000000c;
  case 0x1c3074: // 0160:1c3074
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0xff)
        { pc = 0x1c30a8; break; }
    r32[edi] = 0x0022513c;
    r16[ax] <<= 3;
    r16[bp] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bp];
    r32[edi] -= r32[eax];
    r32[edx]++;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[edi] += r32[eax];
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] == 0x9c)
        { pc = 0x1c30a5; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c30a5: // 0160:1c30a5
    r32[edx]++;
    { pc = 0x1c3074; break; }
  case 0x1c30a8: // 0160:1c30a8
    r32[esi] -= 0x00000018;
    r32[edx]++;
    if (--r32[ecx])
        { pc = 0x1c3074; break; }
    r32[esi] = pop32();
    r32[esi]++;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c306d; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c30b4() // 0160:1c30b4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = 0x0040;
    r16[cx] = 0x0070;
    memoryASet16(ds, 0x20cea5, r16[bx]);
    memoryASet16(ds, 0x20cea7, r16[cx]);
    r32[esi] = 0x00224cef;
    r32[ecx] = 0x00000016;
  case 0x1c30d4: // 0160:1c30d4
    push32(r32[ecx]);
    r32[ecx] = 0x00000013;
  case 0x1c30da: // 0160:1c30da
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8s[al] < signed8(0x80))
        { pc = 0x1c310a; break; }
    if (r8s[al] > signed8(0x84))
        { pc = 0x1c30ed; break; }
    r8[al] -= 0x7d;
    { pc = 0x1c30f7; break; }
  case 0x1c30ed: // 0160:1c30ed
    if (r8s[al] < signed8(0x9c))
        { pc = 0x1c310a; break; }
    if (r8s[al] > signed8(0xa0))
        { pc = 0x1c310a; break; }
    r8[al] -= 0x95;
  case 0x1c30f7: // 0160:1c30f7
    r16[bx] = memoryAGet16(ds, 0x20cea5);
    r16[cx] = memoryAGet16(ds, 0x20cea7);
    yield* sub_1c2c57();
  case 0x1c310a: // 0160:1c310a
    memoryASet16(ds, 0x20cea5, memoryAGet16(ds, 0x20cea5) + 0x0004);
    r32[esi] = pop32();
    r32[esi]++;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c30da; break; }
    r32[ecx] = pop32();
    r32[esi] += 0x00000005;
    memoryASet16(ds, 0x20cea5, memoryAGet16(ds, 0x20cea5) - 0x004c);
    memoryASet16(ds, 0x20cea7, memoryAGet16(ds, 0x20cea7) + 0x0004);
    if (--r32[ecx])
        { pc = 0x1c30d4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c312e() // 0160:1c312e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001f0c84;
    yield* sub_1b5a2d();
    r32[esi] = 0x001f0c96;
    yield* sub_1b5a2d();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001f0350;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1c31c6: // 0160:1c31c6
    yield* sub_1b5096();
    yield* sub_1c7113();
    yield* sub_1c3224();
    r32[esi] = 0x001f037f;
    r8[al] = 0xc2;
    r8[bl] = 0xca;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c31fa; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c31c6; break; }
  case 0x1c31fa: // 0160:1c31fa
    r32[edi] = 0x00232cd8;
    r32[ecx] = 0x00000240;
    r32[esi] = 0x00224cd4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e82f);
    r16[ax] <<= 6;
    r16[bx] = r16[ax];
    r16[ax] <<= 3;
    r16[ax] += r16[bx];
    r32[esi] += r32[eax];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c3224() // 0160:1c3224 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c3224; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 23039 bytes // gap 23039 bytes
  case 0x1c3224: // 0160:1c3224
    r16[cx] = 0;
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c324e; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c324e; break; }
    r8[al] = 0x88;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20e831, 0x0001);
    r32[esp] += 4; return;
  case 0x1c324e: // 0160:1c324e
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1c3285; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c3285; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    r16[cx] = memoryAGet16(ds, 0x20e82f);
    r16[cx] -= 0x0005;
    if (r16s[cx] >= 0)
        { pc = 0x1c3323; break; }
    r16[cx] += 0x000a;
    { pc = 0x1c3323; break; }
  case 0x1c3285: // 0160:1c3285
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1c32bd; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c32bd; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    r16[cx] = memoryAGet16(ds, 0x20e82f);
    r16[cx] += 0x0005;
    if (r16s[cx] < signed16(0x000a))
        { pc = 0x1c3323; break; }
    r16[cx] -= 0x000a;
    { pc = 0x1c3323; break; }
  case 0x1c32bd: // 0160:1c32bd
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c32f1; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c32f1; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    r16[cx] = memoryAGet16(ds, 0x20e82f);
    r16[cx]--;
    if (r16[cx] != 0xffff)
        { pc = 0x1c3323; break; }
    r16[cx] = 0x0009;
    { pc = 0x1c3323; break; }
  case 0x1c32f1: // 0160:1c32f1
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c332a; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= memoryAGet(ds, 0x20e837);
    if (r8[al])
        { pc = 0x1c332a; break; }
    r8[al] = 0x87;
    yield* sub_1b17b7();
    r16[cx] = memoryAGet16(ds, 0x20e82f);
    r16[cx]++;
    if (r16[cx] != 0x000a)
        { pc = 0x1c3323; break; }
    r16[cx] = 0x0000;
  case 0x1c3323: // 0160:1c3323
    memoryASet16(ds, 0x20e82f, r16[cx]);
  case 0x1c332a: // 0160:1c332a
    r16[bp] = 0x0000;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[si] = memoryAGet16(ds, 0x20eeb0);
    r16[si] &= 0x0007;
    r16[si] >>>= 2;
    if (!r16[si])
        { pc = 0x1c334b; break; }
    r16[ax]--;
    r16[bp] = 0x0001;
  case 0x1c334b: // 0160:1c334b
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[cx] = memoryAGet16(ds, 0x20e82f);
    if (r16s[cx] < signed16(0x0005))
        { pc = 0x1c3367; break; }
    r16[cx] -= 0x0005;
    r16[bx] += 0x0028;
  case 0x1c3367: // 0160:1c3367
    r16[cx] <<= 3;
    r16[dx] = r16[cx];
    r16[cx] <<= 2;
    r16[cx] += r16[dx];
    r16[ax] += r16[cx];
    r16[cx] = 0x0000;
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    yield* sub_1bd7dd();
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x002c;
    if (!r16[bp])
        { pc = 0x1c339b; break; }
    r16[ax] += 0x0002;
  case 0x1c339b: // 0160:1c339b
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1c33a1() // 0160:1c33a1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b5998();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    yield* sub_1c34a7();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c34a7();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1c342c: // 0160:1c342c
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    yield* sub_1b4941();
    memoryASet16(ds, 0x20e805, 0x0002);
    memoryASet16(ds, 0x20e809, 0x0001);
    memoryASet16(ds, 0x20ceb1, 0x0000);
    yield* sub_1b49ae();
    yield* sub_1c3486();
    r32[esi] = 0x001ee1b2;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c3485; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c342c; break; }
  case 0x1c3485: // 0160:1c3485
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c3486() // 0160:1c3486 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c3486; break; }
  case 0x1b4b56: // 0160:1b4b56
    r16[dx] = 0x0001;
    { pc = 0x1bd7dd; break; }
    // gap 35966 bytes // gap 35966 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 23649 bytes // gap 23649 bytes
  case 0x1c3486: // 0160:1c3486
    r16[ax] += 0x00c2;
    if (!r16[bp])
        { pc = 0x1c3493; break; }
    r16[ax] += 0x0002;
  case 0x1c3493: // 0160:1c3493
    if (!(memoryAGet16(ds, 0x20e82f) & 0xffff))
        { pc = 0x1c34a2; break; }
    r16[ax] -= 0x0018;
  case 0x1c34a2: // 0160:1c34a2
    { pc = 0x1b4b56; break; }
    return;
  }
}
function* sub_1c34a7() // 0160:1c34a7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c34a7; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 53470 bytes // gap 53470 bytes
  case 0x1c34a7: // 0160:1c34a7
    memoryASet16(ds, 0x20e905, 0x0002);
    r32[esi] = 0x001f0cf0;
    yield* sub_1b60d3();
    r32[esi] = 0x001f0d0a;
    { pc = 0x1b60d3; break; }
    return;
  }
}
function* sub_1c34c4() // 0160:1c34c4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001f0df0;
    yield* sub_1b5a2d();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001f0d24;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = 0x0029be48;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[edx] = 0x001f0d61;
    yield* sub_1aa484();
    r32[edi] = 0x00246d70;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    memoryASet16(ds, 0x20ec3d, 0x0064);
    memoryASet16(ds, 0x20ec3f, 0x0064);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20ceaf, 0x0000);
    memoryASet16(ds, 0x20cead, 0x0001);
    memoryASet16(ds, 0x20ceab, 0x0000);
    memoryASet16(ds, 0x20cea9, 0x0000);
    yield* sub_1b4f0e();
    yield* sub_1c393a();
    yield* sub_1c42f0();
  case 0x1c35a7: // 0160:1c35a7
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1bb00d();
    if (!(memoryAGet16(ds, 0x22465a) & 0xffff))
        { pc = 0x1c35c8; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1c35c8: // 0160:1c35c8
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    r16[ax] += 0x0002;
    r16[bx] += 0x0002;
    memoryASet16(ds, 0x20ec3d, r16[ax]);
    memoryASet16(ds, 0x20ec3f, r16[bx]);
    yield* sub_1c3cf3();
    yield* sub_1c3869();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c384e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] < signed16(0x00d6))
        { pc = 0x1c3665; break; }
    if (r16s[ax] > signed16(0x0115))
        { pc = 0x1c3665; break; }
    if (r16s[bx] < signed16(0x007b))
        { pc = 0x1c3665; break; }
    if (r16s[bx] > signed16(0x00ba))
        { pc = 0x1c3665; break; }
    r16[cx] = 0x0000;
    r16[ax] -= 0x00d6;
    r16[ax] &= 0x0038;
    r16[cx] += r16[ax];
    r16[bx] -= 0x007b;
    r16[bx] >>>= 3;
    r16[cx] += r16[bx];
    memoryASet16(ds, 0x20cead, r16[cx]);
    if (!r16[cx])
        { pc = 0x1c3665; break; }
    r16[bx] = r16[cx];
    r32[esi] = 0x00224cd4;
    r32[ecx] = 0x00000a00;
  case 0x1c365a: // 0160:1c365a
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c3662; break; }
    memoryASet(ds, r32[esi], r8[bl]);
  case 0x1c3662: // 0160:1c3662
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c365a; break; }
  case 0x1c3665: // 0160:1c3665
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] < signed16(0x011c))
        { pc = 0x1c36a1; break; }
    if (r16s[ax] > signed16(0x0124))
        { pc = 0x1c36a1; break; }
    if (r16s[bx] < signed16(0x007b))
        { pc = 0x1c36a1; break; }
    if (r16s[bx] > signed16(0x00ba))
        { pc = 0x1c36a1; break; }
    r16[cx] = 0x0000;
    r16[bx] -= 0x007b;
    r16[bx] >>>= 3;
    r16[cx] += r16[bx];
    memoryASet16(ds, 0x20ceab, r16[cx]);
  case 0x1c36a1: // 0160:1c36a1
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] < signed16(0x0128))
        { pc = 0x1c36e6; break; }
    if (r16s[ax] > signed16(0x0130))
        { pc = 0x1c36e6; break; }
    if (r16s[bx] < signed16(0x007b))
        { pc = 0x1c36e6; break; }
    if (r16s[bx] > signed16(0x00a1))
        { pc = 0x1c36e6; break; }
    r16[cx] = 0x0000;
    if (r16s[bx] <= signed16(0x008d))
        { pc = 0x1c36df; break; }
    memoryASet16(ds, 0x20ceab, 0x0000);
    r16[cx] = 0x0001;
  case 0x1c36df: // 0160:1c36df
    memoryASet16(ds, 0x20cea9, r16[cx]);
  case 0x1c36e6: // 0160:1c36e6
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (r8[al])
        { pc = 0x1c384e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] < signed16(0x00f4))
        { pc = 0x1c371b; break; }
    if (r16s[ax] > signed16(0x0114))
        { pc = 0x1c371b; break; }
    if (r16s[bx] < signed16(0x00c8))
        { pc = 0x1c371b; break; }
    if (r16s[bx] > signed16(0x00d0))
        { pc = 0x1c371b; break; }
    r32[esp] += 4; return;
  case 0x1c371b: // 0160:1c371b
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] < signed16(0x0128))
        { pc = 0x1c374c; break; }
    if (r16s[ax] > signed16(0x0130))
        { pc = 0x1c374c; break; }
    if (r16s[bx] < signed16(0x00a5))
        { pc = 0x1c374c; break; }
    if (r16s[bx] > signed16(0x00b8))
        { pc = 0x1c374c; break; }
    yield* sub_1c446d();
    yield* sub_1c393a();
  case 0x1c374c: // 0160:1c374c
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] <= signed16(0x0104))
        { pc = 0x1c37c6; break; }
    if (r16s[ax] > signed16(0x0128))
        { pc = 0x1c37c6; break; }
    if (r16s[bx] <= signed16(0x00bc))
        { pc = 0x1c37c6; break; }
    if (r16s[bx] > signed16(0x00c5))
        { pc = 0x1c37c6; break; }
    yield* sub_1c42f0();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += 0x0029bb34;
    r32[edi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[edi] += memoryAGet32(ds, 0x20b800);
    r32[ebx] = 0x00000060;
  case 0x1c37a0: // 0160:1c37a0
    r32[ecx] = 0x00000060;
  case 0x1c37a5: // 0160:1c37a5
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c37a5; break; }
    r32[esi] += 0x000000e0;
    r32[edi] += 0x000000e0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c37a0; break; }
    yield* sub_1c393a();
    { pc = 0x1c384e; break; }
  case 0x1c37c6: // 0160:1c37c6
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[ax] <= signed16(0x00de))
        { pc = 0x1c3810; break; }
    if (r16s[ax] > signed16(0x00ee))
        { pc = 0x1c3810; break; }
    if (r16s[bx] <= signed16(0x00bc))
        { pc = 0x1c3810; break; }
    if (r16s[bx] > signed16(0x00c5))
        { pc = 0x1c3810; break; }
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    if (r16[ax])
        { pc = 0x1c37fc; break; }
    r16[ax] = 0x001e;
  case 0x1c37fc: // 0160:1c37fc
    r16[ax]--;
    memoryASet16(ds, 0x20ceaf, r16[ax]);
    yield* sub_1c393a();
    yield* sub_1c42f0();
    { pc = 0x1c384e; break; }
  case 0x1c3810: // 0160:1c3810
    if (r16s[ax] <= signed16(0x00ee))
        { pc = 0x1c384e; break; }
    if (r16s[ax] > signed16(0x00fe))
        { pc = 0x1c384e; break; }
    if (r16s[bx] <= signed16(0x00bc))
        { pc = 0x1c384e; break; }
    if (r16s[bx] > signed16(0x00c5))
        { pc = 0x1c384e; break; }
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    if (r16[ax] != 0x001d)
        { pc = 0x1c383a; break; }
    r16[ax] = 0xffff;
  case 0x1c383a: // 0160:1c383a
    r16[ax]++;
    memoryASet16(ds, 0x20ceaf, r16[ax]);
    yield* sub_1c393a();
    yield* sub_1c42f0();
    { pc = 0x1c384e; break; }
  case 0x1c384e: // 0160:1c384e
    if (memoryAGet16(ds, 0x20e831) & 0xffff)
        { pc = 0x1c3868; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    { pc = 0x1c35a7; break; }
  case 0x1c3868: // 0160:1c3868
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c3869() // 0160:1c3869 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c3869; break; }
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 24644 bytes // gap 24644 bytes
  case 0x1c3869: // 0160:1c3869
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c387a; break; }
    memoryASet16(ds, 0x224656, memoryAGet16(ds, 0x224656) - 0x0001);
  case 0x1c387a: // 0160:1c387a
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c388b; break; }
    memoryASet16(ds, 0x224656, memoryAGet16(ds, 0x224656) + 0x0001);
  case 0x1c388b: // 0160:1c388b
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1c389c; break; }
    memoryASet16(ds, 0x224658, memoryAGet16(ds, 0x224658) - 0x0001);
  case 0x1c389c: // 0160:1c389c
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1c38ad; break; }
    memoryASet16(ds, 0x224658, memoryAGet16(ds, 0x224658) + 0x0001);
  case 0x1c38ad: // 0160:1c38ad
    yield* sub_1bafe1();
    r16[cx] = 0x0000;
    yield* sub_1bafc3();
    r16[ax] = 0x0154;
    r16[bx] = memoryAGet16(ds, 0x20cead);
    r16[bx] &= 0x0038;
    r16[ax] += r16[bx];
    r16[bx] = memoryAGet16(ds, 0x20cead);
    r16[bx] &= 0x0007;
    r16[bx] <<= 3;
    r16[bx] += 0x00f8;
    r16[cx] = 0x0011;
    r16[dx] = 0x0000;
    yield* sub_1bd7dd();
    r16[ax] = 0x0199;
    r16[bx] = memoryAGet16(ds, 0x20ceab);
    r16[bx] <<= 3;
    r16[bx] += 0x00f7;
    r16[cx] = 0x0012;
    r16[dx] = 0x0000;
    yield* sub_1bd7dd();
    r16[ax] = 0x01a7;
    r16[bx] = memoryAGet16(ds, 0x20cea9);
    r16[bx] <<= 2;
    r16[dx] = r16[bx];
    r16[bx] <<= 2;
    r16[bx] += r16[dx];
    r16[bx] += 0x00f8;
    r16[cx] = 0x0013;
    r16[dx] = 0x0000;
    { pc = 0x1bd7dd; break; }
    return;
  }
}
function* sub_1c393a() // 0160:1c393a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x20cecb, r32[esi]);
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += 0x00246a5c;
    memoryASet32(ds, 0x20cecf, r32[esi]);
    r32[edi] = 0x000a0000;
    yield* sub_1c3982();
    r32[edi] = 0x000a4800;
    yield* sub_1c3982();
    r32[edi] = 0x000a9000;
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r16[bx] = 0x00d2;
    r16[cx] = 0x0010;
    r16[dx] = 0x0060;
    r16[bp] = 0x0060;
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c3a0e: // 0160:1c3a0e
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c3a25: // 0160:1c3a25
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c3a2c: // 0160:1c3a2c
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (r8[al] < 0xfc)
        { pc = 0x1c3a6d; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
    { pc = 0x1c3aa7; break; }
  case 0x1c3a6d: // 0160:1c3a6d
    if (r8[al])
        { pc = 0x1c3aa7; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0003ebd4;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
  case 0x1c3aa7: // 0160:1c3aa7
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0004);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c3a2c; break; }
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + 1);
    r32[esi] += 0x000000e0;
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c3a25; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c3b0b; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0060);
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c3a0e; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c3a0e; break; }
  case 0x1c3b0b: // 0160:1c3b0b
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r32[ebp] = memoryAGet32(ds, 0x20cecf);
    r32[edi] = 0x002303d4;
    r32[edx] = 0x00230494;
    r32[ebx] = 0x00000060;
  case 0x1c3b38: // 0160:1c3b38
    r32[ecx] = 0x00000060;
  case 0x1c3b3d: // 0160:1c3b3d
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xfc)
        { pc = 0x1c3b7b; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
    { pc = 0x1c3bb5; break; }
  case 0x1c3b7b: // 0160:1c3b7b
    if (r8[al])
        { pc = 0x1c3bb5; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0003ebd4;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
  case 0x1c3bb5: // 0160:1c3bb5
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    if (!(memoryAGet(ss, r32[ebp]) & 0xff))
        { pc = 0x1c3bc7; break; }
    r8[al] = memoryAGet(ss, r32[ebp]);
  case 0x1c3bc7: // 0160:1c3bc7
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    r32[ebp]++;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 1);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c3b3d; break; }
    r32[edi] += 0x000000c0;
    r32[edx] += 0x000000c0;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0060);
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + 1);
    r32[esi] += 0x000000e0;
    r32[ebp] += 0x000000e0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c3b38; break; }
    r32[edi] = 0x000a0000;
    yield* sub_1c3c21();
    r32[edi] = 0x000a4800;
    yield* sub_1c3c21();
    r32[edi] = 0x000a9000;
    r32[esi] = 0x002303d4;
    r16[bx] = 0x0008;
    r16[cx] = 0x0010;
    r16[dx] = 0x00c0;
    r16[bp] = 0x00c0;
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c3c9a: // 0160:1c3c9a
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c3cb1: // 0160:1c3cb1
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c3cb8: // 0160:1c3cb8
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c3cb8; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c3cb1; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c3cec; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c3c9a; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c3c9a; break; }
  case 0x1c3cec: // 0160:1c3cec
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c3982() // 0160:1c3982 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r16[bx] = 0x00d2;
    r16[cx] = 0x0010;
    r16[dx] = 0x0060;
    r16[bp] = 0x0060;
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c3a0e: // 0160:1c3a0e
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c3a25: // 0160:1c3a25
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c3a2c: // 0160:1c3a2c
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (r8[al] < 0xfc)
        { pc = 0x1c3a6d; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
    { pc = 0x1c3aa7; break; }
  case 0x1c3a6d: // 0160:1c3a6d
    if (r8[al])
        { pc = 0x1c3aa7; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0003ebd4;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
  case 0x1c3aa7: // 0160:1c3aa7
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0004);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c3a2c; break; }
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + 1);
    r32[esi] += 0x000000e0;
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c3a25; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c3b0b; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0060);
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c3a0e; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c3a0e; break; }
  case 0x1c3b0b: // 0160:1c3b0b
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r32[ebp] = memoryAGet32(ds, 0x20cecf);
    r32[edi] = 0x002303d4;
    r32[edx] = 0x00230494;
    r32[ebx] = 0x00000060;
  case 0x1c3b38: // 0160:1c3b38
    r32[ecx] = 0x00000060;
  case 0x1c3b3d: // 0160:1c3b3d
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xfc)
        { pc = 0x1c3b7b; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
    { pc = 0x1c3bb5; break; }
  case 0x1c3b7b: // 0160:1c3b7b
    if (r8[al])
        { pc = 0x1c3bb5; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0003ebd4;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
  case 0x1c3bb5: // 0160:1c3bb5
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    if (!(memoryAGet(ss, r32[ebp]) & 0xff))
        { pc = 0x1c3bc7; break; }
    r8[al] = memoryAGet(ss, r32[ebp]);
  case 0x1c3bc7: // 0160:1c3bc7
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    r32[ebp]++;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 1);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c3b3d; break; }
    r32[edi] += 0x000000c0;
    r32[edx] += 0x000000c0;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0060);
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + 1);
    r32[esi] += 0x000000e0;
    r32[ebp] += 0x000000e0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c3b38; break; }
    r32[edi] = 0x000a0000;
    yield* sub_1c3c21();
    r32[edi] = 0x000a4800;
    yield* sub_1c3c21();
    r32[edi] = 0x000a9000;
    r32[esi] = 0x002303d4;
    r16[bx] = 0x0008;
    r16[cx] = 0x0010;
    r16[dx] = 0x00c0;
    r16[bp] = 0x00c0;
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c3c9a: // 0160:1c3c9a
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c3cb1: // 0160:1c3cb1
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c3cb8: // 0160:1c3cb8
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c3cb8; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c3cb1; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c3cec; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c3c9a; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c3c9a; break; }
  case 0x1c3cec: // 0160:1c3cec
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c3c21() // 0160:1c3c21 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x002303d4;
    r16[bx] = 0x0008;
    r16[cx] = 0x0010;
    r16[dx] = 0x00c0;
    r16[bp] = 0x00c0;
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x224634, r16[dx]);
    memoryASet16(ds, 0x224636, r16[bp]);
    r32[eax] = 0;
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    r16[cx] = r16[bx];
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c3c9a: // 0160:1c3c9a
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c3cb1: // 0160:1c3cb1
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c3cb8: // 0160:1c3cb8
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c3cb8; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c3cb1; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c3cec; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c3c9a; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c3c9a; break; }
  case 0x1c3cec: // 0160:1c3cec
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c3cf3() // 0160:1c3cf3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] &= 0xfffe;
    r16[bx] &= 0xfffe;
    r16[ax] += 0x0070;
    r16[bx] += 0x0070;
    r32[esi] = 0x001f0ea2;
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20ceab);
    r16[cx] <<= 1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[ax] += r16[cx];
    r16[bx] += r16[cx];
    if (r16s[ax] <= signed16(0x0086))
        { pc = 0x1c41a6; break; }
    r16[dx] = 0x013a;
    r16[dx] += r16[cx];
    if (r16s[ax] >= r16s[dx])
        { pc = 0x1c41a6; break; }
    if (r16s[bx] <= signed16(0x008e))
        { pc = 0x1c41a6; break; }
    r16[dx] = 0x0142;
    r16[dx] += r16[cx];
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1c41a6; break; }
    r16[cx] = memoryAGet16(ds, 0x20ceab);
    r16[cx]++;
    r16[dx] = 0;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1bd7dd();
    r32[eax] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    yield* sub_1c41a7();
    r8[dl] = memoryAGet(ds, 0x20c840);
    r8[dl] &= 0x80;
    if (!r8[dl])
        { pc = 0x1c41a6; break; }
    r16[bx] -= 0x0080;
    r16[cx] -= 0x0080;
    if (memoryAGet16(ds, 0x20cea9) & 0xffff)
        { pc = 0x1c3db6; break; }
    r8[dl] = memoryAGet(ds, 0x20e837);
    r8[dl] &= 0x80;
    if (r8[dl])
        { pc = 0x1c3db1; break; }
    yield* sub_1c42f0();
  case 0x1c3db1: // 0160:1c3db1
    { pc = 0x1c4076; break; }
  case 0x1c3db6: // 0160:1c3db6
    r32[eax] = 0x002231c0;
    memoryASet32(ds, 0x20eea5, r32[eax]);
    r8[al] = memoryAGet(ds, 0x20e837);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c3dca; break; }
    r32[esp] += 4; return;
  case 0x1c3dca: // 0160:1c3dca
    yield* sub_1c42f0();
    memoryASet16(ds, 0x20ceab, 0x0000);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[esi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    r32[esi] += memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x20d811, r32[esi]);
    yield* sub_1c4039();
    r8[bh] |= 0xf0;
    yield* sub_1c3f42();
    yield* sub_1c3f53();
    memoryASet32(ds, 0x20d80d, 0x00000001);
  case 0x1c3e14: // 0160:1c3e14
    yield* sub_1c3f75();
    yield* sub_1c3f64();
    yield* sub_1c3f42();
    yield* sub_1c3f53();
    r16[bx] += 0x0080;
    r16[cx] += 0x0080;
    yield* sub_1c41a7();
    r16[bx] -= 0x0080;
    r16[cx] -= 0x0080;
    yield* sub_1c3f86();
    if (r16[ax])
        { pc = 0x1c3e6c; break; }
    yield* sub_1c3f75();
    yield* sub_1c3f64();
    memoryASet32(ds, 0x20d80d, memoryAGet32(ds, 0x20d80d) - 1);
    if (memoryAGet32(ds, 0x20d80d) & 0xffffffff)
        { pc = 0x1c3e14; break; }
    { pc = 0x1c3f41; break; }
  case 0x1c3e6c: // 0160:1c3e6c
    yield* sub_1c3f75();
    yield* sub_1c3f64();
    memoryASet32(ds, 0x20d80d, memoryAGet32(ds, 0x20d80d) - 1);
    r8[dl] = r8[bh];
    r8[dl] >>>= 4;
    if (!(r8[dl] & 0x08))
        { pc = 0x1c3eae; break; }
    r16[cx] -= 0x0002;
    r8[bh] &= 0x0f;
    r8[bh] |= 0xb0;
    yield* sub_1c3fa2();
    if (!r16[ax])
        { pc = 0x1c3eaa; break; }
    yield* sub_1c3f42();
    yield* sub_1c3f53();
    memoryASet32(ds, 0x20d80d, memoryAGet32(ds, 0x20d80d) + 1);
  case 0x1c3eaa: // 0160:1c3eaa
    r16[cx] += 0x0002;
  case 0x1c3eae: // 0160:1c3eae
    if (!(r8[dl] & 0x04))
        { pc = 0x1c3edb; break; }
    r16[cx] += 0x0002;
    r8[bh] &= 0x0f;
    r8[bh] |= 0x70;
    yield* sub_1c3fa2();
    if (!r16[ax])
        { pc = 0x1c3ed7; break; }
    yield* sub_1c3f42();
    yield* sub_1c3f53();
    memoryASet32(ds, 0x20d80d, memoryAGet32(ds, 0x20d80d) + 1);
  case 0x1c3ed7: // 0160:1c3ed7
    r16[cx] -= 0x0002;
  case 0x1c3edb: // 0160:1c3edb
    if (!(r8[dl] & 0x02))
        { pc = 0x1c3f08; break; }
    r16[bx] += 0x0002;
    r8[bh] &= 0x0f;
    r8[bh] |= 0xe0;
    yield* sub_1c3fa2();
    if (!r16[ax])
        { pc = 0x1c3f04; break; }
    yield* sub_1c3f42();
    yield* sub_1c3f53();
    memoryASet32(ds, 0x20d80d, memoryAGet32(ds, 0x20d80d) + 1);
  case 0x1c3f04: // 0160:1c3f04
    r16[bx] -= 0x0002;
  case 0x1c3f08: // 0160:1c3f08
    if (!(r8[dl] & 0x01))
        { pc = 0x1c3f31; break; }
    r16[bx] -= 0x0002;
    r8[bh] &= 0x0f;
    r8[bh] |= 0xd0;
    yield* sub_1c3fa2();
    if (!r16[ax])
        { pc = 0x1c3f31; break; }
    yield* sub_1c3f42();
    yield* sub_1c3f53();
    memoryASet32(ds, 0x20d80d, memoryAGet32(ds, 0x20d80d) + 1);
  case 0x1c3f31: // 0160:1c3f31
    if (memoryAGet32(ds, 0x20d80d) & 0xffffffff)
        { pc = 0x1c3e14; break; }
  case 0x1c3f41: // 0160:1c3f41
    r32[esp] += 4; return;
    // gap 308 bytes // gap 308 bytes
  case 0x1c4076: // 0160:1c4076
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1c433c();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] >>>= 1;
    r16[cx] >>>= 1;
    r16[bx] += 0x00ce;
    r16[cx] += 0x0008;
    r16[ax] += 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1c433c();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[edi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[edi] += memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x20cecb, r32[edi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] -= 0x00d2;
    r16[cx] -= 0x0010;
    memoryASet16(ds, 0x20cec5, r16[cx]);
    push32(r32[edi]);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = pop32();
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 8;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000140;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c4148: // 0160:1c4148
    r16[cx] = memoryAGet16(ds, 0x224634);
    if (!(memoryAGet16(ds, 0x20cead) & 0xffff))
        { pc = 0x1c416e; break; }
  case 0x1c415a: // 0160:1c415a
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (!r8[al])
        { pc = 0x1c4169; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c4169: // 0160:1c4169
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c415a; break; }
    { pc = 0x1c41a0; break; }
  case 0x1c416e: // 0160:1c416e
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (!r8[al])
        { pc = 0x1c419d; break; }
    push32(r32[edi]);
    push32(r32[esi]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += 0x0029bb34;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] = pop32();
    r32[edi] = pop32();
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c419d: // 0160:1c419d
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c416e; break; }
  case 0x1c41a0: // 0160:1c41a0
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c4148; break; }
  case 0x1c41a6: // 0160:1c41a6
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c3f42() // 0160:1c3f42 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20eea5);
    memoryASet16(ds, r32[eax], r16[bx]);
    r32[eax] -= 0x00000002;
    memoryASet32(ds, 0x20eea5, r32[eax]);
    r32[esp] += 4;
}
function* sub_1c3f53() // 0160:1c3f53 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20eea5);
    memoryASet16(ds, r32[eax], r16[cx]);
    r32[eax] -= 0x00000002;
    memoryASet32(ds, 0x20eea5, r32[eax]);
    r32[esp] += 4;
}
function* sub_1c3f64() // 0160:1c3f64 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20eea5);
    r32[eax] += 0x00000002;
    memoryASet32(ds, 0x20eea5, r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[eax]);
    r32[esp] += 4;
}
function* sub_1c3f75() // 0160:1c3f75 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20eea5);
    r32[eax] += 0x00000002;
    memoryASet32(ds, 0x20eea5, r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[eax]);
    r32[esp] += 4;
}
function* sub_1c3f86() // 0160:1c3f86 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c3fa2();
    if (r16[ax])
        { pc = 0x1c3f91; break; }
    r32[esp] += 4; return;
  case 0x1c3f91: // 0160:1c3f91
    r16[ax] = 0x0001;
    r8[bh] &= 0x0f;
    yield* sub_1c4076();
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c3fa2() // 0160:1c3fa2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    if (r32s[ecx] <= signed32(0x0000000e))
        { pc = 0x1c402c; break; }
    if (r32s[ecx] > signed32(0x000000ce))
        { pc = 0x1c402c; break; }
    r8[bh] &= 0x0f;
    if (r32s[ebx] <= signed32(0x00000006))
        { pc = 0x1c402c; break; }
    if (r32s[ebx] > signed32(0x000000c6))
        { pc = 0x1c402c; break; }
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[bx] >>>= 1;
    r16[cx] >>>= 1;
    r16[bx] += 0xfffc;
    r16[cx] += 0xfff8;
    r32[ebx] &= 0x0000ffff;
    r32[ecx] &= 0x0000ffff;
    r32[esi] = memoryAGet32(ds, 0x20d811);
    r32[esi] += r32[ebx];
    r32[ecx] <<= 6;
    r32[ebx] = r32[ecx];
    r32[ecx] <<= 2;
    r32[ecx] += r32[ebx];
    r32[esi] += r32[ecx];
    r8[al] = memoryAGet(ds, r32[esi]);
    if (memoryAGet16(ds, 0x20cead) & 0xffff)
        { pc = 0x1c4017; break; }
    if (r8[al] != memoryAGet(ds, 0x20ee5f))
        { pc = 0x1c402a; break; }
    if (!r8[al])
        { pc = 0x1c402a; break; }
    if (r8[al] < 0xfc)
        { pc = 0x1c4031; break; }
    { pc = 0x1c402a; break; }
  case 0x1c4017: // 0160:1c4017
    if (r8[al] != memoryAGet(ds, 0x20ee5f))
        { pc = 0x1c402a; break; }
    r16[bx] = memoryAGet16(ds, 0x20cead);
    if (r8[al] != r8[bl])
        { pc = 0x1c4031; break; }
  case 0x1c402a: // 0160:1c402a
    r32[esi] = pop32();
    r32[ecx] = pop32();
  case 0x1c402c: // 0160:1c402c
    r32[ebx] = pop32();
    r16[ax] = 0;
    r32[esp] += 4; return;
  case 0x1c4031: // 0160:1c4031
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c4039() // 0160:1c4039 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[bx] >>>= 1;
    r16[cx] >>>= 1;
    r16[bx] += 0xfffc;
    r16[cx] += 0xfff8;
    r32[ebx] &= 0x0000ffff;
    r32[ecx] &= 0x0000ffff;
    r32[esi] = memoryAGet32(ds, 0x20d811);
    r32[esi] += r32[ebx];
    r32[ecx] <<= 6;
    r32[ebx] = r32[ecx];
    r32[ecx] <<= 2;
    r32[ecx] += r32[ebx];
    r32[esi] += r32[ecx];
    r8[bl] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20ee5f, r8[bl]);
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1c4076() // 0160:1c4076 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1c433c();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] >>>= 1;
    r16[cx] >>>= 1;
    r16[bx] += 0x00ce;
    r16[cx] += 0x0008;
    r16[ax] += 0x0008;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    yield* sub_1c433c();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[edi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[edi] += memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x20cecb, r32[edi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] -= 0x00d2;
    r16[cx] -= 0x0010;
    memoryASet16(ds, 0x20cec5, r16[cx]);
    push32(r32[edi]);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = pop32();
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 8;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000140;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c4148: // 0160:1c4148
    r16[cx] = memoryAGet16(ds, 0x224634);
    if (!(memoryAGet16(ds, 0x20cead) & 0xffff))
        { pc = 0x1c416e; break; }
  case 0x1c415a: // 0160:1c415a
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (!r8[al])
        { pc = 0x1c4169; break; }
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c4169: // 0160:1c4169
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c415a; break; }
    { pc = 0x1c41a0; break; }
  case 0x1c416e: // 0160:1c416e
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (!r8[al])
        { pc = 0x1c419d; break; }
    push32(r32[edi]);
    push32(r32[esi]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += 0x0029bb34;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] = pop32();
    r32[edi] = pop32();
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c419d: // 0160:1c419d
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c416e; break; }
  case 0x1c41a0: // 0160:1c41a0
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c4148; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c41a7() // 0160:1c41a7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20cead) & 0xffff)
        { pc = 0x1c42ef; break; }
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[esi] = 0x00224cd4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceab);
    r16[ax] <<= 8;
    r32[esi] += r32[eax];
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    if (memoryAGet16(ds, 0x20ceaf) != 0x0006)
        { pc = 0x1c41f0; break; }
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0003ebd4;
  case 0x1c41f0: // 0160:1c41f0
    r16[bx] -= 0x0080;
    r16[cx] -= 0x0080;
    r16[bx] >>>= 1;
    r16[cx] >>>= 1;
    r16[bx] += 0xfffc;
    r16[cx] += 0xfff8;
    r32[ebx] &= 0x0000001f;
    r32[ecx] &= 0x0000001f;
    memoryASet(ds, 0x20cebb, r8[bl]);
    memoryASet(ds, 0x20cebd, r8[cl]);
    r32[edi] += r32[ebx];
    r32[ecx] <<= 6;
    r32[ebx] = r32[ecx];
    r32[ecx] <<= 2;
    r32[ecx] += r32[ebx];
    r32[edi] += r32[ecx];
    push32(r32[edi]);
    r8[dl] = memoryAGet(ds, 0x20cebb);
    r8[dh] = memoryAGet(ds, 0x20cebd);
    r32[ebx] = 0x00000008;
  case 0x1c423a: // 0160:1c423a
    push32(r32[edi]);
    r32[ecx] = 0x00000008;
  case 0x1c4240: // 0160:1c4240
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c4253; break; }
    r8[al] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    memoryASet(ds, r32[esi] + 0x10, r8[al]);
    memoryASet(ds, r32[esi] + 0x11, r8[al]);
  case 0x1c4253: // 0160:1c4253
    r32[esi]++;
    r32[esi]++;
    r32[edi]++;
    r8[dl]++;
    r8[dl] &= 0x1f;
    if (r8[dl])
        { pc = 0x1c4262; break; }
    r32[edi] -= 0x00000020;
  case 0x1c4262: // 0160:1c4262
    if (--r32[ecx])
        { pc = 0x1c4240; break; }
    r8[dl] = memoryAGet(ds, 0x20cebb);
    r32[edi] = pop32();
    r32[edi] += 0x00000140;
    r8[dh]++;
    r8[dh] &= 0x1f;
    if (r8[dh])
        { pc = 0x1c4280; break; }
    r32[edi] -= 0x00002800;
  case 0x1c4280: // 0160:1c4280
    r32[esi] += 0x00000010;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c423a; break; }
    r32[esi] = 0x002254d4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceab);
    r16[ax] <<= 6;
    r32[esi] += r32[eax];
    r32[edi] = pop32();
    r8[dl] = memoryAGet(ds, 0x20cebb);
    r8[dh] = memoryAGet(ds, 0x20cebd);
    r32[ebx] = 0x00000008;
  case 0x1c42ab: // 0160:1c42ab
    push32(r32[edi]);
    r32[ecx] = 0x00000008;
  case 0x1c42b1: // 0160:1c42b1
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c42bb; break; }
    r8[al] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
  case 0x1c42bb: // 0160:1c42bb
    r32[esi]++;
    r32[edi]++;
    r8[dl]++;
    r8[dl] &= 0x1f;
    if (r8[dl])
        { pc = 0x1c42c9; break; }
    r32[edi] -= 0x00000020;
  case 0x1c42c9: // 0160:1c42c9
    if (--r32[ecx])
        { pc = 0x1c42b1; break; }
    r8[dl] = memoryAGet(ds, 0x20cebb);
    r32[edi] = pop32();
    r32[edi] += 0x00000140;
    r8[dh]++;
    r8[dh] &= 0x1f;
    if (r8[dh])
        { pc = 0x1c42e7; break; }
    r32[edi] -= 0x00002800;
  case 0x1c42e7: // 0160:1c42e7
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c42ab; break; }
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1c42ef: // 0160:1c42ef
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c42f0() // 0160:1c42f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += memoryAGet32(ds, 0x20b800);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005cc60;
    r32[ebx] = 0x00000060;
  case 0x1c4320: // 0160:1c4320
    r32[ecx] = 0x00000060;
  case 0x1c4325: // 0160:1c4325
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c4325; break; }
    r32[esi] += 0x000000e0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c4320; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c433c() // 0160:1c433c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[edi] = 0x000a9000;
    yield* sub_1c4361();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[edi] = 0x000a4800;
    yield* sub_1c4361();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[edi] = 0x000a0000;
    push32(r32[edi]);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = pop32();
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c43ed: // 0160:1c43ed
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    push32(r32[edx]);
    r8[al] = 0x04;
    r8[ah] >>>= 1;
    if (r8[ah] != 0x04)
        { pc = 0x1c43fe; break; }
    r8[ah] = 0x03;
  case 0x1c43fe: // 0160:1c43fe
    r16[dx] = 0x03ce;
    out16(r16[dx], r16[ax]);
    r32[edx] = pop32();
    r32[eax] = pop32();
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c4419: // 0160:1c4419
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c4420: // 0160:1c4420
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c4439; break; }
    if (memoryAGet(ds, r32[edi]) < 0x40)
        { pc = 0x1c4437; break; }
    if (memoryAGet(ds, r32[edi]) < 0x50)
        { pc = 0x1c4439; break; }
  case 0x1c4437: // 0160:1c4437
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c4439: // 0160:1c4439
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c4420; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c4419; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c4466; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c43ed; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c43ed; break; }
  case 0x1c4466: // 0160:1c4466
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c4361() // 0160:1c4361 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edi]);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[edi] = 0x002235f0;
    r32[edi] += r32[eax];
    r32[esi] = 0x00224bd4;
    r32[esi] += memoryAGet32(ds, r32[edi] + 0x4);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] >>>= 2;
    memoryASet16(ds, 0x224634, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, 0x224636, r16[ax]);
    r32[edi] = pop32();
    r16[ax] = r16[cx];
    r16[dx] = r16[cx];
    r16[ax] <<= 6;
    r16[dx] <<= 4;
    r16[ax] += r16[dx];
    r32[edi] += r32[eax];
    r16[ax] = r16[bx];
    r16[ax] >>>= 2;
    r32[edi] += r32[eax];
    memoryASet16(ds, 0x20cebd, r16[bx]);
    memoryASet32(ds, 0x20cedb, r32[edi]);
    memoryASet32(ds, 0x20cedf, r32[esi]);
    r32[ebx] = 0x00000050;
    r16[bx] -= memoryAGet16(ds, 0x224634);
    push(ds);
    es = pop();
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
    r16[cx] = memoryAGet16(ds, 0x20cebd);
    r16[cx] &= 0x0003;
    r8[ah] <<= r8[cl];
    memoryASet16(ds, 0x224638, 0x0004);
    r32[ecx] = 0;
  case 0x1c43ed: // 0160:1c43ed
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    push32(r32[edx]);
    r8[al] = 0x04;
    r8[ah] >>>= 1;
    if (r8[ah] != 0x04)
        { pc = 0x1c43fe; break; }
    r8[ah] = 0x03;
  case 0x1c43fe: // 0160:1c43fe
    r16[dx] = 0x03ce;
    out16(r16[dx], r16[ax]);
    r32[edx] = pop32();
    r32[eax] = pop32();
    r16[bp] = memoryAGet16(ds, 0x224636);
    r32[edi] = memoryAGet32(ds, 0x20cedb);
    r32[esi] = memoryAGet32(ds, 0x20cedf);
  case 0x1c4419: // 0160:1c4419
    r16[cx] = memoryAGet16(ds, 0x224634);
  case 0x1c4420: // 0160:1c4420
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi] += 0x00000004;
    if (!r8[al])
        { pc = 0x1c4439; break; }
    if (memoryAGet(ds, r32[edi]) < 0x40)
        { pc = 0x1c4437; break; }
    if (memoryAGet(ds, r32[edi]) < 0x50)
        { pc = 0x1c4439; break; }
  case 0x1c4437: // 0160:1c4437
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c4439: // 0160:1c4439
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c4420; break; }
    r32[edi] += r32[ebx];
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1c4419; break; }
    memoryASet16(ds, 0x224638, memoryAGet16(ds, 0x224638) - 1);
    if (!memoryAGet16(ds, 0x224638))
        { pc = 0x1c4466; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1c43ed; break; }
    r8[ah] = 0x01;
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    { pc = 0x1c43ed; break; }
  case 0x1c4466: // 0160:1c4466
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c446d() // 0160:1c446d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += memoryAGet32(ds, 0x20b800);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005a550;
    r32[ebx] = 0x00000060;
  case 0x1c449d: // 0160:1c449d
    r32[ecx] = 0x00000060;
  case 0x1c44a2: // 0160:1c44a2
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c44a2; break; }
    r32[esi] += 0x000000e0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c449d; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceaf);
    r16[ax] <<= 2;
    r32[edi] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    r32[esi] += memoryAGet32(ds, 0x20b800);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005cc60;
    r32[ebx] = 0x00000060;
  case 0x1c44de: // 0160:1c44de
    r32[ecx] = 0x00000060;
  case 0x1c44e3: // 0160:1c44e3
    r8[al] = memoryAGet(ds, r32[edi]);
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c44e3; break; }
    r32[esi] += 0x000000e0;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c44de; break; }
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005a550;
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005cc60;
    r32[ecx] = 0x00002400;
  case 0x1c4511: // 0160:1c4511
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c4511; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c451f() // 0160:1c451f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0;
    yield* sub_1c5300();
    r16[ax] = memoryAGet16(ds, 0x20ee63);
    memoryASet16(ds, 0x23c4f6, r16[ax]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r32[edi] = 0x0023f52c;
    r32[ecx] = 0x00052800;
    r32[edx] = 0;
  case 0x1c454b: // 0160:1c454b
    r8[al] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
  case 0x1c454f: // 0160:1c454f
    if (r8[bl] != memoryAGet(ds, r32[esi]))
        { pc = 0x1c455d; break; }
    r8[al]++;
    r32[esi]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1c456a; break; }
    if (r8[al] != 0xff)
        { pc = 0x1c454f; break; }
  case 0x1c455d: // 0160:1c455d
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[edx] += 0x00000002;
    if (!r32[edx])
        { pc = 0x1c4572; break; }
    { pc = 0x1c454b; break; }
  case 0x1c456a: // 0160:1c456a
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    memoryASet(ds, r32[edi], r8[al]);
    r32[edx] += 0x00000002;
  case 0x1c4572: // 0160:1c4572
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c4573() // 0160:1c4573 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r32[esi] = 0x0023f52c;
    r32[ebx] = 0x00052800;
  case 0x1c4589: // 0160:1c4589
    r32[ecx] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r8[cl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
  case 0x1c4591: // 0160:1c4591
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[ebx]--;
    if (!r32[ebx])
        { pc = 0x1c459b; break; }
    if (--r32[ecx])
        { pc = 0x1c4591; break; }
    { pc = 0x1c4589; break; }
  case 0x1c459b: // 0160:1c459b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c459c() // 0160:1c459c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    r32[eax] = 0x002231dc;
    memoryASet32(ds, 0x20ceef, r32[eax]);
    memoryASet32(ds, r32[eax], 0x00000000);
    r32[edi] = 0x002235f0;
    r32[ebx] = 0x00224bd4;
    r32[esi] = 0x001f0df0;
    yield* sub_1b5a2d();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001f0ef0;
    yield* sub_1b52a1();
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x000000a0;
    r8[al] = 0;
    yield* sub_1b5442();
    r32[eax] = 0x00000000;
  case 0x1c45f4: // 0160:1c45f4
    push32(r32[eax]);
    r32[esi] = 0x001f0f20;
    r32[edi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    r32[edx] = 0x001f0d78;
    r32[esi] = memoryAGet32(ds, r32[edx] + r32[eax]);
    r32[esi] += memoryAGet32(ds, 0x20b800);
    r32[edx] = 0x001f0f98;
    r32[ebp] = memoryAGet32(ds, r32[edx] + r32[eax]);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r32[ebx] = 0x00000020;
  case 0x1c4621: // 0160:1c4621
    memoryASet16(ds, 0x20ceb3, 0x0000);
    r32[ecx] = 0x00000020;
  case 0x1c462f: // 0160:1c462f
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xfc)
        { pc = 0x1c466d; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
    { pc = 0x1c46a7; break; }
  case 0x1c466d: // 0160:1c466d
    if (r8[al])
        { pc = 0x1c46a7; break; }
    push32(r32[esi]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0003ebd4;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r32[ebx] &= 0x0000001f;
    r32[esi] += r32[ebx];
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r32[ebx] &= 0x0000001f;
    r32[ebx] <<= 6;
    r32[ecx] = r32[ebx];
    r32[ebx] <<= 2;
    r32[ebx] += r32[ecx];
    r32[esi] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[esi]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esi] = pop32();
  case 0x1c46a7: // 0160:1c46a7
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet(ss, r32[ebp], r8[al]);
    r32[ebp]++;
    r32[edi]++;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0003);
    r32[esi] += 0x00000003;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c462f; break; }
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + 0x0003);
    r32[ebp] += 0x00000120;
    r32[edi] += 0x00000120;
    r32[esi] += 0x00000360;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c4621; break; }
    r32[eax] = pop32();
    r32[eax] += 0x00000004;
    if (r32[eax] != 0x00000078)
        { pc = 0x1c45f4; break; }
    r32[edi] = 0x000a0000;
    yield* sub_1b5267();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    if (signed16(memoryAGet16(ds, 0x20ee61)) < signed16(0x001e))
        { pc = 0x1c473b; break; }
    memoryASet16(ds, 0x20ee61, 0x0000);
  case 0x1c473b: // 0160:1c473b
    yield* sub_1b4f0e();
    r16[ax] = memoryAGet16(ds, 0x22465a);
    memoryASet16(ds, 0x20ee6b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x22465c);
    memoryASet16(ds, 0x20ee6d, r16[ax]);
    r8[al] = memoryAGet(ds, 0x30b0a9);
    memoryASet(ds, 0x20ee6f, r8[al]);
    if (!(memoryAGet16(ds, 0x20d80d) & 0xffff))
        { pc = 0x1c4777; break; }
    r16[ax] = 0;
    memoryASet16(ds, 0x20d80d, r16[ax]);
    r32[esp] += 4; return;
  case 0x1c4777: // 0160:1c4777
    yield* sub_1b5096();
    yield* sub_1b531f();
    yield* sub_1bb00d();
    if (!(memoryAGet16(ds, 0x22465a) & 0xffff))
        { pc = 0x1c4798; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1c4798: // 0160:1c4798
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    r16[ax] += 0x0002;
    r16[bx] += 0x0002;
    memoryASet16(ds, 0x20ec3d, r16[ax]);
    memoryASet16(ds, 0x20ec3f, r16[bx]);
    yield* sub_1c4984();
    r16[ax] = 0x00ac;
    r16[bx] = 0x009c;
    r16[cx] = memoryAGet16(ds, 0x20ee61);
  case 0x1c47ce: // 0160:1c47ce
    if (r16s[cx] < signed16(0x0006))
        { pc = 0x1c47de; break; }
    r16[bx] += 0x0028;
    r16[cx] -= 0x0006;
    { pc = 0x1c47ce; break; }
  case 0x1c47de: // 0160:1c47de
    r16[cx] <<= 3;
    r16[dx] = r16[cx];
    r16[dx] <<= 2;
    r16[cx] += r16[dx];
    r16[ax] += r16[cx];
    r16[cx] = 0x0014;
    r16[dx] = 0;
    yield* sub_1bd7dd();
    r32[esi] = 0x001f0f08;
    r8[al] = 0xc0;
    r8[bl] = 0x4b;
    yield* sub_1b60a7();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c4927; break; }
    r16[cx] = 0x0000;
    r16[dx] = 0x0000;
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    if (r16s[bx] <= signed16(0x0078))
        { pc = 0x1c4862; break; }
    if (r16s[bx] >= signed16(0x0080))
        { pc = 0x1c4862; break; }
    if (r16s[ax] < signed16(0x0008))
        { pc = 0x1c484d; break; }
    if (r16s[ax] > signed16(0x0020))
        { pc = 0x1c484d; break; }
    r16[ax] = 0x00ff;
    { pc = 0x1c4983; break; }
  case 0x1c484d: // 0160:1c484d
    if (r16s[ax] < signed16(0x0120))
        { pc = 0x1c4862; break; }
    if (r16s[ax] > signed16(0x0138))
        { pc = 0x1c4862; break; }
    r16[ax] = 0x00fe;
    { pc = 0x1c4983; break; }
  case 0x1c4862: // 0160:1c4862
    if (r16s[ax] < signed16(0x002d))
        { pc = 0x1c4927; break; }
    if (r16s[ax] < signed16(0x004d))
        { pc = 0x1c48cc; break; }
    if (r16s[ax] < signed16(0x0055))
        { pc = 0x1c4927; break; }
    r16[cx]++;
    if (r16s[ax] < signed16(0x0075))
        { pc = 0x1c48cc; break; }
    if (r16s[ax] < signed16(0x007d))
        { pc = 0x1c4927; break; }
    r16[cx]++;
    if (r16s[ax] < signed16(0x009d))
        { pc = 0x1c48cc; break; }
    if (r16s[ax] < signed16(0x00a5))
        { pc = 0x1c4927; break; }
    r16[cx]++;
    if (r16s[ax] < signed16(0x00c5))
        { pc = 0x1c48cc; break; }
    if (r16s[ax] < signed16(0x00cd))
        { pc = 0x1c4927; break; }
    r16[cx]++;
    if (r16s[ax] < signed16(0x00ed))
        { pc = 0x1c48cc; break; }
    if (r16s[ax] < signed16(0x00f5))
        { pc = 0x1c4927; break; }
    r16[cx]++;
    if (r16s[ax] >= signed16(0x0115))
        { pc = 0x1c4927; break; }
  case 0x1c48cc: // 0160:1c48cc
    if (r16s[bx] < signed16(0x001d))
        { pc = 0x1c4927; break; }
    if (r16s[bx] < signed16(0x003d))
        { pc = 0x1c491d; break; }
    if (r16s[bx] < signed16(0x0045))
        { pc = 0x1c4927; break; }
    r16[dx] += 0x0006;
    if (r16s[bx] < signed16(0x0065))
        { pc = 0x1c491d; break; }
    if (r16s[bx] < signed16(0x006d))
        { pc = 0x1c4927; break; }
    r16[dx] += 0x0006;
    if (r16s[bx] < signed16(0x008d))
        { pc = 0x1c491d; break; }
    if (r16s[bx] < signed16(0x0095))
        { pc = 0x1c4927; break; }
    r16[dx] += 0x0006;
    if (r16s[bx] < signed16(0x00b5))
        { pc = 0x1c491d; break; }
    if (r16s[bx] < signed16(0x00bd))
        { pc = 0x1c4927; break; }
    r16[dx] += 0x0006;
    if (r16s[bx] >= signed16(0x00dd))
        { pc = 0x1c4927; break; }
  case 0x1c491d: // 0160:1c491d
    r16[cx] += r16[dx];
    memoryASet16(ds, 0x20ee61, r16[cx]);
  case 0x1c4927: // 0160:1c4927
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20e837, r8[al]);
    if (!(memoryAGet16(ds, 0x22465c) & 0xffff))
        { pc = 0x1c4947; break; }
    if (!(memoryAGet16(ds, 0x20ee6d) & 0xffff))
        { pc = 0x1c4980; break; }
  case 0x1c4947: // 0160:1c4947
    r8[al] = memoryAGet(ds, 0x30b0a9);
    if (!r8[al])
        { pc = 0x1c4959; break; }
    if (!(memoryAGet(ds, 0x20ee6f) & 0xff))
        { pc = 0x1c4980; break; }
  case 0x1c4959: // 0160:1c4959
    r16[ax] = memoryAGet16(ds, 0x22465a);
    memoryASet16(ds, 0x20ee6b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x22465c);
    memoryASet16(ds, 0x20ee6d, r16[ax]);
    r8[al] = memoryAGet(ds, 0x30b0a9);
    memoryASet(ds, 0x20ee6f, r8[al]);
    { pc = 0x1c4777; break; }
  case 0x1c4980: // 0160:1c4980
    r16[ax] = 0;
  case 0x1c4983: // 0160:1c4983
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c4984() // 0160:1c4984 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c4984; break; }
  case 0x1bafc3: // 0160:1bafc3
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    r16[ax] += 0x0080;
    r16[bx] += 0x0080;
    r16[dx] = 0;
    { pc = 0x1bd7dd; break; }
    // gap 10236 bytes // gap 10236 bytes
  case 0x1bd7dd: // 0160:1bd7dd
    r16[bp] = r16[ax];
    r32[esi] = 0x002231f0;
    r16[ax] = memoryAGet16(ds, 0x2231d0);
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] += r32[eax];
    memoryASet16(ds, r32[esi], r16[cx]);
    if (r16[dx] != 0x0008)
        { pc = 0x1bd807; break; }
    r16[bx] += 0x0004;
    r16[bp] += 0x0004;
  case 0x1bd807: // 0160:1bd807
    r16[bp] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x2, r16[bp]);
    r16[bx] -= 0x0080;
    memoryASet16(ds, r32[esi] + 0x4, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    memoryASet16(ds, 0x2231d0, memoryAGet16(ds, 0x2231d0) + 1);
    r32[esp] += 4; return;
    // gap 29023 bytes // gap 29023 bytes
  case 0x1c4984: // 0160:1c4984
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c4995; break; }
    memoryASet16(ds, 0x224656, memoryAGet16(ds, 0x224656) - 0x0002);
  case 0x1c4995: // 0160:1c4995
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c49a6; break; }
    memoryASet16(ds, 0x224656, memoryAGet16(ds, 0x224656) + 0x0002);
  case 0x1c49a6: // 0160:1c49a6
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1c49b7; break; }
    memoryASet16(ds, 0x224658, memoryAGet16(ds, 0x224658) - 0x0002);
  case 0x1c49b7: // 0160:1c49b7
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1c49c8; break; }
    memoryASet16(ds, 0x224658, memoryAGet16(ds, 0x224658) + 0x0002);
  case 0x1c49c8: // 0160:1c49c8
    yield* sub_1bafe1();
    r16[cx] = 0x0000;
    { pc = 0x1bafc3; break; }
    return;
  }
}
function* sub_1c49d6() // 0160:1c49d6 +long
{
    r32[esp] -= 4;
    yield* sub_1c4a09();
    memoryASet16(ds, 0x2231d0, 0x0000);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0000);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x224644, 0x0000);
    r32[esp] += 4;
}
function* sub_1c4a09() // 0160:1c4a09 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1b4eda();
    yield* sub_1c4e8e();
    r16[ax] = 0;
    memoryASet16(ds, 0x20ee71, r16[ax]);
    memoryASet16(ds, 0x20ee73, r16[ax]);
    memoryASet16(ds, 0x224656, 0x0064);
    memoryASet16(ds, 0x224658, 0x0064);
    yield* sub_1bafe1();
    yield* sub_1ac7de();
    yield* sub_1b4f0e();
    yield* sub_1c51d6();
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20ee63, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x22465a);
    memoryASet16(ds, 0x20ee6b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x22465c);
    memoryASet16(ds, 0x20ee6d, r16[ax]);
    r8[al] = memoryAGet(ds, 0x30b0a9);
    memoryASet(ds, 0x20ee6f, r8[al]);
    memoryASet16(ds, 0x20d7c1, 0x0000);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    r32[eax] = 0;
    memoryASet32(ds, 0x20d773, r32[eax]);
    memoryASet32(ds, 0x20d777, r32[eax]);
    memoryASet(ds, 0x20d773, 0x01);
  case 0x1c4a98: // 0160:1c4a98
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    memoryASet16(ds, 0x20ee51, r16[ax]);
    push32(r32[eax]);
    yield* sub_1a8d10();
    memoryASet32(ds, 0x20c80c, 0x00000000);
    if (!(memoryAGet16(ds, 0x22465c) & 0xffff))
        { pc = 0x1c4aca; break; }
    if (!(memoryAGet16(ds, 0x20ee6d) & 0xffff))
        { pc = 0x1c4adc; break; }
  case 0x1c4aca: // 0160:1c4aca
    r8[al] = memoryAGet(ds, 0x30b0a9);
    if (!r8[al])
        { pc = 0x1c4ae2; break; }
    if (memoryAGet(ds, 0x20ee6f) & 0xff)
        { pc = 0x1c4ae2; break; }
  case 0x1c4adc: // 0160:1c4adc
    r32[eax] = pop32();
    { pc = 0x1c4b97; break; }
  case 0x1c4ae2: // 0160:1c4ae2
    r16[ax] = memoryAGet16(ds, 0x22465a);
    memoryASet16(ds, 0x20ee6b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x22465c);
    memoryASet16(ds, 0x20ee6d, r16[ax]);
    r8[al] = memoryAGet(ds, 0x30b0a9);
    memoryASet(ds, 0x20ee6f, r8[al]);
    yield* sub_1bdf30();
    yield* sub_1c4ba6();
    if (!r16[ax])
        { pc = 0x1c4b1d; break; }
    r32[eax] = pop32();
    { pc = 0x1c4b97; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c4b1d: // 0160:1c4b1d
    yield* sub_1a8c90();
    r32[eax] = pop32();
  case 0x1c4b23: // 0160:1c4b23
    r16[bx] = memoryAGet16(ds, 0x20ee4f);
    r16[bx] -= r16[ax];
    if (!r16[bx])
        { pc = 0x1c4b6c; break; }
    r16[bx]--;
    if (!r16[bx])
        { pc = 0x1c4b6c; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    push32(r32[eax]);
    memoryASet16(ds, 0x20ee59, 0x0001);
    r32[ecx] = 0;
    r16[cx] = r16[bx];
  case 0x1c4b50: // 0160:1c4b50
    push32(r32[ecx]);
    yield* sub_1c4ba6();
    if (!r16[ax])
        { pc = 0x1c4b66; break; }
    r32[ecx] = pop32();
    r32[eax] = pop32();
    { pc = 0x1c4b97; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c4b66: // 0160:1c4b66
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1c4b50; break; }
    r32[eax] = pop32();
    { pc = 0x1c4b23; break; }
  case 0x1c4b6c: // 0160:1c4b6c
    r16[ax] = memoryAGet16(ds, 0x20ee4f);
    r16[ax] -= memoryAGet16(ds, 0x20ee51);
    memoryASet16(ds, 0x20ee57, r16[ax]);
    memoryASet16(ds, 0x20ee59, 0x0000);
    if (memoryAGet16(ds, 0x20ee5b) == 0x0001)
        { pc = 0x1c4b97; break; }
    { pc = 0x1c4a98; break; }
  case 0x1c4b97: // 0160:1c4b97
    yield* sub_1c51d6();
    r16[ax] = memoryAGet16(ds, 0x20ee63);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c4ba6() // 0160:1c4ba6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1a8cae();
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    memoryASet16(ds, 0x20ec3d, r16[ax]);
    memoryASet16(ds, 0x20ec3f, r16[bx]);
    yield* sub_1bb00d();
    if (!(memoryAGet16(ds, 0x22465a) & 0xffff))
        { pc = 0x1c4bdc; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1c4bdc: // 0160:1c4bdc
    yield* sub_1c51d6();
    r16[ax] = memoryAGet16(ds, 0x20ee63);
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, 0x20d7f1, 0x0000);
    memoryASet16(ds, 0x20d7f3, 0x0000);
    memoryASet16(ds, 0x20d7b3, 0x0020);
    yield* sub_1b1ef1();
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[ax] -= memoryAGet16(ds, 0x224656);
    if (r16s[ax] >= 0)
        { pc = 0x1c4c25; break; }
    if (r16[ax] > 0xffe0)
        { pc = 0x1c4c2f; break; }
    r16[ax] = 0xffe1;
    { pc = 0x1c4c2f; break; }
  case 0x1c4c25: // 0160:1c4c25
    if (r16[ax] < 0x0020)
        { pc = 0x1c4c2f; break; }
    r16[ax] = 0x001f;
  case 0x1c4c2f: // 0160:1c4c2f
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) - r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ec3f);
    r16[ax] -= memoryAGet16(ds, 0x224658);
    if (r16s[ax] >= 0)
        { pc = 0x1c4c51; break; }
    if (r16[ax] > 0xffe0)
        { pc = 0x1c4c5b; break; }
    r16[ax] = 0xffe1;
    { pc = 0x1c4c5b; break; }
  case 0x1c4c51: // 0160:1c4c51
    if (r16[ax] < 0x0020)
        { pc = 0x1c4c5b; break; }
    r16[ax] = 0x001f;
  case 0x1c4c5b: // 0160:1c4c5b
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) - r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x08;
    if (!r8[al])
        { pc = 0x1c4c82; break; }
    if (signed16(memoryAGet16(ds, 0x20cf4f)) > signed16(0x02e0))
        { pc = 0x1c4c82; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) + 0x0004);
  case 0x1c4c82: // 0160:1c4c82
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x04;
    if (!r8[al])
        { pc = 0x1c4ca1; break; }
    if (memoryAGet16(ds, 0x20cf4f) == 0x0020)
        { pc = 0x1c4ca1; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) - 0x0004);
  case 0x1c4ca1: // 0160:1c4ca1
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x02;
    if (!r8[al])
        { pc = 0x1c4cc1; break; }
    if (signed16(memoryAGet16(ds, 0x20cf61)) > signed16(0x02e0))
        { pc = 0x1c4cc1; break; }
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) + 0x0004);
  case 0x1c4cc1: // 0160:1c4cc1
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x01;
    if (!r8[al])
        { pc = 0x1c4ce0; break; }
    if (memoryAGet16(ds, 0x20cf61) == 0x0020)
        { pc = 0x1c4ce0; break; }
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) - 0x0004);
  case 0x1c4ce0: // 0160:1c4ce0
    if (signed16(memoryAGet16(ds, 0x20cf4f)) < signed16(0x02e0))
        { pc = 0x1c4cf8; break; }
    memoryASet16(ds, 0x20cf4f, 0x02e0);
  case 0x1c4cf8: // 0160:1c4cf8
    if (signed16(memoryAGet16(ds, 0x20cf4f)) > signed16(0x0020))
        { pc = 0x1c4d0f; break; }
    memoryASet16(ds, 0x20cf4f, 0x0020);
  case 0x1c4d0f: // 0160:1c4d0f
    if (signed16(memoryAGet16(ds, 0x20cf61)) < signed16(0x02e0))
        { pc = 0x1c4d27; break; }
    memoryASet16(ds, 0x20cf61, 0x02e0);
  case 0x1c4d27: // 0160:1c4d27
    if (signed16(memoryAGet16(ds, 0x20cf61)) > signed16(0x0020))
        { pc = 0x1c4d3e; break; }
    memoryASet16(ds, 0x20cf61, 0x0020);
  case 0x1c4d3e: // 0160:1c4d3e
    r16[ax] = memoryAGet16(ds, 0x20ec3d);
    r16[bx] = memoryAGet16(ds, 0x20ec3f);
    memoryASet16(ds, 0x224656, r16[ax]);
    memoryASet16(ds, 0x224658, r16[bx]);
    yield* sub_1bafe1();
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    r16[bx] = memoryAGet16(ds, 0x20cf25);
    memoryASet16(ds, 0x20c810, r16[ax]);
    memoryASet16(ds, 0x20c812, r16[bx]);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r32[ebx] = memoryAGet32(ds, 0x1f1c3c);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[ax] &= 0xffe0;
    r16[bx] &= 0xffe0;
    r16[ax] += 0x007f;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1c4dbf; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1c4df1; break; }
  case 0x1c4dbf: // 0160:1c4dbf
    r16[bx] += 0x007f;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1c4dd9; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1c4df1; break; }
  case 0x1c4dd9: // 0160:1c4dd9
    if (r16[bx] >= 0x0190)
        { pc = 0x1c4df1; break; }
    r16[cx] = 0x0000;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
  case 0x1c4df1: // 0160:1c4df1
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] += 0x0058;
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] += 0x0060;
    r16[cx] = 0x0001;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c4e53; break; }
    yield* sub_1c51d6();
    r16[ax] = memoryAGet16(ds, 0x20ee61);
    if (r16[ax])
        { pc = 0x1c4e50; break; }
    r32[esi] = 0x00232cdc;
    r32[ecx] = 0x00000271;
  case 0x1c4e36: // 0160:1c4e36
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax])
        { pc = 0x1c4e43; break; }
    memoryASet16(ds, r32[esi], 0x0005);
  case 0x1c4e43: // 0160:1c4e43
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1c4e36; break; }
    yield* sub_1c51d6();
    r16[ax] = 0;
  case 0x1c4e50: // 0160:1c4e50
    memoryASet16(ds, r32[esi], r16[ax]);
  case 0x1c4e53: // 0160:1c4e53
    yield* sub_1c51d6();
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet16(ds, 0x20ee63, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee61);
    memoryASet16(ds, r32[esi], r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20c810);
    r16[bx] = memoryAGet16(ds, 0x20c812);
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    yield* sub_1ac75e();
    r16[ax] = 0x0000;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c4e8e() // 0160:1c4e8e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0x00007800;
    r32[edx] = 0x0025e92c;
    memoryASet32(ds, 0x2eeb88, r32[ecx]);
    memoryASet32(ds, 0x2eeb8c, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000314;
    r32[ebp] = 0x00000780;
  case 0x1c4eb5: // 0160:1c4eb5
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    r8[bl] = memoryAGet(ds, r32[esi] + 0x9);
    r8[bh] = memoryAGet(ds, r32[esi] + 0xd);
    r32[ebx] <<= 16;
    r8[bl] = memoryAGet(ds, r32[esi] + 0x1);
    r8[bh] = memoryAGet(ds, r32[esi] + 0x5);
    r8[cl] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ch] = memoryAGet(ds, r32[esi] + 0xe);
    r32[ecx] <<= 16;
    r8[cl] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ch] = memoryAGet(ds, r32[esi] + 0x6);
    r8[dl] = memoryAGet(ds, r32[esi] + 0xb);
    r8[dh] = memoryAGet(ds, r32[esi] + 0xf);
    r32[edx] <<= 16;
    r8[dl] = memoryAGet(ds, r32[esi] + 0x3);
    r8[dh] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[esi], r32[eax]);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[esi] + 0x8, r32[ecx]);
    memoryASet32(ds, r32[esi] + 0xc, r32[edx]);
    r32[esi] += 0x00000010;
    r32[ebp]--;
    if (r32[ebp])
        { pc = 0x1c4eb5; break; }
    r32[esi] = memoryAGet32(ds, 0x2eeb8c);
    r32[esi] += 0x00000314;
    r32[edi] = 0x0030acec;
    r32[edx] = 0x002eecec;
    memoryASet32(ds, 0x2eeb68, 0x00000027);
  case 0x1c4f21: // 0160:1c4f21
    memoryASet32(ds, 0x2eeb64, 0x0000000a);
  case 0x1c4f2b: // 0160:1c4f2b
    r16[bx] = 0x00ff;
    memoryASet32(ds, 0x2eeb60, 0x00000004);
  case 0x1c4f39: // 0160:1c4f39
    memoryASet32(ds, 0x2eeb58, r32[esi]);
    memoryASet32(ds, 0x2eeb6c, r32[edx]);
    memoryASet32(ds, 0x2eeb5c, 0x00000020);
  case 0x1c4f4f: // 0160:1c4f4f
    r32[ecx] = 0x00000004;
  case 0x1c4f54: // 0160:1c4f54
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c4f60; break; }
    r8[al] = 0xff;
  case 0x1c4f60: // 0160:1c4f60
    r8[al] = ~r8[al];
    r16[ax] = ror16(r16[ax], 0x0001);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c4f54; break; }
    r32[esi] += 0x0000000c;
    r32[ecx] = 0x00000004;
  case 0x1c4f70: // 0160:1c4f70
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c4f7c; break; }
    r8[al] = 0xff;
  case 0x1c4f7c: // 0160:1c4f7c
    r8[al] = ~r8[al];
    r16[ax] = ror16(r16[ax], 0x0001);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c4f70; break; }
    memoryASet(ds, r32[edx], r8[ah]);
    r8[bl] &= r8[ah];
    r8[bh] |= r8[ah];
    r32[edx]++;
    r32[esi] += 0x0000012c;
    memoryASet32(ds, 0x2eeb5c, memoryAGet32(ds, 0x2eeb5c) - 1);
    if (memoryAGet32(ds, 0x2eeb5c))
        { pc = 0x1c4f4f; break; }
    r32[esi] = memoryAGet32(ds, 0x2eeb58);
    r32[edx] = memoryAGet32(ds, 0x2eeb6c);
    r32[edx] += 0x00000020;
    r32[esi] += 0x00000004;
    memoryASet32(ds, 0x2eeb60, memoryAGet32(ds, 0x2eeb60) - 1);
    if (memoryAGet32(ds, 0x2eeb60))
        { pc = 0x1c4f39; break; }
    r8[al] = 0;
    if (r8[bl] != 0xff)
        { pc = 0x1c4fbc; break; }
    r8[al] = 0x02;
  case 0x1c4fbc: // 0160:1c4fbc
    if (r8[bh])
        { pc = 0x1c4fc2; break; }
    r8[al] = 0x01;
  case 0x1c4fc2: // 0160:1c4fc2
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi] += 0x00000010;
    memoryASet32(ds, 0x2eeb64, memoryAGet32(ds, 0x2eeb64) - 1);
    if (memoryAGet32(ds, 0x2eeb64))
        { pc = 0x1c4f2b; break; }
    r32[esi] += 0x000026c0;
    memoryASet32(ds, 0x2eeb68, memoryAGet32(ds, 0x2eeb68) - 1);
    if (memoryAGet32(ds, 0x2eeb68))
        { pc = 0x1c4f21; break; }
    r32[edx] = memoryAGet32(ds, 0x20b800);
    memoryASet32(ds, 0x2eeb8c, r32[edx]);
    r32[ecx] = 0x000004e6;
    memoryASet32(ds, 0x2eeb90, r32[ecx]);
    r32[edx] = 0x00232cd8;
    memoryASet32(ds, 0x2eeb94, r32[edx]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx] + 0x1);
    memoryASet32(ds, 0x1f1cb0, r32[eax]);
    memoryASet16(ds, 0x20cef3, r16[ax]);
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[edx] + 0x3);
    memoryASet32(ds, 0x1f1cb4, r32[ebx]);
    memoryASet16(ds, 0x20cef7, r16[bx]);
    mul8(r8[bl]);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeba4, r32[eax]);
    r32[eax] += memoryAGet32(ds, 0x2eeb94);
    r32[eax] += 0x00000004;
    memoryASet32(ds, 0x2eeba0, r32[eax]);
    r32[ecx] = 0;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cef7);
    r16[cx] = memoryAGet16(ds, 0x20cef3);
    r32[edx] = 0;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    memoryASet32(ds, 0x20cefb, r32[eax]);
    yield* sub_1c50ff();
    memoryASet16(ds, 0x20ee5d, 0x0001);
    yield* sub_1a8499();
    memoryASet16(ds, 0x20ee5d, 0x0000);
    r32[edx] = 0x0025e92c;
    memoryASet32(ds, 0x2eeb8c, r32[edx]);
    r32[eax] = 0;
    memoryASet(ds, 0x1f1c44, r8[al]);
    yield* sub_1b29b6();
    r16[ax] = memoryAGet16(ds, 0x20cef9);
    memoryASet16(ds, 0x20cef5, r16[ax]);
    memoryASet16(ds, 0x20cf3d, 0x0001);
    r32[eax] = 0;
    memoryASet32(ds, 0x20d773, r32[eax]);
    memoryASet32(ds, 0x20d777, r32[eax]);
    memoryASet(ds, 0x20d773, 0x01);
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf85, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    memoryASet16(ds, 0x20d881, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    memoryASet16(ds, 0x20d883, r16[ax]);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d885, r16[ax]);
    memoryASet16(ds, 0x20d887, r16[ax]);
    r8[al] = 0x00;
    memoryASet(ds, 0x20d88b, r8[al]);
    memoryASet(ds, 0x20d88d, r8[al]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c50ff() // 0160:1c50ff +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c50ff; break; }
  case 0x1b0da2: // 0160:1b0da2
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, 0x20c85f);
  case 0x1b0dab: // 0160:1b0dab
    r16[dx] = memoryAGet16(ds, r32[esi]);
    if (r16[dx] == 0xffff)
        { pc = 0x1b0dfc; break; }
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] <<= 1;
    r32[ebx] += r32[edx];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[edx] <<= 9;
    r32[ecx] = r32[edx];
    r32[edx] <<= 2;
    r32[edx] += r32[ecx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[edi], r32[ebx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] <<= 3;
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x00000008;
    memoryASet32(ds, 0x20c85f, memoryAGet32(ds, 0x20c85f) + 0x00000008);
    { pc = 0x1b0dab; break; }
  case 0x1b0dfc: // 0160:1b0dfc
    r32[esp] += 4; return;
    // gap 82690 bytes // gap 82690 bytes
  case 0x1c50ff: // 0160:1c50ff
    r32[esi] = 0x0020b80c;
    memoryASet32(ds, 0x20c85f, r32[esi]);
    r32[esi] = 0x001f1010;
    memoryASet32(ds, 0x20cecb, r32[esi]);
    r32[edx] = memoryAGet32(ds, r32[esi]);
    yield* sub_1aa484();
    r32[edi] = 0x002c5658;
    r16[ax] = 0;
    yield* sub_1aa553();
    r32[ecx] = 0x00014314;
    r32[edx] = 0x002c5344;
    memoryASet32(ds, 0x2eebb8, r32[ecx]);
    memoryASet32(ds, 0x2eebbc, r32[edx]);
    r32[esi] = memoryAGet32(ds, 0x2eebbc);
    r32[esi] += 0x00000314;
    r32[edi] = r32[esi];
    r32[esi] += 0x00012ac0;
    r32[edi] += 0x00012c00;
    r32[edx] = 0x000000f0;
  case 0x1c515e: // 0160:1c515e
    r32[ecx] = 0x00000014;
  case 0x1c5163: // 0160:1c5163
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x50, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0xa0, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xf0, r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c5163; break; }
    r32[edi] -= 0x00000190;
    r32[esi] -= 0x00000280;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c515e; break; }
    r32[esi] = memoryAGet32(ds, 0x20cecb);
    r32[eax] = 0x002c5798;
    { pc = 0x1b0da2; break; }
    return;
  }
}
function* sub_1c51d6() // 0160:1c51d6 +long
{
    r32[esp] -= 4;
    r32[esi] = 0x00232cdc;
    r32[eax] = 0;
    r32[ebx] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[ax] &= 0xffe0;
    r16[bx] &= 0xffe0;
    r16[ax] >>>= 4;
    r16[bx] >>>= 4;
    r32[esi] += r32[ebx];
    r16[bx] = r16[ax];
    r16[ax] <<= 3;
    r16[cx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[cx];
    r16[ax] += r16[bx];
    r32[esi] += r32[eax];
    r32[esp] += 4;
}
function* sub_1c52c2() // 0160:1c52c2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c52c2; break; }
  case 0x1bd849: // 0160:1bd849
    push32(r32[edx]);
    push32(r32[eax]);
    r16[dx] = 0x03ce;
    r16[ax] = memoryAGet16(ds, 0x22463e);
    r8[ah] = r8[al];
    r8[al] = 0x05;
    out16(r16[dx], r16[ax]);
    r32[eax] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4; return;
    // gap 31332 bytes // gap 31332 bytes
  case 0x1c52c2: // 0160:1c52c2
    memoryASet16(ds, 0x1f1cb8, 0x9000);
    yield* sub_1a840e();
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a0000;
    r32[ecx] = 0x00004600;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    r32[ecx] = 0x00004600;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    { pc = 0x1bd849; break; }
    return;
  }
}
function* sub_1c52fc() // 0160:1c52fc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c52fc; break; }
  case 0x1c1db4: // 0160:1c1db4
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e16; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e16; break; }
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, 0x224670, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
  case 0x1c1e16: // 0160:1c1e16
    r32[edx] = memoryAGet32(ds, 0x224674);
    r32[ecx] = memoryAGet32(ds, 0x224670);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (memoryAGet32(ds, 0x224670) != r32[eax])
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1c1e87();
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e65; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e65; break; }
    yield* sub_1c4573();
  case 0x1c1e65: // 0160:1c1e65
    r32[esp] += 4; return;
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 13178 bytes // gap 13178 bytes
  case 0x1c5215: // 0160:1c5215
    memoryASet16(ds, 0x20d80d, r16[ax]);
    if (r16[ax])
        { pc = 0x1c524a; break; }
    r16[ax] = 0x0000;
    r16[bx] = 0x0000;
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r16[ax] += 0x0020;
    r16[bx] += 0x0020;
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    memoryASet16(ds, 0x20cf61, r16[bx]);
  case 0x1c524a: // 0160:1c524a
    memoryASet16(ds, 0x20d7f5, 0x0000);
    memoryASet(ds, 0x232cd8, 0x00);
    memoryASet(ds, 0x232cda, 0x00);
    memoryASet(ds, 0x232cd9, 0x19);
    memoryASet(ds, 0x232cdb, 0x19);
    r32[edi] = 0x00232cdc;
    r32[esi] = 0x0023c4fb;
    r32[ecx] = 0x00000271;
  case 0x1c527e: // 0160:1c527e
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c527e; break; }
  case 0x1c528c: // 0160:1c528c
    yield* sub_1c459c();
    if (r16[ax])
        { pc = 0x1c529d; break; }
    yield* sub_1c49d6();
    { pc = 0x1c528c; break; }
  case 0x1c529d: // 0160:1c529d
    if (r16[ax] == 0x00ff)
        { pc = 0x1c52c1; break; }
    r32[esi] = 0x00232cdc;
    r32[edi] = 0x0023c4fb;
    r32[ecx] = 0x00000271;
  case 0x1c52b6: // 0160:1c52b6
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c52b6; break; }
  case 0x1c52c1: // 0160:1c52c1
    r32[esp] += 4; return;
    // gap 58 bytes // gap 58 bytes
  case 0x1c52fc: // 0160:1c52fc
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20ee65, r16[ax]);
    memoryASet16(ds, 0x20ee63, 0xffff);
    r32[esi] = 0x0023c76c;
    r32[ecx] = 0x00000090;
  case 0x1c5319: // 0160:1c5319
    r32[eax] = memoryAGet32(ds, r32[esi]);
    if (r32[eax])
        { pc = 0x1c5329; break; }
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c5319; break; }
    { pc = 0x1c5584; break; }
  case 0x1c5329: // 0160:1c5329
    r32[esi] = 0x0023c4fb;
    r32[ebx] = 0x00000019;
  case 0x1c5333: // 0160:1c5333
    r32[ecx] = 0x00000019;
  case 0x1c5338: // 0160:1c5338
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c5349; break; }
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c5338; break; }
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c5333; break; }
    { pc = 0x1c55d2; break; }
  case 0x1c5349: // 0160:1c5349
    r16[ax] = 0x0019;
    r16[ax] -= r16[bx];
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r16[bx] = r16[ax];
    r16[ax] = 0x0019;
    r16[ax] -= r16[cx];
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[cx] = r16[ax];
    r16[dx] = 0x0000;
  case 0x1c536d: // 0160:1c536d
    r16[dx]++;
    r32[esi]--;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1c55cc; break; }
  case 0x1c537b: // 0160:1c537b
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c5456; break; }
    if (r8[al] == 0x01)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x13)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x14)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x15)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x07)
        { pc = 0x1c543b; break; }
    if (r8[al] == 0x03)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c5408; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c53aa: // 0160:1c53aa
    r16[dx]++;
    r32[esi] += 0x00000019;
    r16[bx]++;
    if (r16[bx] == 0x0018)
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x03)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x02)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x16)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x17)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x18)
        { pc = 0x1c53aa; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c53da: // 0160:1c53da
    r16[dx]++;
    r32[esi]++;
    r16[cx]++;
    if (r16[cx] == 0x0018)
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x01)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x13)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x14)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x15)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x03)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c53aa; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c5408: // 0160:1c5408
    r16[dx]++;
    r32[esi] -= 0x00000019;
    r16[bx]--;
    if (!r16[bx])
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x02)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x16)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x17)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x18)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x03)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c536d; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c543b: // 0160:1c543b
    r16[dx]++;
    r32[esi]--;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x06)
        { pc = 0x1c543b; break; }
    { pc = 0x1c537b; break; }
  case 0x1c5456: // 0160:1c5456
    memoryASet16(ds, 0x20ee63, r16[dx]);
    if (r16s[dx] <= signed16(0x001d))
        { pc = 0x1c55b1; break; }
    if (r16s[dx] >= signed16(0x00af))
        { pc = 0x1c559c; break; }
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    r16[ax] = 0x0003;
    yield* sub_1c5695();
    memoryASet16(ds, 0x20d7f5, 0x0001);
    memoryASet16(ds, 0x20d89b, 0x0001);
    yield* sub_1b66fb();
    r32[esi] = 0x001f118c;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    yield* sub_1bf923();
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[esi] = 0x001f118c;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet32(ds, 0x224670, 0xffffffff);
    memoryASet32(ds, 0x224674, 0x0023c4e0);
    yield* sub_1c1db4();
    memoryASet16(ds, 0x20e90d, 0x0001);
    memoryASet16(ds, 0x20ec8d, 0x0003);
    memoryASet16(ds, 0x20d8b7, 0x0000);
    memoryASet16(ds, 0x20eea9, 0x0001);
    yield* sub_1c58f8();
    memoryASet16(ds, 0x20ee81, 0x0000);
    memoryASet16(ds, 0x20eea9, 0x0000);
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[esi] = 0x001f118c;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet32(ds, 0x224670, 0xffffffff);
    memoryASet32(ds, 0x224674, 0x0023c4e0);
    { pc = 0x1c1db4; break; }
  case 0x1c5584: // 0160:1c5584
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    r16[ax] = 0x0006;
    { pc = 0x1c5695; break; }
  case 0x1c559c: // 0160:1c559c
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5768; break; }
    r16[ax] = 0x0005;
    { pc = 0x1c55f6; break; }
  case 0x1c55b1: // 0160:1c55b1
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5768; break; }
    r16[ax] = 0x0004;
    { pc = 0x1c55f6; break; }
  case 0x1c55c6: // 0160:1c55c6
    r16[ax] = 0x0002;
    { pc = 0x1c55f6; break; }
  case 0x1c55cc: // 0160:1c55cc
    r16[ax] = 0x0001;
    { pc = 0x1c55f6; break; }
  case 0x1c55d2: // 0160:1c55d2
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    r16[ax] = 0;
    yield* sub_1c5695();
    r32[eax] = 0;
    memoryASet16(ds, 0x20ee61, r16[ax]);
    { pc = 0x1c5215; break; }
  case 0x1c55f6: // 0160:1c55f6
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    push(r16[ax]);
    r16[ax] = 0;
    if (r16[bx])
        { pc = 0x1c5613; break; }
    r16[bx] = 0x0001;
  case 0x1c5613: // 0160:1c5613
    if (r16[cx])
        { pc = 0x1c561c; break; }
    r16[cx] = 0x0001;
  case 0x1c561c: // 0160:1c561c
    if (r16[bx] != 0x0018)
        { pc = 0x1c5626; break; }
    r16[bx] = 0x0017;
  case 0x1c5626: // 0160:1c5626
    if (r16[cx] != 0x0018)
        { pc = 0x1c5630; break; }
    r16[cx] = 0x0017;
  case 0x1c5630: // 0160:1c5630
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet16(ds, 0x20ee61, r16[ax]);
    r16[bx] <<= 5;
    r16[cx] <<= 5;
    memoryASet16(ds, 0x20cf4f, r16[bx]);
    memoryASet16(ds, 0x20cf61, r16[cx]);
    r16[bx] -= 0x00a0;
    if (r16s[bx] >= 0)
        { pc = 0x1c5658; break; }
    r16[bx] = 0;
  case 0x1c5658: // 0160:1c5658
    r16[cx] -= 0x0070;
    if (r16s[cx] >= 0)
        { pc = 0x1c5661; break; }
    r16[cx] = 0;
  case 0x1c5661: // 0160:1c5661
    if (r16s[bx] < signed16(0x01c0))
        { pc = 0x1c566c; break; }
    r16[bx] = 0x01c0;
  case 0x1c566c: // 0160:1c566c
    if (r16s[cx] < signed16(0x0200))
        { pc = 0x1c5677; break; }
    r16[cx] = 0x0200;
  case 0x1c5677: // 0160:1c5677
    memoryASet16(ds, 0x20cf23, r16[bx]);
    memoryASet16(ds, 0x20cf25, r16[cx]);
    r16[ax] = pop();
    yield* sub_1c5695();
    r16[ax] = 0x0001;
    { pc = 0x1c5215; break; }
  case 0x1c5695: // 0160:1c5695
    memoryASet16(ds, 0x20ceaf, r16[ax]);
    push(r16[ax]);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b54af();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r16[ax] = pop();
    push(r16[ax]);
    yield* sub_1c5772();
    r16[ax] = pop();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c5772();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1c5724: // 0160:1c5724
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20ceaf) == 0x0003)
        { pc = 0x1c575e; break; }
    if (memoryAGet16(ds, 0x20ceaf) == 0x0006)
        { pc = 0x1c575e; break; }
    r32[esi] = 0x001f1034;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001f10a8;
    r8[al] = 0xc5;
    r8[bl] = 0x87;
    yield* sub_1b60a7();
  case 0x1c575e: // 0160:1c575e
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c5724; break; }
  case 0x1c5767: // 0160:1c5767
    r32[esp] += 4; return;
  case 0x1c5768: // 0160:1c5768
    memoryASet16(ds, 0x20ee63, 0xffff);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c5300() // 0160:1c5300 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c5300; break; }
  case 0x1c1db4: // 0160:1c1db4
    r32[edx] = 0x0020e9c5;
    r32[eax] = 0x00003d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e7c; break; }
    memoryASet32(ds, 0x20ee4b, r32[eax]);
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e16; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e16; break; }
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004202;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, 0x224670, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[ecx] = 0;
    r32[edx] = 0;
    r32[eax] = 0x00004200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
  case 0x1c1e16: // 0160:1c1e16
    r32[edx] = memoryAGet32(ds, 0x224674);
    r32[ecx] = memoryAGet32(ds, 0x224670);
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    r32[eax] = 0x00003f00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x1c1e71; break; }
    if (memoryAGet32(ds, 0x224670) != r32[eax])
        { pc = 0x1c1e66; break; }
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1c1e87();
    if (memoryAGet32(ds, 0x224670) == 0x00000010)
        { pc = 0x1c1e65; break; }
    if (memoryAGet32(ds, 0x224670) == 0x0000304c)
        { pc = 0x1c1e65; break; }
    yield* sub_1c4573();
  case 0x1c1e65: // 0160:1c1e65
    r32[esp] += 4; return;
  case 0x1c1e66: // 0160:1c1e66
    memoryASet16(ds, 0x20cec3, 0x0001);
    { pc = 0x1c1e87; break; }
  case 0x1c1e71: // 0160:1c1e71
    memoryASet16(ds, 0x20cec3, 0x0002);
    { pc = 0x1c1e87; break; }
  case 0x1c1e7c: // 0160:1c1e7c
    memoryASet16(ds, 0x20cec3, 0x0003);
    { pc = 0x1c1e94; break; }
  case 0x1c1e87: // 0160:1c1e87
    r32[eax] = 0x00003e00;
    r32[ebx] = memoryAGet32(ds, 0x20ee4b);
    interrupt(0x21);
  case 0x1c1e94: // 0160:1c1e94
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r32[esp] += 4; return;
    // gap 13178 bytes // gap 13178 bytes
  case 0x1c5215: // 0160:1c5215
    memoryASet16(ds, 0x20d80d, r16[ax]);
    if (r16[ax])
        { pc = 0x1c524a; break; }
    r16[ax] = 0x0000;
    r16[bx] = 0x0000;
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r16[ax] += 0x0020;
    r16[bx] += 0x0020;
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    memoryASet16(ds, 0x20cf61, r16[bx]);
  case 0x1c524a: // 0160:1c524a
    memoryASet16(ds, 0x20d7f5, 0x0000);
    memoryASet(ds, 0x232cd8, 0x00);
    memoryASet(ds, 0x232cda, 0x00);
    memoryASet(ds, 0x232cd9, 0x19);
    memoryASet(ds, 0x232cdb, 0x19);
    r32[edi] = 0x00232cdc;
    r32[esi] = 0x0023c4fb;
    r32[ecx] = 0x00000271;
  case 0x1c527e: // 0160:1c527e
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c527e; break; }
  case 0x1c528c: // 0160:1c528c
    yield* sub_1c459c();
    if (r16[ax])
        { pc = 0x1c529d; break; }
    yield* sub_1c49d6();
    { pc = 0x1c528c; break; }
  case 0x1c529d: // 0160:1c529d
    if (r16[ax] == 0x00ff)
        { pc = 0x1c52c1; break; }
    r32[esi] = 0x00232cdc;
    r32[edi] = 0x0023c4fb;
    r32[ecx] = 0x00000271;
  case 0x1c52b6: // 0160:1c52b6
    r16[ax] = memoryAGet16(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000002;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c52b6; break; }
  case 0x1c52c1: // 0160:1c52c1
    r32[esp] += 4; return;
    // gap 62 bytes // gap 62 bytes
  case 0x1c5300: // 0160:1c5300
    memoryASet16(ds, 0x20ee65, r16[ax]);
    memoryASet16(ds, 0x20ee63, 0xffff);
    r32[esi] = 0x0023c76c;
    r32[ecx] = 0x00000090;
  case 0x1c5319: // 0160:1c5319
    r32[eax] = memoryAGet32(ds, r32[esi]);
    if (r32[eax])
        { pc = 0x1c5329; break; }
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c5319; break; }
    { pc = 0x1c5584; break; }
  case 0x1c5329: // 0160:1c5329
    r32[esi] = 0x0023c4fb;
    r32[ebx] = 0x00000019;
  case 0x1c5333: // 0160:1c5333
    r32[ecx] = 0x00000019;
  case 0x1c5338: // 0160:1c5338
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c5349; break; }
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c5338; break; }
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c5333; break; }
    { pc = 0x1c55d2; break; }
  case 0x1c5349: // 0160:1c5349
    r16[ax] = 0x0019;
    r16[ax] -= r16[bx];
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r16[bx] = r16[ax];
    r16[ax] = 0x0019;
    r16[ax] -= r16[cx];
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[cx] = r16[ax];
    r16[dx] = 0x0000;
  case 0x1c536d: // 0160:1c536d
    r16[dx]++;
    r32[esi]--;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1c55cc; break; }
  case 0x1c537b: // 0160:1c537b
    r8[al] = memoryAGet(ds, r32[esi]);
    if (!r8[al])
        { pc = 0x1c5456; break; }
    if (r8[al] == 0x01)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x13)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x14)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x15)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x07)
        { pc = 0x1c543b; break; }
    if (r8[al] == 0x03)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c5408; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c53aa: // 0160:1c53aa
    r16[dx]++;
    r32[esi] += 0x00000019;
    r16[bx]++;
    if (r16[bx] == 0x0018)
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x03)
        { pc = 0x1c536d; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x02)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x16)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x17)
        { pc = 0x1c53aa; break; }
    if (r8[al] == 0x18)
        { pc = 0x1c53aa; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c53da: // 0160:1c53da
    r16[dx]++;
    r32[esi]++;
    r16[cx]++;
    if (r16[cx] == 0x0018)
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x01)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x13)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x14)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x15)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x03)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c53aa; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c5408: // 0160:1c5408
    r16[dx]++;
    r32[esi] -= 0x00000019;
    r16[bx]--;
    if (!r16[bx])
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x02)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x16)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x17)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x18)
        { pc = 0x1c5408; break; }
    if (r8[al] == 0x03)
        { pc = 0x1c53da; break; }
    if (r8[al] == 0x04)
        { pc = 0x1c536d; break; }
    { pc = 0x1c55c6; break; }
  case 0x1c543b: // 0160:1c543b
    r16[dx]++;
    r32[esi]--;
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x1c55cc; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] == 0x06)
        { pc = 0x1c543b; break; }
    { pc = 0x1c537b; break; }
  case 0x1c5456: // 0160:1c5456
    memoryASet16(ds, 0x20ee63, r16[dx]);
    if (r16s[dx] <= signed16(0x001d))
        { pc = 0x1c55b1; break; }
    if (r16s[dx] >= signed16(0x00af))
        { pc = 0x1c559c; break; }
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    r16[ax] = 0x0003;
    yield* sub_1c5695();
    memoryASet16(ds, 0x20d7f5, 0x0001);
    memoryASet16(ds, 0x20d89b, 0x0001);
    yield* sub_1b66fb();
    r32[esi] = 0x001f118c;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    yield* sub_1bf923();
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[esi] = 0x001f118c;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet32(ds, 0x224670, 0xffffffff);
    memoryASet32(ds, 0x224674, 0x0023c4e0);
    yield* sub_1c1db4();
    memoryASet16(ds, 0x20e90d, 0x0001);
    memoryASet16(ds, 0x20ec8d, 0x0003);
    memoryASet16(ds, 0x20d8b7, 0x0000);
    memoryASet16(ds, 0x20eea9, 0x0001);
    yield* sub_1c58f8();
    memoryASet16(ds, 0x20ee81, 0x0000);
    memoryASet16(ds, 0x20eea9, 0x0000);
    r32[edx] = 0x001f0d39;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
    r32[esi] = 0x001f118c;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x0000001e;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    memoryASet32(ds, 0x224670, 0xffffffff);
    memoryASet32(ds, 0x224674, 0x0023c4e0);
    { pc = 0x1c1db4; break; }
  case 0x1c5584: // 0160:1c5584
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    r16[ax] = 0x0006;
    { pc = 0x1c5695; break; }
  case 0x1c559c: // 0160:1c559c
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5768; break; }
    r16[ax] = 0x0005;
    { pc = 0x1c55f6; break; }
  case 0x1c55b1: // 0160:1c55b1
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5768; break; }
    r16[ax] = 0x0004;
    { pc = 0x1c55f6; break; }
  case 0x1c55c6: // 0160:1c55c6
    r16[ax] = 0x0002;
    { pc = 0x1c55f6; break; }
  case 0x1c55cc: // 0160:1c55cc
    r16[ax] = 0x0001;
    { pc = 0x1c55f6; break; }
  case 0x1c55d2: // 0160:1c55d2
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    r16[ax] = 0;
    yield* sub_1c5695();
    r32[eax] = 0;
    memoryASet16(ds, 0x20ee61, r16[ax]);
    { pc = 0x1c5215; break; }
  case 0x1c55f6: // 0160:1c55f6
    if (!(memoryAGet16(ds, 0x20ee65) & 0xffff))
        { pc = 0x1c5767; break; }
    push(r16[ax]);
    r16[ax] = 0;
    if (r16[bx])
        { pc = 0x1c5613; break; }
    r16[bx] = 0x0001;
  case 0x1c5613: // 0160:1c5613
    if (r16[cx])
        { pc = 0x1c561c; break; }
    r16[cx] = 0x0001;
  case 0x1c561c: // 0160:1c561c
    if (r16[bx] != 0x0018)
        { pc = 0x1c5626; break; }
    r16[bx] = 0x0017;
  case 0x1c5626: // 0160:1c5626
    if (r16[cx] != 0x0018)
        { pc = 0x1c5630; break; }
    r16[cx] = 0x0017;
  case 0x1c5630: // 0160:1c5630
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet16(ds, 0x20ee61, r16[ax]);
    r16[bx] <<= 5;
    r16[cx] <<= 5;
    memoryASet16(ds, 0x20cf4f, r16[bx]);
    memoryASet16(ds, 0x20cf61, r16[cx]);
    r16[bx] -= 0x00a0;
    if (r16s[bx] >= 0)
        { pc = 0x1c5658; break; }
    r16[bx] = 0;
  case 0x1c5658: // 0160:1c5658
    r16[cx] -= 0x0070;
    if (r16s[cx] >= 0)
        { pc = 0x1c5661; break; }
    r16[cx] = 0;
  case 0x1c5661: // 0160:1c5661
    if (r16s[bx] < signed16(0x01c0))
        { pc = 0x1c566c; break; }
    r16[bx] = 0x01c0;
  case 0x1c566c: // 0160:1c566c
    if (r16s[cx] < signed16(0x0200))
        { pc = 0x1c5677; break; }
    r16[cx] = 0x0200;
  case 0x1c5677: // 0160:1c5677
    memoryASet16(ds, 0x20cf23, r16[bx]);
    memoryASet16(ds, 0x20cf25, r16[cx]);
    r16[ax] = pop();
    yield* sub_1c5695();
    r16[ax] = 0x0001;
    { pc = 0x1c5215; break; }
  case 0x1c5695: // 0160:1c5695
    memoryASet16(ds, 0x20ceaf, r16[ax]);
    push(r16[ax]);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b54af();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r16[ax] = pop();
    push(r16[ax]);
    yield* sub_1c5772();
    r16[ax] = pop();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c5772();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1c5724: // 0160:1c5724
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20ceaf) == 0x0003)
        { pc = 0x1c575e; break; }
    if (memoryAGet16(ds, 0x20ceaf) == 0x0006)
        { pc = 0x1c575e; break; }
    r32[esi] = 0x001f1034;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001f10a8;
    r8[al] = 0xc5;
    r8[bl] = 0x87;
    yield* sub_1b60a7();
  case 0x1c575e: // 0160:1c575e
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c5724; break; }
  case 0x1c5767: // 0160:1c5767
    r32[esp] += 4; return;
  case 0x1c5768: // 0160:1c5768
    memoryASet16(ds, 0x20ee63, 0xffff);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c5695() // 0160:1c5695 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ceaf, r16[ax]);
    push(r16[ax]);
    yield* sub_1b4bc9();
    yield* sub_1b6083();
    yield* sub_1b54af();
    r32[edx] = 0x001ecc30;
    yield* sub_1bd899();
    r32[edx] = 0x001ecb7a;
    r32[edi] = 0x000a0000;
    yield* sub_1b524f();
    r32[edi] = 0x000a4800;
    yield* sub_1b5267();
    r32[edi] = 0x000a9000;
    yield* sub_1b5267();
    r16[ax] = pop();
    push(r16[ax]);
    yield* sub_1c5772();
    r16[ax] = pop();
    memoryASet16(ds, 0x2231c4, 0x0002);
    yield* sub_1c5772();
    memoryASet16(ds, 0x2231c4, 0x0000);
    memoryASet16(ds, 0x20ec3d, 0x00b6);
    memoryASet16(ds, 0x20ec3f, 0x00fe);
    memoryASet16(ds, 0x20e831, 0x0000);
    memoryASet16(ds, 0x20e82f, 0x0000);
    yield* sub_1b4f0e();
  case 0x1c5724: // 0160:1c5724
    yield* sub_1b5096();
    yield* sub_1c6ff7();
    if (memoryAGet16(ds, 0x20ceaf) == 0x0003)
        { pc = 0x1c575e; break; }
    if (memoryAGet16(ds, 0x20ceaf) == 0x0006)
        { pc = 0x1c575e; break; }
    r32[esi] = 0x001f1034;
    r8[al] = 0xc3;
    r8[bl] = 0x09;
    yield* sub_1b60a7();
    r32[esi] = 0x001f10a8;
    r8[al] = 0xc5;
    r8[bl] = 0x87;
    yield* sub_1b60a7();
  case 0x1c575e: // 0160:1c575e
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x80;
    if (!r8[al])
        { pc = 0x1c5724; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c5772() // 0160:1c5772 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c5772; break; }
  case 0x1b60d3: // 0160:1b60d3
    yield* sub_1b6113();
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b6269; break; }
    // gap 391 bytes // gap 391 bytes
  case 0x1b6269: // 0160:1b6269
    r32[eax] = 0;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] &= 0x0f;
    r8[bl] <<= 2;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1b627c: // 0160:1b627c
    if (r8[al] < 0x40)
        { pc = 0x1b6286; break; }
    r8[bl]++;
    r8[al] -= 0x40;
    { pc = 0x1b627c; break; }
  case 0x1b6286: // 0160:1b6286
    r8[bl] <<= 3;
    r8[cl] = r8[bl];
    r16[bx] <<= 6;
    r16[cx] <<= 4;
    r16[bx] += r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    r16[cx] &= 0x00ff;
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    push32(r32[esi]);
    r32[ecx] <<= 1;
    yield* sub_1bd825();
    r32[esi] = 0x000a9000;
    r32[edi] = 0x000a4800;
    if (!(memoryAGet16(ds, 0x2231c4) & 0xffff))
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a9000;
    if (memoryAGet16(ds, 0x2231c4) == 0x0001)
        { pc = 0x1b62e3; break; }
    r32[edi] = 0x000a0000;
  case 0x1b62e3: // 0160:1b62e3
    r32[edi] += r32[eax];
    memoryASet32(ds, 0x20ceef, r32[edi]);
    r32[esi] += r32[eax];
    push(ds);
    es = pop();
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20e905) == 0x0002)
        { pc = 0x1b6301; break; }
    r16[dx] = 0x0008;
  case 0x1b6301: // 0160:1b6301
    memoryASet16(ds, 0x20ceb1, r16[dx]);
    r32[ebx] = 0x00000050;
    r32[ebx] -= r32[ecx];
  case 0x1b630f: // 0160:1b630f
    r32[ebp] = r32[ecx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r32[ecx] = r32[ebp];
    r32[esi] += r32[ebx];
    r32[edi] += r32[ebx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x1b630f; break; }
    yield* sub_1bd849();
    r32[esi] = pop32();
    r32[esi] += 0x00000004;
    r32[edi] = memoryAGet32(ds, 0x20ceef);
    memoryASet32(ds, 0x20cedf, r32[edi]);
  case 0x1b6332: // 0160:1b6332
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (r8[bl] == 0xff)
        { pc = 0x1b63a9; break; }
    r16[bx] <<= 3;
    r32[eax] = 0x002239f0;
    r32[ebx] += r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = 0x0028890c;
    r32[ebx] += r32[eax];
    memoryASet32(ds, 0x20cedb, r32[ebx]);
    r16[dx] = 0x03c4;
    r8[ah] = 0x01;
  case 0x1b6361: // 0160:1b6361
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[bp] = memoryAGet16(ds, 0x20ceb1);
    r32[edi] = memoryAGet32(ds, 0x20cedf);
    r32[ebx] = memoryAGet32(ds, 0x20cedb);
  case 0x1b6378: // 0160:1b6378
    r8[cl] = memoryAGet(ds, r32[ebx]);
    if (!r8[cl])
        { pc = 0x1b6384; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6384: // 0160:1b6384
    r32[edi]++;
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x4);
    if (!r8[cl])
        { pc = 0x1b6392; break; }
    memoryASet(ds, r32[edi], r8[cl]);
  case 0x1b6392: // 0160:1b6392
    r32[ebx] += 0x00000008;
    r32[edi] += 0x0000004f;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1b6378; break; }
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + 1);
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1b6361; break; }
  case 0x1b63a9: // 0160:1b63a9
    memoryASet16(ds, 0x20ceb7, memoryAGet16(ds, 0x20ceb7) - 1);
    if (!memoryAGet16(ds, 0x20ceb7))
        { pc = 0x1b63c2; break; }
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + 0x00000002);
    { pc = 0x1b6332; break; }
  case 0x1b63c2: // 0160:1b63c2
    r8[al] = 0x02;
    r8[ah] = 0x0f;
    out16(r16[dx], r16[ax]);
    r32[esp] += 4; return;
    // gap 62377 bytes // gap 62377 bytes
  case 0x1c5772: // 0160:1c5772
    memoryASet16(ds, 0x20e905, 0x0002);
    if (r16[ax])
        { pc = 0x1c578a; break; }
    r32[esi] = 0x001f104e;
    { pc = 0x1b60d3; break; }
  case 0x1c578a: // 0160:1c578a
    if (r16[ax] != 0x0001)
        { pc = 0x1c579a; break; }
    r32[esi] = 0x001f1060;
    { pc = 0x1b60d3; break; }
  case 0x1c579a: // 0160:1c579a
    if (r16[ax] != 0x0002)
        { pc = 0x1c57b4; break; }
    r32[esi] = 0x001f1077;
    yield* sub_1b60d3();
    r32[esi] = 0x001f108a;
    { pc = 0x1b60d3; break; }
  case 0x1c57b4: // 0160:1c57b4
    if (r16[ax] != 0x0003)
        { pc = 0x1c5824; break; }
    r32[esi] = 0x001f10c5;
    yield* sub_1b60d3();
    r32[esi] = 0x001f10e1;
    r32[edi] = 0x0020e9c5;
    r32[ecx] = 0x00000028;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20ee63);
    r16[bx] = 0;
    r16[cx] = 0;
  case 0x1c57e1: // 0160:1c57e1
    if (r16s[ax] < signed16(0x0064))
        { pc = 0x1c57ef; break; }
    r16[cx]++;
    r16[ax] -= 0x0064;
    { pc = 0x1c57e1; break; }
  case 0x1c57ef: // 0160:1c57ef
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1c57fd; break; }
    r16[bx]++;
    r16[ax] -= 0x000a;
    { pc = 0x1c57ef; break; }
  case 0x1c57fd: // 0160:1c57fd
    r16[ax] += 0x0030;
    r16[bx] += 0x0030;
    r16[cx] += 0x0030;
    memoryASet(ds, 0x20e9d3, r8[cl]);
    memoryASet(ds, 0x20e9d4, r8[bl]);
    memoryASet(ds, 0x20e9d5, r8[al]);
    r32[esi] = 0x0020e9c5;
    { pc = 0x1b60d3; break; }
  case 0x1c5824: // 0160:1c5824
    if (r16[ax] != 0x0004)
        { pc = 0x1c5840; break; }
    r32[esi] = 0x001f10f2;
    yield* sub_1b60d3();
    r32[esi] = 0x001f1108;
    yield* sub_1b60d3();
    { pc = 0x1c585a; break; }
  case 0x1c5840: // 0160:1c5840
    if (r16[ax] != 0x0005)
        { pc = 0x1c58ba; break; }
    r32[esi] = 0x001f1126;
    yield* sub_1b60d3();
    r32[esi] = 0x001f114b;
    yield* sub_1b60d3();
  case 0x1c585a: // 0160:1c585a
    r32[esi] = 0x001f113a;
    r32[edi] = 0x0020ea29;
    r32[ecx] = 0x00000028;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
    r16[ax] = memoryAGet16(ds, 0x20ee63);
    r16[bx] = 0;
    r16[cx] = 0;
  case 0x1c5877: // 0160:1c5877
    if (r16s[ax] < signed16(0x0064))
        { pc = 0x1c5885; break; }
    r16[cx]++;
    r16[ax] -= 0x0064;
    { pc = 0x1c5877; break; }
  case 0x1c5885: // 0160:1c5885
    if (r16s[ax] < signed16(0x000a))
        { pc = 0x1c5893; break; }
    r16[bx]++;
    r16[ax] -= 0x000a;
    { pc = 0x1c5885; break; }
  case 0x1c5893: // 0160:1c5893
    r16[ax] += 0x0030;
    r16[bx] += 0x0030;
    r16[cx] += 0x0030;
    memoryASet(ds, 0x20ea37, r8[cl]);
    memoryASet(ds, 0x20ea38, r8[bl]);
    memoryASet(ds, 0x20ea39, r8[al]);
    r32[esi] = 0x0020ea29;
    { pc = 0x1b60d3; break; }
  case 0x1c58ba: // 0160:1c58ba
    if (r16[ax] != 0x0006)
        { pc = 0x1c58ca; break; }
    r32[esi] = 0x001f116a;
    { pc = 0x1b60d3; break; }
  case 0x1c58ca: // 0160:1c58ca
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c58cb() // 0160:1c58cb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[al] = memoryAGet(ds, 0x23c4f0);
    if (r8[al] != 0x01)
        { pc = 0x1c58f3; break; }
    r32[edx] = 0x001f0d4e;
    yield* sub_1aa484();
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r16[ax] = 0x0001;
    yield* sub_1aa553();
  case 0x1c58f3: // 0160:1c58f3
    yield* sub_1c103c();
    memoryASet16(ds, 0x20d7b9, 0x0036);
    yield* sub_1b4eda();
    r16[ax] = 0;
    yield* sub_1c5300();
    if (memoryAGet16(ds, 0x20ee63) == 0xffff)
        { pc = 0x1c59c2; break; }
    if (signed16(memoryAGet16(ds, 0x20ee63)) <= signed16(0x001d))
        { pc = 0x1c59c2; break; }
    if (signed16(memoryAGet16(ds, 0x20ee63)) >= signed16(0x00af))
        { pc = 0x1c59c2; break; }
    yield* sub_1c59f0();
    r8[al] = memoryAGet(ds, 0x23c4f0);
    if (r8[al] != 0x03)
        { pc = 0x1c5960; break; }
    r32[esi] = 0x0020c88f;
    r32[ecx] = 0x00000300;
  case 0x1c5952: // 0160:1c5952
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] -= r8[al];
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c5952; break; }
  case 0x1c5960: // 0160:1c5960
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1c5998; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1c5998; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1c5998; break; }
  case 0x1c5981: // 0160:1c5981
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
    r32[eax] -= memoryAGet32(ds, 0x20ee7b);
    if (r32s[eax] < signed32(0x0000008c))
        { pc = 0x1c5981; break; }
    yield* sub_1c79ac();
  case 0x1c5998: // 0160:1c5998
    yield* sub_1ac7de();
    if (signed16(memoryAGet16(ds, 0x20ee77)) >= signed16(0x0003))
        { pc = 0x1c59b8; break; }
    memoryASet32(ds, 0x2246cc, 0x00000001);
    yield* sub_1abd5e();
    { pc = 0x1c59c2; break; }
  case 0x1c59b8: // 0160:1c59b8
    yield* sub_1b4f0e();
    yield* sub_1abd5e();
  case 0x1c59c2: // 0160:1c59c2
    memoryASet16(ds, 0x2231d0, 0x0000);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0000);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x224644, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c58f8() // 0160:1c58f8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d7b9, 0x0036);
    yield* sub_1b4eda();
    r16[ax] = 0;
    yield* sub_1c5300();
    if (memoryAGet16(ds, 0x20ee63) == 0xffff)
        { pc = 0x1c59c2; break; }
    if (signed16(memoryAGet16(ds, 0x20ee63)) <= signed16(0x001d))
        { pc = 0x1c59c2; break; }
    if (signed16(memoryAGet16(ds, 0x20ee63)) >= signed16(0x00af))
        { pc = 0x1c59c2; break; }
    yield* sub_1c59f0();
    r8[al] = memoryAGet(ds, 0x23c4f0);
    if (r8[al] != 0x03)
        { pc = 0x1c5960; break; }
    r32[esi] = 0x0020c88f;
    r32[ecx] = 0x00000300;
  case 0x1c5952: // 0160:1c5952
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] >>>= 2;
    r8[bl] = memoryAGet(ds, r32[esi]);
    r8[bl] -= r8[al];
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c5952; break; }
  case 0x1c5960: // 0160:1c5960
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1c5998; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1c5998; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1c5998; break; }
  case 0x1c5981: // 0160:1c5981
    r32[eax] = memoryAGet32(ds, 0x2eebd0);
    r32[eax] -= memoryAGet32(ds, 0x20ee7b);
    if (r32s[eax] < signed32(0x0000008c))
        { pc = 0x1c5981; break; }
    yield* sub_1c79ac();
  case 0x1c5998: // 0160:1c5998
    yield* sub_1ac7de();
    if (signed16(memoryAGet16(ds, 0x20ee77)) >= signed16(0x0003))
        { pc = 0x1c59b8; break; }
    memoryASet32(ds, 0x2246cc, 0x00000001);
    yield* sub_1abd5e();
    { pc = 0x1c59c2; break; }
  case 0x1c59b8: // 0160:1c59b8
    yield* sub_1b4f0e();
    yield* sub_1abd5e();
  case 0x1c59c2: // 0160:1c59c2
    memoryASet16(ds, 0x2231d0, 0x0000);
    memoryASet16(ds, 0x20d7bf, 0x0000);
    memoryASet16(ds, 0x20d7c1, 0x0000);
    memoryASet16(ds, 0x20d7c3, 0x0000);
    memoryASet16(ds, 0x224644, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1c59f0() // 0160:1c59f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20cef5, 0x0000);
    memoryASet16(ds, 0x20edfd, 0x0000);
    r32[eax] = 0;
    r32[ebx] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    memoryASet32(ds, 0x1f1c48, r32[eax]);
    memoryASet32(ds, 0x1f1c4c, r32[ebx]);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00000314;
    r32[ecx] = 0x00000026;
  case 0x1c5a2f: // 0160:1c5a2f
    push32(r32[edi]);
    push32(r32[ecx]);
    r32[ecx] = 0x0000000a;
  case 0x1c5a36: // 0160:1c5a36
    push32(r32[edi]);
    push32(r32[ecx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00000314;
    r32[ecx] = 0x00000020;
  case 0x1c5a49: // 0160:1c5a49
    push32(r32[ecx]);
    r32[ecx] = 0x00000020;
  case 0x1c5a4f: // 0160:1c5a4f
    r8[al] = memoryAGet(ds, r32[edi]);
    if (r8[al] < 0xfc)
        { pc = 0x1c5a59; break; }
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
  case 0x1c5a59: // 0160:1c5a59
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c5a4f; break; }
    r32[ecx] = pop32();
    r32[esi] += 0x00000120;
    r32[edi] += 0x00000120;
    if (--r32[ecx])
        { pc = 0x1c5a49; break; }
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[edi] += 0x00000020;
    if (--r32[ecx])
        { pc = 0x1c5a36; break; }
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[edi] += 0x00002800;
    if (--r32[ecx])
        { pc = 0x1c5a2f; break; }
    memoryASet16(ds, 0x20d867, 0x0000);
    memoryASet32(ds, 0x1f1c40, 0x00000000);
    yield* sub_1a8760();
    r32[edi] = 0x00232cdc;
    r32[esi] = 0x0023c4fb;
    r32[ecx] = 0x00000019;
  case 0x1c5aa4: // 0160:1c5aa4
    push32(r32[edi]);
    push32(r32[ecx]);
    r32[ecx] = 0x00000019;
  case 0x1c5aab: // 0160:1c5aab
    push32(r32[edi]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[al] += r8[al];
    r32[edx] = 0x001f11a0;
    r16[ax] = memoryAGet16(ds, r32[edx] + r32[eax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000092;
    r16[ax] -= 0x0013;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000092;
    r16[ax] -= 0x0013;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi]++;
    r32[edi] = pop32();
    r32[edi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1c5aab; break; }
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[edi] += 0x000001c2;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c5aa4; break; }
    r32[edi] = 0x002358ce;
    r32[esi] = 0x0023c4fb;
    r32[ecx] = 0x00000019;
  case 0x1c5b3b: // 0160:1c5b3b
    push32(r32[edi]);
    push32(r32[ecx]);
    r32[ecx] = 0x00000019;
  case 0x1c5b42: // 0160:1c5b42
    push32(r32[edi]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[esi]);
    r16[ax] += r16[ax];
    r16[bx] = r16[ax];
    r16[ax] <<= 3;
    r16[ax] += r16[bx];
    r32[edx] = 0x001f11dc;
    r32[edx] += r32[eax];
    r16[ax] = memoryAGet16(ds, r32[edx]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0x6);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0xc);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000092;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0x2);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0x8);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0xe);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000092;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0x4);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0xa);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[edx] + 0x10);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi]++;
    r32[edi] = pop32();
    r32[edi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1c5b42; break; }
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[edi] += 0x000001c2;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1c5b3b; break; }
    r32[edx] = 0x00232cd8;
    r32[ecx] = 0x000057e8;
    memoryASet32(ds, 0x2eeb90, r32[ecx]);
    memoryASet32(ds, 0x2eeb94, r32[edx]);
    memoryASet(ds, 0x232cd8, 0x00);
    memoryASet(ds, 0x232cd9, 0x4b);
    memoryASet(ds, 0x232cda, 0x00);
    memoryASet(ds, 0x232cdb, 0x4b);
    r32[eax] = 0;
    r8[al] = 0x4b;
    memoryASet32(ds, 0x1f1cb0, r32[eax]);
    memoryASet16(ds, 0x20cef3, r16[ax]);
    memoryASet32(ds, 0x1f1cb4, r32[eax]);
    memoryASet16(ds, 0x20cef7, r16[ax]);
    r32[ebx] = 0x0000004b;
    mul8(r8[bl]);
    r32[eax] += r32[eax];
    memoryASet32(ds, 0x2eeba4, r32[eax]);
    r32[eax] += memoryAGet32(ds, 0x2eeb94);
    r32[eax] += 0x00000004;
    memoryASet32(ds, 0x2eeba0, r32[eax]);
    r32[ecx] = 0;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20cef7);
    r16[cx] = memoryAGet16(ds, 0x20cef3);
    r32[edx] = 0;
    mul16(r16[cx]);
    r32[eax] &= 0x0000ffff;
    memoryASet32(ds, 0x20cefb, r32[eax]);
    yield* sub_1b0c88();
    r32[esi] = 0x0023c76c;
    r32[edi] = 0x0029be48;
    r32[ebx] = 0x00000009;
  case 0x1c5c6b: // 0160:1c5c6b
    push32(r32[edi]);
    r32[edx] = 0x00000018;
  case 0x1c5c71: // 0160:1c5c71
    r32[ecx] = 0x00000018;
  case 0x1c5c76: // 0160:1c5c76
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c5c76; break; }
    r32[edi] += 0x00000128;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c5c71; break; }
    r32[edi] = pop32();
    r32[edi] += 0x00000018;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c5c6b; break; }
    r32[edi] = 0x0029dc48;
    r32[ebx] = 0x00000006;
  case 0x1c5c98: // 0160:1c5c98
    push32(r32[edi]);
    r32[edx] = 0x00000018;
  case 0x1c5c9e: // 0160:1c5c9e
    r32[ecx] = 0x00000018;
  case 0x1c5ca3: // 0160:1c5ca3
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1c5ca3; break; }
    r32[edi] += 0x00000128;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c5c9e; break; }
    r32[edi] = pop32();
    r32[edi] += 0x00000018;
    r32[ebx]--;
    if (r32[ebx])
        { pc = 0x1c5c98; break; }
    yield* sub_1b0f0a();
    yield* sub_1b0dfd();
    r32[esi] = 0x00204d14;
    r32[eax] = 0;
    r16[ax] = 0x0000;
    r32[edx] = memoryAGet32(ds, r32[esi] + r32[eax]);
    yield* sub_1a85aa();
    yield* sub_1a84d3();
    yield* sub_1c6524();
    r32[eax] = 0;
    memoryASet(ds, 0x1f1c44, r8[al]);
    memoryASet16(ds, 0x20d2bb, r16[ax]);
    memoryASet16(ds, 0x20d2bd, r16[ax]);
    memoryASet16(ds, 0x20d2bf, r16[ax]);
    memoryASet16(ds, 0x20d2c1, r16[ax]);
    memoryASet16(ds, 0x20eda7, 0x0001);
    r32[esi] = 0x0020cf39;
    r32[eax] = 0x0020d2c7;
    r32[eax] -= r32[esi];
    r32[eax] >>>= 2;
  case 0x1c5d19: // 0160:1c5d19
    memoryASet32(ds, r32[esi], 0x00000000);
    r32[esi] += 0x00000004;
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1c5d19; break; }
    r32[eax] = 0;
    memoryASet16(ds, 0x20d89d, r16[ax]);
    memoryASet16(ds, 0x20ed9d, 0x0001);
    memoryASet16(ds, 0x20edcf, 0x0001);
    memoryASet16(ds, 0x20edff, 0x0001);
    memoryASet16(ds, 0x20ed9f, 0x0001);
    r16[bx] = 0x00b0;
    r16[cx] = 0x000e;
    r16[dx] = 0xfff2;
    memoryASet16(ds, 0x20e7fd, 0x00a2);
    memoryASet16(ds, 0x20e801, 0xff5e);
    if (signed16(memoryAGet16(ds, 0x20ee63)) >= signed16(0x003b))
        { pc = 0x1c5d99; break; }
    r16[bx] = 0x0058;
    r16[cx] = 0x001c;
    r16[dx] = 0xffe4;
    memoryASet16(ds, 0x20e7fd, 0x0094);
    memoryASet16(ds, 0x20e801, 0xff6c);
  case 0x1c5d99: // 0160:1c5d99
    memoryASet16(ds, 0x20d7e7, r16[bx]);
    memoryASet16(ds, 0x20d7e9, r16[cx]);
    memoryASet16(ds, 0x20d7eb, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20d7ed, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d7ef, r16[ax]);
    yield* sub_1b29b6();
    memoryASet16(ds, 0x20ce93, 0x0004);
    r32[eax] = 0;
    memoryASet32(ds, 0x20d77b, r32[eax]);
    memoryASet16(ds, 0x20d77f, r16[ax]);
    memoryASet32(ds, 0x20d799, r32[eax]);
    memoryASet16(ds, 0x20d79d, r16[ax]);
    memoryASet(ds, 0x20d793, 0x09);
    memoryASet(ds, 0x20d794, 0x05);
    memoryASet(ds, 0x20d795, 0x09);
    memoryASet(ds, 0x20d796, 0x09);
    memoryASet(ds, 0x20d797, 0x09);
    memoryASet16(ds, 0x20d79f, r16[ax]);
    memoryASet16(ds, 0x20d7a1, 0x0057);
    memoryASet16(ds, 0x20d7d3, r16[ax]);
    r16[ax] = 0x0003;
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1c5e39; break; }
    r16[ax] = memoryAGet16(ds, 0x20ec8d);
  case 0x1c5e39: // 0160:1c5e39
    memoryASet16(ds, 0x20d081, r16[ax]);
    memoryASet16(ds, 0x20d083, r16[ax]);
    memoryASet16(ds, 0x20d085, r16[ax]);
    memoryASet16(ds, 0x20d087, r16[ax]);
    r16[ax] = 0x0042;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    r16[ax] = 0x00af;
    memoryASet16(ds, 0x20d04b, r16[ax]);
    memoryASet16(ds, 0x20d04d, r16[ax]);
    memoryASet16(ds, 0x20d04f, r16[ax]);
    memoryASet16(ds, 0x20d051, r16[ax]);
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20d0ff, r16[ax]);
    memoryASet16(ds, 0x20d101, r16[ax]);
    memoryASet16(ds, 0x20d103, r16[ax]);
    memoryASet16(ds, 0x20d105, r16[ax]);
    memoryASet16(ds, 0x20d111, r16[ax]);
    memoryASet16(ds, 0x20d113, r16[ax]);
    memoryASet16(ds, 0x20d115, r16[ax]);
    memoryASet16(ds, 0x20d117, r16[ax]);
    r32[esi] = 0x0023c4fb;
    r16[ax] = 0x0000;
    r16[bx] = 0x0028;
    r32[edx] = 0x00000019;
  case 0x1c5ee7: // 0160:1c5ee7
    r32[ecx] = 0x00000019;
  case 0x1c5eec: // 0160:1c5eec
    if (!memoryAGet(ds, r32[esi]))
        { pc = 0x1c5f04; break; }
    r32[esi]++;
    r16[bx] += 0x0060;
    if (--r32[ecx])
        { pc = 0x1c5eec; break; }
    r16[bx] -= 0x0960;
    r16[ax] += 0x0060;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c5ee7; break; }
  case 0x1c5f04: // 0160:1c5f04
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    memoryASet16(ds, 0x20cf61, r16[bx]);
    memoryASet16(ds, 0x20cf63, r16[bx]);
    r16[ax] += 0x0028;
    memoryASet16(ds, 0x20cf51, r16[ax]);
    memoryASet16(ds, 0x20cf55, r16[ax]);
    r16[bx] += 0x0028;
    memoryASet16(ds, 0x20cf65, r16[bx]);
    memoryASet16(ds, 0x20cf67, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[ax] -= 0x007e;
    if (r16s[ax] >= 0)
        { pc = 0x1c5f56; break; }
    r16[ax] = 0;
  case 0x1c5f56: // 0160:1c5f56
    r16[bx] -= 0x006e;
    if (r16s[bx] >= 0)
        { pc = 0x1c5f5f; break; }
    r16[bx] = 0;
  case 0x1c5f5f: // 0160:1c5f5f
    memoryASet16(ds, 0x20cf23, r16[ax]);
    memoryASet16(ds, 0x20cf25, r16[bx]);
    r32[esi] = 0x00204a3e;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x20d85d, r32[esi]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xa);
    memoryASet16(ds, 0x20e7cf, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xc);
    memoryASet16(ds, 0x20e7d1, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0xe);
    memoryASet16(ds, 0x20e7d3, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x10);
    memoryASet16(ds, 0x20e7d5, r16[bp]);
    memoryASet16(ds, 0x20e7d7, 0x0000);
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, 0x23c4f3);
    r16[ax] += 0x0005;
    memoryASet16(ds, 0x20d003, r16[ax]);
    memoryASet16(ds, 0x20d005, r16[ax]);
    memoryASet16(ds, 0x20d007, r16[ax]);
    memoryASet16(ds, 0x20d009, r16[ax]);
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, 0x23c4f4);
    r16[ax] >>>= 1;
    r16[ax]++;
    r8[bl] = memoryAGet(ds, 0x23c4f0);
    if (r8[bl] != 0x01)
        { pc = 0x1c5ffb; break; }
    r16[ax] = 0x0001;
  case 0x1c5ffb: // 0160:1c5ffb
    memoryASet16(ds, 0x20d015, r16[ax]);
    memoryASet16(ds, 0x20d017, r16[ax]);
    memoryASet16(ds, 0x20d019, r16[ax]);
    memoryASet16(ds, 0x20d01b, r16[ax]);
    r16[ax] = 0;
    r8[al] = memoryAGet(ds, 0x23c4f4);
    r16[ax] <<= 1;
    r8[bl] = memoryAGet(ds, 0x23c4f0);
    if (r8[bl] != 0x01)
        { pc = 0x1c602d; break; }
    r16[ax] = 0x0002;
  case 0x1c602d: // 0160:1c602d
    memoryASet16(ds, 0x20d027, r16[ax]);
    memoryASet16(ds, 0x20d029, r16[ax]);
    memoryASet16(ds, 0x20d02b, r16[ax]);
    memoryASet16(ds, 0x20d02d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x23c4f1);
    r16[bx] = r16[ax];
    r16[bx] >>>= 2;
    r16[ax] += r16[bx];
    memoryASet16(ds, 0x20cff1, r16[ax]);
    memoryASet16(ds, 0x20cff3, r16[ax]);
    memoryASet16(ds, 0x20cff5, r16[ax]);
    memoryASet16(ds, 0x20cff7, r16[ax]);
    r16[ax] = 0x0003;
    memoryASet16(ds, 0x20cfdf, r16[ax]);
    memoryASet16(ds, 0x20cfe1, r16[ax]);
    memoryASet16(ds, 0x20cfe3, r16[ax]);
    memoryASet16(ds, 0x20cfe5, r16[ax]);
    memoryASet16(ds, 0x20cf3d, 0x0001);
    memoryASet16(ds, 0x20cf3f, 0x0005);
    memoryASet16(ds, 0x20cf41, 0x0006);
    memoryASet16(ds, 0x20cf43, 0x0007);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d217, r16[ax]);
    memoryASet16(ds, 0x20d219, r16[ax]);
    memoryASet16(ds, 0x20d21b, r16[ax]);
    memoryASet16(ds, 0x20d21d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] == 0x0001)
        { pc = 0x1c6205; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1c61e5; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1c6180; break; }
    memoryASet16(ds, 0x20d7d3, 0x0001);
    memoryASet16(ds, 0x20cf3f, 0x0002);
    memoryASet16(ds, 0x20cf41, 0x0003);
    memoryASet16(ds, 0x20cf43, 0x0004);
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) - 0x000f);
    memoryASet16(ds, 0x20cf51, memoryAGet16(ds, 0x20cf51) - 0x001e);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf67, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf55, r16[ax]);
    memoryASet16(ds, 0x20cf53, memoryAGet16(ds, 0x20cf53) + 0x0032);
    memoryASet16(ds, 0x20cf55, memoryAGet16(ds, 0x20cf55) + 0x004b);
    r16[ax] = 0x0006;
    memoryASet16(ds, 0x20ce95, r16[ax]);
    memoryASet16(ds, 0x20ce97, r16[ax]);
    memoryASet16(ds, 0x20ce99, r16[ax]);
    memoryASet16(ds, 0x20ce9b, r16[ax]);
    { pc = 0x1c6205; break; }
  case 0x1c6180: // 0160:1c6180
    memoryASet16(ds, 0x20d7d3, 0x0001);
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) - 0x000a);
    memoryASet16(ds, 0x20cf51, memoryAGet16(ds, 0x20cf51) - 0x0014);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    memoryASet16(ds, 0x20cf53, memoryAGet16(ds, 0x20cf53) + 0x003c);
    memoryASet16(ds, 0x20cf3f, 0x0002);
    memoryASet16(ds, 0x20cf41, 0x0003);
    r16[ax] = 0x0004;
    memoryASet16(ds, 0x20ce95, r16[ax]);
    memoryASet16(ds, 0x20ce97, r16[ax]);
    memoryASet16(ds, 0x20ce99, r16[ax]);
    r32[eax] = 0;
    { pc = 0x1c61ff; break; }
  case 0x1c61e5: // 0160:1c61e5
    memoryASet16(ds, 0x20d7d3, 0x0001);
    memoryASet16(ds, 0x20cf3f, 0x0002);
    r32[eax] = 0;
    memoryASet16(ds, 0x20cf41, r16[ax]);
  case 0x1c61ff: // 0160:1c61ff
    memoryASet16(ds, 0x20cf43, r16[ax]);
  case 0x1c6205: // 0160:1c6205
    r32[eax] = 0;
    memoryASet16(ds, 0x20cf45, r16[ax]);
    memoryASet16(ds, 0x20cf47, r16[ax]);
    memoryASet16(ds, 0x20cf49, r16[ax]);
    memoryASet16(ds, 0x20cf4b, r16[ax]);
    if (memoryAGet16(ds, 0x20d89f) == 0x0001)
        { pc = 0x1c627c; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1c627c; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1c627c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[cx] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20cf4f, r16[cx]);
    r16[cx] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20cf61, r16[cx]);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    memoryASet16(ds, 0x20cf65, r16[bx]);
  case 0x1c627c: // 0160:1c627c
    r32[eax] = 0;
    memoryASet32(ds, 0x20d773, r32[eax]);
    memoryASet32(ds, 0x20d777, r32[eax]);
    memoryASet(ds, 0x20d773, 0x01);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1c62c2; break; }
    memoryASet(ds, 0x20d774, 0x01);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1c62c2; break; }
    memoryASet(ds, 0x20d775, 0x01);
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1c62c2; break; }
    memoryASet(ds, 0x20d776, 0x01);
  case 0x1c62c2: // 0160:1c62c2
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1c630e; break; }
    r32[eax] = 0;
    memoryASet16(ds, 0x20cf3f, r16[ax]);
    memoryASet16(ds, 0x20cf41, r16[ax]);
    memoryASet16(ds, 0x20cf43, r16[ax]);
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) + 0x0014);
    memoryASet16(ds, 0x20cf41, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf65, r16[ax]);
  case 0x1c630e: // 0160:1c630e
    r32[eax] = 0;
    memoryASet16(ds, 0x20d2b9, r16[ax]);
    memoryASet16(ds, 0x20d7a9, r16[ax]);
    memoryASet16(ds, 0x20d7ad, r16[ax]);
    memoryASet16(ds, 0x20d7af, r16[ax]);
    r32[esi] = 0x0020d221;
    r32[ecx] = 0x00000008;
  case 0x1c6332: // 0160:1c6332
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1c6332; break; }
    memoryASet16(ds, 0x20d7ab, r16[ax]);
    memoryASet16(ds, 0x20d7a3, r16[ax]);
    memoryASet16(ds, 0x20d7a7, r16[ax]);
    memoryASet16(ds, 0x20d7a5, r16[ax]);
    memoryASet16(ds, 0x20d7b1, r16[ax]);
    memoryASet16(ds, 0x20d7b5, r16[ax]);
    memoryASet16(ds, 0x20d7b7, r16[ax]);
    r32[esi] = 0x0020d251;
    r32[ecx] = 0x00000030;
  case 0x1c636e: // 0160:1c636e
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1c636e; break; }
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000100;
  case 0x1c6380: // 0160:1c6380
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1c6380; break; }
    memoryASet16(ds, 0x20d16d, 0x0000);
    memoryASet16(ds, 0x20d16f, 0x0002);
    memoryASet16(ds, 0x20d171, 0x0004);
    memoryASet16(ds, 0x20d173, 0x0006);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d803, r16[ax]);
    memoryASet32(ds, 0x20d7fb, r32[eax]);
    memoryASet32(ds, 0x20d7ff, r32[eax]);
    memoryASet16(ds, 0x20d7f7, 0xffb0);
    memoryASet16(ds, 0x20d7f9, 0x0050);
    memoryASet16(ds, 0x20d825, 0x0005);
    memoryASet16(ds, 0x20d869, r16[ax]);
    memoryASet16(ds, 0x20d861, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf23);
    memoryASet16(ds, 0x20d881, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf25);
    memoryASet16(ds, 0x20d883, r16[ax]);
    r32[eax] = 0;
    memoryASet16(ds, 0x20d885, r16[ax]);
    memoryASet16(ds, 0x20d887, r16[ax]);
    memoryASet16(ds, 0x20d897, r16[ax]);
    memoryASet(ds, 0x20d88b, 0x00);
    memoryASet(ds, 0x20d88d, 0x00);
    memoryASet16(ds, 0x20d88f, 0x003c);
    memoryASet16(ds, 0x20d891, 0x003c);
    memoryASet16(ds, 0x20d893, 0x003c);
    memoryASet16(ds, 0x20d895, 0x003c);
    memoryASet16(ds, 0x20dcc3, 0xffff);
    memoryASet16(ds, 0x20d8bd, 0xffff);
    memoryASet(ds, 0x20d8c0, 0x00);
    memoryASet(ds, 0x20d8bf, 0x00);
    r32[esi] = 0x0020dcc5;
    r32[ecx] = 0x000001ff;
  case 0x1c646d: // 0160:1c646d
    memoryASet16(ds, r32[esi], 0xffff);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1c646d; break; }
    r32[eax] = 0;
    memoryASet16(ds, 0x20ee3b, r16[ax]);
    memoryASet16(ds, 0x20ed97, r16[ax]);
    memoryASet16(ds, 0x20ed99, r16[ax]);
    memoryASet16(ds, 0x20ed9b, r16[ax]);
    r32[eax] = 0;
    memoryASet16(ds, 0x20ed95, r16[ax]);
    memoryASet16(ds, 0x20ed93, r16[ax]);
    memoryASet32(ds, 0x20c84e, 0xe7190345);
    memoryASet16(ds, 0x20c830, r16[ax]);
    memoryASet16(ds, 0x20c82e, r16[ax]);
    memoryASet16(ds, 0x20d87f, r16[ax]);
    memoryASet16(ds, 0x20eddd, r16[ax]);
    memoryASet16(ds, 0x20ede1, r16[ax]);
    memoryASet16(ds, 0x20ede5, r16[ax]);
    memoryASet16(ds, 0x20ede7, r16[ax]);
    memoryASet16(ds, 0x20ede9, r16[ax]);
    memoryASet16(ds, 0x20ee31, r16[ax]);
    memoryASet16(ds, 0x20ee35, r16[ax]);
    memoryASet16(ds, 0x20ee47, r16[ax]);
    memoryASet16(ds, 0x20ee37, 0x008c);
    memoryASet16(ds, 0x20e7df, r16[ax]);
    memoryASet16(ds, 0x20e7e1, r16[ax]);
    memoryASet16(ds, 0x20e7e3, r16[ax]);
    memoryASet16(ds, 0x20e7e5, 0x0008);
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1c6523; break; }
    memoryASet16(ds, 0x20e7e5, 0x0010);
  case 0x1c6523: // 0160:1c6523
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c6524() // 0160:1c6524 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x002ee384;
    memoryASet32(ds, 0x20d81d, r32[esi]);
    r32[ecx] = 0x000001f4;
  case 0x1c6534: // 0160:1c6534
    memoryASet32(ds, r32[esi], 0xffffffff);
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c6534; break; }
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00057e40;
    r32[ecx] = 0x00001d4c;
  case 0x1c6550: // 0160:1c6550
    memoryASet32(ds, r32[esi], 0xffffffff);
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c6550; break; }
    r32[esi] = 0x0023c4fb;
    r16[ax] = 0x0028;
    r32[edx] = 0x00000019;
  case 0x1c6569: // 0160:1c6569
    r16[bx] = 0x0028;
    r32[ecx] = 0x00000019;
  case 0x1c6572: // 0160:1c6572
    if (!memoryAGet(ds, r32[esi]))
        { pc = 0x1c6585; break; }
    r16[bx] += 0x0060;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1c6572; break; }
    r16[ax] += 0x0060;
    r32[edx]--;
    if (r32[edx])
        { pc = 0x1c6569; break; }
  case 0x1c6585: // 0160:1c6585
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00057e40;
    r32[ebp] = memoryAGet32(ds, 0x20b800);
    r32[ebp] += 0x00058520;
    r32[edx] = memoryAGet32(ds, 0x20b800);
    r32[edx] += 0x00058c00;
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r16[cx] = memoryAGet16(ds, 0x20ee63);
    if (r16s[cx] < signed16(0x003b))
        { pc = 0x1c65ca; break; }
    memoryASet16(ds, 0x20ceb7, 0x00af);
    { pc = 0x1c65d3; break; }
  case 0x1c65ca: // 0160:1c65ca
    memoryASet16(ds, 0x20ceb7, 0x0057);
  case 0x1c65d3: // 0160:1c65d3
    r16[cx] = 0x0000;
  case 0x1c65d7: // 0160:1c65d7
    yield* sub_1c6a11();
  case 0x1c65dc: // 0160:1c65dc
    r32[esi]--;
    r16[bx] -= 0x0060;
    r8[ch] = memoryAGet(ds, r32[esi]);
    if (!r8[ch])
        { pc = 0x1c6774; break; }
    if (r8[ch] == 0x03)
        { pc = 0x1c66c0; break; }
    if (r8[ch] == 0x04)
        { pc = 0x1c6726; break; }
    if (r8[ch] != 0x07)
        { pc = 0x1c6682; break; }
    push32(r32[edi]);
    push32(r32[edx]);
    r32[edi] = memoryAGet32(ds, 0x20d81d);
    r16[dx] = 0;
    r8[dl] = r8[cl];
    r16[dx] -= 0x0002;
    if (r16s[dx] >= 0)
        { pc = 0x1c661a; break; }
    r16[dx] = 0;
  case 0x1c661a: // 0160:1c661a
    if (signed16(memoryAGet16(ds, 0x20ee63)) >= signed16(0x003b))
        { pc = 0x1c6633; break; }
    r16[dx] <<= 1;
    memoryASet16(ds, r32[edi], r16[dx]);
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
    r16[dx] >>>= 1;
    { pc = 0x1c663a; break; }
  case 0x1c6633: // 0160:1c6633
    memoryASet16(ds, r32[edi], r16[dx]);
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
  case 0x1c663a: // 0160:1c663a
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] -= 0x0050;
    memoryASet16(ds, r32[edi] + 0x4, r16[ax]);
    r16[bx] += 0x00c8;
    memoryASet16(ds, r32[edi] + 0x6, r16[bx]);
    r16[ax] += 0x00a0;
    memoryASet16(ds, r32[edi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[edi] + 0xa, r16[bx]);
    r8[ch] = 0x00;
    if (memoryAGet16(ds, 0x20ee63) >= 0x003b)
        { pc = 0x1c6673; break; }
    r8[cl] += r8[cl];
    memoryASet16(ds, r32[edi] + 0xc, r16[cx]);
    r8[cl] >>>= 1;
    { pc = 0x1c6677; break; }
  case 0x1c6673: // 0160:1c6673
    memoryASet16(ds, r32[edi] + 0xc, r16[cx]);
  case 0x1c6677: // 0160:1c6677
    r32[ebx] = pop32();
    r32[eax] = pop32();
    memoryASet32(ds, 0x20d81d, memoryAGet32(ds, 0x20d81d) + 0x0000000e);
    r32[edx] = pop32();
    r32[edi] = pop32();
  case 0x1c6682: // 0160:1c6682
    if (r8[ch] != 0x06)
        { pc = 0x1c66b7; break; }
    push32(r32[edi]);
    push32(r32[edx]);
    r32[edi] = memoryAGet32(ds, 0x20d81d);
    r32[edi] -= 0x0000000e;
    r16[dx] = 0;
    r8[dl] = r8[cl];
    r16[dx] += 0x0005;
    if (signed16(memoryAGet16(ds, 0x20ee63)) >= signed16(0x003b))
        { pc = 0x1c66b1; break; }
    r16[dx] <<= 1;
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
    r16[dx] >>>= 1;
    { pc = 0x1c66b5; break; }
  case 0x1c66b1: // 0160:1c66b1
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
  case 0x1c66b5: // 0160:1c66b5
    r32[edx] = pop32();
    r32[edi] = pop32();
  case 0x1c66b7: // 0160:1c66b7
    r8[ch] = 0x00;
    r8[cl]++;
    { pc = 0x1c65d7; break; }
  case 0x1c66c0: // 0160:1c66c0
    r8[ch] = 0x01;
    r8[cl]++;
    yield* sub_1c6ba2();
  case 0x1c66c9: // 0160:1c66c9
    r32[esi] += 0x00000019;
    r16[ax] += 0x0060;
    r8[ch] = memoryAGet(ds, r32[esi]);
    if (r8[ch] == 0x03)
        { pc = 0x1c670d; break; }
    if (r8[ch] == 0x04)
        { pc = 0x1c66e7; break; }
    r8[ch] = 0x02;
    r8[cl]++;
    yield* sub_1c6ad8();
    { pc = 0x1c66c9; break; }
  case 0x1c66e7: // 0160:1c66e7
    r8[ch] = 0x03;
    r8[cl]++;
    yield* sub_1c6db2();
  case 0x1c66f0: // 0160:1c66f0
    r32[esi]++;
    r16[bx] += 0x0060;
    r8[ch] = memoryAGet(ds, r32[esi]);
    if (r8[ch] == 0x03)
        { pc = 0x1c6734; break; }
    if (r8[ch] == 0x04)
        { pc = 0x1c671b; break; }
    r8[ch] = 0x04;
    r8[cl]++;
    yield* sub_1c6a11();
    { pc = 0x1c66f0; break; }
    // gap 1 bytes // gap 1 bytes
  case 0x1c670d: // 0160:1c670d
    r8[ch] = 0x01;
    r8[cl]++;
    yield* sub_1c6caa();
    { pc = 0x1c65dc; break; }
  case 0x1c671b: // 0160:1c671b
    r8[ch] = 0x03;
    r8[cl]++;
    yield* sub_1c6eba();
    { pc = 0x1c66c9; break; }
  case 0x1c6726: // 0160:1c6726
    r8[ch] = 0x07;
    r8[cl]++;
    yield* sub_1c6db2();
    { pc = 0x1c673d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c6734: // 0160:1c6734
    r8[ch] = 0x05;
    r8[cl]++;
    yield* sub_1c6caa();
  case 0x1c673d: // 0160:1c673d
    r32[esi] -= 0x00000019;
    r16[ax] -= 0x0060;
    r8[ch] = memoryAGet(ds, r32[esi]);
    if (r8[ch] == 0x03)
        { pc = 0x1c675b; break; }
    if (r8[ch] == 0x04)
        { pc = 0x1c6766; break; }
    r8[ch] = 0x06;
    r8[cl]++;
    yield* sub_1c6ad8();
    { pc = 0x1c673d; break; }
  case 0x1c675b: // 0160:1c675b
    r8[ch] = 0x05;
    r8[cl]++;
    yield* sub_1c6ba2();
    { pc = 0x1c66f0; break; }
  case 0x1c6766: // 0160:1c6766
    r8[ch] = 0x07;
    r8[cl]++;
    yield* sub_1c6eba();
    { pc = 0x1c65dc; break; }
  case 0x1c6774: // 0160:1c6774
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005dfe8;
    memoryASet32(ds, 0x20d76f, r32[esi]);
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005a550;
    r16[dx] = 0x0000;
    r32[ecx] = 0x0000012c;
  case 0x1c679b: // 0160:1c679b
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00057e40;
  case 0x1c67a7: // 0160:1c67a7
    if (memoryAGet16(ds, r32[esi]) == 0xffff)
        { pc = 0x1c67b9; break; }
    if (r16[dx] == memoryAGet16(ds, r32[esi] + 0x2))
        { pc = 0x1c67c1; break; }
    r32[esi] += 0x00000008;
    { pc = 0x1c67a7; break; }
  case 0x1c67b9: // 0160:1c67b9
    r16[dx] += 0x0008;
    if (--r32[ecx])
        { pc = 0x1c679b; break; }
    { pc = 0x1c67d3; break; }
  case 0x1c67c1: // 0160:1c67c1
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    { pc = 0x1c67a7; break; }
  case 0x1c67d3: // 0160:1c67d3
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005ac30;
    r16[dx] = 0x0000;
    r32[ecx] = 0x0000012c;
  case 0x1c67e8: // 0160:1c67e8
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00058520;
  case 0x1c67f4: // 0160:1c67f4
    if (memoryAGet16(ds, r32[esi]) == 0xffff)
        { pc = 0x1c6806; break; }
    if (r16[dx] == memoryAGet16(ds, r32[esi] + 0x2))
        { pc = 0x1c680e; break; }
    r32[esi] += 0x00000008;
    { pc = 0x1c67f4; break; }
  case 0x1c6806: // 0160:1c6806
    r16[dx] += 0x0008;
    if (--r32[ecx])
        { pc = 0x1c67e8; break; }
    { pc = 0x1c6820; break; }
  case 0x1c680e: // 0160:1c680e
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r32[edi] += 0x00000008;
    r32[esi] += 0x00000008;
    { pc = 0x1c67f4; break; }
  case 0x1c6820: // 0160:1c6820
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005b310;
    r16[dx] = 0x0000;
    r32[ecx] = 0x0000012c;
  case 0x1c6835: // 0160:1c6835
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x00058c00;
  case 0x1c6841: // 0160:1c6841
    if (memoryAGet16(ds, r32[esi]) == 0xffff)
        { pc = 0x1c6853; break; }
    if (r16[dx] == memoryAGet16(ds, r32[esi] + 0x2))
        { pc = 0x1c685b; break; }
    r32[esi] += 0x0000000a;
    { pc = 0x1c6841; break; }
  case 0x1c6853: // 0160:1c6853
    r16[dx] += 0x0008;
    if (--r32[ecx])
        { pc = 0x1c6835; break; }
    { pc = 0x1c6875; break; }
  case 0x1c685b: // 0160:1c685b
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    memoryASet16(ds, r32[edi] + 0x8, r16[ax]);
    r32[edi] += 0x0000000a;
    r32[esi] += 0x0000000a;
    { pc = 0x1c6841; break; }
  case 0x1c6875: // 0160:1c6875
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005a550;
    r16[dx] = 0;
  case 0x1c6884: // 0160:1c6884
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16[ax] == 0xffff)
        { pc = 0x1c68bb; break; }
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xe);
    if (r16[bx] == 0xffff)
        { pc = 0x1c68bb; break; }
    if (r16s[ax] <= r16s[bx])
        { pc = 0x1c68b6; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    memoryASet32(ds, r32[esi], r32[ebx]);
    memoryASet32(ds, r32[esi] + 0x8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[esi] + 0xc, r32[eax]);
    r16[dx]++;
  case 0x1c68b6: // 0160:1c68b6
    r32[esi] += 0x00000008;
    { pc = 0x1c6884; break; }
  case 0x1c68bb: // 0160:1c68bb
    if (r16[dx])
        { pc = 0x1c6875; break; }
  case 0x1c68c0: // 0160:1c68c0
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005a550;
    r16[dx] = 0;
  case 0x1c68cf: // 0160:1c68cf
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16[ax] == 0xffff)
        { pc = 0x1c6910; break; }
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xe);
    if (r16[bx] == 0xffff)
        { pc = 0x1c6910; break; }
    if (r16[ax] != r16[bx])
        { pc = 0x1c690b; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    if (r16s[ax] <= signed16(memoryAGet16(ds, r32[esi] + 0xa)))
        { pc = 0x1c690b; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    memoryASet32(ds, r32[esi], r32[ebx]);
    memoryASet32(ds, r32[esi] + 0x8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[esi] + 0xc, r32[eax]);
    r16[dx]++;
  case 0x1c690b: // 0160:1c690b
    r32[esi] += 0x00000008;
    { pc = 0x1c68cf; break; }
  case 0x1c6910: // 0160:1c6910
    if (r16[dx])
        { pc = 0x1c68c0; break; }
  case 0x1c6915: // 0160:1c6915
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005ac30;
    r16[dx] = 0;
  case 0x1c6924: // 0160:1c6924
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    if (r16[ax] == 0xffff)
        { pc = 0x1c6965; break; }
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xa);
    if (r16[bx] == 0xffff)
        { pc = 0x1c6965; break; }
    if (r16[ax] != r16[bx])
        { pc = 0x1c6960; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    if (r16s[ax] <= signed16(memoryAGet16(ds, r32[esi] + 0xe)))
        { pc = 0x1c6960; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    memoryASet32(ds, r32[esi], r32[ebx]);
    memoryASet32(ds, r32[esi] + 0x8, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[esi] + 0xc, r32[eax]);
    r16[dx]++;
  case 0x1c6960: // 0160:1c6960
    r32[esi] += 0x00000008;
    { pc = 0x1c6924; break; }
  case 0x1c6965: // 0160:1c6965
    if (r16[dx])
        { pc = 0x1c6915; break; }
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x0005dfec;
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005a550;
    r16[dx] = 0;
  case 0x1c6985: // 0160:1c6985
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r16[dx] += 0x0008;
    r32[esi] += 0x00000008;
    r32[edi] += 0x00000008;
    if (memoryAGet16(ds, r32[esi]) != 0xffff)
        { pc = 0x1c6985; break; }
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005dfe8;
    memoryASet16(ds, r32[esi], r16[dx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005ac30;
  case 0x1c69bb: // 0160:1c69bb
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r16[dx] += 0x0008;
    r32[esi] += 0x00000008;
    r32[edi] += 0x00000008;
    if (memoryAGet16(ds, r32[esi]) != 0xffff)
        { pc = 0x1c69bb; break; }
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005dfea;
    memoryASet16(ds, r32[esi], r16[dx]);
    r32[esi] = memoryAGet32(ds, 0x20b800);
    r32[esi] += 0x0005b310;
  case 0x1c69f1: // 0160:1c69f1
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    memoryASet16(ds, r32[edi] + 0x8, r16[ax]);
    r32[esi] += 0x0000000a;
    r32[edi] += 0x0000000a;
    if (memoryAGet16(ds, r32[esi]) != 0xffff)
        { pc = 0x1c69f1; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6a11() // 0160:1c6a11 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c6fc2();
    if (memoryAGet16(ds, 0x20ceb3) == 0x0001)
        { pc = 0x1c6ab4; break; }
    if (memoryAGet16(ds, 0x20ceb3) == 0x0002)
        { pc = 0x1c6a7e; break; }
    if (!r8[ch])
        { pc = 0x1c6a5a; break; }
    r16[bx] -= 0x0010;
    yield* sub_1c6ab4();
    r8[cl]++;
    r16[bx] += 0x0020;
    yield* sub_1c6ab4();
    r8[cl]++;
    r16[bx] += 0x0020;
    yield* sub_1c6ab4();
    r16[bx] -= 0x0030;
    r32[esp] += 4; return;
  case 0x1c6a5a: // 0160:1c6a5a
    r16[bx] += 0x0030;
    yield* sub_1c6ab4();
    r8[cl]++;
    r16[bx] -= 0x0020;
    yield* sub_1c6ab4();
    r8[cl]++;
    r16[bx] -= 0x0020;
    yield* sub_1c6ab4();
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6a7e: // 0160:1c6a7e
    if (!r8[ch])
        { pc = 0x1c6a9b; break; }
    r16[bx] -= 0x0010;
    yield* sub_1c6ab4();
    r8[cl]++;
    r16[bx] += 0x0020;
    yield* sub_1c6ab4();
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6a9b: // 0160:1c6a9b
    r16[bx] += 0x0010;
    yield* sub_1c6ab4();
    r8[cl]++;
    r16[bx] -= 0x0020;
    yield* sub_1c6ab4();
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6ab4: // 0160:1c6ab4
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[bx] &= 0xffe0;
    r16[ax] -= 0x0050;
    memoryASet16(ds, r32[edi], r16[cx]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r16[ax] += 0x00a0;
    memoryASet16(ds, r32[edi] + 0x4, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x6, r16[bx]);
    r32[edi] += 0x00000008;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6ab4() // 0160:1c6ab4 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[bx] &= 0xffe0;
    r16[ax] -= 0x0050;
    memoryASet16(ds, r32[edi], r16[cx]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r16[ax] += 0x00a0;
    memoryASet16(ds, r32[edi] + 0x4, r16[ax]);
    memoryASet16(ds, r32[edi] + 0x6, r16[bx]);
    r32[edi] += 0x00000008;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c6ad8() // 0160:1c6ad8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c6fc2();
    if (memoryAGet16(ds, 0x20ceb3) == 0x0001)
        { pc = 0x1c6b7d; break; }
    if (memoryAGet16(ds, 0x20ceb3) == 0x0002)
        { pc = 0x1c6b46; break; }
    if (r8[ch] == 0x02)
        { pc = 0x1c6b22; break; }
    r16[ax] += 0x0030;
    yield* sub_1c6b7d();
    r8[cl]++;
    r16[ax] -= 0x0020;
    yield* sub_1c6b7d();
    r8[cl]++;
    r16[ax] -= 0x0020;
    yield* sub_1c6b7d();
    r16[ax] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6b22: // 0160:1c6b22
    r16[ax] -= 0x0010;
    yield* sub_1c6b7d();
    r8[cl]++;
    r16[ax] += 0x0020;
    yield* sub_1c6b7d();
    r8[cl]++;
    r16[ax] += 0x0020;
    yield* sub_1c6b7d();
    r16[ax] -= 0x0030;
    r32[esp] += 4; return;
  case 0x1c6b46: // 0160:1c6b46
    if (r8[ch] == 0x02)
        { pc = 0x1c6b64; break; }
    r16[ax] += 0x0010;
    yield* sub_1c6b7d();
    r8[cl]++;
    r16[ax] -= 0x0020;
    yield* sub_1c6b7d();
    r16[ax] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6b64: // 0160:1c6b64
    r16[ax] -= 0x0010;
    yield* sub_1c6b7d();
    r8[cl]++;
    r16[ax] += 0x0020;
    yield* sub_1c6b7d();
    r16[ax] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6b7d: // 0160:1c6b7d
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] &= 0xffe0;
    r16[bx] += 0x0050;
    memoryASet16(ss, r32[ebp], r16[cx]);
    memoryASet16(ss, r32[ebp] + 0x2, r16[ax]);
    memoryASet16(ss, r32[ebp] + 0x4, r16[bx]);
    r16[bx] -= 0x00a0;
    memoryASet16(ss, r32[ebp] + 0x6, r16[bx]);
    r32[ebp] += 0x00000008;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6b7d() // 0160:1c6b7d +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] &= 0xffe0;
    r16[bx] += 0x0050;
    memoryASet16(ss, r32[ebp], r16[cx]);
    memoryASet16(ss, r32[ebp] + 0x2, r16[ax]);
    memoryASet16(ss, r32[ebp] + 0x4, r16[bx]);
    r16[bx] -= 0x00a0;
    memoryASet16(ss, r32[ebp] + 0x6, r16[bx]);
    r32[ebp] += 0x00000008;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c6ba2() // 0160:1c6ba2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c6fc2();
    if (memoryAGet16(ds, 0x20ceb3) == 0x0001)
        { pc = 0x1c6c7f; break; }
    if (memoryAGet16(ds, 0x20ceb3) == 0x0002)
        { pc = 0x1c6c30; break; }
    if (r8[ch] == 0x01)
        { pc = 0x1c6bfc; break; }
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6c7f();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6c7f();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6c7f();
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6bfc: // 0160:1c6bfc
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6c7f();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6c7f();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6c7f();
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6c30: // 0160:1c6c30
    if (r8[ch] == 0x01)
        { pc = 0x1c6c5a; break; }
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6c7f();
    r8[cl]++;
    r16[ax] -= 0x0020;
    r16[bx] += 0x0020;
    yield* sub_1c6c7f();
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6c5a: // 0160:1c6c5a
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6c7f();
    r8[cl]++;
    r16[ax] += 0x0020;
    r16[bx] -= 0x0020;
    yield* sub_1c6c7f();
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6c7f: // 0160:1c6c7f
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0028;
    r16[bx] -= 0x0028;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] += 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6c7f() // 0160:1c6c7f +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0028;
    r16[bx] -= 0x0028;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] += 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c6caa() // 0160:1c6caa +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c6fc2();
    if (memoryAGet16(ds, 0x20ceb3) == 0x0001)
        { pc = 0x1c6d87; break; }
    if (memoryAGet16(ds, 0x20ceb3) == 0x0002)
        { pc = 0x1c6d38; break; }
    if (r8[ch] == 0x01)
        { pc = 0x1c6d04; break; }
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6d87();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6d87();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6d87();
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6d04: // 0160:1c6d04
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6d87();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6d87();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6d87();
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6d38: // 0160:1c6d38
    if (r8[ch] == 0x01)
        { pc = 0x1c6d62; break; }
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6d87();
    r8[cl]++;
    r16[ax] -= 0x0020;
    r16[bx] += 0x0020;
    yield* sub_1c6d87();
    r16[ax] += 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6d62: // 0160:1c6d62
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6d87();
    r8[cl]++;
    r16[ax] += 0x0020;
    r16[bx] -= 0x0020;
    yield* sub_1c6d87();
    r16[ax] -= 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6d87: // 0160:1c6d87
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0058;
    r16[bx] -= 0x0058;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] += 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6d87() // 0160:1c6d87 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0058;
    r16[bx] -= 0x0058;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] += 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c6db2() // 0160:1c6db2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c6fc2();
    if (memoryAGet16(ds, 0x20ceb3) == 0x0001)
        { pc = 0x1c6e8f; break; }
    if (memoryAGet16(ds, 0x20ceb3) == 0x0002)
        { pc = 0x1c6e40; break; }
    if (r8[ch] == 0x03)
        { pc = 0x1c6e0c; break; }
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6e8f();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6e8f();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6e8f();
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6e0c: // 0160:1c6e0c
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6e8f();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6e8f();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6e8f();
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6e40: // 0160:1c6e40
    if (r8[ch] == 0x03)
        { pc = 0x1c6e6a; break; }
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6e8f();
    r8[cl]++;
    r16[ax] -= 0x0020;
    r16[bx] -= 0x0020;
    yield* sub_1c6e8f();
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6e6a: // 0160:1c6e6a
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6e8f();
    r8[cl]++;
    r16[ax] += 0x0020;
    r16[bx] += 0x0020;
    yield* sub_1c6e8f();
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6e8f: // 0160:1c6e8f
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0058;
    r16[bx] += 0x0058;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] -= 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6e8f() // 0160:1c6e8f +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0058;
    r16[bx] += 0x0058;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] -= 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c6eba() // 0160:1c6eba +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    yield* sub_1c6fc2();
    if (memoryAGet16(ds, 0x20ceb3) == 0x0001)
        { pc = 0x1c6f97; break; }
    if (memoryAGet16(ds, 0x20ceb3) == 0x0002)
        { pc = 0x1c6f48; break; }
    if (r8[ch] == 0x03)
        { pc = 0x1c6f14; break; }
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6f97();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6f97();
    r8[cl]++;
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6f97();
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6f14: // 0160:1c6f14
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6f97();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6f97();
    r8[cl]++;
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6f97();
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6f48: // 0160:1c6f48
    if (r8[ch] == 0x03)
        { pc = 0x1c6f72; break; }
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1c6f97();
    r8[cl]++;
    r16[ax] -= 0x0020;
    r16[bx] -= 0x0020;
    yield* sub_1c6f97();
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    r32[esp] += 4; return;
  case 0x1c6f72: // 0160:1c6f72
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    yield* sub_1c6f97();
    r8[cl]++;
    r16[ax] += 0x0020;
    r16[bx] += 0x0020;
    yield* sub_1c6f97();
    r16[ax] -= 0x0010;
    r16[bx] -= 0x0010;
    r32[esp] += 4; return;
  case 0x1c6f97: // 0160:1c6f97
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0028;
    r16[bx] += 0x0028;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] -= 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6f97() // 0160:1c6f97 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    memoryASet16(ds, r32[edx], r16[cx]);
    r16[ax] -= 0x0028;
    r16[bx] += 0x0028;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x4, r16[bx]);
    r16[ax] += 0x0078;
    r16[bx] -= 0x0078;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[edx] + 0x8, r16[bx]);
    r32[edx] += 0x0000000a;
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1c6fc2() // 0160:1c6fc2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    r16[ax] = memoryAGet16(ds, 0x20ee63);
    r16[ax] -= memoryAGet16(ds, 0x20ceb5);
    r16[bx] = memoryAGet16(ds, 0x20ceb7);
    r8[bl] -= r8[cl];
    r16[cx] = 0;
  case 0x1c6fde: // 0160:1c6fde
    r16[cx]++;
    r16[bx] -= r16[ax];
    if (r16s[bx] >= 0)
        { pc = 0x1c6fde; break; }
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + 1);
    memoryASet16(ds, 0x20ceb3, r16[cx]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c6ff7() // 0160:1c6ff7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x224646, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bb00d();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[cx] = memoryAGet16(ds, 0x224656);
    r16[dx] = memoryAGet16(ds, 0x224658);
    r16[ax] -= r16[cx];
    r16[bx] -= r16[dx];
    memoryASet16(ds, 0x20ee71, memoryAGet16(ds, 0x20ee71) + r16[ax]);
    memoryASet16(ds, 0x20ee73, memoryAGet16(ds, 0x20ee73) + r16[bx]);
    memoryASet16(ds, 0x224656, 0x0064);
    memoryASet16(ds, 0x224658, 0x0064);
    yield* sub_1bafe1();
    r16[ax] = memoryAGet16(ds, 0x20ee73);
    if (!r16[ax])
        { pc = 0x1c70b4; break; }
    if (r16s[ax] < 0)
        { pc = 0x1c7085; break; }
    if (r16s[ax] < signed16(0x0030))
        { pc = 0x1c70b4; break; }
    if (!memoryAGet16(ds, 0x20e82f))
        { pc = 0x1c707a; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x01);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xfe);
  case 0x1c707a: // 0160:1c707a
    memoryASet16(ds, 0x20ee73, 0x0000);
    { pc = 0x1c70b4; break; }
  case 0x1c7085: // 0160:1c7085
    r16[ax] = -r16[ax];
    if (r16s[ax] < signed16(0x0030))
        { pc = 0x1c70b4; break; }
    r16[ax] = memoryAGet16(ds, 0x20ee75);
    if (memoryAGet16(ds, 0x20e82f) == r16[ax])
        { pc = 0x1c707a; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x02);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xfd);
    memoryASet16(ds, 0x20ee73, 0x0000);
  case 0x1c70b4: // 0160:1c70b4
    r16[ax] = memoryAGet16(ds, 0x20ee71);
    if (!r16[ax])
        { pc = 0x1c7100; break; }
    if (r16s[ax] < 0)
        { pc = 0x1c70e0; break; }
    if (r16s[ax] < signed16(0x0030))
        { pc = 0x1c7100; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xfb);
    memoryASet16(ds, 0x20ee71, 0x0000);
    { pc = 0x1c7100; break; }
  case 0x1c70e0: // 0160:1c70e0
    r16[ax] = -r16[ax];
    if (r16s[ax] < signed16(0x0030))
        { pc = 0x1c7100; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xf7);
    memoryASet16(ds, 0x20ee71, 0x0000);
  case 0x1c7100: // 0160:1c7100
    r16[ax] = memoryAGet16(ds, 0x22465a);
    if (!r16[ax])
        { pc = 0x1c7112; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1c7112: // 0160:1c7112
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c7113() // 0160:1c7113 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x224646, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x224656);
    r16[bx] = memoryAGet16(ds, 0x224658);
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1bb00d();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[cx] = memoryAGet16(ds, 0x224656);
    r16[dx] = memoryAGet16(ds, 0x224658);
    r16[ax] -= r16[cx];
    r16[bx] -= r16[dx];
    memoryASet16(ds, 0x20ee71, memoryAGet16(ds, 0x20ee71) + r16[ax]);
    memoryASet16(ds, 0x20ee73, memoryAGet16(ds, 0x20ee73) + r16[bx]);
    memoryASet16(ds, 0x224656, 0x0064);
    memoryASet16(ds, 0x224658, 0x0064);
    yield* sub_1bafe1();
    r16[ax] = memoryAGet16(ds, 0x20ee73);
    if (!r16[ax])
        { pc = 0x1c71cb; break; }
    if (r16s[ax] < 0)
        { pc = 0x1c71a1; break; }
    if (r16s[ax] < signed16(0x0060))
        { pc = 0x1c71cb; break; }
    if (signed16(memoryAGet16(ds, 0x20e82f)) < signed16(0x0005))
        { pc = 0x1c7196; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x01);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xfe);
  case 0x1c7196: // 0160:1c7196
    memoryASet16(ds, 0x20ee73, 0x0000);
    { pc = 0x1c71cb; break; }
  case 0x1c71a1: // 0160:1c71a1
    r16[ax] = -r16[ax];
    if (r16s[ax] < signed16(0x0060))
        { pc = 0x1c71cb; break; }
    if (signed16(memoryAGet16(ds, 0x20e82f)) >= signed16(0x0005))
        { pc = 0x1c7196; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x02);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xfd);
    memoryASet16(ds, 0x20ee73, 0x0000);
  case 0x1c71cb: // 0160:1c71cb
    r16[ax] = memoryAGet16(ds, 0x20ee71);
    if (!r16[ax])
        { pc = 0x1c723f; break; }
    if (r16s[ax] < 0)
        { pc = 0x1c720b; break; }
    if (r16s[ax] < signed16(0x0060))
        { pc = 0x1c723f; break; }
    if (!memoryAGet16(ds, 0x20e82f))
        { pc = 0x1c7200; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0005)
        { pc = 0x1c7200; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x04);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xfb);
  case 0x1c7200: // 0160:1c7200
    memoryASet16(ds, 0x20ee71, 0x0000);
    { pc = 0x1c723f; break; }
  case 0x1c720b: // 0160:1c720b
    r16[ax] = -r16[ax];
    if (r16s[ax] < signed16(0x0060))
        { pc = 0x1c723f; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0004)
        { pc = 0x1c7200; break; }
    if (memoryAGet16(ds, 0x20e82f) == 0x0009)
        { pc = 0x1c7200; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x08);
    memoryASet(ds, 0x20e837, memoryAGet(ds, 0x20e837) & 0xf7);
    memoryASet16(ds, 0x20ee71, 0x0000);
  case 0x1c723f: // 0160:1c723f
    r16[ax] = memoryAGet16(ds, 0x22465a);
    if (!r16[ax])
        { pc = 0x1c7251; break; }
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) | 0x80);
  case 0x1c7251: // 0160:1c7251
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c7260() // 0160:1c7260 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    yield* sub_1c8088();
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1c727c() // 0160:1c727c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c72a2; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c72a2: // 0160:1c72a2
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c7954() // 0160:1c7954 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000010;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 16);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c798f; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7991; break; }
  case 0x1c798f: // 0160:1c798f
    { pc = 0x1c79a2; break; }
  case 0x1c7991: // 0160:1c7991
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1df990();
  case 0x1c79a2: // 0160:1c79a2
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c79ac() // 0160:1c79ac +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c79ff; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c79fd; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c79e4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c79e4: // 0160:1c79e4
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c79fd: // 0160:1c79fd
    { pc = 0x1c7a39; break; }
  case 0x1c79ff: // 0160:1c79ff
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7a39; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7a20; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7a20: // 0160:1c7a20
    yield* sub_1c82bc();
    r32[eax] = 0x00000002;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000002);
  case 0x1c7a39: // 0160:1c7a39
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c7a40() // 0160:1c7a40 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7a93; break; }
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000005)
        { pc = 0x1c7a91; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7a78; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7a78: // 0160:1c7a78
    yield* sub_1c82bc();
    r32[eax] = 0x00000005;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000005);
  case 0x1c7a91: // 0160:1c7a91
    { pc = 0x1c7acd; break; }
  case 0x1c7a93: // 0160:1c7a93
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000003)
        { pc = 0x1c7acd; break; }
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7ab4; break; }
    yield* sub_1e0380();
    yield* sub_1e0690();
    yield* sub_1e0030();
  case 0x1c7ab4: // 0160:1c7ab4
    yield* sub_1c82bc();
    r32[eax] = 0x00000003;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000003);
  case 0x1c7acd: // 0160:1c7acd
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c7b00() // 0160:1c7b00 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    r32[eax] = 0x00000007;
    yield* sub_1c8008();
    memoryASet32(ds, 0x1f1cd8, 0x00000007);
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1c7de8() // 0160:1c7de8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    memoryASet32(ss, r32[ebp] - 8, r32[edx]);
    if (!memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c7e0d; break; }
    if (memoryAGet32(ds, 0x30b150))
        { pc = 0x1c7e0f; break; }
  case 0x1c7e0d: // 0160:1c7e0d
    { pc = 0x1c7e52; break; }
  case 0x1c7e0f: // 0160:1c7e0f
    yield* sub_1e0390();
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    yield* sub_1e0ab0();
    yield* sub_1e0350();
    memoryASet32(ss, r32[ebp] - 4, 0x00000000);
  case 0x1c7e2b: // 0160:1c7e2b
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x30b150)))
        { pc = 0x1c7e40; break; }
    { pc = 0x1c7e4d; break; }
  case 0x1c7e38: // 0160:1c7e38
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ss, r32[ebp] - 4, memoryAGet32(ss, r32[ebp] - 4) + 1);
    { pc = 0x1c7e2b; break; }
  case 0x1c7e40: // 0160:1c7e40
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e0740();
    { pc = 0x1c7e38; break; }
  case 0x1c7e4d: // 0160:1c7e4d
    yield* sub_1e0370();
  case 0x1c7e52: // 0160:1c7e52
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8008() // 0160:1c8008 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    if (memoryAGet32(ds, 0x1f1cd4) == 0x00000001)
        { pc = 0x1c8027; break; }
    yield* sub_1e0390();
  case 0x1c8027: // 0160:1c8027
    yield* sub_1e0690();
    if (memoryAGet32(ds, 0x1f1cd4) == 0x00000001)
        { pc = 0x1c803f; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1df8c0();
  case 0x1c803f: // 0160:1c803f
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c804b; break; }
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000012))
        { pc = 0x1c804d; break; }
  case 0x1c804b: // 0160:1c804b
    { pc = 0x1c807e; break; }
  case 0x1c804d: // 0160:1c804d
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x1f1d08);
    yield* sub_1e00f0();
    if (r32s[eax] < 0)
        { pc = 0x1c807e; break; }
    if (memoryAGet32(ds, 0x1f1cd4) == 0x00000001)
        { pc = 0x1c807e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x1f1ce8);
    yield* sub_1e00f0();
  case 0x1c807e: // 0160:1c807e
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8088() // 0160:1c8088 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    if (memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c80dd; break; }
    r32[eax] = 0x0020aa84;
    yield* sub_1e3508();
    if (!r32[eax])
        { pc = 0x1c80b9; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000004);
    { pc = 0x1c80dd; break; }
  case 0x1c80b9: // 0160:1c80b9
    r32[eax] = 0x0020aa90;
    yield* sub_1e3508();
    if (!r32[eax])
        { pc = 0x1c80d3; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000010);
    { pc = 0x1c80dd; break; }
  case 0x1c80d3: // 0160:1c80d3
    memoryASet32(ds, 0x1f1cd4, 0x00000001);
  case 0x1c80dd: // 0160:1c80dd
    if (memoryAGet32(ds, 0x1f1cd4) != 0x00000001)
        { pc = 0x1c80f2; break; }
    memoryASet32(ds, 0x30b150, 0x00000000);
    { pc = 0x1c80fc; break; }
  case 0x1c80f2: // 0160:1c80f2
    memoryASet32(ds, 0x30b150, 0x00000004);
  case 0x1c80fc: // 0160:1c80fc
    r32[edx] = 0x00000002;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0830();
    r32[edx] = 0x00000046;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e05e0();
    r32[eax] = memoryAGet32(ds, 0x30b150);
    r32[eax] += memoryAGet32(ds, 0x1f1cd0);
    r32[ebx] = memoryAGet32(ds, 0x1f1cd4);
    r32[edx] = r32[eax];
    r32[eax] = r32[ebx];
    yield* sub_1e0500();
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0440();
    r32[eax] = memoryAGet32(ds, 0x30b138);
    memoryASet32(ds, 0x30b158, r32[eax]);
    if (memoryAGet32(ds, 0x30b134) != 0x00000001)
        { pc = 0x1c818b; break; }
    r32[eax] = 0x0046a5f0;
    yield* sub_1df790();
    if (r32[eax])
        { pc = 0x1c818b; break; }
    memoryASet32(ds, 0x30b158, 0x00000000);
    r32[eax] = 0x00102ca0;
    yield* sub_1df790();
    if (r32[eax])
        { pc = 0x1c818b; break; }
    yield* sub_1c8088();
    memoryASet32(ds, 0x1f1cd4, 0x00000000);
    { pc = 0x1c8281; break; }
  case 0x1c818b: // 0160:1c818b
    if (memoryAGet32(ds, 0x30b134))
        { pc = 0x1c81c0; break; }
    memoryASet32(ds, 0x30b158, 0x00000000);
    r32[eax] = 0x00102ca0;
    yield* sub_1df790();
    if (r32[eax])
        { pc = 0x1c81c0; break; }
    yield* sub_1c8088();
    memoryASet32(ds, 0x1f1cd4, 0x00000000);
    { pc = 0x1c8281; break; }
  case 0x1c81c0: // 0160:1c81c0
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1dfcb0();
    if (!r32[eax])
        { pc = 0x1c820a; break; }
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1dfb50();
    if (!r32[eax])
        { pc = 0x1c81ed; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000000);
    { pc = 0x1c8281; break; }
  case 0x1c81ed: // 0160:1c81ed
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1dfcb0();
    if (!r32[eax])
        { pc = 0x1c820a; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000000);
    { pc = 0x1c8281; break; }
  case 0x1c820a: // 0160:1c820a
    memoryASet32(ss, r32[ebp] - 4, 0x00000000);
  case 0x1c8211: // 0160:1c8211
    r32[eax] = memoryAGet32(ds, 0x30b150);
    r32[eax] += memoryAGet32(ds, 0x1f1cd0);
    if (r32s[eax] > signed32(memoryAGet32(ss, r32[ebp] - 4)))
        { pc = 0x1c822b; break; }
    { pc = 0x1c823e; break; }
  case 0x1c8223: // 0160:1c8223
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ss, r32[ebp] - 4, memoryAGet32(ss, r32[ebp] - 4) + 1);
    { pc = 0x1c8211; break; }
  case 0x1c822b: // 0160:1c822b
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx] = memoryAGet32(ds, 0x1f1cd4);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e0760();
    { pc = 0x1c8223; break; }
  case 0x1c823e: // 0160:1c823e
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1df8c0();
    r32[ecx] = 0x00000100;
    r32[ebx] = 0x00000100;
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0800();
    r32[ecx] = 0x00000100;
    r32[ebx] = 0x00000100;
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0800();
    r32[eax] = 0x00000020;
    yield* sub_1e03a0();
  case 0x1c8281: // 0160:1c8281
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c82bc() // 0160:1c82bc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    if (memoryAGet32(ds, 0x1f1cd4))
        { pc = 0x1c8311; break; }
    r32[eax] = 0x0020aa84;
    yield* sub_1e3508();
    if (!r32[eax])
        { pc = 0x1c82ed; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000004);
    { pc = 0x1c8311; break; }
  case 0x1c82ed: // 0160:1c82ed
    r32[eax] = 0x0020aa90;
    yield* sub_1e3508();
    if (!r32[eax])
        { pc = 0x1c8307; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000010);
    { pc = 0x1c8311; break; }
  case 0x1c8307: // 0160:1c8307
    memoryASet32(ds, 0x1f1cd4, 0x00000001);
  case 0x1c8311: // 0160:1c8311
    if (memoryAGet32(ds, 0x1f1cd4) != 0x00000001)
        { pc = 0x1c8326; break; }
    memoryASet32(ds, 0x30b150, 0x00000000);
    { pc = 0x1c8330; break; }
  case 0x1c8326: // 0160:1c8326
    memoryASet32(ds, 0x30b150, 0x00000004);
  case 0x1c8330: // 0160:1c8330
    r32[edx] = 0x00000002;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0830();
    r32[edx] = 0x00000046;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e05e0();
    r32[eax] = memoryAGet32(ds, 0x30b150);
    r32[eax] += memoryAGet32(ds, 0x1f1cd0);
    r32[ebx] = memoryAGet32(ds, 0x1f1cd4);
    r32[edx] = r32[eax];
    r32[eax] = r32[ebx];
    yield* sub_1e0500();
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0440();
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1dfcb0();
    if (!r32[eax])
        { pc = 0x1c83bc; break; }
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1dfb50();
    if (!r32[eax])
        { pc = 0x1c839f; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000000);
    { pc = 0x1c8433; break; }
  case 0x1c839f: // 0160:1c839f
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1dfcb0();
    if (!r32[eax])
        { pc = 0x1c83bc; break; }
    memoryASet32(ds, 0x1f1cd4, 0x00000000);
    { pc = 0x1c8433; break; }
  case 0x1c83bc: // 0160:1c83bc
    memoryASet32(ss, r32[ebp] - 4, 0x00000000);
  case 0x1c83c3: // 0160:1c83c3
    r32[eax] = memoryAGet32(ds, 0x30b150);
    r32[eax] += memoryAGet32(ds, 0x1f1cd0);
    if (r32s[eax] > signed32(memoryAGet32(ss, r32[ebp] - 4)))
        { pc = 0x1c83dd; break; }
    { pc = 0x1c83f0; break; }
  case 0x1c83d5: // 0160:1c83d5
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ss, r32[ebp] - 4, memoryAGet32(ss, r32[ebp] - 4) + 1);
    { pc = 0x1c83c3; break; }
  case 0x1c83dd: // 0160:1c83dd
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx] = memoryAGet32(ds, 0x1f1cd4);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e0760();
    { pc = 0x1c83d5; break; }
  case 0x1c83f0: // 0160:1c83f0
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1df8c0();
    r32[ecx] = 0x00000100;
    r32[ebx] = 0x00000100;
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0800();
    r32[ecx] = 0x00000100;
    r32[ebx] = 0x00000100;
    r32[edx] = 0x00000001;
    r32[eax] = memoryAGet32(ds, 0x1f1cd4);
    yield* sub_1e0800();
    r32[eax] = 0x00000020;
    yield* sub_1e03a0();
  case 0x1c8433: // 0160:1c8433
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8474() // 0160:1c8474 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    r32[edx] = 0x000003e8;
    r32[eax] = 0;
    yield* sub_1e03c0();
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1c84b4() // 0160:1c84b4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c84d4; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c84d6; break; }
  case 0x1c84d4: // 0160:1c84d4
    { pc = 0x1c8519; break; }
  case 0x1c84d6: // 0160:1c84d6
    if (memoryAGet32(ds, 0x30b13c) != 0x00000001)
        { pc = 0x1c84e9; break; }
    r32[eax] = 0x000000ff;
    yield* sub_1e0dd0();
  case 0x1c84e9: // 0160:1c84e9
    if (memoryAGet32(ds, 0x30b13c) != 0x00000002)
        { pc = 0x1c84fc; break; }
    r32[eax] = 0x000000a0;
    yield* sub_1e0dd0();
  case 0x1c84fc: // 0160:1c84fc
    if (memoryAGet32(ds, 0x30b13c) != 0x00000003)
        { pc = 0x1c850f; break; }
    r32[eax] = 0x00000050;
    yield* sub_1e0dd0();
  case 0x1c850f: // 0160:1c850f
    r32[eax] = 0x00000002;
    yield* sub_1e0d50();
  case 0x1c8519: // 0160:1c8519
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8520() // 0160:1c8520 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8540; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c8542; break; }
  case 0x1c8540: // 0160:1c8540
    { pc = 0x1c8585; break; }
  case 0x1c8542: // 0160:1c8542
    if (memoryAGet32(ds, 0x30b13c) != 0x00000001)
        { pc = 0x1c8555; break; }
    r32[eax] = 0x000000ff;
    yield* sub_1e0dd0();
  case 0x1c8555: // 0160:1c8555
    if (memoryAGet32(ds, 0x30b13c) != 0x00000002)
        { pc = 0x1c8568; break; }
    r32[eax] = 0x000000a0;
    yield* sub_1e0dd0();
  case 0x1c8568: // 0160:1c8568
    if (memoryAGet32(ds, 0x30b13c) != 0x00000003)
        { pc = 0x1c857b; break; }
    r32[eax] = 0x00000050;
    yield* sub_1e0dd0();
  case 0x1c857b: // 0160:1c857b
    r32[eax] = 0x00000003;
    yield* sub_1e0d50();
  case 0x1c8585: // 0160:1c8585
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c858c() // 0160:1c858c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c85ac; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c85ae; break; }
  case 0x1c85ac: // 0160:1c85ac
    { pc = 0x1c85f1; break; }
  case 0x1c85ae: // 0160:1c85ae
    if (memoryAGet32(ds, 0x30b13c) != 0x00000001)
        { pc = 0x1c85c1; break; }
    r32[eax] = 0x000000ff;
    yield* sub_1e0dd0();
  case 0x1c85c1: // 0160:1c85c1
    if (memoryAGet32(ds, 0x30b13c) != 0x00000002)
        { pc = 0x1c85d4; break; }
    r32[eax] = 0x000000a0;
    yield* sub_1e0dd0();
  case 0x1c85d4: // 0160:1c85d4
    if (memoryAGet32(ds, 0x30b13c) != 0x00000003)
        { pc = 0x1c85e7; break; }
    r32[eax] = 0x00000050;
    yield* sub_1e0dd0();
  case 0x1c85e7: // 0160:1c85e7
    r32[eax] = 0x00000004;
    yield* sub_1e0d50();
  case 0x1c85f1: // 0160:1c85f1
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c85f8() // 0160:1c85f8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8618; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c861a; break; }
  case 0x1c8618: // 0160:1c8618
    { pc = 0x1c865d; break; }
  case 0x1c861a: // 0160:1c861a
    if (memoryAGet32(ds, 0x30b13c) != 0x00000001)
        { pc = 0x1c862d; break; }
    r32[eax] = 0x000000ff;
    yield* sub_1e0dd0();
  case 0x1c862d: // 0160:1c862d
    if (memoryAGet32(ds, 0x30b13c) != 0x00000002)
        { pc = 0x1c8640; break; }
    r32[eax] = 0x000000a0;
    yield* sub_1e0dd0();
  case 0x1c8640: // 0160:1c8640
    if (memoryAGet32(ds, 0x30b13c) != 0x00000003)
        { pc = 0x1c8653; break; }
    r32[eax] = 0x00000050;
    yield* sub_1e0dd0();
  case 0x1c8653: // 0160:1c8653
    r32[eax] = 0x00000005;
    yield* sub_1e0d50();
  case 0x1c865d: // 0160:1c865d
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8664() // 0160:1c8664 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8684; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c8686; break; }
  case 0x1c8684: // 0160:1c8684
    { pc = 0x1c86c9; break; }
  case 0x1c8686: // 0160:1c8686
    if (memoryAGet32(ds, 0x30b13c) != 0x00000001)
        { pc = 0x1c8699; break; }
    r32[eax] = 0x000000ff;
    yield* sub_1e0dd0();
  case 0x1c8699: // 0160:1c8699
    if (memoryAGet32(ds, 0x30b13c) != 0x00000002)
        { pc = 0x1c86ac; break; }
    r32[eax] = 0x000000a0;
    yield* sub_1e0dd0();
  case 0x1c86ac: // 0160:1c86ac
    if (memoryAGet32(ds, 0x30b13c) != 0x00000003)
        { pc = 0x1c86bf; break; }
    r32[eax] = 0x00000050;
    yield* sub_1e0dd0();
  case 0x1c86bf: // 0160:1c86bf
    r32[eax] = 0x00000006;
    yield* sub_1e0d50();
  case 0x1c86c9: // 0160:1c86c9
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c86d0() // 0160:1c86d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c86f0; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c86f2; break; }
  case 0x1c86f0: // 0160:1c86f0
    { pc = 0x1c86fc; break; }
  case 0x1c86f2: // 0160:1c86f2
    r32[eax] = memoryAGet32(ds, 0x30b144);
    yield* sub_1e0dd0();
  case 0x1c86fc: // 0160:1c86fc
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8734() // 0160:1c8734 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8754; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c8756; break; }
  case 0x1c8754: // 0160:1c8754
    { pc = 0x1c875b; break; }
  case 0x1c8756: // 0160:1c8756
    yield* sub_1e0d60();
  case 0x1c875b: // 0160:1c875b
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8764() // 0160:1c8764 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000000;
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8784; break; }
    if (memoryAGet32(ds, 0x30b140) == 0x00000001)
        { pc = 0x1c8786; break; }
  case 0x1c8784: // 0160:1c8784
    { pc = 0x1c878b; break; }
  case 0x1c8786: // 0160:1c8786
    yield* sub_1e0d70();
  case 0x1c878b: // 0160:1c878b
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8794() // 0160:1c8794 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    yield* sub_1e3562();
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1c8824() // 0160:1c8824 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    if (memoryAGet32(ss, r32[ebp] - 8) <= 0x00000001)
        { pc = 0x1c884d; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x4);
    yield* sub_1e3691();
    memoryASet32(ds, 0x1f1d30, r32[eax]);
  case 0x1c884d: // 0160:1c884d
    if (memoryAGet32(ss, r32[ebp] - 8) <= 0x00000002)
        { pc = 0x1c8865; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x8);
    yield* sub_1e3691();
    r8[al] &= 0xf0;
    memoryASet32(ds, 0x1f1d28, r32[eax]);
  case 0x1c8865: // 0160:1c8865
    if (memoryAGet32(ss, r32[ebp] - 8) <= 0x00000003)
        { pc = 0x1c887b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0xc);
    yield* sub_1e3691();
    memoryASet32(ds, 0x1f1d2c, r32[eax]);
  case 0x1c887b: // 0160:1c887b
    if (!memoryAGet32(ds, 0x1f1d28))
        { pc = 0x1c8890; break; }
    if (signed32(memoryAGet32(ds, 0x1f1d28)) <= signed32(0x00000140))
        { pc = 0x1c889a; break; }
  case 0x1c8890: // 0160:1c8890
    memoryASet32(ds, 0x1f1d28, 0x00000140);
  case 0x1c889a: // 0160:1c889a
    if (!memoryAGet32(ds, 0x1f1d2c))
        { pc = 0x1c88af; break; }
    if (signed32(memoryAGet32(ds, 0x1f1d2c)) <= signed32(0x000000f0))
        { pc = 0x1c88b9; break; }
  case 0x1c88af: // 0160:1c88af
    memoryASet32(ds, 0x1f1d2c, 0x000000f0);
  case 0x1c88b9: // 0160:1c88b9
    if (signed32(memoryAGet32(ds, 0x1f1d28)) >= signed32(0x00000090))
        { pc = 0x1c88cf; break; }
    memoryASet32(ds, 0x1f1d28, 0x00000090);
  case 0x1c88cf: // 0160:1c88cf
    if (signed32(memoryAGet32(ds, 0x1f1d2c)) >= signed32(0x00000080))
        { pc = 0x1c88e5; break; }
    memoryASet32(ds, 0x1f1d2c, 0x00000080);
  case 0x1c88e5: // 0160:1c88e5
    memoryASet32(ds, 0x30b138, 0x00000000);
    memoryASet32(ds, 0x30b140, 0x00000000);
    memoryASet32(ds, 0x30b13c, 0x00000000);
    memoryASet32(ds, 0x30b134, 0x00000000);
    if (memoryAGet32(ds, 0x30b13c) != 0x00000001)
        { pc = 0x1c8920; break; }
    memoryASet32(ds, 0x30b13c, 0x00000002);
  case 0x1c8920: // 0160:1c8920
    memoryASet32(ds, 0x30b154, 0x00000000);
    memoryASet32(ds, 0x30b130, 0x00000001);
    if (memoryAGet32(ds, 0x30b138) != 0x00000001)
        { pc = 0x1c8947; break; }
    yield* sub_1e0d40();
    memoryASet32(ds, 0x30b154, r32[eax]);
  case 0x1c8947: // 0160:1c8947
    if (memoryAGet32(ds, 0x30b154) != 0x00000001)
        { pc = 0x1c8969; break; }
    memoryASet32(ds, 0x30b144, 0x000000ff);
    r32[eax] = 0x000000ff;
    yield* sub_1e0dd0();
    yield* sub_1e0d80();
  case 0x1c8969: // 0160:1c8969
    yield* sub_1a807e();
    yield* sub_1a801e();
    r32[eax] = 0x00000003;
    yield* sub_1aa5d3();
    r32[eax] = 0x0020aac0;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aafc;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ab30;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ab5c;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aba8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020abf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ac44;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ac58;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ac8c;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020acd4;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ad08;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ad4c;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    if (memoryAGet32(ds, 0x30b138) != 0x00000001)
        { pc = 0x1c8ac8; break; }
    r32[eax] = 0x0020aaf8;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ad78;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020adc4;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020ae10;
    push32(r32[eax]);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
  case 0x1c8ac8: // 0160:1c8ac8
    r32[eax] = 0;
    yield* sub_1e3663();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8ae0() // 0160:1c8ae0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1c8aec; break; }
    r32[esp] += 4; return;
  case 0x1c8aec: // 0160:1c8aec
    r32[edi] = 0x00200a10;
    memoryASet32(ds, 0x20e819, r32[edi]);
    if (!(memoryAGet16(ds, 0x20cf3f) & 0xffff))
        { pc = 0x1c8b07; break; }
    yield* sub_1c8b58();
  case 0x1c8b07: // 0160:1c8b07
    if (!(memoryAGet16(ds, 0x20cf41) & 0xffff))
        { pc = 0x1c8b27; break; }
    yield* sub_1c8c9d();
    if (!(memoryAGet16(ds, 0x20cf3f) & 0xffff))
        { pc = 0x1c8b27; break; }
    yield* sub_1c8f33();
  case 0x1c8b27: // 0160:1c8b27
    if (!(memoryAGet16(ds, 0x20cf43) & 0xffff))
        { pc = 0x1c8b57; break; }
    yield* sub_1c8de8();
    if (!(memoryAGet16(ds, 0x20cf3f) & 0xffff))
        { pc = 0x1c8b47; break; }
    yield* sub_1c9084();
  case 0x1c8b47: // 0160:1c8b47
    if (!(memoryAGet16(ds, 0x20cf41) & 0xffff))
        { pc = 0x1c8b57; break; }
    { pc = 0x1c91d5; break; }
  case 0x1c8b57: // 0160:1c8b57
    r32[esp] += 4; return;
    // gap 1661 bytes // gap 1661 bytes
  case 0x1c91d5: // 0160:1c91d5
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[ax] -= memoryAGet16(ds, 0x20cf55);
    if (r16[ax] < 0x0018)
        { pc = 0x1c91f2; break; }
    if (r16[ax] < 0xffe8)
        { pc = 0x1c920c; break; }
  case 0x1c91f2: // 0160:1c91f2
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bx] -= memoryAGet16(ds, 0x20cf67);
    if (r16[bx] < 0x0018)
        { pc = 0x1c920f; break; }
    if (r16[bx] >= 0xffe8)
        { pc = 0x1c920f; break; }
  case 0x1c920c: // 0160:1c920c
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c920f: // 0160:1c920f
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1c920c; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1c920c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d061);
    r16[ax] -= memoryAGet16(ds, 0x20d063);
    r16[ax] += 0x0006;
    if (r16s[ax] < 0)
        { pc = 0x1c920c; break; }
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1c920c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf89);
    memoryASet16(ds, 0x20d135, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20d139, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20d13b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20d141, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf8b);
    memoryASet16(ds, 0x20d137, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    memoryASet16(ds, 0x20d13d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    memoryASet16(ds, 0x20d13f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20d145, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20d147, r16[ax]);
    yield* sub_1c9326();
    if (!r16[ax])
        { pc = 0x1c920c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d141);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    memoryASet16(ds, 0x20cf9b, r16[ax]);
    memoryASet16(ds, 0x20d03d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d145);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    memoryASet16(ds, 0x20cf9d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20d03f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d103);
    yield* sub_1c9cd7();
    r16[ax] = memoryAGet16(ds, 0x20e7e5);
    memoryASet16(ds, 0x20e7e1, r16[ax]);
    memoryASet16(ds, 0x20e7e3, r16[ax]);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8b58() // 0160:1c8b58 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[ax] -= memoryAGet16(ds, 0x20cf51);
    if (r16[ax] < 0x0018)
        { pc = 0x1c8b75; break; }
    if (r16[ax] < 0xffe8)
        { pc = 0x1c8b8f; break; }
  case 0x1c8b75: // 0160:1c8b75
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bx] -= memoryAGet16(ds, 0x20cf63);
    if (r16[bx] < 0x0018)
        { pc = 0x1c8b92; break; }
    if (r16[bx] >= 0xffe8)
        { pc = 0x1c8b92; break; }
  case 0x1c8b8f: // 0160:1c8b8f
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c8b92: // 0160:1c8b92
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1c8b8f; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1c8b8f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    r16[ax] -= memoryAGet16(ds, 0x20d05f);
    r16[ax] += 0x0006;
    if (r16s[ax] < 0)
        { pc = 0x1c8b8f; break; }
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1c8b8f; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf85);
    memoryASet16(ds, 0x20d135, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20d139, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20d13b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20d141, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf87);
    memoryASet16(ds, 0x20d137, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    memoryASet16(ds, 0x20d13d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    memoryASet16(ds, 0x20d13f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20d145, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d147, r16[ax]);
    yield* sub_1c9326();
    if (!r16[ax])
        { pc = 0x1c8b8f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d141);
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    memoryASet16(ds, 0x20cf97, r16[ax]);
    memoryASet16(ds, 0x20d039, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d145);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    memoryASet16(ds, 0x20cf99, r16[ax]);
    memoryASet16(ds, 0x20d03b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    yield* sub_1c9cd7();
    r16[ax] = memoryAGet16(ds, 0x20e7e5);
    memoryASet16(ds, 0x20e7df, r16[ax]);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8c9d() // 0160:1c8c9d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[ax] -= memoryAGet16(ds, 0x20cf53);
    if (r16[ax] < 0x0018)
        { pc = 0x1c8cba; break; }
    if (r16[ax] < 0xffe8)
        { pc = 0x1c8cd4; break; }
  case 0x1c8cba: // 0160:1c8cba
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bx] -= memoryAGet16(ds, 0x20cf65);
    if (r16[bx] < 0x0018)
        { pc = 0x1c8cd7; break; }
    if (r16[bx] >= 0xffe8)
        { pc = 0x1c8cd7; break; }
  case 0x1c8cd4: // 0160:1c8cd4
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c8cd7: // 0160:1c8cd7
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1c8cd4; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1c8cd4; break; }
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    r16[ax] -= memoryAGet16(ds, 0x20d061);
    r16[ax] += 0x0006;
    if (r16s[ax] < 0)
        { pc = 0x1c8cd4; break; }
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1c8cd4; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf85);
    memoryASet16(ds, 0x20d135, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20d139, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20d13b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20d141, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf89);
    memoryASet16(ds, 0x20d137, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20d13d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20d13f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20d145, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20d147, r16[ax]);
    yield* sub_1c9326();
    if (!r16[ax])
        { pc = 0x1c8cd4; break; }
    r16[ax] = memoryAGet16(ds, 0x20d141);
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    memoryASet16(ds, 0x20cf97, r16[ax]);
    memoryASet16(ds, 0x20d039, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d145);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    memoryASet16(ds, 0x20cf9b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d03d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    yield* sub_1c9cd7();
    r16[ax] = memoryAGet16(ds, 0x20e7e5);
    memoryASet16(ds, 0x20e7e1, r16[ax]);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8de8() // 0160:1c8de8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[ax] -= memoryAGet16(ds, 0x20cf55);
    if (r16[ax] < 0x0018)
        { pc = 0x1c8e05; break; }
    if (r16[ax] < 0xffe8)
        { pc = 0x1c8e1f; break; }
  case 0x1c8e05: // 0160:1c8e05
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bx] -= memoryAGet16(ds, 0x20cf67);
    if (r16[bx] < 0x0018)
        { pc = 0x1c8e22; break; }
    if (r16[bx] >= 0xffe8)
        { pc = 0x1c8e22; break; }
  case 0x1c8e1f: // 0160:1c8e1f
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c8e22: // 0160:1c8e22
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1c8e1f; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1c8e1f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    r16[ax] -= memoryAGet16(ds, 0x20d063);
    r16[ax] += 0x0006;
    if (r16s[ax] < 0)
        { pc = 0x1c8e1f; break; }
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1c8e1f; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf85);
    memoryASet16(ds, 0x20d135, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20d139, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20d13b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20d141, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf8b);
    memoryASet16(ds, 0x20d137, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    memoryASet16(ds, 0x20d13d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    memoryASet16(ds, 0x20d13f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20d145, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20d147, r16[ax]);
    yield* sub_1c9326();
    if (!r16[ax])
        { pc = 0x1c8e1f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d141);
    memoryASet16(ds, 0x20cfa9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    memoryASet16(ds, 0x20cf97, r16[ax]);
    memoryASet16(ds, 0x20d039, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d145);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    memoryASet16(ds, 0x20cf9d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d03f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    yield* sub_1c9cd7();
    r16[ax] = memoryAGet16(ds, 0x20e7e5);
    memoryASet16(ds, 0x20e7e3, r16[ax]);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c8f33() // 0160:1c8f33 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[ax] -= memoryAGet16(ds, 0x20cf53);
    if (r16[ax] < 0x0018)
        { pc = 0x1c8f50; break; }
    if (r16[ax] < 0xffe8)
        { pc = 0x1c8f6a; break; }
  case 0x1c8f50: // 0160:1c8f50
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bx] -= memoryAGet16(ds, 0x20cf65);
    if (r16[bx] < 0x0018)
        { pc = 0x1c8f6d; break; }
    if (r16[bx] >= 0xffe8)
        { pc = 0x1c8f6d; break; }
  case 0x1c8f6a: // 0160:1c8f6a
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c8f6d: // 0160:1c8f6d
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1c8f6a; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1c8f6a; break; }
    r16[ax] = memoryAGet16(ds, 0x20d05f);
    r16[ax] -= memoryAGet16(ds, 0x20d061);
    r16[ax] += 0x0006;
    if (r16s[ax] < 0)
        { pc = 0x1c8f6a; break; }
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1c8f6a; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf87);
    memoryASet16(ds, 0x20d135, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    memoryASet16(ds, 0x20d139, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    memoryASet16(ds, 0x20d13b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20d141, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf89);
    memoryASet16(ds, 0x20d137, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20d13d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20d13f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20d145, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20d147, r16[ax]);
    yield* sub_1c9326();
    if (!r16[ax])
        { pc = 0x1c8f6a; break; }
    r16[ax] = memoryAGet16(ds, 0x20d141);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    memoryASet16(ds, 0x20cf99, r16[ax]);
    memoryASet16(ds, 0x20d03b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d145);
    memoryASet16(ds, 0x20cfad, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    memoryASet16(ds, 0x20cf9b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d03d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d101);
    yield* sub_1c9cd7();
    r16[ax] = memoryAGet16(ds, 0x20e7e5);
    memoryASet16(ds, 0x20e7df, r16[ax]);
    memoryASet16(ds, 0x20e7e1, r16[ax]);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c9084() // 0160:1c9084 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[ax] -= memoryAGet16(ds, 0x20cf55);
    if (r16[ax] < 0x0018)
        { pc = 0x1c90a1; break; }
    if (r16[ax] < 0xffe8)
        { pc = 0x1c90bb; break; }
  case 0x1c90a1: // 0160:1c90a1
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bx] -= memoryAGet16(ds, 0x20cf67);
    if (r16[bx] < 0x0018)
        { pc = 0x1c90be; break; }
    if (r16[bx] >= 0xffe8)
        { pc = 0x1c90be; break; }
  case 0x1c90bb: // 0160:1c90bb
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c90be: // 0160:1c90be
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1c90bb; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1c90bb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d05f);
    r16[ax] -= memoryAGet16(ds, 0x20d063);
    r16[ax] += 0x0006;
    if (r16s[ax] < 0)
        { pc = 0x1c90bb; break; }
    if (r16s[ax] >= signed16(0x000c))
        { pc = 0x1c90bb; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf87);
    memoryASet16(ds, 0x20d135, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    memoryASet16(ds, 0x20d139, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    memoryASet16(ds, 0x20d13b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20d141, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf8b);
    memoryASet16(ds, 0x20d137, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    memoryASet16(ds, 0x20d13d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    memoryASet16(ds, 0x20d13f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20d145, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20d147, r16[ax]);
    yield* sub_1c9326();
    if (!r16[ax])
        { pc = 0x1c90bb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d141);
    memoryASet16(ds, 0x20cfab, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    memoryASet16(ds, 0x20cf99, r16[ax]);
    memoryASet16(ds, 0x20d03b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d145);
    memoryASet16(ds, 0x20cfaf, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    memoryASet16(ds, 0x20cf9d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d03f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d101);
    yield* sub_1c9cd7();
    r16[ax] = memoryAGet16(ds, 0x20e7e5);
    memoryASet16(ds, 0x20e7df, r16[ax]);
    memoryASet16(ds, 0x20e7e3, r16[ax]);
    r16[ax] = 0x0001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c9326() // 0160:1c9326 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bp] = memoryAGet16(ds, 0x20d139);
    r16[cx] = memoryAGet16(ds, 0x20d13b);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d135);
    r16[ax] <<= 4;
    r32[esi] = 0x0020583c;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020d2cd;
    r16[dx] = memoryAGet16(ds, r32[esi]);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi], r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi] + 0x8, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0xa, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xc);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi] + 0xc, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xe);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0xe, r16[dx]);
    r32[ebx] = 0x0020d2ed;
    r32[eax] = 0x00000020;
    memoryASet32(ds, r32[ebx], r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x4, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x8, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0xc, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x10, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x14, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x18, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x1c, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x20, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x24, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x28, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x2c, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x30, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x34, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x38, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x3c, r32[eax]);
    r32[esi] = 0x00205a3c;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d137);
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    push32(r32[ecx]);
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r16[cx]++;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, 0x20e805, r16[ax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[esi] += 0x00000006;
    r32[ebx] = 0x0020d2ed;
    r32[ebx] += r32[eax];
  case 0x1c9413: // 0160:1c9413
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[ebx] += 0x00000004;
    r32[esi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c9413; break; }
    r32[ecx] = pop32();
    r32[ebx] = 0x0020d2ed;
    r16[ax] = memoryAGet16(ds, 0x20d2cd);
    r16[ax] -= memoryAGet16(ds, 0x20d13d);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c94e3; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2cf);
    r16[bp] -= memoryAGet16(ds, 0x20d13f);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c94e3; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c94a4; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13d);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13d);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2cd))
        { pc = 0x1c94e3; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2cd))
        { pc = 0x1c94e3; break; }
    r32[eax] = 0x00000001;
    { pc = 0x1c9b17; break; }
  case 0x1c94a4: // 0160:1c94a4
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13f);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13f);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2cf))
        { pc = 0x1c94e3; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2cf))
        { pc = 0x1c94e3; break; }
    r32[eax] = 0x00000001;
    { pc = 0x1c9b17; break; }
  case 0x1c94e3: // 0160:1c94e3
    r16[ax] = memoryAGet16(ds, 0x20d2d1);
    r16[ax] -= memoryAGet16(ds, 0x20d13d);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c95a1; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2d3);
    r16[bp] -= memoryAGet16(ds, 0x20d13f);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c95a1; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c9562; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13d);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13d);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d1))
        { pc = 0x1c95a1; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d1))
        { pc = 0x1c95a1; break; }
    r32[eax] = 0x00000002;
    { pc = 0x1c9b17; break; }
  case 0x1c9562: // 0160:1c9562
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13f);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13f);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d3))
        { pc = 0x1c95a1; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d3))
        { pc = 0x1c95a1; break; }
    r32[eax] = 0x00000002;
    { pc = 0x1c9b17; break; }
  case 0x1c95a1: // 0160:1c95a1
    r16[ax] = memoryAGet16(ds, 0x20d2d5);
    r16[ax] -= memoryAGet16(ds, 0x20d13d);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c965f; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2d7);
    r16[bp] -= memoryAGet16(ds, 0x20d13f);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c965f; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c9620; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13d);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13d);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d5))
        { pc = 0x1c965f; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d5))
        { pc = 0x1c965f; break; }
    r32[eax] = 0x00000003;
    { pc = 0x1c9b17; break; }
  case 0x1c9620: // 0160:1c9620
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13f);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13f);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d7))
        { pc = 0x1c965f; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d7))
        { pc = 0x1c965f; break; }
    r32[eax] = 0x00000003;
    { pc = 0x1c9b17; break; }
  case 0x1c965f: // 0160:1c965f
    r16[ax] = memoryAGet16(ds, 0x20d2d9);
    r16[ax] -= memoryAGet16(ds, 0x20d13d);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c971d; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2db);
    r16[bp] -= memoryAGet16(ds, 0x20d13f);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c971d; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c96de; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13d);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13d);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d9))
        { pc = 0x1c971d; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d9))
        { pc = 0x1c971d; break; }
    r32[eax] = 0x00000004;
    { pc = 0x1c9b17; break; }
  case 0x1c96de: // 0160:1c96de
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13f);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13f);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2db))
        { pc = 0x1c971d; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2db))
        { pc = 0x1c971d; break; }
    r32[eax] = 0x00000004;
    { pc = 0x1c9b17; break; }
  case 0x1c971d: // 0160:1c971d
    r16[bp] = memoryAGet16(ds, 0x20d13d);
    r16[cx] = memoryAGet16(ds, 0x20d13f);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d137);
    r16[ax] <<= 4;
    r32[esi] = 0x0020583c;
    r32[esi] += r32[eax];
    r32[edi] = 0x0020d2cd;
    r16[dx] = memoryAGet16(ds, r32[esi]);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi], r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0x2, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi] + 0x4, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0x6, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi] + 0x8, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0xa, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xc);
    r16[dx] += r16[bp];
    memoryASet16(ds, r32[edi] + 0xc, r16[dx]);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xe);
    r16[dx] += r16[cx];
    memoryASet16(ds, r32[edi] + 0xe, r16[dx]);
    r32[ebx] = 0x0020d2ed;
    r32[eax] = 0x00000020;
    memoryASet32(ds, r32[ebx], r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x4, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x8, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0xc, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x10, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x14, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x18, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x1c, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x20, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x24, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x28, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x2c, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x30, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x34, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x38, r32[eax]);
    memoryASet32(ds, r32[ebx] + 0x3c, r32[eax]);
    r32[esi] = 0x00205a3c;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d135);
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, r32[esi] + r32[eax]);
    push32(r32[ecx]);
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r16[cx]++;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, 0x20e805, r16[ax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[esi] += 0x00000006;
    r32[ebx] = 0x0020d2ed;
    r32[ebx] += r32[eax];
  case 0x1c980a: // 0160:1c980a
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[esi] += 0x00000004;
    r32[ebx] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1c980a; break; }
    r32[ecx] = pop32();
    r32[ebx] = 0x0020d2ed;
    r16[ax] = memoryAGet16(ds, 0x20d2cd);
    r16[ax] -= memoryAGet16(ds, 0x20d139);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c98da; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2cf);
    r16[bp] -= memoryAGet16(ds, 0x20d13b);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c98da; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c989b; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d139);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d139);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2cd))
        { pc = 0x1c98da; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2cd))
        { pc = 0x1c98da; break; }
    r32[eax] = 0x00000005;
    { pc = 0x1c9b17; break; }
  case 0x1c989b: // 0160:1c989b
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13b);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13b);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2cf))
        { pc = 0x1c98da; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2cf))
        { pc = 0x1c98da; break; }
    r32[eax] = 0x00000005;
    { pc = 0x1c9b17; break; }
  case 0x1c98da: // 0160:1c98da
    r16[ax] = memoryAGet16(ds, 0x20d2d1);
    r16[ax] -= memoryAGet16(ds, 0x20d139);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c9998; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2d3);
    r16[bp] -= memoryAGet16(ds, 0x20d13b);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c9998; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c9959; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d139);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d139);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d1))
        { pc = 0x1c9998; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d1))
        { pc = 0x1c9998; break; }
    r32[eax] = 0x00000006;
    { pc = 0x1c9b17; break; }
  case 0x1c9959: // 0160:1c9959
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13b);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13b);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d3))
        { pc = 0x1c9998; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d3))
        { pc = 0x1c9998; break; }
    r32[eax] = 0x00000006;
    { pc = 0x1c9b17; break; }
  case 0x1c9998: // 0160:1c9998
    r16[ax] = memoryAGet16(ds, 0x20d2d5);
    r16[ax] -= memoryAGet16(ds, 0x20d139);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c9a56; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2d7);
    r16[bp] -= memoryAGet16(ds, 0x20d13b);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c9a56; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c9a17; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d139);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d139);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d5))
        { pc = 0x1c9a56; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d5))
        { pc = 0x1c9a56; break; }
    r32[eax] = 0x00000007;
    { pc = 0x1c9b17; break; }
  case 0x1c9a17: // 0160:1c9a17
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13b);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13b);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d7))
        { pc = 0x1c9a56; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d7))
        { pc = 0x1c9a56; break; }
    r32[eax] = 0x00000007;
    { pc = 0x1c9b17; break; }
  case 0x1c9a56: // 0160:1c9a56
    r16[ax] = memoryAGet16(ds, 0x20d2d9);
    r16[ax] -= memoryAGet16(ds, 0x20d139);
    if (r16[ax] >= 0x0020)
        { pc = 0x1c9b14; break; }
    r16[bp] = memoryAGet16(ds, 0x20d2db);
    r16[bp] -= memoryAGet16(ds, 0x20d13b);
    if (r16[bp] >= 0x0020)
        { pc = 0x1c9b14; break; }
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1c9ad5; break; }
    r16[bp] &= 0x001e;
    r16[bp] <<= 1;
    r32[eax] = 0;
    r16[ax] = r16[bp];
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d139);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d139);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2d9))
        { pc = 0x1c9b14; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2d9))
        { pc = 0x1c9b14; break; }
    r32[eax] = 0x00000008;
    { pc = 0x1c9b17; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c9ad5: // 0160:1c9ad5
    r32[eax] &= 0x0000001e;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] += memoryAGet16(ds, 0x20d13b);
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    r16[ax] += memoryAGet16(ds, 0x20d13b);
    memoryASet16(ds, 0x20e7fd, r16[ax]);
    if (r16[dx] >= memoryAGet16(ds, 0x20d2db))
        { pc = 0x1c9b14; break; }
    if (r16[ax] <= memoryAGet16(ds, 0x20d2db))
        { pc = 0x1c9b14; break; }
    r32[eax] = 0x00000008;
    { pc = 0x1c9b17; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1c9b14: // 0160:1c9b14
    r32[eax] = 0;
    r32[esp] += 4; return;
  case 0x1c9b17: // 0160:1c9b17
    memoryASet16(ds, 0x20d76d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d143);
    r16[bx] = memoryAGet16(ds, 0x20d141);
    yield* sub_1cdb0a();
    memoryASet32(ds, 0x20cecb, r32[eax]);
    memoryASet32(ds, 0x20cecf, r32[ebx]);
    r32[eax] &= r32[eax];
    if (r32s[eax] < 0)
        { pc = 0x1c9b43; break; }
    r32[eax] >>>= 6;
    { pc = 0x1c9b4a; break; }
  case 0x1c9b43: // 0160:1c9b43
    r32[eax] = -r32[eax];
    r32[eax] >>>= 6;
    r32[eax] = -r32[eax];
  case 0x1c9b4a: // 0160:1c9b4a
    memoryASet32(ds, 0x20ced3, r32[eax]);
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) - r32[eax]);
    r32[ebx] &= r32[ebx];
    if (r32s[ebx] < 0)
        { pc = 0x1c9b5e; break; }
    r32[ebx] >>>= 6;
    { pc = 0x1c9b65; break; }
  case 0x1c9b5e: // 0160:1c9b5e
    r32[ebx] = -r32[ebx];
    r32[ebx] >>>= 6;
    r32[ebx] = -r32[ebx];
  case 0x1c9b65: // 0160:1c9b65
    memoryASet32(ds, 0x20ced7, r32[ebx]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) - r32[ebx]);
    r16[ax] = memoryAGet16(ds, 0x20d147);
    r16[bx] = memoryAGet16(ds, 0x20d145);
    yield* sub_1cdb0a();
    memoryASet32(ds, 0x20cedb, r32[eax]);
    memoryASet32(ds, 0x20cedf, r32[ebx]);
    r32[eax] &= r32[eax];
    if (r32s[eax] < 0)
        { pc = 0x1c9b97; break; }
    r32[eax] >>>= 6;
    { pc = 0x1c9b9e; break; }
  case 0x1c9b97: // 0160:1c9b97
    r32[eax] = -r32[eax];
    r32[eax] >>>= 6;
    r32[eax] = -r32[eax];
  case 0x1c9b9e: // 0160:1c9b9e
    memoryASet32(ds, 0x20cee3, r32[eax]);
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) - r32[eax]);
    r32[ebx] &= r32[ebx];
    if (r32s[ebx] < 0)
        { pc = 0x1c9bb2; break; }
    r32[ebx] >>>= 6;
    { pc = 0x1c9bb9; break; }
  case 0x1c9bb2: // 0160:1c9bb2
    r32[ebx] = -r32[ebx];
    r32[ebx] >>>= 6;
    r32[ebx] = -r32[ebx];
  case 0x1c9bb9: // 0160:1c9bb9
    memoryASet32(ds, 0x20cee7, r32[ebx]);
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) - r32[ebx]);
    r32[eax] = memoryAGet32(ds, 0x20cee3);
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20cee7);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20ced3);
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20ced7);
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + r32[eax]);
    memoryASet16(ds, 0x20d001, 0x0400);
    r32[ebp] = 0x000186a0;
    memoryASet32(ds, 0x20e809, r32[ebp]);
    r16[ax] = memoryAGet16(ds, 0x20d76d);
    if (r16[ax] == 0x0001)
        { pc = 0x1c9c43; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1c9c35; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1c9c5f; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1c9c51; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1c9c5f; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1c9c51; break; }
    if (r16[ax] == 0x0007)
        { pc = 0x1c9c43; break; }
  case 0x1c9c35: // 0160:1c9c35
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) - r32[ebp]);
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) + r32[ebp]);
    { pc = 0x1c9c6d; break; }
  case 0x1c9c43: // 0160:1c9c43
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) - r32[ebp]);
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) + r32[ebp]);
    { pc = 0x1c9c6d; break; }
  case 0x1c9c51: // 0160:1c9c51
    memoryASet32(ds, 0x20cecb, memoryAGet32(ds, 0x20cecb) - r32[ebp]);
    memoryASet32(ds, 0x20cedb, memoryAGet32(ds, 0x20cedb) + r32[ebp]);
    { pc = 0x1c9c6d; break; }
  case 0x1c9c5f: // 0160:1c9c5f
    memoryASet32(ds, 0x20cecf, memoryAGet32(ds, 0x20cecf) - r32[ebp]);
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) + r32[ebp]);
    { pc = 0x1c9c6d; break; }
  case 0x1c9c6d: // 0160:1c9c6d
    yield* sub_1cdb89();
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    memoryASet16(ds, 0x20d147, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (r16[ax] >= 0x001e)
        { pc = 0x1c9c8e; break; }
    r16[ax] = 0x001e;
  case 0x1c9c8e: // 0160:1c9c8e
    memoryASet16(ds, 0x20d145, r16[ax]);
    push32(r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20cedb);
    memoryASet32(ds, 0x20cecb, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20cedf);
    memoryASet32(ds, 0x20cecf, r32[eax]);
    r32[eax] = pop32();
    yield* sub_1cdb89();
    r16[ax] = memoryAGet16(ds, 0x20cfa7);
    memoryASet16(ds, 0x20d143, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (r16[ax] >= 0x001e)
        { pc = 0x1c9ccb; break; }
    r16[ax] = 0x001e;
  case 0x1c9ccb: // 0160:1c9ccb
    memoryASet16(ds, 0x20d141, r16[ax]);
    r32[eax] = 0x00000001;
    r32[esp] += 4;
    return;
  }
}
function* sub_1c9cd7() // 0160:1c9cd7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r16[ax])
        { pc = 0x1c9d41; break; }
    memoryASet16(ds, 0x20ee83, 0x003c);
    push32(r32[esi]);
    r32[esi] = 0x002091a5;
    if (memoryAGet16(ds, 0x20ed9f) & 0xffff)
        { pc = 0x1c9cfb; break; }
    r32[esi] = 0x002091b5;
  case 0x1c9cfb: // 0160:1c9cfb
    yield* sub_1b1c6b();
    r32[eax] &= 0x0000000f;
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r32[esi] = pop32();
    yield* sub_1b17b7();
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee9b, memoryAGet16(ds, 0x20ee9b) + r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20ee9b)) <= signed16(0x0014))
        { pc = 0x1c9d32; break; }
    memoryASet16(ds, 0x20ee9b, memoryAGet16(ds, 0x20ee9b) - 0x0014);
  case 0x1c9d32: // 0160:1c9d32
    r16[ax] = memoryAGet16(ds, 0x20ee9b);
    r16[ax] += 0x00c9;
    yield* sub_1b1715();
  case 0x1c9d41: // 0160:1c9d41
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1c9d42() // 0160:1c9d42 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1c9d42; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 28860 bytes // gap 28860 bytes
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 8346 bytes // gap 8346 bytes
  case 0x1c9d42: // 0160:1c9d42
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ca00c; break; }
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1ca00c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[ax] += 0x0010;
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bx] += 0x0010;
    yield* sub_1cd7c5();
    memoryASet(ds, 0x20d123, r8[al]);
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1ca00c; break; }
    if (r8[al] != 0x22)
        { pc = 0x1c9dbf; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    r16[ax] >>>= 5;
    if (r16s[ax] <= signed16(0x0008))
        { pc = 0x1c9d9f; break; }
    r16[ax] = 0x0008;
  case 0x1c9d9f: // 0160:1c9d9f
    memoryASet16(ds, 0x20d06f, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d0ff);
    r16[cx] = memoryAGet16(ds, 0x20cf4f);
    r16[dx] = memoryAGet16(ds, 0x20cf61);
    { pc = 0x1ca9c4; break; }
  case 0x1c9dbf: // 0160:1c9dbf
    if (r8[al] != 0x23)
        { pc = 0x1c9de9; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    r16[ax] >>>= 4;
    if (r16s[ax] <= signed16(0x0020))
        { pc = 0x1c9dd7; break; }
    r16[ax] = 0x0020;
  case 0x1c9dd7: // 0160:1c9dd7
    memoryASet16(ds, 0x20d06f, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d0ff);
    { pc = 0x1ca984; break; }
  case 0x1c9de9: // 0160:1c9de9
    if (r8[al] != 0x21)
        { pc = 0x1c9e24; break; }
  case 0x1c9ded: // 0160:1c9ded
    if (memoryAGet16(ds, 0x20cf85) >= 0x0020)
        { pc = 0x1ca00c; break; }
    memoryASet16(ds, 0x20cf85, 0x0020);
    r32[esp] += 4; return;
  case 0x1c9e05: // 0160:1c9e05
    if (signed16(memoryAGet16(ds, 0x20d7b9)) < signed16(0x0012))
        { pc = 0x1c9e19; break; }
    if (signed16(memoryAGet16(ds, 0x20d7b9)) <= signed16(0x0016))
        { pc = 0x1c9ded; break; }
  case 0x1c9e19: // 0160:1c9e19
    r16[ax] = 0x0105;
    yield* sub_1b1715();
    { pc = 0x1c9ded; break; }
  case 0x1c9e24: // 0160:1c9e24
    if (r8[al] != 0x38)
        { pc = 0x1c9e3d; break; }
    if (memoryAGet16(ds, 0x20d371) == 0x0006)
        { pc = 0x1c9e05; break; }
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    { pc = 0x1ca00d; break; }
  case 0x1c9e3d: // 0160:1c9e3d
    if (r8[al] != 0x39)
        { pc = 0x1c9e56; break; }
    if (memoryAGet16(ds, 0x20d379) == 0x0006)
        { pc = 0x1c9e05; break; }
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    { pc = 0x1ca03d; break; }
  case 0x1c9e56: // 0160:1c9e56
    if (r8[al] != 0x3a)
        { pc = 0x1c9e6f; break; }
    if (memoryAGet16(ds, 0x20d381) == 0x0006)
        { pc = 0x1c9e05; break; }
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    { pc = 0x1ca06d; break; }
  case 0x1c9e6f: // 0160:1c9e6f
    if (r8[al] != 0x3b)
        { pc = 0x1c9e88; break; }
    if (memoryAGet16(ds, 0x20d389) == 0x0006)
        { pc = 0x1c9e05; break; }
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    { pc = 0x1ca09d; break; }
  case 0x1c9e88: // 0160:1c9e88
    if (r8[al] != 0x3c)
        { pc = 0x1c9eba; break; }
    r16[ax] = memoryAGet16(ds, 0x20d217);
    memoryASet16(ds, 0x20d217, 0x0005);
    if (memoryAGet16(ds, 0x20d7b9) == 0x000e)
        { pc = 0x1c9eae; break; }
    memoryASet16(ds, 0x20d217, 0x0032);
  case 0x1c9eae: // 0160:1c9eae
    r16[bx] = memoryAGet16(ds, 0x20d0ff);
    { pc = 0x1ca9d9; break; }
  case 0x1c9eba: // 0160:1c9eba
    if (r8[al] != 0x3d)
        { pc = 0x1c9ede; break; }
    memoryASet16(ds, 0x20d06f, 0x0000);
    memoryASet16(ds, 0x20d05d, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d825);
    memoryASet16(ds, 0x20cf61, memoryAGet16(ds, 0x20cf61) + r16[ax]);
    r32[esp] += 4; return;
  case 0x1c9ede: // 0160:1c9ede
    if (r8[al] != 0x3e)
        { pc = 0x1c9f6e; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x001e)
        { pc = 0x1c9f1f; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    if (r16s[ax] <= signed16(0x0096))
        { pc = 0x1c9f1e; break; }
    r16[ax] >>>= 4;
    memoryASet16(ds, 0x20d18f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20d1a1, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20d1b3, r16[ax]);
  case 0x1c9f1e: // 0160:1c9f1e
    r32[esp] += 4; return;
  case 0x1c9f1f: // 0160:1c9f1f
    memoryASet16(ds, 0x20d06f, 0x0017);
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1c9f51; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x003f;
    r16[ax] -= 0x001f;
    r16[ax] += memoryAGet16(ds, 0x20cf97);
    r16[ax] &= 0x03ff;
    memoryASet16(ds, 0x20cf97, r16[ax]);
  case 0x1c9f51: // 0160:1c9f51
    memoryASet16(ds, 0x20cfa9, 0x0100);
    if (!(memoryAGet16(ds, 0x20d0ff) & 0xffff))
        { pc = 0x1ca00c; break; }
    { pc = 0x1ca0e5; break; }
  case 0x1c9f6e: // 0160:1c9f6e
    if (r8[al] != 0x3f)
        { pc = 0x1c9f86; break; }
  case 0x1c9f72: // 0160:1c9f72
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0021))
        { pc = 0x1c9f85; break; }
    memoryASet16(ds, 0x20cf85, 0x003b);
  case 0x1c9f85: // 0160:1c9f85
    r32[esp] += 4; return;
  case 0x1c9f86: // 0160:1c9f86
    if (r8[al] != 0x40)
        { pc = 0x1c9f9b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1c9f72; break; }
    r32[esp] += 4; return;
  case 0x1c9f9b: // 0160:1c9f9b
    if (r8[al] != 0x41)
        { pc = 0x1c9fb0; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1c9f72; break; }
    r32[esp] += 4; return;
  case 0x1c9fb0: // 0160:1c9fb0
    if (r8[al] != 0x42)
        { pc = 0x1c9fc5; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1c9f72; break; }
    r32[esp] += 4; return;
  case 0x1c9fc5: // 0160:1c9fc5
    if (r8[al] != 0x43)
        { pc = 0x1c9fda; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1c9f72; break; }
    r32[esp] += 4; return;
  case 0x1c9fda: // 0160:1c9fda
    if (r8[al] != 0x44)
        { pc = 0x1c9fe7; break; }
    memoryASet16(ds, 0x20d1c5, memoryAGet16(ds, 0x20d1c5) + 0x0001);
    r32[esp] += 4; return;
  case 0x1c9fe7: // 0160:1c9fe7
    if (r8[al] != 0x45)
        { pc = 0x1ca00c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    if (r16s[ax] <= signed16(0x0040))
        { pc = 0x1ca00c; break; }
    r16[bx] = memoryAGet16(ds, 0x20d0ff);
    yield* sub_1ca96f();
    memoryASet16(ds, 0x20cfa9, 0x0040);
  case 0x1ca00c: // 0160:1ca00c
    r32[esp] += 4; return;
  case 0x1ca00d: // 0160:1ca00d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca03c; break; }
    if (memoryAGet16(ds, 0x20d371) & 0xffff)
        { pc = 0x1ca03c; break; }
    memoryASet16(ds, 0x20d373, memoryAGet16(ds, 0x20d373) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca03c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d373);
    yield* sub_1ca0cd();
  case 0x1ca03c: // 0160:1ca03c
    r32[esp] += 4; return;
  case 0x1ca03d: // 0160:1ca03d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca06c; break; }
    if (memoryAGet16(ds, 0x20d379) & 0xffff)
        { pc = 0x1ca06c; break; }
    memoryASet16(ds, 0x20d37b, memoryAGet16(ds, 0x20d37b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca06c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d37b);
    yield* sub_1ca0cd();
  case 0x1ca06c: // 0160:1ca06c
    r32[esp] += 4; return;
  case 0x1ca06d: // 0160:1ca06d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca09c; break; }
    if (memoryAGet16(ds, 0x20d381) & 0xffff)
        { pc = 0x1ca09c; break; }
    memoryASet16(ds, 0x20d383, memoryAGet16(ds, 0x20d383) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca09c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d383);
    yield* sub_1ca0cd();
  case 0x1ca09c: // 0160:1ca09c
    r32[esp] += 4; return;
  case 0x1ca09d: // 0160:1ca09d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca0cc; break; }
    if (memoryAGet16(ds, 0x20d389) & 0xffff)
        { pc = 0x1ca0cc; break; }
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca0cc; break; }
    r16[ax] = memoryAGet16(ds, 0x20d38b);
    yield* sub_1ca0cd();
  case 0x1ca0cc: // 0160:1ca0cc
    r32[esp] += 4; return;
    // gap 24 bytes // gap 24 bytes
  case 0x1ca0e5: // 0160:1ca0e5
    if (memoryAGet16(ds, 0x20d7b9) != 0x0018)
        { pc = 0x1ca0f6; break; }
    r8[al] = 0x49;
    { pc = 0x1b17b7; break; }
  case 0x1ca0f6: // 0160:1ca0f6
    if (memoryAGet16(ds, 0x20d7b9) != 0x0024)
        { pc = 0x1ca125; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1ca11e; break; }
    memoryASet16(ds, 0x20ee85, 0x0000);
    r16[ax] = 0x00fe;
    yield* sub_1b1715();
  case 0x1ca11e: // 0160:1ca11e
    r8[al] = 0x4a;
    { pc = 0x1b17b7; break; }
  case 0x1ca125: // 0160:1ca125
    r8[al] = 0x50;
    { pc = 0x1b17b7; break; }
    // gap 2136 bytes // gap 2136 bytes
  case 0x1ca984: // 0160:1ca984
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9c3; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9c3; break; }
    r8[al] = 0x6a;
    yield* sub_1b17b7();
    yield* sub_1b1c25();
    r16[ax] &= 0x0007;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) + r16[ax]);
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) & 0x0007);
    r16[ax] = memoryAGet16(ds, 0x20ee87);
    r16[ax] += 0x00b9;
    { pc = 0x1b1715; break; }
  case 0x1ca9c3: // 0160:1ca9c3
    r32[esp] += 4; return;
  case 0x1ca9c4: // 0160:1ca9c4
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9d8; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9d8; break; }
    r8[al] = 0x6b;
    { pc = 0x1b17b7; break; }
  case 0x1ca9d8: // 0160:1ca9d8
    r32[esp] += 4; return;
  case 0x1ca9d9: // 0160:1ca9d9
    if (!(r16[bx] & 0xffff))
        { pc = 0x1caa0c; break; }
    if (r16[ax] & 0xffff)
        { pc = 0x1caa0c; break; }
    r8[al] = 0x7b;
    if (signed16(memoryAGet16(ds, 0x20d7b9)) > signed16(0x000a))
        { pc = 0x1ca9f4; break; }
    r8[al] = 0x7c;
  case 0x1ca9f4: // 0160:1ca9f4
    yield* sub_1b17b7();
    if (memoryAGet16(ds, 0x20d7b9) != 0x0004)
        { pc = 0x1caa0c; break; }
    r16[ax] = 0x0125;
    { pc = 0x1b1715; break; }
  case 0x1caa0c: // 0160:1caa0c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ca0cd() // 0160:1ca0cd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ca0cd; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 9373 bytes // gap 9373 bytes
  case 0x1ca0cd: // 0160:1ca0cd
    if (memoryAGet16(ds, 0x20d7b9) == 0x0018)
        { pc = 0x1ca0e4; break; }
    if (r16[ax] != 0x0001)
        { pc = 0x1ca0e4; break; }
    r8[al] = 0x53;
    { pc = 0x1b17b7; break; }
  case 0x1ca0e4: // 0160:1ca0e4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ca12c() // 0160:1ca12c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ca12c; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 28860 bytes // gap 28860 bytes
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 9061 bytes // gap 9061 bytes
  case 0x1ca00d: // 0160:1ca00d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca03c; break; }
    if (memoryAGet16(ds, 0x20d371) & 0xffff)
        { pc = 0x1ca03c; break; }
    memoryASet16(ds, 0x20d373, memoryAGet16(ds, 0x20d373) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca03c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d373);
    yield* sub_1ca0cd();
  case 0x1ca03c: // 0160:1ca03c
    r32[esp] += 4; return;
  case 0x1ca03d: // 0160:1ca03d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca06c; break; }
    if (memoryAGet16(ds, 0x20d379) & 0xffff)
        { pc = 0x1ca06c; break; }
    memoryASet16(ds, 0x20d37b, memoryAGet16(ds, 0x20d37b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca06c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d37b);
    yield* sub_1ca0cd();
  case 0x1ca06c: // 0160:1ca06c
    r32[esp] += 4; return;
  case 0x1ca06d: // 0160:1ca06d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca09c; break; }
    if (memoryAGet16(ds, 0x20d381) & 0xffff)
        { pc = 0x1ca09c; break; }
    memoryASet16(ds, 0x20d383, memoryAGet16(ds, 0x20d383) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca09c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d383);
    yield* sub_1ca0cd();
  case 0x1ca09c: // 0160:1ca09c
    r32[esp] += 4; return;
  case 0x1ca09d: // 0160:1ca09d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca0cc; break; }
    if (memoryAGet16(ds, 0x20d389) & 0xffff)
        { pc = 0x1ca0cc; break; }
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca0cc; break; }
    r16[ax] = memoryAGet16(ds, 0x20d38b);
    yield* sub_1ca0cd();
  case 0x1ca0cc: // 0160:1ca0cc
    r32[esp] += 4; return;
    // gap 24 bytes // gap 24 bytes
  case 0x1ca0e5: // 0160:1ca0e5
    if (memoryAGet16(ds, 0x20d7b9) != 0x0018)
        { pc = 0x1ca0f6; break; }
    r8[al] = 0x49;
    { pc = 0x1b17b7; break; }
  case 0x1ca0f6: // 0160:1ca0f6
    if (memoryAGet16(ds, 0x20d7b9) != 0x0024)
        { pc = 0x1ca125; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1ca11e; break; }
    memoryASet16(ds, 0x20ee85, 0x0000);
    r16[ax] = 0x00fe;
    yield* sub_1b1715();
  case 0x1ca11e: // 0160:1ca11e
    r8[al] = 0x4a;
    { pc = 0x1b17b7; break; }
  case 0x1ca125: // 0160:1ca125
    r8[al] = 0x50;
    { pc = 0x1b17b7; break; }
  case 0x1ca12c: // 0160:1ca12c
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ca3e7; break; }
    if (memoryAGet16(ds, 0x20d05f) & 0xffff)
        { pc = 0x1ca3e7; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[ax] += 0x0010;
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bx] += 0x0010;
    yield* sub_1cd7c5();
    memoryASet(ds, 0x20d125, r8[al]);
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1ca3e7; break; }
    if (r8[al] != 0x22)
        { pc = 0x1ca1a9; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    r16[ax] >>>= 5;
    if (r16s[ax] <= signed16(0x0008))
        { pc = 0x1ca189; break; }
    r16[ax] = 0x0008;
  case 0x1ca189: // 0160:1ca189
    memoryASet16(ds, 0x20d071, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d101);
    r16[cx] = memoryAGet16(ds, 0x20cf51);
    r16[dx] = memoryAGet16(ds, 0x20cf63);
    { pc = 0x1ca9c4; break; }
  case 0x1ca1a9: // 0160:1ca1a9
    if (r8[al] != 0x23)
        { pc = 0x1ca1d3; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    r16[ax] >>>= 4;
    if (r16s[ax] <= signed16(0x0020))
        { pc = 0x1ca1c1; break; }
    r16[ax] = 0x0020;
  case 0x1ca1c1: // 0160:1ca1c1
    memoryASet16(ds, 0x20d071, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d101);
    { pc = 0x1ca984; break; }
  case 0x1ca1d3: // 0160:1ca1d3
    if (r8[al] != 0x21)
        { pc = 0x1ca20e; break; }
  case 0x1ca1d7: // 0160:1ca1d7
    if (memoryAGet16(ds, 0x20cf87) >= 0x0020)
        { pc = 0x1ca3e7; break; }
    memoryASet16(ds, 0x20cf87, 0x0020);
    r32[esp] += 4; return;
  case 0x1ca1ef: // 0160:1ca1ef
    if (signed16(memoryAGet16(ds, 0x20d7b9)) < signed16(0x0012))
        { pc = 0x1ca203; break; }
    if (signed16(memoryAGet16(ds, 0x20d7b9)) <= signed16(0x0016))
        { pc = 0x1ca1d7; break; }
  case 0x1ca203: // 0160:1ca203
    r16[ax] = 0x0105;
    yield* sub_1b1715();
    { pc = 0x1ca1d7; break; }
  case 0x1ca20e: // 0160:1ca20e
    if (r8[al] != 0x38)
        { pc = 0x1ca227; break; }
    if (memoryAGet16(ds, 0x20d371) == 0x0006)
        { pc = 0x1ca1ef; break; }
    r16[ax] = memoryAGet16(ds, 0x20d101);
    { pc = 0x1ca00d; break; }
  case 0x1ca227: // 0160:1ca227
    if (r8[al] != 0x39)
        { pc = 0x1ca240; break; }
    if (memoryAGet16(ds, 0x20d379) == 0x0006)
        { pc = 0x1ca1ef; break; }
    r16[ax] = memoryAGet16(ds, 0x20d101);
    { pc = 0x1ca03d; break; }
  case 0x1ca240: // 0160:1ca240
    if (r8[al] != 0x3a)
        { pc = 0x1ca259; break; }
    if (memoryAGet16(ds, 0x20d381) == 0x0006)
        { pc = 0x1ca1ef; break; }
    r16[ax] = memoryAGet16(ds, 0x20d101);
    { pc = 0x1ca06d; break; }
  case 0x1ca259: // 0160:1ca259
    if (r8[al] != 0x3b)
        { pc = 0x1ca272; break; }
    if (memoryAGet16(ds, 0x20d389) == 0x0006)
        { pc = 0x1ca1ef; break; }
    r16[ax] = memoryAGet16(ds, 0x20d101);
    { pc = 0x1ca09d; break; }
  case 0x1ca272: // 0160:1ca272
    if (r8[al] != 0x3c)
        { pc = 0x1ca2a4; break; }
    r16[ax] = memoryAGet16(ds, 0x20d219);
    memoryASet16(ds, 0x20d219, 0x0005);
    if (memoryAGet16(ds, 0x20d7b9) == 0x000e)
        { pc = 0x1ca298; break; }
    memoryASet16(ds, 0x20d219, 0x0032);
  case 0x1ca298: // 0160:1ca298
    r16[bx] = memoryAGet16(ds, 0x20d101);
    { pc = 0x1ca9d9; break; }
  case 0x1ca2a4: // 0160:1ca2a4
    if (r8[al] != 0x3d)
        { pc = 0x1ca2c8; break; }
    memoryASet16(ds, 0x20d071, 0x0000);
    memoryASet16(ds, 0x20d05f, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d825);
    memoryASet16(ds, 0x20cf63, memoryAGet16(ds, 0x20cf63) + r16[ax]);
    r32[esp] += 4; return;
  case 0x1ca2c8: // 0160:1ca2c8
    if (r8[al] != 0x3e)
        { pc = 0x1ca349; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x001e)
        { pc = 0x1ca305; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    if (r16s[ax] <= signed16(0x0096))
        { pc = 0x1ca304; break; }
    r16[ax] >>>= 4;
    memoryASet16(ds, 0x20d191, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20d1a3, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20d1b5, r16[ax]);
  case 0x1ca304: // 0160:1ca304
    r32[esp] += 4; return;
  case 0x1ca305: // 0160:1ca305
    memoryASet16(ds, 0x20d071, 0x0017);
    yield* sub_1b1c25();
    r16[ax] &= 0x003f;
    r16[ax] -= 0x001f;
    r16[ax] += memoryAGet16(ds, 0x20cf99);
    r16[ax] &= 0x03ff;
    memoryASet16(ds, 0x20cf99, r16[ax]);
    memoryASet16(ds, 0x20cfab, 0x0100);
    if (!(memoryAGet16(ds, 0x20d101) & 0xffff))
        { pc = 0x1ca3e7; break; }
    { pc = 0x1ca0e5; break; }
  case 0x1ca349: // 0160:1ca349
    if (r8[al] != 0x3f)
        { pc = 0x1ca361; break; }
  case 0x1ca34d: // 0160:1ca34d
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0021))
        { pc = 0x1ca360; break; }
    memoryASet16(ds, 0x20cf87, 0x003b);
  case 0x1ca360: // 0160:1ca360
    r32[esp] += 4; return;
  case 0x1ca361: // 0160:1ca361
    if (r8[al] != 0x40)
        { pc = 0x1ca376; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca34d; break; }
    r32[esp] += 4; return;
  case 0x1ca376: // 0160:1ca376
    if (r8[al] != 0x41)
        { pc = 0x1ca38b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca34d; break; }
    r32[esp] += 4; return;
  case 0x1ca38b: // 0160:1ca38b
    if (r8[al] != 0x42)
        { pc = 0x1ca3a0; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1ca34d; break; }
    r32[esp] += 4; return;
  case 0x1ca3a0: // 0160:1ca3a0
    if (r8[al] != 0x43)
        { pc = 0x1ca3b5; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1ca34d; break; }
    r32[esp] += 4; return;
  case 0x1ca3b5: // 0160:1ca3b5
    if (r8[al] != 0x44)
        { pc = 0x1ca3c2; break; }
    memoryASet16(ds, 0x20d1c7, memoryAGet16(ds, 0x20d1c7) + 0x0001);
    r32[esp] += 4; return;
  case 0x1ca3c2: // 0160:1ca3c2
    if (r8[al] != 0x45)
        { pc = 0x1ca3e7; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    if (r16s[ax] <= signed16(0x0040))
        { pc = 0x1ca3e7; break; }
    r16[bx] = memoryAGet16(ds, 0x20d101);
    yield* sub_1ca96f();
    memoryASet16(ds, 0x20cfab, 0x0040);
  case 0x1ca3e7: // 0160:1ca3e7
    r32[esp] += 4; return;
    // gap 1436 bytes // gap 1436 bytes
  case 0x1ca984: // 0160:1ca984
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9c3; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9c3; break; }
    r8[al] = 0x6a;
    yield* sub_1b17b7();
    yield* sub_1b1c25();
    r16[ax] &= 0x0007;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) + r16[ax]);
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) & 0x0007);
    r16[ax] = memoryAGet16(ds, 0x20ee87);
    r16[ax] += 0x00b9;
    { pc = 0x1b1715; break; }
  case 0x1ca9c3: // 0160:1ca9c3
    r32[esp] += 4; return;
  case 0x1ca9c4: // 0160:1ca9c4
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9d8; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9d8; break; }
    r8[al] = 0x6b;
    { pc = 0x1b17b7; break; }
  case 0x1ca9d8: // 0160:1ca9d8
    r32[esp] += 4; return;
  case 0x1ca9d9: // 0160:1ca9d9
    if (!(r16[bx] & 0xffff))
        { pc = 0x1caa0c; break; }
    if (r16[ax] & 0xffff)
        { pc = 0x1caa0c; break; }
    r8[al] = 0x7b;
    if (signed16(memoryAGet16(ds, 0x20d7b9)) > signed16(0x000a))
        { pc = 0x1ca9f4; break; }
    r8[al] = 0x7c;
  case 0x1ca9f4: // 0160:1ca9f4
    yield* sub_1b17b7();
    if (memoryAGet16(ds, 0x20d7b9) != 0x0004)
        { pc = 0x1caa0c; break; }
    r16[ax] = 0x0125;
    { pc = 0x1b1715; break; }
  case 0x1caa0c: // 0160:1caa0c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ca3e8() // 0160:1ca3e8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ca3e8; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 28860 bytes // gap 28860 bytes
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 9061 bytes // gap 9061 bytes
  case 0x1ca00d: // 0160:1ca00d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca03c; break; }
    if (memoryAGet16(ds, 0x20d371) & 0xffff)
        { pc = 0x1ca03c; break; }
    memoryASet16(ds, 0x20d373, memoryAGet16(ds, 0x20d373) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca03c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d373);
    yield* sub_1ca0cd();
  case 0x1ca03c: // 0160:1ca03c
    r32[esp] += 4; return;
  case 0x1ca03d: // 0160:1ca03d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca06c; break; }
    if (memoryAGet16(ds, 0x20d379) & 0xffff)
        { pc = 0x1ca06c; break; }
    memoryASet16(ds, 0x20d37b, memoryAGet16(ds, 0x20d37b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca06c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d37b);
    yield* sub_1ca0cd();
  case 0x1ca06c: // 0160:1ca06c
    r32[esp] += 4; return;
  case 0x1ca06d: // 0160:1ca06d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca09c; break; }
    if (memoryAGet16(ds, 0x20d381) & 0xffff)
        { pc = 0x1ca09c; break; }
    memoryASet16(ds, 0x20d383, memoryAGet16(ds, 0x20d383) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca09c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d383);
    yield* sub_1ca0cd();
  case 0x1ca09c: // 0160:1ca09c
    r32[esp] += 4; return;
  case 0x1ca09d: // 0160:1ca09d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca0cc; break; }
    if (memoryAGet16(ds, 0x20d389) & 0xffff)
        { pc = 0x1ca0cc; break; }
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca0cc; break; }
    r16[ax] = memoryAGet16(ds, 0x20d38b);
    yield* sub_1ca0cd();
  case 0x1ca0cc: // 0160:1ca0cc
    r32[esp] += 4; return;
    // gap 24 bytes // gap 24 bytes
  case 0x1ca0e5: // 0160:1ca0e5
    if (memoryAGet16(ds, 0x20d7b9) != 0x0018)
        { pc = 0x1ca0f6; break; }
    r8[al] = 0x49;
    { pc = 0x1b17b7; break; }
  case 0x1ca0f6: // 0160:1ca0f6
    if (memoryAGet16(ds, 0x20d7b9) != 0x0024)
        { pc = 0x1ca125; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1ca11e; break; }
    memoryASet16(ds, 0x20ee85, 0x0000);
    r16[ax] = 0x00fe;
    yield* sub_1b1715();
  case 0x1ca11e: // 0160:1ca11e
    r8[al] = 0x4a;
    { pc = 0x1b17b7; break; }
  case 0x1ca125: // 0160:1ca125
    r8[al] = 0x50;
    { pc = 0x1b17b7; break; }
    // gap 700 bytes // gap 700 bytes
  case 0x1ca3e8: // 0160:1ca3e8
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ca6b2; break; }
    if (memoryAGet16(ds, 0x20d061) & 0xffff)
        { pc = 0x1ca6b2; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[ax] += 0x0010;
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bx] += 0x0010;
    yield* sub_1cd7c5();
    memoryASet(ds, 0x20d127, r8[al]);
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1ca6b2; break; }
    if (r8[al] != 0x22)
        { pc = 0x1ca465; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    r16[ax] >>>= 5;
    if (r16s[ax] <= signed16(0x0008))
        { pc = 0x1ca445; break; }
    r16[ax] = 0x0008;
  case 0x1ca445: // 0160:1ca445
    memoryASet16(ds, 0x20d073, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d103);
    r16[cx] = memoryAGet16(ds, 0x20cf53);
    r16[dx] = memoryAGet16(ds, 0x20cf65);
    { pc = 0x1ca9c4; break; }
  case 0x1ca465: // 0160:1ca465
    if (r8[al] != 0x23)
        { pc = 0x1ca48f; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    r16[ax] >>>= 4;
    if (r16s[ax] <= signed16(0x0020))
        { pc = 0x1ca47d; break; }
    r16[ax] = 0x0020;
  case 0x1ca47d: // 0160:1ca47d
    memoryASet16(ds, 0x20d073, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d103);
    { pc = 0x1ca984; break; }
  case 0x1ca48f: // 0160:1ca48f
    if (r8[al] != 0x21)
        { pc = 0x1ca4ca; break; }
  case 0x1ca493: // 0160:1ca493
    if (memoryAGet16(ds, 0x20cf89) >= 0x0020)
        { pc = 0x1ca6b2; break; }
    memoryASet16(ds, 0x20cf89, 0x0020);
    r32[esp] += 4; return;
  case 0x1ca4ab: // 0160:1ca4ab
    if (signed16(memoryAGet16(ds, 0x20d7b9)) < signed16(0x0012))
        { pc = 0x1ca4bf; break; }
    if (signed16(memoryAGet16(ds, 0x20d7b9)) <= signed16(0x0016))
        { pc = 0x1ca493; break; }
  case 0x1ca4bf: // 0160:1ca4bf
    r16[ax] = 0x0105;
    yield* sub_1b1715();
    { pc = 0x1ca493; break; }
  case 0x1ca4ca: // 0160:1ca4ca
    if (r8[al] != 0x38)
        { pc = 0x1ca4e3; break; }
    if (memoryAGet16(ds, 0x20d371) == 0x0006)
        { pc = 0x1ca4ab; break; }
    r16[ax] = memoryAGet16(ds, 0x20d103);
    { pc = 0x1ca00d; break; }
  case 0x1ca4e3: // 0160:1ca4e3
    if (r8[al] != 0x39)
        { pc = 0x1ca4fc; break; }
    if (memoryAGet16(ds, 0x20d379) == 0x0006)
        { pc = 0x1ca4ab; break; }
    r16[ax] = memoryAGet16(ds, 0x20d103);
    { pc = 0x1ca03d; break; }
  case 0x1ca4fc: // 0160:1ca4fc
    if (r8[al] != 0x3a)
        { pc = 0x1ca515; break; }
    if (memoryAGet16(ds, 0x20d381) == 0x0006)
        { pc = 0x1ca4ab; break; }
    r16[ax] = memoryAGet16(ds, 0x20d103);
    { pc = 0x1ca06d; break; }
  case 0x1ca515: // 0160:1ca515
    if (r8[al] != 0x3b)
        { pc = 0x1ca52e; break; }
    if (memoryAGet16(ds, 0x20d389) == 0x0006)
        { pc = 0x1ca4ab; break; }
    r16[ax] = memoryAGet16(ds, 0x20d103);
    { pc = 0x1ca09d; break; }
  case 0x1ca52e: // 0160:1ca52e
    if (r8[al] != 0x3c)
        { pc = 0x1ca560; break; }
    r16[ax] = memoryAGet16(ds, 0x20d21b);
    memoryASet16(ds, 0x20d21b, 0x0005);
    if (memoryAGet16(ds, 0x20d7b9) == 0x000e)
        { pc = 0x1ca554; break; }
    memoryASet16(ds, 0x20d21b, 0x0032);
  case 0x1ca554: // 0160:1ca554
    r16[bx] = memoryAGet16(ds, 0x20d103);
    { pc = 0x1ca9d9; break; }
  case 0x1ca560: // 0160:1ca560
    if (r8[al] != 0x3d)
        { pc = 0x1ca584; break; }
    memoryASet16(ds, 0x20d073, 0x0000);
    memoryASet16(ds, 0x20d061, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d825);
    memoryASet16(ds, 0x20cf65, memoryAGet16(ds, 0x20cf65) + r16[ax]);
    r32[esp] += 4; return;
  case 0x1ca584: // 0160:1ca584
    if (r8[al] != 0x3e)
        { pc = 0x1ca614; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x001e)
        { pc = 0x1ca5c5; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    if (r16s[ax] <= signed16(0x0096))
        { pc = 0x1ca5c4; break; }
    r16[ax] >>>= 4;
    memoryASet16(ds, 0x20d193, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20d1a5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20d1b7, r16[ax]);
  case 0x1ca5c4: // 0160:1ca5c4
    r32[esp] += 4; return;
  case 0x1ca5c5: // 0160:1ca5c5
    memoryASet16(ds, 0x20d073, 0x0017);
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca5f7; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x003f;
    r16[ax] -= 0x001f;
    r16[ax] += memoryAGet16(ds, 0x20cf9b);
    r16[ax] &= 0x03ff;
    memoryASet16(ds, 0x20cf9b, r16[ax]);
  case 0x1ca5f7: // 0160:1ca5f7
    memoryASet16(ds, 0x20cfad, 0x0100);
    if (!(memoryAGet16(ds, 0x20d103) & 0xffff))
        { pc = 0x1ca6b2; break; }
    { pc = 0x1ca0e5; break; }
  case 0x1ca614: // 0160:1ca614
    if (r8[al] != 0x3f)
        { pc = 0x1ca62c; break; }
  case 0x1ca618: // 0160:1ca618
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0021))
        { pc = 0x1ca62b; break; }
    memoryASet16(ds, 0x20cf89, 0x003b);
  case 0x1ca62b: // 0160:1ca62b
    r32[esp] += 4; return;
  case 0x1ca62c: // 0160:1ca62c
    if (r8[al] != 0x40)
        { pc = 0x1ca641; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca618; break; }
    r32[esp] += 4; return;
  case 0x1ca641: // 0160:1ca641
    if (r8[al] != 0x41)
        { pc = 0x1ca656; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca618; break; }
    r32[esp] += 4; return;
  case 0x1ca656: // 0160:1ca656
    if (r8[al] != 0x42)
        { pc = 0x1ca66b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1ca618; break; }
    r32[esp] += 4; return;
  case 0x1ca66b: // 0160:1ca66b
    if (r8[al] != 0x43)
        { pc = 0x1ca680; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1ca618; break; }
    r32[esp] += 4; return;
  case 0x1ca680: // 0160:1ca680
    if (r8[al] != 0x44)
        { pc = 0x1ca68d; break; }
    memoryASet16(ds, 0x20d1c9, memoryAGet16(ds, 0x20d1c9) + 0x0001);
    r32[esp] += 4; return;
  case 0x1ca68d: // 0160:1ca68d
    if (r8[al] != 0x45)
        { pc = 0x1ca6b2; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    if (r16s[ax] <= signed16(0x0040))
        { pc = 0x1ca6b2; break; }
    r16[bx] = memoryAGet16(ds, 0x20d103);
    yield* sub_1ca96f();
    memoryASet16(ds, 0x20cfad, 0x0040);
  case 0x1ca6b2: // 0160:1ca6b2
    r32[esp] += 4; return;
    // gap 721 bytes // gap 721 bytes
  case 0x1ca984: // 0160:1ca984
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9c3; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9c3; break; }
    r8[al] = 0x6a;
    yield* sub_1b17b7();
    yield* sub_1b1c25();
    r16[ax] &= 0x0007;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) + r16[ax]);
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) & 0x0007);
    r16[ax] = memoryAGet16(ds, 0x20ee87);
    r16[ax] += 0x00b9;
    { pc = 0x1b1715; break; }
  case 0x1ca9c3: // 0160:1ca9c3
    r32[esp] += 4; return;
  case 0x1ca9c4: // 0160:1ca9c4
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9d8; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9d8; break; }
    r8[al] = 0x6b;
    { pc = 0x1b17b7; break; }
  case 0x1ca9d8: // 0160:1ca9d8
    r32[esp] += 4; return;
  case 0x1ca9d9: // 0160:1ca9d9
    if (!(r16[bx] & 0xffff))
        { pc = 0x1caa0c; break; }
    if (r16[ax] & 0xffff)
        { pc = 0x1caa0c; break; }
    r8[al] = 0x7b;
    if (signed16(memoryAGet16(ds, 0x20d7b9)) > signed16(0x000a))
        { pc = 0x1ca9f4; break; }
    r8[al] = 0x7c;
  case 0x1ca9f4: // 0160:1ca9f4
    yield* sub_1b17b7();
    if (memoryAGet16(ds, 0x20d7b9) != 0x0004)
        { pc = 0x1caa0c; break; }
    r16[ax] = 0x0125;
    { pc = 0x1b1715; break; }
  case 0x1caa0c: // 0160:1caa0c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ca6b3() // 0160:1ca6b3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ca6b3; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 28860 bytes // gap 28860 bytes
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 9061 bytes // gap 9061 bytes
  case 0x1ca00d: // 0160:1ca00d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca03c; break; }
    if (memoryAGet16(ds, 0x20d371) & 0xffff)
        { pc = 0x1ca03c; break; }
    memoryASet16(ds, 0x20d373, memoryAGet16(ds, 0x20d373) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca03c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d373);
    yield* sub_1ca0cd();
  case 0x1ca03c: // 0160:1ca03c
    r32[esp] += 4; return;
  case 0x1ca03d: // 0160:1ca03d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca06c; break; }
    if (memoryAGet16(ds, 0x20d379) & 0xffff)
        { pc = 0x1ca06c; break; }
    memoryASet16(ds, 0x20d37b, memoryAGet16(ds, 0x20d37b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca06c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d37b);
    yield* sub_1ca0cd();
  case 0x1ca06c: // 0160:1ca06c
    r32[esp] += 4; return;
  case 0x1ca06d: // 0160:1ca06d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca09c; break; }
    if (memoryAGet16(ds, 0x20d381) & 0xffff)
        { pc = 0x1ca09c; break; }
    memoryASet16(ds, 0x20d383, memoryAGet16(ds, 0x20d383) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca09c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d383);
    yield* sub_1ca0cd();
  case 0x1ca09c: // 0160:1ca09c
    r32[esp] += 4; return;
  case 0x1ca09d: // 0160:1ca09d
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1ca0cc; break; }
    if (memoryAGet16(ds, 0x20d389) & 0xffff)
        { pc = 0x1ca0cc; break; }
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) + 0x0001);
    if (!(r16[ax] & 0xffff))
        { pc = 0x1ca0cc; break; }
    r16[ax] = memoryAGet16(ds, 0x20d38b);
    yield* sub_1ca0cd();
  case 0x1ca0cc: // 0160:1ca0cc
    r32[esp] += 4; return;
    // gap 24 bytes // gap 24 bytes
  case 0x1ca0e5: // 0160:1ca0e5
    if (memoryAGet16(ds, 0x20d7b9) != 0x0018)
        { pc = 0x1ca0f6; break; }
    r8[al] = 0x49;
    { pc = 0x1b17b7; break; }
  case 0x1ca0f6: // 0160:1ca0f6
    if (memoryAGet16(ds, 0x20d7b9) != 0x0024)
        { pc = 0x1ca125; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1ca11e; break; }
    memoryASet16(ds, 0x20ee85, 0x0000);
    r16[ax] = 0x00fe;
    yield* sub_1b1715();
  case 0x1ca11e: // 0160:1ca11e
    r8[al] = 0x4a;
    { pc = 0x1b17b7; break; }
  case 0x1ca125: // 0160:1ca125
    r8[al] = 0x50;
    { pc = 0x1b17b7; break; }
    // gap 1415 bytes // gap 1415 bytes
  case 0x1ca6b3: // 0160:1ca6b3
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ca96e; break; }
    if (memoryAGet16(ds, 0x20d063) & 0xffff)
        { pc = 0x1ca96e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[ax] += 0x0010;
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[bx] += 0x0010;
    yield* sub_1cd7c5();
    memoryASet(ds, 0x20d129, r8[al]);
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1ca96e; break; }
    if (r8[al] != 0x22)
        { pc = 0x1ca730; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    r16[ax] >>>= 5;
    if (r16s[ax] <= signed16(0x0008))
        { pc = 0x1ca710; break; }
    r16[ax] = 0x0008;
  case 0x1ca710: // 0160:1ca710
    memoryASet16(ds, 0x20d075, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d105);
    r16[cx] = memoryAGet16(ds, 0x20cf55);
    r16[dx] = memoryAGet16(ds, 0x20cf67);
    { pc = 0x1ca9c4; break; }
  case 0x1ca730: // 0160:1ca730
    if (r8[al] != 0x23)
        { pc = 0x1ca75a; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    r16[ax] >>>= 4;
    if (r16s[ax] <= signed16(0x0020))
        { pc = 0x1ca748; break; }
    r16[ax] = 0x0020;
  case 0x1ca748: // 0160:1ca748
    memoryASet16(ds, 0x20d075, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20d105);
    { pc = 0x1ca984; break; }
  case 0x1ca75a: // 0160:1ca75a
    if (r8[al] != 0x21)
        { pc = 0x1ca795; break; }
  case 0x1ca75e: // 0160:1ca75e
    if (memoryAGet16(ds, 0x20cf8b) >= 0x0020)
        { pc = 0x1ca96e; break; }
    memoryASet16(ds, 0x20cf8b, 0x0020);
    r32[esp] += 4; return;
  case 0x1ca776: // 0160:1ca776
    if (signed16(memoryAGet16(ds, 0x20d7b9)) < signed16(0x0012))
        { pc = 0x1ca78a; break; }
    if (signed16(memoryAGet16(ds, 0x20d7b9)) <= signed16(0x0016))
        { pc = 0x1ca75e; break; }
  case 0x1ca78a: // 0160:1ca78a
    r16[ax] = 0x0105;
    yield* sub_1b1715();
    { pc = 0x1ca75e; break; }
  case 0x1ca795: // 0160:1ca795
    if (r8[al] != 0x38)
        { pc = 0x1ca7ae; break; }
    if (memoryAGet16(ds, 0x20d371) == 0x0006)
        { pc = 0x1ca776; break; }
    r16[ax] = memoryAGet16(ds, 0x20d105);
    { pc = 0x1ca00d; break; }
  case 0x1ca7ae: // 0160:1ca7ae
    if (r8[al] != 0x39)
        { pc = 0x1ca7c7; break; }
    if (memoryAGet16(ds, 0x20d379) == 0x0006)
        { pc = 0x1ca776; break; }
    r16[ax] = memoryAGet16(ds, 0x20d105);
    { pc = 0x1ca03d; break; }
  case 0x1ca7c7: // 0160:1ca7c7
    if (r8[al] != 0x3a)
        { pc = 0x1ca7e0; break; }
    if (memoryAGet16(ds, 0x20d381) == 0x0006)
        { pc = 0x1ca776; break; }
    r16[ax] = memoryAGet16(ds, 0x20d105);
    { pc = 0x1ca06d; break; }
  case 0x1ca7e0: // 0160:1ca7e0
    if (r8[al] != 0x3b)
        { pc = 0x1ca7f9; break; }
    if (memoryAGet16(ds, 0x20d389) == 0x0006)
        { pc = 0x1ca776; break; }
    r16[ax] = memoryAGet16(ds, 0x20d105);
    { pc = 0x1ca09d; break; }
  case 0x1ca7f9: // 0160:1ca7f9
    if (r8[al] != 0x3c)
        { pc = 0x1ca82b; break; }
    r16[ax] = memoryAGet16(ds, 0x20d21d);
    memoryASet16(ds, 0x20d21d, 0x0005);
    if (memoryAGet16(ds, 0x20d7b9) == 0x000e)
        { pc = 0x1ca81f; break; }
    memoryASet16(ds, 0x20d21d, 0x0032);
  case 0x1ca81f: // 0160:1ca81f
    r16[bx] = memoryAGet16(ds, 0x20d105);
    { pc = 0x1ca9d9; break; }
  case 0x1ca82b: // 0160:1ca82b
    if (r8[al] != 0x3d)
        { pc = 0x1ca84f; break; }
    memoryASet16(ds, 0x20d075, 0x0000);
    memoryASet16(ds, 0x20d063, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d825);
    memoryASet16(ds, 0x20cf67, memoryAGet16(ds, 0x20cf67) + r16[ax]);
    r32[esp] += 4; return;
  case 0x1ca84f: // 0160:1ca84f
    if (r8[al] != 0x3e)
        { pc = 0x1ca8d0; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x001e)
        { pc = 0x1ca88c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    if (r16s[ax] <= signed16(0x0096))
        { pc = 0x1ca88b; break; }
    r16[ax] >>>= 4;
    memoryASet16(ds, 0x20d195, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20d1a7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20d1b9, r16[ax]);
  case 0x1ca88b: // 0160:1ca88b
    r32[esp] += 4; return;
  case 0x1ca88c: // 0160:1ca88c
    memoryASet16(ds, 0x20d075, 0x0017);
    yield* sub_1b1c25();
    r16[ax] &= 0x003f;
    r16[ax] -= 0x001f;
    r16[ax] += memoryAGet16(ds, 0x20cf9d);
    r16[ax] &= 0x03ff;
    memoryASet16(ds, 0x20cf9d, r16[ax]);
    memoryASet16(ds, 0x20cfaf, 0x0100);
    if (!(memoryAGet16(ds, 0x20d105) & 0xffff))
        { pc = 0x1ca96e; break; }
    { pc = 0x1ca0e5; break; }
  case 0x1ca8d0: // 0160:1ca8d0
    if (r8[al] != 0x3f)
        { pc = 0x1ca8e8; break; }
  case 0x1ca8d4: // 0160:1ca8d4
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0021))
        { pc = 0x1ca8e7; break; }
    memoryASet16(ds, 0x20cf8b, 0x003b);
  case 0x1ca8e7: // 0160:1ca8e7
    r32[esp] += 4; return;
  case 0x1ca8e8: // 0160:1ca8e8
    if (r8[al] != 0x40)
        { pc = 0x1ca8fd; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca8d4; break; }
    r32[esp] += 4; return;
  case 0x1ca8fd: // 0160:1ca8fd
    if (r8[al] != 0x41)
        { pc = 0x1ca912; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    r16[ax] &= 0x0007;
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca8d4; break; }
    r32[esp] += 4; return;
  case 0x1ca912: // 0160:1ca912
    if (r8[al] != 0x42)
        { pc = 0x1ca927; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1ca8d4; break; }
    r32[esp] += 4; return;
  case 0x1ca927: // 0160:1ca927
    if (r8[al] != 0x43)
        { pc = 0x1ca93c; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    r16[ax] &= 0x0007;
    if (r16s[ax] > signed16(0x0002))
        { pc = 0x1ca8d4; break; }
    r32[esp] += 4; return;
  case 0x1ca93c: // 0160:1ca93c
    if (r8[al] != 0x44)
        { pc = 0x1ca949; break; }
    memoryASet16(ds, 0x20d1cb, memoryAGet16(ds, 0x20d1cb) + 0x0001);
    r32[esp] += 4; return;
  case 0x1ca949: // 0160:1ca949
    if (r8[al] != 0x45)
        { pc = 0x1ca96e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    if (r16s[ax] <= signed16(0x0040))
        { pc = 0x1ca96e; break; }
    r16[bx] = memoryAGet16(ds, 0x20d105);
    yield* sub_1ca96f();
    memoryASet16(ds, 0x20cfaf, 0x0040);
  case 0x1ca96e: // 0160:1ca96e
    r32[esp] += 4; return;
    // gap 21 bytes // gap 21 bytes
  case 0x1ca984: // 0160:1ca984
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9c3; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9c3; break; }
    r8[al] = 0x6a;
    yield* sub_1b17b7();
    yield* sub_1b1c25();
    r16[ax] &= 0x0007;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) + r16[ax]);
    memoryASet16(ds, 0x20ee87, memoryAGet16(ds, 0x20ee87) & 0x0007);
    r16[ax] = memoryAGet16(ds, 0x20ee87);
    r16[ax] += 0x00b9;
    { pc = 0x1b1715; break; }
  case 0x1ca9c3: // 0160:1ca9c3
    r32[esp] += 4; return;
  case 0x1ca9c4: // 0160:1ca9c4
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca9d8; break; }
    if (r16s[ax] <= signed16(0x0004))
        { pc = 0x1ca9d8; break; }
    r8[al] = 0x6b;
    { pc = 0x1b17b7; break; }
  case 0x1ca9d8: // 0160:1ca9d8
    r32[esp] += 4; return;
  case 0x1ca9d9: // 0160:1ca9d9
    if (!(r16[bx] & 0xffff))
        { pc = 0x1caa0c; break; }
    if (r16[ax] & 0xffff)
        { pc = 0x1caa0c; break; }
    r8[al] = 0x7b;
    if (signed16(memoryAGet16(ds, 0x20d7b9)) > signed16(0x000a))
        { pc = 0x1ca9f4; break; }
    r8[al] = 0x7c;
  case 0x1ca9f4: // 0160:1ca9f4
    yield* sub_1b17b7();
    if (memoryAGet16(ds, 0x20d7b9) != 0x0004)
        { pc = 0x1caa0c; break; }
    r16[ax] = 0x0125;
    { pc = 0x1b1715; break; }
  case 0x1caa0c: // 0160:1caa0c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ca96f() // 0160:1ca96f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ca96f; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 11583 bytes // gap 11583 bytes
  case 0x1ca96f: // 0160:1ca96f
    if (r16s[ax] <= signed16(0x0080))
        { pc = 0x1ca983; break; }
    if (!(r16[bx] & 0xffff))
        { pc = 0x1ca983; break; }
    r8[al] = 0x4f;
    { pc = 0x1b17b7; break; }
  case 0x1ca983: // 0160:1ca983
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1caa0d() // 0160:1caa0d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20cf85) == 0x0048)
        { pc = 0x1cadc2; break; }
    if (memoryAGet16(ds, 0x20cf85) == 0x004f)
        { pc = 0x1caa3d; break; }
    if (memoryAGet16(ds, 0x20cf85) == 0x0041)
        { pc = 0x1caa3d; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0033)
        { pc = 0x1cadfb; break; }
  case 0x1caa3d: // 0160:1caa3d
    if (memoryAGet16(ds, 0x20d89f) & 0xffff)
        { pc = 0x1caa56; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1cad7b; break; }
  case 0x1caa56: // 0160:1caa56
    if (!(memoryAGet16(ds, 0x20d2b7) & 0xffff))
        { pc = 0x1cad7b; break; }
    r32[esi] = 0x0020cf3f;
    r32[edi] = 0x0020cf87;
    r16[bp] = 0x0000;
    r16[dx] = 0;
    r32[ecx] = 0x00000008;
  case 0x1caa7b: // 0160:1caa7b
    r16[bx] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (!r16[ax])
        { pc = 0x1caaa8; break; }
    if (r16s[ax] >= signed16(0x0005))
        { pc = 0x1caaa8; break; }
    if (r16s[bx] >= signed16(0x0049))
        { pc = 0x1caaa8; break; }
    r16[bp]++;
    if (r16[bx] == 0x0041)
        { pc = 0x1caaa6; break; }
    if (r16[bx] != 0x0033)
        { pc = 0x1caaa8; break; }
  case 0x1caaa6: // 0160:1caaa6
    r16[dx]++;
  case 0x1caaa8: // 0160:1caaa8
    if (--r32[ecx])
        { pc = 0x1caa7b; break; }
    if (r16[dx] != r16[bp])
        { pc = 0x1cadfb; break; }
    if (!(memoryAGet16(ds, 0x20d7b1) & 0xffff))
        { pc = 0x1cac4f; break; }
  case 0x1caac2: // 0160:1caac2
    r16[ax] = memoryAGet16(ds, 0x20d7ab);
    if (r16[ax])
        { pc = 0x1cab26; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7ad);
    if (!r16[ax])
        { pc = 0x1cab12; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1caaf6; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cab04; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (r16[ax] != 0x0001)
        { pc = 0x1cab85; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1cab70; break; }
  case 0x1caaf6: // 0160:1caaf6
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (r16[ax] != 0x0002)
        { pc = 0x1cab70; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cab5b; break; }
  case 0x1cab04: // 0160:1cab04
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (r16[ax] != 0x0001)
        { pc = 0x1cab85; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1cab5b; break; }
  case 0x1cab12: // 0160:1cab12
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (r16[ax] != 0x0001)
        { pc = 0x1cab85; break; }
    if (r16[ax] != 0x0002)
        { pc = 0x1cab70; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cab5b; break; }
  case 0x1cab26: // 0160:1cab26
    memoryASet16(ds, 0x20d7ab, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    if (!r16[ax])
        { pc = 0x1cab85; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1cab70; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cab5b; break; }
    r16[bx] = memoryAGet16(ds, 0x20d051);
    r32[ecx] = memoryAGet32(ds, 0x20d0cf);
    r32[edx] = memoryAGet32(ds, 0x20d0d3);
    { pc = 0x1cab98; break; }
  case 0x1cab5b: // 0160:1cab5b
    r16[bx] = memoryAGet16(ds, 0x20d04f);
    r32[ecx] = memoryAGet32(ds, 0x20d0c7);
    r32[edx] = memoryAGet32(ds, 0x20d0cb);
    { pc = 0x1cab98; break; }
  case 0x1cab70: // 0160:1cab70
    r16[bx] = memoryAGet16(ds, 0x20d04d);
    r32[ecx] = memoryAGet32(ds, 0x20d0bf);
    r32[edx] = memoryAGet32(ds, 0x20d0c3);
    { pc = 0x1cab98; break; }
  case 0x1cab85: // 0160:1cab85
    r16[bx] = memoryAGet16(ds, 0x20d04b);
    r32[ecx] = memoryAGet32(ds, 0x20d0b7);
    r32[edx] = memoryAGet32(ds, 0x20d0bb);
  case 0x1cab98: // 0160:1cab98
    memoryASet16(ds, 0x20d04b, r16[bx]);
    memoryASet16(ds, 0x20d04d, r16[bx]);
    memoryASet16(ds, 0x20d04f, r16[bx]);
    memoryASet16(ds, 0x20d051, r16[bx]);
    memoryASet32(ds, 0x20d0b7, r32[ecx]);
    memoryASet32(ds, 0x20d0bf, r32[ecx]);
    memoryASet32(ds, 0x20d0c7, r32[ecx]);
    memoryASet32(ds, 0x20d0cf, r32[ecx]);
    memoryASet32(ds, 0x20d0bb, r32[edx]);
    memoryASet32(ds, 0x20d0c3, r32[edx]);
    memoryASet32(ds, 0x20d0cb, r32[edx]);
    memoryASet32(ds, 0x20d0d3, r32[edx]);
    yield* sub_1cadfc();
    yield* sub_1cb035();
    yield* sub_1cb291();
    yield* sub_1cb497();
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    memoryASet16(ds, 0x20d04d, r16[ax]);
    memoryASet16(ds, 0x20d04f, r16[ax]);
    memoryASet16(ds, 0x20d051, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d081);
    memoryASet16(ds, 0x20d083, r16[ax]);
    memoryASet16(ds, 0x20d085, r16[ax]);
    memoryASet16(ds, 0x20d087, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d093);
    memoryASet32(ds, 0x20d097, r32[eax]);
    memoryASet32(ds, 0x20d09b, r32[eax]);
    memoryASet32(ds, 0x20d09f, r32[eax]);
    memoryASet16(ds, 0x20d7b1, 0x0001);
    memoryASet16(ds, 0x20d2b9, 0x0001);
    r32[esp] += 4; return;
  case 0x1cac4f: // 0160:1cac4f
    if (!(memoryAGet16(ds, 0x20d2b5) & 0xffff))
        { pc = 0x1cadfb; break; }
    if (!(memoryAGet16(ds, 0x20d2b9) & 0xffff))
        { pc = 0x1caac2; break; }
    memoryASet16(ds, 0x20d2b9, 0x0000);
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cacb7; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1cacb7; break; }
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet16(ds, 0x20cf73, 0x0042);
    memoryASet16(ds, 0x20cf85, 0x0042);
    memoryASet16(ds, 0x20d05d, 0x0000);
    memoryASet16(ds, 0x20d06f, 0x0000);
  case 0x1cacb7: // 0160:1cacb7
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cacf8; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1cacf8; break; }
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20cf75, 0x0042);
    memoryASet16(ds, 0x20cf87, 0x0042);
    memoryASet16(ds, 0x20d05f, 0x0000);
    memoryASet16(ds, 0x20d071, 0x0000);
  case 0x1cacf8: // 0160:1cacf8
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cad39; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0003)
        { pc = 0x1cad39; break; }
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20cf77, 0x0042);
    memoryASet16(ds, 0x20cf89, 0x0042);
    memoryASet16(ds, 0x20d061, 0x0000);
    memoryASet16(ds, 0x20d073, 0x0000);
  case 0x1cad39: // 0160:1cad39
    if (memoryAGet16(ds, 0x20d7a9) == 0x0004)
        { pc = 0x1cad7a; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0004)
        { pc = 0x1cad7a; break; }
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20cf79, 0x0042);
    memoryASet16(ds, 0x20cf8b, 0x0042);
    memoryASet16(ds, 0x20d063, 0x0000);
    memoryASet16(ds, 0x20d075, 0x0000);
  case 0x1cad7a: // 0160:1cad7a
    r32[esp] += 4; return;
  case 0x1cad7b: // 0160:1cad7b
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cadfb; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1cadfb; break; }
    yield* sub_1cadfc();
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet16(ds, 0x20cf73, 0x0042);
    memoryASet16(ds, 0x20cf85, 0x0042);
    memoryASet16(ds, 0x20d05d, 0x0000);
    memoryASet16(ds, 0x20d06f, 0x0000);
    r32[esp] += 4; return;
  case 0x1cadc2: // 0160:1cadc2
    memoryASet16(ds, 0x20cf85, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] >>>= 6;
    r16[ax] &= 0x001c;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    r16[ax] <<= 5;
    memoryASet16(ds, 0x20d039, r16[ax]);
    memoryASet16(ds, 0x20d0ff, 0x0001);
    memoryASet16(ds, 0x20d111, 0x0001);
  case 0x1cadfb: // 0160:1cadfb
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cadfc() // 0160:1cadfc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d17d, 0x0000);
    memoryASet16(ds, 0x20d1c5, 0x0000);
    memoryASet16(ds, 0x20d123, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    yield* sub_1cb68e();
    if (!r16[ax])
        { pc = 0x1cae58; break; }
    memoryASet16(ds, 0x20d0b7, r16[bx]);
    memoryASet16(ds, 0x20d0b9, r16[cx]);
    memoryASet16(ds, 0x20d0bb, r16[dx]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20d0bd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d04b, r16[bp]);
  case 0x1cae58: // 0160:1cae58
    r16[ax] = memoryAGet16(ds, 0x20d0bb);
    r16[ax] -= memoryAGet16(ds, 0x20d0b7);
    if (r16s[ax] <= signed16(memoryAGet16(ds, 0x20ee37)))
        { pc = 0x1cae85; break; }
    r16[ax] -= memoryAGet16(ds, 0x20ee37);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d0b7, memoryAGet16(ds, 0x20d0b7) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee37);
  case 0x1cae85: // 0160:1cae85
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1caea3; break; }
    r16[bx] = 0x0003;
    { pc = 0x1caeac; break; }
  case 0x1caea3: // 0160:1caea3
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
  case 0x1caeac: // 0160:1caeac
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0000);
    yield* sub_1cb5f9();
    r16[ax] += memoryAGet16(ds, 0x20d0b7);
    r16[ax] += r16[cx];
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d0b9);
    r16[bx] = memoryAGet16(ds, 0x20d0bd);
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1caf39; break; }
    r16[bx] -= r16[ax];
    r16[ax] = r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1caf07; break; }
    r16[bx] = 0x0003;
    { pc = 0x1caf10; break; }
  case 0x1caf07: // 0160:1caf07
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
  case 0x1caf10: // 0160:1caf10
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0000);
    yield* sub_1cb5f9();
    r16[bx] = memoryAGet16(ds, 0x20d0b9);
    r16[bx] += r16[ax];
    r16[bx] += r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
    { pc = 0x1caf8a; break; }
  case 0x1caf39: // 0160:1caf39
    r16[ax] -= r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1caf5a; break; }
    r16[bx] = 0x0003;
    { pc = 0x1caf63; break; }
  case 0x1caf5a: // 0160:1caf5a
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
  case 0x1caf63: // 0160:1caf63
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0000);
    yield* sub_1cb5f9();
    r16[bx] = memoryAGet16(ds, 0x20d0b9);
    r16[bx] -= r16[ax];
    r16[bx] -= r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
  case 0x1caf8a: // 0160:1caf8a
    memoryASet16(ds, 0x20cf61, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1caf91() // 0160:1caf91 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20cf87) == 0x0048)
        { pc = 0x1caffb; break; }
    if (memoryAGet16(ds, 0x20cf87) == 0x0041)
        { pc = 0x1cafb3; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x0033)
        { pc = 0x1cb034; break; }
  case 0x1cafb3: // 0160:1cafb3
    if (memoryAGet16(ds, 0x20d2b7) & 0xffff)
        { pc = 0x1cb034; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1cb034; break; }
    yield* sub_1cb035();
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20cf75, 0x0042);
    memoryASet16(ds, 0x20cf87, 0x0042);
    memoryASet16(ds, 0x20d05f, 0x0000);
    memoryASet16(ds, 0x20d071, 0x0000);
    r32[esp] += 4; return;
  case 0x1caffb: // 0160:1caffb
    memoryASet16(ds, 0x20cf87, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    r16[ax] >>>= 6;
    r16[ax] &= 0x001c;
    memoryASet16(ds, 0x20cf75, r16[ax]);
    r16[ax] <<= 5;
    memoryASet16(ds, 0x20d03b, r16[ax]);
    memoryASet16(ds, 0x20d101, 0x0001);
    memoryASet16(ds, 0x20d113, 0x0001);
  case 0x1cb034: // 0160:1cb034
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cb035() // 0160:1cb035 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d17f, 0x0000);
    memoryASet16(ds, 0x20d1c7, 0x0000);
    memoryASet16(ds, 0x20d125, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    yield* sub_1cb68e();
    if (!r16[ax])
        { pc = 0x1cb091; break; }
    memoryASet16(ds, 0x20d0bf, r16[bx]);
    memoryASet16(ds, 0x20d0c1, r16[cx]);
    memoryASet16(ds, 0x20d0c3, r16[dx]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20d0c5, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d04d, r16[bp]);
  case 0x1cb091: // 0160:1cb091
    r16[ax] = memoryAGet16(ds, 0x20d0c3);
    r16[ax] -= memoryAGet16(ds, 0x20d0bf);
    if (r16s[ax] <= signed16(memoryAGet16(ds, 0x20ee37)))
        { pc = 0x1cb0be; break; }
    r16[ax] -= memoryAGet16(ds, 0x20ee37);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d0bf, memoryAGet16(ds, 0x20d0bf) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee37);
  case 0x1cb0be: // 0160:1cb0be
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cb0e4; break; }
    r16[bx] = 0x0003;
    r32[edx] = 0;
    div16(r16[bx]);
    r16[ax] += r16[ax];
    { pc = 0x1cb100; break; }
  case 0x1cb0e4: // 0160:1cb0e4
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0001);
    yield* sub_1cb5f9();
  case 0x1cb100: // 0160:1cb100
    r16[ax] += memoryAGet16(ds, 0x20d0bf);
    r16[ax] += r16[cx];
    memoryASet16(ds, 0x20cf51, r16[ax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d0c1);
    r16[bx] = memoryAGet16(ds, 0x20d0c5);
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1cb182; break; }
    r16[bx] -= r16[ax];
    r16[ax] = r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cb150; break; }
    r16[bx] = 0x0003;
    r32[edx] = 0;
    div16(r16[bx]);
    r16[ax] += r16[ax];
    { pc = 0x1cb16c; break; }
  case 0x1cb150: // 0160:1cb150
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0001);
    yield* sub_1cb5f9();
  case 0x1cb16c: // 0160:1cb16c
    r16[bx] = memoryAGet16(ds, 0x20d0c1);
    r16[bx] += r16[ax];
    r16[bx] += r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
    { pc = 0x1cb1db; break; }
  case 0x1cb182: // 0160:1cb182
    r16[ax] -= r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cb1ab; break; }
    r16[bx] = 0x0003;
    r32[edx] = 0;
    div16(r16[bx]);
    r16[ax] += r16[ax];
    { pc = 0x1cb1c7; break; }
  case 0x1cb1ab: // 0160:1cb1ab
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0001);
    yield* sub_1cb5f9();
  case 0x1cb1c7: // 0160:1cb1c7
    r16[bx] = memoryAGet16(ds, 0x20d0c1);
    r16[bx] -= r16[ax];
    r16[bx] -= r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
  case 0x1cb1db: // 0160:1cb1db
    memoryASet16(ds, 0x20cf63, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cb1e2() // 0160:1cb1e2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20cf89) == 0x0048)
        { pc = 0x1cb257; break; }
    if (memoryAGet16(ds, 0x20cf89) == 0x0041)
        { pc = 0x1cb204; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x0033)
        { pc = 0x1cb290; break; }
  case 0x1cb204: // 0160:1cb204
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1cb21a; break; }
    if (memoryAGet16(ds, 0x20d2b7) & 0xffff)
        { pc = 0x1cb290; break; }
  case 0x1cb21a: // 0160:1cb21a
    if (memoryAGet16(ds, 0x20d7ad) == 0x0003)
        { pc = 0x1cb290; break; }
    yield* sub_1cb291();
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20cf77, 0x0042);
    memoryASet16(ds, 0x20cf89, 0x0042);
    memoryASet16(ds, 0x20d061, 0x0000);
    memoryASet16(ds, 0x20d073, 0x0000);
    r32[esp] += 4; return;
  case 0x1cb257: // 0160:1cb257
    memoryASet16(ds, 0x20cf89, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    r16[ax] >>>= 6;
    r16[ax] &= 0x001c;
    memoryASet16(ds, 0x20cf77, r16[ax]);
    r16[ax] <<= 5;
    memoryASet16(ds, 0x20d03d, r16[ax]);
    memoryASet16(ds, 0x20d103, 0x0001);
    memoryASet16(ds, 0x20d115, 0x0001);
  case 0x1cb290: // 0160:1cb290
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cb291() // 0160:1cb291 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d181, 0x0000);
    memoryASet16(ds, 0x20d1c9, 0x0000);
    memoryASet16(ds, 0x20d127, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    yield* sub_1cb68e();
    if (!r16[ax])
        { pc = 0x1cb2ed; break; }
    memoryASet16(ds, 0x20d0c7, r16[bx]);
    memoryASet16(ds, 0x20d0c9, r16[cx]);
    memoryASet16(ds, 0x20d0cb, r16[dx]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20d0cd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d04f, r16[bp]);
  case 0x1cb2ed: // 0160:1cb2ed
    r16[ax] = memoryAGet16(ds, 0x20d0cb);
    r16[ax] -= memoryAGet16(ds, 0x20d0c7);
    if (r16s[ax] <= signed16(memoryAGet16(ds, 0x20ee37)))
        { pc = 0x1cb31a; break; }
    r16[ax] -= memoryAGet16(ds, 0x20ee37);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d0c7, memoryAGet16(ds, 0x20d0c7) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee37);
  case 0x1cb31a: // 0160:1cb31a
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0002);
    yield* sub_1cb5f9();
    r16[ax] += memoryAGet16(ds, 0x20d0c7);
    r16[ax] += r16[cx];
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d0c9);
    r16[bx] = memoryAGet16(ds, 0x20d0cd);
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1cb3ac; break; }
    r16[bx] -= r16[ax];
    r16[ax] = r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0002);
    yield* sub_1cb5f9();
    r16[bx] = memoryAGet16(ds, 0x20d0c9);
    r16[bx] += r16[ax];
    r16[bx] += r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
    { pc = 0x1cb3ec; break; }
  case 0x1cb3ac: // 0160:1cb3ac
    r16[ax] -= r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0002);
    yield* sub_1cb5f9();
    r16[bx] = memoryAGet16(ds, 0x20d0c9);
    r16[bx] -= r16[ax];
    r16[bx] -= r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
  case 0x1cb3ec: // 0160:1cb3ec
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cb3f3() // 0160:1cb3f3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20cf8b) == 0x0048)
        { pc = 0x1cb45d; break; }
    if (memoryAGet16(ds, 0x20cf8b) == 0x0041)
        { pc = 0x1cb415; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x0033)
        { pc = 0x1cb496; break; }
  case 0x1cb415: // 0160:1cb415
    if (memoryAGet16(ds, 0x20d2b7) & 0xffff)
        { pc = 0x1cb496; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0004)
        { pc = 0x1cb496; break; }
    yield* sub_1cb497();
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20cf79, 0x0042);
    memoryASet16(ds, 0x20cf8b, 0x0042);
    memoryASet16(ds, 0x20d063, 0x0000);
    memoryASet16(ds, 0x20d075, 0x0000);
    r32[esp] += 4; return;
  case 0x1cb45d: // 0160:1cb45d
    memoryASet16(ds, 0x20cf8b, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d051);
    r16[ax] >>>= 6;
    r16[ax] &= 0x001c;
    memoryASet16(ds, 0x20cf79, r16[ax]);
    r16[ax] <<= 5;
    memoryASet16(ds, 0x20d03f, r16[ax]);
    memoryASet16(ds, 0x20d105, 0x0001);
    memoryASet16(ds, 0x20d117, 0x0001);
  case 0x1cb496: // 0160:1cb496
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cb497() // 0160:1cb497 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d183, 0x0000);
    memoryASet16(ds, 0x20d1cb, 0x0000);
    memoryASet16(ds, 0x20d129, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20d051);
    yield* sub_1cb68e();
    if (!r16[ax])
        { pc = 0x1cb4f3; break; }
    memoryASet16(ds, 0x20d0cf, r16[bx]);
    memoryASet16(ds, 0x20d0d1, r16[cx]);
    memoryASet16(ds, 0x20d0d3, r16[dx]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20d0d5, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20d051, r16[bp]);
  case 0x1cb4f3: // 0160:1cb4f3
    r16[ax] = memoryAGet16(ds, 0x20d0d3);
    r16[ax] -= memoryAGet16(ds, 0x20d0cf);
    if (r16s[ax] <= signed16(memoryAGet16(ds, 0x20ee37)))
        { pc = 0x1cb520; break; }
    r16[ax] -= memoryAGet16(ds, 0x20ee37);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20d0cf, memoryAGet16(ds, 0x20d0cf) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20ee37);
  case 0x1cb520: // 0160:1cb520
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0003);
    yield* sub_1cb5f9();
    r16[ax] += memoryAGet16(ds, 0x20d0cf);
    r16[ax] += r16[cx];
    memoryASet16(ds, 0x20cf55, r16[ax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d0d1);
    r16[bx] = memoryAGet16(ds, 0x20d0d5);
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1cb5b2; break; }
    r16[bx] -= r16[ax];
    r16[ax] = r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0003);
    yield* sub_1cb5f9();
    r16[bx] = memoryAGet16(ds, 0x20d0d1);
    r16[bx] += r16[ax];
    r16[bx] += r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
    { pc = 0x1cb5f2; break; }
  case 0x1cb5b2: // 0160:1cb5b2
    r16[ax] -= r16[bx];
    r16[cx] = r16[ax];
    r16[cx] >>>= 2;
    r16[ax] -= r16[cx];
    r16[cx] >>>= 1;
    r16[bx] = memoryAGet16(ds, 0x20d7f5);
    r16[bx]++;
    r32[edx] = 0;
    div16(r16[bx]);
    memoryASet16(ds, 0x20e805, 0x0003);
    yield* sub_1cb5f9();
    r16[bx] = memoryAGet16(ds, 0x20d0d1);
    r16[bx] -= r16[ax];
    r16[bx] -= r16[cx];
    r16[bx] -= 0x0010;
    r16[ax] = r16[bx];
  case 0x1cb5f2: // 0160:1cb5f2
    memoryASet16(ds, 0x20cf67, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cb5f9() // 0160:1cb5f9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1cb68d; break; }
    r16[bp] = memoryAGet16(ds, 0x20ee31);
    memoryASet16(ds, 0x20e801, r16[bp]);
    if (r16s[bp] < signed16(memoryAGet16(ds, 0x20d7f5)))
        { pc = 0x1cb630; break; }
    memoryASet16(ds, 0x20ee31, 0x0000);
    memoryASet16(ds, 0x20e801, 0x0000);
  case 0x1cb630: // 0160:1cb630
    r16[bp] = memoryAGet16(ds, 0x20e805);
    r16[bp] += memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (r16s[bp] < signed16(memoryAGet16(ds, 0x20d7f5)))
        { pc = 0x1cb65c; break; }
    r16[bp] -= memoryAGet16(ds, 0x20d7f5);
    memoryASet16(ds, 0x20e805, r16[bp]);
  case 0x1cb65c: // 0160:1cb65c
    if (!(memoryAGet16(ds, 0x20e805) & 0xffff))
        { pc = 0x1cb68d; break; }
    if (memoryAGet16(ds, 0x20e805) == 0x0001)
        { pc = 0x1cb68a; break; }
    if (memoryAGet16(ds, 0x20e805) == 0x0002)
        { pc = 0x1cb680; break; }
    r16[ax] <<= 2;
    r32[esp] += 4; return;
  case 0x1cb680: // 0160:1cb680
    r16[bx] = r16[ax];
    r16[ax] += r16[ax];
    r16[ax] += r16[bx];
    r32[esp] += 4; return;
  case 0x1cb68a: // 0160:1cb68a
    r16[ax] += r16[ax];
  case 0x1cb68d: // 0160:1cb68d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cb68e() // 0160:1cb68e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] &= 0x00ff;
    r32[esi] = 0x00202700;
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x20d7b9);
    r16[bx] <<= 2;
    r32[ebx] = memoryAGet32(ds, r32[esi] + r32[ebx]);
    if (!r32[ebx])
        { pc = 0x1cb6f7; break; }
    r32[esi] = r32[ebx];
  case 0x1cb6ad: // 0160:1cb6ad
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[bx] < 0)
        { pc = 0x1cb6f7; break; }
    if (r16s[ax] <= r16s[bx])
        { pc = 0x1cb6f7; break; }
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[ax] >= r16s[bx])
        { pc = 0x1cb6f2; break; }
    r16[bx] = memoryAGet16(ds, r32[esi]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x6);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x8);
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[esi] += 0x0000000a;
    r32[eax] = 0x00000001;
    r32[esp] += 4; return;
  case 0x1cb6f2: // 0160:1cb6f2
    r32[esi] += 0x0000000a;
    { pc = 0x1cb6ad; break; }
  case 0x1cb6f7: // 0160:1cb6f7
    r32[eax] = 0;
    r32[esp] += 4;
    return;
  }
}
function* sub_1cb6fa() // 0160:1cb6fa +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cb6fa; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 15050 bytes // gap 15050 bytes
  case 0x1cb6fa: // 0160:1cb6fa
    if (!(memoryAGet16(ds, 0x20d7b1) & 0xffff))
        { pc = 0x1cb70e; break; }
    memoryASet16(ds, 0x20d7b1, memoryAGet16(ds, 0x20d7b1) - 0x0001);
    r32[esp] += 4; return;
  case 0x1cb70e: // 0160:1cb70e
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] == 0x0001)
        { pc = 0x1cb738; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cc32c; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1cbf62; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1cb739; break; }
  case 0x1cb738: // 0160:1cb738
    r32[esp] += 4; return;
  case 0x1cb739: // 0160:1cb739
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1cbd43; break; }
    if (!(memoryAGet16(ds, 0x20d7d5) & 0xffff))
        { pc = 0x1cb7a9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1cbc5f; break; }
    r16[bx] = memoryAGet16(ds, 0x20d7ad);
    if (!r16[bx])
        { pc = 0x1cbb7f; break; }
    r16[ax] += r16[bx];
    if (r16[ax] == 0x0004)
        { pc = 0x1cb795; break; }
    if (r16[ax] != 0x0006)
        { pc = 0x1cb7c7; break; }
    yield* sub_1cbe86();
    if (r16s[cx] > r16s[ax])
        { pc = 0x1cb790; break; }
    { pc = 0x1cb85f; break; }
  case 0x1cb790: // 0160:1cb790
    { pc = 0x1cba3b; break; }
  case 0x1cb795: // 0160:1cb795
    yield* sub_1cbe86();
    if (r16s[dx] > r16s[bx])
        { pc = 0x1cb7a4; break; }
    { pc = 0x1cb94d; break; }
  case 0x1cb7a4: // 0160:1cb7a4
    { pc = 0x1cbb29; break; }
  case 0x1cb7a9: // 0160:1cb7a9
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1cbc5f; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1cbb7f; break; }
  case 0x1cb7c7: // 0160:1cb7c7
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cb8b5; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1cb8b5; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1cb8b5; break; }
    if (memoryAGet16(ds, 0x20d0ff) & 0xffff)
        { pc = 0x1cb8b5; break; }
    yield* sub_1cbe86();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cb82d; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1cb82d; break; }
    if (r16s[bx] > r16s[ax])
        { pc = 0x1cb8b5; break; }
    memoryASet16(ds, 0x20cf87, 0x0034);
    { pc = 0x1cb85f; break; }
  case 0x1cb82d: // 0160:1cb82d
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cb851; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0003)
        { pc = 0x1cb851; break; }
    if (r16s[cx] > r16s[ax])
        { pc = 0x1cb8b5; break; }
    memoryASet16(ds, 0x20cf89, 0x0034);
    { pc = 0x1cb85f; break; }
  case 0x1cb851: // 0160:1cb851
    if (r16s[dx] > r16s[ax])
        { pc = 0x1cb8b5; break; }
    memoryASet16(ds, 0x20cf8b, 0x0034);
  case 0x1cb85f: // 0160:1cb85f
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20d7ab, 0x0001);
    r16[ax] = 0x0002;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cb892; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0002)
        { pc = 0x1cb8ae; break; }
  case 0x1cb892: // 0160:1cb892
    r16[ax] = 0x0003;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cb8aa; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0003)
        { pc = 0x1cb8ae; break; }
  case 0x1cb8aa: // 0160:1cb8aa
    r16[ax] = 0x0004;
  case 0x1cb8ae: // 0160:1cb8ae
    memoryASet16(ds, 0x20d7af, r16[ax]);
    r32[esp] += 4; return;
  case 0x1cb8b5: // 0160:1cb8b5
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cb9a3; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1cb9a3; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1cb9a3; break; }
    if (memoryAGet16(ds, 0x20d101) & 0xffff)
        { pc = 0x1cb9a3; break; }
    yield* sub_1cbe86();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cb91b; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1cb91b; break; }
    if (r16s[ax] > r16s[bx])
        { pc = 0x1cb9a3; break; }
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1cb94d; break; }
  case 0x1cb91b: // 0160:1cb91b
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cb93f; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0003)
        { pc = 0x1cb93f; break; }
    if (r16s[cx] > r16s[bx])
        { pc = 0x1cb9a3; break; }
    memoryASet16(ds, 0x20cf89, 0x0034);
    { pc = 0x1cb94d; break; }
  case 0x1cb93f: // 0160:1cb93f
    if (r16s[dx] > r16s[bx])
        { pc = 0x1cb9a3; break; }
    memoryASet16(ds, 0x20cf8b, 0x0034);
  case 0x1cb94d: // 0160:1cb94d
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20d7ab, 0x0002);
    r16[ax] = 0x0001;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cb980; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0001)
        { pc = 0x1cb99c; break; }
  case 0x1cb980: // 0160:1cb980
    r16[ax] = 0x0003;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cb998; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0003)
        { pc = 0x1cb99c; break; }
  case 0x1cb998: // 0160:1cb998
    r16[ax] = 0x0004;
  case 0x1cb99c: // 0160:1cb99c
    memoryASet16(ds, 0x20d7af, r16[ax]);
    r32[esp] += 4; return;
  case 0x1cb9a3: // 0160:1cb9a3
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cba91; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0003)
        { pc = 0x1cba91; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1cba91; break; }
    if (memoryAGet16(ds, 0x20d103) & 0xffff)
        { pc = 0x1cba91; break; }
    yield* sub_1cbe86();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cba09; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1cba09; break; }
    if (r16s[ax] > r16s[cx])
        { pc = 0x1cba91; break; }
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1cba3b; break; }
  case 0x1cba09: // 0160:1cba09
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cba2d; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1cba2d; break; }
    if (r16s[bx] > r16s[cx])
        { pc = 0x1cba91; break; }
    memoryASet16(ds, 0x20cf87, 0x0034);
    { pc = 0x1cba3b; break; }
  case 0x1cba2d: // 0160:1cba2d
    if (r16s[dx] > r16s[cx])
        { pc = 0x1cba91; break; }
    memoryASet16(ds, 0x20cf8b, 0x0034);
  case 0x1cba3b: // 0160:1cba3b
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0002);
    memoryASet16(ds, 0x20d7ab, 0x0003);
    r16[ax] = 0x0001;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cba6e; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0001)
        { pc = 0x1cba8a; break; }
  case 0x1cba6e: // 0160:1cba6e
    r16[ax] = 0x0002;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cba86; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0002)
        { pc = 0x1cba8a; break; }
  case 0x1cba86: // 0160:1cba86
    r16[ax] = 0x0004;
  case 0x1cba8a: // 0160:1cba8a
    memoryASet16(ds, 0x20d7af, r16[ax]);
    r32[esp] += 4; return;
  case 0x1cba91: // 0160:1cba91
    if (memoryAGet16(ds, 0x20d7a9) == 0x0004)
        { pc = 0x1cbb7e; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0004)
        { pc = 0x1cbb7e; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1cbb7e; break; }
    if (memoryAGet16(ds, 0x20d105) & 0xffff)
        { pc = 0x1cbb7e; break; }
    yield* sub_1cbe86();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cbaf7; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1cbaf7; break; }
    if (r16s[ax] > r16s[dx])
        { pc = 0x1cbb7e; break; }
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1cbb29; break; }
  case 0x1cbaf7: // 0160:1cbaf7
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cbb1b; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1cbb1b; break; }
    if (r16s[bx] > r16s[dx])
        { pc = 0x1cbb7e; break; }
    memoryASet16(ds, 0x20cf87, 0x0034);
    { pc = 0x1cbb29; break; }
  case 0x1cbb1b: // 0160:1cbb1b
    if (r16s[cx] > r16s[dx])
        { pc = 0x1cbb7e; break; }
    memoryASet16(ds, 0x20cf89, 0x0034);
  case 0x1cbb29: // 0160:1cbb29
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0003);
    memoryASet16(ds, 0x20d7ab, 0x0004);
    r16[ax] = 0x0001;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cbb5c; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0001)
        { pc = 0x1cbb78; break; }
  case 0x1cbb5c: // 0160:1cbb5c
    r16[ax] = 0x0002;
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cbb74; break; }
    if (memoryAGet16(ds, 0x20d7ad) != 0x0002)
        { pc = 0x1cbb78; break; }
  case 0x1cbb74: // 0160:1cbb74
    r16[ax] = 0x0003;
  case 0x1cbb78: // 0160:1cbb78
    memoryASet16(ds, 0x20d7af, r16[ax]);
  case 0x1cbb7e: // 0160:1cbb7e
    r32[esp] += 4; return;
  case 0x1cbb7f: // 0160:1cbb7f
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1cbd43; break; }
    yield* sub_1cbd44();
    r16[ax] = memoryAGet16(ds, 0x20ee27);
    if (r16[ax] == 0x00ff)
        { pc = 0x1cbd43; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1cbbb7; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cbbe1; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1cbc0b; break; }
    if (r16[ax] != 0x0003)
        { pc = 0x1cbc35; break; }
  case 0x1cbbb7: // 0160:1cbbb7
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0049))
        { pc = 0x1cbbca; break; }
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1cbbca: // 0160:1cbbca
    memoryASet16(ds, 0x20d7ad, 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbbe1: // 0160:1cbbe1
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0049))
        { pc = 0x1cbbf4; break; }
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1cbbf4: // 0160:1cbbf4
    memoryASet16(ds, 0x20d7ad, 0x0002);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbc0b: // 0160:1cbc0b
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0049))
        { pc = 0x1cbc1e; break; }
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1cbc1e: // 0160:1cbc1e
    memoryASet16(ds, 0x20d7ad, 0x0003);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbc35: // 0160:1cbc35
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0049))
        { pc = 0x1cbc48; break; }
    memoryASet16(ds, 0x20cf8b, 0x0049);
  case 0x1cbc48: // 0160:1cbc48
    memoryASet16(ds, 0x20d7ad, 0x0004);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbc5f: // 0160:1cbc5f
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1cbd43; break; }
    yield* sub_1cbd44();
    r16[ax] = memoryAGet16(ds, 0x20ee27);
    if (r16[ax] == 0x00ff)
        { pc = 0x1cbd43; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1cbc9b; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cbcc5; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1cbcef; break; }
    if (r16[ax] != 0x0003)
        { pc = 0x1cbd19; break; }
  case 0x1cbc9b: // 0160:1cbc9b
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0049))
        { pc = 0x1cbcae; break; }
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1cbcae: // 0160:1cbcae
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbcc5: // 0160:1cbcc5
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0049))
        { pc = 0x1cbcd8; break; }
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1cbcd8: // 0160:1cbcd8
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbcef: // 0160:1cbcef
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0049))
        { pc = 0x1cbd02; break; }
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1cbd02: // 0160:1cbd02
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbd19: // 0160:1cbd19
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0049))
        { pc = 0x1cbd2c; break; }
    memoryASet16(ds, 0x20cf8b, 0x0049);
  case 0x1cbd2c: // 0160:1cbd2c
    memoryASet16(ds, 0x20d7a9, 0x0004);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cbd43: // 0160:1cbd43
    r32[esp] += 4; return;
    // gap 542 bytes // gap 542 bytes
  case 0x1cbf62: // 0160:1cbf62
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1cc180; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1cc0d0; break; }
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cbff2; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1cbfe8; break; }
    if (memoryAGet16(ds, 0x20d0ff) & 0xffff)
        { pc = 0x1cbfe8; break; }
    yield* sub_1cc2ad();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cbfbe; break; }
    if (r16s[bx] > r16s[ax])
        { pc = 0x1cbfe8; break; }
    memoryASet16(ds, 0x20cf87, 0x0034);
    { pc = 0x1cbfcc; break; }
  case 0x1cbfbe: // 0160:1cbfbe
    if (r16s[cx] > r16s[ax])
        { pc = 0x1cbfe8; break; }
    memoryASet16(ds, 0x20cf89, 0x0034);
  case 0x1cbfcc: // 0160:1cbfcc
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20d7ab, 0x0001);
    r32[esp] += 4; return;
  case 0x1cbfe8: // 0160:1cbfe8
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1cc05e; break; }
  case 0x1cbff2: // 0160:1cbff2
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1cc050; break; }
    if (memoryAGet16(ds, 0x20d101) & 0xffff)
        { pc = 0x1cc050; break; }
    yield* sub_1cc2ad();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cc026; break; }
    if (r16s[ax] > r16s[bx])
        { pc = 0x1cc050; break; }
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1cc034; break; }
  case 0x1cc026: // 0160:1cc026
    if (r16s[cx] > r16s[bx])
        { pc = 0x1cc050; break; }
    memoryASet16(ds, 0x20cf89, 0x0034);
  case 0x1cc034: // 0160:1cc034
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20d7ab, 0x0002);
    r32[esp] += 4; return;
  case 0x1cc050: // 0160:1cc050
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1cc180; break; }
  case 0x1cc05e: // 0160:1cc05e
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1cc180; break; }
    if (memoryAGet16(ds, 0x20d103) & 0xffff)
        { pc = 0x1cc180; break; }
    yield* sub_1cc2ad();
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1cc0a2; break; }
    if (r16s[ax] > r16s[cx])
        { pc = 0x1cc180; break; }
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1cc0b4; break; }
  case 0x1cc0a2: // 0160:1cc0a2
    if (r16s[bx] > r16s[cx])
        { pc = 0x1cc180; break; }
    memoryASet16(ds, 0x20cf87, 0x0034);
  case 0x1cc0b4: // 0160:1cc0b4
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0002);
    memoryASet16(ds, 0x20d7ab, 0x0003);
    r32[esp] += 4; return;
  case 0x1cc0d0: // 0160:1cc0d0
    if (memoryAGet16(ds, 0x20d2b9) & 0xffff)
        { pc = 0x1cc180; break; }
    yield* sub_1cc181();
    r16[ax] = memoryAGet16(ds, 0x20ee27);
    if (r16[ax] == 0x00ff)
        { pc = 0x1cc180; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1cc102; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1cc12c; break; }
    if (r16[ax] != 0x0002)
        { pc = 0x1cc156; break; }
  case 0x1cc102: // 0160:1cc102
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0049))
        { pc = 0x1cc115; break; }
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1cc115: // 0160:1cc115
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cc12c: // 0160:1cc12c
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0049))
        { pc = 0x1cc13f; break; }
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1cc13f: // 0160:1cc13f
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cc156: // 0160:1cc156
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0049))
        { pc = 0x1cc169; break; }
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1cc169: // 0160:1cc169
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20d7b1, 0x0004);
    { pc = 0x1cc421; break; }
  case 0x1cc180: // 0160:1cc180
    r32[esp] += 4; return;
    // gap 427 bytes // gap 427 bytes
  case 0x1cc32c: // 0160:1cc32c
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1cc420; break; }
    if (memoryAGet16(ds, 0x20d0ff) & 0xffff)
        { pc = 0x1cc420; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[bx] = memoryAGet16(ds, 0x20d04d);
    r16[ax] &= 0x00ff;
    r16[bx] &= 0x00ff;
    if (r16s[ax] >= signed16(0x008c))
        { pc = 0x1cc36d; break; }
    if (r16s[bx] <= signed16(0x008c))
        { pc = 0x1cc37f; break; }
  case 0x1cc36d: // 0160:1cc36d
    r16[ax] += 0x00b4;
    r16[ax] &= 0x00ff;
    r16[bx] += 0x00b4;
    r16[bx] &= 0x00ff;
  case 0x1cc37f: // 0160:1cc37f
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1cc3d5; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1cc420; break; }
    if (memoryAGet16(ds, 0x20d083) & 0xffff)
        { pc = 0x1cc3a6; break; }
    memoryASet16(ds, 0x20d7b7, 0x0002);
  case 0x1cc3a6: // 0160:1cc3a6
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20d7ab, 0x0002);
    memoryASet16(ds, 0x20cf85, 0x0034);
    memoryASet16(ds, 0x20cf73, 0x0034);
    { pc = 0x1cc420; break; }
  case 0x1cc3d5: // 0160:1cc3d5
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1cc420; break; }
    if (memoryAGet16(ds, 0x20d081) & 0xffff)
        { pc = 0x1cc3f3; break; }
    memoryASet16(ds, 0x20d7b7, 0x0001);
  case 0x1cc3f3: // 0160:1cc3f3
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20d7ab, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0034);
    memoryASet16(ds, 0x20cf75, 0x0034);
  case 0x1cc420: // 0160:1cc420
    r32[esp] += 4; return;
  case 0x1cc421: // 0160:1cc421
    r8[al] = 0x58;
    { pc = 0x1b17b7; break; }
    return;
  }
}
function* sub_1cbd44() // 0160:1cbd44 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ee27, 0x00ff);
    r32[edi] = 0x0020d111;
    r32[ecx] = 0x00000004;
    r16[bx] = 0x0001;
    r16[ax] = 0;
  case 0x1cbd5e: // 0160:1cbd5e
    if (memoryAGet16(ds, 0x20d7a9) == r16[bx])
        { pc = 0x1cbd79; break; }
    if (memoryAGet16(ds, 0x20d7ad) == r16[bx])
        { pc = 0x1cbd79; break; }
    if (memoryAGet16(ds, r32[edi]) & 0xffff)
        { pc = 0x1cbd79; break; }
    r16[ax]++;
  case 0x1cbd79: // 0160:1cbd79
    r16[bx]++;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1cbd5e; break; }
    if (r16s[ax] >= signed16(0x0002))
        { pc = 0x1cbd87; break; }
    r32[esp] += 4; return;
  case 0x1cbd87: // 0160:1cbd87
    yield* sub_1cbe86();
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    memoryASet16(ds, 0x20ceb7, r16[bx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    memoryASet16(ds, 0x20cebb, r16[dx]);
    memoryASet16(ds, 0x20ee17, 0x0002);
    memoryASet16(ds, 0x20ee19, 0x0004);
    memoryASet16(ds, 0x20ee1b, 0x0006);
    memoryASet16(ds, 0x20ee1d, 0x0008);
  case 0x1cbdcb: // 0160:1cbdcb
    r32[esi] = 0x0020ee17;
    r32[edi] = 0x0020ceb5;
    r32[ecx] = 0x00000003;
  case 0x1cbdda: // 0160:1cbdda
    r16[ax] = memoryAGet16(ds, r32[edi]);
    if (r16s[ax] <= signed16(memoryAGet16(ds, r32[edi] + 0x2)))
        { pc = 0x1cbdfe; break; }
    r16[bp] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, r32[edi], r16[bp]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, r32[esi], r16[bp]);
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
    { pc = 0x1cbdcb; break; }
  case 0x1cbdfe: // 0160:1cbdfe
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1cbdda; break; }
    r32[esi] = 0x0020ee17;
    r32[edi] = 0x0020d111;
    r32[ebx] = 0x0020d231;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1cbe1e: // 0160:1cbe1e
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] -= 0x0002;
    r32[eax] &= 0x0000ffff;
    if (!(memoryAGet16(ds, r32[edi] + r32[eax]) & 0xffff))
        { pc = 0x1cbe59; break; }
    r32[eax] <<= 1;
    r16[cx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    if (r16s[cx] <= signed16(0x0098))
        { pc = 0x1cbe59; break; }
    if (r16s[cx] >= signed16(0x0188))
        { pc = 0x1cbe59; break; }
    if (r16s[dx] <= signed16(0x0098))
        { pc = 0x1cbe59; break; }
    if (r16s[dx] < signed16(0x0124))
        { pc = 0x1cbe71; break; }
  case 0x1cbe59: // 0160:1cbe59
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] >>>= 1;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1cbe71; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1cbe7f; break; }
  case 0x1cbe71: // 0160:1cbe71
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1cbe1e; break; }
    r32[esp] += 4; return;
  case 0x1cbe7f: // 0160:1cbe7f
    memoryASet16(ds, 0x20ee27, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cbe86() // 0160:1cbe86 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[bx] = memoryAGet16(ds, 0x20d04d);
    r16[cx] = memoryAGet16(ds, 0x20d04f);
    r16[dx] = memoryAGet16(ds, 0x20d051);
    r16[ax] &= 0x00ff;
    r16[bx] &= 0x00ff;
    r16[cx] &= 0x00ff;
    r16[dx] &= 0x00ff;
    r16[bp] = memoryAGet16(ds, 0x20d7a9);
    memoryASet16(ds, 0x20e809, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20d7ad);
    memoryASet16(ds, 0x20e805, r16[bp]);
    if (memoryAGet16(ds, 0x20e809) == 0x0001)
        { pc = 0x1cbeea; break; }
    if (memoryAGet16(ds, 0x20e805) == 0x0001)
        { pc = 0x1cbeea; break; }
    if (r16s[ax] >= signed16(0x008c))
        { pc = 0x1cbf3b; break; }
  case 0x1cbeea: // 0160:1cbeea
    if (memoryAGet16(ds, 0x20e809) == 0x0002)
        { pc = 0x1cbf05; break; }
    if (memoryAGet16(ds, 0x20e805) == 0x0002)
        { pc = 0x1cbf05; break; }
    if (r16s[bx] >= signed16(0x008c))
        { pc = 0x1cbf3b; break; }
  case 0x1cbf05: // 0160:1cbf05
    if (memoryAGet16(ds, 0x20e809) == 0x0003)
        { pc = 0x1cbf20; break; }
    if (memoryAGet16(ds, 0x20e805) == 0x0003)
        { pc = 0x1cbf20; break; }
    if (r16s[cx] >= signed16(0x008c))
        { pc = 0x1cbf3b; break; }
  case 0x1cbf20: // 0160:1cbf20
    if (memoryAGet16(ds, 0x20e809) == 0x0004)
        { pc = 0x1cbf61; break; }
    if (memoryAGet16(ds, 0x20e805) == 0x0004)
        { pc = 0x1cbf61; break; }
    if (r16s[dx] <= signed16(0x008c))
        { pc = 0x1cbf61; break; }
  case 0x1cbf3b: // 0160:1cbf3b
    r16[ax] += 0x00b4;
    r16[bx] += 0x00b4;
    r16[cx] += 0x00b4;
    r16[dx] += 0x00b4;
    r16[ax] &= 0x00ff;
    r16[bx] &= 0x00ff;
    r16[cx] &= 0x00ff;
    r16[dx] &= 0x00ff;
  case 0x1cbf61: // 0160:1cbf61
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cc181() // 0160:1cc181 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20ee27, 0x00ff);
    r32[edi] = 0x0020d111;
    memoryASet16(ds, 0x20e809, 0x0003);
    r16[bx] = 0x0001;
    r16[ax] = 0;
  case 0x1cc19f: // 0160:1cc19f
    if (r16[bx] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1cc1b1; break; }
    if (memoryAGet16(ds, r32[edi]) & 0xffff)
        { pc = 0x1cc1b1; break; }
    r16[ax]++;
  case 0x1cc1b1: // 0160:1cc1b1
    r16[bx]++;
    r32[edi] += 0x00000002;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1cc19f; break; }
    if (r16s[ax] >= signed16(0x0002))
        { pc = 0x1cc1c7; break; }
    r32[esp] += 4; return;
  case 0x1cc1c7: // 0160:1cc1c7
    yield* sub_1cc2ad();
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    memoryASet16(ds, 0x20ceb7, r16[bx]);
    memoryASet16(ds, 0x20ceb9, r16[cx]);
    memoryASet16(ds, 0x20ee17, 0x0002);
    memoryASet16(ds, 0x20ee19, 0x0004);
    memoryASet16(ds, 0x20ee1b, 0x0006);
  case 0x1cc1fb: // 0160:1cc1fb
    r32[esi] = 0x0020ee17;
    r32[edi] = 0x0020ceb5;
    r32[ecx] = 0x00000002;
  case 0x1cc20a: // 0160:1cc20a
    r16[ax] = memoryAGet16(ds, r32[edi]);
    if (r16s[ax] <= signed16(memoryAGet16(ds, r32[edi] + 0x2)))
        { pc = 0x1cc22e; break; }
    r16[bp] = memoryAGet16(ds, r32[edi] + 0x2);
    memoryASet16(ds, r32[edi], r16[bp]);
    memoryASet16(ds, r32[edi] + 0x2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, r32[esi], r16[bp]);
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
    { pc = 0x1cc1fb; break; }
  case 0x1cc22e: // 0160:1cc22e
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1cc20a; break; }
    r32[esi] = 0x0020ee17;
    r32[edi] = 0x0020d111;
    r32[ebx] = 0x0020d231;
    memoryASet16(ds, 0x20e809, 0x0003);
  case 0x1cc24e: // 0160:1cc24e
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] -= 0x0002;
    r32[eax] &= 0x0000ffff;
    if (!(memoryAGet16(ds, r32[edi] + r32[eax]) & 0xffff))
        { pc = 0x1cc289; break; }
    r32[eax] <<= 1;
    r16[cx] = memoryAGet16(ds, r32[ebx] + r32[eax]);
    r16[dx] = memoryAGet16(ds, r32[ebx] + r32[eax] + 0x2);
    if (r16s[cx] <= signed16(0x0098))
        { pc = 0x1cc289; break; }
    if (r16s[cx] >= signed16(0x0188))
        { pc = 0x1cc289; break; }
    if (r16s[dx] <= signed16(0x0098))
        { pc = 0x1cc289; break; }
    if (r16s[dx] < signed16(0x0124))
        { pc = 0x1cc298; break; }
  case 0x1cc289: // 0160:1cc289
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] >>>= 1;
    if (r16[ax] != memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1cc2a6; break; }
  case 0x1cc298: // 0160:1cc298
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1cc24e; break; }
    r32[esp] += 4; return;
  case 0x1cc2a6: // 0160:1cc2a6
    memoryASet16(ds, 0x20ee27, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cc2ad() // 0160:1cc2ad +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[bx] = memoryAGet16(ds, 0x20d04d);
    r16[cx] = memoryAGet16(ds, 0x20d04f);
    r16[ax] &= 0x00ff;
    r16[bx] &= 0x00ff;
    r16[cx] &= 0x00ff;
    r16[bp] = memoryAGet16(ds, 0x20d7a9);
    memoryASet16(ds, 0x20e809, r16[bp]);
    if (memoryAGet16(ds, 0x20e809) == 0x0001)
        { pc = 0x1cc2ed; break; }
    if (r16s[ax] >= signed16(0x008c))
        { pc = 0x1cc30f; break; }
  case 0x1cc2ed: // 0160:1cc2ed
    if (memoryAGet16(ds, 0x20e809) == 0x0002)
        { pc = 0x1cc2fe; break; }
    if (r16s[bx] >= signed16(0x008c))
        { pc = 0x1cc30f; break; }
  case 0x1cc2fe: // 0160:1cc2fe
    if (memoryAGet16(ds, 0x20e809) == 0x0003)
        { pc = 0x1cc32b; break; }
    if (r16s[cx] <= signed16(0x008c))
        { pc = 0x1cc32b; break; }
  case 0x1cc30f: // 0160:1cc30f
    r16[ax] += 0x00b4;
    r16[bx] += 0x00b4;
    r16[cx] += 0x00b4;
    r16[ax] &= 0x00ff;
    r16[bx] &= 0x00ff;
    r16[cx] &= 0x00ff;
  case 0x1cc32b: // 0160:1cc32b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cc428() // 0160:1cc428 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] &= 0x00ff;
    if (r16s[ax] >= signed16(0x0007))
        { pc = 0x1cc691; break; }
    if (memoryAGet32(ds, 0x20d093) != 0x01010101)
        { pc = 0x1cc689; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1cc689; break; }
    if (memoryAGet16(ds, 0x20d79f) & 0xffff)
        { pc = 0x1cc572; break; }
    memoryASet16(ds, 0x20d79f, 0x0096);
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1cc55c; break; }
    r16[bx] = 0;
    r16[dx] = 0;
    r8[al] = memoryAGet(ds, 0x20d77f);
    r8[al] -= memoryAGet(ds, 0x20d79d);
    if (r8s[al] >= 0)
        { pc = 0x1cc498; break; }
    r8[al] += 0x0a;
    r8[bl] = 0xff;
  case 0x1cc498: // 0160:1cc498
    memoryASet(ds, 0x20d785, r8[al]);
    r8[al] = memoryAGet(ds, 0x20d77e);
    r8[al] -= memoryAGet(ds, 0x20d79c);
    r8[al] += r8[bl];
    if (r8s[al] >= 0)
        { pc = 0x1cc4b4; break; }
    r8[al] += 0x0a;
    r8[bh] = 0xff;
  case 0x1cc4b4: // 0160:1cc4b4
    memoryASet(ds, 0x20d784, r8[al]);
    r8[al] = memoryAGet(ds, 0x20d77d);
    r8[al] -= memoryAGet(ds, 0x20d79b);
    r8[al] += r8[bh];
    if (r8s[al] >= 0)
        { pc = 0x1cc4d0; break; }
    r8[al] += 0x0a;
    r8[dl] = 0xff;
  case 0x1cc4d0: // 0160:1cc4d0
    memoryASet(ds, 0x20d783, r8[al]);
    r8[al] = memoryAGet(ds, 0x20d77c);
    r8[al] -= memoryAGet(ds, 0x20d79a);
    r8[al] += r8[dl];
    if (r8s[al] >= 0)
        { pc = 0x1cc4ec; break; }
    r8[al] += 0x06;
    r8[dh] = 0xff;
  case 0x1cc4ec: // 0160:1cc4ec
    memoryASet(ds, 0x20d782, r8[al]);
    r8[al] = memoryAGet(ds, 0x20d77b);
    r8[al] -= memoryAGet(ds, 0x20d799);
    r8[al] += r8[dh];
    memoryASet(ds, 0x20d781, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x20d77b);
    memoryASet32(ds, 0x20d799, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d77f);
    memoryASet16(ds, 0x20d79d, r16[ax]);
    r32[esi] = 0x0020d781;
    r32[edi] = 0x0020d793;
    r32[ecx] = 0x00000005;
  case 0x1cc528: // 0160:1cc528
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8s[al] < signed8(memoryAGet(ds, r32[edi])))
        { pc = 0x1cc541; break; }
    if (r8[al] > memoryAGet(ds, r32[edi]))
        { pc = 0x1cc572; break; }
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1cc528; break; }
    { pc = 0x1cc572; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1cc541: // 0160:1cc541
    r32[eax] = memoryAGet32(ds, 0x20d781);
    memoryASet32(ds, 0x20d793, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d785);
    memoryASet16(ds, 0x20d797, r16[ax]);
    { pc = 0x1cc572; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1cc55c: // 0160:1cc55c
    r32[eax] = memoryAGet32(ds, 0x20d77b);
    memoryASet32(ds, 0x20d781, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d77f);
    memoryASet16(ds, 0x20d785, r16[ax]);
  case 0x1cc572: // 0160:1cc572
    if (!(memoryAGet16(ds, 0x20d081) & 0xffff))
        { pc = 0x1cc689; break; }
    if (!(memoryAGet16(ds, 0x20edef) & 0xffff))
        { pc = 0x1cc614; break; }
    if (memoryAGet16(ds, 0x20d081) != 0x0003)
        { pc = 0x1cc614; break; }
    if (signed16(memoryAGet16(ds, 0x20d863)) >= signed16(0x000a))
        { pc = 0x1cc614; break; }
    if (memoryAGet16(ds, 0x20d16d) & 0xffff)
        { pc = 0x1cc614; break; }
    r32[esi] = 0;
    r16[si] = memoryAGet16(ds, 0x20d863);
    r32[eax] = r32[esi];
    r32[esi] <<= 2;
    r32[esi] += r32[eax];
    r32[eax] = r32[esi];
    r32[edi] = 0x0020d77b;
    r32[esi] = 0x00209150;
    r32[esi] += r32[eax];
    r32[ecx] = 0x0000000a;
  case 0x1cc5de: // 0160:1cc5de
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] > memoryAGet(ds, r32[edi]))
        { pc = 0x1cc5f2; break; }
    if (r8[al] < memoryAGet(ds, r32[edi]))
        { pc = 0x1cc614; break; }
    r32[esi]++;
    r32[edi]++;
    if (--r32[ecx])
        { pc = 0x1cc5de; break; }
  case 0x1cc5f2: // 0160:1cc5f2
    r8[al] = 0x89;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d7a3, 0x0032);
    memoryASet16(ds, 0x20d87f, 0x0001);
    memoryASet16(ds, 0x20edf1, 0x000c);
  case 0x1cc614: // 0160:1cc614
    memoryASet16(ds, 0x20d081, memoryAGet16(ds, 0x20d081) - 0x0001);
    yield* sub_1cc912();
    if (memoryAGet16(ds, 0x20d081) != 0x0001)
        { pc = 0x1cc66c; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1cc65e; break; }
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1cc689; break; }
    if (memoryAGet16(ds, 0x20d89f) == 0x0001)
        { pc = 0x1cc65e; break; }
    if (memoryAGet16(ds, 0x20d16d))
        { pc = 0x1cc65e; break; }
    r16[ax] = 0x0135;
    yield* sub_1b1715();
    { pc = 0x1cc689; break; }
  case 0x1cc65e: // 0160:1cc65e
    r16[ax] = 0x0136;
    yield* sub_1b1715();
    { pc = 0x1cc689; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1cc66c: // 0160:1cc66c
    if (signed16(memoryAGet16(ds, 0x20d7f5)) > signed16(0x0002))
        { pc = 0x1cc689; break; }
    if (memoryAGet16(ds, 0x20d081) != 0x0002)
        { pc = 0x1cc689; break; }
    r16[ax] = 0x0134;
    yield* sub_1b1715();
  case 0x1cc689: // 0160:1cc689
    r32[eax] = 0;
    memoryASet32(ds, 0x20d093, r32[eax]);
    r32[esp] += 4; return;
  case 0x1cc691: // 0160:1cc691
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1cc6e9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] &= 0x00ff;
    if (r16[ax] != memoryAGet16(ds, 0x20d7a1))
        { pc = 0x1cc6e9; break; }
    if (memoryAGet16(ds, 0x20d79f) & 0xffff)
        { pc = 0x1cc6e9; break; }
    memoryASet16(ds, 0x20d79f, 0x0096);
    r32[ebx] = memoryAGet32(ds, 0x20d77b);
    memoryASet32(ds, 0x20d781, r32[ebx]);
    r16[bx] = memoryAGet16(ds, 0x20d77f);
    memoryASet16(ds, 0x20d785, r16[bx]);
  case 0x1cc6e9: // 0160:1cc6e9
    if (r16[ax] < 0x0020)
        { pc = 0x1cc73a; break; }
    if (r16[ax] < 0x0040)
        { pc = 0x1cc733; break; }
    if (r16[ax] < 0x0060)
        { pc = 0x1cc72b; break; }
    if (r16[ax] < 0x0080)
        { pc = 0x1cc723; break; }
    if (r16[ax] >= 0x00a8)
        { pc = 0x1cc73a; break; }
    memoryASet(ds, 0x20d096, 0x01);
    r32[esp] += 4; return;
  case 0x1cc723: // 0160:1cc723
    memoryASet(ds, 0x20d095, 0x01);
    r32[esp] += 4; return;
  case 0x1cc72b: // 0160:1cc72b
    memoryASet(ds, 0x20d094, 0x01);
    r32[esp] += 4; return;
  case 0x1cc733: // 0160:1cc733
    memoryASet(ds, 0x20d093, 0x01);
  case 0x1cc73a: // 0160:1cc73a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cc73b() // 0160:1cc73b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    r16[ax] &= 0x00ff;
    if (r16s[ax] >= signed16(0x0007))
        { pc = 0x1cc786; break; }
    if (memoryAGet32(ds, 0x20d097) != 0x01010101)
        { pc = 0x1cc77b; break; }
    if (!(memoryAGet16(ds, 0x20d083) & 0xffff))
        { pc = 0x1cc77b; break; }
    memoryASet16(ds, 0x20d083, memoryAGet16(ds, 0x20d083) - 0x0001);
    yield* sub_1cc912();
  case 0x1cc77b: // 0160:1cc77b
    memoryASet32(ds, 0x20d097, 0x00000000);
    r32[esp] += 4; return;
  case 0x1cc786: // 0160:1cc786
    if (r16[ax] < 0x0020)
        { pc = 0x1cc7d7; break; }
    if (r16[ax] < 0x0040)
        { pc = 0x1cc7d0; break; }
    if (r16[ax] < 0x0060)
        { pc = 0x1cc7c8; break; }
    if (r16[ax] < 0x0080)
        { pc = 0x1cc7c0; break; }
    if (r16[ax] >= 0x00a8)
        { pc = 0x1cc7d7; break; }
    memoryASet(ds, 0x20d09a, 0x01);
    r32[esp] += 4; return;
  case 0x1cc7c0: // 0160:1cc7c0
    memoryASet(ds, 0x20d099, 0x01);
    r32[esp] += 4; return;
  case 0x1cc7c8: // 0160:1cc7c8
    memoryASet(ds, 0x20d098, 0x01);
    r32[esp] += 4; return;
  case 0x1cc7d0: // 0160:1cc7d0
    memoryASet(ds, 0x20d097, 0x01);
  case 0x1cc7d7: // 0160:1cc7d7
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cc7d8() // 0160:1cc7d8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    r16[ax] &= 0x00ff;
    if (r16s[ax] >= signed16(0x0007))
        { pc = 0x1cc823; break; }
    if (memoryAGet32(ds, 0x20d09b) != 0x01010101)
        { pc = 0x1cc818; break; }
    if (!(memoryAGet16(ds, 0x20d085) & 0xffff))
        { pc = 0x1cc818; break; }
    memoryASet16(ds, 0x20d085, memoryAGet16(ds, 0x20d085) - 0x0001);
    yield* sub_1cc912();
  case 0x1cc818: // 0160:1cc818
    memoryASet32(ds, 0x20d09b, 0x00000000);
    r32[esp] += 4; return;
  case 0x1cc823: // 0160:1cc823
    if (r16[ax] < 0x0020)
        { pc = 0x1cc874; break; }
    if (r16[ax] < 0x0040)
        { pc = 0x1cc86d; break; }
    if (r16[ax] < 0x0060)
        { pc = 0x1cc865; break; }
    if (r16[ax] < 0x0080)
        { pc = 0x1cc85d; break; }
    if (r16[ax] >= 0x00a8)
        { pc = 0x1cc874; break; }
    memoryASet(ds, 0x20d09e, 0x01);
    r32[esp] += 4; return;
  case 0x1cc85d: // 0160:1cc85d
    memoryASet(ds, 0x20d09d, 0x01);
    r32[esp] += 4; return;
  case 0x1cc865: // 0160:1cc865
    memoryASet(ds, 0x20d09c, 0x01);
    r32[esp] += 4; return;
  case 0x1cc86d: // 0160:1cc86d
    memoryASet(ds, 0x20d09b, 0x01);
  case 0x1cc874: // 0160:1cc874
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cc875() // 0160:1cc875 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d051);
    r16[ax] &= 0x00ff;
    if (r16s[ax] >= signed16(0x0007))
        { pc = 0x1cc8c0; break; }
    if (memoryAGet32(ds, 0x20d09f) != 0x01010101)
        { pc = 0x1cc8b5; break; }
    if (!(memoryAGet16(ds, 0x20d087) & 0xffff))
        { pc = 0x1cc8b5; break; }
    memoryASet16(ds, 0x20d087, memoryAGet16(ds, 0x20d087) - 0x0001);
    yield* sub_1cc912();
  case 0x1cc8b5: // 0160:1cc8b5
    memoryASet32(ds, 0x20d09f, 0x00000000);
    r32[esp] += 4; return;
  case 0x1cc8c0: // 0160:1cc8c0
    if (r16[ax] < 0x0020)
        { pc = 0x1cc911; break; }
    if (r16[ax] < 0x0040)
        { pc = 0x1cc90a; break; }
    if (r16[ax] < 0x0060)
        { pc = 0x1cc902; break; }
    if (r16[ax] < 0x0080)
        { pc = 0x1cc8fa; break; }
    if (r16[ax] >= 0x00a8)
        { pc = 0x1cc911; break; }
    memoryASet(ds, 0x20d0a2, 0x01);
    r32[esp] += 4; return;
  case 0x1cc8fa: // 0160:1cc8fa
    memoryASet(ds, 0x20d0a1, 0x01);
    r32[esp] += 4; return;
  case 0x1cc902: // 0160:1cc902
    memoryASet(ds, 0x20d0a0, 0x01);
    r32[esp] += 4; return;
  case 0x1cc90a: // 0160:1cc90a
    memoryASet(ds, 0x20d09f, 0x01);
  case 0x1cc911: // 0160:1cc911
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cc912() // 0160:1cc912 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cc912; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 19682 bytes // gap 19682 bytes
  case 0x1cc912: // 0160:1cc912
    r8[al] = 0x5a;
    { pc = 0x1b17b7; break; }
    return;
  }
}
function* sub_1cc919() // 0160:1cc919 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cc919; break; }
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
    // gap 91257 bytes // gap 91257 bytes
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 19569 bytes // gap 19569 bytes
  case 0x1cc919: // 0160:1cc919
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1cca09; break; }
    r32[eax] = memoryAGet32(ds, 0x20d0b7);
    memoryASet32(ds, 0x20d0f7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0bb);
    memoryASet32(ds, 0x20d0fb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    memoryASet16(ds, 0x20d05b, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20cf4f);
    r16[dx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1cccef();
    if (memoryAGet16(ds, 0x20d7d3) & 0xffff)
        { pc = 0x1cc9e9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] &= 0x00ff;
    r16[bx] = memoryAGet16(ds, 0x20d05b);
    r16[bx] &= 0x00ff;
    r16[bx] -= r16[ax];
    if (r16[bx] < memoryAGet16(ds, 0x20d7e9))
        { pc = 0x1cc9e9; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7eb))
        { pc = 0x1cc9e9; break; }
    if (r16[bx] < memoryAGet16(ds, 0x20d7ed))
        { pc = 0x1cc9cd; break; }
    if (r16[bx] < 0x00b0)
        { pc = 0x1cc9e9; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7ef))
        { pc = 0x1cc9cd; break; }
    if (r16[bx] >= 0xff50)
        { pc = 0x1cc9e9; break; }
  case 0x1cc9cd: // 0160:1cc9cd
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x003b))
        { pc = 0x1cca09; break; }
    memoryASet16(ds, 0x20cf85, 0x003b);
    { pc = 0x1cccdd; break; }
  case 0x1cc9e9: // 0160:1cc9e9
    r16[ax] = memoryAGet16(ds, 0x20d05b);
    memoryASet16(ds, 0x20d04b, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0f7);
    memoryASet32(ds, 0x20d0b7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0fb);
    memoryASet32(ds, 0x20d0bb, r32[eax]);
  case 0x1cca09: // 0160:1cca09
    r32[esp] += 4; return;
    // gap 723 bytes // gap 723 bytes
  case 0x1cccdd: // 0160:1cccdd
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x00f5;
    { pc = 0x1b1715; break; }
    return;
  }
}
function* sub_1cca0a() // 0160:1cca0a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cca0a; break; }
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
    // gap 91257 bytes // gap 91257 bytes
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 19810 bytes // gap 19810 bytes
  case 0x1cca0a: // 0160:1cca0a
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ccafa; break; }
    r32[eax] = memoryAGet32(ds, 0x20d0bf);
    memoryASet32(ds, 0x20d0f7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0c3);
    memoryASet32(ds, 0x20d0fb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    memoryASet16(ds, 0x20d05b, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20cf51);
    r16[dx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1cccef();
    if (memoryAGet16(ds, 0x20d7d3) & 0xffff)
        { pc = 0x1ccada; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    r16[ax] &= 0x00ff;
    r16[bx] = memoryAGet16(ds, 0x20d05b);
    r16[bx] &= 0x00ff;
    r16[bx] -= r16[ax];
    if (r16[bx] < memoryAGet16(ds, 0x20d7e9))
        { pc = 0x1ccada; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7eb))
        { pc = 0x1ccada; break; }
    if (r16[bx] < memoryAGet16(ds, 0x20d7ed))
        { pc = 0x1ccabe; break; }
    if (r16[bx] < 0x00b0)
        { pc = 0x1ccada; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7ef))
        { pc = 0x1ccabe; break; }
    if (r16[bx] >= 0xff50)
        { pc = 0x1ccada; break; }
  case 0x1ccabe: // 0160:1ccabe
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x003b))
        { pc = 0x1ccafa; break; }
    memoryASet16(ds, 0x20cf87, 0x003b);
    { pc = 0x1cccdd; break; }
  case 0x1ccada: // 0160:1ccada
    r16[ax] = memoryAGet16(ds, 0x20d05b);
    memoryASet16(ds, 0x20d04d, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0f7);
    memoryASet32(ds, 0x20d0bf, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0fb);
    memoryASet32(ds, 0x20d0c3, r32[eax]);
  case 0x1ccafa: // 0160:1ccafa
    r32[esp] += 4; return;
    // gap 482 bytes // gap 482 bytes
  case 0x1cccdd: // 0160:1cccdd
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x00f5;
    { pc = 0x1b1715; break; }
    return;
  }
}
function* sub_1ccafb() // 0160:1ccafb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ccafb; break; }
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
    // gap 91257 bytes // gap 91257 bytes
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 20051 bytes // gap 20051 bytes
  case 0x1ccafb: // 0160:1ccafb
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ccbeb; break; }
    r32[eax] = memoryAGet32(ds, 0x20d0c7);
    memoryASet32(ds, 0x20d0f7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0cb);
    memoryASet32(ds, 0x20d0fb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    memoryASet16(ds, 0x20d05b, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20cf53);
    r16[dx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1cccef();
    if (memoryAGet16(ds, 0x20d7d3) & 0xffff)
        { pc = 0x1ccbcb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    r16[ax] &= 0x00ff;
    r16[bx] = memoryAGet16(ds, 0x20d05b);
    r16[bx] &= 0x00ff;
    r16[bx] -= r16[ax];
    if (r16[bx] < memoryAGet16(ds, 0x20d7e9))
        { pc = 0x1ccbcb; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7eb))
        { pc = 0x1ccbcb; break; }
    if (r16[bx] < memoryAGet16(ds, 0x20d7ed))
        { pc = 0x1ccbaf; break; }
    if (r16[bx] < 0x00b0)
        { pc = 0x1ccbcb; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7ef))
        { pc = 0x1ccbaf; break; }
    if (r16[bx] >= 0xff50)
        { pc = 0x1ccbcb; break; }
  case 0x1ccbaf: // 0160:1ccbaf
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x003b))
        { pc = 0x1ccbeb; break; }
    memoryASet16(ds, 0x20cf89, 0x003b);
    { pc = 0x1cccdd; break; }
  case 0x1ccbcb: // 0160:1ccbcb
    r16[ax] = memoryAGet16(ds, 0x20d05b);
    memoryASet16(ds, 0x20d04f, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0f7);
    memoryASet32(ds, 0x20d0c7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0fb);
    memoryASet32(ds, 0x20d0cb, r32[eax]);
  case 0x1ccbeb: // 0160:1ccbeb
    r32[esp] += 4; return;
    // gap 241 bytes // gap 241 bytes
  case 0x1cccdd: // 0160:1cccdd
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x00f5;
    { pc = 0x1b1715; break; }
    return;
  }
}
function* sub_1ccbec() // 0160:1ccbec +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ccbec; break; }
  case 0x1b1715: // 0160:1b1715
    if (!memoryAGet32(ds, 0x30b130))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b17b6; break; }
    r32[eax] &= 0x0000ffff;
    memoryASet16(ds, 0x20ee85, 0x0078);
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    r32[eax] = 0x00000004;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1c7c30; break; }
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
    // gap 91257 bytes // gap 91257 bytes
  case 0x1c7c30: // 0160:1c7c30
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000020;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x0000003f);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7c86; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c88; break; }
  case 0x1c7c86: // 0160:1c7c86
    { pc = 0x1c7c9f; break; }
  case 0x1c7c88: // 0160:1c7c88
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c9f: // 0160:1c7c9f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 20292 bytes // gap 20292 bytes
  case 0x1ccbec: // 0160:1ccbec
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1cccdc; break; }
    r32[eax] = memoryAGet32(ds, 0x20d0cf);
    memoryASet32(ds, 0x20d0f7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0d3);
    memoryASet32(ds, 0x20d0fb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d051);
    memoryASet16(ds, 0x20d05b, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x20cf55);
    r16[dx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1cccef();
    if (memoryAGet16(ds, 0x20d7d3) & 0xffff)
        { pc = 0x1cccbc; break; }
    r16[ax] = memoryAGet16(ds, 0x20d051);
    r16[ax] &= 0x00ff;
    r16[bx] = memoryAGet16(ds, 0x20d05b);
    r16[bx] &= 0x00ff;
    r16[bx] -= r16[ax];
    if (r16[bx] < memoryAGet16(ds, 0x20d7e9))
        { pc = 0x1cccbc; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7eb))
        { pc = 0x1cccbc; break; }
    if (r16[bx] < memoryAGet16(ds, 0x20d7ed))
        { pc = 0x1ccca0; break; }
    if (r16[bx] < 0x00b0)
        { pc = 0x1cccbc; break; }
    if (r16[bx] >= memoryAGet16(ds, 0x20d7ef))
        { pc = 0x1ccca0; break; }
    if (r16[bx] >= 0xff50)
        { pc = 0x1cccbc; break; }
  case 0x1ccca0: // 0160:1ccca0
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x003b))
        { pc = 0x1cccdc; break; }
    memoryASet16(ds, 0x20cf8b, 0x003b);
    { pc = 0x1cccdd; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1cccbc: // 0160:1cccbc
    r16[ax] = memoryAGet16(ds, 0x20d05b);
    memoryASet16(ds, 0x20d051, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0f7);
    memoryASet32(ds, 0x20d0cf, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0fb);
    memoryASet32(ds, 0x20d0d3, r32[eax]);
  case 0x1cccdc: // 0160:1cccdc
    r32[esp] += 4; return;
  case 0x1cccdd: // 0160:1cccdd
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x00f5;
    { pc = 0x1b1715; break; }
    return;
  }
}
function* sub_1cccef() // 0160:1cccef +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] += 0x0010;
    r16[dx] += 0x0010;
    r16[bx] &= 0xfff8;
    r16[dx] &= 0xfff8;
    memoryASet16(ds, 0x20ceb3, r16[bx]);
    memoryASet16(ds, 0x20ceb5, r16[dx]);
    r32[ecx] = memoryAGet32(ds, 0x20d76f);
    r16[ax] = memoryAGet16(ds, r32[ecx]);
    memoryASet16(ds, 0x20e809, r16[ax]);
    memoryASet16(ds, 0x20e801, 0x0000);
    r32[esi] = 0;
    r16[si] = memoryAGet16(ds, 0x20e809);
    r32[esi] >>>= 1;
    r16[si] &= 0xfff8;
    r16[dx] &= 0xffe0;
  case 0x1ccd3c: // 0160:1ccd3c
    if (r16[dx] != memoryAGet16(ds, r32[ecx] + r32[esi] + 0xa))
        { pc = 0x1ccd93; break; }
    if (r16s[bx] <= signed16(memoryAGet16(ds, r32[ecx] + r32[esi] + 0x6)))
        { pc = 0x1ccdc5; break; }
    if (r16s[bx] >= signed16(memoryAGet16(ds, r32[ecx] + r32[esi] + 0x8)))
        { pc = 0x1ccd99; break; }
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x6);
    memoryASet16(ds, 0x20d0f7, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0xa);
    memoryASet16(ds, 0x20d0f9, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x8);
    memoryASet16(ds, 0x20d0fb, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0xa);
    memoryASet16(ds, 0x20d0fd, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x4);
    { pc = 0x1cd0d6; break; }
  case 0x1ccd93: // 0160:1ccd93
    if (r16s[dx] <= signed16(memoryAGet16(ds, r32[ecx] + r32[esi] + 0xa)))
        { pc = 0x1ccdc5; break; }
  case 0x1ccd99: // 0160:1ccd99
    memoryASet16(ds, 0x20e801, r16[si]);
    r16[si] += memoryAGet16(ds, 0x20e809);
    r16[si] >>>= 1;
    r16[si] += 0x0004;
    r16[si] &= 0xfff8;
    if (r16[si] == memoryAGet16(ds, 0x20e809))
        { pc = 0x1ccde8; break; }
    { pc = 0x1ccd3c; break; }
  case 0x1ccdc5: // 0160:1ccdc5
    memoryASet16(ds, 0x20e809, r16[si]);
    r16[si] += memoryAGet16(ds, 0x20e801);
    r16[si] >>>= 1;
    r16[si] &= 0xfff8;
    if (r16[si] != memoryAGet16(ds, 0x20e809))
        { pc = 0x1ccd3c; break; }
  case 0x1ccde8: // 0160:1ccde8
    r16[ax] = memoryAGet16(ds, r32[ecx] + 0x2);
    memoryASet16(ds, 0x20e809, r16[ax]);
    memoryASet32(ds, 0x20e801, 0x00000000);
    r16[ax] = memoryAGet16(ds, r32[ecx]);
    memoryASet16(ds, 0x20e801, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - r16[ax]);
    r32[ecx] += memoryAGet32(ds, 0x20e801);
    memoryASet16(ds, 0x20e801, 0x0000);
    r32[esi] = 0;
    r16[si] = memoryAGet16(ds, 0x20e809);
    r32[esi] >>>= 1;
    r16[si] &= 0xfff8;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] &= 0xffe0;
  case 0x1cce3d: // 0160:1cce3d
    if (r16[bx] != memoryAGet16(ds, r32[ecx] + r32[esi] + 0x6))
        { pc = 0x1cce88; break; }
    if (r16s[dx] >= signed16(memoryAGet16(ds, r32[ecx] + r32[esi] + 0x8)))
        { pc = 0x1cce8a; break; }
    if (r16s[dx] <= signed16(memoryAGet16(ds, r32[ecx] + r32[esi] + 0xa)))
        { pc = 0x1cceaf; break; }
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x6);
    memoryASet16(ds, 0x20d0f7, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x8);
    memoryASet16(ds, 0x20d0f9, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x6);
    memoryASet16(ds, 0x20d0fb, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0xa);
    memoryASet16(ds, 0x20d0fd, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[ecx] + r32[esi] + 0x4);
    { pc = 0x1cd0d6; break; }
  case 0x1cce88: // 0160:1cce88
    if (r16s[bx] <= signed16(memoryAGet16(ds, r32[ecx] + r32[esi] + 0x6)))
        { pc = 0x1cceaf; break; }
  case 0x1cce8a: // 0160:1cce8a
    memoryASet16(ds, 0x20e801, r16[si]);
    r16[si] += memoryAGet16(ds, 0x20e809);
    r16[si] >>>= 1;
    r16[si] += 0x0004;
    r16[si] &= 0xfff8;
    if (r16[si] == memoryAGet16(ds, 0x20e809))
        { pc = 0x1cced2; break; }
    if (r16[si] != memoryAGet16(ds, 0x20e809))
        { pc = 0x1cce3d; break; }
  case 0x1cceaf: // 0160:1cceaf
    memoryASet16(ds, 0x20e809, r16[si]);
    r16[si] += memoryAGet16(ds, 0x20e801);
    r16[si] >>>= 1;
    r16[si] &= 0xfff8;
    if (r16[si] != memoryAGet16(ds, 0x20e809))
        { pc = 0x1cce3d; break; }
  case 0x1cced2: // 0160:1cced2
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r16[cx] = memoryAGet16(ds, 0x20ceb5);
    r32[esi] = memoryAGet32(ds, 0x20d76f);
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, 0x20e805, r16[ax]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) >> 3);
    r16[ax] = memoryAGet16(ds, 0x20d7e7);
    r16[ax] -= memoryAGet16(ds, 0x20e805);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x20e809, r16[ax]);
    memoryASet16(ds, 0x20e805, r16[ax]);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) << 2);
    r16[ax] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + r16[ax]);
    r32[ebp] = 0;
    r16[bp] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[esi] += r32[ebp];
    r16[bp] >>>= 3;
    r16[ax] = memoryAGet16(ds, 0x20d7e7);
    memoryASet16(ds, 0x20e805, r16[ax]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20e805);
    push32(r32[eax]);
    memoryASet32(ds, 0x20e801, 0x00000000);
    { pc = 0x1ccf63; break; }
  case 0x1ccf5b: // 0160:1ccf5b
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) + 0x000a);
  case 0x1ccf63: // 0160:1ccf63
    r32[edi] = memoryAGet32(ds, 0x20e801);
    if (r16[bx] < memoryAGet16(ds, r32[esi] + r32[edi] + 0x6))
        { pc = 0x1ccf7a; break; }
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e805)) >= 0)
        { pc = 0x1ccf5b; break; }
  case 0x1ccf7a: // 0160:1ccf7a
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e805, r16[ax]);
  case 0x1ccf81: // 0160:1ccf81
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x000a);
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, 0x20e809);
    if (r16[bx] > memoryAGet16(ds, r32[esi] + r32[edi] + 0xa))
        { pc = 0x1ccfac; break; }
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20e805)) >= 0)
        { pc = 0x1ccf81; break; }
    memoryASet16(ds, 0x20e809, 0x0000);
  case 0x1ccfac: // 0160:1ccfac
    r16[di] = memoryAGet16(ds, 0x20e801);
    if (signed16(memoryAGet16(ds, 0x20e809)) >= r16s[di])
        { pc = 0x1cd0ff; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, 0x20e809);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x8);
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[edi] + 0xc);
    if (r16s[ax] <= r16s[bp])
        { pc = 0x1cd052; break; }
    if (r16[cx] >= r16[ax])
        { pc = 0x1cd0c9; break; }
    if (r16[cx] <= r16[bp])
        { pc = 0x1cd0c9; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, 0x20e809);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x6);
    r16[ax] -= r16[bx];
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x8);
    r16[bp] -= r16[cx];
    r16[bp] = -r16[bp];
    r16[bp] -= r16[ax];
    if (r16[bp] >= 0x000a)
        { pc = 0x1cd0c9; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, 0x20e809);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x6);
    memoryASet16(ds, 0x20d0f7, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x8);
    memoryASet16(ds, 0x20d0f9, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0xa);
    memoryASet16(ds, 0x20d0fb, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0xc);
    memoryASet16(ds, 0x20d0fd, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x4);
    { pc = 0x1cd0d6; break; }
  case 0x1cd052: // 0160:1cd052
    if (r16[cx] <= r16[ax])
        { pc = 0x1cd0c9; break; }
    if (r16[cx] >= r16[bp])
        { pc = 0x1cd0c9; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, 0x20e809);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x6);
    r16[ax] -= r16[bx];
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x8);
    r16[bp] -= r16[cx];
    r16[ax] -= r16[bp];
    if (r16[ax] >= 0x000a)
        { pc = 0x1cd0c9; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, 0x20e809);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x6);
    memoryASet16(ds, 0x20d0f7, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x8);
    memoryASet16(ds, 0x20d0f9, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0xa);
    memoryASet16(ds, 0x20d0fb, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0xc);
    memoryASet16(ds, 0x20d0fd, r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[edi] + 0x4);
    { pc = 0x1cd0d6; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1cd0c9: // 0160:1cd0c9
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x000a);
    { pc = 0x1ccfac; break; }
  case 0x1cd0d6: // 0160:1cd0d6
    memoryASet16(ds, 0x20d05b, r16[ax]);
    if (memoryAGet16(ds, 0x20d7e7) == 0x00b0)
        { pc = 0x1cd0ff; break; }
    r16[bx] = r16[ax];
    r16[bx] &= 0xff00;
    r16[ax] &= 0x00ff;
    r16[ax] <<= 1;
    r16[ax] |= r16[bx];
    memoryASet16(ds, 0x20d05b, r16[ax]);
  case 0x1cd0ff: // 0160:1cd0ff
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd100() // 0160:1cd100 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1cd1f4; break; }
    r16[ax] = memoryAGet16(ds, 0x20d83b);
    memoryASet16(ds, 0x20d831, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d843);
    memoryASet16(ds, 0x20d833, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d84b);
    memoryASet16(ds, 0x20d835, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d853);
    memoryASet16(ds, 0x20d837, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d15b);
    memoryASet16(ds, 0x20d16b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1cd554();
    r8[al] = memoryAGet(ds, 0x20d159);
    memoryASet(ds, 0x20d149, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c848);
    memoryASet(ds, 0x20c840, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20d16b);
    memoryASet16(ds, 0x20d15b, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d149);
    if (!r8[al])
        { pc = 0x1cd1ba; break; }
    if (r8s[al] <= signed8(0x40))
        { pc = 0x1cd1cd; break; }
  case 0x1cd1ba: // 0160:1cd1ba
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0021))
        { pc = 0x1cd1cd; break; }
    memoryASet16(ds, 0x20cf85, 0x003b);
  case 0x1cd1cd: // 0160:1cd1cd
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cd1f4; break; }
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1cd1f4; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0001)
        { pc = 0x1cd1f4; break; }
    memoryASet(ds, 0x20c840, 0x00);
  case 0x1cd1f4: // 0160:1cd1f4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd1f5() // 0160:1cd1f5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1cd335; break; }
    if (!(memoryAGet16(ds, 0x20e7df) & 0xffff))
        { pc = 0x1cd229; break; }
    memoryASet16(ds, 0x20e7df, memoryAGet16(ds, 0x20e7df) - 0x0001);
    if (memoryAGet16(ds, 0x20e7df) == 0x0006)
        { pc = 0x1cd229; break; }
    memoryASet(ds, 0x20c841, 0x00);
    r32[esp] += 4; return;
  case 0x1cd229: // 0160:1cd229
    r16[ax] = memoryAGet16(ds, 0x20d83b);
    memoryASet16(ds, 0x20d831, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d843);
    memoryASet16(ds, 0x20d833, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d84b);
    memoryASet16(ds, 0x20d835, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d853);
    memoryASet16(ds, 0x20d837, r16[ax]);
    if (memoryAGet16(ds, 0x20d89f) & 0xffff)
        { pc = 0x1cd277; break; }
    if (memoryAGet16(ds, 0x20d083) & 0xffff)
        { pc = 0x1cd277; break; }
    memoryASet(ds, 0x20c841, 0x00);
    r32[esp] += 4; return;
  case 0x1cd277: // 0160:1cd277
    r16[ax] = memoryAGet16(ds, 0x20d05f);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d15d);
    memoryASet16(ds, 0x20d16b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf75);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1cd554();
    r8[al] = memoryAGet(ds, 0x20d159);
    memoryASet(ds, 0x20d14b, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c848);
    memoryASet(ds, 0x20c841, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20d16b);
    memoryASet16(ds, 0x20d15d, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d14b);
    if (!r8[al])
        { pc = 0x1cd2f2; break; }
    if (r8s[al] <= signed8(0x40))
        { pc = 0x1cd30e; break; }
  case 0x1cd2f2: // 0160:1cd2f2
    if (memoryAGet(ds, 0x20d125) != 0xff)
        { pc = 0x1cd30e; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0021))
        { pc = 0x1cd30e; break; }
    memoryASet16(ds, 0x20cf87, 0x003b);
  case 0x1cd30e: // 0160:1cd30e
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cd335; break; }
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1cd335; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0001)
        { pc = 0x1cd335; break; }
    memoryASet(ds, 0x20c841, 0x00);
  case 0x1cd335: // 0160:1cd335
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd336() // 0160:1cd336 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1cd444; break; }
    if (!(memoryAGet16(ds, 0x20e7e1) & 0xffff))
        { pc = 0x1cd36a; break; }
    memoryASet16(ds, 0x20e7e1, memoryAGet16(ds, 0x20e7e1) - 0x0001);
    if (memoryAGet16(ds, 0x20e7e1) == 0x0006)
        { pc = 0x1cd36a; break; }
    memoryASet(ds, 0x20c842, 0x00);
    r32[esp] += 4; return;
  case 0x1cd36a: // 0160:1cd36a
    r16[ax] = memoryAGet16(ds, 0x20d83d);
    memoryASet16(ds, 0x20d831, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d845);
    memoryASet16(ds, 0x20d833, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d84d);
    memoryASet16(ds, 0x20d835, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d855);
    memoryASet16(ds, 0x20d837, r16[ax]);
    if (memoryAGet16(ds, 0x20d085) & 0xffff)
        { pc = 0x1cd3ad; break; }
    memoryASet(ds, 0x20c842, 0x00);
    r32[esp] += 4; return;
  case 0x1cd3ad: // 0160:1cd3ad
    r16[ax] = memoryAGet16(ds, 0x20d061);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d15f);
    memoryASet16(ds, 0x20d16b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf77);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1cd554();
    r8[al] = memoryAGet(ds, 0x20d159);
    memoryASet(ds, 0x20d14d, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c848);
    memoryASet(ds, 0x20c842, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20d16b);
    memoryASet16(ds, 0x20d15f, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d14d);
    if (!r8[al])
        { pc = 0x1cd428; break; }
    if (r8s[al] <= signed8(0x40))
        { pc = 0x1cd444; break; }
  case 0x1cd428: // 0160:1cd428
    if (memoryAGet(ds, 0x20d127) != 0xff)
        { pc = 0x1cd444; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0021))
        { pc = 0x1cd444; break; }
    memoryASet16(ds, 0x20cf89, 0x003b);
  case 0x1cd444: // 0160:1cd444
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd445() // 0160:1cd445 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1cd553; break; }
    if (!(memoryAGet16(ds, 0x20e7e3) & 0xffff))
        { pc = 0x1cd479; break; }
    memoryASet16(ds, 0x20e7e3, memoryAGet16(ds, 0x20e7e3) - 0x0001);
    if (memoryAGet16(ds, 0x20e7e3) == 0x0006)
        { pc = 0x1cd479; break; }
    memoryASet(ds, 0x20c843, 0x00);
    r32[esp] += 4; return;
  case 0x1cd479: // 0160:1cd479
    r16[ax] = memoryAGet16(ds, 0x20d83f);
    memoryASet16(ds, 0x20d831, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d847);
    memoryASet16(ds, 0x20d833, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d84f);
    memoryASet16(ds, 0x20d835, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d857);
    memoryASet16(ds, 0x20d837, r16[ax]);
    if (memoryAGet16(ds, 0x20d087) & 0xffff)
        { pc = 0x1cd4bc; break; }
    memoryASet(ds, 0x20c843, 0x00);
    r32[esp] += 4; return;
  case 0x1cd4bc: // 0160:1cd4bc
    r16[ax] = memoryAGet16(ds, 0x20d063);
    memoryASet16(ds, 0x20d06d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d161);
    memoryASet16(ds, 0x20d16b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf79);
    memoryASet16(ds, 0x20cf83, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1cd554();
    r8[al] = memoryAGet(ds, 0x20d159);
    memoryASet(ds, 0x20d14f, r8[al]);
    r8[al] = memoryAGet(ds, 0x20c848);
    memoryASet(ds, 0x20c843, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x20d16b);
    memoryASet16(ds, 0x20d161, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20d14f);
    if (!r8[al])
        { pc = 0x1cd537; break; }
    if (r8s[al] <= signed8(0x40))
        { pc = 0x1cd553; break; }
  case 0x1cd537: // 0160:1cd537
    if (memoryAGet(ds, 0x20d129) != 0xff)
        { pc = 0x1cd553; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0021))
        { pc = 0x1cd553; break; }
    memoryASet16(ds, 0x20cf8b, 0x003b);
  case 0x1cd553: // 0160:1cd553
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd554() // 0160:1cd554 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20ee35) & 0xffff))
        { pc = 0x1cd567; break; }
    memoryASet(ds, 0x20c848, 0x40);
    r32[esp] += 4; return;
  case 0x1cd567: // 0160:1cd567
    r16[ax] += 0x0010;
    r16[bx] += 0x0010;
    yield* sub_1cd72b();
    memoryASet(ds, 0x20d159, r8[al]);
    memoryASet(ds, 0x20c848, 0x11);
    if (r8s[al] <= signed8(0x20))
        { pc = 0x1cd5c2; break; }
    r8[al] -= 0x20;
    memoryASet(ds, 0x20d159, r8[al]);
    if (memoryAGet16(ds, 0x20d7b9) == 0x002d)
        { pc = 0x1cd59f; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x002e)
        { pc = 0x1cd5af; break; }
  case 0x1cd59f: // 0160:1cd59f
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) | 0x02);
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) & 0xfe);
    { pc = 0x1cd5c2; break; }
  case 0x1cd5af: // 0160:1cd5af
    r16[ax] = memoryAGet16(ds, 0x20cfb9);
    if (r16s[ax] <= signed16(0x00a0))
        { pc = 0x1cd5c2; break; }
    memoryASet(ds, 0x20c848, 0x00);
  case 0x1cd5c2: // 0160:1cd5c2
    if (!(memoryAGet16(ds, 0x20d06d) & 0xffff))
        { pc = 0x1cd5eb; break; }
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x20d159);
    r8[al]--;
    r16[ax] <<= 5;
    r16[bx] = memoryAGet16(ds, 0x20cf83);
    r16[bx] &= 0x001f;
    r16[bx] <<= 5;
    { pc = 0x1cd5ff; break; }
  case 0x1cd5eb: // 0160:1cd5eb
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x20d159);
    r8[al]--;
    r16[ax] <<= 5;
    r16[bx] = memoryAGet16(ds, 0x20cfa7);
  case 0x1cd5ff: // 0160:1cd5ff
    r16[ax] -= r16[bx];
    if (r16s[ax] >= 0)
        { pc = 0x1cd610; break; }
    if (r16s[ax] >= signed16(0xfe00))
        { pc = 0x1cd61a; break; }
    r16[ax] += 0x0400;
    if (!r16[ax])
        { pc = 0x1cd61a; break; }
  case 0x1cd610: // 0160:1cd610
    if (r16s[ax] <= signed16(0x0200))
        { pc = 0x1cd61a; break; }
    r16[ax] -= 0x0400;
  case 0x1cd61a: // 0160:1cd61a
    memoryASet16(ds, 0x20d82f, r16[ax]);
    if (r16[ax] & 32768)
        { pc = 0x1cd62f; break; }
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) | 0x08);
    flags.sign = signed8(memoryAGet(ds, 0x20c848)) < 0;
    { pc = 0x1cd636; break; }
  case 0x1cd62f: // 0160:1cd62f
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) | 0x04);
    flags.sign = signed8(memoryAGet(ds, 0x20c848)) < 0;
  case 0x1cd636: // 0160:1cd636
    r16[ax] = memoryAGet16(ds, 0x20d82f);
    if (!flags.sign)
        { pc = 0x1cd641; break; }
    flags.sign = r16s[ax] > 0;
    r16[ax] = -r16[ax];
  case 0x1cd641: // 0160:1cd641
    r16[bx] = memoryAGet16(ds, 0x20d16b);
    if (!flags.sign)
        { pc = 0x1cd64d; break; }
    r16[bx] = -r16[bx];
  case 0x1cd64d: // 0160:1cd64d
    r16[bp] = memoryAGet16(ds, 0x20d831);
    memoryASet16(ds, 0x20e801, r16[bp]);
    if (r16s[bp] >= signed16(memoryAGet16(ds, 0x20cfb9)))
        { pc = 0x1cd69f; break; }
    r16[cx] = memoryAGet16(ds, 0x20d833);
    r16[cx] -= memoryAGet16(ds, 0x20cfb9);
    r16[cx] >>>= 1;
    if (r16s[ax] <= r16s[cx])
        { pc = 0x1cd68a; break; }
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) & 0xef);
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) | 0x40);
    { pc = 0x1cd69f; break; }
  case 0x1cd68a: // 0160:1cd68a
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1cd69f; break; }
    r16[bx] -= r16[ax];
    if (r16s[bx] <= signed16(0x000a))
        { pc = 0x1cd69f; break; }
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) & 0xef);
  case 0x1cd69f: // 0160:1cd69f
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, 0x20d159);
    r8[bl]--;
    if (r16[bx] != memoryAGet16(ds, 0x20cf83))
        { pc = 0x1cd6c3; break; }
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20d837)))
        { pc = 0x1cd6f3; break; }
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) & 0xf3);
  case 0x1cd6c3: // 0160:1cd6c3
    r8[bl] = memoryAGet(ds, 0x20d159);
    r8[bl]--;
    if (!r8[bl])
        { pc = 0x1cd6f3; break; }
    if (r8[bl] == 0x08)
        { pc = 0x1cd6f3; break; }
    if (r8[bl] == 0x10)
        { pc = 0x1cd6f3; break; }
    if (r8[bl] == 0x18)
        { pc = 0x1cd6f3; break; }
    r16[ax] = memoryAGet16(ds, 0x20d835);
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0x20cfb9)))
        { pc = 0x1cd6f3; break; }
    memoryASet(ds, 0x20c848, memoryAGet(ds, 0x20c848) & 0xef);
  case 0x1cd6f3: // 0160:1cd6f3
    r16[ax] = memoryAGet16(ds, 0x20d82f);
    memoryASet16(ds, 0x20d16b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf83);
    r16[ax] <<= 5;
    r16[bx] = r16[ax];
    r16[ax] -= memoryAGet16(ds, 0x20cfa7);
    r16[ax] &= 0x03ff;
    if (r16s[ax] <= signed16(0x0160))
        { pc = 0x1cd72a; break; }
    if (r16s[ax] >= signed16(0x02a0))
        { pc = 0x1cd72a; break; }
    memoryASet(ds, 0x20c848, 0x10);
  case 0x1cd72a: // 0160:1cd72a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd72b() // 0160:1cd72b +long
{
    r32[esp] -= 4;
    push32(r32[esi]);
    r32[esi] = memoryAGet32(ds, 0x2eeb9c);
    r32[esi] += 0x00000004;
    r32[esi] += memoryAGet32(ds, 0x20cefb);
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r32[edx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20cef7);
    mul16(r16[cx]);
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r32[esi] = pop32();
    r32[esp] += 4;
}
function* sub_1cd75c() // 0160:1cd75c +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cd75c; break; }
  case 0x1b2710: // 0160:1b2710
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2716: // 0160:1b2716
    r32[ebx] = 0x00000000;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2724: // 0160:1b2724
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[ax] += r16[bx];
    if (r16[ax] == 0x0006)
        { pc = 0x1b2748; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2748: // 0160:1b2748
    r16[bx] = 0x0080;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2755: // 0160:1b2755
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    if (r16[bx] == r16[ax])
        { pc = 0x1b2775; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2775: // 0160:1b2775
    r16[bx] = 0x0180;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2782: // 0160:1b2782
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[bx] += r16[bx];
    r16[ax] -= r16[bx];
    if (!r16[ax])
        { pc = 0x1b27ab; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b27ab; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b27ab: // 0160:1b27ab
    r16[bx] = 0x0155;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b27b8: // 0160:1b27b8
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[bx] += r16[bx];
    r16[bx] -= r16[ax];
    if (r16[bx] == 0x0006)
        { pc = 0x1b27e5; break; }
    if (r16[bx] == 0x0008)
        { pc = 0x1b27e5; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b27e5: // 0160:1b27e5
    r16[bx] = 0x0155;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b27f2: // 0160:1b27f2
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[bx] += r16[bx];
    r16[ax] += r16[bx];
    flags.zero = r16[ax] == 0x000c;
    if (r16s[ax] < signed16(0x000c))
        { pc = 0x1b281f; break; }
    flags.zero = r16[ax] == 0x000e;
    if (flags.zero)
        { pc = 0x1b281f; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b281f: // 0160:1b281f
    r16[bx] = 0x00ab;
    r32[eax] = 0x00000001;
    r32[esp] += 4; return;
  case 0x1b2829: // 0160:1b2829
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[bx] += r16[bx];
    r16[ax] += r16[bx];
    if (r16[ax] == 0x0004)
        { pc = 0x1b2856; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1b2856; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2856: // 0160:1b2856
    r16[bx] = 0x00ab;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2863: // 0160:1b2863
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[ax] += r16[ax];
    r16[bx] -= r16[ax];
    if (!r16[bx])
        { pc = 0x1b288c; break; }
    if (r16[bx] == 0x0002)
        { pc = 0x1b288c; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b288c: // 0160:1b288c
    r16[bx] = 0x01ab;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2899: // 0160:1b2899
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[ax] += r16[ax];
    r16[ax] -= r16[bx];
    if (r16[ax] == 0x0008)
        { pc = 0x1b28c6; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1b28c6; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b28c6: // 0160:1b28c6
    r16[bx] = 0x01ab;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b28d3: // 0160:1b28d3
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[ax] += r16[ax];
    r16[ax] += r16[bx];
    if (r16[ax] == 0x0004)
        { pc = 0x1b2900; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1b2900; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2900: // 0160:1b2900
    r16[bx] = 0x0055;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b290d: // 0160:1b290d
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    r16[bx] = memoryAGet16(ds, 0x20d7e5);
    r16[bx] &= 0x0006;
    r16[ax] += r16[ax];
    r16[ax] -= r16[bx];
    if (r16[ax] == 0x0008)
        { pc = 0x1b293a; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1b293a; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b293a: // 0160:1b293a
    r16[bx] = 0x0055;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2947: // 0160:1b2947
    r16[bx] = 0x0100;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2954: // 0160:1b2954
    r16[bx] = 0x0100;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2961: // 0160:1b2961
    r16[ax] = memoryAGet16(ds, 0x20d7e5);
    r16[ax] &= 0x0006;
    if (r16[ax] == 0x0002)
        { pc = 0x1b2977; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2977: // 0160:1b2977
    r16[bx] = 0x0100;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b2984: // 0160:1b2984
    r16[ax] = memoryAGet16(ds, 0x20d7e3);
    r16[ax] &= 0x0006;
    if (r16[ax] == 0x0002)
        { pc = 0x1b299a; break; }
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b299a: // 0160:1b299a
    r32[ebx] = 0x00000000;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
  case 0x1b29a8: // 0160:1b29a8
    r32[ebx] = 0x00000000;
    r32[eax] = 0x00000001;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
    // gap 109990 bytes // gap 109990 bytes
  case 0x1cd75c: // 0160:1cd75c
    memoryASet16(ds, 0x20d7e3, r16[cx]);
    memoryASet16(ds, 0x20d7e5, r16[dx]);
    r16[ax] &= 0x00ff;
    r16[ax] <<= 4;
    r16[cx] &= 0x0018;
    r16[cx] >>>= 1;
    r16[dx] &= 0x0018;
    r16[dx] >>>= 3;
    r16[cx] += r16[dx];
    r16[ax] += r16[cx];
    push32(r32[esi]);
    r32[esi] = memoryAGet32(ds, 0x20e821);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r32[esi] = pop32();
    if (r8[al] == 0x20)
        { pc = 0x1cd7b4; break; }
    if (r8s[al] < signed8(0x24))
        { pc = 0x1cd7bf; break; }
    if (r8s[al] >= signed8(0x38))
        { pc = 0x1cd7bf; break; }
    r8[al] -= 0x24;
    r32[eax] &= 0x000000ff;
    r16[ax] <<= 2;
    r32[edi] = memoryAGet32(ds, 0x20d7d7);
    r32[edi] = memoryAGet32(ds, r32[edi] + r32[eax]);
    switch (r32[edi])
    {
        case 0x001b2710: { pc = 0x1b2710; break; }
        case 0x001b2716: { pc = 0x1b2716; break; }
        case 0x001b2724: { pc = 0x1b2724; break; }
        case 0x001b2755: { pc = 0x1b2755; break; }
        case 0x001b2782: { pc = 0x1b2782; break; }
        case 0x001b27b8: { pc = 0x1b27b8; break; }
        case 0x001b27f2: { pc = 0x1b27f2; break; }
        case 0x001b2829: { pc = 0x1b2829; break; }
        case 0x001b2863: { pc = 0x1b2863; break; }
        case 0x001b2899: { pc = 0x1b2899; break; }
        case 0x001b28d3: { pc = 0x1b28d3; break; }
        case 0x001b290d: { pc = 0x1b290d; break; }
        case 0x001b2984: { pc = 0x1b2984; break; }
        case 0x001b29a8: { pc = 0x1b29a8; break; }
        case 0x001b2947: { pc = 0x1b2947; break; }
        case 0x001b2961: { pc = 0x1b2961; break; }
        case 0x001b2954: { pc = 0x1b2954; break; }
        default:
            stop("ind 0160:1cd7b2");
    }
    break;
  case 0x1cd7b4: // 0160:1cd7b4
    r32[edi] = memoryAGet32(ds, 0x20d7d7);
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x50);
    switch (r32[edi])
    {
        case 0x001b2710: { pc = 0x1b2710; break; }
        case 0x001b29a8: { pc = 0x1b29a8; break; }
        case 0x001b2954: { pc = 0x1b2954; break; }
        default:
            console.log("ind 0160:1cd7bd", r32[edi].toString(16));
            pc = 0x1cd7bf;
    }
    break;
  case 0x1cd7bf: // 0160:1cd7bf
    r32[eax] = 0;
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cd7c5() // 0160:1cd7c5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r16[ax] < 0xea60)
        { pc = 0x1cd7d0; break; }
    r16[ax] = 0x003f;
    r32[esp] += 4; return;
  case 0x1cd7d0: // 0160:1cd7d0
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    push32(r32[ecx]);
    push32(r32[edx]);
    r16[ax] >>>= 5;
    r16[bx] >>>= 5;
    r16[ax] <<= 1;
    r16[bx] <<= 1;
    r32[edx] = 0;
    mul16(memoryAGet16(ds, 0x20cef7));
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    push32(r32[esi]);
    r32[esi] = memoryAGet32(ds, 0x20e81d);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    r32[esi] = pop32();
    r16[ax] &= 0x00ff;
    r16[ax] <<= 4;
    r16[cx] &= 0x0018;
    r16[cx] >>>= 1;
    r16[dx] &= 0x0018;
    r16[dx] >>>= 3;
    r16[cx] += r16[dx];
    r16[ax] += r16[cx];
    push32(r32[edi]);
    r32[edi] = memoryAGet32(ds, 0x20e821);
    r8[al] = memoryAGet(ds, r32[edi] + r32[eax]);
    r32[edi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1cd830() // 0160:1cd830 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020dcc5;
    r16[ax] = memoryAGet16(ds, 0x20dcc3);
    if (r16[ax] != 0xffff)
        { pc = 0x1cd856; break; }
    r8[bl] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, r32[esi], r8[bl]);
    r32[esi]++;
    memoryASet(ds, r32[esi], 0x01);
    memoryASet16(ds, 0x20dcc3, memoryAGet16(ds, 0x20dcc3) + 0x0001);
    r32[esp] += 4; return;
  case 0x1cd856: // 0160:1cd856
    if (r16s[ax] >= signed16(0x0200))
        { pc = 0x1cd895; break; }
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[bl] != memoryAGet(ds, 0x20c840))
        { pc = 0x1cd87e; break; }
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    if (r8[bl] == 0xff)
        { pc = 0x1cd87e; break; }
    memoryASet(ds, r32[esi] + r32[eax] + 0x1, memoryAGet(ds, r32[esi] + r32[eax] + 0x1) + 0x01);
    r32[esp] += 4; return;
  case 0x1cd87e: // 0160:1cd87e
    memoryASet16(ds, 0x20dcc3, memoryAGet16(ds, 0x20dcc3) + 0x0001);
    r8[bl] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, r32[esi] + r32[eax] + 0x2, r8[bl]);
    memoryASet(ds, r32[esi] + r32[eax] + 0x3, 0x01);
  case 0x1cd895: // 0160:1cd895
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd896() // 0160:1cd896 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d8b7);
    if (!r16[ax])
        { pc = 0x1cd91d; break; }
    r32[esi] = 0x0020d8c1;
    r16[ax] = memoryAGet16(ds, 0x20d8bd);
    if (r16[ax] != 0xffff)
        { pc = 0x1cd8cf; break; }
    r8[dl] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20d8c0, r8[dl]);
    r32[esi]++;
    r8[dl] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, 0x20d8bf, r8[dl]);
    memoryASet16(ds, 0x20d8bd, memoryAGet16(ds, 0x20d8bd) + 0x0001);
  case 0x1cd8cf: // 0160:1cd8cf
    r8[dl] = memoryAGet(ds, 0x20d8c0);
    memoryASet(ds, 0x20c842, r8[dl]);
    memoryASet(ds, 0x20d8bf, memoryAGet(ds, 0x20d8bf) - 0x01);
    if (memoryAGet(ds, 0x20d8bf))
        { pc = 0x1cd91c; break; }
    memoryASet16(ds, 0x20d8bd, memoryAGet16(ds, 0x20d8bd) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20d8bd);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax]);
    if (r8[bl] != 0xff)
        { pc = 0x1cd90c; break; }
    memoryASet16(ds, 0x20d8bd, memoryAGet16(ds, 0x20d8bd) - 0x0001);
    r8[bl] = 0;
  case 0x1cd90c: // 0160:1cd90c
    memoryASet(ds, 0x20d8c0, r8[bl]);
    r8[bl] = memoryAGet(ds, r32[esi] + r32[eax] + 0x1);
    memoryASet(ds, 0x20d8bf, r8[bl]);
  case 0x1cd91c: // 0160:1cd91c
    r32[esp] += 4; return;
  case 0x1cd91d: // 0160:1cd91d
    memoryASet16(ds, 0x20cf41, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cd927() // 0160:1cd927 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d2b7, 0x0000);
    r32[esi] = 0x0020cf3d;
    r32[edi] = 0x0020cf85;
    r16[cx] = 0;
    r16[dx] = 0;
    memoryASet16(ds, 0x20e809, 0x0008);
  case 0x1cd949: // 0160:1cd949
    r16[bx] = memoryAGet16(ds, r32[edi]);
    r32[edi] += 0x00000002;
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (!r16[ax])
        { pc = 0x1cd96a; break; }
    if (r16s[ax] >= signed16(0x0005))
        { pc = 0x1cd96a; break; }
    r16[cx]++;
    if (r16s[bx] < signed16(0x0020))
        { pc = 0x1cd96a; break; }
    r16[dx]++;
  case 0x1cd96a: // 0160:1cd96a
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1cd949; break; }
    if (r16[dx] != r16[cx])
        { pc = 0x1cd982; break; }
    memoryASet16(ds, 0x20d2b7, 0x0001);
  case 0x1cd982: // 0160:1cd982
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cd983() // 0160:1cd983 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r8[dl] == 0x21)
        { pc = 0x1cd999; break; }
    r16[dx] = memoryAGet16(ds, 0x20c830);
    r16[dx] &= 0x0001;
    if (r16[dx])
        { pc = 0x1cdac6; break; }
  case 0x1cd999: // 0160:1cd999
    memoryASet16(ds, 0x20e7fd, r16[bx]);
    memoryASet16(ds, 0x20e801, r16[cx]);
    if (r16s[ax] <= signed16(0x0010))
        { pc = 0x1cdab3; break; }
    if (r16s[ax] <= signed16(0x00f0))
        { pc = 0x1cda93; break; }
    if (r16s[ax] <= signed16(0x0110))
        { pc = 0x1cda7f; break; }
    if (r16s[ax] <= signed16(0x01f0))
        { pc = 0x1cda5f; break; }
    if (r16s[ax] <= signed16(0x0210))
        { pc = 0x1cda4b; break; }
    if (r16s[ax] <= signed16(0x02f0))
        { pc = 0x1cda27; break; }
    if (r16s[ax] < signed16(0x0310))
        { pc = 0x1cda0f; break; }
    if (r16s[ax] >= signed16(0x03f0))
        { pc = 0x1cdab3; break; }
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - 0x0008);
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) - 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[cx]--;
    r16[bx]--;
    r32[esp] += 4; return;
  case 0x1cda0f: // 0160:1cda0f
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) - 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[bx]--;
    r32[esp] += 4; return;
  case 0x1cda27: // 0160:1cda27
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) + 0x0008);
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) - 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[bx]--;
    r16[cx]++;
    r32[esp] += 4; return;
  case 0x1cda4b: // 0160:1cda4b
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) + 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[cx]++;
    r32[esp] += 4; return;
  case 0x1cda5f: // 0160:1cda5f
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) + 0x0008);
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) + 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[cx]++;
    r16[bx]++;
    r32[esp] += 4; return;
  case 0x1cda7f: // 0160:1cda7f
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) + 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[bx]++;
    r32[esp] += 4; return;
  case 0x1cda93: // 0160:1cda93
    memoryASet16(ds, 0x20e7fd, memoryAGet16(ds, 0x20e7fd) + 0x0008);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[bx]++;
    r16[cx]--;
    r32[esp] += 4; return;
  case 0x1cdab3: // 0160:1cdab3
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) - 0x0008);
    yield* sub_1cdac7();
    if (!flags.zero)
        { pc = 0x1cdac6; break; }
    r16[cx]--;
  case 0x1cdac6: // 0160:1cdac6
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cdac7() // 0160:1cdac7 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    flags.zero = r8[dl] == 0x21;
    if (!flags.zero)
        { pc = 0x1cdb00; break; }
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r16[ax] = memoryAGet16(ds, 0x20e7fd);
    r16[ax] += 0x0010;
    r16[bx] = memoryAGet16(ds, 0x20e801);
    r16[bx] += 0x0010;
    yield* sub_1cd7c5();
    flags.zero = r8[al] == 0x21;
    if (flags.zero)
        { pc = 0x1cdafc; break; }
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    memoryASet16(ds, 0x20e801, 0x0001);
    r32[esp] += 4; return;
  case 0x1cdafc: // 0160:1cdafc
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
  case 0x1cdb00: // 0160:1cdb00
    memoryASet16(ds, 0x20e801, 0x0000);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cdb0a() // 0160:1cdb0a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20e801, r16[ax]);
    r16[ax] &= 0x00ff;
    r16[ax] <<= 2;
    r32[esi] = memoryAGet32(ds, 0x20e819);
    r32[eax] &= 0x0000ffff;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r32[ecx] &= 0x0000ffff;
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r32[edx] &= 0x0000ffff;
    r32[ebp] = r32[edx];
    r32[ebx] &= 0x0000ffff;
    r32[eax] = r32[ecx];
    mul32(r32[ebx]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebp];
    mul32(r32[ebx]);
    r32[edx] = r32[eax];
    if (signed16(memoryAGet16(ds, 0x20e801)) <= signed16(0x00ff))
        { pc = 0x1cdb84; break; }
    if (signed16(memoryAGet16(ds, 0x20e801)) <= signed16(0x01ff))
        { pc = 0x1cdb7d; break; }
    if (signed16(memoryAGet16(ds, 0x20e801)) <= signed16(0x02ff))
        { pc = 0x1cdb74; break; }
    r32[ebx] = r32[ecx];
    r32[eax] = r32[edx];
    r32[eax] = -r32[eax];
    r32[esp] += 4; return;
  case 0x1cdb74: // 0160:1cdb74
    r32[eax] = r32[ecx];
    r32[ebx] = r32[edx];
    r32[eax] = -r32[eax];
    r32[ebx] = -r32[ebx];
    r32[esp] += 4; return;
  case 0x1cdb7d: // 0160:1cdb7d
    r32[ebx] = r32[ecx];
    r32[eax] = r32[edx];
    r32[ebx] = -r32[ebx];
    r32[esp] += 4; return;
  case 0x1cdb84: // 0160:1cdb84
    r32[eax] = r32[ecx];
    r32[ebx] = r32[edx];
    r32[esp] += 4;
    return;
  }
}
function* sub_1cdb89() // 0160:1cdb89 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20cecb);
    if (r32[eax])
        { pc = 0x1cdb9e; break; }
    r32[ebx] = memoryAGet32(ds, 0x20cecf);
    if (r32s[ebx] < 0)
        { pc = 0x1cdbac; break; }
    { pc = 0x1cdbc4; break; }
  case 0x1cdb9e: // 0160:1cdb9e
    if (r32s[eax] >= 0)
        { pc = 0x1cdbb0; break; }
    r32[eax] = -r32[eax];
    r32[ebx] = memoryAGet32(ds, 0x20cecf);
    if (r32s[ebx] >= 0)
        { pc = 0x1cdbbe; break; }
  case 0x1cdbac: // 0160:1cdbac
    r32[ebx] = -r32[ebx];
    { pc = 0x1cdbc4; break; }
  case 0x1cdbb0: // 0160:1cdbb0
    r32[ebx] = memoryAGet32(ds, 0x20cecf);
    if (!r32[ebx])
        { pc = 0x1cdbbe; break; }
    if (r32s[ebx] >= 0)
        { pc = 0x1cdbc4; break; }
    r32[ebx] = -r32[ebx];
  case 0x1cdbbe: // 0160:1cdbbe
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[ebx] = r32[ecx];
  case 0x1cdbc4: // 0160:1cdbc4
    memoryASet32(ds, 0x20ced3, r32[eax]);
    memoryASet32(ds, 0x20ced7, r32[ebx]);
    if (r32[ebx])
        { pc = 0x1cdbf5; break; }
    if (r32[eax])
        { pc = 0x1cdbf5; break; }
    memoryASet16(ds, 0x20cfb9, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20cf95);
    r16[ax] <<= 5;
    memoryASet16(ds, 0x20cfa7, r16[ax]);
    { pc = 0x1cde49; break; }
  case 0x1cdbf5: // 0160:1cdbf5
    if (r32s[ebx] <= r32s[eax])
        { pc = 0x1cdc96; break; }
  case 0x1cdbfd: // 0160:1cdbfd
    if (r32[eax] < 0x0000ffff)
        { pc = 0x1cdc0a; break; }
    r32[eax] >>>= 1;
    r32[ebx] >>>= 1;
    { pc = 0x1cdbfd; break; }
  case 0x1cdc0a: // 0160:1cdc0a
    r32[ecx] = 0;
    if (!r32[eax])
        { pc = 0x1cdd15; break; }
    r32[ecx] = 0;
    memoryASet32(ds, 0x20e801, r32[ebx]);
  case 0x1cdc1c: // 0160:1cdc1c
    if (r32[ebx] & 0x80000000)
        { pc = 0x1cdc36; break; }
    memoryASet32(ds, 0x20e801, r32[ebx]);
    r32[ebx] <<= 1;
    r16[cx]++;
    if (r16[cx] != 0x000a)
        { pc = 0x1cdc1c; break; }
  case 0x1cdc36: // 0160:1cdc36
    r32[ebx] = memoryAGet32(ds, 0x20e801);
    if (r16[cx] == 0x000a)
        { pc = 0x1cdc4e; break; }
  case 0x1cdc42: // 0160:1cdc42
    r32[eax] >>>= 1;
    r16[cx]++;
    if (r16[cx] != 0x000a)
        { pc = 0x1cdc42; break; }
  case 0x1cdc4e: // 0160:1cdc4e
    if (r16[ax])
        { pc = 0x1cdc5a; break; }
    r32[ebx] = 0xffffffff;
    { pc = 0x1cdc7b; break; }
  case 0x1cdc5a: // 0160:1cdc5a
    r32[edx] = r32[ebx];
    r32[ebx] = r32[eax];
    r32[eax] = r32[edx];
    r32[ebx] &= 0x0000ffff;
    r32[edx] = 0;
    div32(r32[ebx]);
    r32[ebx] = r32[eax];
    if (r32s[eax] <= signed32(0x0000ffff))
        { pc = 0x1cdc7b; break; }
    r16[bx] = 0xffff;
  case 0x1cdc7b: // 0160:1cdc7b
    r32[eax] = r32[ebx];
    yield* sub_1cde4a();
    r16[ax] = 0x0100;
    r16[ax] -= r16[cx];
    r16[cx] = r16[ax];
    r16[cx] &= 0x00ff;
    { pc = 0x1cdd15; break; }
  case 0x1cdc96: // 0160:1cdc96
    if (r32[ebx] < 0x0000ffff)
        { pc = 0x1cdca4; break; }
    r32[eax] >>>= 1;
    r32[ebx] >>>= 1;
    { pc = 0x1cdc96; break; }
  case 0x1cdca4: // 0160:1cdca4
    r16[cx] = 0x00ff;
    if (!r32[ebx])
        { pc = 0x1cdd15; break; }
    r32[ecx] = 0;
    memoryASet32(ds, 0x20e801, r32[eax]);
  case 0x1cdcb3: // 0160:1cdcb3
    if (r32[eax] & 0x80000000)
        { pc = 0x1cdccb; break; }
    memoryASet32(ds, 0x20e801, r32[eax]);
    r32[eax] <<= 1;
    r16[cx]++;
    if (r16[cx] != 0x000a)
        { pc = 0x1cdcb3; break; }
  case 0x1cdccb: // 0160:1cdccb
    r32[eax] = memoryAGet32(ds, 0x20e801);
    if (r16[cx] == 0x000a)
        { pc = 0x1cdce2; break; }
  case 0x1cdcd6: // 0160:1cdcd6
    r32[ebx] >>>= 1;
    r16[cx]++;
    if (r16[cx] != 0x000a)
        { pc = 0x1cdcd6; break; }
  case 0x1cdce2: // 0160:1cdce2
    if (r16[bx])
        { pc = 0x1cdcee; break; }
    r32[eax] = 0xffffffff;
    { pc = 0x1cdd07; break; }
  case 0x1cdcee: // 0160:1cdcee
    r32[ebx] &= 0x0000ffff;
    r32[edx] = 0;
    div32(r32[ebx]);
    if (r32s[eax] <= signed32(0x0000ffff))
        { pc = 0x1cdd07; break; }
    r16[ax] = 0xffff;
  case 0x1cdd07: // 0160:1cdd07
    yield* sub_1cde4a();
    r16[cx]--;
    r16[cx] &= 0x00ff;
  case 0x1cdd15: // 0160:1cdd15
    r32[eax] = memoryAGet32(ds, 0x20cecb);
    if (r32[eax])
        { pc = 0x1cdd2a; break; }
    r32[ebx] = memoryAGet32(ds, 0x20cecf);
    if (r32s[ebx] < 0)
        { pc = 0x1cdd50; break; }
    { pc = 0x1cdd55; break; }
  case 0x1cdd2a: // 0160:1cdd2a
    if (r32s[eax] < 0)
        { pc = 0x1cdd3f; break; }
    r32[ebx] = memoryAGet32(ds, 0x20cecf);
    if (!r32[ebx])
        { pc = 0x1cdd38; break; }
    if (r32s[ebx] >= 0)
        { pc = 0x1cdd55; break; }
  case 0x1cdd38: // 0160:1cdd38
    r16[cx] += 0x0100;
    { pc = 0x1cdd55; break; }
  case 0x1cdd3f: // 0160:1cdd3f
    r32[ebx] = memoryAGet32(ds, 0x20cecf);
    if (r32s[ebx] < 0)
        { pc = 0x1cdd50; break; }
    r16[cx] += 0x0300;
    { pc = 0x1cdd55; break; }
  case 0x1cdd50: // 0160:1cdd50
    r16[cx] += 0x0200;
  case 0x1cdd55: // 0160:1cdd55
    if (memoryAGet16(ds, 0x20d06d) & 0xffff)
        { pc = 0x1cddbf; break; }
    r16[ax] = r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x20cfa7);
    if (!r16[ax])
        { pc = 0x1cdd7c; break; }
    r16[ax] &= 0x03ff;
    if (r16[ax] == 0x03ff)
        { pc = 0x1cdd7c; break; }
    if (r16[ax] != 0x0001)
        { pc = 0x1cddbf; break; }
  case 0x1cdd7c: // 0160:1cdd7c
    if (r16[cx] == memoryAGet16(ds, 0x20d049))
        { pc = 0x1cddbf; break; }
    memoryASet16(ds, 0x20cfa7, r16[cx]);
    r16[cx] -= memoryAGet16(ds, 0x20d049);
    if (r16s[cx] < 0)
        { pc = 0x1cdda6; break; }
    if (r16s[cx] <= signed16(0x0200))
        { pc = 0x1cddb0; break; }
  case 0x1cdd9c: // 0160:1cdd9c
    memoryASet16(ds, 0x20cfa7, memoryAGet16(ds, 0x20cfa7) + 0x0002);
    { pc = 0x1cddb8; break; }
  case 0x1cdda6: // 0160:1cdda6
    r16[cx] = -r16[cx];
    if (r16s[cx] <= signed16(0x0200))
        { pc = 0x1cdd9c; break; }
  case 0x1cddb0: // 0160:1cddb0
    memoryASet16(ds, 0x20cfa7, memoryAGet16(ds, 0x20cfa7) - 0x0002);
  case 0x1cddb8: // 0160:1cddb8
    r16[cx] = memoryAGet16(ds, 0x20cfa7);
  case 0x1cddbf: // 0160:1cddbf
    memoryASet16(ds, 0x20cfa7, r16[cx]);
    r32[eax] = memoryAGet32(ds, 0x20ced3);
    r32[ebx] = memoryAGet32(ds, 0x20ced7);
    if (r32[ebx] >= r32[eax])
        { pc = 0x1cddf7; break; }
    if (!r32[eax])
        { pc = 0x1cddf2; break; }
    r32[ecx] &= 0x000000ff;
    r16[cx] <<= 2;
    r32[esi] = memoryAGet32(ds, 0x20e819);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    if (r16[dx])
        { pc = 0x1cde17; break; }
  case 0x1cddf2: // 0160:1cddf2
    r16[ax] = 0;
    { pc = 0x1cde20; break; }
  case 0x1cddf7: // 0160:1cddf7
    r32[eax] = r32[ebx];
    if (!r32[eax])
        { pc = 0x1cddf2; break; }
    r32[ecx] &= 0x000000ff;
    r16[cx] <<= 2;
    r32[esi] = memoryAGet32(ds, 0x20e819);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    if (!r16[dx])
        { pc = 0x1cddf2; break; }
  case 0x1cde17: // 0160:1cde17
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[edx] = 0;
    div32(r32[ebx]);
  case 0x1cde20: // 0160:1cde20
    if (r16[ax] < memoryAGet16(ds, 0x20d001))
        { pc = 0x1cde35; break; }
    flags.carry = r16[ax] < 0x0004;
    r16[ax] -= 0x0004;
    if (flags.carry)
        { pc = 0x1cde35; break; }
    r16[ax] = memoryAGet16(ds, 0x20d001);
  case 0x1cde35: // 0160:1cde35
    memoryASet16(ds, 0x20cfb9, r16[ax]);
    if (r16s[ax] >= 0)
        { pc = 0x1cde49; break; }
    memoryASet16(ds, 0x20cfb9, 0x0000);
  case 0x1cde49: // 0160:1cde49
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cde4a() // 0160:1cde4a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00201020;
    r16[bx] = 0;
    r32[ecx] = 0x000000fe;
    r16[dx] = 0x01fe;
  case 0x1cde5b: // 0160:1cde5b
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    if (r16[ax] >= r16[bp])
        { pc = 0x1cde80; break; }
    r16[dx] = r16[cx];
    r16[cx] += r16[bx];
    r16[cx] >>>= 1;
    r16[cx] &= 0xfffe;
    r16[bp] = r16[dx];
    r16[bp] -= r16[bx];
    if (r16[bp] != 0x0002)
        { pc = 0x1cde5b; break; }
    { pc = 0x1cde9a; break; }
  case 0x1cde80: // 0160:1cde80
    r16[bx] = r16[cx];
    r16[cx] += r16[dx];
    r16[cx] >>>= 1;
    r16[cx] &= 0xfffe;
    r16[bp] = r16[dx];
    r16[bp] -= r16[bx];
    if (r16[bp] != 0x0002)
        { pc = 0x1cde5b; break; }
  case 0x1cde9a: // 0160:1cde9a
    r16[cx] >>>= 1;
    r32[esp] += 4;
    return;
  }
}
function* sub_1cde9e() // 0160:1cde9e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1cdeae; break; }
    yield* sub_1c79ac();
  case 0x1cdeae: // 0160:1cdeae
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r32[edi] = 0x000a0000;
    push(ds);
    es = pop();
    r32[eax] = 0;
    r32[ecx] = 0x00004000;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    yield* sub_1b4bc9();
    memoryASet16(ds, 0x20ed7f, 0x0000);
    memoryASet16(ds, 0x20eda7, 0x0001);
    memoryASet16(ds, 0x20e7d7, 0x0001);
    r32[edx] = 0x00209182;
    r32[eax] = 0x0023f52c;
    yield* sub_1aa484();
    r32[edi] = 0x000a0000;
    push(ds);
    es = pop();
    r32[ecx] = 0x00004000;
    r32[eax] = 0x3f3f3f3f;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    r32[esi] = memoryAGet32(ds, 0x23f52c);
    yield* sub_1ce18e();
    r32[edi] = 0x000a0000;
    memoryASet16(ds, 0x20ee79, 0x0001);
    yield* sub_1ce128();
    memoryASet16(ds, 0x20ee79, 0x0000);
    memoryASet16(ds, 0x224648, 0x0000);
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1b4f0e();
    r8[al] = 0x7e;
    yield* sub_1ce10a();
    r32[ecx] = 0x00000088;
    r32[edi] = 0x0023f530;
    memoryASet32(ds, 0x20ceaf, r32[edi]);
  case 0x1cdf68: // 0160:1cdf68
    push32(r32[ecx]);
    yield* sub_1ce004();
    yield* sub_1b2b87();
    yield* sub_1b2b87();
    yield* sub_1b2b87();
    memoryASet16(ds, 0x20cec3, memoryAGet16(ds, 0x20cec3) + 1);
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1cdfb2; break; }
    memoryASet16(ds, 0x224648, 0x0001);
    r32[edi] = memoryAGet32(ds, 0x20ceaf);
    r32[esi] = memoryAGet32(ds, r32[edi]);
    yield* sub_1ce20d();
    r32[edi] = 0x000a4800;
    yield* sub_1ce128();
    { pc = 0x1cdfd2; break; }
  case 0x1cdfb2: // 0160:1cdfb2
    memoryASet16(ds, 0x224648, 0x0000);
    r32[edi] = memoryAGet32(ds, 0x20ceaf);
    r32[esi] = memoryAGet32(ds, r32[edi]);
    yield* sub_1ce20d();
    r32[edi] = 0x000a0000;
    yield* sub_1ce128();
  case 0x1cdfd2: // 0160:1cdfd2
    r32[ecx] = pop32();
    memoryASet32(ds, 0x20ceaf, memoryAGet32(ds, 0x20ceaf) + 0x00000004);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1cdf68; break; }
    r8[al] = 0x56;
    yield* sub_1ce10a();
    r32[ecx] = 0x0000000a;
  case 0x1cdfe9: // 0160:1cdfe9
    yield* sub_1ad600();
    if (--r32[ecx])
        { pc = 0x1cdfe9; break; }
    r8[al] = 0x56;
    yield* sub_1ce10a();
    r32[ecx] = 0x00000050;
  case 0x1cdffc: // 0160:1cdffc
    yield* sub_1ad600();
    if (--r32[ecx])
        { pc = 0x1cdffc; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1cdeae() // 0160:1cdeae +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r32[edi] = 0x000a0000;
    push(ds);
    es = pop();
    r32[eax] = 0;
    r32[ecx] = 0x00004000;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    yield* sub_1b4bc9();
    memoryASet16(ds, 0x20ed7f, 0x0000);
    memoryASet16(ds, 0x20eda7, 0x0001);
    memoryASet16(ds, 0x20e7d7, 0x0001);
    r32[edx] = 0x00209182;
    r32[eax] = 0x0023f52c;
    yield* sub_1aa484();
    r32[edi] = 0x000a0000;
    push(ds);
    es = pop();
    r32[ecx] = 0x00004000;
    r32[eax] = 0x3f3f3f3f;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    r32[esi] = memoryAGet32(ds, 0x23f52c);
    yield* sub_1ce18e();
    r32[edi] = 0x000a0000;
    memoryASet16(ds, 0x20ee79, 0x0001);
    yield* sub_1ce128();
    memoryASet16(ds, 0x20ee79, 0x0000);
    memoryASet16(ds, 0x224648, 0x0000);
    memoryASet16(ds, 0x20eeb0, 0x0000);
    memoryASet16(ds, 0x20cec3, 0x0000);
    yield* sub_1b4f0e();
    r8[al] = 0x7e;
    yield* sub_1ce10a();
    r32[ecx] = 0x00000088;
    r32[edi] = 0x0023f530;
    memoryASet32(ds, 0x20ceaf, r32[edi]);
  case 0x1cdf68: // 0160:1cdf68
    push32(r32[ecx]);
    yield* sub_1ce004();
    yield* sub_1b2b87();
    yield* sub_1b2b87();
    yield* sub_1b2b87();
    memoryASet16(ds, 0x20cec3, memoryAGet16(ds, 0x20cec3) + 1);
    r16[ax] = memoryAGet16(ds, 0x20cec3);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1cdfb2; break; }
    memoryASet16(ds, 0x224648, 0x0001);
    r32[edi] = memoryAGet32(ds, 0x20ceaf);
    r32[esi] = memoryAGet32(ds, r32[edi]);
    yield* sub_1ce20d();
    r32[edi] = 0x000a4800;
    yield* sub_1ce128();
    { pc = 0x1cdfd2; break; }
  case 0x1cdfb2: // 0160:1cdfb2
    memoryASet16(ds, 0x224648, 0x0000);
    r32[edi] = memoryAGet32(ds, 0x20ceaf);
    r32[esi] = memoryAGet32(ds, r32[edi]);
    yield* sub_1ce20d();
    r32[edi] = 0x000a0000;
    yield* sub_1ce128();
  case 0x1cdfd2: // 0160:1cdfd2
    r32[ecx] = pop32();
    memoryASet32(ds, 0x20ceaf, memoryAGet32(ds, 0x20ceaf) + 0x00000004);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1cdf68; break; }
    r8[al] = 0x56;
    yield* sub_1ce10a();
    r32[ecx] = 0x0000000a;
  case 0x1cdfe9: // 0160:1cdfe9
    yield* sub_1ad600();
    if (--r32[ecx])
        { pc = 0x1cdfe9; break; }
    r8[al] = 0x56;
    yield* sub_1ce10a();
    r32[ecx] = 0x00000050;
  case 0x1cdffc: // 0160:1cdffc
    yield* sub_1ad600();
    if (--r32[ecx])
        { pc = 0x1cdffc; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ce004() // 0160:1ce004 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1ce109; break; }
    if (r32[ecx] != 0x00000082)
        { pc = 0x1ce022; break; }
    r8[al] = 0xae;
    yield* sub_1ce10a();
  case 0x1ce022: // 0160:1ce022
    if (r32[ecx] != 0x0000007e)
        { pc = 0x1ce02e; break; }
    r8[al] = 0x7f;
    yield* sub_1ce10a();
  case 0x1ce02e: // 0160:1ce02e
    if (r32[ecx] != 0x00000072)
        { pc = 0x1ce03a; break; }
    r8[al] = 0xae;
    yield* sub_1ce10a();
  case 0x1ce03a: // 0160:1ce03a
    if (r32[ecx] != 0x0000006a)
        { pc = 0x1ce062; break; }
    memoryASet32(ds, 0x1f1cdc, 0x00000000);
    memoryASet32(ds, 0x1f1ce0, 0x0000002c);
    memoryASet32(ds, 0x1f1ce4, 0x00000118);
    yield* sub_1aa64a();
  case 0x1ce062: // 0160:1ce062
    if (r32[ecx] != 0x0000005c)
        { pc = 0x1ce06e; break; }
    r8[al] = 0x6b;
    yield* sub_1ce10a();
  case 0x1ce06e: // 0160:1ce06e
    if (r32[ecx] == 0x0000004f)
        { pc = 0x1ce07d; break; }
    if (r32[ecx] == 0x00000046)
        { pc = 0x1ce07d; break; }
    if (r32[ecx] != 0x00000041)
        { pc = 0x1ce09d; break; }
  case 0x1ce07d: // 0160:1ce07d
    r8[al] = 0x49;
    yield* sub_1ce10a();
    memoryASet32(ds, 0x1f1cdc, 0x00000000);
    memoryASet32(ds, 0x1f1ce4, 0x00000118);
    yield* sub_1c7954();
  case 0x1ce09d: // 0160:1ce09d
    if (r32[ecx] == 0x0000003c)
        { pc = 0x1ce0b1; break; }
    if (r32[ecx] == 0x00000036)
        { pc = 0x1ce0b1; break; }
    if (r32[ecx] == 0x00000030)
        { pc = 0x1ce0b1; break; }
    if (r32[ecx] != 0x0000002c)
        { pc = 0x1ce0d1; break; }
  case 0x1ce0b1: // 0160:1ce0b1
    r8[al] = 0x53;
    yield* sub_1ce10a();
    memoryASet32(ds, 0x1f1cdc, 0x00000000);
    memoryASet32(ds, 0x1f1ce4, 0x00000280);
    yield* sub_1c7954();
  case 0x1ce0d1: // 0160:1ce0d1
    if (r32s[ecx] > signed32(0x00000014))
        { pc = 0x1ce0df; break; }
    r8[al] = 0x28;
    r8[al] -= r8[cl];
    yield* sub_1b17b7();
  case 0x1ce0df: // 0160:1ce0df
    if (r32[ecx] != 0x00000032)
        { pc = 0x1ce109; break; }
    r32[ebx] = 0;
    r16[bx] = 0x0000;
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = 0x0000;
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = 0x0140;
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    yield* sub_1aa64a();
  case 0x1ce109: // 0160:1ce109
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ce10a() // 0160:1ce10a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ce10a; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 25818 bytes // gap 25818 bytes
  case 0x1ce10a: // 0160:1ce10a
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1ce127; break; }
    memoryASet16(ds, 0x20d2c5, 0x0003);
    { pc = 0x1b17b7; break; }
  case 0x1ce127: // 0160:1ce127
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ce128() // 0160:1ce128 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[edi] += 0x00001400;
    push32(r32[edi]);
    r32[esi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
    r8[al] = 0;
    if (!(memoryAGet16(ds, 0x20ee79) & 0xffff))
        { pc = 0x1ce14b; break; }
    yield* sub_1b5442();
  case 0x1ce14b: // 0160:1ce14b
    r32[edi] = pop32();
    r32[esi] = 0x0020f1c4;
    push(ds);
    es = pop();
    flags.direction = 0;
    r32[ebx] = r32[esi];
    r32[ebp] = r32[edi];
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
  case 0x1ce15e: // 0160:1ce15e
    r32[esi] = r32[ebx];
    r32[edi] = r32[ebp];
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    r32[ecx] = 0x00000550;
  case 0x1ce16c: // 0160:1ce16c
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esi] += 0x00000010;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1ce16c; break; }
    r32[eax] = pop32();
    r32[ebx]++;
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x1ce15e; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ce18e() // 0160:1ce18e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] += 0x0023f75c;
    memoryASet32(ds, 0x20ce9d, r32[esi]);
    r32[edi] = 0x0020f1c4;
    r32[edx] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[bx]++;
    mul16(r16[bx]);
    r32[edx] <<= 16;
    r32[eax] &= 0x0000ffff;
    r32[eax] |= r32[edx];
    r32[ecx] = r32[eax];
    r32[esi] = memoryAGet32(ds, 0x20ce9d);
    r32[esi] += 0x00000010;
  case 0x1ce1c9: // 0160:1ce1c9
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xc0)
        { pc = 0x1ce1e1; break; }
    r8[al] -= 0xc0;
    r32[esi]++;
    r8[bl] = memoryAGet(ds, r32[esi]);
  case 0x1ce1d4: // 0160:1ce1d4
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1ce1e8; break; }
    r8[al]--;
    if (r8[al])
        { pc = 0x1ce1d4; break; }
    r32[esi]++;
    { pc = 0x1ce1c9; break; }
  case 0x1ce1e1: // 0160:1ce1e1
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1ce1c9; break; }
    r32[esi]--;
  case 0x1ce1e8: // 0160:1ce1e8
    r32[esi]++;
    r32[esi]++;
    r32[edi] = 0x0020eec4;
    r32[ecx] = 0x00000100;
  case 0x1ce1f4: // 0160:1ce1f4
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi] + 0x2, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, r32[edi], r8[al]);
    r32[esi] += 0x00000003;
    r32[edi] += 0x00000003;
    if (--r32[ecx])
        { pc = 0x1ce1f4; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ce20d() // 0160:1ce20d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] += 0x0023f75c;
    memoryASet32(ds, 0x20ce9d, r32[esi]);
    r32[edi] = 0x0020f1c4;
    r32[edx] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xa);
    r16[bx]++;
    mul16(r16[bx]);
    r32[edx] <<= 16;
    r32[eax] &= 0x0000ffff;
    r32[eax] |= r32[edx];
    r32[ecx] = r32[eax];
    r32[esi] = memoryAGet32(ds, 0x20ce9d);
    r32[esi] += 0x00000010;
  case 0x1ce248: // 0160:1ce248
    r8[al] = memoryAGet(ds, r32[esi]);
    if (r8[al] < 0xc0)
        { pc = 0x1ce260; break; }
    r8[al] -= 0xc0;
    r32[esi]++;
    r8[bl] = memoryAGet(ds, r32[esi]);
  case 0x1ce253: // 0160:1ce253
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edi]++;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1ce267; break; }
    r8[al]--;
    if (r8[al])
        { pc = 0x1ce253; break; }
    r32[esi]++;
    { pc = 0x1ce248; break; }
  case 0x1ce260: // 0160:1ce260
    memoryASet(ds, r32[edi], r8[al]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1ce248; break; }
    r32[esi]--;
  case 0x1ce267: // 0160:1ce267
    r32[esi]++;
    r32[esp] += 4;
    return;
  }
}
function* sub_1ce269() // 0160:1ce269 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d7bf) & 0xffff)
        { pc = 0x1ce642; break; }
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ce2a3; break; }
    if (memoryAGet16(ds, 0x20d87f) & 0xffff)
        { pc = 0x1ce2a3; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1ce2a3; break; }
    if (memoryAGet16(ds, 0x20d0ff) & 0xffff)
        { pc = 0x1ce2c9; break; }
  case 0x1ce2a3: // 0160:1ce2a3
    if (!(memoryAGet16(ds, 0x20e7d7) & 0xffff))
        { pc = 0x1ce360; break; }
    memoryASet16(ds, 0x20e7d7, 0x0000);
    r16[ax] = 0x0000;
    yield* sub_1ce65c();
    { pc = 0x1ce360; break; }
  case 0x1ce2c9: // 0160:1ce2c9
    if (memoryAGet16(ds, 0x20e7d7) & 0xffff)
        { pc = 0x1ce2ec; break; }
    memoryASet16(ds, 0x20e7d7, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e7cf);
    yield* sub_1b17b7();
  case 0x1ce2ec: // 0160:1ce2ec
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1ce2ff; break; }
    r32[esi] = 0x0020315c;
  case 0x1ce2ff: // 0160:1ce2ff
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e7cf);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfa9);
    r16[cx] = r16[bx];
    r16[cx] >>>= 2;
    r16[bx] -= r16[cx];
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[dx] >= 0)
        { pc = 0x1ce34a; break; }
    r16[dx] = 0x003c;
  case 0x1ce34a: // 0160:1ce34a
    if (r16s[dx] > signed16(0x003c))
        { pc = 0x1ce354; break; }
    r16[dx] = 0x003c;
  case 0x1ce354: // 0160:1ce354
    r16[bx] = r16[dx];
    r16[ax] = 0x0000;
    yield* sub_1ce643();
  case 0x1ce360: // 0160:1ce360
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1ce642; break; }
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ce399; break; }
    if (memoryAGet16(ds, 0x20d87f) & 0xffff)
        { pc = 0x1ce399; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1ce399; break; }
    if (memoryAGet16(ds, 0x20d101) & 0xffff)
        { pc = 0x1ce3bf; break; }
  case 0x1ce399: // 0160:1ce399
    if (!(memoryAGet16(ds, 0x20e7d9) & 0xffff))
        { pc = 0x1ce456; break; }
    memoryASet16(ds, 0x20e7d9, 0x0000);
    r16[ax] = 0x0001;
    yield* sub_1ce65c();
    { pc = 0x1ce456; break; }
  case 0x1ce3bf: // 0160:1ce3bf
    if (memoryAGet16(ds, 0x20e7d9) & 0xffff)
        { pc = 0x1ce3e2; break; }
    memoryASet16(ds, 0x20e7d9, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e7d1);
    yield* sub_1b17b7();
  case 0x1ce3e2: // 0160:1ce3e2
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1ce3f5; break; }
    r32[esi] = 0x0020315c;
  case 0x1ce3f5: // 0160:1ce3f5
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e7d1);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfab);
    r16[cx] = r16[bx];
    r16[cx] >>>= 2;
    r16[bx] -= r16[cx];
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20d05f);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[dx] >= 0)
        { pc = 0x1ce440; break; }
    r16[dx] = 0x003c;
  case 0x1ce440: // 0160:1ce440
    if (r16s[dx] > signed16(0x003c))
        { pc = 0x1ce44a; break; }
    r16[dx] = 0x003c;
  case 0x1ce44a: // 0160:1ce44a
    r16[bx] = r16[dx];
    r16[ax] = 0x0001;
    yield* sub_1ce643();
  case 0x1ce456: // 0160:1ce456
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1ce642; break; }
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ce48f; break; }
    if (memoryAGet16(ds, 0x20d87f) & 0xffff)
        { pc = 0x1ce48f; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1ce48f; break; }
    if (memoryAGet16(ds, 0x20d103) & 0xffff)
        { pc = 0x1ce4b5; break; }
  case 0x1ce48f: // 0160:1ce48f
    if (!(memoryAGet16(ds, 0x20e7db) & 0xffff))
        { pc = 0x1ce54c; break; }
    memoryASet16(ds, 0x20e7db, 0x0000);
    r16[ax] = 0x0002;
    yield* sub_1ce65c();
    { pc = 0x1ce54c; break; }
  case 0x1ce4b5: // 0160:1ce4b5
    if (memoryAGet16(ds, 0x20e7db) & 0xffff)
        { pc = 0x1ce4d8; break; }
    memoryASet16(ds, 0x20e7db, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e7d3);
    yield* sub_1b17b7();
  case 0x1ce4d8: // 0160:1ce4d8
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1ce4eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1ce4eb: // 0160:1ce4eb
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e7d3);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfad);
    r16[cx] = r16[bx];
    r16[cx] >>>= 2;
    r16[bx] -= r16[cx];
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20d061);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[dx] >= 0)
        { pc = 0x1ce536; break; }
    r16[dx] = 0x003c;
  case 0x1ce536: // 0160:1ce536
    if (r16s[dx] > signed16(0x003c))
        { pc = 0x1ce540; break; }
    r16[dx] = 0x003c;
  case 0x1ce540: // 0160:1ce540
    r16[bx] = r16[dx];
    r16[ax] = 0x0002;
    yield* sub_1ce643();
  case 0x1ce54c: // 0160:1ce54c
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1ce642; break; }
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1ce585; break; }
    if (memoryAGet16(ds, 0x20d87f) & 0xffff)
        { pc = 0x1ce585; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1ce585; break; }
    if (memoryAGet16(ds, 0x20d105) & 0xffff)
        { pc = 0x1ce5ab; break; }
  case 0x1ce585: // 0160:1ce585
    if (!(memoryAGet16(ds, 0x20e7dd) & 0xffff))
        { pc = 0x1ce642; break; }
    memoryASet16(ds, 0x20e7dd, 0x0000);
    r16[ax] = 0x0003;
    yield* sub_1ce65c();
    { pc = 0x1ce642; break; }
  case 0x1ce5ab: // 0160:1ce5ab
    if (memoryAGet16(ds, 0x20e7dd) & 0xffff)
        { pc = 0x1ce5ce; break; }
    memoryASet16(ds, 0x20e7dd, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20e7d5);
    yield* sub_1b17b7();
  case 0x1ce5ce: // 0160:1ce5ce
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1ce5e1; break; }
    r32[esi] = 0x0020315c;
  case 0x1ce5e1: // 0160:1ce5e1
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20e7d5);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfaf);
    r16[cx] = r16[bx];
    r16[cx] >>>= 2;
    r16[bx] -= r16[cx];
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20d063);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[dx] >= 0)
        { pc = 0x1ce62c; break; }
    r16[dx] = 0x003c;
  case 0x1ce62c: // 0160:1ce62c
    if (r16s[dx] > signed16(0x003c))
        { pc = 0x1ce636; break; }
    r16[dx] = 0x003c;
  case 0x1ce636: // 0160:1ce636
    r16[bx] = r16[dx];
    r16[ax] = 0x0003;
    yield* sub_1ce643();
  case 0x1ce642: // 0160:1ce642
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1ce643() // 0160:1ce643 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ce643; break; }
  case 0x1c7954: // 0160:1c7954
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000010;
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 16);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    flags.zero = memoryAGet32(ss, r32[ebp] - 4) == 0x00000000;
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c798f; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    flags.zero = r32[eax] == memoryAGet32(ds, 0x1f1cd0);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7991; break; }
  case 0x1c798f: // 0160:1c798f
    { pc = 0x1c79a2; break; }
  case 0x1c7991: // 0160:1c7991
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1df990();
  case 0x1c79a2: // 0160:1c79a2
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 27800 bytes // gap 27800 bytes
  case 0x1ce643: // 0160:1ce643
    r32[eax] &= 0x0000000f;
    r32[ebx] &= 0x0000ffff;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    { pc = 0x1c7954; break; }
    return;
  }
}
function* sub_1ce65c() // 0160:1ce65c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ce65c; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 120019 bytes // gap 120019 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 27180 bytes // gap 27180 bytes
  case 0x1ce65c: // 0160:1ce65c
    r32[eax] &= 0x0000000f;
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    memoryASet32(ds, 0x1f1ce0, 0x00000000);
    memoryASet32(ds, 0x1f1ce4, 0x00000140);
    { pc = 0x1aa64a; break; }
    return;
  }
}
function* sub_1ce6b7() // 0160:1ce6b7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1ce6b7; break; }
  case 0x1ce67d: // 0160:1ce67d
    if (!(memoryAGet16(ds, 0x20ed97) & 0xffff))
        { pc = 0x1ce6b6; break; }
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x20ed99);
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    memoryASet32(ds, 0x1f1ce0, 0x00000000);
    memoryASet32(ds, 0x1f1ce4, 0x00000140);
    yield* sub_1aa64a();
    memoryASet16(ds, 0x20ed97, 0x0000);
  case 0x1ce6b6: // 0160:1ce6b6
    r32[esp] += 4; return;
  case 0x1ce6b7: // 0160:1ce6b7
    if (!(memoryAGet16(ds, 0x20ed9d) & 0xffff))
        { pc = 0x1ce67d; break; }
    if (memoryAGet16(ds, 0x20ed97) & 0xffff)
        { pc = 0x1ce886; break; }
    if (!(memoryAGet16(ds, 0x20d0ff) & 0xffff))
        { pc = 0x1ce71f; break; }
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1ce71f; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1ce71f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d039);
    r16[ax] -= memoryAGet16(ds, 0x20cf97);
    if (r16[ax] >= 0xffce)
        { pc = 0x1ce71f; break; }
    if (r16[ax] < 0x0032)
        { pc = 0x1ce71f; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1ce71f; break; }
    r16[ax] = 0x0001;
    { pc = 0x1ce846; break; }
  case 0x1ce71f: // 0160:1ce71f
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1cea27; break; }
    if (!(memoryAGet16(ds, 0x20d101) & 0xffff))
        { pc = 0x1ce77b; break; }
    if (memoryAGet16(ds, 0x20d05f) & 0xffff)
        { pc = 0x1ce77b; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1ce77b; break; }
    r16[ax] = memoryAGet16(ds, 0x20d03b);
    r16[ax] -= memoryAGet16(ds, 0x20cf99);
    if (r16[ax] >= 0xffce)
        { pc = 0x1ce77b; break; }
    if (r16[ax] < 0x0032)
        { pc = 0x1ce77b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1ce77b; break; }
    r16[ax] = 0x0002;
    { pc = 0x1ce846; break; }
  case 0x1ce77b: // 0160:1ce77b
    if (signed16(memoryAGet16(ds, 0x20d7f5)) <= signed16(0x0002))
        { pc = 0x1cea27; break; }
    if (!(memoryAGet16(ds, 0x20d103) & 0xffff))
        { pc = 0x1ce7d7; break; }
    if (memoryAGet16(ds, 0x20d061) & 0xffff)
        { pc = 0x1ce7d7; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1ce7d7; break; }
    r16[ax] = memoryAGet16(ds, 0x20d03d);
    r16[ax] -= memoryAGet16(ds, 0x20cf9b);
    if (r16[ax] >= 0xffce)
        { pc = 0x1ce7d7; break; }
    if (r16[ax] < 0x0032)
        { pc = 0x1ce7d7; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1ce7d7; break; }
    r16[ax] = 0x0003;
    { pc = 0x1ce846; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ce7d7: // 0160:1ce7d7
    if (memoryAGet16(ds, 0x20d7f5) != 0x0004)
        { pc = 0x1cea27; break; }
    if (!(memoryAGet16(ds, 0x20d105) & 0xffff))
        { pc = 0x1cea27; break; }
    if (memoryAGet16(ds, 0x20d063) & 0xffff)
        { pc = 0x1cea27; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1cea27; break; }
    r16[ax] = memoryAGet16(ds, 0x20d03f);
    r16[ax] -= memoryAGet16(ds, 0x20cf9d);
    if (r16[ax] >= 0xffce)
        { pc = 0x1cea27; break; }
    if (r16[ax] < 0x0032)
        { pc = 0x1cea27; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1cea27; break; }
    r16[ax] = 0x0004;
  case 0x1ce846: // 0160:1ce846
    if (memoryAGet16(ds, 0x20ee3b) & 0xffff)
        { pc = 0x1cea27; break; }
    memoryASet16(ds, 0x20ed9b, r16[ax]);
    yield* sub_1b1c25();
    r32[eax] &= 0x00000003;
    r32[esi] = 0x002091c5;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ed97, 0x0001);
    yield* sub_1b17b7();
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    memoryASet(ds, 0x20ed99, r8[al]);
    r32[esp] += 4; return;
  case 0x1ce886: // 0160:1ce886
    r16[ax] = memoryAGet16(ds, 0x20ed9b);
    if (r16[ax] == 0x0004)
        { pc = 0x1ce9c4; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1ce966; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1ce908; break; }
    if (!(memoryAGet16(ds, 0x20d0ff) & 0xffff))
        { pc = 0x1cea22; break; }
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1cea22; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20d039);
    r16[ax] -= memoryAGet16(ds, 0x20cf97);
    if (r16[ax] >= 0xffec)
        { pc = 0x1cea22; break; }
    if (r16[ax] < 0x0014)
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfa9);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1cea22; break; }
    r32[esp] += 4; return;
  case 0x1ce908: // 0160:1ce908
    if (!(memoryAGet16(ds, 0x20d101) & 0xffff))
        { pc = 0x1cea22; break; }
    if (memoryAGet16(ds, 0x20d05f) & 0xffff)
        { pc = 0x1cea22; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20d03b);
    r16[ax] -= memoryAGet16(ds, 0x20cf99);
    if (r16[ax] >= 0xffec)
        { pc = 0x1cea22; break; }
    if (r16[ax] < 0x0014)
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfab);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1cea22; break; }
    r32[esp] += 4; return;
  case 0x1ce966: // 0160:1ce966
    if (!(memoryAGet16(ds, 0x20d103) & 0xffff))
        { pc = 0x1cea22; break; }
    if (memoryAGet16(ds, 0x20d061) & 0xffff)
        { pc = 0x1cea22; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20d03d);
    r16[ax] -= memoryAGet16(ds, 0x20cf9b);
    if (r16[ax] >= 0xffec)
        { pc = 0x1cea22; break; }
    if (r16[ax] < 0x0014)
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfad);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1cea22; break; }
    r32[esp] += 4; return;
  case 0x1ce9c4: // 0160:1ce9c4
    if (!(memoryAGet16(ds, 0x20d105) & 0xffff))
        { pc = 0x1cea22; break; }
    if (memoryAGet16(ds, 0x20d063) & 0xffff)
        { pc = 0x1cea22; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20d03f);
    r16[ax] -= memoryAGet16(ds, 0x20cf9d);
    if (r16[ax] >= 0xffec)
        { pc = 0x1cea22; break; }
    if (r16[ax] < 0x0014)
        { pc = 0x1cea22; break; }
    r16[ax] = memoryAGet16(ds, 0x20cfaf);
    if (r16s[ax] <= signed16(0x0028))
        { pc = 0x1cea22; break; }
    r32[esp] += 4; return;
  case 0x1cea22: // 0160:1cea22
    { pc = 0x1ce67d; break; }
  case 0x1cea27: // 0160:1cea27
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cea28() // 0160:1cea28 +long
{
  return; // TODO: bug
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = memoryAGet32(ds, 0x1f1c34);
    r32[edi] = 0x0023f52c;
    yield* sub_1cec54();
  case 0x1cea38: // 0160:1cea38
    r32[ebx] = memoryAGet32(ds, 0x1f1c34);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r8[bl] = 0x0f;
    r8[bl] &= r8[al];
    r8[bl] >>>= 2;
    memoryASet16(ds, 0x1f1cb8, r16[bx]);
    r32[eax] = memoryAGet32(ds, 0x1f1c38);
    r8[al] &= 0x03;
    r8[al] += r8[al];
    memoryASet(ds, 0x1f1cbe, r8[al]);
    memoryASet(ds, 0x1f1cba, r8[al]);
    r8[al] = memoryAGet(ds, 0x2eebd0);
  case 0x1cea69: // 0160:1cea69
    yield* sync();
    if (memoryAGet(ds, 0x2eebd0) == r8[al])
        { pc = 0x1cea69; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1c34);
    r32[eax] += 0x00005500;
    if (r32[eax] < 0x000aff00)
        { pc = 0x1cea87; break; }
    r32[eax] -= 0x0000ff00;
  case 0x1cea87: // 0160:1cea87
    memoryASet32(ds, 0x1f1c34, r32[eax]);
    r32[esi] = 0x0023f52c;
    r32[edi] = memoryAGet32(ds, 0x1f1c34);
    r32[eax] = memoryAGet32(ds, 0x2246cc);
    yield* sub_1ceb3a();
    yield* sub_1d0dda();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0004)
        { pc = 0x1ceac9; break; }
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1ceb11; break; }
    yield* sub_1d0261();
    { pc = 0x1ceb11; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ceac9: // 0160:1ceac9
    if (memoryAGet16(ds, 0x20d7f5) != 0x0003)
        { pc = 0x1ceadd; break; }
    yield* sub_1d03dc();
    { pc = 0x1ceb11; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1ceadd: // 0160:1ceadd
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1ceb07; break; }
    yield* sub_1cf9db();
    yield* sub_1cff9b();
    if (memoryAGet16(ds, 0x20d89f) & 0xffff)
        { pc = 0x1ceb0c; break; }
    yield* sub_1cfb7c();
    { pc = 0x1ceb0c; break; }
  case 0x1ceb07: // 0160:1ceb07
    yield* sub_1cf9db();
  case 0x1ceb0c: // 0160:1ceb0c
    yield* sub_1d18c0();
  case 0x1ceb11: // 0160:1ceb11
    yield* sub_1d198c();
    yield* sub_1ac75e();
    if (memoryAGet32(ds, 0x2246cc) != 0x00000001)
        { pc = 0x1ceb29; break; }
    yield* sub_1b4f0e();
  case 0x1ceb29: // 0160:1ceb29
    flags.carry = overflow32(memoryAGet32(ds, 0x2246cc), 0x10000000);
    memoryASet32(ds, 0x2246cc, memoryAGet32(ds, 0x2246cc) + 0x10000000);
    if (!flags.carry)
        { pc = 0x1cea38; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1ceb3a() // 0160:1ceb3a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x20cedb, r32[eax]);
    r32[eax] = memoryAGet16(ds, 0x20ee53);
    r32[ecx] = memoryAGet32(ds, 0x1f1c38);
    r32[ecx] &= 0x0000000f;
    r32[eax] += r32[ecx];
    r32[eax] >>>= 1;
    r32[eax]--;
    r32[esi] += r32[eax];
    r32[esi] += 0x00000003;
    r32[eax] += 0x00000008;
    mul32(memoryAGet32(ds, 0x20cedb));
    r32[ecx] = 0x80000000;
    flags.carry = r32[ecx] < r32[eax];
    r32[ecx] -= r32[eax];
    r32[esi] -= (r32[edx] + flags.carry);
    memoryASet32(ds, 0x20ced7, r32[ecx]);
    r32[eax] = memoryAGet16(ds, 0x20ee55);
    r32[eax] >>>= 1;
    r32[ebp] = r32[eax];
    mul32(memoryAGet32(ds, 0x20cedb));
    r32[ecx] = 0x80000000;
    flags.carry = r32[ecx] < r32[eax];
    r32[ecx] -= r32[eax];
    r32[ebp] -= (r32[edx] + flags.carry);
    r32[eax] = 0x00000150;
    mul32(r32[ebp]);
    r32[esi] += r32[eax];
    r32[ebp] = r32[ecx];
    r32[eax] = memoryAGet32(ds, 0x20cedb);
    r32[ebx] = 0;
    flags.carry = overflow32(r32[eax], r32[eax]);
    r32[eax] += r32[eax];
    r32[ebx] += (r32[ebx] + flags.carry);
    flags.carry = overflow32(r32[eax], r32[eax]);
    r32[eax] += r32[eax];
    r32[ebx] += (r32[ebx] + flags.carry);
    memoryASet32(ds, 0x20cecf, r32[eax]);
    memoryASet32(ds, 0x20ced3, r32[ebx]);
    r32[eax] = memoryAGet16(ds, 0x20ee55);
    memoryASet32(ds, 0x20cedf, r32[eax]);
  case 0x1cebbc: // 0160:1cebbc
    r32[ebx] = memoryAGet32(ds, 0x20ced7);
    push32(r32[esi]);
    r16[ax] = 0x0102;
  case 0x1cebc7: // 0160:1cebc7
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    flags.carry = overflow32(r32[ebx], memoryAGet32(ds, 0x20cedb));
    r32[ebx] += memoryAGet32(ds, 0x20cedb);
    r32[esi] += (0x00000000 + flags.carry);
    push32(r32[ebx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ecx] = memoryAGet16(ds, 0x20ee53);
    r32[ecx] >>>= 4;
    r32[ecx]++;
  case 0x1cebe5: // 0160:1cebe5
    flags.carry = overflow32(r32[ebx], memoryAGet32(ds, 0x20cecf));
    r32[ebx] += memoryAGet32(ds, 0x20cecf);
    r32[esi] += memoryAGet32(ds, 0x20ced3) + flags.carry;
    r8[al] = memoryAGet(ds, r32[esi]);
    flags.carry = overflow32(r32[ebx], memoryAGet32(ds, 0x20cecf));
    r32[ebx] += memoryAGet32(ds, 0x20cecf);
    r32[esi] += memoryAGet32(ds, 0x20ced3) + flags.carry;
    r8[ah] = memoryAGet(ds, r32[esi]);
    flags.carry = overflow32(r32[ebx], memoryAGet32(ds, 0x20cecf));
    r32[ebx] += memoryAGet32(ds, 0x20cecf);
    r32[esi] += memoryAGet32(ds, 0x20ced3) + flags.carry;
    r8[dl] = memoryAGet(ds, r32[esi]);
    flags.carry = overflow32(r32[ebx], memoryAGet32(ds, 0x20cecf));
    r32[ebx] += memoryAGet32(ds, 0x20cecf);
    r32[esi] += memoryAGet32(ds, 0x20ced3) + flags.carry;
    r8[dh] = memoryAGet(ds, r32[esi]);
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    memoryASet32(ds, r32[edi], r32[edx]);
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1cebe5; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1cebc7; break; }
    r32[edi] += 0x00000054;
    r32[esi] = pop32();
    flags.carry = overflow32(r32[ebp], memoryAGet32(ds, 0x20cedb));
    r32[ebp] += memoryAGet32(ds, 0x20cedb);
    if (!flags.carry)
        { pc = 0x1cec47; break; }
    r32[esi] += 0x00000150;
  case 0x1cec47: // 0160:1cec47
    memoryASet32(ds, 0x20cedf, memoryAGet32(ds, 0x20cedf) - 1);
    if (memoryAGet32(ds, 0x20cedf))
        { pc = 0x1cebbc; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1cec54() // 0160:1cec54 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = 0x0004;
  case 0x1cec58: // 0160:1cec58
    r16[dx] = 0x03ce;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    push32(r32[edi]);
    push32(r32[esi]);
    r32[ecx] = 0x000013b0;
  case 0x1cec66: // 0160:1cec66
    r32[eax] = memoryAGet32(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet(ds, r32[edi] + 0x4, r8[ah]);
    r32[eax] >>>= 16;
    memoryASet(ds, r32[edi] + 0x8, r8[al]);
    memoryASet(ds, r32[edi] + 0xc, r8[ah]);
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000010;
    if (--r32[ecx])
        { pc = 0x1cec66; break; }
    r32[esi] = pop32();
    r32[edi] = pop32();
    r32[eax] = pop32();
    r32[edi]++;
    r8[ah]++;
    if (r8[ah] < 0x04)
        { pc = 0x1cec58; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1cec8a() // 0160:1cec8a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20cf3d) & 0xffff))
        { pc = 0x1cee09; break; }
    r16[bp] = memoryAGet16(ds, 0x20cf85);
    if (r16[bp] < 0x0020)
        { pc = 0x1ced00; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    if (r16s[bp] < signed16(0x002e))
        { pc = 0x1cecbe; break; }
    if (r16s[bp] > signed16(0x0032))
        { pc = 0x1cecbe; break; }
    r16[ax] &= 0x0007;
    flags.zero = r16[ax] == 0;
    { pc = 0x1cecc2; break; }
  case 0x1cecbe: // 0160:1cecbe
    r16[ax] &= 0x0003;
    flags.zero = r16[ax] == 0;
  case 0x1cecc2: // 0160:1cecc2
    if (!flags.zero)
        { pc = 0x1ced00; break; }
    if (r16[bp] == 0x0033)
        { pc = 0x1cece0; break; }
    if (r16[bp] == 0x003a)
        { pc = 0x1cece0; break; }
    if (r16[bp] == 0x0041)
        { pc = 0x1cece0; break; }
    if (r16[bp] == 0x004f)
        { pc = 0x1cece0; break; }
    r16[bp]++;
  case 0x1cece0: // 0160:1cece0
    memoryASet16(ds, 0x20cf85, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20d0ff);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[cx] = memoryAGet16(ds, 0x20cf4f);
    yield* sub_1cf2d2();
  case 0x1ced00: // 0160:1ced00
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[cx] = memoryAGet16(ds, 0x20d05d);
    memoryASet16(ds, 0x20e805, r16[cx]);
    r16[cx] = 0x0041;
    memoryASet16(ds, 0x20e801, r16[cx]);
    r16[dx] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20eda5, 0x0001);
    yield* sub_1cf538();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20d231, r16[ax]);
    memoryASet16(ds, 0x20d233, r16[bx]);
    r16[cx] = memoryAGet16(ds, 0x20ee53);
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[cx] += 0x005f;
    r16[dx] += 0x005b;
    memoryASet16(ds, 0x20d111, 0x0000);
    if (r16s[ax] <= signed16(0x0081))
        { pc = 0x1ced9e; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1ced9e; break; }
    if (r16s[bx] <= signed16(0x0081))
        { pc = 0x1ced9e; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1ced9e; break; }
    memoryASet16(ds, 0x20d111, 0x0001);
    memoryASet16(ds, 0x20d0ff, 0x0001);
    r32[esp] += 4; return;
  case 0x1ced9e: // 0160:1ced9e
    if (signed16(memoryAGet16(ds, 0x20ceb7)) <= signed16(0x0081))
        { pc = 0x1cedd9; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb7)) >= r16s[cx])
        { pc = 0x1cedd9; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) <= signed16(0x0081))
        { pc = 0x1cedd9; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) >= r16s[dx])
        { pc = 0x1cedd9; break; }
    memoryASet16(ds, 0x20d111, 0x0001);
    memoryASet16(ds, 0x20d0ff, 0x0001);
    r32[esp] += 4; return;
  case 0x1cedd9: // 0160:1cedd9
    memoryASet16(ds, 0x20d0ff, 0x0000);
    r16[cx] += 0x0011;
    r16[dx] += 0x0011;
    if (r16s[ax] <= signed16(0x0070))
        { pc = 0x1cee09; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cee09; break; }
    if (r16s[bx] <= signed16(0x0070))
        { pc = 0x1cee09; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cee09; break; }
    memoryASet16(ds, 0x20d0ff, 0x0001);
  case 0x1cee09: // 0160:1cee09
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cee0a() // 0160:1cee0a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20cf3f) & 0xffff))
        { pc = 0x1cef92; break; }
    r16[bp] = memoryAGet16(ds, 0x20cf87);
    if (r16[bp] < 0x0020)
        { pc = 0x1cee80; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    if (r16s[bp] < signed16(0x002e))
        { pc = 0x1cee3e; break; }
    if (r16s[bp] > signed16(0x0032))
        { pc = 0x1cee3e; break; }
    r16[ax] &= 0x0007;
    flags.zero = r16[ax] == 0;
    { pc = 0x1cee42; break; }
  case 0x1cee3e: // 0160:1cee3e
    r16[ax] &= 0x0003;
    flags.zero = r16[ax] == 0;
  case 0x1cee42: // 0160:1cee42
    if (!flags.zero)
        { pc = 0x1cee80; break; }
    if (r16[bp] == 0x0033)
        { pc = 0x1cee60; break; }
    if (r16[bp] == 0x003a)
        { pc = 0x1cee60; break; }
    if (r16[bp] == 0x0041)
        { pc = 0x1cee60; break; }
    if (r16[bp] == 0x004f)
        { pc = 0x1cee60; break; }
    r16[bp]++;
  case 0x1cee60: // 0160:1cee60
    memoryASet16(ds, 0x20cf87, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20d101);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[cx] = memoryAGet16(ds, 0x20cf51);
    yield* sub_1cf2d2();
  case 0x1cee80: // 0160:1cee80
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[cx] = memoryAGet16(ds, 0x20d05f);
    memoryASet16(ds, 0x20e805, r16[cx]);
    memoryASet16(ds, 0x20ce8f, 0x0001);
    r16[cx] = 0x0041;
    memoryASet16(ds, 0x20e801, r16[cx]);
    r16[dx] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20eda5, 0x0001);
    yield* sub_1cf538();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20d235, r16[ax]);
    memoryASet16(ds, 0x20d237, r16[bx]);
    r16[cx] = memoryAGet16(ds, 0x20ee53);
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[cx] += 0x005f;
    r16[dx] += 0x005b;
    memoryASet16(ds, 0x20d113, 0x0000);
    if (r16s[ax] <= signed16(0x0081))
        { pc = 0x1cef27; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cef27; break; }
    if (r16s[bx] <= signed16(0x0081))
        { pc = 0x1cef27; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cef27; break; }
    memoryASet16(ds, 0x20d113, 0x0001);
    memoryASet16(ds, 0x20d101, 0x0001);
    r32[esp] += 4; return;
  case 0x1cef27: // 0160:1cef27
    if (signed16(memoryAGet16(ds, 0x20ceb7)) <= signed16(0x0081))
        { pc = 0x1cef62; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb7)) >= r16s[cx])
        { pc = 0x1cef62; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) <= signed16(0x0081))
        { pc = 0x1cef62; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) >= r16s[dx])
        { pc = 0x1cef62; break; }
    memoryASet16(ds, 0x20d113, 0x0001);
    memoryASet16(ds, 0x20d101, 0x0001);
    r32[esp] += 4; return;
  case 0x1cef62: // 0160:1cef62
    memoryASet16(ds, 0x20d101, 0x0000);
    r16[cx] += 0x0011;
    r16[dx] += 0x0011;
    if (r16s[ax] <= signed16(0x0070))
        { pc = 0x1cef92; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cef92; break; }
    if (r16s[bx] <= signed16(0x0070))
        { pc = 0x1cef92; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cef92; break; }
    memoryASet16(ds, 0x20d101, 0x0001);
  case 0x1cef92: // 0160:1cef92
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cef93() // 0160:1cef93 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20cf41) & 0xffff))
        { pc = 0x1cf13a; break; }
    r16[bp] = memoryAGet16(ds, 0x20cf89);
    if (r16[bp] < 0x0020)
        { pc = 0x1cf014; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    if (r16s[bp] < signed16(0x002e))
        { pc = 0x1cefc7; break; }
    if (r16s[bp] > signed16(0x0032))
        { pc = 0x1cefc7; break; }
    r16[ax] &= 0x0007;
    flags.zero = r16[ax] == 0;
    { pc = 0x1cefcb; break; }
  case 0x1cefc7: // 0160:1cefc7
    r16[ax] &= 0x0003;
    flags.zero = r16[ax] == 0;
  case 0x1cefcb: // 0160:1cefcb
    if (!flags.zero)
        { pc = 0x1cf014; break; }
    if (r16[bp] == 0x0033)
        { pc = 0x1cefe9; break; }
    if (r16[bp] == 0x003a)
        { pc = 0x1cefe9; break; }
    if (r16[bp] == 0x0041)
        { pc = 0x1cefe9; break; }
    if (r16[bp] == 0x004f)
        { pc = 0x1cefe9; break; }
    r16[bp]++;
  case 0x1cefe9: // 0160:1cefe9
    memoryASet16(ds, 0x20cf89, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20d103);
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1cf014; break; }
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[cx] = memoryAGet16(ds, 0x20cf53);
    yield* sub_1cf2d2();
  case 0x1cf014: // 0160:1cf014
    memoryASet16(ds, 0x20ce8f, 0x0003);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[cx] = memoryAGet16(ds, 0x20d061);
    memoryASet16(ds, 0x20e805, r16[cx]);
    r16[cx] = 0x0041;
    memoryASet16(ds, 0x20e801, r16[cx]);
    r16[dx] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20eda5, 0x0001);
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1cf067; break; }
    memoryASet16(ds, 0x20eda5, 0x0000);
  case 0x1cf067: // 0160:1cf067
    yield* sub_1cf538();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20d239, r16[ax]);
    memoryASet16(ds, 0x20d23b, r16[bx]);
    r16[cx] = memoryAGet16(ds, 0x20ee53);
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[cx] += 0x005f;
    r16[dx] += 0x005b;
    memoryASet16(ds, 0x20d115, 0x0000);
    if (r16s[ax] <= signed16(0x0081))
        { pc = 0x1cf0cf; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cf0cf; break; }
    if (r16s[bx] <= signed16(0x0081))
        { pc = 0x1cf0cf; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cf0cf; break; }
    memoryASet16(ds, 0x20d115, 0x0001);
    memoryASet16(ds, 0x20d103, 0x0001);
    r32[esp] += 4; return;
  case 0x1cf0cf: // 0160:1cf0cf
    if (signed16(memoryAGet16(ds, 0x20ceb7)) <= signed16(0x0081))
        { pc = 0x1cf10a; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb7)) >= r16s[cx])
        { pc = 0x1cf10a; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) <= signed16(0x0081))
        { pc = 0x1cf10a; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) >= r16s[dx])
        { pc = 0x1cf10a; break; }
    memoryASet16(ds, 0x20d115, 0x0001);
    memoryASet16(ds, 0x20d103, 0x0001);
    r32[esp] += 4; return;
  case 0x1cf10a: // 0160:1cf10a
    memoryASet16(ds, 0x20d103, 0x0000);
    r16[cx] += 0x0011;
    r16[dx] += 0x0011;
    if (r16s[ax] <= signed16(0x0070))
        { pc = 0x1cf13a; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cf13a; break; }
    if (r16s[bx] <= signed16(0x0070))
        { pc = 0x1cf13a; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cf13a; break; }
    memoryASet16(ds, 0x20d103, 0x0001);
  case 0x1cf13a: // 0160:1cf13a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cf13b() // 0160:1cf13b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20cf43) & 0xffff))
        { pc = 0x1cf2d1; break; }
    r16[bp] = memoryAGet16(ds, 0x20cf8b);
    if (r16[bp] < 0x0020)
        { pc = 0x1cf1b1; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    if (r16s[bp] < signed16(0x002e))
        { pc = 0x1cf16f; break; }
    if (r16s[bp] > signed16(0x0032))
        { pc = 0x1cf16f; break; }
    r16[ax] &= 0x0007;
    flags.zero = r16[ax] == 0;
    { pc = 0x1cf173; break; }
  case 0x1cf16f: // 0160:1cf16f
    r16[ax] &= 0x0003;
    flags.zero = r16[ax] == 0;
  case 0x1cf173: // 0160:1cf173
    if (!flags.zero)
        { pc = 0x1cf1b1; break; }
    if (r16[bp] == 0x0033)
        { pc = 0x1cf191; break; }
    if (r16[bp] == 0x003a)
        { pc = 0x1cf191; break; }
    if (r16[bp] == 0x0041)
        { pc = 0x1cf191; break; }
    if (r16[bp] == 0x004f)
        { pc = 0x1cf191; break; }
    r16[bp]++;
  case 0x1cf191: // 0160:1cf191
    memoryASet16(ds, 0x20cf8b, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20d105);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[cx] = memoryAGet16(ds, 0x20cf55);
    yield* sub_1cf2d2();
  case 0x1cf1b1: // 0160:1cf1b1
    memoryASet16(ds, 0x20ce8f, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[cx] = memoryAGet16(ds, 0x20d063);
    memoryASet16(ds, 0x20e805, r16[cx]);
    r16[cx] = 0x0041;
    if (signed16(memoryAGet16(ds, 0x20cf8b)) <= signed16(0x0025))
        { pc = 0x1cf1e7; break; }
    r16[cx] = 0x0041;
  case 0x1cf1e7: // 0160:1cf1e7
    memoryASet16(ds, 0x20e801, r16[cx]);
    r16[dx] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20eda5, 0x0001);
    yield* sub_1cf538();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20d23d, r16[ax]);
    memoryASet16(ds, 0x20d23f, r16[bx]);
    r16[cx] = memoryAGet16(ds, 0x20ee53);
    r16[dx] = memoryAGet16(ds, 0x20ee55);
    r16[cx] += 0x005f;
    r16[dx] += 0x005b;
    memoryASet16(ds, 0x20d117, 0x0000);
    if (r16s[ax] <= signed16(0x0081))
        { pc = 0x1cf266; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cf266; break; }
    if (r16s[bx] <= signed16(0x0081))
        { pc = 0x1cf266; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cf266; break; }
    memoryASet16(ds, 0x20d117, 0x0001);
    memoryASet16(ds, 0x20d105, 0x0001);
    r32[esp] += 4; return;
  case 0x1cf266: // 0160:1cf266
    if (signed16(memoryAGet16(ds, 0x20ceb7)) <= signed16(0x0081))
        { pc = 0x1cf2a1; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb7)) >= r16s[cx])
        { pc = 0x1cf2a1; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) <= signed16(0x0081))
        { pc = 0x1cf2a1; break; }
    if (signed16(memoryAGet16(ds, 0x20ceb9)) >= r16s[dx])
        { pc = 0x1cf2a1; break; }
    memoryASet16(ds, 0x20d117, 0x0001);
    memoryASet16(ds, 0x20d105, 0x0001);
    r32[esp] += 4; return;
  case 0x1cf2a1: // 0160:1cf2a1
    memoryASet16(ds, 0x20d105, 0x0000);
    r16[cx] += 0x0011;
    r16[dx] += 0x0011;
    if (r16s[ax] <= signed16(0x0070))
        { pc = 0x1cf2d1; break; }
    if (r16s[ax] >= r16s[cx])
        { pc = 0x1cf2d1; break; }
    if (r16s[bx] <= signed16(0x0070))
        { pc = 0x1cf2d1; break; }
    if (r16s[bx] >= r16s[dx])
        { pc = 0x1cf2d1; break; }
    memoryASet16(ds, 0x20d105, 0x0001);
  case 0x1cf2d1: // 0160:1cf2d1
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cf2d2() // 0160:1cf2d2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cf2d2; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 30370 bytes // gap 30370 bytes
  case 0x1cf2d2: // 0160:1cf2d2
    if (!r16[ax])
        { pc = 0x1cf537; break; }
    if (r16[bp] == 0x0022)
        { pc = 0x1cf2eb; break; }
    if (r16[bp] != 0x0023)
        { pc = 0x1cf498; break; }
  case 0x1cf2eb: // 0160:1cf2eb
    if (memoryAGet16(ds, 0x20edfd) & 0xffff)
        { pc = 0x1cf537; break; }
    if (memoryAGet16(ds, 0x20ee85))
        { pc = 0x1cf491; break; }
    if (!memoryAGet16(ds, 0x20ee83))
        { pc = 0x1cf342; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee89, memoryAGet16(ds, 0x20ee89) + r16[ax]);
    memoryASet16(ds, 0x20ee89, memoryAGet16(ds, 0x20ee89) & 0x0007);
    r16[ax] = memoryAGet16(ds, 0x20ee89);
    r16[ax] += 0x00c1;
    yield* sub_1b1715();
    { pc = 0x1cf491; break; }
  case 0x1cf342: // 0160:1cf342
    if (memoryAGet16(ds, 0x20d7b9) != 0x0008)
        { pc = 0x1cf367; break; }
    yield* sub_1b1c25();
    r8[al] &= 0x01;
    if (r8[al])
        { pc = 0x1cf422; break; }
    r16[ax] = 0x0126;
    yield* sub_1b1715();
    { pc = 0x1cf491; break; }
  case 0x1cf367: // 0160:1cf367
    if (memoryAGet16(ds, 0x20d7b9) != 0x0028)
        { pc = 0x1cf3a4; break; }
    if (r16s[bx] < signed16(0x019a))
        { pc = 0x1cf3a4; break; }
    if (r16s[bx] > signed16(0x03ac))
        { pc = 0x1cf3a4; break; }
    if (r16s[cx] < signed16(0x012c))
        { pc = 0x1cf3a4; break; }
    if (r16s[cx] > signed16(0x0320))
        { pc = 0x1cf3a4; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x0122;
    yield* sub_1b1715();
    { pc = 0x1cf491; break; }
  case 0x1cf3a4: // 0160:1cf3a4
    if (memoryAGet16(ds, 0x20d7b9) == 0x0006)
        { pc = 0x1cf3b8; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x0022)
        { pc = 0x1cf3d6; break; }
  case 0x1cf3b8: // 0160:1cf3b8
    if (r16s[bx] > signed16(0x0190))
        { pc = 0x1cf3d6; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x011e;
    yield* sub_1b1715();
    { pc = 0x1cf491; break; }
  case 0x1cf3d6: // 0160:1cf3d6
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    if (r16s[ax] <= signed16(0x0011))
        { pc = 0x1cf40a; break; }
    if (r16s[ax] >= signed16(0x0016))
        { pc = 0x1cf40a; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1cf422; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x011c;
    yield* sub_1b1715();
    { pc = 0x1cf491; break; }
  case 0x1cf40a: // 0160:1cf40a
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    if (r16[ax] == 0x0016)
        { pc = 0x1cf45c; break; }
    if (r16[ax] == 0x0017)
        { pc = 0x1cf45c; break; }
    if (r16[ax] == 0x0018)
        { pc = 0x1cf45c; break; }
  case 0x1cf422: // 0160:1cf422
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee9d, memoryAGet16(ds, 0x20ee9d) + r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20ee9d)) < signed16(0x000c))
        { pc = 0x1cf448; break; }
    memoryASet16(ds, 0x20ee9d, memoryAGet16(ds, 0x20ee9d) - 0x000c);
  case 0x1cf448: // 0160:1cf448
    r16[ax] = memoryAGet16(ds, 0x20ee9d);
    r16[ax] += 0x00dd;
    yield* sub_1b1715();
    { pc = 0x1cf491; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1cf45c: // 0160:1cf45c
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee9d, memoryAGet16(ds, 0x20ee9d) + r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20ee9d)) < signed16(0x000c))
        { pc = 0x1cf482; break; }
    memoryASet16(ds, 0x20ee9d, memoryAGet16(ds, 0x20ee9d) - 0x000c);
  case 0x1cf482: // 0160:1cf482
    r16[ax] = memoryAGet16(ds, 0x20ee9d);
    r16[ax] += 0x010c;
    yield* sub_1b1715();
  case 0x1cf491: // 0160:1cf491
    r8[al] = 0x4d;
    { pc = 0x1b17b7; break; }
  case 0x1cf498: // 0160:1cf498
    if (r16[bp] == 0x002f)
        { pc = 0x1cf4a4; break; }
    if (r16[bp] != 0x003c)
        { pc = 0x1cf51a; break; }
  case 0x1cf4a4: // 0160:1cf4a4
    if (!(memoryAGet16(ds, 0x20edfd) & 0xffff))
        { pc = 0x1cf513; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    if (r16s[ax] <= signed16(0x000a))
        { pc = 0x1cf4d7; break; }
    if (r16s[ax] >= signed16(0x0013))
        { pc = 0x1cf4d7; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x1cf4d7; break; }
    r16[ax] = 0x0119;
    yield* sub_1b1715();
    { pc = 0x1cf50c; break; }
  case 0x1cf4d7: // 0160:1cf4d7
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] |= 0x0001;
    memoryASet16(ds, 0x20ee9d, memoryAGet16(ds, 0x20ee9d) + r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20ee9d)) < signed16(0x000c))
        { pc = 0x1cf4fd; break; }
    memoryASet16(ds, 0x20ee9d, memoryAGet16(ds, 0x20ee9d) - 0x000c);
  case 0x1cf4fd: // 0160:1cf4fd
    r16[ax] = memoryAGet16(ds, 0x20ee9d);
    r16[ax] += 0x00e9;
    yield* sub_1b1715();
  case 0x1cf50c: // 0160:1cf50c
    r8[al] = 0x86;
    { pc = 0x1b17b7; break; }
  case 0x1cf513: // 0160:1cf513
    r8[al] = 0x58;
    { pc = 0x1b17b7; break; }
  case 0x1cf51a: // 0160:1cf51a
    if (r16[bp] == 0x0043)
        { pc = 0x1cf526; break; }
    if (r16[bp] != 0x0035)
        { pc = 0x1cf537; break; }
  case 0x1cf526: // 0160:1cf526
    if (signed16(memoryAGet16(ds, 0x20c830)) <= signed16(0x0032))
        { pc = 0x1cf537; break; }
    r8[al] = 0x59;
    { pc = 0x1b17b7; break; }
  case 0x1cf537: // 0160:1cf537
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cf538() // 0160:1cf538 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20cec3, 0x0000);
    if (r16s[bp] >= signed16(0x0020))
        { pc = 0x1cf585; break; }
    if (!(memoryAGet16(ds, 0x20d2c3) & 0xffff))
        { pc = 0x1cf585; break; }
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0008;
    if (r16[cx])
        { pc = 0x1cf585; break; }
    r16[ax] = 0x00c8;
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r32[esp] += 4; return;
  case 0x1cf585: // 0160:1cf585
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1cf7c6; break; }
    if (r16s[dx] <= signed16(0x001e))
        { pc = 0x1cf5d4; break; }
    r32[edx] = memoryAGet32(ds, 0x20d85d);
    if (r32[edx] == 0x00204b40)
        { pc = 0x1cf5b0; break; }
    if (r32[edx] != 0x00204c84)
        { pc = 0x1cf5d4; break; }
  case 0x1cf5b0: // 0160:1cf5b0
    r16[dx] = memoryAGet16(ds, 0x20c830);
    r16[dx] >>>= 2;
    r16[dx] &= 0x0001;
    r16[ax] += r16[dx];
    r16[dx] = memoryAGet16(ds, 0x20c830);
    r16[dx] >>>= 3;
    r16[dx] &= 0x0001;
    r16[bx] += r16[dx];
  case 0x1cf5d4: // 0160:1cf5d4
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r16[dx] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20ceb7, r16[dx]);
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) >> 1);
    r16[ax] += 0x0080;
    r16[ax] -= memoryAGet16(ds, 0x20e805);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1cf61f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1cf6b9; break; }
  case 0x1cf61f: // 0160:1cf61f
    r16[bx] += 0x0080;
    r16[bx] -= memoryAGet16(ds, 0x20e805);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1cf641; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1cf6b9; break; }
  case 0x1cf641: // 0160:1cf641
    if (r16[bx] >= 0x0190)
        { pc = 0x1cf6b9; break; }
    r32[esi] = memoryAGet32(ds, 0x20d82b);
    r32[ebp] &= 0x0000ffff;
    r16[bp] <<= 3;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ebp]);
    r16[cx] += memoryAGet16(ds, 0x20e801);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[ebp] + 0x6);
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1cf67b; break; }
    r16[dx] |= 0x0010;
  case 0x1cf67b: // 0160:1cf67b
    r16[ax] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x2);
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x4);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    memoryASet16(ds, 0x20cec7, r16[cx]);
    memoryASet16(ds, 0x20cec9, r16[dx]);
    if (!(memoryAGet16(ds, 0x20eda5) & 0xffff))
        { pc = 0x1cf6b9; break; }
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20cec3, 0x0001);
  case 0x1cf6b9: // 0160:1cf6b9
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    if (memoryAGet16(ds, 0x20eda5) & 0xffff)
        { pc = 0x1cf6d3; break; }
    memoryASet16(ds, 0x20ceb7, 0x0001);
  case 0x1cf6d3: // 0160:1cf6d3
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    memoryASet16(ds, 0x20e805, r16[ax]);
    r32[eax] = pop32();
    r16[dx] = memoryAGet16(ds, 0x20e805);
    if (!r16[dx])
        { pc = 0x1cf789; break; }
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    r16[ax] += 0x0084;
    r16[ax] += memoryAGet16(ds, 0x20e805);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1cf718; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1cf789; break; }
  case 0x1cf718: // 0160:1cf718
    r16[bx] += 0x0084;
    r16[bx] += memoryAGet16(ds, 0x20e805);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1cf736; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1cf789; break; }
  case 0x1cf736: // 0160:1cf736
    if (r16[bx] >= 0x0190)
        { pc = 0x1cf789; break; }
    if (r16s[bp] >= signed16(0x0020))
        { pc = 0x1cf789; break; }
    r16[cx] = memoryAGet16(ds, 0x20cec7);
    r16[dx] = memoryAGet16(ds, 0x20cec9);
    yield* sub_1b1a14();
    if (memoryAGet16(ds, 0x20cec3) != 0x0001)
        { pc = 0x1cf789; break; }
    push32(r32[esi]);
    r32[esi] = 0x0020c00c;
    r32[eax] = memoryAGet32(ds, 0x20c80c);
    r32[eax] -= 0x00000018;
    r32[esi] += r32[eax];
    r32[ecx] = 0x00000006;
  case 0x1cf775: // 0160:1cf775
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xc);
    memoryASet16(ds, r32[esi], r16[bx]);
    memoryASet16(ds, r32[esi] + 0xc, r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1cf775; break; }
    r32[esi] = pop32();
  case 0x1cf789: // 0160:1cf789
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    memoryASet16(ds, 0x20ceb7, r16[bx]);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20ceb9, r16[bx]);
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + r16[ax]);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + r16[ax]);
    r32[esp] += 4; return;
  case 0x1cf7c6: // 0160:1cf7c6
    r16[cx] = memoryAGet16(ds, 0x20cf23);
    r16[cx] &= 0xfffe;
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r16[dx] = memoryAGet16(ds, 0x20e805);
    memoryASet16(ds, 0x20ceb7, r16[dx]);
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ebp]);
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) >> 1);
    r16[ax] -= r16[cx];
    r16[ax] += 0x0078;
    r16[ax] -= memoryAGet16(ds, 0x20e805);
    if (r16s[ax] >= 0)
        { pc = 0x1cf819; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1cf8c0; break; }
  case 0x1cf819: // 0160:1cf819
    r16[ax] >>>= 1;
    r16[ax] += 0x003c;
    r16[cx] = memoryAGet16(ds, 0x20cf25);
    r16[cx] &= 0xfffe;
    r16[bx] -= r16[cx];
    r16[bx] += 0x0078;
    r16[bx] -= memoryAGet16(ds, 0x20e805);
    if (r16s[bx] >= 0)
        { pc = 0x1cf845; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1cf8c0; break; }
  case 0x1cf845: // 0160:1cf845
    r16[bx] >>>= 1;
    r16[bx] += 0x003c;
    if (r16[bx] >= 0x0190)
        { pc = 0x1cf8c0; break; }
    r32[esi] = memoryAGet32(ds, 0x20d82b);
    r32[ebp] &= 0x0000ffff;
    r16[bp] <<= 3;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ebp]);
    r16[cx] += memoryAGet16(ds, 0x20e801);
    r16[dx] = memoryAGet16(ds, r32[esi] + r32[ebp] + 0x6);
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1cf882; break; }
    r16[dx] |= 0x0010;
  case 0x1cf882: // 0160:1cf882
    r16[ax] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x2);
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[ebp] + 0x4);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    memoryASet16(ds, 0x20cec7, r16[cx]);
    memoryASet16(ds, 0x20cec9, r16[dx]);
    if (!(memoryAGet16(ds, 0x20eda5) & 0xffff))
        { pc = 0x1cf8c0; break; }
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20cec3, 0x0001);
  case 0x1cf8c0: // 0160:1cf8c0
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    if (memoryAGet16(ds, 0x20eda5) & 0xffff)
        { pc = 0x1cf8d6; break; }
    memoryASet16(ds, 0x20ceb7, 0x0001);
  case 0x1cf8d6: // 0160:1cf8d6
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    memoryASet16(ds, 0x20e805, r16[ax]);
    r32[eax] = pop32();
    r16[dx] = memoryAGet16(ds, 0x20e805);
    if (!r16[dx])
        { pc = 0x1cf99e; break; }
    r16[dx] >>>= 2;
    memoryASet16(ds, 0x20e805, memoryAGet16(ds, 0x20e805) - r16[dx]);
    r16[ax] += 0x0084;
    r16[ax] += memoryAGet16(ds, 0x20e805);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1cf91f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1cf99e; break; }
  case 0x1cf91f: // 0160:1cf91f
    r16[ax] >>>= 1;
    r16[ax] += 0x003c;
    r16[bx] += 0x0084;
    r16[bx] += memoryAGet16(ds, 0x20e805);
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1cf944; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1cf99e; break; }
  case 0x1cf944: // 0160:1cf944
    r16[bx] >>>= 1;
    r16[bx] += 0x003c;
    if (r16[bx] >= 0x0190)
        { pc = 0x1cf99e; break; }
    if (r16s[bp] >= signed16(0x0020))
        { pc = 0x1cf99e; break; }
    r16[cx] = memoryAGet16(ds, 0x20cec7);
    r16[dx] = memoryAGet16(ds, 0x20cec9);
    yield* sub_1b1a14();
    if (memoryAGet16(ds, 0x20cec3) != 0x0001)
        { pc = 0x1cf99e; break; }
    push32(r32[esi]);
    r32[esi] = 0x0020c00c;
    r32[eax] = memoryAGet32(ds, 0x20c80c);
    r32[eax] -= 0x00000018;
    r32[esi] += r32[eax];
    r32[ecx] = 0x00000006;
  case 0x1cf98a: // 0160:1cf98a
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xc);
    memoryASet16(ds, r32[esi], r16[bx]);
    memoryASet16(ds, r32[esi] + 0xc, r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1cf98a; break; }
    r32[esi] = pop32();
  case 0x1cf99e: // 0160:1cf99e
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    memoryASet16(ds, 0x20ceb7, r16[bx]);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    memoryASet16(ds, 0x20ceb9, r16[bx]);
    memoryASet16(ds, 0x20ceb5, memoryAGet16(ds, 0x20ceb5) + r16[ax]);
    r16[ax] >>>= 1;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1cf9db() // 0160:1cf9db +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cf9db; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 122875 bytes // gap 122875 bytes
  case 0x1cf9db: // 0160:1cf9db
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1cfae1; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] &= 0x00ff;
    if (r16[ax])
        { pc = 0x1cfa00; break; }
    if (!(memoryAGet16(ds, 0x20d081) & 0xffff))
        { pc = 0x1cfa4d; break; }
  case 0x1cfa00: // 0160:1cfa00
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    r16[ax] &= 0x00ff;
    if (r16[ax])
        { pc = 0x1cfa17; break; }
    if (!(memoryAGet16(ds, 0x20d083) & 0xffff))
        { pc = 0x1cfa4d; break; }
  case 0x1cfa17: // 0160:1cfa17
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    r16[ax] &= 0x00ff;
    if (r16[ax])
        { pc = 0x1cfa2e; break; }
    if (!(memoryAGet16(ds, 0x20d085) & 0xffff))
        { pc = 0x1cfa4d; break; }
  case 0x1cfa2e: // 0160:1cfa2e
    r16[ax] = memoryAGet16(ds, 0x20d051);
    r16[ax] &= 0x00ff;
    if (r16[ax])
        { pc = 0x1cfae1; break; }
    if (memoryAGet16(ds, 0x20d081) & 0xffff)
        { pc = 0x1cfae1; break; }
  case 0x1cfa4d: // 0160:1cfa4d
    if (memoryAGet16(ds, 0x20ce93) == 0x0004)
        { pc = 0x1cfacd; break; }
    if (memoryAGet16(ds, 0x20ce93) >= 0x0004)
        { pc = 0x1cfa93; break; }
    memoryASet16(ds, 0x20d081, 0x0000);
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1cfae1; break; }
    memoryASet16(ds, 0x20d7b7, 0x0002);
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1cfae1; break; }
  case 0x1cfa93: // 0160:1cfa93
    memoryASet16(ds, 0x20d081, 0x0000);
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1cfae1; break; }
    memoryASet16(ds, 0x20d7b7, 0x0001);
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf87, 0x0034);
    { pc = 0x1cfae1; break; }
  case 0x1cfacd: // 0160:1cfacd
    if (memoryAGet16(ds, 0x20d7b5) & 0xffff)
        { pc = 0x1cfae1; break; }
    memoryASet16(ds, 0x20d7b5, 0x0001);
  case 0x1cfae1: // 0160:1cfae1
    r16[bx] = 0x00a8;
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1cfafa; break; }
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cfafe; break; }
  case 0x1cfafa: // 0160:1cfafa
    r16[bx] = 0x0096;
  case 0x1cfafe: // 0160:1cfafe
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] += 0x004c;
    r16[cx] = 0x001c;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    yield* sub_1b19ac();
    r16[bx] = 0x00b2;
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1cfb32; break; }
    if (!(memoryAGet16(ds, 0x20d89f) & 0xffff))
        { pc = 0x1cfb36; break; }
  case 0x1cfb32: // 0160:1cfb32
    r16[bx] = 0x00a0;
  case 0x1cfb36: // 0160:1cfb36
    r16[ax] = memoryAGet16(ds, 0x20ee53);
    r16[ax] += 0x0044;
    r16[cx] = memoryAGet16(ds, 0x20d081);
    if (!r16[cx])
        { pc = 0x1cfb5d; break; }
    if (memoryAGet16(ds, 0x20ede7) & 0xffff)
        { pc = 0x1cfb5d; break; }
    if (r16[cx] != 0x0001)
        { pc = 0x1cfb6a; break; }
  case 0x1cfb5d: // 0160:1cfb5d
    r16[dx] = memoryAGet16(ds, 0x20c830);
    r16[dx] &= 0x0010;
    if (r16[dx])
        { pc = 0x1cfb7b; break; }
  case 0x1cfb6a: // 0160:1cfb6a
    r16[cx] += 0x0005;
    r16[dx] = 0x0010;
    r16[bx] += 0x0008;
    { pc = 0x1b19ac; break; }
  case 0x1cfb7b: // 0160:1cfb7b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cfb7c() // 0160:1cfb7c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cfb7c; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 123292 bytes // gap 123292 bytes
  case 0x1cfb7c: // 0160:1cfb7c
    if (!(memoryAGet16(ds, 0x20d79f) & 0xffff))
        { pc = 0x1cfbce; break; }
    memoryASet16(ds, 0x20d79f, memoryAGet16(ds, 0x20d79f) - 0x0001);
    if (memoryAGet16(ds, 0x20d89b) & 0x0fff)
        { pc = 0x1cfbce; break; }
    r32[esi] = 0x0020d781;
    r16[ax] = 0x017c;
    r16[bx] = 0x00ce;
    yield* sub_1cfcb2();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] -= 0x0006;
    r16[cx] = 0x001e;
    r16[dx] = 0x0010;
    r16[ax] += 0x0014;
    yield* sub_1b19ac();
  case 0x1cfbce: // 0160:1cfbce
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1cfc7e; break; }
    if (!(memoryAGet16(ds, 0x20d89d) & 0xffff))
        { pc = 0x1cfbf6; break; }
    memoryASet16(ds, 0x20d89d, memoryAGet16(ds, 0x20d89d) - 0x0001);
    if (memoryAGet16(ds, 0x20d89d))
        { pc = 0x1cfc7e; break; }
  case 0x1cfbf6: // 0160:1cfbf6
    if (!(memoryAGet16(ds, 0x20d081) & 0xffff))
        { pc = 0x1cfc7e; break; }
    r8[bl] = 0x3c;
    r8[al] = memoryAGet(ds, 0x20d780);
    r8[al]++;
    if (r8[bl] != r8[al])
        { pc = 0x1cfc48; break; }
    r8[al] = memoryAGet(ds, 0x20d77d);
    r8[al]++;
    if (r8[al] != 0x0a)
        { pc = 0x1cfc41; break; }
    r8[al] = memoryAGet(ds, 0x20d77c);
    r8[al]++;
    if (r8[al] != 0x06)
        { pc = 0x1cfc3a; break; }
    r8[al] = memoryAGet(ds, 0x20d77b);
    if (r8[al] == 0x04)
        { pc = 0x1cfc7e; break; }
    memoryASet(ds, 0x20d77b, memoryAGet(ds, 0x20d77b) + 0x01);
    r8[al] = 0;
  case 0x1cfc3a: // 0160:1cfc3a
    memoryASet(ds, 0x20d77c, r8[al]);
    r8[al] = 0;
  case 0x1cfc41: // 0160:1cfc41
    memoryASet(ds, 0x20d77d, r8[al]);
    r8[al] = 0;
  case 0x1cfc48: // 0160:1cfc48
    memoryASet(ds, 0x20d780, r8[al]);
    r32[esi] = 0x00205080;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x20d780);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    { pc = 0x1cfc67; break; }
    // gap 9 bytes // gap 9 bytes
  case 0x1cfc67: // 0160:1cfc67
    r8[bl] = 0;
  case 0x1cfc69: // 0160:1cfc69
    if (r8s[al] < signed8(0x0a))
        { pc = 0x1cfc73; break; }
    r8[al] -= 0x0a;
    r8[bl]++;
    { pc = 0x1cfc69; break; }
  case 0x1cfc73: // 0160:1cfc73
    memoryASet(ds, 0x20d77f, r8[al]);
    memoryASet(ds, 0x20d77e, r8[bl]);
  case 0x1cfc7e: // 0160:1cfc7e
    r32[esi] = 0x0020d77b;
    r16[ax] = 0x017c;
    r16[bx] = 0x0096;
    yield* sub_1cfcb2();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += 0x0010;
    r16[bx] -= 0x0006;
    r16[cx] = 0x001d;
    r16[dx] = 0x0010;
    { pc = 0x1b19ac; break; }
    return;
  }
}
function* sub_1cfcb2() // 0160:1cfcb2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cfcb2; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 123602 bytes // gap 123602 bytes
  case 0x1cfcb2: // 0160:1cfcb2
    if (r16s[ax] < signed16(0x012c))
        { pc = 0x1cfcc3; break; }
    r16[ax] -= 0x0140;
    r16[ax] += memoryAGet16(ds, 0x20ee53);
  case 0x1cfcc3: // 0160:1cfcc3
    if (r16s[bx] < signed16(0x012c))
        { pc = 0x1cfcd6; break; }
    r16[bx] -= 0x00e0;
    r16[bx] += memoryAGet16(ds, 0x20ee55);
  case 0x1cfcd6: // 0160:1cfcd6
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, 0x20ceb7, r8[cl]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, 0x20ceb9, r8[cl]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    memoryASet(ds, 0x20cebb, r8[cl]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet(ds, 0x20cebd, r8[cl]);
    r32[ecx] = 0;
    r8[cl] = memoryAGet(ds, r32[esi]);
    r16[cx] += 0x0005;
    r16[dx] = 0x0010;
    r16[ax] += 0x0008;
    r16[bx] += 0x0008;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20ceb7);
    r16[cx] += 0x0005;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x001c;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[dx] = 0x0010;
    r16[bx] += 0x0008;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20ceb9);
    r16[cx] += 0x0005;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0028;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[dx] = 0x0010;
    r16[bx] += 0x0008;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20cebb);
    r16[cx] += 0x0010;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0030;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx]++;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20cebd);
    r16[cx] += 0x0010;
    r16[cx] &= 0x00fe;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0037;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx]++;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] += 0x0006;
    r16[ax] += 0x0010;
    r16[cx] = 0x000f;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    { pc = 0x1b19ac; break; }
    return;
  }
}
function* sub_1cfdfb() // 0160:1cfdfb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cfdfb; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 123550 bytes // gap 123550 bytes
  case 0x1cfc7e: // 0160:1cfc7e
    r32[esi] = 0x0020d77b;
    r16[ax] = 0x017c;
    r16[bx] = 0x0096;
    yield* sub_1cfcb2();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += 0x0010;
    r16[bx] -= 0x0006;
    r16[cx] = 0x001d;
    r16[dx] = 0x0010;
    { pc = 0x1b19ac; break; }
    // gap 329 bytes // gap 329 bytes
  case 0x1cfdfb: // 0160:1cfdfb
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1cfc7e; break; }
    if (memoryAGet16(ds, 0x20d87d) & 0xffff)
        { pc = 0x1cfc7e; break; }
    r16[bx] = 0x003c;
    r8[al] = memoryAGet(ds, 0x20d780);
    r8[al]--;
    if (r8s[al] >= 0)
        { pc = 0x1cfe82; break; }
    r8[al] = memoryAGet(ds, 0x20d77d);
    r8[al]--;
    if (r8s[al] >= 0)
        { pc = 0x1cfe77; break; }
    r8[al] = memoryAGet(ds, 0x20d77c);
    r8[al]--;
    if (r8s[al] >= 0)
        { pc = 0x1cfe70; break; }
    r8[al] = memoryAGet(ds, 0x20d77b);
    if (r8[al])
        { pc = 0x1cfe67; break; }
    if (memoryAGet16(ds, 0x20d7a3) & 0xffff)
        { pc = 0x1cfc7e; break; }
    memoryASet16(ds, 0x20d7a3, 0x0001);
    memoryASet16(ds, 0x20d87f, 0x0001);
    { pc = 0x1cfc7e; break; }
  case 0x1cfe67: // 0160:1cfe67
    memoryASet(ds, 0x20d77b, memoryAGet(ds, 0x20d77b) - 0x01);
    r8[al] = 0x05;
  case 0x1cfe70: // 0160:1cfe70
    memoryASet(ds, 0x20d77c, r8[al]);
    r8[al] = 0x09;
  case 0x1cfe77: // 0160:1cfe77
    memoryASet(ds, 0x20d77d, r8[al]);
    r16[ax] = 0x003c;
    r16[ax]--;
  case 0x1cfe82: // 0160:1cfe82
    memoryASet(ds, 0x20d780, r8[al]);
    r32[esi] = 0x00205080;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x20d780);
    r8[al] = memoryAGet(ds, r32[esi] + r32[eax]);
    { pc = 0x1cfe9f; break; }
    // gap 7 bytes // gap 7 bytes
  case 0x1cfe9f: // 0160:1cfe9f
    r8[bl] = 0;
  case 0x1cfea1: // 0160:1cfea1
    if (r8s[al] < signed8(0x0a))
        { pc = 0x1cfeab; break; }
    r8[al] -= 0x0a;
    r8[bl]++;
    { pc = 0x1cfea1; break; }
  case 0x1cfeab: // 0160:1cfeab
    memoryASet(ds, 0x20d77f, r8[al]);
    memoryASet(ds, 0x20d77e, r8[bl]);
    { pc = 0x1cfc7e; break; }
    return;
  }
}
function* sub_1cfebb() // 0160:1cfebb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d2c3) & 0xffff)
        { pc = 0x1cfee3; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0004)
        { pc = 0x1cff9a; break; }
    if (memoryAGet16(ds, 0x20d7f9) == 0x0100)
        { pc = 0x1cff9a; break; }
  case 0x1cfee3: // 0160:1cfee3
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1cff9a; break; }
    r16[ax] = memoryAGet16(ds, 0x20d05d);
    r16[ax] += memoryAGet16(ds, 0x20d05f);
    r16[ax] += memoryAGet16(ds, 0x20d061);
    r16[ax] += memoryAGet16(ds, 0x20d063);
    memoryASet16(ds, 0x20cec5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r32[esi] = 0x0020d251;
    r16[bp] = 0x0008;
  case 0x1cff2c: // 0160:1cff2c
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r16[ax])
        { pc = 0x1cff93; break; }
    r16[ax] += memoryAGet16(ds, 0x20ceb3);
    if (r16[ax] != 0x0005)
        { pc = 0x1cff48; break; }
    memoryASet16(ds, r32[esi], 0x0000);
    { pc = 0x1cff93; break; }
  case 0x1cff48: // 0160:1cff48
    memoryASet16(ds, r32[esi], r16[ax]);
    if (memoryAGet16(ds, 0x20cec5) & 0xffff)
        { pc = 0x1cff93; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] += 0x0080;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] < 0)
        { pc = 0x1cff93; break; }
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[bx] += 0x0080;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] < 0)
        { pc = 0x1cff93; break; }
    if (r16s[bx] >= signed16(0x0190))
        { pc = 0x1cff93; break; }
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi]);
    r16[cx] += 0x006b;
    push32(r32[ebp]);
    push32(r32[esi]);
    yield* sub_1b19e0();
    r32[esi] = pop32();
    r32[ebp] = pop32();
  case 0x1cff93: // 0160:1cff93
    r32[esi] += 0x00000006;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1cff2c; break; }
  case 0x1cff9a: // 0160:1cff9a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1cff9b() // 0160:1cff9b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1cff9b; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 124347 bytes // gap 124347 bytes
  case 0x1cff9b: // 0160:1cff9b
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d01bb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a3);
    if (r16s[ax] <= signed16(0x0032))
        { pc = 0x1d0059; break; }
    if (r16s[ax] <= signed16(0x004b))
        { pc = 0x1cffc9; break; }
    memoryASet16(ds, 0x20ee47, 0x0001);
  case 0x1cffc9: // 0160:1cffc9
    if (memoryAGet16(ds, 0x20d1f9) & 0xffff)
        { pc = 0x1cfff9; break; }
    r16[ax] = 0x0001;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d16d;
  case 0x1cffe2: // 0160:1cffe2
    if (memoryAGet16(ds, r32[esi]) == 0x0002)
        { pc = 0x1cfff3; break; }
    r32[esi] += 0x00000002;
    r16[ax]++;
    if (--r32[ecx])
        { pc = 0x1cffe2; break; }
    { pc = 0x1cfff9; break; }
  case 0x1cfff3: // 0160:1cfff3
    memoryASet16(ds, 0x20d1f9, r16[ax]);
  case 0x1cfff9: // 0160:1cfff9
    if (memoryAGet16(ds, 0x20d1fb) & 0xffff)
        { pc = 0x1d0029; break; }
    r16[ax] = 0x0001;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d16d;
  case 0x1d0012: // 0160:1d0012
    if (memoryAGet16(ds, r32[esi]) == 0x0004)
        { pc = 0x1d0023; break; }
    r32[esi] += 0x00000002;
    r16[ax]++;
    if (--r32[ecx])
        { pc = 0x1d0012; break; }
    { pc = 0x1d0029; break; }
  case 0x1d0023: // 0160:1d0023
    memoryASet16(ds, 0x20d1fb, r16[ax]);
  case 0x1d0029: // 0160:1d0029
    if (memoryAGet16(ds, 0x20d1fd) & 0xffff)
        { pc = 0x1d0059; break; }
    r16[ax] = 0x0001;
    r32[ecx] = 0x00000004;
    r32[esi] = 0x0020d16d;
  case 0x1d0042: // 0160:1d0042
    if (memoryAGet16(ds, r32[esi]) == 0x0006)
        { pc = 0x1d0053; break; }
    r32[esi] += 0x00000002;
    r16[ax]++;
    if (--r32[ecx])
        { pc = 0x1d0042; break; }
    { pc = 0x1d0059; break; }
  case 0x1d0053: // 0160:1d0053
    memoryASet16(ds, 0x20d1fd, r16[ax]);
  case 0x1d0059: // 0160:1d0059
    if (!(memoryAGet16(ds, 0x20d1f7) & 0xffff))
        { pc = 0x1d01bb; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d01bb; break; }
    r16[ax] = 0x00aa;
    r16[bx] = 0x0094;
    r16[dx] = 0x0010;
    r16[cx] = 0x0006;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20d1f7);
    r16[cx] = 0x0006;
    yield* sub_1d01bc();
    if (!(memoryAGet16(ds, 0x20d1f9) & 0xffff))
        { pc = 0x1d01bb; break; }
    r16[ax] = 0x00aa;
    r16[bx] = 0x00a6;
    r16[dx] = 0x0010;
    r16[cx] = 0x0007;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20d1f9);
    r16[cx] = 0x0007;
    yield* sub_1d01bc();
    if (memoryAGet16(ds, 0x20edfb) & 0xffff)
        { pc = 0x1d00ed; break; }
    if (memoryAGet16(ds, 0x20d7a3) & 0xffff)
        { pc = 0x1d00ed; break; }
    memoryASet16(ds, 0x20d7a3, 0x0001);
  case 0x1d00ed: // 0160:1d00ed
    if (!(memoryAGet16(ds, 0x20d1fb) & 0xffff))
        { pc = 0x1d01bb; break; }
    if (memoryAGet16(ds, 0x20d1fb) == 0x0001)
        { pc = 0x1d0110; break; }
    if (memoryAGet16(ds, 0x20d1fd) != 0x0001)
        { pc = 0x1d0154; break; }
  case 0x1d0110: // 0160:1d0110
    if (memoryAGet16(ds, 0x20ee8d) == 0x00ff)
        { pc = 0x1d0154; break; }
    if (memoryAGet16(ds, 0x20d7b9) != 0x0010)
        { pc = 0x1d0139; break; }
    memoryASet16(ds, 0x20ee8d, 0x00ff);
    r16[ax] = 0x0127;
    yield* sub_1b1715();
    { pc = 0x1d0154; break; }
  case 0x1d0139: // 0160:1d0139
    memoryASet16(ds, 0x20ee8d, 0x00ff);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x0128;
    yield* sub_1b1715();
  case 0x1d0154: // 0160:1d0154
    r16[ax] = 0x00aa;
    r16[bx] = 0x00b8;
    r16[dx] = 0x0010;
    r16[cx] = 0x0008;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20d1fb);
    r16[cx] = 0x0008;
    yield* sub_1d01bc();
    if (memoryAGet16(ds, 0x20d7a3) & 0xffff)
        { pc = 0x1d018c; break; }
    memoryASet16(ds, 0x20d7a3, 0x0001);
  case 0x1d018c: // 0160:1d018c
    if (!(memoryAGet16(ds, 0x20d1fd) & 0xffff))
        { pc = 0x1d01bb; break; }
    r16[ax] = 0x00aa;
    r16[bx] = 0x00ca;
    r16[dx] = 0x0010;
    r16[cx] = 0x0009;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20d1fd);
    r16[cx] = 0x0009;
    { pc = 0x1d01bc; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d01bb: // 0160:1d01bb
    r32[esp] += 4; return;
  case 0x1d01bc: // 0160:1d01bc
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1d0260; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d020a; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d01fb; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d01ec; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    { pc = 0x1d0217; break; }
  case 0x1d01ec: // 0160:1d01ec
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    { pc = 0x1d0217; break; }
  case 0x1d01fb: // 0160:1d01fb
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    { pc = 0x1d0217; break; }
  case 0x1d020a: // 0160:1d020a
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
  case 0x1d0217: // 0160:1d0217
    r16[ax] += 0x00a6;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d0231; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d0260; break; }
  case 0x1d0231: // 0160:1d0231
    r16[bx] += 0x0090;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d024c; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d0260; break; }
  case 0x1d024c: // 0160:1d024c
    if (r16[bx] >= 0x0190)
        { pc = 0x1d0260; break; }
    r16[dx] = 0x0010;
    { pc = 0x1b19ac; break; }
  case 0x1d0260: // 0160:1d0260
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d01bc() // 0160:1d01bc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d01bc; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 124892 bytes // gap 124892 bytes
  case 0x1d01bc: // 0160:1d01bc
    if (memoryAGet16(ds, 0x20d867) & 0xffff)
        { pc = 0x1d0260; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d020a; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d01fb; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d01ec; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    { pc = 0x1d0217; break; }
  case 0x1d01ec: // 0160:1d01ec
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    { pc = 0x1d0217; break; }
  case 0x1d01fb: // 0160:1d01fb
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    { pc = 0x1d0217; break; }
  case 0x1d020a: // 0160:1d020a
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
  case 0x1d0217: // 0160:1d0217
    r16[ax] += 0x00a6;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d0231; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d0260; break; }
  case 0x1d0231: // 0160:1d0231
    r16[bx] += 0x0090;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d024c; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d0260; break; }
  case 0x1d024c: // 0160:1d024c
    if (r16[bx] >= 0x0190)
        { pc = 0x1d0260; break; }
    r16[dx] = 0x0010;
    { pc = 0x1b19ac; break; }
  case 0x1d0260: // 0160:1d0260
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d0261() // 0160:1d0261 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[cx])
        { pc = 0x1d03db; break; }
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088d4;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    if (r16[ax] != 0x0196)
        { pc = 0x1d029a; break; }
    r16[ax] -= 0x0140;
    r16[ax] += memoryAGet16(ds, 0x20ee53);
  case 0x1d029a: // 0160:1d029a
    if (r16[bx] != 0x0144)
        { pc = 0x1d02ad; break; }
    r16[bx] -= 0x00e0;
    r16[bx] += memoryAGet16(ds, 0x20ee55);
  case 0x1d02ad: // 0160:1d02ad
    r16[cx] = 0x0009;
    r16[dx] = 0x0010;
    r16[ax] += 0x0008;
    yield* sub_1b19ac();
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7ad);
    if (!r16[cx])
        { pc = 0x1d03db; break; }
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088d4;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    if (r16[ax] != 0x0196)
        { pc = 0x1d02f7; break; }
    r16[ax] -= 0x0140;
    r16[ax] += memoryAGet16(ds, 0x20ee53);
  case 0x1d02f7: // 0160:1d02f7
    if (r16[bx] != 0x0144)
        { pc = 0x1d030a; break; }
    r16[bx] -= 0x00e0;
    r16[bx] += memoryAGet16(ds, 0x20ee55);
  case 0x1d030a: // 0160:1d030a
    r16[cx] = 0x0008;
    r16[dx] = 0x0010;
    r16[ax] += 0x0008;
    yield* sub_1b19ac();
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7af);
    if (!r16[cx])
        { pc = 0x1d03db; break; }
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088d4;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    if (r16[ax] != 0x0196)
        { pc = 0x1d0354; break; }
    r16[ax] -= 0x0140;
    r16[ax] += memoryAGet16(ds, 0x20ee53);
  case 0x1d0354: // 0160:1d0354
    if (r16[bx] != 0x0144)
        { pc = 0x1d0367; break; }
    r16[bx] -= 0x00e0;
    r16[bx] += memoryAGet16(ds, 0x20ee55);
  case 0x1d0367: // 0160:1d0367
    r16[cx] = 0x0007;
    r16[dx] = 0x0010;
    r16[ax] += 0x0008;
    yield* sub_1b19ac();
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7ab);
    if (!r16[cx])
        { pc = 0x1d03db; break; }
    if (r16s[cx] < signed16(0x0005))
        { pc = 0x1d0390; break; }
    r16[cx] -= 0x0004;
  case 0x1d0390: // 0160:1d0390
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088d4;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    if (r16[ax] != 0x0196)
        { pc = 0x1d03b7; break; }
    r16[ax] -= 0x0140;
    r16[ax] += memoryAGet16(ds, 0x20ee53);
  case 0x1d03b7: // 0160:1d03b7
    if (r16[bx] != 0x0144)
        { pc = 0x1d03ca; break; }
    r16[bx] -= 0x00e0;
    r16[bx] += memoryAGet16(ds, 0x20ee55);
  case 0x1d03ca: // 0160:1d03ca
    r16[cx] = 0x0006;
    r16[dx] = 0x0010;
    r16[ax] += 0x0008;
    yield* sub_1b19ac();
  case 0x1d03db: // 0160:1d03db
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d03dc() // 0160:1d03dc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d03dc; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 125436 bytes // gap 125436 bytes
  case 0x1d03dc: // 0160:1d03dc
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[cx])
        { pc = 0x1d04a0; break; }
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088c8;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    r16[cx] = 0x0008;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20d7ab);
    if (!r16[ax])
        { pc = 0x1d04a0; break; }
    r16[bx] = memoryAGet16(ds, 0x20d7a9);
    r32[ecx] = 0x00000001;
    if (r16[ax] == 0x0001)
        { pc = 0x1d0438; break; }
    if (r16[bx] != 0x0001)
        { pc = 0x1d044c; break; }
  case 0x1d0438: // 0160:1d0438
    r16[cx] = 0x0002;
    if (r16[ax] == 0x0002)
        { pc = 0x1d0448; break; }
    if (r16[bx] != 0x0002)
        { pc = 0x1d044c; break; }
  case 0x1d0448: // 0160:1d0448
    r16[cx] = 0x0003;
  case 0x1d044c: // 0160:1d044c
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088c8;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    r16[cx] = 0x0007;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d7ab);
    if (!r16[cx])
        { pc = 0x1d04a0; break; }
    r16[cx]--;
    r16[cx] <<= 2;
    r32[esi] = 0x002088c8;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    r16[cx] = 0x0006;
    r16[dx] = 0x0010;
    { pc = 0x1b19ac; break; }
  case 0x1d04a0: // 0160:1d04a0
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d04a1() // 0160:1d04a1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] == 0x0001)
        { pc = 0x1d04cb; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d0c95; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d097c; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1d04cc; break; }
  case 0x1d04cb: // 0160:1d04cb
    r32[esp] += 4; return;
  case 0x1d04cc: // 0160:1d04cc
    r16[bx] = memoryAGet16(ds, 0x20d7a5);
    if (!r16[bx])
        { pc = 0x1d091d; break; }
    if (memoryAGet16(ds, 0x20d7a5) != 0x0259)
        { pc = 0x1d050a; break; }
    memoryASet16(ds, 0x20ee31, memoryAGet16(ds, 0x20ee31) + 0x0001);
    r32[esi] = 0x0020cf85;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    r16[ax] <<= 1;
    memoryASet16(ds, r32[esi] + r32[eax], 0x0034);
    { pc = 0x1d091d; break; }
  case 0x1d050a: // 0160:1d050a
    if (memoryAGet16(ds, 0x20d7a5) != 0x02bd)
        { pc = 0x1d07c5; break; }
    r16[ax] = 0x0033;
    r32[esi] = 0x0020cf73;
    r32[edi] = 0x0020cf85;
    r32[ecx] = 0x00000008;
  case 0x1d052c: // 0160:1d052c
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1d052c; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7ad);
    if (r16[ax] == 0x0001)
        { pc = 0x1d0570; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d0566; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d055c; break; }
    memoryASet16(ds, 0x20ce9b, memoryAGet16(ds, 0x20ce9b) - 0x0001);
    { pc = 0x1d0578; break; }
  case 0x1d055c: // 0160:1d055c
    memoryASet16(ds, 0x20ce99, memoryAGet16(ds, 0x20ce99) - 0x0001);
    { pc = 0x1d0578; break; }
  case 0x1d0566: // 0160:1d0566
    memoryASet16(ds, 0x20ce97, memoryAGet16(ds, 0x20ce97) - 0x0001);
    { pc = 0x1d0578; break; }
  case 0x1d0570: // 0160:1d0570
    memoryASet16(ds, 0x20ce95, memoryAGet16(ds, 0x20ce95) - 0x0001);
  case 0x1d0578: // 0160:1d0578
    r16[ax] = memoryAGet16(ds, 0x20d7af);
    if (r16[ax] == 0x0001)
        { pc = 0x1d05cc; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d05b8; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d05a4; break; }
    if (memoryAGet16(ds, 0x20ce9b) == 0x000b)
        { pc = 0x1d05de; break; }
    memoryASet16(ds, 0x20ce9b, memoryAGet16(ds, 0x20ce9b) + 0x0001);
    { pc = 0x1d05de; break; }
  case 0x1d05a4: // 0160:1d05a4
    if (memoryAGet16(ds, 0x20ce99) == 0x000b)
        { pc = 0x1d05de; break; }
    memoryASet16(ds, 0x20ce99, memoryAGet16(ds, 0x20ce99) + 0x0001);
    { pc = 0x1d05de; break; }
  case 0x1d05b8: // 0160:1d05b8
    if (memoryAGet16(ds, 0x20ce97) == 0x000b)
        { pc = 0x1d05de; break; }
    memoryASet16(ds, 0x20ce97, memoryAGet16(ds, 0x20ce97) + 0x0001);
    { pc = 0x1d05de; break; }
  case 0x1d05cc: // 0160:1d05cc
    if (memoryAGet16(ds, 0x20ce95) == 0x000b)
        { pc = 0x1d05de; break; }
    memoryASet16(ds, 0x20ce95, memoryAGet16(ds, 0x20ce95) + 0x0001);
  case 0x1d05de: // 0160:1d05de
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (r16[ax] == 0x0001)
        { pc = 0x1d0614; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d060a; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d0600; break; }
    memoryASet16(ds, 0x20ce9b, memoryAGet16(ds, 0x20ce9b) - 0x0002);
    { pc = 0x1d061c; break; }
  case 0x1d0600: // 0160:1d0600
    memoryASet16(ds, 0x20ce99, memoryAGet16(ds, 0x20ce99) - 0x0002);
    { pc = 0x1d061c; break; }
  case 0x1d060a: // 0160:1d060a
    memoryASet16(ds, 0x20ce97, memoryAGet16(ds, 0x20ce97) - 0x0002);
    { pc = 0x1d061c; break; }
  case 0x1d0614: // 0160:1d0614
    memoryASet16(ds, 0x20ce95, memoryAGet16(ds, 0x20ce95) - 0x0002);
  case 0x1d061c: // 0160:1d061c
    r16[ax] = memoryAGet16(ds, 0x20d7ab);
    if (r16[ax] == 0x0004)
        { pc = 0x1d071e; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d06d4; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d068a; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r32[ebx] = memoryAGet32(ds, 0x20d0b7);
    r32[ecx] = memoryAGet32(ds, 0x20d0bb);
    r16[dx] = memoryAGet16(ds, 0x20d081);
    r32[ebp] = memoryAGet32(ds, 0x20d093);
    memoryASet32(ds, 0x20e7fd, r32[ebp]);
    yield* sub_1d091e();
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1d067d; break; }
    memoryASet16(ds, 0x20ce95, memoryAGet16(ds, 0x20ce95) + 0x0002);
  case 0x1d067d: // 0160:1d067d
    memoryASet16(ds, 0x20ce93, memoryAGet16(ds, 0x20ce93) + 0x0001);
    { pc = 0x1d0763; break; }
  case 0x1d068a: // 0160:1d068a
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    r32[ebx] = memoryAGet32(ds, 0x20d0bf);
    r32[ecx] = memoryAGet32(ds, 0x20d0c3);
    r16[dx] = memoryAGet16(ds, 0x20d083);
    r32[ebp] = memoryAGet32(ds, 0x20d097);
    memoryASet32(ds, 0x20e7fd, r32[ebp]);
    yield* sub_1d091e();
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1d06c7; break; }
    memoryASet16(ds, 0x20ce97, memoryAGet16(ds, 0x20ce97) + 0x0002);
  case 0x1d06c7: // 0160:1d06c7
    memoryASet16(ds, 0x20ce93, memoryAGet16(ds, 0x20ce93) - 0x0001);
    { pc = 0x1d0763; break; }
  case 0x1d06d4: // 0160:1d06d4
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    r32[ebx] = memoryAGet32(ds, 0x20d0c7);
    r32[ecx] = memoryAGet32(ds, 0x20d0cb);
    r16[dx] = memoryAGet16(ds, 0x20d085);
    r32[ebp] = memoryAGet32(ds, 0x20d09b);
    memoryASet32(ds, 0x20e7fd, r32[ebp]);
    yield* sub_1d091e();
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1d0711; break; }
    memoryASet16(ds, 0x20ce99, memoryAGet16(ds, 0x20ce99) + 0x0002);
  case 0x1d0711: // 0160:1d0711
    memoryASet16(ds, 0x20ce93, memoryAGet16(ds, 0x20ce93) + 0x0001);
    { pc = 0x1d0763; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d071e: // 0160:1d071e
    r16[ax] = memoryAGet16(ds, 0x20d051);
    r32[ebx] = memoryAGet32(ds, 0x20d0cf);
    r32[ecx] = memoryAGet32(ds, 0x20d0d3);
    r16[dx] = memoryAGet16(ds, 0x20d087);
    r32[ebp] = memoryAGet32(ds, 0x20d09f);
    memoryASet32(ds, 0x20e7fd, r32[ebp]);
    yield* sub_1d091e();
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1d075b; break; }
    memoryASet16(ds, 0x20ce9b, memoryAGet16(ds, 0x20ce9b) + 0x0002);
  case 0x1d075b: // 0160:1d075b
    memoryASet16(ds, 0x20ce93, memoryAGet16(ds, 0x20ce93) - 0x0001);
  case 0x1d0763: // 0160:1d0763
    r16[ax] = 0x0001;
    r32[esi] = 0x0020d0ff;
    r32[edi] = 0x0020d111;
    r32[ecx] = 0x00000008;
  case 0x1d0776: // 0160:1d0776
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[esi] += 0x00000002;
    r32[edi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1d0776; break; }
    r16[bp] = 0;
    memoryASet16(ds, 0x20d7a5, r16[bp]);
    memoryASet16(ds, 0x20d7a9, r16[bp]);
    memoryASet16(ds, 0x20d7ad, r16[bp]);
    memoryASet16(ds, 0x20d7af, r16[bp]);
    r32[esi] = 0x0020d221;
    r32[ecx] = 0x00000008;
  case 0x1d07ad: // 0160:1d07ad
    memoryASet16(ds, r32[esi], 0x0000);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1d07ad; break; }
    memoryASet16(ds, 0x20d7b1, 0x000a);
    { pc = 0x1d091d; break; }
  case 0x1d07c5: // 0160:1d07c5
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    if (r16[ax])
        { pc = 0x1d0820; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d07f4; break; }
    memoryASet16(ds, 0x20cf85, r16[ax]);
  case 0x1d07f4: // 0160:1d07f4
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1d091d; break; }
    if (memoryAGet16(ds, 0x20d06f) & 0xffff)
        { pc = 0x1d091d; break; }
    memoryASet16(ds, 0x20d06f, 0x0014);
    { pc = 0x1d091d; break; }
  case 0x1d0820: // 0160:1d0820
    if (r16[ax] != 0x0001)
        { pc = 0x1d0876; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf75);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf75, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d084a; break; }
    memoryASet16(ds, 0x20cf87, r16[ax]);
  case 0x1d084a: // 0160:1d084a
    if (memoryAGet16(ds, 0x20d05f) & 0xffff)
        { pc = 0x1d091d; break; }
    if (memoryAGet16(ds, 0x20d071) & 0xffff)
        { pc = 0x1d091d; break; }
    memoryASet16(ds, 0x20d071, 0x0014);
    { pc = 0x1d091d; break; }
  case 0x1d0876: // 0160:1d0876
    if (r16[ax] != 0x0002)
        { pc = 0x1d08cc; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf77);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf77, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d08a0; break; }
    memoryASet16(ds, 0x20cf89, r16[ax]);
  case 0x1d08a0: // 0160:1d08a0
    if (memoryAGet16(ds, 0x20d061) & 0xffff)
        { pc = 0x1d091d; break; }
    if (memoryAGet16(ds, 0x20d073) & 0xffff)
        { pc = 0x1d091d; break; }
    memoryASet16(ds, 0x20d073, 0x0014);
    { pc = 0x1d091d; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d08cc: // 0160:1d08cc
    if (r16[ax] != 0x0003)
        { pc = 0x1d091d; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf79);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf79, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d08f6; break; }
    memoryASet16(ds, 0x20cf8b, r16[ax]);
  case 0x1d08f6: // 0160:1d08f6
    if (memoryAGet16(ds, 0x20d063) & 0xffff)
        { pc = 0x1d091d; break; }
    if (memoryAGet16(ds, 0x20d075) & 0xffff)
        { pc = 0x1d091d; break; }
    memoryASet16(ds, 0x20d075, 0x0014);
  case 0x1d091d: // 0160:1d091d
    r32[esp] += 4; return;
    // gap 94 bytes // gap 94 bytes
  case 0x1d097c: // 0160:1d097c
    r16[bx] = memoryAGet16(ds, 0x20d7a5);
    if (!r16[bx])
        { pc = 0x1d0c94; break; }
    if (memoryAGet16(ds, 0x20d7a5) != 0x0259)
        { pc = 0x1d09ba; break; }
    memoryASet16(ds, 0x20ee31, memoryAGet16(ds, 0x20ee31) + 0x0001);
    r32[esi] = 0x0020cf85;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    r16[ax] <<= 1;
    memoryASet16(ds, r32[esi] + r32[eax], 0x0034);
    { pc = 0x1d0c94; break; }
  case 0x1d09ba: // 0160:1d09ba
    if (memoryAGet16(ds, 0x20d7a5) != 0x02bd)
        { pc = 0x1d0ba3; break; }
    r16[ax] = 0x0033;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (r16[ax] == 0x0001)
        { pc = 0x1d0a23; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d0a19; break; }
    memoryASet16(ds, 0x20ce99, memoryAGet16(ds, 0x20ce99) + 0x0001);
    { pc = 0x1d0a2b; break; }
  case 0x1d0a19: // 0160:1d0a19
    memoryASet16(ds, 0x20ce97, memoryAGet16(ds, 0x20ce97) + 0x0001);
    { pc = 0x1d0a2b; break; }
  case 0x1d0a23: // 0160:1d0a23
    memoryASet16(ds, 0x20ce95, memoryAGet16(ds, 0x20ce95) + 0x0001);
  case 0x1d0a2b: // 0160:1d0a2b
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    if (r16[ax] == 0x0002)
        { pc = 0x1d0afd; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d0a9f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    memoryASet16(ds, 0x20d04d, r16[ax]);
    memoryASet16(ds, 0x20d04f, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0b7);
    memoryASet32(ds, 0x20d0bf, r32[eax]);
    memoryASet32(ds, 0x20d0c7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0bb);
    memoryASet32(ds, 0x20d0c3, r32[eax]);
    memoryASet32(ds, 0x20d0cb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d081);
    memoryASet16(ds, 0x20d083, r16[ax]);
    memoryASet16(ds, 0x20d085, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d093);
    memoryASet32(ds, 0x20d097, r32[eax]);
    memoryASet32(ds, 0x20d09b, r32[eax]);
    memoryASet16(ds, 0x20ce95, memoryAGet16(ds, 0x20ce95) - 0x0001);
    { pc = 0x1d0b5b; break; }
  case 0x1d0a9f: // 0160:1d0a9f
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    memoryASet16(ds, 0x20d04b, r16[ax]);
    memoryASet16(ds, 0x20d04f, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0bf);
    memoryASet32(ds, 0x20d0b7, r32[eax]);
    memoryASet32(ds, 0x20d0c7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0c3);
    memoryASet32(ds, 0x20d0bb, r32[eax]);
    memoryASet32(ds, 0x20d0cb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d083);
    memoryASet16(ds, 0x20d081, r16[ax]);
    memoryASet16(ds, 0x20d085, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d097);
    memoryASet32(ds, 0x20d093, r32[eax]);
    memoryASet32(ds, 0x20d09b, r32[eax]);
    memoryASet16(ds, 0x20ce97, memoryAGet16(ds, 0x20ce97) - 0x0001);
    { pc = 0x1d0b5b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d0afd: // 0160:1d0afd
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    memoryASet16(ds, 0x20d04d, r16[ax]);
    memoryASet16(ds, 0x20d04b, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d0c7);
    memoryASet32(ds, 0x20d0bf, r32[eax]);
    memoryASet32(ds, 0x20d0b7, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20d0cb);
    memoryASet32(ds, 0x20d0c3, r32[eax]);
    memoryASet32(ds, 0x20d0bb, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d085);
    memoryASet16(ds, 0x20d083, r16[ax]);
    memoryASet16(ds, 0x20d081, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x20d09b);
    memoryASet32(ds, 0x20d097, r32[eax]);
    memoryASet32(ds, 0x20d093, r32[eax]);
    memoryASet16(ds, 0x20ce99, memoryAGet16(ds, 0x20ce99) - 0x0001);
    { pc = 0x1d0b5b; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d0b5b: // 0160:1d0b5b
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20d0ff, r16[ax]);
    memoryASet16(ds, 0x20d101, r16[ax]);
    memoryASet16(ds, 0x20d103, r16[ax]);
    memoryASet16(ds, 0x20d111, r16[ax]);
    memoryASet16(ds, 0x20d113, r16[ax]);
    memoryASet16(ds, 0x20d115, r16[ax]);
    memoryASet16(ds, 0x20d7a5, 0x0000);
    memoryASet16(ds, 0x20d7a9, 0x0000);
    memoryASet16(ds, 0x20d7b1, 0x000a);
    { pc = 0x1d0c94; break; }
  case 0x1d0ba3: // 0160:1d0ba3
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    if (r16[ax])
        { pc = 0x1d0bfe; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d0bd2; break; }
    memoryASet16(ds, 0x20cf85, r16[ax]);
  case 0x1d0bd2: // 0160:1d0bd2
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1d0c94; break; }
    if (memoryAGet16(ds, 0x20d06f) & 0xffff)
        { pc = 0x1d0c94; break; }
    memoryASet16(ds, 0x20d06f, 0x0014);
    { pc = 0x1d0c94; break; }
  case 0x1d0bfe: // 0160:1d0bfe
    if (r16[ax] != 0x0001)
        { pc = 0x1d0c49; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf75);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf75, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d0c28; break; }
    memoryASet16(ds, 0x20cf87, r16[ax]);
  case 0x1d0c28: // 0160:1d0c28
    if (memoryAGet16(ds, 0x20d05f) & 0xffff)
        { pc = 0x1d0c94; break; }
    if (memoryAGet16(ds, 0x20d071) & 0xffff)
        { pc = 0x1d0c94; break; }
    memoryASet16(ds, 0x20d071, 0x0014);
    { pc = 0x1d0c94; break; }
  case 0x1d0c49: // 0160:1d0c49
    if (r16[ax] != 0x0002)
        { pc = 0x1d0c94; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf77);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf77, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d0c73; break; }
    memoryASet16(ds, 0x20cf89, r16[ax]);
  case 0x1d0c73: // 0160:1d0c73
    if (memoryAGet16(ds, 0x20d061) & 0xffff)
        { pc = 0x1d0c94; break; }
    if (memoryAGet16(ds, 0x20d073) & 0xffff)
        { pc = 0x1d0c94; break; }
    memoryASet16(ds, 0x20d073, 0x0014);
    { pc = 0x1d0c94; break; }
  case 0x1d0c94: // 0160:1d0c94
    r32[esp] += 4; return;
  case 0x1d0c95: // 0160:1d0c95
    r16[bx] = memoryAGet16(ds, 0x20d7a5);
    if (!r16[bx])
        { pc = 0x1d0dd9; break; }
    if (memoryAGet16(ds, 0x20d7a5) != 0x0259)
        { pc = 0x1d0ccb; break; }
    r32[esi] = 0x0020cf85;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    r16[ax] <<= 1;
    memoryASet16(ds, r32[esi] + r32[eax], 0x0034);
    { pc = 0x1d0dd9; break; }
  case 0x1d0ccb: // 0160:1d0ccb
    if (memoryAGet16(ds, 0x20d7a5) != 0x02bd)
        { pc = 0x1d0d3a; break; }
    r16[ax] = 0x0033;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    if (memoryAGet16(ds, 0x20d7a7) & 0xffff)
        { pc = 0x1d0d0b; break; }
    memoryASet16(ds, 0x20ce93, memoryAGet16(ds, 0x20ce93) + 0x0001);
    { pc = 0x1d0d13; break; }
  case 0x1d0d0b: // 0160:1d0d0b
    memoryASet16(ds, 0x20ce93, memoryAGet16(ds, 0x20ce93) - 0x0001);
  case 0x1d0d13: // 0160:1d0d13
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x20d0ff, r16[ax]);
    memoryASet16(ds, 0x20d101, r16[ax]);
    memoryASet16(ds, 0x20d7a5, 0x0000);
    memoryASet16(ds, 0x20d7b1, 0x000a);
    { pc = 0x1d0dd9; break; }
  case 0x1d0d3a: // 0160:1d0d3a
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    if (r16[ax])
        { pc = 0x1d0d8e; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf73);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf73, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d0d69; break; }
    memoryASet16(ds, 0x20cf85, r16[ax]);
  case 0x1d0d69: // 0160:1d0d69
    if (memoryAGet16(ds, 0x20d05d) & 0xffff)
        { pc = 0x1d0dd9; break; }
    if (memoryAGet16(ds, 0x20d06f) & 0xffff)
        { pc = 0x1d0dd9; break; }
    memoryASet16(ds, 0x20d06f, 0x0014);
    { pc = 0x1d0dd9; break; }
  case 0x1d0d8e: // 0160:1d0d8e
    if (r16[ax] != 0x0001)
        { pc = 0x1d0dd9; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf75);
    r16[ax]++;
    r16[ax] &= 0x001f;
    memoryASet16(ds, 0x20cf75, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20d7a5)) >= signed16(0x0014))
        { pc = 0x1d0db8; break; }
    memoryASet16(ds, 0x20cf87, r16[ax]);
  case 0x1d0db8: // 0160:1d0db8
    if (memoryAGet16(ds, 0x20d05f) & 0xffff)
        { pc = 0x1d0dd9; break; }
    if (memoryAGet16(ds, 0x20d071) & 0xffff)
        { pc = 0x1d0dd9; break; }
    memoryASet16(ds, 0x20d071, 0x0014);
    { pc = 0x1d0dd9; break; }
  case 0x1d0dd9: // 0160:1d0dd9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d091e() // 0160:1d091e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020d04b;
    r32[edi] = 0x0020d0b7;
    r32[ebp] = r32[ecx];
    r32[ecx] = 0x00000008;
  case 0x1d092f: // 0160:1d092f
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    memoryASet32(ds, r32[edi], r32[ebx]);
    r32[edi] += 0x00000004;
    memoryASet32(ds, r32[edi], r32[ebp]);
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1d092f; break; }
    memoryASet16(ds, 0x20d081, r16[dx]);
    memoryASet16(ds, 0x20d083, r16[dx]);
    memoryASet16(ds, 0x20d085, r16[dx]);
    memoryASet16(ds, 0x20d087, r16[dx]);
    r32[ebp] = memoryAGet32(ds, 0x20e7fd);
    memoryASet32(ds, 0x20d093, r32[ebp]);
    memoryASet32(ds, 0x20d097, r32[ebp]);
    memoryASet32(ds, 0x20d09b, r32[ebp]);
    memoryASet32(ds, 0x20d09f, r32[ebp]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d0dda() // 0160:1d0dda +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d0dda; break; }
  case 0x1b19ac: // 0160:1b19ac
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0000);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 123602 bytes // gap 123602 bytes
  case 0x1cfcb2: // 0160:1cfcb2
    if (r16s[ax] < signed16(0x012c))
        { pc = 0x1cfcc3; break; }
    r16[ax] -= 0x0140;
    r16[ax] += memoryAGet16(ds, 0x20ee53);
  case 0x1cfcc3: // 0160:1cfcc3
    if (r16s[bx] < signed16(0x012c))
        { pc = 0x1cfcd6; break; }
    r16[bx] -= 0x00e0;
    r16[bx] += memoryAGet16(ds, 0x20ee55);
  case 0x1cfcd6: // 0160:1cfcd6
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x1);
    memoryASet(ds, 0x20ceb7, r8[cl]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x2);
    memoryASet(ds, 0x20ceb9, r8[cl]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x3);
    memoryASet(ds, 0x20cebb, r8[cl]);
    r8[cl] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet(ds, 0x20cebd, r8[cl]);
    r32[ecx] = 0;
    r8[cl] = memoryAGet(ds, r32[esi]);
    r16[cx] += 0x0005;
    r16[dx] = 0x0010;
    r16[ax] += 0x0008;
    r16[bx] += 0x0008;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20ceb7);
    r16[cx] += 0x0005;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x001c;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[dx] = 0x0010;
    r16[bx] += 0x0008;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20ceb9);
    r16[cx] += 0x0005;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0028;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[dx] = 0x0010;
    r16[bx] += 0x0008;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20cebb);
    r16[cx] += 0x0010;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0030;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx]++;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    yield* sub_1b19ac();
    r16[cx] = 0;
    r8[cl] = memoryAGet(ds, 0x20cebd);
    r16[cx] += 0x0010;
    r16[cx] &= 0x00fe;
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0037;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx]++;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] += 0x0006;
    r16[ax] += 0x0010;
    r16[cx] = 0x000f;
    r16[dx] = 0x0010;
    r16[bx] += 0x0004;
    { pc = 0x1b19ac; break; }
    // gap 4063 bytes // gap 4063 bytes
  case 0x1d0dda: // 0160:1d0dda
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1d14c7; break; }
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d1850; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7f5);
    if (r16[ax] == 0x0001)
        { pc = 0x1d1583; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d14c7; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d128d; break; }
    r16[ax] = memoryAGet16(ds, 0x20ce95);
    memoryASet16(ds, 0x20e809, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d0e96; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0001)
        { pc = 0x1d0e8e; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0005)
        { pc = 0x1d0e8e; break; }
    if (memoryAGet16(ds, 0x20d7a9) == 0x0001)
        { pc = 0x1d0e84; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0001)
        { pc = 0x1d0e7a; break; }
    if (memoryAGet16(ds, 0x20d7af) != 0x0001)
        { pc = 0x1d0e96; break; }
    if (memoryAGet16(ds, 0x20e809) == 0x000b)
        { pc = 0x1d0e96; break; }
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0001);
    { pc = 0x1d0e96; break; }
  case 0x1d0e7a: // 0160:1d0e7a
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    { pc = 0x1d0e96; break; }
  case 0x1d0e84: // 0160:1d0e84
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0002);
    { pc = 0x1d0e96; break; }
  case 0x1d0e8e: // 0160:1d0e8e
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0002);
  case 0x1d0e96: // 0160:1d0e96
    if (signed16(memoryAGet16(ds, 0x20e809)) <= signed16(0x000c))
        { pc = 0x1d0ea9; break; }
    memoryASet16(ds, 0x20e809, 0x000c);
  case 0x1d0ea9: // 0160:1d0ea9
    r16[bp] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20ceb3, r16[bp]);
    r16[bx] = 0x00c2;
  case 0x1d0ebb: // 0160:1d0ebb
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[ax])
        { pc = 0x1d0efd; break; }
    if (r16s[ax] < 0)
        { pc = 0x1d0efd; break; }
    push32(r32[ebx]);
    r16[ax] = 0x009a;
    r32[ecx] = 0x00000005;
    if (signed16(memoryAGet16(ds, 0x20ceb3)) >= signed16(0x0002))
        { pc = 0x1d0ee4; break; }
    r16[cx] += 0x001c;
    r16[bx] += 0x0004;
  case 0x1d0ee4: // 0160:1d0ee4
    r32[edx] = 0x00000010;
    yield* sub_1b19ac();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0002);
    r16[bx] -= 0x000a;
    { pc = 0x1d0ebb; break; }
  case 0x1d0efd: // 0160:1d0efd
    r16[bp] = memoryAGet16(ds, 0x20ce97);
    memoryASet16(ds, 0x20e809, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d0f79; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0002)
        { pc = 0x1d0f71; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0006)
        { pc = 0x1d0f71; break; }
    if (memoryAGet16(ds, 0x20d7a9) == 0x0002)
        { pc = 0x1d0f67; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0002)
        { pc = 0x1d0f5d; break; }
    if (memoryAGet16(ds, 0x20d7af) != 0x0002)
        { pc = 0x1d0f79; break; }
    if (memoryAGet16(ds, 0x20e809) == 0x000b)
        { pc = 0x1d0f79; break; }
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0001);
    { pc = 0x1d0f79; break; }
  case 0x1d0f5d: // 0160:1d0f5d
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    { pc = 0x1d0f79; break; }
  case 0x1d0f67: // 0160:1d0f67
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0002);
    { pc = 0x1d0f79; break; }
  case 0x1d0f71: // 0160:1d0f71
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0002);
  case 0x1d0f79: // 0160:1d0f79
    if (signed16(memoryAGet16(ds, 0x20e809)) <= signed16(0x000c))
        { pc = 0x1d0f8c; break; }
    memoryASet16(ds, 0x20e809, 0x000c);
  case 0x1d0f8c: // 0160:1d0f8c
    r16[bp] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20ceb3, r16[bp]);
    r16[bx] = 0x00c2;
  case 0x1d0f9e: // 0160:1d0f9e
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[ax])
        { pc = 0x1d0fee; break; }
    if (r16s[ax] < 0)
        { pc = 0x1d0fee; break; }
    push32(r32[ebx]);
    r16[ax] = 0x01a8;
    r32[ecx] = 0x00000004;
    if (signed16(memoryAGet16(ds, 0x20ceb3)) >= signed16(0x0002))
        { pc = 0x1d0fc7; break; }
    r16[cx] += 0x001c;
    r16[bx] += 0x0004;
  case 0x1d0fc7: // 0160:1d0fc7
    r32[edx] = 0x00000010;
    r16[bp] = 0x0140;
    r16[bp] -= memoryAGet16(ds, 0x20ee53);
    r16[ax] -= r16[bp];
    yield* sub_1b19ac();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0002);
    r16[bx] -= 0x000a;
    { pc = 0x1d0f9e; break; }
  case 0x1d0fee: // 0160:1d0fee
    memoryASet16(ds, 0x20ce8f, 0x0003);
    r16[ax] = memoryAGet16(ds, 0x20ce99);
    memoryASet16(ds, 0x20e809, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d1071; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0003)
        { pc = 0x1d1069; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0007)
        { pc = 0x1d1069; break; }
    if (memoryAGet16(ds, 0x20d7a9) == 0x0003)
        { pc = 0x1d105f; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0003)
        { pc = 0x1d1055; break; }
    if (memoryAGet16(ds, 0x20d7af) != 0x0003)
        { pc = 0x1d1071; break; }
    if (memoryAGet16(ds, 0x20e809) == 0x000b)
        { pc = 0x1d1071; break; }
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0001);
    { pc = 0x1d1071; break; }
  case 0x1d1055: // 0160:1d1055
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    { pc = 0x1d1071; break; }
  case 0x1d105f: // 0160:1d105f
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0002);
    { pc = 0x1d1071; break; }
  case 0x1d1069: // 0160:1d1069
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0002);
  case 0x1d1071: // 0160:1d1071
    if (signed16(memoryAGet16(ds, 0x20e809)) <= signed16(0x000c))
        { pc = 0x1d1084; break; }
    memoryASet16(ds, 0x20e809, 0x000c);
  case 0x1d1084: // 0160:1d1084
    r16[ax] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r16[bx] = 0x0144;
  case 0x1d1094: // 0160:1d1094
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[ax])
        { pc = 0x1d10e8; break; }
    if (r16s[ax] < 0)
        { pc = 0x1d10e8; break; }
    push32(r32[ebx]);
    r16[ax] = 0x009a;
    r32[ecx] = 0x00000004;
    if (signed16(memoryAGet16(ds, 0x20ceb3)) >= signed16(0x0002))
        { pc = 0x1d10bd; break; }
    r16[cx] += 0x001c;
    r16[bx] += 0x0004;
  case 0x1d10bd: // 0160:1d10bd
    r32[edx] = 0x00000010;
    r16[bx] += 0x0008;
    r16[bp] = 0x00e0;
    r16[bp] -= memoryAGet16(ds, 0x20ee55);
    r16[bx] -= r16[bp];
    yield* sub_1b19ac();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0002);
    r16[bx] -= 0x000a;
    { pc = 0x1d1094; break; }
  case 0x1d10e8: // 0160:1d10e8
    memoryASet16(ds, 0x20ce8f, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x20ce9b);
    memoryASet16(ds, 0x20e809, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d116b; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0004)
        { pc = 0x1d1163; break; }
    if (memoryAGet16(ds, 0x20d7ab) == 0x0008)
        { pc = 0x1d1163; break; }
    if (memoryAGet16(ds, 0x20d7a9) == 0x0004)
        { pc = 0x1d1159; break; }
    if (memoryAGet16(ds, 0x20d7ad) == 0x0004)
        { pc = 0x1d114f; break; }
    if (memoryAGet16(ds, 0x20d7af) != 0x0004)
        { pc = 0x1d116b; break; }
    if (memoryAGet16(ds, 0x20e809) == 0x000b)
        { pc = 0x1d116b; break; }
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0001);
    { pc = 0x1d116b; break; }
  case 0x1d114f: // 0160:1d114f
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    { pc = 0x1d116b; break; }
  case 0x1d1159: // 0160:1d1159
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0002);
    { pc = 0x1d116b; break; }
  case 0x1d1163: // 0160:1d1163
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) + 0x0002);
  case 0x1d116b: // 0160:1d116b
    if (signed16(memoryAGet16(ds, 0x20e809)) <= signed16(0x000c))
        { pc = 0x1d117e; break; }
    memoryASet16(ds, 0x20e809, 0x000c);
  case 0x1d117e: // 0160:1d117e
    r16[ax] = memoryAGet16(ds, 0x20e809);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r16[bx] = 0x0144;
  case 0x1d118e: // 0160:1d118e
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[ax])
        { pc = 0x1d11f0; break; }
    if (r16s[ax] < 0)
        { pc = 0x1d11f0; break; }
    push32(r32[ebx]);
    r16[ax] = 0x01a8;
    r32[ecx] = 0x00000005;
    if (signed16(memoryAGet16(ds, 0x20ceb3)) >= signed16(0x0002))
        { pc = 0x1d11b7; break; }
    r16[cx] += 0x001c;
    r16[bx] += 0x0004;
  case 0x1d11b7: // 0160:1d11b7
    r32[edx] = 0x00000010;
    r16[bx] += 0x0008;
    r16[bp] = 0x0140;
    r16[bp] -= memoryAGet16(ds, 0x20ee53);
    r16[ax] -= r16[bp];
    r16[bp] = 0x00e0;
    r16[bp] -= memoryAGet16(ds, 0x20ee55);
    r16[bx] -= r16[bp];
    yield* sub_1b19ac();
    r32[ebx] = pop32();
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0002);
    r16[bx] -= 0x000a;
    { pc = 0x1d118e; break; }
  case 0x1d11f0: // 0160:1d11f0
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r16[ax] = 0x009a;
    r16[bx] = 0x00ae;
    r32[ecx] = 0x00000003;
    r32[edx] = 0x00000010;
    yield* sub_1b19ac();
    r16[ax] = 0x01a8;
    r16[bx] = 0x00ae;
    r32[ecx] = 0x00000003;
    r32[edx] = 0x00000010;
    r16[bp] = 0x0140;
    r16[bp] -= memoryAGet16(ds, 0x20ee53);
    r16[ax] -= r16[bp];
    yield* sub_1b19ac();
    r16[ax] = 0x009a;
    r16[bx] = 0x0138;
    r32[ecx] = 0x00000003;
    r32[edx] = 0x00000010;
    r16[bp] = 0x00e0;
    r16[bp] -= memoryAGet16(ds, 0x20ee55);
    r16[bx] -= r16[bp];
    yield* sub_1b19ac();
    r16[ax] = 0x01a8;
    r16[bx] = 0x0138;
    r32[ecx] = 0x00000003;
    r32[edx] = 0x00000010;
    r16[bp] = 0x0140;
    r16[bp] -= memoryAGet16(ds, 0x20ee53);
    r16[ax] -= r16[bp];
    r16[bp] = 0x00e0;
    r16[bp] -= memoryAGet16(ds, 0x20ee55);
    r16[bx] -= r16[bp];
    { pc = 0x1b19ac; break; }
  case 0x1d128d: // 0160:1d128d
    r16[ax] = memoryAGet16(ds, 0x20ce95);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    if (memoryAGet16(ds, 0x20d7ab) == 0x0001)
        { pc = 0x1d12c3; break; }
    if (memoryAGet16(ds, 0x20d7a9) != 0x0001)
        { pc = 0x1d12d7; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d12d7; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    { pc = 0x1d12d7; break; }
  case 0x1d12c3: // 0160:1d12c3
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d12d7; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0001);
  case 0x1d12d7: // 0160:1d12d7
    r16[bx] = 0x009a;
    r16[bp] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d12f8; break; }
    if (r16s[bp] <= signed16(0x0008))
        { pc = 0x1d12f1; break; }
    r16[bp] = 0x0008;
  case 0x1d12f1: // 0160:1d12f1
    r16[bp] <<= 3;
    r16[bx] += r16[bp];
  case 0x1d12f8: // 0160:1d12f8
    r16[bp] = 0x0008;
    r16[bp] -= memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d1331; break; }
    if (r16s[bp] < 0)
        { pc = 0x1d1331; break; }
    r16[bp]--;
  case 0x1d130b: // 0160:1d130b
    push32(r32[ebx]);
    push32(r32[ebp]);
    r16[ax] = 0x009a;
    r16[cx] = 0x0021;
    r32[edx] = 0x00000010;
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    yield* sub_1b19ac();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r16[bx] += 0x0008;
    r16[bp]--;
    if (r16s[bp] >= 0)
        { pc = 0x1d130b; break; }
  case 0x1d1331: // 0160:1d1331
    r16[ax] = memoryAGet16(ds, 0x20ce97);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    if (memoryAGet16(ds, 0x20d7ab) == 0x0002)
        { pc = 0x1d1367; break; }
    if (memoryAGet16(ds, 0x20d7a9) != 0x0002)
        { pc = 0x1d137b; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d137b; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    { pc = 0x1d137b; break; }
  case 0x1d1367: // 0160:1d1367
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d137b; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0001);
  case 0x1d137b: // 0160:1d137b
    r16[bx] = 0x009a;
    r16[bp] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d139c; break; }
    if (r16s[bp] <= signed16(0x0008))
        { pc = 0x1d1395; break; }
    r16[bp] = 0x0008;
  case 0x1d1395: // 0160:1d1395
    r16[bp] <<= 3;
    r16[bx] += r16[bp];
  case 0x1d139c: // 0160:1d139c
    r16[bp] = 0x0008;
    r16[bp] -= memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d13d4; break; }
    if (r16s[bp] < 0)
        { pc = 0x1d13d4; break; }
    r16[bp]--;
  case 0x1d13af: // 0160:1d13af
    push32(r32[ebx]);
    push32(r32[ebp]);
    r16[ax] = 0x00a8;
    r16[cx] = 0x0020;
    r16[dx] = 0x0010;
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    yield* sub_1b19ac();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r16[bx] += 0x0008;
    r16[bp]--;
    if (r16s[bp] >= 0)
        { pc = 0x1d13af; break; }
  case 0x1d13d4: // 0160:1d13d4
    r16[ax] = memoryAGet16(ds, 0x20ce99);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    if (memoryAGet16(ds, 0x20d7ab) == 0x0003)
        { pc = 0x1d140a; break; }
    if (memoryAGet16(ds, 0x20d7a9) != 0x0003)
        { pc = 0x1d141e; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d141e; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    { pc = 0x1d141e; break; }
  case 0x1d140a: // 0160:1d140a
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d141e; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0001);
  case 0x1d141e: // 0160:1d141e
    r16[bx] = 0x009a;
    r16[bp] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d143f; break; }
    if (r16s[bp] <= signed16(0x0008))
        { pc = 0x1d1438; break; }
    r16[bp] = 0x0008;
  case 0x1d1438: // 0160:1d1438
    r16[bp] <<= 3;
    r16[bx] += r16[bp];
  case 0x1d143f: // 0160:1d143f
    memoryASet16(ds, 0x20ce8f, 0x0003);
    r16[bp] = 0x0008;
    r16[bp] -= memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d147e; break; }
    if (r16s[bp] < 0)
        { pc = 0x1d147e; break; }
    r16[bp]--;
  case 0x1d1459: // 0160:1d1459
    push32(r32[ebx]);
    push32(r32[ebp]);
    r16[ax] = 0x00b6;
    r16[cx] = 0x0021;
    r16[dx] = 0x0010;
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0008;
    yield* sub_1b19ac();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r16[bx] += 0x0008;
    r16[bp]--;
    if (r16s[bp] >= 0)
        { pc = 0x1d1459; break; }
  case 0x1d147e: // 0160:1d147e
    r16[ax] = 0x0092;
    r16[bx] = 0x00ae;
    r16[cx] = 0x0003;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r16[ax] = 0x00a0;
    r16[bx] = 0x00ae;
    r16[cx] = 0x0003;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r16[ax] = 0x00ae;
    r16[bx] = 0x00ae;
    r16[cx] = 0x0003;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    memoryASet16(ds, 0x20ce8f, 0xffff);
    r32[esp] += 4; return;
  case 0x1d14c7: // 0160:1d14c7
    r16[bx] = 0x0094;
    r16[ax] = memoryAGet16(ds, 0x20ce93);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1d1527; break; }
    if (memoryAGet16(ds, 0x20d081) & 0xffff)
        { pc = 0x1d14f8; break; }
    if (!(memoryAGet16(ds, 0x20d7b5) & 0xffff))
        { pc = 0x1d1527; break; }
  case 0x1d14f8: // 0160:1d14f8
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0006;
    if (!r16[ax])
        { pc = 0x1d1527; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    if (!r16[ax])
        { pc = 0x1d151f; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d151f; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0001);
    { pc = 0x1d1527; break; }
  case 0x1d151f: // 0160:1d151f
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
  case 0x1d1527: // 0160:1d1527
    r16[bp] = memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d1554; break; }
    if (r16s[bp] < 0)
        { pc = 0x1d1554; break; }
    r16[bp]--;
  case 0x1d1537: // 0160:1d1537
    push32(r32[ebx]);
    push32(r32[ebp]);
    r16[ax] = 0x0094;
    r16[cx] = 0x0021;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r16[bx] += 0x000a;
    r16[bp]--;
    if (r16s[bp] >= 0)
        { pc = 0x1d1537; break; }
  case 0x1d1554: // 0160:1d1554
    r16[bp] = 0x0008;
    r16[bp] -= memoryAGet16(ds, 0x20ceb3);
    if (!r16[bp])
        { pc = 0x1d1582; break; }
    if (r16s[bp] < 0)
        { pc = 0x1d1582; break; }
    r16[bp]--;
  case 0x1d1565: // 0160:1d1565
    push32(r32[ebx]);
    push32(r32[ebp]);
    r16[ax] = 0x0094;
    r16[cx] = 0x0020;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r16[bx] += 0x000a;
    r16[bp]--;
    if (r16s[bp] >= 0)
        { pc = 0x1d1565; break; }
  case 0x1d1582: // 0160:1d1582
    r32[esp] += 4; return;
  case 0x1d1583: // 0160:1d1583
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    if (r16[ax] != 0x0005)
        { pc = 0x1d17a0; break; }
    r16[bx] = 0x000a;
    r16[bx] -= memoryAGet16(ds, 0x20d081);
    r32[ebx] = rol32(r32[ebx], 0x10);
    r16[bx] = memoryAGet16(ds, 0x20d04b);
    r16[bx] &= 0x00ff;
    r16[bx] <<= 2;
    r16[bx] += 0x0003;
    r16[cx] = 0x000a;
    r16[cx] -= memoryAGet16(ds, 0x20d083);
    r32[ecx] = rol32(r32[ecx], 0x10);
    r16[cx] = memoryAGet16(ds, 0x20d04d);
    r16[cx] &= 0x00ff;
    r16[cx] <<= 2;
    r16[cx] += 0x0002;
    r16[dx] = 0x000a;
    r16[dx] -= memoryAGet16(ds, 0x20d085);
    r32[edx] = rol32(r32[edx], 0x10);
    r16[dx] = memoryAGet16(ds, 0x20d04f);
    r16[dx] &= 0x00ff;
    r16[dx] <<= 2;
    r16[dx]++;
    r16[ax] = 0x000a;
    r16[ax] -= memoryAGet16(ds, 0x20d087);
    r32[eax] = rol32(r32[eax], 0x10);
    r16[ax] = memoryAGet16(ds, 0x20d051);
    r16[ax] &= 0x00ff;
    r16[ax] <<= 2;
    memoryASet32(ds, 0x20e7fd, r32[eax]);
    r32[esi] = 0x0020d1f7;
    r32[edi] = 0x00989680;
    r16[bp] = 0x0004;
  case 0x1d162c: // 0160:1d162c
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1d1663; break; }
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (r16[ax] == 0x0004)
        { pc = 0x1d1654; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d1650; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d164c; break; }
    r32[ebx] += r32[edi];
    { pc = 0x1d165a; break; }
  case 0x1d164c: // 0160:1d164c
    r32[ecx] += r32[edi];
    { pc = 0x1d165a; break; }
  case 0x1d1650: // 0160:1d1650
    r32[edx] += r32[edi];
    { pc = 0x1d165a; break; }
  case 0x1d1654: // 0160:1d1654
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) + r32[edi]);
  case 0x1d165a: // 0160:1d165a
    r32[esi] += 0x00000002;
    r32[edi] >>>= 1;
    r16[bp]--;
    if (r16[bp])
        { pc = 0x1d162c; break; }
  case 0x1d1663: // 0160:1d1663
    memoryASet32(ds, 0x20cecf, r32[ebx]);
    memoryASet32(ds, 0x20ced3, r32[ecx]);
    memoryASet32(ds, 0x20ced7, r32[edx]);
    r32[ebp] = memoryAGet32(ds, 0x20e7fd);
    memoryASet32(ds, 0x20cedb, r32[ebp]);
    memoryASet32(ds, 0x20cedf, r32[ebx]);
    memoryASet32(ds, 0x20cee3, r32[ecx]);
    memoryASet32(ds, 0x20cee7, r32[edx]);
    memoryASet32(ds, 0x20ceeb, r32[ebp]);
  case 0x1d1699: // 0160:1d1699
    r16[dx] = 0;
    r32[ecx] = 0x00000003;
    r32[esi] = 0x0020cecf;
    r32[edi] = 0x0020ced3;
  case 0x1d16ab: // 0160:1d16ab
    r32[eax] = memoryAGet32(ds, r32[esi]);
    if (r32s[eax] < signed32(memoryAGet32(ds, r32[edi])))
        { pc = 0x1d16c0; break; }
  case 0x1d16b1: // 0160:1d16b1
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000004;
    if (--r32[ecx])
        { pc = 0x1d16ab; break; }
    if (!r16[dx])
        { pc = 0x1d16cc; break; }
    if (r16[dx])
        { pc = 0x1d1699; break; }
  case 0x1d16c0: // 0160:1d16c0
    r32[eax] = memoryAGet32(ds, r32[edi]);
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[ebp]);
    memoryASet32(ds, r32[esi], r32[eax]);
    r16[dx]++;
    { pc = 0x1d16b1; break; }
  case 0x1d16cc: // 0160:1d16cc
    r32[eax] = 0;
    r32[ebx] = memoryAGet32(ds, 0x20cedf);
    if (r32[ebx] == memoryAGet32(ds, 0x20cecf))
        { pc = 0x1d16fb; break; }
    r32[eax] = 0x00000002;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced3))
        { pc = 0x1d16fb; break; }
    r32[eax] = 0x00000004;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced7))
        { pc = 0x1d16fb; break; }
    r32[eax] = 0x00000006;
  case 0x1d16fb: // 0160:1d16fb
    memoryASet16(ds, 0x20d16d, r16[ax]);
    r32[eax] = 0;
    r32[ebx] = memoryAGet32(ds, 0x20cee3);
    if (r32[ebx] == memoryAGet32(ds, 0x20cecf))
        { pc = 0x1d1730; break; }
    r32[eax] = 0x00000002;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced3))
        { pc = 0x1d1730; break; }
    r32[eax] = 0x00000004;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced7))
        { pc = 0x1d1730; break; }
    r32[eax] = 0x00000006;
  case 0x1d1730: // 0160:1d1730
    memoryASet16(ds, 0x20d16f, r16[ax]);
    r32[eax] = 0;
    r32[ebx] = memoryAGet32(ds, 0x20cee7);
    if (r32[ebx] == memoryAGet32(ds, 0x20cecf))
        { pc = 0x1d1765; break; }
    r32[eax] = 0x00000002;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced3))
        { pc = 0x1d1765; break; }
    r32[eax] = 0x00000004;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced7))
        { pc = 0x1d1765; break; }
    r32[eax] = 0x00000006;
  case 0x1d1765: // 0160:1d1765
    memoryASet16(ds, 0x20d171, r16[ax]);
    r32[eax] = 0;
    r32[ebx] = memoryAGet32(ds, 0x20ceeb);
    if (r32[ebx] == memoryAGet32(ds, 0x20cecf))
        { pc = 0x1d179a; break; }
    r32[eax] = 0x00000002;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced3))
        { pc = 0x1d179a; break; }
    r32[eax] = 0x00000004;
    if (r32[ebx] == memoryAGet32(ds, 0x20ced7))
        { pc = 0x1d179a; break; }
    r32[eax] = 0x00000006;
  case 0x1d179a: // 0160:1d179a
    memoryASet16(ds, 0x20d173, r16[ax]);
  case 0x1d17a0: // 0160:1d17a0
    r16[ax] = memoryAGet16(ds, 0x20d16d);
    r32[esi] = 0x00205078;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] = 0x0098;
    r16[cx] = 0x001b;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    r16[ax] = memoryAGet16(ds, 0x20d16f);
    r32[esi] = 0x00205078;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] = 0x0098;
    r16[cx] = 0x001a;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    memoryASet16(ds, 0x20ce8f, 0x0003);
    r16[ax] = memoryAGet16(ds, 0x20d171);
    r32[esi] = 0x00205078;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] = 0x0098;
    r16[cx] = 0x001b;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    memoryASet16(ds, 0x20ce8f, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x20d173);
    r32[esi] = 0x00205078;
    r32[eax] &= 0x0000ffff;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[ax] = 0x0098;
    r16[cx] = 0x001b;
    r16[dx] = 0x0010;
    yield* sub_1b19ac();
    memoryASet16(ds, 0x20ce8f, 0xffff);
  case 0x1d184f: // 0160:1d184f
    r32[esp] += 4; return;
  case 0x1d1850: // 0160:1d1850
    if (memoryAGet16(ds, 0x20eea9) == 0x0001)
        { pc = 0x1d184f; break; }
    if (memoryAGet16(ds, 0x20ec8d) == 0x0001)
        { pc = 0x1d1892; break; }
    r16[ax] = 0x008c;
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] += 0x0060;
    r16[cx] = 0x0003;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    r32[esi] = 0x0020d787;
    r16[ax] = 0x008c;
    r16[bx] = 0x014a;
    { pc = 0x1cfcb2; break; }
  case 0x1d1892: // 0160:1d1892
    r16[ax] = 0x008c;
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] += 0x0060;
    r16[cx] = 0x0004;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    r32[esi] = 0x0020d78d;
    r16[ax] = 0x008c;
    r16[bx] = 0x014a;
    { pc = 0x1cfcb2; break; }
    return;
  }
}
function* sub_1d18c0() // 0160:1d18c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d18c0; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 130732 bytes // gap 130732 bytes
  case 0x1d18c0: // 0160:1d18c0
    r16[bx] = memoryAGet16(ds, 0x20d7b5);
    if (!r16[bx])
        { pc = 0x1d198b; break; }
    if (r16[bx] != 0x0001)
        { pc = 0x1d18ed; break; }
    r16[ax] = 0x0137;
    yield* sub_1b1715();
    r8[al] = 0x8b;
    yield* sub_1b18a6();
    r16[bx] = memoryAGet16(ds, 0x20d7b5);
  case 0x1d18ed: // 0160:1d18ed
    if (memoryAGet16(ds, 0x20d7b5) & 32768)
        { pc = 0x1d1900; break; }
    memoryASet16(ds, 0x20d7b5, memoryAGet16(ds, 0x20d7b5) + 0x0004);
  case 0x1d1900: // 0160:1d1900
    r16[bx] = memoryAGet16(ds, 0x20d7b5);
    r16[bx] >>>= 10;
    r16[bx] += 0x0028;
    if (r16s[bx] <= signed16(0x003c))
        { pc = 0x1d1919; break; }
    r16[bx] = 0x003c;
  case 0x1d1919: // 0160:1d1919
    r8[al] = 0x8b;
    r16[ax] = memoryAGet16(ds, 0x20d7a5);
    if (!r16[ax])
        { pc = 0x1d1938; break; }
    if (r16s[bx] >= signed16(0x015c))
        { pc = 0x1d1938; break; }
    r16[bx] = 0x0160;
    memoryASet16(ds, 0x20d7b5, r16[bx]);
  case 0x1d1938: // 0160:1d1938
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] += 0x004c;
    r16[ax] = memoryAGet16(ds, 0x20d7b5);
    if (r16s[ax] <= signed16(0x0094))
        { pc = 0x1d195f; break; }
    if (r16s[ax] <= signed16(0x015c))
        { pc = 0x1d195b; break; }
    r16[ax] -= 0x00c8;
    { pc = 0x1d195f; break; }
  case 0x1d195b: // 0160:1d195b
    r16[ax] = 0x0094;
  case 0x1d195f: // 0160:1d195f
    r16[ax] += 0x0060;
    r16[bp] = 0x0140;
    r16[bp] -= memoryAGet16(ds, 0x20ee53);
    r16[bp] >>>= 1;
    r16[ax] -= r16[bp];
    r16[dx] = 0;
    r16[cx] = 0x0025;
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1d198b; break; }
    { pc = 0x1b19e0; break; }
  case 0x1d198b: // 0160:1d198b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d198c() // 0160:1d198c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d7a5);
    if (!r16[ax])
        { pc = 0x1d1d9a; break; }
    if (r16[ax] != 0x0001)
        { pc = 0x1d1a8b; break; }
    if (memoryAGet16(ds, 0x20d89f) != 0x0001)
        { pc = 0x1d19d0; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0001)
        { pc = 0x1d19d0; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x012c;
    yield* sub_1b1715();
    { pc = 0x1d1a72; break; }
  case 0x1d19d0: // 0160:1d19d0
    if (memoryAGet16(ds, 0x20d7f5) != 0x0002)
        { pc = 0x1d1a1b; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0001)
        { pc = 0x1d19f0; break; }
    if (memoryAGet16(ds, 0x20ce93) == 0x0002)
        { pc = 0x1d19fa; break; }
    { pc = 0x1d1a1b; break; }
  case 0x1d19f0: // 0160:1d19f0
    if (memoryAGet16(ds, 0x20ce93) != 0x0006)
        { pc = 0x1d1a1b; break; }
  case 0x1d19fa: // 0160:1d19fa
    if (memoryAGet16(ds, 0x20d89f) == 0x0001)
        { pc = 0x1d1a72; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x0138;
    yield* sub_1b1715();
    { pc = 0x1d1a72; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d1a1b: // 0160:1d1a1b
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] -= memoryAGet16(ds, 0x20ee9f);
    if (r16s[ax] > signed16(0x012c))
        { pc = 0x1d1a42; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x013c;
    yield* sub_1b1715();
    { pc = 0x1d1a72; break; }
  case 0x1d1a42: // 0160:1d1a42
    if (r16s[ax] < signed16(0x0258))
        { pc = 0x1d1a5c; break; }
    yield* sub_1b1c25();
    r16[ax] &= 0x0001;
    r16[ax] += 0x013e;
    yield* sub_1b1715();
    { pc = 0x1d1a72; break; }
  case 0x1d1a5c: // 0160:1d1a5c
    yield* sub_1b1c25();
    if (r8s[al] > signed8(0xc0))
        { pc = 0x1d1a72; break; }
    r16[ax] &= 0x0003;
    r16[ax] += 0x0130;
    yield* sub_1b1715();
  case 0x1d1a72: // 0160:1d1a72
    r16[ax] = memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20ee9f, r16[ax]);
    r8[al] = 0xa6;
    yield* sub_1b17b7();
    r16[ax] = memoryAGet16(ds, 0x20d7a5);
  case 0x1d1a8b: // 0160:1d1a8b
    memoryASet16(ds, 0x20d7a5, memoryAGet16(ds, 0x20d7a5) + 0x0004);
    r16[bx] = memoryAGet16(ds, 0x20ee55);
    r16[bx] >>>= 1;
    r16[bx] += 0x0090;
    if (r16s[ax] <= signed16(0x0094))
        { pc = 0x1d1acb; break; }
    if (r16s[ax] <= signed16(0x0154))
        { pc = 0x1d1ab4; break; }
    r16[ax] -= 0x00c0;
    { pc = 0x1d1acb; break; }
  case 0x1d1ab4: // 0160:1d1ab4
    r16[ax] = 0x0094;
    if (!(memoryAGet16(ds, 0x20d7b7) & 0xffff))
        { pc = 0x1d1acb; break; }
    memoryASet16(ds, 0x20d7a5, memoryAGet16(ds, 0x20d7a5) - 0x0003);
  case 0x1d1acb: // 0160:1d1acb
    r16[ax] += 0x0068;
    r16[dx] = 0x0010;
    if (memoryAGet16(ds, 0x20d7b7) & 0xffff)
        { pc = 0x1d1ca7; break; }
    if (memoryAGet16(ds, 0x20d7d5) & 0xffff)
        { pc = 0x1d1c4e; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1d1c4e; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1d1bea; break; }
    r16[cx] = memoryAGet16(ds, 0x20ce95);
    if (r16s[cx] < 0)
        { pc = 0x1d1b42; break; }
    if (r16[cx] < 0x000a)
        { pc = 0x1d1b42; break; }
    if (!(memoryAGet16(ds, 0x20d7a7) & 0xffff))
        { pc = 0x1d1b34; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0004)
        { pc = 0x1d1b42; break; }
  case 0x1d1b34: // 0160:1d1b34
    memoryASet16(ds, 0x20d7b7, 0x0001);
    { pc = 0x1d1ca7; break; }
  case 0x1d1b42: // 0160:1d1b42
    r16[cx] = memoryAGet16(ds, 0x20ce97);
    if (r16s[cx] < 0)
        { pc = 0x1d1b76; break; }
    if (r16[cx] < 0x000a)
        { pc = 0x1d1b76; break; }
    if (memoryAGet16(ds, 0x20d7a7) == 0x0001)
        { pc = 0x1d1b68; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0005)
        { pc = 0x1d1b76; break; }
  case 0x1d1b68: // 0160:1d1b68
    memoryASet16(ds, 0x20d7b7, 0x0002);
    { pc = 0x1d1ca7; break; }
  case 0x1d1b76: // 0160:1d1b76
    r16[cx] = memoryAGet16(ds, 0x20ce99);
    if (r16s[cx] < 0)
        { pc = 0x1d1baa; break; }
    if (r16[cx] < 0x000a)
        { pc = 0x1d1baa; break; }
    if (memoryAGet16(ds, 0x20d7a7) == 0x0002)
        { pc = 0x1d1b9c; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0006)
        { pc = 0x1d1baa; break; }
  case 0x1d1b9c: // 0160:1d1b9c
    memoryASet16(ds, 0x20d7b7, 0x0003);
    { pc = 0x1d1ca7; break; }
  case 0x1d1baa: // 0160:1d1baa
    r16[cx] = memoryAGet16(ds, 0x20ce9b);
    if (r16s[cx] < 0)
        { pc = 0x1d1ca1; break; }
    if (r16[cx] < 0x000a)
        { pc = 0x1d1ca1; break; }
    if (memoryAGet16(ds, 0x20d7a7) == 0x0003)
        { pc = 0x1d1bdc; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0007)
        { pc = 0x1d1ca1; break; }
  case 0x1d1bdc: // 0160:1d1bdc
    memoryASet16(ds, 0x20d7b7, 0x0004);
    { pc = 0x1d1ca7; break; }
  case 0x1d1bea: // 0160:1d1bea
    if (memoryAGet16(ds, 0x20ce95) != 0x0001)
        { pc = 0x1d1c0d; break; }
    if (memoryAGet16(ds, 0x20d7a7) & 0xffff)
        { pc = 0x1d1c0d; break; }
    memoryASet16(ds, 0x20d7b7, 0x0001);
    { pc = 0x1d1ca7; break; }
  case 0x1d1c0d: // 0160:1d1c0d
    if (memoryAGet16(ds, 0x20ce97) != 0x0001)
        { pc = 0x1d1c2f; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0001)
        { pc = 0x1d1c2f; break; }
    memoryASet16(ds, 0x20d7b7, 0x0002);
    { pc = 0x1d1ca7; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d1c2f: // 0160:1d1c2f
    if (memoryAGet16(ds, 0x20ce99) != 0x0001)
        { pc = 0x1d1ca1; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0002)
        { pc = 0x1d1ca1; break; }
    memoryASet16(ds, 0x20d7b7, 0x0003);
    { pc = 0x1d1ca7; break; }
  case 0x1d1c4e: // 0160:1d1c4e
    if (memoryAGet16(ds, 0x20ce93) != 0x0001)
        { pc = 0x1d1c77; break; }
    if (memoryAGet16(ds, 0x20d7a7) == 0x0003)
        { pc = 0x1d1c6c; break; }
    if (memoryAGet16(ds, 0x20d7a7) != 0x0001)
        { pc = 0x1d1ca1; break; }
  case 0x1d1c6c: // 0160:1d1c6c
    memoryASet16(ds, 0x20d7b7, 0x0002);
    { pc = 0x1d1ca7; break; }
  case 0x1d1c77: // 0160:1d1c77
    if (memoryAGet16(ds, 0x20ce93) != 0x0007)
        { pc = 0x1d1ca1; break; }
    if (memoryAGet16(ds, 0x20d7a7) == 0x0002)
        { pc = 0x1d1c96; break; }
    if (memoryAGet16(ds, 0x20d7a7) & 0xffff)
        { pc = 0x1d1ca1; break; }
  case 0x1d1c96: // 0160:1d1c96
    memoryASet16(ds, 0x20d7b7, 0x0001);
    { pc = 0x1d1ca7; break; }
  case 0x1d1ca1: // 0160:1d1ca1
    r16[cx] = 0x0022;
    { pc = 0x1d1cab; break; }
  case 0x1d1ca7: // 0160:1d1ca7
    r16[cx] = 0x0023;
  case 0x1d1cab: // 0160:1d1cab
    r16[ax] -= 0x0010;
    r16[bp] = 0x0140;
    r16[bp] -= memoryAGet16(ds, 0x20ee53);
    r16[bp] >>>= 1;
    r16[ax] -= r16[bp];
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b19e0();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    if (signed16(memoryAGet16(ds, 0x20d7b9)) > signed16(0x0036))
        { pc = 0x1d1d9a; break; }
    r16[bx] += 0x001c;
    r16[ax] += 0x0018;
    push32(r32[eax]);
    push32(r32[ebx]);
    r16[ax] = memoryAGet16(ds, 0x20d7a7);
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] <<= 1;
    r16[ax] += r16[bx];
    r32[esi] = 0x0020e8e1;
    r32[eax] &= 0x0000ffff;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r32[ebp] = 0;
    r16[bp] = r16[ax];
    r16[ax] <<= 2;
    r16[bp] <<= 1;
    r16[bp] += r16[ax];
    if (memoryAGet16(ds, 0x20d7d5) != 0x0001)
        { pc = 0x1d1d4c; break; }
    if (!memoryAGet16(ds, 0x20d7b7))
        { pc = 0x1d1d4c; break; }
    r32[ebp] = 0;
    r32[esi] = 0x002091c9;
    if (!memoryAGet16(ds, 0x20d7a7))
        { pc = 0x1d1d51; break; }
    if (memoryAGet16(ds, 0x20d7a7) == 0x0002)
        { pc = 0x1d1d51; break; }
    r32[esi] = 0x002091cf;
    { pc = 0x1d1d51; break; }
  case 0x1d1d4c: // 0160:1d1d4c
    r32[esi] = 0x00224866;
  case 0x1d1d51: // 0160:1d1d51
    push32(r32[esi]);
    r32[ecx] = 0x00000006;
    r16[dx] = 0;
  case 0x1d1d5a: // 0160:1d1d5a
    if (memoryAGet(ds, r32[esi] + r32[ebp]) != 0x20)
        { pc = 0x1d1d64; break; }
    r16[dx] += 0x0004;
  case 0x1d1d64: // 0160:1d1d64
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1d1d5a; break; }
    r32[esi] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += r16[dx];
    r32[ecx] = 0x00000006;
  case 0x1d1d72: // 0160:1d1d72
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[ebp]);
    push32(r32[eax]);
    push32(r32[ebx]);
    r8[cl] = memoryAGet(ds, r32[esi] + r32[ebp]);
    if (r8[cl] == 0x20)
        { pc = 0x1d1d8e; break; }
    r8[cl] -= 0x41;
    r8[cl] += 0x27;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
  case 0x1d1d8e: // 0160:1d1d8e
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x0008;
    r32[ebp] = pop32();
    r32[ebp]++;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1d1d72; break; }
  case 0x1d1d9a: // 0160:1d1d9a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d1d9b() // 0160:1d1d9b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d1d9b; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 131975 bytes // gap 131975 bytes
  case 0x1d1d9b: // 0160:1d1d9b
    r32[esi] = 0x002089d4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax]);
    if (!r32[eax])
        { pc = 0x1d1db7; break; }
    r32[esi] = r32[eax];
    switch (r32[esi])
    {
        case 0x001d1db8: { pc = 0x1d1db8; break; }
        case 0x001d1ece: { pc = 0x1d1ece; break; }
        case 0x001d6644: { pc = 0x1d6644; break; }
        case 0x001d2493: { pc = 0x1d2493; break; }
        case 0x001d5c1e: { pc = 0x1d5c1e; break; }
        case 0x001d23e7: { pc = 0x1d23e7; break; }
        case 0x001d20fd: { pc = 0x1d20fd; break; }
        case 0x001d226c: { pc = 0x1d226c; break; }
        case 0x001d27ea: { pc = 0x1d27ea; break; }
        case 0x001d27fd: { pc = 0x1d27fd; break; }
        case 0x001d3651: { pc = 0x1d3651; break; }
        case 0x001d417b: { pc = 0x1d417b; break; }
        case 0x001d4cc9: { pc = 0x1d4cc9; break; }
        case 0x001d4e2f: { pc = 0x1d4e2f; break; }
        case 0x001d4f89: { pc = 0x1d4f89; break; }
        case 0x001d251d: { pc = 0x1d251d; break; }
        case 0x001d5f64: { pc = 0x1d5f64; break; }
        case 0x001d6006: { pc = 0x1d6006; break; }
        case 0x001d2177: { pc = 0x1d2177; break; }
        case 0x001d5b2b: { pc = 0x1d5b2b; break; }
        case 0x001d5ae8: { pc = 0x1d5ae8; break; }
        default:
            stop("ind 0160:1d1db5");
    }
    break;
  case 0x1d1db7: // 0160:1d1db7
    r32[esp] += 4; return;
  case 0x1d1db8: // 0160:1d1db8
    yield* sub_1d1ece();
    r16[ax] = memoryAGet16(ds, 0x20d37d);
    r16[bx] = memoryAGet16(ds, 0x20d37f);
    r16[cx] = memoryAGet16(ds, 0x20d383);
    if (!r16[cx])
        { pc = 0x1d1e11; break; }
    if (r16[cx] != 0x0009)
        { pc = 0x1d1df5; break; }
    yield* sub_1d1fdf();
    memoryASet16(ds, 0x20d381, 0x0001);
    memoryASet16(ds, 0x20d383, 0x0000);
    { pc = 0x1d1e11; break; }
  case 0x1d1df5: // 0160:1d1df5
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1d1e0a; break; }
    memoryASet16(ds, 0x20d383, memoryAGet16(ds, 0x20d383) - 0x0001);
  case 0x1d1e0a: // 0160:1d1e0a
    r16[ax] += r16[cx];
    r16[ax]--;
  case 0x1d1e11: // 0160:1d1e11
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d381);
    if (r16[cx] == 0x0006)
        { pc = 0x1d1e45; break; }
    yield* sub_1d1feb();
    r16[ax] = memoryAGet16(ds, 0x20d381);
    if (!r16[ax])
        { pc = 0x1d1e45; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d1e45; break; }
    memoryASet16(ds, 0x20d381, memoryAGet16(ds, 0x20d381) + 0x0001);
  case 0x1d1e45: // 0160:1d1e45
    r16[ax] = memoryAGet16(ds, 0x20d385);
    r16[bx] = memoryAGet16(ds, 0x20d387);
    r16[cx] = memoryAGet16(ds, 0x20d38b);
    if (!r16[cx])
        { pc = 0x1d1e99; break; }
    if (r16[cx] != 0x0009)
        { pc = 0x1d1e7d; break; }
    yield* sub_1d1fdf();
    memoryASet16(ds, 0x20d389, 0x0001);
    memoryASet16(ds, 0x20d38b, 0x0000);
    { pc = 0x1d1e99; break; }
  case 0x1d1e7d: // 0160:1d1e7d
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1d1e92; break; }
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) - 0x0001);
  case 0x1d1e92: // 0160:1d1e92
    r16[ax] += r16[cx];
    r16[ax]--;
  case 0x1d1e99: // 0160:1d1e99
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d389);
    if (r16[cx] == 0x0006)
        { pc = 0x1d1ecd; break; }
    yield* sub_1d1feb();
    r16[ax] = memoryAGet16(ds, 0x20d389);
    if (!r16[ax])
        { pc = 0x1d1ecd; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d1ecd; break; }
    memoryASet16(ds, 0x20d389, memoryAGet16(ds, 0x20d389) + 0x0001);
  case 0x1d1ecd: // 0160:1d1ecd
    r32[esp] += 4; return;
  case 0x1d1ece: // 0160:1d1ece
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[cx] = memoryAGet16(ds, 0x20d373);
    if (!r16[cx])
        { pc = 0x1d1f22; break; }
    if (r16[cx] != 0x0009)
        { pc = 0x1d1f06; break; }
    yield* sub_1d1fdf();
    memoryASet16(ds, 0x20d371, 0x0001);
    memoryASet16(ds, 0x20d373, 0x0000);
    { pc = 0x1d1f22; break; }
  case 0x1d1f06: // 0160:1d1f06
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1d1f1b; break; }
    memoryASet16(ds, 0x20d373, memoryAGet16(ds, 0x20d373) - 0x0001);
  case 0x1d1f1b: // 0160:1d1f1b
    r16[ax] += r16[cx];
    r16[ax]--;
  case 0x1d1f22: // 0160:1d1f22
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d371);
    if (r16[cx] == 0x0006)
        { pc = 0x1d1f56; break; }
    yield* sub_1d1feb();
    r16[ax] = memoryAGet16(ds, 0x20d371);
    if (!r16[ax])
        { pc = 0x1d1f56; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d1f56; break; }
    memoryASet16(ds, 0x20d371, memoryAGet16(ds, 0x20d371) + 0x0001);
  case 0x1d1f56: // 0160:1d1f56
    r16[ax] = memoryAGet16(ds, 0x20d375);
    r16[bx] = memoryAGet16(ds, 0x20d377);
    r16[cx] = memoryAGet16(ds, 0x20d37b);
    if (!r16[cx])
        { pc = 0x1d1faa; break; }
    if (r16[cx] != 0x0009)
        { pc = 0x1d1f8e; break; }
    yield* sub_1d1fdf();
    memoryASet16(ds, 0x20d379, 0x0001);
    memoryASet16(ds, 0x20d37b, 0x0000);
    { pc = 0x1d1faa; break; }
  case 0x1d1f8e: // 0160:1d1f8e
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1d1fa3; break; }
    memoryASet16(ds, 0x20d37b, memoryAGet16(ds, 0x20d37b) - 0x0001);
  case 0x1d1fa3: // 0160:1d1fa3
    r16[ax] += r16[cx];
    r16[ax]--;
  case 0x1d1faa: // 0160:1d1faa
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d379);
    if (r16[cx] == 0x0006)
        { pc = 0x1d1fde; break; }
    yield* sub_1d1feb();
    r16[ax] = memoryAGet16(ds, 0x20d379);
    if (!r16[ax])
        { pc = 0x1d1fde; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d1fde; break; }
    memoryASet16(ds, 0x20d379, memoryAGet16(ds, 0x20d379) + 0x0001);
  case 0x1d1fde: // 0160:1d1fde
    r32[esp] += 4; return;
    // gap 286 bytes // gap 286 bytes
  case 0x1d20fd: // 0160:1d20fd
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0003;
    r16[ax] >>>= 1;
    r16[ax] += 0x0104;
    r32[esi] = memoryAGet32(ds, 0x2eeb94);
    r32[ebx] = 0x00000e30;
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x80, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x100, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x180, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x200, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x280, r16[ax]);
    r16[ax] += 0x0002;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x82, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x102, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x182, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x202, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x282, r16[ax]);
    r32[esp] += 4; return;
  case 0x1d2177: // 0160:1d2177
    r16[ax] = 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfa9);
    if (r16[bx] < 0x00c8)
        { pc = 0x1d2198; break; }
    r16[ax]++;
    if (r16[bx] < 0x0190)
        { pc = 0x1d2198; break; }
    r16[ax]++;
  case 0x1d2198: // 0160:1d2198
    memoryASet16(ds, 0x20cfdf, r16[ax]);
    if (r16[ax] > memoryAGet16(ds, 0x20cfcd))
        { pc = 0x1d21b4; break; }
    memoryASet16(ds, 0x20cfcd, 0x0000);
  case 0x1d21b4: // 0160:1d21b4
    r16[ax] = 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfab);
    if (r16[bx] < 0x00c8)
        { pc = 0x1d21d5; break; }
    r16[ax]++;
    if (r16[bx] < 0x0190)
        { pc = 0x1d21d5; break; }
    r16[ax]++;
  case 0x1d21d5: // 0160:1d21d5
    memoryASet16(ds, 0x20cfe1, r16[ax]);
    if (r16[ax] > memoryAGet16(ds, 0x20cfcf))
        { pc = 0x1d21f1; break; }
    memoryASet16(ds, 0x20cfcf, 0x0000);
  case 0x1d21f1: // 0160:1d21f1
    r16[ax] = 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfad);
    if (r16[bx] < 0x00c8)
        { pc = 0x1d2212; break; }
    r16[ax]++;
    if (r16[bx] < 0x0190)
        { pc = 0x1d2212; break; }
    r16[ax]++;
  case 0x1d2212: // 0160:1d2212
    memoryASet16(ds, 0x20cfe3, r16[ax]);
    if (r16[ax] > memoryAGet16(ds, 0x20cfd1))
        { pc = 0x1d222e; break; }
    memoryASet16(ds, 0x20cfd1, 0x0000);
  case 0x1d222e: // 0160:1d222e
    r16[ax] = 0x0003;
    r16[bx] = memoryAGet16(ds, 0x20cfaf);
    if (r16[bx] < 0x00c8)
        { pc = 0x1d224f; break; }
    r16[ax]++;
    if (r16[bx] < 0x0190)
        { pc = 0x1d224f; break; }
    r16[ax]++;
  case 0x1d224f: // 0160:1d224f
    memoryASet16(ds, 0x20cfe5, r16[ax]);
    if (r16[ax] > memoryAGet16(ds, 0x20cfd3))
        { pc = 0x1d226b; break; }
    memoryASet16(ds, 0x20cfd3, 0x0000);
  case 0x1d226b: // 0160:1d226b
    r32[esp] += 4; return;
  case 0x1d226c: // 0160:1d226c
    memoryASet16(ds, 0x20d825, 0x0001);
    r32[ebx] = 0x00001194;
    yield* sub_1d2341();
    r32[ebx] = 0x00001f54;
    yield* sub_1d2341();
    r32[ebx] = 0x000010c4;
    yield* sub_1d2341();
    r32[ebx] = 0x00002386;
    yield* sub_1d2341();
    r16[ax] = 0x0140;
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0010;
    if (!r16[bx])
        { pc = 0x1d22b6; break; }
    r16[ax] = 0x0154;
  case 0x1d22b6: // 0160:1d22b6
    r32[esi] = memoryAGet32(ds, 0x2eeb94);
    r32[ebx] = 0x00001ac4;
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa0, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] - 158, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x2, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa2, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x142, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] - 156, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x4, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa4, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x144, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x6, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa6, r16[ax]);
    r32[esp] += 4; return;
    // gap 166 bytes // gap 166 bytes
  case 0x1d23e7: // 0160:1d23e7
    memoryASet16(ds, 0x20d825, 0x0001);
    r32[ebx] = 0x00000a92;
    yield* sub_1d23ff();
    r32[ebx] = 0x00000ae0;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    r16[ax] >>>= 1;
    r16[ax] += 0x0104;
    r32[esi] = memoryAGet32(ds, 0x2eeb94);
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x70, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xe0, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x72, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xe2, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x4, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x74, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xe4, r16[ax]);
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[esi] + r32[ebx] - 112, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] - 110, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] - 108, r16[ax]);
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x150, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x152, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x154, r16[ax]);
    r32[esp] += 4; return;
  case 0x1d2493: // 0160:1d2493
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d24eb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04b);
    r16[ax] &= 0x00ff;
    if (!r16[ax])
        { pc = 0x1d24d2; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04d);
    r16[ax] &= 0x00ff;
    if (!r16[ax])
        { pc = 0x1d24ca; break; }
    r16[ax] = memoryAGet16(ds, 0x20d04f);
    r16[ax] &= 0x00ff;
    if (r16[ax])
        { pc = 0x1d24eb; break; }
    r16[ax] = memoryAGet16(ds, 0x20d085);
    { pc = 0x1d24d8; break; }
  case 0x1d24ca: // 0160:1d24ca
    r16[ax] = memoryAGet16(ds, 0x20d083);
    { pc = 0x1d24d8; break; }
  case 0x1d24d2: // 0160:1d24d2
    r16[ax] = memoryAGet16(ds, 0x20d081);
  case 0x1d24d8: // 0160:1d24d8
    if (r16[ax] == 0x0002)
        { pc = 0x1d24f6; break; }
    if (r16[ax] != 0x0001)
        { pc = 0x1d24eb; break; }
    yield* sub_1d24f6();
    if (flags.zero)
        { pc = 0x1d24ec; break; }
  case 0x1d24eb: // 0160:1d24eb
    r32[esp] += 4; return;
  case 0x1d24ec: // 0160:1d24ec
    r32[esi] = 0x00208b84;
    { pc = 0x1d24fb; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d24f6: // 0160:1d24f6
    r32[esi] = 0x00208c94;
  case 0x1d24fb: // 0160:1d24fb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[ax] < 0)
        { pc = 0x1d251c; break; }
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    r32[ebx] += r32[ebx];
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[ebx];
    r32[edi] -= 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    { pc = 0x1d24fb; break; }
  case 0x1d251c: // 0160:1d251c
    r32[esp] += 4; return;
  case 0x1d251d: // 0160:1d251d
    r32[esi] = 0x0020d399;
    memoryASet16(ds, 0x20ceb3, 0x0000);
  case 0x1d252b: // 0160:1d252b
    push32(r32[esi]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx]--;
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r32[esi] += 0x00000006;
    if (signed16(memoryAGet16(ds, 0x20ceb3)) <= signed16(0x0007))
        { pc = 0x1d254d; break; }
    r16[ax] -= r16[cx];
    { pc = 0x1d2550; break; }
  case 0x1d254d: // 0160:1d254d
    r16[ax] += r16[cx];
  case 0x1d2550: // 0160:1d2550
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d2566; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d25a8; break; }
  case 0x1d2566: // 0160:1d2566
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d257c; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d25a8; break; }
  case 0x1d257c: // 0160:1d257c
    if (r16[bx] >= 0x0178)
        { pc = 0x1d25a8; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d25a8; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0075;
    if (signed16(memoryAGet16(ds, 0x20ceb3)) <= signed16(0x0007))
        { pc = 0x1d25a3; break; }
    r16[cx]++;
  case 0x1d25a3: // 0160:1d25a3
    yield* sub_1b19e0();
  case 0x1d25a8: // 0160:1d25a8
    r32[esi] = pop32();
    r32[esi] += 0x0000000a;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    if (memoryAGet16(ds, 0x20ceb3) != 0x0014)
        { pc = 0x1d252b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d2697();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1d2697();
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1d2697();
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1d2697();
    if (memoryAGet16(ds, 0x20d3b1) != 0x0006)
        { pc = 0x1d2628; break; }
    r32[esi] = memoryAGet32(ds, 0x20cf07);
    r32[eax] = 0x00000428;
    memoryASet(ds, r32[esi] + r32[eax], 0xc3);
    memoryASet(ds, r32[esi] + r32[eax] + 0x2, 0xc3);
  case 0x1d2628: // 0160:1d2628
    if (memoryAGet16(ds, 0x20d3d9) != 0x0006)
        { pc = 0x1d2646; break; }
    r32[esi] = memoryAGet32(ds, 0x20cf07);
    r32[eax] = 0x000011aa;
    memoryASet(ds, r32[esi] + r32[eax], 0xc3);
    memoryASet(ds, r32[esi] + r32[eax] + 0x2, 0xc3);
  case 0x1d2646: // 0160:1d2646
    if (memoryAGet16(ds, 0x20d401) != 0x0006)
        { pc = 0x1d266e; break; }
    r32[esi] = memoryAGet32(ds, 0x20cf07);
    r32[eax] = 0x00000506;
    memoryASet(ds, r32[esi] + r32[eax], 0xc4);
    memoryASet(ds, r32[esi] + r32[eax] + 0x2, 0xd3);
    memoryASet(ds, r32[esi] + r32[eax] + 0x4, 0xd3);
    memoryASet(ds, r32[esi] + r32[eax] + 0x6, 0xc4);
  case 0x1d266e: // 0160:1d266e
    if (memoryAGet16(ds, 0x20d43d) != 0x0006)
        { pc = 0x1d2696; break; }
    r32[esi] = memoryAGet32(ds, 0x20cf07);
    r32[eax] = 0x00001286;
    memoryASet(ds, r32[esi] + r32[eax], 0xc4);
    memoryASet(ds, r32[esi] + r32[eax] + 0x2, 0xd3);
    memoryASet(ds, r32[esi] + r32[eax] + 0x4, 0xd3);
    memoryASet(ds, r32[esi] + r32[eax] + 0x6, 0xc4);
  case 0x1d2696: // 0160:1d2696
    r32[esp] += 4; return;
    // gap 339 bytes // gap 339 bytes
  case 0x1d27ea: // 0160:1d27ea
    memoryASet16(ds, 0x20d7f7, 0xff00);
    memoryASet16(ds, 0x20d7f9, 0x0100);
    r32[esp] += 4; return;
  case 0x1d27fd: // 0160:1d27fd
    r16[ax] = memoryAGet16(ds, 0x20d375);
    r16[bx] = memoryAGet16(ds, 0x20d377);
    yield* sub_1d348a();
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1d2a7c; break; }
    r16[ax] = 0x0064;
    yield* sub_1d3339();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1d2a7d; break; }
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d2848; break; }
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) - 0x0001);
  case 0x1d2848: // 0160:1d2848
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d2866; break; }
    if (memoryAGet(ds, 0x20d125) != 0x38)
        { pc = 0x1d28d3; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x002a)
        { pc = 0x1d28d3; break; }
  case 0x1d2866: // 0160:1d2866
    memoryASet16(ds, 0x20cf51, 0x00d6);
    memoryASet16(ds, 0x20cf63, 0x04f2);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) - 0x0001);
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d28d3; break; }
    memoryASet16(ds, 0x20cf87, 0x0008);
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20d04d, 0x0273);
    memoryASet16(ds, 0x20cf99, 0x0100);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0008);
  case 0x1d28d3: // 0160:1d28d3
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d28f1; break; }
    if (memoryAGet(ds, 0x20d127) != 0x38)
        { pc = 0x1d295e; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x002a)
        { pc = 0x1d295e; break; }
  case 0x1d28f1: // 0160:1d28f1
    memoryASet16(ds, 0x20cf53, 0x00d6);
    memoryASet16(ds, 0x20cf65, 0x04f2);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) - 0x0001);
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d295e; break; }
    memoryASet16(ds, 0x20cf89, 0x0008);
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20d04f, 0x0273);
    memoryASet16(ds, 0x20cf9b, 0x0100);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0008);
  case 0x1d295e: // 0160:1d295e
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d297c; break; }
    if (memoryAGet(ds, 0x20d129) != 0x38)
        { pc = 0x1d29e9; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x002a)
        { pc = 0x1d29e9; break; }
  case 0x1d297c: // 0160:1d297c
    memoryASet16(ds, 0x20cf55, 0x00d6);
    memoryASet16(ds, 0x20cf67, 0x04f2);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) - 0x0001);
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d29e9; break; }
    memoryASet16(ds, 0x20cf8b, 0x0008);
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20d051, 0x0273);
    memoryASet16(ds, 0x20cf9d, 0x0100);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0008);
  case 0x1d29e9: // 0160:1d29e9
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d2a07; break; }
    if (memoryAGet(ds, 0x20d123) != 0x38)
        { pc = 0x1d2a7c; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x002a)
        { pc = 0x1d2a7c; break; }
  case 0x1d2a07: // 0160:1d2a07
    memoryASet16(ds, 0x20d861, 0x0001);
    memoryASet16(ds, 0x20cf4f, 0x00d6);
    memoryASet16(ds, 0x20cf61, 0x04f2);
    memoryASet16(ds, 0x20cf85, 0x0008);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    if (memoryAGet16(ds, 0x20d17d) & 0xffff)
        { pc = 0x1d2a7c; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20d04b, 0x0273);
    memoryASet16(ds, 0x20cf97, 0x0100);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0008);
    memoryASet16(ds, 0x20d861, 0x0000);
  case 0x1d2a7c: // 0160:1d2a7c
    r32[esp] += 4; return;
  case 0x1d2a7d: // 0160:1d2a7d
    yield* sub_1d33a0();
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d312b; break; }
    yield* sub_1d3411();
    if (memoryAGet16(ds, 0x20d17d) == 0x0001)
        { pc = 0x1d2ac2; break; }
    if (memoryAGet16(ds, 0x20d17f) == 0x0001)
        { pc = 0x1d2ac2; break; }
    if (memoryAGet16(ds, 0x20d181) == 0x0001)
        { pc = 0x1d2ac2; break; }
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d3338; break; }
  case 0x1d2ac2: // 0160:1d2ac2
    r16[ax] = 0x008c;
    yield* sub_1d34d9();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1d3043; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1d2de1; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d2c23; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d2c11; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d2bfd; break; }
    memoryASet16(ds, 0x20d7af, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2b3b; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
  case 0x1d2b3b: // 0160:1d2b3b
    r16[ax] = 0x0003;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2b51; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
  case 0x1d2b51: // 0160:1d2b51
    r16[ax] = 0x0004;
  case 0x1d2b55: // 0160:1d2b55
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7ab, r16[ax]);
    r16[ax]--;
    memoryASet16(ds, 0x20d7a7, r16[ax]);
    if (!r16[ax])
        { pc = 0x1d2f5e; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d2e0e; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d2e95; break; }
    memoryASet16(ds, 0x20cf55, 0x00e0);
    memoryASet16(ds, 0x20cf67, 0x08f2);
    memoryASet16(ds, 0x20cf79, 0x0001);
    memoryASet16(ds, 0x20cf8b, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20d051, 0x0572);
    memoryASet16(ds, 0x20d04b, 0x0671);
    memoryASet16(ds, 0x20d04d, 0x0671);
    memoryASet16(ds, 0x20d04f, 0x0671);
    { pc = 0x1d3111; break; }
  case 0x1d2bfd: // 0160:1d2bfd
    memoryASet16(ds, 0x20d7ad, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    { pc = 0x1d2c23; break; }
  case 0x1d2c11: // 0160:1d2c11
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d2c23: // 0160:1d2c23
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d2ca2; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d2c90; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d2c7c; break; }
    memoryASet16(ds, 0x20d7af, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2b3b; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
    { pc = 0x1d2b3b; break; }
  case 0x1d2c7c: // 0160:1d2c7c
    memoryASet16(ds, 0x20d7ad, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    { pc = 0x1d2ca2; break; }
  case 0x1d2c90: // 0160:1d2c90
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d2ca2: // 0160:1d2ca2
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d2d3f; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d2d2d; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d2d19; break; }
    memoryASet16(ds, 0x20d7af, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2cf6; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
  case 0x1d2cf6: // 0160:1d2cf6
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2d10; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
  case 0x1d2d10: // 0160:1d2d10
    r16[ax] = 0x0004;
    { pc = 0x1d2b55; break; }
  case 0x1d2d19: // 0160:1d2d19
    memoryASet16(ds, 0x20d7ad, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    { pc = 0x1d2d3f; break; }
  case 0x1d2d2d: // 0160:1d2d2d
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d2d3f: // 0160:1d2d3f
    if (memoryAGet16(ds, 0x20cf8b) != 0x0034)
        { pc = 0x1d2ddc; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d2dca; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d2db6; break; }
    memoryASet16(ds, 0x20d7af, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2d93; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
  case 0x1d2d93: // 0160:1d2d93
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d2dad; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d2b55; break; }
  case 0x1d2dad: // 0160:1d2dad
    r16[ax] = 0x0003;
    { pc = 0x1d2b55; break; }
  case 0x1d2db6: // 0160:1d2db6
    memoryASet16(ds, 0x20d7ad, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    { pc = 0x1d2ddc; break; }
  case 0x1d2dca: // 0160:1d2dca
    memoryASet16(ds, 0x20d7a9, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
  case 0x1d2ddc: // 0160:1d2ddc
    { pc = 0x1d3338; break; }
  case 0x1d2de1: // 0160:1d2de1
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d2f2e; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (memoryAGet16(ds, 0x20cf85) == 0x0034)
        { pc = 0x1d2f1c; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0002)
        { pc = 0x1d2e95; break; }
  case 0x1d2e0e: // 0160:1d2e0e
    memoryASet16(ds, 0x20d7ab, 0x0002);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x00e0);
    memoryASet16(ds, 0x20cf63, 0x08f2);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04d, 0x0572);
    memoryASet16(ds, 0x20d04b, 0x0671);
    memoryASet16(ds, 0x20d04f, 0x0671);
    memoryASet16(ds, 0x20d051, 0x0671);
    { pc = 0x1d3111; break; }
  case 0x1d2e95: // 0160:1d2e95
    memoryASet16(ds, 0x20d7ab, 0x0003);
    memoryASet16(ds, 0x20d7a7, 0x0002);
    memoryASet16(ds, 0x20cf53, 0x00e0);
    memoryASet16(ds, 0x20cf65, 0x08f2);
    memoryASet16(ds, 0x20cf77, 0x0001);
    memoryASet16(ds, 0x20cf89, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04f, 0x0572);
    memoryASet16(ds, 0x20d04b, 0x0671);
    memoryASet16(ds, 0x20d04d, 0x0671);
    memoryASet16(ds, 0x20d051, 0x0671);
    { pc = 0x1d3111; break; }
  case 0x1d2f1c: // 0160:1d2f1c
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d2f2e: // 0160:1d2f2e
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d2ff7; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d2fe5; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d2e95; break; }
  case 0x1d2f5e: // 0160:1d2f5e
    memoryASet16(ds, 0x20d7ab, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x00e0);
    memoryASet16(ds, 0x20cf61, 0x08f2);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04b, 0x0572);
    memoryASet16(ds, 0x20d04d, 0x0671);
    memoryASet16(ds, 0x20d04f, 0x0671);
    memoryASet16(ds, 0x20d051, 0x0671);
    { pc = 0x1d3111; break; }
  case 0x1d2fe5: // 0160:1d2fe5
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d2ff7: // 0160:1d2ff7
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d303e; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d302c; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d2e0e; break; }
    { pc = 0x1d2f5e; break; }
  case 0x1d302c: // 0160:1d302c
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d303e: // 0160:1d303e
    { pc = 0x1d3338; break; }
  case 0x1d3043: // 0160:1d3043
    if (memoryAGet16(ds, 0x20cf87) == 0x0034)
        { pc = 0x1d30b7; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d3338; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x00e0);
    memoryASet16(ds, 0x20cf63, 0x08f2);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0034);
    memoryASet16(ds, 0x20cf73, 0x0034);
    memoryASet16(ds, 0x20d04d, 0x0572);
    memoryASet16(ds, 0x20d04b, 0x0671);
    { pc = 0x1d3111; break; }
  case 0x1d30b7: // 0160:1d30b7
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x00e0);
    memoryASet16(ds, 0x20cf61, 0x08f2);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0034);
    memoryASet16(ds, 0x20cf75, 0x0034);
    memoryASet16(ds, 0x20d04b, 0x0572);
    memoryASet16(ds, 0x20d04d, 0x0671);
  case 0x1d3111: // 0160:1d3111
    r16[ax] = 0x0128;
    r16[bx] = 0x0878;
    r16[cx] = 0x0190;
    r16[dx] = 0x08e0;
    yield* sub_1d359b();
    { pc = 0x1d3338; break; }
  case 0x1d312b: // 0160:1d312b
    if (memoryAGet16(ds, 0x20d17d) != 0x0001)
        { pc = 0x1d316b; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20cf97, 0x0100);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0008);
    memoryASet16(ds, 0x20cf85, 0x0008);
    memoryASet16(ds, 0x20d17d, 0x0000);
  case 0x1d316b: // 0160:1d316b
    if (memoryAGet16(ds, 0x20d17f) != 0x0001)
        { pc = 0x1d31ab; break; }
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20cf99, 0x0100);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0008);
    memoryASet16(ds, 0x20cf87, 0x0008);
    memoryASet16(ds, 0x20d17f, 0x0000);
  case 0x1d31ab: // 0160:1d31ab
    if (memoryAGet16(ds, 0x20d181) != 0x0001)
        { pc = 0x1d31eb; break; }
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20cf9b, 0x0100);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0008);
    memoryASet16(ds, 0x20cf89, 0x0008);
    memoryASet16(ds, 0x20d181, 0x0000);
  case 0x1d31eb: // 0160:1d31eb
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d322b; break; }
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20cf9d, 0x0100);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0008);
    memoryASet16(ds, 0x20cf8b, 0x0008);
    memoryASet16(ds, 0x20d183, 0x0000);
  case 0x1d322b: // 0160:1d322b
    memoryASet16(ds, 0x20d861, 0x0000);
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d3275; break; }
    memoryASet16(ds, 0x20d04b, 0x0273);
    memoryASet16(ds, 0x20cf4f, 0x00d6);
    memoryASet16(ds, 0x20cf61, 0x04f2);
    memoryASet16(ds, 0x20cf85, 0x0026);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d3275: // 0160:1d3275
    if (!(memoryAGet16(ds, 0x20d17f) & 0xffff))
        { pc = 0x1d32b6; break; }
    memoryASet16(ds, 0x20d04d, 0x0273);
    memoryASet16(ds, 0x20cf51, 0x00d6);
    memoryASet16(ds, 0x20cf63, 0x04f2);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d32b6: // 0160:1d32b6
    if (!(memoryAGet16(ds, 0x20d181) & 0xffff))
        { pc = 0x1d32f7; break; }
    memoryASet16(ds, 0x20d04f, 0x0273);
    memoryASet16(ds, 0x20cf53, 0x00d6);
    memoryASet16(ds, 0x20cf65, 0x04f2);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d32f7: // 0160:1d32f7
    if (!(memoryAGet16(ds, 0x20d183) & 0xffff))
        { pc = 0x1d3338; break; }
    memoryASet16(ds, 0x20d051, 0x0273);
    memoryASet16(ds, 0x20cf55, 0x00d6);
    memoryASet16(ds, 0x20cf67, 0x04f2);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d3338: // 0160:1d3338
    r32[esp] += 4; return;
    // gap 792 bytes // gap 792 bytes
  case 0x1d3651: // 0160:1d3651
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1d38be; break; }
    r16[ax] = 0x0082;
    yield* sub_1d3339();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1d38bf; break; }
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d368a; break; }
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) - 0x0001);
  case 0x1d368a: // 0160:1d368a
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d36a8; break; }
    if (memoryAGet(ds, 0x20d125) != 0x38)
        { pc = 0x1d3715; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x002a)
        { pc = 0x1d3715; break; }
  case 0x1d36a8: // 0160:1d36a8
    memoryASet16(ds, 0x20cf51, 0x0608);
    memoryASet16(ds, 0x20cf63, 0x0714);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) - 0x0001);
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d3715; break; }
    memoryASet16(ds, 0x20cf87, 0x0018);
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20d04d, 0x0620);
    memoryASet16(ds, 0x20cf99, 0x0300);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0018);
  case 0x1d3715: // 0160:1d3715
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d3733; break; }
    if (memoryAGet(ds, 0x20d127) != 0x38)
        { pc = 0x1d37a0; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x002a)
        { pc = 0x1d37a0; break; }
  case 0x1d3733: // 0160:1d3733
    memoryASet16(ds, 0x20cf53, 0x0608);
    memoryASet16(ds, 0x20cf65, 0x0714);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) - 0x0001);
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d37a0; break; }
    memoryASet16(ds, 0x20cf89, 0x0018);
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20d04f, 0x0620);
    memoryASet16(ds, 0x20cf9b, 0x0300);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0018);
  case 0x1d37a0: // 0160:1d37a0
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d37be; break; }
    if (memoryAGet(ds, 0x20d129) != 0x38)
        { pc = 0x1d382b; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x002a)
        { pc = 0x1d382b; break; }
  case 0x1d37be: // 0160:1d37be
    memoryASet16(ds, 0x20cf55, 0x0608);
    memoryASet16(ds, 0x20cf67, 0x0714);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) - 0x0001);
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d382b; break; }
    memoryASet16(ds, 0x20cf8b, 0x0018);
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20d051, 0x0620);
    memoryASet16(ds, 0x20cf9d, 0x0300);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0018);
  case 0x1d382b: // 0160:1d382b
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d3849; break; }
    if (memoryAGet(ds, 0x20d123) != 0x38)
        { pc = 0x1d38be; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x002a)
        { pc = 0x1d38be; break; }
  case 0x1d3849: // 0160:1d3849
    memoryASet16(ds, 0x20d861, 0x0001);
    memoryASet16(ds, 0x20cf4f, 0x0608);
    memoryASet16(ds, 0x20cf61, 0x0714);
    memoryASet16(ds, 0x20cf85, 0x0018);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    if (memoryAGet16(ds, 0x20d17d) & 0xffff)
        { pc = 0x1d38be; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20d04b, 0x0620);
    memoryASet16(ds, 0x20cf97, 0x0300);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0018);
    memoryASet16(ds, 0x20d861, 0x0000);
  case 0x1d38be: // 0160:1d38be
    r32[esp] += 4; return;
  case 0x1d38bf: // 0160:1d38bf
    yield* sub_1d33a0();
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d3f6d; break; }
    yield* sub_1d3411();
    if (memoryAGet16(ds, 0x20d17d) == 0x0001)
        { pc = 0x1d3904; break; }
    if (memoryAGet16(ds, 0x20d17f) == 0x0001)
        { pc = 0x1d3904; break; }
    if (memoryAGet16(ds, 0x20d181) == 0x0001)
        { pc = 0x1d3904; break; }
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d417a; break; }
  case 0x1d3904: // 0160:1d3904
    r16[ax] = 0x00c8;
    yield* sub_1d34d9();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1d3e85; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1d3c23; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d3a65; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d3a53; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d3a3f; break; }
    memoryASet16(ds, 0x20d7af, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d397d; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
  case 0x1d397d: // 0160:1d397d
    r16[ax] = 0x0003;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d3993; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
  case 0x1d3993: // 0160:1d3993
    r16[ax] = 0x0004;
  case 0x1d3997: // 0160:1d3997
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7ab, r16[ax]);
    r16[ax]--;
    memoryASet16(ds, 0x20d7a7, r16[ax]);
    if (!r16[ax])
        { pc = 0x1d3da0; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d3c50; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d3cd7; break; }
    memoryASet16(ds, 0x20cf55, 0x05fa);
    memoryASet16(ds, 0x20cf67, 0x00fa);
    memoryASet16(ds, 0x20cf79, 0x0001);
    memoryASet16(ds, 0x20cf8b, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20d051, 0x011f);
    memoryASet16(ds, 0x20d04b, 0x011e);
    memoryASet16(ds, 0x20d04d, 0x011e);
    memoryASet16(ds, 0x20d04f, 0x011e);
    { pc = 0x1d3f53; break; }
  case 0x1d3a3f: // 0160:1d3a3f
    memoryASet16(ds, 0x20d7ad, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    { pc = 0x1d3a65; break; }
  case 0x1d3a53: // 0160:1d3a53
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d3a65: // 0160:1d3a65
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d3ae4; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d3ad2; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d3abe; break; }
    memoryASet16(ds, 0x20d7af, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d397d; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
    { pc = 0x1d397d; break; }
  case 0x1d3abe: // 0160:1d3abe
    memoryASet16(ds, 0x20d7ad, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    { pc = 0x1d3ae4; break; }
  case 0x1d3ad2: // 0160:1d3ad2
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d3ae4: // 0160:1d3ae4
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d3b81; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d3b6f; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d3b5b; break; }
    memoryASet16(ds, 0x20d7af, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d3b38; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
  case 0x1d3b38: // 0160:1d3b38
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d3b52; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
  case 0x1d3b52: // 0160:1d3b52
    r16[ax] = 0x0004;
    { pc = 0x1d3997; break; }
  case 0x1d3b5b: // 0160:1d3b5b
    memoryASet16(ds, 0x20d7ad, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    { pc = 0x1d3b81; break; }
  case 0x1d3b6f: // 0160:1d3b6f
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d3b81: // 0160:1d3b81
    if (memoryAGet16(ds, 0x20cf8b) != 0x0034)
        { pc = 0x1d3c1e; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d3c0c; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d3bf8; break; }
    memoryASet16(ds, 0x20d7af, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d3bd5; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
  case 0x1d3bd5: // 0160:1d3bd5
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d3bef; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d3997; break; }
  case 0x1d3bef: // 0160:1d3bef
    r16[ax] = 0x0003;
    { pc = 0x1d3997; break; }
  case 0x1d3bf8: // 0160:1d3bf8
    memoryASet16(ds, 0x20d7ad, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    { pc = 0x1d3c1e; break; }
  case 0x1d3c0c: // 0160:1d3c0c
    memoryASet16(ds, 0x20d7a9, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
  case 0x1d3c1e: // 0160:1d3c1e
    { pc = 0x1d417a; break; }
  case 0x1d3c23: // 0160:1d3c23
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d3d70; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (memoryAGet16(ds, 0x20cf85) == 0x0034)
        { pc = 0x1d3d5e; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0002)
        { pc = 0x1d3cd7; break; }
  case 0x1d3c50: // 0160:1d3c50
    memoryASet16(ds, 0x20d7ab, 0x0002);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x05fa);
    memoryASet16(ds, 0x20cf63, 0x00fa);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04d, 0x011f);
    memoryASet16(ds, 0x20d04b, 0x011e);
    memoryASet16(ds, 0x20d04f, 0x011e);
    memoryASet16(ds, 0x20d051, 0x011e);
    { pc = 0x1d3f53; break; }
  case 0x1d3cd7: // 0160:1d3cd7
    memoryASet16(ds, 0x20d7ab, 0x0003);
    memoryASet16(ds, 0x20d7a7, 0x0002);
    memoryASet16(ds, 0x20cf53, 0x05fa);
    memoryASet16(ds, 0x20cf65, 0x00fa);
    memoryASet16(ds, 0x20cf77, 0x0001);
    memoryASet16(ds, 0x20cf89, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04f, 0x011f);
    memoryASet16(ds, 0x20d04b, 0x011e);
    memoryASet16(ds, 0x20d04d, 0x011e);
    memoryASet16(ds, 0x20d051, 0x011e);
    { pc = 0x1d3f53; break; }
  case 0x1d3d5e: // 0160:1d3d5e
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d3d70: // 0160:1d3d70
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d3e39; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d3e27; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d3cd7; break; }
  case 0x1d3da0: // 0160:1d3da0
    memoryASet16(ds, 0x20d7ab, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x05fa);
    memoryASet16(ds, 0x20cf61, 0x00fa);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04b, 0x011f);
    memoryASet16(ds, 0x20d04d, 0x011e);
    memoryASet16(ds, 0x20d04f, 0x011e);
    memoryASet16(ds, 0x20d051, 0x011e);
    { pc = 0x1d3f53; break; }
  case 0x1d3e27: // 0160:1d3e27
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d3e39: // 0160:1d3e39
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d3e80; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d3e6e; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d3c50; break; }
    { pc = 0x1d3da0; break; }
  case 0x1d3e6e: // 0160:1d3e6e
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d3e80: // 0160:1d3e80
    { pc = 0x1d417a; break; }
  case 0x1d3e85: // 0160:1d3e85
    if (memoryAGet16(ds, 0x20cf87) == 0x0034)
        { pc = 0x1d3ef9; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d417a; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x05fa);
    memoryASet16(ds, 0x20cf63, 0x00fa);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0034);
    memoryASet16(ds, 0x20cf73, 0x0034);
    memoryASet16(ds, 0x20d04d, 0x011f);
    memoryASet16(ds, 0x20d04b, 0x011e);
    { pc = 0x1d3f53; break; }
  case 0x1d3ef9: // 0160:1d3ef9
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x05fa);
    memoryASet16(ds, 0x20cf61, 0x00fa);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0034);
    memoryASet16(ds, 0x20cf75, 0x0034);
    memoryASet16(ds, 0x20d04b, 0x011f);
    memoryASet16(ds, 0x20d04d, 0x011e);
  case 0x1d3f53: // 0160:1d3f53
    r16[ax] = 0x0578;
    r16[bx] = 0x0124;
    r16[cx] = 0x05c8;
    r16[dx] = 0x0174;
    yield* sub_1d359b();
    { pc = 0x1d417a; break; }
  case 0x1d3f6d: // 0160:1d3f6d
    if (memoryAGet16(ds, 0x20d17d) != 0x0001)
        { pc = 0x1d3fad; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20cf97, 0x0300);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0018);
    memoryASet16(ds, 0x20cf85, 0x0018);
    memoryASet16(ds, 0x20d17d, 0x0000);
  case 0x1d3fad: // 0160:1d3fad
    if (memoryAGet16(ds, 0x20d17f) != 0x0001)
        { pc = 0x1d3fed; break; }
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20cf99, 0x0300);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0018);
    memoryASet16(ds, 0x20cf87, 0x0018);
    memoryASet16(ds, 0x20d17f, 0x0000);
  case 0x1d3fed: // 0160:1d3fed
    if (memoryAGet16(ds, 0x20d181) != 0x0001)
        { pc = 0x1d402d; break; }
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20cf9b, 0x0300);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0018);
    memoryASet16(ds, 0x20cf89, 0x0018);
    memoryASet16(ds, 0x20d181, 0x0000);
  case 0x1d402d: // 0160:1d402d
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d406d; break; }
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20cf9d, 0x0300);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0018);
    memoryASet16(ds, 0x20cf8b, 0x0018);
    memoryASet16(ds, 0x20d183, 0x0000);
  case 0x1d406d: // 0160:1d406d
    memoryASet16(ds, 0x20d861, 0x0000);
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d40b7; break; }
    memoryASet16(ds, 0x20d04b, 0x0633);
    memoryASet16(ds, 0x20cf4f, 0x0608);
    memoryASet16(ds, 0x20cf61, 0x0714);
    memoryASet16(ds, 0x20cf85, 0x0026);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d40b7: // 0160:1d40b7
    if (!(memoryAGet16(ds, 0x20d17f) & 0xffff))
        { pc = 0x1d40f8; break; }
    memoryASet16(ds, 0x20d04d, 0x0620);
    memoryASet16(ds, 0x20cf51, 0x0608);
    memoryASet16(ds, 0x20cf63, 0x0714);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d40f8: // 0160:1d40f8
    if (!(memoryAGet16(ds, 0x20d181) & 0xffff))
        { pc = 0x1d4139; break; }
    memoryASet16(ds, 0x20d04f, 0x0620);
    memoryASet16(ds, 0x20cf53, 0x0608);
    memoryASet16(ds, 0x20cf65, 0x0714);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d4139: // 0160:1d4139
    if (!(memoryAGet16(ds, 0x20d183) & 0xffff))
        { pc = 0x1d417a; break; }
    memoryASet16(ds, 0x20d051, 0x0620);
    memoryASet16(ds, 0x20cf55, 0x0608);
    memoryASet16(ds, 0x20cf67, 0x0714);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d417a: // 0160:1d417a
    r32[esp] += 4; return;
  case 0x1d417b: // 0160:1d417b
    r16[ax] = memoryAGet16(ds, 0x20d375);
    r16[bx] = memoryAGet16(ds, 0x20d377);
    yield* sub_1d348a();
    r16[ax] = memoryAGet16(ds, 0x20d37f);
    r16[bx] = memoryAGet16(ds, 0x20d381);
    yield* sub_1d348a();
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1d440c; break; }
    r16[ax] = 0x005a;
    yield* sub_1d3339();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1d440d; break; }
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d41d8; break; }
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) - 0x0001);
  case 0x1d41d8: // 0160:1d41d8
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d41f6; break; }
    if (memoryAGet(ds, 0x20d125) != 0x38)
        { pc = 0x1d4263; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x002a)
        { pc = 0x1d4263; break; }
  case 0x1d41f6: // 0160:1d41f6
    memoryASet16(ds, 0x20cf51, 0x00f6);
    memoryASet16(ds, 0x20cf63, 0x0464);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) - 0x0001);
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d4263; break; }
    memoryASet16(ds, 0x20cf87, 0x0004);
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20d04d, 0x011f);
    memoryASet16(ds, 0x20cf99, 0x0080);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0004);
  case 0x1d4263: // 0160:1d4263
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d4281; break; }
    if (memoryAGet(ds, 0x20d127) != 0x38)
        { pc = 0x1d42ee; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x002a)
        { pc = 0x1d42ee; break; }
  case 0x1d4281: // 0160:1d4281
    memoryASet16(ds, 0x20cf53, 0x00f6);
    memoryASet16(ds, 0x20cf65, 0x0464);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) - 0x0001);
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d42ee; break; }
    memoryASet16(ds, 0x20cf89, 0x0004);
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20d04f, 0x011f);
    memoryASet16(ds, 0x20cf9b, 0x0080);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0004);
  case 0x1d42ee: // 0160:1d42ee
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d430c; break; }
    if (memoryAGet(ds, 0x20d129) != 0x38)
        { pc = 0x1d4379; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x002a)
        { pc = 0x1d4379; break; }
  case 0x1d430c: // 0160:1d430c
    memoryASet16(ds, 0x20cf55, 0x00f6);
    memoryASet16(ds, 0x20cf67, 0x0464);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) - 0x0001);
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d4379; break; }
    memoryASet16(ds, 0x20cf8b, 0x0004);
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20d051, 0x011f);
    memoryASet16(ds, 0x20cf9d, 0x0080);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0004);
  case 0x1d4379: // 0160:1d4379
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d4397; break; }
    if (memoryAGet(ds, 0x20d123) != 0x38)
        { pc = 0x1d440c; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x002a)
        { pc = 0x1d440c; break; }
  case 0x1d4397: // 0160:1d4397
    memoryASet16(ds, 0x20d861, 0x0001);
    memoryASet16(ds, 0x20cf4f, 0x00f6);
    memoryASet16(ds, 0x20cf61, 0x0464);
    memoryASet16(ds, 0x20cf85, 0x0004);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    if (memoryAGet16(ds, 0x20d17d) & 0xffff)
        { pc = 0x1d440c; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20d04b, 0x011f);
    memoryASet16(ds, 0x20cf97, 0x0080);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0004);
    memoryASet16(ds, 0x20d861, 0x0000);
  case 0x1d440c: // 0160:1d440c
    r32[esp] += 4; return;
  case 0x1d440d: // 0160:1d440d
    yield* sub_1d33a0();
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d4abb; break; }
    yield* sub_1d3411();
    if (memoryAGet16(ds, 0x20d17d) == 0x0001)
        { pc = 0x1d4452; break; }
    if (memoryAGet16(ds, 0x20d17f) == 0x0001)
        { pc = 0x1d4452; break; }
    if (memoryAGet16(ds, 0x20d181) == 0x0001)
        { pc = 0x1d4452; break; }
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d4cc8; break; }
  case 0x1d4452: // 0160:1d4452
    r16[ax] = 0x008c;
    yield* sub_1d34d9();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1d49d3; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1d4771; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d45b3; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d45a1; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d458d; break; }
    memoryASet16(ds, 0x20d7af, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d44cb; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
  case 0x1d44cb: // 0160:1d44cb
    r16[ax] = 0x0003;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d44e1; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
  case 0x1d44e1: // 0160:1d44e1
    r16[ax] = 0x0004;
  case 0x1d44e5: // 0160:1d44e5
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7ab, r16[ax]);
    r16[ax]--;
    memoryASet16(ds, 0x20d7a7, r16[ax]);
    if (!r16[ax])
        { pc = 0x1d48ee; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d479e; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d4825; break; }
    memoryASet16(ds, 0x20cf55, 0x00f6);
    memoryASet16(ds, 0x20cf67, 0x00fa);
    memoryASet16(ds, 0x20cf79, 0x0001);
    memoryASet16(ds, 0x20cf8b, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20d051, 0x071e);
    memoryASet16(ds, 0x20d04b, 0x071d);
    memoryASet16(ds, 0x20d04d, 0x071d);
    memoryASet16(ds, 0x20d04f, 0x071d);
    { pc = 0x1d4aa1; break; }
  case 0x1d458d: // 0160:1d458d
    memoryASet16(ds, 0x20d7ad, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    { pc = 0x1d45b3; break; }
  case 0x1d45a1: // 0160:1d45a1
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d45b3: // 0160:1d45b3
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d4632; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d4620; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d460c; break; }
    memoryASet16(ds, 0x20d7af, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d44cb; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
    { pc = 0x1d44cb; break; }
  case 0x1d460c: // 0160:1d460c
    memoryASet16(ds, 0x20d7ad, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    { pc = 0x1d4632; break; }
  case 0x1d4620: // 0160:1d4620
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d4632: // 0160:1d4632
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d46cf; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d46bd; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d46a9; break; }
    memoryASet16(ds, 0x20d7af, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d4686; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
  case 0x1d4686: // 0160:1d4686
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d46a0; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
  case 0x1d46a0: // 0160:1d46a0
    r16[ax] = 0x0004;
    { pc = 0x1d44e5; break; }
  case 0x1d46a9: // 0160:1d46a9
    memoryASet16(ds, 0x20d7ad, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    { pc = 0x1d46cf; break; }
  case 0x1d46bd: // 0160:1d46bd
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d46cf: // 0160:1d46cf
    if (memoryAGet16(ds, 0x20cf8b) != 0x0034)
        { pc = 0x1d476c; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d475a; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d4746; break; }
    memoryASet16(ds, 0x20d7af, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d4723; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
  case 0x1d4723: // 0160:1d4723
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d473d; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d44e5; break; }
  case 0x1d473d: // 0160:1d473d
    r16[ax] = 0x0003;
    { pc = 0x1d44e5; break; }
  case 0x1d4746: // 0160:1d4746
    memoryASet16(ds, 0x20d7ad, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    { pc = 0x1d476c; break; }
  case 0x1d475a: // 0160:1d475a
    memoryASet16(ds, 0x20d7a9, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
  case 0x1d476c: // 0160:1d476c
    { pc = 0x1d4cc8; break; }
  case 0x1d4771: // 0160:1d4771
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d48be; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (memoryAGet16(ds, 0x20cf85) == 0x0034)
        { pc = 0x1d48ac; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0002)
        { pc = 0x1d4825; break; }
  case 0x1d479e: // 0160:1d479e
    memoryASet16(ds, 0x20d7ab, 0x0002);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x00f6);
    memoryASet16(ds, 0x20cf63, 0x00fa);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04d, 0x071e);
    memoryASet16(ds, 0x20d04b, 0x071d);
    memoryASet16(ds, 0x20d04f, 0x071d);
    memoryASet16(ds, 0x20d051, 0x071d);
    { pc = 0x1d4aa1; break; }
  case 0x1d4825: // 0160:1d4825
    memoryASet16(ds, 0x20d7ab, 0x0003);
    memoryASet16(ds, 0x20d7a7, 0x0002);
    memoryASet16(ds, 0x20cf53, 0x00f6);
    memoryASet16(ds, 0x20cf65, 0x00fa);
    memoryASet16(ds, 0x20cf77, 0x0001);
    memoryASet16(ds, 0x20cf89, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04f, 0x071e);
    memoryASet16(ds, 0x20d04b, 0x071d);
    memoryASet16(ds, 0x20d04d, 0x071d);
    memoryASet16(ds, 0x20d051, 0x071d);
    { pc = 0x1d4aa1; break; }
  case 0x1d48ac: // 0160:1d48ac
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d48be: // 0160:1d48be
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d4987; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d4975; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d4825; break; }
  case 0x1d48ee: // 0160:1d48ee
    memoryASet16(ds, 0x20d7ab, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x00f6);
    memoryASet16(ds, 0x20cf61, 0x00fa);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04b, 0x071e);
    memoryASet16(ds, 0x20d04d, 0x071d);
    memoryASet16(ds, 0x20d04f, 0x071d);
    memoryASet16(ds, 0x20d051, 0x071d);
    { pc = 0x1d4aa1; break; }
  case 0x1d4975: // 0160:1d4975
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d4987: // 0160:1d4987
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d49ce; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d49bc; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d479e; break; }
    { pc = 0x1d48ee; break; }
  case 0x1d49bc: // 0160:1d49bc
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d49ce: // 0160:1d49ce
    { pc = 0x1d4cc8; break; }
  case 0x1d49d3: // 0160:1d49d3
    if (memoryAGet16(ds, 0x20cf87) == 0x0034)
        { pc = 0x1d4a47; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d4cc8; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x00f6);
    memoryASet16(ds, 0x20cf63, 0x00fa);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0034);
    memoryASet16(ds, 0x20cf73, 0x0034);
    memoryASet16(ds, 0x20d04d, 0x071e);
    memoryASet16(ds, 0x20d04b, 0x071d);
    { pc = 0x1d4aa1; break; }
  case 0x1d4a47: // 0160:1d4a47
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x00f6);
    memoryASet16(ds, 0x20cf61, 0x00fa);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0034);
    memoryASet16(ds, 0x20cf75, 0x0034);
    memoryASet16(ds, 0x20d04b, 0x071e);
    memoryASet16(ds, 0x20d04d, 0x071d);
  case 0x1d4aa1: // 0160:1d4aa1
    r16[ax] = 0x0138;
    r16[bx] = 0x01b0;
    r16[cx] = 0x0190;
    r16[dx] = 0x0158;
    yield* sub_1d359b();
    { pc = 0x1d4cc8; break; }
  case 0x1d4abb: // 0160:1d4abb
    if (memoryAGet16(ds, 0x20d17d) != 0x0001)
        { pc = 0x1d4afb; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20cf97, 0x0080);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0004);
    memoryASet16(ds, 0x20cf85, 0x0004);
    memoryASet16(ds, 0x20d17d, 0x0000);
  case 0x1d4afb: // 0160:1d4afb
    if (memoryAGet16(ds, 0x20d17f) != 0x0001)
        { pc = 0x1d4b3b; break; }
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20cf99, 0x0080);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0004);
    memoryASet16(ds, 0x20cf87, 0x0004);
    memoryASet16(ds, 0x20d17f, 0x0000);
  case 0x1d4b3b: // 0160:1d4b3b
    if (memoryAGet16(ds, 0x20d181) != 0x0001)
        { pc = 0x1d4b7b; break; }
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20cf9b, 0x0080);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0004);
    memoryASet16(ds, 0x20cf89, 0x0004);
    memoryASet16(ds, 0x20d181, 0x0000);
  case 0x1d4b7b: // 0160:1d4b7b
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d4bbb; break; }
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20cf9d, 0x0080);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0004);
    memoryASet16(ds, 0x20d183, 0x0000);
  case 0x1d4bbb: // 0160:1d4bbb
    memoryASet16(ds, 0x20d861, 0x0000);
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d4c05; break; }
    memoryASet16(ds, 0x20d04b, 0x011f);
    memoryASet16(ds, 0x20cf4f, 0x00f6);
    memoryASet16(ds, 0x20cf61, 0x0464);
    memoryASet16(ds, 0x20cf85, 0x0026);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d4c05: // 0160:1d4c05
    if (!(memoryAGet16(ds, 0x20d17f) & 0xffff))
        { pc = 0x1d4c46; break; }
    memoryASet16(ds, 0x20d04d, 0x011f);
    memoryASet16(ds, 0x20cf51, 0x00f6);
    memoryASet16(ds, 0x20cf63, 0x0464);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d4c46: // 0160:1d4c46
    if (!(memoryAGet16(ds, 0x20d181) & 0xffff))
        { pc = 0x1d4c87; break; }
    memoryASet16(ds, 0x20d04f, 0x011f);
    memoryASet16(ds, 0x20cf53, 0x00f6);
    memoryASet16(ds, 0x20cf65, 0x0464);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d4c87: // 0160:1d4c87
    if (!(memoryAGet16(ds, 0x20d183) & 0xffff))
        { pc = 0x1d4cc8; break; }
    memoryASet16(ds, 0x20d051, 0x011f);
    memoryASet16(ds, 0x20cf55, 0x00f6);
    memoryASet16(ds, 0x20cf67, 0x0464);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d4cc8: // 0160:1d4cc8
    r32[esp] += 4; return;
  case 0x1d4cc9: // 0160:1d4cc9
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    if (r16[ax])
        { pc = 0x1d4d46; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d4dd2();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1d4dd2();
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d4d16; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1d4dd2();
  case 0x1d4d16: // 0160:1d4d16
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1d4dd2();
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000028;
  case 0x1d4d32: // 0160:1d4d32
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r16[ax])
        { pc = 0x1d4d3e; break; }
    r16[ax]--;
  case 0x1d4d3e: // 0160:1d4d3e
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[esi] += 0x00000002;
    if (--r32[ecx])
        { pc = 0x1d4d32; break; }
  case 0x1d4d46: // 0160:1d4d46
    memoryASet16(ds, 0x20ceb3, 0x04df);
    memoryASet16(ds, 0x20ceb5, 0x01bf);
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000028;
  case 0x1d4d62: // 0160:1d4d62
    r16[ax] = memoryAGet16(ds, r32[esi]);
    if (!r16[ax])
        { pc = 0x1d4dc4; break; }
    r16[ax] += 0x006f;
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[cx] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d4d96; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d4dc2; break; }
  case 0x1d4d96: // 0160:1d4d96
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d4dac; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d4dc2; break; }
  case 0x1d4dac: // 0160:1d4dac
    if (r16[bx] >= 0x0178)
        { pc = 0x1d4dc2; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d4dc2; break; }
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
  case 0x1d4dc2: // 0160:1d4dc2
    r32[esi] = pop32();
    r32[ecx] = pop32();
  case 0x1d4dc4: // 0160:1d4dc4
    r32[esi] += 0x00000002;
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0010);
    if (--r32[ecx])
        { pc = 0x1d4d62; break; }
    r32[esp] += 4; return;
    // gap 93 bytes // gap 93 bytes
  case 0x1d4e2f: // 0160:1d4e2f
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[cx] = memoryAGet16(ds, 0x20d371);
    yield* sub_1d4f07();
    r16[ax] = memoryAGet16(ds, 0x20d379);
    r16[bx] = memoryAGet16(ds, 0x20d37b);
    r16[cx] = memoryAGet16(ds, 0x20d37d);
    yield* sub_1d4f07();
    r32[esi] = 0x0020d385;
    r32[ecx] = 0x0000002f;
  case 0x1d4e6b: // 0160:1d4e6b
    if (!(memoryAGet16(ds, r32[esi]) & 0xffff))
        { pc = 0x1d4e76; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0001);
  case 0x1d4e76: // 0160:1d4e76
    r32[esi] += 0x00000008;
    if (--r32[ecx])
        { pc = 0x1d4e6b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d4e8e();
    r32[esp] += 4; return;
    // gap 251 bytes // gap 251 bytes
  case 0x1d4f89: // 0160:1d4f89
    if (signed16(memoryAGet16(ds, 0x20cf23)) <= signed16(0x02f8))
        { pc = 0x1d4fd9; break; }
    if (signed16(memoryAGet16(ds, 0x20cf25)) >= signed16(0x0172))
        { pc = 0x1d4fd9; break; }
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1d4fed; break; }
    memoryASet16(ds, 0x20e7d7, 0x0000);
    memoryASet16(ds, 0x20e7d9, 0x0000);
    memoryASet16(ds, 0x20e7db, 0x0000);
    memoryASet16(ds, 0x20e7dd, 0x0000);
    memoryASet16(ds, 0x20d897, 0x0001);
    { pc = 0x1d4fed; break; }
  case 0x1d4fd9: // 0160:1d4fd9
    if (!(memoryAGet16(ds, 0x20d897) & 0xffff))
        { pc = 0x1d4fed; break; }
    memoryASet16(ds, 0x20d897, 0x0000);
  case 0x1d4fed: // 0160:1d4fed
    memoryASet16(ds, 0x20d1e9, 0x0000);
    if (memoryAGet(ds, 0x20d123) != 0x38)
        { pc = 0x1d507f; break; }
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf61);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1e1);
    memoryASet16(ds, 0x20d1eb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1d7);
    memoryASet16(ds, 0x20d1df, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1ed);
    memoryASet16(ds, 0x20d1f5, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c840);
    memoryASet(ds, 0x20c848, r8[al]);
    r32[eax] = pop32();
    yield* sub_1d562f();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf4f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf61, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d873);
    memoryASet16(ds, 0x20d1ed, r16[ax]);
    if (memoryAGet16(ds, 0x20d1e9) & 0xffff)
        { pc = 0x1d50a4; break; }
  case 0x1d507f: // 0160:1d507f
    if (!(memoryAGet16(ds, 0x20d1e1) & 0xffff))
        { pc = 0x1d50f8; break; }
    r16[ax] = memoryAGet16(ds, 0x20d1d7);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x20cf97, r16[ax]);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    { pc = 0x1d50f8; break; }
  case 0x1d50a4: // 0160:1d50a4
    if (!(memoryAGet16(ds, 0x20d1e1) & 0xffff))
        { pc = 0x1d50e2; break; }
    r16[ax] = memoryAGet16(ds, 0x20d875);
    r16[bx] = memoryAGet16(ds, 0x20d1d7);
    r16[ax] >>>= 4;
    r16[bx] >>>= 4;
    if (r16[ax] == r16[bx])
        { pc = 0x1d50e2; break; }
    r8[al] = memoryAGet(ds, 0x20c840);
    r8[al] &= 0x0c;
    if (r8[al])
        { pc = 0x1d50e2; break; }
    memoryASet16(ds, 0x20cf73, memoryAGet16(ds, 0x20cf73) + 0x0001);
    memoryASet16(ds, 0x20cf73, memoryAGet16(ds, 0x20cf73) & 0x001f);
  case 0x1d50e2: // 0160:1d50e2
    r16[ax] = memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d1d7, r16[ax]);
    memoryASet16(ds, 0x20d1e1, memoryAGet16(ds, 0x20d1e1) + 0x0001);
    { pc = 0x1d5104; break; }
  case 0x1d50f8: // 0160:1d50f8
    r16[ax] = memoryAGet16(ds, 0x20d1e9);
    memoryASet16(ds, 0x20d1e1, r16[ax]);
  case 0x1d5104: // 0160:1d5104
    memoryASet16(ds, 0x20d1e9, 0x0000);
    if (memoryAGet(ds, 0x20d125) != 0x38)
        { pc = 0x1d5196; break; }
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf63);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1e3);
    memoryASet16(ds, 0x20d1eb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1d9);
    memoryASet16(ds, 0x20d1df, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1ef);
    memoryASet16(ds, 0x20d1f5, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c841);
    memoryASet(ds, 0x20c848, r8[al]);
    r32[eax] = pop32();
    yield* sub_1d562f();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf51, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf63, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d873);
    memoryASet16(ds, 0x20d1ef, r16[ax]);
    if (memoryAGet16(ds, 0x20d1e9) & 0xffff)
        { pc = 0x1d51bb; break; }
  case 0x1d5196: // 0160:1d5196
    if (!(memoryAGet16(ds, 0x20d1e3) & 0xffff))
        { pc = 0x1d520f; break; }
    r16[ax] = memoryAGet16(ds, 0x20d1d9);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x20cf99, r16[ax]);
    memoryASet16(ds, 0x20cfab, 0x0180);
    { pc = 0x1d520f; break; }
  case 0x1d51bb: // 0160:1d51bb
    if (!(memoryAGet16(ds, 0x20d1e3) & 0xffff))
        { pc = 0x1d51f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20d875);
    r16[bx] = memoryAGet16(ds, 0x20d1d9);
    r16[ax] >>>= 4;
    r16[bx] >>>= 4;
    if (r16[ax] == r16[bx])
        { pc = 0x1d51f9; break; }
    r8[al] = memoryAGet(ds, 0x20c841);
    r8[al] &= 0x0c;
    if (r8[al])
        { pc = 0x1d51f9; break; }
    memoryASet16(ds, 0x20cf75, memoryAGet16(ds, 0x20cf75) + 0x0001);
    memoryASet16(ds, 0x20cf75, memoryAGet16(ds, 0x20cf75) & 0x001f);
  case 0x1d51f9: // 0160:1d51f9
    r16[ax] = memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d1d9, r16[ax]);
    memoryASet16(ds, 0x20d1e3, memoryAGet16(ds, 0x20d1e3) + 0x0001);
    { pc = 0x1d521b; break; }
  case 0x1d520f: // 0160:1d520f
    r16[ax] = memoryAGet16(ds, 0x20d1e9);
    memoryASet16(ds, 0x20d1e3, r16[ax]);
  case 0x1d521b: // 0160:1d521b
    memoryASet16(ds, 0x20d1e9, 0x0000);
    if (memoryAGet(ds, 0x20d127) != 0x38)
        { pc = 0x1d52ad; break; }
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf65);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1e5);
    memoryASet16(ds, 0x20d1eb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1db);
    memoryASet16(ds, 0x20d1df, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1f1);
    memoryASet16(ds, 0x20d1f5, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c842);
    memoryASet(ds, 0x20c848, r8[al]);
    r32[eax] = pop32();
    yield* sub_1d562f();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf53, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf65, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d873);
    memoryASet16(ds, 0x20d1f1, r16[ax]);
    if (memoryAGet16(ds, 0x20d1e9) & 0xffff)
        { pc = 0x1d52d2; break; }
  case 0x1d52ad: // 0160:1d52ad
    if (!(memoryAGet16(ds, 0x20d1e5) & 0xffff))
        { pc = 0x1d5326; break; }
    r16[ax] = memoryAGet16(ds, 0x20d1db);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x20cf9b, r16[ax]);
    memoryASet16(ds, 0x20cfad, 0x0180);
    { pc = 0x1d5326; break; }
  case 0x1d52d2: // 0160:1d52d2
    if (!(memoryAGet16(ds, 0x20d1e5) & 0xffff))
        { pc = 0x1d5310; break; }
    r16[ax] = memoryAGet16(ds, 0x20d875);
    r16[bx] = memoryAGet16(ds, 0x20d1db);
    r16[ax] >>>= 4;
    r16[bx] >>>= 4;
    if (r16[ax] == r16[bx])
        { pc = 0x1d5310; break; }
    r8[al] = memoryAGet(ds, 0x20c842);
    r8[al] &= 0x0c;
    if (r8[al])
        { pc = 0x1d5310; break; }
    memoryASet16(ds, 0x20cf77, memoryAGet16(ds, 0x20cf77) + 0x0001);
    memoryASet16(ds, 0x20cf77, memoryAGet16(ds, 0x20cf77) & 0x001f);
  case 0x1d5310: // 0160:1d5310
    r16[ax] = memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d1db, r16[ax]);
    memoryASet16(ds, 0x20d1e5, memoryAGet16(ds, 0x20d1e5) + 0x0001);
    { pc = 0x1d5332; break; }
  case 0x1d5326: // 0160:1d5326
    r16[ax] = memoryAGet16(ds, 0x20d1e9);
    memoryASet16(ds, 0x20d1e5, r16[ax]);
  case 0x1d5332: // 0160:1d5332
    memoryASet16(ds, 0x20d1e9, 0x0000);
    if (memoryAGet(ds, 0x20d129) != 0x38)
        { pc = 0x1d53c4; break; }
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    memoryASet16(ds, 0x20cf5f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf67);
    memoryASet16(ds, 0x20cf71, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1e7);
    memoryASet16(ds, 0x20d1eb, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1dd);
    memoryASet16(ds, 0x20d1df, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1f3);
    memoryASet16(ds, 0x20d1f5, r16[ax]);
    r8[al] = memoryAGet(ds, 0x20c843);
    memoryASet(ds, 0x20c848, r8[al]);
    r32[eax] = pop32();
    yield* sub_1d562f();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    memoryASet16(ds, 0x20cf55, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    memoryASet16(ds, 0x20cf67, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d873);
    memoryASet16(ds, 0x20d1f3, r16[ax]);
    if (memoryAGet16(ds, 0x20d1e9) & 0xffff)
        { pc = 0x1d53e9; break; }
  case 0x1d53c4: // 0160:1d53c4
    if (!(memoryAGet16(ds, 0x20d1e7) & 0xffff))
        { pc = 0x1d543d; break; }
    r16[ax] = memoryAGet16(ds, 0x20d1dd);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x20cf9d, r16[ax]);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    { pc = 0x1d543d; break; }
  case 0x1d53e9: // 0160:1d53e9
    if (!(memoryAGet16(ds, 0x20d1e7) & 0xffff))
        { pc = 0x1d5427; break; }
    r16[ax] = memoryAGet16(ds, 0x20d875);
    r16[bx] = memoryAGet16(ds, 0x20d1dd);
    r16[ax] >>>= 4;
    r16[bx] >>>= 4;
    if (r16[ax] == r16[bx])
        { pc = 0x1d5427; break; }
    r8[al] = memoryAGet(ds, 0x20c843);
    r8[al] &= 0x0c;
    if (r8[al])
        { pc = 0x1d5427; break; }
    memoryASet16(ds, 0x20cf79, memoryAGet16(ds, 0x20cf79) + 0x0001);
    memoryASet16(ds, 0x20cf79, memoryAGet16(ds, 0x20cf79) & 0x001f);
  case 0x1d5427: // 0160:1d5427
    r16[ax] = memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d1dd, r16[ax]);
    memoryASet16(ds, 0x20d1e7, memoryAGet16(ds, 0x20d1e7) + 0x0001);
    { pc = 0x1d5449; break; }
  case 0x1d543d: // 0160:1d543d
    r16[ax] = memoryAGet16(ds, 0x20d1e9);
    memoryASet16(ds, 0x20d1e7, r16[ax]);
  case 0x1d5449: // 0160:1d5449
    memoryASet16(ds, 0x20d36d, memoryAGet16(ds, 0x20d36d) + 0x0004);
    memoryASet16(ds, 0x20d36d, memoryAGet16(ds, 0x20d36d) & 0x01ff);
    memoryASet16(ds, 0x20d873, 0x0014);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0073;
    yield* sub_1d91ba();
    memoryASet16(ds, 0x20d873, 0x0014);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x0032);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) & 0x01ff);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0074;
    yield* sub_1d91ba();
    memoryASet16(ds, 0x20d873, 0x0014);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x0064);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) & 0x01ff);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0075;
    yield* sub_1d91ba();
    memoryASet16(ds, 0x20d873, 0x0050);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0076;
    yield* sub_1d91ba();
    memoryASet16(ds, 0x20d873, 0x0064);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0076;
    yield* sub_1d91ba();
    memoryASet16(ds, 0x20d873, 0x006e);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x0190);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) & 0x01ff);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0076;
    yield* sub_1d91ba();
    memoryASet16(ds, 0x20d873, 0x0020);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    memoryASet16(ds, 0x20d875, r16[ax]);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x00c8);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) & 0x01ff);
    yield* sub_1d58e6();
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[bx] = memoryAGet16(ds, 0x20cf71);
    r16[ax] += 0x008c;
    r16[bx] += 0x008c;
    r16[cx] = 0x0077;
    { pc = 0x1d91ba; break; }
    // gap 1209 bytes // gap 1209 bytes
  case 0x1d5ae8: // 0160:1d5ae8
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1d5b2a; break; }
    r16[ax] = 0;
    memoryASet16(ds, 0x20d05d, r16[ax]);
    memoryASet16(ds, 0x20d05f, r16[ax]);
    memoryASet16(ds, 0x20d061, r16[ax]);
    memoryASet16(ds, 0x20d063, r16[ax]);
    memoryASet16(ds, 0x20d06f, r16[ax]);
    memoryASet16(ds, 0x20d071, r16[ax]);
    memoryASet16(ds, 0x20d073, r16[ax]);
    memoryASet16(ds, 0x20d075, r16[ax]);
  case 0x1d5b2a: // 0160:1d5b2a
    r32[esp] += 4; return;
  case 0x1d5b2b: // 0160:1d5b2b
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0001;
    if (r16[bx])
        { pc = 0x1d5b4b; break; }
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1d5b4b; break; }
    r16[ax] = 0;
  case 0x1d5b4b: // 0160:1d5b4b
    memoryASet16(ds, 0x20d36d, r16[ax]);
    yield* sub_1d5ba6();
    memoryASet16(ds, 0x20d88f, 0x0060);
    memoryASet16(ds, 0x20d891, 0x0060);
    memoryASet16(ds, 0x20d893, 0x0060);
    memoryASet16(ds, 0x20d895, 0x0080);
    if (!(memoryAGet16(ds, 0x20d7a5) & 0xffff))
        { pc = 0x1d5b93; break; }
    memoryASet16(ds, 0x20d803, 0x0000);
    { pc = 0x1d5b9c; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d5b93: // 0160:1d5b93
    memoryASet16(ds, 0x20d803, 0x0001);
  case 0x1d5b9c: // 0160:1d5b9c
    memoryASet16(ds, 0x20d825, 0x0003);
    r32[esp] += 4; return;
    // gap 120 bytes // gap 120 bytes
  case 0x1d5c1e: // 0160:1d5c1e
    yield* sub_1d5c5e();
    r32[eax] = 0x00000000;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    yield* sub_1d5ed3();
    r32[eax] = 0x00000180;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] += 0x0014;
    yield* sub_1d5ed3();
    r32[eax] = 0x00000300;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] += 0x0028;
    { pc = 0x1d5ed3; break; }
    // gap 629 bytes // gap 629 bytes
  case 0x1d5ed3: // 0160:1d5ed3
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[eax];
    r32[esi] = 0x00208d38;
    r32[ecx] &= 0x0000007e;
    r32[esi] += r32[ecx];
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] += r16[ax];
    r16[ax] += 0x0104;
    memoryASet16(ds, r32[edi] + 0xd8e, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe0e, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd90, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe10, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd92, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe12, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd94, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe14, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd96, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe16, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd98, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe18, r16[ax]);
    r32[esp] += 4; return;
  case 0x1d5f64: // 0160:1d5f64
    yield* sub_1d5c5e();
    r16[ax] = 0x03e6;
    r16[bx] = 0x0158;
    r16[dx] = 0x0010;
    yield* sub_1d5fa8();
    r16[ax] = 0x03e6;
    r16[bx] = 0x0178;
    r16[dx] = 0x0013;
    yield* sub_1d5fa8();
    r16[ax] = 0x03e6;
    r16[bx] = 0x0278;
    r16[dx] = 0x0010;
    yield* sub_1d5fa8();
    r16[ax] = 0x03e6;
    r16[bx] = 0x0298;
    r16[dx] = 0x0013;
    r16[bx]--;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] += r16[dx];
    r16[cx] &= 0x000f;
    r16[cx] >>>= 3;
    r16[ax] += r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (!r16[ax])
        { pc = 0x1d6005; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1d5fd9; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d6005; break; }
  case 0x1d5fd9: // 0160:1d5fd9
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d5feb; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d6005; break; }
  case 0x1d5feb: // 0160:1d5feb
    if (r16[bx] >= 0x0190)
        { pc = 0x1d6005; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d6005; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0078;
    { pc = 0x1b19e0; break; }
  case 0x1d6005: // 0160:1d6005
    r32[esp] += 4; return;
  case 0x1d6006: // 0160:1d6006
    r16[cx] = memoryAGet16(ds, 0x20cf85);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d608c();
    memoryASet16(ds, 0x20ce9f, r16[ax]);
    r16[cx] = memoryAGet16(ds, 0x20cf87);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1d608c();
    memoryASet16(ds, 0x20cea1, r16[ax]);
    r16[cx] = memoryAGet16(ds, 0x20cf89);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1d608c();
    memoryASet16(ds, 0x20cea3, r16[ax]);
    r16[cx] = memoryAGet16(ds, 0x20cf8b);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1d608c();
    memoryASet16(ds, 0x20cea5, r16[ax]);
    yield* sub_1d62df();
    { pc = 0x1d60c0; break; }
    // gap 55 bytes // gap 55 bytes
  case 0x1d60c0: // 0160:1d60c0
    memoryASet16(ds, 0x20ceb3, 0x0000);
    memoryASet16(ds, 0x20ceb5, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1d60fb; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r32[eax] &= 0x00000078;
    r16[ax] >>>= 2;
    r32[esi] = 0x00208db8;
    r16[bp] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ceb3, r16[bp]);
  case 0x1d60fb: // 0160:1d60fb
    if (memoryAGet16(ds, 0x20ce9f) & 0xffff)
        { pc = 0x1d6127; break; }
    if (memoryAGet16(ds, 0x20cea1) & 0xffff)
        { pc = 0x1d6127; break; }
    if (memoryAGet16(ds, 0x20cea3) & 0xffff)
        { pc = 0x1d6127; break; }
    if (!(memoryAGet16(ds, 0x20cea5) & 0xffff))
        { pc = 0x1d6159; break; }
  case 0x1d6127: // 0160:1d6127
    if (signed16(memoryAGet16(ds, 0x20d371)) >= signed16(0x0032))
        { pc = 0x1d613b; break; }
    memoryASet16(ds, 0x20d371, memoryAGet16(ds, 0x20d371) + 0x0001);
    { pc = 0x1d6175; break; }
  case 0x1d613b: // 0160:1d613b
    memoryASet16(ds, 0x20d371, 0x00c8);
    if (signed16(memoryAGet16(ds, 0x20d36d)) >= signed16(0x03fe))
        { pc = 0x1d6175; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) + 0x0001);
    { pc = 0x1d6175; break; }
  case 0x1d6159: // 0160:1d6159
    memoryASet16(ds, 0x20d371, 0x0000);
    if (signed16(memoryAGet16(ds, 0x20d36d)) <= signed16(0x02e2))
        { pc = 0x1d6175; break; }
    memoryASet16(ds, 0x20ceb3, memoryAGet16(ds, 0x20ceb3) - 0x0001);
  case 0x1d6175: // 0160:1d6175
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    memoryASet16(ds, 0x20d36d, memoryAGet16(ds, 0x20d36d) + r16[ax]);
    if (!(memoryAGet16(ds, 0x20ce9f) & 0xffff))
        { pc = 0x1d6196; break; }
    memoryASet16(ds, 0x20cf4f, memoryAGet16(ds, 0x20cf4f) + r16[ax]);
    { pc = 0x1d61d9; break; }
  case 0x1d6196: // 0160:1d6196
    if (signed16(memoryAGet16(ds, 0x20cf4f)) <= signed16(0x0252))
        { pc = 0x1d61d9; break; }
    if (signed16(memoryAGet16(ds, 0x20cf4f)) >= signed16(0x03ce))
        { pc = 0x1d61d9; break; }
    if (signed16(memoryAGet16(ds, 0x20cf61)) <= signed16(0x00af))
        { pc = 0x1d61d9; break; }
    if (signed16(memoryAGet16(ds, 0x20cf61)) >= signed16(0x01d2))
        { pc = 0x1d61d9; break; }
    if (memoryAGet16(ds, 0x20cf85) >= 0x0020)
        { pc = 0x1d61d9; break; }
    memoryASet16(ds, 0x20cf85, 0x0020);
  case 0x1d61d9: // 0160:1d61d9
    if (!(memoryAGet16(ds, 0x20cea1) & 0xffff))
        { pc = 0x1d61ed; break; }
    memoryASet16(ds, 0x20cf51, memoryAGet16(ds, 0x20cf51) + r16[ax]);
    { pc = 0x1d6230; break; }
  case 0x1d61ed: // 0160:1d61ed
    if (signed16(memoryAGet16(ds, 0x20cf51)) <= signed16(0x0252))
        { pc = 0x1d6230; break; }
    if (signed16(memoryAGet16(ds, 0x20cf51)) >= signed16(0x03ce))
        { pc = 0x1d6230; break; }
    if (signed16(memoryAGet16(ds, 0x20cf63)) <= signed16(0x00af))
        { pc = 0x1d6230; break; }
    if (signed16(memoryAGet16(ds, 0x20cf63)) >= signed16(0x01d2))
        { pc = 0x1d6230; break; }
    if (memoryAGet16(ds, 0x20cf87) >= 0x0020)
        { pc = 0x1d6230; break; }
    memoryASet16(ds, 0x20cf87, 0x0020);
  case 0x1d6230: // 0160:1d6230
    if (!(memoryAGet16(ds, 0x20cea3) & 0xffff))
        { pc = 0x1d6244; break; }
    memoryASet16(ds, 0x20cf53, memoryAGet16(ds, 0x20cf53) + r16[ax]);
    { pc = 0x1d6287; break; }
  case 0x1d6244: // 0160:1d6244
    if (signed16(memoryAGet16(ds, 0x20cf53)) <= signed16(0x0252))
        { pc = 0x1d6287; break; }
    if (signed16(memoryAGet16(ds, 0x20cf53)) >= signed16(0x03ce))
        { pc = 0x1d6287; break; }
    if (signed16(memoryAGet16(ds, 0x20cf65)) <= signed16(0x00af))
        { pc = 0x1d6287; break; }
    if (signed16(memoryAGet16(ds, 0x20cf65)) >= signed16(0x01d2))
        { pc = 0x1d6287; break; }
    if (memoryAGet16(ds, 0x20cf89) >= 0x0020)
        { pc = 0x1d6287; break; }
    memoryASet16(ds, 0x20cf89, 0x0020);
  case 0x1d6287: // 0160:1d6287
    if (!(memoryAGet16(ds, 0x20cea5) & 0xffff))
        { pc = 0x1d629b; break; }
    memoryASet16(ds, 0x20cf55, memoryAGet16(ds, 0x20cf55) + r16[ax]);
    { pc = 0x1d62de; break; }
  case 0x1d629b: // 0160:1d629b
    if (signed16(memoryAGet16(ds, 0x20cf55)) <= signed16(0x0252))
        { pc = 0x1d62de; break; }
    if (signed16(memoryAGet16(ds, 0x20cf55)) >= signed16(0x03ce))
        { pc = 0x1d62de; break; }
    if (signed16(memoryAGet16(ds, 0x20cf67)) <= signed16(0x00af))
        { pc = 0x1d62de; break; }
    if (signed16(memoryAGet16(ds, 0x20cf67)) >= signed16(0x01d2))
        { pc = 0x1d62de; break; }
    if (memoryAGet16(ds, 0x20cf8b) >= 0x0020)
        { pc = 0x1d62de; break; }
    memoryASet16(ds, 0x20cf8b, 0x0020);
  case 0x1d62de: // 0160:1d62de
    r32[esp] += 4; return;
    // gap 869 bytes // gap 869 bytes
  case 0x1d6644: // 0160:1d6644
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1d68ed; break; }
    r16[ax] = 0x0064;
    yield* sub_1d3339();
    if (memoryAGet16(ds, 0x20d7f5) != 0x0001)
        { pc = 0x1d68ee; break; }
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d667d; break; }
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) - 0x0001);
  case 0x1d667d: // 0160:1d667d
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d669f; break; }
    if (memoryAGet(ds, 0x20d125) != 0x38)
        { pc = 0x1d6715; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x002a)
        { pc = 0x1d6715; break; }
  case 0x1d669f: // 0160:1d669f
    memoryASet16(ds, 0x20cf51, 0x0302);
    memoryASet16(ds, 0x20cf63, 0x0998);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) - 0x0001);
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d6715; break; }
    memoryASet16(ds, 0x20cf87, 0x0002);
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20d05f, 0x000a);
    memoryASet16(ds, 0x20d04d, 0x00a8);
    memoryASet16(ds, 0x20cf99, 0x0040);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0002);
  case 0x1d6715: // 0160:1d6715
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d6737; break; }
    if (memoryAGet(ds, 0x20d127) != 0x38)
        { pc = 0x1d67ad; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x002a)
        { pc = 0x1d67ad; break; }
  case 0x1d6737: // 0160:1d6737
    memoryASet16(ds, 0x20cf53, 0x0302);
    memoryASet16(ds, 0x20cf65, 0x0998);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) - 0x0001);
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d67ad; break; }
    memoryASet16(ds, 0x20cf89, 0x0002);
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20d061, 0x000a);
    memoryASet16(ds, 0x20d04f, 0x00a8);
    memoryASet16(ds, 0x20cf9b, 0x0040);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0002);
  case 0x1d67ad: // 0160:1d67ad
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d67cf; break; }
    if (memoryAGet(ds, 0x20d129) != 0x38)
        { pc = 0x1d6845; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x002a)
        { pc = 0x1d6845; break; }
  case 0x1d67cf: // 0160:1d67cf
    memoryASet16(ds, 0x20cf55, 0x0302);
    memoryASet16(ds, 0x20cf67, 0x0998);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) - 0x0001);
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d6845; break; }
    memoryASet16(ds, 0x20cf8b, 0x0002);
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20d063, 0x000a);
    memoryASet16(ds, 0x20d051, 0x00a8);
    memoryASet16(ds, 0x20cf9d, 0x0040);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0002);
  case 0x1d6845: // 0160:1d6845
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d686b; break; }
    if (memoryAGet(ds, 0x20d123) != 0x38)
        { pc = 0x1d68ed; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x002a)
        { pc = 0x1d68ed; break; }
  case 0x1d686b: // 0160:1d686b
    memoryASet16(ds, 0x20d861, 0x0001);
    memoryASet16(ds, 0x20cf4f, 0x0302);
    memoryASet16(ds, 0x20cf61, 0x0998);
    memoryASet16(ds, 0x20cf85, 0x0008);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet(ds, 0x20c840, memoryAGet(ds, 0x20c840) & 0x80);
    if (memoryAGet16(ds, 0x20d17d) & 0xffff)
        { pc = 0x1d68ed; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20d05d, 0x000a);
    memoryASet16(ds, 0x20d04b, 0x00a8);
    memoryASet16(ds, 0x20cf97, 0x0040);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0002);
    memoryASet16(ds, 0x20d861, 0x0000);
  case 0x1d68ed: // 0160:1d68ed
    r32[esp] += 4; return;
  case 0x1d68ee: // 0160:1d68ee
    yield* sub_1d33a0();
    if (memoryAGet16(ds, 0x20d861) & 0xffff)
        { pc = 0x1d6f9c; break; }
    yield* sub_1d3411();
    if (memoryAGet16(ds, 0x20d17d) == 0x0001)
        { pc = 0x1d6933; break; }
    if (memoryAGet16(ds, 0x20d17f) == 0x0001)
        { pc = 0x1d6933; break; }
    if (memoryAGet16(ds, 0x20d181) == 0x0001)
        { pc = 0x1d6933; break; }
    if (memoryAGet16(ds, 0x20d183) != 0x0001)
        { pc = 0x1d71cd; break; }
  case 0x1d6933: // 0160:1d6933
    r16[ax] = 0x008c;
    yield* sub_1d34d9();
    if (memoryAGet16(ds, 0x20d7f5) == 0x0002)
        { pc = 0x1d6eb4; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0003)
        { pc = 0x1d6c52; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d6a94; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d6a82; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d6a6e; break; }
    memoryASet16(ds, 0x20d7af, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d69ac; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
  case 0x1d69ac: // 0160:1d69ac
    r16[ax] = 0x0003;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d69c2; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
  case 0x1d69c2: // 0160:1d69c2
    r16[ax] = 0x0004;
  case 0x1d69c6: // 0160:1d69c6
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7ab, r16[ax]);
    r16[ax]--;
    memoryASet16(ds, 0x20d7a7, r16[ax]);
    if (!r16[ax])
        { pc = 0x1d6dcf; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d6c82; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d6d09; break; }
    memoryASet16(ds, 0x20cf55, 0x01b8);
    memoryASet16(ds, 0x20cf67, 0x09ac);
    memoryASet16(ds, 0x20cf79, 0x0001);
    memoryASet16(ds, 0x20cf8b, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20d051, 0x04a1);
    memoryASet16(ds, 0x20d04b, 0x04a0);
    memoryASet16(ds, 0x20d04d, 0x04a0);
    memoryASet16(ds, 0x20d04f, 0x04a0);
    { pc = 0x1d6f82; break; }
  case 0x1d6a6e: // 0160:1d6a6e
    memoryASet16(ds, 0x20d7ad, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
    { pc = 0x1d6a94; break; }
  case 0x1d6a82: // 0160:1d6a82
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d6a94: // 0160:1d6a94
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d6b13; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d6b01; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d6aed; break; }
    memoryASet16(ds, 0x20d7af, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d69ac; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
    { pc = 0x1d69ac; break; }
  case 0x1d6aed: // 0160:1d6aed
    memoryASet16(ds, 0x20d7ad, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
    { pc = 0x1d6b13; break; }
  case 0x1d6b01: // 0160:1d6b01
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d6b13: // 0160:1d6b13
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d6bb0; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d6b9e; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d6b8a; break; }
    memoryASet16(ds, 0x20d7af, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d6b67; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
  case 0x1d6b67: // 0160:1d6b67
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d6b81; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
  case 0x1d6b81: // 0160:1d6b81
    r16[ax] = 0x0004;
    { pc = 0x1d69c6; break; }
  case 0x1d6b8a: // 0160:1d6b8a
    memoryASet16(ds, 0x20d7ad, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
    { pc = 0x1d6bb0; break; }
  case 0x1d6b9e: // 0160:1d6b9e
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d6bb0: // 0160:1d6bb0
    if (memoryAGet16(ds, 0x20cf8b) != 0x0034)
        { pc = 0x1d6c4d; break; }
    if (!(memoryAGet16(ds, 0x20d7a9) & 0xffff))
        { pc = 0x1d6c3b; break; }
    if (!(memoryAGet16(ds, 0x20d7ad) & 0xffff))
        { pc = 0x1d6c27; break; }
    memoryASet16(ds, 0x20d7af, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    r16[ax] = 0x0001;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d6c04; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
  case 0x1d6c04: // 0160:1d6c04
    r16[ax] = 0x0002;
    if (r16[ax] == memoryAGet16(ds, 0x20d7a9))
        { pc = 0x1d6c1e; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d7ad))
        { pc = 0x1d69c6; break; }
  case 0x1d6c1e: // 0160:1d6c1e
    r16[ax] = 0x0003;
    { pc = 0x1d69c6; break; }
  case 0x1d6c27: // 0160:1d6c27
    memoryASet16(ds, 0x20d7ad, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
    { pc = 0x1d6c4d; break; }
  case 0x1d6c3b: // 0160:1d6c3b
    memoryASet16(ds, 0x20d7a9, 0x0004);
    memoryASet16(ds, 0x20cf8b, 0x0049);
  case 0x1d6c4d: // 0160:1d6c4d
    { pc = 0x1d71cd; break; }
  case 0x1d6c52: // 0160:1d6c52
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d6da2; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d6d90; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0002)
        { pc = 0x1d6d09; break; }
  case 0x1d6c82: // 0160:1d6c82
    memoryASet16(ds, 0x20d7ab, 0x0002);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x01b8);
    memoryASet16(ds, 0x20cf63, 0x09ac);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04d, 0x04a1);
    memoryASet16(ds, 0x20d04b, 0x04a0);
    memoryASet16(ds, 0x20d04f, 0x04a0);
    memoryASet16(ds, 0x20d051, 0x04a0);
    { pc = 0x1d6f82; break; }
  case 0x1d6d09: // 0160:1d6d09
    memoryASet16(ds, 0x20d7ab, 0x0003);
    memoryASet16(ds, 0x20d7a7, 0x0002);
    memoryASet16(ds, 0x20cf53, 0x01b8);
    memoryASet16(ds, 0x20cf65, 0x09ac);
    memoryASet16(ds, 0x20cf77, 0x0001);
    memoryASet16(ds, 0x20cf89, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf85, r16[ax]);
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf73, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04f, 0x04a1);
    memoryASet16(ds, 0x20d04b, 0x04a0);
    memoryASet16(ds, 0x20d04d, 0x04a0);
    memoryASet16(ds, 0x20d051, 0x04a0);
    { pc = 0x1d6f82; break; }
  case 0x1d6d90: // 0160:1d6d90
    memoryASet16(ds, 0x20d7a9, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0049);
  case 0x1d6da2: // 0160:1d6da2
    if (memoryAGet16(ds, 0x20cf87) != 0x0034)
        { pc = 0x1d6e68; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (memoryAGet16(ds, 0x20cf87) == 0x0034)
        { pc = 0x1d6e56; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d6d09; break; }
  case 0x1d6dcf: // 0160:1d6dcf
    memoryASet16(ds, 0x20d7ab, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x01b8);
    memoryASet16(ds, 0x20cf61, 0x09ac);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    r16[ax] = 0x0034;
    memoryASet16(ds, 0x20cf87, r16[ax]);
    memoryASet16(ds, 0x20cf89, r16[ax]);
    memoryASet16(ds, 0x20cf8b, r16[ax]);
    memoryASet16(ds, 0x20cf75, r16[ax]);
    memoryASet16(ds, 0x20cf77, r16[ax]);
    memoryASet16(ds, 0x20cf79, r16[ax]);
    memoryASet16(ds, 0x20d04b, 0x04a1);
    memoryASet16(ds, 0x20d04d, 0x04a0);
    memoryASet16(ds, 0x20d04f, 0x04a0);
    memoryASet16(ds, 0x20d051, 0x04a0);
    { pc = 0x1d6f82; break; }
  case 0x1d6e56: // 0160:1d6e56
    memoryASet16(ds, 0x20d7a9, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0049);
  case 0x1d6e68: // 0160:1d6e68
    if (memoryAGet16(ds, 0x20cf89) != 0x0034)
        { pc = 0x1d6eaf; break; }
    r16[ax] = memoryAGet16(ds, 0x20d7a9);
    if (!r16[ax])
        { pc = 0x1d6e9d; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    if (r16[ax] == 0x0001)
        { pc = 0x1d6c82; break; }
    { pc = 0x1d6dcf; break; }
  case 0x1d6e9d: // 0160:1d6e9d
    memoryASet16(ds, 0x20d7a9, 0x0003);
    memoryASet16(ds, 0x20cf89, 0x0049);
  case 0x1d6eaf: // 0160:1d6eaf
    { pc = 0x1d71cd; break; }
  case 0x1d6eb4: // 0160:1d6eb4
    if (memoryAGet16(ds, 0x20cf87) == 0x0034)
        { pc = 0x1d6f28; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x0034)
        { pc = 0x1d71cd; break; }
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0001);
    memoryASet16(ds, 0x20cf51, 0x01b8);
    memoryASet16(ds, 0x20cf63, 0x09ac);
    memoryASet16(ds, 0x20cf75, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0034);
    memoryASet16(ds, 0x20cf73, 0x0034);
    memoryASet16(ds, 0x20d04d, 0x04a1);
    memoryASet16(ds, 0x20d04b, 0x04a0);
    { pc = 0x1d6f82; break; }
  case 0x1d6f28: // 0160:1d6f28
    memoryASet16(ds, 0x20d7a5, 0x0001);
    memoryASet16(ds, 0x20d7a7, 0x0000);
    memoryASet16(ds, 0x20cf4f, 0x01b8);
    memoryASet16(ds, 0x20cf61, 0x09ac);
    memoryASet16(ds, 0x20cf73, 0x0001);
    memoryASet16(ds, 0x20cf85, 0x0001);
    memoryASet16(ds, 0x20cf87, 0x0034);
    memoryASet16(ds, 0x20cf75, 0x0034);
    memoryASet16(ds, 0x20d04b, 0x04a1);
    memoryASet16(ds, 0x20d04d, 0x04a0);
  case 0x1d6f82: // 0160:1d6f82
    r16[ax] = 0x0170;
    r16[bx] = 0x0980;
    r16[cx] = 0x0208;
    r16[dx] = 0x0980;
    yield* sub_1d359b();
    { pc = 0x1d71cd; break; }
  case 0x1d6f9c: // 0160:1d6f9c
    if (memoryAGet16(ds, 0x20d17d) != 0x0001)
        { pc = 0x1d6fe5; break; }
    memoryASet16(ds, 0x20d06f, 0x000a);
    memoryASet16(ds, 0x20d05d, 0x000a);
    memoryASet16(ds, 0x20cf97, 0x0040);
    memoryASet16(ds, 0x20cfa9, 0x0180);
    memoryASet16(ds, 0x20cf73, 0x0002);
    memoryASet16(ds, 0x20cf85, 0x0002);
    memoryASet16(ds, 0x20d17d, 0x0000);
  case 0x1d6fe5: // 0160:1d6fe5
    if (memoryAGet16(ds, 0x20d17d) != 0x0002)
        { pc = 0x1d702e; break; }
    memoryASet16(ds, 0x20d071, 0x000a);
    memoryASet16(ds, 0x20d05f, 0x000a);
    memoryASet16(ds, 0x20cf99, 0x0040);
    memoryASet16(ds, 0x20cfab, 0x0180);
    memoryASet16(ds, 0x20cf75, 0x0002);
    memoryASet16(ds, 0x20cf87, 0x0002);
    memoryASet16(ds, 0x20d17f, 0x0000);
  case 0x1d702e: // 0160:1d702e
    if (memoryAGet16(ds, 0x20d181) != 0x0001)
        { pc = 0x1d7077; break; }
    memoryASet16(ds, 0x20d073, 0x000a);
    memoryASet16(ds, 0x20d061, 0x000a);
    memoryASet16(ds, 0x20cf9b, 0x0040);
    memoryASet16(ds, 0x20cfad, 0x0180);
    memoryASet16(ds, 0x20cf77, 0x0002);
    memoryASet16(ds, 0x20cf89, 0x0002);
    memoryASet16(ds, 0x20d181, 0x0000);
  case 0x1d7077: // 0160:1d7077
    if (memoryAGet16(ds, 0x20d17d) != 0x0004)
        { pc = 0x1d70c0; break; }
    memoryASet16(ds, 0x20d075, 0x000a);
    memoryASet16(ds, 0x20d063, 0x000a);
    memoryASet16(ds, 0x20cf9d, 0x0040);
    memoryASet16(ds, 0x20cfaf, 0x0180);
    memoryASet16(ds, 0x20cf79, 0x0002);
    memoryASet16(ds, 0x20cf8b, 0x0002);
    memoryASet16(ds, 0x20d183, 0x0000);
  case 0x1d70c0: // 0160:1d70c0
    memoryASet16(ds, 0x20d861, 0x0000);
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d710a; break; }
    memoryASet16(ds, 0x20d04b, 0x00a8);
    memoryASet16(ds, 0x20cf4f, 0x0302);
    memoryASet16(ds, 0x20cf61, 0x0998);
    memoryASet16(ds, 0x20cf85, 0x0026);
    memoryASet16(ds, 0x20cfa9, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d710a: // 0160:1d710a
    if (!(memoryAGet16(ds, 0x20d17f) & 0xffff))
        { pc = 0x1d714b; break; }
    memoryASet16(ds, 0x20d04d, 0x00a8);
    memoryASet16(ds, 0x20cf51, 0x0302);
    memoryASet16(ds, 0x20cf63, 0x0998);
    memoryASet16(ds, 0x20cf87, 0x0026);
    memoryASet16(ds, 0x20cfab, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d714b: // 0160:1d714b
    if (!(memoryAGet16(ds, 0x20d181) & 0xffff))
        { pc = 0x1d718c; break; }
    memoryASet16(ds, 0x20d04f, 0x00a8);
    memoryASet16(ds, 0x20cf53, 0x0302);
    memoryASet16(ds, 0x20cf65, 0x0998);
    memoryASet16(ds, 0x20cf89, 0x0026);
    memoryASet16(ds, 0x20cfad, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d718c: // 0160:1d718c
    if (!(memoryAGet16(ds, 0x20d183) & 0xffff))
        { pc = 0x1d71cd; break; }
    memoryASet16(ds, 0x20d051, 0x00a8);
    memoryASet16(ds, 0x20cf55, 0x0302);
    memoryASet16(ds, 0x20cf67, 0x0998);
    memoryASet16(ds, 0x20cf8b, 0x0026);
    memoryASet16(ds, 0x20cfaf, 0x0000);
    memoryASet16(ds, 0x20d861, 0x0001);
  case 0x1d71cd: // 0160:1d71cd
    r32[esp] += 4; return;
    // gap 8172 bytes // gap 8172 bytes
  case 0x1d91ba: // 0160:1d91ba
    r16[dx] = 0;
    r16[dx] |= 0x0010;
    r16[bx]--;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d91db; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91db: // 0160:1d91db
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d91f1; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91f1: // 0160:1d91f1
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9207; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9207; break; }
    yield* sub_1b19e0();
  case 0x1d9207: // 0160:1d9207
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d1ece() // 0160:1d1ece +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[cx] = memoryAGet16(ds, 0x20d373);
    if (!r16[cx])
        { pc = 0x1d1f22; break; }
    if (r16[cx] != 0x0009)
        { pc = 0x1d1f06; break; }
    yield* sub_1d1fdf();
    memoryASet16(ds, 0x20d371, 0x0001);
    memoryASet16(ds, 0x20d373, 0x0000);
    { pc = 0x1d1f22; break; }
  case 0x1d1f06: // 0160:1d1f06
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1d1f1b; break; }
    memoryASet16(ds, 0x20d373, memoryAGet16(ds, 0x20d373) - 0x0001);
  case 0x1d1f1b: // 0160:1d1f1b
    r16[ax] += r16[cx];
    r16[ax]--;
  case 0x1d1f22: // 0160:1d1f22
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d371);
    if (r16[cx] == 0x0006)
        { pc = 0x1d1f56; break; }
    yield* sub_1d1feb();
    r16[ax] = memoryAGet16(ds, 0x20d371);
    if (!r16[ax])
        { pc = 0x1d1f56; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d1f56; break; }
    memoryASet16(ds, 0x20d371, memoryAGet16(ds, 0x20d371) + 0x0001);
  case 0x1d1f56: // 0160:1d1f56
    r16[ax] = memoryAGet16(ds, 0x20d375);
    r16[bx] = memoryAGet16(ds, 0x20d377);
    r16[cx] = memoryAGet16(ds, 0x20d37b);
    if (!r16[cx])
        { pc = 0x1d1faa; break; }
    if (r16[cx] != 0x0009)
        { pc = 0x1d1f8e; break; }
    yield* sub_1d1fdf();
    memoryASet16(ds, 0x20d379, 0x0001);
    memoryASet16(ds, 0x20d37b, 0x0000);
    { pc = 0x1d1faa; break; }
  case 0x1d1f8e: // 0160:1d1f8e
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    if (r16[cx])
        { pc = 0x1d1fa3; break; }
    memoryASet16(ds, 0x20d37b, memoryAGet16(ds, 0x20d37b) - 0x0001);
  case 0x1d1fa3: // 0160:1d1fa3
    r16[ax] += r16[cx];
    r16[ax]--;
  case 0x1d1faa: // 0160:1d1faa
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d379);
    if (r16[cx] == 0x0006)
        { pc = 0x1d1fde; break; }
    yield* sub_1d1feb();
    r16[ax] = memoryAGet16(ds, 0x20d379);
    if (!r16[ax])
        { pc = 0x1d1fde; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d1fde; break; }
    memoryASet16(ds, 0x20d379, memoryAGet16(ds, 0x20d379) + 0x0001);
  case 0x1d1fde: // 0160:1d1fde
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d1fdf() // 0160:1d1fdf +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ebx]);
    r8[al] = 0x54;
    yield* sub_1b17b7();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1d1feb() // 0160:1d1feb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] <<= 5;
    push32(r32[esi]);
    r32[esi] = 0x00208ac4;
    r32[ecx] &= 0x0000ffff;
    r32[esi] += r32[ecx];
    memoryASet32(ds, 0x20ceef, r32[esi]);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d2019; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d20fb; break; }
  case 0x1d2019: // 0160:1d2019
    r16[bx]--;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d2033; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d20fb; break; }
  case 0x1d2033: // 0160:1d2033
    if (r16[bx] >= 0x0178)
        { pc = 0x1d20fb; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d20fb; break; }
    r16[ax] += memoryAGet16(ds, r32[esi]);
    r16[bx] += memoryAGet16(ds, r32[esi] + 0x2);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    yield* sub_1b19e0();
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += memoryAGet16(ds, r32[esi] + 0x8);
    r16[bx] += memoryAGet16(ds, r32[esi] + 0xa);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0xc);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0xe);
    yield* sub_1b19e0();
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += memoryAGet16(ds, r32[esi] + 0x10);
    r16[bx] += memoryAGet16(ds, r32[esi] + 0x12);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x14);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x16);
    yield* sub_1b19e0();
    r32[esi] = memoryAGet32(ds, 0x20ceef);
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += memoryAGet16(ds, r32[esi] + 0x18);
    r16[bx] += memoryAGet16(ds, r32[esi] + 0x1a);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x1c);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x1e);
    yield* sub_1b19e0();
  case 0x1d20fb: // 0160:1d20fb
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1d2341() // 0160:1d2341 +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    r16[ax] >>>= 1;
    r16[ax] += 0x0104;
    r32[esi] = memoryAGet32(ds, 0x2eeb94);
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa0, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x140, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa2, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x142, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x4, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xa4, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x144, r16[ax]);
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[esi] + r32[ebx] - 160, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] - 158, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] - 156, r16[ax]);
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x1e0, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x1e2, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x1e4, r16[ax]);
    r32[esp] += 4;
}
function* sub_1d23ff() // 0160:1d23ff +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    r16[ax] >>>= 1;
    r16[ax] += 0x0104;
    r32[esi] = memoryAGet32(ds, 0x2eeb94);
    memoryASet16(ds, r32[esi] + r32[ebx], r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x70, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xe0, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x2, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x72, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xe2, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x4, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x74, r16[ax]);
    memoryASet16(ds, r32[esi] + r32[ebx] + 0xe4, r16[ax]);
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[esi] + r32[ebx] - 112, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] - 110, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] - 108, r16[ax]);
    r16[ax] += 0x000a;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x150, r16[ax]);
    r16[ax] += 0x0004;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x152, r16[ax]);
    r16[ax] += 0x0006;
    memoryASet16(ds, r32[esi] + r32[ebx] + 0x154, r16[ax]);
    r32[esp] += 4;
}
function* sub_1d24f6() // 0160:1d24f6 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x00208c94;
  case 0x1d24fb: // 0160:1d24fb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[ax] < 0)
        { pc = 0x1d251c; break; }
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    r32[ebx] += r32[ebx];
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[ebx];
    r32[edi] -= 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    { pc = 0x1d24fb; break; }
  case 0x1d251c: // 0160:1d251c
    flags.zero = !(r16[ax] | r16[ax]);
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d24fb() // 0160:1d24fb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1d24fb: // 0160:1d24fb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[ax] < 0)
        { pc = 0x1d251c; break; }
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    r32[ebx] += r32[ebx];
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[ebx];
    r32[edi] -= 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    { pc = 0x1d24fb; break; }
  case 0x1d251c: // 0160:1d251c
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d2697() // 0160:1d2697 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r16s[ax] <= signed16(0x010e))
        { pc = 0x1d26cd; break; }
    if (r16s[ax] >= signed16(0x012e))
        { pc = 0x1d26cd; break; }
    if (r16s[bx] <= signed16(0x0358))
        { pc = 0x1d26cd; break; }
    if (r16s[bx] >= signed16(0x03d8))
        { pc = 0x1d26cd; break; }
    r32[esi] = 0x0020d399;
    memoryASet16(ds, r32[esi] + 0x6, memoryAGet16(ds, r32[esi] + 0x6) + 0x0001);
    if (memoryAGet16(ds, r32[esi] + 0x6) != 0x0003)
        { pc = 0x1d26cd; break; }
    memoryASet16(ds, r32[esi] + 0x6, 0x0000);
    { pc = 0x1d27ad; break; }
  case 0x1d26cd: // 0160:1d26cd
    if (r16s[ax] <= signed16(0x04ee))
        { pc = 0x1d2703; break; }
    if (r16s[ax] >= signed16(0x050e))
        { pc = 0x1d2703; break; }
    if (r16s[bx] <= signed16(0x0278))
        { pc = 0x1d2703; break; }
    if (r16s[bx] >= signed16(0x02f8))
        { pc = 0x1d2703; break; }
    r32[esi] = 0x0020d3c1;
    memoryASet16(ds, r32[esi] + 0x6, memoryAGet16(ds, r32[esi] + 0x6) + 0x0001);
    if (memoryAGet16(ds, r32[esi] + 0x6) != 0x0003)
        { pc = 0x1d2703; break; }
    memoryASet16(ds, r32[esi] + 0x6, 0x0000);
    { pc = 0x1d27ad; break; }
  case 0x1d2703: // 0160:1d2703
    if (r16s[ax] <= signed16(0x0150))
        { pc = 0x1d2758; break; }
    if (r16s[ax] >= signed16(0x0172))
        { pc = 0x1d2758; break; }
    if (r16s[bx] <= signed16(0x0348))
        { pc = 0x1d2758; break; }
    if (r16s[bx] >= signed16(0x03e8))
        { pc = 0x1d2758; break; }
    r32[esi] = 0x0020d3e9;
    memoryASet16(ds, r32[esi] + 0x6, memoryAGet16(ds, r32[esi] + 0x6) + 0x0001);
    if (memoryAGet16(ds, r32[esi] + 0x6) != 0x0003)
        { pc = 0x1d2758; break; }
    memoryASet16(ds, r32[esi] + 0x6, 0x0000);
    yield* sub_1d27ad();
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2c);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x30))
        { pc = 0x1d2748; break; }
    memoryASet16(ds, r32[esi] + 0x2c, memoryAGet16(ds, r32[esi] + 0x2c) + 0x0001);
  case 0x1d2748: // 0160:1d2748
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x36);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x3a))
        { pc = 0x1d2757; break; }
    memoryASet16(ds, r32[esi] + 0x36, memoryAGet16(ds, r32[esi] + 0x36) + 0x0001);
  case 0x1d2757: // 0160:1d2757
    r32[esp] += 4; return;
  case 0x1d2758: // 0160:1d2758
    if (r16s[ax] <= signed16(0x0530))
        { pc = 0x1d27ac; break; }
    if (r16s[ax] >= signed16(0x0552))
        { pc = 0x1d27ac; break; }
    if (r16s[bx] <= signed16(0x0258))
        { pc = 0x1d27ac; break; }
    if (r16s[bx] >= signed16(0x02f8))
        { pc = 0x1d27ac; break; }
    r32[esi] = 0x0020d425;
    memoryASet16(ds, r32[esi] + 0x6, memoryAGet16(ds, r32[esi] + 0x6) + 0x0001);
    if (memoryAGet16(ds, r32[esi] + 0x6) != 0x0003)
        { pc = 0x1d27ac; break; }
    memoryASet16(ds, r32[esi] + 0x6, 0x0000);
    yield* sub_1d27ad();
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2c);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x30))
        { pc = 0x1d279d; break; }
    memoryASet16(ds, r32[esi] + 0x2c, memoryAGet16(ds, r32[esi] + 0x2c) + 0x0001);
  case 0x1d279d: // 0160:1d279d
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x36);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x3a))
        { pc = 0x1d27ac; break; }
    memoryASet16(ds, r32[esi] + 0x36, memoryAGet16(ds, r32[esi] + 0x36) + 0x0001);
  case 0x1d27ac: // 0160:1d27ac
    r32[esp] += 4; return;
  case 0x1d27ad: // 0160:1d27ad
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x8))
        { pc = 0x1d27bc; break; }
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) + 0x0001);
  case 0x1d27bc: // 0160:1d27bc
    r16[ax] = memoryAGet16(ds, r32[esi] + 0xe);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x12))
        { pc = 0x1d27cb; break; }
    memoryASet16(ds, r32[esi] + 0xe, memoryAGet16(ds, r32[esi] + 0xe) + 0x0001);
  case 0x1d27cb: // 0160:1d27cb
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x18);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x1c))
        { pc = 0x1d27da; break; }
    memoryASet16(ds, r32[esi] + 0x18, memoryAGet16(ds, r32[esi] + 0x18) + 0x0001);
  case 0x1d27da: // 0160:1d27da
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x22);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x26))
        { pc = 0x1d27e9; break; }
    memoryASet16(ds, r32[esi] + 0x22, memoryAGet16(ds, r32[esi] + 0x22) + 0x0001);
  case 0x1d27e9: // 0160:1d27e9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d27ad() // 0160:1d27ad +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x4);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x8))
        { pc = 0x1d27bc; break; }
    memoryASet16(ds, r32[esi] + 0x4, memoryAGet16(ds, r32[esi] + 0x4) + 0x0001);
  case 0x1d27bc: // 0160:1d27bc
    r16[ax] = memoryAGet16(ds, r32[esi] + 0xe);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x12))
        { pc = 0x1d27cb; break; }
    memoryASet16(ds, r32[esi] + 0xe, memoryAGet16(ds, r32[esi] + 0xe) + 0x0001);
  case 0x1d27cb: // 0160:1d27cb
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x18);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x1c))
        { pc = 0x1d27da; break; }
    memoryASet16(ds, r32[esi] + 0x18, memoryAGet16(ds, r32[esi] + 0x18) + 0x0001);
  case 0x1d27da: // 0160:1d27da
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x22);
    if (r16[ax] == memoryAGet16(ds, r32[esi] + 0x26))
        { pc = 0x1d27e9; break; }
    memoryASet16(ds, r32[esi] + 0x22, memoryAGet16(ds, r32[esi] + 0x22) + 0x0001);
  case 0x1d27e9: // 0160:1d27e9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d3339() // 0160:1d3339 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[bl] = 0x38;
    if (r8[bl] != memoryAGet(ds, 0x20d123))
        { pc = 0x1d3354; break; }
    if (memoryAGet16(ds, 0x20d17d) & 0xffff)
        { pc = 0x1d3354; break; }
    memoryASet16(ds, 0x20d17d, r16[ax]);
  case 0x1d3354: // 0160:1d3354
    if (r8[bl] != memoryAGet(ds, 0x20d125))
        { pc = 0x1d336d; break; }
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d336d; break; }
    memoryASet16(ds, 0x20d17f, r16[ax]);
  case 0x1d336d: // 0160:1d336d
    if (r8[bl] != memoryAGet(ds, 0x20d127))
        { pc = 0x1d3386; break; }
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d3386; break; }
    memoryASet16(ds, 0x20d181, r16[ax]);
  case 0x1d3386: // 0160:1d3386
    if (r8[bl] != memoryAGet(ds, 0x20d129))
        { pc = 0x1d339f; break; }
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d339f; break; }
    memoryASet16(ds, 0x20d183, r16[ax]);
  case 0x1d339f: // 0160:1d339f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d33a0() // 0160:1d33a0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d33bc; break; }
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) - 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0001);
  case 0x1d33bc: // 0160:1d33bc
    if (!(memoryAGet16(ds, 0x20d17f) & 0xffff))
        { pc = 0x1d33d8; break; }
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) - 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0001);
  case 0x1d33d8: // 0160:1d33d8
    if (!(memoryAGet16(ds, 0x20d181) & 0xffff))
        { pc = 0x1d33f4; break; }
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) - 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0001);
  case 0x1d33f4: // 0160:1d33f4
    if (!(memoryAGet16(ds, 0x20d183) & 0xffff))
        { pc = 0x1d3410; break; }
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) - 0x0001);
    memoryASet16(ds, 0x20d7b1, 0x0001);
  case 0x1d3410: // 0160:1d3410
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d3411() // 0160:1d3411 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20d17d) & 0xffff))
        { pc = 0x1d342f; break; }
    if (memoryAGet16(ds, 0x20cf85) != 0x002b)
        { pc = 0x1d342f; break; }
    memoryASet16(ds, 0x20cf85, 0x002a);
  case 0x1d342f: // 0160:1d342f
    if (!(memoryAGet16(ds, 0x20d17f) & 0xffff))
        { pc = 0x1d344d; break; }
    if (memoryAGet16(ds, 0x20cf87) != 0x002b)
        { pc = 0x1d344d; break; }
    memoryASet16(ds, 0x20cf87, 0x002a);
  case 0x1d344d: // 0160:1d344d
    if (!(memoryAGet16(ds, 0x20d181) & 0xffff))
        { pc = 0x1d346b; break; }
    if (memoryAGet16(ds, 0x20cf89) != 0x002b)
        { pc = 0x1d346b; break; }
    memoryASet16(ds, 0x20cf89, 0x002a);
  case 0x1d346b: // 0160:1d346b
    if (!(memoryAGet16(ds, 0x20d183) & 0xffff))
        { pc = 0x1d3489; break; }
    if (memoryAGet16(ds, 0x20cf8b) != 0x002b)
        { pc = 0x1d3489; break; }
    memoryASet16(ds, 0x20cf8b, 0x002a);
  case 0x1d3489: // 0160:1d3489
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d348a() // 0160:1d348a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0008;
    r16[bx] += 0x0008;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d34a8; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d34d8; break; }
  case 0x1d34a8: // 0160:1d34a8
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d34be; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d34d8; break; }
  case 0x1d34be: // 0160:1d34be
    if (r16[bx] >= 0x0178)
        { pc = 0x1d34d8; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d34d8; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0073;
    yield* sub_1b19e0();
  case 0x1d34d8: // 0160:1d34d8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d34d9() // 0160:1d34d9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d861, 0x0001);
    if (memoryAGet16(ds, 0x20d17d) & 0xffff)
        { pc = 0x1d3502; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0021))
        { pc = 0x1d3510; break; }
    memoryASet16(ds, 0x20cf85, 0x0034);
    { pc = 0x1d3510; break; }
  case 0x1d3502: // 0160:1d3502
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) + r16[ax]);
    memoryASet16(ds, 0x20d17d, memoryAGet16(ds, 0x20d17d) >> 1);
  case 0x1d3510: // 0160:1d3510
    if (memoryAGet16(ds, 0x20d17f) & 0xffff)
        { pc = 0x1d3530; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0021))
        { pc = 0x1d353e; break; }
    memoryASet16(ds, 0x20cf87, 0x0034);
    { pc = 0x1d353e; break; }
  case 0x1d3530: // 0160:1d3530
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) + r16[ax]);
    memoryASet16(ds, 0x20d17f, memoryAGet16(ds, 0x20d17f) >> 1);
  case 0x1d353e: // 0160:1d353e
    if (memoryAGet16(ds, 0x20d181) & 0xffff)
        { pc = 0x1d355e; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0021))
        { pc = 0x1d356c; break; }
    memoryASet16(ds, 0x20cf89, 0x0034);
    { pc = 0x1d356c; break; }
  case 0x1d355e: // 0160:1d355e
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) + r16[ax]);
    memoryASet16(ds, 0x20d181, memoryAGet16(ds, 0x20d181) >> 1);
  case 0x1d356c: // 0160:1d356c
    if (memoryAGet16(ds, 0x20d183) & 0xffff)
        { pc = 0x1d358c; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0021))
        { pc = 0x1d359a; break; }
    memoryASet16(ds, 0x20cf8b, 0x0034);
    { pc = 0x1d359a; break; }
  case 0x1d358c: // 0160:1d358c
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) + r16[ax]);
    memoryASet16(ds, 0x20d183, memoryAGet16(ds, 0x20d183) >> 1);
  case 0x1d359a: // 0160:1d359a
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d359b() // 0160:1d359b +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d17d, 0x0000);
    memoryASet16(ds, 0x20d17f, 0x0000);
    memoryASet16(ds, 0x20d181, 0x0000);
    memoryASet16(ds, 0x20d183, 0x0000);
    memoryASet(ds, 0x20d123, 0x00);
    memoryASet(ds, 0x20d125, 0x00);
    memoryASet(ds, 0x20d127, 0x00);
    memoryASet(ds, 0x20d129, 0x00);
    memoryASet16(ds, 0x20d861, 0x0000);
    memoryASet16(ds, 0x20d0b7, r16[ax]);
    memoryASet16(ds, 0x20d0bf, r16[ax]);
    memoryASet16(ds, 0x20d0c7, r16[ax]);
    memoryASet16(ds, 0x20d0cf, r16[ax]);
    memoryASet16(ds, 0x20d0b9, r16[bx]);
    memoryASet16(ds, 0x20d0c1, r16[bx]);
    memoryASet16(ds, 0x20d0c9, r16[bx]);
    memoryASet16(ds, 0x20d0d1, r16[bx]);
    memoryASet16(ds, 0x20d0bb, r16[cx]);
    memoryASet16(ds, 0x20d0c3, r16[cx]);
    memoryASet16(ds, 0x20d0cb, r16[cx]);
    memoryASet16(ds, 0x20d0d3, r16[cx]);
    memoryASet16(ds, 0x20d0bd, r16[dx]);
    memoryASet16(ds, 0x20d0c5, r16[dx]);
    memoryASet16(ds, 0x20d0cd, r16[dx]);
    memoryASet16(ds, 0x20d0d5, r16[dx]);
    r32[esp] += 4;
}
function* sub_1d4dd2() // 0160:1d4dd2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d4dd2; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 53666 bytes // gap 53666 bytes
  case 0x1d4dd2: // 0160:1d4dd2
    if (r16s[bx] <= signed16(0x012c))
        { pc = 0x1d4e2e; break; }
    if (r16s[bx] >= signed16(0x0162))
        { pc = 0x1d4e2e; break; }
    if (r16s[ax] <= signed16(0x044e))
        { pc = 0x1d4e2e; break; }
    if (r16s[ax] >= signed16(0x06ce))
        { pc = 0x1d4e2e; break; }
    r16[ax] -= 0x044e;
    r16[ax] >>>= 4;
    r16[ax] <<= 1;
    r32[eax] &= 0x0000ffff;
    r32[esi] = 0x0020d36d;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    if (r16[bx] == 0x0004)
        { pc = 0x1d4e29; break; }
    if (r16s[bx] >= signed16(0x0005))
        { pc = 0x1d4e2e; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + 0x0002);
    if (memoryAGet16(ds, r32[esi] + r32[eax]) != 0x0002)
        { pc = 0x1d4e2e; break; }
    r16[ax] >>>= 1;
    r16[ax] += 0x000a;
    { pc = 0x1b17b7; break; }
  case 0x1d4e29: // 0160:1d4e29
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + 0x0001);
  case 0x1d4e2e: // 0160:1d4e2e
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d4e8e() // 0160:1d4e8e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r16s[bx] <= signed16(0x0070))
        { pc = 0x1d4eca; break; }
    if (r16s[bx] >= signed16(0x0154))
        { pc = 0x1d4eca; break; }
    if (r16s[ax] <= signed16(0x0150))
        { pc = 0x1d4eca; break; }
    if (r16s[ax] >= signed16(0x0430))
        { pc = 0x1d4eca; break; }
    r16[ax] -= 0x0150;
    r16[ax] >>>= 5;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] = 0x0020d385;
    if (memoryAGet16(ds, r32[esi] + r32[eax]) == 0x0003)
        { pc = 0x1d4ec9; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + 0x0002);
  case 0x1d4ec9: // 0160:1d4ec9
    r32[esp] += 4; return;
  case 0x1d4eca: // 0160:1d4eca
    if (r16s[bx] <= signed16(0x0448))
        { pc = 0x1d4f06; break; }
    if (r16s[bx] >= signed16(0x053c))
        { pc = 0x1d4f06; break; }
    if (r16s[ax] <= signed16(0x02f0))
        { pc = 0x1d4f06; break; }
    if (r16s[ax] >= signed16(0x05d0))
        { pc = 0x1d4f06; break; }
    r16[ax] -= 0x02f0;
    r16[ax] >>>= 5;
    r16[ax] <<= 3;
    r32[eax] &= 0x0000ffff;
    r32[esi] = 0x0020d43d;
    if (memoryAGet16(ds, r32[esi] + r32[eax]) == 0x0003)
        { pc = 0x1d4f06; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + 0x0002);
  case 0x1d4f06: // 0160:1d4f06
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d4f07() // 0160:1d4f07 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] >>>= 1;
    r16[bx] += r16[cx];
    r16[ax] += r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d4f26; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d4f88; break; }
  case 0x1d4f26: // 0160:1d4f26
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d4f3c; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d4f88; break; }
  case 0x1d4f3c: // 0160:1d4f3c
    if (r16[bx] >= 0x0178)
        { pc = 0x1d4f88; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d4f88; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0072;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b19e0();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x000b;
    r16[bx] += 0x0020;
    r16[dx] = 0x0010;
    r16[cx] = 0x0073;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b19e0();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[bx] += 0x0020;
    r16[dx] = 0x0010;
    r16[cx] = 0x0073;
    yield* sub_1b19e0();
  case 0x1d4f88: // 0160:1d4f88
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d562f() // 0160:1d562f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d1e9, 0x0000);
    if (memoryAGet(ds, 0x20c848) & 0xff)
        { pc = 0x1d5673; break; }
    if (!(memoryAGet16(ds, 0x20d1eb) & 0xffff))
        { pc = 0x1d5673; break; }
    r16[ax] = memoryAGet16(ds, 0x20d1df);
    memoryASet16(ds, 0x20d875, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d1f5);
    if (r16s[ax] <= signed16(0x006e))
        { pc = 0x1d5668; break; }
    r16[ax] = 0x006e;
  case 0x1d5668: // 0160:1d5668
    memoryASet16(ds, 0x20d873, r16[ax]);
    { pc = 0x1d58e6; break; }
  case 0x1d5673: // 0160:1d5673
    if (signed16(memoryAGet16(ds, 0x20cf5f)) <= signed16(0x04b0))
        { pc = 0x1d5693; break; }
    memoryASet16(ds, 0x20d86f, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf5f);
    r16[ax] -= 0x04b0;
    { pc = 0x1d56a7; break; }
  case 0x1d5693: // 0160:1d5693
    memoryASet16(ds, 0x20d86f, 0x0000);
    r16[ax] = 0x04b0;
    r16[ax] -= memoryAGet16(ds, 0x20cf5f);
  case 0x1d56a7: // 0160:1d56a7
    memoryASet16(ds, 0x20ceb7, r16[ax]);
    r32[edx] = 0;
    mul16(r16[ax]);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    if (signed16(memoryAGet16(ds, 0x20cf71)) <= signed16(0x00d0))
        { pc = 0x1d56d8; break; }
    memoryASet16(ds, 0x20d871, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20cf71);
    r16[ax] -= 0x00d0;
    { pc = 0x1d56ec; break; }
  case 0x1d56d8: // 0160:1d56d8
    memoryASet16(ds, 0x20d871, 0x0000);
    r16[ax] = 0x00d0;
    r16[ax] -= memoryAGet16(ds, 0x20cf71);
  case 0x1d56ec: // 0160:1d56ec
    memoryASet16(ds, 0x20ceb9, r16[ax]);
    r32[edx] = 0;
    mul16(r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[ax]);
    r16[ax] += memoryAGet16(ds, 0x20ceb3);
    r32[esi] = 0x00201726;
    r32[edi] = 0x00201766;
    r32[ebp] = 0x002017a4;
    r16[bx] = 0;
    r16[cx] = 0x003c;
    r16[dx] = 0x0078;
  case 0x1d571e: // 0160:1d571e
    if (r16s[ax] <= signed16(memoryAGet16(ds, r32[edi])))
        { pc = 0x1d5757; break; }
    r32[esi] = r32[edi];
    memoryASet32(ds, 0x20e7fd, r32[edi]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) + r32[ebp]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) >> 1);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) & 0xfffffffe);
    r32[edi] = memoryAGet32(ds, 0x20e7fd);
    r16[bx] = r16[cx];
    r16[cx] += r16[dx];
    r16[cx] >>>= 1;
    if (r32[edi] == r32[esi])
        { pc = 0x1d5789; break; }
    if (r32[ebp] == r32[edi])
        { pc = 0x1d5789; break; }
    { pc = 0x1d571e; break; }
  case 0x1d5757: // 0160:1d5757
    r32[ebp] = r32[edi];
    memoryASet32(ds, 0x20e7fd, r32[edi]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) + r32[esi]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) >> 1);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) & 0xfffffffe);
    r32[edi] = memoryAGet32(ds, 0x20e7fd);
    r16[dx] = r16[cx];
    r16[cx] += r16[bx];
    r16[cx] >>>= 1;
    if (r32[edi] == r32[esi])
        { pc = 0x1d5789; break; }
    if (r32[ebp] != r32[edi])
        { pc = 0x1d571e; break; }
  case 0x1d5789: // 0160:1d5789
    memoryASet16(ds, 0x20d873, r16[cx]);
    r32[eax] = 0;
    r32[ebx] = 0;
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] = memoryAGet16(ds, 0x20ceb9);
    if (r16s[bx] >= r16s[ax])
        { pc = 0x1d57be; break; }
    r16[ax] <<= 8;
    if (!(r16[bx] & 0xffff))
        { pc = 0x1d586a; break; }
    push32(r32[edx]);
    r32[edx] = 0;
    div16(r16[bx]);
    r32[edx] = pop32();
    { pc = 0x1d57dc; break; }
  case 0x1d57be: // 0160:1d57be
    r16[bx] <<= 8;
    if (!(r16[ax] & 0xffff))
        { pc = 0x1d586a; break; }
    push32(r32[edx]);
    r16[dx] = r16[ax];
    r16[ax] = r16[bx];
    r16[bx] = r16[dx];
    r32[edx] = 0;
    div16(r16[bx]);
    r32[edx] = pop32();
  case 0x1d57dc: // 0160:1d57dc
    r32[esi] = 0x00201624;
    r32[edi] = 0x002016a4;
    r32[ebp] = 0x00201722;
    r16[bx] = 0;
    r16[cx] = 0x0040;
    r16[dx] = 0x0080;
  case 0x1d57f6: // 0160:1d57f6
    if (r16s[ax] <= signed16(memoryAGet16(ds, r32[edi])))
        { pc = 0x1d582f; break; }
    r32[esi] = r32[edi];
    memoryASet32(ds, 0x20e7fd, r32[edi]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) + r32[ebp]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) >> 1);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) & 0xfffffffe);
    r32[edi] = memoryAGet32(ds, 0x20e7fd);
    r16[bx] = r16[cx];
    r16[cx] += r16[dx];
    r16[cx] >>>= 1;
    if (r32[edi] == r32[esi])
        { pc = 0x1d5861; break; }
    if (r32[ebp] == r32[edi])
        { pc = 0x1d5861; break; }
    { pc = 0x1d57f6; break; }
  case 0x1d582f: // 0160:1d582f
    r32[ebp] = r32[edi];
    memoryASet32(ds, 0x20e7fd, r32[edi]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) + r32[esi]);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) >> 1);
    memoryASet32(ds, 0x20e7fd, memoryAGet32(ds, 0x20e7fd) & 0xfffffffe);
    r32[edi] = memoryAGet32(ds, 0x20e7fd);
    r16[dx] = r16[cx];
    r16[cx] += r16[bx];
    r16[cx] >>>= 1;
    if (r32[edi] == r32[esi])
        { pc = 0x1d5861; break; }
    if (r32[ebp] != r32[edi])
        { pc = 0x1d57f6; break; }
  case 0x1d5861: // 0160:1d5861
    memoryASet16(ds, 0x20d875, r16[cx]);
    { pc = 0x1d5873; break; }
  case 0x1d586a: // 0160:1d586a
    memoryASet16(ds, 0x20d875, 0x0080);
  case 0x1d5873: // 0160:1d5873
    r16[ax] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] = memoryAGet16(ds, 0x20ceb9);
    if (r16s[bx] <= r16s[ax])
        { pc = 0x1d5896; break; }
    r16[ax] = 0x0080;
    r16[ax] -= memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d875, r16[ax]);
  case 0x1d5896: // 0160:1d5896
    if (!(memoryAGet16(ds, 0x20d86f) & 0xffff))
        { pc = 0x1d58bf; break; }
    if (!(memoryAGet16(ds, 0x20d871) & 0xffff))
        { pc = 0x1d58e6; break; }
    r16[ax] = 0x0100;
    r16[ax] -= memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d875, r16[ax]);
    { pc = 0x1d58e6; break; }
  case 0x1d58bf: // 0160:1d58bf
    if (!(memoryAGet16(ds, 0x20d871) & 0xffff))
        { pc = 0x1d58d5; break; }
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x0100);
    { pc = 0x1d58e6; break; }
  case 0x1d58d5: // 0160:1d58d5
    r16[ax] = 0x0200;
    r16[ax] -= memoryAGet16(ds, 0x20d875);
    memoryASet16(ds, 0x20d875, r16[ax]);
  case 0x1d58e6: // 0160:1d58e6
    memoryASet32(ds, 0x20e805, 0x00007800);
    if (signed16(memoryAGet16(ds, 0x20d873)) <= signed16(0x006e))
        { pc = 0x1d590e; break; }
    if (signed16(memoryAGet16(ds, 0x20d1eb)) >= signed16(0x000a))
        { pc = 0x1d590e; break; }
    memoryASet32(ds, 0x20e805, 0x00008000);
  case 0x1d590e: // 0160:1d590e
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x0004);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) & 0x01ff);
    r32[esi] = 0x00201420;
    r16[ax] = memoryAGet16(ds, 0x20d875);
    if (r16s[ax] <= signed16(0x007f))
        { pc = 0x1d5a74; break; }
    if (r16s[ax] <= signed16(0x00ff))
        { pc = 0x1d5a17; break; }
    if (r16s[ax] <= signed16(0x017f))
        { pc = 0x1d59b2; break; }
    r16[ax] -= 0x0180;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[dx] = 0x04b0;
    r16[dx] -= r16[bx];
    r16[bx] = r16[dx];
    r16[dx] = 0x00d0;
    r16[dx] -= r16[cx];
    r16[cx] = r16[dx];
    { pc = 0x1d5ad0; break; }
  case 0x1d59b2: // 0160:1d59b2
    r16[ax] -= 0x0100;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[dx] = 0x04b0;
    r16[dx] -= r16[bx];
    r16[bx] = r16[dx];
    r16[cx] += 0x00d0;
    { pc = 0x1d5ad0; break; }
  case 0x1d5a17: // 0160:1d5a17
    r16[ax] -= 0x0080;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[bx] += 0x04b0;
    r16[cx] += 0x00d0;
    { pc = 0x1d5ad0; break; }
  case 0x1d5a74: // 0160:1d5a74
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[bx] += 0x04b0;
    r16[dx] = 0x00d0;
    r16[dx] -= r16[cx];
    r16[cx] = r16[dx];
  case 0x1d5ad0: // 0160:1d5ad0
    memoryASet16(ds, 0x20cf5f, r16[bx]);
    memoryASet16(ds, 0x20cf71, r16[cx]);
    memoryASet16(ds, 0x20d1e9, 0x0001);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d58e6() // 0160:1d58e6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet32(ds, 0x20e805, 0x00007800);
    if (signed16(memoryAGet16(ds, 0x20d873)) <= signed16(0x006e))
        { pc = 0x1d590e; break; }
    if (signed16(memoryAGet16(ds, 0x20d1eb)) >= signed16(0x000a))
        { pc = 0x1d590e; break; }
    memoryASet32(ds, 0x20e805, 0x00008000);
  case 0x1d590e: // 0160:1d590e
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) + 0x0004);
    memoryASet16(ds, 0x20d875, memoryAGet16(ds, 0x20d875) & 0x01ff);
    r32[esi] = 0x00201420;
    r16[ax] = memoryAGet16(ds, 0x20d875);
    if (r16s[ax] <= signed16(0x007f))
        { pc = 0x1d5a74; break; }
    if (r16s[ax] <= signed16(0x00ff))
        { pc = 0x1d5a17; break; }
    if (r16s[ax] <= signed16(0x017f))
        { pc = 0x1d59b2; break; }
    r16[ax] -= 0x0180;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[dx] = 0x04b0;
    r16[dx] -= r16[bx];
    r16[bx] = r16[dx];
    r16[dx] = 0x00d0;
    r16[dx] -= r16[cx];
    r16[cx] = r16[dx];
    { pc = 0x1d5ad0; break; }
  case 0x1d59b2: // 0160:1d59b2
    r16[ax] -= 0x0100;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[dx] = 0x04b0;
    r16[dx] -= r16[bx];
    r16[bx] = r16[dx];
    r16[cx] += 0x00d0;
    { pc = 0x1d5ad0; break; }
  case 0x1d5a17: // 0160:1d5a17
    r16[ax] -= 0x0080;
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[bx] += 0x04b0;
    r16[cx] += 0x00d0;
    { pc = 0x1d5ad0; break; }
  case 0x1d5a74: // 0160:1d5a74
    r16[ax] <<= 2;
    r32[eax] &= 0x0000ffff;
    r32[ebx] = 0;
    r32[ecx] = 0;
    r32[edx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    r16[dx] = memoryAGet16(ds, 0x20d873);
    push32(r32[eax]);
    r32[ebp] = r32[edx];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    mul32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[ecx];
    mul32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[bx] = r16[ax];
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    div32(memoryAGet32(ds, 0x20e805));
    r16[cx] = r16[ax];
    r32[eax] = pop32();
    r16[bx] += 0x04b0;
    r16[dx] = 0x00d0;
    r16[dx] -= r16[cx];
    r16[cx] = r16[dx];
  case 0x1d5ad0: // 0160:1d5ad0
    memoryASet16(ds, 0x20cf5f, r16[bx]);
    memoryASet16(ds, 0x20cf71, r16[cx]);
    memoryASet16(ds, 0x20d1e9, 0x0001);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d5ba6() // 0160:1d5ba6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20ce91) != 0x0010)
        { pc = 0x1d5c1d; break; }
    if (memoryAGet16(ds, 0x2246cc))
        { pc = 0x1d5c1d; break; }
    r32[esi] = 0x00208cfc;
    r32[edi] = 0x0020c898;
    yield* sub_1d5be1();
    r32[esi] = 0x00208d1a;
    r32[edi] = 0x0020c8ad;
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = r16[ax];
    r16[ax] += r16[ax];
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[ecx] = 0x00000005;
  case 0x1d5bf4: // 0160:1d5bf4
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
    r32[esi]++;
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
    r32[esi]++;
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1d5bf4; break; }
    memoryASet16(ds, 0x224666, 0x0003);
    memoryASet16(ds, 0x20eeab, 0x0001);
  case 0x1d5c1d: // 0160:1d5c1d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d5be1() // 0160:1d5be1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = r16[ax];
    r16[ax] += r16[ax];
    r16[ax] += r16[bx];
    r32[eax] &= 0x0000ffff;
    r32[ecx] = 0x00000005;
  case 0x1d5bf4: // 0160:1d5bf4
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
    r32[esi]++;
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
    r32[esi]++;
    r8[dl] = memoryAGet(ds, r32[esi] + r32[eax]);
    memoryASet(ds, r32[edi], r8[dl]);
    r32[edi]++;
    r32[esi]++;
    if (--r32[ecx])
        { pc = 0x1d5bf4; break; }
    memoryASet16(ds, 0x224666, 0x0003);
    memoryASet16(ds, 0x20eeab, 0x0001);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d5c5e() // 0160:1d5c5e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d1c5);
    r16[ax] &= 0x0003;
    if (r16[ax] != 0x0003)
        { pc = 0x1d5c8b; break; }
    if (!(memoryAGet16(ds, 0x20d0ff) & 0xffff))
        { pc = 0x1d5c8b; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d5e9d();
  case 0x1d5c8b: // 0160:1d5c8b
    r16[ax] = memoryAGet16(ds, 0x20d1c7);
    r16[ax] &= 0x0003;
    if (r16[ax] != 0x0003)
        { pc = 0x1d5cb8; break; }
    if (!(memoryAGet16(ds, 0x20d101) & 0xffff))
        { pc = 0x1d5cb8; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1d5e9d();
  case 0x1d5cb8: // 0160:1d5cb8
    r16[ax] = memoryAGet16(ds, 0x20d1c9);
    r16[ax] &= 0x0003;
    if (r16[ax] != 0x0003)
        { pc = 0x1d5ce5; break; }
    if (!(memoryAGet16(ds, 0x20d103) & 0xffff))
        { pc = 0x1d5ce5; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1d5e9d();
  case 0x1d5ce5: // 0160:1d5ce5
    r16[ax] = memoryAGet16(ds, 0x20d1cb);
    r16[ax] &= 0x0003;
    if (r16[ax] != 0x0003)
        { pc = 0x1d5d12; break; }
    if (!(memoryAGet16(ds, 0x20d105) & 0xffff))
        { pc = 0x1d5d12; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1d5e9d();
  case 0x1d5d12: // 0160:1d5d12
    if (!(memoryAGet16(ds, 0x20d1c5) & 0xffff))
        { pc = 0x1d5d4e; break; }
    if (signed16(memoryAGet16(ds, 0x20d1c5)) <= signed16(0x0014))
        { pc = 0x1d5d3c; break; }
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0021))
        { pc = 0x1d5d3a; break; }
    memoryASet16(ds, 0x20cf85, 0x003b);
  case 0x1d5d3a: // 0160:1d5d3a
    { pc = 0x1d5d4e; break; }
  case 0x1d5d3c: // 0160:1d5d3c
    if (memoryAGet(ds, 0x20d123) == 0x44)
        { pc = 0x1d5d4e; break; }
    memoryASet16(ds, 0x20d1c5, 0x0000);
  case 0x1d5d4e: // 0160:1d5d4e
    if (!(memoryAGet16(ds, 0x20d1c7) & 0xffff))
        { pc = 0x1d5d8a; break; }
    if (signed16(memoryAGet16(ds, 0x20d1c7)) <= signed16(0x0014))
        { pc = 0x1d5d78; break; }
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0021))
        { pc = 0x1d5d76; break; }
    memoryASet16(ds, 0x20cf87, 0x003b);
  case 0x1d5d76: // 0160:1d5d76
    { pc = 0x1d5d8a; break; }
  case 0x1d5d78: // 0160:1d5d78
    if (memoryAGet(ds, 0x20d125) == 0x44)
        { pc = 0x1d5d8a; break; }
    memoryASet16(ds, 0x20d1c7, 0x0000);
  case 0x1d5d8a: // 0160:1d5d8a
    if (!(memoryAGet16(ds, 0x20d1c9) & 0xffff))
        { pc = 0x1d5dc6; break; }
    if (signed16(memoryAGet16(ds, 0x20d1c9)) <= signed16(0x0014))
        { pc = 0x1d5db4; break; }
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0021))
        { pc = 0x1d5db2; break; }
    memoryASet16(ds, 0x20cf89, 0x003b);
  case 0x1d5db2: // 0160:1d5db2
    { pc = 0x1d5dc6; break; }
  case 0x1d5db4: // 0160:1d5db4
    if (memoryAGet(ds, 0x20d127) == 0x44)
        { pc = 0x1d5dc6; break; }
    memoryASet16(ds, 0x20d1c9, 0x0000);
  case 0x1d5dc6: // 0160:1d5dc6
    if (!(memoryAGet16(ds, 0x20d1cb) & 0xffff))
        { pc = 0x1d5e02; break; }
    if (signed16(memoryAGet16(ds, 0x20d1cb)) <= signed16(0x0014))
        { pc = 0x1d5df0; break; }
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0021))
        { pc = 0x1d5dee; break; }
    memoryASet16(ds, 0x20cf8b, 0x003b);
  case 0x1d5dee: // 0160:1d5dee
    { pc = 0x1d5e02; break; }
  case 0x1d5df0: // 0160:1d5df0
    if (memoryAGet(ds, 0x20d129) == 0x44)
        { pc = 0x1d5e02; break; }
    memoryASet16(ds, 0x20d1cb, 0x0000);
  case 0x1d5e02: // 0160:1d5e02
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000008;
  case 0x1d5e0c: // 0160:1d5e0c
    push32(r32[esi]);
    push32(r32[ecx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    if (!r16[cx])
        { pc = 0x1d5e90; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1d5e39; break; }
    r16[cx]++;
    if (r16[cx] != 0x0007)
        { pc = 0x1d5e35; break; }
    memoryASet16(ds, r32[esi] + 0x4, 0x0000);
    { pc = 0x1d5e90; break; }
  case 0x1d5e35: // 0160:1d5e35
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
  case 0x1d5e39: // 0160:1d5e39
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (!r16[ax])
        { pc = 0x1d5e90; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1d5e5c; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d5e90; break; }
  case 0x1d5e5c: // 0160:1d5e5c
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d5e6e; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d5e90; break; }
  case 0x1d5e6e: // 0160:1d5e6e
    if (r16[bx] >= 0x0190)
        { pc = 0x1d5e90; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d5e90; break; }
    r16[cx] += 0x0071;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
  case 0x1d5e90: // 0160:1d5e90
    r32[ecx] = pop32();
    r32[esi] = pop32();
    r32[esi] += 0x00000006;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1d5e0c; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1d5e9d() // 0160:1d5e9d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000008;
  case 0x1d5ea7: // 0160:1d5ea7
    if (!(memoryAGet16(ds, r32[esi] + 0x4) & 0xffff))
        { pc = 0x1d5eb5; break; }
    r32[esi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1d5ea7; break; }
    r32[esp] += 4; return;
  case 0x1d5eb5: // 0160:1d5eb5
    r16[ax] += 0x0088;
    r16[bx] += 0x0088;
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, 0x0001);
    r8[al] = 0x85;
    yield* sub_1b17b7();
    r32[esp] += 4;
    return;
  }
}
function* sub_1d5ed3() // 0160:1d5ed3 +long
{
    r32[esp] -= 4;
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[eax];
    r32[esi] = 0x00208d38;
    r32[ecx] &= 0x0000007e;
    r32[esi] += r32[ecx];
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] += r16[ax];
    r16[ax] += 0x0104;
    memoryASet16(ds, r32[edi] + 0xd8e, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe0e, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd90, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe10, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd92, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe12, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd94, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe14, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd96, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe16, r16[ax]);
    r16[ax] += 0x0009;
    memoryASet16(ds, r32[edi] + 0xd98, r16[ax]);
    r16[ax]++;
    memoryASet16(ds, r32[edi] + 0xe18, r16[ax]);
    r32[esp] += 4;
}
function* sub_1d5fa8() // 0160:1d5fa8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d5fa8; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 148884 bytes // gap 148884 bytes
  case 0x1d5fa8: // 0160:1d5fa8
    r16[bx]--;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] += r16[dx];
    r16[cx] &= 0x000f;
    r16[cx] >>>= 3;
    r16[ax] += r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (!r16[ax])
        { pc = 0x1d6005; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1d5fd9; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d6005; break; }
  case 0x1d5fd9: // 0160:1d5fd9
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d5feb; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d6005; break; }
  case 0x1d5feb: // 0160:1d5feb
    if (r16[bx] >= 0x0190)
        { pc = 0x1d6005; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d6005; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0078;
    { pc = 0x1b19e0; break; }
  case 0x1d6005: // 0160:1d6005
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d608c() // 0160:1d608c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0090;
    r16[ax] -= memoryAGet16(ds, 0x20d36d);
    if (r16s[ax] < 0)
        { pc = 0x1d60bc; break; }
    if (r16s[ax] >= signed16(0x0064))
        { pc = 0x1d60bc; break; }
    r16[bx] += 0x0090;
    r16[bx] -= memoryAGet16(ds, 0x20d36f);
    if (r16s[bx] < 0)
        { pc = 0x1d60bc; break; }
    if (r16s[bx] >= signed16(0x0080))
        { pc = 0x1d60bc; break; }
    r16[ax] = 0x0001;
    r32[esp] += 4; return;
  case 0x1d60bc: // 0160:1d60bc
    r16[ax] = 0;
    r32[esp] += 4;
    return;
  }
}
function* sub_1d62df() // 0160:1d62df +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d62df; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 149707 bytes // gap 149707 bytes
  case 0x1d62df: // 0160:1d62df
    r32[esi] = 0x002971d4;
    r32[eax] = 0;
    r16[bx] = memoryAGet16(ds, 0x20d36d);
    r16[bx] -= 0x02e0;
    r16[bx] &= 0x001f;
    r16[ax] = 0x0020;
    r16[ax] -= r16[bx];
    r32[esi] += r32[eax];
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00040014;
    push32(r32[esi]);
    r32[ecx] = 0x00000040;
  case 0x1d6311: // 0160:1d6311
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ecx] = 0x00000004;
  case 0x1d6319: // 0160:1d6319
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0x8, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xc, r32[eax]);
    r32[edi] += 0x00000010;
    r32[esi] += 0x00000010;
    if (--r32[ecx])
        { pc = 0x1d6319; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] += 0x000000a0;
    r32[edi] += 0x00000140;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1d6311; break; }
    r32[edi] = memoryAGet32(ds, 0x20b800);
    r32[edi] += 0x00047814;
    r32[esi] = pop32();
    r32[esi] += 0x00000040;
    r32[ecx] = 0x00000040;
  case 0x1d638d: // 0160:1d638d
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ecx] = 0x00000004;
  case 0x1d6395: // 0160:1d6395
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xc);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi]);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi], r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x9);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x5);
    memoryASet32(ds, r32[edi] + 0x4, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xa);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xe);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x2);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x6);
    memoryASet32(ds, r32[edi] + 0x8, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0xb);
    r8[ah] = memoryAGet(ds, r32[esi] + 0xf);
    r32[eax] <<= 16;
    r8[al] = memoryAGet(ds, r32[esi] + 0x3);
    r8[ah] = memoryAGet(ds, r32[esi] + 0x7);
    memoryASet32(ds, r32[edi] + 0xc, r32[eax]);
    r32[edi] += 0x00000010;
    r32[esi] += 0x00000010;
    if (--r32[ecx])
        { pc = 0x1d6395; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esi] += 0x000000a0;
    r32[edi] += 0x00000140;
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1d638d; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[ax] -= 0x02e0;
    r16[ax] >>>= 5;
    r16[bx] = r16[ax];
    r16[ax] <<= 7;
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[eax];
    if (!r16[bx])
        { pc = 0x1d6446; break; }
    memoryASet16(ds, r32[edi] + 0x914, 0x00f3);
    memoryASet16(ds, r32[edi] + 0x916, 0x00f3);
    memoryASet16(ds, r32[edi] + 0x918, 0x00f3);
    memoryASet16(ds, r32[edi] + 0x91a, 0x00f3);
    memoryASet16(ds, r32[edi] + 0x91c, 0x00f3);
  case 0x1d6446: // 0160:1d6446
    memoryASet16(ds, r32[edi] + 0x994, 0x0102);
    memoryASet16(ds, r32[edi] + 0xa14, 0x0103);
    memoryASet16(ds, r32[edi] + 0xa94, 0x0120);
    memoryASet16(ds, r32[edi] + 0x996, 0x010c);
    memoryASet16(ds, r32[edi] + 0xa16, 0x010d);
    memoryASet16(ds, r32[edi] + 0xa96, 0x012a);
    memoryASet16(ds, r32[edi] + 0x998, 0x010c);
    memoryASet16(ds, r32[edi] + 0xa18, 0x010d);
    memoryASet16(ds, r32[edi] + 0xa98, 0x012a);
    memoryASet16(ds, r32[edi] + 0x99a, 0x010c);
    memoryASet16(ds, r32[edi] + 0xa1a, 0x010d);
    memoryASet16(ds, r32[edi] + 0xa9a, 0x012a);
    memoryASet16(ds, r32[edi] + 0x99c, 0x0116);
    memoryASet16(ds, r32[edi] + 0xa1c, 0x0117);
    memoryASet16(ds, r32[edi] + 0xa9c, 0x0134);
    if (r16s[bx] >= signed16(0x0009))
        { pc = 0x1d6533; break; }
    memoryASet16(ds, r32[edi] + 0xb14, 0x0121);
    memoryASet16(ds, r32[edi] + 0xb16, 0x012b);
    memoryASet16(ds, r32[edi] + 0xb18, 0x012b);
    memoryASet16(ds, r32[edi] + 0xb1a, 0x012b);
    memoryASet16(ds, r32[edi] + 0xb1c, 0x0135);
    if (r16s[bx] >= signed16(0x0008))
        { pc = 0x1d6533; break; }
    memoryASet16(ds, r32[edi] + 0xb94, 0x00f3);
    memoryASet16(ds, r32[edi] + 0xb96, 0x00f3);
    memoryASet16(ds, r32[edi] + 0xb98, 0x00f3);
    memoryASet16(ds, r32[edi] + 0xb9a, 0x00f3);
    memoryASet16(ds, r32[edi] + 0xb9c, 0x00f3);
  case 0x1d6533: // 0160:1d6533
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    if (r16s[ax] <= signed16(0x02e9))
        { pc = 0x1d6597; break; }
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[ax] -= 0x0008;
    r16[bx] -= 0x0004;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x000f;
    r16[cx] >>>= 2;
    r16[cx] += 0x0073;
    yield* sub_1d6603();
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[ax] -= 0x0008;
    r16[bx] += 0x0078;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x000f;
    r16[cx] >>>= 2;
    r16[cx] += 0x0073;
    r16[dx] = 0x0012;
    yield* sub_1d6607();
  case 0x1d6597: // 0160:1d6597
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    if (r16s[ax] >= signed16(0x03f8))
        { pc = 0x1d6643; break; }
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[ax] += 0x0056;
    r16[bx] -= 0x0004;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x000f;
    r16[cx] >>>= 2;
    r16[cx] += 0x0073;
    r16[dx] = 0x0011;
    yield* sub_1d6607();
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[ax] += 0x0056;
    r16[bx] += 0x0078;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x000f;
    r16[cx] >>>= 2;
    r16[cx] += 0x0073;
    r16[dx] = 0x0013;
    { pc = 0x1d6607; break; }
    // gap 7 bytes // gap 7 bytes
  case 0x1d6607: // 0160:1d6607
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (!r16[ax])
        { pc = 0x1d6643; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1d661f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d6643; break; }
  case 0x1d661f: // 0160:1d661f
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d6631; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d6643; break; }
  case 0x1d6631: // 0160:1d6631
    if (r16[bx] >= 0x0190)
        { pc = 0x1d6643; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d6643; break; }
    { pc = 0x1b19e0; break; }
  case 0x1d6643: // 0160:1d6643
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d6603() // 0160:1d6603 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d6603; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 150511 bytes // gap 150511 bytes
  case 0x1d6603: // 0160:1d6603
    r16[dx] = 0x0010;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (!r16[ax])
        { pc = 0x1d6643; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1d661f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d6643; break; }
  case 0x1d661f: // 0160:1d661f
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d6631; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d6643; break; }
  case 0x1d6631: // 0160:1d6631
    if (r16[bx] >= 0x0190)
        { pc = 0x1d6643; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d6643; break; }
    { pc = 0x1b19e0; break; }
  case 0x1d6643: // 0160:1d6643
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d6607() // 0160:1d6607 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d6607; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 150515 bytes // gap 150515 bytes
  case 0x1d6607: // 0160:1d6607
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (!r16[ax])
        { pc = 0x1d6643; break; }
    if (r16s[ax] >= 0)
        { pc = 0x1d661f; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d6643; break; }
  case 0x1d661f: // 0160:1d661f
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d6631; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d6643; break; }
  case 0x1d6631: // 0160:1d6631
    if (r16[bx] >= 0x0190)
        { pc = 0x1d6643; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d6643; break; }
    { pc = 0x1b19e0; break; }
  case 0x1d6643: // 0160:1d6643
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d71ce() // 0160:1d71ce +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d71ce; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 133863 bytes // gap 133863 bytes
  case 0x1d24fb: // 0160:1d24fb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[ax] < 0)
        { pc = 0x1d251c; break; }
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    r32[ebx] += r32[ebx];
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[ebx];
    r32[edi] -= 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    { pc = 0x1d24fb; break; }
  case 0x1d251c: // 0160:1d251c
    r32[esp] += 4; return;
    // gap 19633 bytes // gap 19633 bytes
  case 0x1d71ce: // 0160:1d71ce
    r32[esi] = 0x002088e4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d7b9);
    r16[ax] <<= 2;
    r32[eax] = memoryAGet32(ds, r32[esi] + r32[eax]);
    if (!r32[eax])
        { pc = 0x1d71ea; break; }
    r32[esi] = r32[eax];
    switch (r32[esi])
    {
        case 0x001d71eb: { pc = 0x1d71eb; break; }
        case 0x001d725b: { pc = 0x1d725b; break; }
        case 0x001d7415: { pc = 0x1d7415; break; }
        case 0x001d7d17: { pc = 0x1d7d17; break; }
        case 0x001d7e13: { pc = 0x1d7e13; break; }
        case 0x001d928a: { pc = 0x1d928a; break; }
        case 0x001d9633: { pc = 0x1d9633; break; }
        case 0x001d81f3: { pc = 0x1d81f3; break; }
        case 0x001d82e4: { pc = 0x1d82e4; break; }
        case 0x001d84a2: { pc = 0x1d84a2; break; }
        case 0x001d891c: { pc = 0x1d891c; break; }
        case 0x001d9685: { pc = 0x1d9685; break; }
        case 0x001d9208: { pc = 0x1d9208; break; }
        case 0x001d81d4: { pc = 0x1d81d4; break; }
        case 0x001da151: { pc = 0x1da151; break; }
        case 0x001da030: { pc = 0x1da030; break; }
        case 0x001d8947: { pc = 0x1d8947; break; }
        case 0x001d8c47: { pc = 0x1d8c47; break; }
        case 0x001d8f91: { pc = 0x1d8f91; break; }
        case 0x001d8936: { pc = 0x1d8936; break; }
        case 0x001da1ba: { pc = 0x1da1ba; break; }
        default:
            stop("ind 0160:1d71e8");
    }
    break;
  case 0x1d71ea: // 0160:1d71ea
    r32[esp] += 4; return;
  case 0x1d71eb: // 0160:1d71eb
    if (memoryAGet16(ds, 0x20c830) & 0xffff)
        { pc = 0x1d71f6; break; }
  case 0x1d71f6: // 0160:1d71f6
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x001f;
    if (r16[ax])
        { pc = 0x1d7218; break; }
    yield* sub_1b1c25();
    if (r8s[al] >= signed8(0x3c))
        { pc = 0x1d7218; break; }
    r16[ax] &= 0x0003;
    r16[ax] += 0x005b;
    yield* sub_1b17b7();
  case 0x1d7218: // 0160:1d7218
    yield* sub_1d81e0();
    r32[ecx] = 0x00000004;
  case 0x1d7222: // 0160:1d7222
    push32(r32[ecx]);
    yield* sub_1b1c25();
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    yield* sub_1b1c25();
    r16[ax] &= 0x00ff;
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] &= 0x00ff;
    r16[bx] += 0x0078;
    r16[cx] = 0x0080;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1d7222; break; }
    r32[esp] += 4; return;
  case 0x1d725b: // 0160:1d725b
    yield* sub_1d81e0();
    if (memoryAGet16(ds, 0x20c830) != 0x0096)
        { pc = 0x1d7274; break; }
    r16[ax] = 0x0121;
    yield* sub_1b1715();
  case 0x1d7274: // 0160:1d7274
    if (memoryAGet16(ds, 0x20d897) & 0xffff)
        { pc = 0x1d7291; break; }
    r16[ax] = 0x0064;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d897, 0x0001);
  case 0x1d7291: // 0160:1d7291
    r8[al] = 0x01;
    r16[bx] = memoryAGet16(ds, 0x20ed95);
    r16[bx] -= 0x0064;
    yield* sub_1ce643();
    r16[ax] = memoryAGet16(ds, 0x20ed93);
    if (flags.zero)
        { pc = 0x1d72c7; break; }
    memoryASet16(ds, 0x20ed95, memoryAGet16(ds, 0x20ed95) + 0x0003);
    if (signed16(memoryAGet16(ds, 0x20ed95)) <= signed16(0x00c8))
        { pc = 0x1d72da; break; }
    memoryASet16(ds, 0x20ed93, 0x0000);
  case 0x1d72c7: // 0160:1d72c7
    memoryASet16(ds, 0x20ed95, memoryAGet16(ds, 0x20ed95) - 0x0003);
    if (signed16(memoryAGet16(ds, 0x20ed95)) >= 0)
        { pc = 0x1d72da; break; }
    memoryASet16(ds, 0x20ed93, 0x0001);
  case 0x1d72da: // 0160:1d72da
    yield* sub_1b1c25();
    if (r16s[ax] >= signed16(0x0003))
        { pc = 0x1d72f9; break; }
    r16[ax] = memoryAGet16(ds, 0x20ed93);
    r16[ax]++;
    r16[ax] &= 0x0001;
    memoryASet16(ds, 0x20ed93, r16[ax]);
  case 0x1d72f9: // 0160:1d72f9
    memoryASet32(ds, 0x20d7fb, 0x00000018);
    memoryASet32(ds, 0x20d7ff, 0x00000003);
    r32[esi] = 0x0020d38d;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d731b: // 0160:1d731b
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[cx] = memoryAGet16(ds, 0x20e809);
    r16[cx] >>>= 1;
    r16[cx] += 0x0007;
    r16[ax] += r16[cx];
    r16[ax] += memoryAGet16(ds, 0x20d7f1);
    memoryASet16(ds, r32[esi], r16[ax]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx]--;
    r16[bx] += memoryAGet16(ds, 0x20d7f3);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    if (r16[cx] == 0x0005)
        { pc = 0x1d7381; break; }
    if (r16[cx] == 0x0006)
        { pc = 0x1d7381; break; }
    r16[dx] = memoryAGet16(ds, 0x20c830);
    r16[dx] += memoryAGet16(ds, 0x20e809);
    r16[dx] &= 0x0007;
    if (r16[dx])
        { pc = 0x1d7381; break; }
    r16[cx]++;
    if (r16[cx] != 0x0005)
        { pc = 0x1d737d; break; }
    r16[cx] = 0;
  case 0x1d737d: // 0160:1d737d
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
  case 0x1d7381: // 0160:1d7381
    r16[cx] += 0x0079;
    if (r16s[ax] > signed16(0x01c0))
        { pc = 0x1d73b7; break; }
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    r32[ebp] = memoryAGet32(ds, 0x20e809);
    push32(r32[ebp]);
    push32(r32[esi]);
    yield* sub_1b19ac();
    r32[esi] = pop32();
    r32[ebp] = pop32();
    memoryASet32(ds, 0x20e809, r32[ebp]);
    r32[esi] += 0x00000008;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d731b; break; }
    { pc = 0x1d7414; break; }
  case 0x1d73b7: // 0160:1d73b7
    yield* sub_1b1c25();
    if (r8s[al] >= signed8(0x05))
        { pc = 0x1d7403; break; }
    memoryASet16(ds, r32[esi], 0x0000);
    yield* sub_1b1c25();
    r16[ax] &= 0x00ff;
    r16[ax] <<= 1;
    memoryASet16(ds, r32[esi] + 0x2, r16[ax]);
    yield* sub_1b1c25();
    r16[ax] &= 0x0003;
    r16[ax] += 0x0010;
    memoryASet16(ds, r32[esi] + 0x6, r16[ax]);
    yield* sub_1b1c25();
    r16[cx] = 0;
    if (r16s[ax] >= signed16(0x0040))
        { pc = 0x1d73ff; break; }
    r16[ax] &= 0x0001;
    r16[ax] += 0x0005;
    r16[cx] = r16[ax];
  case 0x1d73ff: // 0160:1d73ff
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
  case 0x1d7403: // 0160:1d7403
    r32[esi] += 0x00000008;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d731b; break; }
  case 0x1d7414: // 0160:1d7414
    r32[esp] += 4; return;
  case 0x1d7415: // 0160:1d7415
    r16[ax] = memoryAGet16(ds, 0x20d37d);
    if (!r16[ax])
        { pc = 0x1d74b4; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d746f; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d379);
    r16[bx] = memoryAGet16(ds, 0x20d37b);
    r16[bx]++;
    memoryASet16(ds, 0x20d37b, r16[bx]);
    r16[bx] &= 0x0007;
    if (r16[bx])
        { pc = 0x1d745a; break; }
    r16[ax]++;
    if (r16[ax] == 0x003f)
        { pc = 0x1d74b4; break; }
    memoryASet16(ds, 0x20d379, r16[ax]);
  case 0x1d745a: // 0160:1d745a
    r32[esi] = 0x00208e58;
    r16[ax] <<= 1;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d377, memoryAGet16(ds, 0x20d377) - r16[ax]);
    { pc = 0x1d74bd; break; }
  case 0x1d746f: // 0160:1d746f
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d379);
    r16[bx] = memoryAGet16(ds, 0x20d37b);
    r16[bx]++;
    memoryASet16(ds, 0x20d37b, r16[bx]);
    r16[bx] &= 0x0007;
    if (r16[bx])
        { pc = 0x1d749f; break; }
    r16[ax]++;
    if (r16[ax] == 0x003f)
        { pc = 0x1d74b4; break; }
    memoryASet16(ds, 0x20d379, r16[ax]);
  case 0x1d749f: // 0160:1d749f
    r32[esi] = 0x00208e58;
    r16[ax] <<= 1;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d377, memoryAGet16(ds, 0x20d377) + r16[ax]);
    { pc = 0x1d74bd; break; }
  case 0x1d74b4: // 0160:1d74b4
    memoryASet16(ds, 0x20d37d, 0x0000);
  case 0x1d74bd: // 0160:1d74bd
    r16[ax] = memoryAGet16(ds, 0x20d375);
    r16[bx] = memoryAGet16(ds, 0x20d377);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d74e0; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d7530; break; }
  case 0x1d74e0: // 0160:1d74e0
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d74f6; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d7530; break; }
  case 0x1d74f6: // 0160:1d74f6
    if (r16[bx] >= 0x0178)
        { pc = 0x1d7530; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d7530; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0071;
    if (!(memoryAGet16(ds, 0x20d37d) & 0xffff))
        { pc = 0x1d752b; break; }
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0003;
    r16[bp] >>>= 1;
    r16[cx] += r16[bp];
  case 0x1d752b: // 0160:1d752b
    yield* sub_1b19e0();
  case 0x1d7530: // 0160:1d7530
    yield* sub_1d7d99();
    if (memoryAGet16(ds, 0x20d04b) == 0x0572)
        { pc = 0x1d756b; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d7586; break; }
    if (memoryAGet16(ds, 0x20d04d) == 0x0572)
        { pc = 0x1d756b; break; }
    if (memoryAGet16(ds, 0x20d04f) == 0x0572)
        { pc = 0x1d756b; break; }
    if (memoryAGet16(ds, 0x20d051) != 0x0572)
        { pc = 0x1d7586; break; }
  case 0x1d756b: // 0160:1d756b
    memoryASet16(ds, 0x20d381, 0x07fc);
    memoryASet16(ds, 0x20d383, 0x0000);
    memoryASet16(ds, 0x20d385, 0x0000);
  case 0x1d7586: // 0160:1d7586
    if (memoryAGet16(ds, 0x20d04b) == 0x0218)
        { pc = 0x1d75bc; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d75d7; break; }
    if (memoryAGet16(ds, 0x20d04d) == 0x0218)
        { pc = 0x1d75bc; break; }
    if (memoryAGet16(ds, 0x20d04f) == 0x0218)
        { pc = 0x1d75bc; break; }
    if (memoryAGet16(ds, 0x20d051) != 0x0218)
        { pc = 0x1d75d7; break; }
  case 0x1d75bc: // 0160:1d75bc
    memoryASet16(ds, 0x20d381, 0x0012);
    memoryASet16(ds, 0x20d383, 0x0000);
    memoryASet16(ds, 0x20d385, 0x0002);
  case 0x1d75d7: // 0160:1d75d7
    if (memoryAGet16(ds, 0x20d37d) == 0x0001)
        { pc = 0x1d7656; break; }
    if (memoryAGet16(ds, 0x20d04b) == 0x0438)
        { pc = 0x1d760c; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d7656; break; }
    if (memoryAGet16(ds, 0x20d04d) == 0x0438)
        { pc = 0x1d760c; break; }
    if (memoryAGet16(ds, 0x20d04f) != 0x0438)
        { pc = 0x1d7656; break; }
  case 0x1d760c: // 0160:1d760c
    if (signed16(memoryAGet16(ds, 0x20d377)) >= signed16(0x03e8))
        { pc = 0x1d7656; break; }
    r8[al] = 0x60;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d37d, 0x0001);
    memoryASet16(ds, 0x20d377, 0x01c8);
    memoryASet16(ds, 0x20d379, 0x0000);
    memoryASet16(ds, 0x20d37b, 0x0000);
    r32[esi] = 0x00208f0c;
    yield* sub_1d24fb();
    r32[esi] = 0x00208ef2;
    yield* sub_1d24fb();
  case 0x1d7656: // 0160:1d7656
    if (memoryAGet16(ds, 0x20d37d) == 0x0002)
        { pc = 0x1d76e6; break; }
    if (memoryAGet16(ds, 0x20d04b) == 0x0085)
        { pc = 0x1d76a5; break; }
    if (memoryAGet16(ds, 0x20d04b) == 0x0086)
        { pc = 0x1d76a5; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d76e6; break; }
    if (memoryAGet16(ds, 0x20d04d) == 0x0085)
        { pc = 0x1d76a5; break; }
    if (memoryAGet16(ds, 0x20d04f) == 0x0085)
        { pc = 0x1d76a5; break; }
    if (memoryAGet16(ds, 0x20d051) != 0x0085)
        { pc = 0x1d76e6; break; }
  case 0x1d76a5: // 0160:1d76a5
    if (signed16(memoryAGet16(ds, 0x20d377)) <= signed16(0x03e8))
        { pc = 0x1d76e6; break; }
    r8[al] = 0x60;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d37d, 0x0002);
    memoryASet16(ds, 0x20d379, 0x0000);
    memoryASet16(ds, 0x20d37b, 0x0000);
    r32[esi] = 0x00208f26;
    yield* sub_1d24fb();
    r32[esi] = 0x00208ed8;
    yield* sub_1d24fb();
  case 0x1d76e6: // 0160:1d76e6
    yield* sub_1d7823();
    if (!(memoryAGet16(ds, 0x20d37d) & 0xffff))
        { pc = 0x1d7822; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bp] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf97, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfa9, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bp] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf99, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfab, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bp] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9b, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfad, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[bp] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9d, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfaf, r16[bp]);
  case 0x1d7822: // 0160:1d7822
    r32[esp] += 4; return;
    // gap 1268 bytes // gap 1268 bytes
  case 0x1d7d17: // 0160:1d7d17
    yield* sub_1d7d99();
    yield* sub_1d7823();
    yield* sub_1d7a6a();
    r16[ax] = memoryAGet16(ds, 0x20d389);
    r16[bx] = memoryAGet16(ds, 0x20d38b);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d7d49; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d7d72; break; }
  case 0x1d7d49: // 0160:1d7d49
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d7d52; break; }
  case 0x1d7d52: // 0160:1d7d52
    if (r16[bx] < 0x0178)
        { pc = 0x1d7d5f; break; }
    if (r16[bx] < 0xff9c)
        { pc = 0x1d7d72; break; }
  case 0x1d7d5f: // 0160:1d7d5f
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d7d72; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0074;
    yield* sub_1b19e0();
  case 0x1d7d72: // 0160:1d7d72
    r16[ax] = memoryAGet16(ds, 0x20d38d);
    r16[ax]++;
    r32[eax] &= 0x0000003f;
    memoryASet16(ds, 0x20d38d, r16[ax]);
    r32[esi] = 0x00208dd8;
    r16[ax] <<= 1;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) + r16[ax]);
    r32[esp] += 4; return;
    // gap 122 bytes // gap 122 bytes
  case 0x1d7e13: // 0160:1d7e13
    if (!(memoryAGet16(ds, 0x20d37d) & 0xffff))
        { pc = 0x1d7e3c; break; }
    memoryASet16(ds, 0x20d377, memoryAGet16(ds, 0x20d377) - 0x0002);
    if (memoryAGet16(ds, 0x20d377) != 0x01a0)
        { pc = 0x1d7e58; break; }
    memoryASet16(ds, 0x20d37d, 0x0000);
    { pc = 0x1d7e58; break; }
  case 0x1d7e3c: // 0160:1d7e3c
    memoryASet16(ds, 0x20d377, memoryAGet16(ds, 0x20d377) + 0x0002);
    if (memoryAGet16(ds, 0x20d377) != 0x04b0)
        { pc = 0x1d7e58; break; }
    memoryASet16(ds, 0x20d37d, 0x0001);
  case 0x1d7e58: // 0160:1d7e58
    if (!(memoryAGet16(ds, 0x20d387) & 0xffff))
        { pc = 0x1d7e81; break; }
    memoryASet16(ds, 0x20d381, memoryAGet16(ds, 0x20d381) - 0x0002);
    if (memoryAGet16(ds, 0x20d381) != 0x01a0)
        { pc = 0x1d7e9d; break; }
    memoryASet16(ds, 0x20d387, 0x0000);
    { pc = 0x1d7e9d; break; }
  case 0x1d7e81: // 0160:1d7e81
    memoryASet16(ds, 0x20d381, memoryAGet16(ds, 0x20d381) + 0x0002);
    if (memoryAGet16(ds, 0x20d381) != 0x04b2)
        { pc = 0x1d7e9d; break; }
    memoryASet16(ds, 0x20d387, 0x0001);
  case 0x1d7e9d: // 0160:1d7e9d
    r16[ax] = memoryAGet16(ds, 0x20d375);
    r16[bx] = memoryAGet16(ds, 0x20d377);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d7ec0; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d7f00; break; }
  case 0x1d7ec0: // 0160:1d7ec0
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d7ed6; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d7f00; break; }
  case 0x1d7ed6: // 0160:1d7ed6
    if (r16[bx] >= 0x0178)
        { pc = 0x1d7f00; break; }
    if (r16s[bx] <= signed16(0x003c))
        { pc = 0x1d7f00; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d7f00; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0070;
    yield* sub_1b19e0();
    { pc = 0x1d7f07; break; }
  case 0x1d7f00: // 0160:1d7f00
    memoryASet(ds, 0x20d899, 0x00);
  case 0x1d7f07: // 0160:1d7f07
    r16[ax] = memoryAGet16(ds, 0x20d37f);
    r16[bx] = memoryAGet16(ds, 0x20d381);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d7f2a; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d7f7c; break; }
  case 0x1d7f2a: // 0160:1d7f2a
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d7f40; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d7f7c; break; }
  case 0x1d7f40: // 0160:1d7f40
    if (r16[bx] >= 0x0178)
        { pc = 0x1d7f7c; break; }
    if (r16s[bx] <= signed16(0x003c))
        { pc = 0x1d7f7c; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d7f7c; break; }
    r16[dx] = 0x0010;
    memoryASet16(ds, 0x20ce8f, 0x0000);
    r16[cx] = 0x0070;
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20ce8f, 0xffff);
    { pc = 0x1d7f83; break; }
  case 0x1d7f7c: // 0160:1d7f7c
    memoryASet(ds, 0x20d89a, 0x00);
  case 0x1d7f83: // 0160:1d7f83
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bp] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf97, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfa9, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bp] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf99, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfab, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bp] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9b, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfad, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[bp] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c1b();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9d, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfaf, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bp] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c99();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf97, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfa9, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bp] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c99();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf99, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfab, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bp] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c99();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9b, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfad, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[bp] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7c99();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9d, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfaf, r16[bp]);
    r32[esp] += 4; return;
  case 0x1d81d4: // 0160:1d81d4
    if (!(memoryAGet16(ds, 0x20d2c3) & 0xffff))
        { pc = 0x1d81e0; break; }
    r32[esp] += 4; return;
  case 0x1d81e0: // 0160:1d81e0
    memoryASet16(ds, 0x20d7f7, 0xff00);
    memoryASet16(ds, 0x20d7f9, 0x0100);
    r32[esp] += 4; return;
  case 0x1d81f3: // 0160:1d81f3
    memoryASet16(ds, 0x20d869, 0x0001);
    memoryASet(ds, 0x1f1c44, 0x01);
    r32[ecx] = 0x0000000b;
    yield* sub_1d8275();
    r16[ax] = 0x0387;
    r16[bx] = 0x0488;
    yield* sub_1d8222();
    r16[ax] = 0x02e7;
    r16[bx] = 0x0508;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d8238; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d8274; break; }
  case 0x1d8238: // 0160:1d8238
    r16[bx]--;
    r16[ax]++;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d8256; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d8274; break; }
  case 0x1d8256: // 0160:1d8256
    if (r16[bx] >= 0x0178)
        { pc = 0x1d8274; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d8274; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0074;
    { pc = 0x1b19e0; break; }
  case 0x1d8274: // 0160:1d8274
    r32[esp] += 4; return;
  case 0x1d8275: // 0160:1d8275
    r32[esi] = 0x0020d36d;
  case 0x1d827a: // 0160:1d827a
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[esi] += 0x00000004;
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d829c; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d82df; break; }
  case 0x1d829c: // 0160:1d829c
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d82b2; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d82df; break; }
  case 0x1d82b2: // 0160:1d82b2
    if (r16[bx] >= 0x0178)
        { pc = 0x1d82df; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d82df; break; }
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 2;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0070;
    yield* sub_1b19e0();
  case 0x1d82df: // 0160:1d82df
    r32[esi] = pop32();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1d827a; break; }
    r32[esp] += 4; return;
  case 0x1d82e4: // 0160:1d82e4
    memoryASet16(ds, 0x20d869, 0x0001);
    memoryASet(ds, 0x1f1c44, 0x01);
    r32[ecx] = 0x00000003;
    yield* sub_1d8275();
    r16[ax] = 0x03a7;
    r16[bx] = 0x02a8;
    yield* sub_1d8222();
    r16[ax] = 0x0367;
    r16[bx] = 0x0468;
    yield* sub_1d8222();
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0040;
    if (r16[ax])
        { pc = 0x1d8335; break; }
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0001;
    memoryASet16(ds, 0x20d379, memoryAGet16(ds, 0x20d379) + r16[ax]);
  case 0x1d8335: // 0160:1d8335
    r16[cx] = 0x0004;
    r16[ax] = 0x02fe;
    r16[bx] = 0x0707;
    yield* sub_1d843e();
    r16[cx] = 0x0003;
    r16[ax] = 0x02ec;
    r16[bx] = 0x0710;
    yield* sub_1d83da();
    r16[cx] = 0x0002;
    r16[ax] = 0x02dd;
    r16[bx] = 0x0710;
    yield* sub_1d83da();
    r16[cx] = 0x0001;
    r16[ax] = 0x02cd;
    r16[bx] = 0x0714;
    yield* sub_1d83da();
    r16[cx] = 0x0000;
    r16[ax] = 0x02bd;
    r16[bx] = 0x0719;
    yield* sub_1d83da();
    r16[cx] = 0x0004;
    r16[ax] = 0x0362;
    r16[bx] = 0x0707;
    yield* sub_1d843e();
    r16[cx] = 0x0003;
    r16[ax] = 0x0378;
    r16[bx] = 0x0710;
    yield* sub_1d83da();
    r16[cx] = 0x0002;
    r16[ax] = 0x0387;
    r16[bx] = 0x0710;
    yield* sub_1d83da();
    r16[cx] = 0x0001;
    r16[ax] = 0x0397;
    r16[bx] = 0x0714;
    yield* sub_1d83da();
    r16[cx] = 0x0000;
    r16[ax] = 0x03a5;
    r16[bx] = 0x0719;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d83f0; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d843d; break; }
  case 0x1d83f0: // 0160:1d83f0
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d8406; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d843d; break; }
  case 0x1d8406: // 0160:1d8406
    if (r16[bx] >= 0x0160)
        { pc = 0x1d843d; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d843d; break; }
    r16[cx] += memoryAGet16(ds, 0x20d379);
    r32[ecx] &= 0x00000007;
    r32[esi] = 0x00209130;
    r16[cx] <<= 1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] += r16[cx];
    r16[dx] = 0x0010;
    r16[cx] = 0x0077;
    { pc = 0x1b19e0; break; }
  case 0x1d843d: // 0160:1d843d
    r32[esp] += 4; return;
    // gap 100 bytes // gap 100 bytes
  case 0x1d84a2: // 0160:1d84a2
    memoryASet16(ds, 0x20d869, 0x0001);
    memoryASet(ds, 0x1f1c44, 0x01);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1d84d2; break; }
    r16[ax] = memoryAGet16(ds, 0x20d385);
    r16[ax]++;
    r16[ax] &= 0x0003;
    memoryASet16(ds, 0x20d385, r16[ax]);
  case 0x1d84d2: // 0160:1d84d2
    r16[ax] = memoryAGet16(ds, 0x20d381);
    r16[bx] = memoryAGet16(ds, 0x20d383);
    yield* sub_1d8828();
    r16[ax] = memoryAGet16(ds, 0x20d389);
    r16[bx] = memoryAGet16(ds, 0x20d38b);
    yield* sub_1d8828();
    memoryASet16(ds, 0x20d387, memoryAGet16(ds, 0x20d387) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20d387);
    r32[eax] &= 0x0000003f;
    r16[ax] <<= 1;
    r32[esi] = 0x00208f40;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d381, memoryAGet16(ds, 0x20d381) + r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20d387);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000003f;
    r16[ax] <<= 1;
    r32[esi] = 0x00208f40;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d383, memoryAGet16(ds, 0x20d383) + r16[bx]);
    memoryASet16(ds, 0x20d38f, memoryAGet16(ds, 0x20d38f) + 0x0001);
    r16[ax] = memoryAGet16(ds, 0x20d38f);
    r32[eax] &= 0x0000003f;
    r16[ax] <<= 1;
    r32[esi] = 0x00208f40;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d389, memoryAGet16(ds, 0x20d389) + r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x20d38f);
    r16[ax] <<= 1;
    r32[eax] &= 0x0000003f;
    r16[ax] <<= 1;
    r32[esi] = 0x00208f40;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d38b, memoryAGet16(ds, 0x20d38b) + r16[bx]);
    if (!(memoryAGet16(ds, 0x20d18f) & 0xffff))
        { pc = 0x1d85a9; break; }
    memoryASet16(ds, 0x20d18f, memoryAGet16(ds, 0x20d18f) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20cf85)) >= signed16(0x0020))
        { pc = 0x1d85a9; break; }
    memoryASet16(ds, 0x20cf73, memoryAGet16(ds, 0x20cf73) + 0x0001);
    memoryASet16(ds, 0x20cf73, memoryAGet16(ds, 0x20cf73) & 0x001f);
  case 0x1d85a9: // 0160:1d85a9
    if (!(memoryAGet16(ds, 0x20d191) & 0xffff))
        { pc = 0x1d85d6; break; }
    memoryASet16(ds, 0x20d191, memoryAGet16(ds, 0x20d191) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20cf87)) >= signed16(0x0020))
        { pc = 0x1d85d6; break; }
    memoryASet16(ds, 0x20cf75, memoryAGet16(ds, 0x20cf75) + 0x0001);
    memoryASet16(ds, 0x20cf75, memoryAGet16(ds, 0x20cf75) & 0x001f);
  case 0x1d85d6: // 0160:1d85d6
    if (!(memoryAGet16(ds, 0x20d193) & 0xffff))
        { pc = 0x1d8603; break; }
    memoryASet16(ds, 0x20d193, memoryAGet16(ds, 0x20d193) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20cf89)) >= signed16(0x0020))
        { pc = 0x1d8603; break; }
    memoryASet16(ds, 0x20cf77, memoryAGet16(ds, 0x20cf77) + 0x0001);
    memoryASet16(ds, 0x20cf77, memoryAGet16(ds, 0x20cf77) & 0x001f);
  case 0x1d8603: // 0160:1d8603
    if (!(memoryAGet16(ds, 0x20d195) & 0xffff))
        { pc = 0x1d8630; break; }
    memoryASet16(ds, 0x20d195, memoryAGet16(ds, 0x20d195) - 0x0001);
    if (signed16(memoryAGet16(ds, 0x20cf8b)) >= signed16(0x0020))
        { pc = 0x1d8630; break; }
    memoryASet16(ds, 0x20cf79, memoryAGet16(ds, 0x20cf79) + 0x0001);
    memoryASet16(ds, 0x20cf79, memoryAGet16(ds, 0x20cf79) & 0x001f);
  case 0x1d8630: // 0160:1d8630
    r32[esi] = 0x0020d06f;
    r32[eax] = 0x0020cfa9;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020d05d;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[eax] = 0x0020cf97;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[eax] = 0x0020d18f;
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d8798();
    r32[esi] = 0x0020d071;
    r32[eax] = 0x0020cfab;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020d05f;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[eax] = 0x0020cf99;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[eax] = 0x0020d191;
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1d8798();
    r32[esi] = 0x0020d073;
    r32[eax] = 0x0020cfad;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020d061;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[eax] = 0x0020cf9b;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[eax] = 0x0020d193;
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1d8798();
    r32[esi] = 0x0020d075;
    r32[eax] = 0x0020cfaf;
    memoryASet32(ds, 0x20e811, r32[eax]);
    r32[eax] = 0x0020d063;
    memoryASet32(ds, 0x20e815, r32[eax]);
    r32[eax] = 0x0020cf9d;
    memoryASet32(ds, 0x20e819, r32[eax]);
    r32[eax] = 0x0020d195;
    memoryASet32(ds, 0x20e81d, r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1d8798();
    r32[ecx] = 0x00000004;
    yield* sub_1d8275();
    r16[ax] = 0x0687;
    r16[bx] = 0x0268;
    yield* sub_1d8222();
    r16[ax] = 0x0447;
    r16[bx] = 0x05c8;
    yield* sub_1d8222();
    r16[ax] = 0x0495;
    r16[bx] = 0x0003;
    r32[esi] = 0x002090f2;
    yield* sub_1d88b9();
    r16[ax] = 0x0495;
    r16[bx] = 0x0002;
    r32[esi] = 0x00209084;
    yield* sub_1d88b9();
    r16[ax] = 0x022f;
    r16[bx] = 0x0003;
    r32[esi] = 0x0020903a;
    yield* sub_1d88b9();
    r16[ax] = 0x022f;
    r16[bx] = 0x0002;
    r32[esi] = 0x00208fc0;
    { pc = 0x1d88b9; break; }
    // gap 289 bytes // gap 289 bytes
  case 0x1d88b9: // 0160:1d88b9
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d8904; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d8904; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d051))
        { pc = 0x1d88e0; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20d087))
        { pc = 0x1d8916; break; }
  case 0x1d88e0: // 0160:1d88e0
    if (r16[ax] != memoryAGet16(ds, 0x20d04f))
        { pc = 0x1d88f2; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20d085))
        { pc = 0x1d8916; break; }
  case 0x1d88f2: // 0160:1d88f2
    if (r16[ax] != memoryAGet16(ds, 0x20d04d))
        { pc = 0x1d8904; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20d083))
        { pc = 0x1d8916; break; }
  case 0x1d8904: // 0160:1d8904
    if (r16[ax] != memoryAGet16(ds, 0x20d04b))
        { pc = 0x1d891b; break; }
    if (r16[bx] != memoryAGet16(ds, 0x20d081))
        { pc = 0x1d891b; break; }
  case 0x1d8916: // 0160:1d8916
    { pc = 0x1d24fb; break; }
  case 0x1d891b: // 0160:1d891b
    r32[esp] += 4; return;
  case 0x1d891c: // 0160:1d891c
    memoryASet16(ds, 0x20d869, 0x0001);
    memoryASet(ds, 0x1f1c44, 0x01);
    r32[ecx] = 0x00000001;
    { pc = 0x1d8275; break; }
  case 0x1d8936: // 0160:1d8936
    memoryASet16(ds, 0x20d869, 0x0001);
    memoryASet(ds, 0x1f1c44, 0x01);
    r32[esp] += 4; return;
  case 0x1d8947: // 0160:1d8947
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r32[esi] = 0x0020cf97;
    r32[edi] = 0x0020cfa9;
    yield* sub_1d8b8a();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r32[esi] = 0x0020cf99;
    r32[edi] = 0x0020cfab;
    yield* sub_1d8b8a();
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r32[esi] = 0x0020cf9b;
    r32[edi] = 0x0020cfad;
    yield* sub_1d8b8a();
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r32[esi] = 0x0020cf9d;
    r32[edi] = 0x0020cfaf;
    yield* sub_1d8b8a();
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d8a60; break; }
    r16[ax] = 0x0466;
    if (r16[ax] == memoryAGet16(ds, 0x20d04b))
        { pc = 0x1d89f8; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d8a13; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04d))
        { pc = 0x1d89f8; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04f))
        { pc = 0x1d89f8; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d051))
        { pc = 0x1d8a13; break; }
  case 0x1d89f8: // 0160:1d89f8
    if (memoryAGet16(ds, 0x20d375) & 0xffff)
        { pc = 0x1d8a13; break; }
    memoryASet16(ds, 0x20d375, 0x0001);
    r8[al] = 0x69;
    yield* sub_1b17b7();
  case 0x1d8a13: // 0160:1d8a13
    r16[ax] = 0x0478;
    if (r16[ax] == memoryAGet16(ds, 0x20d04b))
        { pc = 0x1d8a45; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d8a60; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04d))
        { pc = 0x1d8a45; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04f))
        { pc = 0x1d8a45; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d051))
        { pc = 0x1d8a60; break; }
  case 0x1d8a45: // 0160:1d8a45
    if (memoryAGet16(ds, 0x20d37f) & 0xffff)
        { pc = 0x1d8a60; break; }
    memoryASet16(ds, 0x20d37f, 0x0001);
    r8[al] = 0x69;
    yield* sub_1b17b7();
  case 0x1d8a60: // 0160:1d8a60
    memoryASet16(ds, 0x20ce9d, 0x02a8);
    r32[esi] = 0x0020d36d;
    yield* sub_1d8a81();
    memoryASet16(ds, 0x20ce9d, 0x0488);
    r32[esi] = 0x0020d377;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    if (!r16[ax])
        { pc = 0x1d8b0e; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d8b0e; break; }
    r16[ax]++;
    if (r16[ax] != 0x005f)
        { pc = 0x1d8aac; break; }
    push32(r32[esi]);
    r8[al] = 0x69;
    r32[esi] = pop32();
    r16[ax] = 0;
  case 0x1d8aac: // 0160:1d8aac
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    if (r16s[ax] <= signed16(0x002f))
        { pc = 0x1d8ae6; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x0001);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx]++;
    if (r16[cx] != 0x0003)
        { pc = 0x1d8acb; break; }
    r16[cx] = 0;
  case 0x1d8acb: // 0160:1d8acb
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[cx]++;
    if (r16[cx] != 0x0008)
        { pc = 0x1d8ae0; break; }
    r16[cx] = 0;
  case 0x1d8ae0: // 0160:1d8ae0
    memoryASet16(ds, r32[esi] + 0x6, r16[cx]);
    { pc = 0x1d8b0e; break; }
  case 0x1d8ae6: // 0160:1d8ae6
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0001);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx]--;
    if (r16s[cx] >= 0)
        { pc = 0x1d8af8; break; }
    r16[cx] = 0x0002;
  case 0x1d8af8: // 0160:1d8af8
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[cx]--;
    if (r16s[cx] >= 0)
        { pc = 0x1d8b0a; break; }
    r16[cx] = 0x0007;
  case 0x1d8b0a: // 0160:1d8b0a
    memoryASet16(ds, r32[esi] + 0x6, r16[cx]);
  case 0x1d8b0e: // 0160:1d8b0e
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = 0x0070;
    r16[dx] = 0;
    push32(r32[esi]);
    yield* sub_1d91bd();
    r32[esi] = pop32();
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx] += 0x0020;
    r16[cx] = 0x0070;
    r16[dx] = 0x0002;
    push32(r32[esi]);
    yield* sub_1d91bd();
    r32[esi] = pop32();
    r16[ax] = 0x061f;
    r16[bx] = memoryAGet16(ds, 0x20ce9d);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx] += 0x0071;
    r16[dx] = 0;
    push32(r32[esi]);
    yield* sub_1d91bd();
    r32[esi] = pop32();
    r16[ax] = 0x065c;
    r16[bx] = memoryAGet16(ds, 0x20ce9d);
    r16[bx] -= 0x0018;
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[cx] <<= 1;
    r32[edi] = 0x00209140;
    r16[bx] += memoryAGet16(ds, r32[edi] + r32[ecx]);
    r16[cx] >>>= 1;
    r16[cx] += 0x0074;
    r16[dx] = 0;
    { pc = 0x1d91bd; break; }
    // gap 189 bytes // gap 189 bytes
  case 0x1d8c47: // 0160:1d8c47
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r32[esi] = 0x0020cf97;
    r32[edi] = 0x0020d06f;
    memoryASet32(ds, 0x20e815, r32[edi]);
    r32[edi] = 0x0020cfa9;
    yield* sub_1d8ee1();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r32[esi] = 0x0020cf99;
    r32[edi] = 0x0020d071;
    memoryASet32(ds, 0x20e815, r32[edi]);
    r32[edi] = 0x0020cfab;
    yield* sub_1d8ee1();
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r32[esi] = 0x0020cf9b;
    r32[edi] = 0x0020d073;
    memoryASet32(ds, 0x20e815, r32[edi]);
    r32[edi] = 0x0020cfad;
    yield* sub_1d8ee1();
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r32[esi] = 0x0020cf9d;
    r32[edi] = 0x0020d075;
    memoryASet32(ds, 0x20e815, r32[edi]);
    r32[edi] = 0x0020cfaf;
    yield* sub_1d8ee1();
    r16[ax] = memoryAGet16(ds, 0x20d371);
    r16[ax]++;
    r32[eax] &= 0x0000003f;
    memoryASet16(ds, 0x20d371, r16[ax]);
    r32[esi] = 0x00208dd8;
    r16[ax] <<= 1;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d377, memoryAGet16(ds, 0x20d377) + r16[ax]);
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    memoryASet16(ds, 0x20cec5, r16[cx]);
    r16[ax] = memoryAGet16(ds, 0x20d897);
    push32(r32[eax]);
    r16[ax] = memoryAGet16(ds, 0x20d377);
    memoryASet16(ds, 0x20cec3, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    yield* sub_1d8d96();
    r16[ax] = memoryAGet16(ds, 0x20d373);
    r16[bx] = memoryAGet16(ds, 0x20d375);
    yield* sub_1d8d96();
    r32[eax] = pop32();
    if (!(memoryAGet16(ds, 0x20d897) & 0xffff))
        { pc = 0x1d8d95; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d897))
        { pc = 0x1d8d85; break; }
    if (signed16(memoryAGet16(ds, 0x20d897)) >= signed16(0x000a))
        { pc = 0x1d8d95; break; }
    r8[al] = 0x4c;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d897, 0x000a);
    r32[esp] += 4; return;
  case 0x1d8d85: // 0160:1d8d85
    r8[al] = 0x51;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d897, 0x0000);
  case 0x1d8d95: // 0160:1d8d95
    r32[esp] += 4; return;
    // gap 507 bytes // gap 507 bytes
  case 0x1d8f91: // 0160:1d8f91
    r16[ax] = 0x017f;
    r16[bx] = 0x0560;
    r16[dx] = 0x0001;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0078;
    yield* sub_1d91bd();
    r16[ax] = 0x01e7;
    r16[bx] = 0x0560;
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0078;
    yield* sub_1d91bd();
    r16[ax] = 0x049f;
    r16[bx] = 0x04a0;
    r16[dx] = 0x0001;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0078;
    yield* sub_1d91bd();
    r16[ax] = 0x0507;
    r16[bx] = 0x04a0;
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0078;
    yield* sub_1d91bd();
    r16[ax] = memoryAGet16(ds, 0x20d897);
    push32(r32[eax]);
    r16[ax] = 0x0197;
    r16[bx] = 0x0560;
    yield* sub_1d90ff();
    r16[ax] = 0x0197;
    r16[bx] = 0x05a0;
    yield* sub_1d90ff();
    r16[ax] = 0x0197;
    r16[bx] = 0x05e0;
    yield* sub_1d90ff();
    r16[ax] = 0x01df;
    r16[bx] = 0x0560;
    yield* sub_1d9116();
    r16[ax] = 0x01df;
    r16[bx] = 0x05a0;
    yield* sub_1d9116();
    r16[ax] = 0x01df;
    r16[bx] = 0x05e0;
    yield* sub_1d9116();
    r16[ax] = 0x04b7;
    r16[bx] = 0x04a0;
    yield* sub_1d90ff();
    r16[ax] = 0x04b7;
    r16[bx] = 0x04e0;
    yield* sub_1d90ff();
    r16[ax] = 0x04b7;
    r16[bx] = 0x0520;
    yield* sub_1d90ff();
    r16[ax] = 0x04ff;
    r16[bx] = 0x04a0;
    yield* sub_1d9116();
    r16[ax] = 0x04ff;
    r16[bx] = 0x04e0;
    yield* sub_1d9116();
    r16[ax] = 0x04ff;
    r16[bx] = 0x0520;
    yield* sub_1d9116();
    r32[eax] = pop32();
    if (!(memoryAGet16(ds, 0x20d897) & 0xffff))
        { pc = 0x1d90fe; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d897))
        { pc = 0x1d90ee; break; }
    if (signed16(memoryAGet16(ds, 0x20d897)) >= signed16(0x000a))
        { pc = 0x1d90fe; break; }
    r8[al] = 0x68;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d897, 0x000a);
    r32[esp] += 4; return;
  case 0x1d90ee: // 0160:1d90ee
    r8[al] = 0xad;
    yield* sub_1b17b7();
    memoryASet16(ds, 0x20d897, 0x0000);
  case 0x1d90fe: // 0160:1d90fe
    r32[esp] += 4; return;
    // gap 187 bytes // gap 187 bytes
  case 0x1d91ba: // 0160:1d91ba
    r16[dx] = 0;
  case 0x1d91bd: // 0160:1d91bd
    r16[dx] |= 0x0010;
  case 0x1d91c1: // 0160:1d91c1
    r16[bx]--;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d91db; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91db: // 0160:1d91db
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d91f1; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91f1: // 0160:1d91f1
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9207; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9207; break; }
    yield* sub_1b19e0();
  case 0x1d9207: // 0160:1d9207
    r32[esp] += 4; return;
  case 0x1d9208: // 0160:1d9208
    r32[esi] = 0x0020d36d;
    r32[ecx] = 0x00000008;
  case 0x1d9212: // 0160:1d9212
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[ax] = r16[cx];
    r16[ax] <<= 5;
    r16[ax] += memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20e805, r16[ax]);
    r16[ax] &= 0x0040;
    if (!r16[ax])
        { pc = 0x1d9282; break; }
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d9247; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9282; break; }
  case 0x1d9247: // 0160:1d9247
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d9259; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef5);
    if (r16s[bx] < 0)
        { pc = 0x1d9282; break; }
  case 0x1d9259: // 0160:1d9259
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9282; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9282; break; }
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20e805);
    r16[cx] >>>= 2;
    r16[cx] &= 0x0007;
    r16[cx] += 0x0070;
    yield* sub_1b19e0();
  case 0x1d9282: // 0160:1d9282
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esi] += 0x00000006;
    if (--r32[ecx])
        { pc = 0x1d9212; break; }
    r32[esp] += 4; return;
  case 0x1d928a: // 0160:1d928a
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r16[bx] = memoryAGet16(ds, 0x20d36f);
    r16[cx] = memoryAGet16(ds, 0x20d371);
    yield* sub_1d9599();
    r16[ax] = memoryAGet16(ds, 0x20d379);
    r16[bx] = memoryAGet16(ds, 0x20d37b);
    r16[cx] = memoryAGet16(ds, 0x20d37d);
    yield* sub_1d9599();
    memoryASet16(ds, 0x20cec5, 0x0000);
    r32[esi] = 0x0020d36d;
    yield* sub_1d946e();
    memoryASet16(ds, 0x20cec5, 0x0001);
    r32[esi] = 0x0020d379;
    yield* sub_1d946e();
    if (memoryAGet16(ds, 0x20d371) & 0xffff)
        { pc = 0x1d9375; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r32[esi] = 0x0020d06f;
    r32[edi] = 0x0020cf97;
    r32[ebp] = 0x0020cfa9;
    yield* sub_1d9419();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r32[esi] = 0x0020d071;
    r32[edi] = 0x0020cf99;
    r32[ebp] = 0x0020cfab;
    yield* sub_1d9419();
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r32[esi] = 0x0020d073;
    r32[edi] = 0x0020cf9b;
    r32[ebp] = 0x0020cfad;
    yield* sub_1d9419();
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r32[esi] = 0x0020d075;
    r32[edi] = 0x0020cf9d;
    r32[ebp] = 0x0020cfaf;
    yield* sub_1d9419();
  case 0x1d9375: // 0160:1d9375
    if (memoryAGet16(ds, 0x20d37d) & 0xffff)
        { pc = 0x1d9408; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r32[esi] = 0x0020d06f;
    r32[edi] = 0x0020cf97;
    r32[ebp] = 0x0020cfa9;
    yield* sub_1d9409();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r32[esi] = 0x0020d071;
    r32[edi] = 0x0020cf99;
    r32[ebp] = 0x0020cfab;
    yield* sub_1d9409();
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r32[esi] = 0x0020d073;
    r32[edi] = 0x0020cf9b;
    r32[ebp] = 0x0020cfad;
    yield* sub_1d9409();
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r32[esi] = 0x0020d075;
    r32[edi] = 0x0020cf9d;
    r32[ebp] = 0x0020cfaf;
    { pc = 0x1d9409; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d9408: // 0160:1d9408
    r32[esp] += 4; return;
  case 0x1d9409: // 0160:1d9409
    r16[cx] = memoryAGet16(ds, 0x20d379);
    r16[dx] = memoryAGet16(ds, 0x20d37b);
    { pc = 0x1d9427; break; }
    // gap 14 bytes // gap 14 bytes
  case 0x1d9427: // 0160:1d9427
    r16[ax] += 0x0080;
    r16[ax] -= r16[cx];
    if (r16[ax] < 0x0016)
        { pc = 0x1d943b; break; }
    if (r16[ax] >= 0xffea)
        { pc = 0x1d943b; break; }
    r32[esp] += 4; return;
  case 0x1d943b: // 0160:1d943b
    r16[bx] += 0x0080;
    r16[bx] -= r16[dx];
    if (r16[bx] < 0x0016)
        { pc = 0x1d9450; break; }
    if (r16[bx] >= 0xffea)
        { pc = 0x1d9450; break; }
    r32[esp] += 4; return;
  case 0x1d9450: // 0160:1d9450
    memoryASet16(ds, r32[esi], 0x0008);
    push32(r32[ebp]);
    yield* sub_1b1c5c();
    r32[ebp] = pop32();
    r16[ax] <<= 4;
    r16[ax] &= 0x03ff;
    memoryASet16(ds, r32[edi], r16[ax]);
    memoryASet16(ss, r32[ebp], 0x00c8);
    r32[esp] += 4; return;
    // gap 453 bytes // gap 453 bytes
  case 0x1d9633: // 0160:1d9633
    r16[ax] = 0x04b4;
    r16[bx] = 0x0180;
    r16[cx] = 0x0070;
    yield* sub_1d91ba();
    r16[ax] = 0x04d4;
    r16[bx] = 0x018b;
    r16[cx] = 0x0071;
    yield* sub_1d91ba();
    r16[ax] = 0x04f4;
    r16[bx] = 0x018b;
    r16[cx] = 0x0071;
    yield* sub_1d91ba();
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] >>>= 3;
    r16[ax] &= 0x0001;
    r16[ax] += 0x0513;
    r16[bx] = 0x0188;
    r16[cx] = 0x0072;
    { pc = 0x1d91ba; break; }
  case 0x1d9685: // 0160:1d9685
    r16[ax] = 0x0220;
    if (r16[ax] == memoryAGet16(ds, 0x20d04b))
        { pc = 0x1d96b7; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d96cb; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04d))
        { pc = 0x1d96b7; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04f))
        { pc = 0x1d96b7; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d051))
        { pc = 0x1d96cb; break; }
  case 0x1d96b7: // 0160:1d96b7
    if (memoryAGet16(ds, 0x20d36d) & 0xffff)
        { pc = 0x1d96cb; break; }
    memoryASet16(ds, 0x20d36d, 0x0001);
  case 0x1d96cb: // 0160:1d96cb
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    if (!r16[ax])
        { pc = 0x1d96f6; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x000f;
    if (r16[bx])
        { pc = 0x1d96f6; break; }
    r16[ax]++;
    if (r16[ax] != 0x0017)
        { pc = 0x1d96f0; break; }
    r16[ax] = 0;
  case 0x1d96f0: // 0160:1d96f0
    memoryASet16(ds, 0x20d36d, r16[ax]);
  case 0x1d96f6: // 0160:1d96f6
    r16[ax] = 0x0586;
    if (r16[ax] == memoryAGet16(ds, 0x20d04b))
        { pc = 0x1d9728; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d973c; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04d))
        { pc = 0x1d9728; break; }
    if (r16[ax] == memoryAGet16(ds, 0x20d04f))
        { pc = 0x1d9728; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d051))
        { pc = 0x1d973c; break; }
  case 0x1d9728: // 0160:1d9728
    if (memoryAGet16(ds, 0x20d371) & 0xffff)
        { pc = 0x1d973c; break; }
    memoryASet16(ds, 0x20d371, 0x0001);
  case 0x1d973c: // 0160:1d973c
    r16[ax] = memoryAGet16(ds, 0x20d371);
    if (!r16[ax])
        { pc = 0x1d9767; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x000f;
    if (r16[bx])
        { pc = 0x1d9767; break; }
    r16[ax]++;
    if (r16[ax] != 0x0017)
        { pc = 0x1d9761; break; }
    r16[ax] = 0;
  case 0x1d9761: // 0160:1d9761
    memoryASet16(ds, 0x20d371, r16[ax]);
  case 0x1d9767: // 0160:1d9767
    yield* sub_1d9f0e();
    yield* sub_1d9e4f();
    r32[esi] = 0x0020d375;
    r32[ecx] = 0x00000008;
  case 0x1d977b: // 0160:1d977b
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[dx] = memoryAGet16(ds, r32[esi] + 0x6);
    r32[esi] += 0x0000000a;
    if (!(memoryAGet16(ds, 0x20d89b) & 0xffff))
        { pc = 0x1d979a; break; }
  case 0x1d979a: // 0160:1d979a
    yield* sub_1d9d6c();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esi] += 0x0000000c;
    if (--r32[ecx])
        { pc = 0x1d977b; break; }
    yield* sub_1d9b94();
    yield* sub_1d99bc();
    r32[edi] = 0x0020cfa9;
    r32[ebp] = 0x0020cf97;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    yield* sub_1d982d();
    r32[edi] = 0x0020cfab;
    r32[ebp] = 0x0020cf99;
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    yield* sub_1d982d();
    r32[edi] = 0x0020cfad;
    r32[ebp] = 0x0020cf9b;
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    yield* sub_1d982d();
    r32[edi] = 0x0020cfaf;
    r32[ebp] = 0x0020cf9d;
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    yield* sub_1d982d();
    r16[ax] = 0x01c9;
    r16[bx] = 0x064c;
    { pc = 0x1d9df5; break; }
    // gap 1480 bytes // gap 1480 bytes
  case 0x1d9df5: // 0160:1d9df5
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d9e0b; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9e4e; break; }
  case 0x1d9e0b: // 0160:1d9e0b
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d9e21; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9e4e; break; }
  case 0x1d9e21: // 0160:1d9e21
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9e4e; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9e4e; break; }
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 2;
    r16[cx] &= 0x0001;
    r16[cx] += 0x0070;
    yield* sub_1b19e0();
  case 0x1d9e4e: // 0160:1d9e4e
    r32[esp] += 4; return;
    // gap 481 bytes // gap 481 bytes
  case 0x1da030: // 0160:1da030
    yield* sub_1d81e0();
    if (memoryAGet16(ds, 0x20d7a5) & 0xffff)
        { pc = 0x1da08c; break; }
    memoryASet16(ds, 0x20d06f, 0x0000);
    memoryASet16(ds, 0x20d071, 0x0000);
    memoryASet16(ds, 0x20d073, 0x0000);
    memoryASet16(ds, 0x20d075, 0x0000);
    memoryASet16(ds, 0x20d05d, 0x0006);
    memoryASet16(ds, 0x20d05f, 0x0006);
    memoryASet16(ds, 0x20d061, 0x0006);
    memoryASet16(ds, 0x20d063, 0x0006);
  case 0x1da08c: // 0160:1da08c
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[cx] = memoryAGet16(ds, 0x20cf85);
    r16[dx] = memoryAGet16(ds, 0x20d05d);
    yield* sub_1da112();
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[cx] = memoryAGet16(ds, 0x20cf87);
    r16[dx] = memoryAGet16(ds, 0x20d05f);
    yield* sub_1da112();
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1da0f7; break; }
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[cx] = memoryAGet16(ds, 0x20cf89);
    r16[dx] = memoryAGet16(ds, 0x20d061);
    yield* sub_1da112();
  case 0x1da0f7: // 0160:1da0f7
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[cx] = memoryAGet16(ds, 0x20cf8b);
    r16[dx] = memoryAGet16(ds, 0x20d063);
    r32[esi] = 0x0020602c;
    if (r16s[cx] >= signed16(0x0020))
        { pc = 0x1da150; break; }
    r16[cx] <<= 2;
    r32[ecx] &= 0x0000ffff;
    r16[ax] += memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    r16[dx] >>>= 1;
    r16[ax] -= r16[dx];
    r16[bx] -= r16[dx];
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    r16[cx] += 0x0070;
    { pc = 0x1d91c1; break; }
  case 0x1da150: // 0160:1da150
    r32[esp] += 4; return;
  case 0x1da151: // 0160:1da151
    r16[ax] = 0x0168;
    r16[bx] = 0x03cc;
    r16[cx] = 0x0070;
    r16[dx] = 0x0010;
    yield* sub_1d91bd();
    r16[ax] = 0x01b8;
    r16[bx] = 0x041a;
    r16[cx] = 0x0070;
    r16[dx] = 0x0012;
    yield* sub_1d91bd();
    r16[ax] = 0x017c;
    r16[bx] = 0x0bac;
    r16[cx] = 0x0070;
    r16[dx] = 0x0010;
    yield* sub_1d91bd();
    r16[ax] = 0x01b8;
    r16[bx] = 0x0bfa;
    r16[cx] = 0x0070;
    r16[dx] = 0x0012;
    yield* sub_1d91bd();
    r16[ax] = 0x0190;
    r16[bx] = 0x160c;
    r16[cx] = 0x0070;
    r16[dx] = 0x0010;
    { pc = 0x1d91bd; break; }
  case 0x1da1ba: // 0160:1da1ba
    r8[al] = memoryAGet(ds, 0x23c4f0);
    if (r8[al] == 0x02)
        { pc = 0x1d725b; break; }
    if (r8[al] == 0x03)
        { pc = 0x1d71eb; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1d7823() // 0160:1d7823 +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bp] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d794c();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf97, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfa9, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bp] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d794c();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf99, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfab, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bp] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d794c();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9b, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfad, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[bp] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d794c();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9d, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfaf, r16[bp]);
    r32[esp] += 4;
}
function* sub_1d794c() // 0160:1d794c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x0080;
    r16[cx] = memoryAGet16(ds, 0x20d37f);
    r16[cx] -= r16[ax];
    if (r16[cx] >= 0xfffc)
        { pc = 0x1d7967; break; }
    if (r16[cx] < 0x0010)
        { pc = 0x1d7967; break; }
    r32[esp] += 4; return;
  case 0x1d7967: // 0160:1d7967
    r16[bx] += 0x0080;
    r16[dx] = memoryAGet16(ds, 0x20d381);
    r16[dx] -= r16[bx];
    if (r16[dx] >= 0xff48)
        { pc = 0x1d7984; break; }
    if (r16[dx] < 0x0018)
        { pc = 0x1d7984; break; }
    r32[esp] += 4; return;
  case 0x1d7984: // 0160:1d7984
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) + 0x0200);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0x03ff);
    if (signed16(memoryAGet16(ds, 0x20e7fd)) >= signed16(0x00c8))
        { pc = 0x1d79aa; break; }
    memoryASet16(ds, 0x20e7fd, 0x00c8);
  case 0x1d79aa: // 0160:1d79aa
    if (r16[dx] < 0x0018)
        { pc = 0x1d79c6; break; }
    if (r16[dx] >= 0xff58)
        { pc = 0x1d79c5; break; }
    memoryASet16(ds, 0x20e801, 0x0200);
    yield* sub_1d79cf();
  case 0x1d79c5: // 0160:1d79c5
    r32[esp] += 4; return;
  case 0x1d79c6: // 0160:1d79c6
    memoryASet16(ds, 0x20e801, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] -= memoryAGet16(ds, 0x20d897);
    if (r16s[ax] <= signed16(0x000a))
        { pc = 0x1d7a17; break; }
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    push32(r32[ebp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    push32(r32[ebp]);
    r8[al] = 0x60;
    yield* sub_1b17b7();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20d897, r16[bp]);
  case 0x1d7a17: // 0160:1d7a17
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d79cf() // 0160:1d79cf +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] -= memoryAGet16(ds, 0x20d897);
    if (r16s[ax] <= signed16(0x000a))
        { pc = 0x1d7a17; break; }
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    push32(r32[ebp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    push32(r32[ebp]);
    r8[al] = 0x60;
    yield* sub_1b17b7();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20d897, r16[bp]);
  case 0x1d7a17: // 0160:1d7a17
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d7a6a() // 0160:1d7a6a +long
{
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20cf4f);
    r16[bx] = memoryAGet16(ds, 0x20cf61);
    r16[bp] = memoryAGet16(ds, 0x20cfa9);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf97);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7b93();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf97, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfa9, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf51);
    r16[bx] = memoryAGet16(ds, 0x20cf63);
    r16[bp] = memoryAGet16(ds, 0x20cfab);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf99);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7b93();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf99, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfab, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf53);
    r16[bx] = memoryAGet16(ds, 0x20cf65);
    r16[bp] = memoryAGet16(ds, 0x20cfad);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9b);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7b93();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9b, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfad, r16[bp]);
    r16[ax] = memoryAGet16(ds, 0x20cf55);
    r16[bx] = memoryAGet16(ds, 0x20cf67);
    r16[bp] = memoryAGet16(ds, 0x20cfaf);
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20cf9d);
    memoryASet16(ds, 0x20e801, r16[bp]);
    yield* sub_1d7b93();
    r16[bp] = memoryAGet16(ds, 0x20e801);
    memoryASet16(ds, 0x20cf9d, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    memoryASet16(ds, 0x20cfaf, r16[bp]);
    r32[esp] += 4;
}
function* sub_1d7b93() // 0160:1d7b93 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d7b93; break; }
  case 0x1d79cf: // 0160:1d79cf
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] -= memoryAGet16(ds, 0x20d897);
    if (r16s[ax] <= signed16(0x000a))
        { pc = 0x1d7a17; break; }
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    push32(r32[ebp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    push32(r32[ebp]);
    r8[al] = 0x60;
    yield* sub_1b17b7();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20d897, r16[bp]);
  case 0x1d7a17: // 0160:1d7a17
    r32[esp] += 4; return;
    // gap 379 bytes // gap 379 bytes
  case 0x1d7b93: // 0160:1d7b93
    r16[ax] += 0x0080;
    r16[cx] = memoryAGet16(ds, 0x20d389);
    r16[cx] -= r16[ax];
    if (r16[cx] >= 0xfffc)
        { pc = 0x1d7bae; break; }
    if (r16[cx] < 0x0010)
        { pc = 0x1d7bae; break; }
    r32[esp] += 4; return;
  case 0x1d7bae: // 0160:1d7bae
    r16[bx] += 0x0080;
    r16[dx] = memoryAGet16(ds, 0x20d38b);
    r16[dx] -= r16[bx];
    if (r16[dx] >= 0xff48)
        { pc = 0x1d7bcb; break; }
    if (r16[dx] < 0x0018)
        { pc = 0x1d7bcb; break; }
    r32[esp] += 4; return;
  case 0x1d7bcb: // 0160:1d7bcb
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) + 0x0200);
    memoryASet16(ds, 0x20e801, memoryAGet16(ds, 0x20e801) & 0x03ff);
    if (signed16(memoryAGet16(ds, 0x20e7fd)) >= signed16(0x00c8))
        { pc = 0x1d7bf1; break; }
    memoryASet16(ds, 0x20e7fd, 0x00c8);
  case 0x1d7bf1: // 0160:1d7bf1
    if (r16[dx] < 0x0018)
        { pc = 0x1d7c0d; break; }
    if (r16[dx] >= 0xff58)
        { pc = 0x1d7c0c; break; }
    memoryASet16(ds, 0x20e801, 0x0200);
    { pc = 0x1d79cf; break; }
  case 0x1d7c0c: // 0160:1d7c0c
    r32[esp] += 4; return;
  case 0x1d7c0d: // 0160:1d7c0d
    memoryASet16(ds, 0x20e801, 0x0000);
    { pc = 0x1d79cf; break; }
    return;
  }
}
function* sub_1d7c1b() // 0160:1d7c1b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d7c1b; break; }
  case 0x1d7a18: // 0160:1d7a18
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] -= memoryAGet16(ds, 0x20d897);
    if (r16s[ax] <= signed16(0x000a))
        { pc = 0x1d7a69; break; }
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    push32(r32[ebp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    push32(r32[ebp]);
    r8[al] = 0xac;
    yield* sub_1b17b7();
    r16[ax] = 0x011b;
    yield* sub_1b1715();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20d897, r16[bp]);
  case 0x1d7a69: // 0160:1d7a69
    r32[esp] += 4; return;
    // gap 433 bytes // gap 433 bytes
  case 0x1d7c1b: // 0160:1d7c1b
    r16[ax] += 0x0080;
    r16[cx] = memoryAGet16(ds, 0x20d375);
    r16[cx] -= r16[ax];
    if (r16[cx] >= 0xffe0)
        { pc = 0x1d7c36; break; }
    if (r16[cx] < 0x0018)
        { pc = 0x1d7c36; break; }
    r32[esp] += 4; return;
  case 0x1d7c36: // 0160:1d7c36
    r16[bx] += 0x0080;
    r16[dx] = memoryAGet16(ds, 0x20d377);
    r16[dx] -= r16[bx];
    if (r16[dx] < 0xffe0)
        { pc = 0x1d7c6d; break; }
    yield* sub_1b1c5c();
    r16[ax] &= 0x00ff;
    r16[ax] += 0x0180;
    memoryASet16(ds, 0x20e801, r16[ax]);
    memoryASet16(ds, 0x20e7fd, 0x01c0);
    { pc = 0x1d7a18; break; }
  case 0x1d7c6c: // 0160:1d7c6c
    r32[esp] += 4; return;
  case 0x1d7c6d: // 0160:1d7c6d
    if (r16[dx] >= 0x0018)
        { pc = 0x1d7c6c; break; }
    yield* sub_1b1c5c();
    r16[ax] &= 0x00ff;
    r16[ax] -= 0x0080;
    r16[ax] &= 0x03ff;
    memoryASet16(ds, 0x20e801, r16[ax]);
    memoryASet16(ds, 0x20e7fd, 0x01c0);
    { pc = 0x1d7a18; break; }
    return;
  }
}
function* sub_1d7c99() // 0160:1d7c99 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d7c99; break; }
  case 0x1d7a18: // 0160:1d7a18
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] -= memoryAGet16(ds, 0x20d897);
    if (r16s[ax] <= signed16(0x000a))
        { pc = 0x1d7a69; break; }
    r16[bp] = memoryAGet16(ds, 0x20e7fd);
    push32(r32[ebp]);
    r16[bp] = memoryAGet16(ds, 0x20e801);
    push32(r32[ebp]);
    r8[al] = 0xac;
    yield* sub_1b17b7();
    r16[ax] = 0x011b;
    yield* sub_1b1715();
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e801, r16[bp]);
    r32[ebp] = pop32();
    memoryASet16(ds, 0x20e7fd, r16[bp]);
    r16[bp] = memoryAGet16(ds, 0x20c830);
    memoryASet16(ds, 0x20d897, r16[bp]);
  case 0x1d7a69: // 0160:1d7a69
    r32[esp] += 4; return;
    // gap 559 bytes // gap 559 bytes
  case 0x1d7c99: // 0160:1d7c99
    r16[ax] += 0x0080;
    r16[cx] = memoryAGet16(ds, 0x20d37f);
    r16[cx] -= r16[ax];
    if (r16[cx] >= 0xffe0)
        { pc = 0x1d7cb4; break; }
    if (r16[cx] < 0x0018)
        { pc = 0x1d7cb4; break; }
    r32[esp] += 4; return;
  case 0x1d7cb4: // 0160:1d7cb4
    r16[bx] += 0x0080;
    r16[dx] = memoryAGet16(ds, 0x20d381);
    r16[dx] -= r16[bx];
    if (r16[dx] < 0xffe0)
        { pc = 0x1d7ceb; break; }
    yield* sub_1b1c5c();
    r16[ax] &= 0x00ff;
    r16[ax] += 0x0180;
    memoryASet16(ds, 0x20e801, r16[ax]);
    memoryASet16(ds, 0x20e7fd, 0x01c0);
    { pc = 0x1d7a18; break; }
  case 0x1d7cea: // 0160:1d7cea
    r32[esp] += 4; return;
  case 0x1d7ceb: // 0160:1d7ceb
    if (r16[dx] >= 0x0018)
        { pc = 0x1d7cea; break; }
    yield* sub_1b1c5c();
    r16[ax] &= 0x00ff;
    r16[ax] -= 0x0080;
    r16[ax] &= 0x03ff;
    memoryASet16(ds, 0x20e801, r16[ax]);
    memoryASet16(ds, 0x20e7fd, 0x01c0);
    { pc = 0x1d7a18; break; }
    return;
  }
}
function* sub_1d7d99() // 0160:1d7d99 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, 0x20d37f);
    r16[bx] = memoryAGet16(ds, 0x20d381);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d7dbc; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d7dec; break; }
  case 0x1d7dbc: // 0160:1d7dbc
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d7dc5; break; }
  case 0x1d7dc5: // 0160:1d7dc5
    if (r16[bx] < 0x0178)
        { pc = 0x1d7dd2; break; }
    if (r16[bx] < 0xff9c)
        { pc = 0x1d7dec; break; }
  case 0x1d7dd2: // 0160:1d7dd2
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d7dec; break; }
    r16[dx] = memoryAGet16(ds, 0x20d385);
    r16[dx] |= 0x0010;
    r16[cx] = 0x0074;
    yield* sub_1b19e0();
  case 0x1d7dec: // 0160:1d7dec
    r16[ax] = memoryAGet16(ds, 0x20d383);
    r16[ax]++;
    r32[eax] &= 0x0000003f;
    memoryASet16(ds, 0x20d383, r16[ax]);
    r32[esi] = 0x00208dd8;
    r16[ax] <<= 1;
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20d381, memoryAGet16(ds, 0x20d381) + r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d81e0() // 0160:1d81e0 +long
{
    r32[esp] -= 4;
    memoryASet16(ds, 0x20d7f7, 0xff00);
    memoryASet16(ds, 0x20d7f9, 0x0100);
    r32[esp] += 4;
}
function* sub_1d8222() // 0160:1d8222 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d8222; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 157710 bytes // gap 157710 bytes
  case 0x1d8222: // 0160:1d8222
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d8238; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d8274; break; }
  case 0x1d8238: // 0160:1d8238
    r16[bx]--;
    r16[ax]++;
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d8256; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d8274; break; }
  case 0x1d8256: // 0160:1d8256
    if (r16[bx] >= 0x0178)
        { pc = 0x1d8274; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d8274; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0074;
    { pc = 0x1b19e0; break; }
  case 0x1d8274: // 0160:1d8274
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8275() // 0160:1d8275 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[esi] = 0x0020d36d;
  case 0x1d827a: // 0160:1d827a
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r32[esi] += 0x00000004;
    push32(r32[ecx]);
    push32(r32[esi]);
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d829c; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d82df; break; }
  case 0x1d829c: // 0160:1d829c
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d82b2; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d82df; break; }
  case 0x1d82b2: // 0160:1d82b2
    if (r16[bx] >= 0x0178)
        { pc = 0x1d82df; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d82df; break; }
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 2;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0070;
    yield* sub_1b19e0();
  case 0x1d82df: // 0160:1d82df
    r32[esi] = pop32();
    r32[ecx] = pop32();
    if (--r32[ecx])
        { pc = 0x1d827a; break; }
    r32[esp] += 4;
    return;
  }
}
function* sub_1d83da() // 0160:1d83da +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d83da; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 158150 bytes // gap 158150 bytes
  case 0x1d83da: // 0160:1d83da
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d83f0; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d843d; break; }
  case 0x1d83f0: // 0160:1d83f0
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d8406; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d843d; break; }
  case 0x1d8406: // 0160:1d8406
    if (r16[bx] >= 0x0160)
        { pc = 0x1d843d; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d843d; break; }
    r16[cx] += memoryAGet16(ds, 0x20d379);
    r32[ecx] &= 0x00000007;
    r32[esi] = 0x00209130;
    r16[cx] <<= 1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] += r16[cx];
    r16[dx] = 0x0010;
    r16[cx] = 0x0077;
    { pc = 0x1b19e0; break; }
  case 0x1d843d: // 0160:1d843d
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d843e() // 0160:1d843e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d843e; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 158250 bytes // gap 158250 bytes
  case 0x1d843e: // 0160:1d843e
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d8454; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d84a1; break; }
  case 0x1d8454: // 0160:1d8454
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d846a; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d84a1; break; }
  case 0x1d846a: // 0160:1d846a
    if (r16[bx] >= 0x0160)
        { pc = 0x1d84a1; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d84a1; break; }
    r16[cx] += memoryAGet16(ds, 0x20d379);
    r32[ecx] &= 0x00000007;
    r32[esi] = 0x00209130;
    r16[cx] <<= 1;
    r16[cx] = memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] += r16[cx];
    r16[dx] = 0x0010;
    r16[cx] = 0x0078;
    { pc = 0x1b19e0; break; }
  case 0x1d84a1: // 0160:1d84a1
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8798() // 0160:1d8798 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] += 0x008b;
    r16[bx] += 0x0095;
    r16[cx] = r16[ax];
    r16[dx] = r16[bx];
    r16[ax] -= memoryAGet16(ds, 0x20d381);
    if (r16s[ax] < 0)
        { pc = 0x1d8809; break; }
    if (r16s[ax] >= signed16(0x0029))
        { pc = 0x1d8809; break; }
    r16[bx] -= memoryAGet16(ds, 0x20d383);
    if (r16s[bx] < 0)
        { pc = 0x1d8809; break; }
    if (r16s[bx] >= signed16(0x0029))
        { pc = 0x1d8809; break; }
  case 0x1d87c5: // 0160:1d87c5
    if (signed16(memoryAGet16(ds, r32[esi])) >= signed16(0x0019))
        { pc = 0x1d8808; break; }
    r32[edi] = memoryAGet32(ds, 0x20e815);
    if (memoryAGet16(ds, r32[edi]) & 0xffff)
        { pc = 0x1d8808; break; }
    memoryASet16(ds, r32[esi], 0x0019);
    r32[edi] = memoryAGet32(ds, 0x20e811);
    memoryASet16(ds, r32[edi], 0x0040);
    r16[ax] = 0x0020;
    r16[ax] += 0x02ea;
    r32[edi] = memoryAGet32(ds, 0x20e819);
    memoryASet16(ds, r32[edi], r16[ax]);
    r32[edi] = memoryAGet32(ds, 0x20e81d);
    memoryASet16(ds, r32[edi], 0x0032);
  case 0x1d8808: // 0160:1d8808
    r32[esp] += 4; return;
  case 0x1d8809: // 0160:1d8809
    r16[cx] -= memoryAGet16(ds, 0x20d389);
    if (r16s[cx] < 0)
        { pc = 0x1d8827; break; }
    if (r16s[cx] >= signed16(0x0029))
        { pc = 0x1d8827; break; }
    r16[dx] -= memoryAGet16(ds, 0x20d38b);
    if (r16s[dx] < 0)
        { pc = 0x1d8827; break; }
    if (r16s[dx] <= signed16(0x0029))
        { pc = 0x1d87c5; break; }
  case 0x1d8827: // 0160:1d8827
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8828() // 0160:1d8828 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d883e; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d88b8; break; }
  case 0x1d883e: // 0160:1d883e
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d8854; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d88b8; break; }
  case 0x1d8854: // 0160:1d8854
    if (r16[bx] >= 0x0180)
        { pc = 0x1d88b8; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d88b8; break; }
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20d385);
    if (!r16[dx])
        { pc = 0x1d88ab; break; }
    if (r16[cx] == 0x0001)
        { pc = 0x1d889d; break; }
    if (r16[cx] == 0x0002)
        { pc = 0x1d888f; break; }
    r16[cx] = 0x007a;
    r16[dx] = 0x0003;
    r16[bx] -= 0x0003;
    r16[ax] += 0x0003;
    { pc = 0x1d88af; break; }
  case 0x1d888f: // 0160:1d888f
    r16[cx] = 0x0079;
    r16[dx] = 0x0003;
    r16[bx] -= 0x0006;
    { pc = 0x1d88af; break; }
  case 0x1d889d: // 0160:1d889d
    r16[cx] = 0x007a;
    r16[ax] -= 0x0003;
    r16[bx] -= 0x0003;
    { pc = 0x1d88af; break; }
  case 0x1d88ab: // 0160:1d88ab
    r16[cx] = 0x0079;
  case 0x1d88af: // 0160:1d88af
    r16[dx] |= 0x0010;
    yield* sub_1b19e0();
  case 0x1d88b8: // 0160:1d88b8
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d88b9() // 0160:1d88b9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d88b9; break; }
  case 0x1d24fb: // 0160:1d24fb
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r32[esi] += 0x00000002;
    if (r16s[ax] < 0)
        { pc = 0x1d251c; break; }
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    r32[ebx] += r32[ebx];
    r32[edi] = memoryAGet32(ds, 0x2eeb94);
    r32[edi] += r32[ebx];
    r32[edi] -= 0x00000004;
    memoryASet(ds, r32[edi], r8[al]);
    { pc = 0x1d24fb; break; }
  case 0x1d251c: // 0160:1d251c
    r32[esp] += 4; return;
    // gap 25500 bytes // gap 25500 bytes
  case 0x1d88b9: // 0160:1d88b9
    if (memoryAGet16(ds, 0x20d89b) & 0xffff)
        { pc = 0x1d8904; break; }
    if (memoryAGet16(ds, 0x20d7f5) == 0x0001)
        { pc = 0x1d8904; break; }
    if (r16[ax] != memoryAGet16(ds, 0x20d051))
        { pc = 0x1d88e0; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20d087))
        { pc = 0x1d8916; break; }
  case 0x1d88e0: // 0160:1d88e0
    if (r16[ax] != memoryAGet16(ds, 0x20d04f))
        { pc = 0x1d88f2; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20d085))
        { pc = 0x1d8916; break; }
  case 0x1d88f2: // 0160:1d88f2
    if (r16[ax] != memoryAGet16(ds, 0x20d04d))
        { pc = 0x1d8904; break; }
    if (r16[bx] == memoryAGet16(ds, 0x20d083))
        { pc = 0x1d8916; break; }
  case 0x1d8904: // 0160:1d8904
    if (r16[ax] != memoryAGet16(ds, 0x20d04b))
        { pc = 0x1d891b; break; }
    if (r16[bx] != memoryAGet16(ds, 0x20d081))
        { pc = 0x1d891b; break; }
  case 0x1d8916: // 0160:1d8916
    { pc = 0x1d24fb; break; }
  case 0x1d891b: // 0160:1d891b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8a81() // 0160:1d8a81 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    if (!r16[ax])
        { pc = 0x1d8b0e; break; }
    r16[bx] = memoryAGet16(ds, 0x20c830);
    r16[bx] &= 0x0003;
    if (r16[bx])
        { pc = 0x1d8b0e; break; }
    r16[ax]++;
    if (r16[ax] != 0x005f)
        { pc = 0x1d8aac; break; }
    push32(r32[esi]);
    r8[al] = 0x69;
    r32[esi] = pop32();
    r16[ax] = 0;
  case 0x1d8aac: // 0160:1d8aac
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    if (r16s[ax] <= signed16(0x002f))
        { pc = 0x1d8ae6; break; }
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x0001);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx]++;
    if (r16[cx] != 0x0003)
        { pc = 0x1d8acb; break; }
    r16[cx] = 0;
  case 0x1d8acb: // 0160:1d8acb
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[cx]++;
    if (r16[cx] != 0x0008)
        { pc = 0x1d8ae0; break; }
    r16[cx] = 0;
  case 0x1d8ae0: // 0160:1d8ae0
    memoryASet16(ds, r32[esi] + 0x6, r16[cx]);
    { pc = 0x1d8b0e; break; }
  case 0x1d8ae6: // 0160:1d8ae6
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0001);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx]--;
    if (r16s[cx] >= 0)
        { pc = 0x1d8af8; break; }
    r16[cx] = 0x0002;
  case 0x1d8af8: // 0160:1d8af8
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[cx]--;
    if (r16s[cx] >= 0)
        { pc = 0x1d8b0a; break; }
    r16[cx] = 0x0007;
  case 0x1d8b0a: // 0160:1d8b0a
    memoryASet16(ds, r32[esi] + 0x6, r16[cx]);
  case 0x1d8b0e: // 0160:1d8b0e
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[cx] = 0x0070;
    r16[dx] = 0;
    push32(r32[esi]);
    yield* sub_1d91bd();
    r32[esi] = pop32();
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[bx] = memoryAGet16(ds, r32[esi] + 0x2);
    r16[bx] += 0x0020;
    r16[cx] = 0x0070;
    r16[dx] = 0x0002;
    push32(r32[esi]);
    yield* sub_1d91bd();
    r32[esi] = pop32();
    r16[ax] = 0x061f;
    r16[bx] = memoryAGet16(ds, 0x20ce9d);
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x4);
    r16[cx] += 0x0071;
    r16[dx] = 0;
    push32(r32[esi]);
    yield* sub_1d91bd();
    r32[esi] = pop32();
    r16[ax] = 0x065c;
    r16[bx] = memoryAGet16(ds, 0x20ce9d);
    r16[bx] -= 0x0018;
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[cx] <<= 1;
    r32[edi] = 0x00209140;
    r16[bx] += memoryAGet16(ds, r32[edi] + r32[ecx]);
    r16[cx] >>>= 1;
    r16[cx] += 0x0074;
    r16[dx] = 0;
    { pc = 0x1d91bd; break; }
    // gap 1587 bytes // gap 1587 bytes
  case 0x1d91bd: // 0160:1d91bd
    r16[dx] |= 0x0010;
    r16[bx]--;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d91db; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91db: // 0160:1d91db
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d91f1; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91f1: // 0160:1d91f1
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9207; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9207; break; }
    yield* sub_1b19e0();
  case 0x1d9207: // 0160:1d9207
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8b8a() // 0160:1d8b8a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!(memoryAGet16(ds, 0x20d375) & 0xffff))
        { pc = 0x1d8c0f; break; }
    r16[cx] = memoryAGet16(ds, 0x20d36d);
    r16[dx] = memoryAGet16(ds, 0x20d36f);
    r16[cx] -= r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[cx] >= signed16(0x0096))
        { pc = 0x1d8c0f; break; }
    if (r16s[dx] >= signed16(0x0096))
        { pc = 0x1d8c0f; break; }
    if (r16s[dx] <= signed16(0x004c))
        { pc = 0x1d8c0f; break; }
  case 0x1d8bbd: // 0160:1d8bbd
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] += 0x0200;
    r16[ax] &= 0x03ff;
    if (r16s[ax] <= signed16(0x0100))
        { pc = 0x1d8be0; break; }
    if (r16s[ax] >= signed16(0x0200))
        { pc = 0x1d8be7; break; }
    r16[cx] = 0x0200;
    r16[cx] -= r16[ax];
    r16[ax] = r16[cx];
    { pc = 0x1d8be7; break; }
  case 0x1d8be0: // 0160:1d8be0
    r16[ax] = -r16[ax];
    r16[ax] &= 0x03ff;
  case 0x1d8be7: // 0160:1d8be7
    if (r16s[ax] <= signed16(0x0380))
        { pc = 0x1d8bf3; break; }
    r16[ax] = 0x0380;
    { pc = 0x1d8bfd; break; }
  case 0x1d8bf3: // 0160:1d8bf3
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x1d8bfd; break; }
    r16[ax] = 0x0080;
  case 0x1d8bfd: // 0160:1d8bfd
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[edi], 0x0100);
    r16[ax] = 0x0107;
    yield* sub_1b1715();
    r32[esp] += 4; return;
  case 0x1d8c0f: // 0160:1d8c0f
    if (!(memoryAGet16(ds, 0x20d37f) & 0xffff))
        { pc = 0x1d8c46; break; }
    r16[cx] = memoryAGet16(ds, 0x20d377);
    r16[dx] = memoryAGet16(ds, 0x20d379);
    r16[cx] -= r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[cx] >= signed16(0x0096))
        { pc = 0x1d8c46; break; }
    if (r16s[dx] >= signed16(0x0096))
        { pc = 0x1d8c46; break; }
    if (r16s[dx] > signed16(0x004c))
        { pc = 0x1d8bbd; break; }
  case 0x1d8c46: // 0160:1d8c46
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8d96() // 0160:1d8d96 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[cx] += 0x0070;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d8dba; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d8ee0; break; }
  case 0x1d8dba: // 0160:1d8dba
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d8dd0; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d8ee0; break; }
  case 0x1d8dd0: // 0160:1d8dd0
    if (r16[bx] >= 0x0178)
        { pc = 0x1d8ee0; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d8ee0; break; }
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r16[ax] += memoryAGet16(ds, 0x20cec3);
    r16[bx]--;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0038;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] -= 0x0009;
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[cx] += 0x0078;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0050;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] -= 0x0011;
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[cx] += 0x007c;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0068;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[bx] -= 0x0015;
    r16[dx] = 0x0010;
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[cx] += 0x0080;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0008;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += memoryAGet16(ds, 0x20cec3);
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[cx] += 0x0074;
    r16[bx]--;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[ax] += 0x0028;
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[ax] += memoryAGet16(ds, 0x20cec3);
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20cec5);
    r16[cx] += 0x0074;
    r16[bx]--;
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20d897, memoryAGet16(ds, 0x20d897) + 0x0001);
  case 0x1d8ee0: // 0160:1d8ee0
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d8ee1() // 0160:1d8ee1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20d36d);
    r16[cx] += memoryAGet16(ds, 0x20d377);
    r16[dx] = memoryAGet16(ds, 0x20d36f);
    r16[cx] -= r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[cx] >= signed16(0x0096))
        { pc = 0x1d8f5b; break; }
    if (r16s[cx] <= signed16(0x0050))
        { pc = 0x1d8f5b; break; }
    if (r16s[dx] >= signed16(0x0096))
        { pc = 0x1d8f5b; break; }
    if (r16s[dx] <= signed16(0x0078))
        { pc = 0x1d8f5b; break; }
  case 0x1d8f16: // 0160:1d8f16
    if (r16s[cx] <= signed16(0x008c))
        { pc = 0x1d8f22; break; }
    memoryASet16(ds, r32[esi], 0x0100);
  case 0x1d8f22: // 0160:1d8f22
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] += 0x0200;
    r16[ax] &= 0x03ff;
    memoryASet16(ds, r32[esi], r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[edi]);
    r16[ax] += 0x0020;
    memoryASet16(ds, r32[edi], r16[ax]);
    push32(r32[edi]);
    r32[edi] = memoryAGet32(ds, 0x20e815);
    memoryASet16(ds, r32[edi], 0x0004);
    if (memoryAGet16(ds, 0x20d7a5))
        { pc = 0x1d8f59; break; }
    r16[ax] = 0x0109;
    yield* sub_1b1715();
  case 0x1d8f59: // 0160:1d8f59
    r32[edi] = pop32();
    r32[esp] += 4; return;
  case 0x1d8f5b: // 0160:1d8f5b
    r16[cx] = memoryAGet16(ds, 0x20d373);
    r16[cx] += memoryAGet16(ds, 0x20d377);
    r16[dx] = memoryAGet16(ds, 0x20d375);
    r16[cx] -= r16[ax];
    r16[dx] -= r16[bx];
    if (r16s[cx] >= signed16(0x0096))
        { pc = 0x1d8f90; break; }
    if (r16s[cx] <= signed16(0x0050))
        { pc = 0x1d8f90; break; }
    if (r16s[dx] >= signed16(0x0096))
        { pc = 0x1d8f90; break; }
    if (r16s[dx] >= signed16(0x0078))
        { pc = 0x1d8f16; break; }
  case 0x1d8f90: // 0160:1d8f90
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d90ff() // 0160:1d90ff +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0070;
    { pc = 0x1d9128; break; }
    // gap 21 bytes // gap 21 bytes
  case 0x1d9128: // 0160:1d9128
    r16[dx] = 0x0010;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d9142; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d91b9; break; }
  case 0x1d9142: // 0160:1d9142
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d9158; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d91b9; break; }
  case 0x1d9158: // 0160:1d9158
    if (r16[bx] >= 0x0160)
        { pc = 0x1d91b9; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d91b9; break; }
    memoryASet16(ds, 0x20d897, memoryAGet16(ds, 0x20d897) + 0x0001);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    r16[bx]--;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[cx] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] += 0x001f;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20d897, memoryAGet16(ds, 0x20d897) + 0x0001);
  case 0x1d91b9: // 0160:1d91b9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9116() // 0160:1d9116 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] >>>= 1;
    r16[cx] &= 0x0003;
    r16[cx] += 0x0074;
    r16[dx] = 0x0010;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d9142; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d91b9; break; }
  case 0x1d9142: // 0160:1d9142
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d9158; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d91b9; break; }
  case 0x1d9158: // 0160:1d9158
    if (r16[bx] >= 0x0160)
        { pc = 0x1d91b9; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d91b9; break; }
    memoryASet16(ds, 0x20d897, memoryAGet16(ds, 0x20d897) + 0x0001);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    memoryASet16(ds, 0x20ceb7, r16[cx]);
    r16[bx]--;
    yield* sub_1b19e0();
    r16[ax] = memoryAGet16(ds, 0x20ceb3);
    r16[bx] = memoryAGet16(ds, 0x20ceb5);
    r16[cx] = memoryAGet16(ds, 0x20ceb7);
    r16[bx] += 0x001f;
    r16[dx] = 0x0010;
    yield* sub_1b19e0();
    memoryASet16(ds, 0x20d897, memoryAGet16(ds, 0x20d897) + 0x0001);
  case 0x1d91b9: // 0160:1d91b9
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d91ba() // 0160:1d91ba +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[dx] = 0;
    r16[dx] |= 0x0010;
    r16[bx]--;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d91db; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91db: // 0160:1d91db
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d91f1; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91f1: // 0160:1d91f1
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9207; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9207; break; }
    yield* sub_1b19e0();
  case 0x1d9207: // 0160:1d9207
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d91bd() // 0160:1d91bd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[dx] |= 0x0010;
    r16[bx]--;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d91db; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91db: // 0160:1d91db
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d91f1; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91f1: // 0160:1d91f1
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9207; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9207; break; }
    yield* sub_1b19e0();
  case 0x1d9207: // 0160:1d9207
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9409() // 0160:1d9409 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20d379);
    r16[dx] = memoryAGet16(ds, 0x20d37b);
    { pc = 0x1d9427; break; }
    // gap 14 bytes // gap 14 bytes
  case 0x1d9427: // 0160:1d9427
    r16[ax] += 0x0080;
    r16[ax] -= r16[cx];
    if (r16[ax] < 0x0016)
        { pc = 0x1d943b; break; }
    if (r16[ax] >= 0xffea)
        { pc = 0x1d943b; break; }
    r32[esp] += 4; return;
  case 0x1d943b: // 0160:1d943b
    r16[bx] += 0x0080;
    r16[bx] -= r16[dx];
    if (r16[bx] < 0x0016)
        { pc = 0x1d9450; break; }
    if (r16[bx] >= 0xffea)
        { pc = 0x1d9450; break; }
    r32[esp] += 4; return;
  case 0x1d9450: // 0160:1d9450
    memoryASet16(ds, r32[esi], 0x0008);
    push32(r32[ebp]);
    yield* sub_1b1c5c();
    r32[ebp] = pop32();
    r16[ax] <<= 4;
    r16[ax] &= 0x03ff;
    memoryASet16(ds, r32[edi], r16[ax]);
    memoryASet16(ss, r32[ebp], 0x00c8);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d9419() // 0160:1d9419 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20d36d);
    r16[dx] = memoryAGet16(ds, 0x20d36f);
    r16[ax] += 0x0080;
    r16[ax] -= r16[cx];
    if (r16[ax] < 0x0016)
        { pc = 0x1d943b; break; }
    if (r16[ax] >= 0xffea)
        { pc = 0x1d943b; break; }
    r32[esp] += 4; return;
  case 0x1d943b: // 0160:1d943b
    r16[bx] += 0x0080;
    r16[bx] -= r16[dx];
    if (r16[bx] < 0x0016)
        { pc = 0x1d9450; break; }
    if (r16[bx] >= 0xffea)
        { pc = 0x1d9450; break; }
    r32[esp] += 4; return;
  case 0x1d9450: // 0160:1d9450
    memoryASet16(ds, r32[esi], 0x0008);
    push32(r32[ebp]);
    yield* sub_1b1c5c();
    r32[ebp] = pop32();
    r16[ax] <<= 4;
    r16[ax] &= 0x03ff;
    memoryASet16(ds, r32[edi], r16[ax]);
    memoryASet16(ss, r32[ebp], 0x00c8);
    r32[esp] += 4;
    return;
  }
}
function* sub_1d946e() // 0160:1d946e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[bx] = memoryAGet16(ds, r32[esi] + 0xa);
    if (!r16[bx])
        { pc = 0x1d9557; break; }
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x8);
    if (!r16[ax])
        { pc = 0x1d94f5; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d94eb; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d94ba; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1d94c0; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1d94c6; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1d94cc; break; }
    if (r16[ax] == 0x0006)
        { pc = 0x1d94e7; break; }
    if (r16[ax] == 0x0007)
        { pc = 0x1d94e1; break; }
    if (r16[ax] == 0x0008)
        { pc = 0x1d94d8; break; }
    if (r16[ax] == 0x0009)
        { pc = 0x1d94d2; break; }
  case 0x1d94ba: // 0160:1d94ba
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0004);
    { pc = 0x1d94eb; break; }
  case 0x1d94c0: // 0160:1d94c0
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0010);
    { pc = 0x1d94eb; break; }
  case 0x1d94c6: // 0160:1d94c6
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x001c);
    { pc = 0x1d94eb; break; }
  case 0x1d94cc: // 0160:1d94cc
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) - 0x0038);
    { pc = 0x1d94eb; break; }
  case 0x1d94d2: // 0160:1d94d2
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x0038);
    { pc = 0x1d94eb; break; }
  case 0x1d94d8: // 0160:1d94d8
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x001c);
    { pc = 0x1d94eb; break; }
    // gap 3 bytes // gap 3 bytes
  case 0x1d94e1: // 0160:1d94e1
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x0010);
    { pc = 0x1d94eb; break; }
  case 0x1d94e7: // 0160:1d94e7
    memoryASet16(ds, r32[esi], memoryAGet16(ds, r32[esi]) + 0x0004);
  case 0x1d94eb: // 0160:1d94eb
    memoryASet16(ds, r32[esi] + 0xa, memoryAGet16(ds, r32[esi] + 0xa) - 0x0001);
    { pc = 0x1d9598; break; }
  case 0x1d94f5: // 0160:1d94f5
    r32[edi] = 0x00200e10;
    r16[bx] <<= 1;
    r32[ebx] &= 0x0000ffff;
    push32(r32[ebp]);
    r16[bp] = memoryAGet16(ds, r32[edi] + r32[ebx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[bp]);
    r32[ebp] = pop32();
    if (memoryAGet16(ds, r32[esi] + 0x4) & 0xffff)
        { pc = 0x1d94eb; break; }
    memoryASet16(ds, r32[esi] + 0xa, memoryAGet16(ds, r32[esi] + 0xa) - 0x0001);
    if (memoryAGet16(ds, 0x20cec5) & 0xffff)
        { pc = 0x1d9541; break; }
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] -= 0x01e0;
    r16[ax] >>>= 5;
    r16[bx] = 0x0048;
    r16[bx] -= r16[ax];
    r16[ax] = r16[bx];
    yield* sub_1b17b7();
    { pc = 0x1d9598; break; }
  case 0x1d9541: // 0160:1d9541
    r16[ax] = memoryAGet16(ds, r32[esi]);
    r16[ax] -= 0x0370;
    r16[ax] >>>= 5;
    r16[ax] += 0x0033;
    yield* sub_1b17b7();
    { pc = 0x1d9598; break; }
  case 0x1d9557: // 0160:1d9557
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x6);
    r16[ax] += 0x0002;
    r32[edi] = 0x00200e32;
    if (!(memoryAGet16(ds, 0x20cec5) & 0xffff))
        { pc = 0x1d9576; break; }
    r32[edi] = 0x00200ee8;
  case 0x1d9576: // 0160:1d9576
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[edi] + r32[eax]);
    if (r8s[bl] >= 0)
        { pc = 0x1d9585; break; }
    r32[eax] = 0;
    r8[bl] = memoryAGet(ds, r32[edi] + r32[eax]);
  case 0x1d9585: // 0160:1d9585
    memoryASet16(ds, r32[esi] + 0x6, r16[ax]);
    memoryASet16(ds, r32[esi] + 0x8, r16[bx]);
    r16[bx] = 0;
    r8[bl] = memoryAGet(ds, r32[edi] + r32[eax] + 0x1);
    memoryASet16(ds, r32[esi] + 0xa, r16[bx]);
  case 0x1d9598: // 0160:1d9598
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9599() // 0160:1d9599 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d9599; break; }
  case 0x1b19e0: // 0160:1b19e0
    r32[esi] = 0x0020c00c;
    r32[ebp] = memoryAGet32(ds, 0x20c80c);
    r32[esi] += r32[ebp];
    memoryASet16(ds, r32[esi], r16[ax]);
    memoryASet16(ds, r32[esi] + 0x2, r16[bx]);
    memoryASet16(ds, r32[esi] + 0x4, r16[cx]);
    memoryASet16(ds, r32[esi] + 0x6, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0x20ce8f);
    memoryASet16(ds, r32[esi] + 0x8, r16[ax]);
    memoryASet16(ds, r32[esi] + 0xa, 0x0001);
    memoryASet32(ds, 0x20c80c, memoryAGet32(ds, 0x20c80c) + 0x0000000c);
    r32[esp] += 4; return;
    // gap 162693 bytes // gap 162693 bytes
  case 0x1d9599: // 0160:1d9599
    memoryASet16(ds, 0x20ceb1, r16[cx]);
    r16[ax] -= r16[cx];
    r16[bx] -= r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d95bc; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9632; break; }
  case 0x1d95bc: // 0160:1d95bc
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d95d2; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9632; break; }
  case 0x1d95d2: // 0160:1d95d2
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9632; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9632; break; }
    r16[dx] = 0x0010;
    r16[cx] = 0x0070;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b19e0();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[ax] += 0x000b;
    r16[bx] += 0x0020;
    r16[dx] = 0x0010;
    r16[cx] = 0x0071;
    push32(r32[eax]);
    push32(r32[ebx]);
    yield* sub_1b19e0();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r16[cx] = 0x0024;
    r16[cx] -= memoryAGet16(ds, 0x20ceb1);
    r16[cx] >>>= 1;
    r16[dx] = 0x0020;
    r16[dx] -= r16[cx];
    r16[bx] += r16[dx];
    r16[dx] = 0x0010;
    r16[cx] = 0x0074;
    { pc = 0x1b19e0; break; }
  case 0x1d9632: // 0160:1d9632
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d982d() // 0160:1d982d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r16s[ax] <= signed16(0x02de))
        { pc = 0x1d98b9; break; }
    if (r16s[ax] >= signed16(0x02f8))
        { pc = 0x1d98b9; break; }
    if (r16s[bx] >= signed16(0x0320))
        { pc = 0x1d987f; break; }
    r16[bx] += 0x0072;
    r16[cx] = r16[bx];
    r32[esi] = 0x0020d375;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d9859: // 0160:1d9859
    if (memoryAGet16(ds, r32[esi]) != 0x0370)
        { pc = 0x1d986e; break; }
    r16[bx] -= memoryAGet16(ds, r32[esi] + 0x2);
    if (r16[bx] >= 0xffdc)
        { pc = 0x1d993e; break; }
  case 0x1d986e: // 0160:1d986e
    r16[bx] = r16[cx];
    r32[esi] += 0x0000000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9859; break; }
    r32[esp] += 4; return;
  case 0x1d987f: // 0160:1d987f
    r16[bx] += 0x0072;
    r16[cx] = r16[bx];
    r32[esi] = 0x0020d3a5;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d9894: // 0160:1d9894
    if (memoryAGet16(ds, r32[esi]) != 0x0370)
        { pc = 0x1d98a9; break; }
    r16[bx] -= memoryAGet16(ds, r32[esi] + 0x2);
    if (r16[bx] >= 0xffdc)
        { pc = 0x1d993e; break; }
  case 0x1d98a9: // 0160:1d98a9
    r16[bx] = r16[cx];
    r32[esi] += 0x0000000c;
    memoryASet32(ds, 0x20e809, memoryAGet32(ds, 0x20e809) - 0x00000001);
    if (memoryAGet32(ds, 0x20e809))
        { pc = 0x1d9894; break; }
    r32[esp] += 4; return;
  case 0x1d98b9: // 0160:1d98b9
    if (r16s[ax] <= signed16(0x0302))
        { pc = 0x1d993d; break; }
    if (r16s[ax] >= signed16(0x031c))
        { pc = 0x1d993d; break; }
    if (r16s[bx] >= signed16(0x0320))
        { pc = 0x1d9907; break; }
    r16[bx] += 0x0072;
    r16[cx] = r16[bx];
    r32[esi] = 0x0020d375;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d98e1: // 0160:1d98e1
    if (memoryAGet16(ds, r32[esi]) != 0x0394)
        { pc = 0x1d98f6; break; }
    r16[bx] -= memoryAGet16(ds, r32[esi] + 0x2);
    if (r16[bx] >= 0xffdc)
        { pc = 0x1d997b; break; }
  case 0x1d98f6: // 0160:1d98f6
    r16[bx] = r16[cx];
    r32[esi] += 0x0000000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d98e1; break; }
    r32[esp] += 4; return;
  case 0x1d9907: // 0160:1d9907
    r16[bx] += 0x0072;
    r16[cx] = r16[bx];
    r32[esi] = 0x0020d3a5;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d991c: // 0160:1d991c
    if (memoryAGet16(ds, r32[esi]) != 0x0394)
        { pc = 0x1d992d; break; }
    r16[bx] -= memoryAGet16(ds, r32[esi] + 0x2);
    if (r16[bx] >= 0xffdc)
        { pc = 0x1d997b; break; }
  case 0x1d992d: // 0160:1d992d
    r16[bx] = r16[cx];
    r32[esi] += 0x0000000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d991c; break; }
  case 0x1d993d: // 0160:1d993d
    r32[esp] += 4; return;
  case 0x1d993e: // 0160:1d993e
    if (memoryAGet16(ds, r32[esi] + 0xa) & 0xffff)
        { pc = 0x1d9964; break; }
    r16[ax] = memoryAGet16(ss, r32[ebp]);
    r16[ax] += 0x0200;
    r16[ax] &= 0x03ff;
    memoryASet16(ss, r32[ebp], r16[ax]);
    if (signed16(memoryAGet16(ds, r32[edi])) >= signed16(0x0096))
        { pc = 0x1d997a; break; }
    memoryASet16(ds, r32[edi], 0x00c8);
    { pc = 0x1d997a; break; }
  case 0x1d9964: // 0160:1d9964
    yield* sub_1b1c25();
    r16[ax] &= 0x00ff;
    r16[ax] -= 0x007f;
    memoryASet16(ss, r32[ebp], r16[ax]);
    memoryASet16(ds, r32[edi], 0x0180);
  case 0x1d997a: // 0160:1d997a
    r32[esp] += 4; return;
  case 0x1d997b: // 0160:1d997b
    if (memoryAGet16(ds, r32[esi] + 0xa) & 0xffff)
        { pc = 0x1d99a1; break; }
    r16[ax] = memoryAGet16(ss, r32[ebp]);
    r16[ax] += 0x0200;
    r16[ax] &= 0x03ff;
    memoryASet16(ss, r32[ebp], r16[ax]);
    if (signed16(memoryAGet16(ds, r32[edi])) >= signed16(0x0096))
        { pc = 0x1d99bb; break; }
    memoryASet16(ds, r32[edi], 0x00c8);
    { pc = 0x1d99bb; break; }
  case 0x1d99a1: // 0160:1d99a1
    yield* sub_1b1c25();
    r16[ax] &= 0x00ff;
    r16[ax] -= 0x007f;
    r16[ax] += 0x0200;
    memoryASet16(ss, r32[ebp], r16[ax]);
    memoryASet16(ds, r32[edi], 0x0180);
  case 0x1d99bb: // 0160:1d99bb
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d99bc() // 0160:1d99bc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d373) & 0xffff)
        { pc = 0x1d9a36; break; }
    if (signed16(memoryAGet16(ds, 0x20d371)) >= signed16(0x000e))
        { pc = 0x1d99d1; break; }
  case 0x1d99d1: // 0160:1d99d1
    yield* sub_1d9daf();
    r32[esi] = 0x0020d3a5;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1d9a77; break; }
    memoryASet16(ds, 0x20e809, 0x0004);
    r32[eax] = 0x0000000a;
    memoryASet16(ds, 0x20ceb3, 0x0005);
  case 0x1d9a02: // 0160:1d9a02
    if (signed16(memoryAGet16(ds, 0x20ceb3)) <= signed16(0x0002))
        { pc = 0x1d9a26; break; }
    if (memoryAGet16(ds, r32[esi] + r32[eax]) == 0x0005)
        { pc = 0x1d9a26; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + 0x0001);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r16[ax] = pop();
  case 0x1d9a26: // 0160:1d9a26
    r16[ax] += 0x000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9a02; break; }
    { pc = 0x1d9a77; break; }
  case 0x1d9a36: // 0160:1d9a36
    r32[esi] = 0x0020d3a5;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1d9a77; break; }
    memoryASet16(ds, 0x20e809, 0x0004);
    r32[eax] = 0x0000000a;
  case 0x1d9a55: // 0160:1d9a55
    if (!(memoryAGet16(ds, r32[esi] + r32[eax]) & 0xffff))
        { pc = 0x1d9a69; break; }
    if (memoryAGet16(ds, r32[esi] + r32[eax]) == 0x0003)
        { pc = 0x1d9a69; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) - 0x0001);
  case 0x1d9a69: // 0160:1d9a69
    r16[ax] += 0x000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9a55; break; }
  case 0x1d9a77: // 0160:1d9a77
    r32[esi] = 0x0020d3a5;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d9a85: // 0160:1d9a85
    r16[ax] = memoryAGet16(ds, r32[esi] + 0xa);
    if (!(memoryAGet16(ds, r32[esi] + 0x6) & 0xffff))
        { pc = 0x1d9a97; break; }
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) + r16[ax]);
    { pc = 0x1d9a9b; break; }
  case 0x1d9a97: // 0160:1d9a97
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) - r16[ax]);
  case 0x1d9a9b: // 0160:1d9a9b
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    if (r16s[ax] <= signed16(0x05ae))
        { pc = 0x1d9abf; break; }
    if (r16s[ax] >= signed16(0x0734))
        { pc = 0x1d9aad; break; }
    { pc = 0x1d9acf; break; }
  case 0x1d9aad: // 0160:1d9aad
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) - 0x0006);
    memoryASet16(ds, r32[esi], 0x0370);
    memoryASet16(ds, r32[esi] + 0x6, 0x0000);
    { pc = 0x1d9acf; break; }
  case 0x1d9abf: // 0160:1d9abf
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) + 0x0006);
    memoryASet16(ds, r32[esi], 0x0394);
    memoryASet16(ds, r32[esi] + 0x6, 0x0002);
  case 0x1d9acf: // 0160:1d9acf
    r32[esi] += 0x0000000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9a85; break; }
    if (!(memoryAGet16(ds, 0x20d373) & 0xffff))
        { pc = 0x1d9b93; break; }
    if (memoryAGet16(ds, 0x20d3a5) != 0x0370)
        { pc = 0x1d9b15; break; }
    if (signed16(memoryAGet16(ds, 0x20d3a7)) <= signed16(0x06b2))
        { pc = 0x1d9b15; break; }
    if (signed16(memoryAGet16(ds, 0x20d3a7)) >= signed16(0x06b8))
        { pc = 0x1d9b15; break; }
    memoryASet16(ds, 0x20d3af, 0x0000);
  case 0x1d9b15: // 0160:1d9b15
    if (memoryAGet16(ds, 0x20d3b1) != 0x0370)
        { pc = 0x1d9b3f; break; }
    if (signed16(memoryAGet16(ds, 0x20d3b3)) <= signed16(0x06e4))
        { pc = 0x1d9b3f; break; }
    if (signed16(memoryAGet16(ds, 0x20d3b3)) >= signed16(0x06ea))
        { pc = 0x1d9b3f; break; }
    memoryASet16(ds, 0x20d3bb, 0x0000);
  case 0x1d9b3f: // 0160:1d9b3f
    if (memoryAGet16(ds, 0x20d3bd) != 0x0394)
        { pc = 0x1d9b69; break; }
    if (signed16(memoryAGet16(ds, 0x20d3bf)) <= signed16(0x0612))
        { pc = 0x1d9b69; break; }
    if (signed16(memoryAGet16(ds, 0x20d3bf)) >= signed16(0x0618))
        { pc = 0x1d9b69; break; }
    memoryASet16(ds, 0x20d3c7, 0x0000);
  case 0x1d9b69: // 0160:1d9b69
    if (memoryAGet16(ds, 0x20d3c9) != 0x0394)
        { pc = 0x1d9b93; break; }
    if (signed16(memoryAGet16(ds, 0x20d3cb)) <= signed16(0x05e0))
        { pc = 0x1d9b93; break; }
    if (signed16(memoryAGet16(ds, 0x20d3cb)) >= signed16(0x05e6))
        { pc = 0x1d9b93; break; }
    memoryASet16(ds, 0x20d3d3, 0x0000);
  case 0x1d9b93: // 0160:1d9b93
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9b94() // 0160:1d9b94 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (memoryAGet16(ds, 0x20d36f) & 0xffff)
        { pc = 0x1d9c0e; break; }
    if (signed16(memoryAGet16(ds, 0x20d36d)) >= signed16(0x000e))
        { pc = 0x1d9ba9; break; }
  case 0x1d9ba9: // 0160:1d9ba9
    yield* sub_1d9daf();
    r32[esi] = 0x0020d375;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1d9c4f; break; }
    memoryASet16(ds, 0x20e809, 0x0004);
    r32[eax] = 0x0000000a;
    memoryASet16(ds, 0x20ceb3, 0x0005);
  case 0x1d9bda: // 0160:1d9bda
    if (signed16(memoryAGet16(ds, 0x20ceb3)) <= signed16(0x0002))
        { pc = 0x1d9bfe; break; }
    if (memoryAGet16(ds, r32[esi] + r32[eax]) == 0x0005)
        { pc = 0x1d9bfe; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) + 0x0001);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet16(ds, 0x20ceb3, r16[ax]);
    r16[ax] = pop();
  case 0x1d9bfe: // 0160:1d9bfe
    r16[ax] += 0x000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9bda; break; }
    { pc = 0x1d9c4f; break; }
  case 0x1d9c0e: // 0160:1d9c0e
    r32[esi] = 0x0020d375;
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0003;
    if (r16[ax])
        { pc = 0x1d9c4f; break; }
    memoryASet16(ds, 0x20e809, 0x0004);
    r32[eax] = 0x0000000a;
  case 0x1d9c2d: // 0160:1d9c2d
    if (!(memoryAGet16(ds, r32[esi] + r32[eax]) & 0xffff))
        { pc = 0x1d9c41; break; }
    if (memoryAGet16(ds, r32[esi] + r32[eax]) == 0x0003)
        { pc = 0x1d9c41; break; }
    memoryASet16(ds, r32[esi] + r32[eax], memoryAGet16(ds, r32[esi] + r32[eax]) - 0x0001);
  case 0x1d9c41: // 0160:1d9c41
    r16[ax] += 0x000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9c2d; break; }
  case 0x1d9c4f: // 0160:1d9c4f
    r32[esi] = 0x0020d375;
    memoryASet16(ds, 0x20e809, 0x0004);
  case 0x1d9c5d: // 0160:1d9c5d
    r16[ax] = memoryAGet16(ds, r32[esi] + 0xa);
    if (!(memoryAGet16(ds, r32[esi] + 0x6) & 0xffff))
        { pc = 0x1d9c6f; break; }
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) + r16[ax]);
    { pc = 0x1d9c73; break; }
  case 0x1d9c6f: // 0160:1d9c6f
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) - r16[ax]);
  case 0x1d9c73: // 0160:1d9c73
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x2);
    if (r16s[ax] <= signed16(0x006e))
        { pc = 0x1d9c97; break; }
    if (r16s[ax] >= signed16(0x01f4))
        { pc = 0x1d9c85; break; }
    { pc = 0x1d9ca7; break; }
  case 0x1d9c85: // 0160:1d9c85
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) - 0x0006);
    memoryASet16(ds, r32[esi], 0x0370);
    memoryASet16(ds, r32[esi] + 0x6, 0x0000);
    { pc = 0x1d9ca7; break; }
  case 0x1d9c97: // 0160:1d9c97
    memoryASet16(ds, r32[esi] + 0x2, memoryAGet16(ds, r32[esi] + 0x2) + 0x0006);
    memoryASet16(ds, r32[esi], 0x0394);
    memoryASet16(ds, r32[esi] + 0x6, 0x0002);
  case 0x1d9ca7: // 0160:1d9ca7
    r32[esi] += 0x0000000c;
    memoryASet16(ds, 0x20e809, memoryAGet16(ds, 0x20e809) - 0x0001);
    if (memoryAGet16(ds, 0x20e809))
        { pc = 0x1d9c5d; break; }
    if (!(memoryAGet16(ds, 0x20d36f) & 0xffff))
        { pc = 0x1d9d6b; break; }
    if (memoryAGet16(ds, 0x20d375) != 0x0370)
        { pc = 0x1d9ced; break; }
    if (signed16(memoryAGet16(ds, 0x20d377)) <= signed16(0x0172))
        { pc = 0x1d9ced; break; }
    if (signed16(memoryAGet16(ds, 0x20d377)) >= signed16(0x0178))
        { pc = 0x1d9ced; break; }
    memoryASet16(ds, 0x20d37f, 0x0000);
  case 0x1d9ced: // 0160:1d9ced
    if (memoryAGet16(ds, 0x20d381) != 0x0370)
        { pc = 0x1d9d17; break; }
    if (signed16(memoryAGet16(ds, 0x20d383)) <= signed16(0x01a4))
        { pc = 0x1d9d17; break; }
    if (signed16(memoryAGet16(ds, 0x20d383)) >= signed16(0x01aa))
        { pc = 0x1d9d17; break; }
    memoryASet16(ds, 0x20d38b, 0x0000);
  case 0x1d9d17: // 0160:1d9d17
    if (memoryAGet16(ds, 0x20d38d) != 0x0394)
        { pc = 0x1d9d41; break; }
    if (signed16(memoryAGet16(ds, 0x20d38f)) <= signed16(0x00d2))
        { pc = 0x1d9d41; break; }
    if (signed16(memoryAGet16(ds, 0x20d38f)) >= signed16(0x00d8))
        { pc = 0x1d9d41; break; }
    memoryASet16(ds, 0x20d397, 0x0000);
  case 0x1d9d41: // 0160:1d9d41
    if (memoryAGet16(ds, 0x20d399) != 0x0394)
        { pc = 0x1d9d6b; break; }
    if (signed16(memoryAGet16(ds, 0x20d39b)) <= signed16(0x00a0))
        { pc = 0x1d9d6b; break; }
    if (signed16(memoryAGet16(ds, 0x20d39b)) >= signed16(0x00a6))
        { pc = 0x1d9d6b; break; }
    memoryASet16(ds, 0x20d3a3, 0x0000);
  case 0x1d9d6b: // 0160:1d9d6b
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9d6c() // 0160:1d9d6c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d9d82; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9dae; break; }
  case 0x1d9d82: // 0160:1d9d82
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d9d98; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9dae; break; }
  case 0x1d9d98: // 0160:1d9d98
    if (r16[bx] >= 0x0160)
        { pc = 0x1d9dae; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9dae; break; }
    yield* sub_1b19e0();
  case 0x1d9dae: // 0160:1d9dae
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9daf() // 0160:1d9daf +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1d9daf; break; }
  case 0x1aa64a: // 0160:1aa64a
    if (memoryAGet16(ds, 0x1f1ccc) == 0x0001)
        { pc = 0x1c7b2c; break; }
    r32[esp] += 4; return;
    // gap 29021 bytes // gap 29021 bytes
  case 0x1b17b6: // 0160:1b17b6
    r32[esp] += 4; return;
  case 0x1b17b7: // 0160:1b17b7
    if (!(memoryAGet16(ds, 0x1f1ccc) & 0xffff))
        { pc = 0x1b17b6; break; }
    if (memoryAGet16(ds, 0x20ed7f) & 0xffff)
        { pc = 0x1b17b6; break; }
    if (!(memoryAGet16(ds, 0x20eda7) & 0xffff))
        { pc = 0x1b17b6; break; }
    r32[esi] = 0x002035b2;
    if (memoryAGet32(ds, 0x30b158) == 0x00000001)
        { pc = 0x1b17eb; break; }
    r32[esi] = 0x0020315c;
  case 0x1b17eb: // 0160:1b17eb
    r32[eax] &= 0x000000ff;
    r32[eax] <<= 1;
    r32[ebx] = r32[eax];
    r32[eax] <<= 1;
    r32[eax] += r32[ebx];
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    memoryASet32(ds, 0x1f1cdc, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet32(ds, 0x1f1ce0, r32[ebx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x4);
    memoryASet32(ds, 0x1f1ce4, r32[ebx]);
    if (memoryAGet32(ds, 0x1f1cdc) != 0x00000005)
        { pc = 0x1aa64a; break; }
  case 0x1b1827: // 0160:1b1827
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d2c5);
    r16[ax]++;
    if (r16s[ax] < signed16(0x0006))
        { pc = 0x1b1839; break; }
    r32[eax] = 0;
  case 0x1b1839: // 0160:1b1839
    memoryASet16(ds, 0x20d2c5, r16[ax]);
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1b184e; break; }
    if (r16[ax] == 0x0004)
        { pc = 0x1b1827; break; }
  case 0x1b184e: // 0160:1b184e
    if (r16[ax] == 0x0004)
        { pc = 0x1b189b; break; }
    if (r16[ax] == 0x0005)
        { pc = 0x1b189b; break; }
    if (!r16[ax])
        { pc = 0x1b188f; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b1883; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b1877; break; }
    if (memoryAGet16(ds, 0x20e7dd))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1877: // 0160:1b1877
    if (memoryAGet16(ds, 0x20e7db))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b1883: // 0160:1b1883
    if (memoryAGet16(ds, 0x20e7d9))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b188f: // 0160:1b188f
    if (memoryAGet16(ds, 0x20e7d7))
        { pc = 0x1b1827; break; }
    { pc = 0x1b189b; break; }
  case 0x1b189b: // 0160:1b189b
    memoryASet32(ds, 0x1f1cdc, r32[eax]);
    { pc = 0x1aa64a; break; }
    // gap 90759 bytes // gap 90759 bytes
  case 0x1c7b2c: // 0160:1c7b2c
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000040;
    if (memoryAGet32(ds, 0x30b158) != 0x00000001)
        { pc = 0x1c7ba9; break; }
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    memoryASet32(ss, r32[ebp] - 24, 0x00000010);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 4)) < signed32(0x00000000))
        { pc = 0x1c7b8b; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7b8d; break; }
  case 0x1c7b8b: // 0160:1c7b8b
    { pc = 0x1c7ba4; break; }
  case 0x1c7b8d: // 0160:1c7b8d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7ba4: // 0160:1c7ba4
    { pc = 0x1c7c27; break; }
  case 0x1c7ba9: // 0160:1c7ba9
    if (memoryAGet32(ds, 0x1f1cd8) == 0x00000002)
        { pc = 0x1c7bbb; break; }
    if (memoryAGet32(ds, 0x1f1cd8) != 0x00000003)
        { pc = 0x1c7bbd; break; }
  case 0x1c7bbb: // 0160:1c7bbb
    { pc = 0x1c7bc6; break; }
  case 0x1c7bbd: // 0160:1c7bbd
    if (signed32(memoryAGet32(ds, 0x1f1ce0)) >= signed32(0x00000003))
        { pc = 0x1c7c27; break; }
  case 0x1c7bc6: // 0160:1c7bc6
    r32[eax] = memoryAGet32(ds, 0x1f1cdc);
    memoryASet32(ss, r32[ebp] - 64, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x1f1ce0);
    memoryASet32(ss, r32[ebp] - 60, r32[eax]);
    memoryASet32(ss, r32[ebp] - 56, 0x00000040);
    r32[eax] = memoryAGet32(ds, 0x1f1ce4);
    memoryASet32(ss, r32[ebp] - 52, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 64);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 60);
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 56);
    memoryASet32(ss, r32[ebp] - 44, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 52);
    memoryASet32(ss, r32[ebp] - 48, r32[eax]);
    if (signed32(memoryAGet32(ss, r32[ebp] - 36)) < signed32(0x00000000))
        { pc = 0x1c7c0e; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x1f1cd0)))
        { pc = 0x1c7c10; break; }
  case 0x1c7c0e: // 0160:1c7c0e
    { pc = 0x1c7c27; break; }
  case 0x1c7c10: // 0160:1c7c10
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 48);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 44);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 40);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    r32[eax] += memoryAGet32(ds, 0x30b150);
    yield* sub_1dfb30();
  case 0x1c7c27: // 0160:1c7c27
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 74111 bytes // gap 74111 bytes
  case 0x1d9daf: // 0160:1d9daf
    r16[ax] = memoryAGet16(ds, 0x20c830);
    r16[ax] &= 0x0007;
    if (r16[ax])
        { pc = 0x1d9df4; break; }
    yield* sub_1b1c6b();
    if (r8s[al] >= signed8(0x3c))
        { pc = 0x1d9df4; break; }
    r16[ax] &= 0x0003;
    if (!r16[ax])
        { pc = 0x1d9ddf; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1d9de6; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1d9ded; break; }
    r16[ax] = 0x0056;
    { pc = 0x1b17b7; break; }
  case 0x1d9ddf: // 0160:1d9ddf
    r8[al] = 0x63;
    { pc = 0x1b17b7; break; }
  case 0x1d9de6: // 0160:1d9de6
    r8[al] = 0x4b;
    { pc = 0x1b17b7; break; }
  case 0x1d9ded: // 0160:1d9ded
    r8[al] = 0x7d;
    { pc = 0x1b17b7; break; }
  case 0x1d9df4: // 0160:1d9df4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9e4f() // 0160:1d9e4f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d371);
    r32[esi] = 0x002017a8;
    r16[ax] <<= 2;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] += 0x0072;
    memoryASet16(ds, 0x20ceb3, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20d373, r16[bx]);
    r16[bx] += 0x0075;
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r16[dx] = 0x0010;
    r16[ax] = 0x034f;
    r16[bx] = 0x0628;
    yield* sub_1d9fd1();
    r16[dx] = 0x0010;
    r16[ax] = 0x03bf;
    r16[bx] = 0x0628;
    yield* sub_1d9fd1();
    r16[dx] = 0x0012;
    r16[ax] = 0x034f;
    r16[bx] = 0x06b0;
    yield* sub_1d9fd1();
    r16[dx] = 0x0012;
    r16[ax] = 0x03bf;
    r16[bx] = 0x06b0;
    yield* sub_1d9fd1();
    r16[dx] = 0x0010;
    r16[ax] = 0x0348;
    r16[bx] = 0x0630;
    yield* sub_1d9fc8();
    r16[dx] = 0x0011;
    r16[ax] = 0x03d0;
    r16[bx] = 0x0630;
    yield* sub_1d9fc8();
    r16[dx] = 0x0010;
    r16[ax] = 0x0348;
    r16[bx] = 0x06a0;
    yield* sub_1d9fc8();
    r16[dx] = 0x0011;
    r16[ax] = 0x03d0;
    r16[bx] = 0x06a0;
    { pc = 0x1d9fc8; break; }
    // gap 186 bytes // gap 186 bytes
  case 0x1d9fc8: // 0160:1d9fc8
    r16[cx] = memoryAGet16(ds, 0x20ceb5);
    { pc = 0x1d9fd8; break; }
    // gap 7 bytes // gap 7 bytes
  case 0x1d9fd8: // 0160:1d9fd8
    r16[bx]--;
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0008;
    if (r16[bp])
        { pc = 0x1d9fed; break; }
    r16[cx] += 0x000a;
  case 0x1d9fed: // 0160:1d9fed
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1da003; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da003: // 0160:1da003
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1da019; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da019: // 0160:1da019
    if (r16[bx] >= 0x0178)
        { pc = 0x1da02f; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1da02f; break; }
    yield* sub_1b19e0();
  case 0x1da02f: // 0160:1da02f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9f0e() // 0160:1d9f0e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20d36d);
    r32[esi] = 0x002017a8;
    r16[ax] <<= 2;
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax]);
    r16[bx] += 0x0072;
    memoryASet16(ds, 0x20ceb3, r16[bx]);
    r16[bx] = memoryAGet16(ds, r32[esi] + r32[eax] + 0x2);
    memoryASet16(ds, 0x20d36f, r16[bx]);
    r16[bx] += 0x0075;
    memoryASet16(ds, 0x20ceb5, r16[bx]);
    r16[dx] = 0x0010;
    r16[ax] = 0x034f;
    r16[bx] = 0x00e8;
    yield* sub_1d9fd1();
    r16[dx] = 0x0010;
    r16[ax] = 0x03bf;
    r16[bx] = 0x00e8;
    yield* sub_1d9fd1();
    r16[dx] = 0x0012;
    r16[ax] = 0x034f;
    r16[bx] = 0x0170;
    yield* sub_1d9fd1();
    r16[dx] = 0x0012;
    r16[ax] = 0x03bf;
    r16[bx] = 0x0170;
    yield* sub_1d9fd1();
    r16[dx] = 0x0010;
    r16[ax] = 0x0348;
    r16[bx] = 0x00f0;
    yield* sub_1d9fc8();
    r16[dx] = 0x0011;
    r16[ax] = 0x03d0;
    r16[bx] = 0x00f0;
    yield* sub_1d9fc8();
    r16[dx] = 0x0010;
    r16[ax] = 0x0348;
    r16[bx] = 0x0160;
    yield* sub_1d9fc8();
    r16[dx] = 0x0011;
    r16[ax] = 0x03d0;
    r16[bx] = 0x0160;
    r16[cx] = memoryAGet16(ds, 0x20ceb5);
    { pc = 0x1d9fd8; break; }
    // gap 7 bytes // gap 7 bytes
  case 0x1d9fd8: // 0160:1d9fd8
    r16[bx]--;
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0008;
    if (r16[bp])
        { pc = 0x1d9fed; break; }
    r16[cx] += 0x000a;
  case 0x1d9fed: // 0160:1d9fed
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1da003; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da003: // 0160:1da003
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1da019; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da019: // 0160:1da019
    if (r16[bx] >= 0x0178)
        { pc = 0x1da02f; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1da02f; break; }
    yield* sub_1b19e0();
  case 0x1da02f: // 0160:1da02f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9fc8() // 0160:1d9fc8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20ceb5);
    { pc = 0x1d9fd8; break; }
    // gap 7 bytes // gap 7 bytes
  case 0x1d9fd8: // 0160:1d9fd8
    r16[bx]--;
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0008;
    if (r16[bp])
        { pc = 0x1d9fed; break; }
    r16[cx] += 0x000a;
  case 0x1d9fed: // 0160:1d9fed
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1da003; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da003: // 0160:1da003
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1da019; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da019: // 0160:1da019
    if (r16[bx] >= 0x0178)
        { pc = 0x1da02f; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1da02f; break; }
    yield* sub_1b19e0();
  case 0x1da02f: // 0160:1da02f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1d9fd1() // 0160:1d9fd1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r16[cx] = memoryAGet16(ds, 0x20ceb3);
    r16[bx]--;
    r16[bp] = memoryAGet16(ds, 0x20c830);
    r16[bp] &= 0x0008;
    if (r16[bp])
        { pc = 0x1d9fed; break; }
    r16[cx] += 0x000a;
  case 0x1d9fed: // 0160:1d9fed
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1da003; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da003: // 0160:1da003
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1da019; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1da02f; break; }
  case 0x1da019: // 0160:1da019
    if (r16[bx] >= 0x0178)
        { pc = 0x1da02f; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1da02f; break; }
    yield* sub_1b19e0();
  case 0x1da02f: // 0160:1da02f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1da112() // 0160:1da112 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1da112; break; }
  case 0x1d91c1: // 0160:1d91c1
    r16[bx]--;
    r16[ax] -= memoryAGet16(ds, 0x20cf23);
    if (r16s[ax] >= 0)
        { pc = 0x1d91db; break; }
    r16[ax] += memoryAGet16(ds, 0x20cef5);
    if (r16s[ax] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91db: // 0160:1d91db
    r16[bx] -= memoryAGet16(ds, 0x20cf25);
    if (r16s[bx] >= 0)
        { pc = 0x1d91f1; break; }
    r16[bx] += memoryAGet16(ds, 0x20cef9);
    if (r16s[bx] < 0)
        { pc = 0x1d9207; break; }
  case 0x1d91f1: // 0160:1d91f1
    if (r16[bx] >= 0x0178)
        { pc = 0x1d9207; break; }
    if (r16s[ax] >= signed16(0x01c0))
        { pc = 0x1d9207; break; }
    yield* sub_1b19e0();
  case 0x1d9207: // 0160:1d9207
    r32[esp] += 4; return;
    // gap 3850 bytes // gap 3850 bytes
  case 0x1da112: // 0160:1da112
    r32[esi] = 0x0020602c;
    if (r16s[cx] >= signed16(0x0020))
        { pc = 0x1da150; break; }
    r16[cx] <<= 2;
    r32[ecx] &= 0x0000ffff;
    r16[ax] += memoryAGet16(ds, r32[esi] + r32[ecx]);
    r16[bx] += memoryAGet16(ds, r32[esi] + r32[ecx] + 0x2);
    r16[dx] >>>= 1;
    r16[ax] -= r16[dx];
    r16[bx] -= r16[dx];
    r16[dx] = 0;
    r16[cx] = memoryAGet16(ds, 0x20c830);
    r16[cx] &= 0x0003;
    r16[cx] += 0x0070;
    { pc = 0x1d91c1; break; }
  case 0x1da150: // 0160:1da150
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1da2a0() // 0160:1da2a0 +long +returnCarry
{
    r32[esp] -= 4;
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    flags.carry = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    r32[esp] += 4;
}
function* sub_1da2a8() // 0160:1da2a8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[edi] = r32[eax];
    r32[esi] = r32[edx];
    r32[ecx] = r32[ebx];
    r32[eax] = memoryAGet16(ds, r32[esi]);
    r32[eax] += r32[esi];
    push32(r32[eax]);
    r32[esi] += 0x00000002;
    r32[eax] = 0;
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] += 0x00000004;
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    r32[eax] += (r32[eax] + flags.carry);
    r32[ebp]++;
    memoryASet(ds, 0x30b160, r8[al]);
    memoryASet(ds, 0x30b16a, 0x0a);
  case 0x1da2d0: // 0160:1da2d0
    memoryASet(ds, 0x30b166, 0x0a);
  case 0x1da2d7: // 0160:1da2d7
    r32[eax] = 0;
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    if (r32[ebp])
        { pc = 0x1da2e2; break; }
    yield* sub_1da2a0();
  case 0x1da2e2: // 0160:1da2e2
    r32[eax] += (r32[eax] + flags.carry);
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    if (r32[ebp])
        { pc = 0x1da2ed; break; }
    yield* sub_1da2a0();
  case 0x1da2ed: // 0160:1da2ed
    r32[eax] += (r32[eax] + flags.carry);
    if (!r32[eax])
        { pc = 0x1da39e; break; }
    r32[eax] = r32[eax] + (r32[eax] * 8);
    r8[al] |= 0x08;
    memoryASet(ds, 0x30b161, r8[al]);
    r8[dl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    if (!r8[dl])
        { pc = 0x1da354; break; }
    r32[ebx] = 0;
  case 0x1da308: // 0160:1da308
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r32[eax] = memoryAGet32(ds, r32[esi]);
    if (r8[al] >= 0xc0)
        { pc = 0x1da348; break; }
    if (r8[al] & 128)
        { pc = 0x1da332; break; }
    if (r8[al] & 0xc0)
        { pc = 0x1da323; break; }
    r8[al] &= 0x3f;
    r32[esi]++;
    memoryASet(ds, r32[ecx] + r32[ebx] * 4, r8[al]);
    r8[dl]--;
    if (r8[dl])
        { pc = 0x1da308; break; }
    { pc = 0x1da354; break; }
  case 0x1da323: // 0160:1da323
    r8[al] &= 0x3f;
    r32[esi] += 0x00000002;
    memoryASet16(ds, r32[ecx] + r32[ebx] * 4, r16[ax]);
    r8[dl]--;
    if (r8[dl])
        { pc = 0x1da308; break; }
    { pc = 0x1da354; break; }
  case 0x1da332: // 0160:1da332
    r8[al] &= 0x3f;
    r32[esi] += 0x00000003;
    memoryASet16(ds, r32[ecx] + r32[ebx] * 4, r16[ax]);
    r32[eax] >>>= 16;
    memoryASet(ds, r32[ecx] + r32[ebx] * 4 + 0x2, r8[al]);
    r8[dl]--;
    if (r8[dl])
        { pc = 0x1da308; break; }
    { pc = 0x1da354; break; }
  case 0x1da348: // 0160:1da348
    r8[al] &= 0x3f;
    r32[esi] += 0x00000004;
    memoryASet32(ds, r32[ecx] + r32[ebx] * 4, r32[eax]);
    r8[dl]--;
    if (r8[dl])
        { pc = 0x1da308; break; }
  case 0x1da354: // 0160:1da354
    r16[ax] = 0x0302;
  case 0x1da358: // 0160:1da358
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    push32(r32[eax]);
    r32[edx] = 0;
  case 0x1da361: // 0160:1da361
    if (!(memoryAGet(ds, 0x30b161) & 0x10))
        { pc = 0x1da375; break; }
    yield* sub_1da3c8();
    r32[edi] -= 0x00000780;
  case 0x1da375: // 0160:1da375
    r32[edi] += 0x00000004;
    flags.carry = memoryAGet(ds, 0x30b161) & 8;
    memoryASet(ds, 0x30b161, ror8(memoryAGet(ds, 0x30b161), 0x04));
    if (flags.carry)
        { pc = 0x1da361; break; }
    r32[edi] -= 0x00000008;
    r32[eax] = pop32();
    r8[ah] += r8[ah];
    r8[ah] += r8[ah];
    if (r8[ah] < 0x10)
        { pc = 0x1da358; break; }
    if (!(memoryAGet(ds, 0x30b160) & 0x01))
        { pc = 0x1da39e; break; }
    flags.zero = r8[ah] == 0x20;
    r8[ah] = 0x02;
    if (!flags.zero)
        { pc = 0x1da358; break; }
  case 0x1da39e: // 0160:1da39e
    r32[ecx] += 0x00000400;
    r32[edi] += 0x00000008;
    memoryASet(ds, 0x30b166, memoryAGet(ds, 0x30b166) - 1);
    if (memoryAGet(ds, 0x30b166))
        { pc = 0x1da2d7; break; }
    r32[edi] += 0x00000730;
    memoryASet(ds, 0x30b16a, memoryAGet(ds, 0x30b16a) - 1);
    if (memoryAGet(ds, 0x30b16a))
        { pc = 0x1da2d0; break; }
    r32[edx] = pop32();
    r32[ebp] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1da3c8() // 0160:1da3c8 +long
{
  var pc = 0;
  var temp_cf;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[edi], r32[ebx]);
    r32[esi] += 0x00000004;
    r32[edi] += 0x00000050;
    r8[al] = 0x17;
    { pc = 0x1da3e0; break; }
  case 0x1da3d6: // 0160:1da3d6
    r32[esp] += 4; return;
  case 0x1da3d7: // 0160:1da3d7
    memoryASet32(ds, r32[edi], r32[ebx]);
    r32[edi] += 0x00000050;
    r8[al]--;
    if (!r8[al])
        { pc = 0x1da3d6; break; }
  case 0x1da3e0: // 0160:1da3e0
    r8[dl] = r8[bl];
    r8[dl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4);
    r8[ah] = 0x04;
    switch (r32[edx])
    {
        case 1: { pc = 0x1da455; break; }
        case 2: { pc = 0x1da43e; break; }
        case 3: { pc = 0x1da424; break; }
        case 4: { pc = 0x1da46d; break; }
        case 5: { pc = 0x1da47c; break; }
        case 6: { pc = 0x1da48b; break; }
        case 7: { pc = 0x1da49a; break; }
        case 8: { pc = 0x1da51c; break; }
        case 9: { pc = 0x1da533; break; }
        case 10: { pc = 0x1da54a; break; }
        case 11: { pc = 0x1da561; break; }
        case 12: { pc = 0x1da578; break; }
        case 13: { pc = 0x1da58f; break; }
        case 14: { pc = 0x1da5a6; break; }
        case 15: { pc = 0x1da5bd; break; }
        case 16: { pc = 0x1da6ba; break; }
        case 17: { pc = 0x1da6d1; break; }
        case 18: { pc = 0x1da6e8; break; }
        case 19: { pc = 0x1da6ff; break; }
        case 20: { pc = 0x1da716; break; }
        case 21: { pc = 0x1da72d; break; }
        case 22: { pc = 0x1da744; break; }
        case 23: { pc = 0x1da75b; break; }
        case 24: { pc = 0x1da772; break; }
        case 25: { pc = 0x1da789; break; }
        case 26: { pc = 0x1da7a0; break; }
        case 27: { pc = 0x1da7b7; break; }
        case 28: { pc = 0x1da7ce; break; }
        case 29: { pc = 0x1daa0d; break; }
        case 30: { pc = 0x1daa24; break; }
        case 31: { pc = 0x1daa3b; break; }
        case 32: { pc = 0x1da886; break; }
        case 33: { pc = 0x1da89d; break; }
        case 34: { pc = 0x1da8b4; break; }
        case 35: { pc = 0x1da8cb; break; }
        case 36: { pc = 0x1da8e2; break; }
        case 37: { pc = 0x1da8f9; break; }
        case 38: { pc = 0x1da910; break; }
        case 39: { pc = 0x1da927; break; }
        case 40: { pc = 0x1da93e; break; }
        case 41: { pc = 0x1da955; break; }
        case 42: { pc = 0x1da96c; break; }
        case 43: { pc = 0x1da983; break; }
        case 44: { pc = 0x1da99a; break; }
        case 45: { pc = 0x1daa69; break; }
        case 46: { pc = 0x1daa7c; break; }
        case 47: { pc = 0x1daa8f; break; }
        case 48: { pc = 0x1da9b1; break; }
        case 49: { pc = 0x1da9c8; break; }
        case 50: { pc = 0x1da9df; break; }
        case 51: { pc = 0x1da9f6; break; }
        default:
            stop("ind 0160:1da3e7");
    }
    break;
    // gap 1 bytes // gap 1 bytes
  case 0x1da3f0: // 0160:1da3f0
    r8[dl] = r8[bl];
    r8[bl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4 + 0x3);
    r32[ebx] = ror32(r32[ebx], 0x08);
    r8[ah]--;
    if (!r8[ah])
        { pc = 0x1da3d7; break; }
    r8[dl] = r8[bl];
    r8[dl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4);
    switch (r32[edx])
    {
        case 1: { pc = 0x1da455; break; }
        case 2: { pc = 0x1da43e; break; }
        case 3: { pc = 0x1da424; break; }
        case 4: { pc = 0x1da46d; break; }
        case 5: { pc = 0x1da47c; break; }
        case 6: { pc = 0x1da48b; break; }
        case 7: { pc = 0x1da49a; break; }
        case 8: { pc = 0x1da51c; break; }
        case 9: { pc = 0x1da533; break; }
        case 10: { pc = 0x1da54a; break; }
        case 11: { pc = 0x1da561; break; }
        case 12: { pc = 0x1da578; break; }
        case 13: { pc = 0x1da58f; break; }
        case 14: { pc = 0x1da5a6; break; }
        case 15: { pc = 0x1da5bd; break; }
        case 16: { pc = 0x1da6ba; break; }
        case 17: { pc = 0x1da6d1; break; }
        case 18: { pc = 0x1da6e8; break; }
        case 19: { pc = 0x1da6ff; break; }
        case 20: { pc = 0x1da716; break; }
        case 21: { pc = 0x1da72d; break; }
        case 22: { pc = 0x1da744; break; }
        case 23: { pc = 0x1da75b; break; }
        case 24: { pc = 0x1da772; break; }
        case 25: { pc = 0x1da789; break; }
        case 26: { pc = 0x1da7a0; break; }
        case 27: { pc = 0x1da7b7; break; }
        case 28: { pc = 0x1da7ce; break; }
        case 29: { pc = 0x1daa0d; break; }
        case 30: { pc = 0x1daa24; break; }
        case 31: { pc = 0x1daa3b; break; }
        case 32: { pc = 0x1da886; break; }
        case 33: { pc = 0x1da89d; break; }
        case 34: { pc = 0x1da8b4; break; }
        case 35: { pc = 0x1da8cb; break; }
        case 36: { pc = 0x1da8e2; break; }
        case 37: { pc = 0x1da8f9; break; }
        case 38: { pc = 0x1da910; break; }
        case 39: { pc = 0x1da927; break; }
        case 40: { pc = 0x1da93e; break; }
        case 41: { pc = 0x1da955; break; }
        case 42: { pc = 0x1da96c; break; }
        case 43: { pc = 0x1da983; break; }
        case 44: { pc = 0x1da99a; break; }
        case 45: { pc = 0x1daa69; break; }
        case 46: { pc = 0x1daa7c; break; }
        case 47: { pc = 0x1daa8f; break; }
        case 48: { pc = 0x1da9b1; break; }
        case 49: { pc = 0x1da9c8; break; }
        case 50: { pc = 0x1da9df; break; }
        case 51: { pc = 0x1da9f6; break; }
        default:
            stop("ind 0160:1da402");
    }
    break;
  case 0x1da40a: // 0160:1da40a
    r8[dl] = r8[bl];
    r8[bl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4 + 0x2);
    r32[ebx] = ror32(r32[ebx], 0x08);
    r8[ah]--;
    if (!r8[ah])
        { pc = 0x1da3d7; break; }
    r8[dl] = r8[bl];
    r8[dl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4);
    switch (r32[edx])
    {
        case 1: { pc = 0x1da455; break; }
        case 2: { pc = 0x1da43e; break; }
        case 3: { pc = 0x1da424; break; }
        case 4: { pc = 0x1da46d; break; }
        case 5: { pc = 0x1da47c; break; }
        case 6: { pc = 0x1da48b; break; }
        case 7: { pc = 0x1da49a; break; }
        case 8: { pc = 0x1da51c; break; }
        case 9: { pc = 0x1da533; break; }
        case 10: { pc = 0x1da54a; break; }
        case 11: { pc = 0x1da561; break; }
        case 12: { pc = 0x1da578; break; }
        case 13: { pc = 0x1da58f; break; }
        case 14: { pc = 0x1da5a6; break; }
        case 15: { pc = 0x1da5bd; break; }
        case 16: { pc = 0x1da6ba; break; }
        case 17: { pc = 0x1da6d1; break; }
        case 18: { pc = 0x1da6e8; break; }
        case 19: { pc = 0x1da6ff; break; }
        case 20: { pc = 0x1da716; break; }
        case 21: { pc = 0x1da72d; break; }
        case 22: { pc = 0x1da744; break; }
        case 23: { pc = 0x1da75b; break; }
        case 24: { pc = 0x1da772; break; }
        case 25: { pc = 0x1da789; break; }
        case 26: { pc = 0x1da7a0; break; }
        case 27: { pc = 0x1da7b7; break; }
        case 28: { pc = 0x1da7ce; break; }
        case 29: { pc = 0x1daa0d; break; }
        case 30: { pc = 0x1daa24; break; }
        case 31: { pc = 0x1daa3b; break; }
        case 32: { pc = 0x1da886; break; }
        case 33: { pc = 0x1da89d; break; }
        case 34: { pc = 0x1da8b4; break; }
        case 35: { pc = 0x1da8cb; break; }
        case 36: { pc = 0x1da8e2; break; }
        case 37: { pc = 0x1da8f9; break; }
        case 38: { pc = 0x1da910; break; }
        case 39: { pc = 0x1da927; break; }
        case 40: { pc = 0x1da93e; break; }
        case 41: { pc = 0x1da955; break; }
        case 42: { pc = 0x1da96c; break; }
        case 43: { pc = 0x1da983; break; }
        case 44: { pc = 0x1da99a; break; }
        case 45: { pc = 0x1daa69; break; }
        case 46: { pc = 0x1daa7c; break; }
        case 47: { pc = 0x1daa8f; break; }
        case 48: { pc = 0x1da9b1; break; }
        case 49: { pc = 0x1da9c8; break; }
        case 50: { pc = 0x1da9df; break; }
        case 51: { pc = 0x1da9f6; break; }
        default:
            stop("ind 0160:1da41c");
    }
    break;
  case 0x1da424: // 0160:1da424
    r8[dl] = r8[bl];
    r8[bl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4 + 0x1);
    r32[ebx] = ror32(r32[ebx], 0x08);
    r8[ah]--;
    if (!r8[ah])
        { pc = 0x1da3d7; break; }
    r8[dl] = r8[bl];
    r8[dl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4);
    switch (r32[edx])
    {
        case 1: { pc = 0x1da455; break; }
        case 2: { pc = 0x1da43e; break; }
        case 3: { pc = 0x1da424; break; }
        case 4: { pc = 0x1da46d; break; }
        case 5: { pc = 0x1da47c; break; }
        case 6: { pc = 0x1da48b; break; }
        case 7: { pc = 0x1da49a; break; }
        case 8: { pc = 0x1da51c; break; }
        case 9: { pc = 0x1da533; break; }
        case 10: { pc = 0x1da54a; break; }
        case 11: { pc = 0x1da561; break; }
        case 12: { pc = 0x1da578; break; }
        case 13: { pc = 0x1da58f; break; }
        case 14: { pc = 0x1da5a6; break; }
        case 15: { pc = 0x1da5bd; break; }
        case 16: { pc = 0x1da6ba; break; }
        case 17: { pc = 0x1da6d1; break; }
        case 18: { pc = 0x1da6e8; break; }
        case 19: { pc = 0x1da6ff; break; }
        case 20: { pc = 0x1da716; break; }
        case 21: { pc = 0x1da72d; break; }
        case 22: { pc = 0x1da744; break; }
        case 23: { pc = 0x1da75b; break; }
        case 24: { pc = 0x1da772; break; }
        case 25: { pc = 0x1da789; break; }
        case 26: { pc = 0x1da7a0; break; }
        case 27: { pc = 0x1da7b7; break; }
        case 28: { pc = 0x1da7ce; break; }
        case 29: { pc = 0x1daa0d; break; }
        case 30: { pc = 0x1daa24; break; }
        case 31: { pc = 0x1daa3b; break; }
        case 32: { pc = 0x1da886; break; }
        case 33: { pc = 0x1da89d; break; }
        case 34: { pc = 0x1da8b4; break; }
        case 35: { pc = 0x1da8cb; break; }
        case 36: { pc = 0x1da8e2; break; }
        case 37: { pc = 0x1da8f9; break; }
        case 38: { pc = 0x1da910; break; }
        case 39: { pc = 0x1da927; break; }
        case 40: { pc = 0x1da93e; break; }
        case 41: { pc = 0x1da955; break; }
        case 42: { pc = 0x1da96c; break; }
        case 43: { pc = 0x1da983; break; }
        case 44: { pc = 0x1da99a; break; }
        case 45: { pc = 0x1daa69; break; }
        case 46: { pc = 0x1daa7c; break; }
        case 47: { pc = 0x1daa8f; break; }
        case 48: { pc = 0x1da9b1; break; }
        case 49: { pc = 0x1da9c8; break; }
        case 50: { pc = 0x1da9df; break; }
        case 51: { pc = 0x1da9f6; break; }
        default:
            stop("ind 0160:1da436");
    }
    break;
  case 0x1da43e: // 0160:1da43e
    r8[bl] = memoryAGet(ds, r32[esi]);
    r32[esi]++;
    r32[ebx] = ror32(r32[ebx], 0x08);
    r8[ah]--;
    if (!r8[ah])
        { pc = 0x1da3d7; break; }
    r8[dl] = r8[bl];
    r8[dl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4);
    switch (r32[edx])
    {
        case 1: { pc = 0x1da455; break; }
        case 2: { pc = 0x1da43e; break; }
        case 3: { pc = 0x1da424; break; }
        case 4: { pc = 0x1da46d; break; }
        case 5: { pc = 0x1da47c; break; }
        case 6: { pc = 0x1da48b; break; }
        case 7: { pc = 0x1da49a; break; }
        case 8: { pc = 0x1da51c; break; }
        case 9: { pc = 0x1da533; break; }
        case 10: { pc = 0x1da54a; break; }
        case 11: { pc = 0x1da561; break; }
        case 12: { pc = 0x1da578; break; }
        case 13: { pc = 0x1da58f; break; }
        case 14: { pc = 0x1da5a6; break; }
        case 15: { pc = 0x1da5bd; break; }
        case 16: { pc = 0x1da6ba; break; }
        case 17: { pc = 0x1da6d1; break; }
        case 18: { pc = 0x1da6e8; break; }
        case 19: { pc = 0x1da6ff; break; }
        case 20: { pc = 0x1da716; break; }
        case 21: { pc = 0x1da72d; break; }
        case 22: { pc = 0x1da744; break; }
        case 23: { pc = 0x1da75b; break; }
        case 24: { pc = 0x1da772; break; }
        case 25: { pc = 0x1da789; break; }
        case 26: { pc = 0x1da7a0; break; }
        case 27: { pc = 0x1da7b7; break; }
        case 28: { pc = 0x1da7ce; break; }
        case 29: { pc = 0x1daa0d; break; }
        case 30: { pc = 0x1daa24; break; }
        case 31: { pc = 0x1daa3b; break; }
        case 32: { pc = 0x1da886; break; }
        case 33: { pc = 0x1da89d; break; }
        case 34: { pc = 0x1da8b4; break; }
        case 35: { pc = 0x1da8cb; break; }
        case 36: { pc = 0x1da8e2; break; }
        case 37: { pc = 0x1da8f9; break; }
        case 38: { pc = 0x1da910; break; }
        case 39: { pc = 0x1da927; break; }
        case 40: { pc = 0x1da93e; break; }
        case 41: { pc = 0x1da955; break; }
        case 42: { pc = 0x1da96c; break; }
        case 43: { pc = 0x1da983; break; }
        case 44: { pc = 0x1da99a; break; }
        case 45: { pc = 0x1daa69; break; }
        case 46: { pc = 0x1daa7c; break; }
        case 47: { pc = 0x1daa8f; break; }
        case 48: { pc = 0x1da9b1; break; }
        case 49: { pc = 0x1da9c8; break; }
        case 50: { pc = 0x1da9df; break; }
        case 51: { pc = 0x1da9f6; break; }
        default:
            stop("ind 0160:1da44d");
    }
    break;
  case 0x1da455: // 0160:1da455
    r32[ebx] = ror32(r32[ebx], 0x08);
    r8[ah]--;
    if (!r8[ah])
        { pc = 0x1da3d7; break; }
    r8[dl] = r8[bl];
    r8[dl] = memoryAGet(ds, r32[ecx] + r32[edx] * 4);
    switch (r32[edx])
    {
        case 1: { pc = 0x1da455; break; }
        case 2: { pc = 0x1da43e; break; }
        case 3: { pc = 0x1da424; break; }
        case 4: { pc = 0x1da46d; break; }
        case 5: { pc = 0x1da47c; break; }
        case 6: { pc = 0x1da48b; break; }
        case 7: { pc = 0x1da49a; break; }
        case 8: { pc = 0x1da51c; break; }
        case 9: { pc = 0x1da533; break; }
        case 10: { pc = 0x1da54a; break; }
        case 11: { pc = 0x1da561; break; }
        case 12: { pc = 0x1da578; break; }
        case 13: { pc = 0x1da58f; break; }
        case 14: { pc = 0x1da5a6; break; }
        case 15: { pc = 0x1da5bd; break; }
        case 16: { pc = 0x1da6ba; break; }
        case 17: { pc = 0x1da6d1; break; }
        case 18: { pc = 0x1da6e8; break; }
        case 19: { pc = 0x1da6ff; break; }
        case 20: { pc = 0x1da716; break; }
        case 21: { pc = 0x1da72d; break; }
        case 22: { pc = 0x1da744; break; }
        case 23: { pc = 0x1da75b; break; }
        case 24: { pc = 0x1da772; break; }
        case 25: { pc = 0x1da789; break; }
        case 26: { pc = 0x1da7a0; break; }
        case 27: { pc = 0x1da7b7; break; }
        case 28: { pc = 0x1da7ce; break; }
        case 29: { pc = 0x1daa0d; break; }
        case 30: { pc = 0x1daa24; break; }
        case 31: { pc = 0x1daa3b; break; }
        case 32: { pc = 0x1da886; break; }
        case 33: { pc = 0x1da89d; break; }
        case 34: { pc = 0x1da8b4; break; }
        case 35: { pc = 0x1da8cb; break; }
        case 36: { pc = 0x1da8e2; break; }
        case 37: { pc = 0x1da8f9; break; }
        case 38: { pc = 0x1da910; break; }
        case 39: { pc = 0x1da927; break; }
        case 40: { pc = 0x1da93e; break; }
        case 41: { pc = 0x1da955; break; }
        case 42: { pc = 0x1da96c; break; }
        case 43: { pc = 0x1da983; break; }
        case 44: { pc = 0x1da99a; break; }
        case 45: { pc = 0x1daa69; break; }
        case 46: { pc = 0x1daa7c; break; }
        case 47: { pc = 0x1daa8f; break; }
        case 48: { pc = 0x1da9b1; break; }
        case 49: { pc = 0x1da9c8; break; }
        case 50: { pc = 0x1da9df; break; }
        case 51: { pc = 0x1da9f6; break; }
        default:
            stop("ind 0160:1da465");
    }
    break;
  case 0x1da46d: // 0160:1da46d
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da46f: // 0160:1da46f
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da43e; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da46f; break; }
  case 0x1da47c: // 0160:1da47c
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da47e: // 0160:1da47e
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da424; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da47e; break; }
  case 0x1da48b: // 0160:1da48b
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da48d: // 0160:1da48d
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da424; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da48d; break; }
  case 0x1da49a: // 0160:1da49a
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da49c: // 0160:1da49c
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da40a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da49c; break; }
  case 0x1da4ad: // 0160:1da4ad
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da4af: // 0160:1da4af
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da40a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da4af; break; }
  case 0x1da4c0: // 0160:1da4c0
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da4c2: // 0160:1da4c2
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da40a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da4c2; break; }
  case 0x1da4d7: // 0160:1da4d7
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da4d9: // 0160:1da4d9
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da3f0; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da4d9; break; }
  case 0x1da4ee: // 0160:1da4ee
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da4f0: // 0160:1da4f0
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da3f0; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da4f0; break; }
  case 0x1da505: // 0160:1da505
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da507: // 0160:1da507
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da3f0; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da507; break; }
  case 0x1da51c: // 0160:1da51c
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da51e: // 0160:1da51e
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da48b; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da51e; break; }
  case 0x1da533: // 0160:1da533
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da535: // 0160:1da535
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da49a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da535; break; }
  case 0x1da54a: // 0160:1da54a
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da54c: // 0160:1da54c
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da47c; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da54c; break; }
  case 0x1da561: // 0160:1da561
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da563: // 0160:1da563
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da49a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da563; break; }
  case 0x1da578: // 0160:1da578
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da57a: // 0160:1da57a
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da46d; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da57a; break; }
  case 0x1da58f: // 0160:1da58f
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da591: // 0160:1da591
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da4ad; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da591; break; }
  case 0x1da5a6: // 0160:1da5a6
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da5a8: // 0160:1da5a8
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da4c0; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da5a8; break; }
  case 0x1da5bd: // 0160:1da5bd
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da5bf: // 0160:1da5bf
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da4d7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da5bf; break; }
  case 0x1da5d4: // 0160:1da5d4
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da5d6: // 0160:1da5d6
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da4c0; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da5d6; break; }
  case 0x1da5eb: // 0160:1da5eb
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da5ed: // 0160:1da5ed
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da4d7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da5ed; break; }
  case 0x1da602: // 0160:1da602
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da604: // 0160:1da604
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da4ad; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da604; break; }
  case 0x1da619: // 0160:1da619
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da61b: // 0160:1da61b
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da4d7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da61b; break; }
  case 0x1da630: // 0160:1da630
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da632: // 0160:1da632
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da46d; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da632; break; }
  case 0x1da647: // 0160:1da647
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da649: // 0160:1da649
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da4ee; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da649; break; }
  case 0x1da65e: // 0160:1da65e
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da660: // 0160:1da660
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da505; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da660; break; }
  case 0x1da675: // 0160:1da675
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da677: // 0160:1da677
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da505; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da677; break; }
  case 0x1da68c: // 0160:1da68c
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da68e: // 0160:1da68e
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da4ee; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da68e; break; }
  case 0x1da6a3: // 0160:1da6a3
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da6a5: // 0160:1da6a5
    if (!flags.carry)
        { pc = 0x1da3f0; break; }
    if (!flags.zero)
        { pc = 0x1da46d; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da6a5; break; }
  case 0x1da6ba: // 0160:1da6ba
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da6bc: // 0160:1da6bc
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da561; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da6bc; break; }
  case 0x1da6d1: // 0160:1da6d1
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da6d3: // 0160:1da6d3
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da5a6; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da6d3; break; }
  case 0x1da6e8: // 0160:1da6e8
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da6ea: // 0160:1da6ea
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da5bd; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da6ea; break; }
  case 0x1da6ff: // 0160:1da6ff
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da701: // 0160:1da701
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da533; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da701; break; }
  case 0x1da716: // 0160:1da716
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da718: // 0160:1da718
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da58f; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da718; break; }
  case 0x1da72d: // 0160:1da72d
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da72f: // 0160:1da72f
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da5bd; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da72f; break; }
  case 0x1da744: // 0160:1da744
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da746: // 0160:1da746
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da5d4; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da746; break; }
  case 0x1da75b: // 0160:1da75b
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da75d: // 0160:1da75d
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da5eb; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da75d; break; }
  case 0x1da772: // 0160:1da772
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da774: // 0160:1da774
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da602; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da774; break; }
  case 0x1da789: // 0160:1da789
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da78b: // 0160:1da78b
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da619; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da78b; break; }
  case 0x1da7a0: // 0160:1da7a0
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da7a2: // 0160:1da7a2
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da630; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da7a2; break; }
  case 0x1da7b7: // 0160:1da7b7
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da7b9: // 0160:1da7b9
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da647; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da7b9; break; }
  case 0x1da7ce: // 0160:1da7ce
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da7d0: // 0160:1da7d0
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da65e; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da7d0; break; }
  case 0x1da7e5: // 0160:1da7e5
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da7e7: // 0160:1da7e7
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da619; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da7e7; break; }
  case 0x1da7fc: // 0160:1da7fc
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da7fe: // 0160:1da7fe
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da65e; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da7fe; break; }
  case 0x1da813: // 0160:1da813
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da815: // 0160:1da815
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da5eb; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da815; break; }
  case 0x1da82a: // 0160:1da82a
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da82c: // 0160:1da82c
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da647; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da82c; break; }
  case 0x1da841: // 0160:1da841
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da843: // 0160:1da843
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da675; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da843; break; }
  case 0x1da858: // 0160:1da858
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da85a: // 0160:1da85a
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da68c; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da85a; break; }
  case 0x1da86f: // 0160:1da86f
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da871: // 0160:1da871
    if (!flags.carry)
        { pc = 0x1da40a; break; }
    if (!flags.zero)
        { pc = 0x1da6a3; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da871; break; }
  case 0x1da886: // 0160:1da886
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da888: // 0160:1da888
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da72d; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da888; break; }
  case 0x1da89d: // 0160:1da89d
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da89f: // 0160:1da89f
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da789; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da89f; break; }
  case 0x1da8b4: // 0160:1da8b4
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da8b6: // 0160:1da8b6
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1da7ce; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da8b6; break; }
  case 0x1da8cb: // 0160:1da8cb
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da8cd: // 0160:1da8cd
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da6e8; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da8cd; break; }
  case 0x1da8e2: // 0160:1da8e2
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da8e4: // 0160:1da8e4
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da75b; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da8e4; break; }
  case 0x1da8f9: // 0160:1da8f9
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da8fb: // 0160:1da8fb
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1da7b7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da8fb; break; }
  case 0x1da910: // 0160:1da910
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da912: // 0160:1da912
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da7e5; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da912; break; }
  case 0x1da927: // 0160:1da927
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da929: // 0160:1da929
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da7fc; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da929; break; }
  case 0x1da93e: // 0160:1da93e
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da940: // 0160:1da940
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da813; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da940; break; }
  case 0x1da955: // 0160:1da955
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da957: // 0160:1da957
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da82a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da957; break; }
  case 0x1da96c: // 0160:1da96c
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da96e: // 0160:1da96e
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da841; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da96e; break; }
  case 0x1da983: // 0160:1da983
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da985: // 0160:1da985
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da858; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da985; break; }
  case 0x1da99a: // 0160:1da99a
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da99c: // 0160:1da99c
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1da86f; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da99c; break; }
  case 0x1da9b1: // 0160:1da9b1
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da9b3: // 0160:1da9b3
    if (!flags.carry)
        { pc = 0x1da46d; break; }
    if (!flags.zero)
        { pc = 0x1da5bd; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da9b3; break; }
  case 0x1da9c8: // 0160:1da9c8
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da9ca: // 0160:1da9ca
    if (!flags.carry)
        { pc = 0x1da47c; break; }
    if (!flags.zero)
        { pc = 0x1da65e; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da9ca; break; }
  case 0x1da9df: // 0160:1da9df
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da9e1: // 0160:1da9e1
    if (!flags.carry)
        { pc = 0x1da48b; break; }
    if (!flags.zero)
        { pc = 0x1da647; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da9e1; break; }
  case 0x1da9f6: // 0160:1da9f6
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1da9f8: // 0160:1da9f8
    if (!flags.carry)
        { pc = 0x1da49a; break; }
    if (!flags.zero)
        { pc = 0x1da6a3; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1da9f8; break; }
  case 0x1daa0d: // 0160:1daa0d
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa0f: // 0160:1daa0f
    if (!flags.carry)
        { pc = 0x1da46d; break; }
    if (!flags.zero)
        { pc = 0x1da49a; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa0f; break; }
  case 0x1daa24: // 0160:1daa24
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa26: // 0160:1daa26
    if (!flags.carry)
        { pc = 0x1da47c; break; }
    if (!flags.zero)
        { pc = 0x1da4d7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa26; break; }
  case 0x1daa3b: // 0160:1daa3b
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa3d: // 0160:1daa3d
    if (!flags.carry)
        { pc = 0x1da48b; break; }
    if (!flags.zero)
        { pc = 0x1da4d7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa3d; break; }
  case 0x1daa52: // 0160:1daa52
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa54: // 0160:1daa54
    if (!flags.carry)
        { pc = 0x1da46d; break; }
    if (!flags.zero)
        { pc = 0x1da4d7; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa54; break; }
  case 0x1daa69: // 0160:1daa69
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa6b: // 0160:1daa6b
    if (!flags.carry)
        { pc = 0x1da455; break; }
    if (!flags.zero)
        { pc = 0x1daa3b; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa6b; break; }
  case 0x1daa7c: // 0160:1daa7c
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa7e: // 0160:1daa7e
    if (!flags.carry)
        { pc = 0x1da43e; break; }
    if (!flags.zero)
        { pc = 0x1daa24; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa7e; break; }
  case 0x1daa8f: // 0160:1daa8f
    flags.carry = overflow32(r32[ebp], r32[ebp]);
    r32[ebp] += r32[ebp];
    flags.zero = r32[ebp] == 0;
  case 0x1daa91: // 0160:1daa91
    if (!flags.carry)
        { pc = 0x1da424; break; }
    if (!flags.zero)
        { pc = 0x1daa52; break; }
    r32[ebp] = memoryAGet32(ds, r32[esi]);
    r32[esi] = r32[esi] + 4;
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[ebp], r32[ebp], flags.carry);
    r32[ebp] += (r32[ebp] + flags.carry);
    flags.carry = temp_cf; flags.zero = r32[ebp] == 0;
    { pc = 0x1daa91; break; }
    return;
  }
}
function* sub_1daab0() // 0160:1daab0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = r32[eax];
    memoryASet32(ds, 0x30b194, 0x00001510);
    r32[eax] = memoryAGet32(ds, 0x30b298);
    memoryASet32(ds, 0x30b190, r32[eax]);
    r32[eax] = r32[esi];
    r32[eax] &= 0x0000000f;
    memoryASet32(ds, 0x30b188, r32[eax]);
    r32[eax] = r32[esi];
    r32[eax] = sar32(r32[eax], 0x04);
    memoryASet16(ds, 0x30b19a, r16[ax]);
    memoryASet16(ds, 0x30b1ac, 0x0300);
    memoryASet(ds, 0x30b1b0, 0x2f);
    r8[dl] = 0;
    memoryASet(ds, 0x30b1b1, r8[dl]);
    r32[ebx] = 0;
    memoryASet16(ds, 0x30b1b4, r16[bx]);
    r32[edx] = ds;
    r32[eax] = 0x0030b178;
    memoryASet16(ds, 0x30b1c8, r16[dx]);
    memoryASet32(ds, 0x30b1c0, 0x0030b178);
    r32[edi] = 0x0030b1ac;
  case 0x1dab1e: // 0160:1dab1e
    r32[ecx] = 0x0030b1c8;
    r32[ebx] = r32[edi];
    r32[edx] = r32[edi];
    r32[eax] = 0x00000031;
    yield* sub_1e39c0();
    r16[ax] = memoryAGet16(ds, r32[esi] + 0x3);
    r8[al] = 0;
    r8[ah] &= 0x01;
    r32[eax] &= 0x0000ffff;
    if (!r32[eax])
        { pc = 0x1dab1e; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dab50() // 0160:1dab50 +long
{
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet(ds, r32[ecx], r8[al]);
    r32[ecx] = r32[eax];
    r32[ecx] &= 0x0000ff00;
    r32[ecx] >>>= 8;
    memoryASet32(ss, r32[ebp] - 4, r32[ecx]);
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    memoryASet(ds, r32[ebx], r8[cl]);
    r32[eax] &= 0x00ff0000;
    r32[eax] >>>= 16;
    memoryASet(ds, r32[edx], r8[al]);
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esp] += 4;
}
function* sub_1dab80() // 0160:1dab80 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    r32[ecx] = r32[ebp] - 4;
    r32[ebx] = r32[ebp] - 8;
    r32[edx] = r32[ebp] - 12;
    yield* sub_1dab50();
    r32[edx] = 0;
    r8[dl] = memoryAGet(ss, r32[ebp] - 12);
    r32[eax] = r32[edx];
    r32[eax] <<= 5;
    r32[eax] -= r32[edx];
    r32[eax] = (r32[eax] * 4) + 0;
    r32[eax] += r32[edx];
    r32[eax] = (r32[eax] * 4) + 0;
    r32[edx] = r32[eax];
    r32[eax] = (r32[eax] * 8) + 0;
    r32[eax] += r32[edx];
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ss, r32[ebp] - 8);
    r32[edx] = (r32[ebx] * 4) + 0;
    r32[edx] += r32[ebx];
    r32[ebx] = r32[edx];
    r32[edx] <<= 4;
    r32[edx] -= r32[ebx];
    r32[eax] += r32[edx];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ss, r32[ebp] - 4);
    r32[edx] -= 0x00000096;
    r32[eax] += r32[edx];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dabf0() // 0160:1dabf0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x04);
    r32[edx] <<= 16;
    r32[eax] &= 0x0000000f;
    r32[eax] += r32[edx];
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dac00() // 0160:1dac00 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax], 0x1e);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r8[dl] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[eax] + 0x1, r8[dl]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0x2, 0x03);
    r32[edx] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[edx] + 0x16, 0x00000000);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[dx] = memoryAGet16(ds, r32[edx] + 0x16);
    memoryASet16(ds, r32[eax] + 0x14, r16[dx]);
    r32[edx] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, r32[eax] + 0x14);
    memoryASet(ds, r32[edx] + 0xd, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b268);
    yield* sub_1dabf0();
    r32[edx] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[edx] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet16(ds, r32[eax] + 0x12, 0x0006);
    r32[eax] = memoryAGet32(ds, 0x30b268);
    memoryASet(ds, r32[eax], 0x01);
    r32[eax] = memoryAGet32(ds, 0x30b268);
    memoryASet(ds, r32[eax] + 0x1, 0x00);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x30b268);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x2);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1daca0() // 0160:1daca0 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edi] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30b238);
    memoryASet(ds, r32[eax], 0x04);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax], 0x1e);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r8[dl] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[eax] + 0x1, r8[dl]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0x2, 0x03);
    r32[esi] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[esi] + 0x16, 0x00000000);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[si] = memoryAGet16(ds, r32[esi] + 0x16);
    memoryASet16(ds, r32[eax] + 0x14, r16[si]);
    r32[esi] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, r32[eax] + 0x14);
    memoryASet(ds, r32[esi] + 0xd, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b238);
    yield* sub_1dabf0();
    r32[esi] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[esi] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet16(ds, r32[eax] + 0x12, 0x0009);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[esi] = memoryAGet32(ds, 0x30b238);
    r32[ecx] = 0x00000009;
    push32(r32[edi]);
    r32[eax] = r32[ecx];
    r32[ecx] >>>= 2;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsd_ESEDI_DSESI();
    r8[cl] = r8[al];
    r8[cl] &= 0x03;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1dad50() // 0160:1dad50 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edi] = memoryAGet32(ds, 0x30b238);
    r32[ecx] = 0x00000009;
    r32[esi] = r32[eax];
    push32(r32[edi]);
    r32[eax] = r32[ecx];
    r32[ecx] >>>= 2;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsd_ESEDI_DSESI();
    r8[cl] = r8[al];
    r8[cl] &= 0x03;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r32[eax] = memoryAGet32(ds, 0x30b238);
    memoryASet(ds, r32[eax], 0x03);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax], 0x1e);
    r32[edi] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0x2, 0x0c);
    r32[edi] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[edi] + 0x16, 0x00000000);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[di] = memoryAGet16(ds, r32[edi] + 0x16);
    memoryASet16(ds, r32[eax] + 0x14, r16[di]);
    r32[edi] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, r32[eax] + 0x14);
    memoryASet(ds, r32[edi] + 0xd, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b238);
    yield* sub_1dabf0();
    r32[edi] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[edi] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet16(ds, r32[eax] + 0x12, 0x0009);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1dae00() // 0160:1dae00 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    memoryASet(ds, r32[eax], 0x1a);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    r8[dl] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[eax] + 0x1, r8[dl]);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    memoryASet(ds, r32[eax] + 0x2, 0x03);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    memoryASet(ds, r32[eax] + 0xd, 0x00);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    memoryASet16(ds, r32[eax] + 0x14, 0x0000);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    memoryASet32(ds, r32[eax] + 0x16, 0x00000000);
    r32[eax] = memoryAGet32(ds, 0x30b274);
    yield* sub_1dabf0();
    r32[esi] = memoryAGet32(ds, 0x30b270);
    memoryASet32(ds, r32[esi] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    memoryASet16(ds, r32[eax] + 0x12, 0x0007);
    r32[eax] = memoryAGet32(ds, 0x30b274);
    memoryASet(ds, r32[eax], 0x0a);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    yield* sub_1daab0();
    r32[esi] = memoryAGet32(ds, 0x30b274);
    r32[esi]++;
    r32[ecx] = 0x00000006;
    r32[edi] = 0x0030b255;
    push32(r32[edi]);
    r32[eax] = r32[ecx];
    r32[ecx] >>>= 2;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsd_ESEDI_DSESI();
    r8[cl] = r8[al];
    r8[cl] &= 0x03;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    r32[eax] = memoryAGet32(ds, 0x30b274);
    r8[dl] = memoryAGet(ds, r32[eax] + 0x1);
    memoryASet(ds, 0x30b245, r8[dl]);
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2);
    memoryASet(ds, 0x30b246, r8[dl]);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x3);
    r32[ecx] = 0x0030b249;
    r32[ebx] = 0x0030b248;
    r32[edx] = 0x0030b247;
    yield* sub_1dab50();
    r32[eax] = memoryAGet32(ds, 0x30b274);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x3);
    yield* sub_1dab80();
    memoryASet32(ds, 0x30b24a, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b270);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1daef0() // 0160:1daef0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax], 0x1e);
    r32[ebx] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[ebx] + 0x1, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0x2, 0x03);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0xd, 0x00);
    r32[ebx] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[ebx] + 0x16, 0x00000000);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[bx] = memoryAGet16(ds, r32[ebx] + 0x16);
    memoryASet16(ds, r32[eax] + 0x14, r16[bx]);
    r32[ebx] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, r32[eax] + 0x14);
    memoryASet(ds, r32[ebx] + 0xd, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b278);
    yield* sub_1dabf0();
    r32[ebx] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[ebx] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet16(ds, r32[eax] + 0x12, 0x0007);
    r32[eax] = memoryAGet32(ds, 0x30b278);
    memoryASet(ds, r32[eax], 0x0b);
    r32[eax] = memoryAGet32(ds, 0x30b278);
    memoryASet(ds, r32[eax] + 0x1, r8[dl]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[eax] = memoryAGet32(ds, 0x30b278);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x2);
    yield* sub_1dab80();
    memoryASet32(ds, 0x30b240, r32[eax]);
    memoryASet16(ds, 0x30b23e, r16[dx]);
    r32[eax] = memoryAGet32(ds, 0x30b278);
    r8[al] = memoryAGet(ds, r32[eax] + 0x6);
    r8[al] &= 0xd0;
    memoryASet(ds, 0x30b244, r8[al]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dafc0() // 0160:1dafc0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = memoryAGet32(ds, 0x30b288);
    memoryASet(ds, r32[ebx], 0x16);
    r32[ecx] = memoryAGet32(ds, 0x30b288);
    r8[bl] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[ecx] + 0x1, r8[bl]);
    r32[ebx] = memoryAGet32(ds, 0x30b288);
    memoryASet(ds, r32[ebx] + 0x2, 0x84);
    r32[ebx] = memoryAGet32(ds, 0x30b288);
    memoryASet(ds, r32[ebx] + 0xd, 0x00);
    r32[ebx] = memoryAGet32(ds, 0x30b288);
    memoryASet32(ds, r32[ebx] + 0xe, r32[eax]);
    r32[edx] -= r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30b288);
    memoryASet32(ds, r32[eax] + 0x12, r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x30b288);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b288);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1db020() // 0160:1db020 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x30b28c);
    memoryASet(ds, r32[eax], 0x0d);
    r32[edx] = memoryAGet32(ds, 0x30b28c);
    r8[al] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[edx] + 0x1, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b28c);
    memoryASet(ds, r32[eax] + 0x2, 0x85);
    r32[eax] = memoryAGet32(ds, 0x30b28c);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b28c);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1db060() // 0160:1db060 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x30b290);
    memoryASet(ds, r32[edx], r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax], 0x1e);
    r32[edx] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[edx] + 0x1, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0x2, 0x0c);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0xd, 0x00);
    r32[eax] = memoryAGet32(ds, 0x30b290);
    yield* sub_1dabf0();
    r32[edx] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[edx] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet16(ds, r32[eax] + 0x12, 0x0001);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1db0d0() // 0160:1db0d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    memoryASet32(ds, 0x30b1f0, 0x00001500);
    r32[ebx] = 0;
    memoryASet32(ds, 0x30b1e4, r32[ebx]);
    memoryASet16(ds, 0x30b208, 0x0300);
    memoryASet(ds, 0x30b20c, 0x2f);
    r8[dl] = 0;
    memoryASet(ds, 0x30b20d, r8[dl]);
    r32[ebx] = 0;
    memoryASet16(ds, 0x30b210, r16[bx]);
    r32[edx] = ds;
    r32[eax] = 0x0030b1d4;
    memoryASet16(ds, 0x30b224, r16[dx]);
    memoryASet32(ds, 0x30b21c, 0x0030b1d4);
    r32[ecx] = 0x0030b224;
    r32[ebx] = 0x0030b208;
    r32[edx] = r32[ebx];
    r32[eax] = 0x00000031;
    yield* sub_1e39c0();
    if (memoryAGet16(ds, 0x30b1e4) & 0xffff)
        { pc = 0x1db145; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1db145: // 0160:1db145
    r8[al] = memoryAGet(ds, 0x30b1e4);
    memoryASet(ds, 0x30b23c, r8[al]);
    r8[al] = memoryAGet(ds, 0x30b1ec);
    memoryASet(ds, 0x30b23d, r8[al]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x30b23d);
    memoryASet32(ds, 0x30b298, r32[eax]);
    yield* sub_1dae00();
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db180() // 0160:1db180 +long
{
    r32[esp] -= 4;
    r32[eax] = 0x00000005;
    yield* sub_1db060();
    r16[ax] = memoryAGet16(ds, 0x30b25f);
    r8[al] = 0;
    r8[ah] &= 0x02;
    r32[eax] &= 0x0000ffff;
    r8[al] = r32[eax] == 0;
    r8[ah] = 0;
    r32[esp] += 4;
}
function* sub_1db1a0() // 0160:1db1a0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r8[dl] = r8[al];
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax], 0x1e);
    r32[ebx] = memoryAGet32(ds, 0x30b264);
    r8[al] = memoryAGet(ds, 0x30b294);
    memoryASet(ds, r32[ebx] + 0x1, r8[al]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0x2, 0x0c);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet(ds, r32[eax] + 0xd, 0x00);
    r32[eax] = memoryAGet32(ds, 0x30b280);
    yield* sub_1dabf0();
    r32[ebx] = memoryAGet32(ds, 0x30b264);
    memoryASet32(ds, r32[ebx] + 0xe, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    memoryASet16(ds, r32[eax] + 0x12, 0x0002);
    r32[eax] = memoryAGet32(ds, 0x30b280);
    memoryASet(ds, r32[eax], 0x01);
    r32[eax] = memoryAGet32(ds, 0x30b280);
    memoryASet(ds, r32[eax] + 0x1, r8[dl]);
    r32[eax] = memoryAGet32(ds, 0x30b264);
    yield* sub_1daab0();
    r32[eax] = memoryAGet32(ds, 0x30b264);
    r16[ax] = memoryAGet16(ds, r32[eax] + 0x3);
    memoryASet16(ds, 0x30b25f, r16[ax]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1db220() // 0160:1db220 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
  case 0x1db223: // 0160:1db223
    yield* sub_1dae00();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x30b25f);
    r32[edx]++;
    if (r32[eax] != 0x00008102)
        { pc = 0x1db240; break; }
    if (r32s[edx] < signed32(0x000001f4))
        { pc = 0x1db223; break; }
  case 0x1db240: // 0160:1db240
    if (r32[edx] != 0x000001f4)
        { pc = 0x1db24c; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1db24c: // 0160:1db24c
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x30b246);
    if (r32s[eax] <= signed32(0x0000001e))
        { pc = 0x1db25f; break; }
    memoryASet(ds, 0x30b246, 0x23);
  case 0x1db25f: // 0160:1db25f
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db270() // 0160:1db270 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000001c;
    memoryASet32(ss, r32[ebp] - 28, 0x00000100);
    r32[eax] += 0x0000000f;
    r32[eax] = sar32(r32[eax], 0x04);
    memoryASet32(ss, r32[ebp] - 24, r32[eax]);
    r32[ebx] = r32[ebp] - 28;
    r32[edx] = r32[ebp] - 28;
    r32[eax] = 0x00000031;
    yield* sub_1e39d9();
    if (!memoryAGet32(ss, r32[ebp] - 4))
        { pc = 0x1db2a2; break; }
    r32[eax] = 0;
    { pc = 0x1db2ad; break; }
  case 0x1db2a2: // 0160:1db2a2
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    r32[eax] &= 0x0000ffff;
    r32[eax] <<= 4;
  case 0x1db2ad: // 0160:1db2ad
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db2c0() // 0160:1db2c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    if (memoryAGet32(ds, 0x30b230))
        { pc = 0x1db3aa; break; }
    r32[eax] = 0x0000001e;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b264, r32[eax]);
    r32[eax] = 0x00000006;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b268, r32[eax]);
    r32[eax] = 0x0000000b;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b26c, r32[eax]);
    r32[eax] = 0x0000001a;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b270, r32[eax]);
    r32[eax] = 0x00000007;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b274, r32[eax]);
    r32[eax] = 0x00000007;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b278, r32[eax]);
    r32[eax] = 0x00000005;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b27c, r32[eax]);
    r32[eax] = 0x00000002;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b280, r32[eax]);
    r32[eax] = 0x00000018;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b284, r32[eax]);
    r32[eax] = 0x00000016;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b288, r32[eax]);
    r32[eax] = 0x0000000d;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b28c, r32[eax]);
    r32[eax] = 0x00000001;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b290, r32[eax]);
    r32[eax] = 0x0000000b;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b234, r32[eax]);
    r32[eax] = 0x00000009;
    yield* sub_1db270();
    memoryASet32(ds, 0x30b238, r32[eax]);
    memoryASet32(ds, 0x30b230, 0x00000001);
  case 0x1db3aa: // 0160:1db3aa
    yield* sub_1db0d0();
    if (r16[ax])
        { pc = 0x1db3b8; break; }
    r32[eax] = 0;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1db3b8: // 0160:1db3b8
    r32[ecx] = 0;
    memoryASet32(ds, 0x30b29c, r32[ecx]);
    memoryASet32(ds, 0x30b2a0, r32[ecx]);
    yield* sub_1db180();
    if (r16[ax])
        { pc = 0x1db3da; break; }
    memoryASet32(ds, 0x30b29c, 0x00000001);
  case 0x1db3da: // 0160:1db3da
    r32[eax] = 0x00000001;
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db470() // 0160:1db470 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[edx] = r32[eax];
    yield* sub_1db620();
    r32[ebx] = 0;
    memoryASet32(ds, 0x30b29c, r32[ebx]);
    memoryASet32(ds, 0x30b2a0, r32[ebx]);
    yield* sub_1db220();
    if (!r32[eax])
        { pc = 0x1db540; break; }
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x30b245);
    if (r32s[edx] < r32s[eax])
        { pc = 0x1db4ac; break; }
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x30b246);
    if (r32s[edx] <= r32s[eax])
        { pc = 0x1db4b3; break; }
  case 0x1db4ac: // 0160:1db4ac
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1db4b3: // 0160:1db4b3
    r32[ebx] = r16s[dx];
    r32[eax] = r32[ebx];
    yield* sub_1daef0();
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, 0x30b244);
    if (r32[eax] != 0x00000040)
        { pc = 0x1db4d0; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1db4d0: // 0160:1db4d0
    r32[eax] = memoryAGet32(ds, 0x30b240);
    memoryASet32(ds, 0x2091e0, r32[eax]);
    r32[ecx] = 0;
    r8[cl] = memoryAGet(ds, 0x30b246);
    r32[eax] = r32[edx] + 1;
    if (r32s[eax] <= r32s[ecx])
        { pc = 0x1db4f5; break; }
    r32[eax] = memoryAGet32(ds, 0x30b24a);
    memoryASet32(ds, 0x30b2a4, r32[eax]);
    { pc = 0x1db50f; break; }
  case 0x1db4f5: // 0160:1db4f5
    r32[edx]++;
    r32[eax] = r16s[dx];
    yield* sub_1daef0();
    r32[eax] = memoryAGet32(ds, 0x30b240);
    memoryASet32(ds, 0x30b2a4, r32[eax]);
    r32[eax] = r32[ebx];
    yield* sub_1daef0();
  case 0x1db50f: // 0160:1db50f
    r32[eax] = 0x00000001;
    yield* sub_1db1a0();
    r32[edx] = memoryAGet32(ds, 0x30b2a4);
    r32[eax] = memoryAGet32(ds, 0x2091e0);
    yield* sub_1dafc0();
  case 0x1db529: // 0160:1db529
    yield* sub_1db180();
    if (r16[ax])
        { pc = 0x1db529; break; }
    r32[esi] = 0x00000001;
    memoryASet32(ds, 0x30b29c, r32[esi]);
    r32[eax] = r32[esi];
  case 0x1db540: // 0160:1db540
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db5b0() // 0160:1db5b0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    if (!memoryAGet32(ds, 0x30b29c))
        { pc = 0x1db5e0; break; }
    if (memoryAGet32(ds, 0x30b2a0))
        { pc = 0x1db5e0; break; }
    yield* sub_1dac00();
    memoryASet32(ds, 0x2091dc, r32[eax]);
    r32[edx] = memoryAGet32(ds, 0x30b2a4);
    r32[eax] = r32[edx] - 1;
    yield* sub_1dafc0();
    yield* sub_1db020();
  case 0x1db5e0: // 0160:1db5e0
    memoryASet32(ds, 0x30b2a0, 0x00000001);
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db5f0() // 0160:1db5f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edx]);
    if (!memoryAGet32(ds, 0x30b29c))
        { pc = 0x1db614; break; }
    if (!memoryAGet32(ds, 0x30b2a0))
        { pc = 0x1db614; break; }
    r32[edx] = memoryAGet32(ds, 0x30b2a4);
    r32[eax] = memoryAGet32(ds, 0x2091dc);
    yield* sub_1dafc0();
  case 0x1db614: // 0160:1db614
    r32[ecx] = 0;
    memoryASet32(ds, 0x30b2a0, r32[ecx]);
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db620() // 0160:1db620 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    if (!memoryAGet32(ds, 0x30b29c))
        { pc = 0x1db645; break; }
    r32[edx] = memoryAGet32(ds, 0x30b2a4);
    r32[eax] = r32[edx] - 1;
    yield* sub_1dafc0();
    yield* sub_1db020();
    r32[eax] = 0;
    yield* sub_1db1a0();
  case 0x1db645: // 0160:1db645
    r32[ebx] = 0;
    memoryASet32(ds, 0x30b29c, r32[ebx]);
    memoryASet32(ds, 0x30b2a0, r32[ebx]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db660() // 0160:1db660 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    r32[edx] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1db66f; break; }
    r32[edx] ^= r32[eax];
  case 0x1db66f: // 0160:1db66f
    if (r32s[edx] <= signed32(0x000000ff))
        { pc = 0x1db67c; break; }
    r32[edx] = 0x000000ff;
  case 0x1db67c: // 0160:1db67c
    r32[eax] = r32[ebp] - 12;
    yield* sub_1daca0();
    memoryASet(ss, r32[ebp] - 10, r8[dl]);
    memoryASet(ss, r32[ebp] - 8, r8[dl]);
    memoryASet(ss, r32[ebp] - 6, r8[dl]);
    memoryASet(ss, r32[ebp] - 4, r8[dl]);
    r32[eax] = r32[ebp] - 12;
    yield* sub_1dad50();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db6c0() // 0160:1db6c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[esi] = r32[ebx];
    r32[eax] = 0;
    if (r32s[ebx] <= 0)
        { pc = 0x1db716; break; }
  case 0x1db6d3: // 0160:1db6d3
    r8[bl] = memoryAGet(ds, r32[edx]);
    r8[bl] &= 0x0f;
    r32[ebx] &= 0x000000ff;
    r8[bl] = memoryAGet(ds, r32[ebx] + 0x2091e8);
    memoryASet(ds, r32[ecx], memoryAGet(ds, r32[ecx]) + r8[bl]);
    r32[ebx] = r32[eax];
    r32[eax]++;
    r32[edi] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edi] += r32[ebx];
    r8[bl] = memoryAGet(ds, r32[ecx]);
    memoryASet(ds, r32[edi], r8[bl]);
    if (r32s[eax] >= r32s[esi])
        { pc = 0x1db716; break; }
    r32[ebx] = 0;
    r8[bl] = memoryAGet(ds, r32[edx]);
    r32[ebx] = sar32(r32[ebx], 0x04);
    r8[bl] = memoryAGet(ds, r32[ebx] + 0x2091e8);
    memoryASet(ds, r32[ecx], memoryAGet(ds, r32[ecx]) + r8[bl]);
    r32[ebx] = r32[eax];
    r32[eax]++;
    r32[edi] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edi] += r32[ebx];
    r8[bl] = memoryAGet(ds, r32[ecx]);
    memoryASet(ds, r32[edi], r8[bl]);
    r32[edx]++;
    if (r32s[eax] < r32s[esi])
        { pc = 0x1db6d3; break; }
  case 0x1db716: // 0160:1db716
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db720() // 0160:1db720 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[ebx] - 1;
    r32[eax] = r32s[eax] * signed32(0x00000054);
    r32[ebx] = 0x002091fc;
    r32[ebx] += r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r8[al] = memoryAGet(ds, r32[ebx] + 0x28);
    memoryASet(ds, r32[ebx] + 0x30, r8[al]);
    memoryASet32(ds, r32[ebx] + 0x38, r32[edx]);
    r32[edx] = sar32(r32[edx], 0x10);
    memoryASet32(ds, r32[ebx] + 0x34, r32[edx]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x8);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x1c);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x20);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x30);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x24);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x38);
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x14);
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x38);
    r32[eax] >>>= 8;
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x14);
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x34);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x10);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x24);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ecx];
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x18);
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ecx];
    r32[eax] = sar32(r32[eax], 0x08);
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x18);
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0xc);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x1c);
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1db7a0() // 0160:1db7a0 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[ebx] - 1;
    r32[eax] = r32s[eax] * signed32(0x00000054);
    r32[ebx] = 0x002091fc;
    r32[ebx] += r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r8[al] = memoryAGet(ds, r32[ebx] + 0x28);
    r8[al] |= 0x10;
    memoryASet(ds, r32[ebx] + 0x30, r8[al]);
    memoryASet32(ds, r32[ebx] + 0x38, r32[edx]);
    r32[edx] = sar32(r32[edx], 0x10);
    memoryASet32(ds, r32[ebx] + 0x34, r32[edx]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x8);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x1c);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x20);
    r8[al] = memoryAGet(ds, r32[ebx] + 0x30);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x24);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x38);
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x14);
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x38);
    r32[eax] >>>= 8;
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x14);
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x34);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x10);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x24);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ecx];
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x18);
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ecx];
    r32[eax] = sar32(r32[eax], 0x08);
    r32[eax] &= 0x000000ff;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x18);
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0xc);
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x1c);
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1db8a0() // 0160:1db8a0 +long
{
    r32[esp] -= 4;
    memoryASet32(ds, 0x30b478, r32[eax]);
    r32[esp] += 4;
}
function* sub_1db8b0() // 0160:1db8b0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    memoryASet32(ds, 0x30b478, r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1db8c0() // 0160:1db8c0 +long +returnZero
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = 0x0030b2a8;
    yield* sub_1dbf20();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1db920() // 0160:1db920 +long +stackDrop4
{
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esi] = memoryAGet32(ss, r32[ebp] + 0xc);
    push32(r32[esi]);
    push32(r32[ecx]);
    r32[ecx] = r32[ebx];
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = 0x0030b2a8;
    yield* sub_1dc120();
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
}
function* sub_1db960() // 0160:1db960 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[eax];
    memoryASet32(ds, 0x30b2a8, r32[eax]);
    memoryASet32(ds, 0x30b2ac, r32[edx]);
    r32[eax] = 0x0030b2a8;
    yield* sub_1dbef0();
    if (memoryAGet32(ds, 0x30b474))
        { pc = 0x1db994; break; }
    r32[eax] = 0x00002100;
    yield* sub_1e24b0();
    memoryASet32(ds, 0x30b474, r32[eax]);
    if (!r32[eax])
        { pc = 0x1db9aa; break; }
  case 0x1db994: // 0160:1db994
    r32[eax] = memoryAGet32(ds, 0x30b474);
    r32[edx] = r32[ebx];
    yield* sub_1dc170();
    r32[eax] = 0x001db940;
    yield* sub_1df1f0();
  case 0x1db9aa: // 0160:1db9aa
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1db9b0() // 0160:1db9b0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    { pc = 0x1df1f0; break; }
    // gap 14393 bytes // gap 14393 bytes
  case 0x1df1f0: // 0160:1df1f0
    memoryASet32(ds, 0x30e264, r32[eax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1db9c0() // 0160:1db9c0 +long
{
    r32[esp] -= 4;
    memoryASet32(ds, 0x30b64c, r32[eax]);
    r32[esp] += 4;
}
function* sub_1db9d0() // 0160:1db9d0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    memoryASet32(ds, 0x30b64c, r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1db9e0() // 0160:1db9e0 +long +returnZero
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = 0x0030b47c;
    yield* sub_1dbf20();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dba40() // 0160:1dba40 +long +stackDrop4
{
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esi] = memoryAGet32(ss, r32[ebp] + 0xc);
    push32(r32[esi]);
    push32(r32[ecx]);
    r32[ecx] = r32[ebx];
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = 0x0030b47c;
    yield* sub_1dc120();
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
}
function* sub_1dba80() // 0160:1dba80 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[eax];
    memoryASet32(ds, 0x30b47c, r32[eax]);
    memoryASet32(ds, 0x30b480, r32[edx]);
    r32[eax] = 0x0030b47c;
    yield* sub_1dbef0();
    if (memoryAGet32(ds, 0x30b648))
        { pc = 0x1dbab4; break; }
    r32[eax] = 0x00002100;
    yield* sub_1e24b0();
    memoryASet32(ds, 0x30b648, r32[eax]);
    if (!r32[eax])
        { pc = 0x1dbaca; break; }
  case 0x1dbab4: // 0160:1dbab4
    r32[eax] = memoryAGet32(ds, 0x30b648);
    r32[edx] = r32[ebx];
    yield* sub_1dc170();
    r32[eax] = 0x001dba60;
    yield* sub_1e15e0();
  case 0x1dbaca: // 0160:1dbaca
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dbad0() // 0160:1dbad0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0;
    { pc = 0x1e15e0; break; }
    // gap 23305 bytes // gap 23305 bytes
  case 0x1e15e0: // 0160:1e15e0
    memoryASet32(ds, 0x313338, r32[eax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1dbe60() // 0160:1dbe60 +long
{
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    r32[edx] = 0x000003c8;
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ss, r32[ebp] - 4);
    r32[edx] = 0x000003c9;
    out8(r16[dx], r8[al]);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esp] += 4;
}
function* sub_1dbe90() // 0160:1dbe90 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[eax];
    if (r32s[edx] < 0)
        { pc = 0x1dbedf; break; }
    if (r32s[edx] >= signed32(memoryAGet32(ds, r32[eax])))
        { pc = 0x1dbedf; break; }
    r32[eax] = (r32[edx] * 8) + 0;
    r32[eax] -= r32[edx];
    r32[eax] = (r32[eax] * 4) + 0;
    r32[edx] = r32[ebx] + 12;
    r32[edx] += r32[eax];
    memoryASet(ds, r32[edx], 0x00);
    memoryASet(ds, r32[edx] + 0x1, 0x00);
    memoryASet32(ds, r32[edx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[edx] + 0x8, 0x00000000);
    r32[eax] = r32[edx];
    r32[edx] += 0x00000008;
  case 0x1dbeca: // 0160:1dbeca
    memoryASet32(ds, r32[eax] + 0xc, 0x0030bc50);
    memoryASet32(ds, r32[eax] + 0x14, 0x0030bc51);
    r32[eax] += 0x00000004;
    if (r32[eax] != r32[edx])
        { pc = 0x1dbeca; break; }
  case 0x1dbedf: // 0160:1dbedf
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dbef0() // 0160:1dbef0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ecx] = r32[eax];
    memoryASet32(ds, r32[eax] + 0x8, 0x00000000);
    r32[ebx] = 0;
    if (signed32(memoryAGet32(ds, r32[eax])) <= signed32(0x00000000))
        { pc = 0x1dbf11; break; }
  case 0x1dbf03: // 0160:1dbf03
    r32[edx] = r32[ebx];
    r32[eax] = r32[ecx];
    yield* sub_1dbe90();
    r32[ebx]++;
    if (r32s[ebx] < signed32(memoryAGet32(ds, r32[ecx])))
        { pc = 0x1dbf03; break; }
  case 0x1dbf11: // 0160:1dbf11
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dbf20() // 0160:1dbf20 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r32[esi] = r32[edx];
    flags.zero = r32[edx] == 0;
    if (r32s[edx] < 0)
        { pc = 0x1dbf6f; break; }
    flags.zero = r32[esi] == memoryAGet32(ds, r32[eax]);
    if (r32s[esi] >= signed32(memoryAGet32(ds, r32[eax])))
        { pc = 0x1dbf6f; break; }
    if (r32s[ebx] >= signed32(0x00000071))
        { pc = 0x1dbf3a; break; }
    r32[ebx] = 0x00000071;
    { pc = 0x1dbf47; break; }
  case 0x1dbf3a: // 0160:1dbf3a
    if (r32s[ebx] <= signed32(0x00000358))
        { pc = 0x1dbf47; break; }
    r32[ebx] = 0x00000358;
  case 0x1dbf47: // 0160:1dbf47
    r32[eax] = 0x0036a040;
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ebx]);
    r32[eax] <<= 15;
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[ebx] = memoryAGet32(ds, r32[ecx] + 0x4);
    idiv32(r32[ebx]);
    r32[edx] = r32[eax];
    r32[eax] = (r32[esi] * 8) + 0;
    r32[eax] -= r32[esi];
    flags.zero = r32[eax] == 0;
    memoryASet32(ds, r32[ecx] + r32[eax] * 4 + 0x14, r32[edx]);
  case 0x1dbf6f: // 0160:1dbf6f
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dbf80() // 0160:1dbf80 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    if (r32s[edx] < 0)
        { pc = 0x1dbfaa; break; }
    if (r32s[edx] >= signed32(memoryAGet32(ds, r32[eax])))
        { pc = 0x1dbfaa; break; }
    if (r32s[ebx] >= 0)
        { pc = 0x1dbf93; break; }
    r32[ebx] = 0;
    { pc = 0x1dbf9d; break; }
  case 0x1dbf93: // 0160:1dbf93
    if (r32s[ebx] <= signed32(0x00000040))
        { pc = 0x1dbf9d; break; }
    r32[ebx] = 0x00000040;
  case 0x1dbf9d: // 0160:1dbf9d
    r32[eax] = (r32[edx] * 8) + 0;
    r32[eax] -= r32[edx];
    memoryASet(ds, r32[ecx] + r32[eax] * 4 + 0xc, r8[bl]);
  case 0x1dbfaa: // 0160:1dbfaa
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc050() // 0160:1dc050 +long +stackDrop8
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[edi] = r32[edx];
    memoryASet32(ss, r32[ebp] - 4, r32[ebx]);
    memoryASet32(ss, r32[ebp] - 12, r32[ecx]);
    r32[ebx] = memoryAGet32(ss, r32[ebp] + 0x10);
    r32[ecx] = memoryAGet32(ss, r32[ebp] + 0x14);
    if (r32s[edx] < 0)
        { pc = 0x1dc115; break; }
    if (r32s[edi] >= signed32(memoryAGet32(ds, r32[eax])))
        { pc = 0x1dc115; break; }
    r32[edx] = r32[edi];
    r32[eax] = (r32[edx] * 8) + 0;
    r32[eax] -= r32[edx];
    r32[eax] = (r32[eax] * 4) + 0;
    r32[esi] = memoryAGet32(ss, r32[ebp] - 8);
    r32[esi] += 0x0000000c;
    r32[esi] += r32[eax];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32[eax])
        { pc = 0x1dc0c4; break; }
    memoryASet32(ds, r32[esi] + 0x4, r32[eax]);
    memoryASet32(ds, r32[esi] + 0x8, r32[eax]);
    r8[al] = memoryAGet(ds, r32[esi] + 0x8);
    memoryASet(ds, r32[esi] + 0x1, r8[al]);
    memoryASet(ds, r32[esi], r8[al]);
    r32[eax] = r32[esi];
    r32[edx] = r32[esi] + 8;
  case 0x1dc0ad: // 0160:1dc0ad
    memoryASet32(ds, r32[eax] + 0xc, 0x0030bc50);
    memoryASet32(ds, r32[eax] + 0x14, 0x0030bc51);
    r32[eax] += 0x00000004;
    if (r32[eax] == r32[edx])
        { pc = 0x1dc115; break; }
    { pc = 0x1dc0ad; break; }
  case 0x1dc0c4: // 0160:1dc0c4
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    yield* sub_1dbf80();
    r32[ebx] = r32[ecx];
    r32[edx] = r32[edi];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    yield* sub_1dbf20();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0xc);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] -= memoryAGet32(ds, r32[edx]);
    if (r32s[eax] >= signed32(memoryAGet32(ss, r32[ebp] - 12)))
        { pc = 0x1dc0eb; break; }
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
  case 0x1dc0eb: // 0160:1dc0eb
    r32[edx] = r32[esi];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[ecx] = r32[eax] + 8;
  case 0x1dc0f3: // 0160:1dc0f3
    r32[ebx] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edx] + 0xc, r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[eax] + 0xc);
    memoryASet32(ds, r32[edx] + 0x14, r32[ebx]);
    r32[edx] += 0x00000004;
    r32[eax] += 0x00000004;
    if (r32[eax] != r32[ecx])
        { pc = 0x1dc0f3; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    r32[eax] <<= 15;
    memoryASet32(ds, r32[esi] + 0x4, r32[eax]);
    memoryASet(ds, r32[esi] + 0x1, 0x00);
  case 0x1dc115: // 0160:1dc115
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 12;
    return;
  }
}
function* sub_1dc120() // 0160:1dc120 +long +stackDrop8
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    if (r32s[edx] < 0)
        { pc = 0x1dc15d; break; }
    if (r32s[edx] >= signed32(memoryAGet32(ds, r32[eax])))
        { pc = 0x1dc15d; break; }
    if (r32s[ebx] < 0)
        { pc = 0x1dc15d; break; }
    if (r32s[ebx] > signed32(0x00000180))
        { pc = 0x1dc15d; break; }
    if (!r32[ebx])
        { pc = 0x1dc14e; break; }
    r32[esi] = memoryAGet32(ss, r32[ebp] + 0x14);
    push32(r32[esi]);
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x10);
    push32(r32[edi]);
    r32[ebx] = memoryAGet32(ds, r32[ebx] * 4 + 0x30b64c);
    { pc = 0x1dc158; break; }
  case 0x1dc14e: // 0160:1dc14e
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x14);
    push32(r32[edi]);
    r32[ebx] = memoryAGet32(ss, r32[ebp] + 0x10);
    push32(r32[ebx]);
    r32[ebx] = 0;
  case 0x1dc158: // 0160:1dc158
    yield* sub_1dc050();
  case 0x1dc15d: // 0160:1dc15d
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 12;
    return;
  }
}
function* sub_1dc170() // 0160:1dc170 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000014;
    r32[ecx] = r32[eax];
    memoryASet32(ss, r32[ebp] - 12, r32[edx]);
    r32[edx] = 0;
    memoryASet32(ss, r32[ebp] - 16, r32[edx]);
    { pc = 0x1dc1b0; break; }
    // gap 12 bytes // gap 12 bytes
  case 0x1dc190: // 0160:1dc190
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 16);
    r32[ebx] += 0x00000002;
    memoryASet32(ss, r32[ebp] - 16, r32[ebx]);
    if (r32s[ebx] > signed32(0x00000040))
        { pc = 0x1dc22b; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[eax] = r32[eax];
  case 0x1dc1b0: // 0160:1dc1b0
    push32(0x3fe33333);
    push32(0x40000000);
    fild32(memoryAGet32(ss, r32[ebp] - 16));
    fmul32(memoryAGet32(ds, 0x20affc));
    r32[esp] -= 0x00000008;
    memoryASet64(ds, r32[esp], fstp64());
    yield* sub_1e3b30();
    memoryASet32(ss, r32[ebp] - 20, fstp32());
    r32[ebx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 16);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[eax] <<= 8;
    r32[edx] = r32[ecx] + r32[eax];
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[ebx] = r32[ebx];
  case 0x1dc1f0: // 0160:1dc1f0
    r16[ax] = r8s[bl];
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    fild16(memoryAGet16(ss, r32[ebp] - 4));
    fmul32(memoryAGet32(ss, r32[ebp] - 20));
    memoryASet32(ss, r32[ebp] - 8, fstp32());
    fild32(memoryAGet32(ss, r32[ebp] - 12));
    fld32(memoryAGet32(ss, r32[ebp] - 8));
    fadd32(memoryAGet32(ds, 0x20b000));
    stop("disassembly failed at 0160:1dc20c (fdivrp st(1))");
    yield* sub_1e3b40();
    memoryASet32(ss, r32[ebp] - 8, fistp32());
    r8[al] = memoryAGet(ss, r32[ebp] - 8);
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    r32[ebx]++;
    if (r32s[ebx] >= signed32(0x00000100))
        { pc = 0x1dc190; break; }
    { pc = 0x1dc1f0; break; }
  case 0x1dc22b: // 0160:1dc22b
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc3f0() // 0160:1dc3f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[edi] = r32[ebx];
    r32[esi] = r32[ecx];
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[ebx] = 0;
    if (r32s[ecx] <= 0)
        { pc = 0x1dc41d; break; }
    r32[ecx] = r32[edx];
  case 0x1dc407: // 0160:1dc407
    r32[eax] = r32[ebx];
    r32[edx] = r32[ebx];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[edi]);
    r32[edx] += memoryAGet32(ss, r32[ebp] - 4);
    r8[dl] = memoryAGet(ds, r32[edx]);
    memoryASet(ds, r32[ecx], r8[dl]);
    r32[ecx]++;
    r32[ebx]++;
    if (r32s[ebx] < r32s[esi])
        { pc = 0x1dc407; break; }
  case 0x1dc41d: // 0160:1dc41d
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc430() // 0160:1dc430 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000054;
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    memoryASet32(ss, r32[ebp] - 28, r32[edx]);
    if (!memoryAGet32(ds, 0x313108))
        { pc = 0x1dc459; break; }
    r32[ecx] = 0;
    r32[ebx] = 0x0000003f;
    r32[edx] = r32[ebx];
    r32[eax] = 0;
    yield* sub_1dbe60();
  case 0x1dc459: // 0160:1dc459
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 20);
    r32[ebx] = 0x00000001;
    r32[edx] = 0x00000030;
    r32[eax] = r32[ebp] - 84;
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1dc47d; break; }
    r32[eax] = 0xfffffffd;
    { pc = 0x1dc601; break; }
  case 0x1dc47d: // 0160:1dc47d
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b004;
    r32[eax] = r32[ebp] - 84;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1dc4b6; break; }
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b009;
    r32[eax] = r32[ebp] - 84;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1dc4b6; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc4b6: // 0160:1dc4b6
    r32[eax] = r32[ebp] - 76;
    yield* sub_1e0940();
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1dc601; break; }
    if (memoryAGet32(ds, r32[eax] * 4 + 0x30b650))
        { pc = 0x1dc5ff; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 44);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 40);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[edx] = r32[eax] + 1048;
    r32[eax] = 0x0020b00e;
    yield* sub_1df820();
    r32[esi] = r32[eax];
    if (r32[eax])
        { pc = 0x1dc506; break; }
    r32[eax] = 0xfffffffc;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc506: // 0160:1dc506
    r32[edi] = r32[eax] + 24;
    if (!memoryAGet32(ss, r32[ebp] - 28))
        { pc = 0x1dc55d; break; }
    r8[ah] = 0;
    memoryASet(ss, r32[ebp] - 4, r8[ah]);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[edx]++;
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[edx] = r32[edi] + r32[eax];
    memoryASet32(ss, r32[ebp] - 24, r32[edx]);
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 20);
    r32[ebx] = 0x00000001;
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 24);
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1dc54b; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc54b: // 0160:1dc54b
    r32[ecx] = r32[ebp] - 4;
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 24);
    r32[eax] = r32[edi];
    yield* sub_1db6c0();
    { pc = 0x1dc581; break; }
  case 0x1dc55d: // 0160:1dc55d
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 20);
    r32[ebx] = 0x00000001;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = r32[edi];
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1dc581; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc581: // 0160:1dc581
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] += r32[edi];
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 16);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    if (r32[eax] != r32[edx])
        { pc = 0x1dc5b5; break; }
    r32[ecx] = 0x00000400;
    r32[ebx] = 0x00000001;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[eax] = r32[edi];
    yield* sub_1dc3f0();
    memoryASet32(ds, r32[esi], r32[edi]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ds, r32[esi] + 0xc, r32[eax]);
    memoryASet32(ds, r32[esi] + 0x4, r32[eax]);
    r32[eax]++;
    { pc = 0x1dc5dc; break; }
  case 0x1dc5b5: // 0160:1dc5b5
    r32[ebx] = r32[edx];
    r32[ebx] -= r32[eax];
    r32[eax] += r32[edi];
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    r32[ecx] = 0x00000400;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 12);
    yield* sub_1dc3f0();
    memoryASet32(ds, r32[esi], r32[edi]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ds, r32[esi] + 0xc, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    memoryASet32(ds, r32[esi] + 0x4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
  case 0x1dc5dc: // 0160:1dc5dc
    memoryASet32(ds, r32[esi] + 0x10, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 32);
    memoryASet32(ds, r32[eax] * 4 + 0x30b650, r32[esi]);
    if (!memoryAGet32(ds, 0x313108))
        { pc = 0x1dc5ff; break; }
    r32[ecx] = 0;
    r32[ebx] = 0;
    r32[edx] = 0;
    r32[eax] = 0;
    yield* sub_1dbe60();
  case 0x1dc5ff: // 0160:1dc5ff
    r32[eax] = 0;
  case 0x1dc601: // 0160:1dc601
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc610() // 0160:1dc610 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[eax] = 0;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1dc620: // 0160:1dc620
    r32[edx] = 0;
    memoryASet32(ds, r32[eax] + 0x30b650, r32[edx]);
    r32[eax] += 0x00000004;
    if (r32[eax] != 0x00000600)
        { pc = 0x1dc620; break; }
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc840() // 0160:1dc840 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[edx] = r32[eax];
    r32[ebx] = memoryAGet32(ds, 0x30c05c);
    if (r32s[ebx] < signed32(0x00000010))
        { pc = 0x1dc858; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc858: // 0160:1dc858
    r32[ecx] = 0;
    memoryASet32(ds, r32[ebx] * 8 + 0x30c06c, r32[ecx]);
    memoryASet32(ds, r32[ebx] * 8 + 0x30c070, r32[eax]);
    r32[eax] = 0x00000001;
    r32[esi] = r32[ebx] + r32[eax];
    memoryASet32(ds, 0x30c05c, r32[esi]);
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc880() // 0160:1dc880 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ebx] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30c05c);
    if (r32s[edx] > 0)
        { pc = 0x1dc89d; break; }
    { pc = 0x1dc8d7; break; }
  case 0x1dc894: // 0160:1dc894
    r32[eax] += 0x00000008;
    if (r32s[eax] < r32s[edx])
        { pc = 0x1dc8a6; break; }
    { pc = 0x1dc8d7; break; }
  case 0x1dc89d: // 0160:1dc89d
    r32[eax] = 0;
    r32[edx] = (r32[edx] * 8) + 0;
  case 0x1dc8a6: // 0160:1dc8a6
    if (r32[ebx] != memoryAGet32(ds, r32[eax] + 0x30c070))
        { pc = 0x1dc894; break; }
    r32[esi] = memoryAGet32(ds, 0x30c05c);
    r32[esi]--;
    memoryASet32(ds, 0x30c05c, r32[esi]);
    if (!r32[esi])
        { pc = 0x1dc8cc; break; }
    r32[edi] = r32[eax] + 3194988;
    r32[esi] = (r32[esi] * 8) + 3194988;
    movsd_ESEDI_DSESI();
    movsd_ESEDI_DSESI();
  case 0x1dc8cc: // 0160:1dc8cc
    flagsFromReg32(pop32());
    r32[eax] = 0x00000001;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc8d7: // 0160:1dc8d7
    flagsFromReg32(pop32());
    r32[eax] = 0;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc8e0() // 0160:1dc8e0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = 0;
    memoryASet32(ds, 0x30c05c, r32[edx]);
    r32[eax] = 0x000000c8;
    yield* sub_1e25a0();
    r32[eax] &= 0x0000ffff;
    memoryASet32(ds, 0x30c054, r32[eax]);
    memoryASet32(ds, 0x30c058, r32[eax]);
    memoryASet32(ds, 0x30c050, 0x00010000);
    r32[eax] = 0x001dc652;
    yield* sub_1dc840();
    r32[ebx] = 0x002094ac;
    r32[edx] = 0x002094a8;
    r32[eax] = 0x00000008;
    yield* sub_1e2350();
    r32[edx] = cs;
    r32[eax] = 0x001dc634;
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[edx] = 0x001dc634;
    r32[eax] = 0x00000008;
    yield* sub_1e23a0();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x30c054);
    yield* sub_1e2600();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dc960() // 0160:1dc960 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x30c050);
    yield* sub_1e2600();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x2094ac);
    r32[edx] = memoryAGet32(ds, 0x2094a8);
    r32[eax] = 0x00000008;
    yield* sub_1e23a0();
    flagsFromReg32(pop32());
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dc990() // 0160:1dc990 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x30c060);
    r32[edx]++;
    memoryASet32(ds, 0x30c060, r32[edx]);
    if (r32[edx] != 0x00000001)
        { pc = 0x1dc9b1; break; }
    if (memoryAGet32(ds, 0x30c0ec))
        { pc = 0x1dc9b1; break; }
    yield* sub_1dc8e0();
  case 0x1dc9b1: // 0160:1dc9b1
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dc9c0() // 0160:1dc9c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x30c060);
    r32[edx]--;
    memoryASet32(ds, 0x30c060, r32[edx]);
    if (r32[edx])
        { pc = 0x1dc9de; break; }
    if (memoryAGet32(ds, 0x30c0ec))
        { pc = 0x1dc9de; break; }
    yield* sub_1dc960();
  case 0x1dc9de: // 0160:1dc9de
    if (signed32(memoryAGet32(ds, 0x30c060)) >= signed32(0x00000000))
        { pc = 0x1dc9fe; break; }
    push32(0x0020b06c);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0xffffffff;
    yield* sub_1e3663();
  case 0x1dc9fe: // 0160:1dc9fe
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcad0() // 0160:1dcad0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    memoryASet32(ds, 0x30e250, r32[edx]);
    yield* sub_1dcd60();
    memoryASet32(ds, 0x30e254, r32[eax]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dcaf0() // 0160:1dcaf0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[ebx] = r32[eax];
    r32[eax] = 0;
    r32[edx] = r32[ebx];
    r32[edx] = (r32[edx] * 4) + 0;
    r32[edx] -= r32[ebx];
    r32[edx] = (r32[edx] * 4) + 0;
    if (r32s[edx] <= 0)
        { pc = 0x1dcb3b; break; }
    r32[ebx] = 0;
    r32[ecx] = 0x00000071;
  case 0x1dcb22: // 0160:1dcb22
    memoryASet32(ds, r32[eax] + 0x30d98c, r32[ebx]);
    memoryASet32(ds, r32[eax] + 0x30d990, r32[ecx]);
    memoryASet32(ds, r32[eax] + 0x30d994, r32[ebx]);
    r32[eax] += 0x0000000c;
    if (r32s[eax] < r32s[edx])
        { pc = 0x1dcb22; break; }
  case 0x1dcb3b: // 0160:1dcb3b
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcb60() // 0160:1dcb60 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1dcb60; break; }
  case 0x1dc840: // 0160:1dc840
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[edx] = r32[eax];
    r32[ebx] = memoryAGet32(ds, 0x30c05c);
    if (r32s[ebx] < signed32(0x00000010))
        { pc = 0x1dc858; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dc858: // 0160:1dc858
    r32[ecx] = 0;
    memoryASet32(ds, r32[ebx] * 8 + 0x30c06c, r32[ecx]);
    memoryASet32(ds, r32[ebx] * 8 + 0x30c070, r32[eax]);
    r32[eax] = 0x00000001;
    r32[esi] = r32[ebx] + r32[eax];
    memoryASet32(ds, 0x30c05c, r32[esi]);
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 741 bytes // gap 741 bytes
  case 0x1dcb60: // 0160:1dcb60
    memoryASet32(ds, 0x30e24c, r32[eax]);
    yield* sub_1dc990();
    r32[eax] = 0x001dcb40;
    { pc = 0x1dc840; break; }
    return;
  }
}
function* sub_1dcb80() // 0160:1dcb80 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[ebx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[dl];
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x89;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d958);
    r32[eax] = 0;
    r16[ax] = in16(r16[dx]);
    r32[edx] = r32[eax];
    r32[edx] >>>= 4;
    flagsFromReg32(pop32());
    r32[eax] = r32[edx];
    r32[eax] &= 0x00000fff;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dcbc0() // 0160:1dcbc0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[edx] >= 0)
        { pc = 0x1dcbc6; break; }
    r32[edx] = 0;
  case 0x1dcbc6: // 0160:1dcbc6
    if (r32s[edx] <= signed32(0x000001ff))
        { pc = 0x1dcbd3; break; }
    r32[edx] = 0x000001ff;
  case 0x1dcbd3: // 0160:1dcbd3
    r32[edx] = memoryAGet32(ds, r32[edx] * 4 + 0x209558);
    r32[eax] = r32[eax];
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    if (r32s[edx] >= 0)
        { pc = 0x1dcbec; break; }
    r32[ebx] ^= r32[edx];
  case 0x1dcbec: // 0160:1dcbec
    if (r32s[ebx] <= signed32(0x00000fff))
        { pc = 0x1dcbf9; break; }
    r32[ebx] = 0x00000fff;
  case 0x1dcbf9: // 0160:1dcbf9
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x09;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx];
    r32[eax] <<= 4;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcbe0() // 0160:1dcbe0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    if (r32s[edx] >= 0)
        { pc = 0x1dcbec; break; }
    r32[ebx] ^= r32[edx];
  case 0x1dcbec: // 0160:1dcbec
    if (r32s[ebx] <= signed32(0x00000fff))
        { pc = 0x1dcbf9; break; }
    r32[ebx] = 0x00000fff;
  case 0x1dcbf9: // 0160:1dcbf9
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x09;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx];
    r32[eax] <<= 4;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcc20() // 0160:1dcc20 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    if (r32s[edx] >= 0)
        { pc = 0x1dcc2b; break; }
    r32[edx] = 0;
  case 0x1dcc2b: // 0160:1dcc2b
    if (r32s[edx] <= signed32(0x000001ff))
        { pc = 0x1dcc38; break; }
    r32[edx] = 0x000001ff;
  case 0x1dcc38: // 0160:1dcc38
    r32[eax] = r32[esi];
    yield* sub_1dcf70();
    r32[eax] = r32[esi];
    yield* sub_1dcb80();
    push32(0x00000000);
    r32[ebx] = memoryAGet32(ds, r32[edx] * 4 + 0x30da4c);
    r32[ecx] = 0x0000000a;
    r32[edx] = r32[eax];
    r32[eax] = r32[esi];
    yield* sub_1dcfc0();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcc70() // 0160:1dcc70 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    if (!memoryAGet32(ds, 0x30e24c))
        { pc = 0x1dcc91; break; }
    r32[ebx] = 0;
    memoryASet32(ds, 0x30e24c, r32[ebx]);
    r32[eax] = 0x001dcb40;
    yield* sub_1dc880();
    yield* sub_1dc9c0();
  case 0x1dcc91: // 0160:1dcc91
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcca0() // 0160:1dcca0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = 0;
  case 0x1dcca4: // 0160:1dcca4
    r32[edx] = memoryAGet32(ds, 0x30d964);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[ebx]++;
    if (r32s[ebx] < signed32(0x00000007))
        { pc = 0x1dcca4; break; }
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dccc0() // 0160:1dccc0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[eax];
    r8[cl] = r8[dl];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x43;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d958);
    r32[eax] = r32[ebx];
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x44;
    out8(r16[dx], r8[al]);
    r32[ebx] = sar32(r32[ebx], 0x10);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d978);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dcd00() // 0160:1dcd00 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r32[esi] = r32[edx];
  case 0x1dcd06: // 0160:1dcd06
    r32[ebx]--;
    if (r32[ebx] == 0xffffffff)
        { pc = 0x1dcd1b; break; }
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[esi]);
    r32[eax] = r32[ecx];
    r32[esi]++;
    r32[ecx]++;
    yield* sub_1dccc0();
    { pc = 0x1dcd06; break; }
  case 0x1dcd1b: // 0160:1dcd1b
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcd20() // 0160:1dcd20 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x43;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d958);
    r32[eax] = r32[ebx];
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x44;
    out8(r16[dx], r8[al]);
    r32[ebx] = sar32(r32[ebx], 0x10);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d978);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[ebx] = r32[eax];
    flagsFromReg32(pop32());
    r8[al] = r8[bl];
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dcd60() // 0160:1dcd60 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[eax] = 0;
    yield* sub_1dcd20();
    r8[ch] = r8[al];
    r32[edx] = 0x000000aa;
    r32[eax] = 0;
    yield* sub_1dccc0();
    r32[eax] = 0;
    yield* sub_1dcd20();
    r32[eax] &= 0x000000ff;
    if (r32[eax] == 0x000000aa)
        { pc = 0x1dcdaf; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dcd93: // 0160:1dcd93
    r32[edx] = 0;
    r8[dl] = r8[cl];
    r32[eax] = r32[ebx];
    yield* sub_1dccc0();
    r32[ebx] += 0x00000400;
    r32[esi]++;
    if (r32s[ebx] < signed32(0x00100000))
        { pc = 0x1dcdc2; break; }
    { pc = 0x1dcdf9; break; }
  case 0x1dcdaf: // 0160:1dcdaf
    r32[edx] = 0;
    r32[eax] = 0;
    yield* sub_1dccc0();
    r32[esi] = 0x00000001;
    r32[ebx] = 0x00000400;
  case 0x1dcdc2: // 0160:1dcdc2
    r32[eax] = 0;
    yield* sub_1dcd20();
    r32[edx] = 0;
    r8[dl] = r8[al];
    if (r32[edx])
        { pc = 0x1dcdf9; break; }
    r32[eax] = r32[ebx];
    yield* sub_1dcd20();
    r8[cl] = r8[al];
    r32[edx] = 0x000000aa;
    r32[eax] = r32[ebx];
    yield* sub_1dccc0();
    r32[eax] = r32[ebx];
    yield* sub_1dcd20();
    r32[edx] = 0;
    r8[dl] = r8[al];
    if (r32[edx] == 0x000000aa)
        { pc = 0x1dcd93; break; }
  case 0x1dcdf9: // 0160:1dcdf9
    r32[edx] = 0;
    r8[dl] = r8[ch];
    r32[eax] = 0;
    yield* sub_1dccc0();
    r32[eax] = r32[esi];
    r32[eax] <<= 10;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dce10() // 0160:1dce10 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[eax] = 0;
    yield* sub_1dcd20();
    r8[bl] = r8[al];
    r32[eax] = 0x00000001;
    yield* sub_1dcd20();
    r8[bh] = r8[al];
    r32[edx] = 0x000000aa;
    r32[eax] = 0;
    yield* sub_1dccc0();
    r32[edx] = 0x00000055;
    r32[eax] = 0x00000001;
    yield* sub_1dccc0();
    r32[eax] = 0;
    yield* sub_1dcd20();
    r8[cl] = r8[al];
    r32[eax] = 0x00000001;
    yield* sub_1dcd20();
    r8[ch] = r8[al];
    r32[edx] = 0;
    r8[dl] = r8[bl];
    r32[eax] = 0;
    yield* sub_1dccc0();
    r32[edx] = 0;
    r8[dl] = r8[bh];
    r32[eax] = 0x00000001;
    yield* sub_1dccc0();
    r32[eax] = 0;
    r8[al] = r8[cl];
    if (r32[eax] != 0x000000aa)
        { pc = 0x1dce8e; break; }
    r32[eax] = 0;
    r8[al] = r8[ch];
    if (r32[eax] != 0x00000055)
        { pc = 0x1dce8e; break; }
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dce8e: // 0160:1dce8e
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcea0() // 0160:1dcea0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x4c;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    yield* sub_1dcca0();
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x4c;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    yield* sub_1dcca0();
    yield* sub_1dce10();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dcee0() // 0160:1dcee0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    if (r32s[eax] <= r32s[edx])
        { pc = 0x1dceeb; break; }
    r32[ecx] = r32[eax];
    r32[ecx] -= r32[edx];
    { pc = 0x1dceef; break; }
  case 0x1dceeb: // 0160:1dceeb
    r32[ecx] = r32[edx];
    r32[ecx] -= r32[eax];
  case 0x1dceef: // 0160:1dceef
    r32[edx] = r32[ebx];
    r32[eax] = r32[ebx];
    r32[eax] <<= 5;
    r32[eax] -= r32[ebx];
    r32[eax] = (r32[eax] * 4) + 0;
    r32[eax] += r32[ebx];
    r32[eax] = (r32[eax] * 8) + 0;
    r32[edx] ^= r32[ebx];
    div32(r32[ecx]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0x00000004;
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209e20);
    r32[edx] = 0;
  case 0x1dcf21: // 0160:1dcf21
    if (r32[ebx] >= r32[eax])
        { pc = 0x1dcf38; break; }
    r32[ecx] = r32[edx];
  case 0x1dcf27: // 0160:1dcf27
    if (r32[ecx] != 0x00000004)
        { pc = 0x1dcf47; break; }
    r32[ecx] = 0x00000003;
    r32[edx] = 0x00000001;
    { pc = 0x1dcf53; break; }
  case 0x1dcf38: // 0160:1dcf38
    r32[eax] = (r32[eax] * 8) + 0;
    r32[edx]++;
    if (r32[edx] < 0x00000003)
        { pc = 0x1dcf21; break; }
    { pc = 0x1dcf27; break; }
  case 0x1dcf47: // 0160:1dcf47
    r32[edx] = r32[eax];
    r32[edx] >>>= 1;
    r32[eax] += r32[edx];
    r32[edx] = 0;
    div32(r32[ebx]);
    r32[edx] = r32[eax];
  case 0x1dcf53: // 0160:1dcf53
    r8[al] = r8[cl];
    r8[al] <<= 6;
    r8[ah] = r8[dl];
    r8[ah] &= 0x3f;
    r8[al] |= r8[ah];
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dcf70() // 0160:1dcf70 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[ebx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[dl];
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x8d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[bl] = r8[al];
    r8[bl] |= 0x03;
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dcfc0() // 0160:1dcfc0 +long +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edi] = r32[edx];
    r32[esi] = r32[ebx];
    r32[ebx] = r32[ecx];
    r8[cl] = memoryAGet(ss, r32[ebp] + 0x10);
    if (r32[edx] == r32[esi])
        { pc = 0x1dd09c; break; }
    r32[edx] = r32[esi];
    r32[eax] = r32[edi];
    yield* sub_1dcee0();
    r8[ah] = r8[al];
    r8[cl] &= 0x78;
    r32[ebx] = r32[edi];
    if (r32s[edi] <= r32s[esi])
        { pc = 0x1dcff7; break; }
    r32[edi] = r32[esi];
    r32[esi] = r32[ebx];
    r8[cl] |= 0x40;
  case 0x1dcff7: // 0160:1dcff7
    if (r32s[edi] >= signed32(0x00000040))
        { pc = 0x1dd001; break; }
    r32[edi] = 0x00000040;
  case 0x1dd001: // 0160:1dd001
    if (r32s[esi] <= signed32(0x00000fc0))
        { pc = 0x1dd00e; break; }
    r32[esi] = 0x00000fc0;
  case 0x1dd00e: // 0160:1dd00e
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = memoryAGet(ss, r32[ebp] - 4);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x06;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[ah];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x07;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[edi];
    r32[eax] = sar32(r32[eax], 0x04);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x08;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[esi];
    r32[eax] = sar32(r32[eax], 0x04);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    out8(r16[dx], r8[al]);
    r32[edx] = r32[ebx];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1dcbe0();
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x8d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] &= 0x04;
    r32[eax] &= 0x000000ff;
    if (!r32[eax])
        { pc = 0x1dd07c; break; }
    r8[cl] |= 0x04;
  case 0x1dd07c: // 0160:1dd07c
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
  case 0x1dd09c: // 0160:1dd09c
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
    return;
  }
}
function* sub_1dd0b0() // 0160:1dd0b0 +long +stackDrop8
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000002c;
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[ecx] = 0x00000009;
    r32[edi] = r32[ebp] - 44;
    r32[esi] = 0x00209eac;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    if (memoryAGet32(ss, r32[ebp] + 0x14))
        { pc = 0x1dd0e7; break; }
    push32(0x0020b0e4);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1dd0e7: // 0160:1dd0e7
    r32[ebx] = 0;
    r32[edx] = 0;
    if (signed32(memoryAGet32(ss, r32[ebp] - 44)) < signed32(0x00000000))
        { pc = 0x1dd1cd; break; }
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x14);
  case 0x1dd0f8: // 0160:1dd0f8
    r32[eax] = memoryAGet32(ds, r32[edx] + r32[ebp] - 44);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    if (r32[edi])
        { pc = 0x1dd11a; break; }
    push32(0x0020b0f6);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1dd11a: // 0160:1dd11a
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ds, 0x30d944, r32[eax]);
    r32[eax] += 0x00000101;
    memoryASet32(ds, 0x30d948, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000100;
    memoryASet32(ds, 0x30d94c, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000102;
    memoryASet32(ds, 0x30d950, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000103;
    memoryASet32(ds, 0x30d954, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000104;
    memoryASet32(ds, 0x30d958, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000105;
    memoryASet32(ds, 0x30d95c, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000006;
    memoryASet32(ds, 0x30d960, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000107;
    memoryASet32(ds, 0x30d964, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ds, 0x30d968, r32[eax]);
    r32[eax] += 0x00000008;
    memoryASet32(ds, 0x30d96c, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000009;
    memoryASet32(ds, 0x30d970, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x0000000b;
    memoryASet32(ds, 0x30d974, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30d964);
    memoryASet32(ds, 0x30d978, r32[eax]);
    yield* sub_1dcea0();
    if (r32[eax])
        { pc = 0x1dd1cd; break; }
    r32[edx] += 0x00000004;
    r32[ebx]++;
    if (signed32(memoryAGet32(ds, r32[edx] + r32[ebp] - 44)) >= signed32(0x00000000))
        { pc = 0x1dd0f8; break; }
  case 0x1dd1cd: // 0160:1dd1cd
    if (signed32(memoryAGet32(ss, r32[ebp] + r32[ebx] * 4 - 44)) >= signed32(0x00000000))
        { pc = 0x1dd1eb; break; }
    if (memoryAGet32(ss, r32[ebp] + 0x14))
        { pc = 0x1dd1e7; break; }
    push32(0x0020b0f8);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
  case 0x1dd1e7: // 0160:1dd1e7
    r32[eax] = 0;
    { pc = 0x1dd20f; break; }
  case 0x1dd1eb: // 0160:1dd1eb
    if (memoryAGet32(ss, r32[ebp] + 0x14))
        { pc = 0x1dd202; break; }
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
    push32(r32[ebx]);
    push32(0x0020b101);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
  case 0x1dd202: // 0160:1dd202
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[eax] = 0x00000001;
  case 0x1dd20f: // 0160:1dd20f
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 12;
    return;
  }
}
function* sub_1dd220() // 0160:1dd220 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[edx] = 0;
    memoryASet32(ds, 0x30d980, r32[edx]);
    memoryASet32(ds, 0x30d984, r32[edx]);
    r32[ebx] = memoryAGet32(ds, 0x30d954);
    r32[ecx] = memoryAGet32(ds, 0x30d958);
    r32[esi] = memoryAGet32(ds, 0x30d95c);
    r32[eax] = 0;
    yield* sub_1dccc0();
    r32[edx] = 0;
    r32[eax] = 0x00000001;
    yield* sub_1dccc0();
    push32(flagAsReg32());
    flags.interrupts = 0;
    r8[al] = 0x4c;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r32[edx] ^= r32[esi];
    r32[eax] = r32[eax];
  case 0x1dd270: // 0160:1dd270
    yield* sub_1dcca0();
    r32[edx]++;
    if (r32s[edx] < signed32(0x0000000a))
        { pc = 0x1dd270; break; }
    r8[al] = 0x4c;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x01;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r32[edx] ^= r32[esi];
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1dd290: // 0160:1dd290
    yield* sub_1dcca0();
    r32[edx]++;
    if (r32s[edx] < signed32(0x0000000a))
        { pc = 0x1dd290; break; }
    r32[edx] = memoryAGet32(ds, 0x30d94c);
    r8[al] = 0x03;
    out8(r16[dx], r8[al]);
    r32[edx] = 0;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1dd2b0: // 0160:1dd2b0
    yield* sub_1dcca0();
    r32[edx]++;
    if (r32s[edx] < signed32(0x0000000a))
        { pc = 0x1dd2b0; break; }
    r32[edx] = memoryAGet32(ds, 0x30d94c);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r8[al] = 0x41;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x45;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x49;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x0e;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = memoryAGet(ds, 0x30d8fc);
    r8[al]--;
    r8[al] |= 0xc0;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d960);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x41;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = r32[esi];
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x49;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = r32[esi];
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x8f;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = r32[esi];
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[edi] = 0;
    memoryASet32(ss, r32[ebp] - 4, r32[edi]);
    if (signed32(memoryAGet32(ds, 0x30d8fc)) <= signed32(0x00000000))
        { pc = 0x1dd3e8; break; }
    { pc = 0x1dd386; break; }
  case 0x1dd32e: // 0160:1dd32e
    r8[al] = 0x06;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x01;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x07;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x10;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x08;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0xe0;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x09;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x0a;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x0b;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x0c;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x07;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx]++;
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    if (r32s[edx] >= signed32(memoryAGet32(ds, 0x30d8fc)))
        { pc = 0x1dd3e8; break; }
  case 0x1dd386: // 0160:1dd386
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = memoryAGet(ss, r32[ebp] - 4);
    out8(r16[dx], r8[al]);
    r8[al] = 0;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x03;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    r8[al] = 0x0d;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x03;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    r8[al] = 0x01;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0x00000400;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x02;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x03;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x04;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    r8[al] = 0x05;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    out16(r16[dx], r16[ax]);
    { pc = 0x1dd32e; break; }
  case 0x1dd3e8: // 0160:1dd3e8
    r32[edx] = memoryAGet32(ds, 0x30d960);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x41;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = r32[esi];
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x49;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = r32[esi];
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x8f;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = r32[esi];
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] = 0x4c;
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r8[al] = 0x07;
    r32[edx] = r32[esi];
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[eax] = 0x00000001;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dd430() // 0160:1dd430 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    flags.carry = !!(r32[edx] & 0x10000000);
    r32[edx] <<= 4;
    r32[eax] -= (r32[edx] + flags.carry);
    r32[eax] = sar32(r32[eax], 0x04);
    r32[ebx] = r32[eax] + 8;
    if (r32s[ebx] >= 0)
        { pc = 0x1dd44c; break; }
    r32[ebx] = 0;
  case 0x1dd44c: // 0160:1dd44c
    if (r32s[ebx] <= signed32(0x0000000f))
        { pc = 0x1dd456; break; }
    r32[ebx] = 0x0000000f;
  case 0x1dd456: // 0160:1dd456
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0c;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dd480() // 0160:1dd480 +long +returnZero
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[ebx] = memoryAGet32(ds, r32[eax] * 4 + 0x2094d4);
    r32[edx] <<= 9;
    r32[eax] = r32[ebx];
    r32[eax] >>>= 1;
    r32[eax] += r32[edx];
    r32[edx] = 0;
    div32(r32[ebx]);
    r32[ebx] = r32[eax] + r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d958);
    r32[eax] = r32[ebx];
    out16(r16[dx], r16[ax]);
    flagsFromReg32(pop32());
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd4d0() // 0160:1dd4d0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet(ds, 0x30d97c, memoryAGet(ds, 0x30d97c) & 0xfd);
    r32[eax] = memoryAGet32(ds, 0x30d97c);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd4f0() // 0160:1dd4f0 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet(ds, 0x30d97c, memoryAGet(ds, 0x30d97c) | 0x02);
    r32[eax] = memoryAGet32(ds, 0x30d97c);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd510() // 0160:1dd510 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet(ds, 0x30d97c, memoryAGet(ds, 0x30d97c) & 0xfe);
    r32[eax] = memoryAGet32(ds, 0x30d97c);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd530() // 0160:1dd530 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet(ds, 0x30d97c, memoryAGet(ds, 0x30d97c) | 0x01);
    r32[eax] = memoryAGet32(ds, 0x30d97c);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd550() // 0160:1dd550 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet(ds, 0x30d97c, memoryAGet(ds, 0x30d97c) | 0x04);
    r32[eax] = memoryAGet32(ds, 0x30d97c);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd570() // 0160:1dd570 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet(ds, 0x30d97c, memoryAGet(ds, 0x30d97c) & 0xfb);
    r32[eax] = memoryAGet32(ds, 0x30d97c);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd590() // 0160:1dd590 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    r32[esi] = r32[eax];
    r32[edi] = r32[edx];
    r32[edx] = r32[ebx];
    memoryASet32(ss, r32[ebp] - 8, r32[ecx]);
    r8[ch] = 0;
    r8[cl] = 0;
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[eax] = (r32[ebx] * 4) + 0;
    r32[eax] += r32[ebx];
    r8[al] = memoryAGet(ds, r32[eax] + 0x2094bc);
    memoryASet(ss, r32[ebp] - 4, r8[al]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    r32[eax] = (r32[eax] * 4) + 0;
    r32[eax] += memoryAGet32(ss, r32[ebp] - 12);
    r8[al] = memoryAGet(ds, r32[eax] + 0x2094bc);
    r8[al] <<= 3;
    if (!r32[esi])
        { pc = 0x1dd5df; break; }
    r32[ebx] = r32s[esi] * signed32(0x00000054);
    r8[ch] = memoryAGet(ds, r32[ebx] + 0x209200);
  case 0x1dd5df: // 0160:1dd5df
    if (!r32[edi])
        { pc = 0x1dd5ec; break; }
    r32[ebx] = r32s[edi] * signed32(0x00000054);
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x209200);
  case 0x1dd5ec: // 0160:1dd5ec
    r8[cl] <<= 3;
    r8[bl] = 0;
    r8[ah] = memoryAGet(ds, 0x30d97c);
    r8[bh] = memoryAGet(ss, r32[ebp] - 4);
    if (r32[edx] != memoryAGet32(ss, r32[ebp] - 8))
        { pc = 0x1dd608; break; }
    if (!r32[edx])
        { pc = 0x1dd608; break; }
    r8[bh] |= 0x40;
    { pc = 0x1dd60a; break; }
  case 0x1dd608: // 0160:1dd608
    r8[bh] |= r8[al];
  case 0x1dd60a: // 0160:1dd60a
    r8[bl] |= r8[ch];
    if (r32[esi] != r32[edi])
        { pc = 0x1dd619; break; }
    if (!r32[edi])
        { pc = 0x1dd619; break; }
    r8[bl] |= 0x40;
    { pc = 0x1dd61b; break; }
  case 0x1dd619: // 0160:1dd619
    r8[bl] |= r8[cl];
  case 0x1dd61b: // 0160:1dd61b
    r32[edx] = memoryAGet32(ds, 0x30d944);
    r32[edx] += 0x0000000f;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    r8[al] = r8[ah];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d974);
    r8[al] ^= r8[ah];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d944);
    r32[edx] += 0x0000000f;
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    r8[al] = r8[ah];
    out8(r16[dx], r8[al]);
    r8[al] = r8[bl];
    r8[al] |= 0x80;
    r32[edx] = memoryAGet32(ds, 0x30d974);
    out8(r16[dx], r8[al]);
    r8[cl] = r8[ah];
    r8[cl] |= 0x40;
    r32[edx] = memoryAGet32(ds, 0x30d968);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d974);
    r8[al] = r8[bh];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    r8[al] = r8[ah];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d974);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d968);
    r8[al] = r8[cl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d974);
    r8[al] = r8[bh];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] ^= r8[bh];
    out8(r16[dx], r8[al]);
    r8[ah] |= 0x09;
    r32[edx] = memoryAGet32(ds, 0x30d968);
    r8[al] = r8[ah];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] ^= r8[ah];
    out8(r16[dx], r8[al]);
    r8[al] = r8[ah];
    r32[eax] &= 0x000000ff;
    memoryASet32(ds, 0x30d97c, r32[eax]);
    flagsFromReg32(pop32());
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dd6d0() // 0160:1dd6d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    memoryASet32(ds, 0x30d97c, 0x0000000b);
    yield* sub_1dd530();
    yield* sub_1dd570();
    yield* sub_1dd4f0();
    yield* sub_1dd220();
    if (!r32[eax])
        { pc = 0x1dd73b; break; }
    r32[ecx] = memoryAGet32(ds, 0x30d90c);
    r32[ebx] = memoryAGet32(ds, 0x30d908);
    r32[edx] = memoryAGet32(ds, 0x30d904);
    r32[eax] = memoryAGet32(ds, 0x30d900);
    yield* sub_1dd590();
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = memoryAGet32(ds, 0x30d908);
    yield* sub_1de780();
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = memoryAGet32(ds, 0x30d908);
    yield* sub_1de210();
    yield* sub_1dd4d0();
    r32[eax] = 0x00000001;
  case 0x1dd73b: // 0160:1dd73b
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dd740() // 0160:1dd740 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    yield* sub_1dd4f0();
    yield* sub_1dd530();
    yield* sub_1dd570();
    memoryASet32(ds, 0x30d8fc, 0x0000000e);
    yield* sub_1dd220();
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = memoryAGet32(ds, 0x30d908);
    yield* sub_1de330();
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = memoryAGet32(ds, 0x30d908);
    yield* sub_1de1c0();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd790() // 0160:1dd790 +long +stackDrop12
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esi] = r32[eax];
    r32[edi] = r32[edx];
    if (r32s[eax] < signed32(0x00000007))
        { pc = 0x1dd7a3; break; }
    if (r32s[eax] <= signed32(0x00000010))
        { pc = 0x1dd7aa; break; }
  case 0x1dd7a3: // 0160:1dd7a3
    r32[eax] = 0;
    { pc = 0x1dd8d6; break; }
  case 0x1dd7aa: // 0160:1dd7aa
    r32[eax] = 0;
    r32[eax] = r32[eax];
  case 0x1dd7b0: // 0160:1dd7b0
    r32[edx] = memoryAGet32(ds, r32[eax] + 0x209558);
    memoryASet32(ds, r32[eax] + 0x30da4c, r32[edx]);
    r32[eax] += 0x00000004;
    if (r32[eax] != 0x00000800)
        { pc = 0x1dd7b0; break; }
    r32[esi] += r32[esi];
    memoryASet32(ds, 0x30d8fc, r32[esi]);
    memoryASet32(ds, 0x30d900, r32[ecx]);
    r32[eax] = memoryAGet32(ss, r32[ebp] + 0x10);
    memoryASet32(ds, 0x30d904, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] + 0x14);
    memoryASet32(ds, 0x30d908, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] + 0x18);
    memoryASet32(ds, 0x30d90c, r32[eax]);
    memoryASet32(ds, 0x30d944, r32[ebx]);
    r32[eax] = r32[ebx] + 257;
    memoryASet32(ds, 0x30d948, r32[eax]);
    r32[eax] = r32[ebx] + 256;
    memoryASet32(ds, 0x30d94c, r32[eax]);
    r32[eax] = r32[ebx] + 258;
    memoryASet32(ds, 0x30d950, r32[eax]);
    r32[eax] = r32[ebx] + 259;
    memoryASet32(ds, 0x30d954, r32[eax]);
    r32[eax] = r32[ebx] + 260;
    memoryASet32(ds, 0x30d958, r32[eax]);
    r32[eax] = r32[ebx] + 261;
    memoryASet32(ds, 0x30d95c, r32[eax]);
    r32[eax] = r32[ebx] + 6;
    memoryASet32(ds, 0x30d960, r32[eax]);
    r32[eax] = r32[ebx] + 263;
    memoryASet32(ds, 0x30d964, r32[eax]);
    memoryASet32(ds, 0x30d968, r32[ebx]);
    r32[eax] = r32[ebx] + 8;
    memoryASet32(ds, 0x30d96c, r32[eax]);
    r32[eax] = r32[ebx] + 9;
    memoryASet32(ds, 0x30d970, r32[eax]);
    r32[ebx] += 0x0000000b;
    memoryASet32(ds, 0x30d974, r32[ebx]);
    r32[eax] = memoryAGet32(ds, 0x30d964);
    memoryASet32(ds, 0x30d978, r32[eax]);
    r32[edx] = 0;
    memoryASet32(ds, 0x30d988, r32[edx]);
    memoryASet32(ds, 0x30d920, r32[edx]);
    memoryASet32(ds, 0x30d924, r32[edx]);
    memoryASet32(ds, 0x30d928, r32[edx]);
    memoryASet32(ds, 0x30d92c, r32[edx]);
    memoryASet32(ds, 0x30d930, r32[edx]);
    memoryASet32(ds, 0x30d934, r32[edx]);
    memoryASet32(ds, 0x30d938, r32[edx]);
    memoryASet32(ds, 0x30d93c, r32[edx]);
    memoryASet32(ds, 0x30d940, r32[edx]);
    yield* sub_1dcaf0();
    yield* sub_1dcea0();
    if (!r32[eax])
        { pc = 0x1dd8d6; break; }
    yield* sub_1dd6d0();
    if (!r32[eax])
        { pc = 0x1dd8d6; break; }
    r32[eax] = r32[edi];
    yield* sub_1dddf0();
    yield* sub_1dcad0();
    r32[eax] = 0x00000001;
  case 0x1dd8d6: // 0160:1dd8d6
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 16;
    return;
  }
}
function* sub_1dd8e0() // 0160:1dd8e0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[ebx] = memoryAGet32(ds, 0x30d950);
    r8[al] = r8[dl];
    r32[edx] = r32[ebx];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x8d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[bl] = r8[al];
    r8[bl] &= 0xfb;
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x80;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[bl] = r8[al];
    r8[bl] &= 0xdc;
    r8[bl] |= 0x03;
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1dd970() // 0160:1dd970 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    if (signed32(memoryAGet32(ds, 0x30d8fc)) <= signed32(0x00000000))
        { pc = 0x1dd98c; break; }
  case 0x1dd97c: // 0160:1dd97c
    r32[eax] = r32[edx];
    yield* sub_1dd8e0();
    r32[edx]++;
    if (r32s[edx] < signed32(memoryAGet32(ds, 0x30d8fc)))
        { pc = 0x1dd97c; break; }
  case 0x1dd98c: // 0160:1dd98c
    yield* sub_1dd740();
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dd9a0() // 0160:1dd9a0 +long +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = r32[ecx];
    r8[ch] = memoryAGet(ss, r32[ebp] + 0x10);
    r32[esi] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ss, r32[ebp] - 12, r32[esi]);
    r32[edi] = r32[edx];
    r32[edx] = r32[ebx];
    r32[esi] = r32[eax];
    r8[cl] = r8[ch];
    if (r32s[ebx] <= r32s[eax])
        { pc = 0x1dd9c9; break; }
    r32[edx] = r32[eax];
    r32[esi] = r32[ebx];
    r8[cl] |= 0x40;
  case 0x1dd9c9: // 0160:1dd9c9
    r8[al] = r8[cl];
    r8[al] &= 0x04;
    r32[eax] &= 0x000000ff;
    if (!r32[eax])
        { pc = 0x1dda0d; break; }
    r32[eax] = r32[edi];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[eax] &= 0x0001ffff;
    r32[edi] &= 0x000c0000;
    r32[eax] |= r32[edi];
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edi] = r32[edx];
    r32[edi] = sar32(r32[edi], 0x00000001);
    r32[edi] &= 0x0001ffff;
    r32[edx] &= 0x000c0000;
    r32[edi] |= r32[edx];
    r32[eax] = r32[esi];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[eax] &= 0x0001ffff;
    r32[esi] &= 0x000c0000;
    r32[esi] |= r32[eax];
    { pc = 0x1dda12; break; }
  case 0x1dda0d: // 0160:1dda0d
    memoryASet32(ss, r32[ebp] - 4, r32[edi]);
    r32[edi] = r32[edx];
  case 0x1dda12: // 0160:1dda12
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = memoryAGet(ss, r32[ebp] - 12);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x8d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[dl] = r8[cl];
    r8[dl] &= 0x01;
    r32[edx] &= 0x000000ff;
    if (!r32[edx])
        { pc = 0x1dda44; break; }
    r8[bl] = r8[al];
    r8[bl] |= 0x04;
    { pc = 0x1dda49; break; }
  case 0x1dda44: // 0160:1dda44
    r8[bl] = r8[al];
    r8[bl] &= 0xfb;
  case 0x1dda49: // 0160:1dda49
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0d;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    yield* sub_1dcca0();
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0b;
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] &= 0x0000007f;
    r32[eax] <<= 9;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x0a;
    out8(r16[dx], r8[al]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = sar32(r32[eax], 0x07);
    r32[eax] &= 0x00001fff;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x02;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[edi];
    r32[eax] = sar32(r32[eax], 0x07);
    r32[eax] &= 0x00001fff;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x03;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[edi];
    r32[eax] &= 0x0000007f;
    r32[eax] <<= 9;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x04;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[esi];
    r32[eax] = sar32(r32[eax], 0x07);
    r32[eax] &= 0x00001fff;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[esi];
    r32[eax] &= 0x0000007f;
    r32[eax] <<= 9;
    r32[edx] = memoryAGet32(ds, 0x30d958);
    out16(r16[dx], r16[ax]);
    flagsFromReg32(pop32());
    push32(flagAsReg32());
    flags.interrupts = 0;
    r8[ah] = r8[cl];
    r8[ah] &= 0xfc;
    r32[edx] = memoryAGet32(ds, 0x30d950);
    r8[al] = memoryAGet(ss, r32[ebp] - 8);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d954);
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d95c);
    r8[al] = r8[ah];
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
    return;
  }
}
function* sub_1ddb40() // 0160:1ddb40 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    flags.zero = r32[eax] == 0;
    if (r32s[eax] < 0)
        { pc = 0x1ddb9f; break; }
    flags.zero = r32[eax] == memoryAGet32(ds, 0x30d8fc);
    if (r32s[eax] >= signed32(memoryAGet32(ds, 0x30d8fc)))
        { pc = 0x1ddb9f; break; }
    if (r32s[ebx] >= signed32(0x00000071))
        { pc = 0x1ddb5f; break; }
    r32[ebx] = 0x00000071;
    { pc = 0x1ddb6c; break; }
  case 0x1ddb5f: // 0160:1ddb5f
    if (r32s[ebx] <= signed32(0x00000358))
        { pc = 0x1ddb6c; break; }
    r32[ebx] = 0x00000358;
  case 0x1ddb6c: // 0160:1ddb6c
    r32[esi] = (r32[ecx] * 4) + 0;
    r32[esi] -= r32[ecx];
    r32[esi] = (r32[esi] * 4) + 0;
    flags.zero = r32[ebx] == memoryAGet32(ds, r32[esi] + 0x30d990);
    if (flags.zero)
        { pc = 0x1ddb9f; break; }
    r32[eax] = 0x0036a040;
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ebx]);
    r32[edx] = r32[eax];
    r32[eax] = r32[ecx];
    yield* sub_1dd480();
    memoryASet32(ds, r32[esi] + 0x30d990, r32[ebx]);
  case 0x1ddb9f: // 0160:1ddb9f
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ddbb0() // 0160:1ddbb0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    if (r32s[eax] < 0)
        { pc = 0x1ddc10; break; }
    if (r32s[eax] >= signed32(memoryAGet32(ds, 0x30d8fc)))
        { pc = 0x1ddc10; break; }
    if (r32s[ebx] >= 0)
        { pc = 0x1ddbcb; break; }
    r32[ebx] = 0;
    { pc = 0x1ddbd5; break; }
  case 0x1ddbcb: // 0160:1ddbcb
    if (r32s[ebx] <= signed32(0x00000040))
        { pc = 0x1ddbd5; break; }
    r32[ebx] = 0x00000040;
  case 0x1ddbd5: // 0160:1ddbd5
    r32[esi] = (r32[ecx] * 4) + 0;
    r32[esi] -= r32[ecx];
    r32[esi] = (r32[esi] * 4) + 0;
    if (r32[ebx] == memoryAGet32(ds, r32[esi] + 0x30d98c))
        { pc = 0x1ddc10; break; }
    r32[eax] = r32[ebx];
    r32[eax] <<= 9;
    r32[eax] -= r32[ebx];
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    flags.carry = !!(r32[edx] & 0x04000000);
    r32[edx] <<= 6;
    r32[eax] -= (r32[edx] + flags.carry);
    r32[eax] = sar32(r32[eax], 0x06);
    r32[edx] = r32[eax];
    r32[eax] = r32[ecx];
    yield* sub_1dcc20();
    memoryASet32(ds, r32[esi] + 0x30d98c, r32[ebx]);
  case 0x1ddc10: // 0160:1ddc10
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ddc20() // 0160:1ddc20 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[eax];
    r32[ecx] = r32[edx];
    flags.zero = r32[eax] == 0;
    if (r32s[eax] < 0)
        { pc = 0x1ddc59; break; }
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    flags.zero = r32[ebx] == r32[eax];
    if (r32s[ebx] >= r32s[eax])
        { pc = 0x1ddc59; break; }
    r32[edx] = r32[ebx];
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] -= r32[edx];
    r32[ebx] += r32[ebx];
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x30d994);
    r32[eax] += r32[ebx];
    r32[edx] = r32[ecx];
    yield* sub_1ddb40();
  case 0x1ddc59: // 0160:1ddc59
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ddca0() // 0160:1ddca0 +long +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000000c;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[edi] = r32[edx];
    memoryASet32(ss, r32[ebp] - 8, r32[ecx]);
    if (r32s[eax] < 0)
        { pc = 0x1ddd94; break; }
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 4);
    if (r32s[eax] <= r32s[ecx])
        { pc = 0x1ddd94; break; }
    if (r32s[edi] < 0)
        { pc = 0x1ddd94; break; }
    if (r32s[edi] > signed32(0x00000180))
        { pc = 0x1ddd94; break; }
    r32[esi] = (r32[ecx] * 4) + 0;
    r32[esi] -= r32[ecx];
    r32[eax] = (r32[esi] * 4) + 0;
    r32[esi] = r32[ecx] + r32[ecx];
    r32[edi]--;
    r32[ecx] = memoryAGet32(ds, r32[eax] + 0x30d994);
    r32[ecx] += r32[esi];
    memoryASet32(ss, r32[ebp] - 12, r32[ecx]);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x30d994);
    r8[al] ^= 0x01;
    r32[esi] += r32[eax];
    if (r32s[edi] < 0)
        { pc = 0x1ddd76; break; }
    r32[ecx] = r32[edi];
    r32[ecx] <<= 4;
    if (signed32(memoryAGet32(ds, r32[ecx] + 0x30c0f8)) < signed32(0x00000000))
        { pc = 0x1ddd76; break; }
    r32[eax] = r32[esi];
    yield* sub_1dd8e0();
    r32[edx] = memoryAGet32(ss, r32[ebp] + 0x10);
    r32[eax] = r32[esi];
    yield* sub_1ddb40();
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = r32[esi];
    yield* sub_1ddbb0();
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x30c100);
    r32[eax] -= memoryAGet32(ds, r32[ecx] + 0x30c0f8);
    if (r32s[ebx] <= r32s[eax])
        { pc = 0x1ddd4d; break; }
    r32[ebx] = r32[eax];
  case 0x1ddd4d: // 0160:1ddd4d
    r32[edi] <<= 4;
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edi] + 0x30c104);
    push32(r32[eax]);
    r32[ecx] = memoryAGet32(ds, r32[edi] + 0x30c100);
    r32[eax] = memoryAGet32(ds, r32[edi] + 0x30c0fc);
    r32[edx] = memoryAGet32(ds, r32[edi] + 0x30c0f8);
    r32[edx] += r32[ebx];
    r32[ebx] = r32[eax];
    r32[eax] = r32[esi];
    yield* sub_1dd9a0();
  case 0x1ddd76: // 0160:1ddd76
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    yield* sub_1ddbb0();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[esi] = (r32[eax] * 4) + 0;
    r32[esi] -= r32[eax];
    memoryASet(ds, r32[esi] * 4 + 0x30d994, memoryAGet(ds, r32[esi] * 4 + 0x30d994) ^ 0x01);
  case 0x1ddd94: // 0160:1ddd94
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
    return;
  }
}
function* sub_1dddb0() // 0160:1dddb0 +long +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esi] = r32[eax];
    r32[eax] = 0x0020b10b;
    yield* sub_1e3508();
    if (!r32[eax])
        { pc = 0x1ddddb; break; }
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x10);
    push32(r32[edi]);
    push32(r32[ecx]);
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(0x0020b114);
    push32(r32[eax]);
    yield* sub_1e3dbe();
    r32[esp] += 0x0000001c;
  case 0x1ddddb: // 0160:1ddddb
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
    return;
  }
}
function* sub_1dddf0() // 0160:1dddf0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = r32[eax];
    r32[ebx] = 0;
    r32[ecx] = 0x00000001;
    { pc = 0x1dde1f; break; }
  case 0x1dde00: // 0160:1dde00
    r32[edi] = r32[esi];
    r32[edi] = -r32[edi];
    r32[eax] = (r32[ebx] * 2) + 0;
    r32[edx] = r32[edi];
    yield* sub_1dd430();
    r32[edx] = r32[edi];
    r32[eax] = r32[ecx];
    yield* sub_1dd430();
  case 0x1dde1b: // 0160:1dde1b
    r32[ecx] += 0x00000002;
    r32[ebx]++;
  case 0x1dde1f: // 0160:1dde1f
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    if (r32s[ebx] >= r32s[eax])
        { pc = 0x1dde62; break; }
    r32[eax] = r32[ebx];
    r32[edx] = r32[ebx];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[edi] = 0x00000004;
    idiv32(r32[edi]);
    if (r32[edx] == 0x00000001)
        { pc = 0x1dde49; break; }
    if (r32[edx] != 0x00000002)
        { pc = 0x1dde00; break; }
  case 0x1dde49: // 0160:1dde49
    r32[eax] = (r32[ebx] * 2) + 0;
    r32[edx] = r32[esi];
    yield* sub_1dd430();
    r32[edx] = r32[esi];
    r32[eax] = r32[ecx];
    yield* sub_1dd430();
    { pc = 0x1dde1b; break; }
  case 0x1dde62: // 0160:1dde62
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dde70() // 0160:1dde70 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    flags.carry = !!(r32[edx] & 0x00004000);
    r32[edx] <<= 18;
    r32[eax] -= (r32[edx] + flags.carry);
    r32[eax] = sar32(r32[eax], 0x12);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1dde80() // 0160:1dde80 +long
{
    r32[esp] -= 4;
    r32[eax] <<= 18;
    r32[esp] += 4;
}
function* sub_1dde90() // 0160:1dde90 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30e250);
    yield* sub_1dde70();
    r32[ebx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30e250);
    r32[eax] += r32[edx];
    yield* sub_1dde70();
    if (r32[ebx] == r32[eax])
        { pc = 0x1ddec5; break; }
    r32[eax] = memoryAGet32(ds, 0x30e250);
    yield* sub_1dde70();
    r32[eax]++;
    yield* sub_1dde80();
    memoryASet32(ds, 0x30e250, r32[eax]);
  case 0x1ddec5: // 0160:1ddec5
    r32[eax] = memoryAGet32(ds, 0x30e250);
    r32[edx] += 0x000000ff;
    r8[dl] = 0;
    r32[ebx] = r32[eax] + r32[edx];
    memoryASet32(ds, 0x30e250, r32[ebx]);
    r32[edx] = r32[ebx];
    if (r32s[edx] <= signed32(memoryAGet32(ds, 0x30e254)))
        { pc = 0x1ddeea; break; }
    r32[eax] = 0xfffffffb;
  case 0x1ddeea: // 0160:1ddeea
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1de180() // 0160:1de180 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    r32[edx] = r32[ecx];
    r32[ecx] = r32[ebx];
    r32[eax] = r32[ebx];
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[edx] = r32[ecx];
    r32[eax] = r32[esi];
    yield* sub_1e23a0();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1de1a0() // 0160:1de1a0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    r32[ebx] = r32[ebp] - 4;
    r32[edx] = r32[ebp] - 8;
    yield* sub_1e2350();
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1de1c0() // 0160:1de1c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    if (!r32[eax])
        { pc = 0x1de1e3; break; }
    r16[cx] = memoryAGet16(ds, 0x30d914);
    r32[ebx] = memoryAGet32(ds, 0x30d910);
    r32[eax] = memoryAGet32(ds, 0x30d908);
    yield* sub_1de180();
  case 0x1de1e3: // 0160:1de1e3
    if (r32[esi] == r32[edx])
        { pc = 0x1de205; break; }
    if (!r32[edx])
        { pc = 0x1de205; break; }
    r16[cx] = memoryAGet16(ds, 0x30d91c);
    r32[ebx] = memoryAGet32(ds, 0x30d918);
    r32[eax] = memoryAGet32(ds, 0x30d90c);
    yield* sub_1de180();
  case 0x1de205: // 0160:1de205
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1de210() // 0160:1de210 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    if (!r32[eax])
        { pc = 0x1de284; break; }
    r32[edx] = memoryAGet32(ds, 0x30d908);
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] += r32[edx];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2094c0);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[edx] = memoryAGet32(ds, 0x30d908);
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] += r32[edx];
    r8[dl] = memoryAGet(ss, r32[ebp] - 8);
    r8[dh] = memoryAGet(ds, r32[eax] + 0x2094bd);
    r8[dl] &= r8[dh];
    memoryASet(ss, r32[ebp] - 4, r8[dl]);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2094c0);
    r8[al] = memoryAGet(ss, r32[ebp] - 4);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d908);
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] += r32[edx];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2094bf);
    r8[al] = memoryAGet(ds, r32[eax] + 0x2094be);
    out8(r16[dx], r8[al]);
  case 0x1de284: // 0160:1de284
    if (r32[ebx] == r32[ecx])
        { pc = 0x1de2f0; break; }
    if (!r32[ebx])
        { pc = 0x1de2f0; break; }
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] += r32[edx];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2094c0);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] += r32[edx];
    r8[dl] = memoryAGet(ss, r32[ebp] - 8);
    r8[dh] = memoryAGet(ds, r32[eax] + 0x2094bd);
    r8[dl] &= r8[dh];
    memoryASet(ss, r32[ebp] - 4, r8[dl]);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2094c0);
    r8[al] = memoryAGet(ss, r32[ebp] - 4);
    out8(r16[dx], r8[al]);
    r32[edx] = memoryAGet32(ds, 0x30d90c);
    r32[eax] = (r32[edx] * 4) + 0;
    r32[eax] += r32[edx];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax] + 0x2094bf);
    r8[al] = memoryAGet(ds, r32[eax] + 0x2094be);
    out8(r16[dx], r8[al]);
  case 0x1de2f0: // 0160:1de2f0
    if (r32s[ebx] > signed32(0x00000007))
        { pc = 0x1de2fa; break; }
    if (r32s[ecx] <= signed32(0x00000007))
        { pc = 0x1de322; break; }
  case 0x1de2fa: // 0160:1de2fa
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, 0x2094ca);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] &= memoryAGet(ds, 0x2094c7);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, 0x2094ca);
    out8(r16[dx], r8[al]);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, 0x2094c9);
    r8[al] = memoryAGet(ds, 0x2094c8);
    out8(r16[dx], r8[al]);
  case 0x1de322: // 0160:1de322
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1de330() // 0160:1de330 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[edx];
    if (r32[eax] == 0x00000002)
        { pc = 0x1de366; break; }
    if (!r32[eax])
        { pc = 0x1de366; break; }
    r32[edx] = r32[eax];
    r32[ecx] = (r32[eax] * 4) + 0;
    r32[ecx] += r32[eax];
    r32[edx] ^= r32[eax];
    r8[dl] = memoryAGet(ds, r32[ecx] + 0x2094c0);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[ah] = memoryAGet(ds, r32[ecx] + 0x2094bd);
    r8[ah] = ~r8[ah];
    r8[al] |= r8[ah];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[ecx] + 0x2094c0);
    out8(r16[dx], r8[al]);
  case 0x1de366: // 0160:1de366
    if (r32[ebx] == 0x00000002)
        { pc = 0x1de396; break; }
    if (!r32[ebx])
        { pc = 0x1de396; break; }
    r32[eax] = (r32[ebx] * 4) + 0;
    r32[ebx] += r32[eax];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[ebx] + 0x2094c0);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[ah] = memoryAGet(ds, r32[ebx] + 0x2094bd);
    r8[ah] = ~r8[ah];
    r8[al] |= r8[ah];
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[ebx] + 0x2094c0);
    out8(r16[dx], r8[al]);
  case 0x1de396: // 0160:1de396
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1de780() // 0160:1de780 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[edi] = r32[eax];
    r32[esi] = r32[edx];
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    if (!r32[eax])
        { pc = 0x1de7c3; break; }
    if (r32s[eax] <= signed32(0x00000007))
        { pc = 0x1de79f; break; }
    r32[edi] = r32[eax] + 104;
    { pc = 0x1de7a2; break; }
  case 0x1de79f: // 0160:1de79f
    r32[edi] = r32[eax] + 8;
  case 0x1de7a2: // 0160:1de7a2
    r32[eax] = r32[edi];
    yield* sub_1de1a0();
    memoryASet16(ds, 0x30d914, r16[dx]);
    memoryASet32(ds, 0x30d910, r32[eax]);
    r32[ecx] = cs;
    r32[ebx] = 0x001dca88;
    r32[eax] = r32[edi];
    yield* sub_1de180();
  case 0x1de7c3: // 0160:1de7c3
    if (!r32[esi])
        { pc = 0x1de7fa; break; }
    if (r32[esi] == memoryAGet32(ss, r32[ebp] - 4))
        { pc = 0x1de7fa; break; }
    if (r32s[esi] <= signed32(0x00000007))
        { pc = 0x1de7d6; break; }
    r32[esi] += 0x00000068;
    { pc = 0x1de7d9; break; }
  case 0x1de7d6: // 0160:1de7d6
    r32[esi] += 0x00000008;
  case 0x1de7d9: // 0160:1de7d9
    r32[eax] = r32[esi];
    yield* sub_1de1a0();
    memoryASet16(ds, 0x30d91c, r16[dx]);
    memoryASet32(ds, 0x30d918, r32[eax]);
    r32[ecx] = cs;
    r32[ebx] = 0x001dcaa5;
    r32[eax] = r32[esi];
    yield* sub_1de180();
  case 0x1de7fa: // 0160:1de7fa
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dea00() // 0160:1dea00 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000018;
    memoryASet32(ss, r32[ebp] - 24, r32[eax]);
    memoryASet32(ss, r32[ebp] - 16, r32[edx]);
    memoryASet32(ss, r32[ebp] - 8, r32[ebx]);
    memoryASet32(ss, r32[ebp] - 20, r32[ecx]);
    r8[ah] = 0;
    memoryASet(ss, r32[ebp] - 4, r8[ah]);
    if (!r32[ebx])
        { pc = 0x1deab8; break; }
  case 0x1dea21: // 0160:1dea21
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    r32[edi] = memoryAGet32(ds, 0x2094b8);
    if (r32s[eax] <= r32s[edi])
        { pc = 0x1dea32; break; }
    r32[esi] = r32[edi];
    { pc = 0x1dea34; break; }
  case 0x1dea32: // 0160:1dea32
    r32[esi] = r32[eax];
  case 0x1dea34: // 0160:1dea34
    memoryASet32(ss, r32[ebp] - 12, r32[esi]);
    if (!memoryAGet32(ss, r32[ebp] - 20))
        { pc = 0x1dea7a; break; }
    r32[edx] = r32[esi] + 1;
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    r32[edi] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x30d8f8);
    r32[eax] += r32[edi];
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 24);
    r32[ebx] = 0x00000001;
    r32[edx] = r32[edi];
    yield* sub_1e3b5d();
    if (r32[eax] != 0x00000001)
        { pc = 0x1deab8; break; }
    r32[eax] = memoryAGet32(ds, 0x30d8f8);
    r32[edx] = r32[eax] + r32[edi];
    r32[ecx] = r32[ebp] - 4;
    r32[ebx] = r32[esi];
    yield* sub_1db6c0();
    { pc = 0x1dea93; break; }
  case 0x1dea7a: // 0160:1dea7a
    r32[eax] = memoryAGet32(ds, 0x30d8f8);
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 24);
    r32[ebx] = 0x00000001;
    r32[edx] = r32[esi];
    yield* sub_1e3b5d();
    if (r32[eax] != 0x00000001)
        { pc = 0x1deab8; break; }
  case 0x1dea93: // 0160:1dea93
    r32[edx] = memoryAGet32(ds, 0x30d8f8);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 16);
    yield* sub_1dcd00();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ss, r32[ebp] - 16, memoryAGet32(ss, r32[ebp] - 16) + r32[eax]);
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[ecx] -= r32[eax];
    memoryASet32(ss, r32[ebp] - 8, r32[ecx]);
    if (r32[ecx])
        { pc = 0x1dea21; break; }
  case 0x1deab8: // 0160:1deab8
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1deac0() // 0160:1deac0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esi] = 0x00000080;
    r32[edx] -= r32[eax];
    if (r32s[edx] >= r32s[esi])
        { pc = 0x1dead0; break; }
    r32[esi] = r32[edx];
  case 0x1dead0: // 0160:1dead0
    r32[ecx] = 0;
    if (r32s[esi] <= 0)
        { pc = 0x1deafd; break; }
    r32[ebx] = r32[eax];
  case 0x1dead8: // 0160:1dead8
    r32[eax] = r32[ebx];
    yield* sub_1dcd20();
    r32[edx] = r8s[al];
    r32[edx] = r32s[edx] * r32s[ecx];
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[esi]);
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = r32[ebx];
    yield* sub_1dccc0();
    r32[ebx]++;
    r32[ecx]++;
    if (r32s[ecx] < r32s[esi])
        { pc = 0x1dead8; break; }
  case 0x1deafd: // 0160:1deafd
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1deb10() // 0160:1deb10 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ebx] = r32[eax];
    r32[eax] = r32[edx];
    r32[esi] = 0x00000080;
    r32[edx] -= r32[ebx];
    if (r32s[edx] >= r32s[esi])
        { pc = 0x1deb24; break; }
    r32[esi] = r32[edx];
  case 0x1deb24: // 0160:1deb24
    r32[ecx] = 0;
    if (r32s[esi] <= 0)
        { pc = 0x1deb52; break; }
    r32[ebx] = r32[eax] - 1;
  case 0x1deb2d: // 0160:1deb2d
    r32[eax] = r32[ebx];
    yield* sub_1dcd20();
    r32[edx] = r8s[al];
    r32[edx] = r32s[edx] * r32s[ecx];
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[esi]);
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = r32[ebx];
    yield* sub_1dccc0();
    r32[ebx]--;
    r32[ecx]++;
    if (r32s[ecx] < r32s[esi])
        { pc = 0x1deb2d; break; }
  case 0x1deb52: // 0160:1deb52
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1deb60() // 0160:1deb60 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000003c;
    r32[esi] = r32[eax];
    memoryASet32(ss, r32[ebp] - 12, r32[edx]);
    if (memoryAGet32(ds, 0x30d8f8))
        { pc = 0x1debc0; break; }
    r32[eax] = memoryAGet32(ds, 0x2094b8);
    r32[edx] = 0x00000100;
    yield* sub_1e2510();
    memoryASet32(ds, 0x30d8f8, r32[eax]);
    if (r32[eax])
        { pc = 0x1deb9a; break; }
    r32[eax] = 0xfffffffc;
    { pc = 0x1ded67; break; }
  case 0x1deb9a: // 0160:1deb9a
    r32[eax] = 0;
    r32[ebx] = 0xffffffff;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[eax] = r32[eax];
  case 0x1debb0: // 0160:1debb0
    memoryASet32(ds, r32[eax] + 0x30c0f8, r32[ebx]);
    r32[eax] += 0x00000010;
    if (r32[eax] != 0x00001800)
        { pc = 0x1debb0; break; }
  case 0x1debc0: // 0160:1debc0
    r32[ecx] = r32[esi];
    r32[ebx] = 0x00000001;
    r32[edx] = 0x00000030;
    r32[eax] = r32[ebp] - 60;
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1debe6; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1debe6: // 0160:1debe6
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b123;
    r32[eax] = r32[ebp] - 60;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1dec1f; break; }
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b128;
    r32[eax] = r32[ebp] - 60;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1dec1f; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dec1f: // 0160:1dec1f
    r32[eax] = r32[ebp] - 52;
    yield* sub_1e0940();
    r32[edi] = r32[eax];
    if (r32s[eax] < 0)
        { pc = 0x1ded67; break; }
    r32[edx] = r32[eax];
    r32[edx] <<= 4;
    if (signed32(memoryAGet32(ds, r32[edx] + 0x30c0f8)) < signed32(0x00000000))
        { pc = 0x1dec49; break; }
    r32[eax] = 0;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1dec49: // 0160:1dec49
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 16);
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 20);
    if (r32[eax] != memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1dec67; break; }
    r8[bl] = 0;
    memoryASet(ds, r32[edx] + 0x30c104, r8[bl]);
    { pc = 0x1dec6e; break; }
  case 0x1dec67: // 0160:1dec67
    memoryASet(ds, r32[edx] + 0x30c104, 0x08);
  case 0x1dec6e: // 0160:1dec6e
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] += 0x00000020;
    yield* sub_1dde90();
    if (r32s[eax] < 0)
        { pc = 0x1ded67; break; }
    r32[edi] <<= 4;
    memoryASet32(ds, r32[edi] + 0x30c0f8, r32[eax]);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 20);
    r32[edx] += r32[eax];
    memoryASet32(ds, r32[edi] + 0x30c0fc, r32[edx]);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx] += r32[eax];
    memoryASet32(ds, r32[edi] + 0x30c100, r32[edx]);
    r32[ecx] = memoryAGet32(ss, r32[ebp] - 12);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx] = r32[eax];
    r32[eax] = r32[esi];
    yield* sub_1dea00();
    r8[al] = memoryAGet(ds, r32[edi] + 0x30c104);
    r8[al] &= 0x08;
    r32[eax] &= 0x000000ff;
    if (!r32[eax])
        { pc = 0x1ded0f; break; }
    r32[edx] = memoryAGet32(ds, r32[edi] + 0x30c0fc);
    r32[eax] = memoryAGet32(ds, r32[edi] + 0x30c0f8);
    yield* sub_1deac0();
    r32[esi] = memoryAGet32(ss, r32[ebp] - 4);
    r32[esi] -= memoryAGet32(ss, r32[ebp] - 8);
    r32[ebx] = 0;
    r32[ecx] = r32[edi];
    r32[eax] = r32[eax];
  case 0x1dece0: // 0160:1dece0
    r32[eax] = r32[ebx];
    r32[edx] = r32[ebx];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[esi]);
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x30c0fc);
    r32[eax] += r32[edx];
    yield* sub_1dcd20();
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x30c100);
    r32[eax] += r32[ebx];
    yield* sub_1dccc0();
    r32[ebx]++;
    if (r32s[ebx] >= signed32(0x00000020))
        { pc = 0x1ded62; break; }
    { pc = 0x1dece0; break; }
  case 0x1ded0f: // 0160:1ded0f
    r32[edx] = memoryAGet32(ds, r32[edi] + 0x30c100);
    r32[eax] = memoryAGet32(ds, r32[edi] + 0x30c0f8);
    yield* sub_1deac0();
    r32[edx] = memoryAGet32(ds, r32[edi] + 0x30c100);
    r32[eax] = memoryAGet32(ds, r32[edi] + 0x30c0f8);
    yield* sub_1deb10();
    r32[ebx] = 0;
    r32[ecx] = r32[edi];
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[ebx] = r32[ebx];
  case 0x1ded40: // 0160:1ded40
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x30c0f8);
    yield* sub_1dcd20();
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x30c100);
    r32[eax] += r32[ebx];
    yield* sub_1dccc0();
    r32[ebx]++;
    if (r32s[ebx] < signed32(0x00000020))
        { pc = 0x1ded40; break; }
  case 0x1ded62: // 0160:1ded62
    r32[eax] = 0x00000001;
  case 0x1ded67: // 0160:1ded67
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ded70() // 0160:1ded70 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = 0;
    r32[edi] = 0;
    { pc = 0x1ded8a; break; }
  case 0x1ded7b: // 0160:1ded7b
    push32(r32[edi]);
    r32[ecx] = r32[edi];
    r32[ebx] = r32[edi];
    r32[edx] = r32[edi];
    r32[eax] = r32[esi];
    yield* sub_1ddca0();
    r32[esi]++;
  case 0x1ded8a: // 0160:1ded8a
    r32[eax] = memoryAGet32(ds, 0x30d8fc);
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    if (r32s[esi] < r32s[eax])
        { pc = 0x1ded7b; break; }
    r32[eax] = 0;
    r32[edx] = 0xffffffff;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1dedb0: // 0160:1dedb0
    memoryASet32(ds, r32[eax] + 0x30c0f8, r32[edx]);
    r32[eax] += 0x00000010;
    if (r32[eax] != 0x00001800)
        { pc = 0x1dedb0; break; }
    yield* sub_1dcad0();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dedd0() // 0160:1dedd0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    r32[edx] += r32[ebx];
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    r32[eax] -= r32[edx];
    r32[eax] = sar32(r32[eax], 0x00000001);
    if (r32s[eax] >= signed32(0x00000080))
        { pc = 0x1dee02; break; }
    { pc = 0x1dee2b; break; }
  case 0x1dede7: // 0160:1dede7
    yield* sub_1dd4d0();
    { pc = 0x1dee41; break; }
  case 0x1dedf1: // 0160:1dedf1
    yield* sub_1dd510();
    { pc = 0x1dee41; break; }
  case 0x1dedfb: // 0160:1dedfb
    yield* sub_1dd550();
    { pc = 0x1dee41; break; }
  case 0x1dee02: // 0160:1dee02
    if (r32[ecx] < 0x00000003)
        { pc = 0x1dee10; break; }
    if (r32[ecx] <= 0x00000003)
        { pc = 0x1dedf1; break; }
    if (r32[ecx] == 0x00000004)
        { pc = 0x1dedfb; break; }
    { pc = 0x1dee3d; break; }
  case 0x1dee10: // 0160:1dee10
    if (!r32[ecx])
        { pc = 0x1dede7; break; }
    { pc = 0x1dee3d; break; }
  case 0x1dee16: // 0160:1dee16
    yield* sub_1dd4f0();
    { pc = 0x1dee41; break; }
  case 0x1dee1d: // 0160:1dee1d
    yield* sub_1dd530();
    { pc = 0x1dee41; break; }
  case 0x1dee24: // 0160:1dee24
    yield* sub_1dd570();
    { pc = 0x1dee41; break; }
  case 0x1dee2b: // 0160:1dee2b
    if (r32[ecx] < 0x00000003)
        { pc = 0x1dee39; break; }
    if (r32[ecx] <= 0x00000003)
        { pc = 0x1dee1d; break; }
    if (r32[ecx] == 0x00000004)
        { pc = 0x1dee24; break; }
    { pc = 0x1dee3d; break; }
  case 0x1dee39: // 0160:1dee39
    if (!r32[ecx])
        { pc = 0x1dee16; break; }
  case 0x1dee3d: // 0160:1dee3d
    r32[eax] = 0;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1dee41: // 0160:1dee41
    r32[eax] = 0x00000001;
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df1f0() // 0160:1df1f0 +long
{
    r32[esp] -= 4;
    memoryASet32(ds, 0x30e264, r32[eax]);
    r32[esp] += 4;
}
function* sub_1df200() // 0160:1df200 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[esi] = r32[eax];
    r32[edi] = r32[edx];
    if (memoryAGet32(ds, 0x30e268))
        { pc = 0x1df238; break; }
    r32[eax] = memoryAGet32(ds, 0x209ea4);
    r32[edx] = 0x00000100;
    yield* sub_1e2510();
    memoryASet32(ds, 0x30e268, r32[eax]);
    if (r32[eax])
        { pc = 0x1df238; break; }
    r32[eax] = 0xfffffffc;
    { pc = 0x1df2e2; break; }
  case 0x1df238: // 0160:1df238
    r32[eax] = r32[edi];
    r32[edx] = r32[edi];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ebx]);
    r32[ecx] = r32[eax] + 31;
    r8[cl] &= 0xe0;
    r32[ebx] = memoryAGet32(ds, 0x209ea4);
    if (r32s[ecx] <= r32s[ebx])
        { pc = 0x1df253; break; }
    r32[ecx] = r32[ebx];
  case 0x1df253: // 0160:1df253
    r32[eax] = r32[esi];
    yield* sub_1dd8e0();
    r32[eax] = (r32[ecx] * 2) + 0;
    r32[eax] += 0x00000020;
    yield* sub_1dde90();
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    memoryASet32(ds, 0x30e258, r32[eax]);
    memoryASet32(ds, 0x30e25c, r32[ecx]);
    memoryASet32(ds, 0x30e260, 0x00000001);
    r32[edx] = 0;
    memoryASet32(ds, 0x30e264, r32[edx]);
    memoryASet32(ds, 0x209ea8, r32[esi]);
    r32[ebx] = 0;
    { pc = 0x1df2a2; break; }
  case 0x1df293: // 0160:1df293
    r32[eax] = memoryAGet32(ds, 0x30e258);
    r32[eax] += r32[ebx];
    r32[edx] = 0;
    yield* sub_1dccc0();
    r32[ebx]++;
  case 0x1df2a2: // 0160:1df2a2
    r32[eax] = memoryAGet32(ds, 0x30e25c);
    r32[eax] += r32[eax];
    r32[eax] += 0x00000020;
    if (r32s[ebx] < r32s[eax])
        { pc = 0x1df293; break; }
    r32[edx] = r32[edi];
    r32[eax] = r32[esi];
    yield* sub_1dd480();
    memoryASet32(ds, 0x30d928, 0x001deef0);
    r32[eax] = 0;
    yield* sub_1dddf0();
    push32(0x00000021);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[ecx] += r32[eax];
    r32[ecx] += 0x0000001f;
    r32[ebx] = r32[eax] + 31;
    r32[edx] = r32[eax];
    r32[eax] = r32[esi];
    yield* sub_1dd9a0();
    r32[eax] = r32[edi];
  case 0x1df2e2: // 0160:1df2e2
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df310() // 0160:1df310 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    memoryASet32(ds, r32[eax], 0x00000258);
    memoryASet32(ds, r32[eax] + 0x8, 0x00209ed8);
    r32[edx] = memoryAGet32(ds, r32[eax] + 0x8);
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
    memoryASet32(ds, r32[eax] + 0xc, 0x00209edc);
    memoryASet32(ds, r32[eax] + 0x18, 0x00000000);
    r32[edx] = memoryAGet32(ds, r32[eax] + 0x18);
    memoryASet32(ds, r32[eax] + 0x14, r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1df340() // 0160:1df340 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = r32[eax];
    r32[edi] = r32[edx];
    r32[edx] = r32[ebx];
    if (r32s[eax] < 0)
        { pc = 0x1df3e4; break; }
    if (r32s[eax] >= signed32(memoryAGet32(ds, 0x30e26c)))
        { pc = 0x1df3e4; break; }
    if (r32s[edi] < 0)
        { pc = 0x1df3e4; break; }
    if (r32s[edi] > signed32(0x00000180))
        { pc = 0x1df3e4; break; }
    yield* sub_1df3f0();
    r32[edx] = r32[ecx];
    r32[eax] = r32[esi];
    yield* sub_1df430();
    r32[eax] = r32[esi];
    r32[eax] = (r32[eax] * 8) + 0;
    r32[eax] -= r32[esi];
    r32[eax] = (r32[eax] * 4) + 0;
    r32[eax] += 0x0030fa70;
    if (!r32[edi])
        { pc = 0x1df3c9; break; }
    r32[edi] <<= 4;
    if (!memoryAGet32(ds, r32[edi] + 0x30e260))
        { pc = 0x1df3c9; break; }
    r32[esi] = 0x0030e270;
    r32[esi] += r32[edi];
    r32[esi] -= 0x00000010;
    r32[edx] = memoryAGet32(ds, r32[esi]);
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[eax] + 0x8, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x8);
    memoryASet32(ds, r32[eax] + 0xc, r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0xc);
    memoryASet32(ds, r32[eax] + 0x10, r32[edx]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1df3c9: // 0160:1df3c9
    memoryASet32(ds, r32[eax] + 0x8, 0x00209ed8);
    r32[edx] = memoryAGet32(ds, r32[eax] + 0x8);
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
    memoryASet32(ds, r32[eax] + 0xc, 0x00209edc);
    memoryASet32(ds, r32[eax] + 0x10, 0x00010000);
  case 0x1df3e4: // 0160:1df3e4
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df3f0() // 0160:1df3f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    if (r32s[eax] < 0)
        { pc = 0x1df42b; break; }
    if (r32s[eax] >= signed32(memoryAGet32(ds, 0x30e26c)))
        { pc = 0x1df42b; break; }
    if (r32s[edx] >= 0)
        { pc = 0x1df406; break; }
    r32[edx] = 0;
    { pc = 0x1df410; break; }
  case 0x1df406: // 0160:1df406
    if (r32s[edx] <= signed32(0x00000040))
        { pc = 0x1df410; break; }
    r32[edx] = 0x00000040;
  case 0x1df410: // 0160:1df410
    r32[ebx] = r32[eax];
    r32[eax] = (r32[eax] * 8) + 0;
    r32[eax] -= r32[ebx];
    memoryASet32(ds, r32[eax] * 4 + 0x30fa84, r32[edx]);
    r32[ecx] = 0;
    memoryASet32(ds, r32[eax] * 4 + 0x30fa88, r32[ecx]);
  case 0x1df42b: // 0160:1df42b
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df430() // 0160:1df430 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[eax];
    r32[ecx] = r32[edx];
    flags.zero = r32[eax] == 0;
    if (r32s[eax] < 0)
        { pc = 0x1df462; break; }
    flags.zero = r32[eax] == memoryAGet32(ds, 0x30e26c);
    if (r32s[eax] >= signed32(memoryAGet32(ds, 0x30e26c)))
        { pc = 0x1df462; break; }
    r32[eax] = 0x0036a040;
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ecx]);
    r32[edx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[eax] = (r32[eax] * 8) + 0;
    r32[eax] -= r32[ebx];
    flags.zero = r32[eax] == 0;
    memoryASet32(ds, r32[eax] * 4 + 0x30fa70, r32[edx]);
  case 0x1df462: // 0160:1df462
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df5b0() // 0160:1df5b0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    memoryASet32(ds, 0x30e26c, r32[eax]);
    r32[edx] = 0;
    memoryASet32(ds, 0x30fae0, r32[edx]);
    r32[ebx] = 0;
    if (r32s[eax] <= 0)
        { pc = 0x1df5dd; break; }
    r32[edx] = 0x0030fa70;
  case 0x1df5ca: // 0160:1df5ca
    r32[eax] = r32[edx];
    yield* sub_1df310();
    r32[edx] += 0x0000001c;
    r32[ebx]++;
    if (r32s[ebx] < signed32(memoryAGet32(ds, 0x30e26c)))
        { pc = 0x1df5ca; break; }
  case 0x1df5dd: // 0160:1df5dd
    yield* sub_1dc990();
    r32[eax] = 0x001df560;
    yield* sub_1dc840();
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df600() // 0160:1df600 +long
{
    r32[esp] -= 4;
    yield* sub_1dc9c0();
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[ebx] = r32[ebx];
    push32(r32[edx]);
    r32[edx] = 0x00000061;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r8[al] &= 0xfe;
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1df620() // 0160:1df620 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000034;
    r32[esi] = r32[eax];
    if (!memoryAGet32(ds, 0x209ed4))
        { pc = 0x1df658; break; }
    r32[eax] = 0;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1df640: // 0160:1df640
    r32[ebx] = 0;
    memoryASet32(ds, r32[eax] + 0x30e270, r32[ebx]);
    r32[eax] += 0x00000010;
    if (r32[eax] != 0x00001800)
        { pc = 0x1df640; break; }
    memoryASet32(ds, 0x209ed4, r32[ebx]);
  case 0x1df658: // 0160:1df658
    r32[ecx] = r32[esi];
    r32[ebx] = 0x00000001;
    r32[edx] = 0x00000034;
    r32[eax] = r32[ebp] - 52;
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1df67b; break; }
    r32[eax] = 0xfffffffd;
    { pc = 0x1df72a; break; }
  case 0x1df67b: // 0160:1df67b
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b184;
    r32[eax] = r32[ebp] - 52;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1df69e; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df69e: // 0160:1df69e
    r32[eax] = r32[ebp] - 44;
    yield* sub_1e0940();
    if (r32s[eax] < 0)
        { pc = 0x1df72a; break; }
    r32[ebx] = r32[eax];
    r32[ebx] <<= 4;
    if (memoryAGet32(ds, r32[ebx] + 0x30e270))
        { pc = 0x1df728; break; }
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[edx] = (r32[edx] * 4) + 0;
    r32[eax] = 0x0020b189;
    yield* sub_1df820();
    if (!r32[eax])
        { pc = 0x1df72a; break; }
    memoryASet32(ds, r32[ebx] + 0x30e270, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = (r32[eax] * 4) + 0;
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x30e270);
    r32[eax] += r32[edx];
    memoryASet32(ds, r32[ebx] + 0x30e274, r32[eax]);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[edx] = (r32[edx] * 4) + 0;
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x30e270);
    r32[eax] += r32[edx];
    memoryASet32(ds, r32[ebx] + 0x30e278, r32[eax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ds, r32[ebx] + 0x30e27c, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x30e270);
    r32[ecx] = r32[esi];
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[edx] = 0x00000004;
    yield* sub_1e3b5d();
  case 0x1df728: // 0160:1df728
    r32[eax] = 0;
  case 0x1df72a: // 0160:1df72a
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df740() // 0160:1df740 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[ebx] = 0;
    if (signed32(memoryAGet32(ds, 0x30e26c)) <= signed32(0x00000000))
        { pc = 0x1df766; break; }
    r32[edx] = 0x0030fa70;
  case 0x1df753: // 0160:1df753
    r32[eax] = r32[edx];
    yield* sub_1df310();
    r32[edx] += 0x0000001c;
    r32[ebx]++;
    if (r32s[ebx] < signed32(memoryAGet32(ds, 0x30e26c)))
        { pc = 0x1df753; break; }
  case 0x1df766: // 0160:1df766
    r32[eax] = 0;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1df770: // 0160:1df770
    r32[esi] = 0;
    memoryASet32(ds, r32[eax] + 0x30e270, r32[esi]);
    r32[eax] += 0x00000010;
    if (r32[eax] != 0x00001800)
        { pc = 0x1df770; break; }
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df790() // 0160:1df790 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[ebx] = memoryAGet32(ds, 0x30faf0);
    if (!r32[ebx])
        { pc = 0x1df7a5; break; }
    r32[eax] = r32[ebx];
    yield* sub_1e3df8();
  case 0x1df7a5: // 0160:1df7a5
    memoryASet32(ds, 0x30faf8, r32[edx]);
    r32[eax] = r32[edx];
    yield* sub_1e3562();
    memoryASet32(ds, 0x30faf0, r32[eax]);
    memoryASet32(ds, 0x30faf4, r32[eax]);
    if (!r32[eax])
        { pc = 0x1df7d4; break; }
    r32[edx] = memoryAGet32(ds, 0x30faf8);
    yield* sub_1e2460();
    if (!r32[eax])
        { pc = 0x1df7d4; break; }
    r32[eax] = 0x00000001;
  case 0x1df7d4: // 0160:1df7d4
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df820() // 0160:1df820 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = memoryAGet32(ds, 0x30faf4);
    r32[edx] += 0x00000003;
    r8[dl] &= 0xfc;
    r32[eax] = r32[ebx] + r32[edx];
    memoryASet32(ds, 0x30faf4, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x30faf0);
    r32[eax] += memoryAGet32(ds, 0x30faf8);
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x30faf4)))
        { pc = 0x1df851; break; }
    if (memoryAGet32(ds, 0x30faf0))
        { pc = 0x1df855; break; }
  case 0x1df851: // 0160:1df851
    r32[eax] = 0;
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df855: // 0160:1df855
    r32[eax] = r32[ebx];
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df860() // 0160:1df860 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x30faf0);
    memoryASet32(ds, 0x30faf4, r32[eax]);
    r32[esp] += 4;
}
function* sub_1df870() // 0160:1df870 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    if (!memoryAGet32(ds, 0x209f34))
        { pc = 0x1df8ae; break; }
    r32[eax] = 0;
    r32[ecx] = 0xffffffff;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[eax] = r32[eax];
  case 0x1df890: // 0160:1df890
    r32[ebx] = 0;
    memoryASet32(ds, r32[eax] + 0x31310c, r32[ebx]);
    memoryASet32(ds, r32[eax] + 0x313110, r32[ecx]);
    r32[eax] += 0x00000008;
    if (r32[eax] != 0x00000200)
        { pc = 0x1df890; break; }
    memoryASet32(ds, 0x209f34, r32[ebx]);
  case 0x1df8ae: // 0160:1df8ae
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df8c0() // 0160:1df8c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1df989; break; }
    r32[eax]--;
    if (r32[edx] & r32[eax])
        { pc = 0x1df987; break; }
    if (memoryAGet32(ds, 0x30fae8) & r32[edx])
        { pc = 0x1df900; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1df8e2: // 0160:1df8e2
    yield* sub_1db8b0();
    { pc = 0x1df91d; break; }
  case 0x1df8ec: // 0160:1df8ec
    yield* sub_1db9d0();
    { pc = 0x1df91d; break; }
  case 0x1df8f6: // 0160:1df8f6
    yield* sub_1dcc70();
    { pc = 0x1df91d; break; }
  case 0x1df900: // 0160:1df900
    yield* sub_1e0380();
    r32[eax] = memoryAGet32(ds, 0x30faec);
    if (r32[eax] < 0x00000002)
        { pc = 0x1df91d; break; }
    if (r32[eax] <= 0x00000002)
        { pc = 0x1df8f6; break; }
    if (r32[eax] < 0x00000004)
        { pc = 0x1df91d; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1df8e2; break; }
    if (r32[eax] == 0x00000010)
        { pc = 0x1df8ec; break; }
  case 0x1df91d: // 0160:1df91d
    r32[ecx] = 0;
    memoryASet32(ds, 0x30faec, r32[ecx]);
    if (r32[edx] < 0x00000004)
        { pc = 0x1df97a; break; }
    if (r32[edx] <= 0x00000004)
        { pc = 0x1df933; break; }
    if (r32[edx] == 0x00000010)
        { pc = 0x1df948; break; }
    { pc = 0x1df972; break; }
  case 0x1df933: // 0160:1df933
    r32[eax] = 0x001e31a0;
    yield* sub_1db8a0();
    memoryASet32(ds, 0x30faec, r32[edx]);
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1df948: // 0160:1df948
    r32[eax] = 0x001e31a0;
    yield* sub_1db9c0();
    memoryASet32(ds, 0x30faec, r32[edx]);
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1df95d: // 0160:1df95d
    r32[eax] = 0x001e31a0;
    yield* sub_1dcb60();
    memoryASet32(ds, 0x30faec, r32[edx]);
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1df972: // 0160:1df972
    r32[eax] = 0xfffffff6;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1df97a: // 0160:1df97a
    if (r32[edx] == 0x00000002)
        { pc = 0x1df95d; break; }
    r32[eax] = 0xfffffff6;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1df987: // 0160:1df987
    r32[eax] = 0;
  case 0x1df989: // 0160:1df989
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1df990() // 0160:1df990 +long +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    return;
    r32[esp] -= 4;
    return;
    push32(r32[ebx]);
    flags.zero = r32[eax] == 0;
    if (r32s[eax] < 0)
        { pc = 0x1df9df; break; }
    r32[ebx] = memoryAGet32(ds, r32[eax] * 8 + 0x31310c);
    r32[eax] = memoryAGet32(ds, r32[eax] * 8 + 0x313110);
    r32[ebx] &= memoryAGet32(ds, 0x30fae8);
    if (r32[ebx] < 0x00000002)
        { pc = 0x1df9da; break; }
    if (r32[ebx] <= 0x00000002)
        { pc = 0x1df9cc; break; }
    flags.zero = r32[ebx] == 0x00000004;
    if (r32[ebx] < 0x00000004)
        { pc = 0x1df9df; break; }
    if (r32[ebx] <= 0x00000004)
        { pc = 0x1df9be; break; }
    flags.zero = r32[ebx] == 0x00000010;
    if (flags.zero)
        { pc = 0x1df9c5; break; }
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df9be: // 0160:1df9be
    yield* sub_1db8c0();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df9c5: // 0160:1df9c5
    yield* sub_1db9e0();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df9cc: // 0160:1df9cc
    yield* sub_1ddc20();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df9d3: // 0160:1df9d3
    yield* sub_1df430();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1df9da: // 0160:1df9da
    flags.zero = r32[ebx] == 0x00000001;
    if (flags.zero)
        { pc = 0x1df9d3; break; }
  case 0x1df9df: // 0160:1df9df
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dfa50() // 0160:1dfa50 +long +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esi] = r32[ebx];
    r32[ebx] = r32[ecx];
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x10);
    if (r32s[eax] < 0)
        { pc = 0x1dfabf; break; }
    r32[ecx] = memoryAGet32(ds, r32[eax] * 8 + 0x31310c);
    r32[eax] = memoryAGet32(ds, r32[eax] * 8 + 0x313110);
    r32[ecx] &= memoryAGet32(ds, 0x30fae8);
    if (r32[ecx] < 0x00000002)
        { pc = 0x1dfaba; break; }
    if (r32[ecx] <= 0x00000002)
        { pc = 0x1dfaa5; break; }
    if (r32[ecx] < 0x00000004)
        { pc = 0x1dfabf; break; }
    if (r32[ecx] <= 0x00000004)
        { pc = 0x1dfa8d; break; }
    if (r32[ecx] == 0x00000010)
        { pc = 0x1dfa99; break; }
    { pc = 0x1dfabf; break; }
  case 0x1dfa8d: // 0160:1dfa8d
    push32(r32[edi]);
    r32[ecx] = r32[ebx];
    r32[ebx] = r32[esi];
    yield* sub_1db920();
    { pc = 0x1dfabf; break; }
  case 0x1dfa99: // 0160:1dfa99
    push32(r32[edi]);
    r32[ecx] = r32[ebx];
    r32[ebx] = r32[esi];
    yield* sub_1dba40();
    { pc = 0x1dfabf; break; }
  case 0x1dfaa5: // 0160:1dfaa5
    push32(r32[edi]);
    r32[ecx] = r32[ebx];
    r32[ebx] = r32[esi];
    yield* sub_1ddca0();
    { pc = 0x1dfabf; break; }
  case 0x1dfab1: // 0160:1dfab1
    r32[ecx] = r32[edi];
    yield* sub_1df340();
    { pc = 0x1dfabf; break; }
  case 0x1dfaba: // 0160:1dfaba
    if (r32[ecx] == 0x00000001)
        { pc = 0x1dfab1; break; }
  case 0x1dfabf: // 0160:1dfabf
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 8;
    return;
  }
}
function* sub_1dfb30() // 0160:1dfb30 +long
{
    r32[esp] -= 4;
    push32(r32[esi]);
    r32[esi] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    push32(r32[ecx]);
    r32[ecx] = r32[ebx];
    r32[ebx] = 0;
    r32[eax] = r32[esi];
    yield* sub_1dfa50();
    flagsFromReg32(pop32());
    r32[esi] = pop32();
    r32[esp] += 4;
}
function* sub_1dfb50() // 0160:1dfb50 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[esi] = r32[eax];
    r32[edi] = r32[edx];
    r32[eax] = memoryAGet32(ds, 0x30fae8);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    r32[edx] = 0;
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    { pc = 0x1dfc50; break; }
  case 0x1dfb71: // 0160:1dfb71
    r32[edx] = r32[eax];
    r32[edx] = ~r32[edx];
    r32[esi] &= r32[edx];
    memoryASet32(ds, 0x30fae4, memoryAGet32(ds, 0x30fae4) | r32[eax]);
    { pc = 0x1dfc40; break; }
  case 0x1dfb82: // 0160:1dfb82
    r32[ecx] = r32[edi];
    r32[ebx] = 0x00209eec;
    r32[edx] = 0x00209ee8;
    r32[eax] = 0x00209ee4;
    yield* sub_1e1d00();
    if (!r32[eax])
        { pc = 0x1dfc40; break; }
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    r32[edx] = r32[eax];
    r32[edx] = ~r32[edx];
    r32[esi] &= r32[edx];
    memoryASet32(ds, 0x30fae4, memoryAGet32(ds, 0x30fae4) | r32[eax]);
    { pc = 0x1dfc40; break; }
  case 0x1dfbbb: // 0160:1dfbbb
    if (signed32(memoryAGet32(ds, 0x209f14)) > signed32(0x00000007))
        { pc = 0x1dfc40; break; }
  case 0x1dfbc8: // 0160:1dfbc8
    push32(r32[edi]);
    push32(0x00209f18);
    r32[ecx] = 0x00209f14;
    r32[ebx] = 0x00209f10;
    r32[edx] = 0x00209f0c;
    r32[eax] = 0x00209f08;
    yield* sub_1dd0b0();
    if (!r32[eax])
        { pc = 0x1dfc40; break; }
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    r32[edx] = r32[eax];
    r32[edx] = ~r32[edx];
    r32[esi] &= r32[edx];
    memoryASet32(ds, 0x30fae4, memoryAGet32(ds, 0x30fae4) | r32[eax]);
    { pc = 0x1dfc40; break; }
  case 0x1dfc07: // 0160:1dfc07
    if (r32[eax] < 0x00000004)
        { pc = 0x1dfc2f; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1dfbbb; break; }
    if (r32[eax] < 0x00000100)
        { pc = 0x1dfc24; break; }
    if (r32[eax] <= 0x00000100)
        { pc = 0x1dfbbb; break; }
    if (r32[eax] == 0x00000200)
        { pc = 0x1dfb82; break; }
    { pc = 0x1dfc40; break; }
  case 0x1dfc24: // 0160:1dfc24
    if (r32[eax] == 0x00000010)
        { pc = 0x1dfb82; break; }
    { pc = 0x1dfc40; break; }
  case 0x1dfc2f: // 0160:1dfc2f
    if (r32[eax] < 0x00000001)
        { pc = 0x1dfc40; break; }
    if (r32[eax] <= 0x00000001)
        { pc = 0x1dfb71; break; }
    if (r32[eax] == 0x00000002)
        { pc = 0x1dfbc8; break; }
  case 0x1dfc40: // 0160:1dfc40
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[ebx]++;
    memoryASet32(ss, r32[ebp] - 4, r32[ebx]);
    if (r32s[ebx] >= signed32(0x00000020))
        { pc = 0x1dfc60; break; }
    r32[eax] = r32[eax];
  case 0x1dfc50: // 0160:1dfc50
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    if (r32[esi] & r32[eax])
        { pc = 0x1dfc07; break; }
    { pc = 0x1dfc40; break; }
  case 0x1dfc60: // 0160:1dfc60
    r32[eax] = r32[esi];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1dfc80() // 0160:1dfc80 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    return;
    r32[esp] -= 4;
    if (r32[eax] > 0x00000004)
        { pc = 0x1dfcab; break; }
    switch (r32[eax])
    {
        case 0: { pc = 0x1dfc8d; break; }
        case 1: { pc = 0x1dfc93; break; }
        case 2: { pc = 0x1dfc99; break; }
        case 3: { pc = 0x1dfc9f; break; }
        case 4: { pc = 0x1dfca5; break; }
        default:
            stop("ind 0160:1dfc85");
    }
    break;
  case 0x1dfc8d: // 0160:1dfc8d
    r32[eax] = 0x00001f40;
    r32[esp] += 4; return;
  case 0x1dfc93: // 0160:1dfc93
    r32[eax] = 0x00002ee0;
    r32[esp] += 4; return;
  case 0x1dfc99: // 0160:1dfc99
    r32[eax] = 0x00003e80;
    r32[esp] += 4; return;
  case 0x1dfc9f: // 0160:1dfc9f
    r32[eax] = 0x000055f0;
    r32[esp] += 4; return;
  case 0x1dfca5: // 0160:1dfca5
    r32[eax] = 0x0000abe0;
    r32[esp] += 4; return;
  case 0x1dfcab: // 0160:1dfcab
    r32[eax] = 0;
    r32[esp] += 4;
    return;
  }
}
function* sub_1dfcb0() // 0160:1dfcb0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[esi] = r32[eax];
    yield* sub_1df870();
    r32[eax] = memoryAGet32(ds, 0x30fae8);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    r32[edx] = 0;
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    r32[edi] = 0;
    { pc = 0x1e0010; break; }
  case 0x1dfcd7: // 0160:1dfcd7
    yield* sub_1db9d0();
    if (memoryAGet16(ds, 0x30fae4) & 0x0210)
        { pc = 0x1dfd00; break; }
    r32[ecx] = 0x00209ef0;
    r32[ebx] = 0x00209eec;
    r32[edx] = 0x00209ee8;
    r32[eax] = 0x00209ee4;
    yield* sub_1e1c00();
  case 0x1dfd00: // 0160:1dfd00
    r32[ecx] = memoryAGet32(ds, 0x209eec);
    r32[ebx] = memoryAGet32(ds, 0x209ee8);
    r32[edx] = memoryAGet32(ds, 0x209ee4);
    r32[eax] = memoryAGet32(ds, 0x209ef4);
    yield* sub_1dfc80();
    yield* sub_1e1610();
    r32[edx] = r32[eax];
    memoryASet32(ds, 0x209efc, r32[eax]);
    if (!r32[eax])
        { pc = 0x1e0000; break; }
    r32[eax] = memoryAGet32(ds, 0x209ee0);
    yield* sub_1dba80();
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) | r32[eax]);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    { pc = 0x1e0000; break; }
  case 0x1dfd53: // 0160:1dfd53
    if (memoryAGet16(ds, 0x30fae4) & 0x0210)
        { pc = 0x1dfd77; break; }
    r32[ecx] = 0x00209ef0;
    r32[ebx] = 0x00209eec;
    r32[edx] = 0x00209ee8;
    r32[eax] = 0x00209ee4;
    yield* sub_1e1c00();
  case 0x1dfd77: // 0160:1dfd77
    r32[ecx] = memoryAGet32(ds, 0x209eec);
    r32[ebx] = memoryAGet32(ds, 0x209ee8);
    r32[edx] = memoryAGet32(ds, 0x209ee4);
    r32[eax] = memoryAGet32(ds, 0x209ef8);
    yield* sub_1e1610();
    memoryASet32(ds, 0x209efc, r32[eax]);
    if (!r32[eax])
        { pc = 0x1e0000; break; }
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) | r32[eax]);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    { pc = 0x1e0000; break; }
  case 0x1dfdb9: // 0160:1dfdb9
    yield* sub_1dcc70();
    if (memoryAGet16(ds, 0x30fae4) & 0x0106)
        { pc = 0x1dfde7; break; }
    push32(0x00209f18);
    r32[ecx] = 0x00209f14;
    r32[ebx] = 0x00209f10;
    r32[edx] = 0x00209f0c;
    r32[eax] = 0x00209f08;
    yield* sub_1dddb0();
  case 0x1dfde7: // 0160:1dfde7
    r32[ebx] = memoryAGet32(ds, 0x209f18);
    push32(r32[ebx]);
    r32[ecx] = memoryAGet32(ds, 0x209f14);
    push32(r32[ecx]);
    r32[eax] = memoryAGet32(ds, 0x209f10);
    push32(r32[eax]);
    r32[ecx] = memoryAGet32(ds, 0x209f0c);
    r32[ebx] = memoryAGet32(ds, 0x209f08);
    r32[edx] = memoryAGet32(ds, 0x209f04);
    r32[eax] = memoryAGet32(ds, 0x209f00);
    yield* sub_1dd790();
    if (!r32[eax])
        { pc = 0x1e0000; break; }
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) | r32[eax]);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    { pc = 0x1e0000; break; }
  case 0x1dfe38: // 0160:1dfe38
    if (memoryAGet16(ds, 0x30fae4) & 0x0106)
        { pc = 0x1dfe61; break; }
    push32(0x00209f18);
    r32[ecx] = 0x00209f14;
    r32[ebx] = 0x00209f10;
    r32[edx] = 0x00209f0c;
    r32[eax] = 0x00209f08;
    yield* sub_1dddb0();
  case 0x1dfe61: // 0160:1dfe61
    r32[ebx] = memoryAGet32(ds, 0x209f14);
    if (r32s[ebx] > signed32(0x00000007))
        { pc = 0x1e0000; break; }
    r32[ecx] = memoryAGet32(ds, 0x209f18);
    push32(r32[ecx]);
    push32(r32[ebx]);
    r32[edx] = memoryAGet32(ds, 0x209f10);
    push32(r32[edx]);
    r32[ecx] = memoryAGet32(ds, 0x209f0c);
    r32[ebx] = memoryAGet32(ds, 0x209f08);
    r32[edx] = memoryAGet32(ds, 0x209f04);
    r32[eax] = memoryAGet32(ds, 0x209f00);
    yield* sub_1dd790();
    if (!r32[eax])
        { pc = 0x1e0000; break; }
    r32[ebx] = memoryAGet32(ds, 0x209f20);
    r32[edx] = memoryAGet32(ds, 0x209f1c);
    r32[eax] = r32[edi];
    yield* sub_1df200();
    memoryASet32(ds, 0x209f24, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e0000; break; }
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) | r32[eax]);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    { pc = 0x1e0000; break; }
  case 0x1dfedc: // 0160:1dfedc
    if (memoryAGet16(ds, 0x30fae4) & 0x0106)
        { pc = 0x1dff05; break; }
    push32(0x00209f18);
    r32[ecx] = 0x00209f14;
    r32[ebx] = 0x00209f10;
    r32[edx] = 0x00209f0c;
    r32[eax] = 0x00209f08;
    yield* sub_1dddb0();
  case 0x1dff05: // 0160:1dff05
    r32[eax] = memoryAGet32(ds, 0x209f14);
    if (r32s[eax] > signed32(0x00000007))
        { pc = 0x1e0000; break; }
    r32[edx] = memoryAGet32(ds, 0x209f18);
    push32(r32[edx]);
    push32(r32[eax]);
    r32[ecx] = memoryAGet32(ds, 0x209f10);
    push32(r32[ecx]);
    r32[ecx] = memoryAGet32(ds, 0x209f0c);
    r32[ebx] = memoryAGet32(ds, 0x209f08);
    r32[edx] = memoryAGet32(ds, 0x209f04);
    r32[eax] = memoryAGet32(ds, 0x209f00);
    yield* sub_1dd790();
    if (!r32[eax])
        { pc = 0x1e0000; break; }
    r32[ebx] = memoryAGet32(ds, 0x209f20);
    r32[eax] = memoryAGet32(ds, 0x209f28);
    yield* sub_1dfc80();
    r32[edx] = r32[eax];
    r32[eax] = r32[edi];
    yield* sub_1df200();
    r32[edx] = r32[eax];
    memoryASet32(ds, 0x209f24, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e0000; break; }
    r32[eax] = memoryAGet32(ds, 0x209f2c);
    yield* sub_1db960();
    r32[edx] = 0x00000040;
    r32[eax] = 0x00000100;
    yield* sub_1e0d30();
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) | r32[eax]);
    r32[eax] = ~r32[eax];
    r32[esi] &= r32[eax];
    { pc = 0x1e0000; break; }
  case 0x1dffa0: // 0160:1dffa0
    r32[eax] = memoryAGet32(ds, 0x209f30);
    yield* sub_1df5b0();
    if (!r32[eax])
        { pc = 0x1e0000; break; }
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) | r32[edx]);
    r32[edx] = ~r32[edx];
    r32[esi] &= r32[edx];
    { pc = 0x1e0000; break; }
  case 0x1dffba: // 0160:1dffba
    if (r32[edx] < 0x00000004)
        { pc = 0x1dffec; break; }
    if (r32[edx] <= 0x00000004)
        { pc = 0x1dfedc; break; }
    if (r32[edx] < 0x00000100)
        { pc = 0x1dffe1; break; }
    if (r32[edx] <= 0x00000100)
        { pc = 0x1dfe38; break; }
    if (r32[edx] == 0x00000200)
        { pc = 0x1dfd53; break; }
    { pc = 0x1e0000; break; }
  case 0x1dffe1: // 0160:1dffe1
    if (r32[edx] == 0x00000010)
        { pc = 0x1dfcd7; break; }
    { pc = 0x1e0000; break; }
  case 0x1dffec: // 0160:1dffec
    if (r32[edx] < 0x00000001)
        { pc = 0x1e0000; break; }
    if (r32[edx] <= 0x00000001)
        { pc = 0x1dffa0; break; }
    if (r32[edx] == 0x00000002)
        { pc = 0x1dfdb9; break; }
    r32[eax] = r32[eax];
  case 0x1e0000: // 0160:1e0000
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[ebx]++;
    memoryASet32(ss, r32[ebp] - 4, r32[ebx]);
    if (r32s[ebx] >= signed32(0x00000020))
        { pc = 0x1e0020; break; }
    r32[eax] = r32[eax];
  case 0x1e0010: // 0160:1e0010
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[edx] = 0x00000001;
    r32[edx] <<= r8[cl];
    if (r32[esi] & r32[edx])
        { pc = 0x1dffba; break; }
    { pc = 0x1e0000; break; }
  case 0x1e0020: // 0160:1e0020
    r32[eax] = r32[esi];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0030() // 0160:1e0030 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[edx] = 0;
    r32[ebx] = 0x00000001;
    { pc = 0x1e00d0; break; }
  case 0x1e003f: // 0160:1e003f
    yield* sub_1e1460();
    yield* sub_1dbad0();
    r8[cl] = r8[dl];
    r32[eax] = r32[ebx];
    r32[eax] <<= r8[cl];
    r32[ecx] = r32[eax];
    r32[ecx] = ~r32[ecx];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) & r32[ecx]);
    { pc = 0x1e00c0; break; }
  case 0x1e005e: // 0160:1e005e
    yield* sub_1dd970();
    yield* sub_1db9b0();
    r8[cl] = r8[dl];
    r32[eax] = r32[ebx];
    r32[eax] <<= r8[cl];
    r32[ecx] = r32[eax];
    r32[ecx] = ~r32[ecx];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) & r32[ecx]);
    { pc = 0x1e00c0; break; }
  case 0x1e007a: // 0160:1e007a
    yield* sub_1df600();
    r32[ecx] = ~r32[ecx];
    memoryASet32(ds, 0x30fae8, memoryAGet32(ds, 0x30fae8) & r32[ecx]);
    { pc = 0x1e00c0; break; }
  case 0x1e0089: // 0160:1e0089
    if (r32[eax] < 0x00000004)
        { pc = 0x1e00a9; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1e005e; break; }
    if (r32[eax] < 0x00000100)
        { pc = 0x1e00a2; break; }
    if (r32[eax] <= 0x00000100)
        { pc = 0x1e005e; break; }
    if (r32[eax] == 0x00000200)
        { pc = 0x1e003f; break; }
    { pc = 0x1e00c0; break; }
  case 0x1e00a2: // 0160:1e00a2
    if (r32[eax] == 0x00000010)
        { pc = 0x1e003f; break; }
    { pc = 0x1e00c0; break; }
  case 0x1e00a9: // 0160:1e00a9
    if (r32[eax] < 0x00000001)
        { pc = 0x1e00c0; break; }
    if (r32[eax] <= 0x00000001)
        { pc = 0x1e007a; break; }
    if (r32[eax] == 0x00000002)
        { pc = 0x1e005e; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[ebx] = r32[ebx];
  case 0x1e00c0: // 0160:1e00c0
    r32[edx]++;
    if (r32s[edx] >= signed32(0x00000020))
        { pc = 0x1e00e2; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e00d0: // 0160:1e00d0
    r8[cl] = r8[dl];
    r32[eax] = r32[ebx];
    r32[eax] <<= r8[cl];
    r32[ecx] = r32[eax];
    if (memoryAGet32(ds, 0x30fae8) & r32[eax])
        { pc = 0x1e0089; break; }
    { pc = 0x1e00c0; break; }
  case 0x1e00e2: // 0160:1e00e2
    r32[eax] = memoryAGet32(ds, 0x30fae8);
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e00f0() // 0160:1e00f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    r32[ecx] = r32[eax];
    yield* sub_1e0380();
    r32[edx] = 0x0020b1ed;
    r32[eax] = r32[ecx];
    yield* sub_1e3fed();
    r32[esi] = r32[eax];
    if (r32[eax])
        { pc = 0x1e0122; break; }
    r32[eax] = 0xfffffffe;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0122: // 0160:1e0122
    r32[eax] = r32[esi];
    yield* sub_1e4083();
    r32[edi] = r32[eax];
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[ecx] = r32[esi];
    r32[ebx] = 0x00000004;
    r32[edx] = 0x00000001;
    r32[eax] = 0x0020b1e8;
    yield* sub_1e3b5d();
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    if (r32[eax] == 0x00000004)
        { pc = 0x1e0172; break; }
    r32[eax] = r32[esi];
    yield* sub_1e40b3();
    if (memoryAGet32(ss, r32[ebp] - 8))
        { pc = 0x1e0164; break; }
    r32[eax] = 0;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0164: // 0160:1e0164
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0172: // 0160:1e0172
    r32[ecx] = r32[esi];
    r32[ebx] = 0x00000001;
    r32[edx] = r32[eax];
    r32[eax] = r32[ebp] - 8;
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1e019d; break; }
    r32[eax] = r32[esi];
    yield* sub_1e40b3();
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e019d: // 0160:1e019d
    r32[ebx] = 0;
    r32[edx] = r32[edi];
    r32[eax] = r32[esi];
    yield* sub_1e4237();
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b1f0;
    r32[eax] = 0x0020b1e8;
    yield* sub_1e3d27();
    if (r32[eax])
        { pc = 0x1e01e3; break; }
    r32[eax] = r32[esi];
    yield* sub_1e3220();
    r32[edi] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1e0302; break; }
    r32[eax] = r32[esi];
    yield* sub_1e40b3();
    r32[eax] = r32[edi];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e01e3: // 0160:1e01e3
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b1f5;
    r32[eax] = 0x0020b1e8;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1e0217; break; }
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b1fa;
    r32[eax] = 0x0020b1e8;
    yield* sub_1e3d27();
    if (r32[eax])
        { pc = 0x1e02a5; break; }
  case 0x1e0217: // 0160:1e0217
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b1ff;
    r32[eax] = 0x0020b1e8;
    yield* sub_1e3d27();
    r8[al] = r32[eax] != 0;
    r32[edi] = r8[al];
    r32[ecx] = r32[edi];
    if (!(memoryAGet(ds, 0x30fae8) & 0x14))
        { pc = 0x1e026b; break; }
    r32[ebx] = 0;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = r32[esi];
    yield* sub_1e4237();
    r32[edx] = r32[edi];
    r32[eax] = r32[esi];
    yield* sub_1dc430();
    r32[edi] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1e026b; break; }
    r32[eax] = r32[esi];
    yield* sub_1e40b3();
    r32[eax] = r32[edi];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e026b: // 0160:1e026b
    if (!(memoryAGet(ds, 0x30fae8) & 0x02))
        { pc = 0x1e0302; break; }
    r32[ebx] = 0;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax] = r32[esi];
    yield* sub_1e4237();
    r32[edx] = r32[ecx];
    r32[eax] = r32[esi];
    yield* sub_1deb60();
    r32[edi] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1e0302; break; }
    r32[eax] = r32[esi];
    yield* sub_1e40b3();
    r32[eax] = r32[edi];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e02a5: // 0160:1e02a5
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b204;
    r32[eax] = 0x0020b1e8;
    yield* sub_1e3d27();
    if (r32[eax])
        { pc = 0x1e02f0; break; }
    if (!(memoryAGet(ds, 0x30fae8) & 0x01))
        { pc = 0x1e0302; break; }
    r32[ebx] = 0;
    r32[edx] = r32[edi];
    r32[eax] = r32[esi];
    yield* sub_1e4237();
    r32[eax] = r32[esi];
    yield* sub_1df620();
    r32[edi] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1e0302; break; }
    r32[eax] = r32[esi];
    yield* sub_1e40b3();
    r32[eax] = r32[edi];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e02f0: // 0160:1e02f0
    push32(0x0020b1e8);
    push32(0x0020b209);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
  case 0x1e0302: // 0160:1e0302
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    r32[edx] += memoryAGet32(ss, r32[ebp] - 8);
    r32[ebx] = 0;
    r32[eax] = r32[esi];
    yield* sub_1e4237();
    { pc = 0x1e0122; break; }
    return;
  }
}
function* sub_1e0350() // 0160:1e0350 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[eax] < 0)
        { pc = 0x1e0360; break; }
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x310100)))
        { pc = 0x1e2720; break; }
  case 0x1e0360: // 0160:1e0360
    r32[eax] = 0xfffffff7;
    r32[esp] += 4; return;
    // gap 9146 bytes // gap 9146 bytes
  case 0x1e2720: // 0160:1e2720
    push32(r32[ebx]);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x316404);
    r32[ebx] = memoryAGet32(ds, 0x20a4dc);
    memoryASet32(ds, r32[ebx] + 0x580, r32[eax]);
    r32[ebx] = memoryAGet32(ds, 0x20a4dc);
    memoryASet32(ds, r32[ebx] + 0x594, r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x20a4dc);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x448);
    memoryASet32(ds, r32[edx] + 0x588, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet32(ds, r32[eax] + 0x584, 0x00000000);
    r32[edx] = 0;
    r32[ebx] = 0;
    { pc = 0x1e27f2; break; }
  case 0x1e276a: // 0160:1e276a
    memoryASet(ds, r32[ebx] + r32[eax], 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x1, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x2, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x3, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x4, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x5, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x6, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x7, 0x00);
    memoryASet(ds, r32[ebx] + r32[eax] + 0xa, 0x00);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0xc, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0xe, 0x0000);
    memoryASet32(ds, r32[ebx] + r32[eax] + 0x10, 0x00000000);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x8, 0x00);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x14, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x16, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x18, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x1a, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x1c, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x1e, 0x0000);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x20, 0x0040);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x22, 0x00);
    memoryASet16(ds, r32[ebx] + r32[eax] + 0x24, 0x0000);
    r32[ebx] += 0x0000002c;
    r32[edx]++;
  case 0x1e27f2: // 0160:1e27f2
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    if (r32s[edx] < signed32(memoryAGet32(ds, r32[eax] + 0x588)))
        { pc = 0x1e276a; break; }
    r32[eax] = 0;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[ebx] = r32[ebx];
  case 0x1e2810: // 0160:1e2810
    r32[edx] = memoryAGet32(ds, 0x20a4dc);
    memoryASet32(ds, r32[edx] + r32[eax] + 0x28, 0xffffffff);
    r32[eax] += 0x0000002c;
    if (r32[eax] != 0x00000580)
        { pc = 0x1e2810; break; }
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet(ds, r32[eax] + 0x58c, 0x00);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet(ds, r32[eax] + 0x58d, 0x06);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet(ds, r32[eax] + 0x58e, 0x7d);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet(ds, r32[eax] + 0x58f, 0x00);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet(ds, r32[eax] + 0x590, 0x00);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    memoryASet(ds, r32[eax] + 0x591, 0x00);
    r8[ah] = 0;
    memoryASet(ds, 0x31333c, r8[ah]);
    r32[eax] = 0;
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0370() // 0160:1e0370 +long
{
    yield* sub_1e33c0();
}
function* sub_1e0380() // 0160:1e0380 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x30faec);
    if (r32[eax])
        { pc = 0x1e3390; break; }
    r32[esp] += 4; return;
    // gap 12290 bytes // gap 12290 bytes
  case 0x1e3390: // 0160:1e3390
    r8[ah] = 0;
    memoryASet(ds, 0x31333c, r8[ah]);
    memoryASet32(ds, 0x3164c4, 0x00000001);
    if (!memoryAGet32(ds, 0x3164c4))
        { pc = 0x1e33b4; break; }
  case 0x1e33ab: // 0160:1e33ab
    yield* sync();
    if (memoryAGet32(ds, 0x3164c4))
        { pc = 0x1e33ab; break; }
  case 0x1e33b4: // 0160:1e33b4
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e0390() // 0160:1e0390 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x30faec);
    if (r32[eax])
        { pc = 0x1e3370; break; }
    r32[esp] += 4; return;
    // gap 12242 bytes // gap 12242 bytes
  case 0x1e3370: // 0160:1e3370
    r8[ah] = 0;
    memoryASet(ds, 0x31333c, r8[ah]);
    memoryASet32(ds, 0x3164c4, 0x00000001);
    r32[esp] += 4;
    return;
  }
}
function* sub_1e03a0() // 0160:1e03a0 +long
{
    yield* sub_1e3320();
}
function* sub_1e03c0() // 0160:1e03c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000008;
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[esi] = r32[edx];
    if (r32s[eax] >= 0)
        { pc = 0x1e03d8; break; }
    r32[ebx] = 0;
    memoryASet32(ss, r32[ebp] - 8, r32[ebx]);
  case 0x1e03d8: // 0160:1e03d8
    if (signed32(memoryAGet32(ss, r32[ebp] - 8)) <= signed32(0x00000040))
        { pc = 0x1e03e5; break; }
    memoryASet32(ss, r32[ebp] - 8, 0x00000040);
  case 0x1e03e5: // 0160:1e03e5
    yield* sub_1e3340();
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[ebx] -= r32[eax];
    r32[ecx] = 0;
    if (r32s[esi] <= 0)
        { pc = 0x1e042c; break; }
    r32[edi] = (r32[ebx] * 8) + 0;
    r32[edi] -= r32[ebx];
    r32[edi] = (r32[edi] * 8) + 0;
    r32[edi] -= r32[ebx];
    r32[ebx] = r32s[ebx] * r32s[ecx];
  case 0x1e040d: // 0160:1e040d
    r32[eax] = r32[ebx];
    r32[edx] = r32[ebx];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[esi]);
    r32[eax] += memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e3320();
    yield* sub_1e2690();
    r32[ebx] += r32[edi];
    r32[ecx] += 0x00000037;
    if (r32s[ecx] < r32s[esi])
        { pc = 0x1e040d; break; }
  case 0x1e042c: // 0160:1e042c
    r32[eax] = memoryAGet32(ss, r32[ebp] - 8);
    yield* sub_1e3320();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0440() // 0160:1e0440 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    { pc = 0x1e0490; break; }
  case 0x1e0449: // 0160:1e0449
    yield* sub_1e0f70();
    if (!r32[eax])
        { pc = 0x1e0480; break; }
    r8[cl] = r8[dl];
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
  case 0x1e045b: // 0160:1e045b
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e0480; break; }
  case 0x1e0461: // 0160:1e0461
    if (r32[eax] < 0x00000010)
        { pc = 0x1e0471; break; }
    if (r32[eax] <= 0x00000010)
        { pc = 0x1e0449; break; }
    if (r32[eax] == 0x00000200)
        { pc = 0x1e0449; break; }
    { pc = 0x1e0480; break; }
  case 0x1e0471: // 0160:1e0471
    if (r32[eax] == 0x00000002)
        { pc = 0x1e045b; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e0480: // 0160:1e0480
    r32[edx]++;
    if (r32s[edx] >= signed32(0x00000020))
        { pc = 0x1e049f; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e0490: // 0160:1e0490
    r8[cl] = r8[dl];
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    if (r32[ebx] & r32[eax])
        { pc = 0x1e0461; break; }
    { pc = 0x1e0480; break; }
  case 0x1e049f: // 0160:1e049f
    r32[eax] = r32[ebx];
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0500() // 0160:1e0500 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
    memoryASet32(ss, r32[ebp] - 4, r32[ecx]);
    r32[esi] = 0x00000001;
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = r32[esi];
    r32[eax] <<= r8[cl];
    if (r32[ebx] & r32[eax])
        { pc = 0x1e0595; break; }
    { pc = 0x1e05b0; break; }
  case 0x1e0529: // 0160:1e0529
    if (r32s[edx] < signed32(0x00000001))
        { pc = 0x1e05b0; break; }
    if (r32s[edx] > signed32(0x00000010))
        { pc = 0x1e05b0; break; }
    memoryASet32(ds, 0x209f2c, r32[edx]);
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e05b0; break; }
  case 0x1e054a: // 0160:1e054a
    if (r32s[edx] < signed32(0x00000001))
        { pc = 0x1e05b0; break; }
    if (r32s[edx] > r32s[eax])
        { pc = 0x1e05b0; break; }
    memoryASet32(ds, 0x209ee0, r32[edx]);
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e05b0; break; }
  case 0x1e056a: // 0160:1e056a
    if (r32s[edx] < signed32(0x00000007))
        { pc = 0x1e05b0; break; }
    if (r32s[edx] > signed32(0x00000010))
        { pc = 0x1e05b0; break; }
    memoryASet32(ds, 0x209f00, r32[edx]);
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e05b0; break; }
  case 0x1e0580: // 0160:1e0580
    if (r32s[edx] < r32s[eax])
        { pc = 0x1e05b0; break; }
    if (r32s[edx] > signed32(0x00000004))
        { pc = 0x1e05b0; break; }
    memoryASet32(ds, 0x209f30, r32[edx]);
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e05b0; break; }
  case 0x1e0595: // 0160:1e0595
    if (r32[eax] < 0x00000002)
        { pc = 0x1e05aa; break; }
    if (r32[eax] <= 0x00000002)
        { pc = 0x1e056a; break; }
    if (r32[eax] < 0x00000004)
        { pc = 0x1e05b0; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1e0529; break; }
    if (r32[eax] == 0x00000010)
        { pc = 0x1e054a; break; }
    { pc = 0x1e05b0; break; }
  case 0x1e05aa: // 0160:1e05aa
    if (r32[eax] == 0x00000001)
        { pc = 0x1e0580; break; }
  case 0x1e05b0: // 0160:1e05b0
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    r32[eax]++;
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    if (r32s[eax] >= signed32(0x00000020))
        { pc = 0x1e05c9; break; }
    r8[cl] = memoryAGet(ss, r32[ebp] - 4);
    r32[eax] = r32[esi];
    r32[eax] <<= r8[cl];
    if (r32[ebx] & r32[eax])
        { pc = 0x1e0595; break; }
    { pc = 0x1e05b0; break; }
  case 0x1e05c9: // 0160:1e05c9
    r32[eax] = r32[ebx];
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e05e0() // 0160:1e05e0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ebx] = r32[eax];
    r32[esi] = r32[edx];
    if (r32s[edx] >= signed32(0x00000001))
        { pc = 0x1e05f2; break; }
    r32[esi] = 0x00000001;
  case 0x1e05f2: // 0160:1e05f2
    if (r32s[esi] <= signed32(0x000000c8))
        { pc = 0x1e05ff; break; }
    r32[esi] = 0x000000c8;
  case 0x1e05ff: // 0160:1e05ff
    r32[edx] = 0;
    r32[edi] = 0x00000001;
    r8[cl] = r8[dl];
    r32[eax] = r32[edi];
    r32[eax] <<= r8[cl];
    if (r32[ebx] & r32[eax])
        { pc = 0x1e063a; break; }
    { pc = 0x1e0670; break; }
  case 0x1e0615: // 0160:1e0615
    r32[eax] = r32[esi];
    yield* sub_1e15c0();
    r8[cl] = r8[dl];
    r32[eax] = r32[edi];
    r32[eax] <<= r8[cl];
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e0670; break; }
  case 0x1e0628: // 0160:1e0628
    memoryASet32(ds, 0x209f20, r32[esi]);
    r8[cl] = r8[dl];
    r32[eax] = r32[edi];
    r32[eax] <<= r8[cl];
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e0670; break; }
  case 0x1e063a: // 0160:1e063a
    if (r32[eax] < 0x00000010)
        { pc = 0x1e0653; break; }
    if (r32[eax] <= 0x00000010)
        { pc = 0x1e0615; break; }
    if (r32[eax] < 0x00000100)
        { pc = 0x1e0670; break; }
    if (r32[eax] <= 0x00000100)
        { pc = 0x1e0628; break; }
    if (r32[eax] == 0x00000200)
        { pc = 0x1e0615; break; }
    { pc = 0x1e0670; break; }
  case 0x1e0653: // 0160:1e0653
    if (r32[eax] < 0x00000001)
        { pc = 0x1e0670; break; }
    if (r32[eax] <= 0x00000002)
        { pc = 0x1e0670; break; }
    if (r32[eax] == 0x00000004)
        { pc = 0x1e0628; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[eax] = r32[eax];
  case 0x1e0670: // 0160:1e0670
    r32[edx]++;
    if (r32s[edx] >= signed32(0x00000020))
        { pc = 0x1e0682; break; }
    r8[cl] = r8[dl];
    r32[eax] = r32[edi];
    r32[eax] <<= r8[cl];
    if (r32[ebx] & r32[eax])
        { pc = 0x1e063a; break; }
    { pc = 0x1e0670; break; }
  case 0x1e0682: // 0160:1e0682
    r32[eax] = r32[ebx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0690() // 0160:1e0690 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x30faec);
    if (r32[eax] < 0x00000004)
        { pc = 0x1e06ba; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1e06a5; break; }
    if (r32[eax] == 0x00000010)
        { pc = 0x1e06ac; break; }
    { pc = 0x1e06bf; break; }
  case 0x1e06a5: // 0160:1e06a5
    yield* sub_1db8b0();
    { pc = 0x1e06bf; break; }
  case 0x1e06ac: // 0160:1e06ac
    yield* sub_1db9d0();
    { pc = 0x1e06bf; break; }
  case 0x1e06b3: // 0160:1e06b3
    yield* sub_1dcc70();
    { pc = 0x1e06bf; break; }
  case 0x1e06ba: // 0160:1e06ba
    if (r32[eax] == 0x00000002)
        { pc = 0x1e06b3; break; }
  case 0x1e06bf: // 0160:1e06bf
    r32[edx] = 0;
    memoryASet32(ds, 0x30faec, r32[edx]);
    yield* sub_1e3350();
    { pc = 0x1e0710; break; }
  case 0x1e06ce: // 0160:1e06ce
    yield* sub_1dc610();
    { pc = 0x1e0700; break; }
  case 0x1e06d5: // 0160:1e06d5
    yield* sub_1ded70();
    { pc = 0x1e0700; break; }
  case 0x1e06dc: // 0160:1e06dc
    yield* sub_1df740();
    { pc = 0x1e0700; break; }
  case 0x1e06e3: // 0160:1e06e3
    if (r32[eax] < 0x00000002)
        { pc = 0x1e06f8; break; }
    if (r32[eax] <= 0x00000002)
        { pc = 0x1e06d5; break; }
    if (r32[eax] < 0x00000004)
        { pc = 0x1e0700; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1e06ce; break; }
    if (r32[eax] == 0x00000010)
        { pc = 0x1e06ce; break; }
    { pc = 0x1e0700; break; }
  case 0x1e06f8: // 0160:1e06f8
    if (r32[eax] == 0x00000001)
        { pc = 0x1e06dc; break; }
    r32[eax] = r32[eax];
  case 0x1e0700: // 0160:1e0700
    r32[edx]++;
    if (r32s[edx] >= signed32(0x00000020))
        { pc = 0x1e0723; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e0710: // 0160:1e0710
    r8[cl] = r8[dl];
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    if (memoryAGet32(ds, 0x30fae8) & r32[eax])
        { pc = 0x1e06e3; break; }
    { pc = 0x1e0700; break; }
  case 0x1e0723: // 0160:1e0723
    yield* sub_1df860();
    r32[ecx] = 0;
    memoryASet32(ds, 0x310100, r32[ecx]);
    memoryASet32(ds, 0x313104, r32[ecx]);
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0740() // 0160:1e0740 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[eax];
    yield* sub_1df870();
    if (r32s[edx] < signed32(0xffffffff))
        { pc = 0x1e0752; break; }
    if (r32s[edx] < signed32(0x00000040))
        { pc = 0x1e0756; break; }
  case 0x1e0752: // 0160:1e0752
    r32[eax] = 0;
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0756: // 0160:1e0756
    r32[eax] = r32[ebx];
    yield* sub_1e26f0();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0760() // 0160:1e0760 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[eax];
    yield* sub_1df870();
    r32[eax] = r32[edx] - 1;
    if (!(r32[edx] & r32[eax]))
        { pc = 0x1e0773; break; }
    r32[eax] = 0;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0773: // 0160:1e0773
    if (r32s[ecx] < 0)
        { pc = 0x1e077c; break; }
    if (r32s[ecx] < signed32(0x00000040))
        { pc = 0x1e0780; break; }
  case 0x1e077c: // 0160:1e077c
    r32[eax] = 0;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0780: // 0160:1e0780
    memoryASet32(ds, r32[ecx] * 8 + 0x31310c, r32[edx]);
    memoryASet32(ds, r32[ecx] * 8 + 0x313110, r32[ebx]);
    r32[eax] = 0x00000001;
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0800() // 0160:1e0800 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    r32[esi] = r32[eax];
    r32[eax] = r32[edx];
    r32[edx] = r32[ebx];
    r32[ebx] = r32[ecx];
    if (r32[esi] < 0x00000004)
        { pc = 0x1e0827; break; }
    if (r32[esi] <= 0x00000004)
        { pc = 0x1e0819; break; }
    if (r32[esi] == 0x00000010)
        { pc = 0x1e0820; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e0819: // 0160:1e0819
    yield* sub_1dedd0();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e0820: // 0160:1e0820
    yield* sub_1e1270();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e0827: // 0160:1e0827
    if (r32[esi] == 0x00000002)
        { pc = 0x1e0819; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0830() // 0160:1e0830 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ebx] = r32[eax];
    r32[esi] = r32[edx];
    if (r32[edx] > 0x00000004)
        { pc = 0x1e088f; break; }
    r32[edx] = 0;
    { pc = 0x1e0880; break; }
  case 0x1e0844: // 0160:1e0844
    memoryASet32(ds, 0x209f28, r32[esi]);
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e0870; break; }
  case 0x1e0850: // 0160:1e0850
    memoryASet32(ds, 0x209ef4, r32[esi]);
    r32[eax] = ~r32[eax];
    r32[ebx] &= r32[eax];
    { pc = 0x1e0870; break; }
  case 0x1e085c: // 0160:1e085c
    if (r32[eax] < 0x00000004)
        { pc = 0x1e0870; break; }
    if (r32[eax] <= 0x00000004)
        { pc = 0x1e0844; break; }
    if (r32[eax] == 0x00000010)
        { pc = 0x1e0850; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e0870: // 0160:1e0870
    r32[edx]++;
    if (r32s[edx] >= signed32(0x00000020))
        { pc = 0x1e088f; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e0880: // 0160:1e0880
    r8[cl] = r8[dl];
    r32[eax] = 0x00000001;
    r32[eax] <<= r8[cl];
    if (r32[ebx] & r32[eax])
        { pc = 0x1e085c; break; }
    { pc = 0x1e0870; break; }
  case 0x1e088f: // 0160:1e088f
    r32[eax] = r32[ebx];
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0940() // 0160:1e0940 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ebx] = r32[eax];
    r32[edi] = 0;
    if (signed32(memoryAGet32(ds, 0x313104)) > signed32(0x00000000))
        { pc = 0x1e0961; break; }
    { pc = 0x1e097a; break; }
  case 0x1e0953: // 0160:1e0953
    r32[esi] += 0x00000020;
    r32[edi]++;
    if (r32s[edi] < signed32(memoryAGet32(ds, 0x313104)))
        { pc = 0x1e0966; break; }
    { pc = 0x1e097a; break; }
  case 0x1e0961: // 0160:1e0961
    r32[esi] = 0x00310104;
  case 0x1e0966: // 0160:1e0966
    r32[edx] = r32[ebx];
    r32[eax] = r32[esi];
    yield* sub_1e4340();
    if (r32[eax])
        { pc = 0x1e0953; break; }
    r32[eax] = r32[edi];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e097a: // 0160:1e097a
    r32[esi] = memoryAGet32(ds, 0x313104);
    if (r32s[esi] < signed32(0x00000180))
        { pc = 0x1e0992; break; }
    r32[eax] = 0xfffffffa;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0992: // 0160:1e0992
    r32[edx] = r32[esi];
    r32[edi] = r32[esi];
    r32[edi] <<= 5;
    r32[eax] = r32[esi] + 1;
    memoryASet32(ds, 0x313104, r32[eax]);
    r32[edi] += 0x00310104;
    r32[esi] = r32[ebx];
    push32(r32[edi]);
  case 0x1e09aa: // 0160:1e09aa
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    if (!r8[al])
        { pc = 0x1e09c2; break; }
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r32[esi] += 0x00000002;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r32[edi] += 0x00000002;
    if (r8[al])
        { pc = 0x1e09aa; break; }
  case 0x1e09c2: // 0160:1e09c2
    r32[edi] = pop32();
    r32[eax] = r32[edx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e09d0() // 0160:1e09d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    r32[ecx] = 0;
    if (signed32(memoryAGet32(ds, 0x313104)) > signed32(0x00000000))
        { pc = 0x1e09f1; break; }
    { pc = 0x1e0a0a; break; }
  case 0x1e09e3: // 0160:1e09e3
    r32[ebx] += 0x00000020;
    r32[ecx]++;
    if (r32s[ecx] < signed32(memoryAGet32(ds, 0x313104)))
        { pc = 0x1e09f6; break; }
    { pc = 0x1e0a0a; break; }
  case 0x1e09f1: // 0160:1e09f1
    r32[ebx] = 0x00310104;
  case 0x1e09f6: // 0160:1e09f6
    r32[edx] = r32[esi];
    r32[eax] = r32[ebx];
    yield* sub_1e4340();
    if (r32[eax])
        { pc = 0x1e09e3; break; }
    r32[eax] = r32[ecx];
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0a0a: // 0160:1e0a0a
    r32[eax] = 0xfffffff8;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0a20() // 0160:1e0a20 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ebx] = r32[eax];
    r32[edi] = 0;
    if (signed32(memoryAGet32(ds, 0x310100)) > signed32(0x00000000))
        { pc = 0x1e0a41; break; }
    { pc = 0x1e0a5a; break; }
  case 0x1e0a33: // 0160:1e0a33
    r32[esi] += 0x00000020;
    r32[edi]++;
    if (r32s[edi] < signed32(memoryAGet32(ds, 0x310100)))
        { pc = 0x1e0a46; break; }
    { pc = 0x1e0a5a; break; }
  case 0x1e0a41: // 0160:1e0a41
    r32[esi] = 0x0030fb00;
  case 0x1e0a46: // 0160:1e0a46
    r32[edx] = r32[ebx];
    r32[eax] = r32[esi];
    yield* sub_1e4340();
    if (r32[eax])
        { pc = 0x1e0a33; break; }
    r32[eax] = r32[edi];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0a5a: // 0160:1e0a5a
    r32[esi] = memoryAGet32(ds, 0x310100);
    if (r32s[esi] < signed32(0x00000030))
        { pc = 0x1e0a6f; break; }
    r32[eax] = 0xfffffff9;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0a6f: // 0160:1e0a6f
    r32[edx] = r32[esi];
    r32[edi] = r32[esi];
    r32[edi] <<= 5;
    r32[eax] = r32[esi] + 1;
    memoryASet32(ds, 0x310100, r32[eax]);
    r32[edi] += 0x0030fb00;
    r32[esi] = r32[ebx];
    push32(r32[edi]);
  case 0x1e0a87: // 0160:1e0a87
    r8[al] = memoryAGet(ds, r32[esi]);
    memoryASet(ds, r32[edi], r8[al]);
    if (!r8[al])
        { pc = 0x1e0a9f; break; }
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
    r32[esi] += 0x00000002;
    memoryASet(ds, r32[edi] + 0x1, r8[al]);
    r32[edi] += 0x00000002;
    if (r8[al])
        { pc = 0x1e0a87; break; }
  case 0x1e0a9f: // 0160:1e0a9f
    r32[edi] = pop32();
    r32[eax] = r32[edx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0ab0() // 0160:1e0ab0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    r32[ecx] = 0;
    if (signed32(memoryAGet32(ds, 0x310100)) > signed32(0x00000000))
        { pc = 0x1e0ad1; break; }
    { pc = 0x1e0aea; break; }
  case 0x1e0ac3: // 0160:1e0ac3
    r32[ebx] += 0x00000020;
    r32[ecx]++;
    if (r32s[ecx] < signed32(memoryAGet32(ds, 0x310100)))
        { pc = 0x1e0ad6; break; }
    { pc = 0x1e0aea; break; }
  case 0x1e0ad1: // 0160:1e0ad1
    r32[ebx] = 0x0030fb00;
  case 0x1e0ad6: // 0160:1e0ad6
    r32[edx] = r32[esi];
    r32[eax] = r32[ebx];
    yield* sub_1e4340();
    if (r32[eax])
        { pc = 0x1e0ac3; break; }
    r32[eax] = r32[ecx];
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0aea: // 0160:1e0aea
    r32[eax] = 0xfffffff7;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0d30() // 0160:1e0d30 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e0d30; break; }
  case 0x1e0d02: // 0160:1e0d02
    r32[eax] = r32[edx];
    r32[eax] <<= 9;
    r32[eax] -= r32[edx];
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    flags.carry = !!(r32[edx] & 0x04000000);
    r32[edx] <<= 6;
    r32[eax] -= (r32[edx] + flags.carry);
    r32[eax] = sar32(r32[eax], 0x06);
    r32[edx] = r32[eax];
    r32[eax] = 0;
    yield* sub_1dcbc0();
    r32[eax] = 0;
    r32[esp] += 4; return;
    // gap 14 bytes // gap 14 bytes
  case 0x1e0d30: // 0160:1e0d30
    if (r32[eax] == 0x00000100)
        { pc = 0x1e0d02; break; }
    r32[eax] = 0xffffffff;
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0d40() // 0160:1e0d40 +long
{
    yield* sub_1db2c0();
}
function* sub_1e0d50() // 0160:1e0d50 +long
{
    yield* sub_1db470();
}
function* sub_1e0d60() // 0160:1e0d60 +long
{
    yield* sub_1db5b0();
}
function* sub_1e0d70() // 0160:1e0d70 +long
{
    yield* sub_1db5f0();
}
function* sub_1e0d80() // 0160:1e0d80 +long
{
    yield* sub_1db620();
}
function* sub_1e0dd0() // 0160:1e0dd0 +long
{
    yield* sub_1db660();
}
function* sub_1e0e80() // 0160:1e0e80 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
  case 0x1e0e84: // 0160:1e0e84
    r32[ebx]--;
    if (r16[bx] == 0xffff)
        { pc = 0x1e0ea0; break; }
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x313328);
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    memoryASet16(ds, 0x31332a, memoryAGet16(ds, 0x31332a) + 1);
    { pc = 0x1e0e84; break; }
  case 0x1e0ea0: // 0160:1e0ea0
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0ec0() // 0160:1e0ec0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
  case 0x1e0ec1: // 0160:1e0ec1
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000e;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x80)
        { pc = 0x1e0ee0; break; }
    r32[eax] = 0x00000001;
    yield* sub_1e0e80();
    { pc = 0x1e0ec1; break; }
  case 0x1e0ee0: // 0160:1e0ee0
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000a;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0f00() // 0160:1e0f00 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x00000004;
    out8(r16[dx], r8[al]);
    r32[eax] = 0x0000000a;
    yield* sub_1e0e80();
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x00000005;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e0f30() // 0160:1e0f30 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r8[bl] = r8[dl];
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x00000004;
    out8(r16[dx], r8[al]);
    r32[eax] = 0x0000000a;
    yield* sub_1e0e80();
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x00000005;
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[eax] = 0x0000001e;
    yield* sub_1e0e80();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e0f70() // 0160:1e0f70 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    if (memoryAGet16(ds, 0x313312))
        { pc = 0x1e0f7f; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0f7f: // 0160:1e0f7f
    r32[eax] = 0x0000000e;
    yield* sub_1e0f00();
    r8[al] &= 0xfd;
    r8[al] |= 0x02;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = 0x0000000e;
    yield* sub_1e0f30();
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0fb0() // 0160:1e0fb0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    if (memoryAGet16(ds, 0x313312))
        { pc = 0x1e0fbf; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1e0fbf: // 0160:1e0fbf
    r32[eax] = 0x0000000e;
    yield* sub_1e0f00();
    r8[al] &= 0xfd;
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = 0x0000000e;
    yield* sub_1e0f30();
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e0fe0() // 0160:1e0fe0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e0fe0; break; }
  case 0x1e0ea3: // 0160:1e0ea3
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000c;
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 299 bytes // gap 299 bytes
  case 0x1e0fe0: // 0160:1e0fe0
    r32[eax] = 0x000000d1;
    { pc = 0x1e1000; break; }
    // gap 25 bytes // gap 25 bytes
  case 0x1e1000: // 0160:1e1000
    push32(r32[ebx]);
    push32(r32[edx]);
    r8[bl] = r8[al];
  case 0x1e1004: // 0160:1e1004
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000c;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x80))
        { pc = 0x1e0ea3; break; }
    r32[eax] = 0x00000001;
    yield* sub_1e0e80();
    { pc = 0x1e1004; break; }
    return;
  }
}
function* sub_1e0ff0() // 0160:1e0ff0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e0ff0; break; }
  case 0x1e0ea3: // 0160:1e0ea3
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000c;
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 315 bytes // gap 315 bytes
  case 0x1e0ff0: // 0160:1e0ff0
    r32[eax] = 0x000000d3;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
    r32[ebx] = r32[ebx];
    push32(r32[ebx]);
    push32(r32[edx]);
    r8[bl] = r8[al];
  case 0x1e1004: // 0160:1e1004
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000c;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x80))
        { pc = 0x1e0ea3; break; }
    r32[eax] = 0x00000001;
    yield* sub_1e0e80();
    { pc = 0x1e1004; break; }
    return;
  }
}
function* sub_1e1000() // 0160:1e1000 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e1000; break; }
  case 0x1e0ea3: // 0160:1e0ea3
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000c;
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 331 bytes // gap 331 bytes
  case 0x1e1000: // 0160:1e1000
    push32(r32[ebx]);
    push32(r32[edx]);
    r8[bl] = r8[al];
  case 0x1e1004: // 0160:1e1004
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000c;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x80))
        { pc = 0x1e0ea3; break; }
    r32[eax] = 0x00000001;
    yield* sub_1e0e80();
    { pc = 0x1e1004; break; }
    return;
  }
}
function* sub_1e1090() // 0160:1e1090 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[eax] = 0x000000e1;
    yield* sub_1e1000();
    r32[eax] = 0x00000064;
    yield* sub_1e0e80();
    yield* sub_1e0ec0();
    r8[ah] = 0;
    memoryASet16(ds, 0x313318, r16[ax]);
    yield* sub_1e0ec0();
    r8[ah] = 0;
    memoryASet16(ds, 0x31331a, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x313318);
    if (r16[ax] > 0x0004)
        { pc = 0x1e1113; break; }
    r32[eax] &= 0x0000ffff;
    indirectJump(cs, memoryAGet32(cs, r32[eax] * 4 + 0x1e1074)); return; // 0160:1e10d1
    // gap 58 bytes // gap 58 bytes
  case 0x1e1113: // 0160:1e1113
    r32[edx] = 0;
    memoryASet16(ds, 0x313312, r16[dx]);
    memoryASet16(ds, 0x313310, r16[dx]);
    memoryASet16(ds, 0x313316, r16[dx]);
    memoryASet16(ds, 0x313314, 0x0001);
    memoryASet16(ds, 0x31330e, 0x0fa0);
    memoryASet16(ds, 0x31330c, 0x55f0);
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e11d0() // 0160:1e11d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[eax] = 0x00000064;
    yield* sub_1e0e80();
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x00000006;
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    r32[eax] = 0x00000064;
    yield* sub_1e0e80();
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x00000006;
    r8[al] = 0;
    out8(r16[dx], r8[al]);
    r32[ebx] = 0;
  case 0x1e1206: // 0160:1e1206
    r32[eax] = 0x00000064;
    yield* sub_1e0e80();
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000e;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x80))
        { pc = 0x1e1246; break; }
    r32[edx] = 0;
    r16[dx] = memoryAGet16(ds, 0x31331c);
    r32[edx] += 0x0000000a;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[eax] &= 0x000000ff;
    if (r32[eax] != 0x000000aa)
        { pc = 0x1e1246; break; }
    yield* sub_1e1090();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e1246: // 0160:1e1246
    r32[ebx]++;
    if (r32s[ebx] < signed32(0x00000064))
        { pc = 0x1e1206; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e1270() // 0160:1e1270 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    if (memoryAGet16(ds, 0x313312))
        { pc = 0x1e1283; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e1283: // 0160:1e1283
    if (r32s[edx] >= 0)
        { pc = 0x1e1289; break; }
    r32[edx] = 0;
  case 0x1e1289: // 0160:1e1289
    if (r32s[edx] <= signed32(0x00000100))
        { pc = 0x1e1296; break; }
    r32[edx] = 0x00000100;
  case 0x1e1296: // 0160:1e1296
    if (r32s[ebx] >= 0)
        { pc = 0x1e129c; break; }
    r32[ebx] = 0;
  case 0x1e129c: // 0160:1e129c
    if (r32s[ebx] <= signed32(0x00000100))
        { pc = 0x1e12a9; break; }
    r32[ebx] = 0x00000100;
  case 0x1e12a9: // 0160:1e12a9
    r32[eax] = r32[edx];
    r32[eax] <<= 4;
    r32[eax] -= r32[edx];
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    flags.carry = !!(r32[edx] & 0x01000000);
    r32[edx] <<= 8;
    r32[eax] -= (r32[edx] + flags.carry);
    r32[eax] = sar32(r32[eax], 0x08);
    r32[esi] = r32[eax];
    r32[edx] = r32[ebx];
    r32[edx] <<= 4;
    r32[edx] -= r32[ebx];
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    flags.carry = !!(r32[edx] & 0x01000000);
    r32[edx] <<= 8;
    r32[eax] -= (r32[edx] + flags.carry);
    r32[eax] = sar32(r32[eax], 0x08);
    r32[esi] <<= 4;
    r32[eax] |= r32[esi];
    if (r32[ecx] > 0x00000005)
        { pc = 0x1e1333; break; }
    indirectJump(cs, memoryAGet32(cs, r32[ecx] * 4 + 0x1e1254)); return; // 0160:1e12dd
    // gap 78 bytes // gap 78 bytes
  case 0x1e1333: // 0160:1e1333
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e1340() // 0160:1e1340 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    r32[eax] = 0x0f424000;
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ebx]);
    r32[ebx] = 0x00010000;
    r32[ebx] -= r32[eax];
    r32[ebx] = sar32(r32[ebx], 0x08);
    r32[eax] = r32[ebx];
    r32[eax] <<= 8;
    r32[ecx] = 0x00010000;
    r32[ecx] -= r32[eax];
    r32[eax] = 0x0f424000;
    r32[edx] = r32[eax];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ecx]);
    r32[edx] = r32[eax];
    r32[eax] = 0x00000040;
    yield* sub_1e1000();
    r32[eax] = 0;
    r8[al] = r8[bl];
    yield* sub_1e1000();
    r32[eax] = r32[edx];
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e1390() // 0160:1e1390 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[edx]--;
    r32[eax] = 0x00000048;
    yield* sub_1e1000();
    r32[eax] = 0;
    r8[al] = r8[dl];
    yield* sub_1e1000();
    r32[eax] = 0;
    r16[ax] = r16[dx];
    r32[eax] = sar32(r32[eax], 0x08);
    r32[eax] &= 0x000000ff;
    yield* sub_1e1000();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e13c0() // 0160:1e13c0 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[edx];
    r32[esi] = 0;
    r16[si] = memoryAGet16(ds, 0x31331e);
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = r32[esi];
    yield* sub_1db720();
    push32(flagAsReg32());
    flags.interrupts = 0;
    r32[eax] = 0x00000014;
    yield* sub_1e1000();
    r8[al] = r8[cl];
    r8[al]--;
    r32[eax] &= 0x000000ff;
    yield* sub_1e1000();
    r32[eax] = r32[ecx];
    r32[eax]--;
    r32[eax] = sar32(r32[eax], 0x08);
    r32[eax] &= 0x000000ff;
    yield* sub_1e1000();
    flagsFromReg32(pop32());
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e1410() // 0160:1e1410 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x31331e);
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = r32[ecx];
    yield* sub_1db7a0();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e1440() // 0160:1e1440 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e1440; break; }
  case 0x1db860: // 0160:1db860
    push32(r32[edx]);
    r32[eax] = r32s[eax] * signed32(0x00000054);
    r32[edx] = 0x002091fc;
    r32[edx] += r32[eax];
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x8);
    r32[edx] = memoryAGet32(ds, r32[edx] + 0x1c);
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[esp] += 4; return;
    // gap 23500 bytes // gap 23500 bytes
  case 0x1e1440: // 0160:1e1440
    r32[eax] = 0x000000d0;
    yield* sub_1e1000();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31331e);
    { pc = 0x1db860; break; }
    return;
  }
}
function* sub_1e1460() // 0160:1e1460 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    yield* sub_1e11d0();
    yield* sub_1e0ff0();
    yield* sub_1e1440();
    yield* sub_1e2560();
    r8[cl] = memoryAGet(ds, 0x313320);
    r32[edx] = 0x00000001;
    r32[edx] <<= r8[cl];
    r32[eax] |= r32[edx];
    r32[eax] &= 0x0000ffff;
    yield* sub_1e2580();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x209f44);
    r32[edx] = memoryAGet32(ds, 0x209f40);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    yield* sub_1e23a0();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ebx] >= signed32(0x00000008))
        { pc = 0x1e14cf; break; }
    r32[ebx] += 0x00000060;
    r8[al] = r8[bl];
    r32[edx] = 0x00000020;
    { pc = 0x1e14df; break; }
  case 0x1e14cf: // 0160:1e14cf
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx] + 88;
    r32[edx] = 0x000000a0;
  case 0x1e14df: // 0160:1e14df
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e14f0() // 0160:1e14f0 +long
{
    r32[esp] -= 4;
    r32[eax] = sar32(r32[eax], 0x10);
    r32[esp] += 4;
}
function* sub_1e1500() // 0160:1e1500 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[eax] = 0;
    if (signed32(memoryAGet32(ds, 0x209f54)) <= signed32(0x00000000))
        { pc = 0x1e1529; break; }
  case 0x1e150c: // 0160:1e150c
    r32[edx] = memoryAGet32(ds, 0x31332c);
    memoryASet(ds, r32[edx] + r32[eax], 0x80);
    r32[edx] = memoryAGet32(ds, 0x313330);
    memoryASet(ds, r32[edx] + r32[eax], 0x80);
    r32[eax]++;
    if (r32s[eax] < signed32(memoryAGet32(ds, 0x209f54)))
        { pc = 0x1e150c; break; }
  case 0x1e1529: // 0160:1e1529
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e1530() // 0160:1e1530 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x209f54);
    r32[eax] = (r32[eax] * 4) + 0;
    yield* sub_1e24b0();
    r32[edx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e1583; break; }
  case 0x1e154a: // 0160:1e154a
    r32[eax] = r32[edx];
    yield* sub_1e14f0();
    r32[ebx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x209f54);
    r32[eax] += r32[eax];
    r32[eax] += r32[edx];
    r32[eax]--;
    yield* sub_1e14f0();
    r32[ecx] = memoryAGet32(ds, 0x209f54);
    r32[ecx] += r32[edx];
    if (r32[ebx] == r32[eax])
        { pc = 0x1e1572; break; }
    r32[edx] = r32[ecx];
    { pc = 0x1e154a; break; }
  case 0x1e1572: // 0160:1e1572
    memoryASet32(ds, 0x31332c, r32[edx]);
    memoryASet32(ds, 0x313330, r32[ecx]);
    r32[eax] = 0x00000001;
  case 0x1e1583: // 0160:1e1583
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e1590() // 0160:1e1590 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    if (memoryAGet32(ds, 0x209f58) != 0xffffffff)
        { pc = 0x1e15ab; break; }
    yield* sub_1e1530();
    if (!r32[eax])
        { pc = 0x1e15b5; break; }
    r32[ebx] = 0;
    memoryASet32(ds, 0x209f58, r32[ebx]);
  case 0x1e15ab: // 0160:1e15ab
    yield* sub_1e1500();
    r32[eax] = 0x00000001;
  case 0x1e15b5: // 0160:1e15b5
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e15c0() // 0160:1e15c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[eax] >= signed32(0x00000001))
        { pc = 0x1e15ca; break; }
    r32[eax] = 0x00000001;
  case 0x1e15ca: // 0160:1e15ca
    if (r32s[eax] <= signed32(0x00000118))
        { pc = 0x1e15d6; break; }
    r32[eax] = 0x00000118;
  case 0x1e15d6: // 0160:1e15d6
    memoryASet16(ds, 0x209f4c, r16[ax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1e15e0() // 0160:1e15e0 +long
{
    r32[esp] -= 4;
    memoryASet32(ds, 0x313338, r32[eax]);
    r32[esp] += 4;
}
function* sub_1e15f0() // 0160:1e15f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    if (!memoryAGet32(ds, 0x313338))
        { pc = 0x1e1602; break; }
    yield* indirectCall(cs, memoryAGet32(ds, 0x313338));
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e1602: // 0160:1e1602
    r32[ebx] = r32[edx];
    r32[edx] = 0x00000080;
    yield* sub_1e3de0();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e1610() // 0160:1e1610 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000004;
    r32[esi] = r32[eax];
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    r32[edi] = r32[ebx];
    if (r32s[ecx] <= signed32(0x00000007))
        { pc = 0x1e162b; break; }
    r32[eax] = 0;
    { pc = 0x1e1851; break; }
  case 0x1e162b: // 0160:1e162b
    r32[ebx] = r32[ecx];
    r32[edx] = r32[edi];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1e19e0();
    if (!r32[eax])
        { pc = 0x1e1851; break; }
    r32[edx] = 0;
    memoryASet32(ds, 0x313324, r32[edx]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet16(ds, 0x31331c, r16[ax]);
    memoryASet16(ds, 0x313320, r16[cx]);
    memoryASet16(ds, 0x31331e, r16[di]);
    r32[eax] = 0;
    r16[ax] = r16[di];
    if (r32s[eax] <= signed32(0x00000003))
        { pc = 0x1e1670; break; }
    r32[eax] = 0;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e1670: // 0160:1e1670
    yield* sub_1e11d0();
    if (!r32[eax])
        { pc = 0x1e1851; break; }
    yield* sub_1e1590();
    if (!r32[eax])
        { pc = 0x1e1851; break; }
    if (!memoryAGet16(ds, 0x313310))
        { pc = 0x1e1699; break; }
    yield* sub_1e0fb0();
  case 0x1e1699: // 0160:1e1699
    yield* sub_1e0fe0();
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31330e);
    if (r32s[esi] < r32s[eax])
        { pc = 0x1e16b6; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31330c);
    if (r32s[esi] <= r32s[eax])
        { pc = 0x1e16b8; break; }
  case 0x1e16b6: // 0160:1e16b6
    r32[esi] = r32[eax];
  case 0x1e16b8: // 0160:1e16b8
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[ebx] = 0x00209f44;
    r32[edx] = 0x00209f40;
    yield* sub_1e2350();
    if (memoryAGet16(ds, 0x313314))
        { pc = 0x1e1702; break; }
    r32[edx] = cs;
    r32[eax] = 0x001e0de8;
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[edx] = 0x001e0de8;
    { pc = 0x1e1722; break; }
  case 0x1e1702: // 0160:1e1702
    r32[edx] = cs;
    r32[eax] = 0x001e0e06;
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[edx] = 0x001e0e06;
  case 0x1e1722: // 0160:1e1722
    yield* sub_1e23a0();
    yield* sub_1e2560();
    r8[cl] = memoryAGet(ds, 0x313320);
    r32[edx] = 0x00000001;
    r32[edx] <<= r8[cl];
    r32[edx] = ~r32[edx];
    r32[eax] &= r32[edx];
    r32[eax] &= 0x0000ffff;
    yield* sub_1e2580();
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ecx] >= signed32(0x00000008))
        { pc = 0x1e1761; break; }
    r32[eax] = r32[ecx] + 96;
    r32[edx] = 0x00000020;
    { pc = 0x1e1771; break; }
  case 0x1e1761: // 0160:1e1761
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ecx] + 88;
    r32[edx] = 0x000000a0;
  case 0x1e1771: // 0160:1e1771
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[eax] = r32[esi];
    yield* sub_1e1340();
    memoryASet16(ds, 0x313322, r16[ax]);
    r32[ebx] = 0;
    memoryASet32(ds, 0x209f58, r32[ebx]);
    r32[edx] = 0;
    r16[dx] = r16[ax];
    r16[bx] = memoryAGet16(ds, 0x209f4c);
    r32[eax] = r32[edx];
    r32[edx] = sar32(r32[edx], 0x1f);
    idiv32(r32[ebx]);
    r32[eax]++;
    r8[al] &= 0xfe;
    memoryASet32(ds, 0x209f54, r32[eax]);
    if (r32s[eax] >= signed32(0x00000080))
        { pc = 0x1e17b4; break; }
    memoryASet32(ds, 0x209f54, 0x00000080);
  case 0x1e17b4: // 0160:1e17b4
    r32[eax] = memoryAGet32(ds, 0x209f54);
    r32[edi] = memoryAGet32(ds, 0x209f50);
    if (r32s[eax] <= r32s[edi])
        { pc = 0x1e17c9; break; }
    memoryASet32(ds, 0x209f54, r32[edi]);
  case 0x1e17c9: // 0160:1e17c9
    r32[eax] = memoryAGet32(ds, 0x31332c);
    r32[edx] = memoryAGet32(ds, 0x209f54);
    r32[ebx] = r32[eax] + r32[edx];
    memoryASet32(ds, 0x313330, r32[ebx]);
    if (memoryAGet16(ds, 0x313314))
        { pc = 0x1e180e; break; }
    yield* sub_1e15f0();
    r32[edx] = memoryAGet32(ds, 0x209f54);
    r32[eax] = memoryAGet32(ds, 0x313330);
    yield* sub_1e15f0();
    r32[edx] = memoryAGet32(ds, 0x209f54);
    r32[eax] = memoryAGet32(ds, 0x31332c);
    yield* sub_1e13c0();
    { pc = 0x1e1849; break; }
  case 0x1e180e: // 0160:1e180e
    yield* sub_1e15f0();
    r32[edx] = memoryAGet32(ds, 0x209f54);
    r32[eax] = memoryAGet32(ds, 0x313330);
    yield* sub_1e15f0();
    r32[edx] = memoryAGet32(ds, 0x209f54);
    r32[edx] += r32[edx];
    r32[eax] = memoryAGet32(ds, 0x31332c);
    yield* sub_1e1410();
    r32[eax] = memoryAGet32(ds, 0x209f54);
    yield* sub_1e1390();
    r32[eax] = 0x0000001c;
    yield* sub_1e1000();
  case 0x1e1849: // 0160:1e1849
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313322);
  case 0x1e1851: // 0160:1e1851
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e19e0() // 0160:1e19e0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    memoryASet16(ds, 0x31331c, r16[ax]);
    memoryASet16(ds, 0x31331e, r16[dx]);
    memoryASet16(ds, 0x313320, r16[bx]);
    yield* sub_1e11d0();
    if (!r32[eax])
        { pc = 0x1e1b56; break; }
    yield* sub_1e1590();
    if (!r32[eax])
        { pc = 0x1e1b56; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[ebx] = 0x00209f44;
    r32[edx] = 0x00209f40;
    yield* sub_1e2350();
    r32[edx] = cs;
    r32[eax] = 0x001e0e24;
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[edx] = 0x001e0e24;
    yield* sub_1e23a0();
    yield* sub_1e2560();
    r32[esi] = r32[eax];
    r8[cl] = memoryAGet(ds, 0x313320);
    r32[edx] = 0x00000001;
    r32[edx] <<= r8[cl];
    r32[edx] = ~r32[edx];
    r32[eax] &= r32[edx];
    r32[eax] &= 0x0000ffff;
    yield* sub_1e2580();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ebx] >= signed32(0x00000008))
        { pc = 0x1e1a90; break; }
    r32[eax] = r32[ebx] + 96;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    { pc = 0x1e1aa1; break; }
  case 0x1e1a90: // 0160:1e1a90
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx] + 88;
    r32[edx] = 0x000000a0;
    out8(r16[dx], r8[al]);
  case 0x1e1aa1: // 0160:1e1aa1
    flagsFromReg32(pop32());
    r32[edx] = 0;
    memoryASet32(ds, 0x313334, r32[edx]);
    yield* sub_1e0ff0();
    r32[eax] = 0x00002710;
    yield* sub_1e1340();
    r32[eax] = memoryAGet32(ds, 0x31332c);
    r32[edx] = 0x000003e8;
    yield* sub_1e13c0();
    r32[edx] = 0;
  case 0x1e1aca: // 0160:1e1aca
    if (signed32(memoryAGet32(ds, 0x313334)) < signed32(0x00000004))
        { pc = 0x1e1b24; break; }
  case 0x1e1ad3: // 0160:1e1ad3
    yield* sub_1e11d0();
    yield* sub_1e1440();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x209f44);
    r32[edx] = memoryAGet32(ds, 0x209f40);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    yield* sub_1e23a0();
    r32[eax] = 0;
    r16[ax] = r16[si];
    yield* sub_1e2580();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ebx] >= signed32(0x00000008))
        { pc = 0x1e1b31; break; }
    r32[eax] = r32[ebx] + 96;
    r32[edx] = 0x00000020;
    { pc = 0x1e1b41; break; }
  case 0x1e1b24: // 0160:1e1b24
    yield* sub_1e2690();
    r32[edx]++;
    if (r32s[edx] < signed32(0x00000024))
        { pc = 0x1e1aca; break; }
    { pc = 0x1e1ad3; break; }
  case 0x1e1b31: // 0160:1e1b31
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx] + 88;
    r32[edx] = 0x000000a0;
  case 0x1e1b41: // 0160:1e1b41
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    if (signed32(memoryAGet32(ds, 0x313334)) >= signed32(0x00000004))
        { pc = 0x1e1b51; break; }
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e1b51: // 0160:1e1b51
    r32[eax] = 0x00000001;
  case 0x1e1b56: // 0160:1e1b56
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e1c00() // 0160:1e1c00 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e1c00; break; }
  case 0x1e1854: // 0160:1e1854
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
    // gap 937 bytes // gap 937 bytes
  case 0x1e1c00: // 0160:1e1c00
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edi] = r32[eax];
    r32[esi] = r32[edx];
    r32[eax] = 0x0020b26c;
    yield* sub_1e3508();
    r32[edx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e1854; break; }
  case 0x1e1c1a: // 0160:1e1c1a
    if (!memoryAGet(ds, r32[edx]))
        { pc = 0x1e1854; break; }
  case 0x1e1c23: // 0160:1e1c23
    r8[al] = memoryAGet(ds, r32[edx]);
    if (r8[al] == 0x20)
        { pc = 0x1e1c2d; break; }
    if (r8[al] != 0x09)
        { pc = 0x1e1c86; break; }
  case 0x1e1c2d: // 0160:1e1c2d
    r32[edx]++;
    { pc = 0x1e1c23; break; }
  case 0x1e1c30: // 0160:1e1c30
    push32(r32[edi]);
    push32(0x0020b274);
    r32[eax] = r32[edx] + 1;
    push32(r32[eax]);
    yield* sub_1e3dbe();
    r32[esp] += 0x0000000c;
    { pc = 0x1e1cb6; break; }
  case 0x1e1c47: // 0160:1e1c47
    push32(r32[ebx]);
    push32(0x0020b277);
    r32[eax] = r32[edx] + 1;
    push32(r32[eax]);
    yield* sub_1e3dbe();
    r32[esp] += 0x0000000c;
    { pc = 0x1e1cb6; break; }
  case 0x1e1c5e: // 0160:1e1c5e
    push32(r32[esi]);
    push32(0x0020b27a);
    r32[eax] = r32[edx] + 1;
    push32(r32[eax]);
    yield* sub_1e3dbe();
    r32[esp] += 0x0000000c;
    { pc = 0x1e1cb6; break; }
  case 0x1e1c72: // 0160:1e1c72
    push32(r32[ecx]);
    push32(0x0020b27d);
    r32[eax] = r32[edx] + 1;
    push32(r32[eax]);
    yield* sub_1e3dbe();
    r32[esp] += 0x0000000c;
    { pc = 0x1e1cb6; break; }
  case 0x1e1c86: // 0160:1e1c86
    if (r8[al] < 0x54)
        { pc = 0x1e1ca2; break; }
    if (r8[al] <= 0x54)
        { pc = 0x1e1c72; break; }
    if (r8[al] < 0x64)
        { pc = 0x1e1c9e; break; }
    if (r8[al] <= 0x64)
        { pc = 0x1e1c5e; break; }
    if (r8[al] < 0x69)
        { pc = 0x1e1cb6; break; }
    if (r8[al] <= 0x69)
        { pc = 0x1e1c47; break; }
    if (r8[al] == 0x74)
        { pc = 0x1e1c72; break; }
    { pc = 0x1e1cb6; break; }
  case 0x1e1c9e: // 0160:1e1c9e
    flags.zero = r8[al] == 0x61;
    { pc = 0x1e1cb0; break; }
  case 0x1e1ca2: // 0160:1e1ca2
    if (r8[al] < 0x44)
        { pc = 0x1e1cae; break; }
    if (r8[al] <= 0x44)
        { pc = 0x1e1c5e; break; }
    if (r8[al] == 0x49)
        { pc = 0x1e1c47; break; }
    { pc = 0x1e1cb6; break; }
  case 0x1e1cae: // 0160:1e1cae
    flags.zero = r8[al] == 0x41;
  case 0x1e1cb0: // 0160:1e1cb0
    if (flags.zero)
        { pc = 0x1e1c30; break; }
  case 0x1e1cb6: // 0160:1e1cb6
    r8[al] = memoryAGet(ds, r32[edx]);
    if (!r8[al])
        { pc = 0x1e1c1a; break; }
    if (r8[al] == 0x20)
        { pc = 0x1e1c1a; break; }
    if (r8[al] == 0x09)
        { pc = 0x1e1c1a; break; }
    r32[edx]++;
    { pc = 0x1e1cb6; break; }
    return;
  }
}
function* sub_1e1d00() // 0160:1e1d00 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000048;
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    memoryASet32(ss, r32[ebp] - 8, r32[ebx]);
    memoryASet32(ss, r32[ebp] - 16, r32[ecx]);
    r32[ecx] = 0x00000005;
    r32[edi] = r32[ebp] - 52;
    r32[esi] = 0x00209f9c;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[ecx] = 0x00000005;
    r32[edi] = r32[ebp] - 72;
    r32[esi] = 0x00209fb0;
    for (; r16[cx] != 0; --r16[cx]) movsd_ESEDI_DSESI();
    r32[edi] = r32[ebp] - 32;
    r32[esi] = 0x00209fc4;
    movsd_ESEDI_DSESI();
    movsd_ESEDI_DSESI();
    movsd_ESEDI_DSESI();
    movsd_ESEDI_DSESI();
    yield* sub_1e1590();
    if (!r32[eax])
        { pc = 0x1e2310; break; }
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ds, r32[eax], 0xffffffff);
    memoryASet32(ds, r32[edx], 0xffffffff);
    memoryASet32(ds, r32[ebx], 0xffffffff);
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e1d7d; break; }
    push32(0x0020b280);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1e1d7d: // 0160:1e1d7d
    r32[ebx] = 0;
    r32[edx] = 0;
    if (signed32(memoryAGet32(ss, r32[ebp] - 52)) < signed32(0x00000000))
        { pc = 0x1e1dc4; break; }
    r32[edi] = memoryAGet32(ss, r32[ebp] - 16);
  case 0x1e1d8a: // 0160:1e1d8a
    r16[ax] = memoryAGet16(ds, r32[edx] + r32[ebp] - 52);
    memoryASet16(ds, 0x31331c, r16[ax]);
    if (r32[edi])
        { pc = 0x1e1db0; break; }
    push32(0x0020b292);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1e1db0: // 0160:1e1db0
    yield* sub_1e11d0();
    if (r32[eax])
        { pc = 0x1e1dc4; break; }
    r32[edx] += 0x00000004;
    r32[ebx]++;
    if (signed32(memoryAGet32(ds, r32[edx] + r32[ebp] - 52)) >= signed32(0x00000000))
        { pc = 0x1e1d8a; break; }
  case 0x1e1dc4: // 0160:1e1dc4
    if (signed32(memoryAGet32(ss, r32[ebp] + r32[ebx] * 4 - 52)) >= signed32(0x00000000))
        { pc = 0x1e1de7; break; }
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e230e; break; }
    push32(0x0020b294);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    { pc = 0x1e230e; break; }
  case 0x1e1de7: // 0160:1e1de7
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e1e03; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31331c);
    push32(r32[eax]);
    push32(0x0020b29d);
    yield* sub_1e34e6();
    r32[esp] += 0x00000008;
  case 0x1e1e03: // 0160:1e1e03
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31331c);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet32(ds, r32[edx], r32[eax]);
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e1e2d; break; }
    push32(0x0020b2a8);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1e1e2d: // 0160:1e1e2d
    yield* sub_1e1090();
    if (r32[eax])
        { pc = 0x1e1e55; break; }
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e230e; break; }
    push32(0x0020b2ba);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e1e55: // 0160:1e1e55
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e1e7a; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31331a);
    push32(r32[eax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313318);
    push32(r32[eax]);
    push32(0x0020b2c3);
    yield* sub_1e34e6();
    r32[esp] += 0x0000000c;
  case 0x1e1e7a: // 0160:1e1e7a
    if (!memoryAGet16(ds, 0x313316))
        { pc = 0x1e2087; break; }
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e1ea9; break; }
    push32(0x0020b2d2);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1e1ea9: // 0160:1e1ea9
    r32[eax] = 0x00000080;
    yield* sub_1e0f00();
    r8[al] &= 0x0f;
    r32[eax] &= 0x000000ff;
    r32[eax]--;
    if (r32[eax] > 0x00000007)
        { pc = 0x1e1f18; break; }
    indirectJump(cs, memoryAGet32(cs, r32[eax] * 4 + 0x1e1cd4)); return; // 0160:1e1ec0
    // gap 80 bytes // gap 80 bytes
  case 0x1e1f18: // 0160:1e1f18
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e230e; break; }
    push32(0x0020b2e4);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
    // gap 336 bytes // gap 336 bytes
  case 0x1e2087: // 0160:1e2087
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e20a4; break; }
    push32(0x0020b364);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1e20a4: // 0160:1e20a4
    r32[esi] = 0;
    if (signed32(memoryAGet32(ss, r32[ebp] - 72)) < signed32(0x00000000))
        { pc = 0x1e22fb; break; }
  case 0x1e20b0: // 0160:1e20b0
    r16[ax] = memoryAGet16(ds, r32[esi] + r32[ebp] - 72);
    memoryASet16(ds, 0x313320, r16[ax]);
    r32[eax] &= 0x0000ffff;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[ebx] = 0x00209f44;
    r32[edx] = 0x00209f40;
    yield* sub_1e2350();
    r32[edx] = cs;
    r32[eax] = 0x001e0e24;
    r32[ebx] = 0;
    r16[bx] = r16[dx];
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    r32[edx] = 0x001e0e24;
    yield* sub_1e23a0();
    yield* sub_1e2560();
    r32[edi] = r32[eax];
    r8[cl] = memoryAGet(ds, 0x313320);
    r32[edx] = 0x00000001;
    r32[edx] <<= r8[cl];
    r32[edx] = ~r32[edx];
    r32[eax] &= r32[edx];
    r32[eax] &= 0x0000ffff;
    yield* sub_1e2580();
    r32[ebx] = 0;
    if (signed32(memoryAGet32(ss, r32[ebp] - 32)) < signed32(0x00000000))
        { pc = 0x1e2294; break; }
  case 0x1e2129: // 0160:1e2129
    r32[ecx] = 0;
    r16[cx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ecx] >= signed32(0x00000008))
        { pc = 0x1e2143; break; }
    r32[eax] = r32[ecx] + 96;
    r32[edx] = 0x00000020;
    { pc = 0x1e2155; break; }
  case 0x1e2143: // 0160:1e2143
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[ecx] += 0x00000058;
    r8[al] = r8[cl];
    r32[edx] = 0x000000a0;
  case 0x1e2155: // 0160:1e2155
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r16[ax] = memoryAGet16(ds, r32[ebx] + r32[ebp] - 32);
    memoryASet16(ds, 0x31331e, r16[ax]);
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e217f; break; }
    push32(0x0020b376);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
    r32[eax] = 0x0020a52a;
    yield* sub_1e3d5a();
  case 0x1e217f: // 0160:1e217f
    r32[eax] = 0;
    memoryASet32(ds, 0x313334, r32[eax]);
    yield* sub_1e11d0();
    yield* sub_1e0ff0();
    r32[eax] = 0x00002710;
    yield* sub_1e1340();
    r32[eax] = memoryAGet32(ds, 0x31332c);
    r32[edx] = 0x000003e8;
    yield* sub_1e13c0();
    r32[edx] = 0;
  case 0x1e21ab: // 0160:1e21ab
    if (signed32(memoryAGet32(ds, 0x313334)) < signed32(0x00000004))
        { pc = 0x1e223b; break; }
  case 0x1e21b8: // 0160:1e21b8
    yield* sub_1e11d0();
    yield* sub_1e1440();
    if (signed32(memoryAGet32(ds, 0x313334)) < signed32(0x00000004))
        { pc = 0x1e2286; break; }
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e21f4; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31331e);
    push32(r32[eax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    push32(r32[eax]);
    push32(0x0020b378);
    yield* sub_1e34e6();
    r32[esp] += 0x0000000c;
  case 0x1e21f4: // 0160:1e21f4
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x209f44);
    r32[edx] = memoryAGet32(ds, 0x209f40);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    yield* sub_1e23a0();
    r32[eax] = 0;
    r16[ax] = r16[di];
    yield* sub_1e2580();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ebx] >= signed32(0x00000008))
        { pc = 0x1e224f; break; }
    r32[eax] = r32[ebx] + 96;
    r32[edx] = 0x00000020;
    { pc = 0x1e225f; break; }
  case 0x1e223b: // 0160:1e223b
    yield* sub_1e2690();
    r32[edx]++;
    if (r32s[edx] < signed32(0x00000012))
        { pc = 0x1e21ab; break; }
    { pc = 0x1e21b8; break; }
  case 0x1e224f: // 0160:1e224f
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx] + 88;
    r32[edx] = 0x000000a0;
  case 0x1e225f: // 0160:1e225f
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x31331e);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[eax] = 0x00000001;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e2286: // 0160:1e2286
    r32[ebx] += 0x00000004;
    if (signed32(memoryAGet32(ds, r32[ebx] + r32[ebp] - 32)) >= signed32(0x00000000))
        { pc = 0x1e2129; break; }
  case 0x1e2294: // 0160:1e2294
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x209f44);
    r32[edx] = memoryAGet32(ds, 0x209f40);
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x313320);
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x209f5c);
    yield* sub_1e23a0();
    r32[eax] = 0;
    r16[ax] = r16[di];
    yield* sub_1e2580();
    r32[ebx] = 0;
    r16[bx] = memoryAGet16(ds, 0x313320);
    push32(flagAsReg32());
    flags.interrupts = 0;
    if (r32s[ebx] >= signed32(0x00000008))
        { pc = 0x1e22db; break; }
    r32[eax] = r32[ebx] + 96;
    r32[edx] = 0x00000020;
    { pc = 0x1e22eb; break; }
  case 0x1e22db: // 0160:1e22db
    r8[al] = 0x62;
    r32[edx] = 0x00000020;
    out8(r16[dx], r8[al]);
    r32[eax] = r32[ebx] + 88;
    r32[edx] = 0x000000a0;
  case 0x1e22eb: // 0160:1e22eb
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[esi] += 0x00000004;
    if (signed32(memoryAGet32(ds, r32[esi] + r32[ebp] - 72)) >= signed32(0x00000000))
        { pc = 0x1e20b0; break; }
  case 0x1e22fb: // 0160:1e22fb
    if (memoryAGet32(ss, r32[ebp] - 16))
        { pc = 0x1e230e; break; }
    push32(0x0020b385);
    yield* sub_1e34e6();
    r32[esp] += 0x00000004;
  case 0x1e230e: // 0160:1e230e
    r32[eax] = 0;
  case 0x1e2310: // 0160:1e2310
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e2350() // 0160:1e2350 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000028;
    r32[edi] = r32[edx];
    r32[esi] = r32[ebx];
    r32[eax] += 0x00003500;
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    r32[edx] = 0;
    memoryASet16(ss, r32[ebp] - 12, r16[dx]);
    memoryASet16(ss, r32[ebp] - 6, r16[dx]);
    r32[ecx] = r32[ebp] - 12;
    r32[ebx] = r32[ebp] - 40;
    r32[edx] = r32[ebp] - 40;
    r32[eax] = 0x00000021;
    yield* sub_1e39c0();
    r32[eax] = memoryAGet32(ss, r32[ebp] - 12);
    memoryASet16(ds, r32[esi], r16[ax]);
    r32[eax] = memoryAGet32(ss, r32[ebp] - 36);
    memoryASet32(ds, r32[edi], r32[eax]);
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1e23a0() // 0160:1e23a0 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000028;
    r32[eax] += 0x00002500;
    memoryASet32(ss, r32[ebp] - 40, r32[eax]);
    memoryASet32(ss, r32[ebp] - 28, r32[edx]);
    memoryASet16(ss, r32[ebp] - 6, r16[bx]);
    r32[edx] = 0;
    memoryASet16(ss, r32[ebp] - 12, r16[dx]);
    r32[ecx] = r32[ebp] - 12;
    r32[ebx] = r32[ebp] - 40;
    r32[edx] = r32[ebp] - 40;
    r32[eax] = 0x00000021;
    yield* sub_1e39c0();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1e2460() // 0160:1e2460 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000001c;
    r32[ebx] = r32[eax];
    memoryASet16(ss, r32[ebp] - 28, 0x0600);
    r32[eax] = sar32(r32[eax], 0x10);
    memoryASet16(ss, r32[ebp] - 24, r16[ax]);
    memoryASet16(ss, r32[ebp] - 20, r16[bx]);
    r32[eax] = r32[edx];
    r32[eax] = sar32(r32[eax], 0x10);
    memoryASet16(ss, r32[ebp] - 12, r16[ax]);
    memoryASet16(ss, r32[ebp] - 8, r16[dx]);
    r32[ebx] = r32[ebp] - 28;
    r32[edx] = r32[ebp] - 28;
    r32[eax] = 0x00000031;
    yield* sub_1e39d9();
    r8[al] = memoryAGet32(ss, r32[ebp] - 4) == 0x00000000;
    r32[eax] &= 0x000000ff;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e24b0() // 0160:1e24b0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000001c;
    memoryASet32(ss, r32[ebp] - 28, 0x00000100);
    r32[eax] += 0x0000000f;
    r32[eax] = sar32(r32[eax], 0x04);
    memoryASet32(ss, r32[ebp] - 24, r32[eax]);
    r32[ebx] = r32[ebp] - 28;
    r32[edx] = r32[ebp] - 28;
    r32[eax] = 0x00000031;
    yield* sub_1e39d9();
    if (!memoryAGet32(ss, r32[ebp] - 4))
        { pc = 0x1e24e2; break; }
    r32[eax] = 0;
    { pc = 0x1e24ed; break; }
  case 0x1e24e2: // 0160:1e24e2
    r32[eax] = memoryAGet32(ss, r32[ebp] - 28);
    r32[eax] &= 0x0000ffff;
    r32[eax] <<= 4;
  case 0x1e24ed: // 0160:1e24ed
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e2500() // 0160:1e2500 +long
{
    r32[esp] -= 4;
    r32[eax] = sar32(r32[eax], 0x10);
    r32[esp] += 4;
}
function* sub_1e2510() // 0160:1e2510 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[eax];
    r32[ebx] = r32[eax] + r32[edx];
    r32[ecx] = r32[edx];
    r32[ecx] = -r32[ecx];
    r32[ebx]--;
    r32[ebx] &= r32[ecx];
    r32[eax] = (r32[ebx] * 2) + 0;
    r32[eax] += r32[edx];
    r32[eax]--;
    yield* sub_1e24b0();
    if (!r32[eax])
        { pc = 0x1e2551; break; }
    r32[edx] += r32[eax];
    r32[edx]--;
    r32[edx] &= r32[ecx];
    r32[eax] = r32[edx];
    yield* sub_1e2500();
    r32[ecx] = r32[eax];
    r32[ebx] += r32[edx];
    r32[eax] = r32[ebx] - 1;
    yield* sub_1e2500();
    if (r32[ecx] == r32[eax])
        { pc = 0x1e254f; break; }
    r32[edx] = r32[ebx];
  case 0x1e254f: // 0160:1e254f
    r32[eax] = r32[edx];
  case 0x1e2551: // 0160:1e2551
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e2560() // 0160:1e2560 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = 0x000000a1;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[ebx] = r32[eax];
    r32[ebx] <<= 8;
    r32[edx] = 0x00000021;
    r32[eax] = 0;
    r8[al] = in8(r16[dx]);
    r32[eax] |= r32[ebx];
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e2580() // 0160:1e2580 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    r32[eax] = 0;
    r16[ax] = r16[bx];
    r32[eax] = sar32(r32[eax], 0x08);
    r32[edx] = 0x000000a1;
    out8(r16[dx], r8[al]);
    r8[al] = r8[bl];
    r32[edx] = 0x00000021;
    out8(r16[dx], r8[al]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e25a0() // 0160:1e25a0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    r32[edx] = 0;
    r32[eax] = 0x001234dc;
    div32(r32[ebx]);
    if (r32[eax])
        { pc = 0x1e25b6; break; }
    r32[eax] = 0x00000001;
  case 0x1e25b6: // 0160:1e25b6
    if (r32[eax] < 0x00010000)
        { pc = 0x1e25bf; break; }
    r32[eax] = 0;
  case 0x1e25bf: // 0160:1e25bf
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e2600() // 0160:1e2600 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    push32(flagAsReg32());
    flags.interrupts = 0;
    r8[al] = 0x34;
    r32[edx] = 0x00000043;
    out8(r16[dx], r8[al]);
    r8[al] = r8[bl];
    r32[edx] = 0x00000040;
    out8(r16[dx], r8[al]);
    r32[eax] = 0;
    r16[ax] = r16[bx];
    r32[eax] = sar32(r32[eax], 0x08);
    out8(r16[dx], r8[al]);
    flagsFromReg32(pop32());
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e2690() // 0160:1e2690 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0x0000046c;
    r32[edx] = memoryAGet32(ds, r32[edx]);
    r32[eax] = 0x0000046c;
  case 0x1e269d: // 0160:1e269d
    yield* sync();
    if (r32[edx] == memoryAGet32(ds, r32[eax]))
        { pc = 0x1e269d; break; }
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e26f0() // 0160:1e26f0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    if (r32s[eax] < 0)
        { pc = 0x1e26fa; break; }
    if (r32s[eax] < signed32(0x00000020))
        { pc = 0x1e26fe; break; }
  case 0x1e26fa: // 0160:1e26fa
    r32[eax] = 0;
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e26fe: // 0160:1e26fe
    r32[eax] = r32s[eax] * signed32(0x0000002c);
    r32[ebx] = memoryAGet32(ds, 0x20a4dc);
    memoryASet32(ds, r32[ebx] + r32[eax] + 0x28, r32[edx]);
    r32[eax] = 0x00000001;
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3220() // 0160:1e3220 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x0000045c;
    r32[esi] = r32[eax];
    yield* sub_1e4083();
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    r32[ecx] = r32[esi];
    r32[ebx] = 0x00000001;
    r32[edx] = 0x00000454;
    r32[eax] = r32[ebp] - 1116;
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1e325e; break; }
    r32[eax] = 0xfffffffd;
    { pc = 0x1e330e; break; }
  case 0x1e325e: // 0160:1e325e
    r32[ebx] = 0x00000004;
    r32[edx] = 0x0020b458;
    r32[eax] = r32[ebp] - 1116;
    yield* sub_1e3d27();
    if (!r32[eax])
        { pc = 0x1e3285; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e3285: // 0160:1e3285
    if (signed32(memoryAGet32(ss, r32[ebp] - 20)) <= signed32(0x00000020))
        { pc = 0x1e3299; break; }
    r32[eax] = 0xfffffffd;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e3299: // 0160:1e3299
    r32[eax] = r32[ebp] - 1108;
    yield* sub_1e0a20();
    memoryASet32(ss, r32[ebp] - 4, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e330e; break; }
    r32[edx] = memoryAGet32(ss, r32[ebp] - 1112);
    r32[eax] = 0x0020b45d;
    yield* sub_1df820();
    r32[edi] = r32[eax];
    if (r32[eax])
        { pc = 0x1e32cf; break; }
    r32[eax] = 0xfffffffc;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e32cf: // 0160:1e32cf
    r32[ebx] = 0;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 8);
    r32[eax] = r32[esi];
    yield* sub_1e4237();
    r32[ecx] = r32[esi];
    r32[ebx] = 0x00000001;
    r32[edx] = memoryAGet32(ss, r32[ebp] - 1112);
    r32[eax] = r32[edi];
    yield* sub_1e3b5d();
    if (r32[eax] == 0x00000001)
        { pc = 0x1e3302; break; }
    r32[eax] = 0xfffffffc;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e3302: // 0160:1e3302
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    memoryASet32(ds, r32[eax] * 4 + 0x316404, r32[edi]);
    r32[eax] = 0;
  case 0x1e330e: // 0160:1e330e
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3320() // 0160:1e3320 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[eax] >= 0)
        { pc = 0x1e3328; break; }
    r32[eax] = 0;
    { pc = 0x1e3332; break; }
  case 0x1e3328: // 0160:1e3328
    if (r32s[eax] <= signed32(0x00000040))
        { pc = 0x1e3332; break; }
    r32[eax] = 0x00000040;
  case 0x1e3332: // 0160:1e3332
    memoryASet32(ds, 0x20a4e0, r32[eax]);
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3340() // 0160:1e3340 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20a4e0);
    r32[esp] += 4;
}
function* sub_1e3350() // 0160:1e3350 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r8[ah] = 0;
    memoryASet(ds, 0x31333c, r8[ah]);
    r32[edx] = 0;
    memoryASet32(ds, 0x316400, r32[edx]);
    memoryASet32(ds, 0x20a4dc, 0x00313340);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e33c0() // 0160:1e33c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    if (memoryAGet32(ds, r32[eax] + 0x580))
        { pc = 0x1e33d7; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e33d7: // 0160:1e33d7
    memoryASet32(ds, r32[eax] + 0x598, 0x00000000);
    r32[ebx] = 0;
    r32[edx] = 0;
    { pc = 0x1e3410; break; }
  case 0x1e33e7: // 0160:1e33e7
    r32[eax]++;
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e33f0: // 0160:1e33f0
    r32[ecx] = memoryAGet32(ds, 0x20a4dc);
    memoryASet32(ds, r32[ecx] + r32[edx] + 0x59c, r32[eax]);
    r32[ebx] += 0x00000022;
    r32[edx] += 0x00000004;
    if (r32[edx] == 0x0000007c)
        { pc = 0x1e342d; break; }
    r32[eax] = r32[eax];
    r32[edx] = r32[edx];
  case 0x1e3410: // 0160:1e3410
    r32[eax] = memoryAGet32(ds, 0x20a4dc);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x580);
    r32[eax] += 0x00000028;
    r32[eax] += r32[ebx];
    yield* sub_1e09d0();
    if (r32s[eax] >= 0)
        { pc = 0x1e33e7; break; }
    r32[eax] = 0;
    { pc = 0x1e33f0; break; }
  case 0x1e342d: // 0160:1e342d
    memoryASet(ds, 0x31333c, 0x01);
    r32[eax] = 0x00000001;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e34e6() // 0160:1e34e6 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[esp] -= 0x00000004;
    r32[ebx] = r32[esp] + 20;
    r32[eax] = 0x0020a52a;
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x10);
    memoryASet32(ds, r32[esp], r32[ebx]);
    r32[ebx] = r32[esp];
    yield* sub_1e43f2();
    r32[esp] += 0x00000004;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e3508() // 0160:1e3508 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[eax];
    r32[esi] = memoryAGet32(ds, 0x20a724);
    if (!r32[esi])
        { pc = 0x1e3559; break; }
    if (!r32[eax])
        { pc = 0x1e3559; break; }
    r32[edi] = r32[eax];
    push(es);
    r32[eax] = ds;
    es = r32[eax];
    r32[ecx] = 0;
    r32[ecx]--;
    r32[eax] = 0;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESEDI(r8[al]);
    r32[ecx] = ~r32[ecx];
    r32[ecx]--;
    es = pop();
    r32[edi] = r32[ecx];
    { pc = 0x1e3553; break; }
  case 0x1e3534: // 0160:1e3534
    r32[eax] = r32[ecx];
    r32[edx] = r32[ebp];
    r32[ebx] = r32[edi];
    yield* sub_1e4478();
    if (r32[eax])
        { pc = 0x1e3550; break; }
    if (memoryAGet(ds, r32[ecx] + r32[edi]) != 0x3d)
        { pc = 0x1e3550; break; }
    r32[eax] = r32[edi] + 1;
    r32[eax] += r32[ecx];
    { pc = 0x1e355b; break; }
  case 0x1e3550: // 0160:1e3550
    r32[esi] += 0x00000004;
  case 0x1e3553: // 0160:1e3553
    r32[ecx] = memoryAGet32(ds, r32[esi]);
    if (r32[ecx])
        { pc = 0x1e3534; break; }
  case 0x1e3559: // 0160:1e3559
    r32[eax] = 0;
  case 0x1e355b: // 0160:1e355b
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3562() // 0160:1e3562 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push(fs);
    push(gs);
    push32(r32[ebp]);
    r32[esp] -= 0x00000004;
    r32[esi] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e357b; break; }
    if (r32[eax] <= 0xffffffd4)
        { pc = 0x1e3582; break; }
  case 0x1e357b: // 0160:1e357b
    r32[eax] = 0;
    { pc = 0x1e3636; break; }
  case 0x1e3582: // 0160:1e3582
    r32[ebp] = 0x0020a4e4;
    r32[edi] = r32[esi] + 3;
    r8[ah] = 0;
    r32[ebx] = 0;
    memoryASet(ds, r32[esp], r8[ah]);
    r16[di] &= 0xfffc;
  case 0x1e3595: // 0160:1e3595
    r32[eax] = r32[edi];
    if (r32[edi] >= 0x0000000c)
        { pc = 0x1e35a1; break; }
    r32[eax] = 0x0000000c;
  case 0x1e35a1: // 0160:1e35a1
    if (r32[eax] <= memoryAGet32(ds, 0x20a4ec))
        { pc = 0x1e35c1; break; }
    r32[ecx] = memoryAGet32(ds, 0x20a4e8);
    if (r32[ecx])
        { pc = 0x1e35f9; break; }
  case 0x1e35b3: // 0160:1e35b3
    memoryASet32(ds, 0x20a4ec, r32[ecx]);
    r32[ecx] = memoryAGet32(ds, 0x20a4e4);
    { pc = 0x1e35f9; break; }
  case 0x1e35c1: // 0160:1e35c1
    r32[ecx] = 0;
    { pc = 0x1e35b3; break; }
  case 0x1e35c5: // 0160:1e35c5
    r32[edx] = ds;
    r32[eax] = r32[ebp];
    memoryASet32(ds, 0x20a4e8, r32[ecx]);
    r32[edx] &= 0x0000ffff;
    r32[eax] = r32[esi];
    r32[ebx] = r32[ecx];
    yield* sub_1e44d0();
    r32[ebx] = r32[eax];
    if (r32[eax])
        { pc = 0x1e362c; break; }
    r32[eax] = memoryAGet32(ds, 0x20a4ec);
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0x14);
    if (r32[edx] <= r32[eax])
        { pc = 0x1e35f6; break; }
    memoryASet32(ds, 0x20a4ec, r32[edx]);
  case 0x1e35f6: // 0160:1e35f6
    r32[ecx] = memoryAGet32(ds, r32[ecx] + 0x8);
  case 0x1e35f9: // 0160:1e35f9
    if (r32[ecx])
        { pc = 0x1e35c5; break; }
    if (memoryAGet(ds, r32[esp]))
        { pc = 0x1e360e; break; }
    r32[eax] = r32[esi];
    yield* sub_1e4a67();
    if (r32[eax])
        { pc = 0x1e3623; break; }
  case 0x1e360e: // 0160:1e360e
    r32[eax] = r32[esi];
    yield* sub_1e4c22();
    if (!r32[eax])
        { pc = 0x1e362c; break; }
    r8[cl] = 0;
    memoryASet(ds, r32[esp], r8[cl]);
    { pc = 0x1e3595; break; }
  case 0x1e3623: // 0160:1e3623
    memoryASet(ds, r32[esp], 0x01);
    { pc = 0x1e3595; break; }
  case 0x1e362c: // 0160:1e362c
    r8[ch] = 0;
    r32[eax] = r32[ebx];
    memoryASet(ds, 0x3164cd, r8[ch]);
  case 0x1e3636: // 0160:1e3636
    r32[esp] += 0x00000004;
    r32[ebp] = pop32();
    gs = pop();
    fs = pop();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3645() // 0160:1e3645 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, 0x20a750);
    memoryASet32(ds, 0x20a750, r32[edx]);
    if (r32[eax])
        { pc = 0x1e3660; break; }
    r8[ah] = 0x08;
    interrupt(0x21);
    r32[eax] &= 0x000000ff;
  case 0x1e3660: // 0160:1e3660
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3663() // 0160:1e3663 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a4f0));
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a4f4));
    r32[eax] = r32[edx];
    yield* sub_1e367b();
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e367b() // 0160:1e367b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a4f4));
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a4f8));
    r32[eax] = r32[edx];
    { pc = 0x1e3977; break; }
    // gap 742 bytes // gap 742 bytes
  case 0x1e3977: // 0160:1e3977
    { pc = 0x1e399c; break; }
    // gap 35 bytes // gap 35 bytes
  case 0x1e399c: // 0160:1e399c
    push32(r32[eax]);
    r32[eax] = 0x00000000;
    r32[edx] = 0x000000ff;
    yield* sub_1e4cc1();
    r32[eax] = pop32();
    r8[ah] = 0x4c;
    interrupt(0x21);
    stop("terminating");
    return;
  }
}
function* sub_1e3691() // 0160:1e3691 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
  case 0x1e3694: // 0160:1e3694
    r8[dl] = memoryAGet(ds, r32[eax]);
    r8[dl]++;
    r32[edx] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[edx] + 0x20b628) & 0x02))
        { pc = 0x1e36aa; break; }
    r32[eax]++;
    { pc = 0x1e3694; break; }
  case 0x1e36aa: // 0160:1e36aa
    r8[cl] = memoryAGet(ds, r32[eax]);
    if (r8[cl] == 0x2b)
        { pc = 0x1e36b6; break; }
    if (r8[cl] != 0x2d)
        { pc = 0x1e36b7; break; }
  case 0x1e36b6: // 0160:1e36b6
    r32[eax]++;
  case 0x1e36b7: // 0160:1e36b7
    r32[ebx] = 0;
  case 0x1e36b9: // 0160:1e36b9
    r8[dl] = memoryAGet(ds, r32[eax]);
    r8[dl]++;
    r32[edx] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[edx] + 0x20b628) & 0x20))
        { pc = 0x1e36db; break; }
    r32[ebx] = r32s[ebx] * signed32(0x0000000a);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax]);
    r32[ebx] += r32[edx];
    r32[eax]++;
    r32[ebx] -= 0x00000030;
    { pc = 0x1e36b9; break; }
  case 0x1e36db: // 0160:1e36db
    if (r8[cl] != 0x2d)
        { pc = 0x1e36e2; break; }
    r32[ebx] = -r32[ebx];
  case 0x1e36e2: // 0160:1e36e2
    r32[eax] = r32[ebx];
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e36e8() // 0160:1e36e8 +entry
{
    yield* sub_1e3760();
}
function* sub_1e3760() // 0160:1e3760 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    flags.interrupts = 1;
    r32[esp] &= 0xfffffffc;
    r32[ebx] = r32[esp];
    memoryASet32(ds, 0x20a744, r32[ebx]);
    memoryASet32(ds, 0x20a730, r32[ebx]);
    r16[ax] = 0x0024;
    memoryASet16(ds, 0x20a73c, r16[ax]);
    r32[ebx] = 0x50484152;
    r32[eax] = 0;
    r8[ah] = 0x30;
    interrupt(0x21);
    memoryASet(ds, 0x20a767, r8[al]);
    memoryASet(ds, 0x20a768, r8[ah]);
    r32[ecx] = r32[eax];
    r32[esi] = 0;
    r32[edi] = 0x00000081;
    r32[eax] >>>= 16;
    if (r16[ax] != 0x4458)
        { pc = 0x1e37e2; break; }
    r8[bl] -= 0x30;
    r8[al] = r8[bl];
    r8[ah] = 0x00;
    push32(r32[eax]);
    es = memoryAGet16(ds, 0x20a73c);
    r32[ebx] = memoryAGet32(es, 0x5c);
    r32[ebx] += 0x00000fff;
    r32[ebx] &= 0xfffff000;
    memoryASet32(ds, 0x20a730, r32[ebx]);
    r32[ebx] >>>= 12;
    r16[ax] = ds;
    es = r32[eax];
    r8[ah] = 0x4a;
    interrupt(0x21);
    r32[eax] = pop32();
    r16[bx] = ds;
    r16[cx] = 0x002c;
    { pc = 0x1e381a; break; }
  case 0x1e37e2: // 0160:1e37e2
    if (r16[ax] != 0x4243)
        { pc = 0x1e381c; break; }
    memoryASet32(ds, 0x20a4fc, r32[edx]);
    r32[esi] = r32[edx];
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x1c);
    r32[ebx] = r32[esp];
    r32[ebx] -= r32[edx];
    r8[ah] = 0x4a;
    interrupt(0x21);
    r16[bx] = ds;
    memoryASet16(ds, 0x20a73c, ds);
    r32[eax] = memoryAGet32(ds, r32[esi] + 0x10);
    r32[edi] += r32[eax];
    r32[esi] = 0;
    r16[si] = memoryAGet16(ds, r32[eax] + 0x2c);
    r32[esi] <<= 4;
    r16[cx] = ds;
    r8[al] = 0x09;
    r8[ah] = 0x00;
  case 0x1e381a: // 0160:1e381a
    { pc = 0x1e3875; break; }
  case 0x1e381c: // 0160:1e381c
    r16[dx] = 0x0078;
    r16[ax] = 0xff00;
    interrupt(0x21);
    if (!r8[al])
        { pc = 0x1e385e; break; }
    r16[ax] = gs;
    if (!r16[ax])
        { pc = 0x1e3839; break; }
    memoryASet16(ds, 0x20a500, r16[ax]);
  case 0x1e3839: // 0160:1e3839
    r16[ax] = 0x0006;
    r16[bx] = ds;
    interrupt(0x31);
    r8[al] = 0x01;
    r8[ah] = 0x00;
    r16[dx] |= r16[cx];
    if (!r16[dx])
        { pc = 0x1e384d; break; }
    r8[ah] = 0x01;
  case 0x1e384d: // 0160:1e384d
    memoryASet16(ds, 0x20a73c, es);
    r16[cx] = memoryAGet16(es, 0x2c);
    { pc = 0x1e3875; break; }
  case 0x1e385e: // 0160:1e385e
    r16[dx] = ds;
    r16[cx] = 0x0024;
    ds = r32[ecx];
    r16[cx] = 0x002c;
    ds = r32[edx];
    r16[bx] = 0x0017;
    r8[al] = 0x00;
    r8[ah] = 0x00;
  case 0x1e3875: // 0160:1e3875
    memoryASet(ds, 0x20a75e, r8[al]);
    memoryASet(ds, 0x20a75f, r8[ah]);
    es = r32[ebx];
    memoryASet16(es, 0x1e39bd, ds);
    memoryASet32(ds, 0x20a761, r32[esi]);
    memoryASet16(ds, 0x20a765, r16[cx]);
    push32(r32[esi]);
    es = memoryAGet16(ds, 0x20a73c);
    r32[edx] = 0x00316568;
    r32[edx] += 0x0000000f;
    r8[dl] &= 0xf0;
    r32[ecx] = 0;
    r8[cl] = memoryAGet(es, r32[edi] - 1);
    flags.direction = 0;
    r8[al] = 0x20;
    for (flags.zero = 1; r16[cx] != 0 && flags.zero; --r16[cx]) scasb_inv_ESEDI(r8[al]);
    r32[esi] = r32[edi] - 1;
    r32[edi] = r32[edx];
    r16[bx] = es;
    r16[dx] = ds;
    ds = r32[ebx];
    es = r32[edx];
    if (flags.zero)
        { pc = 0x1e38ca; break; }
    r32[ecx]++;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESEDI_DSESI();
  case 0x1e38ca: // 0160:1e38ca
    r8[al] = 0;
    stosb_ESEDI(r8[al]);
    stosb_ESEDI(r8[al]);
    r32[esi] = pop32();
    r32[edi]--;
    push32(r32[edi]);
    push32(r32[edx]);
    ds = memoryAGet16(es, 0x20a765);
    r32[ebp] = 0;
  case 0x1e38dc: // 0160:1e38dc
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[eax] |= 0x20202020;
    if (r32[eax] != 0x37386f6e)
        { pc = 0x1e38f1; break; }
    if (memoryAGet(ds, r32[esi] + 0x4) != 0x3d)
        { pc = 0x1e38f1; break; }
    r32[ebp]++;
  case 0x1e38f1: // 0160:1e38f1
    r8[al] = lodsb_DSESI();
    if (memoryAGet(ds, r32[esi]))
        { pc = 0x1e38f1; break; }
    if (memoryAGet(ds, r32[esi]))
        { pc = 0x1e38dc; break; }
    r8[al] = lodsb_DSESI();
    r32[esi]++;
    r32[esi]++;
  case 0x1e38ff: // 0160:1e38ff
    movsb_ESEDI_DSESI();
    if (memoryAGet(ds, r32[esi]))
        { pc = 0x1e38ff; break; }
    ds = pop();
    r32[esi] = pop32();
    r32[ebx] = r32[esp];
    memoryASet16(ds, 0x20a75c, r16[bp]);
    memoryASet32(ds, 0x20a740, r32[edi]);
    memoryASet32(ds, 0x20a72c, r32[ebx]);
    r32[ecx] = 0x00316568;
    r32[edi] = 0x0020b800;
    r32[ecx] -= r32[edi];
    if (memoryAGet(ds, 0x20a75e) != 0x01)
        { pc = 0x1e3940; break; }
    if (r32[ecx] <= 0x00001000)
        { pc = 0x1e3940; break; }
    r32[ecx] = 0x00001000;
  case 0x1e3940: // 0160:1e3940
    r8[dl] = r8[cl];
    r32[ecx] >>>= 2;
    r32[eax] = 0;
    for (; r16[cx] != 0; --r16[cx]) stosd_ESEDI(r32[eax]);
    r8[cl] = r8[dl];
    r8[cl] &= 0x03;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESEDI(r8[al]);
    r32[eax] = 0x00316568;
    r32[eax] += 0x0000000f;
    r8[al] &= 0xf0;
    memoryASet32(ds, 0x20a734, r32[eax]);
    memoryASet32(ds, 0x20a738, r32[esi]);
    r32[eax] = 0x000000ff;
    yield* sub_1e4c76();
    r32[ebp] = 0;
    yield* sub_1e4c26();
    { pc = 0x1e399c; break; }
    // gap 35 bytes // gap 35 bytes
  case 0x1e399c: // 0160:1e399c
    push32(r32[eax]);
    r32[eax] = 0x00000000;
    r32[edx] = 0x000000ff;
    yield* sub_1e4cc1();
    r32[eax] = pop32();
    r8[ah] = 0x4c;
    interrupt(0x21);
    stop("terminating");
    return;
  }
}
function* sub_1e3979() // 0160:1e3979 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    push32(r32[eax]);
    r32[edx] = 0x001e375c;
    r16[ax] = 0x3d01;
    interrupt(0x21);
    r16[bx] = r16[ax];
    r32[edx] = pop32();
    r32[esi] = r32[edx];
    flags.direction = 0;
  case 0x1e398d: // 0160:1e398d
    r8[al] = lodsb_DSESI();
    if (r8[al])
        { pc = 0x1e398d; break; }
    r32[ecx] = r32[esi];
    r32[ecx] -= r32[edx];
    r32[ecx]--;
    r8[ah] = 0x40;
    interrupt(0x21);
    r32[eax] = pop32();
    push32(r32[eax]);
    r32[eax] = 0x00000000;
    r32[edx] = 0x000000ff;
    yield* sub_1e4cc1();
    r32[eax] = pop32();
    r8[ah] = 0x4c;
    interrupt(0x21);
    stop("terminating");
    return;
  }
}
function* sub_1e39c0() // 0160:1e39c0 +long
{
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebp] = r32[ebx];
    r32[ebx] = r32[ecx];
    r32[esi] = r32[eax];
    r32[edi] = r32[edx];
    r32[edx] = r32[ebp];
    yield* sub_1e4eb6();
    r32[eax] = memoryAGet32(ss, r32[ebp]);
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
}
function* sub_1e39d9() // 0160:1e39d9 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[esp] -= 0x0000000c;
    r32[ecx] = r32[eax];
    r32[eax] = r32[esp];
    yield* sub_1e5294();
    r32[eax] = r32[ecx];
    r32[ecx] = r32[esp];
    yield* sub_1e39c0();
    r32[esp] += 0x0000000c;
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1e39f4() // 0160:1e39f4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    stop("disassembly failed at 0160:1e39f7 (ftst )");
    r32[esp] -= 0x00000018;
    memoryASet16(ss, r32[ebp] - 8, fnstsw());
    memoryASet64(ss, r32[ebp] - 24, fst64());
    r8[ah] = memoryAGet(ss, r32[ebp] - 7);
    sahf();
    if (!flags.zero)
        { pc = 0x1e3a23; break; }
    r8[al] = 0x00;
  case 0x1e3a0b: // 0160:1e3a0b
    fstp80();
    memoryASet64(ss, r32[ebp] - 16, fstp64());
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    yield* sub_1e52bc();
    r32[esp] -= 0x00000008;
    { pc = 0x1e3b02; break; }
  case 0x1e3a23: // 0160:1e3a23
    fld80(st(1));
    frndint();
    fcomp80(st(2));
    memoryASet16(ss, r32[ebp] - 6, fnstsw());
    r8[ah] = memoryAGet(ss, r32[ebp] - 5);
    if (!flags.carry)
        { pc = 0x1e3a6e; break; }
    r8[al] = 0x01;
    sahf();
    if (!flags.zero)
        { pc = 0x1e3a0b; break; }
    r16[ax] = 0x0002;
    memoryASet16(ss, r32[ebp] - 4, r16[ax]);
    fild16(memoryAGet16(ss, r32[ebp] - 4));
    fld80(st(2));
    stop("disassembly failed at 0160:1e3a45 (fprem )");
    memoryASet16(ss, r32[ebp] - 4, fnstsw());
    r8[ah] = memoryAGet(ss, r32[ebp] - 3);
    sahf();
    r8[ah] = 0x00;
    if (stop("bad condition - jp"))
        { pc = 0x1e3a65; break; }
    stop("disassembly failed at 0160:1e3a54 (ftst )");
    memoryASet16(ss, r32[ebp] - 4, fnstsw());
    r8[ah] = memoryAGet(ss, r32[ebp] - 3);
    sahf();
    r8[ah] = 0x00;
    if (flags.zero)
        { pc = 0x1e3a65; break; }
    r8[ah] = 0x01;
  case 0x1e3a65: // 0160:1e3a65
    memoryASet(ss, r32[ebp] - 7, r8[ah]);
    fstp80();
    fstp80();
    { pc = 0x1e3a71; break; }
  case 0x1e3a6e: // 0160:1e3a6e
    sahf();
    if (!flags.zero)
        { pc = 0x1e3ae3; break; }
  case 0x1e3a71: // 0160:1e3a71
    fld80(st(1));
    memoryASet64(ss, r32[ebp] - 16, fstp64());
    r16[ax] = memoryAGet16(ss, r32[ebp] - 10);
    r16[ax] &= 0x7ff0;
    r16[ax] -= 0x3ff0;
    flags.sign = r16s[ax] < signed16(0x0100);
    if (r16[ax] >= 0x0100)
        { pc = 0x1e3ae3; break; }
    fld80(st(1));
    memoryASet32(ss, r32[ebp] - 4, fistp32());
    r16[ax] = memoryAGet16(ss, r32[ebp] - 2);
    if (r16[ax])
        { pc = 0x1e3aa3; break; }
    r16[ax] = memoryAGet16(ss, r32[ebp] - 4);
    yield* sub_1e3b0d();
    { pc = 0x1e3ab9; break; }
  case 0x1e3aa3: // 0160:1e3aa3
    r16[ax]++;
    flags.sign = r16s[ax] < 0;
    if (r16[ax])
        { pc = 0x1e3ae3; break; }
    r16[ax] |= memoryAGet16(ss, r32[ebp] - 4);
    flags.sign = r16s[ax] < 0;
    if (!r16[ax])
        { pc = 0x1e3ae3; break; }
    r16[ax] = -r16[ax];
    yield* sub_1e3b0d();
    fld1();
    stop("disassembly failed at 0160:1e3ab7 (fdivrp st(1))");
  case 0x1e3ab9: // 0160:1e3ab9
    memoryASet64(ss, r32[ebp] - 8, fst64());
    r16[ax] = memoryAGet16(ss, r32[ebp] - 8);
    r16[ax] |= memoryAGet16(ss, r32[ebp] - 6);
    r16[ax] |= memoryAGet16(ss, r32[ebp] - 4);
    if (r16[ax])
        { pc = 0x1e3adf; break; }
    r16[ax] = memoryAGet16(ss, r32[ebp] - 2);
    r16[ax] <<= 1;
    if (r16[ax] != 0xffe0)
        { pc = 0x1e3adf; break; }
  case 0x1e3ad8: // 0160:1e3ad8
    r8[al] = 0x02;
    { pc = 0x1e3a0b; break; }
  case 0x1e3adf: // 0160:1e3adf
    st(1) = fstp_check80();
    { pc = 0x1e3b02; break; }
  case 0x1e3ae3: // 0160:1e3ae3
    stop("disassembly failed at 0160:1e3ae3 (fldln2 )");
    fmul80(st(2));
    fxch80(st(0));
    stop("disassembly failed at 0160:1e3ae9 (fabs )");
    stop("disassembly failed at 0160:1e3aeb (fyl2x )");
    r8[al] = 0x07;
    yield* sub_1e535e();
    if (r8[al])
        { pc = 0x1e3ad8; break; }
    r8[ah] = memoryAGet(ss, r32[ebp] - 7);
    sahf();
    if (!flags.carry)
        { pc = 0x1e3b00; break; }
    fchs();
  case 0x1e3b00: // 0160:1e3b00
    st(1) = fstp_check80();
  case 0x1e3b02: // 0160:1e3b02
    memoryASet64(ss, r32[ebp] - 8, fstp64());
    fld64(memoryAGet64(ss, r32[ebp] - 8));
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3b0d() // 0160:1e3b0d +long
{
  var pc = 0;
  var temp_cond0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
  case 0x1e3b0d: // 0160:1e3b0d
    temp_cond0 =     stop("TODO: shr - jbe");;
    r16[ax] >>>= 1;
    if (temp_cond0)
        { pc = 0x1e3b16; break; }
    fmul80(st(0));
    { pc = 0x1e3b0d; break; }
  case 0x1e3b16: // 0160:1e3b16
    if (stop("TODO: dirty 0160:1e3b16"))
        { pc = 0x1e3b2b; break; }
    fld80(st(0));
  case 0x1e3b1a: // 0160:1e3b1a
    if (!r16[ax])
        { pc = 0x1e3b27; break; }
    fmul80(st(0));
    flags.carry = r16[ax] & 1;
    r16[ax] >>>= 1;
    flags.zero = r16[ax] == 0;
    if (!flags.carry)
        { pc = 0x1e3b25; break; }
    fmul80(st(1));
  case 0x1e3b25: // 0160:1e3b25
    { pc = 0x1e3b1a; break; }
  case 0x1e3b27: // 0160:1e3b27
    fstp80();
    { pc = 0x1e3b2f; break; }
  case 0x1e3b2b: // 0160:1e3b2b
    fstp80();
    fld1();
  case 0x1e3b2f: // 0160:1e3b2f
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e3b30() // 0160:1e3b30 +long +stackDrop16
{
    r32[esp] -= 4;
    fld64(memoryAGet64(ds, r32[esp] + 0xc));
    fld64(memoryAGet64(ds, r32[esp] + 0x4));
    yield* sub_1e39f4();
    r32[esp] += 20;
}
function* sub_1e3b40() // 0160:1e3b40 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    memoryASet16(ds, r32[esp], fnstcw());
    push32(memoryAGet32(ds, r32[esp]));
    memoryASet(ds, r32[esp] + 0x1, 0x1f);
    fldcw(memoryAGet16(ds, r32[esp]));
    frndint();
    fldcw(memoryAGet16(ds, r32[esp] + 0x4));
    r32[esp] = r32[esp] + 8;
    stop("stack_unbalanced");
    r32[esp] += 4;
}
function* sub_1e3b5d() // 0160:1e3b5d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000008;
    push32(r32[eax]);
    push32(r32[edx]);
    r32[ebp] = r32[ecx];
    if (memoryAGet(ds, r32[ecx] + 0xc) & 0x01)
        { pc = 0x1e3b87; break; }
    r32[eax] = 0x00000004;
    yield* sub_1e53d1();
    r8[dh] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[dh] |= 0x20;
    r32[eax] = 0;
    memoryASet(ds, r32[ecx] + 0xc, r8[dh]);
    { pc = 0x1e3d20; break; }
  case 0x1e3b87: // 0160:1e3b87
    r32[ebx] = r32s[ebx] * r32s[edx];
    if (r32[ebx])
        { pc = 0x1e3b95; break; }
    r32[eax] = r32[ebx];
    { pc = 0x1e3d20; break; }
  case 0x1e3b95: // 0160:1e3b95
    if (memoryAGet32(ds, r32[ecx] + 0x8))
        { pc = 0x1e3ba2; break; }
    r32[eax] = r32[ebp];
    yield* sub_1e5407();
  case 0x1e3ba2: // 0160:1e3ba2
    r32[esi] = 0;
    r8[dl] = memoryAGet(ss, r32[ebp] + 0xc);
    memoryASet32(ds, r32[esp] + 0xc, r32[esi]);
    if (!(r8[dl] & 0x40))
        { pc = 0x1e3ca1; break; }
    memoryASet32(ds, r32[esp] + 0x8, r32[ebx]);
  case 0x1e3bb8: // 0160:1e3bb8
    r32[edx] = memoryAGet32(ss, r32[ebp] + 0x4);
    if (!r32[edx])
        { pc = 0x1e3c13; break; }
    r32[ebx] = memoryAGet32(ds, r32[esp] + 0x8);
    if (r32[edx] <= r32[ebx])
        { pc = 0x1e3bc9; break; }
    r32[edx] = r32[ebx];
  case 0x1e3bc9: // 0160:1e3bc9
    r32[edi] = memoryAGet32(ds, r32[esp] + 0x4);
    r32[ecx] = r32[edx];
    r32[esi] = memoryAGet32(ss, r32[ebp]);
    r32[ebx] = memoryAGet32(ds, r32[esp] + 0xc);
    push(es);
    r32[eax] = ds;
    es = r32[eax];
    push32(r32[edi]);
    r32[eax] = r32[ecx];
    r32[ecx] >>>= 2;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsd_ESEDI_DSESI();
    r8[cl] = r8[al];
    r8[cl] &= 0x03;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    es = pop();
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x8);
    r32[ecx] = memoryAGet32(ss, r32[ebp]);
    r32[esi] = r32[edi] + r32[edx];
    r32[ebx] += r32[edx];
    memoryASet32(ds, r32[esp] + 0x4, r32[esi]);
    memoryASet32(ds, r32[esp] + 0xc, r32[ebx]);
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x4);
    r32[ecx] += r32[edx];
    r32[eax] -= r32[edx];
    r32[edi] -= r32[edx];
    memoryASet32(ss, r32[ebp], r32[ecx]);
    memoryASet32(ds, r32[esp] + 0x8, r32[eax]);
    memoryASet32(ss, r32[ebp] + 0x4, r32[edi]);
  case 0x1e3c13: // 0160:1e3c13
    r32[ecx] = memoryAGet32(ds, r32[esp] + 0x8);
    if (!r32[ecx])
        { pc = 0x1e3d15; break; }
    if (r32[ecx] >= memoryAGet32(ss, r32[ebp] + 0x14))
        { pc = 0x1e3c2a; break; }
    if (!(memoryAGet(ss, r32[ebp] + 0xd) & 0x04))
        { pc = 0x1e3c8d; break; }
  case 0x1e3c2a: // 0160:1e3c2a
    r8[cl] = memoryAGet(ss, r32[ebp] + 0xd);
    r32[ebx] = memoryAGet32(ds, r32[esp] + 0x8);
    if (r8[cl] & 0x04)
        { pc = 0x1e3c43; break; }
    if (r32[ebx] <= 0x00000200)
        { pc = 0x1e3c43; break; }
    r8[bh] &= 0xfe;
    r8[bl] = 0;
  case 0x1e3c43: // 0160:1e3c43
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x4);
    r32[eax] = memoryAGet32(ss, r32[ebp] + 0x10);
    yield* sub_1e547e();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e3c5d; break; }
    memoryASet(ss, r32[ebp] + 0xc, memoryAGet(ss, r32[ebp] + 0xc) | 0x20);
    { pc = 0x1e3d15; break; }
  case 0x1e3c5d: // 0160:1e3c5d
    if (r32[eax])
        { pc = 0x1e3c6a; break; }
  case 0x1e3c61: // 0160:1e3c61
    memoryASet(ss, r32[ebp] + 0xc, memoryAGet(ss, r32[ebp] + 0xc) | 0x10);
    { pc = 0x1e3d15; break; }
  case 0x1e3c6a: // 0160:1e3c6a
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x4);
    r32[ebx] = memoryAGet32(ds, r32[esp] + 0x8);
    r32[ecx] = memoryAGet32(ds, r32[esp] + 0xc);
    r32[edx] += r32[eax];
    r32[ebx] -= r32[eax];
    r32[ecx] += r32[eax];
    memoryASet32(ds, r32[esp] + 0x4, r32[edx]);
    memoryASet32(ds, r32[esp] + 0x8, r32[ebx]);
    memoryASet32(ds, r32[esp] + 0xc, r32[ecx]);
    { pc = 0x1e3bb8; break; }
  case 0x1e3c8d: // 0160:1e3c8d
    r32[eax] = r32[ebp];
    yield* sub_1e5555();
    if (!r32[eax])
        { pc = 0x1e3d15; break; }
    { pc = 0x1e3bb8; break; }
  case 0x1e3ca1: // 0160:1e3ca1
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x4);
    r32[ebx] += r32[edx];
  case 0x1e3ca7: // 0160:1e3ca7
    if (memoryAGet32(ss, r32[ebp] + 0x4))
        { pc = 0x1e3cb8; break; }
    r32[eax] = r32[ebp];
    yield* sub_1e5555();
    if (!r32[eax])
        { pc = 0x1e3d15; break; }
  case 0x1e3cb8: // 0160:1e3cb8
    r32[ecx] = memoryAGet32(ss, r32[ebp] + 0x4);
    r32[eax] = memoryAGet32(ss, r32[ebp]);
    r32[ecx]--;
    r32[esi] = r32[eax] + 1;
    memoryASet32(ss, r32[ebp] + 0x4, r32[ecx]);
    memoryASet32(ss, r32[ebp], r32[esi]);
    r8[al] = memoryAGet(ds, r32[eax]);
    r32[eax] &= 0x000000ff;
    if (r32[eax] != 0x0000000d)
        { pc = 0x1e3cfc; break; }
    if (memoryAGet32(ss, r32[ebp] + 0x4))
        { pc = 0x1e3ce5; break; }
    r32[eax] = r32[ebp];
    yield* sub_1e5555();
    if (!r32[eax])
        { pc = 0x1e3d15; break; }
  case 0x1e3ce5: // 0160:1e3ce5
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x4);
    r32[eax] = memoryAGet32(ss, r32[ebp]);
    r32[edi]--;
    r32[esi] = r32[eax] + 1;
    memoryASet32(ss, r32[ebp] + 0x4, r32[edi]);
    memoryASet32(ss, r32[ebp], r32[esi]);
    r8[al] = memoryAGet(ds, r32[eax]);
    r32[eax] &= 0x000000ff;
  case 0x1e3cfc: // 0160:1e3cfc
    if (r32[eax] == 0x0000001a)
        { pc = 0x1e3c61; break; }
    memoryASet(ds, r32[edx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[esp] + 0xc);
    r32[eax]++;
    r32[edx]++;
    memoryASet32(ds, r32[esp] + 0xc, r32[eax]);
    if (r32[edx] != r32[ebx])
        { pc = 0x1e3ca7; break; }
  case 0x1e3d15: // 0160:1e3d15
    r32[eax] = memoryAGet32(ds, r32[esp] + 0xc);
    r32[esi] = memoryAGet32(ds, r32[esp]);
    r32[edx] = 0;
    div32(r32[esi]);
  case 0x1e3d20: // 0160:1e3d20
    r32[esp] += 0x00000010;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3d27() // 0160:1e3d27 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
  case 0x1e3d28: // 0160:1e3d28
    if (r32[ebx])
        { pc = 0x1e3d30; break; }
  case 0x1e3d2c: // 0160:1e3d2c
    r32[eax] = 0;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e3d30: // 0160:1e3d30
    r8[cl] = memoryAGet(ds, r32[eax]);
    r8[ch] = memoryAGet(ds, r32[edx]);
    if (r8[cl] == r8[ch])
        { pc = 0x1e3d46; break; }
    r32[ebx] = 0;
    r32[eax] = 0;
    r8[bl] = r8[cl];
    r8[al] = r8[ch];
    r32[ebx] -= r32[eax];
    r32[eax] = r32[ebx];
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e3d46: // 0160:1e3d46
    if (!memoryAGet(ds, r32[eax]))
        { pc = 0x1e3d2c; break; }
    r32[eax]++;
    r32[edx]++;
    r32[ebx]--;
    { pc = 0x1e3d28; break; }
    return;
  }
}
function* sub_1e3d50() // 0160:1e3d50 +long
{
    yield* sub_1e561c();
}
function* sub_1e3d5a() // 0160:1e3d5a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32[eax])
        { pc = 0x1e58fc; break; }
    yield* sub_1e59bb();
    r32[eax] = 0;
    r32[esp] += 4; return;
    // gap 7058 bytes // gap 7058 bytes
  case 0x1e58fc: // 0160:1e58fc
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r8[ah] = memoryAGet(ds, r32[eax] + 0xd);
    r32[esi] = 0;
    if (!(r8[ah] & 0x10))
        { pc = 0x1e5969; break; }
    r8[bh] = memoryAGet(ds, r32[ecx] + 0xd);
    r8[bh] &= 0xef;
    r8[al] = memoryAGet(ds, r32[ecx] + 0xc);
    memoryASet(ds, r32[ecx] + 0xd, r8[bh]);
    if (!(r8[al] & 0x02))
        { pc = 0x1e59a8; break; }
    if (!memoryAGet32(ds, r32[ecx] + 0x8))
        { pc = 0x1e59a8; break; }
    r32[ebx] = memoryAGet32(ds, r32[ecx] + 0x4);
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0x8);
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1eaea4();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e594a; break; }
    r8[dl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[dl] |= 0x20;
    r32[esi] = r32[eax];
    memoryASet(ds, r32[ecx] + 0xc, r8[dl]);
    { pc = 0x1e59a8; break; }
  case 0x1e594a: // 0160:1e594a
    if (r32[eax] == memoryAGet32(ds, r32[ecx] + 0x4))
        { pc = 0x1e59a8; break; }
    r32[eax] = 0x0000000c;
    yield* sub_1e53d1();
    r8[ah] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[ah] |= 0x20;
    r32[esi] = 0xffffffff;
    memoryASet(ds, r32[ecx] + 0xc, r8[ah]);
    { pc = 0x1e59a8; break; }
  case 0x1e5969: // 0160:1e5969
    if (!memoryAGet32(ds, r32[ecx] + 0x8))
        { pc = 0x1e59a8; break; }
    r8[dl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[dl] &= 0xef;
    r8[dh] = memoryAGet(ds, r32[ecx] + 0xd);
    memoryASet(ds, r32[ecx] + 0xc, r8[dl]);
    if (r8[dh] & 0x20)
        { pc = 0x1e59a8; break; }
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x4);
    if (!r32[eax])
        { pc = 0x1e5998; break; }
    r32[edx] = r32[eax];
    r32[ebx] = 0x00000001;
    r32[edx] = -r32[edx];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e6986();
  case 0x1e5998: // 0160:1e5998
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e59a8; break; }
    r8[bl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[bl] |= 0x20;
    r32[esi] = r32[eax];
    memoryASet(ds, r32[ecx] + 0xc, r8[bl]);
  case 0x1e59a8: // 0160:1e59a8
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x8);
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[ecx], r32[eax]);
    r32[eax] = r32[esi];
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3d6a() // 0160:1e3d6a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = memoryAGet32(ds, r32[eax] + 0x8);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[ebx]);
    if (!r32[edx])
        { pc = 0x1e3d80; break; }
    r32[ebx]++;
    memoryASet32(ds, r32[eax] + 0x8, r32[ebx]);
    r32[eax] = r32[edx];
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e3d80: // 0160:1e3d80
    r8[bl] = memoryAGet(ds, r32[eax] + 0x10);
    r8[bl] |= 0x02;
    r32[edx] = 0xffffffff;
    memoryASet(ds, r32[eax] + 0x10, r8[bl]);
    r32[eax] = r32[edx];
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3d93() // 0160:1e3d93 +long
{
    r32[esp] -= 4;
    memoryASet32(ds, r32[edx] + 0x8, memoryAGet32(ds, r32[edx] + 0x8) - 1);
    r32[esp] += 4;
}
function* sub_1e3d97() // 0160:1e3d97 +long
{
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esp] -= 0x00000014;
    r32[ecx] = 0x001e3d6a;
    r32[esi] = 0x001e3d93;
    memoryASet32(ds, r32[esp] + 0x8, r32[eax]);
    r32[eax] = r32[esp];
    memoryASet32(ds, r32[esp], r32[ecx]);
    memoryASet32(ds, r32[esp] + 0x4, r32[esi]);
    yield* sub_1e59ef();
    r32[esp] += 0x00000014;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
}
function* sub_1e3dbe() // 0160:1e3dbe +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[esp] -= 0x00000004;
    r32[ebx] = r32[esp] + 24;
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x10);
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x14);
    memoryASet32(ds, r32[esp], r32[ebx]);
    r32[ebx] = r32[esp];
    yield* sub_1e3d97();
    r32[esp] += 0x00000004;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e3de0() // 0160:1e3de0 +long
{
    r32[esp] -= 4;
    push32(r32[eax]);
    push32(r32[ecx]);
    r8[dh] = r8[dl];
    r32[edx] <<= 8;
    r8[dl] = r8[dh];
    r32[edx] <<= 8;
    r8[dl] = r8[dh];
    r32[ecx] = r32[ebx];
    yield* sub_1e6540();
    r32[ecx] = pop32();
    r32[eax] = pop32();
    r32[esp] += 4;
}
function* sub_1e3df8() // 0160:1e3df8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[ebp]);
    r32[ebx] = r32[eax];
    r32[ecx] = memoryAGet32(ds, 0x20a4e4);
    { pc = 0x1e3e11; break; }
  case 0x1e3e06: // 0160:1e3e06
    if (r32[ecx] > r32[ebx])
        { pc = 0x1e3e0e; break; }
    if (r32[ebx] < r32[edx])
        { pc = 0x1e3e18; break; }
  case 0x1e3e0e: // 0160:1e3e0e
    r32[ecx] = memoryAGet32(ds, r32[ecx] + 0x8);
  case 0x1e3e11: // 0160:1e3e11
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0x8);
    if (r32[edx])
        { pc = 0x1e3e06; break; }
  case 0x1e3e18: // 0160:1e3e18
    r32[eax] = 0x0020a4e4;
    r32[edx] = ds;
    r32[edx] &= 0x0000ffff;
    r32[eax] = r32[ebx];
    r32[ebx] = r32[ecx];
    yield* sub_1e4578();
    if (r32[ecx] == memoryAGet32(ds, 0x20a4e8))
        { pc = 0x1e3e49; break; }
    r32[ebp] = memoryAGet32(ds, 0x20a4ec);
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0x14);
    if (r32[edx] <= r32[ebp])
        { pc = 0x1e3e49; break; }
    memoryASet32(ds, 0x20a4ec, r32[edx]);
  case 0x1e3e49: // 0160:1e3e49
    r8[ah] = 0;
    memoryASet(ds, 0x3164cd, r8[ah]);
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3e56() // 0160:1e3e56 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[esp] -= 0x00000004;
    r32[edx] = r32[eax];
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    r32[ebx] = 0;
    yield* sub_1e65e3();
    memoryASet(ds, r32[esp], r8[al]);
    if (r8[al] == 0x72)
        { pc = 0x1e3e89; break; }
    if (r8[al] == 0x77)
        { pc = 0x1e3e89; break; }
    if (r8[al] == 0x61)
        { pc = 0x1e3e89; break; }
    r32[eax] = 0x00000009;
    yield* sub_1e53d1();
    r32[eax] = 0;
    { pc = 0x1e3f03; break; }
  case 0x1e3e89: // 0160:1e3e89
    r32[eax] = r32[ebx];
    r8[cl] = memoryAGet(ds, r32[edx] + 0x1);
    r8[al] |= 0x03;
    if (r8[cl] != 0x2b)
        { pc = 0x1e3eb6; break; }
    r32[ebx] = r32[eax];
    r8[cl] = memoryAGet(ds, r32[edx] + 0x2);
    r8[al] |= 0x40;
    if (r8[cl] == 0x62)
        { pc = 0x1e3eb2; break; }
    if (r8[cl] == 0x74)
        { pc = 0x1e3ee9; break; }
    flags.zero = memoryAGet32(ds, 0x20a719) == 0x00000200;
  case 0x1e3eb0: // 0160:1e3eb0
    if (!flags.zero)
        { pc = 0x1e3ee9; break; }
  case 0x1e3eb2: // 0160:1e3eb2
    r32[ebx] = r32[eax];
    { pc = 0x1e3ee9; break; }
  case 0x1e3eb6: // 0160:1e3eb6
    r32[ecx] = r32[ebx];
    r8[cl] |= 0x40;
    if (memoryAGet(ds, r32[edx] + 0x1) != 0x62)
        { pc = 0x1e3ecf; break; }
    r8[al] = memoryAGet(ds, r32[edx] + 0x2);
    r32[ebx] = r32[ecx];
    if (r8[al] != 0x2b)
        { pc = 0x1e3ee9; break; }
    r8[cl] |= 0x03;
    { pc = 0x1e3ee7; break; }
  case 0x1e3ecf: // 0160:1e3ecf
    if (memoryAGet(ds, r32[edx] + 0x1) != 0x74)
        { pc = 0x1e3edb; break; }
    flags.zero = memoryAGet(ds, r32[edx] + 0x2) == 0x2b;
    { pc = 0x1e3eb0; break; }
  case 0x1e3edb: // 0160:1e3edb
    if (memoryAGet32(ds, 0x20a719) != 0x00000200)
        { pc = 0x1e3ee9; break; }
  case 0x1e3ee7: // 0160:1e3ee7
    r32[ebx] = r32[ecx];
  case 0x1e3ee9: // 0160:1e3ee9
    r8[al] = memoryAGet(ds, r32[esp]);
    if (r8[al] != 0x77)
        { pc = 0x1e3ef5; break; }
    r8[bl] |= 0x02;
    { pc = 0x1e3f01; break; }
  case 0x1e3ef5: // 0160:1e3ef5
    if (r8[al] != 0x61)
        { pc = 0x1e3efe; break; }
    r8[bl] |= 0x82;
    { pc = 0x1e3f01; break; }
  case 0x1e3efe: // 0160:1e3efe
    r8[bl] |= 0x01;
  case 0x1e3f01: // 0160:1e3f01
    r32[eax] = r32[ebx];
  case 0x1e3f03: // 0160:1e3f03
    r32[esp] += 0x00000004;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3f0a() // 0160:1e3f0a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = r32[eax];
    memoryASet(ds, r32[ecx] + 0xc, memoryAGet(ds, r32[ecx] + 0xc) & 0xfc);
    r32[eax] = r32[edx];
    yield* sub_1e3e56();
    r32[edi] = memoryAGet32(ds, r32[ecx] + 0xc);
    r32[edi] |= r32[eax];
    r32[eax] = 0;
    memoryASet32(ds, r32[ecx] + 0xc, r32[edi]);
    r8[al] = memoryAGet(ds, r32[edx]);
    yield* sub_1e65e3();
    r8[dl] = r8[al];
    if (r8[al] != 0x72)
        { pc = 0x1e3f51; break; }
    r8[dh] = memoryAGet(ds, r32[ecx] + 0xc);
    r32[eax] = 0;
    if (!(r8[dh] & 0x02))
        { pc = 0x1e3f3f; break; }
    r32[eax] = 0x00000002;
  case 0x1e3f3f: // 0160:1e3f3f
    if (!(memoryAGet(ds, r32[ecx] + 0xc) & 0x40))
        { pc = 0x1e3f4a; break; }
    r8[ah] |= 0x02;
    { pc = 0x1e3f4d; break; }
  case 0x1e3f4a: // 0160:1e3f4a
    r8[ah] |= 0x01;
  case 0x1e3f4d: // 0160:1e3f4d
    push32(0x00000000);
    { pc = 0x1e3f7e; break; }
  case 0x1e3f51: // 0160:1e3f51
    r8[al] = memoryAGet(ds, r32[ecx] + 0xc) & 0x01;
    r32[eax] &= 0x000000ff;
    r32[eax] += 0x00000021;
    if (r8[dl] != 0x61)
        { pc = 0x1e3f69; break; }
    r8[al] |= 0x10;
    { pc = 0x1e3f6b; break; }
  case 0x1e3f69: // 0160:1e3f69
    r8[al] |= 0x40;
  case 0x1e3f6b: // 0160:1e3f6b
    if (!(memoryAGet(ds, r32[ecx] + 0xc) & 0x40))
        { pc = 0x1e3f76; break; }
    r8[ah] |= 0x02;
    { pc = 0x1e3f79; break; }
  case 0x1e3f76: // 0160:1e3f76
    r8[ah] |= 0x01;
  case 0x1e3f79: // 0160:1e3f79
    push32(0x00000180);
  case 0x1e3f7e: // 0160:1e3f7e
    push32(r32[ebx]);
    push32(r32[eax]);
    push32(r32[esi]);
    yield* sub_1e6615();
    r32[esp] += 0x00000010;
    memoryASet32(ds, r32[ecx] + 0x10, r32[eax]);
    if (memoryAGet32(ds, r32[ecx] + 0x10) != 0xffffffff)
        { pc = 0x1e3f9e; break; }
    r32[eax] = r32[ecx];
    yield* sub_1e68e7();
    r32[eax] = 0;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4; return;
  case 0x1e3f9e: // 0160:1e3f9e
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[ecx] + 0x8, 0x00000000);
    memoryASet32(ds, r32[ecx] + 0x14, 0x00000000);
    if (r8[dl] != 0x61)
        { pc = 0x1e3fc6; break; }
    r32[ebx] = 0x00000002;
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    yield* sub_1e4237();
  case 0x1e3fc6: // 0160:1e3fc6
    r32[eax] = r32[ecx];
    yield* sub_1e693e();
    r32[eax] = r32[ecx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3fd2() // 0160:1e3fd2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    r32[eax] = 0;
    yield* sub_1e683f();
    r32[ecx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e3fea; break; }
    r32[eax] = r32[esi];
    yield* sub_1e3f0a();
  case 0x1e3fea: // 0160:1e3fea
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e3fed() // 0160:1e3fed +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = 0;
    yield* sub_1e3fd2();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e4083() // 0160:1e4083 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x10);
    yield* sub_1e696f();
    r32[ebx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e40af; break; }
    r32[ecx] = memoryAGet32(ds, r32[edx] + 0x4);
    if (!r32[ecx])
        { pc = 0x1e40af; break; }
    if (!(memoryAGet(ds, r32[edx] + 0xd) & 0x10))
        { pc = 0x1e40ab; break; }
    r32[eax] = r32[ecx] + r32[ebx];
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e40ab: // 0160:1e40ab
    r32[eax] = r32[ebx];
    r32[eax] -= r32[ecx];
  case 0x1e40af: // 0160:1e40af
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e40b3() // 0160:1e40b3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x3164d0);
  case 0x1e40bc: // 0160:1e40bc
    if (r32[eax])
        { pc = 0x1e40c8; break; }
    r32[eax] = 0xffffffff;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e40c8: // 0160:1e40c8
    r32[ebx] = memoryAGet32(ds, r32[eax] + 0x4);
    if (r32[edx] == r32[ebx])
        { pc = 0x1e40d3; break; }
    r32[eax] = memoryAGet32(ds, r32[eax]);
    { pc = 0x1e40bc; break; }
  case 0x1e40d3: // 0160:1e40d3
    r32[edx] = 0x00000001;
    r32[eax] = r32[ebx];
    yield* sub_1e40e2();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e40e2() // 0160:1e40e2 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[eax];
    yield* sub_1e416c();
    r32[edx] = r32[eax];
    r32[eax] = r32[ebx];
    yield* sub_1e68e7();
    r32[eax] = r32[edx];
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e40f7() // 0160:1e40f7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] += 0x00000030;
    if (r32s[eax] <= signed32(0x00000039))
        { pc = 0x1e4102; break; }
    r32[eax] += 0x00000027;
  case 0x1e4102: // 0160:1e4102
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e4103() // 0160:1e4103 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ecx] = r32[eax];
    r32[edi] = r32[edx];
    yield* sub_1e6980();
    r32[edx] = 0x00000004;
    r32[ebx] = r32[eax];
    r32[esi] = r32[ecx];
    memoryASet(ds, r32[ecx], 0x74);
    r32[edx] += r32[ecx];
  case 0x1e411e: // 0160:1e411e
    r32[eax] = r32[ebx];
    r32[eax] &= 0x0000000f;
    yield* sub_1e40f7();
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]--;
    r32[ebx] >>>= 4;
    if (r32[edx] != r32[esi])
        { pc = 0x1e411e; break; }
    r32[eax] = r32[edi];
    r32[eax] = sar32(r32[eax], 0x04);
    r32[eax] &= 0x0000000f;
    memoryASet(ds, r32[ecx] + 0x5, 0x5f);
    yield* sub_1e40f7();
    memoryASet(ds, r32[ecx] + 0x6, r8[al]);
    r32[eax] = r32[edi];
    r32[eax] &= 0x0000000f;
    yield* sub_1e40f7();
    memoryASet(ds, r32[ecx] + 0x8, 0x2e);
    memoryASet(ds, r32[ecx] + 0x9, 0x74);
    memoryASet(ds, r32[ecx] + 0xa, 0x6d);
    memoryASet(ds, r32[ecx] + 0xb, 0x70);
    memoryASet(ds, r32[ecx] + 0xc, 0x00);
    memoryASet(ds, r32[ecx] + 0x7, r8[al]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e416c() // 0160:1e416c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esp] -= 0x00000010;
    r32[ecx] = r32[eax];
    r32[edi] = r32[edx];
    if (memoryAGet32(ds, r32[eax] + 0xc))
        { pc = 0x1e4184; break; }
    r32[esi] = 0xffffffff;
    { pc = 0x1e41eb; break; }
  case 0x1e4184: // 0160:1e4184
    r8[ah] = memoryAGet(ds, r32[eax] + 0xd);
    r32[esi] = 0;
    if (!(r8[ah] & 0x10))
        { pc = 0x1e4197; break; }
    r32[eax] = r32[ecx];
    yield* sub_1e58fc();
    r32[esi] = r32[eax];
  case 0x1e4197: // 0160:1e4197
    r32[eax] = r32[ecx];
    yield* sub_1e4083();
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e41af; break; }
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    r32[ebx] = 0;
    yield* sub_1e6986();
  case 0x1e41af: // 0160:1e41af
    if (!r32[edi])
        { pc = 0x1e41bd; break; }
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e69c7();
    r32[esi] |= r32[eax];
  case 0x1e41bd: // 0160:1e41bd
    if (!(memoryAGet(ds, r32[ecx] + 0xc) & 0x08))
        { pc = 0x1e41d2; break; }
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x8);
    yield* sub_1e3df8();
    memoryASet32(ds, r32[ecx] + 0x8, 0x00000000);
  case 0x1e41d2: // 0160:1e41d2
    if (!(memoryAGet(ds, r32[ecx] + 0xd) & 0x08))
        { pc = 0x1e41eb; break; }
    r32[edx] = 0;
    r32[eax] = r32[esp];
    r8[dl] = memoryAGet(ds, r32[ecx] + 0x19);
    yield* sub_1e4103();
    r32[eax] = r32[esp];
    yield* sub_1e69f9();
  case 0x1e41eb: // 0160:1e41eb
    r32[eax] = r32[esi];
    r32[esp] += 0x00000010;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e41f5() // 0160:1e41f5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    memoryASet(ds, r32[edx] + 0xc, memoryAGet(ds, r32[edx] + 0xc) & 0xef);
    if (r32s[eax] > signed32(memoryAGet32(ds, r32[edx] + 0x4)))
        { pc = 0x1e4221; break; }
    r32[ebx] = memoryAGet32(ds, r32[edx] + 0x8);
    r32[ecx] = memoryAGet32(ds, r32[edx]);
    r32[ebx] -= r32[ecx];
    if (r32s[eax] < r32s[ebx])
        { pc = 0x1e4221; break; }
    r32[edi] = memoryAGet32(ds, r32[edx] + 0x4);
    r32[esi] = r32[ecx] + r32[eax];
    r32[edi] -= r32[eax];
    memoryASet32(ds, r32[edx], r32[esi]);
    r32[eax] = 0;
    memoryASet32(ds, r32[edx] + 0x4, r32[edi]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e4221: // 0160:1e4221
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x8);
    memoryASet32(ds, r32[edx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[eax] = 0x00000001;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4237() // 0160:1e4237 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[ecx] = r32[eax];
    r32[esi] = r32[edx];
    if (!(memoryAGet(ds, r32[eax] + 0xc) & 0x06))
        { pc = 0x1e429f; break; }
    if (!(memoryAGet(ds, r32[ecx] + 0xd) & 0x10))
        { pc = 0x1e4270; break; }
    r32[eax] = r32[ecx];
    yield* sub_1e58fc();
    if (!r32[eax])
        { pc = 0x1e4284; break; }
    if (r32[ebx])
        { pc = 0x1e4267; break; }
    if (r32s[esi] >= 0)
        { pc = 0x1e4267; break; }
  case 0x1e425d: // 0160:1e425d
    r32[eax] = 0x00000009;
    yield* sub_1e53d1();
  case 0x1e4267: // 0160:1e4267
    r32[eax] = 0xffffffff;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e4270: // 0160:1e4270
    if (r32[ebx] != 0x00000001)
        { pc = 0x1e4278; break; }
    r32[esi] -= memoryAGet32(ds, r32[ecx] + 0x4);
  case 0x1e4278: // 0160:1e4278
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x8);
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[ecx], r32[eax]);
  case 0x1e4284: // 0160:1e4284
    memoryASet(ds, r32[ecx] + 0xc, memoryAGet(ds, r32[ecx] + 0xc) & 0xeb);
    r32[edx] = r32[esi];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e6986();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e432d; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e429f: // 0160:1e429f
    if (r32[ebx] < 0x00000001)
        { pc = 0x1e42ad; break; }
    if (r32[ebx] <= 0x00000001)
        { pc = 0x1e42b3; break; }
    if (r32[ebx] == 0x00000002)
        { pc = 0x1e4309; break; }
    { pc = 0x1e425d; break; }
  case 0x1e42ad: // 0160:1e42ad
    if (!r32[ebx])
        { pc = 0x1e42d8; break; }
    { pc = 0x1e425d; break; }
  case 0x1e42b3: // 0160:1e42b3
    r32[eax] = r32[edx];
    r32[edx] = r32[ecx];
    r32[edi] = memoryAGet32(ds, r32[ecx] + 0x4);
    yield* sub_1e41f5();
    if (!r32[eax])
        { pc = 0x1e432d; break; }
    r32[edx] = r32[esi];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    r32[edx] -= r32[edi];
    yield* sub_1e6986();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e432d; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e42d8: // 0160:1e42d8
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e696f();
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0x4);
    r32[edi] = r32[esi];
    r32[eax] -= r32[edx];
    r32[edi] -= r32[eax];
    r32[edx] = r32[ecx];
    r32[eax] = r32[edi];
    yield* sub_1e41f5();
    if (!r32[eax])
        { pc = 0x1e432d; break; }
    r32[edx] = r32[esi];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e6986();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e432d; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e4309: // 0160:1e4309
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x8);
    r8[dl] = memoryAGet(ds, r32[ecx] + 0xc);
    memoryASet32(ds, r32[ecx], r32[eax]);
    r8[dl] &= 0xef;
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    memoryASet(ds, r32[ecx] + 0xc, r8[dl]);
    r32[edx] = r32[esi];
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000000);
    yield* sub_1e6986();
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e432f; break; }
  case 0x1e432d: // 0160:1e432d
    r32[eax] = 0;
  case 0x1e432f: // 0160:1e432f
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4340() // 0160:1e4340 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[eax];
    if (r32[eax] == r32[edx])
        { pc = 0x1e43b4; break; }
  case 0x1e4348: // 0160:1e4348
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    r32[ecx] = memoryAGet32(ds, r32[edx]);
    if (r32[ecx] != r32[eax])
        { pc = 0x1e43b9; break; }
    r32[ecx] = ~r32[ecx];
    r32[eax] += 0xfefefeff;
    r32[eax] &= r32[ecx];
    r32[eax] &= 0x80808080;
    if (r32[eax])
        { pc = 0x1e43b4; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[ecx] = memoryAGet32(ds, r32[edx] + 0x4);
    if (r32[ecx] != r32[eax])
        { pc = 0x1e43b9; break; }
    r32[ecx] = ~r32[ecx];
    r32[eax] += 0xfefefeff;
    r32[eax] &= r32[ecx];
    r32[eax] &= 0x80808080;
    if (r32[eax])
        { pc = 0x1e43b4; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x8);
    r32[ecx] = memoryAGet32(ds, r32[edx] + 0x8);
    if (r32[ecx] != r32[eax])
        { pc = 0x1e43b9; break; }
    r32[ecx] = ~r32[ecx];
    r32[eax] += 0xfefefeff;
    r32[eax] &= r32[ecx];
    r32[eax] &= 0x80808080;
    if (r32[eax])
        { pc = 0x1e43b4; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0xc);
    r32[ecx] = memoryAGet32(ds, r32[edx] + 0xc);
    if (r32[ecx] != r32[eax])
        { pc = 0x1e43b9; break; }
    r32[ebx] += 0x00000010;
    r32[edx] += 0x00000010;
    r32[ecx] = ~r32[ecx];
    r32[eax] += 0xfefefeff;
    r32[eax] &= r32[ecx];
    r32[eax] &= 0x80808080;
    if (!r32[eax])
        { pc = 0x1e4348; break; }
  case 0x1e43b4: // 0160:1e43b4
    r32[eax] = 0;
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e43b9: // 0160:1e43b9
    flags.carry = r8[al] < r8[cl];
    if (r8[al] != r8[cl])
        { pc = 0x1e43da; break; }
    if (!r8[al])
        { pc = 0x1e43b4; break; }
    flags.carry = r8[ah] < r8[ch];
    if (r8[ah] != r8[ch])
        { pc = 0x1e43da; break; }
    if (!r8[ah])
        { pc = 0x1e43b4; break; }
    r32[eax] >>>= 16;
    r32[ecx] >>>= 16;
    flags.carry = r8[al] < r8[cl];
    if (r8[al] != r8[cl])
        { pc = 0x1e43da; break; }
    if (!r8[al])
        { pc = 0x1e43b4; break; }
    flags.carry = r8[ah] < r8[ch];
  case 0x1e43da: // 0160:1e43da
    r32[eax] = -flags.carry;
    r8[al] |= 0x01;
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e43e1() // 0160:1e43e1 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[eax];
    r32[eax] = r32[edx];
    r32[edx] = memoryAGet32(ds, r32[ebx]);
    yield* sub_1e69fe();
    memoryASet32(ds, r32[ebx] + 0x10, memoryAGet32(ds, r32[ebx] + 0x10) + 1);
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e43f2() // 0160:1e43f2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esi] = r32[eax];
    r32[ebp] = memoryAGet32(ds, r32[eax] + 0xc);
    r8[ah] = memoryAGet(ds, r32[eax] + 0xc);
    r32[ecx] = memoryAGet32(ds, r32[esi] + 0x8);
    r8[ah] &= 0xcf;
    r32[ebp] &= 0x00000030;
    memoryASet(ds, r32[esi] + 0xc, r8[ah]);
    if (r32[ecx])
        { pc = 0x1e4415; break; }
    r32[eax] = r32[esi];
    yield* sub_1e5407();
  case 0x1e4415: // 0160:1e4415
    r8[cl] = memoryAGet(ds, r32[esi] + 0xd);
    r32[edi] = 0;
    if (!(r8[cl] & 0x04))
        { pc = 0x1e4433; break; }
    r8[ch] = r8[cl];
    r8[ch] &= 0xfa;
    r8[al] = r8[ch];
    memoryASet(ds, r32[esi] + 0xd, r8[ch]);
    r8[al] |= 0x01;
    r32[edi] = 0x00000001;
    memoryASet(ds, r32[esi] + 0xd, r8[al]);
  case 0x1e4433: // 0160:1e4433
    r32[ecx] = 0x001e43e1;
    r32[eax] = r32[esi];
    yield* sub_1e6aa2();
    r32[edx] = r32[eax];
    if (!r32[edi])
        { pc = 0x1e445d; break; }
    r8[ah] = memoryAGet(ds, r32[esi] + 0xd);
    r8[ah] &= 0xfa;
    r8[bl] = r8[ah];
    memoryASet(ds, r32[esi] + 0xd, r8[ah]);
    r8[bl] |= 0x04;
    r32[eax] = r32[esi];
    memoryASet(ds, r32[esi] + 0xd, r8[bl]);
    yield* sub_1e58fc();
  case 0x1e445d: // 0160:1e445d
    if (!(memoryAGet(ds, r32[esi] + 0xc) & 0x20))
        { pc = 0x1e4468; break; }
    r32[edx] = 0xffffffff;
  case 0x1e4468: // 0160:1e4468
    r32[edi] = memoryAGet32(ds, r32[esi] + 0xc);
    r32[edi] |= r32[ebp];
    r32[eax] = r32[edx];
    memoryASet32(ds, r32[esi] + 0xc, r32[edi]);
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4478() // 0160:1e4478 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[esp] -= 0x00000004;
  case 0x1e447c: // 0160:1e447c
    if (r32[ebx])
        { pc = 0x1e4487; break; }
  case 0x1e4480: // 0160:1e4480
    r32[eax] = 0;
    r32[esp] += 0x00000004;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e4487: // 0160:1e4487
    r8[ch] = memoryAGet(ds, r32[edx]);
    r8[cl] = memoryAGet(ds, r32[eax]);
    memoryASet(ds, r32[esp], r8[ch]);
    if (r8[cl] < 0x41)
        { pc = 0x1e449b; break; }
    if (r8[cl] > 0x5a)
        { pc = 0x1e449b; break; }
    r8[cl] += 0x20;
  case 0x1e449b: // 0160:1e449b
    r8[ch] = memoryAGet(ds, r32[esp]);
    if (r8[ch] < 0x41)
        { pc = 0x1e44ae; break; }
    if (r8[ch] > 0x5a)
        { pc = 0x1e44ae; break; }
    r8[ch] += 0x20;
    memoryASet(ds, r32[esp], r8[ch]);
  case 0x1e44ae: // 0160:1e44ae
    r8[ch] = memoryAGet(ds, r32[esp]);
    if (r8[cl] == r8[ch])
        { pc = 0x1e44c6; break; }
    r32[edx] = 0;
    r32[eax] = 0;
    r8[dl] = r8[cl];
    r8[al] = r8[ch];
    r32[edx] -= r32[eax];
    r32[eax] = r32[edx];
    r32[esp] += 0x00000004;
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e44c6: // 0160:1e44c6
    if (!r8[ch])
        { pc = 0x1e4480; break; }
    r32[eax]++;
    r32[edx]++;
    r32[ebx]--;
    { pc = 0x1e447c; break; }
    return;
  }
}
function* sub_1e44d0() // 0160:1e44d0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ecx]);
    push(ds);
    ds = r32[edx];
    if (!r32[eax])
        { pc = 0x1e451f; break; }
    flags.carry = overflow32(r32[eax], 0x00000007);
    r32[eax] += 0x00000007;
    if (flags.carry)
        { pc = 0x1e451f; break; }
    r8[al] &= 0xfc;
    r32[edx] = 0x0000000c;
    flags.carry = r32[eax] < r32[edx];
    r32[eax] -= r32[edx];
    flags.carry = !flags.carry;
    r32[ecx] = -flags.carry;
    r32[eax] &= r32[ecx];
    r32[eax] += r32[edx];
    if (r32[eax] > memoryAGet32(ds, r32[ebx] + 0x14))
        { pc = 0x1e451f; break; }
    r32[esi] = memoryAGet32(ds, r32[ebx] + 0xc);
    r32[edi] = memoryAGet32(ds, r32[ebx] + 0x10);
    if (r32[eax] > r32[edi])
        { pc = 0x1e4503; break; }
    r32[esi] = memoryAGet32(ds, r32[ebx] + 0x28);
    r32[edi] = 0;
  case 0x1e4503: // 0160:1e4503
    r32[edx] = memoryAGet32(ds, r32[esi]);
    if (r32[eax] <= r32[edx])
        { pc = 0x1e4523; break; }
    flags.carry = r32[edi] < r32[edx];
    r32[edi] -= r32[edx];
    flags.carry = !flags.carry;
    r32[ecx] = -flags.carry;
    r32[edi] &= r32[ecx];
    r32[edi] += r32[edx];
    r32[edx] = r32[ebx] + 32;
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x8);
    if (r32[esi] != r32[edx])
        { pc = 0x1e4503; break; }
    memoryASet32(ds, r32[ebx] + 0x14, r32[edi]);
  case 0x1e451f: // 0160:1e451f
    r32[eax] = 0;
    { pc = 0x1e456e; break; }
  case 0x1e4523: // 0160:1e4523
    r32[edx] -= r32[eax];
    memoryASet32(ds, r32[ebx] + 0x10, r32[edi]);
    memoryASet32(ds, r32[ebx] + 0x18, memoryAGet32(ds, r32[ebx] + 0x18) + 1);
    r32[ecx] = memoryAGet32(ds, r32[esi] + 0x8);
    if (r32[edx] < 0x0000000c)
        { pc = 0x1e4551; break; }
    r32[edi] = r32[esi];
    r32[edi] += r32[eax];
    memoryASet32(ds, r32[ebx] + 0xc, r32[edi]);
    memoryASet32(ds, r32[edi], r32[edx]);
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[edi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[edi] + 0x8, r32[ecx]);
    memoryASet32(ds, r32[ebx] + 0x8, r32[edi]);
    r32[ebx] = r32[ecx];
    memoryASet32(ds, r32[ebx] + 0x4, r32[edi]);
    { pc = 0x1e4566; break; }
  case 0x1e4551: // 0160:1e4551
    memoryASet32(ds, r32[ebx] + 0x1c, memoryAGet32(ds, r32[ebx] + 0x1c) - 1);
    r32[eax] = r32[esi];
    r32[edi] = r32[ecx];
    r32[esi] = memoryAGet32(ds, r32[esi] + 0x4);
    memoryASet32(ds, r32[esi] + 0x8, r32[edi]);
    memoryASet32(ds, r32[edi] + 0x4, r32[esi]);
    memoryASet32(ds, r32[ebx] + 0xc, r32[esi]);
    r32[esi] = r32[eax];
  case 0x1e4566: // 0160:1e4566
    memoryASet32(ds, r32[esi], memoryAGet32(ds, r32[esi]) | 0x00000001);
    r32[eax] = r32[esi];
    r32[eax] += 0x00000004;
  case 0x1e456e: // 0160:1e456e
    ds = pop();
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4578() // 0160:1e4578 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e4578; break; }
  case 0x1e4573: // 0160:1e4573
    { pc = 0x1e467e; break; }
  case 0x1e4578: // 0160:1e4578
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ecx]);
    push(ds);
    ds = r32[edx];
    if (!r32[eax])
        { pc = 0x1e4573; break; }
    r32[esi] = r32[eax];
    r32[esi] -= 0x00000004;
    r32[eax] = memoryAGet32(ds, r32[esi]);
    if (!(r8[al] & 0x01))
        { pc = 0x1e4573; break; }
    r8[al] &= 0xfe;
    r32[edi] = r32[esi];
    r32[edi] += r32[eax];
    if (memoryAGet32(ds, r32[edi]) & 0x00000001)
        { pc = 0x1e45ba; break; }
    if (r32[edi] != memoryAGet32(ds, r32[ebx] + 0xc))
        { pc = 0x1e45a3; break; }
    memoryASet32(ds, r32[ebx] + 0xc, r32[esi]);
  case 0x1e45a3: // 0160:1e45a3
    r32[eax] += memoryAGet32(ds, r32[edi]);
    memoryASet32(ds, r32[esi], r32[eax]);
    push32(r32[ebx]);
    r32[ebx] = memoryAGet32(ds, r32[edi] + 0x4);
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x8);
    memoryASet32(ds, r32[ebx] + 0x8, r32[edi]);
    memoryASet32(ds, r32[edi] + 0x4, r32[ebx]);
    r32[ebx] = pop32();
    memoryASet32(ds, r32[ebx] + 0x1c, memoryAGet32(ds, r32[ebx] + 0x1c) - 1);
    { pc = 0x1e4636; break; }
  case 0x1e45ba: // 0160:1e45ba
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[edi] = memoryAGet32(ds, r32[ebx] + 0xc);
    if (r32[esi] >= r32[edi])
        { pc = 0x1e45d1; break; }
    if (r32[esi] > memoryAGet32(ds, r32[edi] + 0x4))
        { pc = 0x1e4636; break; }
    r32[edi] = memoryAGet32(ds, r32[ebx] + 0x28);
    if (r32[esi] < r32[edi])
        { pc = 0x1e4636; break; }
    { pc = 0x1e45e0; break; }
  case 0x1e45d1: // 0160:1e45d1
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x8);
    if (r32[esi] < r32[edi])
        { pc = 0x1e4636; break; }
    r32[edi] = r32[ebx] + 32;
    if (r32[esi] > memoryAGet32(ds, r32[ebx] + 0x24))
        { pc = 0x1e4636; break; }
  case 0x1e45e0: // 0160:1e45e0
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x18);
    r32[ecx] = memoryAGet32(ds, r32[ebx] + 0x1c);
    r32[ecx]++;
    div32(r32[ecx]);
    r32[ecx]--;
    if (r32[eax] >= r32[ecx])
        { pc = 0x1e4615; break; }
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x18);
    r32[edx] -= r32[ecx];
    r32[eax] += r32[eax];
    if (r32[edx] > r32[ecx])
        { pc = 0x1e45fd; break; }
    r32[eax] = 0;
  case 0x1e45fd: // 0160:1e45fd
    r32[edi] = r32[esi];
    r32[edi] += memoryAGet32(ds, r32[esi]);
  case 0x1e4601: // 0160:1e4601
    r32[edx] = memoryAGet32(ds, r32[edi]);
    if (!(r8[dl] & 0x01))
        { pc = 0x1e4636; break; }
    if (r32[edx] == 0xffffffff)
        { pc = 0x1e4615; break; }
    r8[dl] &= 0xfe;
    r32[edi] += r32[edx];
    r32[eax]--;
    if (r32[eax])
        { pc = 0x1e4601; break; }
  case 0x1e4615: // 0160:1e4615
    r32[edi] = memoryAGet32(ds, r32[ebx] + 0xc);
    if (r32[esi] >= r32[edi])
        { pc = 0x1e461f; break; }
    r32[edi] = memoryAGet32(ds, r32[ebx] + 0x28);
  case 0x1e461f: // 0160:1e461f
    if (r32[esi] < r32[edi])
        { pc = 0x1e4636; break; }
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x8);
    if (r32[esi] < r32[edi])
        { pc = 0x1e4636; break; }
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x8);
    if (r32[esi] < r32[edi])
        { pc = 0x1e4636; break; }
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x8);
    { pc = 0x1e461f; break; }
  case 0x1e4636: // 0160:1e4636
    r32[edx] = memoryAGet32(ds, r32[edi] + 0x4);
    r32[ecx] = memoryAGet32(ds, r32[esi]);
    r32[etx] = r32[edx]; r32[edx] = r32[edi]; r32[edi] = r32[etx];
    r32[eax] = r32[edi];
    r32[eax] += memoryAGet32(ds, r32[edi]);
    if (r32[eax] != r32[esi])
        { pc = 0x1e4655; break; }
    r32[ecx] += memoryAGet32(ds, r32[edi]);
    memoryASet32(ds, r32[edi], r32[ecx]);
    if (r32[esi] != memoryAGet32(ds, r32[ebx] + 0xc))
        { pc = 0x1e4651; break; }
    memoryASet32(ds, r32[ebx] + 0xc, r32[edi]);
  case 0x1e4651: // 0160:1e4651
    r32[esi] = r32[edi];
    { pc = 0x1e4666; break; }
  case 0x1e4655: // 0160:1e4655
    memoryASet32(ds, r32[ebx] + 0x1c, memoryAGet32(ds, r32[ebx] + 0x1c) + 1);
    memoryASet32(ds, r32[esi] + 0x8, r32[edx]);
    memoryASet32(ds, r32[esi] + 0x4, r32[edi]);
    memoryASet32(ds, r32[edi] + 0x8, r32[esi]);
    r32[edi] = r32[edx];
    memoryASet32(ds, r32[edi] + 0x4, r32[esi]);
  case 0x1e4666: // 0160:1e4666
    memoryASet32(ds, r32[ebx] + 0x18, memoryAGet32(ds, r32[ebx] + 0x18) - 1);
    if (r32[esi] >= memoryAGet32(ds, r32[ebx] + 0xc))
        { pc = 0x1e4676; break; }
    if (r32[ecx] <= memoryAGet32(ds, r32[ebx] + 0x10))
        { pc = 0x1e4676; break; }
    memoryASet32(ds, r32[ebx] + 0x10, r32[ecx]);
  case 0x1e4676: // 0160:1e4676
    if (r32[ecx] <= memoryAGet32(ds, r32[ebx] + 0x14))
        { pc = 0x1e467e; break; }
    memoryASet32(ds, r32[ebx] + 0x14, r32[ecx]);
  case 0x1e467e: // 0160:1e467e
    ds = pop();
    r32[ecx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4683() // 0160:1e4683 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x20a4e8);
    if (r32[eax] != r32[edx])
        { pc = 0x1e4698; break; }
    r32[edx] = memoryAGet32(ds, r32[edx] + 0x8);
    memoryASet32(ds, 0x20a4e8, r32[edx]);
  case 0x1e4698: // 0160:1e4698
    r32[ebx] = memoryAGet32(ds, 0x20a4e4);
    if (r32[eax] != r32[ebx])
        { pc = 0x1e46ab; break; }
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x8);
    memoryASet32(ds, 0x20a4e4, r32[edx]);
  case 0x1e46ab: // 0160:1e46ab
    r32[edx] = memoryAGet32(ds, r32[eax] + 0x4);
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x8);
    if (!r32[edx])
        { pc = 0x1e46b8; break; }
    memoryASet32(ds, r32[edx] + 0x8, r32[eax]);
  case 0x1e46b8: // 0160:1e46b8
    if (!r32[eax])
        { pc = 0x1e46bf; break; }
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
  case 0x1e46bf: // 0160:1e46bf
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e46c2() // 0160:1e46c2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[edx] = memoryAGet32(ds, 0x20a4e4);
  case 0x1e46cd: // 0160:1e46cd
    if (!r32[edx])
        { pc = 0x1e49b2; break; }
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x24);
    r32[eax] = memoryAGet32(ds, r32[eax]);
    r32[ebx] = memoryAGet32(ds, r32[edx]);
    r32[eax] += 0x0000002c;
    if (r32[eax] != r32[ebx])
        { pc = 0x1e471b; break; }
    r32[ebx] = r32[edx] - 8;
    r32[eax] = r32[edx];
    r32[ecx] = memoryAGet32(ds, r32[edx] + 0x8);
    yield* sub_1e4683();
    r32[edx] = r32[ecx];
    r32[ecx] = memoryAGet32(ds, r32[ebx] + 0x4);
    if (r32[ecx])
        { pc = 0x1e470b; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    r32[eax] >>>= 16;
    r16[di] = memoryAGet16(ds, r32[ebx]);
    r32[esi] = r32[eax];
    r8[ah] = 0x05;
    r8[al] = 0x02;
    interrupt(0x31);
    { pc = 0x1e46cd; break; }
  case 0x1e470b: // 0160:1e470b
    r32[eax] = r32[ecx];
    push(es);
    es = r32[eax];
    r8[ah] = 0x49;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    es = pop();
    { pc = 0x1e46cd; break; }
  case 0x1e471b: // 0160:1e471b
    r32[edx] = memoryAGet32(ds, r32[edx] + 0x8);
    { pc = 0x1e46cd; break; }
    // gap 658 bytes // gap 658 bytes
  case 0x1e49b2: // 0160:1e49b2
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4823() // 0160:1e4823 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x20a4e4);
    r32[ebx] = 0;
    { pc = 0x1e4839; break; }
  case 0x1e4830: // 0160:1e4830
    if (r32[edx] < r32[eax])
        { pc = 0x1e483d; break; }
    r32[ebx] = r32[eax];
    r32[eax] = memoryAGet32(ds, r32[eax] + 0x8);
  case 0x1e4839: // 0160:1e4839
    if (r32[eax])
        { pc = 0x1e4830; break; }
  case 0x1e483d: // 0160:1e483d
    memoryASet32(ds, r32[edx] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[edx] + 0x8, r32[eax]);
    if (!r32[ebx])
        { pc = 0x1e484c; break; }
    memoryASet32(ds, r32[ebx] + 0x8, r32[edx]);
    { pc = 0x1e4852; break; }
  case 0x1e484c: // 0160:1e484c
    memoryASet32(ds, 0x20a4e4, r32[edx]);
  case 0x1e4852: // 0160:1e4852
    if (!r32[eax])
        { pc = 0x1e4859; break; }
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
  case 0x1e4859: // 0160:1e4859
    r32[ebx] = r32[edx] + 32;
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[edx] += 0x0000002c;
    memoryASet32(ds, r32[edx] - 12, 0x00000000);
    memoryASet32(ds, r32[edx] - 28, 0x00000000);
    memoryASet32(ds, r32[edx] - 20, 0x00000000);
    memoryASet32(ds, r32[edx] - 16, 0x00000000);
    memoryASet32(ds, r32[edx] - 8, r32[ebx]);
    memoryASet32(ds, r32[edx] - 4, r32[ebx]);
    r32[eax] -= 0x0000002c;
    memoryASet32(ds, r32[edx] - 32, r32[ebx]);
    memoryASet32(ds, r32[edx], r32[eax]);
    memoryASet32(ds, r32[edx] + r32[eax], 0xffffffff);
    r32[eax] = r32[edx];
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4897() // 0160:1e4897 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = memoryAGet32(ds, 0x20a4e4);
    if (!r32[edx])
        { pc = 0x1e48e0; break; }
    r32[edx] = memoryAGet32(ds, r32[edx] + 0x24);
    r32[ebx] = memoryAGet32(ds, r32[edx]);
    r32[ebx] += r32[edx];
    r8[ah] = memoryAGet(ds, 0x20a75e);
    r32[ebx] += 0x00000004;
    if (r8[ah] < 0x02)
        { pc = 0x1e48d3; break; }
    if (r8[ah] > 0x08)
        { pc = 0x1e48d3; break; }
    if (memoryAGet(ds, 0x20a760))
        { pc = 0x1e48d3; break; }
    r32[eax] = 0;
    r32[eax] = ds;
    stop("disassembly failed at 0160:1e48ca (lsl eax, eax)");
    r32[eax]++;
    memoryASet32(ds, 0x20a730, r32[eax]);
  case 0x1e48d3: // 0160:1e48d3
    if (r32[ebx] != memoryAGet32(ds, 0x20a730))
        { pc = 0x1e48e0; break; }
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e48e0: // 0160:1e48e0
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e48e5() // 0160:1e48e5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[eax]);
    yield* sub_1e46c2();
    r32[eax] = memoryAGet32(ds, r32[esp]);
    r32[eax] >>>= 16;
    r32[ecx] = memoryAGet32(ds, r32[esp]);
    r32[ebx] = r32[eax];
    r8[ah] = 0x05;
    r8[al] = 0x01;
    interrupt(0x31);
    r32[eax] = -flags.carry;
    r32[eax]++;
    if (!r32[eax])
        { pc = 0x1e4916; break; }
    r16[ax] = r16[bx];
    r32[eax] <<= 16;
    r16[ax] = r16[cx];
    memoryASet16(ds, r32[eax], r16[di]);
    memoryASet16(ds, r32[eax] + 0x2, r16[si]);
  case 0x1e4916: // 0160:1e4916
    if (!r32[eax])
        { pc = 0x1e4933; break; }
    r32[ebx] = memoryAGet32(ds, r32[esp]);
    r32[edx] = r32[eax] + 8;
    r32[ebx] -= 0x00000008;
    memoryASet32(ds, r32[edx], r32[ebx]);
    memoryASet32(ds, r32[eax] + 0x4, 0x00000000);
    r32[eax] = r32[edx];
    { pc = 0x1e49af; break; }
  case 0x1e4933: // 0160:1e4933
    if (!(memoryAGet16(ds, 0x3164d6) & 0xfff0))
        { pc = 0x1e4948; break; }
    memoryASet32(ds, 0x3164d4, 0x000fffff);
  case 0x1e4948: // 0160:1e4948
    if (memoryAGet32(ds, r32[esp]) > 0x00010000)
        { pc = 0x1e49ad; break; }
    r32[ebx] = memoryAGet32(ds, 0x3164d4);
    r32[ebx] >>>= 4;
    r8[bl] |= 0x01;
    r8[ah] = 0x48;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    r32[edx] = r32[eax];
    if (r32s[eax] < 0)
        { pc = 0x1e49ad; break; }
    r32[ebx] = memoryAGet32(ds, r32[esp]);
    r32[ebx] >>>= 4;
    r8[ah] = 0x48;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    r32[esi] = r32[eax];
    r32[ebx] = r32[eax];
    r32[eax] = r32[edx];
    push(es);
    es = r32[eax];
    r8[ah] = 0x49;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    es = pop();
    if (r32s[esi] < 0)
        { pc = 0x1e49ad; break; }
    r8[ah] = 0x00;
    r8[al] = 0x06;
    interrupt(0x31);
    r32[eax] = r32[ecx];
    r32[eax] <<= 16;
    r16[ax] = r16[dx];
    r32[eax] += 0x00000008;
    r32[edx] = memoryAGet32(ds, r32[esp]);
    memoryASet32(ds, r32[eax] - 4, r32[esi]);
    r32[edx] -= 0x00000008;
    memoryASet32(ds, r32[eax], r32[edx]);
    { pc = 0x1e49af; break; }
  case 0x1e49ad: // 0160:1e49ad
    r32[eax] = 0;
  case 0x1e49af: // 0160:1e49af
    r32[esp] += 0x00000004;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e49b8() // 0160:1e49b8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e49b8; break; }
  case 0x1e49af: // 0160:1e49af
    r32[esp] += 0x00000004;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e49b8: // 0160:1e49b8
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[eax]);
    if (memoryAGet32(ds, 0x20a7bc))
        { pc = 0x1e49cb; break; }
  case 0x1e49c7: // 0160:1e49c7
    r32[eax] = 0;
    { pc = 0x1e49af; break; }
  case 0x1e49cb: // 0160:1e49cb
    if (memoryAGet32(ds, 0x20a730) == 0xfffffffe)
        { pc = 0x1e49c7; break; }
    r32[eax] = r32[esp];
    yield* sub_1e4bab();
    if (!r32[eax])
        { pc = 0x1e49af; break; }
    if (memoryAGet(ds, 0x20a75e) != 0x01)
        { pc = 0x1e49ff; break; }
    r32[eax] = memoryAGet32(ds, r32[esp]);
    yield* sub_1e48e5();
    r32[ebx] = r32[eax];
    r32[edx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e4a1a; break; }
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[esp], r32[eax]);
    { pc = 0x1e4a1a; break; }
  case 0x1e49ff: // 0160:1e49ff
    r32[ebx] = memoryAGet32(ds, r32[esp]);
    r32[eax] = 0x80004800;
    interrupt(0x21);
    r32[ebx] = -flags.carry;
    r32[ebx] = ~r32[ebx];
    r32[eax] &= r32[ebx];
    r32[ecx] = memoryAGet32(ds, r32[esp]);
    r32[ecx] -= 0x00000004;
    r32[edx] = r32[eax];
    memoryASet32(ds, r32[esp], r32[ecx]);
  case 0x1e4a1a: // 0160:1e4a1a
    if (!r32[edx])
        { pc = 0x1e49c7; break; }
    r32[eax] = memoryAGet32(ds, r32[esp]);
    r32[esi] = memoryAGet32(ds, r32[esp]);
    r32[eax] -= 0x00000004;
    if (r32[eax] > r32[esi])
        { pc = 0x1e49c7; break; }
    memoryASet32(ds, r32[esp], r32[eax]);
    if (r32[eax] < 0x00000038)
        { pc = 0x1e49c7; break; }
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[eax] = r32[edx];
    yield* sub_1e4823();
    r32[ebx] = r32[eax];
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[esp], r32[eax]);
    r8[al] |= 0x01;
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[edi] = memoryAGet32(ds, r32[edx] + 0x18);
    memoryASet32(ds, r32[edx] + 0x14, 0xffffffff);
    r32[edi]++;
    r32[eax] = r32[ebx] + 4;
    memoryASet32(ds, r32[edx] + 0x18, r32[edi]);
    yield* sub_1e3df8();
    r32[eax] = 0x00000001;
    { pc = 0x1e49af; break; }
    return;
  }
}
function* sub_1e4a67() // 0160:1e4a67 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[ebp]);
    push32(r32[eax]);
    if (memoryAGet(ds, 0x20a75e) != 0x01)
        { pc = 0x1e4a7f; break; }
    if (!memoryAGet(ds, 0x20a75f))
        { pc = 0x1e4a88; break; }
  case 0x1e4a7f: // 0160:1e4a7f
    if (memoryAGet(ds, 0x20a75e) != 0x09)
        { pc = 0x1e4a95; break; }
  case 0x1e4a88: // 0160:1e4a88
    r32[eax] = memoryAGet32(ds, r32[esp]);
    yield* sub_1e49b8();
    { pc = 0x1e4ba2; break; }
  case 0x1e4a95: // 0160:1e4a95
    if (memoryAGet32(ds, 0x20a7bc))
        { pc = 0x1e4aa5; break; }
  case 0x1e4a9e: // 0160:1e4a9e
    r32[eax] = 0;
    { pc = 0x1e4ba2; break; }
  case 0x1e4aa5: // 0160:1e4aa5
    if (memoryAGet32(ds, 0x20a730) == 0xfffffffe)
        { pc = 0x1e4a9e; break; }
    r32[eax] = r32[esp];
    yield* sub_1e4bab();
    if (!r32[eax])
        { pc = 0x1e4ba2; break; }
    r8[bl] = memoryAGet(ds, 0x20a75e);
    if (r8[bl] < 0x02)
        { pc = 0x1e4ae3; break; }
    if (r8[bl] > 0x08)
        { pc = 0x1e4ae3; break; }
    if (memoryAGet(ds, 0x20a760))
        { pc = 0x1e4ae3; break; }
    r32[eax] = 0;
    r32[eax] = ds;
    stop("disassembly failed at 0160:1e4ada (lsl eax, eax)");
    r32[eax]++;
    memoryASet32(ds, 0x20a730, r32[eax]);
  case 0x1e4ae3: // 0160:1e4ae3
    r32[edx] = memoryAGet32(ds, r32[esp]);
    r32[ecx] = memoryAGet32(ds, 0x20a730);
    r32[edx] += r32[ecx];
    if (r32[edx] >= r32[ecx])
        { pc = 0x1e4af7; break; }
    r32[edx] = 0xfffffffe;
  case 0x1e4af7: // 0160:1e4af7
    r32[eax] = r32[edx];
    yield* sub_1e763f();
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e4a9e; break; }
    r32[ebx] = r32[eax];
    if (r32[eax] > 0xfffffff8)
        { pc = 0x1e4a9e; break; }
    if (r32[edx] <= r32[eax])
        { pc = 0x1e4a9e; break; }
    r32[edx] -= r32[eax];
    r32[eax] = r32[edx] - 4;
    memoryASet32(ds, r32[esp], r32[edx]);
    if (r32[eax] > r32[edx])
        { pc = 0x1e4a9e; break; }
    r32[edx] = memoryAGet32(ds, 0x20a4e4);
    memoryASet32(ds, r32[esp], r32[eax]);
    { pc = 0x1e4b37; break; }
  case 0x1e4b25: // 0160:1e4b25
    r32[ebp] = memoryAGet32(ds, r32[edx] + 0x8);
    if (!r32[ebp])
        { pc = 0x1e4b3b; break; }
    if (r32[edx] > r32[ebx])
        { pc = 0x1e4b34; break; }
    if (r32[ebx] < r32[ebp])
        { pc = 0x1e4b3b; break; }
  case 0x1e4b34: // 0160:1e4b34
    r32[edx] = memoryAGet32(ds, r32[edx] + 0x8);
  case 0x1e4b37: // 0160:1e4b37
    if (r32[edx])
        { pc = 0x1e4b25; break; }
  case 0x1e4b3b: // 0160:1e4b3b
    if (!r32[edx])
        { pc = 0x1e4b65; break; }
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[ecx] = r32[ebx] - 4;
    r32[eax] += r32[edx];
    if (r32[ecx] != r32[eax])
        { pc = 0x1e4b65; break; }
    r32[esi] = memoryAGet32(ds, r32[esp]);
    r32[esi] += 0x00000004;
    memoryASet32(ds, r32[esp], r32[esi]);
    memoryASet32(ds, r32[edx], memoryAGet32(ds, r32[edx]) + r32[esi]);
    r32[ebp] = memoryAGet32(ds, r32[esp]);
    r32[ecx] = r32[eax] + r32[ebp];
    r32[ebx] = r32[eax];
    memoryASet32(ds, r32[ecx], 0xffffffff);
    { pc = 0x1e4b84; break; }
  case 0x1e4b65: // 0160:1e4b65
    if (memoryAGet32(ds, r32[esp]) < 0x00000038)
        { pc = 0x1e4a9e; break; }
    r32[eax] = memoryAGet32(ds, r32[esp]);
    memoryASet32(ds, r32[ebx], r32[eax]);
    r32[eax] = r32[ebx];
    r32[edx] = r32[ebx];
    yield* sub_1e4823();
    r32[ebx] = r32[eax];
    r32[eax] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[esp], r32[eax]);
  case 0x1e4b84: // 0160:1e4b84
    r32[eax] = memoryAGet32(ds, r32[esp]);
    r8[al] |= 0x01;
    memoryASet32(ds, r32[ebx], r32[eax]);
    memoryASet32(ds, r32[edx] + 0x18, memoryAGet32(ds, r32[edx] + 0x18) + 1);
    r32[eax] = r32[ebx] + 4;
    memoryASet32(ds, r32[edx] + 0x14, 0xffffffff);
    yield* sub_1e3df8();
    r32[eax] = 0x00000001;
  case 0x1e4ba2: // 0160:1e4ba2
    r32[esp] += 0x00000004;
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4bab() // 0160:1e4bab +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[ebx] = r32[eax];
    r32[edx] = memoryAGet32(ds, r32[eax]);
    r32[edx] += 0x00000003;
    r8[dl] &= 0xfc;
    if (r32[edx])
        { pc = 0x1e4bc2; break; }
  case 0x1e4bbc: // 0160:1e4bbc
    r32[eax] = 0;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e4bc2: // 0160:1e4bc2
    if (memoryAGet(ds, 0x20a75e) != 0x01)
        { pc = 0x1e4bd4; break; }
    if (!memoryAGet(ds, 0x20a75f))
        { pc = 0x1e4bdd; break; }
  case 0x1e4bd4: // 0160:1e4bd4
    if (memoryAGet(ds, 0x20a75e) != 0x09)
        { pc = 0x1e4be2; break; }
  case 0x1e4bdd: // 0160:1e4bdd
    r32[edx] += 0x00000008;
    { pc = 0x1e4be9; break; }
  case 0x1e4be2: // 0160:1e4be2
    yield* sub_1e4897();
    r32[edx] -= r32[eax];
  case 0x1e4be9: // 0160:1e4be9
    memoryASet32(ds, r32[ebx], r32[edx]);
    r32[edx] += 0x0000003c;
    if (r32[edx] < memoryAGet32(ds, r32[ebx]))
        { pc = 0x1e4bbc; break; }
    r32[esi] = memoryAGet32(ds, 0x20a7c0);
    if (r32[edx] >= r32[esi])
        { pc = 0x1e4c01; break; }
    r32[edx] = r32[esi];
    r8[dl] &= 0xfe;
  case 0x1e4c01: // 0160:1e4c01
    memoryASet32(ds, r32[ebx], r32[edx]);
    r32[edx] += 0x00000fff;
    if (r32[edx] < memoryAGet32(ds, r32[ebx]))
        { pc = 0x1e4bbc; break; }
    r8[dh] &= 0xf0;
    r8[dl] = 0;
    memoryASet32(ds, r32[ebx], r32[edx]);
    r8[al] = r32[edx] != 0;
    r32[eax] &= 0x000000ff;
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4c22() // 0160:1e4c22 +long
{
    r32[esp] -= 4;
    r32[eax] = 0;
    r32[esp] += 4;
}
function* sub_1e4c26() // 0160:1e4c26 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[edx] = memoryAGet32(ds, 0x20a748);
    r32[edx] += 0x00000003;
    r8[dl] &= 0xfc;
    yield* sub_1e7701();
    if (r32[edx] >= r32[eax])
        { pc = 0x1e4c47; break; }
    r32[eax] = r32[edx];
    r32[esp] -= r32[eax];
    r32[eax] = r32[esp];
    { pc = 0x1e4c49; break; }
  case 0x1e4c47: // 0160:1e4c47
    r32[eax] = 0;
  case 0x1e4c49: // 0160:1e4c49
    r32[edx] = memoryAGet32(ds, 0x20a748);
    r32[eax] += r32[edx];
    memoryASet32(ds, 0x20a74c, r32[eax]);
    yield* sub_1e770a();
    r32[edx] = memoryAGet32(ds, 0x3164dc);
    r32[eax] = memoryAGet32(ds, 0x3164d8);
    yield* sub_1c8824();
    yield* sub_1e3663();
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4c76() // 0160:1e4c76 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    push32(r32[edx]);
    push(es);
    r32[edx] = r32[eax];
  case 0x1e4c7d: // 0160:1e4c7d
    r32[esi] = 0x0020b7c8;
    r32[edi] = 0x0020b7ec;
    r32[ebx] = r32[edi];
    r8[al] = r8[dl];
  case 0x1e4c8d: // 0160:1e4c8d
    if (r32[esi] >= r32[edi])
        { pc = 0x1e4ca5; break; }
    if (memoryAGet(ds, r32[esi]) == 0x02)
        { pc = 0x1e4ca0; break; }
    if (memoryAGet(ds, r32[esi] + 0x1) > r8[al])
        { pc = 0x1e4ca0; break; }
    r32[ebx] = r32[esi];
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1e4ca0: // 0160:1e4ca0
    r32[esi] += 0x00000006;
    { pc = 0x1e4c8d; break; }
  case 0x1e4ca5: // 0160:1e4ca5
    if (r32[ebx] == r32[edi])
        { pc = 0x1e4cbb; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x2);
    if (!r32[eax])
        { pc = 0x1e4cb6; break; }
    push(ds);
    es = pop();
    push32(r32[edx]);
    switch (r32[eax])
    {
        case 0x001e3d50: yield* sub_1e3d50(); break;
        case 0x001e58bb: yield* sub_1e58bb(); break;
        case 0x001eadc9: yield* sub_1eadc9(); break;
        case 0x001e749c: yield* sub_1e749c(); break;
        case 0x001e5600: yield* sub_1e5600(); break;
        case 0x001e4d10: yield* sub_1e4d10(); break;
        default:
            stop("ind 0160:1e4cb3");
    }
    r32[edx] = pop32();
  case 0x1e4cb6: // 0160:1e4cb6
    memoryASet(ds, r32[ebx], 0x02);
    { pc = 0x1e4c7d; break; }
  case 0x1e4cbb: // 0160:1e4cbb
    es = pop();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4cc1() // 0160:1e4cc1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebx]);
    push(es);
    r8[dh] = r8[dl];
    r8[dl] = r8[al];
  case 0x1e4cc9: // 0160:1e4cc9
    r32[esi] = 0x0020b7ec;
    r32[edi] = 0x0020b7f8;
    r32[ebx] = r32[edi];
    r8[al] = r8[dl];
  case 0x1e4cd9: // 0160:1e4cd9
    if (r32[esi] >= r32[edi])
        { pc = 0x1e4cf1; break; }
    if (memoryAGet(ds, r32[esi]) == 0x02)
        { pc = 0x1e4cec; break; }
    if (r8[al] > memoryAGet(ds, r32[esi] + 0x1))
        { pc = 0x1e4cec; break; }
    r32[ebx] = r32[esi];
    r8[al] = memoryAGet(ds, r32[esi] + 0x1);
  case 0x1e4cec: // 0160:1e4cec
    r32[esi] += 0x00000006;
    { pc = 0x1e4cd9; break; }
  case 0x1e4cf1: // 0160:1e4cf1
    if (r32[ebx] == r32[edi])
        { pc = 0x1e4d0b; break; }
    if (r8[al] > r8[dh])
        { pc = 0x1e4d06; break; }
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x2);
    if (!r32[eax])
        { pc = 0x1e4d06; break; }
    push(ds);
    es = pop();
    push32(r32[edx]);
    yield* indirectCall(cs, r32[eax]);
    r32[edx] = pop32();
  case 0x1e4d06: // 0160:1e4d06
    memoryASet(ds, r32[ebx], 0x02);
    { pc = 0x1e4cc9; break; }
  case 0x1e4d0b: // 0160:1e4d0b
    es = pop();
    r32[ebx] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4d10() // 0160:1e4d10 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000008;
    r32[ebx] = r32[esp];
    r32[eax] = memoryAGet32(ds, 0x20a734);
    r32[edx] = 0;
    yield* sub_1e4dcd();
    r32[ecx] = memoryAGet32(ds, r32[esp]);
    r32[ebp] = r32[eax] + 1;
    r32[edx] = memoryAGet32(ds, 0x20a734);
    r32[eax] = r32[ebp];
    r32[ecx] -= r32[edx];
    r32[eax] <<= 2;
    r32[ecx]++;
    memoryASet32(ds, r32[esp] + 0x4, r32[eax]);
    r32[eax] += 0x00000004;
    r32[eax] += r32[ecx];
    yield* sub_1e3562();
    r32[edx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e4da9; break; }
    r32[esi] = memoryAGet32(ds, 0x20a734);
    r32[eax] += r32[ecx];
    r32[edi] = r32[edx];
    memoryASet32(ds, 0x20a508, r32[eax]);
    push(es);
    r32[eax] = ds;
    es = r32[eax];
    push32(r32[edi]);
    r32[eax] = r32[ecx];
    r32[ecx] >>>= 2;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsd_ESEDI_DSESI();
    r8[cl] = r8[al];
    r8[cl] &= 0x03;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) movsb_ESEDI_DSESI();
    r32[edi] = pop32();
    es = pop();
    r32[ecx] = memoryAGet32(ds, 0x20a508);
    r32[eax] = memoryAGet32(ds, 0x20a738);
    r32[ebx] = r32[esp];
    memoryASet32(ds, r32[ecx], r32[eax]);
    r32[ecx] += 0x00000004;
    r32[eax] = r32[edx];
    r32[edx] = r32[ecx];
    r32[esi] = memoryAGet32(ds, r32[esp] + 0x4);
    yield* sub_1e4dcd();
    r32[edx] = memoryAGet32(ds, 0x20a508);
    r32[edx] += r32[esi];
    memoryASet32(ds, 0x20a504, r32[ebp]);
    memoryASet32(ds, r32[edx], 0x00000000);
    { pc = 0x1e4db3; break; }
  case 0x1e4da9: // 0160:1e4da9
    memoryASet32(ds, 0x20a508, r32[eax]);
    memoryASet32(ds, 0x20a504, r32[eax]);
  case 0x1e4db3: // 0160:1e4db3
    r32[eax] = memoryAGet32(ds, 0x20a508);
    memoryASet32(ds, 0x3164d8, r32[ebp]);
    memoryASet32(ds, 0x3164dc, r32[eax]);
    r32[esp] += 0x00000008;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4dcd() // 0160:1e4dcd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000008;
    r32[esi] = r32[edx];
    memoryASet32(ds, r32[esp] + 0x4, r32[ebx]);
    r32[ecx] = 0;
  case 0x1e4ddc: // 0160:1e4ddc
    r8[dl] = memoryAGet(ds, r32[eax]);
    if (r8[dl] == 0x20)
        { pc = 0x1e4de8; break; }
    if (r8[dl] != 0x09)
        { pc = 0x1e4deb; break; }
  case 0x1e4de8: // 0160:1e4de8
    r32[eax]++;
    { pc = 0x1e4ddc; break; }
  case 0x1e4deb: // 0160:1e4deb
    if (!r8[dl])
        { pc = 0x1e4ea6; break; }
    if (r8[dl] != 0x22)
        { pc = 0x1e4e37; break; }
    r32[eax]++;
    memoryASet32(ds, r32[esp], r32[eax]);
    r32[edx] = r32[eax];
  case 0x1e4dfe: // 0160:1e4dfe
    r8[bh] = memoryAGet(ds, r32[eax]);
    if (r8[bh] == 0x22)
        { pc = 0x1e4e6c; break; }
    if (!r8[bh])
        { pc = 0x1e4e6c; break; }
    if (r8[bh] != 0x5c)
        { pc = 0x1e4e23; break; }
    r8[bl] = memoryAGet(ds, r32[eax] + 0x1);
    if (r8[bl] == 0x22)
        { pc = 0x1e4e22; break; }
    if (r8[bl] != r8[bh])
        { pc = 0x1e4e23; break; }
  case 0x1e4e22: // 0160:1e4e22
    r32[eax]++;
  case 0x1e4e23: // 0160:1e4e23
    r32[ebx] = r32[eax] + 1;
    if (!r32[esi])
        { pc = 0x1e4e33; break; }
    r8[al] = memoryAGet(ds, r32[eax]);
    memoryASet(ds, r32[edx], r8[al]);
    r32[eax] = r32[ebx];
    r32[edx]++;
    { pc = 0x1e4dfe; break; }
  case 0x1e4e33: // 0160:1e4e33
    r32[eax] = r32[ebx];
    { pc = 0x1e4dfe; break; }
  case 0x1e4e37: // 0160:1e4e37
    memoryASet32(ds, r32[esp], r32[eax]);
    r32[edx] = r32[eax];
  case 0x1e4e3c: // 0160:1e4e3c
    r8[bl] = memoryAGet(ds, r32[eax]);
    if (!r8[bl])
        { pc = 0x1e4e6c; break; }
    if (r8[bl] == 0x20)
        { pc = 0x1e4e6c; break; }
    if (r8[bl] == 0x09)
        { pc = 0x1e4e6c; break; }
    if (r8[bl] != 0x5c)
        { pc = 0x1e4e58; break; }
    if (memoryAGet(ds, r32[eax] + 0x1) != 0x22)
        { pc = 0x1e4e58; break; }
    r32[eax]++;
  case 0x1e4e58: // 0160:1e4e58
    r32[ebx] = r32[eax] + 1;
    if (!r32[esi])
        { pc = 0x1e4e68; break; }
    r8[al] = memoryAGet(ds, r32[eax]);
    memoryASet(ds, r32[edx], r8[al]);
    r32[eax] = r32[ebx];
    r32[edx]++;
    { pc = 0x1e4e3c; break; }
  case 0x1e4e68: // 0160:1e4e68
    r32[eax] = r32[ebx];
    { pc = 0x1e4e3c; break; }
  case 0x1e4e6c: // 0160:1e4e6c
    r32[ebp] = r32[eax] + 1;
    r32[edi] = r32[ecx] + 1;
    if (!r32[esi])
        { pc = 0x1e4e97; break; }
    r32[ecx] <<= 2;
    r32[ebx] = r32[esi] + r32[ecx];
    r32[ecx] = memoryAGet32(ds, r32[esp]);
    memoryASet32(ds, r32[ebx], r32[ecx]);
    r8[bl] = memoryAGet(ds, r32[eax]);
    r32[ecx] = r32[edi];
    if (r8[bl])
        { pc = 0x1e4e8d; break; }
    memoryASet(ds, r32[edx], r8[bl]);
    { pc = 0x1e4ea6; break; }
  case 0x1e4e8d: // 0160:1e4e8d
    r32[eax] = r32[ebp];
    memoryASet(ds, r32[edx], 0x00);
    { pc = 0x1e4ddc; break; }
  case 0x1e4e97: // 0160:1e4e97
    r8[dl] = memoryAGet(ds, r32[eax]);
    r32[ecx] = r32[edi];
    if (!r8[dl])
        { pc = 0x1e4ea6; break; }
    r32[eax] = r32[ebp];
    { pc = 0x1e4ddc; break; }
  case 0x1e4ea6: // 0160:1e4ea6
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x4);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[eax] = r32[ecx];
    r32[esp] += 0x00000008;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e4eb6() // 0160:1e4eb6 +long
{
    r32[esp] -= 4;
    push32(r32[ebp]);
    push(es);
    push32(r32[ebx]);
    push(ds);
    push32(r32[edx]);
    yield* sub_1e4eee();
    push(ds);
    push32(r32[edi]);
    r32[ebp] = r32[esp];
    r32[edi] = memoryAGet32(ss, r32[ebp] + 0x8);
    ds = memoryAGet16(ss, r32[ebp] + 0xc);
    memoryASet32(ds, r32[edi], r32[eax]);
    memoryASet32(ds, r32[edi] + 0x4, r32[ebx]);
    memoryASet32(ds, r32[edi] + 0x8, r32[ecx]);
    memoryASet32(ds, r32[edi] + 0xc, r32[edx]);
    memoryASet32(ds, r32[edi] + 0x10, r32[esi]);
    memoryASet32(ds, r32[edi] + 0x14, pop32());
    r32[eax] = -flags.carry;
    memoryASet32(ds, r32[edi] + 0x18, r32[eax]);
    r32[eax] = pop32();
    r32[ebx] = pop32();
    r32[ebx] = pop32();
    r32[ebx] = pop32();
    memoryASet16(ds, r32[ebx] + 0x6, r16[ax]);
    memoryASet16(ds, r32[ebx], es);
    es = pop();
    r32[ebp] = pop32();
    r32[esp] += 4;
}
function* sub_1e4eee() // 0160:1e4eee +long +returnCarry
{
    r32[esp] -= 4;
    r32[esi] = r32[esi] + (r32[esi] * 2);
    r32[eax] = r32[esi] + 1986452;
    push32(r32[eax]);
    es = memoryAGet16(ds, r32[ebx]);
    r16[bp] = memoryAGet16(ds, r32[ebx] + 0x6);
    r32[eax] = memoryAGet32(ds, r32[edi]);
    r32[ebx] = memoryAGet32(ds, r32[edi] + 0x4);
    r32[ecx] = memoryAGet32(ds, r32[edi] + 0x8);
    r32[edx] = memoryAGet32(ds, r32[edi] + 0xc);
    r32[esi] = memoryAGet32(ds, r32[edi] + 0x10);
    r32[edi] = memoryAGet32(ds, r32[edi] + 0x14);
    ds = r32[ebp];
    stop("stack_unbalanced");
    r32[esp] += 4;
}
function* sub_1e5294() // 0160:1e5294 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = cs;
    memoryASet16(ds, r32[edx] + 0x2, r16[ax]);
    r32[eax] = ds;
    memoryASet16(ds, r32[edx] + 0x6, r16[ax]);
    r32[eax] = es;
    memoryASet16(ds, r32[edx], r16[ax]);
    r32[eax] = ss;
    memoryASet16(ds, r32[edx] + 0x4, r16[ax]);
    r32[eax] = fs;
    memoryASet16(ds, r32[edx] + 0x8, r16[ax]);
    r32[eax] = gs;
    memoryASet16(ds, r32[edx] + 0xa, r16[ax]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e52bc() // 0160:1e52bc +long +stackDrop20
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[esp] -= 0x00000008;
    r8[ah] = memoryAGet(ss, r32[ebp] + 0x18);
    if (r8[ah] > 0x01)
        { pc = 0x1e52fd; break; }
    if (r8[ah])
        { pc = 0x1e52f6; break; }
    fldz();
    fcomp64(memoryAGet64(ss, r32[ebp] + 0x10));
    r16[ax] = fnstsw();
    sahf();
    if (!flags.carry)
        { pc = 0x1e52e6; break; }
    r32[ecx] = 0;
    memoryASet32(ss, r32[ebp] - 24, r32[ecx]);
    memoryASet32(ss, r32[ebp] - 20, r32[ecx]);
    { pc = 0x1e5335; break; }
  case 0x1e52e6: // 0160:1e52e6
    if (stop("TODO: reads sahf"))
        { pc = 0x1e52ef; break; }
    r32[eax] = 0x00008047;
    { pc = 0x1e5327; break; }
  case 0x1e52ef: // 0160:1e52ef
    r32[eax] = 0x00004047;
    { pc = 0x1e5327; break; }
  case 0x1e52f6: // 0160:1e52f6
    r32[eax] = 0x00002047;
    { pc = 0x1e5327; break; }
  case 0x1e52fd: // 0160:1e52fd
    fldz();
    fcomp64(memoryAGet64(ss, r32[ebp] + 0x10));
    r16[ax] = fnstsw();
    sahf();
    if (flags.carry)
        { pc = 0x1e5311; break; }
    r32[edx] = 0;
    memoryASet32(ss, r32[ebp] - 24, r32[edx]);
    memoryASet32(ss, r32[ebp] - 20, r32[edx]);
    { pc = 0x1e5335; break; }
  case 0x1e5311: // 0160:1e5311
    fldz();
    fcomp64(memoryAGet64(ss, r32[ebp] + 0x8));
    r16[ax] = fnstsw();
    sahf();
    if (!flags.carry)
        { pc = 0x1e5322; break; }
    r32[eax] = 0x00008107;
    { pc = 0x1e5327; break; }
  case 0x1e5322: // 0160:1e5322
    r32[eax] = 0x00001107;
  case 0x1e5327: // 0160:1e5327
    r32[edx] = r32[ebp] + 8;
    r32[ebx] = r32[ebp] + 16;
    yield* sub_1e771f();
    memoryASet64(ss, r32[ebp] - 24, fstp64());
  case 0x1e5335: // 0160:1e5335
    fld64(memoryAGet64(ss, r32[ebp] - 24));
    r32[esp] = r32[ebp] - 16;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[ebp] = pop32();
    stop("stack_unbalanced");
    r32[esp] += 24;
    return;
  }
}
function* sub_1e535e() // 0160:1e535e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    r32[esp] -= 0x00000010;
    fcom64(memoryAGet64(cs, 0x1e5344));
    memoryASet16(ss, r32[ebp] - 16, fnstsw());
    r8[ah] = memoryAGet(ss, r32[ebp] - 15);
    sahf();
    if (stop("TODO: reads sahf"))
        { pc = 0x1e538e; break; }
    if (r8[al] == 0x07)
        { pc = 0x1e5388; break; }
    memoryASet64(ss, r32[ebp] - 16, fstp64());
    memoryASet32(ss, r32[ebp] - 8, r32[eax]);
    memoryASet32(ss, r32[ebp] - 4, r32[edx]);
    yield* sub_1e77fa();
  case 0x1e5388: // 0160:1e5388
    r8[al] = 0x01;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esp] += 4; return;
  case 0x1e538e: // 0160:1e538e
    fcom64(memoryAGet64(cs, 0x1e534c));
    memoryASet16(ss, r32[ebp] - 16, fnstsw());
    r8[ah] = memoryAGet(ss, r32[ebp] - 15);
    sahf();
    if (stop("TODO: reads sahf"))
        { pc = 0x1e53a4; break; }
    fldz();
    { pc = 0x1e53b8; break; }
  case 0x1e53a4: // 0160:1e53a4
    stop("disassembly failed at 0160:1e53a4 (fldl2e )");
    stop("disassembly failed at 0160:1e53a6 (fmulp st(1))");
    fld80(st(0));
    frndint();
    fxch80(st(0));
    fsub80(st(1));
    stop("disassembly failed at 0160:1e53b0 (f2xm1 )");
    fld1();
    faddp80(st(1));
    stop("disassembly failed at 0160:1e53b6 (fscale )");
  case 0x1e53b8: // 0160:1e53b8
    st(1) = fstp_check80();
    r8[al] = 0x00;
    r32[esp] = r32[ebp];
    r32[ebp] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e53cc() // 0160:1e53cc +long
{
    r32[esp] -= 4;
    r32[eax] = 0x0000000d;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* sub_1e7875();
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e53d1() // 0160:1e53d1 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* sub_1e7875();
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e53dd() // 0160:1e53dd +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e53dd; break; }
  case 0x1e53d1: // 0160:1e53d1
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* sub_1e7875();
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1e53dd: // 0160:1e53dd
    r32[eax] = 0x0000000e;
    { pc = 0x1e53d1; break; }
    return;
  }
}
function* sub_1e53f4() // 0160:1e53f4 +long
{
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* sub_1e787b();
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[edx] = pop32();
    r32[esp] += 4;
}
function* sub_1e5407() // 0160:1e5407 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    yield* sub_1e693e();
    if (memoryAGet32(ds, r32[edx] + 0x14))
        { pc = 0x1e543c; break; }
    r8[ah] = memoryAGet(ds, r32[edx] + 0xd);
    if (!(r8[ah] & 0x02))
        { pc = 0x1e5427; break; }
    memoryASet32(ds, r32[edx] + 0x14, 0x00000086);
    { pc = 0x1e543c; break; }
  case 0x1e5427: // 0160:1e5427
    if (!(r8[ah] & 0x04))
        { pc = 0x1e5435; break; }
    memoryASet32(ds, r32[edx] + 0x14, 0x00000001);
    { pc = 0x1e543c; break; }
  case 0x1e5435: // 0160:1e5435
    memoryASet32(ds, r32[edx] + 0x14, 0x00001000);
  case 0x1e543c: // 0160:1e543c
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x14);
    yield* sub_1e3562();
    memoryASet32(ds, r32[edx] + 0x8, r32[eax]);
    if (r32[eax])
        { pc = 0x1e546b; break; }
    r32[eax] = r32[edx] + 24;
    r8[cl] = memoryAGet(ds, r32[edx] + 0xd);
    memoryASet32(ds, r32[edx] + 0x14, 0x00000001);
    r8[cl] &= 0xf8;
    memoryASet32(ds, r32[edx] + 0x8, r32[eax]);
    r8[ch] = r8[cl];
    memoryASet(ds, r32[edx] + 0xd, r8[cl]);
    r8[ch] |= 0x04;
    memoryASet(ds, r32[edx] + 0xd, r8[ch]);
    { pc = 0x1e546f; break; }
  case 0x1e546b: // 0160:1e546b
    memoryASet(ds, r32[edx] + 0xc, memoryAGet(ds, r32[edx] + 0xc) | 0x08);
  case 0x1e546f: // 0160:1e546f
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x8);
    memoryASet32(ds, r32[edx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e547e() // 0160:1e547e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[ebx];
    r32[ebx] = r32[eax];
    r8[ah] = 0x3f;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    r32[edx] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1e549b; break; }
    r32[eax] &= 0x0000ffff;
    yield* sub_1e788d();
  case 0x1e549b: // 0160:1e549b
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5555() // 0160:1e5555 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    if (memoryAGet32(ds, r32[eax] + 0x8))
        { pc = 0x1e5566; break; }
    yield* sub_1e5407();
  case 0x1e5566: // 0160:1e5566
    r8[ah] = memoryAGet(ds, r32[ecx] + 0xd);
    if (!(r8[ah] & 0x20))
        { pc = 0x1e557d; break; }
    if (!(r8[ah] & 0x06))
        { pc = 0x1e557d; break; }
    r32[eax] = 0x00002000;
    yield* sub_1e59c0();
  case 0x1e557d: // 0160:1e557d
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0xc);
    r8[bl] = memoryAGet(ds, r32[ecx] + 0xc);
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x8);
    r8[bl] &= 0xfb;
    memoryASet32(ds, r32[ecx], r32[eax]);
    r32[edx] &= 0x00002400;
    memoryASet(ds, r32[ecx] + 0xc, r8[bl]);
    if (r32[edx] != 0x00002400)
        { pc = 0x1e55bd; break; }
    r32[ebx] = memoryAGet32(ds, r32[ecx] + 0x10);
    if (r32[ebx])
        { pc = 0x1e55bd; break; }
    memoryASet32(ds, r32[ecx] + 0x4, r32[ebx]);
    yield* sub_1e78f3();
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e55da; break; }
    r32[ebx] = memoryAGet32(ds, r32[ecx]);
    memoryASet(ds, r32[ebx], r8[al]);
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000001);
    { pc = 0x1e55da; break; }
  case 0x1e55bd: // 0160:1e55bd
    if (!(memoryAGet(ds, r32[ecx] + 0xd) & 0x04))
        { pc = 0x1e55ca; break; }
    r32[ebx] = 0x00000001;
    { pc = 0x1e55cd; break; }
  case 0x1e55ca: // 0160:1e55ca
    r32[ebx] = memoryAGet32(ds, r32[ecx] + 0x14);
  case 0x1e55cd: // 0160:1e55cd
    r32[edx] = memoryAGet32(ds, r32[ecx]);
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e547e();
    memoryASet32(ds, r32[ecx] + 0x4, r32[eax]);
  case 0x1e55da: // 0160:1e55da
    r32[esi] = memoryAGet32(ds, r32[ecx] + 0x4);
    if (r32s[esi] > 0)
        { pc = 0x1e55f8; break; }
    if (r32[esi])
        { pc = 0x1e55e9; break; }
    memoryASet(ds, r32[ecx] + 0xc, memoryAGet(ds, r32[ecx] + 0xc) | 0x10);
    { pc = 0x1e55f8; break; }
  case 0x1e55e9: // 0160:1e55e9
    r8[al] = memoryAGet(ds, r32[ecx] + 0xc);
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000000);
    r8[al] |= 0x20;
    memoryASet(ds, r32[ecx] + 0xc, r8[al]);
  case 0x1e55f8: // 0160:1e55f8
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x4);
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5600() // 0160:1e5600 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = 0x001e7910;
    r32[ebx] = 0x001e7a35;
    memoryASet32(ds, 0x20a834, r32[edx]);
    memoryASet32(ds, 0x20a838, r32[ebx]);
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e561c() // 0160:1e561c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    return;
    r32[esp] -= 4;
    return;
    push(es);
    push32(r32[ecx]);
    push32(r32[ebx]);
    push32(r32[edx]);
    fninit();
    push32(r32[eax]);
    memoryASet16(ds, r32[esp], fnstcw());
    r32[eax] = pop32();
    if (r8[ah] == 0x03)
        { pc = 0x1e562d; break; }
    r32[ebp]++;
  case 0x1e562d: // 0160:1e562d
    if (!r32[ebp])
        { pc = 0x1e5636; break; }
    yield* sub_1e564c();
  case 0x1e5636: // 0160:1e5636
    fninit();
    fldcw(memoryAGet16(ds, 0x20a8bc));
    fldz();
    fldz();
    fldz();
    fldz();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[ecx] = pop32();
    es = pop();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e564c() // 0160:1e564c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    memoryASet(ds, 0x20a50c, 0x03);
    memoryASet(ds, 0x20a7b8, 0x01);
    stop("disassembly failed at 0160:1e565a (smsw word ptr [0x20a7b6])");
    memoryASet16(ds, 0x20a7b6, memoryAGet16(ds, 0x20a7b6) & 0x0006);
    r32[esp] -= 0x00000008;
    stop("disassembly failed at 0160:1e566d (sidt [esp])");
    r32[ebx] = memoryAGet32(ds, r32[esp] + 0x2);
    r32[ebx] += 0x00000038;
    r32[esp] += 0x00000008;
    if (!memoryAGet(ds, 0x20a760))
        { pc = 0x1e569e; break; }
    yield* sub_1e5717();
    es = memoryAGet16(ds, 0x20a502);
    memoryASet32(es, r32[ebx], r32[edx]);
    memoryASet32(es, r32[ebx] + 0x4, r32[ecx]);
    yield* sub_1e5781();
    { pc = 0x1e5716; break; }
  case 0x1e569e: // 0160:1e569e
    if (memoryAGet(ds, 0x20a75e))
        { pc = 0x1e56c2; break; }
    r16[ax] = 0x2507;
    push(ds);
    r16[cx] = cs;
    ds = r32[ecx];
    r32[edx] = 1998400;
    interrupt(0x21);
    ds = pop();
    r8[al] = 0x04;
    r8[ah] = 0xf3;
    interrupt(0x21);
    { pc = 0x1e5716; break; }
  case 0x1e56c2: // 0160:1e56c2
    if (memoryAGet(ds, 0x20a75e) != 0x09)
        { pc = 0x1e56ea; break; }
    yield* sub_1e5717();
    memoryASet32(ds, r32[ebx], r32[edx]);
    memoryASet32(ds, r32[ebx] + 0x4, r32[ecx]);
    r32[eax] = 0x00000e02;
    r32[ebx] = 0x00000004;
    r32[ecx] = memoryAGet32(ds, 0x20a4fc);
    yield* indirectCall(cs, memoryAGet32(ds, r32[ecx] + 0x30));
    { pc = 0x1e5716; break; }
  case 0x1e56ea: // 0160:1e56ea
    if (memoryAGet(ds, 0x20a75e) != 0x01)
        { pc = 0x1e5703; break; }
    r16[dx] = memoryAGet16(ds, 0x20a500);
    r32[eax] = 0;
    yield* sub_1eac7e();
    { pc = 0x1e5716; break; }
  case 0x1e5703: // 0160:1e5703
    r16[dx] = 0;
    r32[eax] = 0;
    yield* sub_1eac7e();
    if (r8[al] == 0x01)
        { pc = 0x1e5716; break; }
    yield* sub_1e5734();
  case 0x1e5716: // 0160:1e5716
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e5717() // 0160:1e5717 +long
{
    r32[esp] -= 4;
    r32[ecx] = 1998400;
    r16[dx] = cs;
    r32[edx] <<= 16;
    r16[dx] = r16[cx];
    r16[cx] = cs;
    r8[cl] &= 0x03;
    r16[cx] <<= 13;
    r8[ch] |= 0x8e;
    r32[esp] += 4;
}
function* sub_1e5734() // 0160:1e5734 +long
{
  var pc = 0;
  var temp_cond0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r8[cl] = 0x07;
    r16[ax] = 0x2502;
    interrupt(0x21);
    memoryASet32(ds, 0x20a7b0, r32[ebx]);
    memoryASet16(ds, 0x20a7b4, es);
    temp_cond0 = signed8(memoryAGet(ds, 0x20a75e)) < signed8(0x03);
    r8[cl] = 0x07;
    r16[ax] = 0x2504;
    push(ds);
    push(cs);
    ds = pop();
    if (temp_cond0)
        { pc = 0x1e576b; break; }
    r32[edx] = 1998288;
    interrupt(0x21);
    ds = pop();
    yield* sub_1e5781();
    { pc = 0x1e5780; break; }
  case 0x1e576b: // 0160:1e576b
    r32[edx] = 1998400;
    interrupt(0x21);
    ds = pop();
    r32[ecx] = r32[cr0];
    r32[ecx] |= 0x00000004;
    r32[ecx] &= 0xfffffffd;
    r32[cr0] = r32[ecx];
  case 0x1e5780: // 0160:1e5780
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e5781() // 0160:1e5781 +long
{
    r32[esp] -= 4;
    r32[ebx] = 0;
    r32[edx] = 2140016;
    r16[ax] = 0x2535;
    interrupt(0x21);
    memoryASet32(ds, 0x20a770, memoryAGet32(ds, 0x20a770) | 0x00000004);
    memoryASet32(ds, 0x20a770, memoryAGet32(ds, 0x20a770) & 0xfffffffd);
    r32[ebx]++;
    interrupt(0x21);
    r32[esp] += 4;
}
function* sub_1e5880() // 0160:1e5880 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    if (!memoryAGet(ds, 0x20a50d))
        { pc = 0x1e58a1; break; }
    r32[edx] = 0x001e5877;
    r32[ebx] = 0x001e587c;
    memoryASet32(ds, 0x20a8c0, r32[edx]);
    memoryASet32(ds, 0x20a8c4, r32[ebx]);
  case 0x1e58a1: // 0160:1e58a1
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, 0x20a8bc);
    yield* sub_1eada2();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e58bb() // 0160:1e58bb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    return;
    r32[esp] -= 4;
    return;
    push32(r32[edx]);
    r8[ah] = memoryAGet(ds, 0x20a50c);
    if (r8[ah])
        { pc = 0x1e58f9; break; }
    memoryASet(ds, 0x20a50d, r8[ah]);
    r32[eax] = 0;
    push32(r32[eax]);
    fninit();
    memoryASet16(ds, r32[esp], fnstcw());
    r32[eax] = pop32();
    r8[al] = r8[ah];
    r8[dl] = 0;
    if (r8[al] != 0x03)
        { pc = 0x1e58e4; break; }
    yield* sub_1e5880();
    r8[dl] = r8[al];
  case 0x1e58e4: // 0160:1e58e4
    if (memoryAGet(ds, 0x20a75c))
        { pc = 0x1e58f9; break; }
    memoryASet(ds, 0x20a50c, r8[dl]);
    memoryASet(ds, 0x20a50d, r8[dl]);
  case 0x1e58f9: // 0160:1e58f9
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e58fc() // 0160:1e58fc +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r8[ah] = memoryAGet(ds, r32[eax] + 0xd);
    r32[esi] = 0;
    if (!(r8[ah] & 0x10))
        { pc = 0x1e5969; break; }
    r8[bh] = memoryAGet(ds, r32[ecx] + 0xd);
    r8[bh] &= 0xef;
    r8[al] = memoryAGet(ds, r32[ecx] + 0xc);
    memoryASet(ds, r32[ecx] + 0xd, r8[bh]);
    if (!(r8[al] & 0x02))
        { pc = 0x1e59a8; break; }
    if (!memoryAGet32(ds, r32[ecx] + 0x8))
        { pc = 0x1e59a8; break; }
    r32[ebx] = memoryAGet32(ds, r32[ecx] + 0x4);
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0x8);
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1eaea4();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e594a; break; }
    r8[dl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[dl] |= 0x20;
    r32[esi] = r32[eax];
    memoryASet(ds, r32[ecx] + 0xc, r8[dl]);
    { pc = 0x1e59a8; break; }
  case 0x1e594a: // 0160:1e594a
    if (r32[eax] == memoryAGet32(ds, r32[ecx] + 0x4))
        { pc = 0x1e59a8; break; }
    r32[eax] = 0x0000000c;
    yield* sub_1e53d1();
    r8[ah] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[ah] |= 0x20;
    r32[esi] = 0xffffffff;
    memoryASet(ds, r32[ecx] + 0xc, r8[ah]);
    { pc = 0x1e59a8; break; }
  case 0x1e5969: // 0160:1e5969
    if (!memoryAGet32(ds, r32[ecx] + 0x8))
        { pc = 0x1e59a8; break; }
    r8[dl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[dl] &= 0xef;
    r8[dh] = memoryAGet(ds, r32[ecx] + 0xd);
    memoryASet(ds, r32[ecx] + 0xc, r8[dl]);
    if (r8[dh] & 0x20)
        { pc = 0x1e59a8; break; }
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x4);
    if (!r32[eax])
        { pc = 0x1e5998; break; }
    r32[edx] = r32[eax];
    r32[ebx] = 0x00000001;
    r32[edx] = -r32[edx];
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x10);
    yield* sub_1e6986();
  case 0x1e5998: // 0160:1e5998
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e59a8; break; }
    r8[bl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[bl] |= 0x20;
    r32[esi] = r32[eax];
    memoryASet(ds, r32[ecx] + 0xc, r8[bl]);
  case 0x1e59a8: // 0160:1e59a8
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0x8);
    memoryASet32(ds, r32[ecx] + 0x4, 0x00000000);
    memoryASet32(ds, r32[ecx], r32[eax]);
    r32[eax] = r32[esi];
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e59bb() // 0160:1e59bb +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    r32[eax] = 0xffffffff;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ecx] = r32[eax];
    r32[edx] = memoryAGet32(ds, 0x3164d0);
    r32[ebx] = 0;
    { pc = 0x1e59e5; break; }
  case 0x1e59cf: // 0160:1e59cf
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x4);
    if (!(memoryAGet32(ds, r32[eax] + 0xc) & r32[ecx]))
        { pc = 0x1e59e3; break; }
    r32[ebx]++;
    if (!(memoryAGet(ds, r32[eax] + 0xd) & 0x10))
        { pc = 0x1e59e3; break; }
    yield* sub_1e58fc();
  case 0x1e59e3: // 0160:1e59e3
    r32[edx] = memoryAGet32(ds, r32[edx]);
  case 0x1e59e5: // 0160:1e59e5
    if (r32[edx])
        { pc = 0x1e59cf; break; }
    r32[eax] = r32[ebx];
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e59c0() // 0160:1e59c0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ecx] = r32[eax];
    r32[edx] = memoryAGet32(ds, 0x3164d0);
    r32[ebx] = 0;
    { pc = 0x1e59e5; break; }
  case 0x1e59cf: // 0160:1e59cf
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x4);
    if (!(memoryAGet32(ds, r32[eax] + 0xc) & r32[ecx]))
        { pc = 0x1e59e3; break; }
    r32[ebx]++;
    if (!(memoryAGet(ds, r32[eax] + 0xd) & 0x10))
        { pc = 0x1e59e3; break; }
    yield* sub_1e58fc();
  case 0x1e59e3: // 0160:1e59e3
    r32[edx] = memoryAGet32(ds, r32[edx]);
  case 0x1e59e5: // 0160:1e59e5
    if (r32[edx])
        { pc = 0x1e59cf; break; }
    r32[eax] = r32[ebx];
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e59ef() // 0160:1e59ef +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000008;
    r32[esi] = r32[eax];
    memoryASet32(ds, r32[esp], r32[edx]);
    r32[edi] = r32[ebx];
    r8[ah] = memoryAGet(ds, r32[eax] + 0x10);
    r32[edx] = 0;
    r32[ebp] = 0;
    r8[ah] &= 0xfd;
    memoryASet32(ds, r32[esp] + 0x4, r32[edx]);
    memoryASet(ds, r32[esi] + 0x10, r8[ah]);
  case 0x1e5a0e: // 0160:1e5a0e
    r32[ebx] = memoryAGet32(ds, r32[esp]);
    r32[ecx] = r32[ebx] + 1;
    memoryASet32(ds, r32[esp], r32[ecx]);
    r8[bl] = memoryAGet(ds, r32[ebx]);
    r32[ebx] &= 0x000000ff;
    if (!r32[ebx])
        { pc = 0x1e5bf0; break; }
    r8[al] = r8[bl];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x02))
        { pc = 0x1e5a45; break; }
    r32[eax] = r32[esi];
    yield* sub_1e5ce9();
    r32[ebp] += r32[eax];
    { pc = 0x1e5bbc; break; }
  case 0x1e5a45: // 0160:1e5a45
    if (r32[ebx] == 0x00000025)
        { pc = 0x1e5a6a; break; }
    r32[eax] = r32[esi];
    yield* indirectCall(cs, memoryAGet32(ds, r32[esi]));
    if (r32[eax] == r32[ebx])
        { pc = 0x1e5bbb; break; }
  case 0x1e5a56: // 0160:1e5a56
    if (memoryAGet(ds, r32[esi] + 0x10) & 0x02)
        { pc = 0x1e5bf0; break; }
    r32[edx] = r32[esi];
    yield* indirectCall(cs, memoryAGet32(ds, r32[esi] + 0x4));
    { pc = 0x1e5bf0; break; }
  case 0x1e5a6a: // 0160:1e5a6a
    r32[eax] = r32[ecx];
    r32[edx] = r32[esi];
    yield* sub_1e5c10();
    r32[ebx] = 0;
    memoryASet32(ds, r32[esp], r32[eax]);
    r8[bl] = memoryAGet(ds, r32[eax]);
    r32[edx] = r32[eax];
    if (!r32[ebx])
        { pc = 0x1e5a86; break; }
    r32[edx] = r32[eax] + 1;
    memoryASet32(ds, r32[esp], r32[edx]);
  case 0x1e5a86: // 0160:1e5a86
    if (r32[ebx] < 0x00000065)
        { pc = 0x1e5ae0; break; }
    if (r32[ebx] <= 0x00000067)
        { pc = 0x1e5b62; break; }
    if (r32[ebx] < 0x00000070)
        { pc = 0x1e5ac6; break; }
    if (r32[ebx] <= 0x00000070)
        { pc = 0x1e5b5b; break; }
    if (r32[ebx] < 0x00000075)
        { pc = 0x1e5ab8; break; }
    if (r32[ebx] <= 0x00000075)
        { pc = 0x1e5b4e; break; }
    if (r32[ebx] == 0x00000078)
        { pc = 0x1e5b5b; break; }
    { pc = 0x1e5bbc; break; }
  case 0x1e5ab8: // 0160:1e5ab8
    if (r32[ebx] == 0x00000073)
        { pc = 0x1e5b6d; break; }
    { pc = 0x1e5bbc; break; }
  case 0x1e5ac6: // 0160:1e5ac6
    if (r32[ebx] < 0x0000006e)
        { pc = 0x1e5ad6; break; }
    if (r32[ebx] <= 0x0000006e)
        { pc = 0x1e5ba2; break; }
    { pc = 0x1e5b47; break; }
  case 0x1e5ad6: // 0160:1e5ad6
    if (r32[ebx] == 0x00000069)
        { pc = 0x1e5b3a; break; }
    { pc = 0x1e5bbc; break; }
  case 0x1e5ae0: // 0160:1e5ae0
    if (r32[ebx] < 0x00000058)
        { pc = 0x1e5b06; break; }
    if (r32[ebx] <= 0x00000058)
        { pc = 0x1e5b5b; break; }
    if (r32[ebx] < 0x00000063)
        { pc = 0x1e5af8; break; }
    if (r32[ebx] <= 0x00000063)
        { pc = 0x1e5b85; break; }
    { pc = 0x1e5b25; break; }
  case 0x1e5af8: // 0160:1e5af8
    if (r32[ebx] == 0x0000005b)
        { pc = 0x1e5b78; break; }
    { pc = 0x1e5bbc; break; }
  case 0x1e5b06: // 0160:1e5b06
    if (r32[ebx] < 0x00000045)
        { pc = 0x1e5b17; break; }
    if (r32[ebx] <= 0x00000045)
        { pc = 0x1e5b62; break; }
    if (r32[ebx] == 0x00000047)
        { pc = 0x1e5b62; break; }
    { pc = 0x1e5bbc; break; }
  case 0x1e5b17: // 0160:1e5b17
    if (r32[ebx] == 0x00000025)
        { pc = 0x1e5baf; break; }
    { pc = 0x1e5bbc; break; }
  case 0x1e5b25: // 0160:1e5b25
    r32[ebx] = 0x0000000a;
  case 0x1e5b2a: // 0160:1e5b2a
    r32[ecx] = 0x00000001;
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
  case 0x1e5b33: // 0160:1e5b33
    yield* sub_1e62f7();
    { pc = 0x1e5b8e; break; }
  case 0x1e5b3a: // 0160:1e5b3a
    r32[ecx] = 0x00000001;
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    r32[ebx] = 0;
    { pc = 0x1e5b33; break; }
  case 0x1e5b47: // 0160:1e5b47
    r32[ebx] = 0x00000008;
    { pc = 0x1e5b2a; break; }
  case 0x1e5b4e: // 0160:1e5b4e
    r32[ebx] = 0x0000000a;
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    r32[ecx] = 0;
    { pc = 0x1e5b33; break; }
  case 0x1e5b5b: // 0160:1e5b5b
    r32[ebx] = 0x00000010;
    { pc = 0x1e5b2a; break; }
  case 0x1e5b62: // 0160:1e5b62
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    yield* sub_1e6019();
    { pc = 0x1e5b8e; break; }
  case 0x1e5b6d: // 0160:1e5b6d
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    yield* sub_1e5da4();
    { pc = 0x1e5b8e; break; }
  case 0x1e5b78: // 0160:1e5b78
    r32[ebx] = r32[esp];
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    yield* sub_1e5f33();
    { pc = 0x1e5b8e; break; }
  case 0x1e5b85: // 0160:1e5b85
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    yield* sub_1e5d1e();
  case 0x1e5b8e: // 0160:1e5b8e
    if (r32s[eax] <= 0)
        { pc = 0x1e5bf0; break; }
    r8[dh] = memoryAGet(ds, r32[esi] + 0x10);
    r32[ebp] += r32[eax];
    if (!(r8[dh] & 0x01))
        { pc = 0x1e5bbc; break; }
    memoryASet32(ds, r32[esp] + 0x4, memoryAGet32(ds, r32[esp] + 0x4) + 1);
    { pc = 0x1e5bbc; break; }
  case 0x1e5ba2: // 0160:1e5ba2
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    r32[ebx] = r32[ebp];
    yield* sub_1e5e92();
    { pc = 0x1e5bbc; break; }
  case 0x1e5baf: // 0160:1e5baf
    r32[eax] = r32[esi];
    yield* indirectCall(cs, memoryAGet32(ds, r32[esi]));
    if (r32[eax] != r32[ebx])
        { pc = 0x1e5a56; break; }
  case 0x1e5bbb: // 0160:1e5bbb
    r32[ebp]++;
  case 0x1e5bbc: // 0160:1e5bbc
    if (!(memoryAGet(ds, r32[esi] + 0x10) & 0x02))
        { pc = 0x1e5a0e; break; }
    r32[eax] = memoryAGet32(ds, r32[esp]);
    if (memoryAGet(ds, r32[eax]) != 0x25)
        { pc = 0x1e5bf0; break; }
    r32[edx] = r32[eax] + 1;
    memoryASet32(ds, r32[esp], r32[edx]);
    r32[eax] = r32[edx];
    r32[edx] = r32[esi];
    yield* sub_1e5c10();
    memoryASet32(ds, r32[esp], r32[eax]);
    if (memoryAGet(ds, r32[eax]) != 0x6e)
        { pc = 0x1e5bf0; break; }
    r32[eax] = r32[esi];
    r32[edx] = r32[edi];
    r32[ebx] = r32[ebp];
    yield* sub_1e5e92();
  case 0x1e5bf0: // 0160:1e5bf0
    if (memoryAGet32(ds, r32[esp] + 0x4))
        { pc = 0x1e5c04; break; }
    if (!(memoryAGet(ds, r32[esi] + 0x10) & 0x02))
        { pc = 0x1e5c04; break; }
    r32[eax] = 0xffffffff;
    { pc = 0x1e5c08; break; }
  case 0x1e5c04: // 0160:1e5c04
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x4);
  case 0x1e5c08: // 0160:1e5c08
    r32[esp] += 0x00000008;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5c10() // 0160:1e5c10 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esp] -= 0x00000004;
    r32[ebx] = r32[edx];
    r8[dl] = memoryAGet(ds, r32[edx] + 0x10);
    r8[dl] |= 0x01;
    memoryASet32(ds, r32[ebx] + 0xc, 0xffffffff);
    r8[dh] = r8[dl];
    memoryASet(ds, r32[ebx] + 0x10, r8[dl]);
    r8[dh] &= 0x03;
    memoryASet(ds, r32[ebx] + 0x10, r8[dh]);
    if (memoryAGet(ds, r32[eax]) != 0x2a)
        { pc = 0x1e5c3f; break; }
    r8[ch] = memoryAGet(ds, r32[ebx] + 0x10);
    r8[ch] &= 0xfe;
    r32[eax]++;
    memoryASet(ds, r32[ebx] + 0x10, r8[ch]);
  case 0x1e5c3f: // 0160:1e5c3f
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax]);
    memoryASet32(ds, r32[esp], r32[edx]);
    r8[dl] = memoryAGet(ds, r32[esp]);
    r8[dl]++;
    r32[edx] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[edx] + 0x20b628) & 0x20))
        { pc = 0x1e5c82; break; }
    r32[edx] = 0;
  case 0x1e5c5c: // 0160:1e5c5c
    r32[edx] = r32s[edx] * signed32(0x0000000a);
    r32[esi] = memoryAGet32(ds, r32[esp]);
    r32[esi] -= 0x00000030;
    r32[eax]++;
    r32[edx] += r32[esi];
    r32[esi] = memoryAGet(ds, r32[eax]);
    memoryASet32(ds, r32[esp], r32[esi]);
    r8[cl] = memoryAGet(ds, r32[esp]);
    r8[cl]++;
    r32[esi] = r8[cl];
    if (memoryAGet(ds, r32[esi] + 0x20b628) & 0x20)
        { pc = 0x1e5c5c; break; }
    memoryASet32(ds, r32[ebx] + 0xc, r32[edx]);
  case 0x1e5c82: // 0160:1e5c82
    r8[cl] = memoryAGet(ds, r32[eax]);
    r32[edx] = r32[eax] + 1;
    if (r8[cl] != 0x4e)
        { pc = 0x1e5c92; break; }
    memoryASet(ds, r32[ebx] + 0x10, memoryAGet(ds, r32[ebx] + 0x10) | 0x08);
    { pc = 0x1e5c9b; break; }
  case 0x1e5c92: // 0160:1e5c92
    if (r8[cl] != 0x46)
        { pc = 0x1e5c9d; break; }
    memoryASet(ds, r32[ebx] + 0x10, memoryAGet(ds, r32[ebx] + 0x10) | 0x04);
  case 0x1e5c9b: // 0160:1e5c9b
    r32[eax] = r32[edx];
  case 0x1e5c9d: // 0160:1e5c9d
    r8[cl] = memoryAGet(ds, r32[eax]);
    r32[edx] = r32[eax] + 1;
    if (r8[cl] < 0x68)
        { pc = 0x1e5cb7; break; }
    if (r8[cl] <= 0x68)
        { pc = 0x1e5cbe; break; }
    if (r8[cl] < 0x6c)
        { pc = 0x1e5ce2; break; }
    if (r8[cl] <= 0x6c)
        { pc = 0x1e5ccb; break; }
    if (r8[cl] == 0x77)
        { pc = 0x1e5ccb; break; }
    { pc = 0x1e5ce2; break; }
  case 0x1e5cb7: // 0160:1e5cb7
    if (r8[cl] == 0x4c)
        { pc = 0x1e5cd7; break; }
    { pc = 0x1e5ce2; break; }
  case 0x1e5cbe: // 0160:1e5cbe
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x10);
    r8[cl] |= 0x10;
    r32[eax] = r32[edx];
    memoryASet(ds, r32[ebx] + 0x10, r8[cl]);
    { pc = 0x1e5ce2; break; }
  case 0x1e5ccb: // 0160:1e5ccb
    r8[dl] = memoryAGet(ds, r32[ebx] + 0x10);
    r8[dl] |= 0x20;
    r32[eax]++;
    memoryASet(ds, r32[ebx] + 0x10, r8[dl]);
    { pc = 0x1e5ce2; break; }
  case 0x1e5cd7: // 0160:1e5cd7
    r8[ch] = memoryAGet(ds, r32[ebx] + 0x10);
    r8[ch] |= 0x40;
    r32[eax] = r32[edx];
    memoryASet(ds, r32[ebx] + 0x10, r8[ch]);
  case 0x1e5ce2: // 0160:1e5ce2
    r32[esp] += 0x00000004;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5ce9() // 0160:1e5ce9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    r32[ebx] = r32[eax];
    r32[ecx] = 0;
  case 0x1e5cf1: // 0160:1e5cf1
    r32[eax] = r32[ebx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ebx]));
    r32[esi] = r32[eax];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x02))
        { pc = 0x1e5d0a; break; }
    r32[ecx]++;
    { pc = 0x1e5cf1; break; }
  case 0x1e5d0a: // 0160:1e5d0a
    if (memoryAGet(ds, r32[ebx] + 0x10) & 0x02)
        { pc = 0x1e5d17; break; }
    r32[eax] = r32[esi];
    r32[edx] = r32[ebx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ebx] + 0x4));
  case 0x1e5d17: // 0160:1e5d17
    r32[eax] = r32[ecx];
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5d1e() // 0160:1e5d1e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    r32[ebx] = r32[eax];
    if (!(memoryAGet(ds, r32[eax] + 0x10) & 0x01))
        { pc = 0x1e5d62; break; }
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x10);
    if (!(r8[cl] & 0x04))
        { pc = 0x1e5d3f; break; }
    r32[edi] = memoryAGet32(ds, r32[edx]);
    r32[edi] += 0x00000008;
    memoryASet32(ds, r32[edx], r32[edi]);
    r32[ecx] = memoryAGet32(ds, r32[edi] - 8); es = memoryAGet32(ds, r32[edi] - 6);
    { pc = 0x1e5d62; break; }
  case 0x1e5d3f: // 0160:1e5d3f
    if (!(r8[cl] & 0x08))
        { pc = 0x1e5d54; break; }
    r32[esi] = memoryAGet32(ds, r32[edx]);
    r32[esi] += 0x00000004;
    r32[eax] = ds;
    memoryASet32(ds, r32[edx], r32[esi]);
    es = r32[eax];
    r32[ecx] = memoryAGet32(ds, r32[esi] - 4);
    { pc = 0x1e5d62; break; }
  case 0x1e5d54: // 0160:1e5d54
    r32[ecx] = memoryAGet32(ds, r32[edx]);
    r32[ecx] += 0x00000004;
    r32[eax] = ds;
    memoryASet32(ds, r32[edx], r32[ecx]);
    es = r32[eax];
    r32[ecx] = memoryAGet32(ds, r32[ecx] - 4);
  case 0x1e5d62: // 0160:1e5d62
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0xc);
    r32[esi] = 0;
    if (r32[edx] != 0xffffffff)
        { pc = 0x1e5d71; break; }
    r32[edx] = 0x00000001;
  case 0x1e5d71: // 0160:1e5d71
    if (r32s[edx] <= 0)
        { pc = 0x1e5d9c; break; }
    r32[eax] = r32[ebx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ebx]));
    if (memoryAGet(ds, r32[ebx] + 0x10) & 0x02)
        { pc = 0x1e5d9c; break; }
    r32[esi]++;
    r32[edx]--;
    if (!(memoryAGet(ds, r32[ebx] + 0x10) & 0x01))
        { pc = 0x1e5d71; break; }
    if (!(memoryAGet(ds, r32[ebx] + 0x10) & 0x20))
        { pc = 0x1e5d96; break; }
    memoryASet16(es, r32[ecx], r16[ax]);
    r32[ecx] += 0x00000002;
    { pc = 0x1e5d71; break; }
  case 0x1e5d96: // 0160:1e5d96
    memoryASet(es, r32[ecx], r8[al]);
    r32[ecx]++;
    { pc = 0x1e5d71; break; }
  case 0x1e5d9c: // 0160:1e5d9c
    r32[eax] = r32[esi];
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5da4() // 0160:1e5da4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e5da4; break; }
  case 0x1e5d9e: // 0160:1e5d9e
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e5da4: // 0160:1e5da4
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    r32[esp] -= 0x00000004;
    r32[ebx] = r32[eax];
    if (!(memoryAGet(ds, r32[eax] + 0x10) & 0x20))
        { pc = 0x1e5dba; break; }
    memoryASet(ds, r32[esp], 0x02);
    { pc = 0x1e5dc2; break; }
  case 0x1e5dba: // 0160:1e5dba
    memoryASet(ds, r32[esp], 0x01);
  case 0x1e5dc2: // 0160:1e5dc2
    r8[al] = memoryAGet(ds, r32[ebx] + 0x10);
    if (!(r8[al] & 0x01))
        { pc = 0x1e5dfb; break; }
    if (!(r8[al] & 0x04))
        { pc = 0x1e5dd9; break; }
    r32[edi] = memoryAGet32(ds, r32[edx]);
    r32[edi] += 0x00000008;
    memoryASet32(ds, r32[edx], r32[edi]);
    r32[ecx] = memoryAGet32(ds, r32[edi] - 8); es = memoryAGet32(ds, r32[edi] - 6);
    { pc = 0x1e5dfb; break; }
  case 0x1e5dd9: // 0160:1e5dd9
    if (!(r8[al] & 0x08))
        { pc = 0x1e5ded; break; }
    r32[esi] = memoryAGet32(ds, r32[edx]);
    r32[esi] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[esi]);
    r32[edx] = ds;
    es = r32[edx];
    r32[ecx] = memoryAGet32(ds, r32[esi] - 4);
    { pc = 0x1e5dfb; break; }
  case 0x1e5ded: // 0160:1e5ded
    r32[ecx] = memoryAGet32(ds, r32[edx]);
    r32[ecx] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ecx]);
    r32[edx] = ds;
    es = r32[edx];
    r32[ecx] = memoryAGet32(ds, r32[ecx] - 4);
  case 0x1e5dfb: // 0160:1e5dfb
    r32[esi] = 0;
  case 0x1e5dfd: // 0160:1e5dfd
    r32[eax] = r32[ebx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ebx]));
    r32[edx] = r32[eax];
    r8[al]++;
    r32[edi] = r8[al];
    if (!(memoryAGet(ds, r32[edi] + 0x20b628) & 0x02))
        { pc = 0x1e5e14; break; }
    r32[esi]++;
    { pc = 0x1e5dfd; break; }
  case 0x1e5e14: // 0160:1e5e14
    if (!(memoryAGet(ds, r32[ebx] + 0x10) & 0x02))
        { pc = 0x1e5e1e; break; }
    r32[esi] = 0;
    { pc = 0x1e5e6c; break; }
  case 0x1e5e1e: // 0160:1e5e1e
    r32[edi] = memoryAGet32(ds, r32[ebx] + 0xc);
    r32[eax] = r32[edi] - 1;
    memoryASet32(ds, r32[ebx] + 0xc, r32[eax]);
    if (!r32[edi])
        { pc = 0x1e5e65; break; }
  case 0x1e5e2b: // 0160:1e5e2b
    r8[al] = memoryAGet(ds, r32[ebx] + 0x10);
    r32[esi]++;
    if (!(r8[al] & 0x01))
        { pc = 0x1e5e49; break; }
    if (memoryAGet(ds, r32[esp]) != 0x01)
        { pc = 0x1e5e3e; break; }
    memoryASet(es, r32[ecx], r8[dl]);
    { pc = 0x1e5e42; break; }
  case 0x1e5e3e: // 0160:1e5e3e
    memoryASet16(es, r32[ecx], r16[dx]);
  case 0x1e5e42: // 0160:1e5e42
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[esp]);
    r32[ecx] += r32[edx];
  case 0x1e5e49: // 0160:1e5e49
    r32[eax] = r32[ebx];
    yield* sub_1e6516();
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e5e6c; break; }
    r8[al]++;
    r32[edi] = r8[al];
    if (!(memoryAGet(ds, r32[edi] + 0x20b628) & 0x02))
        { pc = 0x1e5e2b; break; }
  case 0x1e5e65: // 0160:1e5e65
    r32[eax] = r32[edx];
    r32[edx] = r32[ebx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ebx] + 0x4));
  case 0x1e5e6c: // 0160:1e5e6c
    if (!(memoryAGet(ds, r32[ebx] + 0x10) & 0x01))
        { pc = 0x1e5e88; break; }
    if (r32s[esi] <= 0)
        { pc = 0x1e5e88; break; }
    if (memoryAGet(ds, r32[esp]) != 0x01)
        { pc = 0x1e5e82; break; }
    memoryASet(es, r32[ecx], 0x00);
    { pc = 0x1e5e88; break; }
  case 0x1e5e82: // 0160:1e5e82
    memoryASet16(es, r32[ecx], 0x0000);
  case 0x1e5e88: // 0160:1e5e88
    r32[eax] = r32[esi];
    r32[esp] += 0x00000004;
    { pc = 0x1e5d9e; break; }
    return;
  }
}
function* sub_1e5e92() // 0160:1e5e92 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    r8[cl] = memoryAGet(ds, r32[eax] + 0x10);
    if (!(r8[cl] & 0x01))
        { pc = 0x1e5eeb; break; }
    if (!(r8[cl] & 0x04))
        { pc = 0x1e5eaf; break; }
    r32[edi] = memoryAGet32(ds, r32[edx]);
    r32[edi] += 0x00000008;
    memoryASet32(ds, r32[edx], r32[edi]);
    r32[edx] = memoryAGet32(ds, r32[edi] - 8); es = memoryAGet32(ds, r32[edi] - 6);
    { pc = 0x1e5ed4; break; }
  case 0x1e5eaf: // 0160:1e5eaf
    if (!(r8[cl] & 0x08))
        { pc = 0x1e5ec4; break; }
    r32[esi] = memoryAGet32(ds, r32[edx]);
    r32[esi] += 0x00000004;
    r32[ecx] = ds;
    memoryASet32(ds, r32[edx], r32[esi]);
    es = r32[ecx];
    r32[edx] = memoryAGet32(ds, r32[esi] - 4);
    { pc = 0x1e5ed4; break; }
  case 0x1e5ec4: // 0160:1e5ec4
    r32[ecx] = memoryAGet32(ds, r32[edx]);
    r32[ecx] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ecx]);
    r32[edx] = r32[ecx];
    r32[ecx] = ds;
    es = r32[ecx];
    r32[edx] = memoryAGet32(ds, r32[edx] - 4);
  case 0x1e5ed4: // 0160:1e5ed4
    r8[ch] = memoryAGet(ds, r32[eax] + 0x10);
    if (!(r8[ch] & 0x10))
        { pc = 0x1e5ee5; break; }
    memoryASet16(es, r32[edx], r16[bx]);
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e5ee5: // 0160:1e5ee5
    memoryASet32(es, r32[edx], r32[ebx]);
  case 0x1e5eeb: // 0160:1e5eeb
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5ef0() // 0160:1e5ef0 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[ecx] = r32[eax];
    r32[esi] = r32[edx];
    r32[ebx] = 0x00000020;
    r32[eax] = r32[edx];
    r32[edx] = 0;
    yield* sub_1e3de0();
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[ecx]);
    r32[ecx]++;
    if (!r32[eax])
        { pc = 0x1e5f2d; break; }
  case 0x1e5f0e: // 0160:1e5f0e
    r32[edx] = r32[eax];
    r32[eax] &= 0x00000007;
    r32[edx] = sar32(r32[edx], 0x03);
    r8[al] = memoryAGet(ds, r32[eax] + 0x20b72c);
    memoryASet(ds, r32[edx] + r32[esi], memoryAGet(ds, r32[edx] + r32[esi]) | r8[al]);
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[ecx]);
    if (!r32[eax])
        { pc = 0x1e5f2d; break; }
    r32[ecx]++;
    if (r32[eax] != 0x0000005d)
        { pc = 0x1e5f0e; break; }
  case 0x1e5f2d: // 0160:1e5f2d
    r32[eax] = r32[ecx];
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e5f33() // 0160:1e5f33 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    r32[esp] -= 0x00000028;
    r32[ecx] = r32[eax];
    r32[edi] = r32[edx];
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    r8[dl] = memoryAGet(ds, r32[eax]) == 0x5e;
    r32[edx] &= 0x000000ff;
    memoryASet32(ds, r32[esp] + 0x20, r32[edx]);
    if (!r32[edx])
        { pc = 0x1e5f56; break; }
    r32[eax]++;
    memoryASet32(ds, r32[ebx], r32[eax]);
  case 0x1e5f56: // 0160:1e5f56
    r32[edx] = r32[esp];
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    yield* sub_1e5ef0();
    memoryASet32(ds, r32[ebx], r32[eax]);
    r8[bl] = memoryAGet(ds, r32[ecx] + 0x10);
    if (!(r8[bl] & 0x01))
        { pc = 0x1e5f9d; break; }
    if (!(r8[bl] & 0x04))
        { pc = 0x1e5f7a; break; }
    r32[esi] = memoryAGet32(ds, r32[edi]);
    r32[esi] += 0x00000008;
    memoryASet32(ds, r32[edi], r32[esi]);
    r16[tx] = memoryAGet32(ds, r32[esi] - 8); es = memoryAGet32(ds, r32[esi] - 6); r32[esi] = r16[tx];
    { pc = 0x1e5f9d; break; }
  case 0x1e5f7a: // 0160:1e5f7a
    if (!(r8[bl] & 0x08))
        { pc = 0x1e5f8f; break; }
    r32[ebx] = memoryAGet32(ds, r32[edi]);
    r32[ebx] += 0x00000004;
    r32[eax] = ds;
    memoryASet32(ds, r32[edi], r32[ebx]);
    es = r32[eax];
    r32[esi] = memoryAGet32(ds, r32[ebx] - 4);
    { pc = 0x1e5f9d; break; }
  case 0x1e5f8f: // 0160:1e5f8f
    r32[edx] = memoryAGet32(ds, r32[edi]);
    r32[edx] += 0x00000004;
    r32[eax] = ds;
    memoryASet32(ds, r32[edi], r32[edx]);
    es = r32[eax];
    r32[esi] = memoryAGet32(ds, r32[edx] - 4);
  case 0x1e5f9d: // 0160:1e5f9d
    r32[ebp] = memoryAGet32(ds, r32[esp] + 0x20);
    r32[edi] = 0;
    r32[ebx] = memoryAGet32(ds, r32[ecx] + 0xc);
    memoryASet32(ds, r32[esp] + 0x24, r32[edi]);
  case 0x1e5faa: // 0160:1e5faa
    if (r32[ebx] <= 0)
        { pc = 0x1e5ffb; break; }
    r32[eax] = r32[ecx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ecx]));
    r32[edx] = r32[eax];
    if (memoryAGet(ds, r32[ecx] + 0x10) & 0x02)
        { pc = 0x1e5ffb; break; }
    r32[edi] = r32[eax];
    r32[edx] &= 0x00000007;
    r32[edi] = sar32(r32[edi], 0x03);
    r8[dl] = memoryAGet(ds, r32[edx] + 0x20b72c);
    r32[edi] = memoryAGet(ds, r32[esp] + r32[edi]);
    r32[edx] &= 0x000000ff;
    r8[dl] = !(r32[edi] & r32[edx]);
    r32[edx] &= 0x000000ff;
    if (r32[edx] == r32[ebp])
        { pc = 0x1e5fe8; break; }
    r32[edx] = r32[ecx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ecx] + 0x4));
    { pc = 0x1e5ffb; break; }
  case 0x1e5fe8: // 0160:1e5fe8
    memoryASet32(ds, r32[esp] + 0x24, memoryAGet32(ds, r32[esp] + 0x24) + 1);
    r8[dl] = memoryAGet(ds, r32[ecx] + 0x10);
    r32[ebx]--;
    if (!(r8[dl] & 0x01))
        { pc = 0x1e5faa; break; }
    memoryASet(es, r32[esi], r8[al]);
    r32[esi]++;
    { pc = 0x1e5faa; break; }
  case 0x1e5ffb: // 0160:1e5ffb
    if (!(memoryAGet(ds, r32[ecx] + 0x10) & 0x01))
        { pc = 0x1e600c; break; }
    if (signed32(memoryAGet32(ds, r32[esp] + 0x24)) <= signed32(0x00000000))
        { pc = 0x1e600c; break; }
    memoryASet(es, r32[esi], 0x00);
  case 0x1e600c: // 0160:1e600c
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x24);
    r32[esp] += 0x00000028;
    r32[ebp] = pop32();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6019() // 0160:1e6019 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e6019; break; }
  case 0x1e5d9e: // 0160:1e5d9e
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
    // gap 629 bytes // gap 629 bytes
  case 0x1e6019: // 0160:1e6019
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    r32[esp] -= 0x00000070;
    r32[ecx] = r32[eax];
    memoryASet32(ds, r32[esp] + 0x58, r32[edx]);
    r32[edi] = 0;
    r32[esi] = r32[esp];
    memoryASet32(ds, r32[esp] + 0x6c, r32[edi]);
  case 0x1e6030: // 0160:1e6030
    r32[eax] = r32[ecx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ecx]));
    r32[ebp] = r32[eax];
    r32[ebx] = r32[eax];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x02))
        { pc = 0x1e604e; break; }
    memoryASet32(ds, r32[esp] + 0x6c, memoryAGet32(ds, r32[esp] + 0x6c) + 1);
    { pc = 0x1e6030; break; }
  case 0x1e604e: // 0160:1e604e
    if (memoryAGet(ds, r32[ecx] + 0x10) & 0x02)
        { pc = 0x1e6239; break; }
    r32[eax] = memoryAGet32(ds, r32[ecx] + 0xc);
    r32[edx] = r32[eax] - 1;
    memoryASet32(ds, r32[ecx] + 0xc, r32[edx]);
    if (!r32[eax])
        { pc = 0x1e6232; break; }
    if (r32[ebp] == 0x0000002b)
        { pc = 0x1e6073; break; }
    if (r32[ebp] != 0x0000002d)
        { pc = 0x1e6091; break; }
  case 0x1e6073: // 0160:1e6073
    r32[ebp] = memoryAGet32(ds, r32[esp] + 0x6c);
    r32[eax] = r32[ecx];
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1e6516();
    r32[esi]++;
    r32[ebp]++;
    r32[ebx] = r32[eax];
    memoryASet32(ds, r32[esp] + 0x6c, r32[ebp]);
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e6239; break; }
  case 0x1e6091: // 0160:1e6091
    r8[al] = r8[bl];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (memoryAGet(ds, r32[eax] + 0x20b628) & 0x20)
        { pc = 0x1e60ac; break; }
    if (r32[ebx] != 0x0000002e)
        { pc = 0x1e6232; break; }
  case 0x1e60ac: // 0160:1e60ac
    r32[eax] = 0;
    memoryASet32(ds, r32[esp] + 0x68, r32[eax]);
    memoryASet32(ds, r32[esp] + 0x5c, r32[eax]);
    r8[al] = r8[bl];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x20))
        { pc = 0x1e610c; break; }
    memoryASet32(ds, r32[esp] + 0x5c, 0x00000001);
  case 0x1e60d0: // 0160:1e60d0
    memoryASet(ds, r32[esi], r8[bl]);
    r8[al] = memoryAGet(ds, r32[ecx] + 0x10);
    r32[esi]++;
    if (!(r8[al] & 0x10))
        { pc = 0x1e60e9; break; }
    r32[eax] = (signed32(memoryAGet32(ds, r32[esp] + 0x6a))) * signed32(0x0000000a);
    r32[ebx] += r32[eax];
    r32[ebx] -= 0x00000030;
    memoryASet16(ds, r32[esp] + 0x6a, r16[bx]);
  case 0x1e60e9: // 0160:1e60e9
    r32[eax] = r32[ecx];
    r32[edi]++;
    yield* sub_1e6516();
    r32[ebx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e6239; break; }
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (memoryAGet(ds, r32[eax] + 0x20b628) & 0x20)
        { pc = 0x1e60d0; break; }
  case 0x1e610c: // 0160:1e610c
    if (r32[ebx] != 0x0000002e)
        { pc = 0x1e61b2; break; }
    r32[eax] = r32[ecx];
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1e6516();
    r32[esi]++;
    r32[ebx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e6239; break; }
    if (memoryAGet32(ds, r32[esp] + 0x5c))
        { pc = 0x1e6147; break; }
    r8[al] = r8[bl];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x20))
        { pc = 0x1e6232; break; }
  case 0x1e6147: // 0160:1e6147
    r32[edi]++;
  case 0x1e6148: // 0160:1e6148
    r8[al] = r8[bl];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x20))
        { pc = 0x1e616c; break; }
    r32[edi]++;
    r32[eax] = r32[ecx];
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1e6516();
    r32[esi]++;
    r32[ebx] = r32[eax];
    if (r32[eax] != 0xffffffff)
        { pc = 0x1e6148; break; }
  case 0x1e616c: // 0160:1e616c
    if (!(memoryAGet(ds, r32[ecx] + 0x10) & 0x10))
        { pc = 0x1e61a9; break; }
    r32[edx] = 0;
    r32[ebp] = r32[esi];
    memoryASet32(ds, r32[esp] + 0x64, r32[edx]);
  case 0x1e617a: // 0160:1e617a
    r32[ebp]--;
    r8[al] = memoryAGet(ss, r32[ebp]);
    if (r8[al] == 0x2e)
        { pc = 0x1e61a0; break; }
    r8[al] -= 0x30;
    memoryASet32(ds, r32[esp] + 0x60, 0x0000000a);
    memoryASet(ds, r32[esp] + 0x66, r8[al]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x64);
    div32(memoryAGet32(ds, r32[esp] + 0x60));
    memoryASet32(ds, r32[esp] + 0x64, r32[eax]);
    { pc = 0x1e617a; break; }
  case 0x1e61a0: // 0160:1e61a0
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x64);
    memoryASet16(ds, r32[esp] + 0x68, r16[ax]);
  case 0x1e61a9: // 0160:1e61a9
    if (r32[ebx] == 0xffffffff)
        { pc = 0x1e6239; break; }
  case 0x1e61b2: // 0160:1e61b2
    if (memoryAGet(ds, r32[ecx] + 0x10) & 0x10)
        { pc = 0x1e6232; break; }
    if (r32[ebx] == 0x00000065)
        { pc = 0x1e61ca; break; }
    if (r32[ebx] != 0x00000045)
        { pc = 0x1e6232; break; }
  case 0x1e61ca: // 0160:1e61ca
    r32[edi]++;
    r32[eax] = r32[ecx];
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1e6516();
    r32[esi]++;
    r32[ebp] = r32[eax];
    r32[ebx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e6239; break; }
    if (r32[eax] == 0x0000002b)
        { pc = 0x1e61e8; break; }
    if (r32[eax] != 0x0000002d)
        { pc = 0x1e61fa; break; }
  case 0x1e61e8: // 0160:1e61e8
    r32[edi]++;
    r32[eax] = r32[ecx];
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1e6516();
    r32[esi]++;
    r32[ebx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e6239; break; }
  case 0x1e61fa: // 0160:1e61fa
    r8[al] = r8[bl];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (memoryAGet(ds, r32[eax] + 0x20b628) & 0x20)
        { pc = 0x1e6210; break; }
    r32[edi] = 0;
    { pc = 0x1e6232; break; }
  case 0x1e6210: // 0160:1e6210
    r32[edi]++;
    r32[eax] = r32[ecx];
    memoryASet(ds, r32[esi], r8[bl]);
    yield* sub_1e6516();
    r32[esi]++;
    r32[ebx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e6239; break; }
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (memoryAGet(ds, r32[eax] + 0x20b628) & 0x20)
        { pc = 0x1e6210; break; }
  case 0x1e6232: // 0160:1e6232
    r32[eax] = r32[ebx];
    r32[edx] = r32[ecx];
    yield* indirectCall(cs, memoryAGet32(ds, r32[ecx] + 0x4));
  case 0x1e6239: // 0160:1e6239
    if (r32s[edi] <= 0)
        { pc = 0x1e62ec; break; }
    r32[edi] += memoryAGet32(ds, r32[esp] + 0x6c);
    if (!(memoryAGet(ds, r32[ecx] + 0x10) & 0x01))
        { pc = 0x1e62ec; break; }
    memoryASet(ds, r32[esi], 0x00);
    if (!(memoryAGet(ds, r32[ecx] + 0x10) & 0x10))
        { pc = 0x1e6264; break; }
    if (memoryAGet(ds, r32[esp]) != 0x2d)
        { pc = 0x1e6270; break; }
    memoryASet32(ds, r32[esp] + 0x68, -memoryAGet32(ds, r32[esp] + 0x68));
    { pc = 0x1e6270; break; }
  case 0x1e6264: // 0160:1e6264
    r32[eax] = r32[esp];
    r32[edx] = r32[esp] + 80;
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a838));
  case 0x1e6270: // 0160:1e6270
    r8[ah] = memoryAGet(ds, r32[ecx] + 0x10);
    if (!(r8[ah] & 0x04))
        { pc = 0x1e6288; break; }
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x58);
    r32[ebx] = memoryAGet32(ds, r32[eax]);
    r32[ebx] += 0x00000008;
    memoryASet32(ds, r32[eax], r32[ebx]);
    r16[tx] = memoryAGet32(ds, r32[ebx] - 8); es = memoryAGet32(ds, r32[ebx] - 6); r32[ebx] = r16[tx];
    { pc = 0x1e62b3; break; }
  case 0x1e6288: // 0160:1e6288
    if (!(r8[ah] & 0x08))
        { pc = 0x1e62a1; break; }
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x58);
    r32[edx] = memoryAGet32(ds, r32[eax]);
    r32[edx] += 0x00000004;
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[eax] = ds;
    es = r32[eax];
    r32[ebx] = memoryAGet32(ds, r32[edx] - 4);
    { pc = 0x1e62b3; break; }
  case 0x1e62a1: // 0160:1e62a1
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x58);
    r32[ebp] = memoryAGet32(ds, r32[eax]);
    r32[ebp] += 0x00000004;
    memoryASet32(ds, r32[eax], r32[ebp]);
    r32[eax] = ds;
    es = r32[eax];
    r32[ebx] = memoryAGet32(ss, r32[ebp] - 4);
  case 0x1e62b3: // 0160:1e62b3
    r8[dh] = memoryAGet(ds, r32[ecx] + 0x10);
    if (!(r8[dh] & 0x10))
        { pc = 0x1e62c1; break; }
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x68);
    { pc = 0x1e62e9; break; }
  case 0x1e62c1: // 0160:1e62c1
    if (r8[dh] & 0x20)
        { pc = 0x1e62cb; break; }
    if (!(r8[dh] & 0x40))
        { pc = 0x1e62dc; break; }
  case 0x1e62cb: // 0160:1e62cb
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x50);
    memoryASet32(es, r32[ebx], r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x54);
    memoryASet32(es, r32[ebx] + 0x4, r32[eax]);
    { pc = 0x1e62ec; break; }
  case 0x1e62dc: // 0160:1e62dc
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x50);
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x54);
    yield* sub_1eaf20();
  case 0x1e62e9: // 0160:1e62e9
    memoryASet32(es, r32[ebx], r32[eax]);
  case 0x1e62ec: // 0160:1e62ec
    r32[eax] = r32[edi];
    r32[esp] += 0x00000070;
    r32[ebp] = pop32();
    { pc = 0x1e5d9e; break; }
    return;
  }
}
function* sub_1e62f7() // 0160:1e62f7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    r32[esp] -= 0x00000010;
    r32[esi] = r32[eax];
    memoryASet32(ds, r32[esp] + 0xc, r32[edx]);
    r32[edi] = r32[ebx];
    memoryASet32(ds, r32[esp] + 0x4, r32[ecx]);
    r32[edx] = 0;
    r32[ebx] = 0;
    r32[ebp] = 0;
    memoryASet32(ds, r32[esp] + 0x8, r32[edx]);
  case 0x1e6314: // 0160:1e6314
    r32[eax] = r32[esi];
    switch (memoryAGet32(ds, r32[esi]))
    {
        case 0x001e3d6a: yield* sub_1e3d6a(); break;
        default:
            stop("ind 0160:1e6316");
    }
    r32[edx] = r32[eax];
    r8[al]++;
    r32[eax] &= 0x000000ff;
    if (!(memoryAGet(ds, r32[eax] + 0x20b628) & 0x02))
        { pc = 0x1e632d; break; }
    r32[ebp]++;
    { pc = 0x1e6314; break; }
  case 0x1e632d: // 0160:1e632d
    if (memoryAGet(ds, r32[esi] + 0x10) & 0x02)
        { pc = 0x1e646d; break; }
    r32[eax] = memoryAGet32(ds, r32[esi] + 0xc);
    r32[ecx] = r32[eax] - 1;
    memoryASet32(ds, r32[esi] + 0xc, r32[ecx]);
    if (!r32[eax])
        { pc = 0x1e6466; break; }
    r32[ecx] = 0x0000002b;
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x4);
    memoryASet32(ds, r32[esp], r32[ecx]);
    if (!r32[eax])
        { pc = 0x1e6378; break; }
    if (r32[edx] == 0x0000002b)
        { pc = 0x1e6362; break; }
    if (r32[edx] != 0x0000002d)
        { pc = 0x1e6378; break; }
  case 0x1e6362: // 0160:1e6362
    memoryASet32(ds, r32[esp], r32[edx]);
    r32[eax] = r32[esi];
    r32[ebp]++;
    yield* sub_1e6516();
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e646d; break; }
  case 0x1e6378: // 0160:1e6378
    if (r32[edi])
        { pc = 0x1e63d0; break; }
    if (r32[edx] != 0x00000030)
        { pc = 0x1e63c9; break; }
    r32[eax] = r32[esi];
    r32[ebx] = 0x00000001;
    yield* sub_1e6516();
    r32[ecx] = r32[eax];
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e646d; break; }
    if (r32[eax] == 0x00000078)
        { pc = 0x1e63a4; break; }
    if (r32[eax] != 0x00000058)
        { pc = 0x1e63c2; break; }
  case 0x1e63a4: // 0160:1e63a4
    r32[eax] = r32[esi];
    r32[ebp] += 0x00000002;
    yield* sub_1e6516();
    r32[ebx] = 0;
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e646d; break; }
    r32[edi] = 0x00000010;
    { pc = 0x1e6410; break; }
  case 0x1e63c2: // 0160:1e63c2
    r32[edi] = 0x00000008;
    { pc = 0x1e6410; break; }
  case 0x1e63c9: // 0160:1e63c9
    r32[edi] = 0x0000000a;
    { pc = 0x1e6410; break; }
  case 0x1e63d0: // 0160:1e63d0
    if (r32[edi] != 0x00000010)
        { pc = 0x1e6410; break; }
    if (r32[edx] != 0x00000030)
        { pc = 0x1e6410; break; }
    r32[eax] = r32[esi];
    r32[ebx] = 0x00000001;
    yield* sub_1e6516();
    r32[ecx] = r32[eax];
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e646d; break; }
    if (r32[eax] == 0x00000078)
        { pc = 0x1e63fd; break; }
    if (r32[eax] != 0x00000058)
        { pc = 0x1e6410; break; }
  case 0x1e63fd: // 0160:1e63fd
    r32[eax] = r32[esi];
    r32[ebp] += 0x00000002;
    yield* sub_1e6516();
    r32[ebx] = 0;
  case 0x1e6409: // 0160:1e6409
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e646d; break; }
  case 0x1e6410: // 0160:1e6410
    r32[eax] = r32[edx];
    yield* sub_1e64ef();
    if (r32s[eax] >= r32s[edi])
        { pc = 0x1e6432; break; }
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x8);
    r32[edx] = r32s[edx] * r32s[edi];
    r32[ebx]++;
    r32[edx] += r32[eax];
    r32[eax] = r32[esi];
    memoryASet32(ds, r32[esp] + 0x8, r32[edx]);
    yield* sub_1e6516();
    { pc = 0x1e6409; break; }
  case 0x1e6432: // 0160:1e6432
    if (r32[edx] != 0x0000003a)
        { pc = 0x1e6466; break; }
    if (!(memoryAGet(ds, r32[esi] + 0x10) & 0x80))
        { pc = 0x1e6466; break; }
  case 0x1e643d: // 0160:1e643d
    r32[eax] = r32[esi];
    r32[ebx]++;
    yield* sub_1e6516();
    r32[ecx] = r32[eax];
    r32[edx] = r32[eax];
    if (r32[eax] == 0xffffffff)
        { pc = 0x1e646d; break; }
    yield* sub_1e64ef();
    if (r32s[eax] >= r32s[edi])
        { pc = 0x1e6466; break; }
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x8);
    r32[edx] = r32s[edx] * r32s[edi];
    r32[edx] += r32[eax];
    memoryASet32(ds, r32[esp] + 0x8, r32[edx]);
    { pc = 0x1e643d; break; }
  case 0x1e6466: // 0160:1e6466
    r32[eax] = r32[edx];
    r32[edx] = r32[esi];
    switch (memoryAGet32(ds, r32[esi] + 0x4))
    {
        case 0x001e3d93: yield* sub_1e3d93(); break;
        default:
            stop("ind 0160:1e646a");
    }
  case 0x1e646d: // 0160:1e646d
    if (memoryAGet32(ds, r32[esp]) != 0x0000002d)
        { pc = 0x1e6477; break; }
    memoryASet32(ds, r32[esp] + 0x8, -memoryAGet32(ds, r32[esp] + 0x8));
  case 0x1e6477: // 0160:1e6477
    if (r32s[ebx] <= 0)
        { pc = 0x1e64e5; break; }
    r8[ah] = memoryAGet(ds, r32[esi] + 0x10);
    r32[ebx] += r32[ebp];
    if (!(r8[ah] & 0x01))
        { pc = 0x1e64e5; break; }
    if (!(r8[ah] & 0x04))
        { pc = 0x1e649e; break; }
    r32[eax] = memoryAGet32(ds, r32[esp] + 0xc);
    r32[edx] = memoryAGet32(ds, r32[eax]);
    r32[edx] += 0x00000008;
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[eax] = memoryAGet32(ds, r32[edx] - 8); es = memoryAGet32(ds, r32[edx] - 6);
    { pc = 0x1e64c9; break; }
  case 0x1e649e: // 0160:1e649e
    if (!(r8[ah] & 0x08))
        { pc = 0x1e64b7; break; }
    r32[eax] = memoryAGet32(ds, r32[esp] + 0xc);
    r32[ebp] = memoryAGet32(ds, r32[eax]);
    r32[ebp] += 0x00000004;
    r32[edx] = ds;
    memoryASet32(ds, r32[eax], r32[ebp]);
    es = r32[edx];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    { pc = 0x1e64c9; break; }
  case 0x1e64b7: // 0160:1e64b7
    r32[eax] = memoryAGet32(ds, r32[esp] + 0xc);
    r32[edi] = memoryAGet32(ds, r32[eax]);
    r32[edi] += 0x00000004;
    r32[edx] = ds;
    memoryASet32(ds, r32[eax], r32[edi]);
    es = r32[edx];
    r32[eax] = memoryAGet32(ds, r32[edi] - 4);
  case 0x1e64c9: // 0160:1e64c9
    r8[cl] = memoryAGet(ds, r32[esi] + 0x10);
    if (!(r8[cl] & 0x10))
        { pc = 0x1e64db; break; }
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x8);
    memoryASet16(es, r32[eax], r16[dx]);
    { pc = 0x1e64e5; break; }
  case 0x1e64db: // 0160:1e64db
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x8);
    memoryASet32(es, r32[eax], r32[edx]);
  case 0x1e64e5: // 0160:1e64e5
    r32[eax] = r32[ebx];
    r32[esp] += 0x00000010;
    r32[ebp] = pop32();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e64ef() // 0160:1e64ef +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[eax] < signed32(0x00000030))
        { pc = 0x1e64fd; break; }
    if (r32s[eax] > signed32(0x00000039))
        { pc = 0x1e64fd; break; }
    r32[eax] -= 0x00000030;
    r32[esp] += 4; return;
  case 0x1e64fd: // 0160:1e64fd
    yield* sub_1e65e3();
    if (r32s[eax] < signed32(0x00000061))
        { pc = 0x1e6510; break; }
    if (r32s[eax] > signed32(0x00000066))
        { pc = 0x1e6510; break; }
    r32[eax] -= 0x00000057;
    r32[esp] += 4; return;
  case 0x1e6510: // 0160:1e6510
    r32[eax] = 0x00000010;
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6516() // 0160:1e6516 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, r32[eax] + 0xc);
    r32[ebx] = r32[eax] - 1;
    memoryASet32(ds, r32[edx] + 0xc, r32[ebx]);
    if (!r32[eax])
        { pc = 0x1e6531; break; }
    r32[eax] = r32[edx];
    switch (memoryAGet32(ds, r32[edx]))
    {
        case 0x001e3d6a: yield* sub_1e3d6a(); break;
        default:
            stop("ind 0160:1e6529");
    }
    if (!(memoryAGet(ds, r32[edx] + 0x10) & 0x02))
        { pc = 0x1e6536; break; }
  case 0x1e6531: // 0160:1e6531
    r32[eax] = 0xffffffff;
  case 0x1e6536: // 0160:1e6536
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6540() // 0160:1e6540 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r32[ecx])
        { pc = 0x1e6570; break; }
  case 0x1e6546: // 0160:1e6546
    if (!(r8[al] & 0x03))
        { pc = 0x1e6553; break; }
    memoryASet(ds, r32[eax], r8[dl]);
    r32[eax]++;
    r32[edx] = ror32(r32[edx], 0x08);
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1e6546; break; }
  case 0x1e6553: // 0160:1e6553
    push32(r32[ecx]);
    r32[ecx] >>>= 2;
    yield* sub_1e6577();
    r32[ecx] = pop32();
    r32[ecx] &= 0x00000003;
    if (!r32[ecx])
        { pc = 0x1e6570; break; }
    memoryASet(ds, r32[eax], r8[dl]);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1e6570; break; }
    memoryASet(ds, r32[eax] + 0x1, r8[dh]);
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1e6570; break; }
    memoryASet(ds, r32[eax] + 0x2, r8[dl]);
  case 0x1e6570: // 0160:1e6570
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e6577() // 0160:1e6577 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!r32[ecx])
        { pc = 0x1e65e2; break; }
  case 0x1e657b: // 0160:1e657b
    if (!(r8[al] & 0x1f))
        { pc = 0x1e6587; break; }
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[eax] = r32[eax] + 4;
    r32[ecx]--;
    if (r32[ecx])
        { pc = 0x1e657b; break; }
  case 0x1e6587: // 0160:1e6587
    push32(r32[ecx]);
    r32[ecx] >>>= 2;
    if (!r32[ecx])
        { pc = 0x1e65c7; break; }
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1e65b9; break; }
  case 0x1e6590: // 0160:1e6590
    memoryASet32(ds, r32[eax], r32[edx]);
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
    r32[ecx]--;
    memoryASet32(ds, r32[eax] + 0x8, r32[edx]);
    memoryASet32(ds, r32[eax] + 0xc, r32[edx]);
    if (!r32[ecx])
        { pc = 0x1e65b6; break; }
    memoryASet32(ds, r32[eax] + 0x10, r32[edx]);
    memoryASet32(ds, r32[eax] + 0x14, r32[edx]);
    r32[ecx]--;
    memoryASet32(ds, r32[eax] + 0x18, r32[edx]);
    memoryASet32(ds, r32[eax] + 0x1c, r32[edx]);
    r32[eax] = r32[eax] + 32;
    if (r32[ecx])
        { pc = 0x1e6590; break; }
    r32[eax] = r32[eax] - 16;
  case 0x1e65b6: // 0160:1e65b6
    r32[eax] = r32[eax] + 16;
  case 0x1e65b9: // 0160:1e65b9
    memoryASet32(ds, r32[eax], r32[edx]);
    memoryASet32(ds, r32[eax] + 0x4, r32[edx]);
    memoryASet32(ds, r32[eax] + 0x8, r32[edx]);
    memoryASet32(ds, r32[eax] + 0xc, r32[edx]);
    r32[eax] = r32[eax] + 16;
  case 0x1e65c7: // 0160:1e65c7
    r32[ecx] = pop32();
    r32[ecx] &= 0x00000003;
    if (!r32[ecx])
        { pc = 0x1e65e2; break; }
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[eax] = r32[eax] + 4;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1e65e2; break; }
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[eax] = r32[eax] + 4;
    r32[ecx]--;
    if (!r32[ecx])
        { pc = 0x1e65e2; break; }
    memoryASet32(ds, r32[eax], r32[edx]);
    r32[eax] = r32[eax] + 4;
  case 0x1e65e2: // 0160:1e65e2
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e65e3() // 0160:1e65e3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[eax] < signed32(0x00000041))
        { pc = 0x1e65f0; break; }
    if (r32s[eax] > signed32(0x0000005a))
        { pc = 0x1e65f0; break; }
    r32[eax] += 0x00000020;
  case 0x1e65f0: // 0160:1e65f0
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1e6615() // 0160:1e6615 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esp] -= 0x0000000c;
    r32[esi] = memoryAGet32(ds, r32[esp] + 0x24);
  case 0x1e6621: // 0160:1e6621
    if (memoryAGet(ds, r32[esi]) != 0x20)
        { pc = 0x1e6629; break; }
    r32[esi]++;
    { pc = 0x1e6621; break; }
  case 0x1e6629: // 0160:1e6629
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x28);
    r32[eax] &= 0x00000083;
    memoryASet32(ds, r32[esp], r32[eax]);
    r8[dl] = memoryAGet(ds, r32[esp] + 0x2c);
    r8[al] = memoryAGet(ds, r32[esp]);
    r8[al] |= r8[dl];
    r32[edx] = r32[esi];
    r32[edi] = 0xffffffff;
    r8[ah] = 0x3d;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    memoryASet32(ds, r32[esp] + 0x4, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e665c; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, r32[esp] + 0x4);
  case 0x1e665c: // 0160:1e665c
    r8[dh] = memoryAGet(ds, r32[esp] + 0x28);
    if (!(r8[dh] & 0x03))
        { pc = 0x1e66d6; break; }
    if (r32[edi] == 0xffffffff)
        { pc = 0x1e66d6; break; }
    r32[eax] = r32[edi];
    yield* sub_1eaf6c();
    if (r32[eax])
        { pc = 0x1e66d6; break; }
    if (!(memoryAGet(ds, r32[esp] + 0x29) & 0x04))
        { pc = 0x1e669e; break; }
    r32[ebx] = r32[edi];
    r8[ah] = 0x3e;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    r32[eax] = 0x00000007;
    yield* sub_1e53d1();
    r32[eax] = 0xffffffff;
    { pc = 0x1e67d1; break; }
  case 0x1e669e: // 0160:1e669e
    if (!(r8[dh] & 0x40))
        { pc = 0x1e66d6; break; }
    r32[edx] = r32[esp] + 8;
    r32[ebx] = r32[edi];
    r32[ecx] = 0;
    r8[ah] = 0x40;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    memoryASet32(ds, r32[esp] + 0x4, r32[eax]);
    if (r32s[eax] >= 0)
        { pc = 0x1e66d6; break; }
    r32[ebx] = r32[edi];
    r8[ah] = 0x3e;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
  case 0x1e66c5: // 0160:1e66c5
    r32[eax] = 0;
    r16[ax] = memoryAGet16(ds, r32[esp] + 0x4);
    yield* sub_1e788d();
    { pc = 0x1e67d1; break; }
  case 0x1e66d6: // 0160:1e66d6
    if (r32[edi] != 0xffffffff)
        { pc = 0x1e6764; break; }
    if (!(memoryAGet(ds, r32[esp] + 0x28) & 0x20))
        { pc = 0x1e66c5; break; }
    if (memoryAGet16(ds, r32[esp] + 0x4) != 0x0002)
        { pc = 0x1e66c5; break; }
    r32[eax] = r32[esp] + 48;
    r32[eax] += 0x00000004;
    r32[eax] = memoryAGet32(ds, r32[eax] - 4);
    if (r32[eax])
        { pc = 0x1e6701; break; }
    r32[eax] = 0x00000180;
  case 0x1e6701: // 0160:1e6701
    r32[eax] ^= memoryAGet32(ds, 0x20a8c8);
    r32[ecx] = 0;
    if (r8[al] & 0x80)
        { pc = 0x1e6712; break; }
    r32[ecx] = 0x00000001;
  case 0x1e6712: // 0160:1e6712
    r32[edx] = r32[esi];
    r32[ecx] &= 0x000000ff;
    r8[ah] = 0x3c;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    memoryASet32(ds, r32[esp] + 0x4, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e66c5; break; }
    r32[ebx] = memoryAGet32(ds, r32[esp] + 0x4);
    r8[ah] = 0x3e;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    memoryASet32(ds, r32[esp] + 0x4, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e66c5; break; }
    r8[al] = memoryAGet(ds, r32[esp]);
    r8[ch] = memoryAGet(ds, r32[esp] + 0x2c);
    r32[edx] = r32[esi];
    r8[al] |= r8[ch];
    r8[ah] = 0x3d;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    memoryASet32(ds, r32[esp] + 0x4, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e66c5; break; }
    r32[edi] = 0;
    r16[di] = memoryAGet16(ds, r32[esp] + 0x4);
  case 0x1e6764: // 0160:1e6764
    r32[eax] = r32[edi];
    yield* sub_1eaf8a();
    r8[al] &= 0x3c;
    r32[edx] = r32[eax];
    r32[eax] = r32[edi];
    yield* sub_1eaf6c();
    if (!r32[eax])
        { pc = 0x1e677d; break; }
    r8[dh] |= 0x20;
  case 0x1e677d: // 0160:1e677d
    memoryASet(ds, r32[esp], memoryAGet(ds, r32[esp]) & 0x7f);
    if (memoryAGet32(ds, r32[esp]) != 0x00000002)
        { pc = 0x1e678a; break; }
    r8[dl] |= 0x03;
  case 0x1e678a: // 0160:1e678a
    if (memoryAGet32(ds, r32[esp]))
        { pc = 0x1e6793; break; }
    r8[dl] |= 0x01;
  case 0x1e6793: // 0160:1e6793
    if (memoryAGet32(ds, r32[esp]) != 0x00000001)
        { pc = 0x1e679c; break; }
    r8[dl] |= 0x02;
  case 0x1e679c: // 0160:1e679c
    if (!(memoryAGet(ds, r32[esp] + 0x28) & 0x10))
        { pc = 0x1e67a6; break; }
    r8[dl] |= 0x80;
  case 0x1e67a6: // 0160:1e67a6
    r32[eax] = r32[edx];
    r8[bl] = memoryAGet(ds, r32[esp] + 0x29);
    r8[al] |= 0x40;
    if (!(r8[bl] & 0x03))
        { pc = 0x1e67ba; break; }
    if (!(r8[bl] & 0x02))
        { pc = 0x1e67c8; break; }
    { pc = 0x1e67c6; break; }
  case 0x1e67ba: // 0160:1e67ba
    if (memoryAGet32(ds, 0x20a719) != 0x00000200)
        { pc = 0x1e67c8; break; }
  case 0x1e67c6: // 0160:1e67c6
    r32[edx] = r32[eax];
  case 0x1e67c8: // 0160:1e67c8
    r32[eax] = r32[edi];
    yield* sub_1eafdf();
    r32[eax] = r32[edi];
  case 0x1e67d1: // 0160:1e67d1
    r32[esp] += 0x0000000c;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e683f() // 0160:1e683f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = memoryAGet32(ds, 0x3164c8);
    if (!r32[esi])
        { pc = 0x1e6867; break; }
    r32[ecx] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[edi] = memoryAGet32(ds, r32[ecx] + 0xc);
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[edi] &= 0x00004003;
    memoryASet32(ds, 0x3164c8, r32[eax]);
    r16[di] |= 0x0003;
    { pc = 0x1e68b0; break; }
  case 0x1e6867: // 0160:1e6867
    r32[ecx] = 0x0020a510;
    { pc = 0x1e688e; break; }
  case 0x1e686e: // 0160:1e686e
    if (memoryAGet(ds, r32[ecx] + 0xc) & 0x03)
        { pc = 0x1e688b; break; }
    r32[eax] = 0x00000008;
    yield* sub_1e3562();
    r32[esi] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e68d5; break; }
    r32[edi] = 0x00000003;
    { pc = 0x1e68b0; break; }
  case 0x1e688b: // 0160:1e688b
    r32[ecx] += 0x0000001a;
  case 0x1e688e: // 0160:1e688e
    if (r32[ecx] < 0x0020a718)
        { pc = 0x1e686e; break; }
    r32[eax] = 0x00000022;
    r32[edi] = 0x00004003;
    yield* sub_1e3562();
    r32[ecx] = r32[eax];
    r32[esi] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e68d5; break; }
    r32[ecx] = r32[eax] + 8;
  case 0x1e68b0: // 0160:1e68b0
    r32[ebx] = 0x0000001a;
    r32[eax] = r32[ecx];
    r32[edx] = 0;
    yield* sub_1e3de0();
    memoryASet32(ds, r32[ecx] + 0xc, r32[edi]);
    r32[eax] = memoryAGet32(ds, 0x3164d0);
    memoryASet32(ds, r32[esi] + 0x4, r32[ecx]);
    memoryASet32(ds, 0x3164d0, r32[esi]);
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[eax] = r32[ecx];
    { pc = 0x1e68e1; break; }
  case 0x1e68d5: // 0160:1e68d5
    r32[eax] = 0x00000005;
    yield* sub_1e53d1();
    r32[eax] = 0;
  case 0x1e68e1: // 0160:1e68e1
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e68e7() // 0160:1e68e7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    r32[edx] = 0x003164d0;
  case 0x1e68f1: // 0160:1e68f1
    r32[eax] = memoryAGet32(ds, r32[edx]);
    if (!r32[eax])
        { pc = 0x1e691c; break; }
    r32[ecx] = memoryAGet32(ds, r32[eax] + 0x4);
    if (r32[ebx] == r32[ecx])
        { pc = 0x1e6902; break; }
    r32[edx] = r32[eax];
    { pc = 0x1e68f1; break; }
  case 0x1e6902: // 0160:1e6902
    r8[cl] = memoryAGet(ds, r32[ecx] + 0xc);
    r8[cl] |= 0x03;
    memoryASet(ds, r32[ebx] + 0xc, r8[cl]);
    r32[ebx] = memoryAGet32(ds, r32[eax]);
    memoryASet32(ds, r32[edx], r32[ebx]);
    r32[edx] = memoryAGet32(ds, 0x3164c8);
    memoryASet32(ds, 0x3164c8, r32[eax]);
    memoryASet32(ds, r32[eax], r32[edx]);
  case 0x1e691c: // 0160:1e691c
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e693e() // 0160:1e693e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    if (memoryAGet(ds, r32[eax] + 0xd) & 0x20)
        { pc = 0x1e696b; break; }
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x10);
    yield* sub_1eaf6c();
    if (!r32[eax])
        { pc = 0x1e696b; break; }
    r8[bl] = memoryAGet(ds, r32[edx] + 0xd);
    r8[bl] |= 0x20;
    memoryASet(ds, r32[edx] + 0xd, r8[bl]);
    if (r8[bl] & 0x07)
        { pc = 0x1e696b; break; }
    r8[cl] = r8[bl];
    r8[cl] |= 0x02;
    memoryASet(ds, r32[edx] + 0xd, r8[cl]);
  case 0x1e696b: // 0160:1e696b
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e696f() // 0160:1e696f +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = 0x00000001;
    r32[edx] = 0;
    yield* sub_1e6986();
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e6980() // 0160:1e6980 +long
{
    r32[esp] -= 4;
    r32[eax] = memoryAGet32(ds, 0x20a73c);
    r32[esp] += 4;
}
function* sub_1e6986() // 0160:1e6986 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[edi]);
    r32[esp] -= 0x00000004;
    r32[ecx] = r32[eax];
    r32[eax] = r32[ebx];
    r32[edi] = r32[esp];
    r32[ebx] = r32[ecx];
    r8[ah] = 0x42;
    r32[ecx] = r32[edx];
    r32[ecx] >>>= 16;
    interrupt(0x21);
    memoryASet16(ss, r32[edi], r16[ax]);
    memoryASet16(ss, r32[edi] + 0x2, r16[dx]);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    if (r32s[eax] >= 0)
        { pc = 0x1e69be; break; }
    r32[eax] &= 0x0000ffff;
    yield* sub_1e788d();
    r32[eax] = 0xffffffff;
    { pc = 0x1e69c1; break; }
  case 0x1e69be: // 0160:1e69be
    r32[eax] = memoryAGet32(ds, r32[esp]);
  case 0x1e69c1: // 0160:1e69c1
    r32[esp] += 0x00000004;
    r32[edi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e69c7() // 0160:1e69c7 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r32[ebx] = r32[eax];
    r8[ah] = 0x3e;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    if (r32s[eax] < 0)
        { pc = 0x1e69e7; break; }
    r32[eax] = r32[edx];
    r32[edx] = 0;
    yield* sub_1eafdf();
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e69e7: // 0160:1e69e7
    r32[eax] = 0x00000004;
    yield* sub_1e53d1();
    r32[eax] = 0xffffffff;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e69f9() // 0160:1e69f9 +long
{
    yield* sub_1eaff4();
}
function* sub_1e69fe() // 0160:1e69fe +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ebx] = r32[eax];
    if (memoryAGet(ds, r32[edx] + 0xc) & 0x02)
        { pc = 0x1e6a23; break; }
    r32[eax] = 0x00000004;
    yield* sub_1e53d1();
    memoryASet(ds, r32[edx] + 0xc, memoryAGet(ds, r32[edx] + 0xc) | 0x20);
  case 0x1e6a19: // 0160:1e6a19
    r32[eax] = 0xffffffff;
    { pc = 0x1e6a9c; break; }
  case 0x1e6a23: // 0160:1e6a23
    if (memoryAGet32(ds, r32[edx] + 0x8))
        { pc = 0x1e6a30; break; }
    r32[eax] = r32[edx];
    yield* sub_1e5407();
  case 0x1e6a30: // 0160:1e6a30
    r32[ecx] = 0x00000400;
    if (r32[ebx] != 0x0000000a)
        { pc = 0x1e6a6d; break; }
    r8[al] = memoryAGet(ds, r32[edx] + 0xc);
    r32[ecx] = 0x00000600;
    if (r8[al] & 0x40)
        { pc = 0x1e6a6d; break; }
    memoryASet(ds, r32[edx] + 0xd, memoryAGet(ds, r32[edx] + 0xd) | 0x10);
    r32[eax] = memoryAGet32(ds, r32[edx]);
    memoryASet(ds, r32[eax], 0x0d);
    r32[esi] = memoryAGet32(ds, r32[edx]);
    r32[esi]++;
    r32[edi] = memoryAGet32(ds, r32[edx] + 0x4);
    memoryASet32(ds, r32[edx], r32[esi]);
    r32[edi]++;
    r32[ebp] = memoryAGet32(ds, r32[edx] + 0x14);
    memoryASet32(ds, r32[edx] + 0x4, r32[edi]);
    if (r32[edi] != r32[ebp])
        { pc = 0x1e6a6d; break; }
    r32[eax] = r32[edx];
    yield* sub_1e58fc();
    if (r32[eax])
        { pc = 0x1e6a19; break; }
  case 0x1e6a6d: // 0160:1e6a6d
    memoryASet(ds, r32[edx] + 0xd, memoryAGet(ds, r32[edx] + 0xd) | 0x10);
    r32[eax] = memoryAGet32(ds, r32[edx]);
    memoryASet(ds, r32[eax], r8[bl]);
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[eax]++;
    r32[esi] = memoryAGet32(ds, r32[edx] + 0x4);
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[esi]++;
    r32[edi] = memoryAGet32(ds, r32[edx] + 0xc);
    memoryASet32(ds, r32[edx] + 0x4, r32[esi]);
    if (r32[ecx] & r32[edi])
        { pc = 0x1e6a8d; break; }
    if (r32[esi] != memoryAGet32(ds, r32[edx] + 0x14))
        { pc = 0x1e6a98; break; }
  case 0x1e6a8d: // 0160:1e6a8d
    r32[eax] = r32[edx];
    yield* sub_1e58fc();
    if (r32[eax])
        { pc = 0x1e6a19; break; }
  case 0x1e6a98: // 0160:1e6a98
    r32[eax] = 0;
    r8[al] = r8[bl];
  case 0x1e6a9c: // 0160:1e6a9c
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6aa2() // 0160:1e6aa2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    r32[esp] -= 0x0000004c;
    r32[esi] = r32[ebx];
    memoryASet32(ds, r32[esp] + 0x44, r32[ecx]);
    r8[bl] = 0;
    memoryASet32(ds, r32[esp] + 0x28, r32[eax]);
    memoryASet(ds, r32[esp] + 0x48, r8[bl]);
    memoryASet(ds, r32[esp] + 0x3c, r8[bl]);
    r32[ebx] = 0;
    r32[edi] = r32[edx];
    memoryASet32(ds, r32[esp] + 0x38, r32[ebx]);
    r32[ebp] = 0x00000004;
    { pc = 0x1e6b25; break; }
  case 0x1e6acc: // 0160:1e6acc
    r32[ebx] = r32[esp] + 40;
    r32[edx] = r32[esi];
    yield* sub_1e6d23();
    r32[edi] = r32[eax];
    r8[al] = memoryAGet(ds, r32[eax]);
    r32[edi]++;
    memoryASet(ds, r32[esp] + 0x3d, r8[al]);
    if (!r8[al])
        { pc = 0x1e6d17; break; }
    if (r8[al] != 0x6e)
        { pc = 0x1e6bc7; break; }
    r8[bl] = memoryAGet(ds, r32[esp] + 0x3c);
    if (!(r8[bl] & 0x20))
        { pc = 0x1e6b52; break; }
    if (!(r8[bl] & 0x80))
        { pc = 0x1e6b11; break; }
    r32[ecx] = memoryAGet32(ds, r32[esi]);
    r32[ecx] += 0x00000008;
    memoryASet32(ds, r32[esi], r32[ecx]);
    r32[edx] = memoryAGet32(ds, r32[ecx] - 8); es = memoryAGet32(ds, r32[ecx] - 6);
  case 0x1e6b08: // 0160:1e6b08
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x38);
    memoryASet32(es, r32[edx], r32[eax]);
    { pc = 0x1e6b25; break; }
  case 0x1e6b11: // 0160:1e6b11
    if (!(r8[bl] & 0x40))
        { pc = 0x1e6b47; break; }
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[ebx] += r32[ebp];
    memoryASet32(ds, r32[esi], r32[ebx]);
    r32[edx] = memoryAGet32(ds, r32[ebx] - 4);
  case 0x1e6b1f: // 0160:1e6b1f
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x38);
    memoryASet32(ds, r32[edx], r32[eax]);
  case 0x1e6b25: // 0160:1e6b25
    r8[cl] = memoryAGet(ds, r32[edi]);
    if (!r8[cl])
        { pc = 0x1e6d17; break; }
    r32[eax] = r32[edi] + 1;
    if (r8[cl] == 0x25)
        { pc = 0x1e6acc; break; }
    r32[edi] = r32[eax];
    r32[edx] = 0;
    r32[eax] = r32[esp] + 40;
    r8[dl] = r8[cl];
    switch (memoryAGet32(ds, r32[esp] + 0x44))
    {
        case 0x001e43e1: yield* sub_1e43e1(); break;
        default:
            stop("ind 0160:1e6b41");
    }
    { pc = 0x1e6b25; break; }
  case 0x1e6b47: // 0160:1e6b47
    r32[edx] = memoryAGet32(ds, r32[esi]);
    r32[edx] += r32[ebp];
    memoryASet32(ds, r32[esi], r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[edx] - 4);
    { pc = 0x1e6b1f; break; }
  case 0x1e6b52: // 0160:1e6b52
    if (!(r8[bl] & 0x10))
        { pc = 0x1e6b92; break; }
    if (!(r8[bl] & 0x80))
        { pc = 0x1e6b70; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[eax] += 0x00000008;
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[edx] = memoryAGet32(ds, r32[eax] - 8); es = memoryAGet32(ds, r32[eax] - 6);
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x38);
    memoryASet16(es, r32[edx], r16[ax]);
    { pc = 0x1e6b25; break; }
  case 0x1e6b70: // 0160:1e6b70
    if (!(r8[bl] & 0x40))
        { pc = 0x1e6b87; break; }
    r32[ecx] = memoryAGet32(ds, r32[esi]);
    r32[ecx] += r32[ebp];
    memoryASet32(ds, r32[esi], r32[ecx]);
    r32[edx] = memoryAGet32(ds, r32[ecx] - 4);
  case 0x1e6b7e: // 0160:1e6b7e
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x38);
    memoryASet16(ds, r32[edx], r16[ax]);
    { pc = 0x1e6b25; break; }
  case 0x1e6b87: // 0160:1e6b87
    r32[ebx] = memoryAGet32(ds, r32[esi]);
    r32[ebx] += r32[ebp];
    memoryASet32(ds, r32[esi], r32[ebx]);
    r32[edx] = memoryAGet32(ds, r32[ebx] - 4);
    { pc = 0x1e6b7e; break; }
  case 0x1e6b92: // 0160:1e6b92
    if (!(r8[bl] & 0x80))
        { pc = 0x1e6ba6; break; }
    r32[edx] = memoryAGet32(ds, r32[esi]);
    r32[edx] += 0x00000008;
    memoryASet32(ds, r32[esi], r32[edx]);
    r16[tx] = memoryAGet32(ds, r32[edx] - 8); es = memoryAGet32(ds, r32[edx] - 6); r32[edx] = r16[tx];
    { pc = 0x1e6b08; break; }
  case 0x1e6ba6: // 0160:1e6ba6
    if (!(r8[bl] & 0x40))
        { pc = 0x1e6bb9; break; }
    r32[eax] = memoryAGet32(ds, r32[esi]);
    r32[eax] += r32[ebp];
    memoryASet32(ds, r32[esi], r32[eax]);
    r32[edx] = memoryAGet32(ds, r32[eax] - 4);
    { pc = 0x1e6b1f; break; }
  case 0x1e6bb9: // 0160:1e6bb9
    r32[ecx] = memoryAGet32(ds, r32[esi]);
    r32[ecx] += r32[ebp];
    memoryASet32(ds, r32[esi], r32[ecx]);
    r32[edx] = memoryAGet32(ds, r32[ecx] - 4);
    { pc = 0x1e6b1f; break; }
  case 0x1e6bc7: // 0160:1e6bc7
    r32[eax] = r32[esp];
    r32[ebx] = r32[esp] + 40;
    r32[ecx] = r32[esp] + 72;
    r32[edx] = r32[esi];
    yield* sub_1e703b();
    es = r32[edx];
    r8[dl] = memoryAGet(ds, r32[esp] + 0x3c);
    r32[ebx] = r32[eax];
    if (r8[dl] & 0x08)
        { pc = 0x1e6c09; break; }
    if (memoryAGet(ds, r32[esp] + 0x3e) != 0x20)
        { pc = 0x1e6c09; break; }
  case 0x1e6bec: // 0160:1e6bec
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x2c);
    r32[eax]--;
    memoryASet32(ds, r32[esp] + 0x2c, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e6c09; break; }
    r32[edx] = 0;
    r32[eax] = r32[esp] + 40;
    r8[dl] = memoryAGet(ds, r32[esp] + 0x3e);
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    { pc = 0x1e6bec; break; }
  case 0x1e6c09: // 0160:1e6c09
    r32[ecx] = r32[esp] + 63;
  case 0x1e6c0d: // 0160:1e6c0d
    r8[al] = memoryAGet(ds, r32[ecx]);
    if (!r8[al])
        { pc = 0x1e6c22; break; }
    r32[edx] = 0;
    r8[dl] = r8[al];
    r32[eax] = r32[esp] + 40;
    r32[ecx]++;
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    { pc = 0x1e6c0d; break; }
  case 0x1e6c22: // 0160:1e6c22
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x34);
    r32[ecx] = r32[eax] - 1;
    memoryASet32(ds, r32[esp] + 0x34, r32[ecx]);
    if (!r32[eax])
        { pc = 0x1e6c40; break; }
    r32[eax] = r32[esp] + 40;
    r32[edx] = 0x00000030;
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    { pc = 0x1e6c22; break; }
  case 0x1e6c40: // 0160:1e6c40
    if (memoryAGet(ds, r32[esp] + 0x3c) & 0x08)
        { pc = 0x1e6c6b; break; }
    if (memoryAGet(ds, r32[esp] + 0x3e) == 0x20)
        { pc = 0x1e6c6b; break; }
  case 0x1e6c4e: // 0160:1e6c4e
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x2c);
    r32[eax]--;
    memoryASet32(ds, r32[esp] + 0x2c, r32[eax]);
    if (r32s[eax] < 0)
        { pc = 0x1e6c6b; break; }
    r32[edx] = 0;
    r32[eax] = r32[esp] + 40;
    r8[dl] = memoryAGet(ds, r32[esp] + 0x3e);
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    { pc = 0x1e6c4e; break; }
  case 0x1e6c6b: // 0160:1e6c6b
    r8[dh] = memoryAGet(ds, r32[esp] + 0x3d);
    if (r8[dh] == 0x73)
        { pc = 0x1e6c79; break; }
    if (r8[dh] != 0x53)
        { pc = 0x1e6cc0; break; }
  case 0x1e6c79: // 0160:1e6c79
    if (!(memoryAGet(ds, r32[esp] + 0x3c) & 0x20))
        { pc = 0x1e6ca1; break; }
  case 0x1e6c80: // 0160:1e6c80
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x30);
    r32[ecx] = r32[eax] - 1;
    memoryASet32(ds, r32[esp] + 0x30, r32[ecx]);
    if (!r32[eax])
        { pc = 0x1e6cdf; break; }
    r32[edx] = 0;
    r32[eax] = r32[esp] + 40;
    r8[dl] = memoryAGet(es, r32[ebx]);
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    r32[ebx] += 0x00000002;
    { pc = 0x1e6c80; break; }
  case 0x1e6ca1: // 0160:1e6ca1
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x30);
    r32[edx] = r32[eax] - 1;
    memoryASet32(ds, r32[esp] + 0x30, r32[edx]);
    if (!r32[eax])
        { pc = 0x1e6cdf; break; }
    r32[edx] = 0;
    r32[eax] = r32[esp] + 40;
    r8[dl] = memoryAGet(es, r32[ebx]);
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    r32[ebx]++;
    { pc = 0x1e6ca1; break; }
  case 0x1e6cc0: // 0160:1e6cc0
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x30);
    r32[ecx] = r32[eax] - 1;
    memoryASet32(ds, r32[esp] + 0x30, r32[ecx]);
    if (!r32[eax])
        { pc = 0x1e6cdf; break; }
    r32[edx] = 0;
    r32[eax] = r32[esp] + 40;
    r8[dl] = memoryAGet(es, r32[ebx]);
    switch (memoryAGet32(ds, r32[esp] + 0x44))
    {
        case 0x001e43e1: yield* sub_1e43e1(); break;
        default:
            stop("ind 0160:1e6cd8");
    }
    r32[ebx]++;
    { pc = 0x1e6cc0; break; }
  case 0x1e6cdf: // 0160:1e6cdf
    if (!(memoryAGet(ds, r32[esp] + 0x3c) & 0x08))
        { pc = 0x1e6b25; break; }
    if (signed32(memoryAGet32(ds, r32[esp] + 0x2c)) <= signed32(0x00000000))
        { pc = 0x1e6b25; break; }
  case 0x1e6cf5: // 0160:1e6cf5
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x2c);
    r32[edx] = r32[eax] - 1;
    memoryASet32(ds, r32[esp] + 0x2c, r32[edx]);
    if (!r32[eax])
        { pc = 0x1e6b25; break; }
    r32[eax] = r32[esp] + 40;
    r32[edx] = 0x00000020;
    yield* indirectCall(cs, memoryAGet32(ds, r32[esp] + 0x44));
    { pc = 0x1e6cf5; break; }
  case 0x1e6d17: // 0160:1e6d17
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x38);
    r32[esp] += 0x0000004c;
    r32[ebp] = pop32();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6d23() // 0160:1e6d23 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esi] = r32[edx];
    memoryASet(ds, r32[ebx] + 0x17, 0x00);
    r32[edx] = r32[ebx];
    memoryASet(ds, r32[ebx] + 0x16, 0x20);
    yield* sub_1e6e56();
    memoryASet32(ds, r32[ebx] + 0x4, 0x00000000);
    r8[cl] = memoryAGet(ds, r32[eax]);
    r32[edx] = r32[eax];
    if (r8[cl] < 0x30)
        { pc = 0x1e6d6b; break; }
    if (r8[cl] > 0x39)
        { pc = 0x1e6d6b; break; }
  case 0x1e6d4c: // 0160:1e6d4c
    r32[ecx] = (signed32(memoryAGet32(ds, r32[ebx] + 0x4))) * signed32(0x0000000a);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax]);
    r32[edx] -= 0x00000030;
    r32[ecx] += r32[edx];
    r32[eax]++;
    memoryASet32(ds, r32[ebx] + 0x4, r32[ecx]);
    r8[cl] = memoryAGet(ds, r32[eax]);
    if (r8[cl] < 0x30)
        { pc = 0x1e6d92; break; }
    if (r8[cl] <= 0x39)
        { pc = 0x1e6d4c; break; }
    { pc = 0x1e6d92; break; }
  case 0x1e6d6b: // 0160:1e6d6b
    if (memoryAGet(ds, r32[eax]) != 0x2a)
        { pc = 0x1e6d92; break; }
    r32[edx] = memoryAGet32(ds, r32[esi]);
    r32[edx] += 0x00000004;
    memoryASet32(ds, r32[esi], r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[edx] - 4);
    memoryASet32(ds, r32[ebx] + 0x4, r32[edx]);
    if (r32s[edx] >= 0)
        { pc = 0x1e6d91; break; }
    r32[edi] = r32[edx];
    r8[dh] = memoryAGet(ds, r32[ebx] + 0x14);
    r32[edi] = -r32[edi];
    r8[dh] |= 0x08;
    memoryASet32(ds, r32[ebx] + 0x4, r32[edi]);
    memoryASet(ds, r32[ebx] + 0x14, r8[dh]);
  case 0x1e6d91: // 0160:1e6d91
    r32[eax]++;
  case 0x1e6d92: // 0160:1e6d92
    memoryASet32(ds, r32[ebx] + 0x8, 0xffffffff);
    if (memoryAGet(ds, r32[eax]) != 0x2e)
        { pc = 0x1e6de5; break; }
    r32[eax]++;
    memoryASet32(ds, r32[ebx] + 0x8, 0x00000000);
    if (memoryAGet(ds, r32[eax]) != 0x2a)
        { pc = 0x1e6dc6; break; }
    r32[edx] = memoryAGet32(ds, r32[esi]);
    r32[edx] += 0x00000004;
    memoryASet32(ds, r32[esi], r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[edx] - 4);
    memoryASet32(ds, r32[ebx] + 0x8, r32[edx]);
    if (r32s[edx] >= 0)
        { pc = 0x1e6dc3; break; }
    memoryASet32(ds, r32[ebx] + 0x8, 0xffffffff);
  case 0x1e6dc3: // 0160:1e6dc3
    r32[eax]++;
    { pc = 0x1e6de5; break; }
  case 0x1e6dc6: // 0160:1e6dc6
    r8[cl] = memoryAGet(ds, r32[eax]);
    if (r8[cl] < 0x30)
        { pc = 0x1e6de5; break; }
    if (r8[cl] > 0x39)
        { pc = 0x1e6de5; break; }
    r32[ecx] = (signed32(memoryAGet32(ds, r32[ebx] + 0x8))) * signed32(0x0000000a);
    r32[edx] = 0;
    r8[dl] = memoryAGet(ds, r32[eax]);
    r32[edx] -= 0x00000030;
    r32[ecx] += r32[edx];
    r32[eax]++;
    memoryASet32(ds, r32[ebx] + 0x8, r32[ecx]);
    { pc = 0x1e6dc6; break; }
  case 0x1e6de5: // 0160:1e6de5
    r8[cl] = memoryAGet(ds, r32[eax]);
    r32[edx] = r32[eax] + 1;
    if (r8[cl] < 0x4e)
        { pc = 0x1e6e0a; break; }
    if (r8[cl] <= 0x4e)
        { pc = 0x1e6e47; break; }
    if (r8[cl] < 0x6c)
        { pc = 0x1e6e01; break; }
    if (r8[cl] <= 0x6c)
        { pc = 0x1e6e1a; break; }
    if (r8[cl] == 0x77)
        { pc = 0x1e6e1a; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6e01: // 0160:1e6e01
    if (r8[cl] == 0x68)
        { pc = 0x1e6e28; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6e0a: // 0160:1e6e0a
    if (r8[cl] < 0x46)
        { pc = 0x1e6e52; break; }
    if (r8[cl] <= 0x46)
        { pc = 0x1e6e41; break; }
    if (r8[cl] == 0x4c)
        { pc = 0x1e6e37; break; }
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6e1a: // 0160:1e6e1a
    r8[dl] = memoryAGet(ds, r32[ebx] + 0x14);
    r8[dl] |= 0x20;
    r32[eax]++;
    memoryASet(ds, r32[ebx] + 0x14, r8[dl]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6e28: // 0160:1e6e28
    r8[cl] = memoryAGet(ds, r32[ebx] + 0x14);
    r8[cl] |= 0x10;
    r32[eax] = r32[edx];
    memoryASet(ds, r32[ebx] + 0x14, r8[cl]);
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6e37: // 0160:1e6e37
    memoryASet(ds, r32[ebx] + 0x14, memoryAGet(ds, r32[ebx] + 0x14) | 0x40);
  case 0x1e6e3b: // 0160:1e6e3b
    r32[eax] = r32[edx];
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6e41: // 0160:1e6e41
    memoryASet(ds, r32[ebx] + 0x14, memoryAGet(ds, r32[ebx] + 0x14) | 0x80);
    { pc = 0x1e6e3b; break; }
  case 0x1e6e47: // 0160:1e6e47
    r8[ch] = memoryAGet(ds, r32[ebx] + 0x14);
    r8[ch] |= 0x40;
    r32[eax] = r32[edx];
    memoryASet(ds, r32[ebx] + 0x14, r8[ch]);
  case 0x1e6e52: // 0160:1e6e52
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6e56() // 0160:1e6e56 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    memoryASet(ds, r32[edx] + 0x14, 0x00);
  case 0x1e6e5c: // 0160:1e6e5c
    r8[bl] = memoryAGet(ds, r32[eax]);
    if (r8[bl] != 0x2d)
        { pc = 0x1e6e69; break; }
    memoryASet(ds, r32[edx] + 0x14, memoryAGet(ds, r32[edx] + 0x14) | 0x08);
    { pc = 0x1e6eab; break; }
  case 0x1e6e69: // 0160:1e6e69
    if (r8[bl] != 0x23)
        { pc = 0x1e6e74; break; }
    memoryASet(ds, r32[edx] + 0x14, memoryAGet(ds, r32[edx] + 0x14) | 0x01);
    { pc = 0x1e6eab; break; }
  case 0x1e6e74: // 0160:1e6e74
    if (r8[bl] != 0x2b)
        { pc = 0x1e6e8c; break; }
    r8[ch] = memoryAGet(ds, r32[edx] + 0x14);
    r8[ch] |= 0x04;
    r8[bl] = r8[ch];
    memoryASet(ds, r32[edx] + 0x14, r8[ch]);
    r8[bl] &= 0xfd;
    memoryASet(ds, r32[edx] + 0x14, r8[bl]);
    { pc = 0x1e6eab; break; }
  case 0x1e6e8c: // 0160:1e6e8c
    if (r8[bl] != 0x20)
        { pc = 0x1e6ea3; break; }
    r8[bh] = memoryAGet(ds, r32[edx] + 0x14);
    if (r8[bh] & 0x04)
        { pc = 0x1e6eab; break; }
    r8[cl] = r8[bh];
    r8[cl] |= 0x02;
    memoryASet(ds, r32[edx] + 0x14, r8[cl]);
    { pc = 0x1e6eab; break; }
  case 0x1e6ea3: // 0160:1e6ea3
    if (r8[bl] != 0x30)
        { pc = 0x1e6eae; break; }
    memoryASet(ds, r32[edx] + 0x16, r8[bl]);
  case 0x1e6eab: // 0160:1e6eab
    r32[eax]++;
    { pc = 0x1e6e5c; break; }
  case 0x1e6eae: // 0160:1e6eae
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6eb1() // 0160:1e6eb1 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    r32[esi] = r32[edx];
    r32[edi] = r32[ebx];
    r32[edx] = r32[eax];
    r32[eax] = 0;
  case 0x1e6ebd: // 0160:1e6ebd
    es = r32[esi];
    r32[ebx] = r32[edx];
    r8[cl] = memoryAGet(es, r32[ebx]);
    r32[edx]++;
    if (!r8[cl])
        { pc = 0x1e6ed0; break; }
    if (r32[eax] == r32[edi])
        { pc = 0x1e6ed0; break; }
    r32[eax]++;
    { pc = 0x1e6ebd; break; }
  case 0x1e6ed0: // 0160:1e6ed0
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6ed5() // 0160:1e6ed5 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e6ed5; break; }
  case 0x1e6ed0: // 0160:1e6ed0
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4; return;
  case 0x1e6ed5: // 0160:1e6ed5
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    r32[ecx] = r32[edx];
    r32[esi] = r32[ebx];
    r32[edx] = r32[eax];
    r32[eax] = 0;
  case 0x1e6ee1: // 0160:1e6ee1
    es = r32[ecx];
    r32[ebx] = r32[edx];
    r16[di] = memoryAGet16(es, r32[ebx]);
    r32[edx] += 0x00000002;
    if (!r16[di])
        { pc = 0x1e6ed0; break; }
    if (r32[eax] == r32[esi])
        { pc = 0x1e6ed0; break; }
    r32[eax]++;
    { pc = 0x1e6ee1; break; }
    return;
  }
}
function* sub_1e6ef8() // 0160:1e6ef8 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000004;
    r32[ebp] = r32[edx];
    memoryASet32(ds, r32[esp], r32[ebx]);
    r32[ebx] = 0x00000010;
    r32[edi] = r32[ebp];
    yield* sub_1eb082();
    push(es);
    r32[eax] = ds;
    es = r32[eax];
    r32[ecx] = 0;
    r32[ecx]--;
    r32[eax] = 0;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESEDI(r8[al]);
    r32[ecx] = ~r32[ecx];
    r32[ecx]--;
    es = pop();
    r32[eax] = memoryAGet32(ds, r32[esp]);
    r32[esi] = r32[ecx];
    r32[edi] = r32[ebp];
    r32[eax]--;
    r32[edx] = r32[ecx] + r32[ebp];
    r32[ebx] = r32[eax] + r32[ebp];
    { pc = 0x1e6f38; break; }
  case 0x1e6f30: // 0160:1e6f30
    r32[edx]--;
    r32[esi]--;
    r8[cl] = memoryAGet(ds, r32[edx]);
    r32[eax]--;
    memoryASet(ds, r32[ebx], r8[cl]);
    r32[ebx]--;
  case 0x1e6f38: // 0160:1e6f38
    if (r32[edx] != r32[edi])
        { pc = 0x1e6f30; break; }
    r32[edx] = r32[eax] + r32[ebp];
  case 0x1e6f3f: // 0160:1e6f3f
    if (r32s[eax] < 0)
        { pc = 0x1e6f4a; break; }
    r32[eax]--;
    memoryASet(ds, r32[edx], 0x30);
    r32[edx]--;
    { pc = 0x1e6f3f; break; }
  case 0x1e6f4a: // 0160:1e6f4a
    r32[ebp] += memoryAGet32(ds, r32[esp]);
    memoryASet(ss, r32[ebp], 0x00);
    r32[esp] += 0x00000004;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e6f59() // 0160:1e6f59 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    r32[esp] -= 0x00000004;
    r32[ecx] = r32[eax];
    r32[esi] = r32[ebx];
    memoryASet32(ds, r32[esp], r32[edx]);
    if (r32s[edx] >= 0)
        { pc = 0x1e6f75; break; }
    r32[edx] = -r32[edx];
    r32[ecx] = r32[eax] + 1;
    memoryASet(ds, r32[eax], 0x2d);
    memoryASet32(ds, r32[esp], r32[edx]);
  case 0x1e6f75: // 0160:1e6f75
    if (memoryAGet32(ds, r32[esi] + 0x8) != 0xffffffff)
        { pc = 0x1e6f82; break; }
    memoryASet32(ds, r32[esi] + 0x8, 0x00000004);
  case 0x1e6f82: // 0160:1e6f82
    r32[ebx] = 0x0000000a;
    r32[eax] = 0;
    r32[edx] = r32[ecx];
    r16[ax] = memoryAGet16(ds, r32[esp] + 0x2);
    yield* sub_1eb082();
    r32[ebx] = r32[ecx];
  case 0x1e6f97: // 0160:1e6f97
    r8[ah] = memoryAGet(ds, r32[ecx]);
    r32[edx] = r32[ecx] + 1;
    if (!r8[ah])
        { pc = 0x1e6fa4; break; }
    r32[ecx] = r32[edx];
    { pc = 0x1e6f97; break; }
  case 0x1e6fa4: // 0160:1e6fa4
    if (!memoryAGet32(ds, r32[esi] + 0x8))
        { pc = 0x1e6fd6; break; }
    memoryASet(ds, r32[ecx], 0x2e);
    r32[eax] = 0;
    r32[ecx] = r32[edx];
    { pc = 0x1e6fce; break; }
  case 0x1e6fb3: // 0160:1e6fb3
    r32[edx] = 0;
    memoryASet16(ds, r32[esp] + 0x2, r16[dx]);
    r32[edi] = memoryAGet32(ds, r32[esp]);
    r32[edx] = r32s[edi] * signed32(0x0000000a);
    memoryASet32(ds, r32[esp], r32[edx]);
    r8[dl] = memoryAGet(ds, r32[esp] + 0x2);
    r8[dl] += 0x30;
    r32[eax]++;
    memoryASet(ds, r32[ecx], r8[dl]);
    r32[ecx]++;
  case 0x1e6fce: // 0160:1e6fce
    if (r32s[eax] < signed32(memoryAGet32(ds, r32[esi] + 0x8)))
        { pc = 0x1e6fb3; break; }
    memoryASet(ds, r32[ecx], 0x00);
  case 0x1e6fd6: // 0160:1e6fd6
    if (!(memoryAGet(ds, r32[esp] + 0x1) & 0x80))
        { pc = 0x1e702d; break; }
  case 0x1e6fdd: // 0160:1e6fdd
    if (r32[ecx] != r32[ebx])
        { pc = 0x1e7013; break; }
    r32[ecx] = r32[ebx] + 1;
    memoryASet(ds, r32[ebx], 0x31);
  case 0x1e6fe7: // 0160:1e6fe7
    r8[dl] = memoryAGet(ds, r32[ecx]);
    r32[eax] = r32[ecx] + 1;
    if (r8[dl] != 0x30)
        { pc = 0x1e6ff5; break; }
    r32[ecx] = r32[eax];
    { pc = 0x1e6fe7; break; }
  case 0x1e6ff5: // 0160:1e6ff5
    if (r8[dl] != 0x2e)
        { pc = 0x1e700a; break; }
    memoryASet(ds, r32[ecx], 0x30);
    r32[ecx] = r32[eax] + 1;
    memoryASet(ds, r32[eax], r8[dl]);
  case 0x1e7002: // 0160:1e7002
    if (memoryAGet(ds, r32[ecx]) != 0x30)
        { pc = 0x1e700a; break; }
    r32[ecx]++;
    { pc = 0x1e7002; break; }
  case 0x1e700a: // 0160:1e700a
    memoryASet(ds, r32[ecx], 0x30);
    r32[ecx]++;
    memoryASet(ds, r32[ecx], 0x00);
    { pc = 0x1e702d; break; }
  case 0x1e7013: // 0160:1e7013
    r32[ecx]--;
    if (memoryAGet(ds, r32[ecx]) != 0x2e)
        { pc = 0x1e701a; break; }
    r32[ecx]--;
  case 0x1e701a: // 0160:1e701a
    r8[al] = memoryAGet(ds, r32[ecx]);
    if (r8[al] == 0x39)
        { pc = 0x1e7028; break; }
    r8[ah] = r8[al];
    r8[ah]++;
    memoryASet(ds, r32[ecx], r8[ah]);
    { pc = 0x1e702d; break; }
  case 0x1e7028: // 0160:1e7028
    memoryASet(ds, r32[ecx], 0x30);
    { pc = 0x1e6fdd; break; }
  case 0x1e702d: // 0160:1e702d
    r32[esp] += 0x00000004;
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e7034() // 0160:1e7034 +long
{
    r32[esp] -= 4;
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a834));
    r32[esp] += 4;
}
function* sub_1e703b() // 0160:1e703b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    r32[esp] -= 0x00000008;
    r32[edi] = r32[eax];
    r32[esi] = r32[ebx];
    memoryASet32(ds, r32[esp], r32[ecx]);
    r32[ebx] = 0x00000001;
    r32[eax] = ds;
    r32[ecx] = r32[edi];
    memoryASet32(ds, r32[esp] + 0x4, r32[ebx]);
    es = r32[eax];
    r8[al] = memoryAGet(ds, r32[esi] + 0x15);
    memoryASet32(ds, r32[esi] + 0xc, 0x00000000);
    if (r8[al] < 0x69)
        { pc = 0x1e707c; break; }
    if (r8[al] <= 0x69)
        { pc = 0x1e70bc; break; }
    if (r8[al] < 0x75)
        { pc = 0x1e7078; break; }
    if (r8[al] <= 0x75)
        { pc = 0x1e7088; break; }
    flags.zero = r8[al] == 0x78;
  case 0x1e7074: // 0160:1e7074
    if (flags.zero)
        { pc = 0x1e7088; break; }
    { pc = 0x1e70c6; break; }
  case 0x1e7078: // 0160:1e7078
    flags.zero = r8[al] == 0x6f;
    { pc = 0x1e7074; break; }
  case 0x1e707c: // 0160:1e707c
    if (r8[al] < 0x58)
        { pc = 0x1e70c6; break; }
    if (r8[al] <= 0x58)
        { pc = 0x1e7088; break; }
    if (r8[al] == 0x64)
        { pc = 0x1e70bc; break; }
    { pc = 0x1e70c6; break; }
  case 0x1e7088: // 0160:1e7088
    r8[ah] = memoryAGet(ds, r32[esi] + 0x14);
    if (!(r8[ah] & 0x20))
        { pc = 0x1e709c; break; }
    r32[ebx] = memoryAGet32(ds, r32[edx]);
    r32[ebx] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebx]);
    r32[ebp] = memoryAGet32(ds, r32[ebx] - 4);
    { pc = 0x1e70b8; break; }
  case 0x1e709c: // 0160:1e709c
    if (!(r8[ah] & 0x10))
        { pc = 0x1e70ae; break; }
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[eax] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[ebp] = memoryAGet16(ds, r32[eax] - 4);
    { pc = 0x1e70b8; break; }
  case 0x1e70ae: // 0160:1e70ae
    r32[ebp] = memoryAGet32(ds, r32[edx]);
    r32[ebp] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebp]);
    r32[ebp] = memoryAGet32(ss, r32[ebp] - 4);
  case 0x1e70b8: // 0160:1e70b8
    memoryASet(ds, r32[esi] + 0x14, memoryAGet(ds, r32[esi] + 0x14) & 0xf9);
  case 0x1e70bc: // 0160:1e70bc
    if (memoryAGet32(ds, r32[esi] + 0x8) == 0xffffffff)
        { pc = 0x1e70c6; break; }
    memoryASet(ds, r32[esi] + 0x16, 0x20);
  case 0x1e70c6: // 0160:1e70c6
    r8[al] = memoryAGet(ds, r32[esi] + 0x15);
    r32[ebx] = 0x0000000a;
    if (r8[al] < 0x65)
        { pc = 0x1e712b; break; }
    if (r8[al] <= 0x65)
        { pc = 0x1e719c; break; }
    if (r8[al] < 0x6f)
        { pc = 0x1e7114; break; }
    if (r8[al] <= 0x6f)
        { pc = 0x1e71b0; break; }
    if (r8[al] < 0x73)
        { pc = 0x1e7107; break; }
    if (r8[al] <= 0x73)
        { pc = 0x1e722b; break; }
    if (r8[al] < 0x75)
        { pc = 0x1e73bf; break; }
    if (r8[al] <= 0x75)
        { pc = 0x1e72f4; break; }
    if (r8[al] == 0x78)
        { pc = 0x1e72d7; break; }
    { pc = 0x1e73bf; break; }
  case 0x1e7107: // 0160:1e7107
    if (r8[al] == 0x70)
        { pc = 0x1e7313; break; }
    { pc = 0x1e73bf; break; }
  case 0x1e7114: // 0160:1e7114
    if (r8[al] < 0x67)
        { pc = 0x1e7172; break; }
    if (r8[al] <= 0x67)
        { pc = 0x1e719c; break; }
    if (r8[al] == 0x69)
        { pc = 0x1e71eb; break; }
    { pc = 0x1e73bf; break; }
  case 0x1e712b: // 0160:1e712b
    if (r8[al] < 0x50)
        { pc = 0x1e715f; break; }
    if (r8[al] <= 0x50)
        { pc = 0x1e7313; break; }
    if (r8[al] < 0x58)
        { pc = 0x1e7152; break; }
    if (r8[al] <= 0x58)
        { pc = 0x1e72d7; break; }
    if (r8[al] < 0x63)
        { pc = 0x1e73bf; break; }
    if (r8[al] <= 0x63)
        { pc = 0x1e7392; break; }
    { pc = 0x1e71eb; break; }
  case 0x1e7152: // 0160:1e7152
    if (r8[al] == 0x53)
        { pc = 0x1e722b; break; }
    { pc = 0x1e73bf; break; }
  case 0x1e715f: // 0160:1e715f
    if (r8[al] < 0x46)
        { pc = 0x1e716e; break; }
    if (r8[al] <= 0x46)
        { pc = 0x1e7172; break; }
    flags.zero = r8[al] == 0x47;
  case 0x1e7167: // 0160:1e7167
    if (flags.zero)
        { pc = 0x1e719c; break; }
    { pc = 0x1e73bf; break; }
  case 0x1e716e: // 0160:1e716e
    flags.zero = r8[al] == 0x45;
    { pc = 0x1e7167; break; }
  case 0x1e7172: // 0160:1e7172
    if (!(memoryAGet(ds, r32[esi] + 0x14) & 0x10))
        { pc = 0x1e719c; break; }
    r32[ebx] = memoryAGet32(ds, r32[edx]);
    r32[ebx] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebx]);
    r32[eax] = r32[edi];
    r32[edx] = memoryAGet32(ds, r32[ebx] - 4);
    r32[ebx] = r32[esi];
    yield* sub_1e6f59();
    r32[ebx] = 0xffffffff;
    r32[eax] = ds;
    r32[edx] = ds;
    es = r32[eax];
    r32[eax] = r32[edi];
    r32[ecx] = r32[edi];
    { pc = 0x1e71e1; break; }
  case 0x1e719c: // 0160:1e719c
    r32[eax] = r32[edi];
    r32[ebx] = r32[esi];
    yield* sub_1e7034();
    r32[ebx] = 0xffffffff;
    es = r32[edx];
    r32[ecx] = r32[eax];
    { pc = 0x1e71e1; break; }
  case 0x1e71b0: // 0160:1e71b0
    r8[al] = memoryAGet(ds, r32[esi] + 0x14);
    r32[ebx] = 0x00000008;
    if (!(r8[al] & 0x01))
        { pc = 0x1e71c0; break; }
    memoryASet(ds, r32[edi], 0x30);
    r32[edi]++;
  case 0x1e71c0: // 0160:1e71c0
    r32[eax] = r32[ebp];
    r32[edx] = r32[edi];
    yield* sub_1eb10b();
  case 0x1e71c9: // 0160:1e71c9
    if (memoryAGet32(ds, r32[esi] + 0x8))
        { pc = 0x1e71d8; break; }
    if (memoryAGet(ds, r32[edi]) != 0x30)
        { pc = 0x1e71d8; break; }
    memoryASet(es, r32[ecx], 0x00);
  case 0x1e71d8: // 0160:1e71d8
    r32[ebx] = 0xffffffff;
    r32[edx] = es;
    r32[eax] = r32[ecx];
  case 0x1e71e1: // 0160:1e71e1
    yield* sub_1e6eb1();
    { pc = 0x1e73e9; break; }
  case 0x1e71eb: // 0160:1e71eb
    r8[al] = memoryAGet(ds, r32[esi] + 0x14);
    if (!(r8[al] & 0x20))
        { pc = 0x1e7205; break; }
    r32[ebp] = memoryAGet32(ds, r32[edx]);
    r32[ebp] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebp]);
    r32[edx] = r32[edi];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
  case 0x1e71fe: // 0160:1e71fe
    yield* sub_1eb10b();
    { pc = 0x1e71c9; break; }
  case 0x1e7205: // 0160:1e7205
    if (!(r8[al] & 0x10))
        { pc = 0x1e7218; break; }
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[eax] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[edx] = r32[edi];
    r32[eax] = signed16(memoryAGet16(ds, r32[eax] - 4));
    { pc = 0x1e71fe; break; }
  case 0x1e7218: // 0160:1e7218
    r32[ebp] = memoryAGet32(ds, r32[edx]);
    r32[ebp] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebp]);
    r32[edx] = r32[edi];
    r32[eax] = memoryAGet32(ss, r32[ebp] - 4);
    yield* sub_1eb082();
    { pc = 0x1e71c9; break; }
  case 0x1e722b: // 0160:1e722b
    r8[ah] = memoryAGet(ds, r32[esi] + 0x14);
    if (!(r8[ah] & 0x80))
        { pc = 0x1e7255; break; }
    r32[ecx] = memoryAGet32(ds, r32[edx]);
    r32[ecx] += 0x00000008;
    memoryASet32(ds, r32[edx], r32[ecx]);
    r16[dx] = memoryAGet16(ds, r32[ecx] - 4);
    r32[ecx] = memoryAGet32(ds, r32[ecx] - 8);
    if (r32[ecx])
        { pc = 0x1e724a; break; }
    if (!r16[dx])
        { pc = 0x1e724e; break; }
  case 0x1e724a: // 0160:1e724a
    es = r32[edx];
    { pc = 0x1e7281; break; }
  case 0x1e724e: // 0160:1e724e
    r32[eax] = ds;
    r32[ecx] = memoryAGet32(ds, r32[esp]);
    { pc = 0x1e727f; break; }
  case 0x1e7255: // 0160:1e7255
    if (!(r8[ah] & 0x40))
        { pc = 0x1e726c; break; }
    r32[ebx] = memoryAGet32(ds, r32[edx]);
    r32[ebx] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebx]);
    r32[ecx] = memoryAGet32(ds, r32[ebx] - 4);
    if (!r32[ecx])
        { pc = 0x1e724e; break; }
  case 0x1e7268: // 0160:1e7268
    r32[eax] = ds;
    { pc = 0x1e727f; break; }
  case 0x1e726c: // 0160:1e726c
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[eax] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[ecx] = memoryAGet32(ds, r32[eax] - 4);
    if (r32[ecx])
        { pc = 0x1e7268; break; }
    r32[eax] = ds;
    r32[ecx] = memoryAGet32(ds, r32[esp]);
  case 0x1e727f: // 0160:1e727f
    es = r32[eax];
  case 0x1e7281: // 0160:1e7281
    r8[bh] = memoryAGet(ds, r32[esi] + 0x14);
    r8[al] = memoryAGet(ds, r32[esi] + 0x15);
    r32[edi] = 0;
    r8[bh] &= 0xf9;
    memoryASet32(ds, r32[esp] + 0x4, r32[edi]);
    memoryASet(ds, r32[esi] + 0x14, r8[bh]);
    if (r8[al] != 0x53)
        { pc = 0x1e72b5; break; }
    if (!(r8[bh] & 0x20))
        { pc = 0x1e72aa; break; }
    r32[eax] = 0;
    r16[ax] = memoryAGet16(es, r32[ecx]);
    r32[ecx] += 0x00000002;
    { pc = 0x1e73e9; break; }
  case 0x1e72aa: // 0160:1e72aa
    r32[eax] = 0;
    r8[al] = memoryAGet(es, r32[ecx]);
    r32[ecx]++;
    { pc = 0x1e73e9; break; }
  case 0x1e72b5: // 0160:1e72b5
    if (!(r8[bh] & 0x20))
        { pc = 0x1e72cb; break; }
    r32[edx] = es;
    r32[eax] = r32[ecx];
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    yield* sub_1e6ed5();
    { pc = 0x1e73e9; break; }
  case 0x1e72cb: // 0160:1e72cb
    r32[edx] = es;
    r32[eax] = r32[ecx];
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    { pc = 0x1e71e1; break; }
  case 0x1e72d7: // 0160:1e72d7
    if (!(memoryAGet(ds, r32[esi] + 0x14) & 0x01))
        { pc = 0x1e72ef; break; }
    if (!r32[ebp])
        { pc = 0x1e72ef; break; }
    memoryASet(ds, r32[esi] + 0x17, 0x30);
    r8[al] = memoryAGet(ds, r32[esi] + 0x15);
    memoryASet(ds, r32[esi] + 0x19, 0x00);
    memoryASet(ds, r32[esi] + 0x18, r8[al]);
  case 0x1e72ef: // 0160:1e72ef
    r32[ebx] = 0x00000010;
  case 0x1e72f4: // 0160:1e72f4
    r32[eax] = r32[ebp];
    r32[edx] = r32[edi];
    yield* sub_1eb0c2();
    if (memoryAGet(ds, r32[esi] + 0x15) != 0x58)
        { pc = 0x1e71c9; break; }
    r32[eax] = r32[edi];
    yield* sub_1e7484();
    { pc = 0x1e71c9; break; }
  case 0x1e7313: // 0160:1e7313
    if (memoryAGet32(ds, r32[esi] + 0x4))
        { pc = 0x1e732f; break; }
    if (!(memoryAGet(ds, r32[esi] + 0x14) & 0x80))
        { pc = 0x1e7328; break; }
    memoryASet32(ds, r32[esi] + 0x4, 0x0000000d);
    { pc = 0x1e732f; break; }
  case 0x1e7328: // 0160:1e7328
    memoryASet32(ds, r32[esi] + 0x4, 0x00000008);
  case 0x1e732f: // 0160:1e732f
    memoryASet(ds, r32[esi] + 0x14, memoryAGet(ds, r32[esi] + 0x14) & 0xf9);
    r32[eax] = memoryAGet32(ds, r32[edx]);
    r32[eax] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[eax]);
    r8[bl] = memoryAGet(ds, r32[esi] + 0x14);
    r32[ebp] = memoryAGet32(ds, r32[eax] - 4);
    if (!(r8[bl] & 0x80))
        { pc = 0x1e736e; break; }
    r32[eax] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[eax]);
    r32[ebx] = 0x00000004;
    r32[eax] = memoryAGet32(ds, r32[eax] - 4);
    r32[edx] = r32[edi];
    r32[eax] &= 0x0000ffff;
    yield* sub_1e6ef8();
    r32[ebx] = 0x00000008;
    r32[edx] = r32[edi] + 5;
    r32[eax] = r32[ebp];
    memoryASet(ds, r32[edi] + 0x4, 0x3a);
    { pc = 0x1e7377; break; }
  case 0x1e736e: // 0160:1e736e
    r32[ebx] = 0x00000008;
    r32[eax] = r32[ebp];
    r32[edx] = r32[edi];
  case 0x1e7377: // 0160:1e7377
    yield* sub_1e6ef8();
    if (memoryAGet(ds, r32[esi] + 0x15) != 0x50)
        { pc = 0x1e71d8; break; }
    r32[eax] = r32[edi];
    yield* sub_1e7484();
    { pc = 0x1e71d8; break; }
  case 0x1e7392: // 0160:1e7392
    r32[ebx] = memoryAGet32(ds, r32[edx]);
    r32[ebx] += 0x00000004;
    memoryASet32(ds, r32[edx], r32[ebx]);
    r8[al] = memoryAGet(ds, r32[ebx] - 4);
    memoryASet(ds, r32[edi] + 0x1, 0x00);
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet32(ds, r32[esi] + 0x8, 0x00000001);
    r32[eax] = 0x00000001;
    r8[dh] = memoryAGet(ds, r32[esi] + 0x14);
    r32[edi] = 0;
    r8[dh] &= 0xf9;
    memoryASet32(ds, r32[esp] + 0x4, r32[edi]);
    memoryASet(ds, r32[esi] + 0x14, r8[dh]);
    { pc = 0x1e73e9; break; }
  case 0x1e73bf: // 0160:1e73bf
    memoryASet32(ds, r32[esi] + 0x4, 0x00000000);
    r8[al] = memoryAGet(ds, r32[esi] + 0x15);
    memoryASet(ds, r32[edi] + 0x1, 0x00);
    memoryASet(ds, r32[edi], r8[al]);
    memoryASet32(ds, r32[esi] + 0x8, 0x00000001);
    r8[al] = memoryAGet(ds, r32[esi] + 0x14);
    r32[edi] = 0;
    r8[al] &= 0xf9;
    memoryASet32(ds, r32[esp] + 0x4, r32[edi]);
    memoryASet(ds, r32[esi] + 0x14, r8[al]);
    r32[eax] = 0x00000001;
  case 0x1e73e9: // 0160:1e73e9
    if (!memoryAGet32(ds, r32[esp] + 0x4))
        { pc = 0x1e742f; break; }
    r8[dl] = memoryAGet(es, r32[ecx]);
    if (r8[dl] != 0x2d)
        { pc = 0x1e7403; break; }
    r32[ecx]++;
    memoryASet(ds, r32[esi] + 0x18, 0x00);
    r32[eax]--;
    memoryASet(ds, r32[esi] + 0x17, r8[dl]);
    { pc = 0x1e741e; break; }
  case 0x1e7403: // 0160:1e7403
    r8[dh] = memoryAGet(ds, r32[esi] + 0x14);
    if (!(r8[dh] & 0x02))
        { pc = 0x1e7411; break; }
    memoryASet(ds, r32[esi] + 0x17, 0x20);
    { pc = 0x1e741a; break; }
  case 0x1e7411: // 0160:1e7411
    if (!(r8[dh] & 0x04))
        { pc = 0x1e741e; break; }
    memoryASet(ds, r32[esi] + 0x17, 0x2b);
  case 0x1e741a: // 0160:1e741a
    memoryASet(ds, r32[esi] + 0x18, 0x00);
  case 0x1e741e: // 0160:1e741e
    r32[edx] = memoryAGet32(ds, r32[esi] + 0x8);
    if (r32s[eax] <= r32s[edx])
        { pc = 0x1e742a; break; }
    memoryASet32(ds, r32[esi] + 0x8, r32[eax]);
    { pc = 0x1e742f; break; }
  case 0x1e742a: // 0160:1e742a
    r32[edx] -= r32[eax];
    memoryASet32(ds, r32[esi] + 0xc, r32[edx]);
  case 0x1e742f: // 0160:1e742f
    if (memoryAGet(ds, r32[esi] + 0x16) != 0x2a)
        { pc = 0x1e7442; break; }
    r8[dl] = memoryAGet(ds, r32[esi] + 0x14);
    memoryASet(ds, r32[esi] + 0x17, 0x00);
    r8[dl] &= 0xf9;
    memoryASet(ds, r32[esi] + 0x14, r8[dl]);
  case 0x1e7442: // 0160:1e7442
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x8);
    if (r32[ebx] == 0xffffffff)
        { pc = 0x1e744e; break; }
    if (r32s[eax] >= r32s[ebx])
        { pc = 0x1e7457; break; }
  case 0x1e744e: // 0160:1e744e
    if (memoryAGet(ds, r32[esi] + 0x15) == 0x63)
        { pc = 0x1e7457; break; }
    memoryASet32(ds, r32[esi] + 0x8, r32[eax]);
  case 0x1e7457: // 0160:1e7457
    r32[ebx] = 0xffffffff;
    r32[eax] = r32[esi] + 23;
    r32[edx] = ds;
    yield* sub_1e6eb1();
    r32[ebp] = memoryAGet32(ds, r32[esi] + 0x8);
    r32[edx] = memoryAGet32(ds, r32[esi] + 0xc);
    r32[eax] += r32[ebp];
    r32[ebx] = memoryAGet32(ds, r32[esi] + 0x4);
    r32[eax] += r32[edx];
    r32[edx] = es;
    r32[ebx] -= r32[eax];
    r32[eax] = r32[ecx];
    memoryASet32(ds, r32[esi] + 0x4, r32[ebx]);
    r32[esp] += 0x00000008;
    r32[ebp] = pop32();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e7484() // 0160:1e7484 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
  case 0x1e7487: // 0160:1e7487
    if (!memoryAGet(ds, r32[edx]))
        { pc = 0x1e749a; break; }
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[edx]);
    yield* sub_1eb126();
    memoryASet(ds, r32[edx], r8[al]);
    r32[edx]++;
    { pc = 0x1e7487; break; }
  case 0x1e749a: // 0160:1e749a
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e749c() // 0160:1e749c +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push(fs);
    if (memoryAGet32(ds, 0x20a724))
        { pc = 0x1e7567; break; }
    fs = memoryAGet16(ds, 0x20a765);
    r32[ecx] = 0;
    r8[dl] = 0;
    r32[eax] = fs;
    r32[edi] = memoryAGet32(ds, 0x20a761);
    es = r32[eax];
    r32[eax] = r32[edi];
  case 0x1e74c7: // 0160:1e74c7
    if (r8[dl] == memoryAGet(es, r32[eax]))
        { pc = 0x1e74df; break; }
  case 0x1e74cc: // 0160:1e74cc
    r8[dh] = memoryAGet(es, r32[eax]);
    r32[ebx] = r32[eax] + 1;
    if (r8[dl] == r8[dh])
        { pc = 0x1e74da; break; }
    r32[eax] = r32[ebx];
    { pc = 0x1e74cc; break; }
  case 0x1e74da: // 0160:1e74da
    r32[ecx]++;
    r32[eax] = r32[ebx];
    { pc = 0x1e74c7; break; }
  case 0x1e74df: // 0160:1e74df
    r32[eax] -= r32[edi];
    if (r32[eax])
        { pc = 0x1e74e8; break; }
    r32[eax] = 0x00000001;
  case 0x1e74e8: // 0160:1e74e8
    yield* sub_1e3562();
    r32[edx] = r32[eax];
    r32[ebx] = r32[eax];
    if (!r32[eax])
        { pc = 0x1e7567; break; }
    r32[eax] = r32[ecx];
    r32[eax] <<= 2;
    r32[eax] += 0x00000004;
    r32[eax] += r32[ecx];
    yield* sub_1e3562();
    if (!r32[eax])
        { pc = 0x1e7560; break; }
    memoryASet32(ds, 0x20a724, r32[eax]);
    r32[esi] = 0;
    r32[eax] = fs;
    r32[ecx] = 0;
    es = r32[eax];
    r32[eax] = r32[edi];
  case 0x1e751b: // 0160:1e751b
    if (!memoryAGet(es, r32[eax]))
        { pc = 0x1e753b; break; }
    r32[edx] = memoryAGet32(ds, 0x20a724);
    memoryASet32(ds, r32[ecx] + r32[edx], r32[ebx]);
  case 0x1e752a: // 0160:1e752a
    r8[dl] = memoryAGet(es, r32[eax]);
    r32[eax]++;
    memoryASet(ds, r32[ebx], r8[dl]);
    r32[ebx]++;
    if (r8[dl])
        { pc = 0x1e752a; break; }
    r32[ecx] += 0x00000004;
    r32[esi]++;
    { pc = 0x1e751b; break; }
  case 0x1e753b: // 0160:1e753b
    r32[edx] = memoryAGet32(ds, 0x20a724);
    memoryASet32(ds, r32[ecx] + r32[edx], 0x00000000);
    r32[ecx] += 0x00000004;
    r32[edx] += r32[ecx];
    r32[ebx] = r32[esi];
    memoryASet32(ds, 0x20a728, r32[edx]);
    r32[eax] = r32[edx];
    r32[edx] = 0;
    yield* sub_1e3de0();
    { pc = 0x1e7567; break; }
  case 0x1e7560: // 0160:1e7560
    r32[eax] = r32[edx];
    yield* sub_1e3df8();
  case 0x1e7567: // 0160:1e7567
    fs = pop();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e763f() // 0160:1e763f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    { pc = 0x1e763f; break; }
  case 0x1e7639: // 0160:1e7639
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1e763f: // 0160:1e763f
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    push32(r32[eax]);
    if (r32[eax] < memoryAGet32(ds, 0x20a744))
        { pc = 0x1e76a6; break; }
    if (memoryAGet(ds, 0x20a75e))
        { pc = 0x1e76b8; break; }
    r32[ebp] = memoryAGet32(ds, r32[esp]);
    r32[ebp] += 0x0000000f;
    r32[ebp] >>>= 4;
    if (r32[ebp])
        { pc = 0x1e766a; break; }
    r32[ebp] = 0x0fffffff;
  case 0x1e766a: // 0160:1e766a
    r32[ebx] = 0;
    r32[eax] = ds;
    r16[bx] = r16[ax];
    r8[ah] = 0xed;
    interrupt(0x21);
    r32[eax] <<= 31;
    r32[edi] &= 0x0000ffff;
    r32[edi] |= r32[eax];
    if (r32s[edi] >= 0)
        { pc = 0x1e7694; break; }
    es = r32[edi];
    r32[ebx] = r32[ebp];
    r8[ah] = 0x4a;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    if (r32s[eax] < 0)
        { pc = 0x1e76a6; break; }
  case 0x1e7694: // 0160:1e7694
    r32[eax] = ds;
    es = r32[eax];
    r32[ebx] = r32[ebp];
  case 0x1e769a: // 0160:1e769a
    r8[ah] = 0x4a;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    if (r32s[eax] >= 0)
        { pc = 0x1e76e9; break; }
  case 0x1e76a6: // 0160:1e76a6
    yield* sub_1e7875();
    memoryASet32(ds, r32[eax], 0x00000005);
    r32[eax] = 0xffffffff;
    { pc = 0x1e76f7; break; }
  case 0x1e76b8: // 0160:1e76b8
    r32[ebx] = memoryAGet32(ds, r32[esp]);
    r32[ebx] += 0x00000fff;
    r32[ebx] >>>= 12;
    if (r32[ebx])
        { pc = 0x1e76cd; break; }
    r32[ebx] = 0x000fffff;
  case 0x1e76cd: // 0160:1e76cd
    r8[dl] = memoryAGet(ds, 0x20a75e);
    if (r8[dl] != 0x01)
        { pc = 0x1e76e3; break; }
    if (r8[dl] != memoryAGet(ds, 0x20a75f))
        { pc = 0x1e76e3; break; }
    r32[ebx] <<= 8;
  case 0x1e76e3: // 0160:1e76e3
    r32[eax] = ds;
    es = r32[eax];
    { pc = 0x1e769a; break; }
  case 0x1e76e9: // 0160:1e76e9
    r32[ebx] = memoryAGet32(ds, r32[esp]);
    r32[eax] = memoryAGet32(ds, 0x20a730);
    memoryASet32(ds, 0x20a730, r32[ebx]);
  case 0x1e76f7: // 0160:1e76f7
    r32[esp] += 0x00000004;
    r32[ebp] = pop32();
    es = pop();
    { pc = 0x1e7639; break; }
    return;
  }
}
function* sub_1e7701() // 0160:1e7701 +long
{
    r32[esp] -= 4;
    r32[eax] = r32[esp];
    r32[eax] -= memoryAGet32(ds, 0x20a740);
    r32[esp] += 4;
}
function* sub_1e770a() // 0160:1e770a +long
{
    r32[esp] -= 4;
    memoryASet32(ds, 0x20a7c0, 0x00008000);
    r32[esp] += 4;
}
function* sub_1e7715() // 0160:1e7715 +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r32[ebx] = r32[edx];
    yield* sub_1e771f();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1e771f() // 0160:1e771f +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esp] -= 0x00000020;
    r32[ecx] = r32[eax];
    r32[eax] = memoryAGet32(ds, r32[edx]);
    memoryASet32(ss, r32[ebp] - 32, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x4);
    memoryASet32(ss, r32[ebp] - 28, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ss, r32[ebp] - 24, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
    memoryASet32(ss, r32[ebp] - 20, r32[eax]);
    if (!(r8[cl] & 0x40))
        { pc = 0x1e774b; break; }
    r32[esi] = 0x00000001;
    { pc = 0x1e7785; break; }
  case 0x1e774b: // 0160:1e774b
    if (!(r8[cl] & 0x80))
        { pc = 0x1e7757; break; }
    r32[esi] = 0x00000002;
    { pc = 0x1e7785; break; }
  case 0x1e7757: // 0160:1e7757
    if (!(r8[ch] & 0x01))
        { pc = 0x1e7763; break; }
    r32[esi] = 0x00000003;
    { pc = 0x1e7785; break; }
  case 0x1e7763: // 0160:1e7763
    if (!(r8[ch] & 0x08))
        { pc = 0x1e776f; break; }
    r32[esi] = 0x00000004;
    { pc = 0x1e7785; break; }
  case 0x1e776f: // 0160:1e776f
    if (!(r8[ch] & 0x02))
        { pc = 0x1e777b; break; }
    r32[esi] = 0x00000006;
    { pc = 0x1e7785; break; }
  case 0x1e777b: // 0160:1e777b
    if (!(r8[ch] & 0x04))
        { pc = 0x1e7785; break; }
    r32[esi] = 0x00000005;
  case 0x1e7785: // 0160:1e7785
    r32[eax] = r32[ecx];
    r32[eax] &= 0x0000001f;
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x20a7c0);
    memoryASet32(ss, r32[ebp] - 40, r32[esi]);
    memoryASet32(ss, r32[ebp] - 36, r32[eax]);
    if (!(r8[ch] & 0x10))
        { pc = 0x1e77a9; break; }
    fld64(memoryAGet64(ds, 0x20b734));
    fchs();
    memoryASet64(ss, r32[ebp] - 16, fstp64());
    { pc = 0x1e77eb; break; }
  case 0x1e77a9: // 0160:1e77a9
    if (!(r8[ch] & 0x20))
        { pc = 0x1e77b8; break; }
    r32[ecx] = 0;
    memoryASet32(ss, r32[ebp] - 16, r32[ecx]);
    memoryASet32(ss, r32[ebp] - 12, r32[ecx]);
    { pc = 0x1e77eb; break; }
  case 0x1e77b8: // 0160:1e77b8
    if (!(r8[ch] & 0x40))
        { pc = 0x1e77cc; break; }
    r32[edx] = 0;
    r32[ebx] = 0x3ff00000;
    memoryASet32(ss, r32[ebp] - 16, r32[edx]);
    memoryASet32(ss, r32[ebp] - 12, r32[ebx]);
    { pc = 0x1e77eb; break; }
  case 0x1e77cc: // 0160:1e77cc
    if (!(r8[ch] & 0x80))
        { pc = 0x1e77e0; break; }
    r32[eax] = memoryAGet32(ds, 0x20b734);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    r32[eax] = memoryAGet32(ds, 0x20b738);
    { pc = 0x1e77e8; break; }
  case 0x1e77e0: // 0160:1e77e0
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    memoryASet32(ss, r32[ebp] - 16, r32[eax]);
    r32[eax] = memoryAGet32(ds, r32[ebx] + 0x4);
  case 0x1e77e8: // 0160:1e77e8
    memoryASet32(ss, r32[ebp] - 12, r32[eax]);
  case 0x1e77eb: // 0160:1e77eb
    r32[eax] = r32[ebp] - 40;
    yield* sub_1eb182();
    r32[esp] = r32[ebp] - 8;
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebp] = pop32();
    stop("stack_unbalanced");
    r32[esp] += 4;
    return;
  }
}
function* sub_1e77fa() // 0160:1e77fa +long +stackDrop12
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebp]);
    r32[ebp] = r32[esp];
    push32(r32[eax]);
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[esp] -= 0x00000008;
    r8[cl] = memoryAGet(ss, r32[ebp] + 0x10);
    if (r8[cl] < 0x01)
        { pc = 0x1e783d; break; }
    if (r8[cl] <= 0x03)
        { pc = 0x1e7818; break; }
    if (r8[cl] == 0x04)
        { pc = 0x1e7829; break; }
    { pc = 0x1e783d; break; }
  case 0x1e7818: // 0160:1e7818
    r8[al] = r8[cl];
    r8[al] |= 0x40;
    r32[eax] &= 0x000000ff;
    r32[edx] = r32[ebp] + 8;
    r8[ah] |= 0x20;
    { pc = 0x1e785f; break; }
  case 0x1e7829: // 0160:1e7829
    fldz();
    fcomp64(memoryAGet64(ss, r32[ebp] + 0x8));
    r16[ax] = fnstsw();
    sahf();
    if (stop("TODO: reads sahf"))
        { pc = 0x1e783d; break; }
    r32[edx] = 0;
    memoryASet32(ss, r32[ebp] - 24, r32[edx]);
    memoryASet32(ss, r32[ebp] - 20, r32[edx]);
    { pc = 0x1e7867; break; }
  case 0x1e783d: // 0160:1e783d
    r32[ebx] = 0;
    r8[bl] = r8[cl];
    r32[edx] = r32[ebx];
    r8[dh] |= 0x81;
    if (r8[cl] != 0x06)
        { pc = 0x1e785a; break; }
    fldz();
    fcomp64(memoryAGet64(ss, r32[ebp] + 0x8));
    r16[ax] = fnstsw();
    sahf();
    if (stop("TODO: reads sahf"))
        { pc = 0x1e785a; break; }
    r8[bh] |= 0x11;
    r32[edx] = r32[ebx];
  case 0x1e785a: // 0160:1e785a
    r32[eax] = r32[edx];
    r32[edx] = r32[ebp] + 8;
  case 0x1e785f: // 0160:1e785f
    yield* sub_1e7715();
    memoryASet64(ss, r32[ebp] - 24, fstp64());
  case 0x1e7867: // 0160:1e7867
    fld64(memoryAGet64(ss, r32[ebp] - 24));
    r32[esp] = r32[ebp] - 16;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[eax] = pop32();
    r32[ebp] = pop32();
    stop("stack_unbalanced");
    r32[esp] += 16;
    return;
  }
}
function* sub_1e7875() // 0160:1e7875 +long
{
    r32[esp] -= 4;
    r32[eax] = 0x003164e4;
    r32[esp] += 4;
}
function* sub_1e787b() // 0160:1e787b +long
{
    r32[esp] -= 4;
    r32[eax] = 0x003164e0;
    r32[esp] += 4;
}
function* sub_1e788d() // 0160:1e788d +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r8[bl] = r8[al];
    r32[eax] = 0;
    r8[al] = r8[dl];
    yield* sub_1e53f4();
    if (r32[edx] >= 0x00000100)
        { pc = 0x1e78dc; break; }
    if (memoryAGet(ds, 0x20a767) < 0x03)
        { pc = 0x1e78c6; break; }
    if (r8[dl] != 0x50)
        { pc = 0x1e78b6; break; }
    r8[bl] = 0x0e;
    { pc = 0x1e78c6; break; }
  case 0x1e78b6: // 0160:1e78b6
    if (r8[dl] < 0x22)
        { pc = 0x1e78bf; break; }
    r8[bl] = 0x13;
    { pc = 0x1e78c6; break; }
  case 0x1e78bf: // 0160:1e78bf
    if (r8[dl] < 0x20)
        { pc = 0x1e78c6; break; }
    r8[bl] = 0x05;
  case 0x1e78c6: // 0160:1e78c6
    if (r8[bl] <= 0x13)
        { pc = 0x1e78cd; break; }
    r8[bl] = 0x13;
  case 0x1e78cd: // 0160:1e78cd
    r32[edx] = 0;
    r8[dl] = r8[bl];
    r32[eax] = memoryAGet32(ds, r32[edx] + 0x20a81d);
    r32[eax] = sar32(r32[eax], 0x18);
    { pc = 0x1e78e6; break; }
  case 0x1e78dc: // 0160:1e78dc
    r32[eax] = r32[edx];
    r32[eax] >>>= 8;
    r32[eax] &= 0x000000ff;
  case 0x1e78e6: // 0160:1e78e6
    yield* sub_1e53d1();
    r32[eax] = 0xffffffff;
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1e78f3() // 0160:1e78f3 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = 0;
    r32[eax] = memoryAGet32(ds, 0x20a750);
    memoryASet32(ds, 0x20a750, r32[edx]);
    if (r32[eax])
        { pc = 0x1e790e; break; }
    r8[ah] = 0x01;
    interrupt(0x21);
    r32[eax] &= 0x000000ff;
  case 0x1e790e: // 0160:1e790e
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eac7e() // 0160:1eac7e +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push(es);
    push32(r32[ebp]);
    push32(r32[edx]);
    r32[ebp] = r32[eax];
    r16[ax] = 0x1600;
    interrupt(0x2f);
    if (!r8[al])
        { pc = 0x1eace4; break; }
    if (r8[al] == 0x80)
        { pc = 0x1eace4; break; }
    r8[al] = 0;
    r32[edx] = 0;
    r32[ecx] = 0;
    r32[ebx] = 0;
    r8[ah] = 0xfa;
    interrupt(0x2f);
    if (r16[ax] != 0x0666)
        { pc = 0x1eace4; break; }
    r8[al] = 0x22;
    r32[edx] = 0;
    r32[ecx] = 0;
    r32[ebx] = 0;
    r8[ah] = 0xfa;
    interrupt(0x2f);
    if (r16[ax])
        { pc = 0x1eace4; break; }
    r8[dh] = 0x01;
    r8[al] = 0x1e;
    r32[ecx] = 0;
    r32[ebx] = 0;
    memoryASet(ds, 0x20a8b9, r8[dh]);
    r32[edx] = 0;
    r8[ah] = 0xfa;
    interrupt(0x2f);
    r32[eax] = cs;
    r32[ebx] = 0x003164e8;
    r32[edx] = r32[eax];
    r32[ecx] = r32[ebx];
    r8[al] = 0x20;
    r32[ecx] >>>= 16;
    r8[ah] = 0xfa;
    interrupt(0x2f);
    r8[al] = 0x01;
    { pc = 0x1ead3e; break; }
  case 0x1eace4: // 0160:1eace4
    r32[edx] = memoryAGet32(ds, r32[esp]);
    if (r32[ebp])
        { pc = 0x1eacf0; break; }
    if (!r16[dx])
        { pc = 0x1ead3c; break; }
  case 0x1eacf0: // 0160:1eacf0
    r32[esi] = 0x0020b54c;
    r32[eax] = 0x00000a00;
    push(es);
    interrupt(0x31);
    r32[eax] = -flags.carry;
    es = pop();
    if (r32[eax])
        { pc = 0x1ead3c; break; }
    r32[eax] = 0x00000007;
    r32[ebx] = 0x001e7e40;
    r32[ecx] = cs;
    yield* sub_1eb71b();
    es = memoryAGet16(ds, r32[esp]);
    r8[ah] = memoryAGet(es, r32[ebp] + 0x40);
    memoryASet(es, r32[ebp] + 0x3e, 0x01);
    r8[ah] |= 0x04;
    memoryASet(es, r32[ebp] + 0x40, r8[ah]);
    r32[eax] = r32[cr0];
    r8[al] |= 0x04;
    r8[dl] = 0x01;
    r32[cr0] = r32[eax];
    r8[ah] = 0x30;
    interrupt(0x21);
    memoryASet(ds, 0x20a8b8, r8[dl]);
  case 0x1ead3c: // 0160:1ead3c
    r8[al] = 0;
  case 0x1ead3e: // 0160:1ead3e
    r32[esp] += 0x00000004;
    r32[ebp] = pop32();
    es = pop();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eada2() // 0160:1eada2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push(r16[ax]);
    fninit();
    fld1();
    fldz();
    fdivp80(st(1));
    fld80(st(0));
    fchs();
    fcompp();
    r16[ax] = fnstsw();
    r8[al] = 0x02;
    sahf();
    if (flags.zero)
        { pc = 0x1eadbc; break; }
    r8[al] = 0x03;
  case 0x1eadbc: // 0160:1eadbc
    fninit();
    fldcw(memoryAGet16(ds, r32[esp]));
    r16[tx] = memoryAGet16(ds, r32[esp]); memoryASet16(ds, r32[esp], r16[ax]); r16[ax] = r16[tx];
    r16[ax] = pop();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eadc9() // 0160:1eadc9 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r8[ah] = memoryAGet(ds, 0x20a551);
    r8[ah] &= 0xf8;
    r8[dl] = r8[ah];
    memoryASet(ds, 0x20a551, r8[ah]);
    r8[dl] |= 0x04;
    r32[ecx] = 0x0020a510;
    memoryASet(ds, 0x20a551, r8[dl]);
    { pc = 0x1eae30; break; }
  case 0x1eaded: // 0160:1eaded
    r32[eax] = 0x00000008;
    yield* sub_1e3562();
    r32[ebx] = r32[eax];
    if (r32[eax])
        { pc = 0x1eae1c; break; }
    r32[eax] = 0x00000008;
    yield* sub_1e3562();
    r32[ebx] = r32[eax];
    if (r32[eax])
        { pc = 0x1eae1c; break; }
    r32[eax] = 0x0020b55c;
    r32[edx] = 0x00000001;
    yield* sub_1eb6fe();
  case 0x1eae1c: // 0160:1eae1c
    r32[edx] = memoryAGet32(ds, 0x3164d0);
    memoryASet32(ds, r32[ebx] + 0x4, r32[ecx]);
    memoryASet32(ds, 0x3164d0, r32[ebx]);
    r32[ecx] += 0x0000001a;
    memoryASet32(ds, r32[ebx], r32[edx]);
  case 0x1eae30: // 0160:1eae30
    r32[edx] = memoryAGet32(ds, r32[ecx] + 0xc);
    if (r32[edx])
        { pc = 0x1eaded; break; }
    memoryASet32(ds, 0x3164c8, r32[edx]);
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eaea4() // 0160:1eaea4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000004;
    r32[esi] = r32[eax];
    memoryASet32(ds, r32[esp], r32[edx]);
    r32[ebp] = r32[ebx];
    yield* sub_1eaf8a();
    if (!(r8[al] & 0x80))
        { pc = 0x1eaee8; break; }
    r8[al] = 0x02;
    r32[ebx] = r32[esi];
    r32[edx] = 0;
    r8[ah] = 0x42;
    r32[ecx] = r32[edx];
    r32[ecx] >>>= 16;
    interrupt(0x21);
    r16[dx] = rcl16(r16[dx], 0x0001);
    r16[dx] = ror16(r16[dx], 0x0001);
    r32[edx] <<= 16;
    r16[dx] = r16[ax];
    r32[edi] = r32[edx];
    if (r32s[edx] >= 0)
        { pc = 0x1eaee8; break; }
    r32[eax] = 0;
    r16[ax] = r16[dx];
  case 0x1eaee1: // 0160:1eaee1
    yield* sub_1e788d();
    { pc = 0x1eaf18; break; }
  case 0x1eaee8: // 0160:1eaee8
    r32[edx] = memoryAGet32(ds, r32[esp]);
    r32[ebx] = r32[esi];
    r32[ecx] = r32[ebp];
    r8[ah] = 0x40;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    r32[esi] = r32[eax];
    r32[edi] = r32[eax];
    r32[edx] = r32[eax];
    if (r32s[eax] >= 0)
        { pc = 0x1eaf08; break; }
    r32[eax] = 0;
    r16[ax] = r16[si];
    { pc = 0x1eaee1; break; }
  case 0x1eaf08: // 0160:1eaf08
    if (r32[eax] == r32[ebp])
        { pc = 0x1eaf16; break; }
    r32[eax] = 0x0000000c;
    yield* sub_1e53d1();
  case 0x1eaf16: // 0160:1eaf16
    r32[eax] = r32[edx];
  case 0x1eaf18: // 0160:1eaf18
    r32[esp] += 0x00000004;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eaf20() // 0160:1eaf20 +long
{
  var pc = 0;
  var temp_cf;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    if (!(r32[edx] & 0x7ff00000))
        { pc = 0x1eaf68; break; }
    r32[ebx] = 0;
    flags.carry = overflow32(r32[eax], r32[eax]);
    r32[eax] += r32[eax];
    temp_cf = flags.carry;
    temp_cf = overflow32(r32[edx], r32[edx], flags.carry);
    r32[edx] += (r32[edx] + flags.carry);
    flags.carry = temp_cf;
    r32[ebx] = rcr32(r32[ebx], 0x00000001);
    flags.carry = overflow32(r32[eax], 0x20000000);
    r32[eax] += 0x20000000;
    r32[edx] += (0x00000000 + flags.carry);
    if (!r32[edx])
        { pc = 0x1eaf5f; break; }
    if (r32[edx] >= 0x8fe00000)
        { pc = 0x1eaf5f; break; }
    if (r32[edx] < 0x70200000)
        { pc = 0x1eaf68; break; }
    r32[edx] -= 0x70000000;
    flags.carry = overflow32(r32[eax], r32[eax]);
    r32[eax] += r32[eax];
    r32[edx] += (r32[edx] + flags.carry);
    flags.carry = overflow32(r32[eax], r32[eax]);
    r32[eax] += r32[eax];
    r32[edx] += (r32[edx] + flags.carry);
    r32[edx] |= r32[ebx];
    r32[eax] = r32[edx];
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1eaf5f: // 0160:1eaf5f
    r32[eax] = 0x7f800000;
    r32[eax] |= r32[ebx];
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1eaf68: // 0160:1eaf68
    r32[eax] = 0;
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eaf6c() // 0160:1eaf6c +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    r8[al] = 0x00;
    r8[ah] = 0x44;
    interrupt(0x21);
    r32[edx] = rcl32(r32[edx], 0x00000001);
    r32[edx] = ror32(r32[edx], 0x00000001);
    r8[al] = r8[dl] & 0x80;
    r32[eax] &= 0x000000ff;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1eaf8a() // 0160:1eaf8a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[edx]);
    r32[edx] = r32[eax];
    if (r32[eax] < memoryAGet32(ds, 0x20a8cc))
        { pc = 0x1eaf9d; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4; return;
  case 0x1eaf9d: // 0160:1eaf9d
    if (r32s[eax] > signed32(0x00000005))
        { pc = 0x1eafd3; break; }
    r32[ebx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x20a920);
    r32[ebx] <<= 2;
    r32[eax] += r32[ebx];
    r8[cl] = memoryAGet(ds, r32[eax] + 0x1);
    if (r8[cl] & 0x40)
        { pc = 0x1eafd3; break; }
    r8[ch] = r8[cl];
    r8[ch] |= 0x40;
    memoryASet(ds, r32[eax] + 0x1, r8[ch]);
    r32[eax] = r32[edx];
    yield* sub_1eaf6c();
    if (!r32[eax])
        { pc = 0x1eafd3; break; }
    r32[eax] = memoryAGet32(ds, 0x20a920);
    memoryASet(ds, r32[ebx] + r32[eax] + 0x1, memoryAGet(ds, r32[ebx] + r32[eax] + 0x1) | 0x20);
  case 0x1eafd3: // 0160:1eafd3
    r32[eax] = memoryAGet32(ds, 0x20a920);
    r32[eax] = memoryAGet32(ds, r32[eax] + r32[edx] * 4);
    r32[edx] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eafdf() // 0160:1eafdf +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    r8[dh] |= 0x40;
    r32[ebx] = r32[edx];
    r32[edx] = r32[eax];
    r32[eax] = memoryAGet32(ds, 0x20a920);
    r32[edx] <<= 2;
    memoryASet32(ds, r32[edx] + r32[eax], r32[ebx]);
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1eaff4() // 0160:1eaff4 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[eax];
    r8[ah] = 0x41;
    interrupt(0x21);
    r32[eax] = rcl32(r32[eax], 0x00000001);
    r32[eax] = ror32(r32[eax], 0x00000001);
    if (r32s[eax] >= 0)
        { pc = 0x1eb00f; break; }
    r32[eax] &= 0x0000ffff;
    yield* sub_1e788d();
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1eb00f: // 0160:1eb00f
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb038() // 0160:1eb038 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000028;
    r32[ebp] = r32[edx];
    r32[edi] = r32[ebx];
    r32[esi] = r32[edx];
    r8[dl] = 0;
    r32[ecx] = r32[esp] + 1;
    memoryASet(ds, r32[esp], r8[dl]);
  case 0x1eb04e: // 0160:1eb04e
    r32[ebx] = r32[esp] + 36;
    memoryASet32(ds, r32[esp] + 0x24, r32[edi]);
    r32[edx] = 0;
    div32(memoryAGet32(ds, r32[ebx]));
    memoryASet32(ds, r32[ebx], r32[eax]);
    r8[al] = memoryAGet(cs, r32[edx] + 0x1eb013);
    memoryASet(ds, r32[ecx], r8[al]);
    r32[eax] = memoryAGet32(ds, r32[esp] + 0x24);
    r32[ecx]++;
    if (r32[eax])
        { pc = 0x1eb04e; break; }
  case 0x1eb06e: // 0160:1eb06e
    r32[ecx]--;
    r8[al] = memoryAGet(ds, r32[ecx]);
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    if (r8[al])
        { pc = 0x1eb06e; break; }
    r32[eax] = r32[ebp];
    r32[esp] += 0x00000028;
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb082() // 0160:1eb082 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[edx];
    if (r32[ebx] != 0x0000000a)
        { pc = 0x1eb094; break; }
    if (r32s[eax] >= 0)
        { pc = 0x1eb094; break; }
    r32[eax] = -r32[eax];
    memoryASet(ds, r32[edx], 0x2d);
    r32[edx]++;
  case 0x1eb094: // 0160:1eb094
    yield* sub_1eb038();
    r32[eax] = r32[ecx];
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb0c2() // 0160:1eb0c2 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[ebp]);
    r32[esp] -= 0x00000028;
    push32(r32[edx]);
    r32[ebp] = r32[ebx];
    r32[esi] = r32[edx];
    r8[dl] = 0;
    r32[ecx] = r32[esp] + 5;
    memoryASet(ds, r32[esp] + 0x4, r8[dl]);
  case 0x1eb0d7: // 0160:1eb0d7
    r32[ebx] = r32[esp] + 40;
    memoryASet32(ds, r32[esp] + 0x28, r32[ebp]);
    r32[edx] = 0;
    div32(memoryAGet32(ds, r32[ebx]));
    memoryASet32(ds, r32[ebx], r32[edx]);
    r32[edx] = memoryAGet32(ds, r32[esp] + 0x28);
    r8[dl] = memoryAGet(cs, r32[edx] + 0x1eb09d);
    memoryASet(ds, r32[ecx], r8[dl]);
    r32[ecx]++;
    if (r32[eax])
        { pc = 0x1eb0d7; break; }
  case 0x1eb0f7: // 0160:1eb0f7
    r32[ecx]--;
    r8[al] = memoryAGet(ds, r32[ecx]);
    memoryASet(ds, r32[esi], r8[al]);
    r32[esi]++;
    if (r8[al])
        { pc = 0x1eb0f7; break; }
    r32[eax] = memoryAGet32(ds, r32[esp]);
    r32[esp] += 0x0000002c;
    r32[ebp] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb10b() // 0160:1eb10b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ecx]);
    r32[ecx] = r32[edx];
    if (r32[ebx] != 0x0000000a)
        { pc = 0x1eb11d; break; }
    if (r32s[eax] >= 0)
        { pc = 0x1eb11d; break; }
    r32[eax] = -r32[eax];
    memoryASet(ds, r32[edx], 0x2d);
    r32[edx]++;
  case 0x1eb11d: // 0160:1eb11d
    yield* sub_1eb0c2();
    r32[eax] = r32[ecx];
    r32[ecx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb126() // 0160:1eb126 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (r32s[eax] < signed32(0x00000061))
        { pc = 0x1eb133; break; }
    if (r32s[eax] > signed32(0x0000007a))
        { pc = 0x1eb133; break; }
    r32[eax] -= 0x00000020;
  case 0x1eb133: // 0160:1eb133
    r32[esp] += 4; return;
    return;
  }
}
function* sub_1eb13a() // 0160:1eb13a +long
{
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    r32[esi] = r32[eax];
    r32[ecx] = r32[edx];
    r32[eax] = 0x00000002;
    yield* sub_1eb74b();
    r32[ebx] = r32[eax];
    r32[eax] = r32[esi];
    r32[edx] = r32[ebx];
    r32[eax] = memoryAGet32(ds, r32[eax] * 4 + 0x20b73c);
    yield* sub_1eb76a();
    r32[eax] = 0x0020b611;
    r32[edx] = r32[ebx];
    yield* sub_1eb76a();
    r32[eax] = r32[ecx];
    r32[edx] = r32[ebx];
    yield* sub_1eb76a();
    r32[eax] = 0x0000000a;
    r32[edx] = r32[ebx];
    yield* sub_1e69fe();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
}
function* sub_1eb182() // 0160:1eb182 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[edx]);
    r32[ebx] = r32[eax];
    yield* indirectCall(cs, memoryAGet32(ds, 0x20a924));
    if (r32[eax])
        { pc = 0x1eb1ab; break; }
    r32[edx] = memoryAGet32(ds, r32[ebx] + 0x4);
    r32[eax] = memoryAGet32(ds, r32[ebx]);
    yield* sub_1eb13a();
    if (memoryAGet32(ds, r32[ebx]) != 0x00000001)
        { pc = 0x1eb1a6; break; }
    yield* sub_1e53cc();
    { pc = 0x1eb1ab; break; }
  case 0x1eb1a6: // 0160:1eb1a6
    yield* sub_1e53dd();
  case 0x1eb1ab: // 0160:1eb1ab
    fld64(memoryAGet64(ds, r32[ebx] + 0x18));
    r32[edx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb6fe() // 0160:1eb6fe +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    r32[ebx] = r32[eax];
    r32[ecx] = r32[edx];
    r32[edx] = ds;
    yield* sub_1ebce6();
    if (r32[eax])
        { pc = 0x1eb718; break; }
    r32[eax] = r32[ebx];
    r32[edx] = r32[ecx];
    yield* sub_1e3979();
  case 0x1eb718: // 0160:1eb718
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb71b() // 0160:1eb71b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    r32[edx] = r32[ebx];
    r8[bl] = memoryAGet(ds, 0x20a75e);
    if (r8[bl] < 0x02)
        { pc = 0x1eb73c; break; }
    if (r8[bl] > 0x08)
        { pc = 0x1eb73c; break; }
    push(ds);
    ds = r32[ecx];
    r8[cl] = r8[al];
    r8[al] = 0x04;
    r8[ah] = 0x25;
    interrupt(0x21);
    ds = pop();
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1eb73c: // 0160:1eb73c
    push(ds);
    ds = r32[ecx];
    r8[ah] = 0x25;
    interrupt(0x21);
    ds = pop();
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb74b() // 0160:1eb74b +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[edx]);
    if (r32[eax] <= 0x00000005)
        { pc = 0x1eb755; break; }
    r32[eax] = 0;
    r32[edx] = pop32();
    r32[esp] += 4; return;
  case 0x1eb755: // 0160:1eb755
    r32[edx] = r32[eax];
    r32[eax] <<= 2;
    r32[eax] -= r32[edx];
    r32[eax] <<= 2;
    r32[eax] += r32[edx];
    r32[eax] += r32[eax];
    r32[eax] += 0x0020a510;
    r32[edx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1eb76a() // 0160:1eb76a +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    push32(r32[ebx]);
    push32(r32[ecx]);
    push32(r32[esi]);
    push32(r32[edi]);
    push32(r32[ebp]);
    r32[ecx] = r32[eax];
    r32[ebx] = r32[edx];
    if (memoryAGet32(ds, r32[edx] + 0x8))
        { pc = 0x1eb780; break; }
    r32[eax] = r32[ebx];
    yield* sub_1e5407();
  case 0x1eb780: // 0160:1eb780
    r8[ah] = memoryAGet(ds, r32[ebx] + 0xd);
    r32[edi] = 0;
    if (!(r8[ah] & 0x04))
        { pc = 0x1eb79f; break; }
    r8[dl] = r8[ah];
    r8[dl] &= 0xf9;
    r8[dh] = r8[dl];
    memoryASet(ds, r32[ebx] + 0xd, r8[dl]);
    r8[dh] |= 0x02;
    r32[edi] = 0x00000001;
    memoryASet(ds, r32[ebx] + 0xd, r8[dh]);
  case 0x1eb79f: // 0160:1eb79f
    r32[ebp] = r32[ecx];
    r32[esi] = 0;
  case 0x1eb7a3: // 0160:1eb7a3
    r32[eax] = 0;
    r8[al] = memoryAGet(ds, r32[ecx]);
    if (!r32[eax])
        { pc = 0x1eb7ba; break; }
    r32[edx] = r32[ebx];
    r32[ecx]++;
    yield* sub_1e69fe();
    if (r32[eax] != 0xffffffff)
        { pc = 0x1eb7a3; break; }
    r32[esi] = r32[eax];
  case 0x1eb7ba: // 0160:1eb7ba
    if (!r32[edi])
        { pc = 0x1eb7db; break; }
    r8[al] = memoryAGet(ds, r32[ebx] + 0xd);
    r8[al] &= 0xf9;
    r8[ah] = r8[al];
    memoryASet(ds, r32[ebx] + 0xd, r8[al]);
    r8[ah] |= 0x04;
    memoryASet(ds, r32[ebx] + 0xd, r8[ah]);
    if (r32[esi])
        { pc = 0x1eb7db; break; }
    r32[eax] = r32[ebx];
    yield* sub_1e58fc();
    r32[esi] = r32[eax];
  case 0x1eb7db: // 0160:1eb7db
    if (r32[esi])
        { pc = 0x1eb7e3; break; }
    r32[esi] = r32[ecx];
    r32[esi] -= r32[ebp];
  case 0x1eb7e3: // 0160:1eb7e3
    r32[eax] = r32[esi];
    r32[ebp] = pop32();
    r32[edi] = pop32();
    r32[esi] = pop32();
    r32[ecx] = pop32();
    r32[ebx] = pop32();
    r32[esp] += 4;
    return;
  }
}
function* sub_1ebce6() // 0160:1ebce6 +long
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r32[esp] -= 4;
    if (!memoryAGet(ds, 0x20a92c))
        { pc = 0x1ebd09; break; }
    r32[edx] &= 0x0000ffff;
    push32(r32[edx]);
    push32(r32[eax]);
    stop("breakpoint");
    { pc = 0x1ebd00; break; }
    // gap 6 bytes // gap 6 bytes
  case 0x1ebd00: // 0160:1ebd00
    r32[eax] = 0x00000001;
    r32[esp] += 0x00000008;
    r32[esp] += 4; return;
  case 0x1ebd09: // 0160:1ebd09
    r32[eax] = 0;
    r32[esp] += 4;
    return;
  }
}
function fixReloc(seg)
{
}

