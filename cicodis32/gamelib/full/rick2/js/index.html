<canvas id="canvas" style="position:relative; left:120px; width:80%; max-width:100vw; aspect-ratio: 640/400;"></canvas><br>

<script src="controls.js"></script>
<script src="resources.js"></script>
<script src="ega.js"></script>

<script>
"use strict";
let cs, ds, es, ss, sp;
const ax = 0, bx = 1, cx = 2, dx = 3, tx = 4, si = 5, di = 6, bp = 7;
const al = 0, ah = 1, bl = 2, bh = 3, cl = 4, ch = 5, dl = 6, dh = 7, tl = 8, th = 9;
const r0 = new ArrayBuffer(16);
const r16 = new Uint16Array(r0, 0, 8);
const r16s = new Int16Array(r0, 0, 8);
const r8 = new Uint8Array(r0, 0, 16);
const r8s = new Int8Array(r0, 0, 16);
const memorybuf = new ArrayBuffer(0x10000*6);
const memory = new Uint8Array(memorybuf, 0, 0x10000*6);
const memorys = new Int8Array(memorybuf, 0, 0x10000*6);
const video = new Ega();

function stop()
{
  console.trace();
  throw "stop"
}
function assert(cond)
{
  if (!cond)
  {                
    console.trace();
    throw "assertion failed"
  }
}

function load(archive, exec, size)
{
  var b = Module["main.exe"];
  var ofs = loadAddress*16 - headerSize;
  for (var i=0; i<b.length; i++)
    memory[i+ofs] = b[i];
}

function push(r)
{
    assert(sp >= 10 && sp < 0xfff0);
    sp -= 2;
    memorySet16(ss, sp, r);
}
function pop()
{
    assert(sp >= 10 && sp < 0xfff0);
    var aux = memoryGet16(ss, sp);
    sp += 2;
    return aux;
}
/*
function memoryASet16(seg, ofs, v)
{
  if (seg == 0x0040 && ofs == 0x004e)
    return;
  assert(seg >= 0x1000);
  assert(seg < 0xa000);
  assert(ofs >= 0 && ofs < 0xffff);
  var i = seg*16+ofs;
  assert(i < memory.length);

  memory[i] = v & 0xff;
  memory[i+1] = v >> 8;
}
function memoryAGet16(seg, ofs)
{   
  if (seg == 0x0040 && ofs == 0x0063)
    return 0x3d4;
  assert(seg < 0xa000);
  assert(seg >= 0x1000);
  assert(ofs >= 0 && ofs < 0xffff);
  var i = seg*16+ofs;
  assert(i < memory.length);
  return memory[i] | (memory[i+1]<<8);
}
function memoryASet(seg, ofs, v)
{
  if (seg >= 0xa000)
  {
    video.write(seg*16+ofs, v);
    return;
  }
  assert(seg > 0x1000);
  assert(seg < 0xa000);
  assert(ofs >= 0 && ofs < 0xffff);
  var i = seg*16+ofs;
  assert(i < memory.length);

  memory[i] = v;
}
function memoryAGet(seg, ofs)
{
  if (seg >= 0xa000)
  {
    return video.read(seg*16+ofs);
  }
  assert(seg > 0x1000);
  assert(seg < 0xa000);
  assert(ofs >= 0 && ofs <= 0xffff);
  var i = seg*16+ofs;
  assert(i < memory.length);
  return memory[i];
}
*/
/*
function memoryASet(seg, ofs, v)
{
  if (seg >= 0xa000)
  {
    video.write(seg*16+ofs, v);
    return;
  }
  assert(seg > 0x1000);
  assert(seg < 0xa000);
  assert(ofs >= 0 && ofs < 0xffff);
  var i = seg*16+ofs;
  assert(i < memory.length);

  memory[i] = v;
}
*/
function memoryGet(seg, ofs)
{
  let i = seg*16+ofs;
  assert(i >= 0x10000 && i < memory.length);
  return memory[i];
}

function memorySet(seg, ofs, v)
{
  let i = seg*16+ofs;
  assert(i >= 0x10000 && i < memory.length);
  memory[i] = v;
}

function memoryGet16(seg, ofs)
{
  let i = seg*16+ofs;
  assert(i >= 0x10000 && i < memory.length);
  return memory[i] | (memory[i+1]<<8);
}

function memorySet16(seg, ofs, v)
{
  let i = seg*16+ofs;
  assert(i >= 0x10000 && i < memory.length);
  memory[i] = v;
  memory[i+1] = v>>8;
}

function memoryVideoSet(seg, ofs, v)
{
  video.write(seg*16+ofs, v);
}

function memoryVideoGet(seg, ofs)
{
  return video.read(seg*16+ofs);
}

function memoryVideoGet16(seg, ofs)
{
  return video.read(seg*16+ofs) | (video.read(seg*16+ofs+1)<<8);
}


function memoryBiosGet16(seg, ofs)
{
  if (seg == 0x0040 && ofs == 0x0063)
    return 0x3d4;
  return 0;
}

function memoryBiosSet16(seg, ofs, v)
{
}

function signed8(v)
{
  r8[th] = v;
  return r8s[th];
}
function signed16(v)
{
  r16[tx] = v;
  return r16s[tx];
}

function movsb_MemFwdESDI_MemFwdDSSI() 
{
  assert(flags.direction == 0);
  memorySet(es, r16[di]++, memoryGet(ds, r16[si]++));
}
function movsw_MemFwdESDI_MemFwdDSSI() 
{
  assert(flags.direction == 0);
  memorySet(es, r16[di]++, memoryGet(ds, r16[si]++));
  memorySet(es, r16[di]++, memoryGet(ds, r16[si]++));
}
function movsw_MemBwdESDI_MemBwdDSSI() 
{                              
  assert(flags.direction == 1);
  memorySet(es, r16[di]--, memoryGet(ds, r16[si]--));
  memorySet(es, r16[di]--, memoryGet(ds, r16[si]--));
}
function stosw_MemFwdESDI() 
{
  assert(flags.direction == 0);
  memorySet(es, r16[di]++, r8[al]);
  memorySet(es, r16[di]++, r8[ah]);
}

function movsw_VideoFwdESDI_VideoFwdDSSI() 
{
  assert(flags.direction == 0);
  memoryVideoSet(es, r16[di]++, memoryVideoGet(ds, r16[si]++));
  memoryVideoSet(es, r16[di]++, memoryVideoGet(ds, r16[si]++));
}

function movsw_VideoFwdESDI_MemFwdDSSI()
{
  assert(flags.direction == 0);
  memoryVideoSet(es, r16[di]++, memoryGet(ds, r16[si]++));
  memoryVideoSet(es, r16[di]++, memoryGet(ds, r16[si]++));
}

function movsb_VideoFwdESDI_MemFwdDSSI()
{
  assert(flags.direction == 0);
  memoryVideoSet(es, r16[di]++, memoryGet(ds, r16[si]++));
}

function movsb_VideoFwdESDI_VideoFwdDSSI() 
{
  assert(flags.direction == 0);
  memoryVideoSet(es, r16[di]++, memoryVideoGet(ds, r16[si]++));
}

function stosb_MemFwdESDI() 
{
  memorySet(es, r16[di]++, r8[al]);
}
function lodsb_VideoFwdDSSI() 
{ 
  assert(flags.direction == 0);
  return memoryVideoGet(ds, r16[si]++);
}
function stosb_VideoFwdESDI() 
{
  memoryVideoSet(es, r16[di]++, r8[al]);
}
function lodsb_MemFwdDSSI() 
{ 
  assert(flags.direction == 0);
  return memoryGet(ds, r16[si]++);
}


/*
function movsb_ESDI_DSSI() 
{
  assert(flags.direction == 0);
  memoryASet(es, r16[di]++, memoryAGet(ds, r16[si]++));
}
function movsw_ESDI_DSSI() 
{
  if(flags.direction == 0)
  {
    memoryASet(es, r16[di]++, memoryAGet(ds, r16[si]++));
    memoryASet(es, r16[di]++, memoryAGet(ds, r16[si]++));
  } else {
    memoryASet(es, r16[di]--, memoryAGet(ds, r16[si]--));
    memoryASet(es, r16[di]--, memoryAGet(ds, r16[si]--));
  }
}

function stosw_ESDI() 
{
  assert(flags.direction == 0);
  memoryASet(es, r16[di]++, r8[al]);
  memoryASet(es, r16[di]++, r8[ah]);
}
function lodsb_DSSI() 
{ 
  assert(flags.direction == 0);
  return memoryAGet(ds, r16[si]++);
}
function lodsw_DSSI() 
{ 
  assert(flags.direction == 0);
  let v = memoryAGet16(ds, r16[si]);
  r16[si] += 2;
  return v;
}
function stosb_ESDI() 
{
  memoryASet(es, r16[di]++, r8[al]);
}

*/
function out8(port, val) {
 console.log("out8", port.toString(16), val.toString(16))
}
let flags = {carry:0, zero:0}

function interrupt(i)
{
  console.log("interrupt", i.toString(16), r16[ax].toString(16))
}

function interrupt(i)
{
  if (i == 0x10 && video.interrupt(i))
    return;  
  if (i == 0x21 && r8[ah] == 0x35)
    return; // get int vect
  if (i == 0x21 && r8[ah] == 0x25)
    return; // set int vect
  if (i == 0x15 && r8[ah] == 0x84)
  {
      flags.carry = true;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x2c)
  {
      r8[ch] = Math.random()*256;
      r8[cl] = Math.random()*256;
      r8[dh] = 117;
      r8[dl] = 150;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x3d)
  {
      var filename = "";
      var dot = false;
      for (var i=0; i<100; i++)
      {
          var c = String.fromCharCode(memory[ds*16+r16[dx]+i]);
          if (c==' ')
              continue;
          if (c=='\0')
              break;
          if (c=='\\')
              c = "/";
          filename += c;
      }
      console.log("Open: " + filename);
      if (!Module[filename])
        throw "resource not found";
      window.currentFile = {ofs:0, len:Module[filename].length, data:Module[filename]};
      flags.carry = 0;
      r16[ax] = 1;
      return; 
  }
  if (i == 0x21 && r8[ah] == 0x3f)
  {
      var bytes = Math.min(r16[cx], window.currentFile.len); 
      var wptr = ds*16+r16[dx];
      var rptr = window.currentFile.ofs;
      r16[ax] = bytes;
      window.currentFile.ofs += bytes;
      while (bytes--)
          memory[wptr++] = window.currentFile.data[rptr++];
      flags.carry = 0;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x3e)
  {   
      window.currentFile = null;
      return;
  }
  if (i == 0x16 && r8[ah] == 0x01)
  {
      flags.zero = lastKey == null;
      return; 
  }
  if (i == 0x16 && r8[ah] == 0x00)
  {
      r16[ax] = lastKey;
      lastKey = -1;
      return; 
  }
  if (i == 0x21 && r8[ah] == 0x30)
  {
      r16[ax] = 0x0005;
      r16[bx] = 0xff00;
      r16[cx] = 0x0000;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x44)
  {
      r16[ax] = 2;
      r16[dx] = 2;
      flags.carry = false;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x42)
  {
      if (r8[al] == 2 && r16[cx] == 0 && r16[dx] == 0)
      {
          r16[ax] = window.currentFile.len;
          r16[dx] = window.currentFile.ofs>>16;
          return;
      }
      if (r8[al] == 1)
      {
          window.currentFile.ofs += r16[cx]*0x10000 + r16[dx];
          r16[ax] = window.currentFile.ofs;
          r16[dx] = window.currentFile.ofs>>16;
          flags.carry = false;
          return;
      }
      if (r8[al] == 0)
      {
          window.currentFile.ofs = r16[cx]*0x10000 + r16[dx];
          r16[ax] = window.currentFile.ofs;
          r16[dx] = window.currentFile.ofs>>16;
          flags.carry = false;
          return;
      }
  }
  if (i == 0x21 && r8[ah] == 0x43)
  {
      r16[cx] = 1<<5;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x40)
  {
      flags.carry = false;
      r16[ax] = r16[cx];
      return;
  }
  if (i == 0x21 && r8[ah] == 0x19)
  {
      r8[al] = 2;
      return;
  }
  if (i == 0x15 && r8[ah] == 0x06)
  {
      return;
  }
  if (i == 0x11)
  {
      r16[ax] = 0;
      return;
  }
  if (i == 0x33)
  {
      r16[ax] = -1;
      r16[bx] = 3;
      return;
  }
  if (i == 0x21 && r8[ah] == 0x4a)
  {
      console.log("Resize ", endAddress.toString(16), "->", (loadAddress+r16[bx]).toString(16))
      assert(loadAddress+r16[bx] >= endAddress);
      endAddress = loadAddress+r16[bx];
      flags.carry = false;
      return;
  }
    if (i == 0x21 && r8[ah] == 0x48)
    {
        if (r16[bx]>=0xf000)
        {
            r16[bx] = 0x810c;
            flags.carry = true;
            return;
        }
        assert (r16[bx] < 0xf000);
        console.log("Alloc", r16[bx].toString(16), "->", endAddress.toString(16));
        r16[ax] = endAddress;
        endAddress += r16[bx];
        endAddress++;
        flags.carry = false;
        return;
    }
  console.log(i.toString(16), r8[ah].toString(16), r8[al].toString(16));
  throw "unhandled interrupt"
}
function cbw()
{
    r8[ah] = (r8[al] & 0x80) ? 0xff : 0;
}
function rcr8(r, c)
{
    assert(c == 1);
    var newCarry = !!(r & 0x1);
    r >>= 1;
    r |= flags.carry ? 0x80 : 0;
    flags.carry = newCarry;
    return r;
}

function mul16(v16)
{
    var v = v16 * r16[ax];
    r16[ax] = v & 0xffff;
    r16[dx] = v >> 16;
}
function sar8(a, b)
{
    r8[tl] = a;
    r8s[tl] >>= b;
    return r8[tl];
}
function sar16(a, b)
{
    r16[tx] = a;
    r16s[tx] >>= b;
    return r16[tx];
}
function rol16(r, l)
{
    return (r << l) | (r >> (16-l));
}

function out8(port, val)
{
  if (port >= 0x200)
    video.portWrite8(port, val);
}
function out16(port, val)
{
  video.portWrite16(port, val);
}
function* sync(k)
{
  yield 0;
}

function flagAsReg()
{
  return flags.zero + flags.carry*2;
}
function flagsFromReg(r)
{
  flags.zero = r &1;
  flags.carry = (r>>1) & 1;
}

let counter = 0;
function in8(port)
{
    if (port == 0x3da)
        return (counter++ & 1) ? 9 : 0;
    if (port == 0x40)
        return (counter++ & 2) ? 0xff:0x00;
    if (port == 0x201)
        return 0;
    if (port == 0x3d4 || port == 0x3d5)
        return video.PortRead8(port);
  return 0;
}
var can = document.getElementById("canvas");
var ctx = can.getContext('2d');
can.width = 320;
can.height = 200;
var data = ctx.createImageData(can.width, can.height);

function display()
{
  var p = 0;
  var pixels = data.data;
    for (var x=0; x<200; x++)
  for (var y=0; y<320; y++)
    {
      var c = video.getPixel(y, x);
      pixels[p++] = c>>16;
      pixels[p++] = (c>>8)&0xff;
      pixels[p++] = c & 0xff;
      pixels[p++] = 255;
    }
  ctx.putImageData(data, 0, 0);
}

</script>
<script src="rick2.js"></script>
<script>
function tick() {}
let seq = start();
init();
setInterval(()=>{
//  for (var i=0; i<50; i++) {
  tick();
  seq.next();
//}
  display();
}, 20);
</script>
<script src="replay.js"></script>
