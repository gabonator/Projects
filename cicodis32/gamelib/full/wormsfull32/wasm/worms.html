<canvas id="canvas" width="320" height="200" style="border: 1px solid #d0d0d0; width:960px; height:600px;"></canvas>
<script src="wasmapp.js"></script>
<script src="fflate.js"></script>
<script>
"use strict"

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

let fsCurrent = {name:null, data:null}
let archive = null;

function fsRequest(name)
{
  if (name == fsCurrent.name)
    return Promise.resolve(fsCurrent.data);
  fsCurrent = {data: archive[name], name:name}
  return Promise.resolve(fsCurrent.data)
}

var game = new WasmApp(fsRequest, {apiSound:play8BitPCM});
fetch("app.wasm")
  .then(x => x.arrayBuffer())
  .then(x => game.load(x))
  .then(() => fetch("worms.zip"))
  .then(x => x.arrayBuffer())
  .then(x => archive = fflate.unzipSync(new Uint8Array(x)))
  .then(() => {
    var frameBuffer = new Uint8ClampedArray(game.memory.buffer, game.HEAP32[game.symbols.appFrameBuffer.value>>2], 320 * 200 * 4);

    game.symbols.appMain();
    setInterval(() => {
      const img = new ImageData(frameBuffer, 320, 200);
      ctx.putImageData(img, 0, 0);
      if (game.sleeping)
        game.asyncifyResume();
    }, 50)
  })

// mouse
let mouseAccumulatorX = 0;
let mouseAccumulatorY = 0;

document.addEventListener("click", () => {
  if (!document.pointerLockElement)
    canvas.requestPointerLock();
});

document.addEventListener("mousedown", (e) => {
  if (game.symbols)
    game.HEAP32[game.symbols.mouseB.value>>2] = e.button+1;
});
document.addEventListener("mouseup", (e) => {
  if (game.symbols)
    game.HEAP32[game.symbols.mouseB.value>>2] = 0;
});

function updatePosition(event) {
  if (!game.symbols)
    return;

  let speed = 2;
  mouseAccumulatorX += event.movementX;
  mouseAccumulatorY += event.movementY;
  let mouseDivX = Math.floor(mouseAccumulatorX/speed);
  let mouseDivY = Math.floor(mouseAccumulatorY/speed);
  mouseAccumulatorX -= mouseDivX*speed;
  mouseAccumulatorY -= mouseDivY*speed;
  game.HEAP32[game.symbols.mouseX.value>>2] += mouseDivX;
  game.HEAP32[game.symbols.mouseY.value>>2] += mouseDivY;
}

document.addEventListener("pointerlockchange", () => {
  if (document.pointerLockElement === canvas) {
    console.log("Pointer locked");
    document.addEventListener("mousemove", updatePosition);
  } else {
    console.log("Pointer unlocked");
    document.removeEventListener("mousemove", updatePosition);
  }
});

// sound
const audioCtx = new window.AudioContext();

function play8BitPCM(ofs, len) {
  const audioBuffer = audioCtx.createBuffer(1, len, 16000);
  const floatData = audioBuffer.getChannelData(0);

  for (let i = 0; i < len; i++)
    floatData[i] = game.HEAPS8[ofs+i] / 128 / 3;

  const source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(audioCtx.destination);
  source.start();
}

// keyboard

document.onkeydown = evt => {
  if (onKey(evt.keyCode, 1))
    evt.preventDefault();
}
document.onkeyup = evt => {
  if (onKey(evt.keyCode, 0))
    evt.preventDefault();
}

function onKey(code, pressed)
{
  const keyToScanCode = {
    27:0x01, 49:0x02, 50:0x03, 51:0x04, 52:0x05, 53:0x06, 54:0x07, 55:0x08, 56:0x09, 57:0x0A, 48:0x0B,
    189:0x0C, 187:0x0D, 8:0x0E, /*9:0x0F,*/ 81:0x10, 87:0x11, 69:0x12, 82:0x13, 84:0x14, 89:0x15, 85:0x16,
    73:0x17, 79:0x18, 80:0x19, 219:0x1A, 221:0x1B, 13:0x1C, 17:0x1D, 65:0x1E, 83:0x1F, 68:0x20, 70:0x21,
    71:0x22, 72:0x23, 74:0x24, 75:0x25, 76:0x26, 186:0x27, 222:0x28, 192:0x29, 16:0x2A, 220:0x2B, 90:0x2C,
    88:0x2D, 67:0x2E, 86:0x2F, 66:0x30, 78:0x31, 77:0x32, 188:0x33, 190:0x34, 191:0x35, /*18:0x38,*/ 32:0x39,
    20:0x3A, 112:0x3B, 113:0x3C, 114:0x3D, 115:0x3E, 116:0x3F, 117:0x40, 118:0x41, 119:0x42, 120:0x43, 121:0x44,
    36:0x47, 38:0x48, 33:0x49, 37:0x4B, 39:0x4D, 35:0x4F, 40:0x50, 34:0x51, 45:0x52, 46:0x53
  };

  var scancode = keyToScanCode[code];
  if (scancode && game.HEAPU8)
  {
    game.HEAPU8[3842104-0x187000+scancode] = pressed;
    return true;
  }
  return false;
}

</script>
