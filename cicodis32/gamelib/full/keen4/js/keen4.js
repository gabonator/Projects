function init()
{
    headerSize = 0x2df0;
    loadAddress = 0x01ed;
    endAddress = 0x424d;
    cs = 0x01ed;
    ds = 0x01dd;
    es = 0x01dd;
    ss = 0x3f59;
    sp = 0x0080;
    load("keen4.zip", "KEEN4.EXE", 263472);
    fixReloc(loadAddress);
}

function* start()
{
    yield* sub_1ed0();
}

function* sub_1ed0() // 01ed:0000 +stackDrop2 +entry
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    r16[dx] = 0x30d4;
    memoryASet16(cs, 0x023c, r16[dx]);
    r8[ah] = 0x30;
    interrupt(0x21);
    r16[bp] = memoryAGet16(ds, 0x0002);
    r16[bx] = memoryAGet16(ds, 0x002c);
    ds = r16[dx];
    memoryASet16(ds, 0x0092, r16[ax]);
    memoryASet16(ds, 0x0090, es);
    memoryASet16(ds, 0x008c, r16[bx]);
    memoryASet16(ds, 0x00a8, r16[bp]);
    yield* sub_203b();
    r16[di] = memoryAGet16(ds, 0x008a); es = memoryAGet16(ds, 0x008c);
    r16[ax] = r16[di];
    r16[bx] = r16[ax];
    r16[cx] = 0x7fff;
    flags.direction = 0;
  case 0x1f04:
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    if (!r16[cx])
        { pc = 0x1f69; break; }
    r16[bx]++;
    if (memoryAGet(es, r16[di]) != r8[al])
        { pc = 0x1f04; break; }
    r8[ch] |= 0x80;
    r16[cx] = -r16[cx];
    memoryASet16(ds, 0x008a, r16[cx]);
    r16[cx] = 0x0001;
    r16[bx] <<= r8[cl];
    r16[bx] += 0x0008;
    r16[bx] &= 0xfff8;
    memoryASet16(ds, 0x008e, r16[bx]);
    r16[dx] = ds;
    r16[bp] -= r16[dx];
    r16[di] = memoryAGet16(ds, 0x7344);
    if (r16[di] >= 0x0200)
        { pc = 0x1f3b; break; }
    r16[di] = 0x0200;
    memoryASet16(ds, 0x7344, r16[di]);
  case 0x1f3b:
    flags.carry = r16[di] + 0xe846 >= 0x10000;
    r16[di] += 0xe846;
    if (flags.carry)
        { pc = 0x1f69; break; }
    flags.carry = r16[di] + memoryAGet16(ds, 0x7104) >= 0x10000;
    r16[di] += memoryAGet16(ds, 0x7104);
    if (flags.carry)
        { pc = 0x1f69; break; }
    r8[cl] = 0x04;
    r16[di] >>= r8[cl];
    r16[di]++;
    if (r16[bp] < r16[di])
        { pc = 0x1f69; break; }
    if (!memoryAGet16(ds, 0x7344))
        { pc = 0x1f5e; break; }
    if (memoryAGet16(ds, 0x7104))
        { pc = 0x1f6c; break; }
  case 0x1f5e:
    r16[di] = 0x1000;
    if (r16[bp] > r16[di])
        { pc = 0x1f6c; break; }
    r16[di] = r16[bp];
    { pc = 0x1f6c; break; }
  case 0x1f69:
    { pc = 0x20f6; break; }
  case 0x1f6c:
    r16[bx] = r16[di];
    r16[bx] += r16[dx];
    memoryASet16(ds, 0x00a0, r16[bx]);
    memoryASet16(ds, 0x00a4, r16[bx]);
    r16[ax] = memoryAGet16(ds, 0x0090);
    r16[bx] -= r16[ax];
    es = r16[ax];
    r8[ah] = 0x4a;
    push(r16[di]);
    interrupt(0x21);
    r16[di] = pop();
    r16[di] <<= r8[cl];
    flags.interrupts = 0;
    ss = r16[dx];
    sp = r16[di];
    flags.interrupts = 1;
    r16[ax] = 0;
    es = memoryAGet16(cs, 0x023c);
    r16[di] = 0x7464;
    r16[cx] = 0xe846;
    r16[cx] -= r16[di];
    flags.direction = 0;
    for (; r16[cx] != 0; --r16[cx]) stosb_ESDI(r8[al]);
    r8[ah] = 0x00;
    interrupt(0x1a);
    memoryASet16(ds, 0x0096, r16[dx]);
    memoryASet16(ds, 0x0098, r16[cx]);
    r16[bp] = 0;
    r16[ax] = 0x30d4;
    ds = r16[ax];
    r16[si] = 0x744c;
    r16[di] = 0x7464;
    yield* sub_20ab();
    ds = memoryAGet16(cs, 0x023c);
    memoryASet(cs, 0x01ed, 0x72);
    memoryASet(cs, 0x01dc, 0x00);
    push(memoryAGet16(ds, 0x0088));
    push(memoryAGet16(ds, 0x0086));
    push(memoryAGet16(ds, 0x0084));
    push(cs); cs = 0x056a; yield* sub_5d4b(); assert(cs == 0x01ed);
    push(r16[ax]);
    push(cs);
    yield* sub_248b();
    r16[ax] = 0x30d4;
    ds = r16[ax];
    r16[si] = 0x7464;
    r16[di] = 0x7464;
    yield* sub_20ab();
    ds = memoryAGet16(cs, 0x023c);
    push(cs); cs = memoryAGet16(ds, 0x6f8c); indirectCall(cs, memoryAGet16(ds, 0x6f8a)); assert(cs == 0x01ed); // 01ed:0126
    push(cs); cs = memoryAGet16(ds, 0x6f90); indirectCall(cs, memoryAGet16(ds, 0x6f8e)); assert(cs == 0x01ed); // 01ed:012a
    push(cs); cs = memoryAGet16(ds, 0x6f94); indirectCall(cs, memoryAGet16(ds, 0x6f92)); assert(cs == 0x01ed); // 01ed:012e
    push(r16[ax]);
    ds = memoryAGet16(cs, 0x023c);
    push(cs);
    yield* sub_207e();
    r16[ax] = 0;
    r16[si] = r16[ax];
    r16[cx] = 0x002f;
  case 0x2013:
    flags.carry = r8[al] + memoryAGet(ds, r16[si]) >= 0x100;
    r8[al] += memoryAGet(ds, r16[si]);
    r8[ah] += (0x00 + flags.carry);
    r16[si]++;
    if (--r16[cx])
        { pc = 0x2013; break; }
    r16[ax] -= 0x0d5c;
    if (!r16[ax])
        { pc = 0x2029; break; }
    r16[cx] = 0x0019;
    r16[dx] = 0x002f;
    yield* sub_20ee();
  case 0x2029:
    r16[bp] = sp;
    r8[ah] = 0x4c;
    r8[al] = memoryAGet(ss, r16[bp] + 4);
    interrupt(0x21);
    stop("terminating");
    // gap 196 bytes
  case 0x20f6:
    r16[cx] = 0x001e;
    r16[dx] = 0x0056;
    ds = memoryAGet16(cs, 0x023c);
    yield* sub_20ee();
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs);
    yield* sub_2003();
    memoryASet(ds, r16[bx] + r16[si], memoryAGet(ds, r16[bx] + r16[si]) + r8[al]);
    r8[al] += memoryAGet(ds, r16[bx] + r16[si] + 35669);
    r8[al] = in8(r16[dx]);
    if (memoryAGet16(ds, 0x6e86) != 0x0020)
        { pc = 0x211f; break; }
    r16[ax] = 0x0001;
    { pc = 0x213b; break; }
  case 0x211f:
    r16[bx] = memoryAGet16(ds, 0x6e86);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx] + 30950, r16[ax]);
    memoryASet16(ds, r16[bx] + 30948, r16[dx]);
    memoryASet16(ds, 0x6e86, memoryAGet16(ds, 0x6e86) + 1);
    r16[ax] = 0;
  case 0x213b:
    r16[bp] = pop();
    stop("stack_unbalanced");
    cs = pop();
    return;
  }
}
function* sub_1fe3() // 01ed:0113
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[ax] = 0x30d4;
    ds = r16[ax];
    r16[si] = 0x7464;
    r16[di] = 0x7464;
    yield* sub_20ab();
    ds = memoryAGet16(cs, 0x023c);
    push(cs); cs = memoryAGet16(ds, 0x6f8c); indirectCall(cs, memoryAGet16(ds, 0x6f8a)); assert(cs == 0x01ed); // 01ed:0126
    push(cs); cs = memoryAGet16(ds, 0x6f90); indirectCall(cs, memoryAGet16(ds, 0x6f8e)); assert(cs == 0x01ed); // 01ed:012a
    push(cs); cs = memoryAGet16(ds, 0x6f94); indirectCall(cs, memoryAGet16(ds, 0x6f92)); assert(cs == 0x01ed); // 01ed:012e
    push(r16[ax]);
    ds = memoryAGet16(cs, 0x023c);
    push(cs);
    yield* sub_207e();
    r16[ax] = 0;
    r16[si] = r16[ax];
    r16[cx] = 0x002f;
  case 0x2013:
    flags.carry = r8[al] + memoryAGet(ds, r16[si]) >= 0x100;
    r8[al] += memoryAGet(ds, r16[si]);
    r8[ah] += (0x00 + flags.carry);
    r16[si]++;
    if (--r16[cx])
        { pc = 0x2013; break; }
    r16[ax] -= 0x0d5c;
    if (!r16[ax])
        { pc = 0x2029; break; }
    r16[cx] = 0x0019;
    r16[dx] = 0x002f;
    yield* sub_20ee();
  case 0x2029:
    r16[bp] = sp;
    r8[ah] = 0x4c;
    r8[al] = memoryAGet(ss, r16[bp] + 4);
    interrupt(0x21);
    stop("terminating");
    return;
  }
}
function* sub_2003() // 01ed:0133
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    ds = memoryAGet16(cs, 0x023c);
    push(cs);
    yield* sub_207e();
    r16[ax] = 0;
    r16[si] = r16[ax];
    r16[cx] = 0x002f;
  case 0x2013:
    flags.carry = r8[al] + memoryAGet(ds, r16[si]) >= 0x100;
    r8[al] += memoryAGet(ds, r16[si]);
    r8[ah] += (0x00 + flags.carry);
    r16[si]++;
    if (--r16[cx])
        { pc = 0x2013; break; }
    r16[ax] -= 0x0d5c;
    if (!r16[ax])
        { pc = 0x2029; break; }
    r16[cx] = 0x0019;
    r16[dx] = 0x002f;
    yield* sub_20ee();
  case 0x2029:
    r16[bp] = sp;
    r8[ah] = 0x4c;
    r8[al] = memoryAGet(ss, r16[bp] + 4);
    interrupt(0x21);
    stop("terminating");
    return;
  }
}
function* sub_203b() // 01ed:016b
{
    sp -= 2;
    push(ds);
    r16[ax] = 0x3500;
    interrupt(0x21);
    memoryASet16(ds, 0x0074, r16[bx]);
    memoryASet16(ds, 0x0076, es);
    r16[ax] = 0x3504;
    interrupt(0x21);
    memoryASet16(ds, 0x0078, r16[bx]);
    memoryASet16(ds, 0x007a, es);
    r16[ax] = 0x3505;
    interrupt(0x21);
    memoryASet16(ds, 0x007c, r16[bx]);
    memoryASet16(ds, 0x007e, es);
    r16[ax] = 0x3506;
    interrupt(0x21);
    memoryASet16(ds, 0x0080, r16[bx]);
    memoryASet16(ds, 0x0082, es);
    r16[ax] = 0x2500;
    r16[dx] = cs;
    ds = r16[dx];
    r16[dx] = 0x0162;
    interrupt(0x21);
    ds = pop();
    sp += 2;
}
function* sub_207e() // 01ed:01ae +stackDrop2
{
    sp -= 2;
    push(ds);
    r16[ax] = 0x2500;
    r16[dx] = memoryAGet16(ds, 0x0074); ds = memoryAGet16(ds, 0x0076);
    interrupt(0x21);
    ds = pop();
    push(ds);
    r16[ax] = 0x2504;
    r16[dx] = memoryAGet16(ds, 0x0078); ds = memoryAGet16(ds, 0x007a);
    interrupt(0x21);
    ds = pop();
    push(ds);
    r16[ax] = 0x2505;
    r16[dx] = memoryAGet16(ds, 0x007c); ds = memoryAGet16(ds, 0x007e);
    interrupt(0x21);
    ds = pop();
    push(ds);
    r16[ax] = 0x2506;
    r16[dx] = memoryAGet16(ds, 0x0080); ds = memoryAGet16(ds, 0x0082);
    interrupt(0x21);
    ds = pop();
    sp += 2; cs = pop();
}
function* sub_20ab() // 01ed:01db
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
  case 0x20ab:
    r8[ah] = 0xff;
    r16[dx] = r16[di];
    r16[bx] = r16[si];
  case 0x20b1:
    if (r16[bx] == r16[di])
        { pc = 0x20c9; break; }
    if (memoryAGet(ds, r16[bx]) == 0xff)
        { pc = 0x20c4; break; }
    if (memoryAGet(ds, r16[bx] + 1) > r8[ah])
        { pc = 0x20c4; break; }
    r8[ah] = memoryAGet(ds, r16[bx] + 1);
    r16[dx] = r16[bx];
  case 0x20c4:
    r16[bx] += 0x0006;
    { pc = 0x20b1; break; }
  case 0x20c9:
    if (r16[dx] == r16[di])
        { pc = 0x20ed; break; }
    r16[bx] = r16[dx];
    push(ds);
    es = pop();
    push(es);
    flags.zero = memoryAGet(ds, r16[bx]) == 0x00;
    memoryASet(ds, r16[bx], 0xff);
    ds = memoryAGet16(cs, 0x023c);
    if (flags.zero)
        { pc = 0x20e6; break; }
    push(cs); cs = memoryAGet16(es, r16[bx] + 4); indirectCall(cs, memoryAGet16(es, r16[bx] + 2)); assert(cs == 0x01ed); // 01ed:020f
    ds = pop();
    { pc = 0x20ab; break; }
  case 0x20e6:
    switch (memoryAGet16(es, r16[bx] + 2))
    {
        case 0x12a3: yield* sub_3173(); break;
        case 0x36f4: yield* sub_55c4(); break;
        case 0x35e1: yield* sub_54b1(); break;
        case 0x181e: yield* sub_36ee(); break;
        default:
            stop("ind 01ed:0216");
    }
    ds = pop();
    { pc = 0x20ab; break; }
  case 0x20ed:
    sp += 2; return;
    return;
  }
}
function* sub_20ee() // 01ed:021e
{
    sp -= 2;
    r8[ah] = 0x40;
    r16[bx] = 0x0002;
    interrupt(0x21);
    sp += 2;
}
function* sub_213d() // 01ed:026d +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16s[si] < 0)
        { pc = 0x214d; break; }
    if (r16s[si] < signed16(0x0014))
        { pc = 0x2156; break; }
  case 0x214d:
    r16[ax] = 0x0006;
    push(r16[ax]);
    yield* sub_3a4b();
    { pc = 0x2167; break; }
  case 0x2156:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, 0xffff);
    push(r16[si]);
    push(cs);
    yield* sub_3604();
    r16[cx] = pop();
  case 0x2167:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_216a() // 01ed:029a +stackDrop6
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet(ss, r16[bp] - 5, 0x00);
    yield* sub_3357();
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    yield* sub_3357();
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0x226b; break; }
  case 0x2193:
    r16[bx] = r16[si];
    r16[si]++;
    r8[al] = memoryAGet(ds, r16[bx]);
    memoryASet(ss, r16[bp] - 5, r8[al]);
    r8[ah] = 0x00;
    r16[ax] -= 0x0007;
    r16[bx] = r16[ax];
    if (r16[bx] > 0x0006)
        { pc = 0x21d5; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x21ae; break; }
        case 2: { pc = 0x21b7; break; }
        case 4: { pc = 0x21d5; break; }
        case 6: { pc = 0x21d0; break; }
        case 8: { pc = 0x21d5; break; }
        case 10: { pc = 0x21d5; break; }
        case 12: { pc = 0x21c6; break; }
        default:
            stop("ind 01ed:02d9");
    }
    break;
  case 0x21ae:
    r8[ah] = 0x0e;
    r8[al] = 0x07;
    yield* sub_366a();
    { pc = 0x222d; break; }
  case 0x21b7:
    r8[al] = memoryAGet(ds, 0x7348);
    r8[ah] = 0x00;
    if (r16s[ax] >= signed16(memoryAGet16(ss, r16[bp] - 2)))
        { pc = 0x222d; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - 1);
    { pc = 0x222d; break; }
  case 0x21c6:
    r8[al] = memoryAGet(ds, 0x7348);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0x222d; break; }
  case 0x21d0:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    { pc = 0x222d; break; }
  case 0x21d5:
    r8[al] = memoryAGet(ds, 0x7351);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x220c; break; }
    if (!memoryAGet16(ds, 0x7357))
        { pc = 0x220c; break; }
    r8[ah] = memoryAGet(ds, 0x734c);
    r8[al] = memoryAGet(ss, r16[bp] - 5);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax]++;
    push(r16[ax]);
    yield* sub_4710();
    push(r16[dx]);
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    yield* sub_4736();
    { pc = 0x222a; break; }
  case 0x220c:
    r8[dl] = memoryAGet(ss, r16[bp] - 2);
    r8[dh] = memoryAGet(ss, r16[bp] - 4);
    r8[ah] = 0x02;
    r8[bh] = 0x00;
    yield* sub_366a();
    r8[bl] = memoryAGet(ds, 0x734c);
    r8[al] = memoryAGet(ss, r16[bp] - 5);
    r8[ah] = 0x09;
    r8[bh] = 0x00;
    r16[cx] = 0x0001;
    yield* sub_366a();
  case 0x222a:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x222d:
    r8[al] = memoryAGet(ds, 0x734a);
    r8[ah] = 0x00;
    if (r16s[ax] >= signed16(memoryAGet16(ss, r16[bp] - 2)))
        { pc = 0x2245; break; }
    r8[al] = memoryAGet(ds, 0x7348);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7346);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
  case 0x2245:
    r8[al] = memoryAGet(ds, 0x734b);
    r8[ah] = 0x00;
    if (r16s[ax] >= signed16(memoryAGet16(ss, r16[bp] - 4)))
        { pc = 0x226b; break; }
    r8[al] = 0x06;
    push(r16[ax]);
    r8[al] = memoryAGet(ds, 0x7348);
    push(r16[ax]);
    r8[al] = memoryAGet(ds, 0x7349);
    push(r16[ax]);
    r8[al] = memoryAGet(ds, 0x734a);
    push(r16[ax]);
    r8[al] = memoryAGet(ds, 0x734b);
    push(r16[ax]);
    r8[al] = 0x01;
    push(r16[ax]);
    yield* sub_30be();
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 1);
  case 0x226b:
    r16[ax] = r16[di];
    r16[di]--;
    if (!r16[ax])
        { pc = 0x2275; break; }
    { pc = 0x2193; break; }
  case 0x2275:
    r8[dl] = memoryAGet(ss, r16[bp] - 2);
    r8[dh] = memoryAGet(ss, r16[bp] - 4);
    r8[ah] = 0x02;
    r8[bh] = 0x00;
    yield* sub_366a();
    r8[al] = memoryAGet(ss, r16[bp] - 5);
    r8[ah] = 0x00;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 8;
    return;
  }
}
function* sub_22b3() // 01ed:03e3 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(r16[si]);
    push(r16[si]);
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    yield* sub_216a();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_22cc() // 01ed:03fc +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 2, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    r16[si] = r16[ax];
    if (!r16[ax])
        { pc = 0x2315; break; }
    r16[bx] = r16[si];
    r16[si]++;
    r16[si]++;
    if (!memoryAGet16(ds, r16[bx]))
        { pc = 0x2315; break; }
    { pc = 0x2309; break; }
  case 0x22ed:
    r16[bx] = r16[si];
    r16[si]++;
    r16[si]++;
    push(memoryAGet16(ds, r16[bx]));
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    r16[ax]++;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += r16[di];
    if (r16[ax] > 0x007f)
        { pc = 0x2315; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + r16[di]);
  case 0x2309:
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x2315; break; }
    r16[bx] = memoryAGet16(ds, r16[si]);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0x22ed; break; }
  case 0x2315:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_52c7();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (!r16[ax])
        { pc = 0x237b; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0xfe;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    memoryASet(ds, r16[bx], r8[al]);
    if (!r8[al])
        { pc = 0x236a; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    r16[ax]++;
    r16[ax]++;
    r16[si] = r16[ax];
    { pc = 0x235e; break; }
  case 0x2342:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet(ds, r16[bx], 0x20);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    r16[bx] = r16[si];
    r16[si]++;
    r16[si]++;
    push(memoryAGet16(ds, r16[bx]));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs);
    yield* sub_32bc();
    r16[cx] = pop();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0x235e:
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x236a; break; }
    r16[bx] = memoryAGet16(ds, r16[si]);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0x2342; break; }
  case 0x236a:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet(ds, r16[bx], 0x0d);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    { pc = 0x237d; break; }
  case 0x237b:
    r16[ax] = 0;
  case 0x237d:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 4;
    return;
  }
}
function* sub_2385() // 01ed:04b5 +stackDrop6
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0x0001;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = r16[ax];
    if (!r16[ax])
        { pc = 0x23b7; break; }
    r16[di] = 0;
    { pc = 0x23ab; break; }
  case 0x239c:
    r16[bx] = r16[si];
    r16[si]++;
    r16[si]++;
    push(memoryAGet16(ds, r16[bx]));
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    r16[ax]++;
    r16[di] += r16[ax];
  case 0x23ab:
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x23b7; break; }
    r16[bx] = memoryAGet16(ds, r16[si]);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0x239c; break; }
  case 0x23b7:
    r16[di]++;
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x23cc; break; }
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    r16[ax] += 0x0003;
    r16[di] += r16[ax];
  case 0x23cc:
    if (r16[di] < 0x2000)
        { pc = 0x23d5; break; }
    { pc = 0x2463; break; }
  case 0x23d5:
    r16[ax] = r16[di];
    r16[ax] += 0x000f;
    push(r16[ax]);
    push(cs);
    yield* sub_52c7();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!r16[ax])
        { pc = 0x2463; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 4);
    memoryASet16(ds, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 0x000f);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) & 0xfff0);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = r16[ax];
    if (!r16[ax])
        { pc = 0x2429; break; }
    { pc = 0x241d; break; }
  case 0x2401:
    r16[bx] = r16[si];
    r16[si]++;
    r16[si]++;
    push(memoryAGet16(ds, r16[bx]));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_32bc();
    r16[cx] = pop();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx], 0x00);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x241d:
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x2429; break; }
    r16[bx] = memoryAGet16(ds, r16[si]);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0x2401; break; }
  case 0x2429:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx], 0x00);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x245c; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 0x0002);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_32bc();
    r16[cx] = pop();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx], 0x00);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x245c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= r16[di];
    { pc = 0x2465; break; }
  case 0x2463:
    r16[ax] = 0;
  case 0x2465:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 8;
    return;
  }
}
function* sub_246d() // 01ed:059d +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = r16[bp] + 8;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    r16[ax] = 0x2a8f;
    push(r16[ax]);
    yield* sub_2a7c();
    sp += 0x000a;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_248b() // 01ed:05bb +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    { pc = 0x249c; break; }
  case 0x2490:
    r16[bx] = memoryAGet16(ds, 0x6e86);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    push(cs); cs = memoryAGet16(ds, r16[bx] + 30950); indirectCall(cs, memoryAGet16(ds, r16[bx] + 30948)); assert(cs == 0x01ed); // 01ed:05c8
  case 0x249c:
    r16[ax] = memoryAGet16(ds, 0x6e86);
    memoryASet16(ds, 0x6e86, memoryAGet16(ds, 0x6e86) - 1);
    if (r16[ax])
        { pc = 0x2490; break; }
    push(memoryAGet16(ss, r16[bp] + 6));
    yield* sub_1fe3();
    r16[cx] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_24b0() // 01ed:05e0 +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax]++;
    r16[si] = r16[ax];
    r16[si] -= memoryAGet16(ds, 0x0090);
    r16[ax] = r16[si];
    r16[ax] += 0x003f;
    r8[cl] = 0x06;
    r16[ax] >>= r8[cl];
    r16[si] = r16[ax];
    if (r16[si] != memoryAGet16(ds, 0x6f96))
        { pc = 0x24e2; break; }
  case 0x24d0:
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 4);
    memoryASet16(ds, 0x00a4, r16[ax]);
    memoryASet16(ds, 0x00a2, r16[dx]);
    r16[ax] = 0x0001;
    { pc = 0x252a; break; }
  case 0x24e2:
    r8[cl] = 0x06;
    r16[si] <<= r8[cl];
    r16[di] = memoryAGet16(ds, 0x00a8);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0x0090);
    if (r16[ax] <= r16[di])
        { pc = 0x24fc; break; }
    r16[ax] = r16[di];
    r16[ax] -= memoryAGet16(ds, 0x0090);
    r16[si] = r16[ax];
  case 0x24fc:
    push(r16[si]);
    push(memoryAGet16(ds, 0x0090));
    push(cs);
    yield* sub_4135();
    r16[cx] = pop();
    r16[cx] = pop();
    r16[di] = r16[ax];
    if (r16[di] != 0xffff)
        { pc = 0x251a; break; }
    r16[ax] = r16[si];
    r8[cl] = 0x06;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, 0x6f96, r16[ax]);
    { pc = 0x24d0; break; }
  case 0x251a:
    r16[ax] = memoryAGet16(ds, 0x0090);
    r16[ax] += r16[di];
    memoryASet16(ds, 0x00a8, r16[ax]);
    memoryASet16(ds, 0x00a6, 0x0000);
    r16[ax] = 0;
  case 0x252a:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 6;
    return;
  }
}
function* sub_2530() // 01ed:0660
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[cx] = memoryAGet16(ds, 0x00a0);
    r16[bx] = memoryAGet16(ds, 0x009e);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    yield* sub_548a();
    if (flags.carry)
        { pc = 0x2566; break; }
    r16[cx] = memoryAGet16(ds, 0x00a8);
    r16[bx] = memoryAGet16(ds, 0x00a6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    yield* sub_548a();
    if (!flags.carry && !flags.zero)
        { pc = 0x2566; break; }
    push(memoryAGet16(ss, r16[bp] + 6));
    push(memoryAGet16(ss, r16[bp] + 4));
    yield* sub_24b0();
    if (r16[ax])
        { pc = 0x256b; break; }
  case 0x2566:
    r16[ax] = 0xffff;
    { pc = 0x256d; break; }
  case 0x256b:
    r16[ax] = 0;
  case 0x256d:
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_256f() // 01ed:069f
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    r16[dx] = memoryAGet16(ds, 0x00a4);
    r16[ax] = memoryAGet16(ds, 0x00a2);
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ss, r16[bp] + 4);
    yield* sub_512a();
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[cx] = memoryAGet16(ds, 0x00a0);
    r16[bx] = memoryAGet16(ds, 0x009e);
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    yield* sub_548a();
    if (flags.carry)
        { pc = 0x25ae; break; }
    r16[cx] = memoryAGet16(ds, 0x00a8);
    r16[bx] = memoryAGet16(ds, 0x00a6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    yield* sub_548a();
    if (flags.carry || flags.zero)
        { pc = 0x25b6; break; }
  case 0x25ae:
    r16[dx] = 0xffff;
    r16[ax] = 0xffff;
    { pc = 0x25d8; break; }
  case 0x25b6:
    r16[ax] = memoryAGet16(ds, 0x00a4);
    r16[dx] = memoryAGet16(ds, 0x00a2);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    yield* sub_24b0();
    if (r16[ax])
        { pc = 0x25d2; break; }
    { pc = 0x25ae; break; }
  case 0x25d2:
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
  case 0x25d8:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_25dc() // 01ed:070c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    r16[dx] = memoryAGet16(ds, 0x00a8);
    r16[ax] = memoryAGet16(ds, 0x00a6);
    r16[cx] = memoryAGet16(ds, 0x00a4);
    r16[bx] = memoryAGet16(ds, 0x00a2);
    yield* sub_518a();
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2) < 0x0000)
        { pc = 0x261a; break; }
    if (memoryAGet16(ss, r16[bp] - 2) > 0x0000)
        { pc = 0x2612; break; }
    if (memoryAGet16(ss, r16[bp] - 4) <= 0x0010)
        { pc = 0x261a; break; }
  case 0x2612:
    flags.carry = memoryAGet16(ss, r16[bp] - 4) < 0x0010;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 0x0010);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - (0x0000 + flags.carry));
  case 0x261a:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) & 0xfff0);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) & 0xffff);
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_262e() // 01ed:075e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[si])
        { pc = 0x2641; break; }
    push(cs);
    yield* sub_26b0();
    { pc = 0x26aa; break; }
  case 0x2641:
    if (memoryAGet16(ds, r16[si] + 14) == r16[si])
        { pc = 0x264b; break; }
  case 0x2646:
    r16[ax] = 0xffff;
    { pc = 0x26ac; break; }
  case 0x264b:
    if (signed16(memoryAGet16(ds, r16[si])) < signed16(0x0000))
        { pc = 0x2679; break; }
    if (memoryAGet16(ds, r16[si] + 2) & 0x0008)
        { pc = 0x2661; break; }
    r16[ax] = r16[si];
    r16[ax] += 0x0005;
    if (memoryAGet16(ds, r16[si] + 10) != r16[ax])
        { pc = 0x2677; break; }
  case 0x2661:
    memoryASet16(ds, r16[si], 0x0000);
    r16[ax] = r16[si];
    r16[ax] += 0x0005;
    if (memoryAGet16(ds, r16[si] + 10) != r16[ax])
        { pc = 0x2677; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 8);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    { pc = 0x26aa; break; }
  case 0x2677:
    { pc = 0x26aa; break; }
  case 0x2679:
    r16[ax] = memoryAGet16(ds, r16[si] + 6);
    r16[ax] += memoryAGet16(ds, r16[si]);
    r16[ax]++;
    r16[di] = r16[ax];
    memoryASet16(ds, r16[si], memoryAGet16(ds, r16[si]) - r16[di]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, r16[si] + 8);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    push(r16[ax]);
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_3383();
    sp += 0x0006;
    if (r16[ax] == r16[di])
        { pc = 0x26aa; break; }
    if (memoryAGet16(ds, r16[si] + 2) & 0x0200)
        { pc = 0x26aa; break; }
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) | 0x0010);
    { pc = 0x2646; break; }
  case 0x26aa:
    r16[ax] = 0;
  case 0x26ac:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_26b0() // 01ed:07e0 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    r16[di] = 0x0014;
    r16[si] = 0x6f98;
    { pc = 0x26d8; break; }
  case 0x26c4:
    if (!(memoryAGet16(ds, r16[si] + 2) & 0x0003))
        { pc = 0x26d5; break; }
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x26d5:
    r16[si] += 0x0010;
  case 0x26d8:
    r16[ax] = r16[di];
    r16[di]--;
    if (r16[ax])
        { pc = 0x26c4; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_277c() // 01ed:08ac
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0056;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    if (!memoryAGet16(ss, r16[bp] + 8))
        { pc = 0x2795; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet(ds, r16[bx], 0x00);
  case 0x2795:
    if (!memoryAGet16(ss, r16[bp] + 10))
        { pc = 0x27a1; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet(ds, r16[bx], 0x00);
  case 0x27a1:
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x27ad; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(ds, r16[bx], 0x00);
  case 0x27ad:
    if (!memoryAGet16(ss, r16[bp] + 14))
        { pc = 0x27b9; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 14);
    memoryASet(ds, r16[bx], 0x00);
  case 0x27b9:
    r16[ax] = r16[bp] - 86;
    r16[si] = r16[ax];
    { pc = 0x27c3; break; }
  case 0x27c0:
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 1);
  case 0x27c3:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet(ds, r16[bx]) == 0x20)
        { pc = 0x27c0; break; }
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    r16[di] = r16[ax];
    if (r16s[ax] <= signed16(0x0050))
        { pc = 0x27de; break; }
    r16[di] = 0x0050;
  case 0x27de:
    memoryASet(ds, r16[si], 0x00);
    r16[si]++;
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(r16[si]);
    push(cs);
    yield* sub_41f7();
    sp += 0x0006;
    r16[si] += r16[di];
    memoryASet(ds, r16[si], 0x00);
    r16[di] = 0;
  case 0x27f6:
    r16[si]--;
    r16[bx] = r16[si];
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[cx] = 0x0007;
    r16[bx] = 0x0a10;
  case 0x2805:
    r16[ax] = memoryAGet16(cs, r16[bx]);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x2813; break; }
    r16[bx]++;
    r16[bx]++;
    if (--r16[cx])
        { pc = 0x2805; break; }
    { pc = 0x27f6; break; }
  case 0x2813:
    indirectJump(cs, memoryAGet16(cs, r16[bx] + 14)); return; // 01ed:0943
    return;
  }
}
function* sub_2912() // 01ed:0a42 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    r16[cx] = memoryAGet16(ss, r16[bp] + 4);
    r16[bx] = r16[cx];
    if (signed16(memoryAGet16(ds, r16[bx])) >= signed16(0x0000))
        { pc = 0x292b; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 6);
    r16[ax] += memoryAGet16(ds, r16[bx]);
    r16[ax]++;
    { pc = 0x2934; break; }
  case 0x292b:
    r16[bx] = r16[cx];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] ^= r16[dx];
    r16[ax] -= r16[dx];
  case 0x2934:
    r16[si] = r16[ax];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = r16[cx];
    if (!(memoryAGet16(ds, r16[bx] + 2) & 0x0040))
        { pc = 0x2944; break; }
    { pc = 0x2976; break; }
  case 0x2944:
    r16[bx] = r16[cx];
    r16[di] = memoryAGet16(ds, r16[bx] + 10);
    if (signed16(memoryAGet16(ds, r16[bx])) >= signed16(0x0000))
        { pc = 0x296f; break; }
    { pc = 0x295b; break; }
  case 0x2950:
    r16[di]--;
    r16[bx] = r16[di];
    if (memoryAGet(ds, r16[bx]) != 0x0a)
        { pc = 0x295b; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x295b:
    r16[ax] = r16[si];
    r16[si]--;
    if (r16[ax])
        { pc = 0x2950; break; }
    { pc = 0x2976; break; }
  case 0x2964:
    r16[bx] = r16[di];
    r16[di]++;
    if (memoryAGet(ds, r16[bx]) != 0x0a)
        { pc = 0x296f; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x296f:
    r16[ax] = r16[si];
    r16[si]--;
    if (r16[ax])
        { pc = 0x2964; break; }
  case 0x2976:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 4;
    return;
  }
}
function* sub_2981() // 01ed:0ab1 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    if (!r16[ax])
        { pc = 0x299c; break; }
    r16[ax] = 0xffff;
    { pc = 0x29e5; break; }
  case 0x299c:
    if (r16[di] != 0x0001)
        { pc = 0x29b1; break; }
    if (signed16(memoryAGet16(ds, r16[si])) <= signed16(0x0000))
        { pc = 0x29b1; break; }
    push(r16[si]);
    yield* sub_2912();
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    flags.carry = memoryAGet16(ss, r16[bp] + 8) < r16[ax];
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) - r16[ax]);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) - (r16[dx] + flags.carry));
  case 0x29b1:
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) & 0xfe5f);
    memoryASet16(ds, r16[si], 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 8);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_3a99();
    sp += 0x0008;
    if (r16[dx] != 0xffff)
        { pc = 0x29e3; break; }
    if (r16[ax] != 0xffff)
        { pc = 0x29e3; break; }
    r16[ax] = 0xffff;
    { pc = 0x29e5; break; }
  case 0x29e3:
    r16[ax] = 0;
  case 0x29e5:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2a2c() // 01ed:0b5c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    r8[al] += 0xff;
    memoryASet(ss, r16[bp] - 1, r8[al]);
    r8[al] = memoryAGet(ds, 0x7349);
    memoryASet(ss, r16[bp] - 1, memoryAGet(ss, r16[bp] - 1) + r8[al]);
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    r8[al] += 0xff;
    memoryASet(ss, r16[bp] - 2, r8[al]);
    r8[al] = memoryAGet(ds, 0x7348);
    memoryASet(ss, r16[bp] - 2, memoryAGet(ss, r16[bp] - 2) + r8[al]);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    if (r8[al] < memoryAGet(ds, 0x7349))
        { pc = 0x2a78; break; }
    if (r8[al] > memoryAGet(ds, 0x734b))
        { pc = 0x2a78; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    if (r8[al] < memoryAGet(ds, 0x7348))
        { pc = 0x2a78; break; }
    if (r8[al] > memoryAGet(ds, 0x734a))
        { pc = 0x2a78; break; }
    r8[dl] = memoryAGet(ss, r16[bp] - 2);
    r8[dh] = memoryAGet(ss, r16[bp] - 1);
    r8[ah] = 0x02;
    r8[bh] = 0x00;
    yield* sub_366a();
  case 0x2a78:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2a7c() // 01ed:0bac
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    push(r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] |= 0x0002;
    push(r16[ax]);
    yield* sub_3fc1();
    r16[si] = r16[ax];
    if (r16[ax])
        { pc = 0x2aa6; break; }
    memoryASet16(ds, 0x0094, 0x0002);
  case 0x2aa1:
    r16[ax] = 0xffff;
    { pc = 0x2b0d; break; }
  case 0x2aa6:
    push(memoryAGet16(ss, r16[bp] + 8));
    yield* sub_22cc();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[ax])
        { pc = 0x2abb; break; }
    memoryASet16(ds, 0x0094, 0x0008);
    { pc = 0x2aa1; break; }
  case 0x2abb:
    if (r16[di])
        { pc = 0x2ac3; break; }
    r16[di] = memoryAGet16(ds, 0x744a);
  case 0x2ac3:
    push(r16[di]);
    push(r16[si]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    yield* sub_2385();
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (r16[ax])
        { pc = 0x2ae4; break; }
    memoryASet16(ds, 0x0094, 0x0008);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_51f8();
    r16[cx] = pop();
    { pc = 0x2aa1; break; }
  case 0x2ae4:
    push(cs); cs = memoryAGet16(ds, 0x6f8c); indirectCall(cs, memoryAGet16(ds, 0x6f8a)); assert(cs == 0x01ed); // 01ed:0c14
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[si]);
    yield* indirectCall(cs, memoryAGet16(ss, r16[bp] + 4));
    sp += 0x0006;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    push(cs);
    yield* sub_51f8();
    r16[cx] = pop();
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_51f8();
    r16[cx] = pop();
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
  case 0x2b0d:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_2b13() // 01ed:0c43 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 12));
    yield* sub_3058();
    if (!r16[ax])
        { pc = 0x2b53; break; }
    push(memoryAGet16(ss, r16[bp] + 14));
    push(memoryAGet16(ss, r16[bp] + 16));
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 14);
    r16[dx] += r16[ax];
    push(r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] -= r16[si];
    r16[dx] = memoryAGet16(ss, r16[bp] + 16);
    r16[dx] += r16[ax];
    push(r16[dx]);
    yield* sub_3058();
    if (r16[ax])
        { pc = 0x2b57; break; }
  case 0x2b53:
    r16[ax] = 0;
    { pc = 0x2bb3; break; }
  case 0x2b57:
    memoryASet16(ss, r16[bp] - 2, r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    if (r16s[si] >= signed16(memoryAGet16(ss, r16[bp] + 16)))
        { pc = 0x2b78; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[si]);
    memoryASet16(ss, r16[bp] - 6, 0xffff);
  case 0x2b78:
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    { pc = 0x2ba6; break; }
  case 0x2b7d:
    push(memoryAGet16(ss, r16[bp] + 14));
    r16[ax] = r16[di];
    r16[ax] -= r16[si];
    r16[dx] = memoryAGet16(ss, r16[bp] + 16);
    r16[dx] += r16[ax];
    push(r16[dx]);
    yield* sub_4710();
    push(r16[dx]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(r16[di]);
    yield* sub_4710();
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 6);
    r16[ax]++;
    push(r16[ax]);
    yield* sub_301a();
    r16[di] += memoryAGet16(ss, r16[bp] - 6);
  case 0x2ba6:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    if (r16[ax] != r16[di])
        { pc = 0x2b7d; break; }
    r16[ax] = 0x0001;
  case 0x2bb3:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2bf3() // 01ed:0d23 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si], memoryAGet16(ds, r16[si]) - 1);
    push(r16[si]);
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_2c0c();
    r16[cx] = pop();
    r16[cx] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_2c0c() // 01ed:0d3c +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    memoryASet(ds, 0x7964, r8[al]);
    if (signed16(memoryAGet16(ds, r16[si])) >= signed16(0xffff))
        { pc = 0x2c54; break; }
    memoryASet16(ds, r16[si], memoryAGet16(ds, r16[si]) + 1);
    r16[bx] = memoryAGet16(ds, r16[si] + 10);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) + 1);
    r8[al] = memoryAGet(ds, 0x7964);
    memoryASet(ds, r16[bx], r8[al]);
    if (!(memoryAGet16(ds, r16[si] + 2) & 0x0008))
        { pc = 0x2c51; break; }
    if (memoryAGet(ds, 0x7964) == 0x0a)
        { pc = 0x2c40; break; }
    if (memoryAGet(ds, 0x7964) != 0x0d)
        { pc = 0x2c51; break; }
  case 0x2c40:
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    if (!r16[ax])
        { pc = 0x2c51; break; }
  case 0x2c4b:
    r16[ax] = 0xffff;
    { pc = 0x2d0d; break; }
  case 0x2c51:
    { pc = 0x2d08; break; }
  case 0x2c54:
    if (memoryAGet16(ds, r16[si] + 2) & 0x0090)
        { pc = 0x2c62; break; }
    if (memoryAGet16(ds, r16[si] + 2) & 0x0002)
        { pc = 0x2c69; break; }
  case 0x2c62:
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) | 0x0010);
    { pc = 0x2c4b; break; }
  case 0x2c69:
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) | 0x0100);
    if (!memoryAGet16(ds, r16[si] + 6))
        { pc = 0x2cbc; break; }
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x2c86; break; }
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    if (!r16[ax])
        { pc = 0x2c86; break; }
    { pc = 0x2c4b; break; }
  case 0x2c86:
    r16[ax] = memoryAGet16(ds, r16[si] + 6);
    r16[ax] = -r16[ax];
    memoryASet16(ds, r16[si], r16[ax]);
    r16[bx] = memoryAGet16(ds, r16[si] + 10);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) + 1);
    r8[al] = memoryAGet(ds, 0x7964);
    memoryASet(ds, r16[bx], r8[al]);
    if (!(memoryAGet16(ds, r16[si] + 2) & 0x0008))
        { pc = 0x2cba; break; }
    if (memoryAGet(ds, 0x7964) == 0x0a)
        { pc = 0x2cad; break; }
    if (memoryAGet(ds, 0x7964) != 0x0d)
        { pc = 0x2cba; break; }
  case 0x2cad:
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    if (!r16[ax])
        { pc = 0x2cba; break; }
    { pc = 0x2c4b; break; }
  case 0x2cba:
    { pc = 0x2d08; break; }
  case 0x2cbc:
    if (memoryAGet(ds, 0x7964) != 0x0a)
        { pc = 0x2ce4; break; }
    if (memoryAGet16(ds, r16[si] + 2) & 0x0040)
        { pc = 0x2ce4; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x733a;
    push(r16[ax]);
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    if (r16[ax] != 0x0001)
        { pc = 0x2cfe; break; }
  case 0x2ce4:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x7964;
    push(r16[ax]);
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    if (r16[ax] == 0x0001)
        { pc = 0x2d08; break; }
  case 0x2cfe:
    if (memoryAGet16(ds, r16[si] + 2) & 0x0200)
        { pc = 0x2d08; break; }
    { pc = 0x2c62; break; }
  case 0x2d08:
    r8[al] = memoryAGet(ds, 0x7964);
    r8[ah] = 0x00;
  case 0x2d0d:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2d25() // 01ed:0e55 +stackDrop6
{
  var pc = 0;
  var temp_cond0;
  var temp_cond1;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 4);
    memoryASet16(ss, r16[bp] - 2, r16[di]);
    if (!(memoryAGet16(ds, r16[si] + 2) & 0x0008))
        { pc = 0x2d63; break; }
    { pc = 0x2d59; break; }
  case 0x2d3e:
    push(r16[si]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_2c0c();
    r16[cx] = pop();
    r16[cx] = pop();
    if (r16[ax] != 0xffff)
        { pc = 0x2d59; break; }
  case 0x2d54:
    r16[ax] = 0;
    { pc = 0x2e58; break; }
  case 0x2d59:
    r16[ax] = r16[di];
    r16[di]--;
    if (r16[ax])
        { pc = 0x2d3e; break; }
    { pc = 0x2e55; break; }
  case 0x2d63:
    if (memoryAGet16(ds, r16[si] + 2) & 0x0040)
        { pc = 0x2d6d; break; }
    { pc = 0x2dfa; break; }
  case 0x2d6d:
    if (!memoryAGet16(ds, r16[si] + 6))
        { pc = 0x2de0; break; }
    if (memoryAGet16(ds, r16[si] + 6) >= r16[di])
        { pc = 0x2da4; break; }
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x2d8a; break; }
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    if (!r16[ax])
        { pc = 0x2d8a; break; }
    { pc = 0x2d54; break; }
  case 0x2d8a:
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 8));
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    if (r16[ax] >= r16[di])
        { pc = 0x2da1; break; }
    { pc = 0x2d54; break; }
  case 0x2da1:
    { pc = 0x2e55; break; }
  case 0x2da4:
    r16[ax] = memoryAGet16(ds, r16[si]);
    temp_cond0 = r16s[ax] < 0;
    r16[ax] += r16[di];
    if (temp_cond0)
        { pc = 0x2dc6; break; }
    if (memoryAGet16(ds, r16[si]))
        { pc = 0x2db9; break; }
    r16[ax] = 0xffff;
    r16[ax] -= memoryAGet16(ds, r16[si] + 6);
    memoryASet16(ds, r16[si], r16[ax]);
    { pc = 0x2dc6; break; }
  case 0x2db9:
    push(r16[si]);
    push(cs);
    yield* sub_262e();
    r16[cx] = pop();
    if (!r16[ax])
        { pc = 0x2dc6; break; }
    { pc = 0x2d54; break; }
  case 0x2dc6:
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ds, r16[si] + 10));
    push(cs);
    yield* sub_3bac();
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += r16[di];
    memoryASet16(ds, r16[si], r16[ax]);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) + r16[di]);
    { pc = 0x2e55; break; }
  case 0x2de0:
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 8));
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    if (r16[ax] >= r16[di])
        { pc = 0x2df8; break; }
    { pc = 0x2d54; break; }
  case 0x2df8:
    { pc = 0x2e55; break; }
  case 0x2dfa:
    if (!memoryAGet16(ds, r16[si] + 6))
        { pc = 0x2e3d; break; }
    { pc = 0x2e34; break; }
  case 0x2e02:
    temp_cond1 = (signed16(memoryAGet16(ds, r16[si]))) + 1 >= 0;
    memoryASet16(ds, r16[si], memoryAGet16(ds, r16[si]) + 1);
    if (temp_cond1)
        { pc = 0x2e1c; break; }
    r16[bx] = memoryAGet16(ds, r16[si] + 10);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) + 1);
    push(r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    r16[bx] = pop();
    memoryASet(ds, r16[bx], r8[al]);
    r8[ah] = 0x00;
    { pc = 0x2e2c; break; }
  case 0x2e1c:
    push(r16[si]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    push(r16[ax]);
    push(cs);
    yield* sub_2bf3();
    r16[cx] = pop();
    r16[cx] = pop();
  case 0x2e2c:
    if (r16[ax] != 0xffff)
        { pc = 0x2e34; break; }
    { pc = 0x2d54; break; }
  case 0x2e34:
    r16[ax] = r16[di];
    r16[di]--;
    if (r16[ax])
        { pc = 0x2e02; break; }
    { pc = 0x2e55; break; }
  case 0x2e3d:
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 8));
    r8[al] = memoryAGet(ds, r16[si] + 4);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_3383();
    sp += 0x0006;
    if (r16[ax] >= r16[di])
        { pc = 0x2e55; break; }
    { pc = 0x2d54; break; }
  case 0x2e55:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
  case 0x2e58:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 8;
    return;
  }
}
function* sub_2e73() // 01ed:0fa3 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(r16[si]);
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    r16[di] = r16[ax];
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x6fa8;
    push(r16[ax]);
    yield* sub_2d25();
    if (r16[ax] == r16[di])
        { pc = 0x2e96; break; }
    r16[ax] = 0xffff;
    { pc = 0x2eb2; break; }
  case 0x2e96:
    r16[ax] = 0x6fa8;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    push(cs);
    yield* sub_2c0c();
    r16[cx] = pop();
    r16[cx] = pop();
    if (r16[ax] == 0x000a)
        { pc = 0x2eaf; break; }
    r16[ax] = 0xffff;
    { pc = 0x2eb2; break; }
  case 0x2eaf:
    r16[ax] = 0x000a;
  case 0x2eb2:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2ec7() // 01ed:0ff7 +far +stackDrop2
{
    sp -= 2;
    r16[cx] = memoryAGet16(ds, 0x733e);
    r16[bx] = memoryAGet16(ds, 0x733c);
    r16[dx] = 0x015a;
    r16[ax] = 0x4e35;
    yield* sub_5473();
    flags.carry = r16[ax] + 0x0001 >= 0x10000;
    r16[ax]++;
    r16[dx] += (0x0000 + flags.carry);
    memoryASet16(ds, 0x733e, r16[dx]);
    memoryASet16(ds, 0x733c, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x733e);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] &= 0x7fff;
    sp += 2; cs = pop();
}
function* sub_2eed() // 01ed:101d +stackDrop4
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    r16[ax] >>= 1;
    r16[cx] = r16[ax];
    r8[al] = memoryAGet(ds, 0x7350);
    r8[ah] = 0x00;
    push(r16[ax]);
    r16[ax] = r16[cx];
    r16[dx] = 0;
    r16[bx] = pop();
    div16(r16[bx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    r8[ah] = 0x00;
    r8[dl] = memoryAGet(ds, 0x7350);
    r8[dh] = 0x00;
    imul16(r16[dx]);
    r8[dl] = r8[cl];
    r8[dl] -= r8[al];
    memoryASet(ss, r16[bp] - 2, r8[dl]);
    r8[ah] = memoryAGet(ss, r16[bp] - 1);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 6;
}
function* sub_2f26() // 01ed:1056 +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 4);
    r16[dx] = memoryAGet16(ds, r16[si]);
    if (r16[dx] == memoryAGet16(ds, r16[di]))
        { pc = 0x2f40; break; }
    r8[bh] = 0x00;
    r8[ah] = 0x02;
    yield* sub_366a();
    memoryASet16(ds, r16[di], r16[dx]);
  case 0x2f40:
    r8[dl]++;
    if (r8[dl] < memoryAGet(ds, 0x7350))
        { pc = 0x2f4c; break; }
    r8[dh]++;
    r8[dl] = 0x00;
  case 0x2f4c:
    memoryASet16(ds, r16[si], r16[dx]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 6;
    return;
  }
}
function* sub_2f54() // 01ed:1084 +stackDrop10
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 4);
    yield* sub_3357();
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    if (r16[ax] != memoryAGet16(ds, 0x7355))
        { pc = 0x2f76; break; }
    r16[ax] = 0x0001;
    { pc = 0x2f78; break; }
  case 0x2f76:
    r16[ax] = 0;
  case 0x2f78:
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    if (!r16[ax])
        { pc = 0x2f8b; break; }
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    yield* sub_2eed();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x2f8b:
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    if (r16[ax] != memoryAGet16(ds, 0x7355))
        { pc = 0x2f99; break; }
    r16[ax] = 0x0001;
    { pc = 0x2f9b; break; }
  case 0x2f99:
    r16[ax] = 0;
  case 0x2f9b:
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    if (!r16[ax])
        { pc = 0x3001; break; }
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    yield* sub_2eed();
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0x3001; break; }
  case 0x2fb0:
    if (!memoryAGet16(ss, r16[bp] - 12))
        { pc = 0x2fcc; break; }
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    yield* sub_2f26();
    r8[bh] = 0x00;
    r8[ah] = 0x08;
    yield* sub_366a();
    r16[si] = r16[ax];
    { pc = 0x2fd6; break; }
  case 0x2fcc:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
  case 0x2fd6:
    if (!memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x2ff7; break; }
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    yield* sub_2f26();
    r16[ax] = r16[si];
    r8[bl] = r8[ah];
    r16[cx] = 0x0001;
    r8[bh] = 0x00;
    r8[ah] = 0x09;
    yield* sub_366a();
    { pc = 0x3001; break; }
  case 0x2ff7:
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(es, r16[bx], r16[si]);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 0x0002);
  case 0x3001:
    r16[ax] = r16[di];
    r16[di]--;
    if (r16[ax])
        { pc = 0x2fb0; break; }
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    r8[bh] = 0x00;
    r8[ah] = 0x02;
    yield* sub_366a();
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 12;
    return;
  }
}
function* sub_301a() // 01ed:114a +stackDrop10
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 4);
    r8[al] = memoryAGet(ds, 0x7351);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x3043; break; }
    if (!memoryAGet16(ds, 0x7357))
        { pc = 0x3043; break; }
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(r16[si]);
    yield* sub_4736();
    { pc = 0x3053; break; }
  case 0x3043:
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(r16[si]);
    yield* sub_2f54();
  case 0x3053:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 12;
    return;
  }
}
function* sub_3058() // 01ed:1188 +stackDrop8
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r8[al] = memoryAGet(ds, 0x7350);
    r8[ah] = 0x00;
    r16[cx] = r16[ax];
    r8[al] = memoryAGet(ds, 0x734f);
    r8[ah] = 0x00;
    r16[dx] = r16[ax];
    if (r16[si] > r16[cx])
        { pc = 0x3093; break; }
    if (r16[bx] > r16[cx])
        { pc = 0x3093; break; }
    if (r16s[si] > r16s[bx])
        { pc = 0x3093; break; }
    if (r16[di] > r16[dx])
        { pc = 0x3093; break; }
    if (memoryAGet16(ss, r16[bp] + 4) > r16[dx])
        { pc = 0x3093; break; }
    if (r16s[di] > signed16(memoryAGet16(ss, r16[bp] + 4)))
        { pc = 0x3093; break; }
    r16[ax] = 0x0001;
    { pc = 0x3095; break; }
  case 0x3093:
    r16[ax] = 0;
  case 0x3095:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 10;
    return;
  }
}
function* sub_309b() // 01ed:11cb +stackDrop6
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r8[ch] = memoryAGet(ds, 0x734c);
    r8[cl] = 0x20;
    { pc = 0x30b3; break; }
  case 0x30ae:
    memoryASet16(ds, r16[si], r16[cx]);
    r16[si]++;
    r16[si]++;
    r16[di]++;
  case 0x30b3:
    if (r16s[di] <= signed16(memoryAGet16(ss, r16[bp] + 4)))
        { pc = 0x30ae; break; }
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 8;
    return;
  }
}
function* sub_30be() // 01ed:11ee +stackDrop12
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x00a0;
    r8[al] = memoryAGet(ds, 0x7351);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0x30d1; break; }
    { pc = 0x3154; break; }
  case 0x30d1:
    if (!memoryAGet16(ds, 0x7357))
        { pc = 0x3154; break; }
    if (memoryAGet(ss, r16[bp] + 4) != 0x01)
        { pc = 0x3154; break; }
    memoryASet(ss, r16[bp] + 12, memoryAGet(ss, r16[bp] + 12) + 1);
    memoryASet(ss, r16[bp] + 10, memoryAGet(ss, r16[bp] + 10) + 1);
    memoryASet(ss, r16[bp] + 8, memoryAGet(ss, r16[bp] + 8) + 1);
    memoryASet(ss, r16[bp] + 6, memoryAGet(ss, r16[bp] + 6) + 1);
    if (memoryAGet(ss, r16[bp] + 14) != 0x06)
        { pc = 0x3133; break; }
    r8[al] = memoryAGet(ss, r16[bp] + 10);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 12);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 10);
    r8[ah] = 0x00;
    r16[ax]++;
  case 0x310e:
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 12);
    r8[ah] = 0x00;
    push(r16[ax]);
    push(cs);
    yield* sub_2b13();
    sp += 0x000c;
    r16[ax] = r16[bp] - 160;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 12);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    r8[ah] = 0x00;
    push(r16[ax]);
    yield* sub_309b();
    { pc = 0x316d; break; }
  case 0x3133:
    r8[al] = memoryAGet(ss, r16[bp] + 10);
    r8[ah] = 0x00;
    r16[ax]++;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 12);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    r8[ah] = 0x00;
    r16[ax]--;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    r8[ah] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 10);
    r8[ah] = 0x00;
    { pc = 0x310e; break; }
  case 0x3154:
    r8[bh] = memoryAGet(ds, 0x734c);
    r8[ah] = memoryAGet(ss, r16[bp] + 14);
    r8[al] = memoryAGet(ss, r16[bp] + 4);
    r8[ch] = memoryAGet(ss, r16[bp] + 10);
    r8[cl] = memoryAGet(ss, r16[bp] + 12);
    r8[dh] = memoryAGet(ss, r16[bp] + 6);
    r8[dl] = memoryAGet(ss, r16[bp] + 8);
    yield* sub_366a();
  case 0x316d:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 14;
    return;
  }
}
function* sub_3173() // 01ed:12a3
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r8[al] = memoryAGet(ds, 0x6f9c);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_3a88();
    r16[cx] = pop();
    if (r16[ax])
        { pc = 0x3188; break; }
    memoryASet16(ds, 0x6f9a, memoryAGet16(ds, 0x6f9a) & 0xfdff);
  case 0x3188:
    r16[ax] = 0x0200;
    push(r16[ax]);
    if (!(memoryAGet16(ds, 0x6f9a) & 0x0200))
        { pc = 0x3199; break; }
    r16[ax] = 0x0001;
    { pc = 0x319b; break; }
  case 0x3199:
    r16[ax] = 0;
  case 0x319b:
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x6f98;
    push(r16[ax]);
    push(cs);
    yield* sub_31e4();
    sp += 0x0008;
    r8[al] = memoryAGet(ds, 0x6fac);
    cbw();
    push(r16[ax]);
    push(cs);
    yield* sub_3a88();
    r16[cx] = pop();
    if (r16[ax])
        { pc = 0x31c0; break; }
    memoryASet16(ds, 0x6faa, memoryAGet16(ds, 0x6faa) & 0xfdff);
  case 0x31c0:
    r16[ax] = 0x0200;
    push(r16[ax]);
    if (!(memoryAGet16(ds, 0x6faa) & 0x0200))
        { pc = 0x31d1; break; }
    r16[ax] = 0x0002;
    { pc = 0x31d3; break; }
  case 0x31d1:
    r16[ax] = 0;
  case 0x31d3:
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x6fa8;
    push(r16[ax]);
    push(cs);
    yield* sub_31e4();
    sp += 0x0008;
    sp += 2;
    return;
  }
}
function* sub_31e4() // 01ed:1314 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    if (memoryAGet16(ds, r16[si] + 14) != r16[si])
        { pc = 0x3200; break; }
    if (signed16(memoryAGet16(ss, r16[bp] + 10)) > signed16(0x0002))
        { pc = 0x3200; break; }
    if (r16[di] <= 0x7fff)
        { pc = 0x3206; break; }
  case 0x3200:
    r16[ax] = 0xffff;
    { pc = 0x32b8; break; }
  case 0x3206:
    if (memoryAGet16(ds, 0x7342))
        { pc = 0x321b; break; }
    if (r16[si] != 0x6fa8)
        { pc = 0x321b; break; }
    memoryASet16(ds, 0x7342, 0x0001);
    { pc = 0x322e; break; }
  case 0x321b:
    if (memoryAGet16(ds, 0x7340))
        { pc = 0x322e; break; }
    if (r16[si] != 0x6f98)
        { pc = 0x322e; break; }
    memoryASet16(ds, 0x7340, 0x0001);
  case 0x322e:
    if (!memoryAGet16(ds, r16[si]))
        { pc = 0x3246; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0;
    push(r16[ax]);
    push(r16[dx]);
    push(r16[si]);
    push(cs);
    yield* sub_2981();
    sp += 0x0008;
  case 0x3246:
    if (!(memoryAGet16(ds, r16[si] + 2) & 0x0004))
        { pc = 0x3256; break; }
    push(memoryAGet16(ds, r16[si] + 8));
    push(cs);
    yield* sub_51f8();
    r16[cx] = pop();
  case 0x3256:
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) & 0xfff3);
    memoryASet16(ds, r16[si] + 6, 0x0000);
    r16[ax] = r16[si];
    r16[ax] += 0x0005;
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    if (memoryAGet16(ss, r16[bp] + 10) == 0x0002)
        { pc = 0x32b6; break; }
    if (r16[di] <= 0)
        { pc = 0x32b6; break; }
    memoryASet16(ds, 0x6f8c, 0x01ed);
    memoryASet16(ds, 0x6f8a, 0x15ac);
    if (memoryAGet16(ss, r16[bp] + 8))
        { pc = 0x329f; break; }
    push(r16[di]);
    push(cs);
    yield* sub_52c7();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
    if (!r16[ax])
        { pc = 0x329c; break; }
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) | 0x0004);
    { pc = 0x329f; break; }
  case 0x329c:
    { pc = 0x3200; break; }
  case 0x329f:
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    memoryASet16(ds, r16[si] + 6, r16[di]);
    if (memoryAGet16(ss, r16[bp] + 10) != 0x0001)
        { pc = 0x32b6; break; }
    memoryASet16(ds, r16[si] + 2, memoryAGet16(ds, r16[si] + 2) | 0x0008);
  case 0x32b6:
    r16[ax] = 0;
  case 0x32b8:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_32bc() // 01ed:13ec +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(cs);
    yield* sub_41dd();
    r16[cx] = pop();
    r16[si] = r16[ax];
    r16[ax]++;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(cs);
    yield* sub_3bac();
    sp += 0x0006;
    r16[ax] = r16[di];
    r16[ax] += r16[si];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_32ff() // 01ed:142f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[dx] != 0xffff)
        { pc = 0x330f; break; }
    r16[ax] = 0xffff;
    { pc = 0x3329; break; }
  case 0x330f:
    r8[al] = r8[dl];
    r8[ah] = 0x00;
    r16[bx] = r16[ax];
    if (!(memoryAGet(ds, r16[bx] + 28297) & 0x04))
        { pc = 0x3325; break; }
    r8[al] = r8[dl];
    r8[ah] = 0x00;
    r16[ax] += 0x0020;
    { pc = 0x3329; break; }
  case 0x3325:
    r8[al] = r8[dl];
    r8[ah] = 0x00;
  case 0x3329:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_332b() // 01ed:145b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[dx] != 0xffff)
        { pc = 0x333b; break; }
    r16[ax] = 0xffff;
    { pc = 0x3355; break; }
  case 0x333b:
    r8[al] = r8[dl];
    r8[ah] = 0x00;
    r16[bx] = r16[ax];
    if (!(memoryAGet(ds, r16[bx] + 28297) & 0x08))
        { pc = 0x3351; break; }
    r8[al] = r8[dl];
    r8[ah] = 0x00;
    r16[ax] += 0xffe0;
    { pc = 0x3355; break; }
  case 0x3351:
    r8[al] = r8[dl];
    r8[ah] = 0x00;
  case 0x3355:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3357() // 01ed:1487
{
    sp -= 2;
    r8[ah] = 0x03;
    r8[bh] = 0x00;
    yield* sub_366a();
    r16[ax] = r16[dx];
    sp += 2;
}
function* sub_3383() // 01ed:14b3 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x008a;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax]++;
    if (r16[ax] >= 0x0002)
        { pc = 0x339a; break; }
    r16[ax] = 0;
    { pc = 0x3476; break; }
  case 0x339a:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    if (!(memoryAGet16(ds, r16[bx] + 28888) & 0x8000))
        { pc = 0x33bb; break; }
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    { pc = 0x3476; break; }
  case 0x33bb:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, memoryAGet16(ds, r16[bx] + 28888) & 0xfdff);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0x342d; break; }
  case 0x33d4:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 1);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    memoryASet(ss, r16[bp] - 5, r8[al]);
    if (r8[al] != 0x0a)
        { pc = 0x33ea; break; }
    memoryASet(ds, r16[si], 0x0d);
    r16[si]++;
  case 0x33ea:
    r8[al] = memoryAGet(ss, r16[bp] - 5);
    memoryASet(ds, r16[si], r8[al]);
    r16[si]++;
    r16[ax] = r16[bp] - 138;
    r16[dx] = r16[si];
    r16[dx] -= r16[ax];
    if (r16s[dx] < signed16(0x0080))
        { pc = 0x3433; break; }
    r16[dx] = r16[si];
    r16[dx] -= r16[ax];
    r16[di] = r16[dx];
    push(r16[di]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[ax] == r16[di])
        { pc = 0x342d; break; }
    if (memoryAGet16(ss, r16[bp] - 2) >= 0x0000)
        { pc = 0x3423; break; }
  case 0x341e:
    r16[ax] = 0xffff;
    { pc = 0x3471; break; }
  case 0x3423:
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    { pc = 0x346c; break; }
    // gap 2 bytes
  case 0x342d:
    r16[ax] = r16[bp] - 138;
    r16[si] = r16[ax];
  case 0x3433:
    if (memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x33d4; break; }
    r16[ax] = r16[bp] - 138;
    r16[dx] = r16[si];
    r16[dx] -= r16[ax];
    r16[di] = r16[dx];
    r16[ax] = r16[dx];
    if (r16[ax] <= 0)
        { pc = 0x3473; break; }
    push(r16[di]);
    r16[ax] = r16[bp] - 138;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_47af();
    sp += 0x0006;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[ax] == r16[di])
        { pc = 0x3473; break; }
    if (memoryAGet16(ss, r16[bp] - 2) >= 0x0000)
        { pc = 0x3469; break; }
    { pc = 0x341e; break; }
  case 0x3469:
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
  case 0x346c:
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= r16[di];
  case 0x3471:
    { pc = 0x3476; break; }
  case 0x3473:
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
  case 0x3476:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_349f() // 01ed:15cf +far +stackDrop2
{
  var pc = 0;
  var temp_cond0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    push(r16[bp]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    flags.direction = 0;
    r16[ax] -= r16[ax];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[cx] = 0x000a;
    r8[bh] = 0x00;
    r16[di] = 0x6e89;
  case 0x34b4:
    r8[bl] = memoryAGet(ds, r16[si]);
    r16[si]++;
    if (memoryAGet(ds, r16[bx] + r16[di]) & 0x01)
        { pc = 0x34b4; break; }
    r16[bp] = 0x0000;
    if (r8[bl] == 0x2b)
        { pc = 0x34ca; break; }
    if (r8[bl] != 0x2d)
        { pc = 0x34cd; break; }
    r16[bp]++;
  case 0x34ca:
    r8[bl] = memoryAGet(ds, r16[si]);
    r16[si]++;
  case 0x34cd:
    if (r8[bl] > 0x39)
        { pc = 0x3500; break; }
    flags.carry = r8[bl] < 0x30;
    r8[bl] -= 0x30;
    if (flags.carry)
        { pc = 0x3500; break; }
    mul16(r16[cx]);
    flags.carry = r16[ax] + r16[bx] >= 0x10000;
    r16[ax] += r16[bx];
    r8[dl] += (r8[dh] + flags.carry);
    if (!r8[dl])
        { pc = 0x34ca; break; }
    { pc = 0x34f3; break; }
  case 0x34e1:
    r16[di] = r16[dx];
    r16[cx] = 0x000a;
    mul16(r16[cx]);
    r16[tx] = r16[di]; r16[di] = r16[ax]; r16[ax] = r16[tx];
    r16[tx] = r16[cx]; r16[cx] = r16[dx]; r16[dx] = r16[tx];
    mul16(r16[dx]);
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[tx] = r16[di]; r16[di] = r16[ax]; r16[ax] = r16[tx];
    flags.carry = r16[ax] + r16[bx] >= 0x10000;
    r16[ax] += r16[bx];
    r16[dx] += (r16[cx] + flags.carry);
  case 0x34f3:
    r8[bl] = memoryAGet(ds, r16[si]);
    r16[si]++;
    if (r8[bl] > 0x39)
        { pc = 0x3500; break; }
    flags.carry = r8[bl] < 0x30;
    r8[bl] -= 0x30;
    if (!flags.carry)
        { pc = 0x34e1; break; }
  case 0x3500:
    temp_cond0 = r16s[bp] < 0;
    r16[bp]--;
    if (temp_cond0)
        { pc = 0x350a; break; }
    r16[dx] = -r16[dx];
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[dx] -= (0x0000 + flags.carry);
  case 0x350a:
    r16[bp] = pop();
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_352c() // 01ed:165c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = 0;
    r8[ah] = memoryAGet(ss, r16[bp] + 6);
    interrupt(0x16);
    if (flags.zero)
        { pc = 0x3547; break; }
    if (memoryAGet(ss, r16[bp] + 6) & 0x01)
        { pc = 0x354f; break; }
    if (r16[ax])
        { pc = 0x354f; break; }
    r16[ax] = 0xffff;
    { pc = 0x354f; break; }
  case 0x3547:
    if (!(memoryAGet(ss, r16[bp] + 6) & 0x01))
        { pc = 0x354f; break; }
    r16[ax] = 0;
  case 0x354f:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3551() // 01ed:1681
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    r16[dx] = sp;
    r16[dx] -= 0x0200;
    if (r16[ax] >= r16[dx])
        { pc = 0x3568; break; }
    memoryASet16(ds, 0x009c, r16[ax]);
    r16[ax] = 0;
    { pc = 0x3571; break; }
  case 0x3568:
    memoryASet16(ds, 0x0094, 0x0008);
    r16[ax] = 0xffff;
  case 0x3571:
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_3573() // 01ed:16a3
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    flags.carry = r16[ax] + memoryAGet16(ds, 0x009c) >= 0x10000;
    r16[ax] += memoryAGet16(ds, 0x009c);
    r16[dx] += (0x0000 + flags.carry);
    r16[cx] = r16[ax];
    if (r16[dx])
        { pc = 0x3599; break; }
    flags.carry = r16[cx] + 0x0200 >= 0x10000;
    r16[cx] += 0x0200;
    if (flags.carry)
        { pc = 0x3599; break; }
    if (r16[cx] >= sp)
        { pc = 0x3599; break; }
    r16[tx] = memoryAGet16(ds, 0x009c); memoryASet16(ds, 0x009c, r16[ax]); r16[ax] = r16[tx];
    { pc = 0x35a2; break; }
  case 0x3599:
    memoryASet16(ds, 0x0094, 0x0008);
    r16[ax] = 0xffff;
  case 0x35a2:
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_35d6() // 01ed:1706 +stackDrop2
{
    sp -= 2;
    r8[ah] = 0x19;
    interrupt(0x21);
    cbw();
    sp += 2; cs = pop();
}
function* sub_35e9() // 01ed:1719 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r8[ah] = 0x43;
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x35fe; break; }
    r16[tx] = r16[cx]; r16[cx] = r16[ax]; r16[ax] = r16[tx];
    { pc = 0x3602; break; }
  case 0x35fe:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3602:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3604() // 01ed:1734 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x3e;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x361c; break; }
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, 0xffff);
    r16[ax] = 0;
    { pc = 0x3620; break; }
  case 0x361c:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3620:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3622() // 01ed:1752 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[ax] = sp;
    r16[ax] -= memoryAGet16(ds, 0x009c);
    flags.carry = r16[ax] < 0x0220;
    r16[ax] -= 0x0220;
    if (!flags.carry)
        { pc = 0x362f; break; }
    r16[ax] = 0;
  case 0x362f:
    r8[al] &= 0xf0;
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3632() // 01ed:1762 +stackDrop6
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 4);
    { pc = 0x364f; break; }
  case 0x363b:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 1);
    r8[al] = memoryAGet(es, r16[bx]);
    r16[bx] = r16[si];
    r16[si]++;
    if (r8[al] == memoryAGet(ds, r16[bx]))
        { pc = 0x364f; break; }
    r16[ax] = 0;
    { pc = 0x3657; break; }
  case 0x364f:
    if (memoryAGet(ds, r16[si]))
        { pc = 0x363b; break; }
    r16[ax] = 0x0001;
  case 0x3657:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 8;
    return;
  }
}
function* sub_365c() // 01ed:178c
{
    sp -= 2;
    r8[ah] = 0x12;
    r8[bl] = 0x10;
    yield* sub_366a();
    r8[al] = r8[bl];
    r8[al] += 0xf0;
    r8[ah] = 0x00;
    sp += 2;
}
function* sub_366a() // 01ed:179a
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    push(ds);
    push(r16[cx]);
    r16[cx] = 0x0040;
    ds = r16[cx];
    r16[cx] = pop();
    if (!r8[ah])
        { pc = 0x3681; break; }
    if (r8[ah] == 0x0f)
        { pc = 0x36d3; break; }
  case 0x367d:
    interrupt(0x10);
    { pc = 0x36eb; break; }
  case 0x3681:
    if (r8[al] != 0x03)
        { pc = 0x369f; break; }
    r16[ax] = 0x1a00;
    interrupt(0x10);
    if (r8[al] == 0x1a)
        { pc = 0x3693; break; }
    memoryASet(ds, 0x0087, memoryAGet(ds, 0x0087) & 0xfe);
  case 0x3693:
    r8[ah] = 0x01;
    r16[cx] = 0x0607;
    interrupt(0x10);
    r16[ax] = 0x0003;
    { pc = 0x367d; break; }
  case 0x369f:
    if (r8[al] != 0x40)
        { pc = 0x367d; break; }
    r8[bl] = 0x10;
    r8[ah] = 0x12;
    interrupt(0x10);
    if (r8[bl] == 0x10)
        { pc = 0x36eb; break; }
    r16[ax] = 0x1112;
    r8[bl] = 0;
    interrupt(0x10);
    r16[ax] = 0x1200;
    r8[bl] = 0x20;
    interrupt(0x10);
    r16[ax] = 0x1a00;
    interrupt(0x10);
    if (r8[al] == 0x1a)
        { pc = 0x36eb; break; }
    memoryASet(ds, 0x0087, memoryAGet(ds, 0x0087) | 0x01);
    r8[ah] = 0x01;
    r16[cx] = 0x0600;
    interrupt(0x10);
    { pc = 0x36eb; break; }
  case 0x36d3:
    interrupt(0x10);
    if (r8[al] != 0x03)
        { pc = 0x36eb; break; }
    push(r16[ax]);
    yield* sub_365c();
    flags.zero = r8[al] == 0;
    r16[ax] = pop();
    if (flags.zero)
        { pc = 0x36eb; break; }
    if (memoryAGet(ds, 0x0084) == 0x18)
        { pc = 0x36eb; break; }
    r8[al] = 0x40;
  case 0x36eb:
    ds = pop();
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_36ee() // 01ed:181e
{
    sp -= 2;
    r8[ah] = 0x0f;
    yield* sub_366a();
    push(r16[ax]);
    yield* sub_370b();
    r16[cx] = pop();
    r8[ah] = 0x08;
    r8[bh] = 0x00;
    yield* sub_366a();
    r8[ah] &= 0x7f;
    memoryASet(ds, 0x734d, r8[ah]);
    memoryASet(ds, 0x734c, r8[ah]);
    sp += 2;
}
function* sub_370b() // 01ed:183b
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = memoryAGet(ss, r16[bp] + 4);
    memoryASet(ds, 0x734e, r8[al]);
    r8[ah] = 0x0f;
    yield* sub_366a();
    memoryASet(ds, 0x7350, r8[ah]);
    if (r8[al] == memoryAGet(ds, 0x734e))
        { pc = 0x3750; break; }
    r8[al] = memoryAGet(ds, 0x734e);
    r8[ah] = 0x00;
    yield* sub_366a();
    r8[ah] = 0x0f;
    yield* sub_366a();
    memoryASet(ds, 0x734e, r8[al]);
    memoryASet(ds, 0x7350, r8[ah]);
    if (memoryAGet(ds, 0x734e) != 0x03)
        { pc = 0x3750; break; }
    r16[ax] = 0x0040;
    es = r16[ax];
    if (signed8(memoryAGet(es, 0x0084)) <= signed8(0x18))
        { pc = 0x3750; break; }
    memoryASet(ds, 0x734e, 0x40);
  case 0x3750:
    if (memoryAGet(ds, 0x734e) <= 0x03)
        { pc = 0x376a; break; }
    if (memoryAGet(ds, 0x734e) >= 0x40)
        { pc = 0x376a; break; }
    if (memoryAGet(ds, 0x734e) == 0x07)
        { pc = 0x376a; break; }
    r16[ax] = 0x0001;
    { pc = 0x376c; break; }
  case 0x376a:
    r16[ax] = 0;
  case 0x376c:
    memoryASet(ds, 0x7351, r8[al]);
    if (memoryAGet(ds, 0x734e) == 0x40)
        { pc = 0x377a; break; }
    r8[al] = 0x19;
    { pc = 0x3785; break; }
  case 0x377a:
    r16[ax] = 0x0040;
    es = r16[ax];
    r8[al] = memoryAGet(es, 0x0084);
    r8[al]++;
  case 0x3785:
    memoryASet(ds, 0x734f, r8[al]);
    if (memoryAGet(ds, 0x734e) == 0x07)
        { pc = 0x37ae; break; }
    r16[ax] = 0xf000;
    r16[dx] = 0xffea;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0x7359;
    push(r16[ax]);
    yield* sub_3632();
    if (r16[ax])
        { pc = 0x37ae; break; }
    yield* sub_365c();
    if (r16[ax])
        { pc = 0x37ae; break; }
    r16[ax] = 0x0001;
    { pc = 0x37b0; break; }
  case 0x37ae:
    r16[ax] = 0;
  case 0x37b0:
    memoryASet(ds, 0x7352, r8[al]);
    if (memoryAGet(ds, 0x734e) != 0x07)
        { pc = 0x37bf; break; }
    r16[ax] = 0xb000;
    { pc = 0x37c2; break; }
  case 0x37bf:
    r16[ax] = 0xb800;
  case 0x37c2:
    memoryASet16(ds, 0x7355, r16[ax]);
    memoryASet16(ds, 0x7353, 0x0000);
    r8[al] = 0x00;
    memoryASet(ds, 0x7349, r8[al]);
    memoryASet(ds, 0x7348, r8[al]);
    r8[al] = memoryAGet(ds, 0x7350);
    r8[al] += 0xff;
    memoryASet(ds, 0x734a, r8[al]);
    r8[al] = memoryAGet(ds, 0x734f);
    r8[al] += 0xff;
    memoryASet(ds, 0x734b, r8[al]);
    r16[bp] = pop();
    sp += 2;
    return;
  }
}
function* sub_37e5() // 01ed:1915 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(ds);
    r8[ah] = 0x2f;
    interrupt(0x21);
    push(es);
    push(r16[bx]);
    r8[ah] = 0x1a;
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    interrupt(0x21);
    r8[ah] = 0x4e;
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    push(flagAsReg());
    r16[cx] = pop();
    r16[tx] = r16[bx]; r16[bx] = r16[ax]; r16[ax] = r16[tx];
    r8[ah] = 0x1a;
    r16[dx] = pop();
    ds = pop();
    interrupt(0x21);
    push(r16[cx]);
    flagsFromReg(pop());
    ds = pop();
    if (flags.carry)
        { pc = 0x3812; break; }
    r16[ax] = 0;
    { pc = 0x3816; break; }
  case 0x3812:
    push(r16[bx]);
    yield* sub_3a4b();
  case 0x3816:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3845() // 01ed:1975 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r16[ax] = 0x4201;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = 0;
    r16[dx] = 0;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x387d; break; }
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x4202;
    r16[cx] = 0;
    r16[dx] = 0;
    interrupt(0x21);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    r16[dx] = pop();
    r16[cx] = pop();
    if (flags.carry)
        { pc = 0x387d; break; }
    r16[ax] = 0x4200;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x387d; break; }
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    { pc = 0x3882; break; }
  case 0x387d:
    push(r16[ax]);
    yield* sub_3a4b();
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
  case 0x3882:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3886() // 01ed:19b6 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (!memoryAGet(ds, 0x7360))
        { pc = 0x3897; break; }
    memoryASet(ds, 0x7360, 0x00);
    r8[al] = memoryAGet(ds, 0x7361);
    { pc = 0x389c; break; }
  case 0x3897:
    r16[ax] = 0x0700;
    interrupt(0x21);
  case 0x389c:
    r8[ah] = 0x00;
    sp += 2; cs = pop();
    return;
  }
}
function* sub_38e2() // 01ed:1a12 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r8[ah] = 0x47;
    r8[dl] = memoryAGet(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x38f6; break; }
    r16[ax] = 0;
    { pc = 0x38fa; break; }
  case 0x38f6:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x38fa:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_38fd() // 01ed:1a2d +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    push(ds);
    es = pop();
    if (!r16[di])
        { pc = 0x3927; break; }
    r8[al] = 0x00;
    r8[ah] = memoryAGet(ds, r16[di]);
    r16[cx] = 0xffff;
    flags.direction = 0;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[cx] = ~r16[cx];
    r16[cx]--;
    if (!r16[cx])
        { pc = 0x3927; break; }
    r16[di] = memoryAGet16(ds, 0x744a);
    memoryASet16(ss, r16[bp] - 2, r16[di]);
    if (r16[di])
        { pc = 0x3932; break; }
  case 0x3927:
    r16[ax] = 0;
    { pc = 0x3955; break; }
  case 0x392b:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 0x0002);
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
  case 0x3932:
    r16[di] = memoryAGet16(ds, r16[di]);
    if (!r16[di])
        { pc = 0x3927; break; }
    r8[al] = memoryAGet(ds, r16[di]);
    if (!r8[al])
        { pc = 0x3927; break; }
    if (r8[ah] != r8[al])
        { pc = 0x392b; break; }
    r16[bx] = r16[cx];
    if (memoryAGet(ds, r16[bx] + r16[di]) != 0x3d)
        { pc = 0x392b; break; }
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    for (flags.zero = 1; r16[cx] != 0 && flags.zero; --r16[cx]) cmpsb_DSSI_ESDI();
    r16[tx] = r16[bx]; r16[bx] = r16[cx]; r16[cx] = r16[tx];
    if (!flags.zero)
        { pc = 0x392b; break; }
    r16[di]++;
    r16[ax] = r16[di];
  case 0x3955:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_395b() // 01ed:1a8b +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x35;
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    interrupt(0x21);
    r16[tx] = r16[bx]; r16[bx] = r16[ax]; r16[ax] = r16[tx];
    r16[dx] = es;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_396a() // 01ed:1a9a +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x25;
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    push(ds);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8); ds = memoryAGet16(ss, r16[bp] + 10);
    interrupt(0x21);
    ds = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_39b3() // 01ed:1ae3 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x7968, r16[ax]);
    memoryASet16(ds, 0x7966, r16[dx]);
    push(cs);
    r16[ax] = 0x1aab;
    push(r16[ax]);
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    yield* sub_396a();
    sp += 0x0006;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_3a24() // 01ed:1b54 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x44;
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 10);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x3a45; break; }
    if (memoryAGet16(ss, r16[bp] + 8))
        { pc = 0x3a43; break; }
    r16[ax] = r16[dx];
    { pc = 0x3a49; break; }
  case 0x3a43:
    { pc = 0x3a49; break; }
  case 0x3a45:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3a49:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3a4b() // 01ed:1b7b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 4);
    if (r16s[si] < 0)
        { pc = 0x3a6b; break; }
    if (r16s[si] <= signed16(0x0058))
        { pc = 0x3a5e; break; }
  case 0x3a5b:
    r16[si] = 0x0057;
  case 0x3a5e:
    memoryASet16(ds, 0x7362, r16[si]);
    r8[al] = memoryAGet(ds, r16[si] + 29540);
    cbw();
    r16[si] = r16[ax];
    { pc = 0x3a7c; break; }
  case 0x3a6b:
    r16[ax] = r16[si];
    r16[ax] = -r16[ax];
    r16[si] = r16[ax];
    if (r16s[si] > signed16(0x0023))
        { pc = 0x3a5b; break; }
    memoryASet16(ds, 0x7362, 0xffff);
  case 0x3a7c:
    memoryASet16(ds, 0x0094, r16[si]);
    r16[ax] = 0xffff;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 4;
    return;
  }
}
function* sub_3a88() // 01ed:1bb8 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x4400;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[ax] &= 0x0080;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_3a99() // 01ed:1bc9 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, memoryAGet16(ds, r16[bx] + 28888) & 0xfdff);
    r8[ah] = 0x42;
    r8[al] = memoryAGet(ss, r16[bp] + 12);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x3abb; break; }
    { pc = 0x3ac0; break; }
  case 0x3abb:
    push(r16[ax]);
    yield* sub_3a4b();
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
  case 0x3ac0:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3ac2() // 01ed:1bf2 +stackDrop12
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0022;
    push(r16[si]);
    push(r16[di]);
    push(es);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    push(ds);
    es = pop();
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    if (r16[bx] > 0x0024)
        { pc = 0x3b30; break; }
    if (r8[bl] < 0x02)
        { pc = 0x3b30; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[cx] = memoryAGet16(ss, r16[bp] + 14);
    if (r16s[cx] >= 0)
        { pc = 0x3af8; break; }
    if (!memoryAGet(ss, r16[bp] + 6))
        { pc = 0x3af8; break; }
    memoryASet(ds, r16[di], 0x2d);
    r16[di]++;
    r16[cx] = -r16[cx];
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[cx] -= (0x0000 + flags.carry);
  case 0x3af8:
    r16[si] = r16[bp] - 34;
    if (!r16[cx])
        { pc = 0x3b0c; break; }
  case 0x3afd:
    r16[tx] = r16[cx]; r16[cx] = r16[ax]; r16[ax] = r16[tx];
    r16[dx] -= r16[dx];
    div16(r16[bx]);
    r16[tx] = r16[cx]; r16[cx] = r16[ax]; r16[ax] = r16[tx];
    div16(r16[bx]);
    memoryASet(ds, r16[si], r8[dl]);
    r16[si]++;
    if (!r16[cx])
        { pc = 0x3b13; break; }
    { pc = 0x3afd; break; }
  case 0x3b0c:
    r16[dx] -= r16[dx];
    div16(r16[bx]);
    memoryASet(ds, r16[si], r8[dl]);
    r16[si]++;
  case 0x3b13:
    if (r16[ax])
        { pc = 0x3b0c; break; }
    r16[cx] = r16[bp] - 34;
    r16[cx] = -r16[cx];
    r16[cx] += r16[si];
    flags.direction = 0;
  case 0x3b1f:
    r16[si]--;
    r8[al] = memoryAGet(ds, r16[si]);
    flags.carry = r8[al] < 0x0a;
    r8[al] -= 0x0a;
    if (!flags.carry)
        { pc = 0x3b2a; break; }
    r8[al] += 0x3a;
    { pc = 0x3b2d; break; }
  case 0x3b2a:
    r8[al] += memoryAGet(ss, r16[bp] + 4);
  case 0x3b2d:
    stosb_ESDI(r8[al]);
    if (--r16[cx])
        { pc = 0x3b1f; break; }
  case 0x3b30:
    r8[al] = 0x00;
    stosb_ESDI(r8[al]);
    es = pop();
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 14;
    return;
  }
}
function* sub_3b3f() // 01ed:1c6f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    if (r16[di] != 0x000a)
        { pc = 0x3b54; break; }
    r16[ax] = r16[si];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    { pc = 0x3b58; break; }
  case 0x3b54:
    r16[ax] = r16[si];
    r16[dx] = 0;
  case 0x3b58:
    push(r16[dx]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    r8[al] = 0x01;
    push(r16[ax]);
    r8[al] = 0x61;
    push(r16[ax]);
    yield* sub_3ac2();
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3b6b() // 01ed:1c9b +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 12));
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0x61;
    push(r16[ax]);
    yield* sub_3ac2();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_3b85() // 01ed:1cb5 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 12);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(r16[si]);
    if (r16[si] != 0x000a)
        { pc = 0x3ba0; break; }
    r16[ax] = 0x0001;
    { pc = 0x3ba2; break; }
  case 0x3ba0:
    r16[ax] = 0;
  case 0x3ba2:
    push(r16[ax]);
    r8[al] = 0x61;
    push(r16[ax]);
    yield* sub_3ac2();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3bac() // 01ed:1cdc +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    flags.direction = 0;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    if (!flags.carry)
        { pc = 0x3bc6; break; }
    movsb_ESDI_DSSI();
  case 0x3bc6:
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3bcd() // 01ed:1cfd +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(ss, r16[bp] + 10);
    r8[ah] = r8[al];
    flags.direction = 0;
    if (!(r16[di] & 0x0001))
        { pc = 0x3beb; break; }
    if (!r16[cx])
        { pc = 0x3bf2; break; }
    stosb_ESDI(r8[al]);
    r16[cx]--;
  case 0x3beb:
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    if (!flags.carry)
        { pc = 0x3bf2; break; }
    stosb_ESDI(r8[al]);
  case 0x3bf2:
    r16[di] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3bf5() // 01ed:1d25 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(r16[si]);
    push(cs);
    yield* sub_3bcd();
    sp += 0x0006;
    r16[ax] = r16[si];
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_3c10() // 01ed:1d40 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    flags.direction = 0;
    r16[cx] = memoryAGet16(ss, r16[bp] + 14);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    es = memoryAGet16(ss, r16[bp] + 10);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    push(ds);
    ds = memoryAGet16(ss, r16[bp] + 6);
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    if (!flags.carry)
        { pc = 0x3c2d; break; }
    movsb_ESDI_DSSI();
  case 0x3c2d:
    ds = pop();
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3c32() // 01ed:1d62 +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[cx] = memoryAGet16(ss, r16[bp] + 4);
    r8[ah] = 0x3c;
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x3c43; break; }
    { pc = 0x3c47; break; }
  case 0x3c43:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3c47:
    r16[bp] = pop();
    sp += 6;
    return;
  }
}
function* sub_3c4b() // 01ed:1d7b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 4);
    r16[cx] -= r16[cx];
    r16[dx] -= r16[dx];
    r8[ah] = 0x40;
    interrupt(0x21);
    r16[bp] = pop();
    sp += 4;
}
function* sub_3c5d() // 01ed:1d8d +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    if (r16[si] & 0xc000)
        { pc = 0x3c76; break; }
    r16[ax] = memoryAGet16(ds, 0x7100);
    r16[ax] &= 0xc000;
    r16[si] |= r16[ax];
  case 0x3c76:
    if (r16[si] & 0x0100)
        { pc = 0x3c7e; break; }
    { pc = 0x3cfc; break; }
  case 0x3c7e:
    r16[ax] = memoryAGet16(ds, 0x7102);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) & r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    if (r16[ax] & 0x0180)
        { pc = 0x3c93; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3c93:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_35e9();
    r16[cx] = pop();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[ax] != 0xffff)
        { pc = 0x3cd1; break; }
    if (!(memoryAGet16(ss, r16[bp] + 10) & 0x0080))
        { pc = 0x3cb3; break; }
    r16[ax] = 0;
    { pc = 0x3cb6; break; }
  case 0x3cb3:
    r16[ax] = 0x0001;
  case 0x3cb6:
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!(r16[si] & 0x00f0))
        { pc = 0x3cea; break; }
    push(memoryAGet16(ss, r16[bp] + 6));
    r16[ax] = 0;
    push(r16[ax]);
    yield* sub_3c32();
    r16[di] = r16[ax];
    if (r16s[ax] >= 0)
        { pc = 0x3ce1; break; }
    { pc = 0x3d8c; break; }
  case 0x3cd1:
    if (!(r16[si] & 0x0400))
        { pc = 0x3cfc; break; }
    r16[ax] = 0x0050;
    push(r16[ax]);
    yield* sub_3a4b();
    { pc = 0x3d8e; break; }
  case 0x3ce1:
    push(r16[di]);
    push(cs);
    yield* sub_3604();
    r16[cx] = pop();
    { pc = 0x3d01; break; }
  case 0x3cea:
    push(memoryAGet16(ss, r16[bp] + 6));
    push(memoryAGet16(ss, r16[bp] - 2));
    yield* sub_3c32();
    r16[di] = r16[ax];
    if (r16s[ax] >= 0)
        { pc = 0x3d6b; break; }
    { pc = 0x3d8c; break; }
  case 0x3cfc:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
  case 0x3d01:
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_3d94();
    r16[cx] = pop();
    r16[cx] = pop();
    r16[di] = r16[ax];
    if (r16s[ax] < 0)
        { pc = 0x3d6b; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_3a24();
    r16[cx] = pop();
    r16[cx] = pop();
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (!(r16[ax] & 0x0080))
        { pc = 0x3d45; break; }
    r16[si] |= 0x2000;
    if (!(r16[si] & 0x8000))
        { pc = 0x3d4f; break; }
    r16[ax] &= 0x00ff;
    r16[ax] |= 0x0020;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_3a24();
    sp += 0x0006;
    { pc = 0x3d4f; break; }
  case 0x3d45:
    if (!(r16[si] & 0x0200))
        { pc = 0x3d4f; break; }
    push(r16[di]);
    yield* sub_3c4b();
  case 0x3d4f:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x3d6b; break; }
    if (!(r16[si] & 0x00f0))
        { pc = 0x3d6b; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_35e9();
    sp += 0x0006;
  case 0x3d6b:
    if (r16s[di] < 0)
        { pc = 0x3d8c; break; }
    if (!(r16[si] & 0x0300))
        { pc = 0x3d7a; break; }
    r16[ax] = 0x1000;
    { pc = 0x3d7c; break; }
  case 0x3d7a:
    r16[ax] = 0;
  case 0x3d7c:
    r16[dx] = r16[si];
    r16[dx] &= 0xf8ff;
    r16[dx] |= r16[ax];
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, r16[dx]);
  case 0x3d8c:
    r16[ax] = r16[di];
  case 0x3d8e:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3d94() // 01ed:1ec4 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    r8[al] = 0x01;
    r16[cx] = memoryAGet16(ss, r16[bp] + 8);
    if (r16[cx] & 0x0002)
        { pc = 0x3dae; break; }
    r8[al] = 0x02;
    if (r16[cx] & 0x0004)
        { pc = 0x3dae; break; }
    r8[al] = 0x00;
  case 0x3dae:
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0xf0;
    r8[cl] &= memoryAGet(ss, r16[bp] + 8);
    r8[al] |= r8[cl];
    r8[ah] = 0x3d;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x3dd8; break; }
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] &= 0xf8ff;
    r16[ax] |= 0x8000;
    memoryASet16(ds, r16[bx] + 28888, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    { pc = 0x3ddc; break; }
  case 0x3dd8:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3ddc:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3de0() // 01ed:1f10 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax]++;
    if (r16[ax] < 0x0002)
        { pc = 0x3dfe; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    if (!(memoryAGet16(ds, r16[bx] + 28888) & 0x0200))
        { pc = 0x3e03; break; }
  case 0x3dfe:
    r16[ax] = 0;
    { pc = 0x3e95; break; }
  case 0x3e03:
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_3e9b();
    sp += 0x0006;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax]++;
    if (r16[ax] < 0x0002)
        { pc = 0x3e2a; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    if (!(memoryAGet16(ds, r16[bx] + 28888) & 0x8000))
        { pc = 0x3e2f; break; }
  case 0x3e2a:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    { pc = 0x3e95; break; }
  case 0x3e2f:
    r16[cx] = memoryAGet16(ss, r16[bp] - 2);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    push(ds);
    es = pop();
    r16[di] = r16[si];
    r16[bx] = r16[si];
    flags.direction = 0;
  case 0x3e3c:
    r8[al] = lodsb_DSSI();
    if (r8[al] == 0x1a)
        { pc = 0x3e70; break; }
    if (r8[al] == 0x0d)
        { pc = 0x3e4a; break; }
    stosb_ESDI(r8[al]);
    if (--r16[cx])
        { pc = 0x3e3c; break; }
    { pc = 0x3e68; break; }
  case 0x3e4a:
    if (--r16[cx])
        { pc = 0x3e3c; break; }
    push(es);
    push(r16[bx]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[bp] - 3;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_3e9b();
    sp += 0x0006;
    r16[bx] = pop();
    es = pop();
    flags.direction = 0;
    r8[al] = memoryAGet(ss, r16[bp] - 3);
    stosb_ESDI(r8[al]);
  case 0x3e68:
    if (r16[di] != r16[bx])
        { pc = 0x3e6e; break; }
    { pc = 0x3e03; break; }
  case 0x3e6e:
    { pc = 0x3e92; break; }
  case 0x3e70:
    push(r16[bx]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    flags.carry = r16[cx] != 0;
    r16[cx] = -r16[cx];
    r16[ax] = -flags.carry;
    push(r16[ax]);
    push(r16[cx]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_3a99();
    sp += 0x0008;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, memoryAGet16(ds, r16[bx] + 28888) | 0x0200);
    r16[bx] = pop();
  case 0x3e92:
    r16[di] -= r16[bx];
    r16[tx] = r16[di]; r16[di] = r16[ax]; r16[ax] = r16[tx];
  case 0x3e95:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3e9b() // 01ed:1fcb +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x3f;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x3eaf; break; }
    { pc = 0x3eb3; break; }
  case 0x3eaf:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3eb3:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3ecb() // 01ed:1ffb +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    r8[ah] = 0x56;
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x3ee3; break; }
    r16[ax] = 0;
    { pc = 0x3ee7; break; }
  case 0x3ee3:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x3ee7:
    r16[di] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_3eea() // 01ed:201a +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 4);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    flags.direction = 0;
    push(ds);
    es = pop();
  case 0x3ef8:
    r8[al] = lodsb_DSSI();
    if (r8[al] < 0x61)
        { pc = 0x3f03; break; }
    if (r8[al] > 0x7a)
        { pc = 0x3f03; break; }
    r8[al] -= 0x20;
  case 0x3f03:
    stosb_ESDI(r8[al]);
    if (r8[al])
        { pc = 0x3ef8; break; }
    r16[di]--;
    r16[tx] = r16[di]; r16[di] = r16[ax]; r16[ax] = r16[tx];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 6;
    return;
  }
}
function* sub_3f10() // 01ed:2040 +stackDrop12
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x002c;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    r16[si] = memoryAGet16(ss, r16[bp] + 14);
    if (memoryAGet(ds, r16[di]))
        { pc = 0x3f2e; break; }
    push(cs);
    yield* sub_35d6();
    r8[al] += 0x41;
    memoryASet(ds, r16[di], r8[al]);
    { pc = 0x3f31; break; }
  case 0x3f2e:
    memoryASet(ds, r16[di], memoryAGet(ds, r16[di]) & 0xdf);
  case 0x3f31:
    r8[al] = memoryAGet(ds, r16[di]);
    memoryASet(ds, r16[si], r8[al]);
    r16[si]++;
    memoryASet(ds, r16[si], 0x3a);
    r16[si]++;
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    if (memoryAGet(ds, r16[bx]) == 0x5c)
        { pc = 0x3f6a; break; }
    if (memoryAGet(ds, r16[bx]) == 0x2f)
        { pc = 0x3f6a; break; }
    memoryASet(ds, r16[si], 0x5c);
    r16[si]++;
    push(r16[si]);
    r8[al] = memoryAGet(ds, r16[di]);
    cbw();
    r16[ax] += 0xffc0;
    push(r16[ax]);
    push(cs);
    yield* sub_38e2();
    r16[cx] = pop();
    r16[cx] = pop();
    if (!memoryAGet(ds, r16[si]))
        { pc = 0x3f6a; break; }
    push(r16[si]);
    push(r16[si]);
    yield* sub_3eea();
    r16[si] = r16[ax];
    memoryASet(ds, r16[si], 0x5c);
    r16[si]++;
  case 0x3f6a:
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 10));
    yield* sub_3eea();
    r16[si] = r16[ax];
    if (memoryAGet(ds, r16[si] - 1) == 0x5c)
        { pc = 0x3f83; break; }
    if (memoryAGet(ds, r16[si] - 1) == 0x2f)
        { pc = 0x3f83; break; }
    memoryASet(ds, r16[si], 0x5c);
    r16[si]++;
  case 0x3f83:
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 8));
    yield* sub_3eea();
    r16[si] = r16[ax];
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x3f99; break; }
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 6));
    yield* sub_3eea();
  case 0x3f99:
    if (!(memoryAGet16(ss, r16[bp] + 4) & 0x0002))
        { pc = 0x3fa5; break; }
    r16[ax] = 0x0027;
    { pc = 0x3fa8; break; }
  case 0x3fa5:
    r16[ax] = 0x0037;
  case 0x3fa8:
    push(r16[ax]);
    r16[ax] = r16[bp] - 44;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 14));
    push(cs);
    yield* sub_37e5();
    sp += 0x0006;
    r16[ax]++;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 14;
    return;
  }
}
function* sub_3fc1() // 01ed:20f1 +stackDrop4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0x79b5;
    r16[si] = 0;
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    if (memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x3fe0; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet(ds, r16[bx]))
        { pc = 0x3ffe; break; }
  case 0x3fe0:
    r16[ax] = 0x796c;
    push(r16[ax]);
    r16[ax] = 0x7a05;
    push(r16[ax]);
    r16[ax] = 0x7972;
    push(r16[ax]);
    r16[ax] = 0x7a0f;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_277c();
    sp += 0x000a;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x3ffe:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] &= 0x0005;
    if (r16[ax] == 0x0004)
        { pc = 0x400e; break; }
    r16[ax] = 0;
    { pc = 0x411e; break; }
  case 0x400e:
    if (!(memoryAGet16(ss, r16[bp] + 4) & 0x0002))
        { pc = 0x402b; break; }
    if (!(memoryAGet16(ss, r16[bp] - 2) & 0x0008))
        { pc = 0x4020; break; }
    memoryASet16(ss, r16[bp] + 4, memoryAGet16(ss, r16[bp] + 4) & 0xfffe);
  case 0x4020:
    if (!(memoryAGet16(ss, r16[bp] - 2) & 0x0002))
        { pc = 0x402b; break; }
    memoryASet16(ss, r16[bp] + 4, memoryAGet16(ss, r16[bp] + 4) & 0xfffd);
  case 0x402b:
    if (!(memoryAGet16(ss, r16[bp] + 4) & 0x0001))
        { pc = 0x403e; break; }
    r16[ax] = 0x73be;
    push(r16[ax]);
    push(cs);
    yield* sub_38fd();
    r16[cx] = pop();
    r16[si] = r16[ax];
  case 0x403e:
    push(r16[di]);
    r16[ax] = 0x7a0f;
    push(r16[ax]);
    r16[ax] = 0x7972;
    push(r16[ax]);
    r16[ax] = 0x7a05;
    push(r16[ax]);
    r16[ax] = 0x796c;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 4));
    yield* sub_3f10();
    if (!r16[ax])
        { pc = 0x405c; break; }
    { pc = 0x411c; break; }
  case 0x405c:
    if (!(memoryAGet16(ss, r16[bp] + 4) & 0x0002))
        { pc = 0x409e; break; }
    push(r16[di]);
    r16[ax] = 0x7a0f;
    push(r16[ax]);
    r16[ax] = 0x7972;
    push(r16[ax]);
    r16[ax] = 0x7a05;
    push(r16[ax]);
    r16[ax] = 0x73c3;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 4));
    yield* sub_3f10();
    if (!r16[ax])
        { pc = 0x4081; break; }
    { pc = 0x411c; break; }
  case 0x4081:
    push(r16[di]);
    r16[ax] = 0x7a0f;
    push(r16[ax]);
    r16[ax] = 0x7972;
    push(r16[ax]);
    r16[ax] = 0x7a05;
    push(r16[ax]);
    r16[ax] = 0x73c8;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 4));
    yield* sub_3f10();
    if (!r16[ax])
        { pc = 0x409e; break; }
    { pc = 0x411c; break; }
  case 0x409e:
    if (!r16[si])
        { pc = 0x40a7; break; }
    if (memoryAGet(ds, r16[si]))
        { pc = 0x40ab; break; }
  case 0x40a7:
    r16[di] = 0;
    { pc = 0x411c; break; }
  case 0x40ab:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    if (memoryAGet(ds, r16[si] + 1) != 0x3a)
        { pc = 0x40d0; break; }
    r8[al] = memoryAGet(ds, r16[si]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx] + 31247, r8[al]);
    r16[si]++;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    r8[al] = memoryAGet(ds, r16[si]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx] + 31247, r8[al]);
    r16[si]++;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x40d0:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx] + 31247, 0x00);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x40f4; break; }
  case 0x40df:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet(ds, r16[bx] + 31090) != 0x3b)
        { pc = 0x40f1; break; }
    memoryASet(ds, r16[bx] + 31090, 0x00);
    r16[si]++;
    { pc = 0x4104; break; }
  case 0x40f1:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x40f4:
    r16[bx] = r16[si];
    r16[si]++;
    r8[al] = memoryAGet(ds, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(ds, r16[bx] + 31090, r8[al]);
    if (r8[al])
        { pc = 0x40df; break; }
  case 0x4104:
    r16[si]--;
    if (!memoryAGet(ds, 0x7972))
        { pc = 0x410f; break; }
    { pc = 0x403e; break; }
  case 0x410f:
    memoryASet(ds, 0x7972, 0x5c);
    memoryASet(ds, 0x7973, 0x00);
    { pc = 0x403e; break; }
  case 0x411c:
    r16[ax] = r16[di];
  case 0x411e:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 6;
    return;
  }
}
function* sub_4135() // 01ed:2265 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x4a;
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    es = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x4149; break; }
    r16[ax] = 0xffff;
    { pc = 0x414f; break; }
  case 0x4149:
    push(r16[bx]);
    push(r16[ax]);
    yield* sub_3a4b();
    r16[ax] = pop();
  case 0x414f:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_4151() // 01ed:2281 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    flags.direction = 0;
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    push(ds);
    es = pop();
    r16[dx] = r16[di];
    r8[al] = 0;
    r16[cx] = 0xffff;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[si] = r16[di] - 1;
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[cx] = 0xffff;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[cx] = ~r16[cx];
    r16[di] -= r16[cx];
    r16[tx] = r16[di]; r16[di] = r16[si]; r16[si] = r16[tx];
    if (!(r16[si] & 0x0001))
        { pc = 0x417e; break; }
    movsb_ESDI_DSSI();
    r16[cx]--;
  case 0x417e:
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    if (!flags.carry)
        { pc = 0x4185; break; }
    movsb_ESDI_DSSI();
  case 0x4185:
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_418a() // 01ed:22ba +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    flags.direction = 0;
    r16[ax] = 0;
    r16[bx] = r16[ax];
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = r16[di];
    r8[al] = 0;
    r16[cx] = 0xffff;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[cx] = ~r16[cx];
    r16[di] = r16[si];
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    for (flags.zero = 1; r16[cx] != 0 && flags.zero; --r16[cx]) cmpsb_DSSI_ESDI();
    r8[al] = memoryAGet(ds, r16[si] - 1);
    r8[bl] = memoryAGet(ds, r16[di] - 1);
    r16[ax] -= r16[bx];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_41b9() // 01ed:22e9 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    flags.direction = 0;
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = r16[di];
    r8[al] = 0;
    r16[cx] = 0xffff;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[cx] = ~r16[cx];
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_41dd() // 01ed:230d +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0;
    flags.direction = 0;
    r16[cx] = 0xffff;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[tx] = r16[cx]; r16[cx] = r16[ax]; r16[ax] = r16[tx];
    r16[ax] = ~r16[ax];
    r16[ax]--;
    r16[di] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_41f7() // 01ed:2327 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    flags.direction = 0;
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = r16[di];
    r8[al] = 0;
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[cx] = r16[bx];
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[bx] -= r16[cx];
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[tx] = r16[bx]; r16[bx] = r16[cx]; r16[cx] = r16[tx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) stosb_ESDI(r8[al]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_4223() // 01ed:2353 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[ah] = 0x41;
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x4233; break; }
    r16[ax] = 0;
    { pc = 0x4237; break; }
  case 0x4233:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x4237:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_4710() // 01ed:2840 +stackDrop4
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 4);
    r16[ax]--;
    r8[dl] = memoryAGet(ds, 0x7350);
    r8[dh] = 0x00;
    imul16(r16[dx]);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7353);
    r16[dx] = pop();
    r16[ax] += r16[dx];
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx]--;
    r16[ax] += r16[dx];
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0x7355);
    r16[bp] = pop();
    sp += 6;
}
function* sub_4736() // 01ed:2866 +stackDrop10
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp--;
    sp--;
    push(r16[si]);
    push(r16[di]);
    r8[al] = memoryAGet(ds, 0x7352);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(ds);
    r16[cx] = memoryAGet16(ss, r16[bp] + 4);
    if (!r16[cx])
        { pc = 0x47a5; break; }
    r16[di] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    r16[si] = memoryAGet16(ss, r16[bp] + 6); ds = memoryAGet16(ss, r16[bp] + 8);
    flags.direction = 0;
    if (r16[si] >= r16[di])
        { pc = 0x4760; break; }
    r16[ax] = r16[cx];
    r16[ax]--;
    r16[ax] <<= 1;
    r16[si] += r16[ax];
    r16[di] += r16[ax];
    flags.direction = 1;
  case 0x4760:
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x476a; break; }
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    { pc = 0x47a5; break; }
  case 0x476a:
    r16[dx] = 0x03da;
    r16[ax] = es;
    r16[bx] = ds;
    if (r16[ax] == r16[bx])
        { pc = 0x4786; break; }
  case 0x4775:
    flags.interrupts = 0;
  case 0x4776:
    r8[al] = in8(r16[dx]);
    flags.carry = r8[al] & 1;
    r8[al] = ror8(r8[al], 0x01);
    if (flags.carry)
        { pc = 0x4776; break; }
  case 0x477b:
    r8[al] = in8(r16[dx]);
    flags.carry = r8[al] & 1;
    r8[al] = ror8(r8[al], 0x01);
    if (!flags.carry)
        { pc = 0x477b; break; }
    movsw_ESDI_DSSI();
    flags.interrupts = 1;
    if (--r16[cx])
        { pc = 0x4775; break; }
    { pc = 0x47a5; break; }
  case 0x4786:
    flags.interrupts = 0;
  case 0x4787:
    r8[al] = in8(r16[dx]);
    flags.carry = r8[al] & 1;
    r8[al] = ror8(r8[al], 0x01);
    if (flags.carry)
        { pc = 0x4787; break; }
  case 0x478c:
    r8[al] = in8(r16[dx]);
    flags.carry = r8[al] & 1;
    r8[al] = ror8(r8[al], 0x01);
    if (!flags.carry)
        { pc = 0x478c; break; }
    r16[ax] = lodsw_DSSI();
    flags.interrupts = 1;
    r16[bx] = r16[ax];
  case 0x4795:
    r8[al] = in8(r16[dx]);
    flags.carry = r8[al] & 1;
    r8[al] = ror8(r8[al], 0x01);
    if (flags.carry)
        { pc = 0x4795; break; }
  case 0x479a:
    r8[al] = in8(r16[dx]);
    flags.carry = r8[al] & 1;
    r8[al] = ror8(r8[al], 0x01);
    if (!flags.carry)
        { pc = 0x479a; break; }
    r16[ax] = r16[bx];
    stosw_ESDI(r16[ax]);
    flags.interrupts = 1;
    if (--r16[cx])
        { pc = 0x4786; break; }
  case 0x47a5:
    flags.direction = 0;
    ds = pop();
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 12;
    return;
  }
}
function* sub_47af() // 01ed:28df +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    if (!(memoryAGet16(ds, r16[bx] + 28888) & 0x0800))
        { pc = 0x47d4; break; }
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_3a99();
    sp += 0x0008;
  case 0x47d4:
    r8[ah] = 0x40;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x47f2; break; }
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 28888, memoryAGet16(ds, r16[bx] + 28888) | 0x1000);
    r16[ax] = pop();
    { pc = 0x47f6; break; }
  case 0x47f2:
    push(r16[ax]);
    yield* sub_3a4b();
  case 0x47f6:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_4b7b() // 01ed:2cab
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (r16[dx] == memoryAGet16(cs, 0x2c9f))
        { pc = 0x4bb9; break; }
    ds = r16[dx];
    ds = memoryAGet16(ds, 0x0002);
    if (!memoryAGet16(ds, 0x0002))
        { pc = 0x4b96; break; }
    memoryASet16(cs, 0x2ca1, ds);
    { pc = 0x4bce; break; }
  case 0x4b96:
    r16[ax] = ds;
    if (r16[ax] == memoryAGet16(cs, 0x2c9f))
        { pc = 0x4bb4; break; }
    r16[ax] = memoryAGet16(ds, 0x0008);
    memoryASet16(cs, 0x2ca1, r16[ax]);
    push(ds);
    r16[ax] = 0;
    push(r16[ax]);
    yield* sub_4c4e();
    ds = memoryAGet16(cs, 0x2ca5);
    { pc = 0x4bd7; break; }
  case 0x4bb4:
    r16[dx] = memoryAGet16(cs, 0x2c9f);
  case 0x4bb9:
    memoryASet16(cs, 0x2c9f, 0x0000);
    memoryASet16(cs, 0x2ca1, 0x0000);
    memoryASet16(cs, 0x2ca3, 0x0000);
  case 0x4bce:
    ds = memoryAGet16(cs, 0x2ca5);
    push(r16[dx]);
    r16[ax] = 0;
    push(r16[ax]);
  case 0x4bd7:
    yield* sub_2530();
    r16[ax] = pop();
    r16[ax] = pop();
    sp += 2;
    return;
  }
}
function* sub_4bdd() // 01ed:2d0d
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    ds = r16[dx];
    push(ds);
    es = memoryAGet16(ds, 0x0002);
    memoryASet16(ds, 0x0002, 0x0000);
    memoryASet16(ds, 0x0008, es);
    if (r16[dx] == memoryAGet16(cs, 0x2c9f))
        { pc = 0x4c23; break; }
    if (memoryAGet16(es, 0x0002))
        { pc = 0x4c23; break; }
    r16[ax] = memoryAGet16(ds, 0x0000);
    r16[bx] = pop();
    push(es);
    memoryASet16(es, 0x0000, memoryAGet16(es, 0x0000) + r16[ax]);
    r16[cx] = es;
    r16[dx] += r16[ax];
    es = r16[dx];
    if (memoryAGet16(es, 0x0002))
        { pc = 0x4c1c; break; }
    memoryASet16(es, 0x0008, r16[cx]);
    { pc = 0x4c26; break; }
  case 0x4c1c:
    memoryASet16(es, 0x0002, r16[cx]);
    { pc = 0x4c26; break; }
  case 0x4c23:
    yield* sub_4c77();
  case 0x4c26:
    es = pop();
    r16[ax] = es;
    r16[ax] += memoryAGet16(es, 0x0000);
    ds = r16[ax];
    if (!memoryAGet16(ds, 0x0002))
        { pc = 0x4c38; break; }
    sp += 2; return;
  case 0x4c38:
    r16[ax] = memoryAGet16(ds, 0x0000);
    memoryASet16(es, 0x0000, memoryAGet16(es, 0x0000) + r16[ax]);
    r16[ax] = es;
    r16[bx] = ds;
    r16[bx] += memoryAGet16(ds, 0x0000);
    es = r16[bx];
    memoryASet16(es, 0x0002, r16[ax]);
    r16[bx] = ds;
    if (r16[bx] == memoryAGet16(ds, 0x0006))
        { pc = 0x4c6f; break; }
    es = memoryAGet16(ds, 0x0006);
    ds = memoryAGet16(ds, 0x0004);
    memoryASet16(ds, 0x0006, es);
    memoryASet16(es, 0x0004, ds);
    memoryASet16(cs, 0x2ca3, ds);
    ds = r16[bx];
    sp += 2; return;
  case 0x4c6f:
    memoryASet16(cs, 0x2ca3, 0x0000);
    sp += 2;
    return;
  }
}
function* sub_4c4e() // 01ed:2d7e
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[bx] = ds;
    if (r16[bx] == memoryAGet16(ds, 0x0006))
        { pc = 0x4c6f; break; }
    es = memoryAGet16(ds, 0x0006);
    ds = memoryAGet16(ds, 0x0004);
    memoryASet16(ds, 0x0006, es);
    memoryASet16(es, 0x0004, ds);
    memoryASet16(cs, 0x2ca3, ds);
    ds = r16[bx];
    sp += 2; return;
  case 0x4c6f:
    memoryASet16(cs, 0x2ca3, 0x0000);
    sp += 2;
    return;
  }
}
function* sub_4c77() // 01ed:2da7
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[ax] = memoryAGet16(cs, 0x2ca3);
    if (!r16[ax])
        { pc = 0x4c9f; break; }
    r16[bx] = ss;
    flags.interrupts = 0;
    ss = r16[ax];
    es = memoryAGet16(ss, 0x0006);
    memoryASet16(ss, 0x0006, ds);
    memoryASet16(ds, 0x0004, ss);
    ss = r16[bx];
    flags.interrupts = 1;
    memoryASet16(es, 0x0004, ds);
    memoryASet16(ds, 0x0006, es);
    sp += 2; return;
  case 0x4c9f:
    memoryASet16(cs, 0x2ca3, ds);
    memoryASet16(ds, 0x0004, ds);
    memoryASet16(ds, 0x0006, ds);
    sp += 2;
    return;
  }
}
function* sub_4cad() // 01ed:2ddd +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(cs, 0x2ca5, ds);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    if (!r16[dx])
        { pc = 0x4ccd; break; }
    if (r16[dx] != memoryAGet16(cs, 0x2ca1))
        { pc = 0x4cca; break; }
    yield* sub_4b7b();
    { pc = 0x4ccd; break; }
  case 0x4cca:
    yield* sub_4bdd();
  case 0x4ccd:
    ds = memoryAGet16(cs, 0x2ca5);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_4cd6() // 01ed:2e06
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[ax]);
    ds = memoryAGet16(cs, 0x2ca5);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    yield* sub_256f();
    r16[bx] = pop();
    r16[bx] = pop();
    r16[ax] &= 0x000f;
    if (!r16[ax])
        { pc = 0x4cfd; break; }
    r16[dx] = 0x0010;
    r16[dx] -= r16[ax];
    r16[ax] = 0;
    ds = memoryAGet16(cs, 0x2ca5);
    push(r16[ax]);
    push(r16[dx]);
    yield* sub_256f();
    r16[bx] = pop();
    r16[bx] = pop();
  case 0x4cfd:
    r16[ax] = pop();
    push(r16[ax]);
    r16[bx] = 0;
    r8[bl] = r8[ah];
    r8[cl] = 0x04;
    r16[bx] >>= r8[cl];
    r16[ax] <<= r8[cl];
    ds = memoryAGet16(cs, 0x2ca5);
    push(r16[bx]);
    push(r16[ax]);
    yield* sub_256f();
    r16[bx] = pop();
    r16[bx] = pop();
    r16[bx] = pop();
    if (r16[ax] == 0xffff)
        { pc = 0x4d33; break; }
    memoryASet16(cs, 0x2c9f, r16[dx]);
    memoryASet16(cs, 0x2ca1, r16[dx]);
    ds = r16[dx];
    memoryASet16(ds, 0x0000, r16[bx]);
    memoryASet16(ds, 0x0002, r16[dx]);
    r16[ax] = 0x0004;
    sp += 2; return;
  case 0x4d33:
    r16[ax] = 0;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    sp += 2;
    return;
  }
}
function* sub_4d37() // 01ed:2e67
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[ax]);
    r16[bx] = 0;
    r8[bl] = r8[ah];
    r8[cl] = 0x04;
    r16[bx] >>= r8[cl];
    r16[ax] <<= r8[cl];
    ds = memoryAGet16(cs, 0x2ca5);
    push(r16[bx]);
    push(r16[ax]);
    yield* sub_256f();
    r16[bx] = pop();
    r16[bx] = pop();
    r16[bx] = pop();
    if (r16[ax] == 0xffff)
        { pc = 0x4d6c; break; }
    r16[cx] = memoryAGet16(cs, 0x2ca1);
    memoryASet16(cs, 0x2ca1, r16[dx]);
    ds = r16[dx];
    memoryASet16(ds, 0x0000, r16[bx]);
    memoryASet16(ds, 0x0002, r16[cx]);
    r16[ax] = 0x0004;
    sp += 2; return;
  case 0x4d6c:
    r16[ax] = 0;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    sp += 2;
    return;
  }
}
function* sub_4d70() // 01ed:2ea0
{
    sp -= 2;
    r16[bx] = r16[dx];
    memoryASet16(ds, 0x0000, memoryAGet16(ds, 0x0000) - r16[ax]);
    r16[dx] += memoryAGet16(ds, 0x0000);
    ds = r16[dx];
    memoryASet16(ds, 0x0000, r16[ax]);
    memoryASet16(ds, 0x0002, r16[bx]);
    r16[bx] = r16[dx];
    r16[bx] += memoryAGet16(ds, 0x0000);
    ds = r16[bx];
    memoryASet16(ds, 0x0002, r16[dx]);
    r16[ax] = 0x0004;
    sp += 2;
}
function* sub_4d93() // 01ed:2ec3 +far +stackDrop2
{
  var pc = 0;
  var temp_cf;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    push(r16[si]);
    push(r16[di]);
    memoryASet16(cs, 0x2ca5, ds);
    r16[cx] = r16[ax];
    r16[cx] |= r16[dx];
    if (!r16[cx])
        { pc = 0x4e07; break; }
    flags.carry = r16[ax] + 0x0013 >= 0x10000;
    r16[ax] += 0x0013;
    temp_cf = flags.carry;
    temp_cf = (r16[dx] + 0x0000) + flags.carry >= 0x10000;
    r16[dx] += (0x0000 + flags.carry);
    flags.carry = temp_cf;
    if (flags.carry)
        { pc = 0x4df2; break; }
    if (r16[dx] & 0xfff0)
        { pc = 0x4df2; break; }
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    r16[dx] <<= r8[cl];
    r8[ah] |= r8[dl];
    r16[dx] = memoryAGet16(cs, 0x2c9f);
    if (!r16[dx])
        { pc = 0x4de8; break; }
    r16[dx] = memoryAGet16(cs, 0x2ca3);
    if (!r16[dx])
        { pc = 0x4de3; break; }
    r16[bx] = r16[dx];
  case 0x4dd3:
    ds = r16[dx];
    if (memoryAGet16(ds, 0x0000) >= r16[ax])
        { pc = 0x4df7; break; }
    r16[dx] = memoryAGet16(ds, 0x0006);
    if (r16[dx] != r16[bx])
        { pc = 0x4dd3; break; }
  case 0x4de3:
    yield* sub_4d37();
    { pc = 0x4e07; break; }
  case 0x4de8:
    yield* sub_4cd6();
    { pc = 0x4e07; break; }
  case 0x4ded:
    yield* sub_4d70();
    { pc = 0x4e07; break; }
  case 0x4df2:
    r16[ax] = 0;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    { pc = 0x4e07; break; }
  case 0x4df7:
    if (memoryAGet16(ds, 0x0000) > r16[ax])
        { pc = 0x4ded; break; }
    yield* sub_4c4e();
    r16[bx] = memoryAGet16(ds, 0x0008);
    memoryASet16(ds, 0x0002, r16[bx]);
    r16[ax] = 0x0004;
  case 0x4e07:
    ds = memoryAGet16(cs, 0x2ca5);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_4f5a() // 01ed:308a +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    r16[tx] = r16[si]; r16[si] = r16[ax]; r16[ax] = r16[tx];
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    if (!r16[ax])
        { pc = 0x4f63; break; }
    mul16(r16[bx]);
  case 0x4f63:
    if (!r16[cx])
        { pc = 0x4f6a; break; }
    r16[tx] = r16[cx]; r16[cx] = r16[ax]; r16[ax] = r16[tx];
    mul16(r16[si]);
    r16[ax] += r16[cx];
  case 0x4f6a:
    r16[tx] = r16[si]; r16[si] = r16[ax]; r16[ax] = r16[tx];
    mul16(r16[bx]);
    r16[dx] += r16[si];
    r16[si] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_4f95() // 01ed:30c5 +far +stackDrop10
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[cx] = 0;
    { pc = 0x4faf; break; }
    // gap 22 bytes
  case 0x4faf:
    push(r16[bp]);
    push(r16[si]);
    push(r16[di]);
    r16[bp] = sp;
    r16[di] = r16[cx];
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
    r16[bx] = memoryAGet16(ss, r16[bp] + 14);
    r16[cx] = memoryAGet16(ss, r16[bp] + 16);
    if (r16[cx])
        { pc = 0x4fce; break; }
    if (!r16[dx])
        { pc = 0x5033; break; }
    if (!r16[bx])
        { pc = 0x5033; break; }
  case 0x4fce:
    if (r16[di] & 0x0001)
        { pc = 0x4ff0; break; }
    if (r16s[dx] >= 0)
        { pc = 0x4fe2; break; }
    r16[dx] = -r16[dx];
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[dx] -= (0x0000 + flags.carry);
    r16[di] |= 0x000c;
  case 0x4fe2:
    if (r16s[cx] >= 0)
        { pc = 0x4ff0; break; }
    r16[cx] = -r16[cx];
    flags.carry = r16[bx] != 0;
    r16[bx] = -r16[bx];
    r16[cx] -= (0x0000 + flags.carry);
    r16[di] ^= 0x0004;
  case 0x4ff0:
    r16[bp] = r16[cx];
    r16[cx] = 0x0020;
    push(r16[di]);
    r16[di] = 0;
    r16[si] = 0;
  case 0x4ffa:
    flags.carry = !!(r16[ax] & 0x8000);
    r16[ax] <<= 1;
    r16[dx] = rcl16(r16[dx], 0x0001);
    r16[si] = rcl16(r16[si], 0x0001);
    r16[di] = rcl16(r16[di], 0x0001);
    if (r16[di] < r16[bp])
        { pc = 0x5011; break; }
    if (r16[di] > r16[bp])
        { pc = 0x500c; break; }
    if (r16[si] < r16[bx])
        { pc = 0x5011; break; }
  case 0x500c:
    flags.carry = r16[si] < r16[bx];
    r16[si] -= r16[bx];
    r16[di] -= (r16[bp] + flags.carry);
    r16[ax]++;
  case 0x5011:
    if (--r16[cx])
        { pc = 0x4ffa; break; }
    r16[bx] = pop();
    if (!(r16[bx] & 0x0002))
        { pc = 0x5020; break; }
    r16[ax] = r16[si];
    r16[dx] = r16[di];
    r16[bx] >>= 1;
  case 0x5020:
    if (!(r16[bx] & 0x0004))
        { pc = 0x502d; break; }
    r16[dx] = -r16[dx];
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[dx] -= (0x0000 + flags.carry);
  case 0x502d:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); sp += 8; return;
  case 0x5033:
    div16(r16[bx]);
    if (!(r16[di] & 0x0002))
        { pc = 0x503c; break; }
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
  case 0x503c:
    r16[dx] = 0;
    { pc = 0x502d; break; }
    return;
  }
}
function* sub_5043() // 01ed:3173 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (r8[cl] >= 0x10)
        { pc = 0x5058; break; }
    r16[bx] = r16[ax];
    r16[ax] <<= r8[cl];
    r16[dx] <<= r8[cl];
    r8[cl] = -r8[cl];
    r8[cl] += 0x10;
    r16[bx] >>= r8[cl];
    r16[dx] |= r16[bx];
    sp += 2; cs = pop(); return;
  case 0x5058:
    r8[cl] -= 0x10;
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[ax] = 0;
    r16[dx] <<= r8[cl];
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5064() // 01ed:3194 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (r8[cl] >= 0x10)
        { pc = 0x5079; break; }
    r16[bx] = r16[dx];
    r16[ax] >>= r8[cl];
    r16[dx] = sar16(r16[dx], r8[cl]);
    r8[cl] = -r8[cl];
    r8[cl] += 0x10;
    r16[bx] <<= r8[cl];
    r16[ax] |= r16[bx];
    sp += 2; cs = pop(); return;
  case 0x5079:
    r8[cl] -= 0x10;
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] = sar16(r16[ax], r8[cl]);
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5084() // 01ed:31b4 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (r8[cl] >= 0x10)
        { pc = 0x5099; break; }
    r16[bx] = r16[dx];
    r16[ax] >>= r8[cl];
    r16[dx] >>= r8[cl];
    r8[cl] = -r8[cl];
    r8[cl] += 0x10;
    r16[bx] <<= r8[cl];
    r16[ax] |= r16[bx];
    sp += 2; cs = pop(); return;
  case 0x5099:
    r8[cl] -= 0x10;
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[dx] = 0;
    r16[ax] >>= r8[cl];
    sp += 2; cs = pop();
    return;
  }
}
function* sub_50a5() // 01ed:31d5 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    es = r16[dx];
    r16[tx] = r16[bx]; r16[bx] = r16[ax]; r16[ax] = r16[tx];
    r16[dx] = memoryAGet16(es, r16[bx] + 2);
    push(r16[bx]);
    r16[bx] = memoryAGet16(es, r16[bx]);
    if (r16s[cx] >= 0)
        { pc = 0x50c0; break; }
    r16[ax] = ~r16[ax];
    r16[cx] = ~r16[cx];
    flags.carry = r16[ax] + 0x0001 >= 0x10000;
    r16[ax]++;
    r16[cx] += (0x0000 + flags.carry);
    { pc = 0x5104; break; }
  case 0x50c0:
    flags.carry = r16[bx] + r16[ax] >= 0x10000;
    r16[bx] += r16[ax];
    if (!flags.carry)
        { pc = 0x50c8; break; }
    r16[dx] += 0x1000;
  case 0x50c8:
    r8[ah] = r8[cl];
    r8[cl] = 0x04;
    r8[ah] <<= r8[cl];
    r8[al] = 0;
    r16[dx] += r16[ax];
    r8[ch] = r8[bl];
    r16[bx] >>= r8[cl];
    r16[dx] += r16[bx];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    r16[bx] = pop();
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(es, r16[bx] + 2, r16[dx]);
    sp += 2; cs = pop(); return;
    // gap 30 bytes
  case 0x5104:
    flags.carry = r16[bx] < r16[ax];
    r16[bx] -= r16[ax];
    if (!flags.carry)
        { pc = 0x510c; break; }
    r16[dx] -= 0x1000;
  case 0x510c:
    r8[ah] = r8[cl];
    r8[cl] = 0x04;
    r8[ah] <<= r8[cl];
    r8[al] = 0;
    r16[dx] -= r16[ax];
    r8[ch] = r8[bl];
    r16[bx] >>= r8[cl];
    r16[dx] += r16[bx];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    r16[bx] = pop();
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(es, r16[bx] + 2, r16[dx]);
    sp += 2; cs = pop();
    return;
  }
}
function* sub_50e9() // 01ed:3219 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    { pc = 0x50e9; break; }
  case 0x50c0:
    flags.carry = r16[bx] + r16[ax] >= 0x10000;
    r16[bx] += r16[ax];
    if (!flags.carry)
        { pc = 0x50c8; break; }
    r16[dx] += 0x1000;
  case 0x50c8:
    r8[ah] = r8[cl];
    r8[cl] = 0x04;
    r8[ah] <<= r8[cl];
    r8[al] = 0;
    r16[dx] += r16[ax];
    r8[ch] = r8[bl];
    r16[bx] >>= r8[cl];
    r16[dx] += r16[bx];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    r16[bx] = pop();
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(es, r16[bx] + 2, r16[dx]);
    sp += 2; cs = pop(); return;
    // gap 3 bytes
  case 0x50e9:
    es = r16[dx];
    r16[tx] = r16[bx]; r16[bx] = r16[ax]; r16[ax] = r16[tx];
    r16[dx] = memoryAGet16(es, r16[bx] + 2);
    push(r16[bx]);
    r16[bx] = memoryAGet16(es, r16[bx]);
    if (r16s[cx] >= 0)
        { pc = 0x5104; break; }
    r16[ax] = ~r16[ax];
    r16[cx] = ~r16[cx];
    flags.carry = r16[ax] + 0x0001 >= 0x10000;
    r16[ax]++;
    r16[cx] += (0x0000 + flags.carry);
    { pc = 0x50c0; break; }
  case 0x5104:
    flags.carry = r16[bx] < r16[ax];
    r16[bx] -= r16[ax];
    if (!flags.carry)
        { pc = 0x510c; break; }
    r16[dx] -= 0x1000;
  case 0x510c:
    r8[ah] = r8[cl];
    r8[cl] = 0x04;
    r8[ah] <<= r8[cl];
    r8[al] = 0;
    r16[dx] -= r16[ax];
    r8[ch] = r8[bl];
    r16[bx] >>= r8[cl];
    r16[dx] += r16[bx];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    r16[bx] = pop();
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(es, r16[bx] + 2, r16[dx]);
    sp += 2; cs = pop();
    return;
  }
}
function* sub_512a() // 01ed:325a +stackDrop2 +nearAsFar
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    es = pop();
    push(cs);
    push(es);
    if (r16s[cx] >= 0)
        { pc = 0x513d; break; }
    r16[bx] = ~r16[bx];
    r16[cx] = ~r16[cx];
    flags.carry = r16[bx] + 0x0001 >= 0x10000;
    r16[bx]++;
    r16[cx] += (0x0000 + flags.carry);
    { pc = 0x516c; break; }
  case 0x513d:
    flags.carry = r16[ax] + r16[bx] >= 0x10000;
    r16[ax] += r16[bx];
    if (!flags.carry)
        { pc = 0x5145; break; }
    r16[dx] += 0x1000;
  case 0x5145:
    r8[ch] = r8[cl];
    r8[cl] = 0x04;
    r8[ch] <<= r8[cl];
    r8[dh] += r8[ch];
    r8[ch] = r8[al];
    r16[ax] >>= r8[cl];
    r16[dx] += r16[ax];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    sp += 2; cs = pop(); return;
    // gap 19 bytes
  case 0x516c:
    flags.carry = r16[ax] < r16[bx];
    r16[ax] -= r16[bx];
    if (!flags.carry)
        { pc = 0x5174; break; }
    r16[dx] -= 0x1000;
  case 0x5174:
    r8[bh] = r8[cl];
    r8[cl] = 0x04;
    r8[bh] <<= r8[cl];
    r8[bl] = 0;
    r16[dx] -= r16[bx];
    r8[ch] = r8[al];
    r16[ax] >>= r8[cl];
    r16[dx] += r16[ax];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    sp += 2; cs = pop();
    return;
  }
}
function* sub_512d() // 01ed:325d +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (r16s[cx] >= 0)
        { pc = 0x513d; break; }
    r16[bx] = ~r16[bx];
    r16[cx] = ~r16[cx];
    flags.carry = r16[bx] + 0x0001 >= 0x10000;
    r16[bx]++;
    r16[cx] += (0x0000 + flags.carry);
    { pc = 0x516c; break; }
  case 0x513d:
    flags.carry = r16[ax] + r16[bx] >= 0x10000;
    r16[ax] += r16[bx];
    if (!flags.carry)
        { pc = 0x5145; break; }
    r16[dx] += 0x1000;
  case 0x5145:
    r8[ch] = r8[cl];
    r8[cl] = 0x04;
    r8[ch] <<= r8[cl];
    r8[dh] += r8[ch];
    r8[ch] = r8[al];
    r16[ax] >>= r8[cl];
    r16[dx] += r16[ax];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    sp += 2; cs = pop(); return;
    // gap 19 bytes
  case 0x516c:
    flags.carry = r16[ax] < r16[bx];
    r16[ax] -= r16[bx];
    if (!flags.carry)
        { pc = 0x5174; break; }
    r16[dx] -= 0x1000;
  case 0x5174:
    r8[bh] = r8[cl];
    r8[cl] = 0x04;
    r8[bh] <<= r8[cl];
    r8[bl] = 0;
    r16[dx] -= r16[bx];
    r8[ch] = r8[al];
    r16[ax] >>= r8[cl];
    r16[dx] += r16[ax];
    r8[al] = r8[ch];
    r16[ax] &= 0x000f;
    sp += 2; cs = pop();
    return;
  }
}
function* sub_518a() // 01ed:32ba +stackDrop2 +nearAsFar
{
    sp -= 2;
    es = pop();
    push(cs);
    push(es);
    push(r16[di]);
    r16[di] = r16[cx];
    r8[ch] = r8[dh];
    r8[cl] = 0x04;
    r16[dx] <<= r8[cl];
    r8[ch] >>= r8[cl];
    flags.carry = r16[dx] + r16[ax] >= 0x10000;
    r16[dx] += r16[ax];
    r8[ch] += (0x00 + flags.carry);
    r16[ax] = r16[di];
    r16[di] <<= r8[cl];
    r8[ah] >>= r8[cl];
    flags.carry = r16[bx] + r16[di] >= 0x10000;
    r16[bx] += r16[di];
    r8[ah] += (0x00 + flags.carry);
    flags.carry = r16[dx] < r16[bx];
    r16[dx] -= r16[bx];
    r8[ch] -= (r8[ah] + flags.carry);
    r8[al] = r8[ch];
    cbw();
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    r16[di] = pop();
    sp += 2; cs = pop();
}
function* sub_51b5() // 01ed:32e5 +far +stackDrop10
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    push(ds);
    r16[si] = memoryAGet16(ss, r16[bp] + 6); ds = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    flags.direction = 0;
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    r16[cx] += (r16[cx] + flags.carry);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    ds = pop();
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); sp += 8;
}
function* sub_51d7() // 01ed:3307 +far +stackDrop2
{
    sp -= 2;
    r16[bx] = pop();
    stop("stack_below");
    es = pop();
    sp -= r16[cx];
    push(es);
    push(r16[bx]);
    push(r16[di]);
    push(ds);
    r16[di] = sp;
    r16[di] += 0x0008;
    r16[bx] = ss;
    es = r16[bx];
    ds = r16[dx];
    r16[tx] = r16[si]; r16[si] = r16[ax]; r16[ax] = r16[tx];
    flags.direction = 0;
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    r16[cx] += (r16[cx] + flags.carry);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[tx] = r16[si]; r16[si] = r16[ax]; r16[ax] = r16[tx];
    ds = pop();
    r16[di] = pop();
    stop("stack_unbalanced");
    sp += 2; cs = pop();
}
function* sub_51f8() // 01ed:3328 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    push(r16[di]);
    r16[si] = sp;
    r16[bx] = memoryAGet16(ds, r16[si] + 8);
    flags.carry = r16[bx] < 0x0004;
    r16[bx] -= 0x0004;
    if (flags.carry)
        { pc = 0x5212; break; }
    if (r16[bx] == memoryAGet16(ds, 0x7438))
        { pc = 0x520f; break; }
    yield* sub_524f();
    { pc = 0x5212; break; }
  case 0x520f:
    yield* sub_5215();
  case 0x5212:
    r16[di] = pop();
    r16[si] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5215() // 01ed:3345
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (memoryAGet16(ds, 0x7436) == r16[bx])
        { pc = 0x523e; break; }
    r16[si] = memoryAGet16(ds, r16[bx] + 2);
    if (!(memoryAGet(ds, r16[si]) & 0x01))
        { pc = 0x5229; break; }
    memoryASet16(ds, 0x7438, r16[si]);
    { pc = 0x5249; break; }
  case 0x5229:
    if (r16[si] == memoryAGet16(ds, 0x7436))
        { pc = 0x523c; break; }
    r16[bx] = r16[si];
    yield* sub_5288();
    r16[ax] = memoryAGet16(ds, r16[bx] + 2);
    memoryASet16(ds, 0x7438, r16[ax]);
    { pc = 0x5249; break; }
  case 0x523c:
    r16[bx] = r16[si];
  case 0x523e:
    r16[ax] = 0;
    memoryASet16(ds, 0x7436, r16[ax]);
    memoryASet16(ds, 0x7438, r16[ax]);
    memoryASet16(ds, 0x743a, r16[ax]);
  case 0x5249:
    push(r16[bx]);
    yield* sub_3551();
    r16[bx] = pop();
    sp += 2;
    return;
  }
}
function* sub_524f() // 01ed:337f
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    memoryASet16(ds, r16[bx], memoryAGet16(ds, r16[bx]) - 1);
    if (r16[bx] == memoryAGet16(ds, 0x7436))
        { pc = 0x526f; break; }
    r16[si] = memoryAGet16(ds, r16[bx] + 2);
    r16[ax] = memoryAGet16(ds, r16[si]);
    if (r8[al] & 0x01)
        { pc = 0x526f; break; }
    r16[ax] += memoryAGet16(ds, r16[bx]);
    memoryASet16(ds, r16[si], r16[ax]);
    r16[di] = memoryAGet16(ds, r16[bx]);
    r16[di] += r16[bx];
    memoryASet16(ds, r16[di] + 2, r16[si]);
    r16[bx] = r16[si];
    { pc = 0x5272; break; }
  case 0x526f:
    yield* sub_52a4();
  case 0x5272:
    r16[di] = memoryAGet16(ds, r16[bx]);
    r16[di] += r16[bx];
    r16[ax] = memoryAGet16(ds, r16[di]);
    if (!(r8[al] & 0x01))
        { pc = 0x527d; break; }
    sp += 2; return;
  case 0x527d:
    memoryASet16(ds, r16[bx], memoryAGet16(ds, r16[bx]) + r16[ax]);
    r16[si] = r16[di];
    r16[si] += r16[ax];
    memoryASet16(ds, r16[si] + 2, r16[bx]);
    r16[bx] = r16[di];
    r16[di] = memoryAGet16(ds, r16[bx] + 6);
    if (r16[bx] == r16[di])
        { pc = 0x529d; break; }
    memoryASet16(ds, 0x743a, r16[di]);
    r16[si] = memoryAGet16(ds, r16[bx] + 4);
    memoryASet16(ds, r16[di] + 4, r16[si]);
    memoryASet16(ds, r16[si] + 6, r16[di]);
    sp += 2; return;
  case 0x529d:
    memoryASet16(ds, 0x743a, 0x0000);
    sp += 2;
    return;
  }
}
function* sub_5288() // 01ed:33b8
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[di] = memoryAGet16(ds, r16[bx] + 6);
    if (r16[bx] == r16[di])
        { pc = 0x529d; break; }
    memoryASet16(ds, 0x743a, r16[di]);
    r16[si] = memoryAGet16(ds, r16[bx] + 4);
    memoryASet16(ds, r16[di] + 4, r16[si]);
    memoryASet16(ds, r16[si] + 6, r16[di]);
    sp += 2; return;
  case 0x529d:
    memoryASet16(ds, 0x743a, 0x0000);
    sp += 2;
    return;
  }
}
function* sub_52a4() // 01ed:33d4
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[si] = memoryAGet16(ds, 0x743a);
    if (!r16[si])
        { pc = 0x52bc; break; }
    r16[di] = memoryAGet16(ds, r16[si] + 6);
    memoryASet16(ds, r16[si] + 6, r16[bx]);
    memoryASet16(ds, r16[di] + 4, r16[bx]);
    memoryASet16(ds, r16[bx] + 6, r16[di]);
    memoryASet16(ds, r16[bx] + 4, r16[si]);
    sp += 2; return;
  case 0x52bc:
    memoryASet16(ds, 0x743a, r16[bx]);
    memoryASet16(ds, r16[bx] + 4, r16[bx]);
    memoryASet16(ds, r16[bx] + 6, r16[bx]);
    sp += 2;
    return;
  }
}
function* sub_52c7() // 01ed:33f7 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    push(r16[di]);
    r16[si] = sp;
    r16[ax] = memoryAGet16(ds, r16[si] + 8);
    if (!r16[ax])
        { pc = 0x5324; break; }
    flags.carry = r16[ax] + 0x0005 >= 0x10000;
    r16[ax] += 0x0005;
    if (flags.carry)
        { pc = 0x530d; break; }
    r16[ax] &= 0xfffe;
    if (r16[ax] >= 0x0008)
        { pc = 0x52e2; break; }
    r16[ax] = 0x0008;
  case 0x52e2:
    if (!memoryAGet16(ds, 0x7436))
        { pc = 0x5308; break; }
    r16[bx] = memoryAGet16(ds, 0x743a);
    if (!r16[bx])
        { pc = 0x52fe; break; }
    r16[dx] = r16[bx];
  case 0x52f3:
    if (memoryAGet16(ds, r16[bx]) >= r16[ax])
        { pc = 0x5311; break; }
    r16[bx] = memoryAGet16(ds, r16[bx] + 6);
    if (r16[bx] != r16[dx])
        { pc = 0x52f3; break; }
  case 0x52fe:
    yield* sub_5367();
    { pc = 0x5324; break; }
  case 0x5303:
    yield* sub_5390();
    { pc = 0x5324; break; }
  case 0x5308:
    yield* sub_5327();
    { pc = 0x5324; break; }
  case 0x530d:
    r16[ax] = 0;
    { pc = 0x5324; break; }
  case 0x5311:
    r16[si] = r16[ax];
    r16[si] += 0x0008;
    if (memoryAGet16(ds, r16[bx]) >= r16[si])
        { pc = 0x5303; break; }
    yield* sub_5288();
    memoryASet16(ds, r16[bx], memoryAGet16(ds, r16[bx]) + 1);
    r16[ax] = r16[bx];
    r16[ax] += 0x0004;
  case 0x5324:
    r16[di] = pop();
    r16[si] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5327() // 01ed:3457
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    yield* sub_3573();
    r16[bx] = pop();
    r16[bx] = pop();
    r16[ax] &= 0x0001;
    if (!r16[ax])
        { pc = 0x533f; break; }
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    yield* sub_3573();
    r16[bx] = pop();
    r16[bx] = pop();
  case 0x533f:
    r16[ax] = pop();
    push(r16[ax]);
    r16[bx] = 0;
    push(r16[bx]);
    push(r16[ax]);
    yield* sub_3573();
    r16[bx] = pop();
    r16[bx] = pop();
    if (r16[ax] == 0xffff)
        { pc = 0x5363; break; }
    r16[bx] = r16[ax];
    memoryASet16(ds, 0x7436, r16[bx]);
    memoryASet16(ds, 0x7438, r16[bx]);
    r16[ax] = pop();
    r16[ax]++;
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] += 0x0004;
    r16[ax] = r16[bx];
    sp += 2; return;
  case 0x5363:
    r16[bx] = pop();
    r16[ax] = 0;
    sp += 2;
    return;
  }
}
function* sub_5367() // 01ed:3497
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[ax]);
    r16[bx] = 0;
    push(r16[bx]);
    push(r16[ax]);
    yield* sub_3573();
    r16[bx] = pop();
    r16[bx] = pop();
    if (r16[ax] == 0xffff)
        { pc = 0x538c; break; }
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x7438);
    memoryASet16(ds, r16[bx] + 2, r16[ax]);
    memoryASet16(ds, 0x7438, r16[bx]);
    r16[ax] = pop();
    r16[ax]++;
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] += 0x0004;
    r16[ax] = r16[bx];
    sp += 2; return;
  case 0x538c:
    r16[ax] = pop();
    r16[ax] = 0;
    sp += 2;
    return;
  }
}
function* sub_5390() // 01ed:34c0
{
    sp -= 2;
    memoryASet16(ds, r16[bx], memoryAGet16(ds, r16[bx]) - r16[ax]);
    r16[si] = r16[bx];
    r16[si] += memoryAGet16(ds, r16[bx]);
    r16[di] = r16[si];
    r16[di] += r16[ax];
    r16[ax]++;
    memoryASet16(ds, r16[si], r16[ax]);
    memoryASet16(ds, r16[si] + 2, r16[bx]);
    memoryASet16(ds, r16[di] + 2, r16[si]);
    r16[si] += 0x0004;
    r16[ax] = r16[si];
    sp += 2;
}
function* sub_5473() // 01ed:35a3
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    r16[tx] = r16[si]; r16[si] = r16[ax]; r16[ax] = r16[tx];
    r16[tx] = r16[dx]; r16[dx] = r16[ax]; r16[ax] = r16[tx];
    if (!r16[ax])
        { pc = 0x547c; break; }
    mul16(r16[bx]);
  case 0x547c:
    if (!r16[cx])
        { pc = 0x5483; break; }
    r16[tx] = r16[cx]; r16[cx] = r16[ax]; r16[ax] = r16[tx];
    mul16(r16[si]);
    r16[ax] += r16[cx];
  case 0x5483:
    r16[tx] = r16[si]; r16[si] = r16[ax]; r16[ax] = r16[tx];
    mul16(r16[bx]);
    r16[dx] += r16[si];
    r16[si] = pop();
    sp += 2;
    return;
  }
}
function* sub_548a() // 01ed:35ba +returnCarry +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[cx]);
    r8[ch] = r8[al];
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    r16[dx] += r16[ax];
    r8[al] = r8[ch];
    r8[ah] = r8[bl];
    r16[bx] >>= r8[cl];
    r16[cx] = pop();
    r16[cx] += r16[bx];
    r8[bl] = r8[ah];
    r16[ax] &= 0x000f;
    r16[bx] &= 0x000f;
    flags.carry = r16[dx] < r16[cx];
    flags.zero = r16[dx] == r16[cx];
    if (!flags.zero)
        { pc = 0x54aa; break; }
    flags.carry = r16[ax] < r16[bx];
    flags.zero = r16[ax] == r16[bx];
  case 0x54aa:
    sp += 2; return;
    return;
  }
}
function* sub_54b1() // 01ed:35e1 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    { pc = 0x54b1; break; }
  case 0x20f6:
    r16[cx] = 0x001e;
    stop("stack_below");
    r16[dx] = 0x0056;
    ds = memoryAGet16(cs, 0x023c);
    yield* sub_20ee();
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs);
    yield* sub_2003();
    memoryASet(ds, r16[bx] + r16[si], memoryAGet(ds, r16[bx] + r16[si]) + r8[al]);
    r8[al] += memoryAGet(ds, r16[bx] + r16[si] + 35669);
    r8[al] = in8(r16[dx]);
    if (memoryAGet16(ds, 0x6e86) != 0x0020)
        { pc = 0x211f; break; }
    r16[ax] = 0x0001;
    { pc = 0x213b; break; }
  case 0x211f:
    r16[bx] = memoryAGet16(ds, 0x6e86);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx] + 30950, r16[ax]);
    memoryASet16(ds, r16[bx] + 30948, r16[dx]);
    memoryASet16(ds, 0x6e86, memoryAGet16(ds, 0x6e86) + 1);
    r16[ax] = 0;
  case 0x213b:
    r16[bp] = pop();
    stop("stack_unbalanced");
    sp += 2; cs = pop(); return;
    // gap 13172 bytes
  case 0x54b1:
    memoryASet16(ds, 0x7440, pop());
    stop("stack_below");
    memoryASet16(ds, 0x7442, pop());
    memoryASet16(ds, 0x7444, pop());
    memoryASet16(cs, 0x35df, ds);
    memoryASet16(ds, 0x7446, r16[si]);
    memoryASet16(ds, 0x7448, r16[di]);
    flags.direction = 0;
    es = memoryAGet16(ds, 0x0090);
    r16[si] = 0x0080;
    r8[ah] = 0;
    r8[al] = lodsb_ESSI();
    r16[ax]++;
    r16[bp] = es;
    r16[tx] = r16[si]; r16[si] = r16[dx]; r16[dx] = r16[tx];
    r16[tx] = r16[bx]; r16[bx] = r16[ax]; r16[ax] = r16[tx];
    r16[si] = memoryAGet16(ds, 0x008a);
    r16[si]++;
    r16[si]++;
    r16[cx] = 0x0001;
    if (memoryAGet(ds, 0x0092) < 0x03)
        { pc = 0x54fd; break; }
    es = memoryAGet16(ds, 0x008c);
    r16[di] = r16[si];
    r8[cl] = 0x7f;
    r8[al] = 0;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    if (!r16[cx])
        { pc = 0x5568; break; }
    r8[cl] ^= 0x7f;
  case 0x54fd:
    push(r16[ax]);
    r16[ax] = r16[cx];
    r16[ax] += r16[bx];
    r16[ax]++;
    r16[ax] &= 0xfffe;
    r16[di] = sp;
    flags.carry = r16[di] < r16[ax];
    r16[di] -= r16[ax];
    if (flags.carry)
        { pc = 0x5568; break; }
    sp = r16[di];
    push(es);
    ds = pop();
    push(ss);
    es = pop();
    push(r16[cx]);
    r16[cx]--;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r8[al] = 0;
    stosb_ESDI(r8[al]);
    ds = r16[bp];
    r16[tx] = r16[dx]; r16[dx] = r16[si]; r16[si] = r16[tx];
    r16[tx] = r16[cx]; r16[cx] = r16[bx]; r16[bx] = r16[tx];
    r16[ax] = r16[bx];
    r16[dx] = r16[ax];
    r16[bx]++;
  case 0x5524:
    yield* sub_5540();
    if (!flags.carry && !flags.zero)
        { pc = 0x5530; break; }
  case 0x5529:
    if (flags.carry)
        { pc = 0x556d; break; }
    yield* sub_5540();
    if (!flags.carry && !flags.zero)
        { pc = 0x5529; break; }
  case 0x5530:
    if (r8[al] == 0x20)
        { pc = 0x553c; break; }
    if (r8[al] == 0x0d)
        { pc = 0x553c; break; }
    if (r8[al] != 0x09)
        { pc = 0x5524; break; }
  case 0x553c:
    r8[al] = 0;
    { pc = 0x5524; break; }
    // gap 40 bytes
  case 0x5568:
    stop("stack_below");
    { pc = 0x20f6; break; }
  case 0x556d:
    r16[cx] = pop();
    r16[cx] += r16[dx];
    ds = memoryAGet16(cs, 0x35df);
    memoryASet16(ds, 0x743c, r16[bx]);
    r16[bx]++;
    r16[bx] += r16[bx];
    r16[si] = sp;
    r16[bp] = sp;
    flags.carry = r16[bp] < r16[bx];
    r16[bp] -= r16[bx];
    if (flags.carry)
        { pc = 0x5568; break; }
    sp = r16[bp];
    memoryASet16(ds, 0x743e, r16[bp]);
  case 0x558a:
    if (!r16[cx])
        { pc = 0x559a; break; }
    memoryASet16(ss, r16[bp], r16[si]);
    r16[bp] += 0x0002;
  case 0x5592:
    r8[al] = lodsb_SSSI();
    if (--r16[cx] && !r8[al])
        { pc = 0x5592; break; }
    if (!r8[al])
        { pc = 0x558a; break; }
  case 0x559a:
    r16[ax] = 0;
    memoryASet16(ss, r16[bp], r16[ax]);
    ds = memoryAGet16(cs, 0x35df);
    r16[si] = memoryAGet16(ds, 0x7446);
    r16[di] = memoryAGet16(ds, 0x7448);
    push(memoryAGet16(ds, 0x7444));
    push(memoryAGet16(ds, 0x7442));
    r16[ax] = memoryAGet16(ds, 0x743c);
    memoryASet16(ds, 0x0084, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x743e);
    memoryASet16(ds, 0x0086, r16[ax]);
    return;
  }
}
function* sub_5540() // 01ed:3670 +returnCarry +returnZero
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (!r16[ax])
        { pc = 0x554b; break; }
    r16[dx]++;
    stosb_ESDI(r8[al]);
    if (r8[al])
        { pc = 0x554b; break; }
    r16[bx]++;
  case 0x554b:
    r8[tl] = r8[al]; r8[al] = r8[ah]; r8[ah] = r8[tl];
    flags.zero = r8[al] == 0;
    r8[al] = 0;
    flags.carry = 1;
    if (!r16[cx])
        { pc = 0x5567; break; }
    r8[al] = lodsb_DSSI();
    r16[cx]--;
    flags.carry = r8[al] < 0x22;
    flags.zero = r8[al] == 0;
    r8[al] -= 0x22;
    if (flags.zero)
        { pc = 0x5567; break; }
    r8[al] += 0x22;
    if (r8[al] != 0x5c)
        { pc = 0x5565; break; }
    if (memoryAGet(ds, r16[si]) != 0x22)
        { pc = 0x5565; break; }
    r8[al] = lodsb_DSSI();
    r16[cx]--;
  case 0x5565:
    flags.carry = false;
    flags.zero = r16[si] == 0;
  case 0x5567:
    sp += 2; return;
    return;
  }
}
function* sub_55c4() // 01ed:36f4 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    { pc = 0x55c4; break; }
  case 0x20f6:
    r16[cx] = 0x001e;
    r16[dx] = 0x0056;
    ds = memoryAGet16(cs, 0x023c);
    yield* sub_20ee();
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs);
    yield* sub_2003();
    memoryASet(ds, r16[bx] + r16[si], memoryAGet(ds, r16[bx] + r16[si]) + r8[al]);
    r8[al] += memoryAGet(ds, r16[bx] + r16[si] + 35669);
    r8[al] = in8(r16[dx]);
    if (memoryAGet16(ds, 0x6e86) != 0x0020)
        { pc = 0x211f; break; }
    r16[ax] = 0x0001;
    { pc = 0x213b; break; }
  case 0x211f:
    r16[bx] = memoryAGet16(ds, 0x6e86);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx] + 30950, r16[ax]);
    memoryASet16(ds, r16[bx] + 30948, r16[dx]);
    memoryASet16(ds, 0x6e86, memoryAGet16(ds, 0x6e86) + 1);
    r16[ax] = 0;
  case 0x213b:
    r16[bp] = pop();
    stop("stack_unbalanced");
    sp += 2; cs = pop(); return;
    // gap 13447 bytes
  case 0x55c4:
    push(r16[si]);
    push(r16[di]);
    r16[cx] = memoryAGet16(ds, 0x008a);
    push(r16[cx]);
    push(cs);
    yield* sub_52c7();
    r16[cx] = pop();
    r16[di] = r16[ax];
    if (!r16[ax])
        { pc = 0x55fb; break; }
    push(ds);
    push(ds);
    es = pop();
    ds = memoryAGet16(ds, 0x008c);
    r16[si] = 0;
    flags.direction = 0;
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    ds = pop();
    r16[di] = r16[ax];
    push(es);
    push(memoryAGet16(ds, 0x008e));
    push(cs);
    yield* sub_52c7();
    r16[bx] = pop();
    r16[bx] = r16[ax];
    es = pop();
    memoryASet16(ds, 0x744a, r16[ax]);
    if (r16[ax])
        { pc = 0x5600; break; }
  case 0x55fb:
    { pc = 0x20f6; break; }
  case 0x5600:
    r16[ax] = 0;
    r16[cx] = 0xffff;
  case 0x5605:
    memoryASet16(ds, r16[bx], r16[di]);
    r16[bx] += 0x0002;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    if (memoryAGet(es, r16[di]) != r8[al])
        { pc = 0x5605; break; }
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    r16[ax] = memoryAGet16(ds, 0x744a);
    memoryASet16(ds, 0x0088, r16[ax]);
    sp += 2;
    return;
  }
}
function* sub_561c() // 01ed:374c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[dx] = ds;
    r16[di] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(ss, r16[bp] + 10); ds = memoryAGet16(ss, r16[bp] + 12);
    r16[cx] = memoryAGet16(ss, r16[bp] + 14);
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    flags.direction = 0;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    if (!flags.carry)
        { pc = 0x5634; break; }
    movsb_ESDI_DSSI();
  case 0x5634:
    ds = r16[dx];
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5683() // 01ed:37b3 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    flags.direction = 0;
    r16[di] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    r16[si] = r16[di];
    r8[al] = 0;
    r16[cx] = 0xffff;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    r16[cx] = ~r16[cx];
    push(ds);
    r16[ax] = es;
    ds = r16[ax];
    r16[di] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    ds = pop();
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_56ac() // 056a:000c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0056;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = 0;
    memoryASet16(ds, r16[bx], r16[ax]);
    memoryASet16(ds, r16[di], r16[ax]);
    r16[ax] = r16[bp] - 86;
    r16[si] = r16[ax];
    { pc = 0x570a; break; }
  case 0x56c7:
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    memoryASet(ds, r16[si], r8[al]);
    r16[si]++;
    if (memoryAGet(ss, r16[bp] - 1) == 0x0a)
        { pc = 0x56dd; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    if (r16[ax])
        { pc = 0x570a; break; }
  case 0x56dd:
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 86;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x056a); break;
        default:
            stop("ind 056a:004a");
    }
    sp += 0x0008;
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[bx], memoryAGet16(ds, r16[bx]) + r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x5705; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, r16[di], r16[ax]);
  case 0x5705:
    r16[ax] = r16[bp] - 86;
    r16[si] = r16[ax];
  case 0x570a:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    if (r8[al])
        { pc = 0x56c7; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_571f() // 056a:007f +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1b1e; yield* sub_1b7c2(); assert(cs == 0x056a);
    push(cs); cs = 0x1a61; yield* sub_1afaf(); assert(cs == 0x056a);
    push(cs); cs = 0x164d; yield* sub_16d38(); assert(cs == 0x056a);
    push(cs); cs = 0x1841; yield* sub_18544(); assert(cs == 0x056a);
    push(cs); cs = 0x1ef3; yield* sub_1efc0(); assert(cs == 0x056a);
    push(cs); cs = 0x1493; yield* sub_152c9(); assert(cs == 0x056a);
    push(cs); cs = 0x174b; yield* sub_17b92(); assert(cs == 0x056a);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_5747() // 056a:00a7 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[si] = 0x0001;
    { pc = 0x5777; break; }
  case 0x5754:
    r16[ax] = 0x00aa;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x056a);
    sp += 0x0004;
    if (r16[ax])
        { pc = 0x5776; break; }
    memoryASet16(ds, 0x7a14, 0x0001);
  case 0x5776:
    r16[si]++;
  case 0x5777:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x5754; break; }
    push(cs); cs = 0x1b1e; yield* sub_1b97a(); assert(cs == 0x056a);
    push(cs); cs = 0x174b; yield* sub_178db(); assert(cs == 0x056a);
    push(cs); cs = 0x1ef3; yield* sub_1ef35(); assert(cs == 0x056a);
    push(cs); cs = 0x1841; yield* sub_1841f(); assert(cs == 0x056a);
    push(cs); cs = 0x164d; yield* sub_16c64(); assert(cs == 0x056a);
    push(cs); cs = 0x1a61; yield* sub_1ae36(); assert(cs == 0x056a);
    push(cs); cs = 0x1b1e; yield* sub_1b727(); assert(cs == 0x056a);
    push(cs); cs = 0x1b1e; yield* sub_1baf1(); assert(cs == 0x056a);
    push(cs); cs = 0x1493; yield* sub_15284(); assert(cs == 0x056a);
    push(cs); cs = 0x1b1e; yield* sub_1b7a1(); assert(cs == 0x056a);
    r16[ax] = 0x07b1;
    push(r16[ax]);
    r16[ax] = 0x0466;
    push(r16[ax]);
    r16[ax] = 0x07b1;
    push(r16[ax]);
    r16[ax] = 0x00d3;
    push(r16[ax]);
    r16[ax] = 0x07b1;
    push(r16[ax]);
    r16[ax] = 0x01e0;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1b334(); assert(cs == 0x056a);
    sp += 0x000c;
    memoryASet16(ds, 0x7aea, 0x07b1);
    memoryASet16(ds, 0x7ae8, 0x066d);
    memoryASet16(ds, 0x7ae6, 0x07b1);
    memoryASet16(ds, 0x7ae4, 0x07ea);
    memoryASet16(ds, 0x7ae2, 0x07b1);
    memoryASet16(ds, 0x7ae0, 0x085b);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x056a);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x0003, memoryAGet(es, 0x0003) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0209, memoryAGet(es, 0x0209) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x020a, memoryAGet(es, 0x020a) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x007a, memoryAGet(es, 0x007a) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x007b, memoryAGet(es, 0x007b) | r8[dl]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x7af3;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x7eff;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x7f01;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x7be1;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x7be3;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x056a);
    sp += 0x0004;
    memoryASet(ds, 0x6025, 0x0f);
    push(cs); cs = 0x1b1e; yield* sub_1be1c(); assert(cs == 0x056a);
    r16[di] = 0x21d1;
    memoryASet16(ss, r16[bp] - 2, 0x00fa);
    r16[ax] = 0x0000;
    if (!r16[ax])
        { pc = 0x589a; break; }
    r16[di]++;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - 1);
  case 0x589a:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[di]);
    push(cs); cs = 0x174b; yield* sub_176e6(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1efdc(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f019(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_58cf() // 056a:022f +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[si])
        { pc = 0x58f4; break; }
    push(cs); cs = 0x1493; yield* sub_15ec3(); assert(cs == 0x056a);
    r16[ax] = 0x127f;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0x9feb);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x58f4:
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x056a);
    sp += 0x0002;
    push(cs);
    yield* sub_571f();
    if (!r16[si])
        { pc = 0x596d; break; }
    if (!memoryAGet(ds, r16[si]))
        { pc = 0x596d; break; }
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_2e73(); assert(cs == 0x056a);
    sp += 0x0002;
    if (!memoryAGet16(ds, 0x7adc))
        { pc = 0x5946; break; }
    push(cs); cs = 0x01ed; yield* sub_3886(); assert(cs == 0x056a);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x00ce;
    push(r16[ax]);
    r16[ax] = 0x00c5;
    push(r16[ax]);
    r16[ax] = 0x00bc;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_246d(); assert(cs == 0x056a);
    sp += 0x0008;
    { pc = 0x5961; break; }
  case 0x5946:
    r16[ax] = 0x00d6;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1b895(); assert(cs == 0x056a);
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x5961; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_352c(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x5961:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x596d:
    if (memoryAGet16(ds, 0x7ad8))
        { pc = 0x59b9; break; }
    r16[ax] = 0x0fa0;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0xb800;
    push(r16[ax]);
    r16[ax] = 0x0007;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x01ed; yield* sub_3c10(); assert(cs == 0x056a);
    sp += 0x000a;
    r16[ax] = 0x0018;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_2a2c(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x00de;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1b895(); assert(cs == 0x056a);
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x59b9; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_352c(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x59b9:
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_59c9() // 056a:0329 +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_571f();
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x00f8;
    push(r16[ax]);
    r16[ax] = 0x00ef;
    push(r16[ax]);
    r16[ax] = 0x00e6;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_246d(); assert(cs == 0x056a);
    sp += 0x0008;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_59e9() // 056a:0349 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa00d);
    r16[dx] = memoryAGet16(ds, 0xa00b);
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa00f) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa00f);
    r16[ax] += memoryAGet16(ds, 0xa011) + flags.carry;
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa013) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa013);
    r16[ax] += memoryAGet16(ds, 0xa015) + flags.carry;
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa017) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa017);
    r16[ax] += memoryAGet16(ds, 0xa019) + flags.carry;
    if (r16s[ax] < signed16(0x0004))
        { pc = 0x5a1b; break; }
    if (r16[ax] != 0x0004)
        { pc = 0x5a67; break; }
    if (r16[dx] >= 0xbaf0)
        { pc = 0x5a67; break; }
  case 0x5a1b:
    r16[ax] = 0x1282;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0x9ff1);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(cs);
    yield* sub_571f();
    r16[ax] = 0x0fa0;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0xb800;
    push(r16[ax]);
    r16[ax] = 0x0007;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x01ed; yield* sub_3c10(); assert(cs == 0x056a);
    sp += 0x000a;
    r16[ax] = 0x0018;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_2a2c(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x5a67:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5a6b() // 056a:03cb
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    if (!memoryAGet16(ds, 0x7adc))
        { pc = 0x5ace; break; }
    push(cs); cs = 0x07b1; yield* sub_7b73(); assert(cs == 0x056a);
    push(cs); cs = 0x1493; yield* sub_15458(); assert(cs == 0x056a);
    r16[ax] = memoryAGet16(ds, 0x7ada);
    memoryASet16(ds, 0x7a68, r16[ax]);
    memoryASet16(ds, 0x474a, 0x0002);
    r16[si] = 0x0001;
    { pc = 0x5abf; break; }
  case 0x5a95:
    r16[ax] = 0x00ae;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x056a);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[ax] == 0xffff)
        { pc = 0x5abe; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax]++;
    memoryASet16(ds, 0x474a, r16[ax]);
    { pc = 0x5ac5; break; }
  case 0x5abe:
    r16[si]++;
  case 0x5abf:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x5a95; break; }
  case 0x5ac5:
    push(cs); cs = 0x07b1; yield* sub_8891(); assert(cs == 0x056a);
    push(cs);
    yield* sub_59c9();
  case 0x5ace:
    r16[di] = 0;
    memoryASet16(ds, 0x7a70, 0x0000);
  case 0x5ad6:
    r16[bx] = r16[di];
    r16[di]++;
    if (r16[bx] <= 0x0006)
        { pc = 0x5ae1; break; }
    { pc = 0x5b71; break; }
  case 0x5ae1:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x5ae8; break; }
        case 2: { pc = 0x5aff; break; }
        case 4: { pc = 0x5b0c; break; }
        case 6: { pc = 0x5b13; break; }
        case 8: { pc = 0x5b21; break; }
        case 10: { pc = 0x5b28; break; }
        case 12: { pc = 0x5b36; break; }
        default:
            stop("ind 056a:0443");
    }
    break;
  case 0x5ae8:
    if (!memoryAGet16(ds, 0x7ade))
        { pc = 0x5af6; break; }
    push(cs); cs = 0x05da; yield* sub_776a(); assert(cs == 0x056a);
    { pc = 0x5b71; break; }
  case 0x5af6:
    push(cs); cs = 0x05da; yield* sub_6d6f(); assert(cs == 0x056a);
    { pc = 0x5b71; break; }
    // gap 2 bytes
  case 0x5aff:
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x05da; yield* sub_77d1(); assert(cs == 0x056a);
    sp += 0x0002;
    { pc = 0x5b71; break; }
  case 0x5b0c:
    push(cs); cs = 0x05da; yield* sub_7658(); assert(cs == 0x056a);
    { pc = 0x5b71; break; }
  case 0x5b13:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x05da; yield* sub_77d1(); assert(cs == 0x056a);
    sp += 0x0002;
    { pc = 0x5b71; break; }
  case 0x5b21:
    push(cs); cs = 0x05da; yield* sub_7af5(); assert(cs == 0x056a);
    { pc = 0x5b71; break; }
  case 0x5b28:
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x05da; yield* sub_77d1(); assert(cs == 0x056a);
    sp += 0x0002;
    { pc = 0x5b71; break; }
  case 0x5b36:
    r16[di] = 0;
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs); cs = 0x05da; yield* sub_77d1(); assert(cs == 0x056a);
    sp += 0x0002;
    { pc = 0x5b71; break; }
    // gap 2 bytes
  case 0x5b48:
    push(cs); cs = 0x07b1; yield* sub_8891(); assert(cs == 0x056a);
    push(cs); cs = 0x05da; yield* sub_7af5(); assert(cs == 0x056a);
    if (memoryAGet16(ds, 0x7a70) == 0x0005)
        { pc = 0x5b71; break; }
    if (memoryAGet16(ds, 0x7a70) == 0x0006)
        { pc = 0x5b71; break; }
    push(cs); cs = 0x05da; yield* sub_776a(); assert(cs == 0x056a);
    if (memoryAGet16(ds, 0x7a70) == 0x0005)
        { pc = 0x5b71; break; }
  case 0x5b71:
    if (memoryAGet16(ds, 0x7a70) == 0x0005)
        { pc = 0x5b48; break; }
    if (memoryAGet16(ds, 0x7a70) == 0x0006)
        { pc = 0x5b48; break; }
    { pc = 0x5ad6; break; }
    return;
  }
}
function* sub_5b97() // 056a:04f7 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x8001;
    push(r16[ax]);
    r16[ax] = 0x0112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x056a);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[ax] == 0xffff)
        { pc = 0x5bc6; break; }
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x5bc6:
    r16[ax] = 0x011f;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_2e73(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x015d;
    push(r16[ax]);
    r16[ax] = 0x0154;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3ecb(); assert(cs == 0x056a);
    sp += 0x0004;
    if (r16[ax] != 0xffff)
        { pc = 0x5bff; break; }
    r16[ax] = 0x016a;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_2e73(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x5bff:
    r16[ax] = 0x8802;
    push(r16[ax]);
    r16[ax] = 0x0181;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[si] = r16[ax];
    if (r16[ax] != 0xffff)
        { pc = 0x5c2e; break; }
    r16[ax] = 0x018e;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_2e73(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x5c2e:
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x056a);
    sp += 0x0008;
    r16[ax] = 0x8001;
    push(r16[ax]);
    r16[ax] = 0x01a7;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x056a);
    sp += 0x0004;
    r16[di] = r16[ax];
    if (r16[ax] != 0xffff)
        { pc = 0x5c6e; break; }
    r16[ax] = 0x01b0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_2e73(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x056a);
    sp += 0x0002;
  case 0x5c6e:
    push(r16[di]);
    push(cs); cs = 0x01ed; yield* sub_3845(); assert(cs == 0x056a);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0x7d00;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4d93(); assert(cs == 0x056a);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    { pc = 0x5d0e; break; }
  case 0x5c94:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) < signed16(0x0000))
        { pc = 0x5cda; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) > signed16(0x0000))
        { pc = 0x5ca3; break; }
    if (memoryAGet16(ss, r16[bp] - 6) <= 0x7d00)
        { pc = 0x5cda; break; }
  case 0x5ca3:
    r16[ax] = 0;
    r16[dx] = 0x7d00;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[di]);
    push(cs); cs = 0x1493; yield* sub_14a24(); assert(cs == 0x056a);
    sp += 0x000a;
    r16[ax] = 0;
    r16[dx] = 0x7d00;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_14a70(); assert(cs == 0x056a);
    sp += 0x000a;
    flags.carry = memoryAGet16(ss, r16[bp] - 6) < 0x7d00;
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) - 0x7d00);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - (0x0000 + flags.carry));
    { pc = 0x5d0e; break; }
  case 0x5cda:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[di]);
    push(cs); cs = 0x1493; yield* sub_14a24(); assert(cs == 0x056a);
    sp += 0x000a;
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_14a70(); assert(cs == 0x056a);
    sp += 0x000a;
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
  case 0x5d0e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 4);
    if (!r16[ax])
        { pc = 0x5d19; break; }
    { pc = 0x5c94; break; }
  case 0x5d19:
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(cs); cs = 0x01ed; yield* sub_4cad(); assert(cs == 0x056a);
    sp += 0x0004;
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x056a);
    sp += 0x0002;
    push(r16[di]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[ax] = 0x01c5;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4223(); assert(cs == 0x056a);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5d4b() // 056a:06ab +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_5b97();
    r16[ax] = 0x01ce;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1b895(); assert(cs == 0x056a);
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x5d68; break; }
    memoryASet16(ds, 0x7a72, 0x0001);
  case 0x5d68:
    r16[ax] = 0x01d3;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1b895(); assert(cs == 0x056a);
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x5d7e; break; }
    memoryASet16(ds, 0x7a18, 0x0001);
  case 0x5d7e:
    push(cs);
    yield* sub_5747();
    push(cs);
    yield* sub_59e9();
    if (memoryAGet16(ds, 0x7ad8))
        { pc = 0x5d94; break; }
    if (!memoryAGet16(ds, 0x7adc))
        { pc = 0x5d9a; break; }
  case 0x5d94:
    memoryASet16(ds, 0x7a16, 0x0001);
  case 0x5d9a:
    push(cs);
    yield* sub_5a6b();
    r16[ax] = 0x01da;
    push(r16[ax]);
    push(cs);
    yield* sub_58cf();
    sp += 0x0002;
    r16[bp] = pop();
    stop("stack_unbalanced");
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5dab() // 05da:000b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet(ds, 0xa545))
        { pc = 0x5e03; break; }
    if (!memoryAGet16(ds, 0x7a72))
        { pc = 0x5dd4; break; }
    memoryASet16(ds, 0x7a70, 0x0005);
    memoryASet16(ds, 0x474a, 0x0002);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x05da);
    push(cs); cs = 0x07b1; yield* sub_7b73(); assert(cs == 0x05da);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x5dd4:
    if (memoryAGet(ds, 0xa545) != 0x3b)
        { pc = 0x5de2; break; }
    push(cs); cs = 0x0b02; yield* sub_b9c5(); assert(cs == 0x05da);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x5de2:
    push(cs); cs = 0x1c76; yield* sub_1ece2(); assert(cs == 0x05da);
    if (!memoryAGet16(ds, 0x474a))
        { pc = 0x5df6; break; }
    memoryASet16(ds, 0x7a70, 0x0005);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x5df6:
    if (!memoryAGet16(ds, 0xa53b))
        { pc = 0x5e03; break; }
    memoryASet16(ds, 0x7a70, 0x0006);
  case 0x5e03:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5e05() // 05da:0065 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0012;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 512);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= 0x0006;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa552);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 41025, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 41015, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    imul16(memoryAGet16(ss, r16[bp] - 8));
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] <<= 1;
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0xa04b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41035);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
    r16[si] = 0;
    { pc = 0x5eba; break; }
  case 0x5ea2:
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 1);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
    r16[si]++;
  case 0x5eba:
    if (r16[si] < memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x5ea2; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_5ed6() // 05da:0136 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0010;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] &= 0x0007;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, 0xa021);
    r16[dx] += r16[ax];
    r16[ax] = memoryAGet16(ds, 0xa033);
    r16[ax] >>= 1;
    r16[bx] = 0x0014;
    r16[bx] -= r16[ax];
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0c02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_6078();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] += memoryAGet16(ds, 0xa02f);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) >= signed16(0x0000))
        { pc = 0x5f2e; break; }
    memoryASet16(ss, r16[bp] - 8, 0x0000);
  case 0x5f2e:
    r16[bx] = memoryAGet16(ds, 0x7468);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 29796);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) >= signed16(0x00c8))
        { pc = 0x5f81; break; }
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 8)))
        { pc = 0x5f81; break; }
    r16[ax] -= memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[bx] = memoryAGet16(ds, 0xa7ac);
    r16[bx] -= memoryAGet16(ds, 0xa031);
    r16[bx] -= memoryAGet16(ds, 0xa031);
    r16[di] = memoryAGet16(ss, r16[bp] - 16);
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    r16[si] = memoryAGet16(ds, 0xa031);
    r16[ax] = 0;
  case 0x5f78:
    r16[cx] = r16[si];
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    r16[di] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x5f78; break; }
  case 0x5f81:
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) <= signed16(0x00c8))
        { pc = 0x5f8d; break; }
    memoryASet16(ss, r16[bp] - 8, 0x00c8);
  case 0x5f8d:
    r16[bx] = memoryAGet16(ds, 0x7468);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[bx] + 29796, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa02f);
    memoryASet16(ds, 0xa025, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) >= signed16(0x0000))
        { pc = 0x5fc9; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = -r16[ax];
    r16[dx] = memoryAGet16(ds, 0xa033);
    r16[dx] <<= 1;
    imul16(r16[dx]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xa025, memoryAGet16(ds, 0xa025) + r16[ax]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x5fde; break; }
  case 0x5fc9:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += memoryAGet16(ds, 0xa02f);
    if (r16[ax] <= 0x00c8)
        { pc = 0x5fde; break; }
    r16[ax] = 0x00c8;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xa025, r16[ax]);
  case 0x5fde:
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] += memoryAGet16(ds, 0xa02d);
    memoryASet16(ds, 0xa023, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa025)) > signed16(0x0000))
        { pc = 0x5ff2; break; }
    { pc = 0x6072; break; }
  case 0x5ff2:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 24530);
    memoryASet16(ds, 0xa029, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ds, 0x7472, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14);
    push(r16[bp]);
    r16[bp] = memoryAGet16(ds, 0xa029);
    es = memoryAGet16(ds, 0xa7ae);
    ds = memoryAGet16(ds, 0xa035);
    r8[ah] = 0x04;
    memoryASet(ss, 0xa027, r8[ah]);
  case 0x6024:
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
    out16(r16[dx], r16[ax]);
    r16[dx] = memoryAGet16(ss, 0xa025);
    r16[di] = memoryAGet16(ss, 0x7472);
  case 0x6034:
    r16[cx] = memoryAGet16(ss, 0xa033);
    r8[al] = 0;
  case 0x603b:
    r16[si] = memoryAGet16(ds, r16[bx]);
    r16[bx] += 0x0002;
    r8[ah] = 0;
    r16[ax] |= memoryAGet16(ss, r16[bp] + r16[si]);
    stosb_ESDI(r8[al]);
    r8[al] = r8[ah];
    if (--r16[cx])
        { pc = 0x603b; break; }
    stosb_ESDI(r8[al]);
    memoryASet16(es, r16[di], 0x0000);
    r16[di] += memoryAGet16(ss, 0xa02b);
    r16[dx]--;
    if (r16[dx])
        { pc = 0x6034; break; }
    r16[bx] = memoryAGet16(ss, 0xa023);
    r8[ah] = memoryAGet(ss, 0xa027);
    r8[ah] <<= 1;
    memoryASet(ss, 0xa027, r8[ah]);
    if (r8[ah] != 0x10)
        { pc = 0x6024; break; }
    r16[bp] = pop();
    r16[ax] = ss;
    ds = r16[ax];
  case 0x6072:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_6078() // 05da:02d8 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ds, 0x746e);
    r16[bx]++;
    if (r16[bx] <= 0x0003)
        { pc = 0x608b; break; }
    { pc = 0x617e; break; }
  case 0x608b:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x6092; break; }
        case 2: { pc = 0x60e9; break; }
        case 4: { pc = 0x6118; break; }
        case 6: { pc = 0x6139; break; }
        default:
            stop("ind 05da:02ed");
    }
    break;
  case 0x6092:
    r16[bx] = memoryAGet16(ds, 0x7470);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41035);
    memoryASet16(ds, 0xa035, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x7470);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41025);
    memoryASet16(ds, 0xa033, r16[ax]);
    r16[ax] += 0x0003;
    r16[ax] >>= 1;
    memoryASet16(ds, 0xa031, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x7470);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41015);
    memoryASet16(ds, 0xa02f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa033);
    r16[ax]++;
    r16[dx] = memoryAGet16(ds, 0xa7ac);
    r16[dx] -= r16[ax];
    memoryASet16(ds, 0xa02b, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xa033);
    imul16(memoryAGet16(ds, 0xa02f));
    r16[ax] <<= 1;
    memoryASet16(ds, 0xa02d, r16[ax]);
    memoryASet16(ds, 0x746e, memoryAGet16(ds, 0x746e) + 1);
    memoryASet16(ds, 0x746a, r16[cx]);
    memoryASet16(ds, 0x746c, 0x00f0);
  case 0x60e9:
    r16[ax] = r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x746a);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x746c, memoryAGet16(ds, 0x746c) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x746c)) >= signed16(0x0064))
        { pc = 0x6106; break; }
    memoryASet16(ds, 0x746c, 0x0064);
    memoryASet16(ds, 0x746e, memoryAGet16(ds, 0x746e) + 1);
  case 0x6106:
    memoryASet16(ds, 0x746a, r16[cx]);
    r16[ax] = memoryAGet16(ds, 0xa02f);
    r16[ax] >>= 1;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x746c);
    r16[dx] = pop();
    r16[ax] -= r16[dx];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x6118:
    r16[ax] = r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x746a);
    if (r16s[ax] <= signed16(0x00c8))
        { pc = 0x612b; break; }
    memoryASet16(ds, 0x746e, memoryAGet16(ds, 0x746e) + 1);
    memoryASet16(ds, 0x746a, r16[cx]);
  case 0x612b:
    r16[ax] = memoryAGet16(ds, 0xa02f);
    r16[ax] >>= 1;
    push(r16[ax]);
    r16[ax] = 0x0064;
    r16[dx] = pop();
    r16[ax] -= r16[dx];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x6139:
    r16[ax] = r16[cx];
    r16[ax] -= memoryAGet16(ds, 0x746a);
    r16[ax] <<= 1;
    memoryASet16(ds, 0x746c, memoryAGet16(ds, 0x746c) - r16[ax]);
    if (signed16(memoryAGet16(ds, 0x746c)) >= signed16(0xffd8))
        { pc = 0x616c; break; }
    memoryASet16(ds, 0x746c, 0xffd8);
    memoryASet16(ds, 0x7470, memoryAGet16(ds, 0x7470) + 1);
    r16[ax] = memoryAGet16(ds, 0x7470);
    if (r16s[ax] >= signed16(0x0004))
        { pc = 0x6166; break; }
    memoryASet16(ds, 0x746e, 0xffff);
    { pc = 0x616c; break; }
  case 0x6166:
    memoryASet16(ds, 0x746e, 0x0003);
  case 0x616c:
    memoryASet16(ds, 0x746a, r16[cx]);
    r16[ax] = memoryAGet16(ds, 0xa02f);
    r16[ax] >>= 1;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x746c);
    r16[dx] = pop();
    r16[ax] -= r16[dx];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x617e:
    r16[ax] = 0xffd8;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_618c() // 05da:03ec +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0026;
    push(r16[si]);
    push(r16[di]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0004;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    es = memoryAGet16(ds, 0xa06f);
    r16[ax] = memoryAGet16(es, 0x0002);
    r16[ax] += 0x00c8;
    memoryASet16(ds, 0xa055, r16[ax]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0104;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    es = memoryAGet16(ds, 0xa071);
    r16[ax] = 0x0078;
    r16[ax] -= memoryAGet16(es, 0x0002);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, 0x0140);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] ^= r16[dx];
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, 0x7468, r16[ax]);
    memoryASet16(ds, 0xa021, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
  case 0x61f5:
    yield* sync(); /*
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    if (r16[ax] != memoryAGet16(ds, 0xa54a))
        { pc = 0x6208; break; }
    if (r16[dx] == memoryAGet16(ds, 0xa548))
        { pc = 0x61f5; break; }
  case 0x6208:
    */
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    { pc = 0x6424; break; }
  case 0x621e:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 10));
    r16[bx] = memoryAGet16(ds, 0xa055);
    r16[cx] = 0;
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 8);
    r16[dx] = 0;
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x05da);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 8));
    push(cs);
    yield* sub_5ed6();
    sp += 0x0004;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 10));
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    push(r16[dx]);
    r16[dx] = 0;
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x05da);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    r16[dx] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] &= 0x0007;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += 0x0800;
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[ax] += 0xff00;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += 0x0800;
    r16[ax] &= 0x0007;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41051);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    memoryASet16(ss, r16[bp] - 24, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[dx] = memoryAGet16(ds, 0xa021);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) <= signed16(0x0000))
        { pc = 0x62ea; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax]++;
    r16[bx] = 0x0002;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    if (!(memoryAGet16(ss, r16[bp] - 6) & 0x0001))
        { pc = 0x62da; break; }
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) - 1);
  case 0x62da:
    r16[ax] = 0x0015;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 26);
    memoryASet16(ss, r16[bp] - 28, r16[ax]);
    memoryASet16(ss, r16[bp] - 30, 0x0000);
    { pc = 0x6331; break; }
  case 0x62ea:
    r16[ax] = memoryAGet16(ds, 0xa059);
    r16[ax] = -r16[ax];
    r16[ax] += 0x0028;
    if (r16s[ax] >= signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0x630e; break; }
    memoryASet16(ss, r16[bp] - 26, 0x0000);
    memoryASet16(ss, r16[bp] - 28, 0x0015);
    memoryASet16(ss, r16[bp] - 30, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 24, memoryAGet16(ss, r16[bp] - 24) - r16[ax]);
    { pc = 0x6331; break; }
  case 0x630e:
    memoryASet16(ss, r16[bp] - 26, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa059);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    r16[bx] = 0x0002;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 28, r16[ax]);
    r16[ax] = 0x0015;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 28);
    memoryASet16(ss, r16[bp] - 30, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 24, memoryAGet16(ss, r16[bp] - 24) - r16[ax]);
  case 0x6331:
    r16[ax] = memoryAGet16(ss, r16[bp] - 28);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa059);
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 32, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 26);
    r16[ax] += memoryAGet16(ss, r16[bp] - 28);
    r16[ax] += memoryAGet16(ss, r16[bp] - 30);
    r16[ax] <<= 1;
    r16[dx] = 0x00f8;
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 34, r16[dx]);
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0202;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[di] = memoryAGet16(ss, r16[bp] - 12);
    es = memoryAGet16(ds, 0xa7ae);
    r16[si] = memoryAGet16(ss, r16[bp] - 24);
    memoryASet16(ds, 0xa057, r16[si]);
    ds = memoryAGet16(ss, r16[bp] - 22);
    r16[dx] = 0x00c8;
  case 0x636f:
    r16[ax] = 0;
    r16[cx] = memoryAGet16(ss, r16[bp] - 26);
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    r16[cx] = memoryAGet16(ss, r16[bp] - 28);
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    r16[ax] = 0;
    r16[cx] = memoryAGet16(ss, r16[bp] - 30);
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    if (r16[dx] & 0x0001)
        { pc = 0x638f; break; }
    r16[si] = memoryAGet16(ss, 0xa057);
    { pc = 0x6397; break; }
  case 0x638f:
    r16[si] += memoryAGet16(ss, r16[bp] - 32);
    memoryASet16(ss, 0xa057, r16[si]);
  case 0x6397:
    r16[di] += memoryAGet16(ss, r16[bp] - 34);
    r16[dx]--;
    if (r16[dx])
        { pc = 0x636f; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] &= 0x0007;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[dx] = memoryAGet16(ds, 0xa021);
    r16[dx] += r16[ax];
    push(r16[dx]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    memoryASet16(ds, 0x7468, memoryAGet16(ds, 0x7468) ^ 0x0001);
    if (!memoryAGet16(ds, 0x7468))
        { pc = 0x63d4; break; }
    memoryASet16(ds, 0xa021, 0x007c);
    { pc = 0x63da; break; }
  case 0x63d4:
    memoryASet16(ds, 0xa021, 0x0000);
  case 0x63da:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 36, r16[ax]);
    memoryASet16(ss, r16[bp] - 38, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 38);
    r16[ax] -= memoryAGet16(ds, 0xa548);
    memoryASet16(ds, 0xa54c, r16[ax]);
    if (memoryAGet16(ds, 0xa54c) < 0x0002)
        { pc = 0x63da; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 36);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x05da);
    if (!r16[ax])
        { pc = 0x6417; break; }
    if (memoryAGet(ds, 0xa545) == 0x3b)
        { pc = 0x6417; break; }
    memoryASet(ds, 0xa545, 0x39);
  case 0x6417:
    if (memoryAGet(ds, 0xa545))
        { pc = 0x643b; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + r16[ax]);
  case 0x6424:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x642f; break; }
    { pc = 0x621e; break; }
  case 0x642f:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ds, 0xa01f, r16[ax]);
  case 0x643b:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_6441() // 05da:06a1 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    r16[si] = r16[ax];
    r16[dx] = r16[ax];
  case 0x644c:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[cx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    if (r16[cx] != 0xffff)
        { pc = 0x646f; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], r8[dl]);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 1);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], 0x00);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x646f:
    r16[si] += r16[cx];
    if (r16[si] <= 0x0007)
        { pc = 0x64a2; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], r8[dl]);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 1);
    r16[dx] = 0;
    r16[ax] = r16[si];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax]--;
    r16[di] = r16[ax];
    { pc = 0x6498; break; }
  case 0x648e:
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], 0x00);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 1);
  case 0x6498:
    r16[ax] = r16[di];
    r16[di]--;
    if (r16[ax])
        { pc = 0x648e; break; }
    r16[si] &= 0x0007;
  case 0x64a2:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[cx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    if (r16[cx] != 0xffff)
        { pc = 0x64c5; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], r8[dl]);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 1);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], 0x00);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x64c5:
    r8[al] = memoryAGet(ds, r16[si] + 554);
    r8[ah] = 0x00;
    r16[dx] |= r16[ax];
    r16[si] += r16[cx];
    if (r16[si] <= 0x0007)
        { pc = 0x6501; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], r8[dl]);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 1);
    r16[dx] = 0x00ff;
    r16[ax] = r16[si];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax]--;
    r16[di] = r16[ax];
    { pc = 0x64f7; break; }
  case 0x64ed:
    r16[bx] = memoryAGet16(ss, r16[bp] + 10); es = memoryAGet16(ss, r16[bp] + 12);
    memoryASet(es, r16[bx], 0xff);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + 1);
  case 0x64f7:
    r16[ax] = r16[di];
    r16[di]--;
    if (r16[ax])
        { pc = 0x64ed; break; }
    r16[si] &= 0x0007;
  case 0x6501:
    r8[al] = memoryAGet(ds, r16[si] + 562);
    r8[ah] = 0x00;
    r16[dx] &= r16[ax];
    { pc = 0x644c; break; }
    return;
  }
}
function* sub_6510() // 05da:0770 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    r16[dx] = 0x7530;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xa06d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa06d);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, 0x0194);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    { pc = 0x6602; break; }
  case 0x653e:
    es = memoryAGet16(ds, 0xa06d);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(es, r16[bx] + 4, r16[ax]);
    r16[si] = 0;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0104;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    es = memoryAGet16(ds, 0xa071);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = memoryAGet16(ds, 0xa071);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
  case 0x657a:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, r16[bx], r16[si]);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    r16[ax] = r16[si];
    r16[ax] += r16[di];
    r16[si] = r16[ax];
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
    if (r16[di] != 0xffff)
        { pc = 0x657a; break; }
    r16[si] += 0x0050;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0004;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    es = memoryAGet16(ds, 0xa06f);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = memoryAGet16(ds, 0xa06f);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
  case 0x65ca:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, r16[bx], r16[si]);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    r16[ax] = r16[si];
    r16[ax] += r16[di];
    r16[si] = r16[ax];
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
    if (r16[di] != 0xffff)
        { pc = 0x65ca; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, r16[bx], r16[si]);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, r16[bx], 0xffff);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    memoryASet16(ss, r16[bp] - 10, memoryAGet16(ss, r16[bp] - 10) + 1);
  case 0x6602:
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) >= signed16(0x00c8))
        { pc = 0x660c; break; }
    { pc = 0x653e; break; }
  case 0x660c:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_6612() // 05da:0872 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0010;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = 0x0140;
    r16[ax] -= memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa021);
    r16[ax] += memoryAGet16(ds, 0xa01f);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ss, r16[bp] - 2, 0xa000);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] + 12)) >= signed16(0x0000))
        { pc = 0x6698; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] = -r16[ax];
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
  case 0x665b:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 14); es = memoryAGet16(ss, r16[bp] + 16);
    r16[bx] += r16[ax];
    r16[dx] = memoryAGet16(es, r16[bx]);
    if (r16s[dx] <= signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0x6679; break; }
    { pc = 0x6728; break; }
  case 0x6679:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 14); es = memoryAGet16(ss, r16[bp] + 16);
    r16[bx] += r16[ax];
    r16[dx] = memoryAGet16(es, r16[bx]);
    if (r16s[dx] <= signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0x665b; break; }
    { pc = 0x66d1; break; }
    // gap 2 bytes
  case 0x6698:
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] &= 0x0007;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] = sar16(r16[ax], 0x0001);
    r16[ax] = sar16(r16[ax], 0x0001);
    r16[ax] = sar16(r16[ax], 0x0001);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
  case 0x66bb:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 14); es = memoryAGet16(ss, r16[bp] + 16);
    r16[bx] += r16[ax];
    r16[dx] = memoryAGet16(es, r16[bx]);
  case 0x66d1:
    r16[ax] = r16[dx];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 14) <= 0x0007)
        { pc = 0x6705; break; }
    r16[di] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r8[al] = memoryAGet(ss, r16[bp] - 12);
    stosb_ESDI(r8[al]);
    r16[cx] = memoryAGet16(ss, r16[bp] - 14);
    r16[cx] >>= 1;
    r16[cx] >>= 1;
    r16[cx] >>= 1;
    r16[cx]--;
    r8[al] = 0;
    memoryASet(ss, r16[bp] - 12, r8[al]);
    for (; r16[cx] != 0; --r16[cx]) stosb_ESDI(r8[al]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) & 0x0007);
    memoryASet16(ss, r16[bp] - 4, r16[di]);
  case 0x6705:
    if (r16s[dx] <= signed16(memoryAGet16(ss, r16[bp] - 8)))
        { pc = 0x670d; break; }
    { pc = 0x67cf; break; }
  case 0x670d:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    if (r16[si] == 0xffff)
        { pc = 0x677f; break; }
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 14); es = memoryAGet16(ss, r16[bp] + 16);
    r16[bx] += r16[ax];
    r16[dx] = memoryAGet16(es, r16[bx]);
  case 0x6728:
    r16[ax] = r16[dx];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14);
    r8[al] = memoryAGet(ds, r16[bx] + 554);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) | r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 14) <= 0x0007)
        { pc = 0x676b; break; }
    r16[di] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r8[al] = memoryAGet(ss, r16[bp] - 12);
    stosb_ESDI(r8[al]);
    r16[cx] = memoryAGet16(ss, r16[bp] - 14);
    r16[cx] >>= 1;
    r16[cx] >>= 1;
    r16[cx] >>= 1;
    r16[cx]--;
    r8[al] = 0xff;
    memoryASet(ss, r16[bp] - 12, r8[al]);
    for (; r16[cx] != 0; --r16[cx]) stosb_ESDI(r8[al]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) & 0x0007);
    memoryASet16(ss, r16[bp] - 4, r16[di]);
  case 0x676b:
    if (r16s[dx] > signed16(memoryAGet16(ss, r16[bp] - 8)))
        { pc = 0x67cf; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 14);
    r8[al] = memoryAGet(ds, r16[bx] + 562);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) & r16[ax]);
    { pc = 0x66bb; break; }
  case 0x677f:
    r16[ax] = 0x0140;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 14) <= 0x0007)
        { pc = 0x67cf; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r8[al] = memoryAGet(ss, r16[bp] - 12);
    memoryASet(es, r16[bx], r8[al]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    { pc = 0x67bb; break; }
  case 0x67b1:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(es, r16[bx], 0x00);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x67bb:
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(ss, r16[bp] - 16, memoryAGet16(ss, r16[bp] - 16) - 1);
    if (r16[ax])
        { pc = 0x67b1; break; }
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) & 0x0007);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x67cf:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_67d5() // 05da:0a35 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0024;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = ds;
    es = r16[ax];
    r16[dx] = 0x0219;
    r16[ax] = 0x1002;
    interrupt(0x10);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0104;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    es = memoryAGet16(ds, 0xa071);
    r16[ax] = 0;
    r16[dx] = 0x0078;
    flags.carry = r16[dx] < memoryAGet16(es, 0x0002);
    r16[dx] -= memoryAGet16(es, 0x0002);
    r16[ax] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 34, r16[ax]);
    memoryASet16(ss, r16[bp] - 36, r16[dx]);
    push(cs);
    yield* sub_6510();
    r16[ax] = 0;
    r16[dx] = 0x1388;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xa06b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    memoryASet16(ss, r16[bp] - 8, 0x0100);
    memoryASet16(ss, r16[bp] - 10, 0x0021);
    memoryASet16(ss, r16[bp] - 10, 0x0021);
    r16[ax] = 0x00c8;
    memoryASet16(ss, r16[bp] - 30, r16[ax]);
    memoryASet16(ss, r16[bp] - 32, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, 0x0001);
    memoryASet16(ss, r16[bp] - 6, 0x001e);
    { pc = 0x6a8b; break; }
  case 0x6845:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x685f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 26, 0x0004);
    { pc = 0x68a7; break; }
  case 0x685f:
    r16[ax] = 0x0100;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    imul16(memoryAGet16(ss, r16[bp] - 4));
    r16[dx] = 0;
    div16(memoryAGet16(ss, r16[bp] - 6));
    r16[dx] = 0x0100;
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[cx] = 0;
    r16[dx] = memoryAGet16(ss, r16[bp] - 34);
    r16[ax] = memoryAGet16(ss, r16[bp] - 36);
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x05da);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = 0;
    div16(memoryAGet16(ss, r16[bp] - 6));
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
  case 0x68a7:
    r16[ax] = 0;
    r16[dx] = 0;
    r16[cx] = 0x09c4;
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    es = memoryAGet16(ds, 0xa06b);
    r16[di] = 0;
  case 0x68b7:
    memoryASet(es, r16[di], r8[ah]);
    r16[di]++;
    memoryASet(es, r16[di], r8[dl]);
    r16[di]++;
    flags.carry = r16[ax] + r16[bx] >= 0x10000;
    r16[ax] += r16[bx];
    r16[dx] += (0x0000 + flags.carry);
    if (--r16[cx])
        { pc = 0x68b7; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x68d5; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x68f8; break; }
  case 0x68d5:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[cx] = 0;
    r16[dx] = memoryAGet16(ss, r16[bp] - 34);
    r16[ax] = memoryAGet16(ss, r16[bp] - 36);
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x05da);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x68f8:
    es = memoryAGet16(ds, 0xa06b);
    r16[ax] = memoryAGet16(es, 0x0190);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 8));
    r16[ax] = 0x0001;
    r16[dx] = 0;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa021);
    r16[ax] += memoryAGet16(ds, 0xa01f);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 26) <= 0x0000)
        { pc = 0x6943; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 26));
    r16[ax] = 0x0140;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f57e(); assert(cs == 0x05da);
    sp += 0x000a;
  case 0x6943:
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[si] = 0;
    { pc = 0x6998; break; }
  case 0x6959:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r8[cl] = 0x08;
    r16[bx] >>= r8[cl];
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa06d);
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = memoryAGet16(ds, 0xa06d);
    memoryASet16(ss, r16[bp] - 20, r16[dx]);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    push(memoryAGet16(ds, 0xa06b));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ss, r16[bp] - 26);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 20));
    push(memoryAGet16(ss, r16[bp] - 22));
    push(cs);
    yield* sub_6612();
    sp += 0x000c;
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + r16[ax]);
    r16[si]++;
  case 0x6998:
    if (r16[si] < memoryAGet16(ss, r16[bp] - 24))
        { pc = 0x6959; break; }
    r16[ax] = memoryAGet16(ds, 0xa021);
    r16[ax] += memoryAGet16(ds, 0xa01f);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 24);
    r16[ax] += memoryAGet16(ss, r16[bp] - 26);
    memoryASet16(ss, r16[bp] - 28, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x7468);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 32;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 28))
        { pc = 0x69f8; break; }
    r16[ax] = 0;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x7468);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 32;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 28);
    push(r16[ax]);
    r16[ax] = 0x0140;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 28));
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f57e(); assert(cs == 0x05da);
    sp += 0x000a;
    r16[bx] = memoryAGet16(ds, 0x7468);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 32;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 28);
    memoryASet16(ds, r16[bx], r16[ax]);
  case 0x69f8:
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa021);
    r16[ax] += memoryAGet16(ds, 0xa01f);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    memoryASet16(ds, 0x7468, memoryAGet16(ds, 0x7468) ^ 0x0001);
    if (!memoryAGet16(ds, 0x7468))
        { pc = 0x6a1f; break; }
    memoryASet16(ds, 0xa021, 0x007c);
    { pc = 0x6a25; break; }
  case 0x6a1f:
    memoryASet16(ds, 0xa021, 0x0000);
  case 0x6a25:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] -= memoryAGet16(ds, 0xa548);
    memoryASet16(ds, 0xa54c, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    if (memoryAGet16(ds, 0xa54c) <= 0x0008)
        { pc = 0x6a53; break; }
    memoryASet16(ds, 0xa54c, 0x0008);
  case 0x6a53:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x6a96; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x6a6f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0x6a6f:
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x05da);
    if (!r16[ax])
        { pc = 0x6a84; break; }
    if (memoryAGet(ds, 0xa545) == 0x3b)
        { pc = 0x6a84; break; }
    memoryASet(ds, 0xa545, 0x39);
  case 0x6a84:
    if (memoryAGet(ds, 0xa545))
        { pc = 0x6aae; break; }
  case 0x6a8b:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x6a96; break; }
    { pc = 0x6845; break; }
  case 0x6a96:
    r16[ax] = 0xa06b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0xa06d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
  case 0x6aae:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_6ab4() // 05da:0d14 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x042c;
    push(r16[si]);
    push(r16[di]);
    push(ss);
    r16[ax] = r16[bp] - 28;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x023a;
    push(r16[ax]);
    r16[cx] = 0x0008;
    push(cs); cs = 0x01ed; yield* sub_51b5(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x6ae9; break; }
  case 0x6ad6:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 668;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x6ae9:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0140))
        { pc = 0x6ad6; break; }
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x6b59; break; }
  case 0x6af7:
    r16[ax] = 0;
    r16[dx] = 0x8000;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_2ec7(); assert(cs == 0x05da);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    push(r16[dx]);
    r16[dx] = 0;
    r16[ax] = 0x0140;
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x05da);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 668;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 668;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[dx] = r16[bp] - 668;
    r16[bx] += r16[dx];
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 668;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x6b59:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0140))
        { pc = 0x6af7; break; }
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x6b84; break; }
  case 0x6b67:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 668;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[dx] = r16[bp] - 1068;
    r16[bx] += r16[dx];
    memoryASet16(ds, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x6b84:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x00c8))
        { pc = 0x6b67; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f082(); assert(cs == 0x05da);
    if (!memoryAGet16(ds, 0x7468))
        { pc = 0x6ba8; break; }
    r16[ax] = memoryAGet16(ds, 0xa01f);
    r16[ax] += 0x007c;
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa01f);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    { pc = 0x6bb4; break; }
  case 0x6ba8:
    r16[ax] = memoryAGet16(ds, 0xa01f);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] += 0x007c;
    memoryASet16(ds, 0xa7b2, r16[ax]);
  case 0x6bb4:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = 0x006d;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f28c(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa7b2);
    r16[ax] -= memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    es = memoryAGet16(ds, 0xa7ae);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x6d3d; break; }
  case 0x6be9:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += 0xff60;
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 16)) >= signed16(0x0000))
        { pc = 0x6bfd; break; }
    memoryASet16(ss, r16[bp] - 16, 0x0000);
  case 0x6bfd:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 18)) < signed16(0x00c8))
        { pc = 0x6c0f; break; }
    memoryASet16(ss, r16[bp] - 18, 0x00c7);
  case 0x6c0f:
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    { pc = 0x6cef; break; }
  case 0x6c18:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    { pc = 0x6ce3; break; }
  case 0x6c2f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 1068;
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(ds, r16[bx]);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 668;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 1068;
    r16[bx] += r16[ax];
    memoryASet16(ds, r16[bx], memoryAGet16(ds, r16[bx]) + 1);
    r16[ax] = memoryAGet16(ds, r16[bx]);
    if (r16[ax] != 0x0140)
        { pc = 0x6c6c; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 1068;
    r16[bx] += r16[ax];
    memoryASet16(ds, r16[bx], 0x0000);
  case 0x6c6c:
    r16[cx] = memoryAGet16(ss, r16[bp] - 10);
    r16[si] = r16[cx];
    r16[si] &= 0x0007;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] + r16[si] - 28);
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[si] = memoryAGet16(ss, r16[bp] - 14);
    r16[cx] >>= 1;
    r16[cx] >>= 1;
    r16[cx] >>= 1;
    r16[si] += r16[cx];
    r16[di] = r16[si];
    r16[di] += memoryAGet16(ss, r16[bp] - 20);
    r16[dx] = 0x03c4;
    r16[ax] = 0x0102;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0004;
    out16(r16[dx], r16[ax]);
    r8[bl] = memoryAGet(es, r16[si]);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    r16[dx] = 0x03c4;
    r16[ax] = 0x0202;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0104;
    out16(r16[dx], r16[ax]);
    r8[bl] = memoryAGet(es, r16[si]);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    r16[dx] = 0x03c4;
    r16[ax] = 0x0402;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0204;
    out16(r16[dx], r16[ax]);
    r8[bl] = memoryAGet(es, r16[si]);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    r16[dx] = 0x03c4;
    r16[ax] = 0x0802;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0304;
    out16(r16[dx], r16[ax]);
    r8[bl] = memoryAGet(es, r16[si]);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 1);
  case 0x6ce3:
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) >= signed16(0x0002))
        { pc = 0x6cec; break; }
    { pc = 0x6c2f; break; }
  case 0x6cec:
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 1);
  case 0x6cef:
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    if (r16s[ax] > signed16(memoryAGet16(ss, r16[bp] - 18)))
        { pc = 0x6cfa; break; }
    { pc = 0x6c18; break; }
  case 0x6cfa:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x05da);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x05da);
    if (!r16[ax])
        { pc = 0x6d1b; break; }
    if (memoryAGet(ds, 0xa545) == 0x3b)
        { pc = 0x6d1b; break; }
    memoryASet(ds, 0xa545, 0x39);
  case 0x6d1b:
    if (!memoryAGet(ds, 0xa545))
        { pc = 0x6d3a; break; }
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0xff08;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x6d3a:
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x6d3d:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) >= signed16(0x0168))
        { pc = 0x6d47; break; }
    { pc = 0x6be9; break; }
  case 0x6d47:
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0xff08;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[ax] = 0;
    push(r16[ax]);
    r16[dx] = 0x01a4;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x164d; yield* sub_17462(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_6d6f() // 05da:0fcf +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x01a4;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 20, 0x0000);
    push(cs); cs = 0x1493; yield* sub_15ec3(); assert(cs == 0x05da);
    r8[al] = memoryAGet(ds, 0xa54e);
    memoryASet(ds, 0x4ec4, r8[al]);
    r16[ax] = ds;
    es = r16[ax];
    r16[dx] = 0x4eb4;
    r16[ax] = 0x1002;
    interrupt(0x10);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x00f8;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x006d;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x1280;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x1281;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0x9fef);
    memoryASet16(ds, 0xa06f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x9fed);
    memoryASet16(ds, 0xa071, r16[ax]);
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0102;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    es = memoryAGet16(ds, 0xa06f);
    r16[ax] = memoryAGet16(es, 0x0002);
    r16[ax] += 0x00c8;
    memoryASet16(ds, 0xa055, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa055);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x6e51; break; }
  case 0x6e0f:
    es = memoryAGet16(ds, 0xa06f);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = memoryAGet16(ds, 0xa06f);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ss, r16[bp] - 12, 0xa000);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 0x0019);
    push(memoryAGet16(ss, r16[bp] - 12));
    push(memoryAGet16(ss, r16[bp] - 14));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(cs);
    yield* sub_6441();
    sp += 0x0008;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x6e51:
    if (memoryAGet16(ss, r16[bp] - 2) < 0x00c8)
        { pc = 0x6e0f; break; }
    r16[ax] = 0x00c8;
    push(r16[ax]);
    r16[ax] = 0x006d;
    push(r16[ax]);
    r16[ax] = 0x007c;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x05da);
    sp += 0x0008;
    es = memoryAGet16(ds, 0xa071);
    r16[ax] = memoryAGet16(es, 0x0002);
    r16[ax] += 0x0007;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet16(ds, 0xa059, r16[ax]);
    r16[ax] += 0x0003;
    r16[ax] &= 0xfffe;
    memoryASet16(ds, 0xa059, r16[ax]);
    r16[dx] = 0x0064;
    imul16(r16[dx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x6eb5; break; }
  case 0x6e9b:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    r16[ax] += 0xa05b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x6eb5:
    if (memoryAGet16(ss, r16[bp] - 4) < 0x0008)
        { pc = 0x6e9b; break; }
    r16[ax] = memoryAGet16(ds, 0x9fef);
    memoryASet16(ds, 0xa06f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x9fed);
    memoryASet16(ds, 0xa071, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x6f3a; break; }
  case 0x6ece:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx]++;
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 420;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    imul16(memoryAGet16(ds, 0xa059));
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[dx] = r16[bp] - 420;
    r16[bx] += r16[dx];
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa071);
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = memoryAGet16(ds, 0xa071);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 420;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[dx] = memoryAGet16(ds, 0xa05b);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 12));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(cs);
    yield* sub_6441();
    sp += 0x0008;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x6f3a:
    if (memoryAGet16(ss, r16[bp] - 2) < 0x0064)
        { pc = 0x6ece; break; }
    memoryASet16(ss, r16[bp] - 4, 0x0001);
    { pc = 0x6f7b; break; }
  case 0x6f47:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx]--;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41051);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41051);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    ds = memoryAGet16(ss, r16[bp] - 16);
    es = memoryAGet16(ss, r16[bp] - 18);
    r16[cx] = memoryAGet16(ss, r16[bp] - 6);
    flags.carry = 0;
    r16[si] = 0;
    flags.carry = false;
    r16[di] = 0;
  case 0x6f6e:
    r8[al] = lodsb_DSSI();
    r8[al] = rcr8(r8[al], 0x01);
    stosb_ESDI(r8[al]);
    if (--r16[cx])
        { pc = 0x6f6e; break; }
    r16[ax] = ss;
    ds = r16[ax];
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x6f7b:
    if (memoryAGet16(ss, r16[bp] - 4) < 0x0008)
        { pc = 0x6f47; break; }
    r8[al] = memoryAGet(ds, 0xa54e);
    memoryASet(ds, 0x0218, r8[al]);
    memoryASet(ds, 0x0229, r8[al]);
    memoryASet(ds, 0x0218, r8[al]);
    r16[ax] = ds;
    es = r16[ax];
    r16[dx] = 0x0208;
    r16[ax] = 0x1002;
    interrupt(0x10);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x6fad; break; }
  case 0x6fa0:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_5e05();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x6fad:
    if (memoryAGet16(ss, r16[bp] - 2) < 0x0004)
        { pc = 0x6fa0; break; }
    r16[ax] = 0;
    memoryASet16(ds, 0x746a, r16[ax]);
    memoryASet16(ds, 0x7470, r16[ax]);
    memoryASet16(ds, 0x746e, 0xffff);
    push(cs);
    yield* sub_618c();
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x6fe0; break; }
  case 0x6fcc:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[ax] += 0xa04b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x6fe0:
    if (memoryAGet16(ss, r16[bp] - 2) < 0x0004)
        { pc = 0x6fcc; break; }
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x7001; break; }
  case 0x6fed:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    r16[ax] += 0xa05b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x7001:
    if (memoryAGet16(ss, r16[bp] - 4) < 0x0008)
        { pc = 0x6fed; break; }
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x7014; break; }
    push(cs);
    yield* sub_67d5();
  case 0x7014:
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x7026; break; }
    push(cs);
    yield* sub_6ab4();
    memoryASet16(ss, r16[bp] - 20, 0x0001);
  case 0x7026:
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x9fed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x9fef;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x0040;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x05da);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f082(); assert(cs == 0x05da);
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x05da);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x05da);
    if (memoryAGet(ds, 0xa545))
        { pc = 0x7076; break; }
    { pc = 0x7110; break; }
  case 0x7076:
    if (memoryAGet(ds, 0xa545) != 0x3b)
        { pc = 0x7088; break; }
    push(cs); cs = 0x0b02; yield* sub_b9c5(); assert(cs == 0x05da);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x7088:
    if (memoryAGet16(ss, r16[bp] - 20))
        { pc = 0x70eb; break; }
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x05da);
    r16[ax] = 0x006d;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x006d;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f28c(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b4));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x05da);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x05da);
    if (!memoryAGet16(ds, 0x7a72))
        { pc = 0x70eb; break; }
    memoryASet16(ds, 0x7a70, 0x0005);
    memoryASet16(ds, 0x474a, 0x0002);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x05da);
    push(cs); cs = 0x07b1; yield* sub_7b73(); assert(cs == 0x05da);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x70eb:
    push(cs); cs = 0x1c76; yield* sub_1ece2(); assert(cs == 0x05da);
    if (!memoryAGet16(ds, 0x474a))
        { pc = 0x7103; break; }
    memoryASet16(ds, 0x7a70, 0x0005);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x7103:
    if (!memoryAGet16(ds, 0xa53b))
        { pc = 0x7110; break; }
    memoryASet16(ds, 0x7a70, 0x0006);
  case 0x7110:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_7116() // 05da:1376 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    r16[dx] = 0x4000;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xa073;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa073);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    r16[di] = 0x0001;
    { pc = 0x7178; break; }
  case 0x7141:
    memoryASet16(ss, r16[bp] - 2, 0x0001);
    { pc = 0x716f; break; }
  case 0x7148:
    r16[si] = 0;
    { pc = 0x7166; break; }
  case 0x714c:
    if (!(r16[di] & r16[si]))
        { pc = 0x715b; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 6); es = memoryAGet16(ss, r16[bp] - 4);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    memoryASet(es, r16[bx], r8[al]);
    { pc = 0x7162; break; }
  case 0x715b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6); es = memoryAGet16(ss, r16[bp] - 4);
    memoryASet(es, r16[bx], 0x00);
  case 0x7162:
    r16[si]++;
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x7166:
    if (r16[si] < 0x0100)
        { pc = 0x714c; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) << 1);
  case 0x716f:
    if (memoryAGet16(ss, r16[bp] - 2) < 0x0100)
        { pc = 0x7148; break; }
    r16[di] <<= 1;
  case 0x7178:
    if (r16[di] < 0x0100)
        { pc = 0x7141; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_7184() // 05da:13e4 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x002a;
    push(r16[si]);
    push(r16[di]);
    push(cs);
    yield* sub_7116();
    memoryASet16(ss, r16[bp] - 22, 0x0002);
    memoryASet16(ss, r16[bp] - 24, 0xe630);
    push(memoryAGet16(ss, r16[bp] - 22));
    push(memoryAGet16(ss, r16[bp] - 24));
    r16[ax] = 0xa52d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa52d);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, 0x0000);
    es = memoryAGet16(ss, r16[bp] - 26);
    r16[di] = memoryAGet16(ss, r16[bp] - 28);
    memoryASet16(ss, r16[bp] - 10, 0x000a);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    memoryASet16(ss, r16[bp] - 6, 0x0b33);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
    memoryASet16(ss, r16[bp] - 16, 0x0000);
    memoryASet16(ss, r16[bp] - 2, 0x00c7);
    { pc = 0x739b; break; }
  case 0x71de:
    push(es);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    r16[ax] = 0x0140;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f4ad(); assert(cs == 0x05da);
    sp += 0x0008;
    es = pop();
    memoryASet16(ss, r16[bp] - 28, r16[di]);
    memoryASet16(ss, r16[bp] - 26, es);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 26);
    r16[dx] = memoryAGet16(ss, r16[bp] - 28);
    memoryASet16(ds, r16[bx] + 41487, r16[ax]);
    memoryASet16(ds, r16[bx] + 41485, r16[dx]);
    r16[ax] = 0;
    r16[dx] = 0x0002;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ss, r16[bp] - 10));
    push(memoryAGet16(ss, r16[bp] - 12));
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    r8[cl] = 0x0b;
    push(cs); cs = 0x01ed; yield* sub_5064(); assert(cs == 0x05da);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r8[cl] = 0x0b;
    push(cs); cs = 0x01ed; yield* sub_5064(); assert(cs == 0x05da);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 41085, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    r16[ax] = 0x000a;
    r16[dx] = 0x8000;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
    memoryASet16(ss, r16[bp] - 20, 0x0000);
    flags.carry = memoryAGet16(ss, r16[bp] - 16) + r16[ax] >= 0x10000;
    memoryASet16(ss, r16[bp] - 16, memoryAGet16(ss, r16[bp] - 16) + r16[ax]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + (0x0000 + flags.carry));
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] >>= 1;
    r16[dx] = 0x00a0;
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 38, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    r16[dx] >>= 1;
    r16[dx] >>= 1;
    r16[dx] >>= 1;
    r16[ax] += r16[dx];
    memoryASet16(ss, r16[bp] - 34, r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 38);
    r8[al] &= 0x07;
    memoryASet(ss, r16[bp] - 31, r8[al]);
    r16[ax] = 0xd18c;
    stosw_ESDI(r16[ax]);
    r16[ax] = 0xd08e;
    stosw_ESDI(r16[ax]);
    r16[ax] = 0xc781;
    stosw_ESDI(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 34);
    stosw_ESDI(r16[ax]);
    r16[ax] = 0xc030;
    stosw_ESDI(r16[ax]);
    memoryASet16(ss, r16[bp] - 42, 0xffff);
    r16[si] = 0;
    { pc = 0x7333; break; }
  case 0x72b3:
    r16[dx] = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(ss, r16[bp] - 20);
    r8[cl] = 0x0b;
    push(cs); cs = 0x01ed; yield* sub_5064(); assert(cs == 0x05da);
    memoryASet16(ss, r16[bp] - 36, r16[ax]);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet(ss, r16[bp] - 29, r8[al]);
    r8[al] = memoryAGet(ss, r16[bp] - 36);
    r8[al] &= 0x07;
    memoryASet(ss, r16[bp] - 30, r8[al]);
    r8[ah] = 0x00;
    r16[dx] = 0x0007;
    r16[dx] -= r16[ax];
    r16[dx] <<= 1;
    r16[dx] <<= 1;
    r16[dx] <<= 1;
    r16[dx] += 0x0007;
    r8[al] = memoryAGet(ss, r16[bp] - 31);
    r8[ah] = 0x00;
    r16[dx] -= r16[ax];
    r8[cl] = 0x08;
    r16[dx] <<= r8[cl];
    memoryASet16(ss, r16[bp] - 40, r16[dx]);
    r8[al] = memoryAGet(ss, r16[bp] - 29);
    r8[ah] = 0x00;
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 42))
        { pc = 0x730c; break; }
    r16[ax] = 0x5e8a;
    stosw_ESDI(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 29);
    stosb_ESDI(r8[al]);
    r8[al] = memoryAGet(ss, r16[bp] - 29);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 42, r16[ax]);
  case 0x730c:
    r16[ax] = 0x870a;
    stosw_ESDI(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 40);
    stosw_ESDI(r16[ax]);
    memoryASet(ss, r16[bp] - 31, memoryAGet(ss, r16[bp] - 31) + 1);
    if (memoryAGet(ss, r16[bp] - 31) != 0x08)
        { pc = 0x7328; break; }
    memoryASet(ss, r16[bp] - 31, 0x00);
    r16[ax] = 0x30aa;
    stosw_ESDI(r16[ax]);
    r8[al] = 0xc0;
    stosb_ESDI(r8[al]);
  case 0x7328:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    flags.carry = memoryAGet16(ss, r16[bp] - 20) + r16[ax] >= 0x10000;
    memoryASet16(ss, r16[bp] - 20, memoryAGet16(ss, r16[bp] - 20) + r16[ax]);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + (0x0000 + flags.carry));
    r16[si]++;
  case 0x7333:
    if (r16[si] >= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x733b; break; }
    { pc = 0x72b3; break; }
  case 0x733b:
    if (!memoryAGet(ss, r16[bp] - 31))
        { pc = 0x7344; break; }
    r8[al] = 0xaa;
    stosb_ESDI(r8[al]);
  case 0x7344:
    r16[ax] = 0xd18e;
    stosw_ESDI(r16[ax]);
    r8[al] = 0xcb;
    stosb_ESDI(r8[al]);
    r16[ax] = r16[di];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[bx] = es;
    r16[ax] += r16[bx];
    es = r16[ax];
    r16[di] &= 0x000f;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    flags.carry = memoryAGet16(ss, r16[bp] - 12) < r16[ax];
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) - r16[ax]);
    memoryASet16(ss, r16[bp] - 10, memoryAGet16(ss, r16[bp] - 10) - (0x0000 + flags.carry));
    push(es);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 42324));
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += 0x8000;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x05da);
    sp += 0x0008;
    es = pop();
    if (memoryAGet(ds, 0xa545))
        { pc = 0x73a4; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - 1);
  case 0x739b:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x0000))
        { pc = 0x73a4; break; }
    { pc = 0x71de; break; }
  case 0x73a4:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_73aa() // 05da:160a +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    { pc = 0x7422; break; }
  case 0x73b3:
    r8[dl] = memoryAGet(ds, r16[si]);
    if (r8s[dl] < signed8(0x41))
        { pc = 0x73c7; break; }
    if (r8s[dl] > signed8(0x5a))
        { pc = 0x73c7; break; }
    r8[al] = r8[dl];
    r8[al] += 0xdf;
    r8[dl] = r8[al];
    { pc = 0x741f; break; }
  case 0x73c7:
    if (r8s[dl] < signed8(0x61))
        { pc = 0x73d9; break; }
    if (r8s[dl] > signed8(0x7a))
        { pc = 0x73d9; break; }
    r8[al] = r8[dl];
    r8[al] += 0xd9;
    r8[dl] = r8[al];
    { pc = 0x741f; break; }
  case 0x73d9:
    if (r8[dl] != 0x2e)
        { pc = 0x73e2; break; }
    r8[dl] = 0x54;
    { pc = 0x741f; break; }
  case 0x73e2:
    if (r8[dl] != 0x2c)
        { pc = 0x73eb; break; }
    r8[dl] = 0x55;
    { pc = 0x741f; break; }
  case 0x73eb:
    if (r8[dl] != 0x2d)
        { pc = 0x73f4; break; }
    r8[dl] = 0x56;
    { pc = 0x741f; break; }
  case 0x73f4:
    if (r8[dl] != 0x22)
        { pc = 0x73fd; break; }
    r8[dl] = 0x57;
    { pc = 0x741f; break; }
  case 0x73fd:
    if (r8[dl] != 0x20)
        { pc = 0x7406; break; }
    r8[dl] = 0x58;
    { pc = 0x741f; break; }
  case 0x7406:
    if (r8[dl] != 0x21)
        { pc = 0x740f; break; }
    r8[dl] = 0x59;
    { pc = 0x741f; break; }
  case 0x740f:
    if (r8[dl] != 0x27)
        { pc = 0x7418; break; }
    r8[dl] = 0x5a;
    { pc = 0x741f; break; }
  case 0x7418:
    if (r8[dl] == 0x0a)
        { pc = 0x741f; break; }
    r8[dl] = 0x54;
  case 0x741f:
    memoryASet(ds, r16[si], r8[dl]);
    r16[si]++;
  case 0x7422:
    if (memoryAGet(ds, r16[si]))
        { pc = 0x73b3; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_742a() // 05da:168a +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0056;
    push(r16[si]);
    memoryASet16(ds, 0xa533, 0x0000);
    memoryASet16(ds, 0xa531, 0x0150);
    memoryASet16(ds, 0xa535, 0x0001);
    memoryASet16(ds, 0xa7b4, 0x0000);
    memoryASet16(ds, 0xa7b0, 0x0000);
    memoryASet16(ss, r16[bp] - 2, 0x20d1);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    memoryASet16(ds, 0xa07b, 0x0000);
    { pc = 0x74b6; break; }
  case 0x7461:
    r16[ax] = r16[bp] - 86;
    r16[si] = r16[ax];
  case 0x7466:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 5, r8[al]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    memoryASet(ds, r16[si], r8[al]);
    r16[si]++;
    if (memoryAGet(ss, r16[bp] - 5) == 0x0a)
        { pc = 0x7481; break; }
    if (memoryAGet(ss, r16[bp] - 5))
        { pc = 0x7466; break; }
  case 0x7481:
    memoryASet(ds, r16[si], 0x00);
    r16[ax] = r16[bp] - 86;
    push(r16[ax]);
    push(cs);
    yield* sub_73aa();
    sp += 0x0002;
    r16[ax] = r16[bp] - 86;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa535);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ds, 0xa7b4, memoryAGet16(ds, 0xa7b4) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa535);
    memoryASet16(ds, 0xa07b, memoryAGet16(ds, 0xa07b) + r16[ax]);
    memoryASet16(ds, 0xa535, 0x0000);
  case 0x74b6:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet(es, r16[bx]))
        { pc = 0x7461; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b4));
    r16[ax] = 0xa075;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0104;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    push(memoryAGet16(ds, 0xa7b4));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa075));
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7ae));
    push(cs); cs = 0x01ed; yield* sub_3c10(); assert(cs == 0x05da);
    sp += 0x000a;
    memoryASet16(ds, 0xa7b4, 0x0000);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x00c8;
    push(r16[ax]);
    r16[ax] = 0x0140;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f57e(); assert(cs == 0x05da);
    sp += 0x000a;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_7515() // 05da:1775 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    r16[dx] = 0;
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    memoryASet16(ds, 0xa53f, r16[ax]);
    memoryASet16(ds, 0xa53d, r16[dx]);
    r16[ax] = r16[dx];
    memoryASet16(ds, 0xa54c, r16[ax]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0802;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x7644; break; }
  case 0x754e:
    r16[si] = 0x00c7;
    { pc = 0x75ba; break; }
  case 0x7553:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] -= memoryAGet16(ds, r16[bx] + 41085);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) < signed16(0x0000))
        { pc = 0x756d; break; }
    if (r16[ax] < memoryAGet16(ds, 0xa07b))
        { pc = 0x7575; break; }
  case 0x756d:
    memoryASet16(ds, 0xa546, 0x0000);
    { pc = 0x7580; break; }
  case 0x7575:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[dx] = 0x002a;
    imul16(r16[dx]);
    memoryASet16(ds, 0xa546, r16[ax]);
  case 0x7580:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 41487);
    r16[dx] = memoryAGet16(ds, r16[bx] + 41485);
    memoryASet16(ds, 0xa079, r16[ax]);
    memoryASet16(ds, 0xa077, r16[dx]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ds, 0xa021);
    ds = memoryAGet16(ds, 0xa073);
    push(r16[bp]);
    r16[bp] = memoryAGet16(ss, 0xa546);
    r16[ax] = memoryAGet16(ss, 0xa075);
    r8[bh] = 0;
    flags.interrupts = 0;
    push(cs); cs = memoryAGet16(ss, 0xa079); indirectCall(cs, memoryAGet16(ss, 0xa077)); assert(cs == 0x05da); // 05da:180e
    flags.interrupts = 1;
    r16[bp] = pop();
    r16[ax] = ss;
    ds = r16[ax];
    r16[si]--;
  case 0x75ba:
    if (r16s[si] >= 0)
        { pc = 0x7553; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa021));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    memoryASet16(ds, 0x7468, memoryAGet16(ds, 0x7468) ^ 0x0001);
    r16[ax] = memoryAGet16(ds, 0x7468);
    r8[cl] = 0x0f;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xa021, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ds, 0xa548);
    r16[dx] = memoryAGet16(ds, 0xa54c);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0xa54c, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    if (memoryAGet16(ds, 0xa54c) <= 0x0014)
        { pc = 0x7614; break; }
    memoryASet16(ds, 0xa54c, 0x0014);
  case 0x7614:
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ds, 0xa54c, memoryAGet16(ds, 0xa54c) & 0x0003);
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x05da);
    if (!r16[ax])
        { pc = 0x763d; break; }
    if (memoryAGet(ds, 0xa545) == 0x3b)
        { pc = 0x763d; break; }
    memoryASet(ds, 0xa545, 0x39);
  case 0x763d:
    if (memoryAGet(ds, 0xa545))
        { pc = 0x7652; break; }
  case 0x7644:
    r16[ax] = memoryAGet16(ds, 0xa07b);
    r16[ax] += 0x0190;
    if (r16[ax] < memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x7652; break; }
    { pc = 0x754e; break; }
  case 0x7652:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_7658() // 05da:18b8 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = memoryAGet(ds, 0xa54e);
    memoryASet(ds, 0x4ec4, r8[al]);
    r16[ax] = ds;
    es = r16[ax];
    r16[dx] = 0x4eb4;
    r16[ax] = 0x1002;
    interrupt(0x10);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x002a;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = 0;
    memoryASet16(ds, 0xa021, r16[ax]);
    memoryASet16(ds, 0x7468, r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15ec3(); assert(cs == 0x05da);
    r16[ax] = 0x0005;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    memoryASet16(ds, 0xa550, 0x0002);
    push(cs);
    yield* sub_742a();
    memoryASet16(ds, 0xa550, 0x0000);
    r16[ax] = 0x006c;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    memoryASet16(ds, 0xa7b4, 0x8000);
    r16[ax] = 0x006c;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f28c(); assert(cs == 0x05da);
    sp += 0x0006;
    push(cs); cs = 0x1493; yield* sub_15ec3(); assert(cs == 0x05da);
    r8[al] = memoryAGet(ds, 0xa54e);
    memoryASet(ds, 0x01fe, r8[al]);
    r16[ax] = ds;
    es = r16[ax];
    r16[dx] = 0x01ee;
    r16[ax] = 0x1002;
    interrupt(0x10);
    memoryASet16(ds, 0xa7b4, 0x0000);
    push(cs);
    yield* sub_7184();
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x771a; break; }
    r16[ax] = 0x000c;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_ab67(); assert(cs == 0x05da);
    sp += 0x0002;
    push(cs);
    yield* sub_7515();
    push(cs); cs = 0x08aa; yield* sub_ab32(); assert(cs == 0x05da);
  case 0x771a:
    r16[ax] = 0xa52d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0xa073;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0xa075;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x0040;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x05da);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f082(); assert(cs == 0x05da);
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x05da);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x05da);
    push(cs);
    yield* sub_5dab();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_776a() // 05da:19ca +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xa7b0, 0x0000);
    r16[ax] = 0x006d;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[ax] = 0x006d;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f28c(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = 0x00e0;
    push(r16[ax]);
    r16[ax] = 0x002a;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(memoryAGet16(ds, 0xa7b4));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x05da);
    sp += 0x0008;
    r16[ax] = 0;
    push(r16[ax]);
    r16[dx] = 0x01a4;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x164d; yield* sub_17462(); assert(cs == 0x05da);
    sp += 0x0006;
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x05da);
    push(cs);
    yield* sub_5dab();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_77d1() // 05da:1a31 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(cs); cs = 0x07b1; yield* sub_7b73(); assert(cs == 0x05da);
    r16[ax] = r16[si];
    r16[ax] += 0x128a;
    r16[si] = r16[ax];
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x05da);
    sp += 0x0002;
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, 0x7a68, r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ds, 0xa541, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa541));
    r16[ax] = 0xa543;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x05da);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0xa543;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x05da);
    sp += 0x0004;
    push(memoryAGet16(ds, 0xa541));
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa543));
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_561c(); assert(cs == 0x05da);
    sp += 0x000a;
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    push(memoryAGet16(ds, 0xa541));
    push(memoryAGet16(ds, 0xa543));
    push(cs); cs = 0x164d; yield* sub_17251(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x07b1; yield* sub_80a1(); assert(cs == 0x05da);
    sp += 0x0002;
    if (!memoryAGet16(ds, 0xa52f))
        { pc = 0x788a; break; }
    push(cs);
    yield* sub_78b3();
  case 0x788a:
    push(cs); cs = 0x08aa; yield* sub_ac66(); assert(cs == 0x05da);
    push(cs); cs = 0x164d; yield* sub_17271(); assert(cs == 0x05da);
    r16[ax] = 0xa543;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x05da);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x05da);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x05da);
    push(cs);
    yield* sub_5dab();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_78b3() // 05da:1b13 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x001a;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19743(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa546);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    r16[di] = 0x43c4;
    { pc = 0x7984; break; }
  case 0x78de:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0033;
    memoryASet16(ds, 0xa535, r16[ax]);
    memoryASet16(ds, 0xa537, 0x0018);
    push(r16[di]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x05da);
    sp += 0x0002;
    memoryASet16(ds, 0xa537, 0x0098);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x7924; break; }
  case 0x7907:
    r16[ax] = 0x0047;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa535);
    r16[ax]++;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa537));
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x05da);
    sp += 0x0006;
    memoryASet16(ds, 0xa537, memoryAGet16(ds, 0xa537) + 0x0008);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x7924:
    r16[ax] = memoryAGet16(ds, r16[di] + 62);
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x7907; break; }
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 26;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[di] + 60));
    push(memoryAGet16(ds, r16[di] + 58));
    push(cs); cs = 0x01ed; yield* sub_3b6b(); assert(cs == 0x05da);
    sp += 0x0008;
    r16[ax] = r16[bp] - 26;
    r16[si] = r16[ax];
    { pc = 0x7950; break; }
  case 0x7949:
    r8[al] = memoryAGet(ds, r16[si]);
    r8[al] += 0x51;
    memoryASet(ds, r16[si], r8[al]);
    r16[si]++;
  case 0x7950:
    if (memoryAGet(ds, r16[si]))
        { pc = 0x7949; break; }
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 26;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x05da); break;
        default:
            stop("ind 05da:1bc2");
    }
    sp += 0x0008;
    r16[ax] = 0x0128;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[ax] = r16[bp] - 26;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x05da);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    r16[di] += 0x0040;
  case 0x7984:
    if (memoryAGet16(ss, r16[bp] - 2) >= 0x0008)
        { pc = 0x798d; break; }
    { pc = 0x78de; break; }
  case 0x798d:
    memoryASet(ds, 0x6025, 0x0f);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_799e() // 05da:1bfe +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0046;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x0242;
    push(r16[ax]);
    r16[ax] = r16[bp] - 70;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x05da);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 6, 0xffff);
    { pc = 0x7a77; break; }
  case 0x79d5:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r8[cl] = 0x06;
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ds, r16[bx] + 17408);
    r16[dx] = memoryAGet16(ds, r16[bx] + 17406);
    if (r16s[ax] < signed16(memoryAGet16(ss, r16[bp] - 10)))
        { pc = 0x7a17; break; }
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x79f0; break; }
    if (r16[dx] < memoryAGet16(ss, r16[bp] - 12))
        { pc = 0x7a17; break; }
  case 0x79f0:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r8[cl] = 0x06;
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ds, r16[bx] + 17408);
    r16[dx] = memoryAGet16(ds, r16[bx] + 17406);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x7a74; break; }
    if (r16[dx] != memoryAGet16(ss, r16[bp] - 12))
        { pc = 0x7a74; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ds, r16[bx] + 17410);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x7a74; break; }
  case 0x7a17:
    memoryASet16(ss, r16[bp] - 4, 0x0008);
    { pc = 0x7a40; break; }
  case 0x7a1e:
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[si]--;
    r8[cl] = 0x06;
    r16[si] <<= r8[cl];
    r16[si] += 0x43c4;
    r16[ax] = ds;
    r16[di] = memoryAGet16(ss, r16[bp] - 4);
    r16[di] <<= r8[cl];
    r16[di] += 0x43c4;
    push(ds);
    es = pop();
    push(r16[ax]);
    ds = r16[ax];
    r16[cx] = 0x0020;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    ds = pop();
  case 0x7a40:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x7a1e; break; }
    r16[si] = r16[bp] - 70;
    r16[ax] = ss;
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    r8[cl] = 0x06;
    r16[di] <<= r8[cl];
    r16[di] += 0x43c4;
    push(ds);
    es = pop();
    push(ds);
    ds = r16[ax];
    r16[cx] = 0x0020;
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    ds = pop();
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ds, 0xa539, 0x0001);
    { pc = 0x7a80; break; }
  case 0x7a74:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x7a77:
    if (memoryAGet16(ss, r16[bp] - 2) >= 0x0008)
        { pc = 0x7a80; break; }
    { pc = 0x79d5; break; }
  case 0x7a80:
    if (memoryAGet16(ss, r16[bp] - 6) == 0xffff)
        { pc = 0x7aef; break; }
    memoryASet16(ds, 0xa52f, 0x0001);
    memoryASet16(ds, 0x7a68, 0x0013);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x07b1; yield* sub_80a1(); assert(cs == 0x05da);
    sp += 0x0002;
    push(cs);
    yield* sub_78b3();
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x05da);
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x05da);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0033;
    memoryASet16(ds, 0xa535, r16[ax]);
    memoryASet16(ds, 0xa537, 0x0018);
    r16[ax] = 0x0070;
    push(r16[ax]);
    r16[ax] = 0x0039;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r8[cl] = 0x06;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x43c4;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa535));
    push(memoryAGet16(ds, 0xa537));
    push(cs); cs = 0x1b1e; yield* sub_1c3e5(); assert(cs == 0x05da);
    sp += 0x000e;
    memoryASet16(ds, 0xa52f, 0x0000);
  case 0x7aef:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_7af5() // 05da:1d55 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xa52f, 0x0001);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x05da);
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs);
    yield* sub_77d1();
    sp += 0x0002;
    memoryASet16(ds, 0xa52f, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_7b16() // 07b1:0006 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0x007c;
    { pc = 0x7b3f; break; }
  case 0x7b1f:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x7b3e; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x07b1);
    sp += 0x0004;
  case 0x7b3e:
    r16[si]++;
  case 0x7b3f:
    if (r16s[si] < signed16(0x0209))
        { pc = 0x7b1f; break; }
    r16[si] = 0x020b;
    { pc = 0x7b6a; break; }
  case 0x7b4a:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x7b69; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x07b1);
    sp += 0x0004;
  case 0x7b69:
    r16[si]++;
  case 0x7b6a:
    if (r16s[si] < signed16(0x127f))
        { pc = 0x7b4a; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_7b73() // 07b1:0063 +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x0056;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a1a;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x07b1);
    sp += 0x0006;
    memoryASet16(ds, 0x7a56, 0x0000);
    memoryASet16(ds, 0x7a54, 0x4e20);
    memoryASet16(ds, 0x7a6a, 0x0003);
    memoryASet16(ds, 0x7a58, 0x0005);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_7ba3() // 07b1:0093 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x07b1);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    r16[ax] = 0x024e;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x07b1);
    r16[ax] = 0;
    push(r16[ax]);
    r16[dx] = 0x0118;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x164d; yield* sub_17462(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_7f76() // 07b1:0466 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_7b73();
    memoryASet(ds, 0xa7e6, memoryAGet(ds, 0xa7e6) - 1);
    memoryASet(ds, 0x7aec, memoryAGet(ds, 0x7aec) >> 1);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x07b1);
    memoryASet(ds, 0x7aec, memoryAGet(ds, 0x7aec) << 1);
    memoryASet(ds, 0xa7e6, memoryAGet(ds, 0xa7e6) + 1);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_7f94() // 07b1:0484 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa7eb);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x803f; break; }
  case 0x7fb4:
    r16[si] = 0;
    { pc = 0x8033; break; }
  case 0x7fb8:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] &= 0x00ff;
    r16[di] = r16[ax];
    if (r16[di] < 0x0001)
        { pc = 0x802b; break; }
    if (r16[di] > 0x0011)
        { pc = 0x802b; break; }
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31262))
        { pc = 0x802b; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(es, r16[bx], 0x0000);
    if (memoryAGet16(ss, r16[bp] - 8) != 0x00d0)
        { pc = 0x8004; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7e9);
    memoryASet16(es, r16[bx], 0x0000);
    { pc = 0x802b; break; }
  case 0x8004:
    if (memoryAGet16(ss, r16[bp] - 8) != 0x00f0)
        { pc = 0x802b; break; }
    if (memoryAGet16(ds, 0xa7c2) != r16[di])
        { pc = 0x801f; break; }
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[si]);
    push(cs); cs = 0x0f7c; yield* sub_1021b(); assert(cs == 0x07b1);
    sp += 0x0004;
    { pc = 0x802b; break; }
  case 0x801f:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[si]);
    push(cs); cs = 0x0f7c; yield* sub_101bd(); assert(cs == 0x07b1);
    sp += 0x0004;
  case 0x802b:
    r16[si]++;
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x8033:
    if (r16[si] >= memoryAGet16(ds, 0xa7e4))
        { pc = 0x803c; break; }
    { pc = 0x7fb8; break; }
  case 0x803c:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x803f:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax] >= memoryAGet16(ds, 0xa7e2))
        { pc = 0x804b; break; }
    { pc = 0x7fb4; break; }
  case 0x804b:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8051() // 07b1:0541 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1ef3; yield* sub_1f09f(); assert(cs == 0x07b1);
    memoryASet16(ds, 0xa7c4, 0x0000);
    r16[ax] = 0x07b1;
    push(r16[ax]);
    r16[ax] = 0x0561;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19060(); assert(cs == 0x07b1);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_8071() // 07b1:0561 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xa7c4, memoryAGet16(ds, 0xa7c4) + 1);
    r16[ax] = memoryAGet16(ds, 0xa7c4);
    if (r16[ax] != 0x0002)
        { pc = 0x809f; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f0f2(); assert(cs == 0x07b1);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19060(); assert(cs == 0x07b1);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    memoryASet16(ds, 0xa53f, r16[ax]);
    memoryASet16(ds, 0xa53d, r16[dx]);
  case 0x809f:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_80a1() // 07b1:0591 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, 0x3bd6))
        { pc = 0x80c2; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1eef2(); assert(cs == 0x07b1);
    sp += 0x0002;
    memoryASet16(ds, 0x7a6c, 0x0002);
    { pc = 0x80ce; break; }
  case 0x80c2:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1eef2(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x80ce:
    push(memoryAGet16(ds, 0x7a68));
    push(cs); cs = 0x1493; yield* sub_15b90(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_185d2(); assert(cs == 0x07b1);
    push(cs); cs = 0x1493; yield* sub_15e4a(); assert(cs == 0x07b1);
    push(cs); cs = 0x107c; yield* sub_107c3(); assert(cs == 0x07b1);
    if (memoryAGet16(ds, 0xa7ed))
        { pc = 0x80f4; break; }
    push(cs);
    yield* sub_7f94();
  case 0x80f4:
    push(cs); cs = 0x1841; yield* sub_18728(); assert(cs == 0x07b1);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_18414(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1493; yield* sub_15458(); assert(cs == 0x07b1);
    if (!r16[si])
        { pc = 0x815f; break; }
    if (!memoryAGet16(ds, 0xa52f))
        { pc = 0x8121; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x07b1);
    sp += 0x0002;
    { pc = 0x815f; break; }
  case 0x8121:
    if (!memoryAGet16(ds, 0x3bd6))
        { pc = 0x8136; break; }
    r16[ax] = 0x0299;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x07b1);
    sp += 0x0002;
    { pc = 0x815f; break; }
  case 0x8136:
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 6490));
    push(memoryAGet16(ds, r16[bx] + 6488));
    push(ds);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x815f:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_18414(); assert(cs == 0x07b1);
    sp += 0x0002;
    if (memoryAGet16(ds, 0xa7ef))
        { pc = 0x817a; break; }
    if (!r16[si])
        { pc = 0x817a; break; }
    push(cs);
    yield* sub_8051();
  case 0x817a:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_817d() // 07b1:066d +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    push(cs); cs = 0x174b; yield* sub_18396(); assert(cs == 0x07b1);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x81b0; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0000))
        { pc = 0x81a2; break; }
    if (memoryAGet16(ss, r16[bp] - 8) >= 0x0800)
        { pc = 0x81b0; break; }
  case 0x81a2:
    memoryASet16(ds, 0xa7b8, 0x0000);
    memoryASet16(ds, 0xa7b6, 0x0005);
    { pc = 0x8219; break; }
  case 0x81b0:
    memoryASet16(ds, 0xa7b8, 0x0000);
    memoryASet16(ds, 0xa7b6, 0x0000);
    r16[si] = 0;
    { pc = 0x8214; break; }
  case 0x81c0:
    r16[ax] = r16[si];
    r16[ax] += 0x0073;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x07b1);
    sp += 0x0002;
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    r8[dl] = ~r8[dl];
    es = r16[ax];
    memoryASet(es, r16[si] + 115, memoryAGet(es, r16[si] + 115) & r8[dl]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31699))
        { pc = 0x81ff; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7bd3;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x07b1);
    sp += 0x0004;
    { pc = 0x8213; break; }
  case 0x81ff:
    memoryASet16(ds, 0xa7ef, 0x0000);
    memoryASet16(ds, 0xa7b8, 0x0000);
    memoryASet16(ds, 0xa7b6, 0x0005);
    { pc = 0x8219; break; }
  case 0x8213:
    r16[si]++;
  case 0x8214:
    if (r16s[si] < signed16(0x0006))
        { pc = 0x81c0; break; }
  case 0x8219:
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    if (!memoryAGet16(ds, 0x7bd3))
        { pc = 0x8246; break; }
    r16[ax] = 0x0073;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x07b1);
    sp += 0x0006;
    { pc = 0x8252; break; }
  case 0x8246:
    memoryASet16(ds, 0xa7b8, 0x0000);
    memoryASet16(ds, 0xa7b6, 0x0005);
  case 0x8252:
    r8[al] = memoryAGet(ds, 0x7aec);
    r8[al] = ~r8[al];
    r16[dx] = 0x2c27;
    es = r16[dx];
    memoryASet(es, 0x0073, memoryAGet(es, 0x0073) & r8[al]);
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa533, memoryAGet16(ds, 0xa533) + 0x0030);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x056a; yield* sub_56ac(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa7dc);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] >>= 1;
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] = 0x0006;
    r16[dx] = 0;
    div16(r16[bx]);
    r16[dx] = 0;
    memoryASet16(ds, 0xa7c0, r16[dx]);
    memoryASet16(ds, 0xa7be, r16[ax]);
    memoryASet16(ds, 0xa7bc, r16[dx]);
    memoryASet16(ds, 0xa7ba, r16[ax]);
    r16[ax] |= memoryAGet16(ds, 0xa7bc);
    if (r16[ax])
        { pc = 0x82f4; break; }
    r16[ax] = memoryAGet16(ds, 0xa7b6);
    r16[ax] |= memoryAGet16(ds, 0xa7b8);
    if (r16[ax])
        { pc = 0x82f4; break; }
    memoryASet16(ds, 0xa7b8, 0x0000);
    memoryASet16(ds, 0xa7b6, 0x0005);
    if (!memoryAGet16(ds, 0x7bdd))
        { pc = 0x82ef; break; }
    r16[ax] = 0x0078;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7de);
    r16[ax] += 0x0028;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] -= 0x0018;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x07b1);
    sp += 0x0006;
  case 0x82ef:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
  case 0x82f4:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_82fa() // 07b1:07ea +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    flags.carry = memoryAGet16(ds, 0xa7be) < 0x0001;
    memoryASet16(ds, 0xa7be, memoryAGet16(ds, 0xa7be) - 0x0001);
    r16[ax] = memoryAGet16(ds, 0xa7be);
    memoryASet16(ds, 0xa7c0, memoryAGet16(ds, 0xa7c0) - (0x0000 + flags.carry));
    r16[dx] = memoryAGet16(ds, 0xa7c0);
    r16[ax] |= r16[dx];
    if (r16[ax])
        { pc = 0x8369; break; }
    if (signed16(memoryAGet16(ds, 0xa7b8)) < signed16(0x0000))
        { pc = 0x8322; break; }
    if (signed16(memoryAGet16(ds, 0xa7b8)) > signed16(0x0000))
        { pc = 0x8369; break; }
    if (memoryAGet16(ds, 0xa7b6) > 0x0004)
        { pc = 0x8369; break; }
  case 0x8322:
    r16[ax] = memoryAGet16(ds, 0xa7bc);
    r16[dx] = memoryAGet16(ds, 0xa7ba);
    memoryASet16(ds, 0xa7c0, r16[ax]);
    memoryASet16(ds, 0xa7be, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xa7b6);
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31701))
        { pc = 0x835a; break; }
    r16[ax] = memoryAGet16(ds, 0xa7b6);
    r16[ax] += 0x0074;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7de);
    r16[ax] += 0x0028;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] -= 0x0018;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x07b1);
    sp += 0x0006;
  case 0x835a:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    flags.carry = memoryAGet16(ds, 0xa7b6) + 0x0001 >= 0x10000;
    memoryASet16(ds, 0xa7b6, memoryAGet16(ds, 0xa7b6) + 0x0001);
    memoryASet16(ds, 0xa7b8, memoryAGet16(ds, 0xa7b8) + (0x0000 + flags.carry));
  case 0x8369:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_836b() // 07b1:085b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_8370() // 07b1:0860 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x07b1);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    r16[ax] = 0x029e;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(memoryAGet16(ds, 0x6022));
    push(memoryAGet16(ds, 0x6020));
    push(cs); cs = 0x1b1e; yield* sub_1c3e5(); assert(cs == 0x07b1);
    sp += 0x000e;
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[ax] = -flags.carry;
    r16[ax]++;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x83ff; break; }
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_349f(); assert(cs == 0x07b1);
    sp += 0x0002;
    r16[si] = r16[ax];
    if (r16s[si] < 0)
        { pc = 0x83ff; break; }
    if (r16s[si] > signed16(0x0015))
        { pc = 0x83ff; break; }
    memoryASet16(ds, 0x7a68, r16[si]);
    memoryASet16(ds, 0x7a70, 0x0004);
    r16[ax] = 0x1000;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_17209(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x83ff:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8404() // 07b1:08f4 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(ss);
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x0244;
    push(r16[ax]);
    r16[cx] = 0x000a;
    push(cs); cs = 0x01ed; yield* sub_51b5(); assert(cs == 0x07b1);
    push(cs); cs = 0x164d; yield* sub_17271(); assert(cs == 0x07b1);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x07b1);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0016;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    r16[ax] = 0x02c0;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(memoryAGet16(ds, 0x6022));
    push(memoryAGet16(ds, 0x6020));
    push(cs); cs = 0x1b1e; yield* sub_1c3e5(); assert(cs == 0x07b1);
    sp += 0x000e;
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[ax] = -flags.carry;
    r16[ax]++;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x84f8; break; }
    if (signed8(memoryAGet(ds, 0x7a88)) < signed8(0x30))
        { pc = 0x84f8; break; }
    if (signed8(memoryAGet(ds, 0x7a88)) > signed8(0x39))
        { pc = 0x84f8; break; }
    r8[al] = memoryAGet(ds, 0x7a88);
    memoryASet(ss, r16[bp] - 8, r8[al]);
    r16[ax] = 0x8180;
    push(r16[ax]);
    r16[ax] = 0x8102;
    push(r16[ax]);
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[si] = r16[ax];
    if (r16[si] != 0xffff)
        { pc = 0x84b8; break; }
    r16[ax] = 0x02d7;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x84b8:
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xa7ed;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xa7e0;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7e0));
    push(memoryAGet16(ds, 0xa543));
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_14a70(); assert(cs == 0x07b1);
    sp += 0x000a;
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x84f8:
    push(cs); cs = 0x164d; yield* sub_1728f(); assert(cs == 0x07b1);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8502() // 07b1:09f2 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 6390));
    push(memoryAGet16(ds, r16[bx] + 6388));
    push(ds);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_56ac(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a60;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x07b1);
    sp += 0x0006;
    memoryASet16(ds, 0x7a6a, memoryAGet16(ds, 0x7a6a) - 1);
    if (signed16(memoryAGet16(ds, 0x7a6a)) >= signed16(0x0000))
        { pc = 0x855c; break; }
    { pc = 0x888b; break; }
  case 0x855c:
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x07b1);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0003);
    r16[ax] = 0x02ff;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa535);
    r16[ax] += 0x0016;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 10) >= 0x000f)
        { pc = 0x8596; break; }
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0004);
  case 0x8596:
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += 0x0002;
    memoryASet16(ds, 0xa535, r16[ax]);
    r16[ax] = 0x0317;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0004);
    r16[ax] = memoryAGet16(ds, 0xa535);
    r16[ax] -= 0x0002;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = 0x0321;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x07b1);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
  case 0x85db:
    if (!memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x85e6; break; }
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    { pc = 0x85e9; break; }
  case 0x85e6:
    r16[si] = memoryAGet16(ss, r16[bp] - 2);
  case 0x85e9:
    r16[dx] = memoryAGet16(ds, 0xa53f);
    r16[ax] = memoryAGet16(ds, 0xa53d);
    r8[cl] = 0x04;
    push(cs); cs = 0x01ed; yield* sub_5084(); assert(cs == 0x07b1);
    r16[ax] &= 0x0001;
    r16[ax] |= 0x0000;
    if (!r16[ax])
        { pc = 0x8604; break; }
    r16[di] = 0x000c;
    { pc = 0x8607; break; }
  case 0x8604:
    r16[di] = 0x0001;
  case 0x8607:
    push(r16[di]);
    push(r16[si]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] += 0x000c;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] += 0x000d;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0005;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0005;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    r16[ax] = 0x000f;
    push(r16[ax]);
    push(r16[si]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000c;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000d;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0004;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += 0x0005;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0004;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0005;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x000b;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x07b1);
    sp += 0x0008;
    if (memoryAGet(ds, 0xa545) != 0x01)
        { pc = 0x8816; break; }
    memoryASet16(ds, 0x7a68, 0x0000);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x07b1);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x8816:
    r16[ax] = 0xa7c6;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16e8e(); assert(cs == 0x07b1);
    sp += 0x0004;
    if (memoryAGet16(ds, 0xa7c6))
        { pc = 0x8841; break; }
    if (memoryAGet16(ds, 0xa7c8))
        { pc = 0x8841; break; }
    if (memoryAGet(ds, 0xa545) == 0x1c)
        { pc = 0x8841; break; }
    if (memoryAGet(ds, 0xa545) != 0x39)
        { pc = 0x8859; break; }
  case 0x8841:
    if (!memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x888b; break; }
    memoryASet16(ds, 0x7a68, 0x0000);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 6 bytes
  case 0x8859:
    if (memoryAGet16(ds, 0xa7d0) == 0xffff)
        { pc = 0x8867; break; }
    if (memoryAGet(ds, 0xa545) != 0x48)
        { pc = 0x886f; break; }
  case 0x8867:
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x85db; break; }
  case 0x886f:
    if (memoryAGet16(ds, 0xa7d0) == 0x0001)
        { pc = 0x8880; break; }
    if (memoryAGet(ds, 0xa545) == 0x50)
        { pc = 0x8880; break; }
    { pc = 0x85db; break; }
  case 0x8880:
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x85db; break; }
    // gap 3 bytes
  case 0x888b:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8891() // 07b1:0d81 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    if (memoryAGet16(ds, 0x7a70) == 0x0006)
        { pc = 0x8916; break; }
  case 0x889c:
    r16[ax] = memoryAGet16(ds, 0x474a);
    memoryASet16(ds, 0x7a6c, r16[ax]);
    memoryASet16(ds, 0x474a, 0x0000);
  case 0x88a8:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    yield* sub_80a1();
    sp += 0x0002;
    if (!memoryAGet16(ds, 0xa7ef))
        { pc = 0x8916; break; }
    if (!memoryAGet16(ds, 0x7a68))
        { pc = 0x8903; break; }
    memoryASet16(ds, 0xa7ef, 0x0000);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0014);
    r16[ax] = 0x0335;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x07b1);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x07b1);
    memoryASet16(ds, 0x7a68, 0x0000);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    yield* sub_80a1();
    sp += 0x0002;
  case 0x8903:
    if (!memoryAGet16(ds, 0xa7ef))
        { pc = 0x8916; break; }
    r16[ax] = 0x0358;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x8916:
    memoryASet16(ds, 0xa7da, 0x0000);
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x07b1);
    push(cs); cs = 0x08aa; yield* sub_ac66(); assert(cs == 0x07b1);
    if (memoryAGet16(ds, 0x7a70) == 0x0006)
        { pc = 0x8940; break; }
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a60;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x07b1);
    sp += 0x0006;
  case 0x8940:
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x07b1);
    if (!memoryAGet16(ds, 0x7adc))
        { pc = 0x8962; break; }
    if (memoryAGet16(ds, 0x7a70) == 0x0006)
        { pc = 0x8916; break; }
    if (memoryAGet16(ds, 0x7a70) != 0x0001)
        { pc = 0x895d; break; }
    { pc = 0x88a8; break; }
  case 0x895d:
    push(cs); cs = 0x056a; yield* sub_59c9(); assert(cs == 0x07b1);
  case 0x8962:
    memoryASet16(ds, 0xa7c2, 0xffff);
    r16[bx] = memoryAGet16(ds, 0x7a70);
    r16[bx]--;
    if (r16[bx] <= 0x000c)
        { pc = 0x8975; break; }
    { pc = 0x8a6c; break; }
  case 0x8975:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x8981; break; }
        case 2: { pc = 0x89ee; break; }
        case 4: { pc = 0x8988; break; }
        case 6: { pc = 0x8a6c; break; }
        case 8: { pc = 0x889c; break; }
        case 10: { pc = 0x8916; break; }
        case 12: { pc = 0x89ee; break; }
        case 14: { pc = 0x8a64; break; }
        case 16: { pc = 0x8a6c; break; }
        case 18: { pc = 0x8a6c; break; }
        case 20: { pc = 0x8a6c; break; }
        case 22: { pc = 0x8a6c; break; }
        case 24: { pc = 0x89ee; break; }
        default:
            stop("ind 07b1:0e67");
    }
    break;
    // gap 5 bytes
  case 0x8981:
    push(cs);
    yield* sub_8502();
    { pc = 0x8a6c; break; }
  case 0x8988:
    if (!memoryAGet16(ds, 0xa7ed))
        { pc = 0x899b; break; }
    r16[ax] = 0x000d;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x07b1);
    sp += 0x0002;
  case 0x899b:
    r16[ax] = memoryAGet16(ds, 0xa7ed);
    memoryASet16(ds, 0xa7c2, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 31262, 0x0001);
    push(cs); cs = 0x107c; yield* sub_11365(); assert(cs == 0x07b1);
    if (memoryAGet16(ds, 0x7a5e) == 0x0008)
        { pc = 0x89c2; break; }
    memoryASet16(ds, 0x7a68, 0x0000);
    { pc = 0x8a6c; break; }
  case 0x89c2:
    push(cs);
    yield* sub_7b16();
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x07b1);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x07b1);
    push(cs); cs = 0x0b02; yield* sub_bb4d(); assert(cs == 0x07b1);
    push(memoryAGet16(ds, 0x7a5e));
    push(memoryAGet16(ds, 0x7a52));
    push(memoryAGet16(ds, 0x7a50));
    push(cs); cs = 0x05da; yield* sub_799e(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0x89ee:
    if (!memoryAGet16(ds, 0xa7ed))
        { pc = 0x8a31; break; }
    r16[ax] = 0x000d;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x07b1);
    sp += 0x0002;
    memoryASet16(ds, 0x7a68, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa7ed);
    memoryASet16(ds, 0xa7c2, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 31262, 0x0001);
    if (!memoryAGet16(ds, 0x7a72))
        { pc = 0x8a6c; break; }
    if (memoryAGet16(ds, 0xa7ed) != 0x0002)
        { pc = 0x8a6c; break; }
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x07b1);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0x8a31:
    r16[si] = memoryAGet16(ds, 0xa7b4);
    r16[ax] = memoryAGet16(ds, 0xa7b2);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x07b1);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0019);
    r16[ax] = 0x0389;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x07b1);
    sp += 0x0002;
    memoryASet16(ds, 0xa7b4, r16[si]);
    { pc = 0x8a6c; break; }
    // gap 2 bytes
  case 0x8a64:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x07b1);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x8a6c:
    if (signed16(memoryAGet16(ds, 0x7a6a)) < signed16(0x0000))
        { pc = 0x8a76; break; }
    { pc = 0x88a8; break; }
  case 0x8a76:
    push(cs);
    yield* sub_7ba3();
    push(memoryAGet16(ds, 0x7a5e));
    push(memoryAGet16(ds, 0x7a52));
    push(memoryAGet16(ds, 0x7a50));
    push(cs); cs = 0x05da; yield* sub_799e(); assert(cs == 0x07b1);
    sp += 0x0006;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8aab() // 08aa:000b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[di] = r16[ax];
    r16[si] = memoryAGet16(ds, 0xa7d6);
    { pc = 0x8acf; break; }
  case 0x8ac0:
    if (!memoryAGet16(ds, r16[si] + 2))
        { pc = 0x8ac9; break; }
    r16[di]++;
    { pc = 0x8acc; break; }
  case 0x8ac9:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x8acc:
    r16[si] = memoryAGet16(ds, r16[si] + 72);
  case 0x8acf:
    if (r16[si])
        { pc = 0x8ac0; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0007);
    r16[ax] = 0x03be;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x03cf;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8b2f() // 08aa:008f +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x03e2;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x03ef;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x03fc;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    r16[dx] = 0x0400;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xa01d);
    r16[dx] = memoryAGet16(ds, 0xa01b);
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa013) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa013);
    r16[ax] += memoryAGet16(ds, 0xa015) + flags.carry;
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa017) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa017);
    r16[ax] += memoryAGet16(ds, 0xa019) + flags.carry;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x08aa);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0408;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    r16[dx] = 0x0400;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x174b; yield* sub_1832f(); assert(cs == 0x08aa);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x08aa);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0416;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    r16[dx] = 0x0400;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x174b; yield* sub_18396(); assert(cs == 0x08aa);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x08aa);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0424;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    push(cs); cs = 0x174b; yield* sub_181ed(); assert(cs == 0x08aa);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_8c09() // 08aa:0169 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0018;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0011;
    push(r16[ax]);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 22, 0x0000);
    memoryASet16(ss, r16[bp] - 24, 0x0000);
    r16[ax] = 0x0427;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x0433;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa535);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa537);
    r16[ax] += 0x0038;
    r16[ax] &= 0xfff8;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] += 0x0028;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = 0x043f;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa535);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[si] = 0x007c;
    r16[di] = 0;
  case 0x8c77:
    if (r16s[si] < signed16(0x0209))
        { pc = 0x8c82; break; }
    r16[si] = 0x0208;
    { pc = 0x8c8a; break; }
  case 0x8c82:
    if (r16s[si] >= signed16(0x007c))
        { pc = 0x8c8a; break; }
    r16[si] = 0x007c;
  case 0x8c8a:
    r16[ax] = r16[si];
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[ax] += 0xf748;
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa535, r16[ax]);
    r16[ax] = r16[si];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x047f;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0481;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0483;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0485;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 6);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0487;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0489;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x048b;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x048d;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 14);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x048f;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf7a(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0491;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa537, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x8e48; break; }
    r16[ax] = 0x0493;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x8e8c; break; }
  case 0x8e48:
    es = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] = memoryAGet16(es, 0x0006);
    push(r16[ax]);
    r16[ax] = memoryAGet16(es, 0x000e);
    r16[dx] = 0x0005;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] += 0x000f;
    r16[ax] &= 0xfff0;
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    flags.carry = memoryAGet16(ss, r16[bp] - 24) + r16[ax] >= 0x10000;
    memoryASet16(ss, r16[bp] - 24, memoryAGet16(ss, r16[bp] - 24) + r16[ax]);
    memoryASet16(ss, r16[bp] - 22, memoryAGet16(ss, r16[bp] - 22) + (0x0000 + flags.carry));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 18));
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0499;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x8e8c:
    memoryASet16(ss, r16[bp] - 6, r16[si]);
  case 0x8e8f:
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    push(r16[ax]);
    r16[ax] = 0x006e;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    if (!memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x8efd; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa535, r16[ax]);
    r16[ax] = 0x049b;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = r16[di];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bf52(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x04a2;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(r16[si]);
    push(memoryAGet16(ds, 0xa535));
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 10);
    r16[dx] += r16[ax];
    r16[dx] += 0x0010;
    push(r16[dx]);
    push(cs); cs = 0x1ef3; yield* sub_1fda5(); assert(cs == 0x08aa);
    sp += 0x0006;
  case 0x8efd:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_172ef(); assert(cs == 0x08aa);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    if (r16[ax] == 0x004b)
        { pc = 0x8f5a; break; }
    if (r16[ax] > 0x004b)
        { pc = 0x8f24; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x8f88; break; }
    if (r16[ax] == 0x0048)
        { pc = 0x8f35; break; }
    if (r16[ax] == 0x0049)
        { pc = 0x8f3b; break; }
    { pc = 0x8f7d; break; }
  case 0x8f24:
    if (r16[ax] == 0x004d)
        { pc = 0x8f69; break; }
    if (r16[ax] == 0x0050)
        { pc = 0x8f38; break; }
    if (r16[ax] == 0x0051)
        { pc = 0x8f4b; break; }
    { pc = 0x8f7d; break; }
  case 0x8f35:
    r16[si]++;
    { pc = 0x8f7d; break; }
  case 0x8f38:
    r16[si]--;
    { pc = 0x8f7d; break; }
  case 0x8f3b:
    r16[si] += 0x000a;
    if (r16s[si] < signed16(0x0209))
        { pc = 0x8f7d; break; }
    r16[si] = 0x0208;
    { pc = 0x8f7d; break; }
    // gap 2 bytes
  case 0x8f4b:
    r16[si] -= 0x000a;
    if (r16s[si] >= signed16(0x007c))
        { pc = 0x8f7d; break; }
    r16[si] = 0x007c;
    { pc = 0x8f7d; break; }
    // gap 2 bytes
  case 0x8f5a:
    r16[di]--;
    r16[ax] = r16[di];
    if (r16[ax] != 0xffff)
        { pc = 0x8f7d; break; }
    r16[di] = 0x0003;
    { pc = 0x8f7d; break; }
    // gap 2 bytes
  case 0x8f69:
    r16[di]++;
    r16[ax] = r16[di];
    if (r16[ax] != 0x0004)
        { pc = 0x8f7d; break; }
    r16[di] = 0;
    { pc = 0x8f7d; break; }
    // gap 8 bytes
  case 0x8f7d:
    if (r16[si] != memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x8f85; break; }
    { pc = 0x8e8f; break; }
  case 0x8f85:
    { pc = 0x8c77; break; }
  case 0x8f88:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_8f8e() // 08aa:04ee +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
  case 0x8f98:
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0x8f98; break; }
    if (memoryAGet(ds, 0xa545) == 0x1c)
        { pc = 0x8fb1; break; }
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x8fb1:
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x08aa);
    r16[ax] = memoryAGet16(ds, 0xa7b2);
    r16[ax] += memoryAGet16(ds, 0xa7b0);
    r16[di] = r16[ax];
    r16[ax] = 0x000f;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f019(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x08aa);
    sp += 0x0004;
    if (r16[di] >= 0xce00)
        { pc = 0x9025; break; }
    r16[si] = 0;
    { pc = 0x901d; break; }
  case 0x8ff9:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[dx] = 0x0028;
    imul16(r16[dx]);
    push(r16[ax]);
    r16[ax] = r16[si];
    r8[cl] = 0x06;
    r16[ax] <<= r8[cl];
    r16[dx] = r16[di];
    r16[dx] += r16[ax];
    push(r16[dx]);
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x08aa);
    sp += 0x0008;
    r16[si]++;
  case 0x901d:
    if (r16s[si] < signed16(0x00c8))
        { pc = 0x8ff9; break; }
    { pc = 0x9052; break; }
  case 0x9025:
    r16[si] = 0x00c7;
    { pc = 0x904e; break; }
  case 0x902a:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[dx] = 0x0028;
    imul16(r16[dx]);
    push(r16[ax]);
    r16[ax] = r16[si];
    r8[cl] = 0x06;
    r16[ax] <<= r8[cl];
    r16[dx] = r16[di];
    r16[dx] += r16[ax];
    push(r16[dx]);
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x08aa);
    sp += 0x0008;
    r16[si]--;
  case 0x904e:
    if (r16s[si] >= 0)
        { pc = 0x902a; break; }
  case 0x9052:
    push(cs); cs = 0x164d; yield* sub_16d38(); assert(cs == 0x08aa);
    r16[ax] = 0x0011;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x08aa);
    push(cs); cs = 0x1b1e; yield* sub_1b7c2(); assert(cs == 0x08aa);
    push(cs); cs = 0x1a61; yield* sub_1afaf(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_16d38(); assert(cs == 0x08aa);
    push(cs); cs = 0x1841; yield* sub_18544(); assert(cs == 0x08aa);
    push(cs); cs = 0x1493; yield* sub_152c9(); assert(cs == 0x08aa);
    push(cs); cs = 0x174b; yield* sub_17b92(); assert(cs == 0x08aa);
  case 0x9086:
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_352c(); assert(cs == 0x08aa);
    sp += 0x0002;
    r8[cl] = 0x08;
    r16[ax] = sar16(r16[ax], r8[cl]);
    r16[ax] &= 0x00ff;
    if (r16[ax] != 0x0001)
        { pc = 0x9086; break; }
    push(cs); cs = 0x1ef3; yield* sub_1efc0(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_248b(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_90b1() // 08aa:0611 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 35107);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    r16[cx] = memoryAGet16(ds, r16[bx] + 35107);
    r16[dx] = 0;
    { pc = 0x9108; break; }
  case 0x90d2:
    r16[ax] = r16[dx];
    r16[ax] &= 0x000f;
    r16[si] = r16[ax];
    es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = r16[dx];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 32);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[di] = memoryAGet16(es, r16[bx]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    es = r16[cx];
    memoryASet16(es, r16[bx], memoryAGet16(es, r16[bx]) & r16[di]);
    r16[bx] = r16[dx];
    r16[bx] <<= 1;
    memoryASet16(es, r16[bx] + 32, memoryAGet16(es, r16[bx] + 32) & r16[di]);
    r16[bx] = r16[dx];
    r16[bx] <<= 1;
    memoryASet16(es, r16[bx] + 32, memoryAGet16(es, r16[bx] + 32) | r16[ax]);
    r16[dx]++;
  case 0x9108:
    if (r16s[dx] < signed16(0x0040))
        { pc = 0x90d2; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_9113() // 08aa:0673 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0018;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x04a4;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    r16[si] = 0x0787;
    { pc = 0x914d; break; }
  case 0x9143:
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[si]++;
  case 0x914d:
    if (r16s[si] < signed16(0x0797))
        { pc = 0x9143; break; }
    r16[si] = 0;
    { pc = 0x926f; break; }
  case 0x9158:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 35107))
        { pc = 0x9166; break; }
    { pc = 0x926e; break; }
  case 0x9166:
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 2994);
    r8[ah] = 0x00;
    r16[ax] &= 0x0007;
    r16[di] = r16[ax];
    if (!r16[di])
        { pc = 0x9186; break; }
    r16[ax] += 0x006b;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_90b1();
    sp += 0x0004;
  case 0x9186:
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 8826);
    r8[ah] = 0x00;
    r16[ax] &= 0x0007;
    r16[di] = r16[ax];
    if (!r16[di])
        { pc = 0x91a6; break; }
    r16[ax] += 0x0073;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_90b1();
    sp += 0x0004;
  case 0x91a6:
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 5910);
    r8[ah] = 0x00;
    r16[ax] &= 0x0007;
    r16[di] = r16[ax];
    if (r16s[di] <= signed16(0x0001))
        { pc = 0x91f8; break; }
    r16[ax] = 0x04ac;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x7a74;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x7a74;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x91f8:
    if (!r16[di])
        { pc = 0x920a; break; }
    r16[ax] = r16[di];
    r16[ax] += 0x0072;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_90b1();
    sp += 0x0004;
  case 0x920a:
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 11742);
    r8[ah] = 0x00;
    r16[ax] &= 0x0007;
    r16[di] = r16[ax];
    if (r16s[di] <= signed16(0x0001))
        { pc = 0x925c; break; }
    r16[ax] = 0x04cf;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x7a74;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x7a74;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x925c:
    if (!r16[di])
        { pc = 0x926e; break; }
    r16[ax] = r16[di];
    r16[ax] += 0x007a;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_90b1();
    sp += 0x0004;
  case 0x926e:
    r16[si]++;
  case 0x926f:
    if (r16s[si] >= signed16(0x0b64))
        { pc = 0x9278; break; }
    { pc = 0x9158; break; }
  case 0x9278:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_927c() // 08aa:07dc +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    if (memoryAGet16(ds, 0xc6a7))
        { pc = 0x928e; break; }
    { pc = 0x931c; break; }
  case 0x928e:
    if (memoryAGet16(ds, 0xc631))
        { pc = 0x9298; break; }
    { pc = 0x931c; break; }
  case 0x9298:
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0018;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    r16[ax] = 0x04f2;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(memoryAGet16(ds, 0x6022));
    push(memoryAGet16(ds, 0x6020));
    push(cs); cs = 0x1b1e; yield* sub_1c3e5(); assert(cs == 0x08aa);
    sp += 0x000e;
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[ax] = -flags.carry;
    r16[ax]++;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x9313; break; }
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_349f(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[di] = r16[ax];
    if (r16s[di] < 0)
        { pc = 0x9313; break; }
    if (r16s[di] > signed16(0x000f))
        { pc = 0x9313; break; }
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f019(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9313:
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x931c:
    if (!memoryAGet16(ds, 0xc6a3))
        { pc = 0x9337; break; }
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x9337; break; }
    push(cs);
    yield* sub_8aab();
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x9337:
    if (!memoryAGet16(ds, 0xc687))
        { pc = 0x936e; break; }
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x936e; break; }
    if (memoryAGet16(ds, 0x3bd6))
        { pc = 0x9353; break; }
    push(cs); cs = 0x07b1; yield* sub_8370(); assert(cs == 0x08aa);
    { pc = 0x9365; break; }
  case 0x9353:
    if (memoryAGet16(ds, 0x3bd6) != 0x0001)
        { pc = 0x9365; break; }
    push(cs); cs = 0x07b1; yield* sub_8404(); assert(cs == 0x08aa);
    memoryASet16(ds, 0x7a70, 0x0002);
  case 0x9365:
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x936e:
    if (!memoryAGet16(ds, 0xc66b))
        { pc = 0x938e; break; }
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x938e; break; }
    if (!memoryAGet16(ds, 0x7adc))
        { pc = 0x9388; break; }
    push(cs); cs = 0x056a; yield* sub_59c9(); assert(cs == 0x08aa);
  case 0x9388:
    memoryASet16(ds, 0x7a70, 0x0002);
  case 0x938e:
    if (!memoryAGet16(ds, 0xc68b))
        { pc = 0x93ea; break; }
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x93ea; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x000c;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    if (!memoryAGet16(ds, 0xc629))
        { pc = 0x93c6; break; }
    r16[ax] = 0x0508;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x93d2; break; }
  case 0x93c6:
    r16[ax] = 0x0515;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x93d2:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    memoryASet16(ds, 0xc629, memoryAGet16(ds, 0xc629) ^ 0x0001);
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x93ea:
    if (!memoryAGet16(ds, 0xc675))
        { pc = 0x9451; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x000c;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x0521;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[si] = 0;
    { pc = 0x9421; break; }
  case 0x9416:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 31328, 0x0063);
    r16[si]++;
  case 0x9421:
    if (r16s[si] < signed16(0x0004))
        { pc = 0x9416; break; }
    memoryASet16(ds, 0x7a58, 0x0063);
    memoryASet16(ds, 0x7a5c, 0x0001);
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    r16[ax] = 0x0bb8;
    push(r16[ax]);
    push(cs);
    yield* sub_a992();
    sp += 0x0002;
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x9451:
    if (!memoryAGet16(ds, 0xc68f))
        { pc = 0x94a6; break; }
    memoryASet16(ds, 0xc62b, memoryAGet16(ds, 0xc62b) ^ 0x0001);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    if (!memoryAGet16(ds, 0xc62b))
        { pc = 0x9487; break; }
    r16[ax] = 0x052d;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9493; break; }
  case 0x9487:
    r16[ax] = 0x053b;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9493:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x94a6:
    if (!memoryAGet16(ds, 0xc6ab))
        { pc = 0x94ba; break; }
    push(cs);
    yield* sub_8b2f();
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x94ba:
    if (!memoryAGet16(ds, 0xc6a9))
        { pc = 0x951f; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    if (!memoryAGet16(ds, r16[bx] + 6))
        { pc = 0x94f7; break; }
    r16[ax] = 0x054a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    { pc = 0x950c; break; }
  case 0x94f7:
    r16[ax] = 0x0559;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 6, 0x0001);
  case 0x950c:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x951f:
    if (!memoryAGet16(ds, 0xc679))
        { pc = 0x9538; break; }
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    push(cs);
    yield* sub_8f8e();
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x9538:
    if (!memoryAGet16(ds, 0xc685))
        { pc = 0x9594; break; }
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x9594; break; }
    memoryASet16(ds, 0xc62d, memoryAGet16(ds, 0xc62d) ^ 0x0001);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    if (!memoryAGet16(ds, 0xc62d))
        { pc = 0x9575; break; }
    r16[ax] = 0x0569;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9581; break; }
  case 0x9575:
    r16[ax] = 0x0578;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9581:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x9594:
    if (!memoryAGet16(ds, 0xc66f))
        { pc = 0x95a8; break; }
    push(cs);
    yield* sub_8c09();
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x95a8:
    if (memoryAGet16(ds, 0xc6a5))
        { pc = 0x95b2; break; }
    { pc = 0x9631; break; }
  case 0x95b2:
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    r16[ax] = 0x0588;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(memoryAGet16(ds, 0x6022));
    push(memoryAGet16(ds, 0x6020));
    push(cs); cs = 0x1b1e; yield* sub_1c3e5(); assert(cs == 0x08aa);
    sp += 0x000e;
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[ax] = -flags.carry;
    r16[ax]++;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x9628; break; }
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_349f(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[di] = r16[ax];
    if (r16s[di] < 0)
        { pc = 0x9628; break; }
    if (r16s[di] > signed16(0x0008))
        { pc = 0x9628; break; }
    memoryASet16(ds, 0xa7f9, r16[di]);
  case 0x9628:
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x9631:
    if (memoryAGet16(ds, 0xc669))
        { pc = 0x963b; break; }
    { pc = 0x96ca; break; }
  case 0x963b:
    if (memoryAGet16(ds, 0xc631))
        { pc = 0x9645; break; }
    { pc = 0x96ca; break; }
  case 0x9645:
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    r16[ax] = 0x05a8;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(memoryAGet16(ds, 0x6022));
    push(memoryAGet16(ds, 0x6020));
    push(cs); cs = 0x1b1e; yield* sub_1c3e5(); assert(cs == 0x08aa);
    sp += 0x000e;
    flags.carry = r16[ax] != 0;
    r16[ax] = -r16[ax];
    r16[ax] = -flags.carry;
    r16[ax]++;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x96c1; break; }
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_349f(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[di] = r16[ax];
    if (r16s[di] <= 0)
        { pc = 0x96c1; break; }
    if (r16s[di] > signed16(0x0012))
        { pc = 0x96c1; break; }
    memoryASet16(ds, 0x7a68, r16[di]);
    memoryASet16(ds, 0x7a70, 0x0004);
  case 0x96c1:
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x96ca:
    if (!memoryAGet16(ds, 0xc671))
        { pc = 0x96de; break; }
    push(cs);
    yield* sub_9113();
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x96de:
    if (!memoryAGet16(ds, 0xc69f))
        { pc = 0x96f8; break; }
    memoryASet16(ds, 0x7a6a, 0x0000);
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x08aa);
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x96f8:
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_9700() // 08aa:0c60 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0x001e;
    { pc = 0x9724; break; }
  case 0x9709:
    if (r16[si] == 0x0030)
        { pc = 0x9723; break; }
    if (r16[si] == 0x001e)
        { pc = 0x9723; break; }
    if (r16[si] == 0x0014)
        { pc = 0x9723; break; }
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x9772; break; }
  case 0x9723:
    r16[si]++;
  case 0x9724:
    if (r16s[si] <= signed16(0x002c))
        { pc = 0x9709; break; }
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0002);
    r16[ax] = 0x05c5;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
    memoryASet16(ds, 0x7a58, 0x0063);
    memoryASet16(ds, 0x7a6a, memoryAGet16(ds, 0x7a6a) + 1);
    r16[ax] = 0x0001;
    memoryASet16(ds, 0x7a66, r16[ax]);
    memoryASet16(ds, 0x7a64, r16[ax]);
    memoryASet16(ds, 0x7a62, r16[ax]);
    memoryASet16(ds, 0x7a60, r16[ax]);
  case 0x9772:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_9775() // 08aa:0cd5 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xc757))
        { pc = 0x9782; break; }
    { pc = 0x9a40; break; }
  case 0x9782:
    if (memoryAGet16(ds, 0xc67f))
        { pc = 0x9797; break; }
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0x97b4; break; }
    if (!memoryAGet16(ds, 0xc641))
        { pc = 0x97b4; break; }
  case 0x9797:
    push(cs);
    yield* sub_a191();
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
  case 0x97b4:
    if (!memoryAGet16(ds, 0xc645))
        { pc = 0x97fb; break; }
    push(cs); cs = 0x1a61; yield* sub_1b125(); assert(cs == 0x08aa);
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = 0x060c;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
    memoryASet16(ds, 0xc645, 0x0000);
    push(cs); cs = 0x1a61; yield* sub_1b11a(); assert(cs == 0x08aa);
  case 0x97fb:
    if (memoryAGet(ds, 0xa545) != 0x3b)
        { pc = 0x983c; break; }
    push(cs);
    yield* sub_ab32();
    push(cs); cs = 0x0b02; yield* sub_b9c5(); assert(cs == 0x08aa);
    push(memoryAGet16(ds, 0x7a68));
    push(cs);
    yield* sub_ab67();
    sp += 0x0002;
    if (!memoryAGet16(ds, 0xc5cd))
        { pc = 0x9837; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d4);
    memoryASet16(ds, r16[bx] + 64, 0xffff);
    memoryASet16(ds, r16[bx] + 62, 0xffff);
    memoryASet16(ds, r16[bx] + 66, 0xffff);
    memoryASet16(ds, r16[bx] + 68, 0xffff);
  case 0x9837:
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
  case 0x983c:
    if (!memoryAGet16(ds, 0x7a72))
        { pc = 0x9846; break; }
    { pc = 0x9969; break; }
  case 0x9846:
    if (memoryAGet(ds, 0xa545) < 0x3c)
        { pc = 0x9854; break; }
    if (memoryAGet(ds, 0xa545) <= 0x41)
        { pc = 0x985e; break; }
  case 0x9854:
    if (memoryAGet(ds, 0xa545) == 0x01)
        { pc = 0x985e; break; }
    { pc = 0x990b; break; }
  case 0x985e:
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x08aa);
    push(cs);
    yield* sub_ab32();
    push(cs); cs = 0x1c76; yield* sub_1ece2(); assert(cs == 0x08aa);
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x08aa);
    push(memoryAGet16(ds, 0x7a68));
    push(cs);
    yield* sub_ab67();
    sp += 0x0002;
    if (memoryAGet16(ds, 0xc5cd))
        { pc = 0x989e; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d4);
    if (!memoryAGet16(ds, r16[bx] + 70))
        { pc = 0x989e; break; }
    r16[ax] = memoryAGet16(ds, 0xa7d4);
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19c6b(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x989e:
    if (!memoryAGet16(ds, 0xc5cd))
        { pc = 0x98bd; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d4);
    memoryASet16(ds, r16[bx] + 64, 0xffff);
    memoryASet16(ds, r16[bx] + 62, 0xffff);
    memoryASet16(ds, r16[bx] + 66, 0xffff);
    memoryASet16(ds, r16[bx] + 68, 0xffff);
  case 0x98bd:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    if (!memoryAGet16(ds, 0x474a))
        { pc = 0x98d1; break; }
    memoryASet16(ds, 0x7a70, 0x0005);
    { pc = 0x98dd; break; }
  case 0x98d1:
    if (memoryAGet16(ds, 0xa53b))
        { pc = 0x98dd; break; }
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
  case 0x98dd:
    if (!memoryAGet16(ds, 0xc62f))
        { pc = 0x98f0; break; }
    memoryASet16(ds, 0xc62f, 0x0000);
    memoryASet16(ds, 0x7a70, 0x0008);
  case 0x98f0:
    if (!memoryAGet16(ds, 0xa53b))
        { pc = 0x98fd; break; }
    memoryASet16(ds, 0x7a70, 0x0006);
  case 0x98fd:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
  case 0x990b:
    if (memoryAGet(ds, 0xa545) != 0x43)
        { pc = 0x9969; break; }
    push(cs); cs = 0x1ef3; yield* sub_1efc0(); assert(cs == 0x08aa);
    push(cs); cs = 0x1a61; yield* sub_1b125(); assert(cs == 0x08aa);
    r16[ax] = 0x0613;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_22b3(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
  case 0x992d:
    yield* sync();
    if (memoryAGet(ds, 0xa545) != 0x01)
        { pc = 0x992d; break; }
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1efdc(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(memoryAGet16(ds, 0xa54e));
    push(cs); cs = 0x1ef3; yield* sub_1f019(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    push(cs); cs = 0x1a61; yield* sub_1b11a(); assert(cs == 0x08aa);
  case 0x9969:
    if (!memoryAGet16(ds, 0xc6a7))
        { pc = 0x9982; break; }
    if (!memoryAGet16(ds, 0xc683))
        { pc = 0x9982; break; }
    if (!memoryAGet16(ds, 0xc66f))
        { pc = 0x9982; break; }
    push(cs);
    yield* sub_9700();
  case 0x9982:
    if (!memoryAGet16(ds, 0x7a16))
        { pc = 0x99ab; break; }
    if (!memoryAGet16(ds, 0xc6cf))
        { pc = 0x99ab; break; }
    push(cs);
    yield* sub_927c();
    if (!r16[ax])
        { pc = 0x99ab; break; }
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x08aa);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
  case 0x99ab:
    if (!memoryAGet16(ds, 0x7a72))
        { pc = 0x9a22; break; }
    if (!memoryAGet16(ds, 0xc681))
        { pc = 0x9a22; break; }
    if (memoryAGet(ds, 0xa545) != 0x1f)
        { pc = 0x9a22; break; }
    if (!memoryAGet16(ds, 0xc635))
        { pc = 0x99df; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ad5b(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ade0(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9a22; break; }
  case 0x99df:
    if (!memoryAGet16(ds, 0xc639))
        { pc = 0x9a06; break; }
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ad5b(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ds, 0xc637, 0x0000);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ade0(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9a1d; break; }
  case 0x9a06:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ad5b(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ade0(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9a1d:
    push(cs); cs = 0x1493; yield* sub_15458(); assert(cs == 0x08aa);
  case 0x9a22:
    if (!memoryAGet16(ds, 0xc681))
        { pc = 0x9a40; break; }
    if (memoryAGet(ds, 0xa545) != 0x10)
        { pc = 0x9a40; break; }
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9a40:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_9a42() // 08aa:0fa2 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0016;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 22;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 16));
    push(memoryAGet16(ss, r16[bp] + 14));
    push(cs); cs = 0x01ed; yield* sub_3b85(); assert(cs == 0x08aa);
    sp += 0x0008;
    r16[ax] = r16[bp] - 22;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    { pc = 0x9a8a; break; }
  case 0x9a77:
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[si]--;
    r16[di] += 0x0008;
  case 0x9a8a:
    if (r16s[si] > signed16(memoryAGet16(ss, r16[bp] - 2)))
        { pc = 0x9a77; break; }
    { pc = 0x9ab7; break; }
  case 0x9a91:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] -= r16[si];
    r16[ax] = r16[bp] - 22;
    r16[bx] += r16[ax];
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] += r16[ax];
    r16[dx] += 0xffd1;
    push(r16[dx]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[si]--;
    r16[di] += 0x0008;
  case 0x9ab7:
    if (r16s[si] > 0)
        { pc = 0x9a91; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_9ac1() // 08aa:1021 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 4, 0x0040);
    r16[di] = 0x0010;
    memoryASet16(ss, r16[bp] - 6, 0x00b8);
    memoryASet16(ss, r16[bp] - 8, 0x0090);
    r16[ax] = 0x0036;
    push(r16[ax]);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += 0x0008;
    r16[si] = r16[ax];
    { pc = 0x9b2e; break; }
  case 0x9b0a:
    r16[ax] = 0x0037;
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x003d;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[si] += 0x0008;
  case 0x9b2e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += 0xfff8;
    if (r16s[ax] >= r16s[si])
        { pc = 0x9b0a; break; }
    r16[ax] = 0x0038;
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x003e;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = r16[di];
    r16[ax] += 0x0008;
    r16[si] = r16[ax];
    { pc = 0x9b8c; break; }
  case 0x9b65:
    r16[ax] = 0x0039;
    push(r16[ax]);
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x003b;
    push(r16[ax]);
    push(r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[si] += 0x0008;
  case 0x9b8c:
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xfff8;
    if (r16s[ax] >= r16s[si])
        { pc = 0x9b65; break; }
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0x0088;
    push(r16[ax]);
    r16[ax] = 0x00b0;
    push(r16[ax]);
    r16[ax] = 0x0018;
    push(r16[ax]);
    r16[ax] = 0x0048;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    memoryASet16(ds, 0xa535, 0x001c);
    memoryASet16(ds, 0xa533, 0x0050);
    memoryASet16(ds, 0xa531, 0x00a0);
    r16[ax] = 0x0617;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    r16[ax] = 0x00a2;
    push(r16[ax]);
    r16[ax] = 0x0026;
    push(r16[ax]);
    r16[ax] = 0x004f;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[bx] = memoryAGet16(ds, 0x7a68);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 6390));
    push(memoryAGet16(ds, r16[bx] + 6388));
    push(ds);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x08aa);
    sp += 0x0008;
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_56ac(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = 0x0014;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 12);
    r16[ax] >>= 1;
    r16[ax] += 0x0028;
    r16[ax] -= 0x0002;
    memoryASet16(ds, 0xa535, r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ds, 0xa535, 0x003d);
    memoryASet16(ds, 0xa533, 0x0050);
    memoryASet16(ds, 0xa531, 0x0040);
    r16[ax] = 0x0620;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0042;
    push(r16[ax]);
    r16[ax] = 0x0047;
    push(r16[ax]);
    r16[ax] = 0x004f;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    push(memoryAGet16(ds, 0x7a52));
    push(memoryAGet16(ds, 0x7a50));
    r16[ax] = 0x0029;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0048;
    push(r16[ax]);
    r16[ax] = 0x0050;
    push(r16[ax]);
    push(cs);
    yield* sub_9a42();
    sp += 0x000c;
    memoryASet16(ds, 0xa535, 0x003d);
    memoryASet16(ds, 0xa533, 0x00b0);
    memoryASet16(ds, 0xa531, 0x0040);
    r16[ax] = 0x0626;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0042;
    push(r16[ax]);
    r16[ax] = 0x0047;
    push(r16[ax]);
    r16[ax] = 0x00af;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    push(memoryAGet16(ds, 0x7a56));
    push(memoryAGet16(ds, 0x7a54));
    r16[ax] = 0x0029;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0048;
    push(r16[ax]);
    r16[ax] = 0x00b0;
    push(r16[ax]);
    push(cs);
    yield* sub_9a42();
    sp += 0x000c;
    memoryASet16(ds, 0xa535, 0x0055);
    memoryASet16(ds, 0xa533, 0x0050);
    memoryASet16(ds, 0xa531, 0x0040);
    r16[ax] = 0x062c;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0042;
    push(r16[ax]);
    r16[ax] = 0x005f;
    push(r16[ax]);
    r16[ax] = 0x004f;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[si] = 0;
    { pc = 0x9d4a; break; }
  case 0x9d29:
    r16[ax] = 0x0028;
    push(r16[ax]);
    r16[ax] = 0x0060;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0x0050;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[si]++;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 0x0008);
  case 0x9d4a:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x7a5e)))
        { pc = 0x9d29; break; }
    memoryASet16(ds, 0xa535, 0x0055);
    memoryASet16(ds, 0xa533, 0x00b0);
    memoryASet16(ds, 0xa531, 0x0040);
    r16[ax] = 0x0634;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0042;
    push(r16[ax]);
    r16[ax] = 0x005f;
    push(r16[ax]);
    r16[ax] = 0x00af;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    memoryASet16(ds, 0xa535, 0x0060);
    memoryASet16(ds, 0xa533, 0x00b0);
    memoryASet16(ds, 0xa531, 0x0040);
    r16[ax] = memoryAGet16(ds, 0x7a6c);
    if (r16[ax] == 0x0001)
        { pc = 0x9db0; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x9dbe; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x9dcc; break; }
    { pc = 0x9dd8; break; }
  case 0x9db0:
    r16[ax] = 0x063a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9dd8; break; }
  case 0x9dbe:
    r16[ax] = 0x063f;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9dd8; break; }
  case 0x9dcc:
    r16[ax] = 0x0646;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9dd8:
    memoryASet16(ds, 0xa537, 0x0050);
    memoryASet16(ds, 0xa535, 0x0070);
    r16[ax] = 0x064b;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0022;
    push(r16[ax]);
    r16[ax] = 0x006f;
    push(r16[ax]);
    r16[ax] = 0x0077;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[si] = 0;
    { pc = 0x9e39; break; }
  case 0x9e0f:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31328))
        { pc = 0x9e38; break; }
    r16[ax] = r16[si];
    r16[ax] += 0x0024;
    push(r16[ax]);
    r16[ax] = 0x0070;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0x0078;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
  case 0x9e38:
    r16[si]++;
  case 0x9e39:
    if (r16s[si] < signed16(0x0004))
        { pc = 0x9e0f; break; }
    memoryASet16(ds, 0xa537, 0x00b0);
    memoryASet16(ds, 0xa535, 0x0070);
    r16[ax] = 0x0650;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    r16[ax] = 0x006f;
    push(r16[ax]);
    r16[ax] = 0x00d7;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0x7a58);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0029;
    push(r16[ax]);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0070;
    push(r16[ax]);
    r16[ax] = 0x00d8;
    push(r16[ax]);
    push(cs);
    yield* sub_9a42();
    sp += 0x000c;
    memoryASet16(ds, 0xa537, 0x0050);
    memoryASet16(ds, 0xa535, 0x0080);
    r16[ax] = 0x0655;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    r16[ax] = 0x007f;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0x7a6a);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0029;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0080;
    push(r16[ax]);
    push(r16[ax]);
    push(cs);
    yield* sub_9a42();
    sp += 0x000c;
    memoryASet16(ds, 0xa537, 0x00b0);
    memoryASet16(ds, 0xa535, 0x0080);
    r16[ax] = 0x065b;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    r16[ax] = 0x007f;
    push(r16[ax]);
    r16[ax] = 0x00e0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0x7a5a);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0029;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0080;
    push(r16[ax]);
    r16[ax] = 0x00e0;
    push(r16[ax]);
    push(cs);
    yield* sub_9a42();
    sp += 0x000c;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0042;
    push(r16[ax]);
    r16[ax] = 0x008f;
    push(r16[ax]);
    r16[ax] = 0x004f;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x08aa);
    sp += 0x000a;
    memoryASet16(ds, 0xa535, 0x0090);
    memoryASet16(ds, 0xa533, 0x0050);
    memoryASet16(ds, 0xa531, 0x0040);
    if (!memoryAGet16(ds, 0x7a5c))
        { pc = 0x9f6b; break; }
    r16[ax] = 0x0661;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0x9f77; break; }
  case 0x9f6b:
    r16[ax] = 0x0669;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0x9f77:
    r16[si] = 0;
    { pc = 0x9fb8; break; }
  case 0x9f7b:
    r16[ax] = r16[si];
    r16[ax] += 0x0048;
    push(r16[ax]);
    r16[ax] = 0x008c;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0x00a0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[ax] = r16[si];
    r16[ax] += 0x0052;
    push(r16[ax]);
    r16[ax] = 0x0094;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0x00a0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x08aa);
    sp += 0x0006;
    r16[si]++;
  case 0x9fb8:
    if (r16s[si] < signed16(0x000a))
        { pc = 0x9f7b; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a191() // 08aa:16f1 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    memoryASet16(ds, 0xa533, 0x0000);
    memoryASet16(ds, 0xa531, 0x0140);
    memoryASet16(ds, 0xa7de, 0x0000);
    memoryASet16(ds, 0xa7dc, 0x00c8);
    if (!memoryAGet16(ds, 0xc683))
        { pc = 0xa1ee; break; }
    if (!memoryAGet16(ds, 0xc64d))
        { pc = 0xa1ee; break; }
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0002);
    r16[ax] = 0x066d;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bed9(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    memoryASet16(ds, 0x7a16, 0x0001);
  case 0xa1ee:
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x08aa);
    push(cs); cs = 0x1841; yield* sub_18af2(); assert(cs == 0x08aa);
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(cs); cs = 0x1841; yield* sub_196fc(); assert(cs == 0x08aa);
    memoryASet16(ds, 0xa7f7, r16[ax]);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = 0x00e0;
    push(r16[ax]);
    r16[ax] = 0x002c;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x08aa);
    sp += 0x0008;
    r16[ax] = 0x00e0;
    push(r16[ax]);
    r16[ax] = 0x002c;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa546));
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x08aa);
    sp += 0x0008;
    r16[ax] = 0x00a8;
    push(r16[ax]);
    r16[ax] = 0x002c;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b4));
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x08aa);
    sp += 0x0008;
    push(cs);
    yield* sub_9ac1();
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x08aa);
    r16[ax] = 0x0022;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ds, 0xa7f5, 0x0010);
    memoryASet16(ds, 0xa7f3, 0x0000);
    r16[ax] = 0x08aa;
    push(r16[ax]);
    r16[ax] = 0x1523;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19060(); assert(cs == 0x08aa);
    sp += 0x0004;
  case 0xa288:
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x08aa);
    if (memoryAGet16(ds, 0xa7f5) == 0x00a8)
        { pc = 0xa2ba; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7f5);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0xa7f5, r16[dx]);
    if (signed16(memoryAGet16(ds, 0xa7f5)) <= signed16(0x00a8))
        { pc = 0xa288; break; }
    memoryASet16(ds, 0xa7f5, 0x00a8);
    { pc = 0xa288; break; }
    // gap 2 bytes
  case 0xa2ba:
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19060(); assert(cs == 0x08aa);
    sp += 0x0004;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x08aa);
    r16[ax] = 0x0023;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ds, 0xa7f5, memoryAGet16(ds, 0xa7f5) - 0x0010);
    memoryASet16(ds, 0xa7f3, 0x0001);
    r16[ax] = 0x08aa;
    push(r16[ax]);
    r16[ax] = 0x1523;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19060(); assert(cs == 0x08aa);
    sp += 0x0004;
  case 0xa2fc:
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x08aa);
    if (!memoryAGet16(ds, 0xa7f5))
        { pc = 0xa32c; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7f5);
    r16[dx] -= r16[ax];
    memoryASet16(ds, 0xa7f5, r16[dx]);
    if (signed16(memoryAGet16(ds, 0xa7f5)) >= signed16(0x0000))
        { pc = 0xa2fc; break; }
    memoryASet16(ds, 0xa7f5, 0x0000);
    { pc = 0xa2fc; break; }
    // gap 2 bytes
  case 0xa32c:
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19060(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[bx] = memoryAGet16(ds, 0xa7d4);
    memoryASet16(ds, r16[bx] + 10, 0x0000);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a345() // 08aa:18a5 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xc5b9, 0x008c);
    if (memoryAGet16(ds, r16[si] + 10) >= 0x0980)
        { pc = 0xa364; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0xa36d; break; }
  case 0xa364:
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[ax] -= 0x0980;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0xa36d:
    if (memoryAGet16(ds, 0xa7ed))
        { pc = 0xa38b; break; }
    if (memoryAGet16(ds, r16[si] + 12) >= 0x0500)
        { pc = 0xa37f; break; }
    r16[di] = 0;
    { pc = 0xa39e; break; }
  case 0xa37f:
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[ax] -= 0x0500;
    r16[di] = r16[ax];
    { pc = 0xa39e; break; }
    // gap 2 bytes
  case 0xa38b:
    if (memoryAGet16(ds, r16[si] + 40) >= 0x08c0)
        { pc = 0xa396; break; }
    r16[di] = 0;
    { pc = 0xa39e; break; }
  case 0xa396:
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= 0x08c0;
    r16[di] = r16[ax];
  case 0xa39e:
    if (memoryAGet16(ds, 0xa52f))
        { pc = 0xa3b1; break; }
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1841; yield* sub_19743(); assert(cs == 0x08aa);
    sp += 0x0004;
  case 0xa3b1:
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x0015;
    r16[ax]--;
    memoryASet16(ds, 0xc625, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x000e;
    r16[ax]--;
    memoryASet16(ds, 0xc623, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa801, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa801)) >= signed16(0x0000))
        { pc = 0xa3db; break; }
    memoryASet16(ds, 0xa801, 0x0000);
  case 0xa3db:
    r16[ax] = memoryAGet16(ds, 0xc625);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0xa7ff, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7ff)) >= signed16(0x0000))
        { pc = 0xa3f1; break; }
    memoryASet16(ds, 0xa7ff, 0x0000);
  case 0xa3f1:
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa7fd, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7fd)) >= signed16(0x0000))
        { pc = 0xa407; break; }
    memoryASet16(ds, 0xa7fd, 0x0000);
  case 0xa407:
    r16[ax] = memoryAGet16(ds, 0xc623);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0xa7fb, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7fb)) >= signed16(0x0000))
        { pc = 0xa41d; break; }
    memoryASet16(ds, 0xa7fb, 0x0000);
  case 0xa41d:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a423() // 08aa:1983 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, 0xa7da))
        { pc = 0xa438; break; }
    { pc = 0xa567; break; }
  case 0xa438:
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] += 0x0900;
    if (memoryAGet16(ds, r16[si] + 34) >= r16[ax])
        { pc = 0xa454; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 34);
    r16[dx] = memoryAGet16(ds, 0xc753);
    r16[dx] += 0x0900;
    r16[ax] -= r16[dx];
    r16[di] = r16[ax];
    { pc = 0xa475; break; }
  case 0xa454:
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] += 0x0c00;
    if (memoryAGet16(ds, r16[si] + 38) <= r16[ax])
        { pc = 0xa473; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 38);
    r16[ax] += 0x0010;
    r16[dx] = memoryAGet16(ds, 0xc753);
    r16[dx] += 0x0c00;
    r16[ax] -= r16[dx];
    r16[di] = r16[ax];
    { pc = 0xa475; break; }
  case 0xa473:
    r16[di] = 0;
  case 0xa475:
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] += 0x0500;
    if (memoryAGet16(ds, r16[si] + 36) >= r16[ax])
        { pc = 0xa492; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 36);
    r16[dx] = memoryAGet16(ds, 0xc751);
    r16[dx] += 0x0500;
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xa4b4; break; }
  case 0xa492:
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] += 0x0700;
    if (memoryAGet16(ds, r16[si] + 40) <= r16[ax])
        { pc = 0xa4af; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[dx] = memoryAGet16(ds, 0xc751);
    r16[dx] += 0x0700;
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xa4b4; break; }
  case 0xa4af:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
  case 0xa4b4:
    if (r16[di])
        { pc = 0xa4c1; break; }
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xa4c1; break; }
    { pc = 0xa567; break; }
  case 0xa4c1:
    if (r16s[di] < signed16(0x0100))
        { pc = 0xa4cc; break; }
    r16[di] = 0x00ff;
    { pc = 0xa4d5; break; }
  case 0xa4cc:
    if (r16s[di] > signed16(0xff00))
        { pc = 0xa4d5; break; }
    r16[di] = 0xff01;
  case 0xa4d5:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x0100))
        { pc = 0xa4e3; break; }
    memoryASet16(ss, r16[bp] - 2, 0x00ff);
    { pc = 0xa4ef; break; }
  case 0xa4e3:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) > signed16(0xff00))
        { pc = 0xa4ef; break; }
    memoryASet16(ss, r16[bp] - 2, 0xff01);
  case 0xa4ef:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[di]);
    push(cs); cs = 0x1841; yield* sub_197ed(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x0015;
    r16[ax]--;
    memoryASet16(ds, 0xc625, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x000e;
    r16[ax]--;
    memoryASet16(ds, 0xc623, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa801, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa801)) >= signed16(0x0000))
        { pc = 0xa525; break; }
    memoryASet16(ds, 0xa801, 0x0000);
  case 0xa525:
    r16[ax] = memoryAGet16(ds, 0xc625);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0xa7ff, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7ff)) >= signed16(0x0000))
        { pc = 0xa53b; break; }
    memoryASet16(ds, 0xa7ff, 0x0000);
  case 0xa53b:
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa7fd, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7fd)) >= signed16(0x0000))
        { pc = 0xa551; break; }
    memoryASet16(ds, 0xa7fd, 0x0000);
  case 0xa551:
    r16[ax] = memoryAGet16(ds, 0xc623);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0xa7fb, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7fb)) >= signed16(0x0000))
        { pc = 0xa567; break; }
    memoryASet16(ds, 0xa7fb, 0x0000);
  case 0xa567:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a56d() // 08aa:1acd +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, 0xa7da))
        { pc = 0xa582; break; }
    { pc = 0xa838; break; }
  case 0xa582:
    r16[ax] = memoryAGet16(ds, r16[si] + 34);
    if (r16[ax] < memoryAGet16(ds, 0xc74b))
        { pc = 0xa596; break; }
    r16[ax] = memoryAGet16(ds, 0xc749);
    r16[ax] += 0x1400;
    if (memoryAGet16(ds, r16[si] + 38) <= r16[ax])
        { pc = 0xa5a2; break; }
  case 0xa596:
    memoryASet16(ds, 0x7a70, 0x0002);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xa5a2:
    r16[ax] = memoryAGet16(ds, 0xc747);
    r16[ax] += 0x0d00;
    if (memoryAGet16(ds, r16[si] + 40) <= r16[ax])
        { pc = 0xa5da; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[dx] = memoryAGet16(ds, 0xc747);
    r16[dx] += 0x0d00;
    r16[ax] -= r16[dx];
    memoryASet16(ds, r16[si] + 12, memoryAGet16(ds, r16[si] + 12) - r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ds, 0xc629, 0x0000);
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x08aa);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xa5da:
    r16[ax] = 0;
    r16[di] = r16[ax];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] += 0x0900;
    if (memoryAGet16(ds, r16[si] + 10) >= r16[ax])
        { pc = 0xa5fe; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[dx] = memoryAGet16(ds, 0xc753);
    r16[dx] += 0x0900;
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xa619; break; }
  case 0xa5fe:
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] += 0x0c00;
    if (memoryAGet16(ds, r16[si] + 10) <= r16[ax])
        { pc = 0xa619; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[dx] = memoryAGet16(ds, 0xc753);
    r16[dx] += 0x0c00;
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0xa619:
    if (memoryAGet16(ds, r16[si] + 28) != 0x0c20)
        { pc = 0xa64f; break; }
    r16[ax] = memoryAGet16(ds, 0xc5b9);
    r16[ax] += memoryAGet16(ds, 0xa54c);
    if (r16[ax] <= 0x00a7)
        { pc = 0xa638; break; }
    r16[ax] = 0x00a7;
    r16[ax] -= memoryAGet16(ds, 0xc5b9);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0xa63e; break; }
  case 0xa638:
    r16[ax] = memoryAGet16(ds, 0xa54c);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0xa63e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xc5b9, memoryAGet16(ds, 0xc5b9) + r16[ax]);
    r16[ax] = -r16[ax];
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[di] = r16[ax];
    { pc = 0xa680; break; }
  case 0xa64f:
    if (memoryAGet16(ds, r16[si] + 28) != 0x0c7a)
        { pc = 0xa680; break; }
    r16[ax] = memoryAGet16(ds, 0xc5b9);
    r16[ax] -= memoryAGet16(ds, 0xa54c);
    if (r16[ax] >= 0x0021)
        { pc = 0xa66d; break; }
    r16[ax] = memoryAGet16(ds, 0xc5b9);
    r16[ax] += 0xffdf;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0xa673; break; }
  case 0xa66d:
    r16[ax] = memoryAGet16(ds, 0xa54c);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0xa673:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xc5b9, memoryAGet16(ds, 0xc5b9) - r16[ax]);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[di] = r16[ax];
  case 0xa680:
    if (memoryAGet16(ds, r16[si] + 54))
        { pc = 0xa696; break; }
    if (!memoryAGet16(ds, r16[si] + 6))
        { pc = 0xa696; break; }
    if (memoryAGet16(ds, r16[si] + 28) == 0x12ec)
        { pc = 0xa696; break; }
    { pc = 0xa747; break; }
  case 0xa696:
    if (memoryAGet16(ds, r16[si] + 28) != 0x1328)
        { pc = 0xa6a0; break; }
    { pc = 0xa74d; break; }
  case 0xa6a0:
    if (memoryAGet16(ds, r16[si] + 28) != 0x1346)
        { pc = 0xa6aa; break; }
    { pc = 0xa74d; break; }
  case 0xa6aa:
    if (memoryAGet16(ds, r16[si] + 28) != 0x1364)
        { pc = 0xa6b4; break; }
    { pc = 0xa74d; break; }
  case 0xa6b4:
    if (memoryAGet16(ds, r16[si] + 28) != 0x1382)
        { pc = 0xa6be; break; }
    { pc = 0xa74d; break; }
  case 0xa6be:
    r16[di] += memoryAGet16(ds, r16[si] + 20);
    r16[ax] = memoryAGet16(ds, 0xc5b9);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[dx] = memoryAGet16(ds, 0xc751);
    r16[dx] += r16[di];
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xa74d; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xa6ee; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ds, r16[si] + 40);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0xa6f7; break; }
  case 0xa6ee:
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0xa6f7:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r8[cl] = 0x07;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) <= signed16(0x0030))
        { pc = 0xa710; break; }
    memoryASet16(ss, r16[bp] - 6, 0x0030);
  case 0xa710:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    imul16(memoryAGet16(ds, 0xa54c));
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) >= signed16(0x0010))
        { pc = 0xa733; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0x0010))
        { pc = 0xa72e; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    { pc = 0xa733; break; }
  case 0xa72e:
    memoryASet16(ss, r16[bp] - 6, 0x0010);
  case 0xa733:
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xa740; break; }
    r16[di] -= memoryAGet16(ss, r16[bp] - 6);
    { pc = 0xa74d; break; }
  case 0xa740:
    r16[di] += memoryAGet16(ss, r16[bp] - 6);
    { pc = 0xa74d; break; }
    // gap 2 bytes
  case 0xa747:
    memoryASet16(ds, 0xc5b9, 0x008c);
  case 0xa74d:
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= 0x0200;
    r16[dx] = memoryAGet16(ds, 0xc751);
    r16[dx] += r16[di];
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0x0000))
        { pc = 0xa767; break; }
    r16[di] += memoryAGet16(ss, r16[bp] - 4);
  case 0xa767:
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] += 0x0200;
    r16[dx] = memoryAGet16(ds, 0xc751);
    r16[dx] += r16[di];
    r16[dx] += 0x0c80;
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) <= signed16(0x0000))
        { pc = 0xa785; break; }
    r16[di] += memoryAGet16(ss, r16[bp] - 4);
  case 0xa785:
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xa792; break; }
    if (r16[di])
        { pc = 0xa792; break; }
    { pc = 0xa838; break; }
  case 0xa792:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x0100))
        { pc = 0xa7a0; break; }
    memoryASet16(ss, r16[bp] - 2, 0x00ff);
    { pc = 0xa7ac; break; }
  case 0xa7a0:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) > signed16(0xff00))
        { pc = 0xa7ac; break; }
    memoryASet16(ss, r16[bp] - 2, 0xff01);
  case 0xa7ac:
    if (r16s[di] < signed16(0x0100))
        { pc = 0xa7b7; break; }
    r16[di] = 0x00ff;
    { pc = 0xa7c0; break; }
  case 0xa7b7:
    if (r16s[di] > signed16(0xff00))
        { pc = 0xa7c0; break; }
    r16[di] = 0xff01;
  case 0xa7c0:
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1841; yield* sub_197ed(); assert(cs == 0x08aa);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x0015;
    r16[ax]--;
    memoryASet16(ds, 0xc625, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x000e;
    r16[ax]--;
    memoryASet16(ds, 0xc623, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa801, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa801)) >= signed16(0x0000))
        { pc = 0xa7f6; break; }
    memoryASet16(ds, 0xa801, 0x0000);
  case 0xa7f6:
    r16[ax] = memoryAGet16(ds, 0xc625);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0xa7ff, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7ff)) >= signed16(0x0000))
        { pc = 0xa80c; break; }
    memoryASet16(ds, 0xa7ff, 0x0000);
  case 0xa80c:
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] -= 0x0004;
    memoryASet16(ds, 0xa7fd, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7fd)) >= signed16(0x0000))
        { pc = 0xa822; break; }
    memoryASet16(ds, 0xa7fd, 0x0000);
  case 0xa822:
    r16[ax] = memoryAGet16(ds, 0xc623);
    r16[ax] += 0x0004;
    memoryASet16(ds, 0xa7fb, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xa7fb)) >= signed16(0x0000))
        { pc = 0xa838; break; }
    memoryASet16(ds, 0xa7fb, 0x0000);
  case 0xa838:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a83e() // 08aa:1d9e +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0;
    { pc = 0xa86f; break; }
  case 0xa846:
    r16[ax] = r16[si];
    r16[dx] = 0x004c;
    imul16(r16[dx]);
    r16[ax] += 0xa853;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[dx] = 0x004c;
    imul16(r16[dx]);
    r16[bx] = r16[ax];
    r16[ax] = pop();
    memoryASet16(ds, r16[bx] + 43089, r16[ax]);
    r16[ax] = r16[si];
    r16[dx] = 0x004c;
    imul16(r16[dx]);
    r16[bx] = r16[ax];
    memoryASet16(ds, r16[bx] + 43087, 0x0000);
    r16[si]++;
  case 0xa86f:
    if (r16s[si] < signed16(0x0064))
        { pc = 0xa846; break; }
    memoryASet16(ds, 0xc5b5, 0x0000);
    memoryASet16(ds, 0xa803, 0xa807);
    memoryASet16(ds, 0xa805, 0x0000);
    memoryASet16(ds, 0xc5b7, 0x0000);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_a8b1();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, 0xa7d6, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_a8b1();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, 0xa7d4, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a8b1() // 08aa:1e11 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (memoryAGet16(ds, 0xa803))
        { pc = 0xa8d8; break; }
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0xa8cc; break; }
    memoryASet16(ds, 0xa7d8, 0xc5d3);
    r16[ax] = 0xffff;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xa8cc:
    r16[ax] = 0x067f;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xa8d8:
    r16[ax] = memoryAGet16(ds, 0xa803);
    memoryASet16(ds, 0xa7d8, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    r16[ax] = memoryAGet16(ds, r16[bx] + 74);
    memoryASet16(ds, 0xa803, r16[ax]);
    r16[ax] = 0x004c;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x08aa);
    sp += 0x0006;
    if (!memoryAGet16(ds, 0xa805))
        { pc = 0xa909; break; }
    r16[bx] = memoryAGet16(ds, 0xa805);
    r16[ax] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 72, r16[ax]);
  case 0xa909:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    r16[ax] = memoryAGet16(ds, 0xa805);
    memoryASet16(ds, r16[bx] + 74, r16[ax]);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 6, 0x0001);
    r16[ax] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, 0xa805, r16[ax]);
    memoryASet16(ds, 0xc5b7, memoryAGet16(ds, 0xc5b7) + 1);
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a92b() // 08aa:1e8b +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[si] != memoryAGet16(ds, 0xa7d6))
        { pc = 0xa944; break; }
    r16[ax] = 0x06a5;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xa944:
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19c6b(); assert(cs == 0x08aa);
    sp += 0x0002;
    if (memoryAGet16(ds, r16[si]) != 0x0021)
        { pc = 0xa965; break; }
    r16[ax] = r16[si];
    r16[ax] += 0x0042;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19c6b(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xa965:
    if (r16[si] != memoryAGet16(ds, 0xa805))
        { pc = 0xa973; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 74);
    memoryASet16(ds, 0xa805, r16[ax]);
    { pc = 0xa97c; break; }
  case 0xa973:
    r16[ax] = memoryAGet16(ds, r16[si] + 74);
    r16[bx] = memoryAGet16(ds, r16[si] + 72);
    memoryASet16(ds, r16[bx] + 74, r16[ax]);
  case 0xa97c:
    r16[ax] = memoryAGet16(ds, r16[si] + 72);
    r16[bx] = memoryAGet16(ds, r16[si] + 74);
    memoryASet16(ds, r16[bx] + 72, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa803);
    memoryASet16(ds, r16[si] + 74, r16[ax]);
    memoryASet16(ds, 0xa803, r16[si]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a992() // 08aa:1ef2 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    flags.carry = memoryAGet16(ds, 0x7a50) + r16[ax] >= 0x10000;
    memoryASet16(ds, 0x7a50, memoryAGet16(ds, 0x7a50) + r16[ax]);
    memoryASet16(ds, 0x7a52, memoryAGet16(ds, 0x7a52) + (0x0000 + flags.carry));
    if (memoryAGet16(ds, 0x3bd6))
        { pc = 0xa9e5; break; }
    r16[ax] = memoryAGet16(ds, 0x7a52);
    r16[dx] = memoryAGet16(ds, 0x7a50);
    if (r16s[ax] < signed16(memoryAGet16(ds, 0x7a56)))
        { pc = 0xa9e5; break; }
    if (r16[ax] != memoryAGet16(ds, 0x7a56))
        { pc = 0xa9bd; break; }
    if (r16[dx] < memoryAGet16(ds, 0x7a54))
        { pc = 0xa9e5; break; }
  case 0xa9bd:
    r16[ax] = 0x0011;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x08aa);
    sp += 0x0002;
    memoryASet16(ds, 0x7a6a, memoryAGet16(ds, 0x7a6a) + 1);
    r16[cx] = 0;
    r16[bx] = 0x0002;
    r16[dx] = memoryAGet16(ds, 0x7a56);
    r16[ax] = memoryAGet16(ds, 0x7a54);
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x08aa);
    memoryASet16(ds, 0x7a56, r16[dx]);
    memoryASet16(ds, 0x7a54, r16[ax]);
  case 0xa9e5:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_a9e7() // 08aa:1f47 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0xa7c6;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16e8e(); assert(cs == 0x08aa);
    sp += 0x0004;
    if (memoryAGet16(ds, 0xa7d0) == 0xffff)
        { pc = 0xaa06; break; }
    memoryASet16(ds, 0xc5bd, 0x0000);
  case 0xaa06:
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0xaa54; break; }
    if (memoryAGet16(ds, 0x3bd6))
        { pc = 0xaa54; break; }
    r16[ax] = memoryAGet16(ds, 0xc63b);
    memoryASet16(ds, 0xc5c9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc63d);
    memoryASet16(ds, 0xc5c5, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc63f);
    memoryASet16(ds, 0xc5c1, r16[ax]);
    if (memoryAGet16(ds, 0xc5c9))
        { pc = 0xaa33; break; }
    memoryASet16(ds, 0xc5c7, 0x0000);
  case 0xaa33:
    if (memoryAGet16(ds, 0xc5c5))
        { pc = 0xaa40; break; }
    memoryASet16(ds, 0xc5c3, 0x0000);
  case 0xaa40:
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xaa4a; break; }
    { pc = 0xab30; break; }
  case 0xaa4a:
    memoryASet16(ds, 0xc5bf, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0xaa54:
    if (memoryAGet16(ds, 0xc5cf))
        { pc = 0xaa65; break; }
    if (memoryAGet16(ds, 0x3bd6))
        { pc = 0xaa65; break; }
    { pc = 0xaaed; break; }
  case 0xaa65:
    if (!memoryAGet16(ds, 0xa7c6))
        { pc = 0xaa89; break; }
    if (!memoryAGet16(ds, 0xa7c8))
        { pc = 0xaa89; break; }
    memoryASet16(ds, 0xc5c1, 0x0001);
    r16[ax] = 0;
    memoryASet16(ds, 0xc5c3, r16[ax]);
    memoryASet16(ds, 0xc5c7, r16[ax]);
    memoryASet16(ds, 0xc5c5, r16[ax]);
    memoryASet16(ds, 0xc5c9, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xaa89:
    r16[ax] = 0;
    memoryASet16(ds, 0xc5bf, r16[ax]);
    memoryASet16(ds, 0xc5c1, r16[ax]);
    if (!memoryAGet16(ds, 0xa7c6))
        { pc = 0xaaa0; break; }
    memoryASet16(ds, 0xc5c9, 0x0001);
    { pc = 0xaaa8; break; }
  case 0xaaa0:
    r16[ax] = 0;
    memoryASet16(ds, 0xc5c7, r16[ax]);
    memoryASet16(ds, 0xc5c9, r16[ax]);
  case 0xaaa8:
    if (!memoryAGet16(ds, 0xa7c8))
        { pc = 0xaacc; break; }
    if (signed16(memoryAGet16(ds, 0xa7f1)) > signed16(0x0008))
        { pc = 0xaac2; break; }
    r16[ax] = memoryAGet16(ds, 0xa7f1);
    r16[ax] += memoryAGet16(ds, 0xa54c);
    memoryASet16(ds, 0xa7f1, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xaac2:
    memoryASet16(ds, 0xc5c5, 0x0001);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0xaacc:
    if (!memoryAGet16(ds, 0xa7f1))
        { pc = 0xaadb; break; }
    memoryASet16(ds, 0xc5c5, 0x0001);
    { pc = 0xaae3; break; }
  case 0xaadb:
    r16[ax] = 0;
    memoryASet16(ds, 0xc5c3, r16[ax]);
    memoryASet16(ds, 0xc5c5, r16[ax]);
  case 0xaae3:
    memoryASet16(ds, 0xa7f1, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0xaaed:
    r16[ax] = memoryAGet16(ds, 0xa7c6);
    memoryASet16(ds, 0xc5c9, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7c8);
    memoryASet16(ds, 0xc5c5, r16[ax]);
    r8[al] = memoryAGet(ds, 0x0394);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx] + 50759);
    memoryASet16(ds, 0xc5c1, r16[ax]);
    if (memoryAGet16(ds, 0xc5c9))
        { pc = 0xab16; break; }
    memoryASet16(ds, 0xc5c7, 0x0000);
  case 0xab16:
    if (memoryAGet16(ds, 0xc5c5))
        { pc = 0xab23; break; }
    memoryASet16(ds, 0xc5c3, 0x0000);
  case 0xab23:
    if (memoryAGet16(ds, 0xc5c1))
        { pc = 0xab30; break; }
    memoryASet16(ds, 0xc5bf, 0x0000);
  case 0xab30:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ab32() // 08aa:2092 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(cs); cs = 0x1a61; yield* sub_1b125(); assert(cs == 0x08aa);
    r16[si] = 0;
    { pc = 0xab5f; break; }
  case 0xab3f:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 51349))
        { pc = 0xab5e; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xc895;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x08aa);
    sp += 0x0004;
  case 0xab5e:
    r16[si]++;
  case 0xab5f:
    if (r16s[si] < signed16(0x0006))
        { pc = 0xab3f; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ab67() // 08aa:20c7 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[si] < 0x0014)
        { pc = 0xab88; break; }
    if (r16[si] == 0xffff)
        { pc = 0xab88; break; }
    r16[ax] = 0x06cc;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xab88:
    push(cs); cs = 0x1a61; yield* sub_1b125(); assert(cs == 0x08aa);
    if (r16[si] != 0xffff)
        { pc = 0xab97; break; }
    r16[di] = 0x0005;
    { pc = 0xab9f; break; }
  case 0xab97:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[di] = memoryAGet16(ds, r16[bx] + 918);
  case 0xab9f:
    if (r16[di] != 0xffff)
        { pc = 0xaba7; break; }
    { pc = 0xac60; break; }
  case 0xaba7:
    if (memoryAGet16(ds, 0xc633) == 0x0001)
        { pc = 0xabb1; break; }
    { pc = 0xac60; break; }
  case 0xabb1:
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_18414(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = r16[di];
    r16[ax] += 0x009c;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_152f2(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_18414(); assert(cs == 0x08aa);
    sp += 0x0002;
    if (!memoryAGet16(ds, 0xa7ef))
        { pc = 0xac4d; break; }
    memoryASet16(ds, 0xa7ef, 0x0000);
    if (memoryAGet16(ds, 0x3bd6))
        { pc = 0xac60; break; }
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x08aa);
    sp += 0x0004;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0014);
    r16[ax] = 0x06ec;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x08aa);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x08aa);
    r16[ax] = memoryAGet16(ds, 0xc757);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xac21; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f082(); assert(cs == 0x08aa);
  case 0xac21:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x08aa);
    r16[ax] = 0;
    push(r16[ax]);
    r16[dx] = 0x00d2;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x164d; yield* sub_17462(); assert(cs == 0x08aa);
    sp += 0x0006;
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xac60; break; }
    push(cs); cs = 0x1ef3; yield* sub_1f09f(); assert(cs == 0x08aa);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 6 bytes
  case 0xac4d:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 51349));
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b172(); assert(cs == 0x08aa);
    sp += 0x0004;
  case 0xac60:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ac66() // 08aa:21c6 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(memoryAGet16(ds, 0x7a68));
    push(cs);
    yield* sub_ab67();
    sp += 0x0002;
    r16[ax] = 0;
    memoryASet16(ds, 0xc5c7, r16[ax]);
    memoryASet16(ds, 0xc5bd, r16[ax]);
    memoryASet16(ds, 0xc5c3, r16[ax]);
    memoryASet16(ds, 0xc5bf, r16[ax]);
    memoryASet16(ds, 0xc631, 0x0001);
    memoryASet16(ds, 0x7a70, 0x0000);
    r16[ax] = 0;
    memoryASet16(ds, 0xa7f1, r16[ax]);
    memoryASet16(ds, 0xa7da, r16[ax]);
    memoryASet16(ds, 0xc5d1, r16[ax]);
    push(memoryAGet16(ds, 0xa7d6));
    push(cs);
    yield* sub_a345();
    sp += 0x0002;
    if (!memoryAGet16(ds, 0x3bd6))
        { pc = 0xacb9; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1eef2(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0xacc5; break; }
  case 0xacb9:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1eef2(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xacc5:
    r16[ax] = 0x0003;
    memoryASet16(ds, 0xa54c, r16[ax]);
    r16[dx] = 0;
    memoryASet16(ds, 0xa54a, r16[dx]);
    memoryASet16(ds, 0xa548, r16[ax]);
    memoryASet16(ds, 0xa53f, r16[dx]);
    memoryASet16(ds, 0xa53d, r16[ax]);
  case 0xacdb:
    push(cs);
    yield* sub_a9e7();
    r16[ax] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, 0xc5bb, r16[ax]);
    { pc = 0xadd4; break; }
  case 0xace8:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (memoryAGet16(ds, r16[bx] + 2))
        { pc = 0xad20; break; }
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax]--;
    if (memoryAGet16(ds, r16[bx] + 48) < r16[ax])
        { pc = 0xad20; break; }
    r16[ax] = memoryAGet16(ds, 0xc625);
    r16[ax]++;
    if (memoryAGet16(ds, r16[bx] + 44) > r16[ax])
        { pc = 0xad20; break; }
    r16[ax] = memoryAGet16(ds, 0xc623);
    r16[ax]++;
    if (memoryAGet16(ds, r16[bx] + 46) > r16[ax])
        { pc = 0xad20; break; }
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax]--;
    if (memoryAGet16(ds, r16[bx] + 50) < r16[ax])
        { pc = 0xad20; break; }
    memoryASet16(ds, r16[bx] + 4, 0x0001);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
  case 0xad20:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (memoryAGet16(ds, r16[bx] + 2))
        { pc = 0xad2d; break; }
    { pc = 0xadca; break; }
  case 0xad2d:
    r16[ax] = memoryAGet16(ds, r16[bx] + 48);
    if (r16[ax] < memoryAGet16(ds, 0xa801))
        { pc = 0xad51; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 44);
    if (r16[ax] > memoryAGet16(ds, 0xa7ff))
        { pc = 0xad51; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 46);
    if (r16[ax] > memoryAGet16(ds, 0xa7fb))
        { pc = 0xad51; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 50);
    if (r16[ax] >= memoryAGet16(ds, 0xa7fd))
        { pc = 0xadbe; break; }
  case 0xad51:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (memoryAGet16(ds, r16[bx] + 2) != 0x0003)
        { pc = 0xad65; break; }
    push(r16[bx]);
    push(cs);
    yield* sub_a92b();
    sp += 0x0002;
    { pc = 0xadca; break; }
  case 0xad65:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (memoryAGet16(ds, r16[bx] + 2) == 0x0002)
        { pc = 0xadbe; break; }
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x08aa);
    r16[dx] = memoryAGet16(ds, 0xa54c);
    r16[dx] <<= 1;
    if (r16[ax] < r16[dx])
        { pc = 0xad8c; break; }
    if (memoryAGet16(ds, 0xc757))
        { pc = 0xad8c; break; }
    if (!memoryAGet16(ds, 0xa53b))
        { pc = 0xadbe; break; }
  case 0xad8c:
    r16[ax] = memoryAGet16(ds, 0xc5bb);
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19c6b(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (memoryAGet16(ds, r16[bx]) != 0x0021)
        { pc = 0xadb3; break; }
    r16[ax] = memoryAGet16(ds, 0xc5bb);
    r16[ax] += 0x0042;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19c6b(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xadb3:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    memoryASet16(ds, r16[bx] + 2, 0x0000);
    { pc = 0xadca; break; }
  case 0xadbe:
    push(memoryAGet16(ds, 0xc5bb));
    push(cs); cs = 0x0bc9; yield* sub_cd27(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xadca:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    r16[ax] = memoryAGet16(ds, r16[bx] + 72);
    memoryASet16(ds, 0xc5bb, r16[ax]);
  case 0xadd4:
    if (!memoryAGet16(ds, 0xc5bb))
        { pc = 0xadde; break; }
    { pc = 0xace8; break; }
  case 0xadde:
    if (!memoryAGet16(ds, 0x7a6e))
        { pc = 0xadf1; break; }
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0d6d; yield* sub_ed9d(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xadf1:
    r16[ax] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, 0xc5bb, r16[ax]);
    { pc = 0xae80; break; }
  case 0xadfa:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (!memoryAGet16(ds, r16[bx] + 2))
        { pc = 0xae76; break; }
    r16[si] = memoryAGet16(ds, r16[bx] + 72);
    { pc = 0xae72; break; }
  case 0xae09:
    if (!memoryAGet16(ds, r16[si] + 2))
        { pc = 0xae6f; break; }
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    r16[ax] = memoryAGet16(ds, r16[bx] + 38);
    if (r16[ax] <= memoryAGet16(ds, r16[si] + 34))
        { pc = 0xae6f; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 34);
    if (r16[ax] >= memoryAGet16(ds, r16[si] + 38))
        { pc = 0xae6f; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 36);
    if (r16[ax] >= memoryAGet16(ds, r16[si] + 40))
        { pc = 0xae6f; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 40);
    if (r16[ax] <= memoryAGet16(ds, r16[si] + 36))
        { pc = 0xae6f; break; }
    r16[bx] = memoryAGet16(ds, r16[bx] + 28);
    r16[ax] = memoryAGet16(ds, r16[bx] + 20);
    r16[ax] |= memoryAGet16(ds, r16[bx] + 22);
    if (!r16[ax])
        { pc = 0xae50; break; }
    push(r16[si]);
    push(memoryAGet16(ds, 0xc5bb));
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    r16[bx] = memoryAGet16(ds, r16[bx] + 28);
    switch (memoryAGet32(ds, r16[bx] + 20))
    {
        case 0x0d6d14a9: push(cs); cs = 0x0d6d; yield* sub_eb79(); assert(cs == 0x08aa); break;
        case 0x119503ea: push(cs); cs = 0x1195; yield* sub_11d3a(); assert(cs == 0x08aa); break;
        default:
            stop("ind 08aa:23aa");
    }
    sp += 0x0004;
  case 0xae50:
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[ax] = memoryAGet16(ds, r16[bx] + 20);
    r16[ax] |= memoryAGet16(ds, r16[bx] + 22);
    if (!r16[ax])
        { pc = 0xae66; break; }
    push(memoryAGet16(ds, 0xc5bb));
    push(r16[si]);
    switch (memoryAGet32(ds, r16[bx] + 20))
    {
        case 0x126d0938: push(cs); cs = 0x126d; yield* sub_13008(); assert(cs == 0x08aa); break;
        case 0x0bc91752: push(cs); cs = 0x0bc9; yield* sub_d3e2(); assert(cs == 0x08aa); break;
        default:
            stop("ind 08aa:23c0");
    }
    sp += 0x0004;
  case 0xae66:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (!memoryAGet16(ds, r16[bx]))
        { pc = 0xae76; break; }
  case 0xae6f:
    r16[si] = memoryAGet16(ds, r16[si] + 72);
  case 0xae72:
    if (r16[si])
        { pc = 0xae09; break; }
  case 0xae76:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    r16[ax] = memoryAGet16(ds, r16[bx] + 72);
    memoryASet16(ds, 0xc5bb, r16[ax]);
  case 0xae80:
    if (!memoryAGet16(ds, 0xc5bb))
        { pc = 0xae8a; break; }
    { pc = 0xadfa; break; }
  case 0xae8a:
    if (!memoryAGet16(ds, 0xa7ed))
        { pc = 0xae9f; break; }
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0d6d; yield* sub_efb9(); assert(cs == 0x08aa);
    sp += 0x0002;
    { pc = 0xaeab; break; }
  case 0xae9f:
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0f7c; yield* sub_10069(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xaeab:
    r16[ax] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, 0xc5bb, r16[ax]);
    { pc = 0xaf18; break; }
  case 0xaeb3:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (!memoryAGet16(ds, r16[bx] + 2))
        { pc = 0xaf0e; break; }
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    r16[ax] = memoryAGet16(ds, 0xa7e2);
    r16[ax]--;
    if (memoryAGet16(ds, r16[bx] + 50) < r16[ax])
        { pc = 0xaee6; break; }
    if (memoryAGet16(ds, r16[bx]) != 0x0002)
        { pc = 0xaed7; break; }
    memoryASet16(ds, 0x7a70, 0x0001);
    { pc = 0xaf0e; break; }
  case 0xaed7:
    push(memoryAGet16(ds, 0xc5bb));
    push(cs);
    yield* sub_a92b();
    sp += 0x0002;
    { pc = 0xaf0e; break; }
    // gap 2 bytes
  case 0xaee6:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    if (!memoryAGet16(ds, r16[bx] + 4))
        { pc = 0xaf0e; break; }
    r16[bx] = memoryAGet16(ds, r16[bx] + 28);
    r16[ax] = memoryAGet16(ds, r16[bx] + 24);
    r16[ax] |= memoryAGet16(ds, r16[bx] + 26);
    if (!r16[ax])
        { pc = 0xaf0e; break; }
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    memoryASet16(ds, r16[bx] + 4, 0x0000);
    push(r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[bx] + 28);
    switch (memoryAGet32(ds, r16[bx] + 24))
    {
        case 0x0bc9176e: push(cs); cs = 0x0bc9; yield* sub_d3fe(); assert(cs == 0x08aa); break;
        case 0x0d6d1aa2: push(cs); cs = 0x0d6d; yield* sub_f172(); assert(cs == 0x08aa); break;
        case 0x126d097e: push(cs); cs = 0x126d; yield* sub_1304e(); assert(cs == 0x08aa); break;
        case 0x0d6d1b5f: push(cs); cs = 0x0d6d; yield* sub_f22f(); assert(cs == 0x08aa); break;
        case 0x0d6d1c48: push(cs); cs = 0x0d6d; yield* sub_f318(); assert(cs == 0x08aa); break;
        case 0x0bc91847: push(cs); cs = 0x0bc9; yield* sub_d4d7(); assert(cs == 0x08aa); break;
        default:
            stop("ind 08aa:2468");
    }
    sp += 0x0002;
  case 0xaf0e:
    r16[bx] = memoryAGet16(ds, 0xc5bb);
    r16[ax] = memoryAGet16(ds, r16[bx] + 72);
    memoryASet16(ds, 0xc5bb, r16[ax]);
  case 0xaf18:
    if (memoryAGet16(ds, 0xc5bb))
        { pc = 0xaeb3; break; }
    if (!memoryAGet16(ds, 0xa7ed))
        { pc = 0xaf3a; break; }
    if (memoryAGet16(ds, 0xa7ed) == 0x0011)
        { pc = 0xaf3a; break; }
    push(memoryAGet16(ds, 0xa7d6));
    push(cs);
    yield* sub_a56d();
    sp += 0x0002;
    { pc = 0xaf45; break; }
  case 0xaf3a:
    push(memoryAGet16(ds, 0xa7d6));
    push(cs);
    yield* sub_a423();
    sp += 0x0002;
  case 0xaf45:
    push(memoryAGet16(ds, 0xa7d4));
    push(cs); cs = 0x0f7c; yield* sub_f90f(); assert(cs == 0x08aa);
    sp += 0x0002;
    if (!memoryAGet16(ds, 0xa53b))
        { pc = 0xaf5e; break; }
    memoryASet16(ds, 0xa53b, 0x0000);
  case 0xaf5e:
    push(cs); cs = 0x1841; yield* sub_1a07e(); assert(cs == 0x08aa);
    if (!memoryAGet16(ds, 0xc5d1))
        { pc = 0xaf7e; break; }
    r16[ax] = memoryAGet16(ds, 0xc5d1);
    r16[ax] -= memoryAGet16(ds, 0xa54c);
    memoryASet16(ds, 0xc5d1, r16[ax]);
    if (r16s[ax] >= 0)
        { pc = 0xaf7e; break; }
    memoryASet16(ds, 0xc5d1, 0x0000);
  case 0xaf7e:
    if (!memoryAGet16(ds, 0xc62d))
        { pc = 0xaf9f; break; }
    r16[ax] = 0x000e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x08aa);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
  case 0xaf9f:
    if (!memoryAGet16(ds, 0xa7f9))
        { pc = 0xafb2; break; }
    push(memoryAGet16(ds, 0xa7f9));
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x08aa);
    sp += 0x0002;
  case 0xafb2:
    if (memoryAGet16(ds, 0x3bd6) != 0x0002)
        { pc = 0xafdf; break; }
    if (memoryAGet16(ds, 0xc757))
        { pc = 0xaff2; break; }
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x08aa);
    if (!r16[ax])
        { pc = 0xaff2; break; }
    memoryASet16(ds, 0x7a70, 0x0002);
    if (memoryAGet(ds, 0xa545) == 0x3b)
        { pc = 0xaff2; break; }
    memoryASet(ds, 0xa545, 0x39);
    { pc = 0xaff2; break; }
    // gap 2 bytes
  case 0xafdf:
    if (memoryAGet16(ds, 0x3bd6) != 0x0003)
        { pc = 0xafee; break; }
    memoryASet16(ds, 0x7a70, 0x0002);
    { pc = 0xaff2; break; }
  case 0xafee:
    push(cs);
    yield* sub_9775();
  case 0xaff2:
    if (!memoryAGet16(ds, 0xc66b))
        { pc = 0xb013; break; }
    if (!memoryAGet16(ds, 0xc6a9))
        { pc = 0xb013; break; }
    if (!memoryAGet16(ds, 0xc687))
        { pc = 0xb013; break; }
    memoryASet16(ds, 0x7a5e, 0x0007);
    memoryASet16(ds, 0x7a70, 0x0003);
  case 0xb013:
    if (memoryAGet16(ds, 0x7a70))
        { pc = 0xb01d; break; }
    { pc = 0xacdb; break; }
  case 0xb01d:
    memoryASet16(ds, 0xc631, 0x0000);
    push(cs);
    yield* sub_ab32();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b02a() // 0b02:000a +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
  case 0xb02d:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    if (memoryAGet(es, r16[bx]) != 0x0a)
        { pc = 0xb02d; break; }
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b03d() // 0b02:001d +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0052;
    push(r16[si]);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    { pc = 0xb05e; break; }
  case 0xb050:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
  case 0xb05e:
    if (signed8(memoryAGet(ss, r16[bp] - 1)) < signed8(0x30))
        { pc = 0xb050; break; }
    if (signed8(memoryAGet(ss, r16[bp] - 1)) > signed8(0x39))
        { pc = 0xb050; break; }
    r16[ax] = r16[bp] - 82;
    r16[si] = r16[ax];
  case 0xb06f:
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    memoryASet(ds, r16[si], r8[al]);
    r16[si]++;
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    if (signed8(memoryAGet(ss, r16[bp] - 1)) < signed8(0x30))
        { pc = 0xb08f; break; }
    if (signed8(memoryAGet(ss, r16[bp] - 1)) <= signed8(0x39))
        { pc = 0xb06f; break; }
  case 0xb08f:
    memoryASet(ds, r16[si], 0x00);
    r16[ax] = r16[bp] - 82;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_349f(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b0a3() // 0b02:0083 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8ab, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8ad, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8a9, r16[ax]);
    push(cs);
    yield* sub_b02a();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_b0c1() // 0b02:00a1 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8ab, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8ad, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8a9, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8a7, r16[ax]);
    push(cs);
    yield* sub_b02a();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_b0e6() // 0b02:00c6 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_b0c1();
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x00c8;
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(memoryAGet16(ds, 0xa7b4));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x0b02);
    sp += 0x0008;
    memoryASet16(ds, 0xa53f, 0x0000);
    memoryASet16(ds, 0xa53d, 0x0000);
  case 0xb11d:
    r16[ax] = memoryAGet16(ds, 0xc8a7);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    if (r16[dx] > memoryAGet16(ds, 0xa53f))
        { pc = 0xb11d; break; }
    if (r16[dx] != memoryAGet16(ds, 0xa53f))
        { pc = 0xb12f; break; }
    if (r16[ax] > memoryAGet16(ds, 0xa53d))
        { pc = 0xb11d; break; }
  case 0xb12f:
    push(memoryAGet16(ds, 0xc8a9));
    push(memoryAGet16(ds, 0xc8ab));
    r16[ax] = memoryAGet16(ds, 0xc8ad);
    r16[ax] &= 0xfff8;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b148() // 0b02:0128 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_332b(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] -= 0x0042;
    r16[bx] = r16[ax];
    if (r16[bx] <= 0x0012)
        { pc = 0xb172; break; }
    { pc = 0xb34b; break; }
  case 0xb172:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0xb179; break; }
        case 2: { pc = 0xb1c9; break; }
        case 4: { pc = 0xb34b; break; }
        case 6: { pc = 0xb1b9; break; }
        case 8: { pc = 0xb34b; break; }
        case 10: { pc = 0xb25d; break; }
        case 12: { pc = 0xb34b; break; }
        case 14: { pc = 0xb34b; break; }
        case 16: { pc = 0xb34b; break; }
        case 18: { pc = 0xb34b; break; }
        case 20: { pc = 0xb21a; break; }
        case 22: { pc = 0xb34b; break; }
        case 24: { pc = 0xb34b; break; }
        case 26: { pc = 0xb34b; break; }
        case 28: { pc = 0xb1b9; break; }
        case 30: { pc = 0xb34b; break; }
        case 32: { pc = 0xb34b; break; }
        case 34: { pc = 0xb34b; break; }
        case 36: { pc = 0xb253; break; }
        default:
            stop("ind 0b02:0154");
    }
    break;
  case 0xb179:
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8ab, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0xc8ad, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ds, 0xc8ab));
    push(memoryAGet16(ds, 0xc8ad));
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x0b02);
    sp += 0x000a;
    push(cs);
    yield* sub_b02a();
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb1b9:
    memoryASet16(ds, 0xc8a5, 0x0001);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) - 1);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb1c9:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_332b(); assert(cs == 0x0b02);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x0030))
        { pc = 0xb1f7; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) > signed16(0x0039))
        { pc = 0xb1f7; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0xd0;
    memoryASet(ds, 0x6025, r8[al]);
    { pc = 0xb20b; break; }
  case 0xb1f7:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x0041))
        { pc = 0xb20b; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) > signed16(0x0046))
        { pc = 0xb20b; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0xc9;
    memoryASet(ds, 0x6025, r8[al]);
  case 0xb20b:
    memoryASet(ds, 0x6025, memoryAGet(ds, 0x6025) ^ 0x04);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb21a:
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0x6022, r16[ax]);
    r16[ax] += 0xfff6;
    r16[bx] = 0x000a;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ds, 0xc8af, r16[ax]);
    r16[dx] = 0x000a;
    imul16(r16[dx]);
    r16[ax] += 0x000a;
    memoryASet16(ds, 0x6022, r16[ax]);
    push(cs);
    yield* sub_b03d();
    memoryASet16(ds, 0x6020, r16[ax]);
  case 0xb23f:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    if (memoryAGet(es, r16[bx]) != 0x0a)
        { pc = 0xb23f; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb253:
    push(cs);
    yield* sub_b0e6();
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb25d:
    push(cs);
    yield* sub_b0a3();
    push(memoryAGet16(ds, 0xc8a9));
    push(memoryAGet16(ds, 0xc8ab));
    r16[ax] = memoryAGet16(ds, 0xc8ad);
    r16[ax] &= 0xfff8;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[bx] = memoryAGet16(ds, 0xc8a9);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa552);
    r16[ax] = memoryAGet16(es, r16[bx] - 24);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xc8a9);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] - 22);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] = 0x0002;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[dx] = memoryAGet16(ds, 0xc8ad);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 10, r16[dx]);
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) <= signed16(0x00a0))
        { pc = 0xb2c3; break; }
    r16[ax] = memoryAGet16(ds, 0xc8ad);
    r16[ax] += 0xfff8;
    r16[si] = r16[ax];
    { pc = 0xb2ce; break; }
  case 0xb2c3:
    r16[ax] = memoryAGet16(ds, 0xc8ad);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += 0x0008;
    r16[si] = r16[ax];
  case 0xb2ce:
    r16[ax] = memoryAGet16(ds, 0xc8ab);
    r16[ax] += 0xfff6;
    r16[bx] = 0x000a;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0x0000))
        { pc = 0xb2e8; break; }
    memoryASet16(ss, r16[bp] - 4, 0x0000);
  case 0xb2e8:
    r16[ax] = memoryAGet16(ds, 0xc8ab);
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xfff6;
    r16[bx] = 0x000a;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[di] = r16[ax];
    if (r16s[di] < signed16(0x0012))
        { pc = 0xb301; break; }
    r16[di] = 0x0011;
  case 0xb301:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xb327; break; }
  case 0xb309:
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) <= signed16(0x00a0))
        { pc = 0xb31b; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51381, r16[si]);
    { pc = 0xb324; break; }
  case 0xb31b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51417, r16[si]);
  case 0xb324:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0xb327:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) <= r16s[di])
        { pc = 0xb309; break; }
    r16[bx] = memoryAGet16(ds, 0xc8af);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51417);
    if (r16[ax] <= memoryAGet16(ds, 0x6020))
        { pc = 0xb34b; break; }
    r16[bx] = memoryAGet16(ds, 0xc8af);
    r16[bx] <<= 1;
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb34b:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b377() // 0b02:0357 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    memoryASet16(ds, 0xc8af, memoryAGet16(ds, 0xc8af) + 1);
    r16[ax] = memoryAGet16(ds, 0xc8af);
    if (r16[ax] != 0x0012)
        { pc = 0xb3c6; break; }
    memoryASet16(ds, 0xc8a5, 0x0001);
  case 0xb38f:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    if (memoryAGet(es, r16[bx]) != 0x5e)
        { pc = 0xb3c0; break; }
    r8[al] = memoryAGet(es, r16[bx] + 1);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_332b(); assert(cs == 0x0b02);
    sp += 0x0002;
    memoryASet(ss, r16[bp] - 1, r8[al]);
    if (memoryAGet(ss, r16[bp] - 1) == 0x45)
        { pc = 0xb3b6; break; }
    if (memoryAGet(ss, r16[bp] - 1) != 0x50)
        { pc = 0xb3c0; break; }
  case 0xb3b6:
    memoryASet16(ds, 0xc8a5, 0x0001);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb3c0:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    { pc = 0xb38f; break; }
  case 0xb3c6:
    r16[bx] = memoryAGet16(ds, 0xc8af);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51417);
    memoryASet16(ds, 0x6020, r16[ax]);
    memoryASet16(ds, 0x6022, memoryAGet16(ds, 0x6022) + 0x000a);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b3dc() // 0b02:03bc +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    if (memoryAGet(ss, r16[bp] - 1) != 0x0a)
        { pc = 0xb3fa; break; }
    push(cs);
    yield* sub_b377();
  case 0xb3fa:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b3fe() // 0b02:03de +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0056;
    push(r16[si]);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 86, r8[al]);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[si] = 0x0001;
    { pc = 0xb43a; break; }
  case 0xb418:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] + r16[si] - 86, r8[al]);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[si]++;
    r16[ax] = r16[si];
    if (r16[ax] != 0x0050)
        { pc = 0xb43a; break; }
    r16[ax] = 0x0720;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x0b02);
    sp += 0x0002;
  case 0xb43a:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    if (signed8(memoryAGet(es, r16[bx])) > signed8(0x20))
        { pc = 0xb418; break; }
    memoryASet(ss, r16[bp] + r16[si] - 86, 0x00);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 86;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x0b02);
    sp += 0x0008;
    { pc = 0xb46a; break; }
  case 0xb45f:
    push(cs);
    yield* sub_b377();
    if (memoryAGet16(ds, 0xc8a5))
        { pc = 0xb4ad; break; }
  case 0xb46a:
    r16[bx] = memoryAGet16(ds, 0xc8af);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0x6020);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(ds, r16[bx] + 51381) < r16[ax])
        { pc = 0xb45f; break; }
    r16[ax] = memoryAGet16(ds, 0x6020);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 86;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x0b02);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0x6020, r16[ax]);
    { pc = 0xb4a3; break; }
  case 0xb49a:
    memoryASet16(ds, 0x6020, memoryAGet16(ds, 0x6020) + 0x0007);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
  case 0xb4a3:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    if (memoryAGet(es, r16[bx]) == 0x20)
        { pc = 0xb49a; break; }
  case 0xb4ad:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b4b2() // 0b02:0492 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r8[al] = memoryAGet(ds, 0x6025);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet(ds, 0x6025, 0x0a);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x00c8;
    push(r16[ax]);
    r16[ax] = 0x0140;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x0b02);
    sp += 0x000a;
    r16[ax] = 0x0050;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x0051;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x0052;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0138;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    if (!r16[di])
        { pc = 0xb533; break; }
    r16[ax] = 0x0053;
    push(r16[ax]);
    r16[ax] = 0x00b0;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    { pc = 0xb547; break; }
  case 0xb533:
    r16[ax] = 0x0054;
    push(r16[ax]);
    r16[ax] = 0x00c0;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
  case 0xb547:
    r16[si] = 0;
    { pc = 0xb560; break; }
  case 0xb54b:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51417, 0x000a);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51381, 0x0136);
    r16[si]++;
  case 0xb560:
    if (r16s[si] < signed16(0x0012))
        { pc = 0xb54b; break; }
    memoryASet16(ds, 0x6020, 0x000a);
    memoryASet16(ds, 0x6022, 0x000a);
    memoryASet16(ds, 0xc8af, 0x0000);
    memoryASet16(ds, 0xc8a5, 0x0000);
    { pc = 0xb583; break; }
  case 0xb57f:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
  case 0xb583:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    if (signed8(memoryAGet(es, r16[bx])) <= signed8(0x20))
        { pc = 0xb57f; break; }
    if (memoryAGet(es, r16[bx]) != 0x5e)
        { pc = 0xb5ad; break; }
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_332b(); assert(cs == 0x0b02);
    sp += 0x0002;
    if (r16[ax] == 0x0050)
        { pc = 0xb5bb; break; }
  case 0xb5ad:
    r16[ax] = 0x0740;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x0b02);
    sp += 0x0002;
    { pc = 0xb5bb; break; }
  case 0xb5bb:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    if (memoryAGet(es, r16[bx]) != 0x0a)
        { pc = 0xb5bb; break; }
  case 0xb5c9:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    memoryASet(ss, r16[bp] - 3, r8[al]);
    if (memoryAGet(ss, r16[bp] - 3) != 0x5e)
        { pc = 0xb5df; break; }
    push(cs);
    yield* sub_b148();
    { pc = 0xb5ef; break; }
  case 0xb5df:
    if (signed8(memoryAGet(ss, r16[bp] - 3)) > signed8(0x20))
        { pc = 0xb5eb; break; }
    push(cs);
    yield* sub_b3dc();
    { pc = 0xb5ef; break; }
  case 0xb5eb:
    push(cs);
    yield* sub_b3fe();
  case 0xb5ef:
    if (!memoryAGet16(ds, 0xc8a5))
        { pc = 0xb5c9; break; }
    memoryASet16(ds, 0xc8ff, memoryAGet16(ds, 0xc8ff) + 1);
    if (r16[di])
        { pc = 0xb601; break; }
    { pc = 0xb687; break; }
  case 0xb601:
    r16[ax] = 0x0764;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x0b02);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x7a74;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xc8ff));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x7a74;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x0b02);
    sp += 0x0004;
    r16[ax] = 0x0768;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x0b02);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x7a74;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xc8fd));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x7a74;
    push(r16[ax]);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x0b02);
    sp += 0x0004;
    memoryASet(ds, 0x6025, 0x08);
    memoryASet16(ds, 0x6022, 0x00ba);
    memoryASet16(ds, 0x6020, 0x00da);
    push(ds);
    r16[ax] = 0x7a88;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x0b02);
    sp += 0x0004;
  case 0xb687:
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    memoryASet(ds, 0x6025, r8[al]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b693() // 0b02:0673 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xc8ff, memoryAGet16(ds, 0xc8ff) - 1);
  case 0xb69a:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) - 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    if (memoryAGet(es, r16[bx]) != 0x5e)
        { pc = 0xb69a; break; }
    r8[al] = memoryAGet(es, r16[bx] + 1);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_332b(); assert(cs == 0x0b02);
    sp += 0x0002;
    if (r16[ax] != 0x0050)
        { pc = 0xb69a; break; }
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b6c1() // 0b02:06a1 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    r16[ax] = memoryAGet16(ds, 0xc8b3);
    r16[dx] = memoryAGet16(ds, 0xc8b1);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[dx] += 0x7530;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = 0;
    memoryASet16(ds, 0xc8ff, r16[ax]);
    memoryASet16(ds, 0xc8fd, r16[ax]);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x0050, memoryAGet(es, 0x0050) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0051, memoryAGet(es, 0x0051) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0052, memoryAGet(es, 0x0052) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0053, memoryAGet(es, 0x0053) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0054, memoryAGet(es, 0x0054) | r8[dl]);
  case 0xb710:
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    if (memoryAGet(es, r16[bx]) == 0x5e)
        { pc = 0xb71d; break; }
    { pc = 0xb79d; break; }
  case 0xb71d:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
    r16[bx] = memoryAGet16(ds, 0xc8b1); es = memoryAGet16(ds, 0xc8b3);
    r8[al] = memoryAGet(es, r16[bx]);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_332b(); assert(cs == 0x0b02);
    sp += 0x0002;
    memoryASet(ss, r16[bp] - 9, r8[al]);
    if (memoryAGet(ss, r16[bp] - 9) != 0x50)
        { pc = 0xb73f; break; }
    memoryASet16(ds, 0xc8fd, memoryAGet16(ds, 0xc8fd) + 1);
  case 0xb73f:
    if (memoryAGet(ss, r16[bp] - 9) != 0x45)
        { pc = 0xb761; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, 0xc8b3, r16[ax]);
    memoryASet16(ds, 0xc8b1, r16[dx]);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb761:
    if (memoryAGet(ss, r16[bp] - 9) != 0x47)
        { pc = 0xb77d; break; }
    push(cs);
    yield* sub_b0a3();
    r16[ax] = 0x2c27;
    r16[bx] = memoryAGet16(ds, 0xc8a9);
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[bx], memoryAGet(es, r16[bx]) | r8[dl]);
  case 0xb77d:
    if (memoryAGet(ss, r16[bp] - 9) != 0x54)
        { pc = 0xb7a1; break; }
    push(cs);
    yield* sub_b0c1();
    r16[ax] = 0x2c27;
    r16[bx] = memoryAGet16(ds, 0xc8a9);
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[bx], memoryAGet(es, r16[bx]) | r8[dl]);
    { pc = 0xb7a1; break; }
    // gap 2 bytes
  case 0xb79d:
    memoryASet16(ds, 0xc8b1, memoryAGet16(ds, 0xc8b1) + 1);
  case 0xb7a1:
    r16[ax] = memoryAGet16(ds, 0xc8b1);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0xb7ac; break; }
    { pc = 0xb710; break; }
  case 0xb7ac:
    r16[ax] = 0x076d;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x0b02);
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_b7bc() // 0b02:079c +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x001c;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x00c8;
    push(r16[ax]);
    r16[ax] = 0x0140;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x0b02);
    sp += 0x000a;
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x002d;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x0050;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x0051;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x0052;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x0054;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x0050;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x0051;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x0052;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0138;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x0054;
    push(r16[ax]);
    r16[ax] = 0x00c0;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[ax] = 0x0006;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0060;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[si] = 0;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x0b02);
  case 0xb88a:
    if (signed16(memoryAGet16(ds, 0xc8a3)) >= signed16(0x0000))
        { pc = 0xb899; break; }
    memoryASet16(ds, 0xc8a3, 0x0000);
    { pc = 0xb8a6; break; }
  case 0xb899:
    if (signed16(memoryAGet16(ds, 0xc8a3)) <= signed16(0x0004))
        { pc = 0xb8a6; break; }
    memoryASet16(ds, 0xc8a3, 0x0004);
  case 0xb8a6:
    r16[ax] = 0x002d;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc8a3);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    r16[ax] += 0x0030;
    push(r16[ax]);
    r16[ax] = 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x0b02);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0018;
    push(r16[ax]);
    r16[ax] = 0x0027;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc8a3);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    r16[ax] += 0x0030;
    push(r16[ax]);
    r16[ax] = 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x0b02);
    sp += 0x000a;
    r16[ax] = r16[bp] - 28;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16e8e(); assert(cs == 0x0b02);
    sp += 0x0004;
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16dc9(); assert(cs == 0x0b02);
    sp += 0x0002;
    if (!memoryAGet(ds, 0xa545))
        { pc = 0xb96b; break; }
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    r16[di] = r16[ax];
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x0b02);
    r16[ax] = r16[di];
    if (r16[ax] == 0x0048)
        { pc = 0xb935; break; }
    if (r16[ax] > 0x0048)
        { pc = 0xb92e; break; }
    if (r16[ax] == 0x0001)
        { pc = 0xb956; break; }
    if (r16[ax] == 0x001c)
        { pc = 0xb941; break; }
    { pc = 0xb96b; break; }
  case 0xb92e:
    if (r16[ax] == 0x0050)
        { pc = 0xb93b; break; }
    { pc = 0xb96b; break; }
  case 0xb935:
    memoryASet16(ds, 0xc8a3, memoryAGet16(ds, 0xc8a3) - 1);
    { pc = 0xb96b; break; }
  case 0xb93b:
    memoryASet16(ds, 0xc8a3, memoryAGet16(ds, 0xc8a3) + 1);
    { pc = 0xb96b; break; }
  case 0xb941:
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc8a3);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb956:
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0xffff;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb96b:
    r16[si] += memoryAGet16(ss, r16[bp] - 8);
    if (memoryAGet16(ss, r16[bp] - 14))
        { pc = 0xb986; break; }
    if (memoryAGet16(ss, r16[bp] - 12))
        { pc = 0xb986; break; }
    if (memoryAGet16(ss, r16[bp] - 28))
        { pc = 0xb986; break; }
    if (!memoryAGet16(ss, r16[bp] - 26))
        { pc = 0xb99b; break; }
  case 0xb986:
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc8a3);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xb99b:
    if (r16s[si] >= signed16(0xffd8))
        { pc = 0xb9aa; break; }
    r16[si] += 0x0028;
    memoryASet16(ds, 0xc8a3, memoryAGet16(ds, 0xc8a3) - 1);
    { pc = 0xb88a; break; }
  case 0xb9aa:
    if (r16s[si] > signed16(0x0028))
        { pc = 0xb9b2; break; }
    { pc = 0xb88a; break; }
  case 0xb9b2:
    r16[si] -= 0x0028;
    memoryASet16(ds, 0xc8a3, memoryAGet16(ds, 0xc8a3) + 1);
    { pc = 0xb88a; break; }
    return;
  }
}
function* sub_b9c5() // 0b02:09a5 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xa550);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7b2);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ds, 0xa550, 0x0000);
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x0b02);
    push(cs); cs = 0x1493; yield* sub_15f4f(); assert(cs == 0x0b02);
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x0b02);
    memoryASet16(ds, 0xa7b4, 0x0000);
    memoryASet16(ds, 0xa7b2, 0x8000);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x0b02);
    sp += 0x0004;
  case 0xba24:
    push(cs);
    yield* sub_b7bc();
    r16[di] = r16[ax];
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    if (r16[di] != 0xffff)
        { pc = 0xba6e; break; }
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x0b02);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x0b02);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xa550, r16[ax]);
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x0b02);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xba6e:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[di] = memoryAGet16(ds, r16[bx] + 1814);
    push(r16[di]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ds, 0xc8b3, r16[ax]);
    memoryASet16(ds, 0xc8b1, 0x0000);
    push(cs);
    yield* sub_b6c1();
    r16[si] = 0x0001;
  case 0xba97:
    if (!r16[si])
        { pc = 0xbac9; break; }
    r16[si] = 0;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    yield* sub_b4b2();
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b4));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x0b02);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xa7b2);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, 0xa7b4, r16[ax]);
  case 0xbac9:
    memoryASet(ds, 0xa545, 0x00);
  case 0xbace:
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0xbace; break; }
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    r16[ax] -= 0x0048;
    r16[bx] = r16[ax];
    if (r16[bx] > 0x0009)
        { pc = 0xbb11; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0xbaed; break; }
        case 2: { pc = 0xbaed; break; }
        case 4: { pc = 0xbb11; break; }
        case 6: { pc = 0xbaed; break; }
        case 8: { pc = 0xbb11; break; }
        case 10: { pc = 0xbb03; break; }
        case 12: { pc = 0xbb11; break; }
        case 14: { pc = 0xbb11; break; }
        case 16: { pc = 0xbb03; break; }
        case 18: { pc = 0xbb03; break; }
        default:
            stop("ind 0b02:0ac8");
    }
    break;
  case 0xbaed:
    if (signed16(memoryAGet16(ds, 0xc8ff)) <= signed16(0x0001))
        { pc = 0xbb11; break; }
    push(cs);
    yield* sub_b693();
    push(cs);
    yield* sub_b693();
    r16[si] = 0x0001;
    { pc = 0xbb11; break; }
    // gap 2 bytes
  case 0xbb03:
    r16[ax] = memoryAGet16(ds, 0xc8ff);
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0xc8fd)))
        { pc = 0xbb11; break; }
    r16[si] = 0x0001;
    { pc = 0xbb11; break; }
  case 0xbb11:
    if (memoryAGet(ds, 0xa545) == 0x01)
        { pc = 0xbb1b; break; }
    { pc = 0xba97; break; }
  case 0xbb1b:
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x0b02);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x0b02);
    { pc = 0xba24; break; }
    return;
  }
}
function* sub_bb4d() // 0b02:0b2d +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x0b02);
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x0b02);
    push(cs); cs = 0x1493; yield* sub_15f4f(); assert(cs == 0x0b02);
    r16[ax] = 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x002f;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x1287;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0x9ffb);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ds, 0xc8b3, r16[ax]);
    memoryASet16(ds, 0xc8b1, 0x0000);
    push(cs);
    yield* sub_b6c1();
    r16[ax] = 0x0007;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_ab67(); assert(cs == 0x0b02);
    sp += 0x0002;
    { pc = 0xbc3b; break; }
  case 0xbbb5:
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_b4b2();
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x0b02);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b4));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x0b02);
    sp += 0x0004;
  case 0xbbd3:
    r16[ax] = 0x002f;
    push(r16[ax]);
    r16[ax] = 0x00b8;
    push(r16[ax]);
    r16[ax] = 0x012a;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[si] = 0;
    { pc = 0xbc01; break; }
  case 0xbbeb:
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x0b02);
    if (r16[ax])
        { pc = 0xbc3b; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[si]++;
  case 0xbc01:
    if (r16s[si] < signed16(0x0046))
        { pc = 0xbbeb; break; }
    r16[ax] = 0x0030;
    push(r16[ax]);
    r16[ax] = 0x00b8;
    push(r16[ax]);
    r16[ax] = 0x012a;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x0b02);
    sp += 0x0006;
    r16[si] = 0;
    { pc = 0xbc34; break; }
  case 0xbc1e:
    push(cs); cs = 0x164d; yield* sub_17413(); assert(cs == 0x0b02);
    if (r16[ax])
        { pc = 0xbc3b; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[si]++;
  case 0xbc34:
    if (r16s[si] < signed16(0x0046))
        { pc = 0xbc1e; break; }
    { pc = 0xbbd3; break; }
  case 0xbc3b:
    r16[ax] = memoryAGet16(ds, 0xc8ff);
    if (r16s[ax] >= signed16(memoryAGet16(ds, 0xc8fd)))
        { pc = 0xbc47; break; }
    { pc = 0xbbb5; break; }
  case 0xbc47:
    push(cs); cs = 0x08aa; yield* sub_ab32(); assert(cs == 0x0b02);
    r16[ax] = 0x9ffb;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x7b4b;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x0b02);
    sp += 0x0002;
    r16[ax] = 0x7b4d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x0b02);
    sp += 0x0002;
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x0b02);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x0b02);
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x0b02);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x0b02);
    push(cs); cs = 0x1493; yield* sub_15e92(); assert(cs == 0x0b02);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_bc95() // 0bc9:0005 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 12, memoryAGet16(ds, r16[si] + 12) + r16[dx]);
    memoryASet16(ds, r16[si] + 36, memoryAGet16(ds, r16[si] + 36) + r16[dx]);
    memoryASet16(ds, r16[si] + 40, memoryAGet16(ds, r16[si] + 40) + r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[si] + 36);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[si] + 46, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[si] + 50, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_bcbd() // 0bc9:002d +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) + r16[dx]);
    memoryASet16(ds, r16[si] + 34, memoryAGet16(ds, r16[si] + 34) + r16[dx]);
    memoryASet16(ds, r16[si] + 38, memoryAGet16(ds, r16[si] + 38) + r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[si] + 34);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[si] + 44, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 38);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[si] + 48, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_bce5() // 0bc9:0055 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = memoryAGet16(ds, r16[si] + 50);
    r16[bx]--;
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xbd5d; break; }
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 48);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 38);
    r16[ax] -= memoryAGet16(ds, r16[si] + 42);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] -= r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 11742))
        { pc = 0xbd43; break; }
    { pc = 0xbe29; break; }
  case 0xbd43:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 11742))
        { pc = 0xbda4; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0xbd5d:
    memoryASet16(ss, r16[bp] - 10, 0x000f);
    r16[ax] = memoryAGet16(ds, r16[si] + 44);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 34);
    r16[ax] -= memoryAGet16(ds, r16[si] + 42);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] -= r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 5910))
        { pc = 0xbd8f; break; }
    { pc = 0xbe29; break; }
  case 0xbd8f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 5910))
        { pc = 0xbda4; break; }
    { pc = 0xbe29; break; }
  case 0xbda4:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 2994);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0xbe29; break; }
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 2994);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (r16[ax] != 0x0001)
        { pc = 0xbe29; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] &= 0x0007;
    r8[cl] = 0x05;
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx] + 1948);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[ax]--;
    r16[ax] -= memoryAGet16(ds, r16[si] + 40);
    r16[di] = r16[ax];
    if (r16s[di] > 0)
        { pc = 0xbe29; break; }
    r16[ax] = memoryAGet16(ds, 0xc903);
    r16[ax] = -r16[ax];
    if (r16s[ax] > r16s[di])
        { pc = 0xbe29; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[si] + 54, r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_bc95();
    sp += 0x0004;
    push(memoryAGet16(ss, r16[bp] - 12));
    push(r16[si]);
    push(cs);
    yield* sub_bcbd();
    sp += 0x0004;
  case 0xbe29:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_be2f() // 0bc9:019f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = memoryAGet16(ds, r16[si] + 46);
    r16[bx]++;
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xbea7; break; }
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 48);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 11742))
        { pc = 0xbe84; break; }
    { pc = 0xbf64; break; }
  case 0xbe84:
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 11742))
        { pc = 0xbeeb; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0xbea7:
    memoryASet16(ss, r16[bp] - 6, 0x000f);
    r16[ax] = memoryAGet16(ds, r16[si] + 44);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 5910))
        { pc = 0xbed0; break; }
    { pc = 0xbf64; break; }
  case 0xbed0:
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (memoryAGet(es, r16[bx] + 5910))
        { pc = 0xbf64; break; }
  case 0xbeeb:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 8826);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0xbf64; break; }
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 8826);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (!r16[ax])
        { pc = 0xbf64; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] &= 0x0007;
    r8[cl] = 0x05;
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx] + 1948);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 46);
    r16[ax]++;
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    r16[ax] -= memoryAGet16(ds, r16[si] + 36);
    r16[di] = r16[ax];
    if (r16s[di] < 0)
        { pc = 0xbf64; break; }
    r16[ax] = memoryAGet16(ds, 0xc907);
    r16[ax] = -r16[ax];
    if (r16s[ax] < r16s[di])
        { pc = 0xbf64; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[si] + 58, r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_bc95();
    sp += 0x0004;
  case 0xbf64:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_bf6a() // 0bc9:02da +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0010;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 42);
    r16[ax] &= 0x00f0;
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc901);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] ^= r16[dx];
    r16[ax] -= r16[dx];
    r16[ax] = -r16[ax];
    r16[ax] -= memoryAGet16(ds, 0xc903);
    r16[ax] += 0xfff0;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = memoryAGet16(ds, 0xc917);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51491);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    r16[bx] = memoryAGet16(ds, r16[si] + 52);
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xc917);
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    { pc = 0xc02a; break; }
  case 0xbfc1:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 2994);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (!r16[ax])
        { pc = 0xc01f; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] &= 0x0007;
    r8[cl] = 0x05;
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx] + 1948);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += memoryAGet16(ss, r16[bp] - 10);
    r16[ax]--;
    r16[ax] -= memoryAGet16(ds, r16[si] + 40);
    r16[di] = r16[ax];
    if (r16s[di] >= 0)
        { pc = 0xc01f; break; }
    if (r16s[di] < signed16(memoryAGet16(ss, r16[bp] - 14)))
        { pc = 0xc01f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[si] + 54, r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_bc95();
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xc01f:
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 1);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
  case 0xc02a:
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xbfc1; break; }
    r16[ax] = memoryAGet16(ds, 0xc901);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] ^= r16[dx];
    r16[ax] -= r16[dx];
    r16[ax] -= memoryAGet16(ds, 0xc907);
    r16[ax] += 0x0010;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = memoryAGet16(ds, 0xc91b);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51495);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    r16[bx] = memoryAGet16(ds, r16[si] + 52);
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xc91b);
    r16[ax]++;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    { pc = 0xc0e8; break; }
  case 0xc06f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 8826);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (!r16[ax])
        { pc = 0xc0dd; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] &= 0x0007;
    r8[cl] = 0x05;
    r16[bx] <<= r8[cl];
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx] + 1948);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax]++;
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    r16[ax] -= memoryAGet16(ds, r16[si] + 36);
    r16[di] = r16[ax];
    if (r16s[di] <= 0)
        { pc = 0xc0dd; break; }
    if (r16s[di] > signed16(memoryAGet16(ss, r16[bp] - 14)))
        { pc = 0xc0dd; break; }
    r16[ax] = memoryAGet16(ds, 0xc921);
    r16[ax] += r16[di];
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) >= signed16(0x0100))
        { pc = 0xc0dd; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) <= signed16(0xff00))
        { pc = 0xc0dd; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[si] + 58, r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_bc95();
    sp += 0x0004;
  case 0xc0dd:
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) - 1);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - r16[ax]);
  case 0xc0e8:
    r16[ax] = memoryAGet16(ds, r16[si] + 46);
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xc0f3; break; }
    { pc = 0xc06f; break; }
  case 0xc0f3:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_c0f9() // 0bc9:0469 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 46);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ds, r16[si] + 58)) <= signed16(0x0001))
        { pc = 0xc113; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0xc113:
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (signed16(memoryAGet16(ds, r16[si] + 54)) <= signed16(0x0001))
        { pc = 0xc122; break; }
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) - 1);
  case 0xc122:
    r16[di] = memoryAGet16(ss, r16[bp] - 4);
    { pc = 0xc17d; break; }
  case 0xc127:
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    r16[bx] = memoryAGet16(ds, r16[si] + 44);
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 10, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10); es = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 5910);
    r8[ah] = 0x00;
    memoryASet16(ds, r16[si] + 56, r16[ax]);
    if (!r16[ax])
        { pc = 0xc17c; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 44);
    r16[ax]++;
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] -= memoryAGet16(ds, r16[si] + 34);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_bcbd();
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xc17c:
    r16[di]++;
  case 0xc17d:
    if (r16s[di] <= signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0xc127; break; }
    r16[di] = memoryAGet16(ss, r16[bp] - 4);
    { pc = 0xc1dd; break; }
  case 0xc187:
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    r16[bx] = memoryAGet16(ds, r16[si] + 48);
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 10, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10); es = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 11742);
    r8[ah] = 0x00;
    memoryASet16(ds, r16[si] + 60, r16[ax]);
    if (!r16[ax])
        { pc = 0xc1dc; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 48);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax]--;
    r16[ax] -= memoryAGet16(ds, r16[si] + 38);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_bcbd();
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xc1dc:
    r16[di]++;
  case 0xc1dd:
    if (r16s[di] <= signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0xc187; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_c1e8() // 0bc9:0558 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = memoryAGet16(ds, r16[di] + 46);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    r16[bx] = memoryAGet16(ds, r16[di] + 44);
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[di] + 48);
    r16[ax] -= memoryAGet16(ds, r16[di] + 44);
    r16[ax]++;
    r16[dx] = memoryAGet16(ds, 0xa7e4);
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[di] + 46);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xc278; break; }
  case 0xc22c:
    r16[cx] = memoryAGet16(ds, r16[di] + 44);
    { pc = 0xc268; break; }
  case 0xc231:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6); es = memoryAGet16(ss, r16[bp] - 4);
    r16[si] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 0x0002);
    es = memoryAGet16(ds, 0xc8a1);
    if (memoryAGet(es, r16[si] + 2994))
        { pc = 0xc25f; break; }
    if (memoryAGet(es, r16[si] + 5910))
        { pc = 0xc25f; break; }
    if (memoryAGet(es, r16[si] + 8826))
        { pc = 0xc25f; break; }
    if (!memoryAGet(es, r16[si] + 11742))
        { pc = 0xc267; break; }
  case 0xc25f:
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xc267:
    r16[cx]++;
  case 0xc268:
    if (memoryAGet16(ds, r16[di] + 48) >= r16[cx])
        { pc = 0xc231; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + r16[ax]);
  case 0xc278:
    r16[ax] = memoryAGet16(ds, r16[di] + 50);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xc22c; break; }
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_c335() // 0bc9:06a5 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    r16[bx] = memoryAGet16(ds, r16[di] + 28);
    if (!memoryAGet16(ds, r16[bx] + 8))
        { pc = 0xc38a; break; }
    if (memoryAGet16(ds, r16[di] + 54) != 0x0019)
        { pc = 0xc368; break; }
    memoryASet16(ds, 0xc921, 0x0091);
    { pc = 0xc38a; break; }
  case 0xc368:
    if (signed16(memoryAGet16(ds, 0xc923)) <= signed16(0x0000))
        { pc = 0xc37a; break; }
    r16[ax] = memoryAGet16(ds, 0xc923);
    r16[ax] += 0x0010;
    memoryASet16(ds, 0xc921, r16[ax]);
    { pc = 0xc385; break; }
  case 0xc37a:
    r16[ax] = memoryAGet16(ds, 0xc923);
    r16[ax] = -r16[ax];
    r16[ax] += 0x0010;
    memoryASet16(ds, 0xc921, r16[ax]);
  case 0xc385:
    memoryASet16(ss, r16[bp] - 10, 0x0001);
  case 0xc38a:
    if (signed16(memoryAGet16(ds, 0xc923)) <= signed16(0x00ef))
        { pc = 0xc39a; break; }
    memoryASet16(ds, 0xc923, 0x00ef);
    { pc = 0xc3a8; break; }
  case 0xc39a:
    if (signed16(memoryAGet16(ds, 0xc923)) >= signed16(0xff11))
        { pc = 0xc3a8; break; }
    memoryASet16(ds, 0xc923, 0xff11);
  case 0xc3a8:
    if (signed16(memoryAGet16(ds, 0xc921)) <= signed16(0x00ff))
        { pc = 0xc3b8; break; }
    memoryASet16(ds, 0xc921, 0x00ff);
    { pc = 0xc3c6; break; }
  case 0xc3b8:
    if (signed16(memoryAGet16(ds, 0xc921)) >= signed16(0xff11))
        { pc = 0xc3c6; break; }
    memoryASet16(ds, 0xc921, 0xff11);
  case 0xc3c6:
    r16[ax] = memoryAGet16(ds, 0xc923);
    memoryASet16(ds, r16[di] + 10, memoryAGet16(ds, r16[di] + 10) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc921);
    memoryASet16(ds, r16[di] + 12, memoryAGet16(ds, r16[di] + 12) + r16[ax]);
    memoryASet16(ds, r16[di] + 4, 0x0001);
    if (memoryAGet16(ds, r16[di] + 30))
        { pc = 0xc3e0; break; }
    { pc = 0xc5c0; break; }
  case 0xc3e0:
    r16[ax] = memoryAGet16(ds, r16[di] + 30);
    r16[ax] -= 0x007c;
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 48);
    memoryASet16(ds, 0xc919, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 46);
    memoryASet16(ds, 0xc91b, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 44);
    memoryASet16(ds, 0xc91d, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 50);
    memoryASet16(ds, 0xc917, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 52);
    memoryASet16(ds, 0xc915, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    memoryASet16(ds, 0xc90f, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    memoryASet16(ds, 0xc911, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    memoryASet16(ds, 0xc913, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    memoryASet16(ds, 0xc90d, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    memoryASet16(ds, 0xc90b, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, r16[di] + 34, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 12);
    memoryASet16(ds, r16[di] + 38, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 10);
    memoryASet16(ds, r16[di] + 36, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 14);
    memoryASet16(ds, r16[di] + 40, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, r16[di] + 34);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, r16[di] + 34);
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[di] + 42, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 44, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 48, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 46, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 50, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 52, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, r16[di] + 60, r16[ax]);
    memoryASet16(ds, r16[di] + 58, r16[ax]);
    memoryASet16(ds, r16[di] + 56, r16[ax]);
    memoryASet16(ds, r16[di] + 54, r16[ax]);
    if (!memoryAGet16(ds, r16[di] + 6))
        { pc = 0xc523; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r16[ax] -= memoryAGet16(ds, 0xc913);
    memoryASet16(ds, 0xc909, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, 0xc90f);
    memoryASet16(ds, 0xc905, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] -= memoryAGet16(ds, 0xc911);
    memoryASet16(ds, 0xc907, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] -= memoryAGet16(ds, 0xc90d);
    memoryASet16(ds, 0xc903, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    r16[ax] -= memoryAGet16(ds, 0xc90b);
    memoryASet16(ds, 0xc901, r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_bf6a();
    sp += 0x0002;
    if (r16[di] != memoryAGet16(ds, 0xa7d6))
        { pc = 0xc51b; break; }
    if (memoryAGet16(ds, 0xc91f))
        { pc = 0xc51b; break; }
    if (memoryAGet16(ds, r16[di] + 54))
        { pc = 0xc506; break; }
    if (signed16(memoryAGet16(ds, 0xc903)) <= signed16(0x0000))
        { pc = 0xc506; break; }
    push(r16[di]);
    push(cs);
    yield* sub_bce5();
    sp += 0x0002;
  case 0xc506:
    if (memoryAGet16(ds, r16[di] + 58))
        { pc = 0xc51b; break; }
    if (signed16(memoryAGet16(ds, 0xc907)) >= signed16(0x0000))
        { pc = 0xc51b; break; }
    push(r16[di]);
    push(cs);
    yield* sub_be2f();
    sp += 0x0002;
  case 0xc51b:
    push(r16[di]);
    push(cs);
    yield* sub_c0f9();
    sp += 0x0002;
  case 0xc523:
    if (!memoryAGet16(ss, r16[bp] - 10))
        { pc = 0xc5a4; break; }
    if (memoryAGet16(ds, r16[di] + 54))
        { pc = 0xc5a4; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, r16[di] + 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ds, 0xc923);
    memoryASet16(ds, r16[di] + 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, r16[di] + 34, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 12);
    memoryASet16(ds, r16[di] + 38, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 10);
    memoryASet16(ds, r16[di] + 36, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 14);
    memoryASet16(ds, r16[di] + 40, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, r16[di] + 34);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, r16[di] + 34);
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[di] + 42, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 44, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 48, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 46, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 50, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 52, r16[ax]);
  case 0xc5a4:
    r16[ax] = memoryAGet16(ds, r16[di] + 18);
    r16[dx] = memoryAGet16(ds, r16[di] + 10);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di] + 18, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 20);
    r16[dx] = memoryAGet16(ds, r16[di] + 12);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di] + 20, r16[ax]);
  case 0xc5c0:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_c5c6() // 0bc9:0936 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ds, 0xc923)) <= signed16(0x00ef))
        { pc = 0xc5ed; break; }
    memoryASet16(ds, 0xc923, 0x00ef);
    { pc = 0xc5fb; break; }
  case 0xc5ed:
    if (signed16(memoryAGet16(ds, 0xc923)) >= signed16(0xff11))
        { pc = 0xc5fb; break; }
    memoryASet16(ds, 0xc923, 0xff11);
  case 0xc5fb:
    if (signed16(memoryAGet16(ds, 0xc921)) <= signed16(0x00ef))
        { pc = 0xc60b; break; }
    memoryASet16(ds, 0xc921, 0x00ef);
    { pc = 0xc619; break; }
  case 0xc60b:
    if (signed16(memoryAGet16(ds, 0xc921)) >= signed16(0xff11))
        { pc = 0xc619; break; }
    memoryASet16(ds, 0xc921, 0xff11);
  case 0xc619:
    r16[ax] = memoryAGet16(ds, 0xc923);
    memoryASet16(ds, r16[di] + 10, memoryAGet16(ds, r16[di] + 10) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc921);
    memoryASet16(ds, r16[di] + 12, memoryAGet16(ds, r16[di] + 12) + r16[ax]);
    memoryASet16(ds, r16[di] + 4, 0x0001);
    r16[ax] = memoryAGet16(ds, r16[di] + 30);
    r16[ax] -= 0x007c;
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 10, r16[dx]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    if (r16[ax] == 0x0016)
        { pc = 0xc67f; break; }
    if (r16s[ax] > signed16(0x0016))
        { pc = 0xc654; break; }
    if (r16[ax] == 0x0002)
        { pc = 0xc65b; break; }
    if (r16[ax] == 0x0015)
        { pc = 0xc673; break; }
    { pc = 0xc68b; break; }
  case 0xc654:
    if (r16[ax] == 0x001b)
        { pc = 0xc667; break; }
    { pc = 0xc68b; break; }
  case 0xc65b:
    memoryASet16(ss, r16[bp] - 6, 0x0280);
    memoryASet16(ss, r16[bp] - 8, 0x0180);
    { pc = 0xc697; break; }
  case 0xc667:
    memoryASet16(ss, r16[bp] - 6, 0x0400);
    memoryASet16(ss, r16[bp] - 8, 0x0200);
    { pc = 0xc697; break; }
  case 0xc673:
    memoryASet16(ss, r16[bp] - 6, 0x0580);
    memoryASet16(ss, r16[bp] - 8, 0x0400);
    { pc = 0xc697; break; }
  case 0xc67f:
    memoryASet16(ss, r16[bp] - 6, 0x0100);
    memoryASet16(ss, r16[bp] - 8, 0x0080);
    { pc = 0xc697; break; }
  case 0xc68b:
    r16[ax] = 0x08d8;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x0bc9);
    sp += 0x0002;
  case 0xc697:
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[di] + 38, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    memoryASet16(ds, r16[di] + 34, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    memoryASet16(ds, r16[di] + 36, r16[ax]);
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[di] + 40, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 44, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 48, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 46, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 50, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, r16[di] + 60, r16[ax]);
    memoryASet16(ds, r16[di] + 58, r16[ax]);
    memoryASet16(ds, r16[di] + 56, r16[ax]);
    memoryASet16(ds, r16[di] + 54, r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_c1e8();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0xc6f1; break; }
    { pc = 0xc77c; break; }
  case 0xc6f1:
    r16[ax] = memoryAGet16(ds, 0xc923);
    r16[ax] = -r16[ax];
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_bcbd();
    sp += 0x0004;
    push(r16[di]);
    push(cs);
    yield* sub_c1e8();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0xc722; break; }
    if (signed16(memoryAGet16(ds, 0xc923)) <= signed16(0x0000))
        { pc = 0xc719; break; }
    memoryASet16(ds, r16[di] + 60, 0x0001);
    { pc = 0xc77c; break; }
  case 0xc719:
    memoryASet16(ds, r16[di] + 56, 0x0001);
    { pc = 0xc77c; break; }
    // gap 2 bytes
  case 0xc722:
    if (signed16(memoryAGet16(ds, 0xc921)) <= signed16(0x0000))
        { pc = 0xc730; break; }
    memoryASet16(ds, r16[di] + 54, 0x0001);
    { pc = 0xc735; break; }
  case 0xc730:
    memoryASet16(ds, r16[di] + 58, 0x0001);
  case 0xc735:
    push(memoryAGet16(ds, 0xc923));
    push(r16[di]);
    push(cs);
    yield* sub_bcbd();
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xc921);
    r16[ax] = -r16[ax];
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_bc95();
    sp += 0x0004;
    push(r16[di]);
    push(cs);
    yield* sub_c1e8();
    sp += 0x0002;
    if (r16[ax])
        { pc = 0xc77c; break; }
    r16[ax] = memoryAGet16(ds, 0xc923);
    r16[ax] = -r16[ax];
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_bcbd();
    sp += 0x0004;
    if (signed16(memoryAGet16(ds, 0xc923)) <= signed16(0x0000))
        { pc = 0xc777; break; }
    memoryASet16(ds, r16[di] + 60, 0x0001);
    { pc = 0xc77c; break; }
  case 0xc777:
    memoryASet16(ds, r16[di] + 56, 0x0001);
  case 0xc77c:
    r16[ax] = memoryAGet16(ds, r16[di] + 18);
    r16[dx] = memoryAGet16(ds, r16[di] + 10);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di] + 18, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 20);
    r16[dx] = memoryAGet16(ds, r16[di] + 12);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di] + 20, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, r16[di] + 34, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 12);
    memoryASet16(ds, r16[di] + 38, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 10);
    memoryASet16(ds, r16[di] + 36, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 14);
    memoryASet16(ds, r16[di] + 40, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, r16[di] + 34);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, r16[di] + 34);
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[di] + 42, r16[dx]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_c7d9() // 0bc9:0b49 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc923);
    memoryASet16(ds, r16[di] + 10, memoryAGet16(ds, r16[di] + 10) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc921);
    memoryASet16(ds, r16[di] + 12, memoryAGet16(ds, r16[di] + 12) + r16[ax]);
    memoryASet16(ds, r16[di] + 4, 0x0001);
    if (memoryAGet16(ds, r16[di] + 30))
        { pc = 0xc80a; break; }
    { pc = 0xc924; break; }
  case 0xc80a:
    r16[ax] = memoryAGet16(ds, r16[di] + 30);
    r16[ax] -= 0x007c;
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 48);
    memoryASet16(ds, 0xc919, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 46);
    memoryASet16(ds, 0xc91b, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 44);
    memoryASet16(ds, 0xc91d, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 50);
    memoryASet16(ds, 0xc917, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 52);
    memoryASet16(ds, 0xc915, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    memoryASet16(ds, 0xc90f, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    memoryASet16(ds, 0xc911, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    memoryASet16(ds, 0xc913, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    memoryASet16(ds, 0xc90d, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    memoryASet16(ds, 0xc90b, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, r16[di] + 34, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += memoryAGet16(es, r16[bx] + 12);
    memoryASet16(ds, r16[di] + 38, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 10);
    memoryASet16(ds, r16[di] + 36, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += memoryAGet16(es, r16[bx] + 14);
    memoryASet16(ds, r16[di] + 40, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, r16[di] + 34);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, r16[di] + 34);
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[di] + 42, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 44, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 48, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 46, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 50, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[di] + 52, r16[ax]);
    if (!memoryAGet16(ds, r16[di] + 6))
        { pc = 0xc908; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r16[ax] -= memoryAGet16(ds, 0xc913);
    memoryASet16(ds, 0xc909, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, 0xc90f);
    memoryASet16(ds, 0xc905, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] -= memoryAGet16(ds, 0xc911);
    memoryASet16(ds, 0xc907, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] -= memoryAGet16(ds, 0xc90d);
    memoryASet16(ds, 0xc903, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 42);
    r16[ax] -= memoryAGet16(ds, 0xc90b);
    memoryASet16(ds, 0xc901, r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_bf6a();
    sp += 0x0002;
    push(r16[di]);
    push(cs);
    yield* sub_c0f9();
    sp += 0x0002;
  case 0xc908:
    r16[ax] = memoryAGet16(ds, r16[di] + 18);
    r16[dx] = memoryAGet16(ds, r16[di] + 10);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di] + 18, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 20);
    r16[dx] = memoryAGet16(ds, r16[di] + 12);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di] + 20, r16[ax]);
  case 0xc924:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_c9c3() // 0bc9:0d33 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ds, r16[si] + 20);
    r16[ax] -= memoryAGet16(ds, r16[di] + 20);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= memoryAGet16(ds, r16[di] + 36);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0000))
        { pc = 0xca2a; break; }
    if (r16s[ax] > signed16(memoryAGet16(ss, r16[bp] - 4)))
        { pc = 0xca2a; break; }
    if (r16[si] != memoryAGet16(ds, 0xa7d6))
        { pc = 0xc9f8; break; }
    memoryASet16(ds, 0x7a6e, r16[di]);
  case 0xc9f8:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = -r16[ax];
    memoryASet16(ds, 0xc921, r16[ax]);
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[ax] = memoryAGet16(ds, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ds, r16[bx] + 8, 0x0000);
    push(r16[si]);
    push(cs);
    yield* sub_c335();
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[bx] + 8, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 58))
        { pc = 0xca2a; break; }
    memoryASet16(ds, r16[si] + 54, 0x0019);
  case 0xca2a:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ca30() // 0bc9:0da0 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ds, r16[di] + 18);
    r16[ax] -= memoryAGet16(ds, r16[si] + 18);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xc923, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] -= memoryAGet16(ds, r16[si] + 34);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 38);
    r16[ax] -= memoryAGet16(ds, r16[di] + 34);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) <= signed16(0x0000))
        { pc = 0xca9f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax]++;
    if (r16s[ax] < signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0xca9f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, r16[si] + 22, 0x0000);
    push(r16[si]);
    push(cs);
    yield* sub_c7d9();
    sp += 0x0002;
    if (!memoryAGet16(ss, r16[bp] + 10))
        { pc = 0xca94; break; }
    if (!memoryAGet16(ds, r16[si] + 60))
        { pc = 0xca94; break; }
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x0bc9);
  case 0xca94:
    memoryASet16(ds, r16[si] + 56, 0x0001);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xca9f:
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) <= signed16(0x0000))
        { pc = 0xcae1; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = -r16[ax];
    r16[ax]++;
    if (r16s[ax] < signed16(memoryAGet16(ss, r16[bp] - 8)))
        { pc = 0xcae1; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] = -r16[ax];
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, r16[si] + 22, 0x0000);
    push(r16[si]);
    push(cs);
    yield* sub_c7d9();
    sp += 0x0002;
    if (!memoryAGet16(ss, r16[bp] + 10))
        { pc = 0xcad6; break; }
    if (!memoryAGet16(ds, r16[si] + 56))
        { pc = 0xcad6; break; }
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x0bc9);
  case 0xcad6:
    memoryASet16(ds, r16[si] + 60, 0x0001);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcae1:
    r16[ax] = memoryAGet16(ds, r16[si] + 20);
    r16[ax] -= memoryAGet16(ds, r16[di] + 20);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 40);
    r16[ax] -= memoryAGet16(ds, r16[si] + 36);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= memoryAGet16(ds, r16[di] + 36);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) < signed16(0x0000))
        { pc = 0xcb49; break; }
    if (r16s[ax] > signed16(memoryAGet16(ss, r16[bp] - 4)))
        { pc = 0xcb49; break; }
    if (r16[si] != memoryAGet16(ds, 0xa7d6))
        { pc = 0xcb11; break; }
    memoryASet16(ds, 0x7a6e, r16[di]);
  case 0xcb11:
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = -r16[ax];
    memoryASet16(ds, 0xc921, r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_c7d9();
    sp += 0x0002;
    if (!memoryAGet16(ss, r16[bp] + 10))
        { pc = 0xcb32; break; }
    if (!memoryAGet16(ds, r16[si] + 58))
        { pc = 0xcb32; break; }
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x0bc9);
  case 0xcb32:
    if (memoryAGet16(ds, r16[si] + 58))
        { pc = 0xcb78; break; }
    memoryASet16(ds, r16[si] + 54, 0x0019);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 6 bytes
  case 0xcb49:
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) < signed16(0x0000))
        { pc = 0xcb78; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    if (r16s[ax] > signed16(memoryAGet16(ss, r16[bp] - 4)))
        { pc = 0xcb78; break; }
    memoryASet16(ds, 0xc921, r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_c335();
    sp += 0x0002;
    if (!memoryAGet16(ss, r16[bp] + 10))
        { pc = 0xcb73; break; }
    if (!memoryAGet16(ds, r16[si] + 54))
        { pc = 0xcb73; break; }
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x0bc9);
  case 0xcb73:
    memoryASet16(ds, r16[si] + 58, 0x0019);
  case 0xcb78:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_cb7e() // 0bc9:0eee +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ds, r16[si] + 28);
    if (memoryAGet16(ds, r16[di] + 4) != 0x0002)
        { pc = 0xcbb4; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 16);
    r16[ax] |= memoryAGet16(ds, r16[di] + 18);
    if (!r16[ax])
        { pc = 0xcbac; break; }
    if (!memoryAGet16(ds, r16[si] + 8))
        { pc = 0xcba5; break; }
    memoryASet16(ds, r16[si] + 8, memoryAGet16(ds, r16[si] + 8) - 1);
    { pc = 0xcbac; break; }
  case 0xcba5:
    push(r16[si]);
    switch (memoryAGet32(ds, r16[di] + 16))
    {
        case 0x0bc90f16: push(cs); cs = 0x0bc9; yield* sub_cba6(); assert(cs == 0x0bc9); break;
        case 0x0d6d0b5b: push(cs); cs = 0x0d6d; yield* sub_e22b(); assert(cs == 0x0bc9); break;
        case 0x126d114f: push(cs); cs = 0x126d; yield* sub_1381f(); assert(cs == 0x0bc9); break;
        case 0x0d6d07d8: push(cs); cs = 0x0d6d; yield* sub_dea8(); assert(cs == 0x0bc9); break;
        case 0x0d6d04e2: push(cs); cs = 0x0d6d; yield* sub_dbb2(); assert(cs == 0x0bc9); break;
        case 0x0f7c0bc4: push(cs); cs = 0x0f7c; yield* sub_10384(); assert(cs == 0x0bc9); break;
        default:
            stop("ind 0bc9:0f16");
    }
    sp += 0x0002;
  case 0xcbac:
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcbb4:
    r16[ax] = memoryAGet16(ds, r16[si] + 26);
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    if (r16s[ax] > signed16(memoryAGet16(ss, r16[bp] - 2)))
        { pc = 0xcbce; break; }
    if (!memoryAGet16(ds, r16[di] + 10))
        { pc = 0xcbce; break; }
    { pc = 0xcc4e; break; }
  case 0xcbce:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[si] + 26, r16[ax]);
    if (memoryAGet16(ds, r16[di] + 4) == 0x0001)
        { pc = 0xcbe0; break; }
    if (memoryAGet16(ds, r16[di] + 4) != 0x0004)
        { pc = 0xcc20; break; }
  case 0xcbe0:
    if (!memoryAGet16(ds, r16[si] + 14))
        { pc = 0xcc00; break; }
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xcbf4; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    imul16(memoryAGet16(ss, r16[bp] + 8));
    { pc = 0xcbfc; break; }
  case 0xcbf4:
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = -r16[ax];
    imul16(memoryAGet16(ds, r16[di] + 12));
  case 0xcbfc:
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) + r16[ax]);
  case 0xcc00:
    if (!memoryAGet16(ds, r16[si] + 16))
        { pc = 0xcc20; break; }
    if (memoryAGet16(ds, r16[si] + 16) != 0x0001)
        { pc = 0xcc14; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    imul16(memoryAGet16(ss, r16[bp] + 8));
    { pc = 0xcc1c; break; }
  case 0xcc14:
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = -r16[ax];
    imul16(memoryAGet16(ds, r16[di] + 14));
  case 0xcc1c:
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
  case 0xcc20:
    if (memoryAGet16(ds, r16[di] + 4) == 0x0004)
        { pc = 0xcc2c; break; }
    if (memoryAGet16(ds, r16[di] + 4) != 0x0003)
        { pc = 0xcc46; break; }
  case 0xcc2c:
    r16[ax] = memoryAGet16(ds, r16[di] + 16);
    r16[ax] |= memoryAGet16(ds, r16[di] + 18);
    if (!r16[ax])
        { pc = 0xcc46; break; }
    if (!memoryAGet16(ds, r16[si] + 8))
        { pc = 0xcc3f; break; }
    memoryASet16(ds, r16[si] + 8, memoryAGet16(ds, r16[si] + 8) - 1);
    { pc = 0xcc46; break; }
  case 0xcc3f:
    push(r16[si]);
    switch (memoryAGet32(ds, r16[di] + 16))
    {
        case 0x1195002e: push(cs); cs = 0x1195; yield* sub_1197e(); assert(cs == 0x0bc9); break;
        case 0x1195008b: push(cs); cs = 0x1195; yield* sub_119db(); assert(cs == 0x0bc9); break;
        case 0x119500b3: push(cs); cs = 0x1195; yield* sub_11a03(); assert(cs == 0x0bc9); break;
        case 0x119500db: push(cs); cs = 0x1195; yield* sub_11a2b(); assert(cs == 0x0bc9); break;
        case 0x11950103: push(cs); cs = 0x1195; yield* sub_11a53(); assert(cs == 0x0bc9); break;
        case 0x1195012b: push(cs); cs = 0x1195; yield* sub_11a7b(); assert(cs == 0x0bc9); break;
        case 0x11950153: push(cs); cs = 0x1195; yield* sub_11aa3(); assert(cs == 0x0bc9); break;
        case 0x1195017b: push(cs); cs = 0x1195; yield* sub_11acb(); assert(cs == 0x0bc9); break;
        case 0x1195024e: push(cs); cs = 0x1195; yield* sub_11b9e(); assert(cs == 0x0bc9); break;
        case 0x0f7c07ab: push(cs); cs = 0x0f7c; yield* sub_ff6b(); assert(cs == 0x0bc9); break;
        case 0x0f7c0826: push(cs); cs = 0x0f7c; yield* sub_ffe6(); assert(cs == 0x0bc9); break;
        case 0x0f7c06af: push(cs); cs = 0x0f7c; yield* sub_fe6f(); assert(cs == 0x0bc9); break;
        case 0x0f7c06f0: push(cs); cs = 0x0f7c; yield* sub_feb0(); assert(cs == 0x0bc9); break;
        case 0x0d6d0395: push(cs); cs = 0x0d6d; yield* sub_da65(); assert(cs == 0x0bc9); break;
        case 0x0bc916c9: push(cs); cs = 0x0bc9; yield* sub_d359(); assert(cs == 0x0bc9); break;
        case 0x0d6d062c: push(cs); cs = 0x0d6d; yield* sub_dcfc(); assert(cs == 0x0bc9); break;
        case 0x0d6d0b5b: push(cs); cs = 0x0d6d; yield* sub_e22b(); assert(cs == 0x0bc9); break;
        case 0x0d6d049a: push(cs); cs = 0x0d6d; yield* sub_db6a(); assert(cs == 0x0bc9); break;
        case 0x0d6d04e2: push(cs); cs = 0x0d6d; yield* sub_dbb2(); assert(cs == 0x0bc9); break;
        case 0x0d6d024c: push(cs); cs = 0x0d6d; yield* sub_d91c(); assert(cs == 0x0bc9); break;
        case 0x0d6d0842: push(cs); cs = 0x0d6d; yield* sub_df12(); assert(cs == 0x0bc9); break;
        case 0x11950369: push(cs); cs = 0x1195; yield* sub_11cb9(); assert(cs == 0x0bc9); break;
        case 0x119503a6: push(cs); cs = 0x1195; yield* sub_11cf6(); assert(cs == 0x0bc9); break;
        default:
            stop("ind 0bc9:0fb0");
    }
    sp += 0x0002;
  case 0xcc46:
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcc4e:
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] -= memoryAGet16(ds, r16[si] + 26);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= memoryAGet16(ds, r16[di] + 10);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ds, r16[si] + 26, 0x0000);
    if (memoryAGet16(ds, r16[di] + 4) == 0x0001)
        { pc = 0xcc71; break; }
    if (memoryAGet16(ds, r16[di] + 4) != 0x0004)
        { pc = 0xccb5; break; }
  case 0xcc71:
    if (!memoryAGet16(ds, r16[si] + 14))
        { pc = 0xcc91; break; }
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xcc85; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    imul16(memoryAGet16(ss, r16[bp] - 4));
    { pc = 0xcc8d; break; }
  case 0xcc85:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = -r16[ax];
    imul16(memoryAGet16(ds, r16[di] + 12));
  case 0xcc8d:
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) + r16[ax]);
  case 0xcc91:
    if (!memoryAGet16(ds, r16[si] + 16))
        { pc = 0xcce9; break; }
    if (memoryAGet16(ds, r16[si] + 16) != 0x0001)
        { pc = 0xcca5; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    imul16(memoryAGet16(ss, r16[bp] - 4));
    { pc = 0xccad; break; }
  case 0xcca5:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = -r16[ax];
    imul16(memoryAGet16(ds, r16[di] + 14));
  case 0xccad:
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
    { pc = 0xcce9; break; }
    // gap 2 bytes
  case 0xccb5:
    if (!memoryAGet16(ds, r16[si] + 14))
        { pc = 0xcccf; break; }
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xccc6; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    { pc = 0xcccb; break; }
  case 0xccc6:
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] = -r16[ax];
  case 0xcccb:
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) + r16[ax]);
  case 0xcccf:
    if (!memoryAGet16(ds, r16[si] + 16))
        { pc = 0xcce9; break; }
    if (memoryAGet16(ds, r16[si] + 16) != 0x0001)
        { pc = 0xcce0; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    { pc = 0xcce5; break; }
  case 0xcce0:
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    r16[ax] = -r16[ax];
  case 0xcce5:
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
  case 0xcce9:
    r16[ax] = memoryAGet16(ds, r16[di] + 16);
    r16[ax] |= memoryAGet16(ds, r16[di] + 18);
    if (!r16[ax])
        { pc = 0xcd03; break; }
    if (!memoryAGet16(ds, r16[si] + 8))
        { pc = 0xccfc; break; }
    memoryASet16(ds, r16[si] + 8, memoryAGet16(ds, r16[si] + 8) - 1);
    { pc = 0xcd03; break; }
  case 0xccfc:
    push(r16[si]);
    switch (memoryAGet32(ds, r16[di] + 16))
    {
        case 0x0f7c06f0: push(cs); cs = 0x0f7c; yield* sub_feb0(); assert(cs == 0x0bc9); break;
        case 0x1195002e: push(cs); cs = 0x1195; yield* sub_1197e(); assert(cs == 0x0bc9); break;
        case 0x1195008b: push(cs); cs = 0x1195; yield* sub_119db(); assert(cs == 0x0bc9); break;
        case 0x119500b3: push(cs); cs = 0x1195; yield* sub_11a03(); assert(cs == 0x0bc9); break;
        case 0x119500db: push(cs); cs = 0x1195; yield* sub_11a2b(); assert(cs == 0x0bc9); break;
        case 0x0f7c06af: push(cs); cs = 0x0f7c; yield* sub_fe6f(); assert(cs == 0x0bc9); break;
        case 0x11950103: push(cs); cs = 0x1195; yield* sub_11a53(); assert(cs == 0x0bc9); break;
        case 0x1195012b: push(cs); cs = 0x1195; yield* sub_11a7b(); assert(cs == 0x0bc9); break;
        case 0x11950153: push(cs); cs = 0x1195; yield* sub_11aa3(); assert(cs == 0x0bc9); break;
        case 0x1195017b: push(cs); cs = 0x1195; yield* sub_11acb(); assert(cs == 0x0bc9); break;
        case 0x0d6d0395: push(cs); cs = 0x0d6d; yield* sub_da65(); assert(cs == 0x0bc9); break;
        case 0x0bc916c9: push(cs); cs = 0x0bc9; yield* sub_d359(); assert(cs == 0x0bc9); break;
        case 0x0d6d062c: push(cs); cs = 0x0d6d; yield* sub_dcfc(); assert(cs == 0x0bc9); break;
        case 0x0d6d0b5b: push(cs); cs = 0x0d6d; yield* sub_e22b(); assert(cs == 0x0bc9); break;
        case 0x0d6d0234: push(cs); cs = 0x0d6d; yield* sub_d904(); assert(cs == 0x0bc9); break;
        case 0x0d6d024c: push(cs); cs = 0x0d6d; yield* sub_d91c(); assert(cs == 0x0bc9); break;
        case 0x0d6d0842: push(cs); cs = 0x0d6d; yield* sub_df12(); assert(cs == 0x0bc9); break;
        case 0x1195024e: push(cs); cs = 0x1195; yield* sub_11b9e(); assert(cs == 0x0bc9); break;
        case 0x11950369: push(cs); cs = 0x1195; yield* sub_11cb9(); assert(cs == 0x0bc9); break;
        case 0x119503a6: push(cs); cs = 0x1195; yield* sub_11cf6(); assert(cs == 0x0bc9); break;
        case 0x0d6d04e2: push(cs); cs = 0x0d6d; yield* sub_dbb2(); assert(cs == 0x0bc9); break;
        case 0x0d6d049a: push(cs); cs = 0x0d6d; yield* sub_db6a(); assert(cs == 0x0bc9); break;
        default:
            stop("ind 0bc9:106d");
    }
    sp += 0x0002;
  case 0xcd03:
    if (memoryAGet16(ds, r16[si] + 28) != r16[di])
        { pc = 0xcd10; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 28);
    memoryASet16(ds, r16[si] + 28, r16[ax]);
    { pc = 0xcd1e; break; }
  case 0xcd10:
    if (memoryAGet16(ds, r16[si] + 28))
        { pc = 0xcd1e; break; }
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcd1e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_cba6() // 0bc9:0f16 +stackDrop2
{
    sp -= 2;
    switch (memoryAGet32(ds, r16[di] + 16))
    {
        case 0x0bc90f16: push(cs); cs = 0x0bc9; yield* sub_cba6(); assert(cs == 0x0bc9); break;
        case 0x0d6d0b5b: push(cs); cs = 0x0d6d; yield* sub_e22b(); assert(cs == 0x0bc9); break;
        case 0x126d114f: push(cs); cs = 0x126d; yield* sub_1381f(); assert(cs == 0x0bc9); break;
        case 0x0d6d07d8: push(cs); cs = 0x0d6d; yield* sub_dea8(); assert(cs == 0x0bc9); break;
        case 0x0d6d04e2: push(cs); cs = 0x0d6d; yield* sub_dbb2(); assert(cs == 0x0bc9); break;
        case 0x0f7c0bc4: push(cs); cs = 0x0f7c; yield* sub_10384(); assert(cs == 0x0bc9); break;
        default:
            stop("ind 0bc9:0f16");
    }
    sp += 0x0002;
    stop("stack_below");
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    stop("stack_unbalanced");
    sp += 2; cs = pop();
}
function* sub_cd27() // 0bc9:1097 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0;
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, r16[si] + 20, r16[ax]);
    memoryASet16(ds, r16[si] + 18, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 30);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[di] = memoryAGet16(ds, r16[si] + 28);
    push(memoryAGet16(ds, 0xa54c));
    push(r16[si]);
    push(cs);
    yield* sub_cb7e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 28) == r16[di])
        { pc = 0xcda1; break; }
    memoryASet16(ds, r16[si] + 26, 0x0000);
    r16[di] = memoryAGet16(ds, r16[si] + 28);
    { pc = 0xcda1; break; }
    // gap 2 bytes
  case 0xcd69:
    if (memoryAGet16(ds, r16[di] + 6))
        { pc = 0xcd86; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    if (r16s[ax] > signed16(memoryAGet16(ss, r16[bp] - 2)))
        { pc = 0xcd86; break; }
    r16[ax]--;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_cb7e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xcd94; break; }
  case 0xcd86:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[si]);
    push(cs);
    yield* sub_cb7e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0xcd94:
    if (memoryAGet16(ds, r16[si] + 28) == r16[di])
        { pc = 0xcda1; break; }
    memoryASet16(ds, r16[si] + 26, 0x0000);
    r16[di] = memoryAGet16(ds, r16[si] + 28);
  case 0xcda1:
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xcd69; break; }
    if (r16[di])
        { pc = 0xcdba; break; }
    push(r16[si]);
    push(cs); cs = 0x08aa; yield* sub_a92b(); assert(cs == 0x0bc9);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcdba:
    if (!memoryAGet16(ds, r16[di] + 2))
        { pc = 0xcdd3; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 14)) <= signed16(0x0000))
        { pc = 0xcdce; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 2);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    { pc = 0xcdd3; break; }
  case 0xcdce:
    r16[ax] = memoryAGet16(ds, r16[di]);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
  case 0xcdd3:
    if (memoryAGet16(ds, r16[si] + 30) != 0xffff)
        { pc = 0xcdde; break; }
    memoryASet16(ds, r16[si] + 30, 0x0000);
  case 0xcdde:
    if (memoryAGet16(ds, 0xc923))
        { pc = 0xcdfa; break; }
    if (memoryAGet16(ds, 0xc921))
        { pc = 0xcdfa; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 30);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0xcdfa; break; }
    if (memoryAGet16(ds, r16[si] + 54) != 0x0019)
        { pc = 0xce16; break; }
  case 0xcdfa:
    if (memoryAGet16(ds, r16[si] + 6) != 0x0002)
        { pc = 0xce0e; break; }
    push(r16[si]);
    push(cs);
    yield* sub_c5c6();
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xce0e:
    push(r16[si]);
    push(cs);
    yield* sub_c335();
    sp += 0x0002;
  case 0xce16:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ce1c() // 0bc9:118c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 28, r16[di]);
    if (!memoryAGet16(ds, r16[di] + 2))
        { pc = 0xce46; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 14)) <= signed16(0x0000))
        { pc = 0xce41; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 2);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    { pc = 0xce46; break; }
  case 0xce41:
    r16[ax] = memoryAGet16(ds, r16[di]);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
  case 0xce46:
    if (memoryAGet16(ds, r16[si] + 30) != 0xffff)
        { pc = 0xce51; break; }
    memoryASet16(ds, r16[si] + 30, 0x0000);
  case 0xce51:
    r16[ax] = memoryAGet16(ds, r16[si] + 6);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ds, r16[si] + 6, 0x0000);
    r16[ax] = 0;
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xc923, r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_c335();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[si] + 6, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 6) != 0x0002)
        { pc = 0xce86; break; }
    push(r16[si]);
    push(cs);
    yield* sub_c5c6();
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xce86:
    if (memoryAGet16(ds, r16[si] + 6) != 0x0001)
        { pc = 0xce94; break; }
    push(r16[si]);
    push(cs);
    yield* sub_c335();
    sp += 0x0002;
  case 0xce94:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ce9a() // 0bc9:120a +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 28, r16[di]);
    memoryASet16(ds, r16[si] + 26, 0x0000);
    if (!memoryAGet16(ds, r16[di] + 2))
        { pc = 0xcec6; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 14)) <= signed16(0x0000))
        { pc = 0xcec1; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 2);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    { pc = 0xcec6; break; }
  case 0xcec1:
    r16[ax] = memoryAGet16(ds, r16[di]);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
  case 0xcec6:
    if (memoryAGet16(ds, r16[si] + 30) != 0xffff)
        { pc = 0xced1; break; }
    memoryASet16(ds, r16[si] + 30, 0x0000);
  case 0xced1:
    memoryASet16(ds, r16[si] + 4, 0x0001);
    r16[ax] = 0;
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xc923, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 54) == 0x0019)
        { pc = 0xceec; break; }
    push(r16[si]);
    push(cs);
    yield* sub_c335();
    sp += 0x0002;
  case 0xceec:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_cef0() // 0bc9:1260 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 48);
    if (r16[ax] < memoryAGet16(ds, 0xc74f))
        { pc = 0xcf1b; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    if (r16[ax] < memoryAGet16(ds, 0xc74d))
        { pc = 0xcf1b; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 44);
    if (r16[ax] > memoryAGet16(ds, 0xc625))
        { pc = 0xcf1b; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 46);
    if (r16[ax] <= memoryAGet16(ds, 0xc623))
        { pc = 0xcf20; break; }
  case 0xcf1b:
    r16[ax] = 0;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcf20:
    r16[ax] = 0x0001;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_cf26() // 0bc9:1296 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    flags.carry = r16[dx] < memoryAGet16(ds, 0xa54c);
    r16[dx] -= memoryAGet16(ds, 0xa54c);
    r16[ax] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0xcf8c; break; }
  case 0xcf46:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] &= 0x0001;
    r16[ax] |= 0x0000;
    if (!r16[ax])
        { pc = 0xcf7d; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 24)) >= signed16(0x0000))
        { pc = 0xcf6e; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 24)) < signed16(0xfffc))
        { pc = 0xcf6e; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0x0000);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcf6e:
    memoryASet16(ds, r16[si] + 24, memoryAGet16(ds, r16[si] + 24) + 0x0004);
    if (signed16(memoryAGet16(ds, r16[si] + 24)) <= signed16(0x0046))
        { pc = 0xcf7d; break; }
    memoryASet16(ds, r16[si] + 24, 0x0046);
  case 0xcf7d:
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
    flags.carry = memoryAGet16(ss, r16[bp] - 4) + 0x0001 >= 0x10000;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0001);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + (0x0000 + flags.carry));
  case 0xcf8c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    if (r16s[ax] < signed16(memoryAGet16(ds, 0xa54a)))
        { pc = 0xcf46; break; }
    if (r16[ax] != memoryAGet16(ds, 0xa54a))
        { pc = 0xcfa0; break; }
    if (r16[dx] < memoryAGet16(ds, 0xa548))
        { pc = 0xcf46; break; }
  case 0xcfa0:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_cfa5() // 0bc9:1315 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    flags.carry = r16[dx] < memoryAGet16(ds, 0xa54c);
    r16[dx] -= memoryAGet16(ds, 0xa54c);
    r16[ax] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0xd00b; break; }
  case 0xcfc5:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] &= 0x0001;
    r16[ax] |= 0x0000;
    if (!r16[ax])
        { pc = 0xcffc; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 24)) >= signed16(0x0000))
        { pc = 0xcfed; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 24)) < signed16(0xfffd))
        { pc = 0xcfed; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0x0000);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xcfed:
    memoryASet16(ds, r16[si] + 24, memoryAGet16(ds, r16[si] + 24) + 0x0003);
    if (signed16(memoryAGet16(ds, r16[si] + 24)) <= signed16(0x0046))
        { pc = 0xcffc; break; }
    memoryASet16(ds, r16[si] + 24, 0x0046);
  case 0xcffc:
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) + r16[ax]);
    flags.carry = memoryAGet16(ss, r16[bp] - 4) + 0x0001 >= 0x10000;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0001);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + (0x0000 + flags.carry));
  case 0xd00b:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    if (r16s[ax] < signed16(memoryAGet16(ds, 0xa54a)))
        { pc = 0xcfc5; break; }
    if (r16[ax] != memoryAGet16(ds, 0xa54a))
        { pc = 0xd01f; break; }
    if (r16[dx] < memoryAGet16(ds, 0xa548))
        { pc = 0xcfc5; break; }
  case 0xd01f:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d08e() // 0bc9:13fe +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    r16[ax] &= 0x8000;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    flags.carry = r16[dx] < memoryAGet16(ds, 0xa54c);
    r16[dx] -= memoryAGet16(ds, 0xa54c);
    r16[ax] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0xd115; break; }
  case 0xd0ba:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] &= 0x0001;
    r16[ax] |= 0x0000;
    if (!r16[ax])
        { pc = 0xd106; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 22, memoryAGet16(ds, r16[si] + 22) + r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    r16[ax] &= 0x8000;
    if (r16[ax] == r16[di])
        { pc = 0xd0ec; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    r16[ax] &= 0x8000;
    r16[di] = r16[ax];
    if (!r16[di])
        { pc = 0xd0e6; break; }
    r16[ax] = 0xffff;
    { pc = 0xd0e9; break; }
  case 0xd0e6:
    r16[ax] = 0x0001;
  case 0xd0e9:
    memoryASet16(ds, r16[si] + 14, r16[ax]);
  case 0xd0ec:
    if (signed16(memoryAGet16(ds, r16[si] + 22)) <= r16s[cx])
        { pc = 0xd0f6; break; }
    memoryASet16(ds, r16[si] + 22, r16[cx]);
    { pc = 0xd106; break; }
  case 0xd0f6:
    r16[ax] = r16[cx];
    r16[ax] = -r16[ax];
    if (signed16(memoryAGet16(ds, r16[si] + 22)) >= r16s[ax])
        { pc = 0xd106; break; }
    r16[ax] = r16[cx];
    r16[ax] = -r16[ax];
    memoryASet16(ds, r16[si] + 22, r16[ax]);
  case 0xd106:
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) + r16[ax]);
    flags.carry = memoryAGet16(ss, r16[bp] - 4) + 0x0001 >= 0x10000;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0001);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + (0x0000 + flags.carry));
  case 0xd115:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    if (r16s[ax] < signed16(memoryAGet16(ds, 0xa54a)))
        { pc = 0xd0ba; break; }
    if (r16[ax] != memoryAGet16(ds, 0xa54a))
        { pc = 0xd129; break; }
    if (r16[dx] < memoryAGet16(ds, 0xa548))
        { pc = 0xd0ba; break; }
  case 0xd129:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d21f() // 0bc9:158f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    r16[ax] &= 0x8000;
    r16[di] = r16[ax];
    if (signed16(memoryAGet16(ds, r16[si] + 22)) <= signed16(0x0000))
        { pc = 0xd23d; break; }
    r16[cx] = 0xffff;
    { pc = 0xd24a; break; }
  case 0xd23d:
    if (signed16(memoryAGet16(ds, r16[si] + 22)) >= signed16(0x0000))
        { pc = 0xd248; break; }
    r16[cx] = 0x0001;
    { pc = 0xd24a; break; }
  case 0xd248:
    r16[cx] = 0;
  case 0xd24a:
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    flags.carry = r16[dx] < memoryAGet16(ds, 0xa54c);
    r16[dx] -= memoryAGet16(ds, 0xa54c);
    r16[ax] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0xd28c; break; }
  case 0xd260:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] &= 0x0001;
    r16[ax] |= 0x0000;
    if (!r16[ax])
        { pc = 0xd27d; break; }
    memoryASet16(ds, r16[si] + 22, memoryAGet16(ds, r16[si] + 22) + r16[cx]);
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    r16[ax] &= 0x8000;
    if (r16[ax] == r16[di])
        { pc = 0xd27d; break; }
    memoryASet16(ds, r16[si] + 22, 0x0000);
  case 0xd27d:
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) + r16[ax]);
    flags.carry = memoryAGet16(ss, r16[bp] - 4) + 0x0001 >= 0x10000;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0001);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + (0x0000 + flags.carry));
  case 0xd28c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    if (r16s[ax] < signed16(memoryAGet16(ds, 0xa54a)))
        { pc = 0xd260; break; }
    if (r16[ax] != memoryAGet16(ds, 0xa54a))
        { pc = 0xd2a0; break; }
    if (r16[dx] < memoryAGet16(ds, 0xa548))
        { pc = 0xd260; break; }
  case 0xd2a0:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d325() // 0bc9:1695 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(cs); cs = 0x0f7c; yield* sub_10503(); assert(cs == 0x0bc9);
    sp += 0x0002;
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 66, r16[ax]);
    memoryASet16(ds, r16[si] + 64, r16[ax]);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    memoryASet16(ds, r16[si] + 68, r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(r16[si]);
    push(cs);
    yield* sub_ce9a();
    sp += 0x0004;
    memoryASet16(ds, r16[si], 0x0021);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_d359() // 0bc9:16c9 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(r16[si]);
    push(cs);
    yield* sub_cf26();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    imul16(memoryAGet16(ds, 0xa54c));
    memoryASet16(ds, 0xc923, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_d3e2() // 0bc9:1752 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] += 0x004c;
    if (memoryAGet16(ds, r16[di]) != 0x0002)
        { pc = 0xd3fa; break; }
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x0bc9);
  case 0xd3fa:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d3fe() // 0bc9:176e +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(memoryAGet16(ds, r16[si] + 32));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 30));
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0bc9);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_d4d7() // 0bc9:1847 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xd50e; break; }
    if (!memoryAGet16(ds, r16[si] + 60))
        { pc = 0xd50e; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 18);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) - r16[ax]);
    memoryASet16(ds, r16[si] + 14, 0xffff);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x0bc9);
    r8[cl] = 0x05;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    push(memoryAGet16(ds, r16[si] + 28));
    push(r16[si]);
    push(cs);
    yield* sub_ce9a();
    sp += 0x0004;
    { pc = 0xd572; break; }
  case 0xd50e:
    if (memoryAGet16(ds, r16[si] + 14) != 0xffff)
        { pc = 0xd53e; break; }
    if (!memoryAGet16(ds, r16[si] + 56))
        { pc = 0xd53e; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 18);
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) - r16[ax]);
    memoryASet16(ds, r16[si] + 14, 0x0001);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x0bc9);
    r8[cl] = 0x05;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    push(memoryAGet16(ds, r16[si] + 28));
    push(r16[si]);
    push(cs);
    yield* sub_ce9a();
    sp += 0x0004;
    { pc = 0xd572; break; }
  case 0xd53e:
    if (!memoryAGet16(ds, r16[si] + 54))
        { pc = 0xd54b; break; }
    if (!(memoryAGet16(ds, r16[si] + 54) & 0xfff8))
        { pc = 0xd572; break; }
  case 0xd54b:
    r16[ax] = memoryAGet16(ds, r16[si] + 18);
    r16[ax] <<= 1;
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) - r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] = -r16[ax];
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x0bc9);
    r8[cl] = 0x05;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    push(memoryAGet16(ds, r16[si] + 28));
    push(r16[si]);
    push(cs);
    yield* sub_ce9a();
    sp += 0x0004;
  case 0xd572:
    push(memoryAGet16(ds, r16[si] + 32));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 30));
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0bc9);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d6de() // 0d6d:000e +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx], 0x0002);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff0f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[bx] + 14, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x098c;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0d6d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_d722() // 0d6d:0052 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    if (r16s[ax] > signed16(memoryAGet16(ds, 0xcab9)))
        { pc = 0xd74f; break; }
    if (r16s[ax] < signed16(memoryAGet16(ds, 0xcab9)))
        { pc = 0xd741; break; }
    if (r16[dx] >= memoryAGet16(ds, 0xcab7))
        { pc = 0xd74f; break; }
  case 0xd741:
    memoryASet16(ds, 0xcab9, 0x0000);
    memoryASet16(ds, 0xcab7, 0x0000);
    { pc = 0xd770; break; }
  case 0xd74f:
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    flags.carry = r16[dx] < memoryAGet16(ds, 0xcab7);
    r16[dx] -= memoryAGet16(ds, 0xcab7);
    r16[ax] -= memoryAGet16(ds, 0xcab9) + flags.carry;
    if (r16s[ax] > 0)
        { pc = 0xd770; break; }
    if (r16s[ax] < 0)
        { pc = 0xd769; break; }
    if (r16[dx] >= 0x0013)
        { pc = 0xd770; break; }
  case 0xd769:
    r16[ax] = 0;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd770:
    if (memoryAGet16(ds, 0xa7d0) != 0xffff)
        { pc = 0xd797; break; }
    r16[bx] = memoryAGet16(ds, r16[si] + 36);
    r16[bx] += 0x0060;
    r8[cl] = 0x08;
    r16[bx] >>= r8[cl];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    { pc = 0xd7af; break; }
  case 0xd797:
    r16[bx] = memoryAGet16(ds, r16[si] + 50);
    r16[bx]++;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0xd7af:
    r16[ax] = memoryAGet16(ds, r16[si] + 52);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 17574);
    r8[ah] = 0x00;
    r16[ax] &= 0x007f;
    if (r16[ax] != 0x0001)
        { pc = 0xd800; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 52);
    r16[ax]--;
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0080;
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    memoryASet16(ds, 0xc923, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa7d0);
    r8[cl] = 0x05;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, r16[si] + 6, 0x0000);
    memoryASet16(ds, r16[si] + 28, 0x0ef0);
    r16[ax] = 0x0001;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd800:
    r16[ax] = 0;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d807() // 0d6d:0137 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ds, r16[di] + 46);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7e9);
    r16[ax] = memoryAGet16(ds, r16[di] + 52);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 17574);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2) == 0x0005)
        { pc = 0xd84d; break; }
    if (memoryAGet16(ss, r16[bp] - 2) == 0x0006)
        { pc = 0xd84d; break; }
    if (memoryAGet16(ss, r16[bp] - 2) != 0x000f)
        { pc = 0xd87c; break; }
  case 0xd84d:
    r16[ax] = memoryAGet16(ds, r16[di] + 52);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] -= 0x0040;
    r16[dx] = r16[ax];
    if (memoryAGet16(ds, r16[di] + 10) == r16[dx])
        { pc = 0xd868; break; }
    memoryASet16(ds, r16[di] + 62, r16[dx]);
    memoryASet16(ds, r16[di] + 28, 0x0e3c);
    { pc = 0xd86d; break; }
  case 0xd868:
    memoryASet16(ds, r16[di] + 28, 0x0de2);
  case 0xd86d:
    memoryASet16(ds, 0xc5bd, 0x0001);
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd87c:
    if (memoryAGet16(ss, r16[bp] - 2) == 0x0002)
        { pc = 0xd888; break; }
    if (memoryAGet16(ss, r16[bp] - 2) != 0x0020)
        { pc = 0xd8fc; break; }
  case 0xd888:
    r16[ax] = memoryAGet16(ds, r16[di] + 52);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0060;
    r16[dx] = r16[ax];
    r16[bx] = memoryAGet16(ds, r16[di] + 46);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7e9);
    r16[ax] = memoryAGet16(ds, r16[di] + 52);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx] - 2);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 17574);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 4) == 0x0002)
        { pc = 0xd8ca; break; }
    if (memoryAGet16(ss, r16[bp] - 4) != 0x0020)
        { pc = 0xd8ce; break; }
  case 0xd8ca:
    r16[dx] -= 0x0100;
  case 0xd8ce:
    if (memoryAGet16(ds, r16[di] + 10) == r16[dx])
        { pc = 0xd8dd; break; }
    memoryASet16(ds, r16[di] + 62, r16[dx]);
    memoryASet16(ds, r16[di] + 28, 0x0e3c);
    { pc = 0xd8ed; break; }
  case 0xd8dd:
    memoryASet16(ds, 0xc5d1, 0x006e);
    memoryASet16(ds, r16[di] + 28, 0x0e5a);
    memoryASet16(ds, r16[di] + 32, 0x0000);
  case 0xd8ed:
    memoryASet16(ds, 0xc5bd, 0x0001);
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd8fc:
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_d904() // 0d6d:0234 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[si] += 0x004c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_d91c() // 0d6d:024c +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[si] += 0x004c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_d935() // 0d6d:0265 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, 0xa7ce))
        { pc = 0xd96a; break; }
    memoryASet16(ds, r16[si] + 28, 0x1094);
    push(r16[si]);
    push(cs);
    yield* sub_dcfc();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    imul16(memoryAGet16(ds, r16[bx] + 12));
    imul16(memoryAGet16(ds, 0xa54c));
    r16[bx] = 0x0004;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ds, 0xc923, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd96a:
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xd998; break; }
    if (memoryAGet16(ds, 0xc5bf))
        { pc = 0xd998; break; }
    memoryASet16(ds, 0xc5bf, 0x0001);
    if (memoryAGet16(ds, 0xa7d0) != 0xffff)
        { pc = 0xd98d; break; }
    memoryASet16(ds, r16[si] + 28, 0x0da6);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd98d:
    memoryASet16(ds, r16[si] + 28, 0x0d6a);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 3 bytes
  case 0xd998:
    if (!memoryAGet16(ds, 0xc5c9))
        { pc = 0xd9d6; break; }
    if (memoryAGet16(ds, 0xc5c7))
        { pc = 0xd9d6; break; }
    memoryASet16(ds, 0xc5c7, 0x0001);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, r16[si] + 22, 0x0000);
    memoryASet16(ds, r16[si] + 24, 0xffd8);
    memoryASet16(ds, 0xc921, 0x0000);
    memoryASet16(ds, 0xcabb, 0x0012);
    memoryASet16(ds, r16[si] + 28, 0x1166);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xd9d6:
    if (!memoryAGet16(ds, 0xc5c5))
        { pc = 0xda14; break; }
    if (memoryAGet16(ds, 0xc5c3))
        { pc = 0xda14; break; }
    memoryASet16(ds, 0xc5c3, 0x0001);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, r16[si] + 28, 0x110c);
    memoryASet16(ds, r16[si] + 22, 0x0000);
    memoryASet16(ds, r16[si] + 24, 0xffd0);
    memoryASet16(ds, 0xc921, 0x0000);
    memoryASet16(ds, 0xcabb, 0x0018);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xda14:
    r16[ax] = memoryAGet16(ds, 0xa7d0);
    if (r16[ax] == 0xffff)
        { pc = 0xda24; break; }
    if (r16[ax] == 0x0001)
        { pc = 0xda4e; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xda24:
    push(r16[si]);
    push(cs);
    yield* sub_d722();
    sp += 0x0002;
    if (r16[ax])
        { pc = 0xda62; break; }
    if (memoryAGet16(ds, 0xc5bd))
        { pc = 0xda43; break; }
    push(r16[si]);
    push(cs);
    yield* sub_d807();
    sp += 0x0002;
    if (r16[ax])
        { pc = 0xda62; break; }
  case 0xda43:
    memoryASet16(ds, r16[si] + 28, 0x0c02);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 3 bytes
  case 0xda4e:
    push(r16[si]);
    push(cs);
    yield* sub_d722();
    sp += 0x0002;
    if (r16[ax])
        { pc = 0xda62; break; }
    memoryASet16(ds, r16[si] + 28, 0x0c3e);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xda62:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_da65() // 0d6d:0395 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xa7d2) != 0x0008)
        { pc = 0xda88; break; }
    if (memoryAGet16(ds, 0xc5c9))
        { pc = 0xda88; break; }
    if (memoryAGet16(ds, 0xc5c5))
        { pc = 0xda88; break; }
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xdaa0; break; }
  case 0xda88:
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 64, r16[ax]);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    memoryASet16(ds, r16[si] + 28, 0x098c);
    push(r16[si]);
    push(cs);
    yield* sub_d935();
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdaa0:
    r16[ax] = memoryAGet16(ds, r16[si] + 54);
    r16[ax] &= 0xfff8;
    if (r16[ax] == 0x0018)
        { pc = 0xdab5; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 62);
    r16[ax] += memoryAGet16(ds, 0xa54c);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
  case 0xdab5:
    r16[ax] = memoryAGet16(ds, r16[si] + 64);
    if (!r16[ax])
        { pc = 0xdac9; break; }
    if (r16[ax] == 0x0001)
        { pc = 0xdae3; break; }
    if (r16[ax] == 0x0002)
        { pc = 0xdb12; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdac9:
    if (signed16(memoryAGet16(ds, r16[si] + 62)) <= signed16(0x00c8))
        { pc = 0xdb29; break; }
    memoryASet16(ds, r16[si] + 64, memoryAGet16(ds, r16[si] + 64) + 1);
    memoryASet16(ds, r16[si] + 28, 0x09aa);
    memoryASet16(ds, r16[si] + 62, 0x0000);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 3 bytes
  case 0xdae3:
    if (signed16(memoryAGet16(ds, r16[si] + 62)) <= signed16(0x012c))
        { pc = 0xdb29; break; }
    memoryASet16(ds, r16[si] + 64, memoryAGet16(ds, r16[si] + 64) + 1);
    memoryASet16(ds, r16[si] + 62, 0x0000);
    if (memoryAGet16(ds, 0xcab5) != 0x0001)
        { pc = 0xdb07; break; }
    memoryASet16(ds, 0xcab5, 0x0002);
    memoryASet16(ds, r16[si] + 28, 0x0a7c);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdb07:
    memoryASet16(ds, r16[si] + 28, 0x09c8);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 3 bytes
  case 0xdb12:
    if (signed16(memoryAGet16(ds, r16[si] + 62)) <= signed16(0x02bc))
        { pc = 0xdb29; break; }
    memoryASet16(ds, r16[si] + 64, memoryAGet16(ds, r16[si] + 64) + 1);
    memoryASet16(ds, r16[si] + 28, 0x0ad6);
    memoryASet16(ds, r16[si] + 62, 0x0000);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdb29:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_db6a() // 0d6d:049a +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xa7d0) != 0xffff)
        { pc = 0xdba2; break; }
    if (memoryAGet16(ds, 0xa7ce))
        { pc = 0xdba2; break; }
    if (!memoryAGet16(ds, 0xc5c9))
        { pc = 0xdb8d; break; }
    if (!memoryAGet16(ds, 0xc5c7))
        { pc = 0xdba2; break; }
  case 0xdb8d:
    if (!memoryAGet16(ds, 0xc5c5))
        { pc = 0xdb9b; break; }
    if (!memoryAGet16(ds, 0xc5c3))
        { pc = 0xdba2; break; }
  case 0xdb9b:
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xdbaf; break; }
  case 0xdba2:
    memoryASet16(ds, r16[si] + 28, 0x098c);
    push(r16[si]);
    push(cs);
    yield* sub_d935();
    sp += 0x0002;
  case 0xdbaf:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_dbb2() // 0d6d:04e2 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xc5c9))
        { pc = 0xdbc7; break; }
    { pc = 0xdcc7; break; }
  case 0xdbc7:
    if (!memoryAGet16(ds, 0xc5c7))
        { pc = 0xdbd1; break; }
    { pc = 0xdcc7; break; }
  case 0xdbd1:
    r16[ax] = memoryAGet16(ds, r16[si] + 54);
    r16[ax] &= 0x0007;
    if (r16[ax] == 0x0001)
        { pc = 0xdbdf; break; }
    { pc = 0xdcc7; break; }
  case 0xdbdf:
    memoryASet16(ds, 0xc5c7, 0x0001);
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    r16[dx] = 0;
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    r16[bx] = memoryAGet16(ds, r16[si] + 52);
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[di] + 11742))
        { pc = 0xdc21; break; }
    { pc = 0xdcf6; break; }
  case 0xdc21:
    if (!memoryAGet(es, r16[di] + 5910))
        { pc = 0xdc2c; break; }
    { pc = 0xdcf6; break; }
  case 0xdc2c:
    if (!memoryAGet(es, r16[di] + 8826))
        { pc = 0xdc37; break; }
    { pc = 0xdcf6; break; }
  case 0xdc37:
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[di] + 11742))
        { pc = 0xdc54; break; }
    { pc = 0xdcf6; break; }
  case 0xdc54:
    if (!memoryAGet(es, r16[di] + 5910))
        { pc = 0xdc5f; break; }
    { pc = 0xdcf6; break; }
  case 0xdc5f:
    if (!memoryAGet(es, r16[di] + 8826))
        { pc = 0xdc6a; break; }
    { pc = 0xdcf6; break; }
  case 0xdc6a:
    if (memoryAGet16(ds, 0xa54c) >= 0x0004)
        { pc = 0xdc76; break; }
    r16[ax] = 0x0004;
    { pc = 0xdc79; break; }
  case 0xdc76:
    r16[ax] = memoryAGet16(ds, 0xa54c);
  case 0xdc79:
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (!memoryAGet16(ds, 0x7a6e))
        { pc = 0xdc91; break; }
    r16[bx] = memoryAGet16(ds, 0x7a6e);
    r16[ax] = memoryAGet16(ds, r16[bx] + 20);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + r16[ax]);
  case 0xdc91:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[si] + 40, memoryAGet16(ds, r16[si] + 40) + r16[ax]);
    memoryASet16(ds, 0x7a6e, 0x0000);
    memoryASet16(ds, r16[si] + 12, memoryAGet16(ds, r16[si] + 12) + r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, r16[si] + 28, 0x11a2);
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 24, r16[ax]);
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdcc7:
    if (memoryAGet16(ds, 0xa7d0) != 0x0001)
        { pc = 0xdcf1; break; }
    if (memoryAGet16(ds, 0xa7ce))
        { pc = 0xdcf1; break; }
    if (!memoryAGet16(ds, 0xc5c9))
        { pc = 0xdce3; break; }
    if (!memoryAGet16(ds, 0xc5c7))
        { pc = 0xdcf1; break; }
  case 0xdce3:
    if (!memoryAGet16(ds, 0xc5c5))
        { pc = 0xdcf6; break; }
    if (memoryAGet16(ds, 0xc5c3))
        { pc = 0xdcf6; break; }
  case 0xdcf1:
    memoryASet16(ds, r16[si] + 28, 0x0c98);
  case 0xdcf6:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_dcfc() // 0d6d:062c +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xa7ce))
        { pc = 0xdd1f; break; }
    memoryASet16(ds, r16[si] + 28, 0x098c);
    push(r16[si]);
    push(cs);
    yield* sub_d935();
    sp += 0x0002;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdd1f:
    r16[ax] = memoryAGet16(ds, 0xa7ce);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7d0);
    if (r16[ax] == 0xffff)
        { pc = 0xdd34; break; }
    if (r16[ax] == 0x0001)
        { pc = 0xdd63; break; }
    { pc = 0xdd79; break; }
  case 0xdd34:
    push(r16[si]);
    push(cs);
    yield* sub_d722();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0xdd43; break; }
    { pc = 0xdea3; break; }
  case 0xdd43:
    if (!memoryAGet16(ds, 0xc5bd))
        { pc = 0xdd4d; break; }
    { pc = 0xdea3; break; }
  case 0xdd4d:
    push(r16[si]);
    push(cs);
    yield* sub_d807();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0xdd5c; break; }
    { pc = 0xdea3; break; }
  case 0xdd5c:
    { pc = 0xdd79; break; }
    // gap 5 bytes
  case 0xdd63:
    push(r16[si]);
    push(cs);
    yield* sub_d722();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0xdd72; break; }
    { pc = 0xdea3; break; }
  case 0xdd72:
    { pc = 0xdd79; break; }
    // gap 5 bytes
  case 0xdd79:
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xddad; break; }
    if (memoryAGet16(ds, 0xc5bf))
        { pc = 0xddad; break; }
    memoryASet16(ds, 0xc5bf, 0x0001);
    if (memoryAGet16(ds, 0xa7d0) != 0xffff)
        { pc = 0xdd9e; break; }
    memoryASet16(ds, r16[si] + 28, 0x0da6);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xdd9e:
    memoryASet16(ds, r16[si] + 28, 0x0d6a);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 5 bytes
  case 0xddad:
    if (!memoryAGet16(ds, 0xc5c9))
        { pc = 0xddef; break; }
    if (memoryAGet16(ds, 0xc5c7))
        { pc = 0xddef; break; }
    memoryASet16(ds, 0xc5c7, 0x0001);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0xffd8);
    r16[ax] = 0;
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, 0xcabb, 0x0012);
    memoryASet16(ds, r16[si] + 28, 0x1166);
  case 0xddef:
    if (!memoryAGet16(ds, 0xc5c5))
        { pc = 0xde34; break; }
    if (memoryAGet16(ds, 0xc5c3))
        { pc = 0xde34; break; }
    memoryASet16(ds, 0xc5c3, 0x0001);
    memoryASet16(ds, r16[si] + 28, 0x110c);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0xffd0);
    memoryASet16(ds, 0xc923, 0x0000);
    memoryASet16(ds, 0xcabb, 0x0018);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xde34:
    r16[bx] = memoryAGet16(ds, r16[si] + 54);
    r16[bx] &= 0x0007;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5054);
    imul16(memoryAGet16(ds, 0xa54c));
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) + r16[ax]);
    if (memoryAGet16(ds, r16[si] + 28) != 0x1094)
        { pc = 0xde6d; break; }
    if (memoryAGet16(ds, r16[si] + 66))
        { pc = 0xde6d; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, r16[si] + 66, 0x0001);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xde6d:
    if (memoryAGet16(ds, r16[si] + 28) != 0x10d0)
        { pc = 0xde90; break; }
    if (memoryAGet16(ds, r16[si] + 66))
        { pc = 0xde90; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, r16[si] + 66, 0x0001);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xde90:
    if (memoryAGet16(ds, r16[si] + 28) == 0x10b2)
        { pc = 0xde9e; break; }
    if (memoryAGet16(ds, r16[si] + 28) != 0x10ee)
        { pc = 0xdea3; break; }
  case 0xde9e:
    memoryASet16(ds, r16[si] + 66, 0x0000);
  case 0xdea3:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_dea8() // 0d6d:07d8 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 62);
    r16[ax] -= memoryAGet16(ds, r16[si] + 10);
    r16[di] = r16[ax];
    if (r16s[di] >= 0)
        { pc = 0xded9; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[dx] = memoryAGet16(ds, 0xc923);
    r16[dx] -= r16[ax];
    memoryASet16(ds, 0xc923, r16[dx]);
    if (signed16(memoryAGet16(ds, 0xc923)) <= r16s[di])
        { pc = 0xdef4; break; }
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0xded9:
    if (r16s[di] <= 0)
        { pc = 0xdef4; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[dx] = memoryAGet16(ds, 0xc923);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0xc923, r16[dx]);
    if (signed16(memoryAGet16(ds, 0xc923)) < r16s[di])
        { pc = 0xdf0e; break; }
  case 0xdef4:
    memoryASet16(ds, 0xc923, r16[di]);
    memoryASet16(ds, r16[si] + 62, 0x0000);
    push(r16[si]);
    push(cs);
    yield* sub_d807();
    sp += 0x0002;
    if (r16[ax])
        { pc = 0xdf0e; break; }
    memoryASet16(ds, r16[si] + 28, 0x098c);
  case 0xdf0e:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_df12() // 0d6d:0842 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ds, r16[si] + 50);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7eb);
    r16[bx] = memoryAGet16(ds, r16[si] + 44);
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    r16[ax] = r16[di];
    r16[ax] &= 0x00ff;
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] -= 0x0100;
    r16[ax] += 0x000f;
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] >>= r8[cl];
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    memoryASet16(ds, r16[si] + 32, 0x0001);
    memoryASet16(ds, r16[si] + 6, 0x0000);
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    push(memoryAGet16(ds, r16[bx] + 28));
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    memoryASet16(ds, r16[si] + 6, 0x0001);
    push(r16[si]);
    push(cs); cs = 0x08aa; yield* sub_a345(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_e22b() // 0d6d:0b5b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, 0xc62b))
        { pc = 0xe251; break; }
    if (!memoryAGet16(ds, 0xc5c9))
        { pc = 0xe251; break; }
    memoryASet16(ds, r16[si] + 24, 0xffd8);
    memoryASet16(ds, 0xcabb, 0x0012);
    memoryASet16(ds, 0xc5c7, 0x0001);
  case 0xe251:
    if (!memoryAGet16(ds, 0xcabb))
        { pc = 0xe2b5; break; }
    r16[ax] = memoryAGet16(ds, 0xcabb);
    if (r16[ax] > memoryAGet16(ds, 0xa54c))
        { pc = 0xe273; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    imul16(memoryAGet16(ds, 0xcabb));
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, 0xcabb, 0x0000);
    { pc = 0xe28e; break; }
  case 0xe273:
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    imul16(memoryAGet16(ds, 0xa54c));
    memoryASet16(ds, 0xc921, r16[ax]);
    if (memoryAGet16(ds, 0xc62b))
        { pc = 0xe28e; break; }
    r16[ax] = memoryAGet16(ds, 0xcabb);
    r16[ax] -= memoryAGet16(ds, 0xa54c);
    memoryASet16(ds, 0xcabb, r16[ax]);
  case 0xe28e:
    if (memoryAGet16(ds, 0xc5c9))
        { pc = 0xe29b; break; }
    memoryASet16(ds, 0xcabb, 0x0000);
  case 0xe29b:
    if (memoryAGet16(ds, 0xcabb))
        { pc = 0xe2ed; break; }
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    if (!memoryAGet16(ds, r16[bx] + 28))
        { pc = 0xe2ed; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 28);
    memoryASet16(ds, r16[si] + 28, r16[ax]);
    { pc = 0xe2ed; break; }
    // gap 2 bytes
  case 0xe2b5:
    if (memoryAGet16(ds, 0x7a6c) != 0x0001)
        { pc = 0xe2c7; break; }
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_cfa5(); assert(cs == 0x0d6d);
    sp += 0x0002;
    { pc = 0xe2d0; break; }
  case 0xe2c7:
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_cf26(); assert(cs == 0x0d6d);
    sp += 0x0002;
  case 0xe2d0:
    if (signed16(memoryAGet16(ds, r16[si] + 24)) <= signed16(0x0000))
        { pc = 0xe2ed; break; }
    if (memoryAGet16(ds, r16[si] + 28) == 0x11a2)
        { pc = 0xe2ed; break; }
    if (memoryAGet16(ds, r16[si] + 28) == 0x11c0)
        { pc = 0xe2ed; break; }
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[ax] = memoryAGet16(ds, r16[bx] + 28);
    memoryASet16(ds, r16[si] + 28, r16[ax]);
  case 0xe2ed:
    if (!memoryAGet16(ds, 0xa7ce))
        { pc = 0xe30f; break; }
    r16[ax] = memoryAGet16(ds, 0xa7ce);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    r16[ax] = 0x0018;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7ce);
    r16[ax] <<= 1;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_d08e(); assert(cs == 0x0d6d);
    sp += 0x0006;
    { pc = 0xe318; break; }
  case 0xe30f:
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_d21f(); assert(cs == 0x0d6d);
    sp += 0x0002;
  case 0xe318:
    if (memoryAGet16(ds, r16[si] + 58) != 0x0011)
        { pc = 0xe326; break; }
    r16[ax] = 0;
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, r16[si] + 22, r16[ax]);
  case 0xe326:
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xe365; break; }
    if (memoryAGet16(ds, 0xc5bf))
        { pc = 0xe365; break; }
    memoryASet16(ds, 0xc5bf, 0x0001);
    r16[ax] = memoryAGet16(ds, 0xa7d0);
    if (r16[ax] == 0xffff)
        { pc = 0xe34d; break; }
    if (!r16[ax])
        { pc = 0xe355; break; }
    if (r16[ax] == 0x0001)
        { pc = 0xe35d; break; }
    { pc = 0xe365; break; }
  case 0xe34d:
    memoryASet16(ds, r16[si] + 28, 0x1238);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xe355:
    memoryASet16(ds, r16[si] + 28, 0x11de);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xe35d:
    memoryASet16(ds, r16[si] + 28, 0x1292);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xe365:
    if (!memoryAGet16(ds, 0xc5c5))
        { pc = 0xe387; break; }
    if (memoryAGet16(ds, 0xc5c3))
        { pc = 0xe387; break; }
    memoryASet16(ds, 0xc5c3, 0x0001);
    memoryASet16(ds, r16[si] + 28, 0x112a);
    memoryASet16(ds, 0xcabb, 0x0000);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xe387:
    if (memoryAGet16(ds, 0xa7d0) != 0xffff)
        { pc = 0xe396; break; }
    push(r16[si]);
    push(cs);
    yield* sub_d722();
    sp += 0x0002;
  case 0xe396:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_eab9() // 0d6d:13e9 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xc5d1))
        { pc = 0xeac6; break; }
    { pc = 0xeb77; break; }
  case 0xeac6:
    if (!memoryAGet16(ds, 0xc629))
        { pc = 0xead0; break; }
    { pc = 0xeb77; break; }
  case 0xead0:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    if (memoryAGet16(ds, r16[bx] + 28) != 0x0cd4)
        { pc = 0xeade; break; }
    { pc = 0xeb77; break; }
  case 0xeade:
    memoryASet16(ds, 0xcab5, 0x0000);
    memoryASet16(ds, 0xc5d1, 0x001e);
    memoryASet16(ds, 0xa7da, 0x0001);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    if (memoryAGet16(ds, 0xa7ed) != 0x0011)
        { pc = 0xeb31; break; }
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x0d6d);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0xeb1d; break; }
    r16[ax] = 0x0d2e;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xeb5d; break; }
  case 0xeb1d:
    r16[ax] = 0x0d4c;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xeb5d; break; }
    // gap 2 bytes
  case 0xeb31:
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x0d6d);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0xeb4d; break; }
    r16[ax] = 0x0cf2;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xeb5d; break; }
  case 0xeb4d:
    r16[ax] = 0x0d10;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
  case 0xeb5d:
    r16[ax] = 0x0017;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 24, 0xffd8);
    memoryASet16(ds, r16[bx] + 22, 0x0010);
  case 0xeb77:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_eb79() // 0d6d:14a9 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ds, r16[si]);
    if (r16[ax] != 0x0011)
        { pc = 0xeb8e; break; }
    { pc = 0xece0; break; }
  case 0xeb8e:
    if (r16s[ax] > signed16(0x0011))
        { pc = 0xeba9; break; }
    if (r16[ax] == 0x0004)
        { pc = 0xebc5; break; }
    if (r16[ax] != 0x0006)
        { pc = 0xeb9d; break; }
    { pc = 0xec54; break; }
  case 0xeb9d:
    if (r16[ax] != 0x000f)
        { pc = 0xeba5; break; }
    { pc = 0xecb8; break; }
  case 0xeba5:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xeba9:
    if (r16[ax] != 0x0014)
        { pc = 0xebb1; break; }
    { pc = 0xec9b; break; }
  case 0xebb1:
    if (r16[ax] != 0x0018)
        { pc = 0xebb9; break; }
    { pc = 0xecc9; break; }
  case 0xebb9:
    if (r16[ax] != 0x0021)
        { pc = 0xebc1; break; }
    { pc = 0xec95; break; }
  case 0xebc1:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xebc5:
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    if (r16[bx] <= 0x000b)
        { pc = 0xebd0; break; }
    { pc = 0xece6; break; }
  case 0xebd0:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0xebd7; break; }
        case 2: { pc = 0xebd7; break; }
        case 4: { pc = 0xebd7; break; }
        case 6: { pc = 0xebd7; break; }
        case 8: { pc = 0xebd7; break; }
        case 10: { pc = 0xebd7; break; }
        case 12: { pc = 0xebd7; break; }
        case 14: { pc = 0xebd7; break; }
        case 16: { pc = 0xebd7; break; }
        case 18: { pc = 0xebd7; break; }
        case 20: { pc = 0xebd7; break; }
        default:
            stop("ind 0d6d:1502");
    }
    break;
  case 0xebd7:
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 5084));
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, r16[si], 0x0001);
    memoryASet16(ds, r16[si] + 32, 0x0003);
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5132);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 5108));
    push(cs); cs = 0x08aa; yield* sub_a992(); assert(cs == 0x0d6d);
    sp += 0x0002;
    if (signed16(memoryAGet16(ds, r16[si] + 62)) >= signed16(0x0004))
        { pc = 0xec1f; break; }
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 31328, memoryAGet16(ds, r16[bx] + 31328) + 1);
    { pc = 0xec3f; break; }
  case 0xec1f:
    if (memoryAGet16(ds, r16[si] + 62) != 0x000a)
        { pc = 0xec2b; break; }
    memoryASet16(ds, 0x7a6a, memoryAGet16(ds, 0x7a6a) + 1);
    { pc = 0xec3f; break; }
  case 0xec2b:
    if (memoryAGet16(ds, r16[si] + 62) != 0x000b)
        { pc = 0xec3f; break; }
    r16[bx] = memoryAGet16(ds, 0x7a6c);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5076);
    memoryASet16(ds, 0x7a58, memoryAGet16(ds, 0x7a58) + r16[ax]);
  case 0xec3f:
    r16[ax] = 0x1f28;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 4 bytes
  case 0xec54:
    if (memoryAGet16(ds, r16[di] + 54))
        { pc = 0xec5d; break; }
    { pc = 0xece6; break; }
  case 0xec5d:
    if (memoryAGet16(ds, 0xa7ed) != 0x000e)
        { pc = 0xec7b; break; }
    push(cs); cs = 0x107c; yield* sub_10f99(); assert(cs == 0x0d6d);
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x0d6d);
    push(r16[si]);
    push(cs); cs = 0x08aa; yield* sub_a92b(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xec7b:
    r16[ax] = 0x001f;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, 0x7a70, 0x0003);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 4 bytes
  case 0xec95:
    if (memoryAGet16(ds, r16[si] + 68) != 0x000f)
        { pc = 0xece6; break; }
  case 0xec9b:
    if (memoryAGet16(ds, 0x7a6e))
        { pc = 0xece6; break; }
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x0bc9; yield* sub_c9c3(); assert(cs == 0x0d6d);
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 8 bytes
  case 0xecb8:
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x0bc9; yield* sub_ca30(); assert(cs == 0x0d6d);
    sp += 0x0006;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xecc9:
    push(cs); cs = 0x107c; yield* sub_10e05(); assert(cs == 0x0d6d);
    push(r16[si]);
    push(cs); cs = 0x08aa; yield* sub_a92b(); assert(cs == 0x0d6d);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x0d6d);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xece0:
    memoryASet16(ds, 0x7a70, 0x0007);
  case 0xece6:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ed9d() // 0d6d:16cd +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ds, 0x7a6e);
    r16[ax] = memoryAGet16(ds, r16[si] + 38);
    if (r16[ax] < memoryAGet16(ds, r16[di] + 34))
        { pc = 0xedb9; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 34);
    if (r16[ax] <= memoryAGet16(ds, r16[di] + 38))
        { pc = 0xedc3; break; }
  case 0xedb9:
    memoryASet16(ds, 0x7a6e, 0x0000);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xedc3:
    if (signed16(memoryAGet16(ds, r16[si] + 20)) >= signed16(0x0000))
        { pc = 0xedf2; break; }
    memoryASet16(ds, 0x7a6e, 0x0000);
    if (signed16(memoryAGet16(ds, r16[di] + 20)) >= signed16(0x0000))
        { pc = 0xee41; break; }
    memoryASet16(ds, 0xc923, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[di] + 20);
    memoryASet16(ds, 0xc921, r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c7d9(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 4 bytes
  case 0xedf2:
    r16[ax] = memoryAGet16(ds, r16[di] + 18);
    memoryASet16(ds, 0xc923, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 36);
    r16[ax] -= memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= 0x0010;
    memoryASet16(ds, 0xc921, r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c7d9(); assert(cs == 0x0d6d);
    sp += 0x0002;
    if (!memoryAGet16(ds, 0x7ade))
        { pc = 0xee23; break; }
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) & 0xff80);
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] &= 0x007f;
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) | r16[ax]);
    { pc = 0xee2c; break; }
  case 0xee23:
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] &= 0x001f;
    memoryASet16(ds, r16[si] + 10, memoryAGet16(ds, r16[si] + 10) | r16[ax]);
  case 0xee2c:
    if (!memoryAGet16(ds, r16[si] + 58))
        { pc = 0xee3c; break; }
    memoryASet16(ds, 0x7a6e, 0x0000);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xee3c:
    memoryASet16(ds, r16[si] + 54, 0x0019);
  case 0xee41:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ee45() // 0d6d:1775 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x1424;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19338(); assert(cs == 0x0d6d);
    sp += 0x000e;
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 5084));
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 5108));
    push(cs); cs = 0x08aa; yield* sub_a992(); assert(cs == 0x0d6d);
    sp += 0x0002;
    if (r16[si] >= 0x0004)
        { pc = 0xee96; break; }
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 31328, memoryAGet16(ds, r16[bx] + 31328) + 1);
    { pc = 0xeeb4; break; }
  case 0xee96:
    if (r16[si] != 0x000a)
        { pc = 0xeea1; break; }
    memoryASet16(ds, 0x7a6a, memoryAGet16(ds, 0x7a6a) + 1);
    { pc = 0xeeb4; break; }
  case 0xeea1:
    if (r16[si] != 0x000b)
        { pc = 0xeeb4; break; }
    r16[bx] = memoryAGet16(ds, 0x7a6c);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5076);
    memoryASet16(ds, 0x7a58, memoryAGet16(ds, 0x7a58) + r16[ax]);
  case 0xeeb4:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    r16[ax] = r16[di];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, 0xffff);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5132);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 30, r16[ax]);
    memoryASet16(ds, r16[bx] + 64, r16[ax]);
    r16[ax] = 0x1f28;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0d6d);
    sp += 0x0004;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ef0f() // 0d6d:183f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x1424;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19338(); assert(cs == 0x0d6d);
    sp += 0x000e;
    r16[ax] = 0x000a;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x1195; yield* sub_11b5c(); assert(cs == 0x0d6d);
    sp += 0x0004;
    memoryASet16(ds, 0x7a5a, memoryAGet16(ds, 0x7a5a) + 1);
    r16[ax] = memoryAGet16(ds, 0x7a5a);
    if (r16[ax] != 0x0064)
        { pc = 0xefb5; break; }
    memoryASet16(ds, 0x7a5a, 0x0000);
    r16[ax] = 0x0011;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    memoryASet16(ds, 0x7a6a, memoryAGet16(ds, 0x7a6a) + 1);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    r16[ax] = r16[si];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = r16[di];
    r16[ax]--;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, 0xffff);
    r16[ax] = 0x00da;
    memoryASet16(ds, r16[bx] + 30, r16[ax]);
    memoryASet16(ds, r16[bx] + 64, r16[ax]);
    r16[ax] = 0x1f28;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0d6d);
    sp += 0x0004;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
  case 0xefb5:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_efb9() // 0d6d:18e9 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xcab5) != 0x0001)
        { pc = 0xefd1; break; }
    memoryASet16(ds, 0xcab5, 0x0000);
  case 0xefd1:
    r16[bx] = memoryAGet16(ds, r16[si] + 46);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    r16[bx] = memoryAGet16(ds, r16[si] + 44);
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 48);
    r16[ax] -= memoryAGet16(ds, r16[si] + 44);
    r16[ax]++;
    r16[dx] = memoryAGet16(ds, 0xa7e4);
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = memoryAGet16(ds, r16[si] + 46);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xf106; break; }
  case 0xf008:
    r16[di] = memoryAGet16(ds, r16[si] + 44);
    { pc = 0xf0f3; break; }
  case 0xf00e:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6); es = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 17574);
    r8[ah] = 0x00;
    r16[ax] &= 0x007f;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    if (r16[ax])
        { pc = 0xf02c; break; }
    { pc = 0xf0ee; break; }
  case 0xf02c:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] -= 0x0003;
    if (r16[bx] <= 0x0019)
        { pc = 0xf03a; break; }
    { pc = 0xf0ee; break; }
  case 0xf03a:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0xf041; break; }
        case 2: { pc = 0xf048; break; }
        case 4: { pc = 0xf0ee; break; }
        case 6: { pc = 0xf0ee; break; }
        case 8: { pc = 0xf056; break; }
        case 10: { pc = 0xf056; break; }
        case 12: { pc = 0xf056; break; }
        case 14: { pc = 0xf056; break; }
        case 16: { pc = 0xf0ee; break; }
        case 18: { pc = 0xf0ee; break; }
        case 20: { pc = 0xf0ee; break; }
        case 22: { pc = 0xf0ee; break; }
        case 24: { pc = 0xf0ee; break; }
        case 26: { pc = 0xf0c8; break; }
        case 28: { pc = 0xf0ee; break; }
        case 30: { pc = 0xf0ee; break; }
        case 32: { pc = 0xf0ee; break; }
        case 34: { pc = 0xf0ee; break; }
        case 36: { pc = 0xf0d9; break; }
        case 38: { pc = 0xf0d9; break; }
        case 40: { pc = 0xf0d9; break; }
        case 42: { pc = 0xf0d9; break; }
        case 44: { pc = 0xf0d9; break; }
        case 46: { pc = 0xf0d9; break; }
        case 48: { pc = 0xf0d9; break; }
        case 50: { pc = 0xf0d9; break; }
        default:
            stop("ind 0d6d:196c");
    }
    break;
  case 0xf041:
    push(cs);
    yield* sub_eab9();
    { pc = 0xf0ee; break; }
  case 0xf048:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[di]);
    push(cs);
    yield* sub_ef0f();
    sp += 0x0004;
    { pc = 0xf0ee; break; }
  case 0xf056:
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xf061; break; }
    { pc = 0xf111; break; }
  case 0xf061:
    if (memoryAGet16(ds, r16[si] + 54))
        { pc = 0xf06a; break; }
    { pc = 0xf111; break; }
  case 0xf06a:
    if (memoryAGet16(ds, r16[si] + 28) != 0x0e1e)
        { pc = 0xf074; break; }
    { pc = 0xf111; break; }
  case 0xf074:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] -= 0x0007;
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 31328))
        { pc = 0xf086; break; }
    { pc = 0xf111; break; }
  case 0xf086:
    r16[ax] = r16[di];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0xffc0;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 12))
        { pc = 0xf0ab; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    memoryASet16(ds, r16[si] + 28, 0x0e3c);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xf0ab:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] -= 0x0007;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 31328, memoryAGet16(ds, r16[bx] + 31328) - 1);
    r16[ax] = 0x0e1e;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xf0ee; break; }
    // gap 2 bytes
  case 0xf0c8:
    if (memoryAGet16(ds, 0xcab5))
        { pc = 0xf0ee; break; }
    memoryASet16(ds, 0xcab5, 0x0001);
    { pc = 0xf0ee; break; }
    // gap 2 bytes
  case 0xf0d9:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] -= 0x0015;
    r16[ax] += 0x0004;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[di]);
    push(cs);
    yield* sub_ee45();
    sp += 0x0006;
  case 0xf0ee:
    r16[di]++;
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 0x0002);
  case 0xf0f3:
    if (memoryAGet16(ds, r16[si] + 48) < r16[di])
        { pc = 0xf0fb; break; }
    { pc = 0xf00e; break; }
  case 0xf0fb:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + r16[ax]);
  case 0xf106:
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    if (r16[ax] < memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xf111; break; }
    { pc = 0xf008; break; }
  case 0xf111:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_f172() // 0d6d:1aa2 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, r16[si] + 54))
        { pc = 0xf1b1; break; }
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0x0000);
    r16[ax] = 0x11a2;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    memoryASet16(ds, 0xcabb, 0x0000);
    { pc = 0xf20f; break; }
  case 0xf1b1:
    r16[ax] = memoryAGet16(ds, r16[si] + 54);
    r16[ax] &= 0xfff8;
    if (r16[ax] != 0x0008)
        { pc = 0xf1c2; break; }
    push(cs);
    yield* sub_eab9();
    { pc = 0xf20f; break; }
  case 0xf1c2:
    if (memoryAGet16(ds, r16[si] + 54) != 0x0029)
        { pc = 0xf1ea; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, 0xc921, 0x0000);
    memoryASet16(ds, r16[si] + 62, 0x0000);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c335(); assert(cs == 0x0d6d);
    sp += 0x0002;
    { pc = 0xf20f; break; }
  case 0xf1ea:
    if (memoryAGet16(ds, r16[si] + 54) != 0x0031)
        { pc = 0xf20f; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[dx] = 0xfff8;
    imul16(r16[dx]);
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, 0xc921, 0x0000);
    memoryASet16(ds, r16[si] + 62, 0x0000);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c335(); assert(cs == 0x0d6d);
    sp += 0x0002;
  case 0xf20f:
    push(memoryAGet16(ds, r16[si] + 32));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 30));
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0d6d);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_f22f() // 0d6d:1b5f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, r16[si] + 54))
        { pc = 0xf26f; break; }
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0x0000);
    r16[ax] = 0x11a2;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    memoryASet16(ds, 0xcabb, 0x0000);
    { pc = 0xf2f8; break; }
  case 0xf26f:
    r16[ax] = memoryAGet16(ds, r16[si] + 54);
    r16[ax] &= 0xfff8;
    if (r16[ax] != 0x0008)
        { pc = 0xf280; break; }
    push(cs);
    yield* sub_eab9();
    { pc = 0xf2f8; break; }
  case 0xf280:
    if (memoryAGet16(ds, r16[si] + 54) != 0x0029)
        { pc = 0xf2a3; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, 0xc921, 0x0000);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c335(); assert(cs == 0x0d6d);
    sp += 0x0002;
    { pc = 0xf2f8; break; }
  case 0xf2a3:
    if (memoryAGet16(ds, r16[si] + 54) != 0x0031)
        { pc = 0xf2c5; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[dx] = 0xfff8;
    imul16(r16[dx]);
    memoryASet16(ds, 0xc923, r16[ax]);
    memoryASet16(ds, 0xc921, 0x0000);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c335(); assert(cs == 0x0d6d);
    sp += 0x0002;
    { pc = 0xf2f8; break; }
  case 0xf2c5:
    if (!memoryAGet16(ds, r16[si] + 56))
        { pc = 0xf2d1; break; }
    if (memoryAGet16(ds, r16[si] + 14) == 0xffff)
        { pc = 0xf2dd; break; }
  case 0xf2d1:
    if (!memoryAGet16(ds, r16[si] + 60))
        { pc = 0xf2f8; break; }
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xf2f8; break; }
  case 0xf2dd:
    memoryASet16(ds, r16[si] + 26, 0x0000);
    memoryASet16(ds, r16[si] + 28, 0x098c);
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xf2f2; break; }
    r16[ax] = memoryAGet16(ds, 0x098e);
    { pc = 0xf2f5; break; }
  case 0xf2f2:
    r16[ax] = memoryAGet16(ds, 0x098c);
  case 0xf2f5:
    memoryASet16(ds, r16[si] + 30, r16[ax]);
  case 0xf2f8:
    push(memoryAGet16(ds, r16[si] + 32));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 30));
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0d6d);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_f318() // 0d6d:1c48 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, r16[si] + 56))
        { pc = 0xf32f; break; }
    if (memoryAGet16(ds, r16[si] + 14) == 0xffff)
        { pc = 0xf33b; break; }
  case 0xf32f:
    if (!memoryAGet16(ds, r16[si] + 60))
        { pc = 0xf340; break; }
    if (memoryAGet16(ds, r16[si] + 14) != 0x0001)
        { pc = 0xf340; break; }
  case 0xf33b:
    memoryASet16(ds, r16[si] + 22, 0x0000);
  case 0xf340:
    if (!memoryAGet16(ds, r16[si] + 58))
        { pc = 0xf39f; break; }
    if (memoryAGet16(ds, r16[si] + 58) != 0x0011)
        { pc = 0xf368; break; }
    memoryASet16(ds, r16[si] + 12, memoryAGet16(ds, r16[si] + 12) - 0x0020);
    memoryASet16(ds, r16[si] + 36, memoryAGet16(ds, r16[si] + 36) - 0x0020);
    memoryASet16(ds, r16[si] + 22, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 52);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] -= 0x0020;
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    { pc = 0xf39f; break; }
  case 0xf368:
    if (memoryAGet16(ds, 0xc62b))
        { pc = 0xf39f; break; }
    r16[ax] = 0x000f;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    if (signed16(memoryAGet16(ds, r16[si] + 58)) <= signed16(0x0001))
        { pc = 0xf394; break; }
    memoryASet16(ds, r16[si] + 24, memoryAGet16(ds, r16[si] + 24) + 0x0010);
    if (signed16(memoryAGet16(ds, r16[si] + 24)) >= signed16(0x0000))
        { pc = 0xf399; break; }
    memoryASet16(ds, r16[si] + 24, 0x0000);
    { pc = 0xf399; break; }
    // gap 2 bytes
  case 0xf394:
    memoryASet16(ds, r16[si] + 24, 0x0000);
  case 0xf399:
    memoryASet16(ds, 0xcabb, 0x0000);
  case 0xf39f:
    if (memoryAGet16(ds, r16[si] + 54))
        { pc = 0xf3a8; break; }
    { pc = 0xf438; break; }
  case 0xf3a8:
    memoryASet16(ds, r16[si] + 20, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 54);
    r16[ax] &= 0xfff8;
    if (r16[ax] != 0x0008)
        { pc = 0xf3bf; break; }
    push(cs);
    yield* sub_eab9();
    { pc = 0xf62e; break; }
  case 0xf3bf:
    if (memoryAGet16(ds, r16[si] + 54) != 0x0019)
        { pc = 0xf3cf; break; }
    if (!memoryAGet16(ds, 0xcabb))
        { pc = 0xf3cf; break; }
    { pc = 0xf62e; break; }
  case 0xf3cf:
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 64, r16[ax]);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 28) != 0x11de)
        { pc = 0xf3ed; break; }
    r16[ax] = 0x0d6a;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xf426; break; }
  case 0xf3ed:
    if (memoryAGet16(ds, r16[si] + 28) != 0x1238)
        { pc = 0xf403; break; }
    r16[ax] = 0x0da6;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xf426; break; }
  case 0xf403:
    if (!memoryAGet16(ds, 0xa7ce))
        { pc = 0xf419; break; }
    r16[ax] = 0x1094;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xf426; break; }
  case 0xf419:
    r16[ax] = 0x098c;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
  case 0xf426:
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0d6d);
    sp += 0x0002;
    { pc = 0xf62e; break; }
    // gap 3 bytes
  case 0xf438:
    if (signed16(memoryAGet16(ds, r16[si] + 20)) > signed16(0x0000))
        { pc = 0xf441; break; }
    { pc = 0xf62e; break; }
  case 0xf441:
    r16[ax] = memoryAGet16(ds, r16[si] + 36);
    r16[ax] -= memoryAGet16(ds, r16[si] + 20);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 36);
    r16[ax] -= 0x0040;
    r16[ax] &= 0xff00;
    r16[ax] += 0x0040;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    if (r16[ax] < memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xf46c; break; }
    { pc = 0xf62e; break; }
  case 0xf46c:
    r16[ax] = memoryAGet16(ds, r16[si] + 36);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0xf477; break; }
    { pc = 0xf62e; break; }
  case 0xf477:
    if (memoryAGet16(ds, 0xa7ce) == 0xffff)
        { pc = 0xf481; break; }
    { pc = 0xf55d; break; }
  case 0xf481:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    r16[bx] = memoryAGet16(ds, r16[si] + 44);
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (!memoryAGet16(ds, r16[si] + 56))
        { pc = 0xf4a9; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 0x0002);
  case 0xf4a9:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[di] + 5910);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0xf4c1; break; }
    { pc = 0xf62e; break; }
  case 0xf4c1:
    r8[al] = memoryAGet(es, r16[di] + 11742);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0xf4cf; break; }
    { pc = 0xf62e; break; }
  case 0xf4cf:
    r8[al] = memoryAGet(es, r16[di] + 2994);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0xf4dd; break; }
    { pc = 0xf62e; break; }
  case 0xf4dd:
    r8[al] = memoryAGet(es, r16[di] + 8826);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0xf4eb; break; }
    { pc = 0xf62e; break; }
  case 0xf4eb:
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (memoryAGet(es, r16[bx] + 5910))
        { pc = 0xf507; break; }
    { pc = 0xf62e; break; }
  case 0xf507:
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (memoryAGet(es, r16[bx] + 2994))
        { pc = 0xf523; break; }
    { pc = 0xf62e; break; }
  case 0xf523:
    memoryASet16(ds, r16[si] + 14, 0xffff);
    memoryASet16(ds, r16[si] + 6, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[ax] &= 0xff00;
    r16[ax] += 0x0080;
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= 0x0040;
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 20, r16[ax]);
    memoryASet16(ds, r16[si] + 24, r16[ax]);
    r16[ax] = 0x12ec;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
    { pc = 0xf62e; break; }
    // gap 3 bytes
  case 0xf55d:
    if (memoryAGet16(ds, 0xa7ce) == 0x0001)
        { pc = 0xf567; break; }
    { pc = 0xf62e; break; }
  case 0xf567:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    r16[bx] = memoryAGet16(ds, r16[si] + 48);
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (!memoryAGet16(ds, r16[si] + 60))
        { pc = 0xf58f; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
  case 0xf58f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[di] + 5910);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0xf5a7; break; }
    { pc = 0xf62e; break; }
  case 0xf5a7:
    r8[al] = memoryAGet(es, r16[di] + 11742);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0xf62e; break; }
    r8[al] = memoryAGet(es, r16[di] + 2994);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0xf62e; break; }
    r8[al] = memoryAGet(es, r16[di] + 8826);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0xf62e; break; }
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 11742))
        { pc = 0xf62e; break; }
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[bx] + 2994))
        { pc = 0xf62e; break; }
    memoryASet16(ds, r16[si] + 14, 0x0001);
    memoryASet16(ds, r16[si] + 6, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[ax] &= 0xff00;
    r16[ax] += 0x0100;
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= 0x0040;
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 20, r16[ax]);
    memoryASet16(ds, r16[si] + 24, r16[ax]);
    r16[ax] = 0x12ec;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0d6d);
    sp += 0x0004;
  case 0xf62e:
    push(memoryAGet16(ds, r16[si] + 32));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 30));
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0d6d);
    sp += 0x000c;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_f7c3() // 0f7c:0003 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xa7d4);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx] + 64, 0xffff);
    memoryASet16(ds, r16[bx] + 62, 0xffff);
    memoryASet16(ds, r16[bx] + 66, 0xffff);
    memoryASet16(ds, r16[bx] + 68, 0xffff);
    if (!memoryAGet16(ds, 0xa52f))
        { pc = 0xf7ff; break; }
    memoryASet16(ds, r16[bx] + 28, 0x089c);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xf7ff:
    if (memoryAGet16(ds, 0x3bd6))
        { pc = 0xf818; break; }
    r16[ax] = 0x1456;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d4));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xf818:
    r16[ax] = 0x1474;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d4));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x0081, memoryAGet(es, 0x0081) | r8[dl]);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_f838() // 0f7c:0078 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0x7eff);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    ds = memoryAGet16(ss, r16[bp] - 2);
    es = memoryAGet16(ss, r16[bp] + 10);
    r16[cx] = 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 12);
    r16[bx]--;
  case 0xf860:
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + r16[ax]);
    if (--r16[cx])
        { pc = 0xf860; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_f88b() // 0f7c:00cb +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[ax] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, 0x0912);
    r16[si] = memoryAGet16(ds, 0x7ce7);
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = r16[si];
    push(memoryAGet16(es, 0x0002));
    push(memoryAGet16(es, 0x0000));
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_154de(); assert(cs == 0x0f7c);
    sp += 0x000c;
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = r16[si];
    push(memoryAGet16(es, 0x0004));
    push(memoryAGet16(es, 0x0000));
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_154de(); assert(cs == 0x0f7c);
    sp += 0x000c;
    r16[ax] = 0x0006;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = r16[si];
    push(memoryAGet16(es, 0x0006));
    push(memoryAGet16(es, 0x0000));
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_154de(); assert(cs == 0x0f7c);
    sp += 0x000c;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_f90f() // 0f7c:014f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x001c;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, 0xa52f))
        { pc = 0xf924; break; }
    { pc = 0xfc72; break; }
  case 0xf924:
    if (!memoryAGet16(ds, 0x3bd6))
        { pc = 0xf93a; break; }
    push(r16[si]);
    push(cs);
    yield* sub_fc78();
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xf93a:
    if (memoryAGet16(ds, 0xc5cd))
        { pc = 0xf944; break; }
    { pc = 0xfc72; break; }
  case 0xf944:
    memoryASet16(ss, r16[bp] - 28, 0x0000);
    r16[ax] = memoryAGet16(ds, 0x7a52);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 62);
    push(r16[dx]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[bx] = pop();
    flags.zero = r16[bx] == r16[dx];
    r16[dx] = pop();
    if (!flags.zero)
        { pc = 0xf969; break; }
    if (r16[dx] != r16[ax])
        { pc = 0xf969; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 64);
    if (r16[ax] != memoryAGet16(ds, 0x7a50))
        { pc = 0xf969; break; }
    { pc = 0xfa38; break; }
  case 0xf969:
    r16[ax] = memoryAGet16(ds, 0x7ce7);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] = memoryAGet16(es, 0x0010);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    r16[ax] = memoryAGet16(es, 0x0008);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7ce7);
    r16[dx] = 0;
    r16[dx] += memoryAGet16(es, 0x0000);
    r16[dx] += memoryAGet16(ss, r16[bp] - 24);
    r16[bx] = memoryAGet16(ss, r16[bp] - 22);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[dx] += r16[bx];
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(memoryAGet16(ds, 0x7a52));
    push(memoryAGet16(ds, 0x7a50));
    push(cs); cs = 0x01ed; yield* sub_3b85(); assert(cs == 0x0f7c);
    sp += 0x0008;
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x0f7c);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[di] = 0x0009;
    { pc = 0xf9e4; break; }
  case 0xf9c8:
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 22));
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(r16[ax]);
    r16[ax] = 0x0029;
    push(r16[ax]);
    push(cs);
    yield* sub_f838();
    sp += 0x000a;
    r16[di]--;
  case 0xf9e4:
    if (r16[di] > memoryAGet16(ss, r16[bp] - 20))
        { pc = 0xf9c8; break; }
    r16[ax] = r16[bp] - 10;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    { pc = 0xfa15; break; }
  case 0xf9f1:
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 22));
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    r16[ax] += 0xfffa;
    push(r16[ax]);
    push(cs);
    yield* sub_f838();
    sp += 0x000a;
  case 0xfa15:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0xf9f1; break; }
    push(cs);
    yield* sub_f88b();
    memoryASet16(ds, r16[si] + 4, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x7a52);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7a50);
    memoryASet16(ds, r16[si] + 64, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, 0x0001);
  case 0xfa38:
    r16[ax] = memoryAGet16(ds, 0x7a58);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 66);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 26))
        { pc = 0xfa49; break; }
    { pc = 0xfb2f; break; }
  case 0xfa49:
    r16[ax] = memoryAGet16(ds, 0x7ce7);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] = memoryAGet16(es, 0x0010);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    r16[ax] = memoryAGet16(es, 0x0008);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7ce7);
    r16[dx] = 0;
    r16[dx] += memoryAGet16(es, 0x0000);
    r16[dx] += memoryAGet16(ss, r16[bp] - 24);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    r16[bx] = 0x0014;
    push(r16[dx]);
    imul16(r16[bx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[dx] += 0x0007;
    r16[ax] = pop();
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    if (memoryAGet16(ss, r16[bp] - 26) <= 0x0063)
        { pc = 0xfa9c; break; }
    r16[ax] = 0x1846;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x0f7c);
    sp += 0x0004;
    { pc = 0xfab2; break; }
  case 0xfa9c:
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 26));
    push(cs); cs = 0x01ed; yield* sub_3b85(); assert(cs == 0x0f7c);
    sp += 0x0008;
  case 0xfab2:
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x0f7c);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[di] = 0x0002;
    { pc = 0xfae2; break; }
  case 0xfac6:
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 22));
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(r16[ax]);
    r16[ax] = 0x0029;
    push(r16[ax]);
    push(cs);
    yield* sub_f838();
    sp += 0x000a;
    r16[di]--;
  case 0xfae2:
    if (r16[di] > memoryAGet16(ss, r16[bp] - 20))
        { pc = 0xfac6; break; }
    r16[ax] = r16[bp] - 10;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    { pc = 0xfb13; break; }
  case 0xfaef:
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 22));
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    r16[ax] += 0xfffa;
    push(r16[ax]);
    push(cs);
    yield* sub_f838();
    sp += 0x000a;
  case 0xfb13:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0xfaef; break; }
    push(cs);
    yield* sub_f88b();
    memoryASet16(ds, r16[si] + 4, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] - 26);
    memoryASet16(ds, r16[si] + 66, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, 0x0001);
  case 0xfb2f:
    r16[ax] = memoryAGet16(ds, r16[si] + 68);
    if (r16[ax] != memoryAGet16(ds, 0x7a6a))
        { pc = 0xfb3b; break; }
    { pc = 0xfc22; break; }
  case 0xfb3b:
    r16[ax] = memoryAGet16(ds, 0x7ce7);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] = memoryAGet16(es, 0x0010);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    r16[ax] = memoryAGet16(es, 0x0008);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7ce7);
    r16[dx] = 0;
    r16[dx] += memoryAGet16(es, 0x0000);
    r16[dx] += memoryAGet16(ss, r16[bp] - 24);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    r16[bx] = 0x0014;
    push(r16[dx]);
    imul16(r16[bx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[dx] += 0x0002;
    r16[ax] = pop();
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    if (signed16(memoryAGet16(ds, 0x7a6a)) <= signed16(0x0063))
        { pc = 0xfb8f; break; }
    r16[ax] = 0x1849;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x0f7c);
    sp += 0x0004;
    { pc = 0xfba5; break; }
  case 0xfb8f:
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7a6a);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3b85(); assert(cs == 0x0f7c);
    sp += 0x0008;
  case 0xfba5:
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x0f7c);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[di] = 0x0002;
    { pc = 0xfbd5; break; }
  case 0xfbb9:
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 22));
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(r16[ax]);
    r16[ax] = 0x0029;
    push(r16[ax]);
    push(cs);
    yield* sub_f838();
    sp += 0x000a;
    r16[di]--;
  case 0xfbd5:
    if (r16[di] > memoryAGet16(ss, r16[bp] - 20))
        { pc = 0xfbb9; break; }
    r16[ax] = r16[bp] - 10;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    { pc = 0xfc06; break; }
  case 0xfbe2:
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 22));
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 1);
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    r16[ax] += 0xfffa;
    push(r16[ax]);
    push(cs);
    yield* sub_f838();
    sp += 0x000a;
  case 0xfc06:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    if (memoryAGet(ds, r16[bx]))
        { pc = 0xfbe2; break; }
    push(cs);
    yield* sub_f88b();
    memoryASet16(ds, r16[si] + 4, 0x0001);
    r16[ax] = memoryAGet16(ds, 0x7a6a);
    memoryASet16(ds, r16[si] + 68, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, 0x0001);
  case 0xfc22:
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    if (r16[ax] != memoryAGet16(ds, 0xc753))
        { pc = 0xfc34; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    if (r16[ax] == memoryAGet16(ds, 0xc751))
        { pc = 0xfc45; break; }
  case 0xfc34:
    r16[ax] = memoryAGet16(ds, 0xc753);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc751);
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, 0x0001);
  case 0xfc45:
    if (!memoryAGet16(ss, r16[bp] - 28))
        { pc = 0xfc72; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x00fd;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[ax] += 0x0040;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[ax] += 0x0040;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0f7c);
    sp += 0x000c;
  case 0xfc72:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_fc78() // 0f7c:04b8 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    if (r16[ax] != memoryAGet16(ds, 0xc753))
        { pc = 0xfc91; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    if (r16[ax] == memoryAGet16(ds, 0xc751))
        { pc = 0xfcc7; break; }
  case 0xfc91:
    r16[ax] = memoryAGet16(ds, 0xc753);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc751);
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0x0081;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[ax] += 0x0080;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[ax] += 0x0a00;
    r16[ax] -= 0x0200;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x0f7c);
    sp += 0x000c;
  case 0xfcc7:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_fcca() // 0f7c:050a +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (memoryAGet16(ds, 0x7a70) == 0x0007)
        { pc = 0xfcd7; break; }
    { pc = 0xfd80; break; }
  case 0xfcd7:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx], 0x0002);
    r16[ax] = memoryAGet16(ds, 0x7a1a);
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7a1c);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
    if (memoryAGet16(ds, 0x7a1a) >= 0x1400)
        { pc = 0xfd3d; break; }
    memoryASet16(ds, r16[bx] + 62, 0x0118);
    r16[ax] = 0x1e00;
    r16[ax] -= memoryAGet16(ds, r16[bx] + 10);
    r16[bx] = 0x0118;
    r16[dx] = 0;
    div16(r16[bx]);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 22, r16[ax]);
    r16[ax] = 0x3700;
    r16[ax] -= memoryAGet16(ds, r16[bx] + 12);
    r16[bx] = 0x0118;
    r16[dx] = 0;
    div16(r16[bx]);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 24, r16[ax]);
    { pc = 0xfd6e; break; }
  case 0xfd3d:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 62, 0x008c);
    r16[ax] = 0x1000;
    r16[ax] -= memoryAGet16(ds, r16[bx] + 10);
    r16[bx] = 0x008c;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 22, r16[ax]);
    r16[ax] = 0x2f00;
    r16[ax] -= memoryAGet16(ds, r16[bx] + 12);
    r16[bx] = 0x008c;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[ax]++;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 24, r16[ax]);
  case 0xfd6e:
    r16[ax] = 0x1492;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d6));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xfd80:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx], 0x0002);
    if (memoryAGet16(ds, 0x7a1a))
        { pc = 0xfda3; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    { pc = 0xfdb3; break; }
  case 0xfda3:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    r16[ax] = memoryAGet16(ds, 0x7a1a);
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7a1c);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
  case 0xfdb3:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0001);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
    memoryASet16(ds, r16[bx] + 62, 0x0006);
    memoryASet16(ds, r16[bx] + 64, 0x0003);
    memoryASet16(ds, r16[bx] + 66, 0x0000);
    memoryASet16(ds, r16[bx] + 30, 0x0100);
    r16[ax] = 0x14ec;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_fdee() // 0f7c:062e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 46);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0xfe61; break; }
  case 0xfe01:
    r16[di] = memoryAGet16(ds, r16[si] + 44);
    { pc = 0xfe59; break; }
  case 0xfe06:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7eb);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 4) <= 0xc000)
        { pc = 0xfe58; break; }
    if (memoryAGet16(ss, r16[bp] - 4) > 0xc012)
        { pc = 0xfe58; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    memoryASet16(ds, 0x7a1a, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    memoryASet16(ds, 0x7a1c, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= 0xc000;
    memoryASet16(ds, 0x7a68, r16[ax]);
    memoryASet16(ds, 0x7a70, 0x0002);
    r16[ax] = 0x000c;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
  case 0xfe58:
    r16[di]++;
  case 0xfe59:
    if (memoryAGet16(ds, r16[si] + 48) >= r16[di])
        { pc = 0xfe06; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0xfe61:
    r16[ax] = memoryAGet16(ds, r16[si] + 50);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 2))
        { pc = 0xfe01; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_fe6f() // 0f7c:06af +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xa7d2) == 0x0008)
        { pc = 0xfe90; break; }
    memoryASet16(ds, r16[si] + 28, 0x15a0);
    memoryASet16(ds, r16[si] + 64, 0x0000);
    push(r16[si]);
    push(cs);
    yield* sub_feb0();
    sp += 0x0002;
  case 0xfe90:
    if (memoryAGet16(ds, 0xc5c9))
        { pc = 0xfea5; break; }
    if (memoryAGet16(ds, 0xc5c5))
        { pc = 0xfea5; break; }
    if (!memoryAGet16(ds, 0xc5c1))
        { pc = 0xfead; break; }
  case 0xfea5:
    push(r16[si]);
    push(cs);
    yield* sub_fdee();
    sp += 0x0002;
  case 0xfead:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_feb0() // 0f7c:06f0 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, r16[si] + 66))
        { pc = 0xfed0; break; }
    memoryASet16(ds, r16[si] + 66, memoryAGet16(ds, r16[si] + 66) - 0x0004);
    if (signed16(memoryAGet16(ds, r16[si] + 66)) >= signed16(0x0000))
        { pc = 0xff1d; break; }
    memoryASet16(ds, r16[si] + 66, 0x0000);
    { pc = 0xff1d; break; }
    // gap 2 bytes
  case 0xfed0:
    r16[ax] = memoryAGet16(ds, 0xa7ce);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7d0);
    memoryASet16(ds, r16[si] + 16, r16[ax]);
    if (memoryAGet16(ds, 0xc5c5))
        { pc = 0xfef1; break; }
    if (memoryAGet16(ds, 0xc5c1))
        { pc = 0xfef1; break; }
    if (!memoryAGet16(ds, 0xc5c9))
        { pc = 0xfef9; break; }
  case 0xfef1:
    push(r16[si]);
    push(cs);
    yield* sub_fdee();
    sp += 0x0002;
  case 0xfef9:
    if (memoryAGet16(ds, 0xa7d2) != 0x0008)
        { pc = 0xff17; break; }
    memoryASet16(ds, r16[si] + 28, 0x14ec);
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5566);
    r16[ax] += 0x0003;
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xff17:
    r16[ax] = memoryAGet16(ds, 0xa7d2);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
  case 0xff1d:
    memoryASet16(ds, r16[si] + 64, memoryAGet16(ds, r16[si] + 64) + 1);
    r16[ax] = memoryAGet16(ds, r16[si] + 64);
    if (r16[ax] != 0x0004)
        { pc = 0xff2d; break; }
    memoryASet16(ds, r16[si] + 64, 0x0000);
  case 0xff2d:
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5566);
    r16[bx] = memoryAGet16(ds, r16[si] + 64);
    r16[bx] <<= 1;
    r16[ax] += memoryAGet16(ds, r16[bx] + 5582);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 64) != 0x0001)
        { pc = 0xff56; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0xff56:
    if (memoryAGet16(ds, r16[si] + 64) != 0x0003)
        { pc = 0xff68; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
  case 0xff68:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ff6b() // 0f7c:07ab +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, r16[si] + 62);
    r16[ax] -= memoryAGet16(ds, 0xa54c);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    imul16(memoryAGet16(ds, 0xa54c));
    memoryASet16(ds, 0xc923, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    imul16(memoryAGet16(ds, 0xa54c));
    memoryASet16(ds, 0xc921, r16[ax]);
    if (signed16(memoryAGet16(ds, r16[si] + 62)) > signed16(0x0000))
        { pc = 0xffe3; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 22);
    r16[dx] = memoryAGet16(ds, r16[si] + 62);
    r16[dx] = -r16[dx];
    imul16(r16[dx]);
    memoryASet16(ds, 0xc923, memoryAGet16(ds, 0xc923) - r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    r16[dx] = memoryAGet16(ds, r16[si] + 62);
    r16[dx] = -r16[dx];
    imul16(r16[dx]);
    memoryASet16(ds, 0xc921, memoryAGet16(ds, 0xc921) - r16[ax]);
    memoryASet16(ds, r16[si] + 32, 0x0001);
    memoryASet16(ds, r16[si] + 62, 0x0006);
    memoryASet16(ds, r16[si] + 64, 0x0003);
    memoryASet16(ds, r16[si] + 66, 0x0000);
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
    memoryASet16(ds, r16[si] + 28, 0x14ec);
    memoryASet16(ds, r16[si] + 30, 0x0100);
    memoryASet16(ds, r16[si] + 6, 0x0001);
  case 0xffe3:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_ffe6() // 0f7c:0826 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, r16[si] + 66))
        { pc = 0x10006; break; }
    memoryASet16(ds, r16[si] + 66, memoryAGet16(ds, r16[si] + 66) - 0x0006);
    if (signed16(memoryAGet16(ds, r16[si] + 66)) >= signed16(0x0000))
        { pc = 0x10026; break; }
    memoryASet16(ds, r16[si] + 66, 0x0000);
    { pc = 0x10026; break; }
    // gap 2 bytes
  case 0x10006:
    r16[ax] = memoryAGet16(ds, 0xa7ce);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7d0);
    memoryASet16(ds, r16[si] + 16, r16[ax]);
    if (memoryAGet16(ds, 0xa7ce))
        { pc = 0x10020; break; }
    if (!memoryAGet16(ds, 0xa7d0))
        { pc = 0x10026; break; }
  case 0x10020:
    r16[ax] = memoryAGet16(ds, 0xa7d2);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
  case 0x10026:
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5590);
    r16[ax] += memoryAGet16(ds, r16[si] + 64);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    memoryASet16(ds, r16[si] + 64, memoryAGet16(ds, r16[si] + 64) + 1);
    r16[ax] = memoryAGet16(ds, r16[si] + 64);
    if (r16[ax] != 0x0002)
        { pc = 0x10045; break; }
    memoryASet16(ds, r16[si] + 64, 0x0000);
  case 0x10045:
    if (memoryAGet16(ds, r16[si] + 64))
        { pc = 0x1005a; break; }
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1005a:
    r16[ax] = 0x001b;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_10069() // 0f7c:08a9 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, r16[si] + 66))
        { pc = 0x1007d; break; }
    { pc = 0x101a9; break; }
  case 0x1007d:
    r16[ax] = memoryAGet16(ds, r16[si] + 52);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= memoryAGet16(ds, r16[si] + 36);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, r16[si] + 36);
    r16[dx] += r16[ax];
    r8[cl] = 0x08;
    r16[dx] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[bx] >>= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7e9);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[bx] += r16[ax];
    r16[bx] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 17574);
    r8[ah] = 0x00;
    r16[di] = r16[ax];
    if (r16[di] == 0x000b)
        { pc = 0x100d6; break; }
    if (r16[di] == 0x000d)
        { pc = 0x100d6; break; }
    if (r16[di] == 0x000e)
        { pc = 0x100d6; break; }
    if (r16[di] == 0x000c)
        { pc = 0x100d6; break; }
    { pc = 0x101a9; break; }
  case 0x100d6:
    if (memoryAGet16(ds, 0x7a5c))
        { pc = 0x1011a; break; }
    r16[ax] = 0x000e;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
    push(cs); cs = 0x107c; yield* sub_11226(); assert(cs == 0x0f7c);
    push(cs); cs = 0x1841; yield* sub_19169(); assert(cs == 0x0f7c);
    r16[ax] = memoryAGet16(ds, r16[si] + 18);
    r16[ax] = -r16[ax];
    memoryASet16(ds, 0xc923, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 20);
    r16[ax] = -r16[ax];
    memoryASet16(ds, 0xc921, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, r16[si] + 16, r16[ax]);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_c335(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1011a:
    r16[bx] = r16[di];
    r16[bx] -= 0x000b;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5606);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
    if (memoryAGet16(ds, r16[si] + 28) != 0x14ce)
        { pc = 0x1013b; break; }
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 5190);
    memoryASet16(ds, r16[si] + 62, r16[ax]);
  case 0x1013b:
    r16[bx] = memoryAGet16(ds, r16[si] + 62);
    if (r16[bx] > 0x0006)
        { pc = 0x10178; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x1014a; break; }
        case 2: { pc = 0x10178; break; }
        case 4: { pc = 0x10156; break; }
        case 6: { pc = 0x10178; break; }
        case 8: { pc = 0x10162; break; }
        case 10: { pc = 0x10178; break; }
        case 12: { pc = 0x1016e; break; }
        default:
            stop("ind 0f7c:0985");
    }
    break;
  case 0x1014a:
    memoryASet16(ds, r16[si] + 14, 0x0000);
    memoryASet16(ds, r16[si] + 16, 0xffff);
    { pc = 0x10178; break; }
  case 0x10156:
    memoryASet16(ds, r16[si] + 14, 0x0001);
    memoryASet16(ds, r16[si] + 16, 0x0000);
    { pc = 0x10178; break; }
  case 0x10162:
    memoryASet16(ds, r16[si] + 14, 0x0000);
    memoryASet16(ds, r16[si] + 16, 0x0001);
    { pc = 0x10178; break; }
  case 0x1016e:
    memoryASet16(ds, r16[si] + 14, 0xffff);
    memoryASet16(ds, r16[si] + 16, 0x0000);
  case 0x10178:
    memoryASet16(ds, r16[si] + 64, 0x0000);
    memoryASet16(ds, r16[si] + 66, 0x0012);
    if (memoryAGet16(ds, r16[si] + 28) != 0x14ce)
        { pc = 0x1019c; break; }
    r16[ax] = 0x15a0;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1019c:
    r16[ax] = 0x14ce;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0f7c);
    sp += 0x0004;
  case 0x101a9:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_101bd() // 0f7c:09fd +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    memoryASet16(ds, r16[bx], 0x0022);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0060;
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfe20;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x0f7c);
    r16[bx] = 0x0010;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 26, r16[ax]);
    r16[ax] = 0x15ee;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1021b() // 0f7c:0a5b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    memoryASet16(ds, r16[bx], 0x0022);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    r16[ax] = memoryAGet16(ds, 0x7a1a);
    r16[ax] -= 0x0100;
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x7a1c);
    r16[ax] -= 0x0100;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0060;
    memoryASet16(ds, r16[bx] + 62, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfda0;
    memoryASet16(ds, r16[bx] + 64, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 62);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    flags.carry = r16[ax] < memoryAGet16(ds, r16[bx] + 10);
    r16[ax] -= memoryAGet16(ds, r16[bx] + 10);
    r16[dx] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 64);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    flags.carry = r16[ax] < memoryAGet16(ds, r16[bx] + 12);
    r16[ax] -= memoryAGet16(ds, r16[bx] + 12);
    r16[dx] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[si] = 0;
    { pc = 0x10367; break; }
  case 0x10293:
    r16[ax] = 0;
    r16[dx] = 0x0018;
    push(r16[ax]);
    push(r16[dx]);
    if (r16s[si] >= signed16(0x0018))
        { pc = 0x102a3; break; }
    r16[ax] = r16[si];
    { pc = 0x102a6; break; }
  case 0x102a3:
    r16[ax] = 0x0018;
  case 0x102a6:
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    push(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x0f7c);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x0f7c);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    r16[dx] = memoryAGet16(ds, r16[bx] + 10);
    r16[dx] += r16[ax];
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51903, r16[dx]);
    r16[ax] = 0;
    r16[dx] = 0x001e;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = r16[si];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    push(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x0f7c);
    push(r16[dx]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x0f7c);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    r16[dx] = memoryAGet16(ds, r16[bx] + 12);
    r16[dx] += r16[ax];
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51905, r16[dx]);
    if (r16s[si] >= signed16(0x000a))
        { pc = 0x1031b; break; }
    r16[ax] = r16[si];
    r16[dx] = 0x0030;
    imul16(r16[dx]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51905, memoryAGet16(ds, r16[bx] + 51905) - r16[ax]);
    { pc = 0x10366; break; }
  case 0x1031b:
    if (r16s[si] >= signed16(0x000f))
        { pc = 0x10335; break; }
    r16[ax] = r16[si];
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0140;
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51905, memoryAGet16(ds, r16[bx] + 51905) - r16[ax]);
    { pc = 0x10366; break; }
  case 0x10335:
    if (r16s[si] >= signed16(0x0014))
        { pc = 0x10352; break; }
    r16[ax] = 0x0014;
    r16[ax] -= r16[si];
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x01e0;
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51905, memoryAGet16(ds, r16[bx] + 51905) - r16[ax]);
    { pc = 0x10366; break; }
  case 0x10352:
    r16[ax] = 0x001d;
    r16[ax] -= r16[si];
    r16[dx] = 0x0030;
    imul16(r16[dx]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 51905, memoryAGet16(ds, r16[bx] + 51905) - r16[ax]);
  case 0x10366:
    r16[si]++;
  case 0x10367:
    if (r16s[si] >= signed16(0x001e))
        { pc = 0x1036f; break; }
    { pc = 0x10293; break; }
  case 0x1036f:
    r16[ax] = 0x1666;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d8));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_10384() // 0f7c:0bc4 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xc757))
        { pc = 0x103ac; break; }
    push(cs); cs = 0x1a61; yield* sub_1b0e7(); assert(cs == 0x0f7c);
    r16[ax] = 0x002b;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[ax] = memoryAGet16(ds, r16[bx] + 28);
    memoryASet16(ds, r16[si] + 28, r16[ax]);
  case 0x103ac:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_10503() // 0f7c:0d43 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[si], 0x0001);
    r16[ax] = 0x17b0;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x0f7c);
    sp += 0x0004;
    r16[ax] = 0x0019;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x0f7c);
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_107c3() // 107c:0003 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x08aa; yield* sub_a83e(); assert(cs == 0x107c);
    r16[ax] = 0x004a;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0xcb3b;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x107c);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa7eb);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x10cda; break; }
  case 0x107f6:
    r16[di] = 0;
    { pc = 0x10cce; break; }
  case 0x107fb:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
    if (memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x10811; break; }
    { pc = 0x10ccd; break; }
  case 0x10811:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx]--;
    if (r16[bx] <= 0x0057)
        { pc = 0x1081d; break; }
    { pc = 0x10ccd; break; }
  case 0x1081d:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x10824; break; }
        case 2: { pc = 0x10850; break; }
        case 4: { pc = 0x1087c; break; }
        case 6: { pc = 0x108a4; break; }
        case 8: { pc = 0x108cd; break; }
        case 10: { pc = 0x108e2; break; }
        case 12: { pc = 0x1090b; break; }
        case 14: { pc = 0x10934; break; }
        case 16: { pc = 0x10949; break; }
        case 18: { pc = 0x1095e; break; }
        case 20: { pc = 0x1098d; break; }
        case 22: { pc = 0x109bc; break; }
        case 24: { pc = 0x109d1; break; }
        case 26: { pc = 0x10a00; break; }
        case 28: { pc = 0x10a29; break; }
        case 30: { pc = 0x10a3e; break; }
        case 32: { pc = 0x10a67; break; }
        case 34: { pc = 0x10a7c; break; }
        case 36: { pc = 0x10a91; break; }
        case 38: { pc = 0x10aba; break; }
        case 40: { pc = 0x10acf; break; }
        case 42: { pc = 0x10af8; break; }
        case 44: { pc = 0x10a5d; break; }
        case 46: { pc = 0x10a53; break; }
        case 48: { pc = 0x10b0d; break; }
        case 50: { pc = 0x10b20; break; }
        case 52: { pc = 0x10b32; break; }
        case 54: { pc = 0x10b32; break; }
        case 56: { pc = 0x10b32; break; }
        case 58: { pc = 0x10b32; break; }
        case 60: { pc = 0x10ccd; break; }
        case 62: { pc = 0x10b4e; break; }
        case 64: { pc = 0x10b63; break; }
        case 66: { pc = 0x10b72; break; }
        case 68: { pc = 0x10b9e; break; }
        case 70: { pc = 0x10ccd; break; }
        case 72: { pc = 0x10ccd; break; }
        case 74: { pc = 0x10ccd; break; }
        case 76: { pc = 0x10ccd; break; }
        case 78: { pc = 0x10ccd; break; }
        case 80: { pc = 0x10ccd; break; }
        case 82: { pc = 0x10bbb; break; }
        case 84: { pc = 0x10aee; break; }
        case 86: { pc = 0x10ae4; break; }
        case 88: { pc = 0x1092a; break; }
        case 90: { pc = 0x10920; break; }
        case 92: { pc = 0x109f6; break; }
        case 94: { pc = 0x109ec; break; }
        case 96: { pc = 0x108c3; break; }
        case 98: { pc = 0x108b9; break; }
        case 100: { pc = 0x10901; break; }
        case 102: { pc = 0x108f7; break; }
        case 104: { pc = 0x10c49; break; }
        case 106: { pc = 0x10c49; break; }
        case 108: { pc = 0x10c49; break; }
        case 110: { pc = 0x10c49; break; }
        case 112: { pc = 0x10c64; break; }
        case 114: { pc = 0x10c64; break; }
        case 116: { pc = 0x10c64; break; }
        case 118: { pc = 0x10c64; break; }
        case 120: { pc = 0x10c64; break; }
        case 122: { pc = 0x10c64; break; }
        case 124: { pc = 0x10c64; break; }
        case 126: { pc = 0x10c64; break; }
        case 128: { pc = 0x10c64; break; }
        case 130: { pc = 0x10c64; break; }
        case 132: { pc = 0x10c64; break; }
        case 134: { pc = 0x10c64; break; }
        case 136: { pc = 0x10c8a; break; }
        case 138: { pc = 0x10c8a; break; }
        case 140: { pc = 0x10c8a; break; }
        case 142: { pc = 0x10c8a; break; }
        case 144: { pc = 0x10ab0; break; }
        case 146: { pc = 0x10aa6; break; }
        case 148: { pc = 0x10ca5; break; }
        case 150: { pc = 0x10cbb; break; }
        case 152: { pc = 0x10cb4; break; }
        case 154: { pc = 0x10cad; break; }
        case 156: { pc = 0x10c23; break; }
        case 158: { pc = 0x10c23; break; }
        case 160: { pc = 0x10c23; break; }
        case 162: { pc = 0x10c23; break; }
        case 164: { pc = 0x10bfd; break; }
        case 166: { pc = 0x10bfd; break; }
        case 168: { pc = 0x10bfd; break; }
        case 170: { pc = 0x10bfd; break; }
        case 172: { pc = 0x10a1f; break; }
        case 174: { pc = 0x10a15; break; }
        default:
            stop("ind 107c:005f");
    }
    break;
  case 0x10824:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x0d6d; yield* sub_d6de(); assert(cs == 0x107c);
    sp += 0x0006;
    push(cs); cs = 0x0f7c; yield* sub_f7c3(); assert(cs == 0x107c);
    memoryASet16(ds, 0xcb3d, 0x0001);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x00fd, memoryAGet(es, 0x00fd) | r8[dl]);
    { pc = 0x10ccd; break; }
  case 0x10850:
    r16[ax] = 0xffff;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x0d6d; yield* sub_d6de(); assert(cs == 0x107c);
    sp += 0x0006;
    push(cs); cs = 0x0f7c; yield* sub_f7c3(); assert(cs == 0x107c);
    memoryASet16(ds, 0xcb3d, 0x0001);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x00fd, memoryAGet(es, 0x00fd) | r8[dl]);
    { pc = 0x10ccd; break; }
  case 0x1087c:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x0f7c; yield* sub_fcca(); assert(cs == 0x107c);
    sp += 0x0004;
    push(cs); cs = 0x0f7c; yield* sub_f7c3(); assert(cs == 0x107c);
    memoryASet16(ds, 0xcb4f, 0x0001);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x00fd, memoryAGet(es, 0x00fd) | r8[dl]);
    { pc = 0x10ccd; break; }
  case 0x108a4:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11bb9(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb5d, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x108b9:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x108c3; break; }
    { pc = 0x10ccd; break; }
  case 0x108c3:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x108cd; break; }
    { pc = 0x10ccd; break; }
  case 0x108cd:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_12a6b(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb75, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x108e2:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_146a5(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb57, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x108f7:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x10901; break; }
    { pc = 0x10ccd; break; }
  case 0x10901:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x1090b; break; }
    { pc = 0x10ccd; break; }
  case 0x1090b:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_126d6(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb6b, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10920:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x1092a; break; }
    { pc = 0x10ccd; break; }
  case 0x1092a:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10934; break; }
    { pc = 0x10ccd; break; }
  case 0x10934:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_124b7(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb69, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10949:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_12892(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb73, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x1095e:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_12dfc(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb59, 0x0001);
    r16[si] = 0x015e;
    { pc = 0x10984; break; }
  case 0x10975:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si], memoryAGet(es, r16[si]) | r8[dl]);
    r16[si]++;
  case 0x10984:
    if (r16[si] <= 0x0161)
        { pc = 0x10975; break; }
    { pc = 0x10ccd; break; }
  case 0x1098d:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_12d82(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb59, 0x0001);
    r16[si] = 0x015e;
    { pc = 0x109b3; break; }
  case 0x109a4:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si], memoryAGet(es, r16[si]) | r8[dl]);
    r16[si]++;
  case 0x109b3:
    if (r16[si] <= 0x0161)
        { pc = 0x109a4; break; }
    { pc = 0x10ccd; break; }
  case 0x109bc:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_12fba(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb71, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x109d1:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11ead(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb5f, 0x0001);
    memoryASet16(ds, 0xcb83, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x109ec:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x109f6; break; }
    { pc = 0x10ccd; break; }
  case 0x109f6:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10a00; break; }
    { pc = 0x10ccd; break; }
  case 0x10a00:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_13198(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb6d, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10a15:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x10a1f; break; }
    { pc = 0x10ccd; break; }
  case 0x10a1f:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10a29; break; }
    { pc = 0x10ccd; break; }
  case 0x10a29:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_13f80(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb63, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10a3e:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_14397(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb65, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10a53:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x10a5d; break; }
    { pc = 0x10ccd; break; }
  case 0x10a5d:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10a67; break; }
    { pc = 0x10ccd; break; }
  case 0x10a67:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_1444f(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb7d, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10a7c:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_138fe(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb5b, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10a91:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_13d37(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb61, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10aa6:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x10ab0; break; }
    { pc = 0x10ccd; break; }
  case 0x10ab0:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10aba; break; }
    { pc = 0x10ccd; break; }
  case 0x10aba:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_123de(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb67, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10acf:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11d95(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb53, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10ae4:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x10aee; break; }
    { pc = 0x10ccd; break; }
  case 0x10aee:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10af8; break; }
    { pc = 0x10ccd; break; }
  case 0x10af8:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11c4e(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb51, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10b0d:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1841; yield* sub_18f18(); assert(cs == 0x107c);
    sp += 0x0006;
    { pc = 0x10ccd; break; }
  case 0x10b20:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1841; yield* sub_18f18(); assert(cs == 0x107c);
    sp += 0x0006;
    { pc = 0x10ccd; break; }
  case 0x10b32:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xffe5;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_1337b(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xcb6f, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10b4e:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x126d; yield* sub_137cc(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb6f, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10b63:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11950(); assert(cs == 0x107c);
    sp += 0x0004;
    { pc = 0x10ccd; break; }
  case 0x10b72:
    if (signed16(memoryAGet16(ds, 0x7a58)) < signed16(0x0005))
        { pc = 0x10b7c; break; }
    { pc = 0x10ccd; break; }
  case 0x10b7c:
    r16[ax] = 0x000b;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11af3(); assert(cs == 0x107c);
    sp += 0x0006;
    r16[bx] = memoryAGet16(ds, 0x19d2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 52027, 0x0001);
    { pc = 0x10ccd; break; }
    // gap 3 bytes
  case 0x10b9e:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_148c1(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x01ae, memoryAGet(es, 0x01ae) | r8[dl]);
    { pc = 0x10ccd; break; }
  case 0x10bbb:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs);
    yield* sub_114be();
    sp += 0x0004;
    push(cs); cs = 0x0f7c; yield* sub_f7c3(); assert(cs == 0x107c);
    memoryASet16(ds, 0xcb7b, 0x0001);
    r16[si] = 0x00db;
    { pc = 0x10be6; break; }
  case 0x10bd7:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si], memoryAGet(es, r16[si]) | r8[dl]);
    r16[si]++;
  case 0x10be6:
    if (r16[si] <= 0x00e2)
        { pc = 0x10bd7; break; }
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x00fd, memoryAGet(es, 0x00fd) | r8[dl]);
    { pc = 0x10ccd; break; }
  case 0x10bfd:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0003))
        { pc = 0x10c07; break; }
    { pc = 0x10ccd; break; }
  case 0x10c07:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xffad;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_1472b(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xcb79, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10c23:
    if (signed16(memoryAGet16(ds, 0x7a6c)) >= signed16(0x0002))
        { pc = 0x10c2d; break; }
    { pc = 0x10ccd; break; }
  case 0x10c2d:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xffb1;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_1472b(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xcb79, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10c49:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xffcb;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_1472b(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xcb79, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10c64:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xffc7;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11af3(); assert(cs == 0x107c);
    sp += 0x0006;
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(ds, r16[bx] + 6474);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 52027, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10c8a:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0xffbb;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x138f; yield* sub_145dc(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xcb7f, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10ca5:
    memoryASet16(ds, 0xcb81, 0x0001);
    { pc = 0x10ccd; break; }
  case 0x10cad:
    if (signed16(memoryAGet16(ds, 0x7a6c)) < signed16(0x0003))
        { pc = 0x10ccd; break; }
  case 0x10cb4:
    if (signed16(memoryAGet16(ds, 0x7a6c)) < signed16(0x0002))
        { pc = 0x10ccd; break; }
  case 0x10cbb:
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs); cs = 0x1195; yield* sub_11f09(); assert(cs == 0x107c);
    sp += 0x0004;
    memoryASet16(ds, 0xcb5f, 0x0001);
  case 0x10ccd:
    r16[di]++;
  case 0x10cce:
    if (r16[di] >= memoryAGet16(ds, 0xa7e4))
        { pc = 0x10cd7; break; }
    { pc = 0x107fb; break; }
  case 0x10cd7:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x10cda:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] >= memoryAGet16(ds, 0xa7e2))
        { pc = 0x10ce6; break; }
    { pc = 0x107f6; break; }
  case 0x10ce6:
    r16[ax] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0x10d05; break; }
  case 0x10cee:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(ds, r16[bx] + 2) == 0x0002)
        { pc = 0x10cfc; break; }
    memoryASet16(ds, r16[bx] + 2, 0x0000);
  case 0x10cfc:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx] + 72);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x10d05:
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x10cee; break; }
    r16[si] = 0;
    { pc = 0x10d49; break; }
  case 0x10d0f:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 52027))
        { pc = 0x10d48; break; }
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 6240);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    { pc = 0x10d3b; break; }
  case 0x10d27:
    r16[ax] = 0x2c27;
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[bx], memoryAGet(es, r16[bx]) | r8[dl]);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x10d3b:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 6314);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x10d27; break; }
  case 0x10d48:
    r16[si]++;
  case 0x10d49:
    if (r16[si] < 0x0025)
        { pc = 0x10d0f; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_10e05() // 107c:0645 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x107c);
    push(cs); cs = 0x08aa; yield* sub_ab32(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x107c);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x0072, memoryAGet(es, 0x0072) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x006f, memoryAGet(es, 0x006f) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0070, memoryAGet(es, 0x0070) | r8[dl]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x0072;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa533, memoryAGet16(ds, 0xa533) + 0x0030);
    r16[ax] = 0x1bb5;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    if (memoryAGet16(ds, 0xa7ed) != 0x0007)
        { pc = 0x10e97; break; }
    push(memoryAGet16(ds, 0x19d4));
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    { pc = 0x10ea3; break; }
  case 0x10e97:
    push(memoryAGet16(ds, 0x19d6));
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
  case 0x10ea3:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x002d;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x107c);
    sp += 0x0002;
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006f;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x000c);
    if (memoryAGet16(ds, 0xa7ed) != 0x0007)
        { pc = 0x10f14; break; }
    push(memoryAGet16(ds, 0x19d8));
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    { pc = 0x10f20; break; }
  case 0x10f14:
    push(memoryAGet16(ds, 0x19da));
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
  case 0x10f20:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0070;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x107c);
    push(memoryAGet16(ds, 0x7a68));
    push(cs); cs = 0x08aa; yield* sub_ab67(); assert(cs == 0x107c);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d4);
    memoryASet16(ds, r16[bx] + 64, 0xffff);
    memoryASet16(ds, r16[bx] + 62, 0xffff);
    memoryASet16(ds, r16[bx] + 66, 0xffff);
    memoryASet16(ds, r16[bx] + 68, 0xffff);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_10f99() // 107c:07d9 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x00c8;
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x107c);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x006e, memoryAGet(es, 0x006e) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x006f, memoryAGet(es, 0x006f) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0071, memoryAGet(es, 0x0071) | r8[dl]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x107c);
    r16[ax] = 0xffff;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_ab67(); assert(cs == 0x107c);
    sp += 0x0002;
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006e;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa533, memoryAGet16(ds, 0xa533) + 0x0030);
    r16[ax] = 0x2145;
    push(r16[ax]);
    r16[ax] = 0x0000;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x107c);
    sp += 0x0008;
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006e;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa533, memoryAGet16(ds, 0xa533) + 0x0030);
    r16[ax] = 0x214b;
    push(r16[ax]);
    r16[ax] = 0x0000;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x107c);
    sp += 0x0008;
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006f;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x000c);
    r16[ax] = 0x2150;
    push(r16[ax]);
    r16[ax] = 0x0000;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x107c);
    sp += 0x0008;
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006e;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa533, memoryAGet16(ds, 0xa533) + 0x0030);
    r16[ax] = 0x2152;
    push(r16[ax]);
    r16[ax] = 0x0000;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_5683(); assert(cs == 0x107c);
    sp += 0x0008;
    r16[ax] = r16[bp] - 200;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006f;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    r16[ax] = 0x0071;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7de);
    r16[ax] += 0x0018;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0028;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    push(cs); cs = 0x08aa; yield* sub_ab32(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x107c);
    push(memoryAGet16(ds, 0x7a68));
    push(cs); cs = 0x08aa; yield* sub_ab67(); assert(cs == 0x107c);
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11226() // 107c:0a66 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x107c);
    r16[ax] = 0x006f;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_15a47(); assert(cs == 0x107c);
    sp += 0x0002;
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006f;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x000c);
    r16[ax] = 0x1bcd;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x107c);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11365() // 107c:0ba5 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x107c);
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x107c);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x006e, memoryAGet(es, 0x006e) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x006f, memoryAGet(es, 0x006f) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0070, memoryAGet(es, 0x0070) | r8[dl]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x107c);
    sp += 0x0002;
    r16[ax] = 0xffff;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_ab67(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f8c9(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006e;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x0006);
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa533, memoryAGet16(ds, 0xa533) + 0x0030);
    if (memoryAGet16(ds, 0xa7ed) != 0x0011)
        { pc = 0x113f2; break; }
    r16[ax] = 0x1d43;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    { pc = 0x113fe; break; }
  case 0x113f2:
    r16[ax] = 0x1da7;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
  case 0x113fe:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[ax] = 0x006f;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    r16[ax] -= 0x0030;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    memoryASet16(ds, 0xa531, memoryAGet16(ds, 0xa531) - 0x0030);
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + 0x000c);
    r16[bx] = memoryAGet16(ds, 0x7a5e);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 6620));
    push(cs); cs = 0x1b1e; yield* sub_1c09d(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    r16[ax] = 0x0070;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7de));
    r16[ax] = memoryAGet16(ds, 0xa533);
    r16[ax] += memoryAGet16(ds, 0xa531);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x107c);
    sp += 0x0006;
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x107c);
    r16[ax] = 0x001e;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x107c);
    sp += 0x0002;
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x107c);
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x107c);
    memoryASet16(ds, 0x7a5e, memoryAGet16(ds, 0x7a5e) + 1);
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x107c);
    push(cs); cs = 0x08aa; yield* sub_ab32(); assert(cs == 0x107c);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_114be() // 107c:0cfe +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    memoryASet16(ds, r16[bx], 0x0002);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    memoryASet16(ds, r16[bx] + 6, 0x0002);
    r16[ax] = 0x19ec;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x107c);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11950() // 1195:0000 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 28, 0x1dfc);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1197e() // 1195:002e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    r16[ax] = memoryAGet16(ds, r16[bx] + 48);
    if (r16[ax] < memoryAGet16(ds, r16[di] + 10))
        { pc = 0x119b9; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 10);
    r16[ax] += 0x0005;
    if (memoryAGet16(ds, r16[bx] + 44) > r16[ax])
        { pc = 0x119b9; break; }
    r16[ax] = memoryAGet16(ds, r16[bx] + 46);
    if (r16[ax] < memoryAGet16(ds, r16[di] + 12))
        { pc = 0x119b9; break; }
    r16[ax] = memoryAGet16(ds, r16[di] + 12);
    r16[ax] += 0x0004;
    if (memoryAGet16(ds, r16[bx] + 50) > r16[ax])
        { pc = 0x119b9; break; }
    memoryASet16(ds, r16[di] + 28, 0x1ece);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x119b9:
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[di] + 12));
    push(memoryAGet16(ds, r16[di] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_119db() // 1195:008b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x000e;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11a03() // 1195:00b3 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11a2b() // 1195:00db +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x001a;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11a53() // 1195:0103 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11a7b() // 1195:012b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x000e;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11aa3() // 1195:0153 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11acb() // 1195:017b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[si] + 12));
    push(memoryAGet16(ds, r16[si] + 10));
    r16[ax] = 0x003c;
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19188(); assert(cs == 0x1195);
    sp += 0x000c;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11af3() // 1195:01a3 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    memoryASet16(ds, r16[bx], 0x0004);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, 0xffff);
    memoryASet16(ds, r16[bx] + 62, r16[si]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 8096);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 30, r16[ax]);
    memoryASet16(ds, r16[bx] + 64, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 64);
    r16[ax] += 0x0002;
    memoryASet16(ds, r16[bx] + 66, r16[ax]);
    r16[ax] = 0x1eec;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11b5c() // 1195:020c +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    memoryASet16(ds, r16[bx], 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x1f46;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11b9e() // 1195:024e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[si] + 30, memoryAGet16(ds, r16[si] + 30) + 1);
    r16[ax] = memoryAGet16(ds, r16[si] + 30);
    if (r16[ax] != memoryAGet16(ds, r16[si] + 66))
        { pc = 0x11bb6; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 64);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
  case 0x11bb6:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_11bb9() // 1195:0269 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0006);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfe8f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x11c03; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x11c0c; break; }
  case 0x11c03:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x11c0c:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x1fb8;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_11c4e() // 1195:02fe +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0005);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff8f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x11c98; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x11ca1; break; }
  case 0x11c98:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x11ca1:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x2012;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_11cb9() // 1195:0369 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0010))
        { pc = 0x11cf3; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    if (r16[ax] >= memoryAGet16(ds, r16[bx] + 10))
        { pc = 0x11cdd; break; }
    memoryASet16(ds, r16[si] + 14, 0x0001);
    { pc = 0x11ce2; break; }
  case 0x11cdd:
    memoryASet16(ds, r16[si] + 14, 0xffff);
  case 0x11ce2:
    memoryASet16(ds, r16[si] + 28, 0x204e);
    r16[ax] = 0x002e;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x1195);
    sp += 0x0002;
  case 0x11cf3:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_11cf6() // 1195:03a6 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ds, r16[bx] + 2, 0x0003);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 40);
    r16[ax] -= 0x0080;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x20a8;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11d3a() // 1195:03ea +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    if (memoryAGet16(ds, r16[di]) != 0x0002)
        { pc = 0x11d53; break; }
    push(cs); cs = 0x0d6d; yield* sub_eab9(); assert(cs == 0x1195);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x11d53:
    if (memoryAGet16(ds, r16[di]) != 0x0003)
        { pc = 0x11d91; break; }
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x11d72; break; }
    r16[ax] = 0x206c;
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_d325(); assert(cs == 0x1195);
    sp += 0x0006;
    { pc = 0x11d80; break; }
  case 0x11d72:
    r16[ax] = 0x208a;
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_d325(); assert(cs == 0x1195);
    sp += 0x0006;
  case 0x11d80:
    memoryASet16(ds, r16[si] + 24, 0xffe8);
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, r16[si] + 22, r16[ax]);
  case 0x11d91:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_11d95() // 1195:0445 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0009);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff0f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x20e4;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11ead() // 1195:055d +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0008);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff8f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x2120;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_11f09() // 1195:05b9 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x001b);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff0f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 10);
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    if (r16[ax] >= memoryAGet16(ds, r16[bx] + 10))
        { pc = 0x11f56; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x11f5f; break; }
  case 0x11f56:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x11f5f:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x21b6;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_123de() // 1195:0a8e +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x000a);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfe8f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x12428; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x12431; break; }
  case 0x12428:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x12431:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x2378;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_124b7() // 1195:0b67 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x1195);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x000b);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x124fe; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x12507; break; }
  case 0x124fe:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x12507:
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x1195);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x1251c; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    { pc = 0x12525; break; }
  case 0x1251c:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0xffff);
  case 0x12525:
    r16[ax] = 0x2486;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d8));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x1195);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_126d6() // 126d:0006 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x000c);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0x008f;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x12720; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x12729; break; }
  case 0x12720:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x12729:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x26de;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_12892() // 126d:01c2 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x000d);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x0001;
    memoryASet16(ds, r16[bx] + 14, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, r16[ax]);
    r16[ax] = 0x28a0;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_12a6b() // 126d:039b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x000e);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfe00;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x12ab5; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x12abe; break; }
  case 0x12ab5:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x12abe:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    memoryASet16(ds, r16[bx] + 64, 0x0008);
    r16[ax] = 0x2af8;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_12d82() // 126d:06b2 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0010);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x12dc9; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x12dd2; break; }
  case 0x12dc9:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x12dd2:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x2e9a;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    r16[bx] = 0x0020;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 26, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_12dfc() // 126d:072c +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0011);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] += 0xfffd;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x2ef4;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_12fba() // 126d:08ea +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x000f);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff80;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    r16[ax] = 0x2f12;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_13008() // 126d:0938 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    if (memoryAGet16(ds, r16[di]) != 0x0003)
        { pc = 0x1304a; break; }
    memoryASet16(ds, r16[si] + 62, 0x0000);
    memoryASet16(ds, r16[si] + 64, 0x0000);
    memoryASet16(ds, r16[si] + 66, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si]);
    memoryASet16(ds, r16[si] + 68, r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x0f7c; yield* sub_10503(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[ax] = 0x2f8a;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x126d);
    sp += 0x0004;
    memoryASet16(ds, r16[si], 0x0021);
    memoryASet16(ds, r16[si] + 24, memoryAGet16(ds, r16[si] + 24) - 0x0020);
  case 0x1304a:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1304e() // 126d:097e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    if (!memoryAGet16(ds, r16[di] + 58))
        { pc = 0x13064; break; }
    memoryASet16(ds, r16[di] + 24, 0x0000);
  case 0x13064:
    if (memoryAGet16(ds, r16[di] + 54))
        { pc = 0x1306d; break; }
    { pc = 0x13159; break; }
  case 0x1306d:
    memoryASet16(ds, r16[di] + 64, memoryAGet16(ds, r16[di] + 64) + 1);
    push(r16[di]);
    push(cs); cs = 0x0bc9; yield* sub_cef0(); assert(cs == 0x126d);
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x13089; break; }
    r16[ax] = 0x0010;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x126d);
    sp += 0x0002;
  case 0x13089:
    memoryASet16(ds, r16[di] + 24, 0xffce);
    if (memoryAGet16(ds, 0x7a6e) != r16[di])
        { pc = 0x130d7; break; }
    memoryASet16(ds, r16[di] + 64, 0x0000);
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    r16[ax] = memoryAGet16(ds, r16[di] + 34);
    r16[ax] -= 0x0040;
    if (memoryAGet16(ds, r16[bx] + 34) >= r16[ax])
        { pc = 0x130af; break; }
    memoryASet16(ds, r16[di] + 14, 0xffff);
    { pc = 0x130ca; break; }
  case 0x130af:
    r16[bx] = memoryAGet16(ds, 0xa7d6);
    r16[ax] = memoryAGet16(ds, r16[di] + 38);
    r16[ax] += 0x0040;
    if (memoryAGet16(ds, r16[bx] + 38) <= r16[ax])
        { pc = 0x130c5; break; }
    memoryASet16(ds, r16[di] + 14, 0x0001);
    { pc = 0x130ca; break; }
  case 0x130c5:
    memoryASet16(ds, r16[di] + 14, 0x0000);
  case 0x130ca:
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    memoryASet16(ds, r16[di] + 22, r16[ax]);
    { pc = 0x13137; break; }
  case 0x130d7:
    if (signed16(memoryAGet16(ds, r16[di] + 64)) <= signed16(0x0002))
        { pc = 0x130e3; break; }
    if (memoryAGet16(ds, r16[di] + 62))
        { pc = 0x130ff; break; }
  case 0x130e3:
    memoryASet16(ds, r16[di] + 62, 0x0001);
    r16[ax] = 0;
    memoryASet16(ds, r16[di] + 22, r16[ax]);
    memoryASet16(ds, r16[di] + 14, r16[ax]);
    r16[ax] = 0x2f12;
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x126d);
    sp += 0x0004;
    { pc = 0x13137; break; }
  case 0x130ff:
    memoryASet16(ds, r16[di] + 62, 0x0000);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) >= signed16(0x0064))
        { pc = 0x13119; break; }
    memoryASet16(ds, r16[di] + 14, 0xffff);
    { pc = 0x1312c; break; }
  case 0x13119:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) >= signed16(0x00c8))
        { pc = 0x13127; break; }
    memoryASet16(ds, r16[di] + 14, 0x0001);
    { pc = 0x1312c; break; }
  case 0x13127:
    memoryASet16(ds, r16[di] + 14, 0x0000);
  case 0x1312c:
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    memoryASet16(ds, r16[di] + 22, r16[ax]);
  case 0x13137:
    if (!memoryAGet16(ds, r16[di] + 14))
        { pc = 0x1314c; break; }
    r16[ax] = 0x2f4e;
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x126d);
    sp += 0x0004;
    { pc = 0x13159; break; }
  case 0x1314c:
    r16[ax] = 0x2f12;
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x0bc9; yield* sub_ce9a(); assert(cs == 0x126d);
    sp += 0x0004;
  case 0x13159:
    if (memoryAGet16(ds, r16[di] + 56))
        { pc = 0x13165; break; }
    if (!memoryAGet16(ds, r16[di] + 60))
        { pc = 0x13175; break; }
  case 0x13165:
    r16[ax] = memoryAGet16(ds, r16[di] + 14);
    r16[ax] = -r16[ax];
    memoryASet16(ds, r16[di] + 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di] + 22);
    r16[ax] = -r16[ax];
    memoryASet16(ds, r16[di] + 22, r16[ax]);
  case 0x13175:
    push(memoryAGet16(ds, r16[di] + 32));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[di] + 30));
    push(memoryAGet16(ds, r16[di] + 12));
    push(memoryAGet16(ds, r16[di] + 10));
    r16[ax] = r16[di];
    r16[ax] += 0x0046;
    push(r16[ax]);
    push(cs); cs = 0x1841; yield* sub_19a51(); assert(cs == 0x126d);
    sp += 0x000c;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_13198() // 126d:0ac8 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0012);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x131df; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x131e8; break; }
  case 0x131df:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x131e8:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x126d);
    r16[bx] = 0x0040;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 8, r16[ax]);
    r16[ax] = 0x3002;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1337b() // 126d:0cab +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0014);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    if (r16[bx] > 0x0003)
        { pc = 0x133fa; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x133bc; break; }
        case 2: { pc = 0x133cc; break; }
        case 4: { pc = 0x133dc; break; }
        case 6: { pc = 0x133ec; break; }
        default:
            stop("ind 126d:0ce7");
    }
    break;
  case 0x133bc:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0xffff);
    { pc = 0x133fa; break; }
  case 0x133cc:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
    { pc = 0x133fa; break; }
  case 0x133dc:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    { pc = 0x133fa; break; }
  case 0x133ec:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
  case 0x133fa:
    r16[ax] = 0x316a;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d8));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_137cc() // 126d:10fc +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x126d);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0014);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 62, r16[ax]);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    r16[ax] = 0x3188;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x126d);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1381f() // 126d:114f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0x7a6e) != r16[si])
        { pc = 0x1384f; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xc921, r16[ax]);
    memoryASet16(ds, r16[si] + 24, 0x0000);
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[ax] += memoryAGet16(ds, 0xc921);
    r16[ax] -= memoryAGet16(ds, r16[si] + 62);
    if (r16[ax] < 0x0080)
        { pc = 0x1384f; break; }
    memoryASet16(ds, r16[si] + 28, 0x31a6);
  case 0x1384f:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_138fe() // 138f:000e +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x001a);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfe80;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x138f);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x13948; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x13951; break; }
  case 0x13948:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x13951:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x31e2;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_13d37() // 138f:0447 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0013);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0003);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff30;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x0001;
    memoryASet16(ds, r16[bx] + 14, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, r16[ax]);
    r16[ax] = 0x343a;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_13f80() // 138f:0690 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0015);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0002);
    memoryASet16(ds, r16[bx] + 6, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xfd00;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1ef1a(); assert(cs == 0x138f);
    if (r16s[ax] >= signed16(0x0080))
        { pc = 0x13fcf; break; }
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    { pc = 0x13fd8; break; }
  case 0x13fcf:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
  case 0x13fd8:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x35c0;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_14397() // 138f:0aa7 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0016);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 6, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x0001;
    memoryASet16(ds, r16[bx] + 14, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, r16[ax]);
    r16[ax] = 0x3764;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1444f() // 138f:0b5f +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0017);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 62, r16[ax]);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x0001;
    memoryASet16(ds, r16[bx] + 14, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, r16[ax]);
    r16[ax] = 0x37a0;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_145dc() // 138f:0cec +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0020);
    memoryASet16(ds, r16[bx] + 2, 0x0002);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    if (r16[bx] > 0x0003)
        { pc = 0x1465b; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x1461d; break; }
        case 2: { pc = 0x1462d; break; }
        case 4: { pc = 0x1463d; break; }
        case 6: { pc = 0x1464d; break; }
        default:
            stop("ind 138f:0d28");
    }
    break;
  case 0x1461d:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0xffff);
    { pc = 0x1465b; break; }
  case 0x1462d:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0001);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
    { pc = 0x1465b; break; }
  case 0x1463d:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0x0000);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    { pc = 0x1465b; break; }
  case 0x1464d:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 14, 0xffff);
    memoryASet16(ds, r16[bx] + 16, 0x0000);
  case 0x1465b:
    r16[ax] = 0x3890;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d8));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_146a5() // 138f:0db5 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0018);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    memoryASet16(ds, r16[bx] + 32, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff00;
    memoryASet16(ds, r16[bx] + 62, r16[ax]);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 16, 0x0001);
    r16[ax] = 0x38ea;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1472b() // 138f:0e3b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x0001);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    memoryASet16(ds, r16[bx] + 6, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    memoryASet16(ds, r16[bx] + 62, r16[si]);
    r16[bx] = r16[si];
    if (r16[bx] > 0x0003)
        { pc = 0x147bb; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x14772; break; }
        case 2: { pc = 0x14786; break; }
        case 4: { pc = 0x1479a; break; }
        case 6: { pc = 0x147aa; break; }
        default:
            stop("ind 138f:0e7d");
    }
    break;
  case 0x14772:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 12, memoryAGet16(ds, r16[bx] + 12) - 0x0030);
    memoryASet16(ds, r16[bx] + 10, memoryAGet16(ds, r16[bx] + 10) + 0x0090);
    memoryASet16(ds, r16[bx] + 30, 0x017c);
    { pc = 0x147bb; break; }
  case 0x14786:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 10, memoryAGet16(ds, r16[bx] + 10) + 0x0080);
    memoryASet16(ds, r16[bx] + 12, memoryAGet16(ds, r16[bx] + 12) + 0x0050);
    memoryASet16(ds, r16[bx] + 30, 0x0180);
    { pc = 0x147bb; break; }
  case 0x1479a:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 10, memoryAGet16(ds, r16[bx] + 10) + 0x0090);
    memoryASet16(ds, r16[bx] + 30, 0x017e);
    { pc = 0x147bb; break; }
  case 0x147aa:
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx] + 12, memoryAGet16(ds, r16[bx] + 12) + 0x0070);
    memoryASet16(ds, r16[bx] + 10, memoryAGet16(ds, r16[bx] + 10) - 0x0030);
    memoryASet16(ds, r16[bx] + 30, 0x0182);
  case 0x147bb:
    r16[ax] = 0x3962;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7d8));
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_148c1() // 138f:0fd1 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x08aa; yield* sub_a8b1(); assert(cs == 0x138f);
    sp += 0x0002;
    r16[bx] = memoryAGet16(ds, 0xa7d8);
    memoryASet16(ds, r16[bx], 0x001e);
    memoryASet16(ds, r16[bx] + 2, 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= r8[cl];
    r16[ax] += 0xff00;
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    r16[ax] = 0x3a34;
    push(r16[ax]);
    push(r16[bx]);
    push(cs); cs = 0x0bc9; yield* sub_ce1c(); assert(cs == 0x138f);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1493f() // 1493:000f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[cx];
    r16[ax] <<= 1;
    r16[ax] += r16[cx];
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    es = memoryAGet16(ds, 0xcba9);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) & 0xffff);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) & 0x00ff);
    if (memoryAGet16(ss, r16[bp] - 2) != 0x00ff)
        { pc = 0x14985; break; }
    if (memoryAGet16(ss, r16[bp] - 4) != 0xffff)
        { pc = 0x14985; break; }
    memoryASet16(ss, r16[bp] - 2, 0xffff);
    memoryASet16(ss, r16[bp] - 4, 0xffff);
  case 0x14985:
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_149c4() // 1493:0094 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    push(r16[dx]);
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0xcb95;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = r16[si];
    r16[ax]++;
    push(r16[ax]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    push(r16[ax]);
    push(r16[dx]);
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    r16[bx] = pop();
    r16[cx] = pop();
    flags.carry = r16[cx] < r16[ax];
    r16[cx] -= r16[ax];
    r16[bx] -= (r16[dx] + flags.carry);
    flags.carry = r16[cx] + 0xfffc >= 0x10000;
    r16[cx] += 0xfffc;
    r16[bx] += (0xffff + flags.carry);
    memoryASet16(ds, 0xcb9b, r16[bx]);
    memoryASet16(ds, 0xcb99, r16[cx]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_14a24() // 1493:00f4 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (signed16(memoryAGet16(ss, r16[bp] + 14)) < signed16(0x0000))
        { pc = 0x14a41; break; }
    if (signed16(memoryAGet16(ss, r16[bp] + 14)) > signed16(0x0000))
        { pc = 0x14a35; break; }
    if (memoryAGet16(ss, r16[bp] + 12) <= 0xffff)
        { pc = 0x14a41; break; }
  case 0x14a35:
    r16[ax] = 0x3a66;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x14a41:
    push(ds);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    ds = memoryAGet16(ss, r16[bp] + 10);
    r8[ah] = 0x3f;
    interrupt(0x21);
    ds = pop();
    if (!flags.carry)
        { pc = 0x14a5c; break; }
    memoryASet16(ds, 0x0094, r16[ax]);
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x14a5c:
    if (r16[ax] == memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x14a6b; break; }
    memoryASet16(ds, 0x0094, 0x000b);
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x14a6b:
    r16[ax] = 0x0001;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_14a70() // 1493:0140 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (signed16(memoryAGet16(ss, r16[bp] + 14)) < signed16(0x0000))
        { pc = 0x14a8d; break; }
    if (signed16(memoryAGet16(ss, r16[bp] + 14)) > signed16(0x0000))
        { pc = 0x14a81; break; }
    if (memoryAGet16(ss, r16[bp] + 12) <= 0xffff)
        { pc = 0x14a8d; break; }
  case 0x14a81:
    r16[ax] = 0x3a90;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x14a8d:
    push(ds);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[cx] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    ds = memoryAGet16(ss, r16[bp] + 10);
    r8[ah] = 0x40;
    interrupt(0x21);
    ds = pop();
    if (!flags.carry)
        { pc = 0x14aa8; break; }
    memoryASet16(ds, 0x0094, r16[ax]);
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x14aa8:
    if (r16[ax] == memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x14ab7; break; }
    memoryASet16(ds, 0x0094, 0x0008);
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x14ab7:
    r16[ax] = 0x0001;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_14bb3() // 1493:0283 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = r16[di];
    r16[cx] = 0;
    { pc = 0x14bf2; break; }
  case 0x14bc1:
    if (memoryAGet16(ds, r16[si]) < 0x0100)
        { pc = 0x14bd6; break; }
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] -= 0x0100;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = r16[di];
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[si], r16[dx]);
  case 0x14bd6:
    if (memoryAGet16(ds, r16[si] + 2) < 0x0100)
        { pc = 0x14bee; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] -= 0x0100;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = r16[di];
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[si] + 2, r16[dx]);
  case 0x14bee:
    r16[si] += 0x0004;
    r16[cx]++;
  case 0x14bf2:
    if (r16s[cx] < signed16(0x00ff))
        { pc = 0x14bc1; break; }
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_14bfc() // 1493:02cc +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 18);
    r16[ax] += 0x03f8;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[cx] = 0;
    r16[bx] = 0x0001;
    r16[dx] = ss;
    r16[ax] = r16[bp] + 6;
    push(cs); cs = 0x01ed; yield* sub_50a5(); assert(cs == 0x1493);
    r16[cx] = 0;
    r16[bx] = 0x0001;
    r16[dx] = ss;
    r16[ax] = r16[bp] + 6;
    push(cs); cs = 0x01ed; yield* sub_50e9(); assert(cs == 0x1493);
    r16[cx] = 0;
    r16[bx] = 0x0001;
    r16[dx] = ss;
    r16[ax] = r16[bp] + 10;
    push(cs); cs = 0x01ed; yield* sub_50a5(); assert(cs == 0x1493);
    r16[cx] = 0;
    r16[bx] = 0x0001;
    r16[dx] = ss;
    r16[ax] = r16[bp] + 10;
    push(cs); cs = 0x01ed; yield* sub_50e9(); assert(cs == 0x1493);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] + 16)) > signed16(0x0000))
        { pc = 0x14cbb; break; }
    if (signed16(memoryAGet16(ss, r16[bp] + 16)) < signed16(0x0000))
        { pc = 0x14c75; break; }
    if (memoryAGet16(ss, r16[bp] + 14) >= 0xfff0)
        { pc = 0x14cbb; break; }
  case 0x14c75:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[di] = memoryAGet16(ss, r16[bp] - 8);
    es = memoryAGet16(ss, r16[bp] - 6);
    ds = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r8[ch] = memoryAGet(ds, r16[si]);
    r16[si]++;
    r8[cl] = 0x01;
  case 0x14c8c:
    if (r8[ch] & r8[cl])
        { pc = 0x14c99; break; }
    r16[dx] = memoryAGet16(ss, r16[bx]);
    flags.carry = !!(r8[cl] & 0x80);
    r8[cl] <<= 1;
    if (flags.carry)
        { pc = 0x14ca1; break; }
    if (!flags.carry)
        { pc = 0x14ca6; break; }
  case 0x14c99:
    r16[dx] = memoryAGet16(ss, r16[bx] + 2);
    flags.carry = !!(r8[cl] & 0x80);
    r8[cl] <<= 1;
    if (!flags.carry)
        { pc = 0x14ca6; break; }
  case 0x14ca1:
    r8[ch] = memoryAGet(ds, r16[si]);
    r16[si]++;
    r8[cl] = 0x01;
  case 0x14ca6:
    if (!r8[dh])
        { pc = 0x14cae; break; }
    r16[bx] = r16[dx];
    { pc = 0x14c8c; break; }
  case 0x14cae:
    memoryASet(es, r16[di], r8[dl]);
    r16[di]++;
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    if (r16[di] != r16[ax])
        { pc = 0x14c8c; break; }
    { pc = 0x14d1b; break; }
  case 0x14cbb:
    flags.carry = memoryAGet16(ss, r16[bp] + 14) < 0x0001;
    memoryASet16(ss, r16[bp] + 14, memoryAGet16(ss, r16[bp] + 14) - 0x0001);
    memoryASet16(ss, r16[bp] + 16, memoryAGet16(ss, r16[bp] + 16) - (0x0000 + flags.carry));
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r8[cl] = 0x01;
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[di] = memoryAGet16(ss, r16[bp] - 8);
    es = memoryAGet16(ss, r16[bp] - 6);
    ds = memoryAGet16(ss, r16[bp] - 2);
    r8[al] = lodsb_DSSI();
  case 0x14cd5:
    if (r8[al] & r8[cl])
        { pc = 0x14cde; break; }
    r16[dx] = memoryAGet16(ss, r16[bx]);
    { pc = 0x14ce2; break; }
  case 0x14cde:
    r16[dx] = memoryAGet16(ss, r16[bx] + 2);
  case 0x14ce2:
    flags.carry = !!(r8[cl] & 0x80);
    r8[cl] <<= 1;
    if (!flags.carry)
        { pc = 0x14cf5; break; }
    r8[al] = lodsb_DSSI();
    if (r16[si] < 0x0010)
        { pc = 0x14cf3; break; }
    r16[cx] = ds;
    r16[cx]++;
    ds = r16[cx];
    r16[si] = 0;
  case 0x14cf3:
    r8[cl] = 0x01;
  case 0x14cf5:
    if (!r8[dh])
        { pc = 0x14cfd; break; }
    r16[bx] = r16[dx];
    { pc = 0x14cd5; break; }
  case 0x14cfd:
    memoryASet(es, r16[di], r8[dl]);
    r16[di]++;
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    if (r16[di] < 0x0010)
        { pc = 0x14d10; break; }
    r16[dx] = es;
    r16[dx]++;
    es = r16[dx];
    r16[di] = 0;
  case 0x14d10:
    flags.carry = memoryAGet16(ss, r16[bp] + 14) < 0x0001;
    memoryASet16(ss, r16[bp] + 14, memoryAGet16(ss, r16[bp] + 14) - 0x0001);
    if (!flags.carry)
        { pc = 0x14cd5; break; }
    memoryASet16(ss, r16[bp] + 16, memoryAGet16(ss, r16[bp] + 16) - 1);
    if (signed16(memoryAGet16(ss, r16[bp] + 16)) >= 0)
        { pc = 0x14cd5; break; }
  case 0x14d1b:
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_14d25() // 1493:03f5 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0012;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 14);
    r16[bx] = 0x0002;
    r16[ax] = r16[si];
    r16[dx] = 0;
    div16(r16[bx]);
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    { pc = 0x14e58; break; }
  case 0x14d56:
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[di] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 0x0002);
    r16[ax] = r16[di];
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 2) != 0x00a7)
        { pc = 0x14ddc; break; }
    r16[ax] = r16[di];
    r16[ax] &= 0x00ff;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x14d99; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0x00;
    r16[di] |= r16[ax];
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 1);
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[di]);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
    r16[si]--;
    { pc = 0x14e58; break; }
  case 0x14d99:
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 1);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 16);
    r16[bx] = memoryAGet16(ss, r16[bp] - 18);
    r16[bx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, r16[bx]);
    r16[si] -= memoryAGet16(ss, r16[bp] - 4);
    { pc = 0x14dd0; break; }
  case 0x14dbc:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10); es = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 10, memoryAGet16(ss, r16[bp] - 10) + 0x0002);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
  case 0x14dd0:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 1);
    if (r16[ax])
        { pc = 0x14dbc; break; }
    { pc = 0x14e58; break; }
  case 0x14ddc:
    if (memoryAGet16(ss, r16[bp] - 2) != 0x00a8)
        { pc = 0x14e4d; break; }
    r16[ax] = r16[di];
    r16[ax] &= 0x00ff;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x14e0b; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0x00;
    r16[di] |= r16[ax];
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 1);
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[di]);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
    r16[si]--;
    { pc = 0x14e58; break; }
  case 0x14e0b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 14); es = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 0x0002);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] += r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, r16[bx]);
    r16[si] -= memoryAGet16(ss, r16[bp] - 4);
    { pc = 0x14e41; break; }
  case 0x14e2d:
    r16[bx] = memoryAGet16(ss, r16[bp] - 10); es = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 10, memoryAGet16(ss, r16[bp] - 10) + 0x0002);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
  case 0x14e41:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 1);
    if (r16[ax])
        { pc = 0x14e2d; break; }
    { pc = 0x14e58; break; }
  case 0x14e4d:
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[di]);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
    r16[si]--;
  case 0x14e58:
    if (!r16[si])
        { pc = 0x14e5f; break; }
    { pc = 0x14d56; break; }
  case 0x14e5f:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_14fb5() // 1493:0685 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0010;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    r16[dx] = 0x0002;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ss, r16[bp] + 16));
    push(memoryAGet16(ss, r16[bp] + 14));
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x1493);
    flags.carry = !!(r16[ax] & 0x8000);
    r16[ax] <<= 1;
    r16[dx] = rcl16(r16[dx], 0x0001);
    push(r16[ax]);
    push(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_512d(); assert(cs == 0x1493);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 18);
    r16[si] = memoryAGet16(ss, r16[bp] - 8);
    r16[di] = memoryAGet16(ss, r16[bp] - 12);
    es = memoryAGet16(ss, r16[bp] - 10);
    ds = memoryAGet16(ss, r16[bp] - 6);
  case 0x1501b:
    r16[ax] = lodsw_DSSI();
    if (r16[ax] == r16[bx])
        { pc = 0x15023; break; }
    stosw_ESDI(r16[ax]);
    { pc = 0x15029; break; }
  case 0x15023:
    r16[ax] = lodsw_DSSI();
    r16[cx] = r16[ax];
    r16[ax] = lodsw_DSSI();
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
  case 0x15029:
    if (r16[si] < 0x0010)
        { pc = 0x15042; break; }
    r16[ax] = r16[si];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[dx] = ds;
    r16[dx] += r16[ax];
    ds = r16[dx];
    r16[si] &= 0x000f;
  case 0x15042:
    if (r16[di] < 0x0010)
        { pc = 0x1505b; break; }
    r16[ax] = r16[di];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[dx] = es;
    r16[dx] += r16[ax];
    es = r16[dx];
    r16[di] &= 0x000f;
  case 0x1505b:
    if (r16[di] != memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x1501b; break; }
    r16[ax] = es;
    if (r16[ax] < memoryAGet16(ss, r16[bp] - 14))
        { pc = 0x1501b; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15071() // 1493:0741 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    memoryASet16(ds, 0xcba5, 0x6a86);
    memoryASet16(ds, 0xcba9, 0x22f5);
    push(memoryAGet16(ds, 0xcba5));
    push(cs);
    yield* sub_14bb3();
    sp += 0x0002;
    r16[ax] = 0x8001;
    push(r16[ax]);
    r16[ax] = 0x3abb;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x1493);
    sp += 0x0004;
    memoryASet16(ds, 0xcba1, r16[ax]);
    if (memoryAGet16(ds, 0xcba1) != 0xffff)
        { pc = 0x150b4; break; }
    r16[ax] = 0x3ac8;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x150b4:
    r16[ax] = 0;
    r16[dx] = 0x01cc;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xa552;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_149c4();
    sp += 0x0002;
    push(memoryAGet16(ds, 0xcb9b));
    push(memoryAGet16(ds, 0xcb99));
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    push(memoryAGet16(ds, 0xcb9b));
    push(memoryAGet16(ds, 0xcb99));
    push(memoryAGet16(ss, r16[bp] - 2));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    push(memoryAGet16(ds, 0xcba5));
    r16[ax] = 0;
    r16[dx] = 0x01cc;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xa552));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[ax]);
    push(cs);
    yield* sub_14bfc();
    sp += 0x000e;
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
    r16[ax] = 0;
    r16[dx] = 0x000c;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xcbab;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    yield* sub_149c4();
    sp += 0x0002;
    push(memoryAGet16(ds, 0xcb9b));
    push(memoryAGet16(ds, 0xcb99));
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    push(memoryAGet16(ds, 0xcb9b));
    push(memoryAGet16(ds, 0xcb99));
    push(memoryAGet16(ss, r16[bp] - 2));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    push(memoryAGet16(ds, 0xcba5));
    r16[ax] = 0;
    r16[dx] = 0x01cc;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xcbab));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[ax]);
    push(cs);
    yield* sub_14bfc();
    sp += 0x000e;
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
    r16[ax] = 0;
    r16[dx] = 0x1bea;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xc755;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs);
    yield* sub_149c4();
    sp += 0x0002;
    push(memoryAGet16(ds, 0xcb9b));
    push(memoryAGet16(ds, 0xcb99));
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    push(memoryAGet16(ds, 0xcb9b));
    push(memoryAGet16(ds, 0xcb99));
    push(memoryAGet16(ss, r16[bp] - 2));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    push(memoryAGet16(ds, 0xcba5));
    r16[ax] = 0;
    r16[dx] = 0x1bea;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xc755));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[ax]);
    push(cs);
    yield* sub_14bfc();
    sp += 0x000e;
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1520d() // 1493:08dd +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xc8a1, 0x2670);
    r16[ax] = 0x0100;
    push(r16[ax]);
    r16[ax] = 0x8001;
    push(r16[ax]);
    r16[ax] = 0x3ae2;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x1493);
    sp += 0x0006;
    memoryASet16(ds, 0xcb9f, r16[ax]);
    if (r16[ax] != 0xffff)
        { pc = 0x1523e; break; }
    r16[ax] = 0x3aef;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x1523e:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15240() // 1493:0910 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xcba3, 0x6686);
    push(memoryAGet16(ds, 0xcba3));
    push(cs);
    yield* sub_14bb3();
    sp += 0x0002;
    memoryASet16(ds, 0xcba7, 0x22cc);
    r16[ax] = 0x0100;
    push(r16[ax]);
    r16[ax] = 0x8001;
    push(r16[ax]);
    r16[ax] = 0x3b08;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x1493);
    sp += 0x0006;
    memoryASet16(ds, 0xcb9d, r16[ax]);
    if (r16[ax] != 0xffff)
        { pc = 0x15282; break; }
    r16[ax] = 0x3b12;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15282:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15284() // 1493:0954 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_1520d();
    push(cs);
    yield* sub_15071();
    push(cs);
    yield* sub_15240();
    memoryASet16(ds, 0xa7ed, 0xffff);
    memoryASet(ds, 0x7aec, 0x01);
    memoryASet(ds, 0xa7e6, 0x00);
    memoryASet16(ds, 0x7aea, 0x1493);
    memoryASet16(ds, 0x7ae8, 0x1650);
    memoryASet16(ds, 0x7ae6, 0x1493);
    memoryASet16(ds, 0x7ae4, 0x17bf);
    memoryASet16(ds, 0x7ae2, 0x1493);
    memoryASet16(ds, 0x7ae0, 0x1812);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_152c9() // 1493:0999 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(memoryAGet16(ds, 0xcb9f));
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1493);
    sp += 0x0002;
    push(memoryAGet16(ds, 0xcba1));
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1493);
    sp += 0x0002;
    push(memoryAGet16(ds, 0xcb9d));
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1493);
    sp += 0x0002;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_152f2() // 1493:09c2 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0012;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 51037))
        { pc = 0x1531f; break; }
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1531f:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xcba7);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 6);
    r16[dx] = memoryAGet16(es, r16[bx] + 4);
    flags.carry = r16[dx] < memoryAGet16(ss, r16[bp] - 4);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2) + flags.carry;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ds, 0xcb9d));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x15399; break; }
    if (memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x15374; break; }
    if (memoryAGet16(ss, r16[bp] - 8) > 0x1000)
        { pc = 0x15399; break; }
  case 0x15374:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ds, 0xcbed));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcb9d));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0xcbed);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
    { pc = 0x153e7; break; }
  case 0x15399:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    if (!memoryAGet16(ds, 0xa7ef))
        { pc = 0x153b5; break; }
    { pc = 0x15453; break; }
  case 0x153b5:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x1493);
    sp += 0x0004;
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 14));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcb9d));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
  case 0x153e7:
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0004);
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[dx]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    if (memoryAGet16(ds, 0xa7ef))
        { pc = 0x15438; break; }
    push(memoryAGet16(ds, 0xcba3));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(memoryAGet16(ss, r16[bp] - 12));
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 51037));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(memoryAGet16(ss, r16[bp] - 18));
    push(cs);
    yield* sub_14bfc();
    sp += 0x000e;
  case 0x15438:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0000))
        { pc = 0x15453; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x15447; break; }
    if (memoryAGet16(ss, r16[bp] - 8) <= 0x1000)
        { pc = 0x15453; break; }
  case 0x15447:
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15453:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15458() // 1493:0b28 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xcb93);
    if (!r16[ax])
        { pc = 0x154a3; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x15472; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x15476; break; }
    { pc = 0x15479; break; }
    // gap 2 bytes
  case 0x15472:
    r16[si] = 0;
    { pc = 0x15479; break; }
  case 0x15476:
    r16[si] = 0x0034;
  case 0x15479:
    r16[di] = 0;
    { pc = 0x1549e; break; }
  case 0x1547d:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 51037))
        { pc = 0x1549c; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x1549c:
    r16[di]++;
    r16[si]++;
  case 0x1549e:
    if (r16[di] < 0x0034)
        { pc = 0x1547d; break; }
  case 0x154a3:
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (!r16[ax])
        { pc = 0x154da; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x154ba; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x154be; break; }
    { pc = 0x154c1; break; }
    // gap 4 bytes
  case 0x154ba:
    r16[si] = 0;
    { pc = 0x154c1; break; }
  case 0x154be:
    r16[si] = 0x0034;
  case 0x154c1:
    r16[di] = 0;
    { pc = 0x154cf; break; }
  case 0x154c5:
    push(r16[si]);
    push(cs);
    yield* sub_152f2();
    sp += 0x0002;
    r16[di]++;
    r16[si]++;
  case 0x154cf:
    if (r16[di] < 0x0034)
        { pc = 0x154c5; break; }
    r16[ax] = memoryAGet16(ds, 0xc635);
    memoryASet16(ds, 0xcb93, r16[ax]);
  case 0x154da:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_154de() // 1493:0bae +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ds, 0x7476, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, 0x7474, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    ds = r16[ax];
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    r16[bp] = memoryAGet16(ss, r16[bp] + 16);
    r16[bp] <<= 1;
    r16[bp] = memoryAGet16(ss, r16[bp] + 24530);
    r16[dx] = memoryAGet16(ss, 0x7476);
  case 0x15508:
    memoryASet(ds, r16[di], 0xff);
    r16[cx] = memoryAGet16(ss, 0x7474);
  case 0x15510:
    r8[al] = memoryAGet(ds, r16[bx]);
    r8[al] = ~r8[al];
    r16[bx]++;
    r8[ah] = 0;
    r16[ax] <<= 1;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + r16[si]);
    r16[ax] = ~r16[ax];
    memoryASet(ds, r16[di], memoryAGet(ds, r16[di]) & r8[al]);
    r16[di]++;
    memoryASet(ds, r16[di], r8[ah]);
    if (--r16[cx])
        { pc = 0x15510; break; }
    r16[di]++;
    r16[dx]--;
    if (r16[dx])
        { pc = 0x15508; break; }
    r16[dx] = memoryAGet16(ss, 0x7476);
    r16[dx] <<= 1;
    r16[dx] <<= 1;
  case 0x15533:
    memoryASet(ds, r16[di], 0x00);
    r16[cx] = memoryAGet16(ss, 0x7474);
  case 0x1553b:
    r8[al] = memoryAGet(ds, r16[bx]);
    r16[bx]++;
    r8[ah] = 0;
    r16[ax] <<= 1;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + r16[si]);
    memoryASet(ds, r16[di], memoryAGet(ds, r16[di]) | r8[al]);
    r16[di]++;
    memoryASet(ds, r16[di], r8[ah]);
    if (--r16[cx])
        { pc = 0x1553b; break; }
    r16[di]++;
    r16[dx]--;
    if (r16[dx])
        { pc = 0x15533; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15559() // 1493:0c29 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0016;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[ax] += 0xf748;
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    imul16(memoryAGet16(es, r16[bx]));
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    r16[dx]++;
    imul16(r16[dx]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 10, 0x0018);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] = 0x0005;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 10);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = 0x0005;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = 0x0005;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = 0x0005;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    r16[bx] = memoryAGet16(es, r16[bx] + 16);
    r16[bx] <<= 1;
    r16[ax] = r16[bp] - 10;
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 16));
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    if (!memoryAGet16(ds, 0xa7ef))
        { pc = 0x15606; break; }
    { pc = 0x1582f; break; }
  case 0x15606:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    push(memoryAGet16(ds, 0xcba5));
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] = 0x0005;
    imul16(r16[dx]);
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0018;
    push(memoryAGet16(ss, r16[bp] - 22));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(cs);
    yield* sub_14bfc();
    sp += 0x000e;
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    if (r16[ax] == 0x0001)
        { pc = 0x15652; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1568a; break; }
    if (r16[ax] != 0x0004)
        { pc = 0x1564f; break; }
    { pc = 0x15722; break; }
  case 0x1564f:
    { pc = 0x15823; break; }
  case 0x15652:
    r16[di] = 0;
    { pc = 0x1567f; break; }
  case 0x15656:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(es, r16[bx] + 8, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    memoryASet16(es, r16[bx] + 16, r16[ax]);
    r16[di]++;
  case 0x1567f:
    if (r16s[di] < signed16(0x0004))
        { pc = 0x15656; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1568a:
    r16[di] = 0;
    { pc = 0x156b7; break; }
  case 0x1568e:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(es, r16[bx] + 8, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    memoryASet16(es, r16[bx] + 16, r16[ax]);
    r16[di]++;
  case 0x156b7:
    if (r16s[di] < signed16(0x0002))
        { pc = 0x1568e; break; }
    r16[di] = 0x0002;
    { pc = 0x156ec; break; }
  case 0x156c1:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, r16[bx] + 8, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax]++;
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    memoryASet16(es, r16[bx] + 16, r16[ax]);
    r16[di]++;
  case 0x156ec:
    if (r16s[di] < signed16(0x0004))
        { pc = 0x156c1; break; }
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = memoryAGet16(ss, r16[bp] - 22);
    push(memoryAGet16(es, 0x0004));
    push(memoryAGet16(es, 0x0000));
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(cs);
    yield* sub_154de();
    sp += 0x000c;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x15722:
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(es, 0x0000, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(es, 0x0008, r16[ax]);
    push(es);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx]);
    es = pop();
    memoryASet16(es, 0x0010, r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(es, 0x0002, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, 0x000a, r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax]++;
    es = memoryAGet16(ss, r16[bp] - 22);
    memoryASet16(es, 0x0012, r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = memoryAGet16(ss, r16[bp] - 22);
    push(memoryAGet16(es, 0x0002));
    push(memoryAGet16(es, 0x0000));
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(cs);
    yield* sub_154de();
    sp += 0x000c;
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, 0x0004, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, 0x000c, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax]++;
    es = memoryAGet16(ss, r16[bp] - 22);
    memoryASet16(es, 0x0014, r16[ax]);
    r16[ax] = 0x0004;
    push(r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = memoryAGet16(ss, r16[bp] - 22);
    push(memoryAGet16(es, 0x0004));
    push(memoryAGet16(es, 0x0000));
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(cs);
    yield* sub_154de();
    sp += 0x000c;
    es = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(es, 0x0006, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, 0x000e, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax]++;
    es = memoryAGet16(ss, r16[bp] - 22);
    memoryASet16(es, 0x0016, r16[ax]);
    r16[ax] = 0x0006;
    push(r16[ax]);
    es = memoryAGet16(ss, r16[bp] - 18);
    push(memoryAGet16(es, r16[bx] + 2));
    push(memoryAGet16(es, r16[bx]));
    es = memoryAGet16(ss, r16[bp] - 22);
    push(memoryAGet16(es, 0x0006));
    push(memoryAGet16(es, 0x0000));
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(cs);
    yield* sub_154de();
    sp += 0x000c;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x15823:
    r16[ax] = 0x3b28;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x1582f:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15835() // 1493:0f05 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16s[si] < signed16(0x0209))
        { pc = 0x158b3; break; }
    if (r16s[si] >= signed16(0x127f))
        { pc = 0x158b3; break; }
    if (r16s[si] >= signed16(0x020a))
        { pc = 0x1585d; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x0d80);
    { pc = 0x158c7; break; }
  case 0x1585d:
    if (r16s[si] >= signed16(0x020b))
        { pc = 0x1586f; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x05a0);
    { pc = 0x158c7; break; }
  case 0x1586f:
    if (r16s[si] >= signed16(0x071b))
        { pc = 0x15881; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x0080);
    { pc = 0x158c7; break; }
  case 0x15881:
    if (r16s[si] >= signed16(0x127f))
        { pc = 0x15893; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x00a0);
    { pc = 0x158c7; break; }
  case 0x15893:
    if (r16s[si] >= signed16(0x127f))
        { pc = 0x158a5; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x0200);
    { pc = 0x158c7; break; }
  case 0x158a5:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, 0x0280);
    { pc = 0x158c7; break; }
    // gap 2 bytes
  case 0x158b3:
    r16[bx] = memoryAGet16(ss, r16[bp] + 8); es = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + 0x0004);
  case 0x158c7:
    if (r16s[si] < signed16(0x007c))
        { pc = 0x158e5; break; }
    if (r16s[si] >= signed16(0x0209))
        { pc = 0x158e5; break; }
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[si]);
    push(cs);
    yield* sub_15559();
    sp += 0x0006;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x158e5:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    if (memoryAGet16(ds, 0xa7ef))
        { pc = 0x15924; break; }
    push(memoryAGet16(ds, 0xcba5));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(cs);
    yield* sub_14bfc();
    sp += 0x000e;
  case 0x15924:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15a47() // 1493:1117 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000e;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[di], memoryAGet(es, r16[di]) | r8[dl]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x15a84; break; }
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x15a84:
    push(r16[di]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) > signed16(0x0000))
        { pc = 0x15aa6; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) >= signed16(0x0000))
        { pc = 0x15a9d; break; }
    { pc = 0x15b8a; break; }
  case 0x15a9d:
    if (memoryAGet16(ss, r16[bp] - 4) >= 0x0000)
        { pc = 0x15aa6; break; }
    { pc = 0x15b8a; break; }
  case 0x15aa6:
    r16[ax] = r16[di];
    r16[ax]++;
    r16[si] = r16[ax];
    { pc = 0x15aae; break; }
  case 0x15aad:
    r16[si]++;
  case 0x15aae:
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    if (r16[dx] != 0xffff)
        { pc = 0x15ac0; break; }
    if (r16[ax] == 0xffff)
        { pc = 0x15aad; break; }
  case 0x15ac0:
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    flags.carry = r16[ax] < memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 2) + flags.carry;
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ds, 0xcba1));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x15b1d; break; }
    if (memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x15af8; break; }
    if (memoryAGet16(ss, r16[bp] - 8) > 0x1000)
        { pc = 0x15b1d; break; }
  case 0x15af8:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ds, 0xcbed));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0xcbed);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
    { pc = 0x15b61; break; }
  case 0x15b1d:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x1493);
    sp += 0x0004;
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 10));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
  case 0x15b61:
    push(memoryAGet16(ss, r16[bp] - 12));
    push(memoryAGet16(ss, r16[bp] - 14));
    push(r16[di]);
    push(cs);
    yield* sub_15835();
    sp += 0x0006;
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0000))
        { pc = 0x15b8a; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x15b7e; break; }
    if (memoryAGet16(ss, r16[bp] - 8) <= 0x1000)
        { pc = 0x15b8a; break; }
  case 0x15b7e:
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15b8a:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15b90() // 1493:1260 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0018;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    if (signed16(memoryAGet16(ds, 0xa7ed)) <= signed16(0xffff))
        { pc = 0x15bc4; break; }
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 52145))
        { pc = 0x15bc4; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7ed);
    r16[ax] <<= 1;
    r16[ax] += 0xcbb1;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x15bc4:
    r16[si] = 0;
    { pc = 0x15be4; break; }
  case 0x15bc8:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 42983))
        { pc = 0x15be3; break; }
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xa7e7;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15be3:
    r16[si]++;
  case 0x15be4:
    if (r16s[si] < signed16(0x0003))
        { pc = 0x15bc8; break; }
    memoryASet16(ds, 0xa7ed, r16[di]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 52145))
        { pc = 0x15c73; break; }
    es = memoryAGet16(ds, 0xc8a1);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[dx] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) > signed16(0x0000))
        { pc = 0x15c2a; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x0000))
        { pc = 0x15c1e; break; }
    if (memoryAGet16(ss, r16[bp] - 4) >= 0x0000)
        { pc = 0x15c2a; break; }
  case 0x15c1e:
    r16[ax] = 0x3b4c;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15c2a:
    r16[ax] = 0;
    r16[dx] = 0x0026;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0xcbb1;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ds, 0xcb9f));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    r16[ax] = 0;
    r16[dx] = 0x0026;
    push(r16[ax]);
    push(r16[dx]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 52145));
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcb9f));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    { pc = 0x15c86; break; }
  case 0x15c73:
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0xcbb1;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x15c86:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    es = memoryAGet16(ds, r16[bx] + 52145);
    r16[ax] = memoryAGet16(es, 0x0012);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    imul16(memoryAGet16(es, 0x0014));
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[si] = 0;
    { pc = 0x15def; break; }
  case 0x15ca5:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    es = memoryAGet16(ds, r16[bx] + 52145);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 6);
    if (r16[ax])
        { pc = 0x15cdc; break; }
    { pc = 0x15dee; break; }
  case 0x15cdc:
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xa7e7;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 14));
    push(memoryAGet16(ss, r16[bp] - 10));
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ds, 0xcb9f));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x15d28; break; }
    if (memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x15d1b; break; }
    if (memoryAGet16(ss, r16[bp] - 8) > 0x1000)
        { pc = 0x15d28; break; }
  case 0x15d1b:
    r16[ax] = memoryAGet16(ds, 0xcbed);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
    { pc = 0x15d55; break; }
  case 0x15d28:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x1493);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
  case 0x15d55:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 16));
    push(memoryAGet16(ss, r16[bp] - 18));
    push(memoryAGet16(ds, 0xcb9f));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[bx] = memoryAGet16(ss, r16[bp] - 18); es = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 22, 0x0000);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0002);
    push(memoryAGet16(ss, r16[bp] - 22));
    push(r16[ax]);
    r16[ax] = r16[bp] - 20;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 20));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 16));
    push(memoryAGet16(ss, r16[bp] - 18));
    push(cs);
    yield* sub_14d25();
    sp += 0x000a;
    es = memoryAGet16(ds, 0xc8a1);
    push(memoryAGet16(es, 0x0000));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 14));
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    push(memoryAGet16(ds, r16[bx]));
    push(r16[ax]);
    r16[ax] += 0x0002;
    push(memoryAGet16(ss, r16[bp] - 20));
    push(r16[ax]);
    push(cs);
    yield* sub_14fb5();
    sp += 0x000e;
    r16[ax] = r16[bp] - 20;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) < signed16(0x0000))
        { pc = 0x15dee; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x15de2; break; }
    if (memoryAGet16(ss, r16[bp] - 8) <= 0x1000)
        { pc = 0x15dee; break; }
  case 0x15de2:
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15dee:
    r16[si]++;
  case 0x15def:
    if (r16s[si] >= signed16(0x0003))
        { pc = 0x15df7; break; }
    { pc = 0x15ca5; break; }
  case 0x15df7:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15dfd() // 1493:14cd +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (memoryAGet(ds, 0xa7e6) != 0x07)
        { pc = 0x15e13; break; }
    r16[ax] = 0x3b7b;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15e13:
    memoryASet(ds, 0x7aec, memoryAGet(ds, 0x7aec) << 1);
    memoryASet(ds, 0xa7e6, memoryAGet(ds, 0xa7e6) + 1);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15e1d() // 1493:14ed +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = memoryAGet(ds, 0xa7e6);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x15e35; break; }
    r16[ax] = 0x3b98;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15e35:
    memoryASet(ds, 0x7aec, memoryAGet(ds, 0x7aec) >> 1);
    memoryASet(ds, 0xa7e6, memoryAGet(ds, 0xa7e6) - 1);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_1617b();
    sp += 0x0002;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15e4a() // 1493:151a +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0;
    { pc = 0x15e63; break; }
  case 0x15e52:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    r8[dl] = ~r8[dl];
    es = r16[ax];
    memoryASet(es, r16[si], memoryAGet(es, r16[si]) & r8[dl]);
    r16[si]++;
  case 0x15e63:
    if (r16s[si] < signed16(0x128f))
        { pc = 0x15e52; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15e92() // 1493:1562 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0;
    { pc = 0x15eba; break; }
  case 0x15e9a:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x15eb9; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x15eb9:
    r16[si]++;
  case 0x15eba:
    if (r16s[si] < signed16(0x128f))
        { pc = 0x15e9a; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15ec3() // 1493:1593 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(cs);
    yield* sub_15e4a();
    push(cs); cs = 0x1ef3; yield* sub_1f85b(); assert(cs == 0x1493);
    r16[si] = 0;
    { pc = 0x15ef4; break; }
  case 0x15ed4:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 52145))
        { pc = 0x15ef3; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xcbb1;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x15ef3:
    r16[si]++;
  case 0x15ef4:
    if (r16s[si] < signed16(0x001e))
        { pc = 0x15ed4; break; }
    r16[si] = 0;
    { pc = 0x15f19; break; }
  case 0x15efd:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 42983))
        { pc = 0x15f18; break; }
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xa7e7;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x15f18:
    r16[si]++;
  case 0x15f19:
    if (r16s[si] < signed16(0x0003))
        { pc = 0x15efd; break; }
    r16[si] = 0;
    { pc = 0x15f42; break; }
  case 0x15f22:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 51037))
        { pc = 0x15f41; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x15f41:
    r16[si]++;
  case 0x15f42:
    if (r16s[si] < signed16(0x00a2))
        { pc = 0x15f22; break; }
    push(cs);
    yield* sub_15e92();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_15f4f() // 1493:161f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0;
    { pc = 0x15f77; break; }
  case 0x15f57:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x15f76; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x15f76:
    r16[si]++;
  case 0x15f77:
    if (r16s[si] < signed16(0x128f))
        { pc = 0x15f57; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1617b() // 1493:184b +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0026;
    push(r16[si]);
    push(r16[di]);
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x1618e; break; }
    r16[ax] = 0x0001;
    { pc = 0x16190; break; }
  case 0x1618e:
    r16[ax] = 0;
  case 0x16190:
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    r16[di] = 0;
    { pc = 0x161f3; break; }
  case 0x1619c:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    if (!(memoryAGet(es, r16[di]) & r8[dl]))
        { pc = 0x161d3; break; }
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x161cc; break; }
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
    { pc = 0x161f2; break; }
  case 0x161cc:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    { pc = 0x161f2; break; }
    // gap 2 bytes
  case 0x161d3:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x161f2; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1493);
    sp += 0x0004;
  case 0x161f2:
    r16[di]++;
  case 0x161f3:
    if (r16s[di] < signed16(0x128f))
        { pc = 0x1619c; break; }
    if (memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x16202; break; }
    { pc = 0x164d5; break; }
  case 0x16202:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1621e; break; }
    r16[ax] = memoryAGet16(ds, 0x7ae8);
    r16[ax] |= memoryAGet16(ds, 0x7aea);
    if (!r16[ax])
        { pc = 0x1621e; break; }
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] + 6));
    switch (memoryAGet32(ds, 0x7ae8))
    {
        case 0x07b1066d: push(cs); cs = 0x07b1; yield* sub_817d(); assert(cs == 0x1493); break;
        default:
            stop("ind 1493:18e7");
    }
    sp += 0x0004;
  case 0x1621e:
    r16[ax] = 0;
    r16[dx] = 0;
    memoryASet16(ss, r16[bp] - 30, r16[ax]);
    memoryASet16(ss, r16[bp] - 32, r16[dx]);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, r16[dx]);
    r16[di] = 0;
    { pc = 0x164b9; break; }
  case 0x16233:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    if (memoryAGet(es, r16[di]) & r8[dl])
        { pc = 0x16246; break; }
    { pc = 0x164b8; break; }
  case 0x16246:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x16254; break; }
    { pc = 0x164b8; break; }
  case 0x16254:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x16267; break; }
    r16[ax] = memoryAGet16(ds, 0x7ae4);
    r16[ax] |= memoryAGet16(ds, 0x7ae6);
    if (!r16[ax])
        { pc = 0x16267; break; }
    switch (memoryAGet32(ds, 0x7ae4))
    {
        case 0x07b107ea: push(cs); cs = 0x07b1; yield* sub_82fa(); assert(cs == 0x1493); break;
        default:
            stop("ind 1493:1933");
    }
  case 0x16267:
    push(r16[di]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0000))
        { pc = 0x16289; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) >= signed16(0x0000))
        { pc = 0x16280; break; }
    { pc = 0x164b8; break; }
  case 0x16280:
    if (memoryAGet16(ss, r16[bp] - 8) >= 0x0000)
        { pc = 0x16289; break; }
    { pc = 0x164b8; break; }
  case 0x16289:
    r16[ax] = r16[di];
    r16[ax]++;
    r16[si] = r16[ax];
    { pc = 0x16291; break; }
  case 0x16290:
    r16[si]++;
  case 0x16291:
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    if (r16[dx] != 0xffff)
        { pc = 0x162a3; break; }
    if (r16[ax] == 0xffff)
        { pc = 0x16290; break; }
  case 0x162a3:
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    flags.carry = r16[ax] < memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 8);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 6) + flags.carry;
    memoryASet16(ss, r16[bp] - 22, r16[dx]);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    flags.carry = r16[dx] + memoryAGet16(ss, r16[bp] - 24) >= 0x10000;
    r16[dx] += memoryAGet16(ss, r16[bp] - 24);
    r16[ax] += memoryAGet16(ss, r16[bp] - 22) + flags.carry;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    if (signed16(memoryAGet16(ss, r16[bp] - 22)) <= signed16(0x0000))
        { pc = 0x162d2; break; }
    { pc = 0x16425; break; }
  case 0x162d2:
    if (memoryAGet16(ss, r16[bp] - 22))
        { pc = 0x162de; break; }
    if (memoryAGet16(ss, r16[bp] - 24) <= 0x1000)
        { pc = 0x162de; break; }
    { pc = 0x16425; break; }
  case 0x162de:
    r16[ax] = memoryAGet16(ss, r16[bp] - 26);
    r16[dx] = memoryAGet16(ss, r16[bp] - 28);
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 6)))
        { pc = 0x162ec; break; }
    { pc = 0x163c0; break; }
  case 0x162ec:
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x162f6; break; }
    if (r16[dx] <= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x162f6; break; }
    { pc = 0x163c0; break; }
  case 0x162f6:
    r16[ax] = memoryAGet16(ss, r16[bp] - 30);
    r16[dx] = memoryAGet16(ss, r16[bp] - 32);
    if (r16s[ax] >= signed16(memoryAGet16(ss, r16[bp] - 10)))
        { pc = 0x16304; break; }
    { pc = 0x163c0; break; }
  case 0x16304:
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x1630e; break; }
    if (r16[dx] >= memoryAGet16(ss, r16[bp] - 12))
        { pc = 0x1630e; break; }
    { pc = 0x163c0; break; }
  case 0x1630e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 28);
    r16[dx] = memoryAGet16(ds, 0xcbed);
    memoryASet16(ss, r16[bp] - 34, r16[dx]);
    memoryASet16(ss, r16[bp] - 36, r16[ax]);
    { pc = 0x16488; break; }
    // gap 5 bytes
  case 0x16326:
    r16[si]++;
  case 0x16327:
    if (r16s[si] >= signed16(0x128f))
        { pc = 0x16348; break; }
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    if (!(memoryAGet(es, r16[si]) & r8[dl]))
        { pc = 0x16326; break; }
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 31469))
        { pc = 0x16326; break; }
  case 0x16348:
    if (r16[si] == 0x128f)
        { pc = 0x163c0; break; }
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 14, r16[dx]);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
  case 0x1635c:
    r16[si]++;
    r16[ax] = r16[si];
    push(r16[ax]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    if (r16[dx] != 0xffff)
        { pc = 0x16371; break; }
    if (r16[ax] == 0xffff)
        { pc = 0x1635c; break; }
  case 0x16371:
    push(r16[si]);
    push(cs);
    yield* sub_1493f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 18, r16[dx]);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = memoryAGet16(ss, r16[bp] - 16);
    flags.carry = r16[dx] < memoryAGet16(ss, r16[bp] - 12);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 12);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10) + flags.carry;
    if (r16s[ax] > 0)
        { pc = 0x163bd; break; }
    if (r16[ax])
        { pc = 0x16397; break; }
    if (r16[dx] > 0x0400)
        { pc = 0x163bd; break; }
  case 0x16397:
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[dx] = memoryAGet16(ss, r16[bp] - 20);
    flags.carry = r16[dx] < memoryAGet16(ss, r16[bp] - 8);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6) + flags.carry;
    if (r16s[ax] > 0)
        { pc = 0x163bd; break; }
    if (r16[ax])
        { pc = 0x163af; break; }
    if (r16[dx] > 0x1000)
        { pc = 0x163bd; break; }
  case 0x163af:
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[dx] = memoryAGet16(ss, r16[bp] - 20);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    { pc = 0x163c0; break; }
  case 0x163bd:
    r16[si] = 0x128f;
  case 0x163c0:
    if (r16s[si] >= signed16(0x128f))
        { pc = 0x163c9; break; }
    { pc = 0x16327; break; }
  case 0x163c9:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ds, 0xcba1));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    flags.carry = r16[dx] < memoryAGet16(ss, r16[bp] - 8);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6) + flags.carry;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xcbed));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    memoryASet16(ss, r16[bp] - 28, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 30, r16[ax]);
    memoryASet16(ss, r16[bp] - 32, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcbed);
    memoryASet16(ss, r16[bp] - 34, r16[ax]);
    memoryASet16(ss, r16[bp] - 36, 0x0000);
    { pc = 0x16488; break; }
    // gap 2 bytes
  case 0x16425:
    push(memoryAGet16(ss, r16[bp] - 22));
    push(memoryAGet16(ss, r16[bp] - 24));
    r16[ax] = r16[bp] - 38;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x1493);
    sp += 0x0006;
    if (!memoryAGet16(ds, 0xa7ef))
        { pc = 0x16441; break; }
    { pc = 0x164d5; break; }
  case 0x16441:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[bp] - 38;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x1493);
    sp += 0x0004;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ds, 0xcba1));
    push(cs); cs = 0x01ed; yield* sub_3a99(); assert(cs == 0x1493);
    sp += 0x0008;
    push(memoryAGet16(ss, r16[bp] - 22));
    push(memoryAGet16(ss, r16[bp] - 24));
    push(memoryAGet16(ss, r16[bp] - 38));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcba1));
    push(cs);
    yield* sub_14a24();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ss, r16[bp] - 38);
    memoryASet16(ss, r16[bp] - 34, r16[ax]);
    memoryASet16(ss, r16[bp] - 36, 0x0000);
  case 0x16488:
    push(memoryAGet16(ss, r16[bp] - 34));
    push(memoryAGet16(ss, r16[bp] - 36));
    push(r16[di]);
    push(cs);
    yield* sub_15835();
    sp += 0x0006;
    if (memoryAGet16(ds, 0xa7ef))
        { pc = 0x164d5; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 22)) < signed16(0x0000))
        { pc = 0x164b8; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 22)) > signed16(0x0000))
        { pc = 0x164ac; break; }
    if (memoryAGet16(ss, r16[bp] - 24) <= 0x1000)
        { pc = 0x164b8; break; }
  case 0x164ac:
    r16[ax] = r16[bp] - 38;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1493);
    sp += 0x0002;
  case 0x164b8:
    r16[di]++;
  case 0x164b9:
    if (r16s[di] >= signed16(0x128f))
        { pc = 0x164c2; break; }
    { pc = 0x16233; break; }
  case 0x164c2:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x164d5; break; }
    r16[ax] = memoryAGet16(ds, 0x7ae0);
    r16[ax] |= memoryAGet16(ds, 0x7ae2);
    if (!r16[ax])
        { pc = 0x164d5; break; }
    switch (memoryAGet32(ds, 0x7ae0))
    {
        case 0x07b1085b: push(cs); cs = 0x07b1; yield* sub_836b(); assert(cs == 0x1493); break;
        default:
            stop("ind 1493:1ba1");
    }
  case 0x164d5:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_166a0() // 164d:01d0 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = 0x000b;
    interrupt(0x33);
    memoryASet16(ds, r16[si], r16[cx]);
    memoryASet16(ds, r16[di], r16[dx]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_166b8() // 164d:01e8 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    r16[ax] = 0x0003;
    interrupt(0x33);
    memoryASet16(ss, r16[bp] - 2, r16[bx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_166cd() // 164d:01fd +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x166e7; break; }
    r8[al] = 0x02;
    { pc = 0x166e9; break; }
  case 0x166e7:
    r8[al] = 0x00;
  case 0x166e9:
    memoryASet(ss, r16[bp] - 3, r8[al]);
    r8[al] = 0x01;
    r8[cl] = memoryAGet(ss, r16[bp] - 3);
    r8[al] <<= r8[cl];
    memoryASet(ss, r16[bp] - 1, r8[al]);
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x16700; break; }
    r8[al] = 0x03;
    { pc = 0x16702; break; }
  case 0x16700:
    r8[al] = 0x01;
  case 0x16702:
    memoryASet(ss, r16[bp] - 4, r8[al]);
    r8[al] = 0x01;
    r8[cl] = memoryAGet(ss, r16[bp] - 4);
    r8[al] <<= r8[cl];
    memoryASet(ss, r16[bp] - 2, r8[al]);
    push(flagAsReg());
    push(r16[si]);
    push(r16[di]);
    flags.interrupts = 0;
    r16[dx] = 0x0201;
    r8[al] = in8(r16[dx]);
    out8(r16[dx], r8[al]);
    r8[ah] = memoryAGet(ss, r16[bp] - 1);
    r8[ch] = memoryAGet(ss, r16[bp] - 2);
    r16[si] = 0;
    r16[di] = 0;
    r8[bh] = 0;
    push(r16[bp]);
    r16[bp] = 0x1388;
  case 0x16728:
    r8[al] = in8(r16[dx]);
    r16[bp]--;
    if (!r16[bp])
        { pc = 0x1673e; break; }
    r8[bl] = r8[al];
    r8[bl] &= r8[ah];
    r16[si] += r16[bx];
    r8[cl] = r8[bl];
    r8[bl] = r8[al];
    r8[bl] &= r8[ch];
    r16[di] += r16[bx];
    r8[cl] += r8[bl];
    if (r8[cl])
        { pc = 0x16728; break; }
  case 0x1673e:
    r16[bp] = pop();
    r8[cl] = memoryAGet(ss, r16[bp] - 3);
    r16[si] >>= r8[cl];
    r8[cl] = memoryAGet(ss, r16[bp] - 4);
    r16[di] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 6, r16[si]);
    memoryASet16(ss, r16[bp] - 8, r16[di]);
    r16[di] = pop();
    r16[si] = pop();
    flagsFromReg(pop());
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16768() // 164d:0298 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_166cd();
    sp += 0x0006;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    r16[ax] += 0xcc15;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ds, r16[si] + 4);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x167ce; break; }
    r16[ax] = memoryAGet16(ds, r16[si]);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x167a4; break; }
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x167a4:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= memoryAGet16(ds, r16[si] + 4);
    r16[ax] = -r16[ax];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    imul16(memoryAGet16(ds, r16[si] + 16));
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r8[cl] = 0x08;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) >> r8[cl]);
    if (memoryAGet16(ss, r16[bp] - 2) <= 0x007f)
        { pc = 0x167c5; break; }
    r16[ax] = 0xff81;
    { pc = 0x167ca; break; }
  case 0x167c5:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = -r16[ax];
  case 0x167ca:
    memoryASet16(ds, r16[di], r16[ax]);
    { pc = 0x1680b; break; }
  case 0x167ce:
    r16[ax] = memoryAGet16(ds, r16[si] + 8);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x16807; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x167e1; break; }
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x167e1:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= memoryAGet16(ds, r16[si] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    imul16(memoryAGet16(ds, r16[si] + 20));
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r8[cl] = 0x08;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) >> r8[cl]);
    if (memoryAGet16(ss, r16[bp] - 2) <= 0x007f)
        { pc = 0x16800; break; }
    r16[ax] = 0x007f;
    { pc = 0x16803; break; }
  case 0x16800:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
  case 0x16803:
    memoryASet16(ds, r16[di], r16[ax]);
    { pc = 0x1680b; break; }
  case 0x16807:
    memoryASet16(ds, r16[di], 0x0000);
  case 0x1680b:
    r16[ax] = memoryAGet16(ds, r16[si] + 6);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1684b; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1681e; break; }
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0x1681e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ds, r16[si] + 6);
    r16[ax] = -r16[ax];
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    imul16(memoryAGet16(ds, r16[si] + 18));
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r8[cl] = 0x08;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) >> r8[cl]);
    if (memoryAGet16(ss, r16[bp] - 4) <= 0x007f)
        { pc = 0x1683f; break; }
    r16[ax] = 0xff81;
    { pc = 0x16844; break; }
  case 0x1683f:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = -r16[ax];
  case 0x16844:
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[bx], r16[ax]);
    { pc = 0x1688e; break; }
  case 0x1684b:
    r16[ax] = memoryAGet16(ds, r16[si] + 10);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x16887; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1685e; break; }
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0x1685e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ds, r16[si] + 10);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    imul16(memoryAGet16(ds, r16[si] + 22));
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r8[cl] = 0x08;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) >> r8[cl]);
    if (memoryAGet16(ss, r16[bp] - 4) <= 0x007f)
        { pc = 0x1687d; break; }
    r16[ax] = 0x007f;
    { pc = 0x16880; break; }
  case 0x1687d:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
  case 0x16880:
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[bx], r16[ax]);
    { pc = 0x1688e; break; }
  case 0x16887:
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[bx], 0x0000);
  case 0x1688e:
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x168fb; break; }
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    flags.carry = r16[dx] < memoryAGet16(ds, 0x747a);
    r16[dx] -= memoryAGet16(ds, 0x747a);
    r16[ax] -= memoryAGet16(ds, 0x747c) + flags.carry;
    flags.carry = r16[ax] & 1;
    r16[ax] >>= 1;
    r16[dx] = rcr16(r16[dx], 0x0001);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 6);
    if (!r16[ax])
        { pc = 0x168fb; break; }
    if (memoryAGet16(ss, r16[bp] - 6) < 0x0000)
        { pc = 0x168cd; break; }
    if (memoryAGet16(ss, r16[bp] - 6) > 0x0000)
        { pc = 0x168c3; break; }
    if (memoryAGet16(ss, r16[bp] - 8) <= 0x0008)
        { pc = 0x168cd; break; }
  case 0x168c3:
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    memoryASet16(ss, r16[bp] - 8, 0x0008);
  case 0x168cd:
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    push(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x164d);
    memoryASet16(ds, r16[di], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    push(r16[ax]);
    push(r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[cx] = pop();
    r16[bx] = pop();
    push(cs); cs = 0x01ed; yield* sub_4f5a(); assert(cs == 0x164d);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[bx], r16[ax]);
  case 0x168fb:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0x747c, r16[ax]);
    memoryASet16(ds, 0x747a, r16[dx]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1690f() // 164d:043f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x0201;
    r8[al] = in8(r16[dx]);
    r8[ah] = 0x00;
    r16[bx] = r16[ax];
    if (r16[si] != 0x0002)
        { pc = 0x1692f; break; }
    r8[cl] = 0x04;
    r16[bx] >>= r8[cl];
    r16[bx] &= 0x000f;
    r16[bx] ^= 0x000f;
    { pc = 0x16943; break; }
  case 0x1692f:
    if (!r16[si])
        { pc = 0x16937; break; }
    r8[al] = 0x06;
    { pc = 0x16939; break; }
  case 0x16937:
    r8[al] = 0x04;
  case 0x16939:
    r8[cl] = r8[al];
    r16[bx] >>= r8[cl];
    r16[bx] &= 0x0003;
    r16[bx] ^= 0x0003;
  case 0x16943:
    r16[ax] = r16[bx];
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16948() // 164d:0478 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
  case 0x16953:
    push(r16[si]);
    push(cs);
    yield* sub_1690f();
    sp += 0x0002;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    flags.carry = r16[dx] + 0x0002 >= 0x10000;
    r16[dx] += 0x0002;
    r16[ax] += (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x16970:
    yield* sync(); /*
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    if (r16[ax] < memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x16970; break; }
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x16983; break; }
    if (r16[dx] <= memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x16970; break; }
  case 0x16983:
    */
    push(r16[si]);
    push(cs);
    yield* sub_1690f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (r16[di] != memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x16953; break; }
    r16[ax] = r16[di];
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1699b() // 164d:04cb +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0x7484, 0x0000);
    memoryASet16(ds, 0x7482, 0x0000);
    push(cs);
    yield* sub_16d78();
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_395b(); assert(cs == 0x164d);
    sp += 0x0002;
    memoryASet16(ds, 0x7480, r16[dx]);
    memoryASet16(ds, 0x747e, r16[ax]);
    r16[ax] = 0x164d;
    push(r16[ax]);
    r16[ax] = 0x000b;
    push(r16[ax]);
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_396a(); assert(cs == 0x164d);
    sp += 0x0006;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_169d8() // 164d:0508 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x0040;
    es = r16[ax];
    r16[ax] = memoryAGet16(es, 0x0017);
    r16[ax] &= 0xfaf0;
    r16[dx] = 0x0040;
    es = r16[dx];
    memoryASet16(es, 0x0017, r16[ax]);
    push(memoryAGet16(ds, 0x7480));
    push(memoryAGet16(ds, 0x747e));
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_396a(); assert(cs == 0x164d);
    sp += 0x0006;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_16a06() // 164d:0536 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x0033;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_395b(); assert(cs == 0x164d);
    sp += 0x0002;
    r16[ax] |= r16[dx];
    if (!r16[ax])
        { pc = 0x16a27; break; }
    r16[ax] = 0;
    interrupt(0x33);
    if (r16[ax] != 0xffff)
        { pc = 0x16a27; break; }
    r16[ax] = 0x0001;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x16a27:
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16a2b() // 164d:055b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_16a30() // 164d:0560 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    r16[ax] += 0xcc15;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ds, r16[si] + 4);
    r16[ax] -= memoryAGet16(ds, r16[si]);
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0x8000;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x164d);
    memoryASet16(ds, r16[si] + 16, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[ax] -= memoryAGet16(ds, r16[si] + 8);
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0x8000;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x164d);
    memoryASet16(ds, r16[si] + 20, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 6);
    r16[ax] -= memoryAGet16(ds, r16[si] + 2);
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0x8000;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x164d);
    memoryASet16(ds, r16[si] + 18, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] -= memoryAGet16(ds, r16[si] + 10);
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0x8000;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x164d);
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_16aa7() // 164d:05d7 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x0018;
    imul16(r16[dx]);
    r16[ax] += 0xcc15;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 8);
    r16[di] = r16[ax];
    r16[bx] = 0x0005;
    r16[dx] = 0;
    div16(r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] >>= 1;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 4, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] >>= 1;
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, r16[si] + 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 12);
    r16[di] = r16[ax];
    r16[dx] = 0;
    div16(r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] >>= 1;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, r16[si] + 6, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] >>= 1;
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_16a30();
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_16b32() // 164d:0662 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_166cd();
    sp += 0x0006;
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x16b66; break; }
    if (memoryAGet16(ss, r16[bp] - 2) > 0x137e)
        { pc = 0x16b66; break; }
    if (!memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x16b66; break; }
    if (memoryAGet16(ss, r16[bp] - 4) <= 0x137e)
        { pc = 0x16b6d; break; }
  case 0x16b66:
    r16[ax] = 0;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x16b6d:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    yield* sub_16aa7();
    sp += 0x000a;
    r16[ax] = 0x0001;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16b8f() // 164d:06bf +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 52294, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_16c64() // 164d:0794 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    if (memoryAGet16(ds, 0x748a))
        { pc = 0x16cf0; break; }
    r16[di] = 0x0001;
    memoryASet16(ss, r16[bp] - 2, 0x0001);
    r16[si] = 0x0001;
    { pc = 0x16cad; break; }
  case 0x16c80:
    r16[ax] = 0x3d32;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x164d);
    sp += 0x0004;
    if (!r16[ax])
        { pc = 0x16ca3; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x16ca7; break; }
    { pc = 0x16cac; break; }
  case 0x16ca3:
    r16[di] = 0;
    { pc = 0x16cac; break; }
  case 0x16ca7:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
  case 0x16cac:
    r16[si]++;
  case 0x16cad:
    if (r16[si] < memoryAGet16(ds, 0x743c))
        { pc = 0x16c80; break; }
    push(cs);
    yield* sub_1699b();
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x16cc3; break; }
    push(cs);
    yield* sub_16a06();
    { pc = 0x16cc5; break; }
  case 0x16cc3:
    r16[ax] = 0;
  case 0x16cc5:
    memoryASet16(ds, 0xcc4a, r16[ax]);
    r16[si] = 0;
    { pc = 0x16ce5; break; }
  case 0x16ccc:
    if (!r16[di])
        { pc = 0x16cda; break; }
    push(r16[si]);
    push(cs);
    yield* sub_16b32();
    sp += 0x0002;
    { pc = 0x16cdc; break; }
  case 0x16cda:
    r16[ax] = 0;
  case 0x16cdc:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 52294, r16[ax]);
    r16[si]++;
  case 0x16ce5:
    if (r16[si] < 0x0002)
        { pc = 0x16ccc; break; }
    memoryASet16(ds, 0x748a, 0x0001);
  case 0x16cf0:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16cf6() // 164d:0826 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    if (!memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x16d27; break; }
    if (r16[si] != 0x0002)
        { pc = 0x16d0f; break; }
    if (!memoryAGet16(ds, 0xcc46))
        { pc = 0x16d27; break; }
  case 0x16d0f:
    if (r16[si] != 0x0003)
        { pc = 0x16d1b; break; }
    if (!memoryAGet16(ds, 0xcc48))
        { pc = 0x16d27; break; }
  case 0x16d1b:
    if (r16[si] != 0x0004)
        { pc = 0x16d29; break; }
    if (memoryAGet16(ds, 0xcc4a))
        { pc = 0x16d29; break; }
  case 0x16d27:
    r16[si] = 0;
  case 0x16d29:
    push(r16[si]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_171f8();
    sp += 0x0004;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16d38() // 164d:0868 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    if (!memoryAGet16(ds, 0x748a))
        { pc = 0x16d63; break; }
    push(cs);
    yield* sub_16a2b();
    r16[si] = 0;
    { pc = 0x16d54; break; }
  case 0x16d4b:
    push(r16[si]);
    push(cs);
    yield* sub_16b8f();
    sp += 0x0002;
    r16[si]++;
  case 0x16d54:
    if (r16[si] < 0x0002)
        { pc = 0x16d4b; break; }
    push(cs);
    yield* sub_169d8();
    memoryASet16(ds, 0x748a, 0x0000);
  case 0x16d63:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16d78() // 164d:08a8 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet(ds, 0xa545, 0x00);
    memoryASet(ds, 0xcc45, 0x00);
    r16[ax] = 0;
    { pc = 0x16d94; break; }
  case 0x16d89:
    r16[bx] = r16[ax];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 50759, 0x0000);
    r16[ax]++;
  case 0x16d94:
    if (r16s[ax] < signed16(0x0080))
        { pc = 0x16d89; break; }
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16d9b() // 164d:08cb +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    if (!(r16[dx] & 0x0001))
        { pc = 0x16daf; break; }
    memoryASet16(ds, r16[si], 0x0001);
  case 0x16daf:
    if (!(r16[dx] & 0x0002))
        { pc = 0x16dba; break; }
    memoryASet16(ds, r16[si] + 2, 0x0001);
  case 0x16dba:
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, r16[si] + 4, memoryAGet16(ds, r16[si] + 4) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, r16[si] + 6, memoryAGet16(ds, r16[si] + 6) + r16[ax]);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16dc9() // 164d:08f9 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0;
    memoryASet16(ds, r16[bx] + 6, r16[ax]);
    memoryASet16(ds, r16[bx] + 4, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ds, r16[bx] + 2, r16[ax]);
    memoryASet16(ds, r16[bx], r16[ax]);
    if (!memoryAGet16(ds, 0xcc4a))
        { pc = 0x16e13; break; }
    push(cs);
    yield* sub_166b8();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    push(cs);
    yield* sub_166a0();
    sp += 0x0004;
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_16d9b();
    sp += 0x0008;
  case 0x16e13:
    r16[di] = 0;
    { pc = 0x16e83; break; }
  case 0x16e17:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    if (!memoryAGet16(ds, r16[bx] + 52294))
        { pc = 0x16e82; break; }
    r16[si] = 0;
    { pc = 0x16e36; break; }
  case 0x16e26:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = r16[di];
    r16[ax] += 0x0002;
    if (memoryAGet16(ds, r16[bx] + 52237) == r16[ax])
        { pc = 0x16e3d; break; }
    r16[si]++;
  case 0x16e36:
    if (r16[si] < 0x0004)
        { pc = 0x16e26; break; }
    { pc = 0x16e82; break; }
  case 0x16e3d:
    push(r16[di]);
    push(cs);
    yield* sub_1690f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_16768();
    sp += 0x0008;
    r16[bx] = 0x0040;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_16d9b();
    sp += 0x0008;
  case 0x16e82:
    r16[di]++;
  case 0x16e83:
    if (r16[di] < 0x0002)
        { pc = 0x16e17; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_16e8e() // 164d:09be +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0010;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    if (memoryAGet16(ds, 0x3bd6) != 0x0002)
        { pc = 0x16f13; break; }
    r16[bx] = memoryAGet16(ds, 0xa7e0);
    es = memoryAGet16(ds, 0xa543);
    r8[al] = memoryAGet(es, r16[bx] + 1);
    memoryASet(ss, r16[bp] - 3, r8[al]);
    r8[ah] = 0x00;
    r16[ax] &= 0x0003;
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 3);
    r8[ah] = 0x00;
    r16[ax] = sar16(r16[ax], 0x0001);
    r16[ax] = sar16(r16[ax], 0x0001);
    r16[ax] &= 0x0003;
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 3);
    r8[ah] = 0x00;
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    r16[ax] &= 0x0003;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[al] += 0xff;
    memoryASet(es, r16[bx], r8[al]);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x16f0b; break; }
    memoryASet16(ds, 0xa7e0, memoryAGet16(ds, 0xa7e0) + 0x0002);
    r16[ax] = memoryAGet16(ds, 0xa7e0);
    if (r16[ax] < memoryAGet16(ds, 0xa541))
        { pc = 0x16f0b; break; }
    memoryASet16(ds, 0x3bd6, 0x0003);
  case 0x16f0b:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x170cc; break; }
  case 0x16f13:
    if (memoryAGet16(ds, 0x3bd6) != 0x0003)
        { pc = 0x16f29; break; }
    r16[ax] = 0x3ee5;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x164d);
    sp += 0x0002;
    { pc = 0x170cc; break; }
  case 0x16f29:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52237);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[bx] = r16[ax];
    if (r16[bx] <= 0x0004)
        { pc = 0x16f3f; break; }
    { pc = 0x170cc; break; }
  case 0x16f3f:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x16f46; break; }
        case 2: { pc = 0x16f46; break; }
        case 4: { pc = 0x17047; break; }
        case 6: { pc = 0x17047; break; }
        case 8: { pc = 0x170b1; break; }
        default:
            stop("ind 164d:0a71");
    }
    break;
  case 0x16f46:
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r16[dx] = 0x000a;
    imul16(r16[dx]);
    r16[ax] += 0x3bc2;
    r16[si] = r16[ax];
    r8[al] = memoryAGet(ds, r16[si] + 2);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x16f6f; break; }
    memoryASet16(ss, r16[bp] - 12, 0xffff);
    memoryASet16(ss, r16[bp] - 14, 0xffff);
    { pc = 0x16fc1; break; }
  case 0x16f6f:
    r8[al] = memoryAGet(ds, r16[si] + 4);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x16f8b; break; }
    memoryASet16(ss, r16[bp] - 12, 0x0001);
    memoryASet16(ss, r16[bp] - 14, 0xffff);
    { pc = 0x16fc1; break; }
  case 0x16f8b:
    r8[al] = memoryAGet(ds, r16[si] + 7);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x16fa7; break; }
    memoryASet16(ss, r16[bp] - 12, 0xffff);
    memoryASet16(ss, r16[bp] - 14, 0x0001);
    { pc = 0x16fc1; break; }
  case 0x16fa7:
    r8[al] = memoryAGet(ds, r16[si] + 9);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x16fc1; break; }
    memoryASet16(ss, r16[bp] - 12, 0x0001);
    memoryASet16(ss, r16[bp] - 14, 0x0001);
  case 0x16fc1:
    r8[al] = memoryAGet(ds, r16[si] + 3);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x16fd8; break; }
    memoryASet16(ss, r16[bp] - 14, 0xffff);
    { pc = 0x16fed; break; }
  case 0x16fd8:
    r8[al] = memoryAGet(ds, r16[si] + 8);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x16fed; break; }
    memoryASet16(ss, r16[bp] - 14, 0x0001);
  case 0x16fed:
    r8[al] = memoryAGet(ds, r16[si] + 5);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x17004; break; }
    memoryASet16(ss, r16[bp] - 12, 0xffff);
    { pc = 0x17019; break; }
  case 0x17004:
    r8[al] = memoryAGet(ds, r16[si] + 6);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x17019; break; }
    memoryASet16(ss, r16[bp] - 12, 0x0001);
  case 0x17019:
    r8[al] = memoryAGet(ds, r16[si]);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x1702b; break; }
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
  case 0x1702b:
    r8[al] = memoryAGet(ds, r16[si] + 1);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    if (!memoryAGet16(ds, r16[bx] + 50759))
        { pc = 0x1703f; break; }
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 0x0002);
  case 0x1703f:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x170cc; break; }
  case 0x17047:
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] += 0xfffe;
    push(r16[ax]);
    push(cs);
    yield* sub_16768();
    sp += 0x0008;
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0x17099; break; }
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs);
    yield* sub_1690f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[di] = 0;
    { pc = 0x17094; break; }
  case 0x17079:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r8[cl] = memoryAGet(ds, r16[bx] + 52229);
    r16[ax] = 0x0001;
    r16[ax] <<= r8[cl];
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] &= r16[ax];
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 50747, r16[dx]);
    r16[di]++;
  case 0x17094:
    if (r16s[di] < signed16(0x0004))
        { pc = 0x17079; break; }
  case 0x17099:
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] += 0xfffe;
    push(r16[ax]);
    push(cs);
    yield* sub_1690f();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0001);
    { pc = 0x170cc; break; }
  case 0x170b1:
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    push(cs);
    yield* sub_166a0();
    sp += 0x0004;
    push(cs);
    yield* sub_166b8();
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0001);
  case 0x170cc:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1710a; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) >= signed16(0x0000))
        { pc = 0x170dd; break; }
    r16[ax] = 0xffff;
    { pc = 0x170ea; break; }
  case 0x170dd:
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) <= signed16(0x0000))
        { pc = 0x170e8; break; }
    r16[ax] = 0x0001;
    { pc = 0x170ea; break; }
  case 0x170e8:
    r16[ax] = 0;
  case 0x170ea:
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) >= signed16(0x0000))
        { pc = 0x170f8; break; }
    r16[ax] = 0xffff;
    { pc = 0x17105; break; }
  case 0x170f8:
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) <= signed16(0x0000))
        { pc = 0x17103; break; }
    r16[ax] = 0x0001;
    { pc = 0x17105; break; }
  case 0x17103:
    r16[ax] = 0;
  case 0x17105:
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    { pc = 0x17120; break; }
  case 0x1710a:
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] = 0x007f;
    imul16(r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = 0x007f;
    imul16(r16[dx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
  case 0x17120:
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[bx] + 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ds, r16[bx] + 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ds, r16[bx] + 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ds, r16[bx] + 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] &= 0x0001;
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] &= 0x0002;
    memoryASet16(ds, r16[bx] + 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 14);
    r16[bx] <<= 1;
    r16[bx] += memoryAGet16(ss, r16[bp] - 14);
    r16[bx] += memoryAGet16(ss, r16[bp] - 12);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 15656);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
    if (memoryAGet16(ds, 0x3bd6) != 0x0001)
        { pc = 0x171e8; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 6);
    r8[cl] = 0x04;
    r8[al] <<= r8[cl];
    r8[dl] = memoryAGet(ss, r16[bp] - 12);
    r8[dl]++;
    r8[dl] <<= 1;
    r8[dl] <<= 1;
    r8[al] |= r8[dl];
    r8[dl] = memoryAGet(ss, r16[bp] - 14);
    r8[dl]++;
    r8[al] |= r8[dl];
    memoryASet(ss, r16[bp] - 3, r8[al]);
    r16[bx] = memoryAGet16(ds, 0xa7e0);
    es = memoryAGet16(ds, 0xa543);
    r8[al] = memoryAGet(es, r16[bx] + 1);
    if (r8[al] != memoryAGet(ss, r16[bp] - 3))
        { pc = 0x171a6; break; }
    if (memoryAGet(es, r16[bx]) >= 0xff)
        { pc = 0x171a6; break; }
    memoryASet(es, r16[bx], memoryAGet(es, r16[bx]) + 1);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x171a6:
    if (memoryAGet16(ds, 0xa7e0))
        { pc = 0x171bb; break; }
    es = memoryAGet16(ds, 0xa543);
    r16[bx] = memoryAGet16(ds, 0xa7e0);
    if (!memoryAGet(es, r16[bx]))
        { pc = 0x171c0; break; }
  case 0x171bb:
    memoryASet16(ds, 0xa7e0, memoryAGet16(ds, 0xa7e0) + 0x0002);
  case 0x171c0:
    r16[ax] = memoryAGet16(ds, 0xa7e0);
    if (r16[ax] < memoryAGet16(ds, 0xa541))
        { pc = 0x171d5; break; }
    r16[ax] = 0x3efc;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x164d);
    sp += 0x0002;
  case 0x171d5:
    es = memoryAGet16(ds, 0xa543);
    r16[bx] = memoryAGet16(ds, 0xa7e0);
    memoryASet(es, r16[bx], 0x01);
    r8[al] = memoryAGet(ss, r16[bp] - 3);
    memoryASet(es, r16[bx] + 1, r8[al]);
  case 0x171e8:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_171f8() // 164d:0d28 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[bx] + 52237, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_17209() // 164d:0d39 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[si])
        { pc = 0x17219; break; }
    r16[ax] = 0;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x17219:
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[si]);
    r16[ax] = 0xa543;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17bc2(); assert(cs == 0x164d);
    sp += 0x0006;
    memoryASet16(ds, 0x3bd6, 0x0001);
    r16[ax] = r16[si];
    r16[ax] &= 0xfffe;
    memoryASet16(ds, 0xa541, r16[ax]);
    memoryASet16(ds, 0xa7e0, 0x0000);
    es = memoryAGet16(ds, 0xa543);
    r8[al] = 0x00;
    memoryASet(es, 0x0001, r8[al]);
    memoryASet(es, 0x0000, r8[al]);
    r16[ax] = 0x0001;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17251() // 164d:0d81 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xa543, r16[ax]);
    memoryASet16(ds, 0x3bd6, 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] &= 0xfffe;
    memoryASet16(ds, 0xa541, r16[ax]);
    memoryASet16(ds, 0xa7e0, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_17271() // 164d:0da1 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (memoryAGet16(ds, 0x3bd6) != 0x0001)
        { pc = 0x17287; break; }
    if (!memoryAGet16(ds, 0xa7e0))
        { pc = 0x17287; break; }
    memoryASet16(ds, 0xa7e0, memoryAGet16(ds, 0xa7e0) + 0x0002);
  case 0x17287:
    memoryASet16(ds, 0x3bd6, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1728f() // 164d:0dbf +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xa543))
        { pc = 0x172a5; break; }
    r16[ax] = 0xa543;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x164d);
    sp += 0x0002;
  case 0x172a5:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_172ef() // 164d:0e1f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
  case 0x172f5:
    r8[al] = memoryAGet(ds, 0xa545);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0x172f5; break; }
    memoryASet(ds, 0xa545, 0x00);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1732a() // 164d:0e5a +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    { pc = 0x17381; break; }
  case 0x17330:
    if (!memoryAGet16(ds, 0xcc4a))
        { pc = 0x1734a; break; }
    push(cs);
    yield* sub_166b8();
    if (!r16[ax])
        { pc = 0x1734a; break; }
  case 0x1733f:
    push(cs);
    yield* sub_166b8();
    if (r16[ax])
        { pc = 0x1733f; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1734a:
    r16[si] = 0;
    { pc = 0x1737c; break; }
  case 0x1734e:
    yield* sync();
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 52294))
        { pc = 0x17360; break; }
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0x1737b; break; }
  case 0x17360:
    push(r16[si]);
    push(cs);
    yield* sub_16948();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x1737b; break; }
  case 0x1736c:
    push(r16[si]);
    push(cs);
    yield* sub_16948();
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1737b:
    r16[si]++;
  case 0x1737c:
    if (r16[si] < 0x0002)
        { pc = 0x1734e; break; }
  case 0x17381:
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (!r16[ax])
        { pc = 0x17330; break; }
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    memoryASet16(ds, r16[bx] + 50759, 0x0000);
    r8[al] = memoryAGet(ds, 0xa545);
    if (r8[al] != memoryAGet(ds, 0xa545))
        { pc = 0x173a7; break; }
    memoryASet(ds, 0xa545, 0x00);
  case 0x173a7:
    memoryASet(ds, 0xa545, 0x00);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_173af() // 164d:0edf +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    r16[ax] <<= 1;
    r16[bx] = r16[ax];
    memoryASet16(ds, r16[bx] + 50759, 0x0000);
    r8[al] = memoryAGet(ds, 0xa545);
    if (r8[al] != memoryAGet(ds, 0xa545))
        { pc = 0x173d0; break; }
    memoryASet(ds, 0xa545, 0x00);
  case 0x173d0:
    memoryASet(ds, 0xa545, 0x00);
    if (!memoryAGet16(ds, 0xcc4a))
        { pc = 0x173e4; break; }
  case 0x173dc:
    push(cs);
    yield* sub_166b8();
    if (r16[ax])
        { pc = 0x173dc; break; }
  case 0x173e4:
    r16[si] = 0;
    { pc = 0x17407; break; }
  case 0x173e8:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 52294))
        { pc = 0x173fa; break; }
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0x17406; break; }
  case 0x173fa:
    push(r16[si]);
    push(cs);
    yield* sub_16948();
    sp += 0x0002;
    if (r16[ax])
        { pc = 0x173fa; break; }
  case 0x17406:
    r16[si]++;
  case 0x17407:
    if (r16[si] < 0x0002)
        { pc = 0x173e8; break; }
    push(cs);
    yield* sub_1732a();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17413() // 164d:0f43 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    r16[di] = r16[ax];
    if (!memoryAGet16(ds, 0xcc4a))
        { pc = 0x17431; break; }
    push(cs);
    yield* sub_166b8();
    if (!r16[ax])
        { pc = 0x17431; break; }
    r16[di] = 0x0001;
  case 0x17431:
    r16[si] = 0;
    { pc = 0x17457; break; }
  case 0x17435:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 52294))
        { pc = 0x17447; break; }
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0x17456; break; }
  case 0x17447:
    push(r16[si]);
    push(cs);
    yield* sub_1690f();
    sp += 0x0002;
    if (!r16[ax])
        { pc = 0x17456; break; }
    r16[di] = 0x0001;
  case 0x17456:
    r16[si]++;
  case 0x17457:
    if (r16[si] < 0x0002)
        { pc = 0x17435; break; }
    r16[ax] = r16[di];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17462() // 164d:0f92 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x17479:
    yield* sync();
    push(cs);
    yield* sub_17413();
    if (!r16[ax])
        { pc = 0x17491; break; }
    if (!r16[si])
        { pc = 0x17489; break; }
    push(cs);
    yield* sub_1732a();
  case 0x17489:
    r16[ax] = 0x0001;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x17491:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    flags.carry = r16[dx] < memoryAGet16(ss, r16[bp] - 4);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2) + flags.carry;
    if (r16[ax] < memoryAGet16(ss, r16[bp] + 8))
        { pc = 0x17479; break; }
    if (r16[ax] != memoryAGet16(ss, r16[bp] + 8))
        { pc = 0x174aa; break; }
    if (r16[dx] < memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x17479; break; }
  case 0x174aa:
    r16[ax] = 0;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_174b1() // 174b:0001 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = 0x3f12;
    r16[ax] = 0x3d00;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x174e3; break; }
    r16[bx] = r16[ax];
    r16[ax] = 0x4400;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x174e3; break; }
    r16[dx] &= 0x0080;
    if (!r16[dx])
        { pc = 0x174e3; break; }
    r16[ax] = 0x4407;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x174e3; break; }
    if (!r8[al])
        { pc = 0x174e3; break; }
    r8[ah] = 0x3e;
    interrupt(0x21);
    if (flags.carry)
        { pc = 0x174e3; break; }
    r16[ax] = 0x0001;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x174e3:
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_174e7() // 174b:0037 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x005c;
    r16[ax] = 0;
    memoryASet16(ds, 0xcc68, r16[ax]);
    memoryASet16(ds, 0xcc6a, r16[ax]);
    memoryASet16(ds, 0xcc6c, r16[ax]);
    memoryASet16(ds, 0xcc6e, r16[ax]);
    r8[ah] = 0x40;
    interrupt(0x67);
    if (r8[ah])
        { pc = 0x1754b; break; }
    r8[ah] = 0x46;
    interrupt(0x67);
    if (r8[ah])
        { pc = 0x1754b; break; }
    if (r8[al] < 0x32)
        { pc = 0x1754b; break; }
    r8[ah] = 0x41;
    interrupt(0x67);
    if (r8[ah])
        { pc = 0x1754b; break; }
    memoryASet16(ds, 0xcc6a, r16[bx]);
    r8[ah] = 0x42;
    interrupt(0x67);
    if (r8[ah])
        { pc = 0x1754b; break; }
    memoryASet16(ds, 0xcc6e, r16[dx]);
    memoryASet16(ds, 0xcc6c, r16[bx]);
    if (!r16[bx])
        { pc = 0x17591; break; }
    if (r16s[bx] <= signed16(0x0004))
        { pc = 0x17537; break; }
    r16[bx] = 0x0004;
  case 0x17537:
    memoryASet16(ds, 0xcc68, r16[bx]);
    r8[ah] = 0x43;
    interrupt(0x67);
    if (r8[ah])
        { pc = 0x1754b; break; }
    memoryASet16(ds, 0xcc66, r16[dx]);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1754b:
    r8[al] = r8[ah];
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = 0x3f22;
    push(r16[ax]);
    r16[ax] = r16[bp] - 92;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x174b);
    sp += 0x0004;
    r16[ax] = 0x0010;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 12));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x174b);
    sp += 0x0006;
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = r16[bp] - 92;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x174b);
    sp += 0x0004;
    r16[ax] = r16[bp] - 92;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
  case 0x17591:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17595() // 174b:00e5 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xcc66))
        { pc = 0x175b7; break; }
    r8[ah] = 0x45;
    r16[dx] = memoryAGet16(ds, 0xcc66);
    interrupt(0x67);
    if (!r8[ah])
        { pc = 0x175b7; break; }
    r16[ax] = 0x3f3d;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
  case 0x175b7:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_175b9() // 174b:0109 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x005e;
    memoryASet16(ss, r16[bp] - 14, 0x0000);
    { pc = 0x175da; break; }
  case 0x175c6:
    r8[ah] = 0x44;
    r16[bx] = memoryAGet16(ss, r16[bp] - 14);
    r8[al] = r8[bl];
    r16[dx] = memoryAGet16(ds, 0xcc66);
    interrupt(0x67);
    if (r8[ah])
        { pc = 0x175e7; break; }
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 1);
  case 0x175da:
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    if (r16[ax] < memoryAGet16(ds, 0xcc68))
        { pc = 0x175c6; break; }
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x175e7:
    r8[al] = r8[ah];
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = 0x3f61;
    push(r16[ax]);
    r16[ax] = r16[bp] - 94;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x174b);
    sp += 0x0004;
    r16[ax] = 0x0010;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 12));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x174b);
    sp += 0x0006;
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    r16[ax] = r16[bp] - 94;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x174b);
    sp += 0x0004;
    r16[ax] = r16[bp] - 94;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17631() // 174b:0181 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xcc60, 0x0000);
    r16[ax] = 0x4300;
    interrupt(0x2f);
    if (r8[al] == 0x80)
        { pc = 0x17647; break; }
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x17647:
    r16[ax] = 0x0001;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1764c() // 174b:019c +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r16[ax] = 0x4310;
    interrupt(0x2f);
    memoryASet16(ds, 0xcc62, r16[bx]);
    memoryASet16(ds, 0xcc64, es);
  case 0x1765f:
    r8[ah] = 0x10;
    r16[dx] = 0xffff;
    push(cs); cs = memoryAGet16(ds, 0xcc64); indirectCall(cs, memoryAGet16(ds, 0xcc62)); assert(cs == 0x174b); // 174b:01b4
    if (r16[ax])
        { pc = 0x1767b; break; }
    if (r8[bl] != 0xb0)
        { pc = 0x176b7; break; }
    r8[ah] = 0x10;
    push(cs); cs = memoryAGet16(ds, 0xcc64); indirectCall(cs, memoryAGet16(ds, 0xcc62)); assert(cs == 0x174b); // 174b:01c3
    if (!r16[ax])
        { pc = 0x176b7; break; }
  case 0x1767b:
    memoryASet16(ss, r16[bp] - 2, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs);
    yield* sub_176e6();
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    flags.carry = memoryAGet16(ds, 0xa017) + r16[ax] >= 0x10000;
    memoryASet16(ds, 0xa017, memoryAGet16(ds, 0xa017) + r16[ax]);
    memoryASet16(ds, 0xa019, memoryAGet16(ds, 0xa019) + (0x0000 + flags.carry));
    r16[bx] = memoryAGet16(ds, 0xcc60);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[bx] + 52300, r16[ax]);
    memoryASet16(ds, 0xcc60, memoryAGet16(ds, 0xcc60) + 1);
    if (memoryAGet16(ds, 0xcc60) < 0x000a)
        { pc = 0x1765f; break; }
  case 0x176b7:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_176bb() // 174b:020b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    r16[si] = 0;
    { pc = 0x176db; break; }
  case 0x176c6:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52300);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r8[ah] = 0x11;
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    push(cs); cs = memoryAGet16(ds, 0xcc64); indirectCall(cs, memoryAGet16(ds, 0xcc62)); assert(cs == 0x174b); // 174b:0226
    r16[si]++;
  case 0x176db:
    if (r16[si] < memoryAGet16(ds, 0xcc60))
        { pc = 0x176c6; break; }
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_176e6() // 174b:0236 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000e;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    { pc = 0x17731; break; }
  case 0x17714:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x17731:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    if (r16[ax] < r16[di])
        { pc = 0x17714; break; }
    es = memoryAGet16(ss, r16[bp] - 2);
    push(es);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] - 10);
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    memoryASet16(ss, r16[bp] - 14, r16[dx]);
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) > signed16(0x0000))
        { pc = 0x1777f; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) < signed16(0x0000))
        { pc = 0x17773; break; }
    if (memoryAGet16(ss, r16[bp] - 14) >= 0x0000)
        { pc = 0x1777f; break; }
  case 0x17773:
    r16[ax] = 0x3f79;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
  case 0x1777f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx]) != r16[di])
        { pc = 0x177d2; break; }
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx] + 6);
    memoryASet16(ds, r16[bx], 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x177e3; break; }
  case 0x177d2:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = r16[di];
    r16[ax] -= memoryAGet16(es, r16[si]);
    es = pop();
    memoryASet16(es, r16[bx] + 2, r16[ax]);
  case 0x177e3:
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) >= signed16(0x0000))
        { pc = 0x177ec; break; }
    { pc = 0x1786f; break; }
  case 0x177ec:
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) > signed16(0x0000))
        { pc = 0x177f4; break; }
    if (memoryAGet16(ss, r16[bp] - 14) <= 0x0000)
        { pc = 0x1786f; break; }
  case 0x177f4:
    r16[ax] = memoryAGet16(ds, 0xcc7a);
    r16[ax] |= memoryAGet16(ds, 0xcc7c);
    if (r16[ax])
        { pc = 0x17802; break; }
    push(cs);
    yield* sub_17875();
  case 0x17802:
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(ds, 0xcc74, r16[ax]);
    memoryASet16(ds, 0xcc72, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc7a); es = memoryAGet16(ds, 0xcc7c);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc72); es = memoryAGet16(ds, 0xcc74);
    memoryASet16(es, r16[bx] + 6, 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    r16[bx] = memoryAGet16(ds, 0xcc72); es = memoryAGet16(ds, 0xcc74);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, 0xcc74);
    r16[dx] = memoryAGet16(ds, 0xcc72);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    r16[bx] = memoryAGet16(ds, 0xcc72); es = memoryAGet16(ds, 0xcc74);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, r16[bx] + 2, r16[ax]);
    memoryASet16(es, r16[bx] + 4, 0x0080);
  case 0x1786f:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17875() // 174b:03c5 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r16[bx] = memoryAGet16(ds, 0xcc7e); es = memoryAGet16(ds, 0xcc80);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x178c3; break; }
  case 0x1788f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx] + 4) & 0x0080)
        { pc = 0x178b2; break; }
    if (!(memoryAGet16(es, r16[bx] + 4) & 0x0003))
        { pc = 0x178b2; break; }
    push(memoryAGet16(es, r16[bx] + 6));
    push(cs);
    yield* sub_17e37();
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x178b2:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x178c3:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax])
        { pc = 0x1788f; break; }
    r16[ax] = 0x3fa1;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_178db() // 174b:042b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    if (!memoryAGet16(ds, 0xcc88))
        { pc = 0x178ef; break; }
    push(cs);
    yield* sub_17b92();
  case 0x178ef:
    memoryASet16(ds, 0xcc88, 0x0001);
    memoryASet16(ds, 0xcc70, 0x0001);
    memoryASet16(ds, 0xcc80, 0x0000);
    memoryASet16(ds, 0xcc7e, 0x0000);
    memoryASet16(ds, 0xcc7c, 0x2d50);
    memoryASet16(ds, 0xcc7a, 0x0000);
    r16[si] = 0;
    { pc = 0x1793e; break; }
  case 0x17917:
    r16[ax] = r16[si];
    r16[dx] = 0x000c;
    imul16(r16[dx]);
    r16[ax] += 0x000c;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[dx] = 0x000c;
    imul16(r16[dx]);
    r16[dx] = 0x2d50;
    r16[bx] = r16[ax];
    es = r16[dx];
    memoryASet16(es, r16[bx] + 10, 0x2d50);
    r16[ax] = pop();
    memoryASet16(es, r16[bx] + 8, r16[ax]);
    r16[si]++;
  case 0x1793e:
    if (r16s[si] < signed16(0x04af))
        { pc = 0x17917; break; }
    r16[ax] = r16[si];
    r16[dx] = 0x000c;
    imul16(r16[dx]);
    r16[dx] = 0x2d50;
    r16[bx] = r16[ax];
    es = r16[dx];
    memoryASet16(es, r16[bx] + 10, 0x0000);
    memoryASet16(es, r16[bx] + 8, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xcc7a);
    r16[ax] |= memoryAGet16(ds, 0xcc7c);
    if (r16[ax])
        { pc = 0x1796d; break; }
    push(cs);
    yield* sub_17875();
  case 0x1796d:
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(ds, 0xcc74, r16[ax]);
    memoryASet16(ds, 0xcc72, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc7a); es = memoryAGet16(ds, 0xcc7c);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc74);
    r16[dx] = memoryAGet16(ds, 0xcc72);
    memoryASet16(ds, 0xcc80, r16[ax]);
    memoryASet16(ds, 0xcc7e, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc72); es = memoryAGet16(ds, 0xcc74);
    memoryASet16(es, r16[bx], 0x0000);
    memoryASet16(es, r16[bx] + 2, 0xffff);
    memoryASet16(es, r16[bx] + 4, 0x0080);
    memoryASet16(es, r16[bx] + 10, 0x0000);
    memoryASet16(es, r16[bx] + 8, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xcc80);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_3622(); assert(cs == 0x174b);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_52c7(); assert(cs == 0x174b);
    sp += 0x0002;
    memoryASet16(ds, 0xcc82, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, ds);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] &= 0x000f;
    r16[dx] = 0x0010;
    r16[dx] -= r16[ax];
    flags.carry = memoryAGet16(ss, r16[bp] - 4) < r16[dx];
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - r16[dx]);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - (0x0000 + flags.carry));
    flags.carry = memoryAGet16(ss, r16[bp] - 4) < 0x0400;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 0x0400);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - (0x0000 + flags.carry));
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x04;
    push(cs); cs = 0x01ed; yield* sub_5084(); assert(cs == 0x174b);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0x000f;
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] += r16[ax];
    r16[di] = r16[dx];
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[dx]);
    push(cs);
    yield* sub_176e6();
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa00d, r16[ax]);
    memoryASet16(ds, 0xa00b, r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_25dc(); assert(cs == 0x174b);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4d93(); assert(cs == 0x174b);
    sp += 0x0004;
    memoryASet16(ds, 0xcc86, r16[dx]);
    memoryASet16(ds, 0xcc84, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] &= 0x000f;
    r16[dx] = 0x0010;
    r16[dx] -= r16[ax];
    flags.carry = memoryAGet16(ss, r16[bp] - 4) < r16[dx];
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - r16[dx]);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - (0x0000 + flags.carry));
    flags.carry = memoryAGet16(ss, r16[bp] - 4) < 0x0000;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 0x0000);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - (0x0000 + flags.carry));
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x04;
    push(cs); cs = 0x01ed; yield* sub_5084(); assert(cs == 0x174b);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += 0x000f;
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] += r16[ax];
    r16[di] = r16[dx];
    push(memoryAGet16(ss, r16[bp] - 10));
    push(r16[dx]);
    push(cs);
    yield* sub_176e6();
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa011, r16[ax]);
    memoryASet16(ds, 0xa00f, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xa00d);
    r16[dx] = memoryAGet16(ds, 0xa00b);
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa00f) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa00f);
    r16[ax] += memoryAGet16(ds, 0xa011) + flags.carry;
    memoryASet16(ds, 0xa01d, r16[ax]);
    memoryASet16(ds, 0xa01b, r16[dx]);
    memoryASet16(ds, 0xa015, 0x0000);
    memoryASet16(ds, 0xa013, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x17aef; break; }
  case 0x17ad2:
    r16[ax] = 0x3f1c;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x174b);
    sp += 0x0004;
    if (!r16[ax])
        { pc = 0x17b2b; break; }
    r16[si]++;
  case 0x17aef:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x17ad2; break; }
    push(cs);
    yield* sub_174b1();
    if (!r16[ax])
        { pc = 0x17b2b; break; }
    push(cs);
    yield* sub_174e7();
    r16[ax] = memoryAGet16(ds, 0xcc68);
    r8[cl] = 0x0a;
    r16[ax] <<= r8[cl];
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcc6a));
    push(cs);
    yield* sub_176e6();
    sp += 0x0004;
    push(cs);
    yield* sub_175b9();
    r16[ax] = memoryAGet16(ds, 0xcc68);
    r16[dx] = 0;
    r8[cl] = 0x0e;
    push(cs); cs = 0x01ed; yield* sub_5043(); assert(cs == 0x174b);
    memoryASet16(ds, 0xa015, r16[dx]);
    memoryASet16(ds, 0xa013, r16[ax]);
  case 0x17b2b:
    memoryASet16(ds, 0xa019, 0x0000);
    memoryASet16(ds, 0xa017, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x17b59; break; }
  case 0x17b3c:
    r16[ax] = 0x3f1c;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x174b);
    sp += 0x0004;
    if (!r16[ax])
        { pc = 0x17b6b; break; }
    r16[si]++;
  case 0x17b59:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x17b3c; break; }
    push(cs);
    yield* sub_17631();
    if (!r16[ax])
        { pc = 0x17b6b; break; }
    push(cs);
    yield* sub_1764c();
  case 0x17b6b:
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    r16[ax] = 0;
    r16[dx] = 0x1000;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0xcbed;
    push(r16[ax]);
    push(cs);
    yield* sub_17bc2();
    sp += 0x0006;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17b92() // 174b:06e2 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xcc88))
        { pc = 0x17bc0; break; }
    push(memoryAGet16(ds, 0xcc86));
    push(memoryAGet16(ds, 0xcc84));
    push(cs); cs = 0x01ed; yield* sub_4cad(); assert(cs == 0x174b);
    sp += 0x0004;
    push(memoryAGet16(ds, 0xcc82));
    push(cs); cs = 0x01ed; yield* sub_51f8(); assert(cs == 0x174b);
    sp += 0x0002;
    push(cs);
    yield* sub_17595();
    push(cs);
    yield* sub_176bb();
  case 0x17bc0:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17bc2() // 174b:0712 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0018;
    push(r16[si]);
    push(r16[di]);
    r16[dx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    flags.carry = r16[ax] + 0x000f >= 0x10000;
    r16[ax] += 0x000f;
    r16[dx] += (0x0000 + flags.carry);
    r8[cl] = 0x04;
    push(cs); cs = 0x01ed; yield* sub_5084(); assert(cs == 0x174b);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xcc7a);
    r16[ax] |= memoryAGet16(ds, 0xcc7c);
    if (r16[ax])
        { pc = 0x17bed; break; }
    push(cs);
    yield* sub_17875();
  case 0x17bed:
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(ds, 0xcc74, r16[ax]);
    memoryASet16(ds, 0xcc72, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc7a); es = memoryAGet16(ds, 0xcc7c);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc72); es = memoryAGet16(ds, 0xcc74);
    r16[ax] = memoryAGet16(ss, r16[bp] - 24);
    memoryASet16(es, r16[bx] + 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(es, r16[bx] + 6, r16[ax]);
    memoryASet16(es, r16[bx] + 4, 0x0000);
    memoryASet16(ss, r16[bp] - 22, 0x0000);
    { pc = 0x17e09; break; }
  case 0x17c2e:
    if (memoryAGet16(ss, r16[bp] - 22) != 0x0001)
        { pc = 0x17c4a; break; }
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    if (r16[ax] != memoryAGet16(ds, 0xcc80))
        { pc = 0x17c4a; break; }
    if (r16[dx] != memoryAGet16(ds, 0xcc7e))
        { pc = 0x17c4a; break; }
    memoryASet16(ss, r16[bp] - 22, memoryAGet16(ss, r16[bp] - 22) + 1);
  case 0x17c4a:
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    if (!r16[ax])
        { pc = 0x17c5e; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x17c89; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x17cb7; break; }
    { pc = 0x17ce5; break; }
  case 0x17c5e:
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    { pc = 0x17ce5; break; }
  case 0x17c89:
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc7e); es = memoryAGet16(ds, 0xcc80);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    { pc = 0x17ce5; break; }
  case 0x17cb7:
    push(cs);
    yield* sub_1800d();
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc7e); es = memoryAGet16(ds, 0xcc80);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
  case 0x17ce5:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    r16[di] = r16[ax];
    { pc = 0x17df0; break; }
  case 0x17cf9:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax] -= r16[di];
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 24))
        { pc = 0x17d09; break; }
    { pc = 0x17daf; break; }
  case 0x17d09:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 16, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc74);
    r16[dx] = memoryAGet16(ds, 0xcc72);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[di];
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xcc72); es = memoryAGet16(ds, 0xcc74);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    { pc = 0x17d8b; break; }
  case 0x17d47:
    r16[bx] = memoryAGet16(ss, r16[bp] - 16); es = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    memoryASet16(ss, r16[bp] - 20, r16[dx]);
    r16[bx] = memoryAGet16(es, r16[bx] + 6);
    memoryASet16(ds, r16[bx], 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 16);
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[dx] = memoryAGet16(ss, r16[bp] - 20);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    memoryASet16(ss, r16[bp] - 16, r16[dx]);
  case 0x17d8b:
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = memoryAGet16(ss, r16[bp] - 16);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x17d47; break; }
    if (r16[dx] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x17d47; break; }
    r16[ax] = memoryAGet16(ds, 0xcc74);
    r16[dx] = memoryAGet16(ds, 0xcc72);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x17daf:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx] + 4) & 0x0080)
        { pc = 0x17dc2; break; }
    if (memoryAGet16(es, r16[bx] + 4) & 0x0003)
        { pc = 0x17ddf; break; }
  case 0x17dc2:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    r16[di] = r16[ax];
  case 0x17ddf:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x17df0:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x17dfe; break; }
    { pc = 0x17cf9; break; }
  case 0x17dfe:
    if (r16[dx] == memoryAGet16(ss, r16[bp] - 12))
        { pc = 0x17e06; break; }
    { pc = 0x17cf9; break; }
  case 0x17e06:
    memoryASet16(ss, r16[bp] - 22, memoryAGet16(ss, r16[bp] - 22) + 1);
  case 0x17e09:
    if (signed16(memoryAGet16(ss, r16[bp] - 22)) >= signed16(0x0003))
        { pc = 0x17e12; break; }
    { pc = 0x17c2e; break; }
  case 0x17e12:
    if (!memoryAGet16(ds, 0xcc70))
        { pc = 0x17e2b; break; }
    r16[ax] = 0x3fd1;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x17e2b:
    memoryASet16(ds, 0xa7ef, 0x0001);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17e37() // 174b:0987 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    if (memoryAGet16(es, r16[bx] + 6) != r16[si])
        { pc = 0x17e98; break; }
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    { pc = 0x17e98; break; }
    // gap 2 bytes
  case 0x17e7b:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x17e98:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx] + 6) == r16[si])
        { pc = 0x17ea9; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax])
        { pc = 0x17e7b; break; }
  case 0x17ea9:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax])
        { pc = 0x17ebd; break; }
    r16[ax] = 0x3feb;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
  case 0x17ebd:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(es, r16[bx] + 6);
    memoryASet16(ds, r16[bx], 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17f02() // 174b:0a52 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x17f19:
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    if (memoryAGet16(es, r16[bx] + 6) == r16[si])
        { pc = 0x17f70; break; }
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc76);
    r16[ax] |= memoryAGet16(ds, 0xcc78);
    if (r16[ax])
        { pc = 0x17f4f; break; }
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    { pc = 0x17f19; break; }
  case 0x17f4f:
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x17f19; break; }
    if (r16[dx] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x17f19; break; }
    r16[ax] = 0x4008;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
    { pc = 0x17f19; break; }
    // gap 2 bytes
  case 0x17f70:
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    memoryASet16(es, r16[bx] + 4, memoryAGet16(es, r16[bx] + 4) & 0xfffc);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(es, r16[bx] + 4, memoryAGet16(es, r16[bx] + 4) | r16[ax]);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_17f85() // 174b:0ad5 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x17f9c:
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    if (memoryAGet16(es, r16[bx] + 6) == r16[si])
        { pc = 0x17ff3; break; }
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc76);
    r16[ax] |= memoryAGet16(ds, 0xcc78);
    if (r16[ax])
        { pc = 0x17fd2; break; }
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    { pc = 0x17f9c; break; }
  case 0x17fd2:
    r16[ax] = memoryAGet16(ds, 0xcc78);
    r16[dx] = memoryAGet16(ds, 0xcc76);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x17f9c; break; }
    if (r16[dx] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x17f9c; break; }
    r16[ax] = 0x4026;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
    { pc = 0x17f9c; break; }
    // gap 2 bytes
  case 0x17ff3:
    r16[bx] = memoryAGet16(ds, 0xcc76); es = memoryAGet16(ds, 0xcc78);
    memoryASet16(es, r16[bx] + 4, memoryAGet16(es, r16[bx] + 4) & 0xff7f);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r8[cl] = 0x07;
    r16[ax] <<= r8[cl];
    memoryASet16(es, r16[bx] + 4, memoryAGet16(es, r16[bx] + 4) | r16[ax]);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1800d() // 174b:0b5d +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0016;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x1a61; yield* sub_1b0a0(); assert(cs == 0x174b);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 22))
        { pc = 0x1804c; break; }
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (r16[ax] == 0x0001)
        { pc = 0x18032; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x18034; break; }
    { pc = 0x18038; break; }
  case 0x18032:
    { pc = 0x18038; break; }
  case 0x18034:
    memoryASet16(ss, r16[bp] - 22, memoryAGet16(ss, r16[bp] - 22) + 0x0034);
  case 0x18038:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    push(r16[ax]);
    push(cs);
    yield* sub_17f85();
    sp += 0x0004;
  case 0x1804c:
    push(cs); cs = 0x1a61; yield* sub_1b0e7(); assert(cs == 0x174b);
    r16[ax] = memoryAGet16(ds, 0xa54e);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f019(); assert(cs == 0x174b);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xcc8e);
    r16[ax] |= memoryAGet16(ds, 0xcc90);
    if (!r16[ax])
        { pc = 0x18070; break; }
    push(cs); cs = memoryAGet16(ds, 0xcc90); indirectCall(cs, memoryAGet16(ds, 0xcc8e)); assert(cs == 0x174b); // 174b:0bbc
  case 0x18070:
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    { pc = 0x1819d; break; }
  case 0x1808a:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 4) & 0x0080))
        { pc = 0x180a7; break; }
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    { pc = 0x18180; break; }
  case 0x180a7:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 4) & 0x0003))
        { pc = 0x18101; break; }
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    r16[bx] = memoryAGet16(es, r16[bx] + 6);
    memoryASet16(ds, r16[bx], 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(ds, 0xcc7c);
    r16[dx] = memoryAGet16(ds, 0xcc7a);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xcc7c, r16[ax]);
    memoryASet16(ds, 0xcc7a, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(es, r16[bx] + 10, r16[ax]);
    memoryASet16(es, r16[bx] + 8, r16[dx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x1819d; break; }
  case 0x18101:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx]);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 14))
        { pc = 0x1816e; break; }
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[di] = memoryAGet16(es, r16[bx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    { pc = 0x18140; break; }
  case 0x1811e:
    r16[ax] = 0xf000;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 18));
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x01ed; yield* sub_3c10(); assert(cs == 0x174b);
    sp += 0x000a;
    memoryASet16(ss, r16[bp] - 16, memoryAGet16(ss, r16[bp] - 16) - 0x0f00);
    r16[di] += 0x0f00;
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 0x0f00);
  case 0x18140:
    if (memoryAGet16(ss, r16[bp] - 16) > 0x0f00)
        { pc = 0x1811e; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 18));
    push(r16[ax]);
    push(r16[di]);
    push(cs); cs = 0x01ed; yield* sub_3c10(); assert(cs == 0x174b);
    sp += 0x000a;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(es, r16[bx] + 6);
    memoryASet16(ds, r16[bx], r16[ax]);
  case 0x1816e:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
  case 0x18180:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x1819d:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 2);
    if (!r16[ax])
        { pc = 0x181a8; break; }
    { pc = 0x1808a; break; }
  case 0x181a8:
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ds, 0xcc78, r16[ax]);
    memoryASet16(ds, 0xcc76, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xcc8a);
    r16[ax] |= memoryAGet16(ds, 0xcc8c);
    if (!r16[ax])
        { pc = 0x181c3; break; }
    push(cs); cs = memoryAGet16(ds, 0xcc8c); indirectCall(cs, memoryAGet16(ds, 0xcc8a)); assert(cs == 0x174b); // 174b:0d0f
  case 0x181c3:
    push(memoryAGet16(ss, r16[bp] - 20));
    push(cs); cs = 0x1ef3; yield* sub_1f019(); assert(cs == 0x174b);
    sp += 0x0002;
    if (!memoryAGet16(ss, r16[bp] - 22))
        { pc = 0x181e7; break; }
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    push(r16[ax]);
    push(cs);
    yield* sub_17f85();
    sp += 0x0004;
  case 0x181e7:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_181ed() // 174b:0d3d +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x1ef3; yield* sub_1f082(); assert(cs == 0x174b);
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x174b);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ds, 0xa7b4, 0x0000);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x174b);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 8, 0xffff);
    memoryASet16(ss, r16[bp] - 10, 0xffff);
    { pc = 0x18307; break; }
  case 0x18238:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 4) & 0x0003))
        { pc = 0x18248; break; }
    r16[di] = 0x0005;
    { pc = 0x1824b; break; }
  case 0x18248:
    r16[di] = 0x0009;
  case 0x1824b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 4) & 0x0080))
        { pc = 0x18259; break; }
    r16[di] = 0x000c;
  case 0x18259:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[dx] = 0;
    if (r16s[dx] > signed16(memoryAGet16(ss, r16[bp] - 8)))
        { pc = 0x18279; break; }
    if (r16[dx] != memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1826d; break; }
    if (r16[ax] > memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x18279; break; }
  case 0x1826d:
    r16[ax] = 0x4043;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x174b);
    sp += 0x0002;
  case 0x18279:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    push(r16[di]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 10));
    es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx]));
    push(cs); cs = 0x1ef3; yield* sub_1f4ad(); assert(cs == 0x174b);
    sp += 0x0008;
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx]));
    push(cs); cs = 0x1ff7; yield* sub_1ff70(); assert(cs == 0x174b);
    sp += 0x0006;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    r16[ax] = 0;
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    r16[cx] = memoryAGet16(ss, r16[bp] - 10);
    flags.carry = r16[cx] + 0x0001 >= 0x10000;
    r16[cx]++;
    r16[dx] += (0x0000 + flags.carry);
    if (r16s[ax] < r16s[dx])
        { pc = 0x182f6; break; }
    if (r16s[ax] > r16s[dx])
        { pc = 0x182db; break; }
    if (memoryAGet16(es, r16[bx]) <= r16[cx])
        { pc = 0x182f6; break; }
  case 0x182db:
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    push(memoryAGet16(es, r16[bx]));
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax]++;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f4ad(); assert(cs == 0x174b);
    sp += 0x0008;
  case 0x182f6:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x18307:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 2);
    if (!r16[ax])
        { pc = 0x18312; break; }
    { pc = 0x18238; break; }
  case 0x18312:
    push(cs); cs = 0x164d; yield* sub_173af(); assert(cs == 0x174b);
    r16[ax] = 0x0040;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f20d(); assert(cs == 0x174b);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1832f() // 174b:0e7f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0;
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x18378; break; }
  case 0x18348:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(r16[ax]);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    r16[dx] = pop();
    r16[dx] -= r16[ax];
    r16[di] += r16[dx];
    es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x18378:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[ax] |= memoryAGet16(es, r16[bx] + 10);
    if (r16[ax])
        { pc = 0x18348; break; }
    r16[ax] = r16[di];
    r16[dx] = 0;
    r8[cl] = 0x04;
    push(cs); cs = 0x01ed; yield* sub_5043(); assert(cs == 0x174b);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18396() // 174b:0ee6 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0;
    r16[ax] = memoryAGet16(ds, 0xcc80);
    r16[dx] = memoryAGet16(ds, 0xcc7e);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x183f6; break; }
  case 0x183af:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 4) & 0x0003))
        { pc = 0x183c6; break; }
    if (memoryAGet16(es, r16[bx] + 4) & 0x0080)
        { pc = 0x183c6; break; }
    r16[di] += memoryAGet16(es, r16[bx] + 2);
  case 0x183c6:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(r16[ax]);
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(es, r16[si]);
    es = pop();
    r16[ax] += memoryAGet16(es, r16[bx] + 2);
    r16[dx] = pop();
    r16[dx] -= r16[ax];
    r16[di] += r16[dx];
    es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
  case 0x183f6:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[ax] |= memoryAGet16(es, r16[bx] + 10);
    if (r16[ax])
        { pc = 0x183af; break; }
    r16[ax] = r16[di];
    r16[dx] = 0;
    r8[cl] = 0x04;
    push(cs); cs = 0x01ed; yield* sub_5043(); assert(cs == 0x174b);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18414() // 174b:0f64 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xcc70, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1841f() // 1841:000f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x18442; break; }
  case 0x1842e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = 0x0016;
    imul16(r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 57836, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x18442:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x000e))
        { pc = 0x1842e; break; }
    r16[ax] = 0x0200;
    memoryASet16(ds, 0xe6da, r16[ax]);
    memoryASet16(ds, 0xc74b, r16[ax]);
    memoryASet16(ds, 0xccae, 0xccb2);
    memoryASet16(ds, 0xccb0, 0xce92);
    if (memoryAGet16(ds, 0xe6ee) == 0x0002)
        { pc = 0x18467; break; }
    { pc = 0x184ed; break; }
  case 0x18467:
    memoryASet16(ds, 0xe1ea, 0x0001);
    memoryASet16(ds, 0xdeb2, 0xdeec);
    memoryASet16(ds, 0xdeb4, 0xe082);
    memoryASet16(ds, 0xdda4, 0x0000);
    memoryASet16(ds, 0xdda2, 0x0001);
    r16[bx] = memoryAGet16(ds, 0xdda4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x4074);
    memoryASet16(ds, 0xa546, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57010);
    memoryASet16(ds, 0xe6d8, r16[ax]);
    r16[di] = 0xe470;
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x184db; break; }
  case 0x184bc:
    r16[si] = 0;
    { pc = 0x184d3; break; }
  case 0x184c0:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x0a;
    r16[ax] <<= r8[cl];
    r16[dx] = r16[si];
    r16[dx] <<= 1;
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di], r16[ax]);
    r16[di] += 0x0002;
    r16[si]++;
  case 0x184d3:
    if (r16s[si] < signed16(0x0016))
        { pc = 0x184c0; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x184db:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) < signed16(0x000e))
        { pc = 0x184bc; break; }
    memoryASet16(ds, 0xdda6, 0x0006);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x184ed:
    if (memoryAGet16(ds, 0xe6ee) != 0x0001)
        { pc = 0x1853e; break; }
    memoryASet16(ds, 0xe1ea, 0x0002);
    r16[ax] = 0xdeec;
    memoryASet16(ds, 0xdeba, r16[ax]);
    memoryASet16(ds, 0xe6d8, r16[ax]);
    memoryASet16(ds, 0xa7b4, 0x0000);
    memoryASet16(ds, 0xa546, 0x8000);
    r16[di] = 0xe470;
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x18538; break; }
  case 0x18519:
    r16[si] = 0;
    { pc = 0x18530; break; }
  case 0x1851d:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x0a;
    r16[ax] <<= r8[cl];
    r16[dx] = r16[si];
    r16[dx] <<= 1;
    r16[ax] += r16[dx];
    memoryASet16(ds, r16[di], r16[ax]);
    r16[di] += 0x0002;
    r16[si]++;
  case 0x18530:
    if (r16s[si] < signed16(0x0016))
        { pc = 0x1851d; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x18538:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) < signed16(0x000e))
        { pc = 0x18519; break; }
  case 0x1853e:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18544() // 1841:0134 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_18549() // 1841:0139 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0x4070, 0x0000);
    memoryASet16(ds, 0x4072, 0x3c00);
    memoryASet16(ds, 0x4074, 0x7800);
    if (memoryAGet16(ds, 0xe6ee) != 0x0002)
        { pc = 0x185b3; break; }
    memoryASet16(ds, 0xdda4, 0x0000);
    memoryASet16(ds, 0xdda2, 0x0001);
    r16[ax] = 0;
    memoryASet16(ds, 0xa7b0, r16[ax]);
    memoryASet16(ds, 0xc759, r16[ax]);
    memoryASet16(ds, 0xc75b, r16[ax]);
    memoryASet16(ds, 0xe6ea, r16[ax]);
    memoryASet16(ds, 0xe6ec, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x4074);
    memoryASet16(ds, 0xa546, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x185b3:
    r16[ax] = 0;
    memoryASet16(ds, 0xa7b0, r16[ax]);
    memoryASet16(ds, 0xc759, r16[ax]);
    memoryASet16(ds, 0xc75b, r16[ax]);
    memoryASet16(ds, 0xe6ea, r16[ax]);
    memoryASet16(ds, 0xe6ec, r16[ax]);
    memoryASet16(ds, 0xa7b4, 0x0000);
    memoryASet16(ds, 0xa546, 0x8000);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_185d2() // 1841:01c2 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    es = memoryAGet16(ds, r16[bx] + 52145);
    r16[ax] = memoryAGet16(es, 0x0012);
    memoryASet16(ds, 0xa7e4, r16[ax]);
    r16[ax] <<= 1;
    memoryASet16(ds, 0xe6e2, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xa7ed);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, 0x0014);
    memoryASet16(ds, 0xa7e2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] -= 0x0015;
    memoryASet16(ds, 0xe6dc, r16[ax]);
    r16[ax] <<= 1;
    memoryASet16(ds, 0xe6de, r16[ax]);
    if (memoryAGet16(ds, 0xa7e2) <= 0x00c8)
        { pc = 0x1861f; break; }
    r16[ax] = 0x4080;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x1861f:
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x18640; break; }
  case 0x1862b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[bx] + 51493, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe6e2);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + r16[ax]);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x18640:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax] < memoryAGet16(ds, 0xa7e2))
        { pc = 0x1862b; break; }
    r16[di] = 0xe208;
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x18674; break; }
  case 0x18653:
    r16[si] = 0;
    { pc = 0x1866c; break; }
  case 0x18657:
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    r16[dx] = memoryAGet16(ds, r16[bx] + 51493);
    r16[dx] += r16[ax];
    memoryASet16(ds, r16[di], r16[dx]);
    r16[di] += 0x0002;
    r16[si]++;
  case 0x1866c:
    if (r16s[si] < signed16(0x0016))
        { pc = 0x18657; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x18674:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) < signed16(0x000e))
        { pc = 0x18653; break; }
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] -= 0x0002;
    r16[ax] -= 0x0014;
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xc749, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e2);
    r16[ax] -= 0x0002;
    r16[ax] -= 0x000d;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xc747, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc749);
    if (r16[ax] >= memoryAGet16(ds, 0xc74b))
        { pc = 0x186a7; break; }
    r16[ax] = memoryAGet16(ds, 0xc74b);
    memoryASet16(ds, 0xc749, r16[ax]);
  case 0x186a7:
    r16[ax] = memoryAGet16(ds, 0xc747);
    if (r16[ax] >= memoryAGet16(ds, 0xe6da))
        { pc = 0x186b6; break; }
    r16[ax] = memoryAGet16(ds, 0xe6da);
    memoryASet16(ds, 0xc747, r16[ax]);
  case 0x186b6:
    push(cs);
    yield* sub_18e41();
    push(cs);
    yield* sub_18af2();
    push(cs);
    yield* sub_18f0b();
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_18f18();
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e2);
    r16[ax] -= 0x0002;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_18f18();
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    yield* sub_18f18();
    sp += 0x0006;
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] -= 0x0002;
    push(r16[ax]);
    push(cs);
    yield* sub_18f18();
    sp += 0x0006;
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    memoryASet16(ds, 0xa54c, 0x0001);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18728() // 1841:0318 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0070;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x0104;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0xddae;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x1841);
    sp += 0x0006;
    memoryASet16(ds, 0xddac, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    imul16(memoryAGet16(ds, 0xa7e2));
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e7);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa7eb);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    memoryASet16(ss, r16[bp] - 20, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] += r16[ax];
    memoryASet16(ss, r16[bp] - 14, r16[dx]);
    memoryASet16(ss, r16[bp] - 16, r16[bx]);
  case 0x1877c:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0x0000))
        { pc = 0x18792; break; }
    { pc = 0x1890c; break; }
  case 0x18792:
    r16[ax] = 0x2c27;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[bx] + 523, memoryAGet(es, r16[bx] + 523) | r8[dl]);
    es = memoryAGet16(ds, 0xc8a1);
    if (memoryAGet(es, r16[bx] + 1698))
        { pc = 0x187b2; break; }
    { pc = 0x1890c; break; }
  case 0x187b2:
    if (memoryAGet(es, r16[bx] + 402))
        { pc = 0x187bd; break; }
    { pc = 0x1887c; break; }
  case 0x187bd:
    r8[al] = memoryAGet(es, r16[bx] + 1698);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x18807; break; }
    r16[ax] = 0x4099;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x1841);
    sp += 0x0006;
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18807:
    r16[di] = 0;
    { pc = 0x1882d; break; }
  case 0x1880b:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 56750);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1882c; break; }
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0xddae;
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    memoryASet16(es, r16[bx], r16[ax]);
    { pc = 0x1890c; break; }
  case 0x1882c:
    r16[di]++;
  case 0x1882d:
    if (r16[di] < memoryAGet16(ds, 0xddac))
        { pc = 0x1880b; break; }
    if (r16[di] < 0x0041)
        { pc = 0x18844; break; }
    r16[ax] = 0x40c4;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18844:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, r16[bx] + 56750, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 402);
    r8[ah] = 0x00;
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 56752, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0xddae;
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ds, 0xddac, memoryAGet16(ds, 0xddac) + 1);
  case 0x1887c:
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 1698);
    cbw();
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[si] = r16[ax];
    { pc = 0x18901; break; }
  case 0x1889b:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si] + 523, memoryAGet(es, r16[si] + 523) | r8[dl]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 1698);
    cbw();
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[si] += memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    if (r16s[ax] <= signed16(0x0014))
        { pc = 0x18901; break; }
    r16[ax] = 0x40f9;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x1841);
    sp += 0x0006;
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18901:
    if (!memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1890c; break; }
    if (r16[si] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1889b; break; }
  case 0x1890c:
    memoryASet16(ss, r16[bp] - 20, memoryAGet16(ss, r16[bp] - 20) + 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x1891b; break; }
    { pc = 0x1877c; break; }
  case 0x1891b:
    r16[ax] = memoryAGet16(ds, 0xa7e9);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa7eb);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    memoryASet16(ss, r16[bp] - 20, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] += r16[ax];
    memoryASet16(ss, r16[bp] - 14, r16[dx]);
    memoryASet16(ss, r16[bp] - 16, r16[bx]);
  case 0x18944:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0x0000))
        { pc = 0x1895a; break; }
    { pc = 0x18add; break; }
  case 0x1895a:
    r16[ax] = 0x2c27;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[bx] + 1819, memoryAGet(es, r16[bx] + 1819) | r8[dl]);
    es = memoryAGet16(ds, 0xc8a1);
    if (memoryAGet(es, r16[bx] + 14658))
        { pc = 0x1897a; break; }
    { pc = 0x18add; break; }
  case 0x1897a:
    if (memoryAGet(es, r16[bx] + 20490))
        { pc = 0x18985; break; }
    { pc = 0x18a4d; break; }
  case 0x18985:
    r8[al] = memoryAGet(es, r16[bx] + 14658);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x189cf; break; }
    r16[ax] = 0x412d;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x1841);
    sp += 0x0006;
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x189cf:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= 0x8000;
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    r16[di] = 0;
    { pc = 0x189fe; break; }
  case 0x189dc:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 56750);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 22))
        { pc = 0x189fd; break; }
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0xddae;
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    memoryASet16(es, r16[bx], r16[ax]);
    { pc = 0x18add; break; }
  case 0x189fd:
    r16[di]++;
  case 0x189fe:
    if (r16[di] < memoryAGet16(ds, 0xddac))
        { pc = 0x189dc; break; }
    if (r16[di] < 0x0041)
        { pc = 0x18a15; break; }
    r16[ax] = 0x4158;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18a15:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    memoryASet16(ds, r16[bx] + 56750, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 20490);
    r8[ah] = 0x00;
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 56752, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0xddae;
    r16[bx] = memoryAGet16(ss, r16[bp] - 20); es = memoryAGet16(ss, r16[bp] - 18);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ds, 0xddac, memoryAGet16(ds, 0xddac) + 1);
  case 0x18a4d:
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[bx] + 14658);
    cbw();
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[si] = r16[ax];
    { pc = 0x18ad2; break; }
  case 0x18a6c:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si] + 1819, memoryAGet(es, r16[si] + 1819) | r8[dl]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 14658);
    cbw();
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[si] += memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    if (r16s[ax] <= signed16(0x0014))
        { pc = 0x18ad2; break; }
    r16[ax] = 0x418d;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x1841);
    sp += 0x0006;
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = r16[bp] - 112;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18ad2:
    if (!memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x18add; break; }
    if (r16[si] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x18a6c; break; }
  case 0x18add:
    memoryASet16(ss, r16[bp] - 20, memoryAGet16(ss, r16[bp] - 20) + 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x18aec; break; }
    { pc = 0x18944; break; }
  case 0x18aec:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18af2() // 1841:06e2 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xd074, 0xd078);
    r16[dx] = 0;
    { pc = 0x18b11; break; }
  case 0x18aff:
    r16[ax] = r16[dx];
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r16[ax] += 0xd088;
    r16[bx] = r16[dx];
    r16[bx] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 53382, r16[ax]);
    r16[dx]++;
  case 0x18b11:
    if (r16s[dx] < signed16(0x0059))
        { pc = 0x18aff; break; }
    r16[bx] = r16[dx];
    r8[cl] = 0x04;
    r16[bx] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 53382, 0x0000);
    memoryASet16(ds, 0xd076, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18b2a() // 1841:071a +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] += memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e7);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6); es = memoryAGet16(ss, r16[bp] - 4);
    r16[di] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[di] + 1698))
        { pc = 0x18bd9; break; }
    if (!memoryAGet(es, r16[di] + 402))
        { pc = 0x18bd9; break; }
    if (memoryAGet16(ds, 0xd074))
        { pc = 0x18b7c; break; }
    r16[ax] = 0x41c1;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18b7c:
    r16[si] = memoryAGet16(ds, 0xd074);
    r16[bx] = memoryAGet16(ds, 0xd074);
    r16[ax] = memoryAGet16(ds, r16[bx] + 14);
    memoryASet16(ds, 0xd074, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xd076);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ds, 0xd076, r16[si]);
    if (!memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x18ba5; break; }
    r16[ax] = r16[si];
    r16[ax] += 0x000e;
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
  case 0x18ba5:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    memoryASet16(ds, r16[si] + 12, 0xd076);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[si], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 2, r16[ax]);
    memoryASet16(ds, r16[si] + 4, r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    memoryASet16(ds, r16[si] + 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7eb);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, r16[si] + 6, r16[ax]);
  case 0x18bd9:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 6); es = memoryAGet16(ss, r16[bp] - 4);
    r16[di] = memoryAGet16(es, r16[bx]);
    es = memoryAGet16(ds, 0xc8a1);
    if (!memoryAGet(es, r16[di] + 14658))
        { pc = 0x18c72; break; }
    if (!memoryAGet(es, r16[di] + 20490))
        { pc = 0x18c72; break; }
    if (memoryAGet16(ds, 0xd074))
        { pc = 0x18c15; break; }
    r16[ax] = 0x41f2;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18c15:
    r16[si] = memoryAGet16(ds, 0xd074);
    r16[bx] = memoryAGet16(ds, 0xd074);
    r16[ax] = memoryAGet16(ds, r16[bx] + 14);
    memoryASet16(ds, 0xd074, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xd076);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ds, 0xd076, r16[si]);
    if (!memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x18c3e; break; }
    r16[ax] = r16[si];
    r16[ax] += 0x000e;
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
  case 0x18c3e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    memoryASet16(ds, r16[si] + 12, 0xd076);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[si], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[si] + 2, r16[ax]);
    memoryASet16(ds, r16[si] + 4, r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[dx] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    memoryASet16(ds, r16[si] + 8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa7eb);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, r16[si] + 6, r16[ax]);
  case 0x18c72:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18c78() // 1841:0868 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ds, 0xd076);
    { pc = 0x18cb4; break; }
  case 0x18c85:
    if (memoryAGet16(ds, r16[si]) != r16[cx])
        { pc = 0x18cb1; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[bx] = memoryAGet16(ds, r16[si] + 12);
    memoryASet16(ds, r16[bx], r16[ax]);
    if (!memoryAGet16(ds, r16[si] + 14))
        { pc = 0x18ca0; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[bx] = memoryAGet16(ds, r16[si] + 14);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
  case 0x18ca0:
    r16[dx] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] = memoryAGet16(ds, 0xd074);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    memoryASet16(ds, 0xd074, r16[si]);
    r16[si] = r16[dx];
    { pc = 0x18cb4; break; }
  case 0x18cb1:
    r16[si] = memoryAGet16(ds, r16[si] + 14);
  case 0x18cb4:
    if (r16[si])
        { pc = 0x18c85; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18cbb() // 1841:08ab +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ds, 0xd076);
    { pc = 0x18cf8; break; }
  case 0x18cc8:
    if (memoryAGet16(ds, r16[si] + 2) != r16[cx])
        { pc = 0x18cf5; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[bx] = memoryAGet16(ds, r16[si] + 12);
    memoryASet16(ds, r16[bx], r16[ax]);
    if (!memoryAGet16(ds, r16[si] + 14))
        { pc = 0x18ce4; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[bx] = memoryAGet16(ds, r16[si] + 14);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
  case 0x18ce4:
    r16[dx] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] = memoryAGet16(ds, 0xd074);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    memoryASet16(ds, 0xd074, r16[si]);
    r16[si] = r16[dx];
    { pc = 0x18cf8; break; }
  case 0x18cf5:
    r16[si] = memoryAGet16(ds, r16[si] + 14);
  case 0x18cf8:
    if (r16[si])
        { pc = 0x18cc8; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18cff() // 1841:08ef +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(ds, 0xd076);
    { pc = 0x18d4e; break; }
  case 0x18d10:
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] -= r16[cx];
    if (r16[ax] >= memoryAGet16(ss, r16[bp] + 10))
        { pc = 0x18d4b; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] -= r16[di];
    if (r16[ax] >= memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x18d4b; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 14);
    r16[bx] = memoryAGet16(ds, r16[si] + 12);
    memoryASet16(ds, r16[bx], r16[ax]);
    if (!memoryAGet16(ds, r16[si] + 14))
        { pc = 0x18d3a; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 12);
    r16[bx] = memoryAGet16(ds, r16[si] + 14);
    memoryASet16(ds, r16[bx] + 12, r16[ax]);
  case 0x18d3a:
    r16[dx] = memoryAGet16(ds, r16[si] + 14);
    r16[ax] = memoryAGet16(ds, 0xd074);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    memoryASet16(ds, 0xd074, r16[si]);
    r16[si] = r16[dx];
    { pc = 0x18d4e; break; }
  case 0x18d4b:
    r16[si] = memoryAGet16(ds, r16[si] + 14);
  case 0x18d4e:
    if (r16[si])
        { pc = 0x18d10; break; }
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18d56() // 1841:0946 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0xddae;
    { pc = 0x18dbb; break; }
  case 0x18d63:
    r16[ax] = memoryAGet16(ds, r16[di] + 2);
    r16[ax] -= memoryAGet16(ds, 0xa54c);
    memoryASet16(ds, r16[di] + 2, r16[ax]);
    { pc = 0x18db2; break; }
  case 0x18d6f:
    if (!(memoryAGet16(ds, r16[di]) & 0x8000))
        { pc = 0x18d98; break; }
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax] &= 0x7fff;
    r16[si] = r16[ax];
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 14658);
    cbw();
    r16[si] += r16[ax];
    r8[al] = memoryAGet(es, r16[si] + 20490);
    r8[ah] = 0x00;
    memoryASet16(ds, r16[di] + 2, memoryAGet16(ds, r16[di] + 2) + r16[ax]);
    r16[si] |= 0x8000;
    { pc = 0x18db0; break; }
  case 0x18d98:
    r16[si] = memoryAGet16(ds, r16[di]);
    es = memoryAGet16(ds, 0xc8a1);
    r8[al] = memoryAGet(es, r16[si] + 1698);
    cbw();
    r16[si] += r16[ax];
    r8[al] = memoryAGet(es, r16[si] + 402);
    r8[ah] = 0x00;
    memoryASet16(ds, r16[di] + 2, memoryAGet16(ds, r16[di] + 2) + r16[ax]);
  case 0x18db0:
    memoryASet16(ds, r16[di], r16[si]);
  case 0x18db2:
    if (signed16(memoryAGet16(ds, r16[di] + 2)) < signed16(0x0001))
        { pc = 0x18d6f; break; }
    r16[di] += 0x0004;
  case 0x18dbb:
    if (memoryAGet16(ds, r16[di]))
        { pc = 0x18d63; break; }
    r16[ax] = memoryAGet16(ds, 0xd076);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0x18e35; break; }
  case 0x18dc8:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] = memoryAGet16(ds, r16[bx] + 6);
    r16[si] = memoryAGet16(ds, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(ds, r16[bx] + 4) == r16[si])
        { pc = 0x18e2c; break; }
    memoryASet16(ds, r16[bx] + 4, r16[si]);
    r16[tx] = memoryAGet16(ds, r16[bx] + 8); es = memoryAGet16(ds, r16[bx] + 10); r16[bx] = r16[tx];
    r16[ax] = r16[si];
    r16[ax] &= 0x7fff;
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[ax] -= memoryAGet16(ds, 0xc74f);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 2);
    r16[ax] -= memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 6) >= 0x0015)
        { pc = 0x18e08; break; }
    if (memoryAGet16(ss, r16[bp] - 8) < 0x000e)
        { pc = 0x18e14; break; }
  case 0x18e08:
    r16[ax] = 0x4223;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18e14:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57836);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1a13; yield* sub_1a13c(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18e2c:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx] + 14);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x18e35:
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x18dc8; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18e41() // 1841:0a31 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    memoryASet16(ds, 0xd618, 0xd622);
    r16[si] = 0;
    { pc = 0x18e61; break; }
  case 0x18e4f:
    r16[ax] = r16[si];
    r8[cl] = 0x05;
    r16[ax] <<= r8[cl];
    r16[ax] += 0xd642;
    r16[bx] = r16[si];
    r16[bx] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 54848, r16[ax]);
    r16[si]++;
  case 0x18e61:
    if (r16s[si] < signed16(0x003b))
        { pc = 0x18e4f; break; }
    r16[bx] = r16[si];
    r8[cl] = 0x05;
    r16[bx] <<= r8[cl];
    memoryASet16(ds, r16[bx] + 54848, 0x0000);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0xd61a;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bf5(); assert(cs == 0x1841);
    sp += 0x0006;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18e88() // 1841:0a78 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xc753, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, 0xc751, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc753);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, 0xc74f, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, 0xc74d, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r8[cl] = memoryAGet(ds, 0xe1ea);
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xe6e6, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    memoryASet16(ds, 0xe6e4, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xc74d);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[dx] = memoryAGet16(ds, 0xc74f);
    r16[dx] <<= 1;
    r16[ax] += r16[dx];
    memoryASet16(ds, 0xe1e8, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] >>= r8[cl];
    r16[ax] &= 0x000f;
    memoryASet16(ds, 0xe6ec, r16[ax]);
    r16[ax] &= 0x0008;
    memoryASet16(ds, 0xc75b, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] >>= r8[cl];
    r16[ax] &= 0x000f;
    memoryASet16(ds, 0xc759, r16[ax]);
    memoryASet16(ds, 0xe6ea, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe6ec);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[bx] = memoryAGet16(ds, 0xe6ea);
    r16[bx] <<= 1;
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ds, 0xa7b0, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_18f0b() // 1841:0afb +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    memoryASet16(ds, 0xccaa, r16[ax]);
    memoryASet16(ds, 0xccac, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_18f18() // 1841:0b08 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ss, r16[bp] + 10))
        { pc = 0x18f4a; break; }
    r16[bx] = memoryAGet16(ds, 0xccac);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, r16[bx] + 52382, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xccac);
    memoryASet16(ds, 0xccac, memoryAGet16(ds, 0xccac) + 1);
    if (r16[ax] != 0x0006)
        { pc = 0x18f6f; break; }
    r16[ax] = 0x4244;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0x18f4a:
    r16[bx] = memoryAGet16(ds, 0xccaa);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx] + 52370, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xccaa);
    memoryASet16(ds, 0xccaa, memoryAGet16(ds, 0xccaa) + 1);
    if (r16[ax] != 0x0006)
        { pc = 0x18f6f; break; }
    r16[ax] = 0x4279;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x18f6f:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_18f71() // 1841:0b61 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xc753, memoryAGet16(ds, 0xc753) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, 0xc751, memoryAGet16(ds, 0xc751) + r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc753);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] + 6)) <= signed16(0x0000))
        { pc = 0x18fc3; break; }
    r16[di] += 0x0014;
    r16[si] = 0;
    { pc = 0x18fbb; break; }
  case 0x18fa5:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 52370) != r16[di])
        { pc = 0x18fba; break; }
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] &= 0xff00;
    memoryASet16(ds, 0xc753, r16[ax]);
    { pc = 0x18fec; break; }
  case 0x18fba:
    r16[si]++;
  case 0x18fbb:
    if (r16s[si] < signed16(memoryAGet16(ds, 0xccaa)))
        { pc = 0x18fa5; break; }
    { pc = 0x18fec; break; }
  case 0x18fc3:
    if (signed16(memoryAGet16(ss, r16[bp] + 6)) >= signed16(0x0000))
        { pc = 0x18fec; break; }
    r16[si] = 0;
    { pc = 0x18fe6; break; }
  case 0x18fcd:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 52370) != r16[di])
        { pc = 0x18fe5; break; }
    r16[ax] = memoryAGet16(ds, 0xc753);
    r16[ax] &= 0xff00;
    r16[ax] += 0x0100;
    memoryASet16(ds, 0xc753, r16[ax]);
    { pc = 0x18fec; break; }
  case 0x18fe5:
    r16[si]++;
  case 0x18fe6:
    if (r16s[si] < signed16(memoryAGet16(ds, 0xccaa)))
        { pc = 0x18fcd; break; }
  case 0x18fec:
    if (signed16(memoryAGet16(ss, r16[bp] + 8)) <= signed16(0x0000))
        { pc = 0x1901b; break; }
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 0x000d);
    r16[si] = 0;
    { pc = 0x19013; break; }
  case 0x18ffa:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52382);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x19012; break; }
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] &= 0xff00;
    memoryASet16(ds, 0xc751, r16[ax]);
    { pc = 0x19047; break; }
  case 0x19012:
    r16[si]++;
  case 0x19013:
    if (r16s[si] < signed16(memoryAGet16(ds, 0xccac)))
        { pc = 0x18ffa; break; }
    { pc = 0x19047; break; }
  case 0x1901b:
    if (signed16(memoryAGet16(ss, r16[bp] + 8)) >= signed16(0x0000))
        { pc = 0x19047; break; }
    r16[si] = 0;
    { pc = 0x19041; break; }
  case 0x19025:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52382);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x19040; break; }
    r16[ax] = memoryAGet16(ds, 0xc751);
    r16[ax] &= 0xff00;
    r16[ax] += 0x0100;
    memoryASet16(ds, 0xc751, r16[ax]);
    { pc = 0x19047; break; }
  case 0x19040:
    r16[si]++;
  case 0x19041:
    if (r16s[si] < signed16(memoryAGet16(ds, 0xccac)))
        { pc = 0x19025; break; }
  case 0x19047:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xc751));
    push(r16[ax]);
    push(memoryAGet16(ds, 0xc753));
    push(cs);
    yield* sub_18e88();
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19060() // 1841:0c50 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xddaa, r16[ax]);
    memoryASet16(ds, 0xdda8, r16[dx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_19072() // 1841:0c62 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[bx] <= 0x0003)
        { pc = 0x19085; break; }
    { pc = 0x19120; break; }
  case 0x19085:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x1908c; break; }
        case 2: { pc = 0x190af; break; }
        case 4: { pc = 0x190d7; break; }
        case 6: { pc = 0x190fe; break; }
        default:
            stop("ind 1841:0c77");
    }
    break;
  case 0x1908c:
    r16[si] = 0;
    memoryASet16(ss, r16[bp] - 4, 0x0001);
    r16[di] = memoryAGet16(ds, 0xc74f);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, 0x0001);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    memoryASet16(ss, r16[bp] - 2, 0x0015);
    { pc = 0x19150; break; }
  case 0x190af:
    r16[si] = 0x0014;
    memoryASet16(ss, r16[bp] - 4, 0x0016);
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x0015;
    r16[ax]--;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    memoryASet16(ss, r16[bp] - 10, 0x0001);
    memoryASet16(ss, r16[bp] - 2, 0x000e);
    { pc = 0x19150; break; }
  case 0x190d7:
    r16[si] = 0x011e;
    memoryASet16(ss, r16[bp] - 4, 0x0001);
    r16[di] = memoryAGet16(ds, 0xc74f);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x000e;
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, 0x0001);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    memoryASet16(ss, r16[bp] - 2, 0x0015);
    { pc = 0x19150; break; }
  case 0x190fe:
    r16[si] = 0;
    memoryASet16(ss, r16[bp] - 4, 0x0016);
    r16[di] = memoryAGet16(ds, 0xc74f);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    memoryASet16(ss, r16[bp] - 10, 0x0001);
    memoryASet16(ss, r16[bp] - 2, 0x000e);
    { pc = 0x19150; break; }
  case 0x19120:
    r16[ax] = 0x42ac;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
    { pc = 0x19150; break; }
    // gap 2 bytes
  case 0x19130:
    push(r16[si]);
    push(cs); cs = 0x1a13; yield* sub_1a13c(); assert(cs == 0x1841);
    sp += 0x0002;
    push(memoryAGet16(ss, r16[bp] - 6));
    push(r16[di]);
    push(cs);
    yield* sub_18b2a();
    sp += 0x0004;
    r16[si] += memoryAGet16(ss, r16[bp] - 4);
    r16[di] += memoryAGet16(ss, r16[bp] - 8);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + r16[ax]);
  case 0x19150:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) - 1);
    if (r16[ax])
        { pc = 0x19130; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19169() // 1841:0d59 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(memoryAGet16(ds, 0xc751));
    push(memoryAGet16(ds, 0xc753));
    push(cs);
    yield* sub_19743();
    sp += 0x0004;
    push(cs);
    yield* sub_1a07e();
    push(cs);
    yield* sub_1a07e();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_19188() // 1841:0d78 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x002c;
    push(r16[si]);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 16));
    push(memoryAGet16(ss, r16[bp] + 14));
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(cs);
    yield* sub_18cff();
    sp += 0x0008;
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] += memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e7);
    memoryASet16(ss, r16[bp] - 20, r16[dx]);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7e9);
    memoryASet16(ss, r16[bp] - 24, r16[dx]);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xa7eb);
    memoryASet16(ss, r16[bp] - 28, r16[dx]);
    memoryASet16(ss, r16[bp] - 30, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 12);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] += memoryAGet16(ss, r16[bp] + 10);
    r16[di] = r16[ax];
    r16[di] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x19327; break; }
  case 0x19202:
    r16[si] = 0;
    { pc = 0x19304; break; }
  case 0x19207:
    r16[bx] = memoryAGet16(ss, r16[bp] - 22); es = memoryAGet16(ss, r16[bp] - 20);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 26); es = memoryAGet16(ss, r16[bp] - 24);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 30); es = memoryAGet16(ss, r16[bp] - 28);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 20);
    r16[bx] = memoryAGet16(ss, r16[bp] - 22);
    r16[bx] += r16[ax];
    memoryASet16(ss, r16[bp] - 32, r16[dx]);
    memoryASet16(ss, r16[bp] - 34, r16[bx]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 24);
    r16[bx] = memoryAGet16(ss, r16[bp] - 26);
    r16[bx] += r16[ax];
    memoryASet16(ss, r16[bp] - 36, r16[dx]);
    memoryASet16(ss, r16[bp] - 38, r16[bx]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 28);
    r16[bx] = memoryAGet16(ss, r16[bp] - 30);
    r16[bx] += r16[ax];
    memoryASet16(ss, r16[bp] - 40, r16[dx]);
    memoryASet16(ss, r16[bp] - 42, r16[bx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 34); es = memoryAGet16(ss, r16[bp] - 32);
    r16[ax] = memoryAGet16(es, r16[bx]);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 12))
        { pc = 0x19279; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 38); es = memoryAGet16(ss, r16[bp] - 36);
    r16[ax] = memoryAGet16(es, r16[bx]);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 14))
        { pc = 0x19279; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 42); es = memoryAGet16(ss, r16[bp] - 40);
    r16[ax] = memoryAGet16(es, r16[bx]);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x1929b; break; }
  case 0x19279:
    r16[bx] = memoryAGet16(ss, r16[bp] - 34); es = memoryAGet16(ss, r16[bp] - 32);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 38); es = memoryAGet16(ss, r16[bp] - 36);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(es, r16[bx], r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 42); es = memoryAGet16(ss, r16[bp] - 40);
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 44, 0x0001);
    { pc = 0x192a0; break; }
  case 0x1929b:
    memoryASet16(ss, r16[bp] - 44, 0x0000);
  case 0x192a0:
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] += r16[si];
    r16[ax] -= memoryAGet16(ds, 0xc74f);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    r16[ax] -= memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 8) >= 0x000e)
        { pc = 0x192f7; break; }
    if (memoryAGet16(ss, r16[bp] - 6) >= 0x0015)
        { pc = 0x192f7; break; }
    if (!memoryAGet16(ss, r16[bp] - 44))
        { pc = 0x192e3; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57836);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1a13; yield* sub_1a13c(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x192e3:
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] += r16[si];
    push(r16[ax]);
    push(cs);
    yield* sub_18b2a();
    sp += 0x0004;
  case 0x192f7:
    r16[si]++;
    memoryASet16(ss, r16[bp] - 22, memoryAGet16(ss, r16[bp] - 22) + 0x0002);
    memoryASet16(ss, r16[bp] - 26, memoryAGet16(ss, r16[bp] - 26) + 0x0002);
    memoryASet16(ss, r16[bp] - 30, memoryAGet16(ss, r16[bp] - 30) + 0x0002);
  case 0x19304:
    if (r16[si] >= memoryAGet16(ss, r16[bp] + 14))
        { pc = 0x1930c; break; }
    { pc = 0x19207; break; }
  case 0x1930c:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 22, memoryAGet16(ss, r16[bp] - 22) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 26, memoryAGet16(ss, r16[bp] - 26) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 30, memoryAGet16(ss, r16[bp] - 30) + r16[ax]);
  case 0x19327:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] + 16))
        { pc = 0x19332; break; }
    { pc = 0x19202; break; }
  case 0x19332:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19338() // 1841:0f28 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0012;
    push(r16[si]);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 18));
    push(memoryAGet16(ss, r16[bp] + 16));
    push(memoryAGet16(ss, r16[bp] + 14));
    push(memoryAGet16(ss, r16[bp] + 12));
    push(cs);
    yield* sub_18cff();
    sp += 0x0008;
    r16[bx] = memoryAGet16(ss, r16[bp] + 14);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 51493);
    r16[ax] >>= 1;
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] <<= 1;
    r16[dx] = memoryAGet16(ds, r16[bx] + 42983);
    r16[bx] = memoryAGet16(ss, r16[bp] + 12);
    r16[bx] <<= 1;
    r16[ax] += r16[bx];
    memoryASet16(ss, r16[bp] - 10, r16[dx]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7e4);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 16);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[di] = 0;
    { pc = 0x19427; break; }
  case 0x19384:
    r16[si] = 0;
    { pc = 0x19416; break; }
  case 0x19389:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    if (r16[ax] == memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x193b7; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] = memoryAGet16(ss, r16[bp] - 16);
    memoryASet16(es, r16[bx], r16[ax]);
    memoryASet16(ss, r16[bp] - 18, 0x0001);
    { pc = 0x193bc; break; }
  case 0x193b7:
    memoryASet16(ss, r16[bp] - 18, 0x0000);
  case 0x193bc:
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] += r16[si];
    r16[ax] -= memoryAGet16(ds, 0xc74f);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    r16[ax] += r16[di];
    r16[ax] -= memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 4) >= 0x000e)
        { pc = 0x19415; break; }
    if (memoryAGet16(ss, r16[bp] - 2) >= 0x0015)
        { pc = 0x19415; break; }
    if (!memoryAGet16(ss, r16[bp] - 18))
        { pc = 0x19402; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57836);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1a13; yield* sub_1a13c(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x19402:
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    r16[ax] += r16[di];
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] += r16[si];
    push(r16[ax]);
    push(cs);
    yield* sub_18b2a();
    sp += 0x0004;
  case 0x19415:
    r16[si]++;
  case 0x19416:
    if (r16[si] >= memoryAGet16(ss, r16[bp] + 16))
        { pc = 0x1941e; break; }
    { pc = 0x19389; break; }
  case 0x1941e:
    r16[di]++;
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + r16[ax]);
  case 0x19427:
    if (r16[di] >= memoryAGet16(ss, r16[bp] + 18))
        { pc = 0x1942f; break; }
    { pc = 0x19384; break; }
  case 0x1942f:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19435() // 1841:1025 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[ax] >= memoryAGet16(ds, 0xc74b))
        { pc = 0x1944b; break; }
    r16[ax] = memoryAGet16(ds, 0xc74b);
    memoryASet16(ss, r16[bp] + 6, r16[ax]);
    { pc = 0x1945a; break; }
  case 0x1944b:
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[ax] <= memoryAGet16(ds, 0xc749))
        { pc = 0x1945a; break; }
    r16[ax] = memoryAGet16(ds, 0xc749);
    memoryASet16(ss, r16[bp] + 6, r16[ax]);
  case 0x1945a:
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    if (r16[ax] >= memoryAGet16(ds, 0xe6da))
        { pc = 0x1946b; break; }
    r16[ax] = memoryAGet16(ds, 0xe6da);
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
    { pc = 0x1947a; break; }
  case 0x1946b:
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    if (r16[ax] <= memoryAGet16(ds, 0xc747))
        { pc = 0x1947a; break; }
    r16[ax] = memoryAGet16(ds, 0xc747);
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
  case 0x1947a:
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, 0xc74f, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] >>= r8[cl];
    memoryASet16(ds, 0xc74d, r16[ax]);
    r16[di] = 0;
    { pc = 0x194d9; break; }
  case 0x19490:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[si] = memoryAGet16(ds, r16[bx] + 52370);
    if (r16[si] < memoryAGet16(ds, 0xc74f))
        { pc = 0x194b6; break; }
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x000a;
    if (r16[ax] < r16[si])
        { pc = 0x194b6; break; }
    r16[ax] = r16[si];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0100;
    memoryASet16(ss, r16[bp] + 6, r16[ax]);
    { pc = 0x194df; break; }
  case 0x194b6:
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x000b;
    if (r16[ax] > r16[si])
        { pc = 0x194d8; break; }
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x0014;
    if (r16[ax] < r16[si])
        { pc = 0x194d8; break; }
    r16[ax] = r16[si];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0xec00;
    memoryASet16(ss, r16[bp] + 6, r16[ax]);
    { pc = 0x194df; break; }
  case 0x194d8:
    r16[di]++;
  case 0x194d9:
    if (r16s[di] < signed16(memoryAGet16(ds, 0xccaa)))
        { pc = 0x19490; break; }
  case 0x194df:
    r16[di] = 0;
    { pc = 0x1952c; break; }
  case 0x194e3:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[si] = memoryAGet16(ds, r16[bx] + 52382);
    if (r16[si] < memoryAGet16(ds, 0xc74d))
        { pc = 0x19509; break; }
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x0006;
    if (r16[ax] < r16[si])
        { pc = 0x19509; break; }
    r16[ax] = r16[si];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0x0100;
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
    { pc = 0x19532; break; }
  case 0x19509:
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x0007;
    if (r16[ax] > r16[si])
        { pc = 0x1952b; break; }
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x000d;
    if (r16[ax] < r16[si])
        { pc = 0x1952b; break; }
    r16[ax] = r16[si];
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] += 0xf300;
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
    { pc = 0x19532; break; }
  case 0x1952b:
    r16[di]++;
  case 0x1952c:
    if (r16s[di] < signed16(memoryAGet16(ds, 0xccac)))
        { pc = 0x194e3; break; }
  case 0x19532:
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_18e88();
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19630() // 1841:1220 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    if (r16[ax] < memoryAGet16(ds, 0xa53f))
        { pc = 0x19659; break; }
    if (r16[ax] > memoryAGet16(ds, 0xa53f))
        { pc = 0x1964b; break; }
    if (r16[dx] <= memoryAGet16(ds, 0xa53d))
        { pc = 0x19659; break; }
  case 0x1964b:
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    memoryASet16(ds, 0xa53f, r16[ax]);
    memoryASet16(ds, 0xa53d, r16[dx]);
  case 0x19659:
    if (!memoryAGet16(ds, 0x3bd6))
        { pc = 0x196b4; break; }
    r16[ax] = memoryAGet16(ds, 0xa54a);
    r16[dx] = memoryAGet16(ds, 0xa548);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
  case 0x1966d:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    flags.carry = r16[dx] + 0x0006 >= 0x10000;
    r16[dx] += 0x0006;
    r16[ax] += (0x0000 + flags.carry);
    if (r16[ax] > memoryAGet16(ds, 0xa53f))
        { pc = 0x1966d; break; }
    if (r16[ax] != memoryAGet16(ds, 0xa53f))
        { pc = 0x19687; break; }
    if (r16[dx] > memoryAGet16(ds, 0xa53d))
        { pc = 0x1966d; break; }
  case 0x19687:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[dx] = memoryAGet16(ss, r16[bp] - 8);
    flags.carry = r16[dx] + 0x0003 >= 0x10000;
    r16[dx] += 0x0003;
    r16[ax] += (0x0000 + flags.carry);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xa54a);
    flags.carry = r16[dx] + 0x0003 >= 0x10000;
    r16[dx] += 0x0003;
    r16[ax] += (0x0000 + flags.carry);
    memoryASet16(ds, 0xa53f, r16[ax]);
    memoryASet16(ds, 0xa53d, r16[dx]);
    memoryASet16(ds, 0xa54c, 0x0003);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x196b4:
    yield* sync();
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= memoryAGet16(ds, 0xa548);
    memoryASet16(ds, 0xa54c, r16[ax]);
    if (memoryAGet16(ds, 0xa54c) < 0x0002)
        { pc = 0x196b4; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0xa54a, r16[ax]);
    memoryASet16(ds, 0xa548, r16[dx]);
    if (memoryAGet16(ds, 0xa54c) <= 0x0005)
        { pc = 0x196f8; break; }
    r16[ax] = memoryAGet16(ds, 0xa54c);
    r16[ax] -= 0x0005;
    flags.carry = memoryAGet16(ds, 0xa53d) < r16[ax];
    memoryASet16(ds, 0xa53d, memoryAGet16(ds, 0xa53d) - r16[ax]);
    memoryASet16(ds, 0xa53f, memoryAGet16(ds, 0xa53f) - (0x0000 + flags.carry));
    memoryASet16(ds, 0xa54c, 0x0005);
  case 0x196f8:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_196fc() // 1841:12ec +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0;
    { pc = 0x19738; break; }
  case 0x19705:
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    r16[ax] += 0x3c00;
    r16[cx] = r16[ax];
    r16[si] = 0x0001;
    r16[dx] = 0;
    { pc = 0x19728; break; }
  case 0x19719:
    r16[bx] = r16[dx];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 16496) != r16[cx])
        { pc = 0x19727; break; }
    r16[si] = 0;
    { pc = 0x1972d; break; }
  case 0x19727:
    r16[dx]++;
  case 0x19728:
    if (r16[dx] < 0x0003)
        { pc = 0x19719; break; }
  case 0x1972d:
    if (!r16[si])
        { pc = 0x19737; break; }
    r16[ax] = r16[cx];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x19737:
    r16[di]++;
  case 0x19738:
    if (r16[di] < 0x0003)
        { pc = 0x19705; break; }
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19743() // 1841:1333 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_19435();
    sp += 0x0004;
    push(cs);
    yield* sub_18af2();
    r16[ax] = memoryAGet16(ds, 0xdeb2);
    memoryASet16(ds, 0xdeb6, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xdeb4);
    memoryASet16(ds, 0xdeb8, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57014);
    memoryASet16(ds, 0xe6d8, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xdeb6);
    r16[ax] += 0x0015;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xdeb8);
    r16[ax] += 0x0015;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[di] = 0;
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x197d2; break; }
  case 0x19790:
    r16[si] = 0;
    { pc = 0x197b5; break; }
  case 0x19794:
    push(r16[di]);
    push(cs); cs = 0x1a13; yield* sub_1a13c(); assert(cs == 0x1841);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ds, 0xc74d);
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc74f);
    push(r16[ax]);
    push(cs);
    yield* sub_18b2a();
    sp += 0x0004;
    r16[di]++;
    r16[si]++;
  case 0x197b5:
    if (r16s[si] < signed16(0x0015))
        { pc = 0x19794; break; }
    r16[di]++;
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r8[al] = 0x00;
    memoryASet(ds, r16[bx], r8[al]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet(ds, r16[bx], r8[al]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0016);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) + 0x0016);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x197d2:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x000e))
        { pc = 0x19790; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = 0x0301;
    memoryASet16(ds, r16[bx] - 21, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, r16[bx] - 21, r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_197ed() // 1841:13dd +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0020;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0xc74f);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7b0);
    memoryASet16(ss, r16[bp] - 24, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe6ec);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_18f71();
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] ^= r16[dx];
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    r16[ax] ^= r16[dx];
    r16[ax] -= r16[dx];
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) > signed16(0x0001))
        { pc = 0x19848; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) <= signed16(0x0001))
        { pc = 0x1985d; break; }
  case 0x19848:
    push(memoryAGet16(ds, 0xc751));
    push(memoryAGet16(ds, 0xc753));
    push(cs);
    yield* sub_19743();
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1985d:
    if (memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x1986c; break; }
    if (memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1986c; break; }
    { pc = 0x19a4b; break; }
  case 0x1986c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x04;
    r16[ax] <<= r8[cl];
    r8[cl] = 0x06;
    r16[ax] <<= r8[cl];
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] <<= 1;
    r16[ax] += r16[dx];
    memoryASet16(ss, r16[bp] - 32, r16[ax]);
    r16[si] = 0;
    { pc = 0x19908; break; }
  case 0x19886:
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] - 32);
    memoryASet16(ds, r16[bx] + 16496, memoryAGet16(ds, r16[bx] + 16496) + r16[ax]);
    if (!memoryAGet16(ds, 0xe6e8))
        { pc = 0x19907; break; }
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    if (memoryAGet16(ds, r16[bx] + 16496) <= 0xc400)
        { pc = 0x19907; break; }
    if (signed16(memoryAGet16(ss, r16[bp] - 32)) <= signed16(0x0000))
        { pc = 0x198af; break; }
    r16[ax] = 0x4c00;
    { pc = 0x198b2; break; }
  case 0x198af:
    r16[ax] = 0xb400;
  case 0x198b2:
    memoryASet16(ss, r16[bp] - 30, r16[ax]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 32);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    r16[ax] += memoryAGet16(ss, r16[bp] - 30);
    memoryASet16(ss, r16[bp] - 28, r16[ax]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] += memoryAGet16(ss, r16[bp] - 32);
    memoryASet16(ds, r16[bx] + 16496, r16[ax]);
    r16[ax] = 0x00e0;
    push(r16[ax]);
    r16[ax] = 0x002a;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 28));
    push(memoryAGet16(ss, r16[bp] - 26));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x1841);
    sp += 0x0008;
    if (r16[si] != memoryAGet16(ds, 0xdda4))
        { pc = 0x19907; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] &= memoryAGet16(ds, 0xdda6);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 28);
    r16[ax] += memoryAGet16(ss, r16[bp] - 24);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x1841);
    sp += 0x0004;
  case 0x19907:
    r16[si]++;
  case 0x19908:
    if (r16s[si] >= signed16(0x0003))
        { pc = 0x19910; break; }
    { pc = 0x19886; break; }
  case 0x19910:
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x4074);
    memoryASet16(ds, 0xa546, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 4) != 0x0001)
        { pc = 0x19942; break; }
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) + 0x0016);
    { pc = 0x1994c; break; }
  case 0x19942:
    if (memoryAGet16(ss, r16[bp] - 4) != 0xffff)
        { pc = 0x1994c; break; }
    memoryASet16(ss, r16[bp] - 14, memoryAGet16(ss, r16[bp] - 14) - 0x0016);
  case 0x1994c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ds, 0xdeb6, memoryAGet16(ds, 0xdeb6) + r16[ax]);
    memoryASet16(ds, 0xdeb8, memoryAGet16(ds, 0xdeb8) + r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x199c6; break; }
    if (memoryAGet16(ss, r16[bp] - 2) != 0x0001)
        { pc = 0x1997c; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    yield* sub_19072();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax]--;
    push(r16[ax]);
    push(cs);
    yield* sub_18c78();
    sp += 0x0002;
    { pc = 0x19995; break; }
  case 0x1997c:
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs);
    yield* sub_19072();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc74f);
    r16[ax] += 0x0015;
    push(r16[ax]);
    push(cs);
    yield* sub_18c78();
    sp += 0x0002;
  case 0x19995:
    r16[ax] = memoryAGet16(ds, 0xdeb6);
    r16[ax] += 0x0015;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0xdeb8);
    r16[ax] += 0x0015;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    memoryASet16(ss, r16[bp] - 16, 0x0000);
    { pc = 0x199c0; break; }
  case 0x199ad:
    r16[bx] = memoryAGet16(ss, r16[bp] - 20);
    r8[al] = 0x00;
    memoryASet(ds, r16[bx], r8[al]);
    memoryASet(ds, r16[di], r8[al]);
    r16[di] += 0x0016;
    memoryASet16(ss, r16[bp] - 20, memoryAGet16(ss, r16[bp] - 20) + 0x0016);
    memoryASet16(ss, r16[bp] - 16, memoryAGet16(ss, r16[bp] - 16) + 1);
  case 0x199c0:
    if (signed16(memoryAGet16(ss, r16[bp] - 16)) < signed16(0x000e))
        { pc = 0x199ad; break; }
  case 0x199c6:
    if (!memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x19a23; break; }
    if (memoryAGet16(ss, r16[bp] - 4) != 0x0001)
        { pc = 0x199f0; break; }
    memoryASet16(ss, r16[bp] - 18, 0x011e);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs);
    yield* sub_19072();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax]--;
    push(r16[ax]);
    push(cs);
    yield* sub_18cbb();
    sp += 0x0002;
    { pc = 0x19a0d; break; }
  case 0x199f0:
    memoryASet16(ss, r16[bp] - 18, 0x0000);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_19072();
    sp += 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc74d);
    r16[ax] += 0x000e;
    push(r16[ax]);
    push(cs);
    yield* sub_18cbb();
    sp += 0x0002;
  case 0x19a0d:
    r16[bx] = memoryAGet16(ds, 0xdeb8);
    r16[bx] += memoryAGet16(ss, r16[bp] - 18);
    r8[al] = 0x00;
    memoryASet(ds, r16[bx] + 21, r8[al]);
    r16[bx] = memoryAGet16(ds, 0xdeb6);
    r16[bx] += memoryAGet16(ss, r16[bp] - 18);
    memoryASet(ds, r16[bx] + 21, r8[al]);
  case 0x19a23:
    r16[ax] = memoryAGet16(ds, 0xdeb6);
    r16[ax] += 0x0133;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0xdeb8);
    r16[ax] += 0x0133;
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 20);
    r8[al] = 0x00;
    memoryASet(ds, r16[bx], r8[al]);
    memoryASet(ds, r16[di], r8[al]);
    memoryASet16(ss, r16[bp] - 20, memoryAGet16(ss, r16[bp] - 20) + 1);
    r16[di]++;
    r16[bx] = memoryAGet16(ss, r16[bp] - 20);
    r16[ax] = 0x0301;
    memoryASet16(ds, r16[bx], r16[ax]);
    memoryASet16(ds, r16[di], r16[ax]);
  case 0x19a4b:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19a51() // 1841:1641 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0064;
    push(r16[si]);
    push(r16[di]);
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x19a65; break; }
    if (memoryAGet16(ss, r16[bp] + 12) != 0xffff)
        { pc = 0x19a76; break; }
  case 0x19a65:
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_19c6b();
    sp += 0x0002;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x19a76:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ds, r16[bx]);
    if (!r16[si])
        { pc = 0x19ae3; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 26)) >= signed16(0x0002))
        { pc = 0x19ac5; break; }
    if (memoryAGet16(ds, r16[si] + 26))
        { pc = 0x19aa8; break; }
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(r16[si]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52398);
    memoryASet16(ds, r16[bx] + 52398, memoryAGet16(ds, r16[bx] + 52398) + 0x0008);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bac(); assert(cs == 0x1841);
    sp += 0x0006;
  case 0x19aa8:
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(r16[si]);
    r16[bx] = memoryAGet16(ds, 0xdda4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52398);
    memoryASet16(ds, r16[bx] + 52398, memoryAGet16(ds, r16[bx] + 52398) + 0x0008);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bac(); assert(cs == 0x1841);
    sp += 0x0006;
  case 0x19ac5:
    r16[ax] = memoryAGet16(ds, r16[si] + 24);
    if (r16[ax] == memoryAGet16(ss, r16[bp] + 16))
        { pc = 0x19b30; break; }
    r16[di] = memoryAGet16(ds, r16[si] + 30);
    if (!r16[di])
        { pc = 0x19ada; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 28);
    memoryASet16(ds, r16[di] + 28, r16[ax]);
  case 0x19ada:
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    memoryASet16(ds, r16[bx], r16[di]);
    { pc = 0x19b04; break; }
    // gap 2 bytes
  case 0x19ae3:
    if (memoryAGet16(ds, 0xd618))
        { pc = 0x19af6; break; }
    r16[ax] = 0x42c1;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x19af6:
    r16[si] = memoryAGet16(ds, 0xd618);
    r16[bx] = memoryAGet16(ds, 0xd618);
    r16[ax] = memoryAGet16(ds, r16[bx] + 30);
    memoryASet16(ds, 0xd618, r16[ax]);
  case 0x19b04:
    r16[bx] = memoryAGet16(ss, r16[bp] + 16);
    r16[bx] <<= 1;
    r16[di] = memoryAGet16(ds, r16[bx] + 54810);
    if (!r16[di])
        { pc = 0x19b19; break; }
    r16[ax] = r16[si];
    r16[ax] += 0x001e;
    memoryASet16(ds, r16[di] + 28, r16[ax]);
  case 0x19b19:
    memoryASet16(ds, r16[si] + 30, r16[di]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 16);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 54810, r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 16);
    r16[ax] <<= 1;
    r16[ax] += 0xd61a;
    memoryASet16(ds, r16[si] + 28, r16[ax]);
  case 0x19b30:
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] -= 0x007c;
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 12);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x19b96; break; }
    r16[ax] = 0x42ef;
    push(r16[ax]);
    r16[ax] = r16[bp] - 100;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 20;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 12));
    push(cs); cs = 0x01ed; yield* sub_3b3f(); assert(cs == 0x1841);
    sp += 0x0006;
    r16[ax] = r16[bp] - 20;
    push(r16[ax]);
    r16[ax] = r16[bp] - 100;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_4151(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[ax] = r16[bp] - 100;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1841);
    sp += 0x0002;
  case 0x19b96:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 6);
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) + r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    if (!memoryAGet16(ds, 0x7ade))
        { pc = 0x19bbf; break; }
    memoryASet16(ss, r16[bp] - 8, 0x0000);
    { pc = 0x19bca; break; }
  case 0x19bbf:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] &= 0x0007;
    r16[ax] >>= 1;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
  case 0x19bca:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet16(ds, r16[si], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r8[cl] = 0x04;
    r16[ax] >>= r8[cl];
    memoryASet16(ds, r16[si] + 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    memoryASet16(ds, r16[si] + 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ds, r16[si] + 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, r16[si] + 8, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] <<= 1;
    es = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, r16[si] + 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ds, r16[si] + 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ds, r16[si] + 14, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 16);
    memoryASet16(ds, r16[si] + 24, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r8[cl] = memoryAGet(ds, 0xe1ea);
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ds, r16[si] + 16, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ds, r16[si] + 18, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ds, r16[si] + 4);
    r16[ax]--;
    r8[cl] = memoryAGet(ds, 0xe1ea);
    r16[ax] = sar16(r16[ax], r8[cl]);
    r16[ax] -= memoryAGet16(ds, r16[si] + 16);
    r16[ax]++;
    memoryASet16(ds, r16[si] + 20, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] += memoryAGet16(ds, r16[si] + 6);
    r16[ax]--;
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    r16[ax] -= memoryAGet16(ds, r16[si] + 18);
    r16[ax]++;
    memoryASet16(ds, r16[si] + 22, r16[ax]);
    memoryASet16(ds, r16[si] + 26, 0x0002);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx], r16[si]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19c6b() // 1841:185b +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ds, r16[di]);
    if (!r16[si])
        { pc = 0x19ced; break; }
    if (signed16(memoryAGet16(ds, r16[si] + 26)) >= signed16(0x0002))
        { pc = 0x19cc2; break; }
    if (memoryAGet16(ds, r16[si] + 26))
        { pc = 0x19ca5; break; }
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(r16[si]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52398);
    memoryASet16(ds, r16[bx] + 52398, memoryAGet16(ds, r16[bx] + 52398) + 0x0008);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bac(); assert(cs == 0x1841);
    sp += 0x0006;
  case 0x19ca5:
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(r16[si]);
    r16[bx] = memoryAGet16(ds, 0xdda4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52398);
    memoryASet16(ds, r16[bx] + 52398, memoryAGet16(ds, r16[bx] + 52398) + 0x0008);
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3bac(); assert(cs == 0x1841);
    sp += 0x0006;
  case 0x19cc2:
    r16[ax] = memoryAGet16(ds, r16[si] + 30);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x19cd7; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 28);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[bx] + 28, r16[ax]);
  case 0x19cd7:
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, r16[bx], r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xd618);
    memoryASet16(ds, r16[si] + 30, r16[ax]);
    memoryASet16(ds, 0xd618, r16[si]);
    memoryASet16(ds, r16[di], 0x0000);
  case 0x19ced:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19cf3() // 1841:18e3 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0016;
    push(r16[si]);
    push(r16[di]);
    if (!memoryAGet16(ds, 0xdda2))
        { pc = 0x19d07; break; }
    r16[ax] = 0xce92;
    { pc = 0x19d0a; break; }
  case 0x19d07:
    r16[ax] = 0xccb2;
  case 0x19d0a:
    r16[si] = r16[ax];
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 52398);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0x19e57; break; }
  case 0x19d1c:
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] -= memoryAGet16(ds, 0xe6e6);
    memoryASet16(ds, r16[si], r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] -= memoryAGet16(ds, 0xe6e4);
    memoryASet16(ds, r16[si] + 2, r16[ax]);
    if (signed16(memoryAGet16(ds, r16[si])) >= signed16(0x0000))
        { pc = 0x19d45; break; }
    r16[ax] = memoryAGet16(ds, r16[si]);
    memoryASet16(ds, r16[si] + 4, memoryAGet16(ds, r16[si] + 4) + r16[ax]);
    if (signed16(memoryAGet16(ds, r16[si] + 4)) >= signed16(0x0001))
        { pc = 0x19d41; break; }
    { pc = 0x19e54; break; }
  case 0x19d41:
    memoryASet16(ds, r16[si], 0x0000);
  case 0x19d45:
    if (signed16(memoryAGet16(ds, r16[si] + 2)) >= signed16(0x0000))
        { pc = 0x19d5f; break; }
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    memoryASet16(ds, r16[si] + 6, memoryAGet16(ds, r16[si] + 6) + r16[ax]);
    if (signed16(memoryAGet16(ds, r16[si] + 6)) >= signed16(0x0001))
        { pc = 0x19d5a; break; }
    { pc = 0x19e54; break; }
  case 0x19d5a:
    memoryASet16(ds, r16[si] + 2, 0x0000);
  case 0x19d5f:
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ds, r16[si] + 4);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] += memoryAGet16(ds, r16[si] + 6);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) <= signed16(0x002a))
        { pc = 0x19d86; break; }
    r16[ax] = 0x002a;
    r16[ax] -= memoryAGet16(ds, r16[si]);
    memoryASet16(ds, r16[si] + 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ds, r16[si] + 4);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0x19d86:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) <= signed16(0x00e0))
        { pc = 0x19d9f; break; }
    r16[ax] = 0x00e0;
    r16[ax] -= memoryAGet16(ds, r16[si] + 2);
    memoryASet16(ds, r16[si] + 6, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] += memoryAGet16(ds, r16[si] + 6);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
  case 0x19d9f:
    if (signed16(memoryAGet16(ds, r16[si] + 4)) >= signed16(0x0001))
        { pc = 0x19da8; break; }
    { pc = 0x19e54; break; }
  case 0x19da8:
    if (signed16(memoryAGet16(ds, r16[si] + 6)) >= signed16(0x0001))
        { pc = 0x19db1; break; }
    { pc = 0x19e54; break; }
  case 0x19db1:
    r16[bx] = memoryAGet16(ds, r16[si] + 2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += memoryAGet16(ds, r16[si]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    push(memoryAGet16(ds, r16[si] + 6));
    push(memoryAGet16(ds, r16[si] + 4));
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa546);
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x1841);
    sp += 0x0008;
    r16[ax] = memoryAGet16(ds, r16[si]);
    r8[cl] = memoryAGet(ds, 0xe1ea);
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ds, r16[si] + 4);
    r16[ax]--;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si] + 2);
    r16[ax] += memoryAGet16(ds, r16[si] + 6);
    r16[ax]--;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 12);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xe6d8);
    r16[ax] += memoryAGet16(ds, r16[bx] + 57836);
    r16[ax] += memoryAGet16(ss, r16[bp] - 10);
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    r16[ax]++;
    r16[dx] = 0x0016;
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 22, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    { pc = 0x19e4c; break; }
  case 0x19e2f:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    { pc = 0x19e3e; break; }
  case 0x19e37:
    memoryASet(ds, r16[di], 0x02);
    r16[di]++;
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
  case 0x19e3e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 14))
        { pc = 0x19e37; break; }
    r16[di] += memoryAGet16(ss, r16[bp] - 22);
    memoryASet16(ss, r16[bp] - 20, memoryAGet16(ss, r16[bp] - 20) + 1);
  case 0x19e4c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 20);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 16))
        { pc = 0x19e2f; break; }
  case 0x19e54:
    r16[si] += 0x0008;
  case 0x19e57:
    if (r16[si] == memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x19e5f; break; }
    { pc = 0x19d1c; break; }
  case 0x19e5f:
    if (!memoryAGet16(ds, 0xdda2))
        { pc = 0x19e6b; break; }
    r16[ax] = 0xce92;
    { pc = 0x19e6e; break; }
  case 0x19e6b:
    r16[ax] = 0xccb2;
  case 0x19e6e:
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 52398, r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_19e7e() // 1841:1a6e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x001c;
    push(r16[si]);
    push(r16[di]);
    memoryASet16(ss, r16[bp] - 18, 0x0000);
    { pc = 0x1a06f; break; }
  case 0x19e8e:
    if (memoryAGet16(ss, r16[bp] - 18) != 0x0003)
        { pc = 0x19e99; break; }
    push(cs); cs = 0x1a13; yield* sub_1a474(); assert(cs == 0x1841);
  case 0x19e99:
    r16[bx] = memoryAGet16(ss, r16[bp] - 18);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 54810);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0x1a063; break; }
  case 0x19ea8:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx]);
    r16[ax] -= memoryAGet16(ds, 0xe6e6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 2);
    r16[ax] -= memoryAGet16(ds, 0xe6e4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = memoryAGet(ds, 0xe1ea);
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 4);
    r16[ax]--;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += memoryAGet16(ds, r16[bx] + 6);
    r16[ax]--;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 16, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) >= signed16(0x0000))
        { pc = 0x19ef7; break; }
    memoryASet16(ss, r16[bp] - 10, 0x0000);
  case 0x19ef7:
    if (signed16(memoryAGet16(ss, r16[bp] - 12)) < signed16(0x0015))
        { pc = 0x19f02; break; }
    memoryASet16(ss, r16[bp] - 12, 0x0014);
  case 0x19f02:
    if (signed16(memoryAGet16(ss, r16[bp] - 14)) >= signed16(0x0000))
        { pc = 0x19f0d; break; }
    memoryASet16(ss, r16[bp] - 14, 0x0000);
  case 0x19f0d:
    if (signed16(memoryAGet16(ss, r16[bp] - 16)) < signed16(0x000e))
        { pc = 0x19f18; break; }
    memoryASet16(ss, r16[bp] - 16, 0x000d);
  case 0x19f18:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 12)))
        { pc = 0x19f23; break; }
    { pc = 0x1a05a; break; }
  case 0x19f23:
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 16)))
        { pc = 0x19f2e; break; }
    { pc = 0x1a05a; break; }
  case 0x19f2e:
    r16[bx] = memoryAGet16(ss, r16[bp] - 14);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xe6d8);
    r16[ax] += memoryAGet16(ds, r16[bx] + 57836);
    r16[ax] += memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(ss, r16[bp] - 22, r16[ax]);
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    r16[ax]++;
    r16[dx] = 0x0016;
    r16[dx] -= r16[ax];
    memoryASet16(ss, r16[bp] - 24, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    if (!memoryAGet16(ds, r16[bx] + 26))
        { pc = 0x19f5f; break; }
    memoryASet16(ds, r16[bx] + 26, memoryAGet16(ds, r16[bx] + 26) - 1);
    { pc = 0x19f8b; break; }
  case 0x19f5f:
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    { pc = 0x19f80; break; }
  case 0x19f67:
    r16[di] = memoryAGet16(ss, r16[bp] - 10);
    { pc = 0x19f75; break; }
  case 0x19f6c:
    r16[bx] = r16[si];
    r16[si]++;
    if (memoryAGet(ds, r16[bx]))
        { pc = 0x19f8b; break; }
    r16[di]++;
  case 0x19f75:
    if (r16s[di] <= signed16(memoryAGet16(ss, r16[bp] - 12)))
        { pc = 0x19f6c; break; }
    r16[si] += memoryAGet16(ss, r16[bp] - 24);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 1);
  case 0x19f80:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 16)))
        { pc = 0x19f67; break; }
    { pc = 0x1a05a; break; }
  case 0x19f8b:
    r16[si] = memoryAGet16(ss, r16[bp] - 22);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    { pc = 0x19fab; break; }
  case 0x19f96:
    r16[di] = memoryAGet16(ss, r16[bp] - 10);
    { pc = 0x19fa0; break; }
  case 0x19f9b:
    memoryASet(ds, r16[si], 0x03);
    r16[si]++;
    r16[di]++;
  case 0x19fa0:
    if (r16s[di] <= signed16(memoryAGet16(ss, r16[bp] - 12)))
        { pc = 0x19f9b; break; }
    r16[si] += memoryAGet16(ss, r16[bp] - 24);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 1);
  case 0x19fab:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 16)))
        { pc = 0x19f96; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx] + 6);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 10);
    memoryASet16(ss, r16[bp] - 28, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) >= signed16(0x0000))
        { pc = 0x19fde; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 26, memoryAGet16(ss, r16[bp] - 26) + r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[bx] + 4);
    imul16(memoryAGet16(ss, r16[bp] - 6));
    memoryASet16(ss, r16[bp] - 28, memoryAGet16(ss, r16[bp] - 28) - r16[ax]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x19ff2; break; }
  case 0x19fde:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += memoryAGet16(ss, r16[bp] - 26);
    if (r16[ax] <= 0x00e0)
        { pc = 0x19ff2; break; }
    r16[ax] = 0x00e0;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 26, r16[ax]);
  case 0x19ff2:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1a015; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1a03a; break; }
    { pc = 0x1a05a; break; }
  case 0x1a015:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(ds, r16[bx] + 12));
    push(memoryAGet16(ss, r16[bp] - 26));
    push(memoryAGet16(ds, r16[bx] + 4));
    push(memoryAGet16(ss, r16[bp] - 20));
    push(memoryAGet16(ss, r16[bp] - 28));
    r16[bx] = memoryAGet16(ds, r16[bx] + 8);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(cs); cs = 0x1ff7; yield* sub_20085(); assert(cs == 0x1841);
    sp += 0x000c;
    { pc = 0x1a05a; break; }
  case 0x1a03a:
    push(memoryAGet16(ss, r16[bp] - 26));
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(ds, r16[bx] + 4));
    push(memoryAGet16(ss, r16[bp] - 20));
    push(memoryAGet16(ss, r16[bp] - 28));
    r16[bx] = memoryAGet16(ds, r16[bx] + 8);
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(cs); cs = 0x1ff7; yield* sub_203b9(); assert(cs == 0x1841);
    sp += 0x000a;
  case 0x1a05a:
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ds, r16[bx] + 30);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x1a063:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1a06c; break; }
    { pc = 0x19ea8; break; }
  case 0x1a06c:
    memoryASet16(ss, r16[bp] - 18, memoryAGet16(ss, r16[bp] - 18) + 1);
  case 0x1a06f:
    if (signed16(memoryAGet16(ss, r16[bp] - 18)) >= signed16(0x0004))
        { pc = 0x1a078; break; }
    { pc = 0x19e8e; break; }
  case 0x1a078:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1a07e() // 1841:1c6e +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[di]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57014);
    memoryASet16(ds, 0xe6d8, r16[ax]);
    push(cs);
    yield* sub_18d56();
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0105;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    push(cs); cs = 0x1a13; yield* sub_1a31a(); assert(cs == 0x1841);
    push(cs);
    yield* sub_19cf3();
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    push(cs);
    yield* sub_19e7e();
    r16[ax] = memoryAGet16(ds, 0xdda8);
    r16[ax] |= memoryAGet16(ds, 0xddaa);
    if (!r16[ax])
        { pc = 0x1a0cb; break; }
    switch (memoryAGet32(ds, 0xdda8))
    {
        case 0x07b10561: push(cs); cs = 0x07b1; yield* sub_8071(); assert(cs == 0x1841); break;
        default:
            stop("ind 1841:1cb7");
    }
  case 0x1a0cb:
    r16[ax] = memoryAGet16(ds, 0xe6ec);
    r16[ax] &= memoryAGet16(ds, 0xdda6);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, 0xa7b0);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x1841);
    sp += 0x0004;
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 57010);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 57014, r16[ax]);
    r16[ax] = ds;
    es = r16[ax];
    r16[ax] = 0;
    r16[cx] = 0x009a;
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    memoryASet16(es, r16[di], 0x0301);
    memoryASet16(ds, 0xdda4, memoryAGet16(ds, 0xdda4) ^ 0x0001);
    memoryASet16(ds, 0xdda2, memoryAGet16(ds, 0xdda2) ^ 0x0001);
    r16[bx] = memoryAGet16(ds, 0xdda2);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b4, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xdda4);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 16496);
    memoryASet16(ds, 0xa7b2, r16[ax]);
    push(cs);
    yield* sub_19630();
    r16[di] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1a13c() // 1a13:000c +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ds, 0xdeb6);
    memoryASet(ds, r16[bx] + r16[di], 0x01);
    r16[bx] = memoryAGet16(ds, 0xdeb8);
    memoryASet(ds, r16[bx] + r16[di], 0x01);
    r16[di] <<= 1;
    r16[si] = memoryAGet16(ds, r16[di] + 57864);
    r16[si] += memoryAGet16(ds, 0xe1e8);
    r16[di] = memoryAGet16(ds, r16[di] + 58480);
    r16[di] += memoryAGet16(ds, 0xa546);
    memoryASet16(cs, 0x000a, r16[di]);
    es = memoryAGet16(ds, 0xa7e9);
    r16[bx] = memoryAGet16(es, r16[si]);
    es = memoryAGet16(ds, 0xa7e7);
    r16[si] = memoryAGet16(es, r16[si]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[dx] = 0x03c4;
    if (!r16[bx])
        { pc = 0x1a185; break; }
    { pc = 0x1a1dd; break; }
    // gap 1 bytes
  case 0x1a185:
    r16[bx] = 0x003e;
    r16[si] <<= 1;
    r16[ax] = memoryAGet16(cs, 0x000a);
    ds = memoryAGet16(ds, r16[si] + 32515);
    r16[si] = 0;
    r16[ax] = 0x0102;
    r16[cx] = 0x0004;
  case 0x1a19a:
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(cs, 0x000a);
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    movsw_ESDI_DSSI();
    r8[ah] <<= 1;
    if (--r16[cx])
        { pc = 0x1a19a; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1a1dd:
    flags.interrupts = 0;
    r16[bx] <<= 1;
    ss = memoryAGet16(ds, r16[bx] + 35107);
    r16[si] <<= 1;
    ds = memoryAGet16(ds, r16[si] + 32515);
    r16[si] = 0;
    r16[ax] = 0x0102;
    r16[di] = memoryAGet16(cs, 0x000a);
  case 0x1a1f4:
    out16(r16[dx], r16[ax]);
    r16[bx] = memoryAGet16(ds, r16[si]);
    r16[bx] &= memoryAGet16(ss, 0x0000);
    r16[bx] |= memoryAGet16(ss, r16[si] + 32);
    memoryASet16(es, r16[di], r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 2);
    r16[bx] &= memoryAGet16(ss, 0x0002);
    r16[bx] |= memoryAGet16(ss, r16[si] + 34);
    memoryASet16(es, r16[di] + 64, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 4);
    r16[bx] &= memoryAGet16(ss, 0x0004);
    r16[bx] |= memoryAGet16(ss, r16[si] + 36);
    memoryASet16(es, r16[di] + 128, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 6);
    r16[bx] &= memoryAGet16(ss, 0x0006);
    r16[bx] |= memoryAGet16(ss, r16[si] + 38);
    memoryASet16(es, r16[di] + 192, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 8);
    r16[bx] &= memoryAGet16(ss, 0x0008);
    r16[bx] |= memoryAGet16(ss, r16[si] + 40);
    memoryASet16(es, r16[di] + 256, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 10);
    r16[bx] &= memoryAGet16(ss, 0x000a);
    r16[bx] |= memoryAGet16(ss, r16[si] + 42);
    memoryASet16(es, r16[di] + 320, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 12);
    r16[bx] &= memoryAGet16(ss, 0x000c);
    r16[bx] |= memoryAGet16(ss, r16[si] + 44);
    memoryASet16(es, r16[di] + 384, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 14);
    r16[bx] &= memoryAGet16(ss, 0x000e);
    r16[bx] |= memoryAGet16(ss, r16[si] + 46);
    memoryASet16(es, r16[di] + 448, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 16);
    r16[bx] &= memoryAGet16(ss, 0x0010);
    r16[bx] |= memoryAGet16(ss, r16[si] + 48);
    memoryASet16(es, r16[di] + 512, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 18);
    r16[bx] &= memoryAGet16(ss, 0x0012);
    r16[bx] |= memoryAGet16(ss, r16[si] + 50);
    memoryASet16(es, r16[di] + 576, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 20);
    r16[bx] &= memoryAGet16(ss, 0x0014);
    r16[bx] |= memoryAGet16(ss, r16[si] + 52);
    memoryASet16(es, r16[di] + 640, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 22);
    r16[bx] &= memoryAGet16(ss, 0x0016);
    r16[bx] |= memoryAGet16(ss, r16[si] + 54);
    memoryASet16(es, r16[di] + 704, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 24);
    r16[bx] &= memoryAGet16(ss, 0x0018);
    r16[bx] |= memoryAGet16(ss, r16[si] + 56);
    memoryASet16(es, r16[di] + 768, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 26);
    r16[bx] &= memoryAGet16(ss, 0x001a);
    r16[bx] |= memoryAGet16(ss, r16[si] + 58);
    memoryASet16(es, r16[di] + 832, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 28);
    r16[bx] &= memoryAGet16(ss, 0x001c);
    r16[bx] |= memoryAGet16(ss, r16[si] + 60);
    memoryASet16(es, r16[di] + 896, r16[bx]);
    r16[bx] = memoryAGet16(ds, r16[si] + 30);
    r16[bx] &= memoryAGet16(ss, 0x001e);
    r16[bx] |= memoryAGet16(ss, r16[si] + 62);
    memoryASet16(es, r16[di] + 960, r16[bx]);
    r16[si] += 0x0020;
    r8[ah] <<= 1;
    if (r8[ah] == 0x10)
        { pc = 0x1a30e; break; }
    { pc = 0x1a1f4; break; }
  case 0x1a30e:
    r16[ax] = 0x30d4;
    ss = r16[ax];
    flags.interrupts = 1;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1a31a() // 1a13:01ea +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    push(r16[di]);
    push(r16[bp]);
    { pc = 0x1a323; break; }
  case 0x1a31f:
    r16[bp] = pop();
    r16[di] = pop();
    r16[si] = pop();
    sp += 2; cs = pop(); return;
  case 0x1a323:
    r16[di] = memoryAGet16(ds, 0xe6d8);
    r16[bp] = 0x0135;
    r16[bp] += r16[di];
    push(r16[di]);
    r16[cx] = 0xffff;
  case 0x1a330:
    r16[di] = pop();
    r16[ax] = ss;
    es = r16[ax];
    ds = r16[ax];
    r8[al] = 0x01;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    if (r16[di] == r16[bp])
        { pc = 0x1a31f; break; }
    if (memoryAGet(ds, r16[di]) != r8[al])
        { pc = 0x1a346; break; }
    { pc = 0x1a3c6; break; }
  case 0x1a346:
    r16[di]++;
    push(r16[di]);
    r16[di] -= memoryAGet16(ds, 0xe6d8);
    r16[di] <<= 1;
    r16[di] = memoryAGet16(ds, r16[di] + 58476);
    r16[si] = r16[di];
    r16[di] += memoryAGet16(ds, 0xa7b4);
    r16[si] += memoryAGet16(ds, 0xa546);
    r16[dx] = 0x003e;
    r16[ax] = memoryAGet16(ds, 0xa7ae);
    ds = r16[ax];
    es = r16[ax];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    { pc = 0x1a330; break; }
    // gap 1 bytes
  case 0x1a3c6:
    r16[dx] = r16[di];
    r16[di]++;
    for (flags.zero = 1; r16[cx] != 0 && flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    push(r16[di]);
    r16[bx] = r16[di];
    r16[bx] -= r16[dx];
    r16[bx] <<= 1;
    r16[di] = r16[dx];
    r16[di] -= memoryAGet16(ds, 0xe6d8);
    r16[di] <<= 1;
    r16[di] = memoryAGet16(ds, r16[di] + 58478);
    r16[si] = r16[di];
    r16[di] += memoryAGet16(ds, 0xa7b4);
    r16[si] += memoryAGet16(ds, 0xa546);
    r16[dx] = 0x0040;
    r16[dx] -= r16[bx];
    r16[ax] = memoryAGet16(ds, 0xa7ae);
    ds = r16[ax];
    es = r16[ax];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[cx]--;
    { pc = 0x1a330; break; }
    return;
  }
}
function* sub_1a474() // 1a13:0344 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    push(r16[di]);
    push(r16[bp]);
    { pc = 0x1a47d; break; }
  case 0x1a479:
    r16[bp] = pop();
    r16[di] = pop();
    r16[si] = pop();
    sp += 2; cs = pop(); return;
  case 0x1a47d:
    r16[di] = memoryAGet16(ds, 0xe6d8);
    r16[bp] = 0x0136;
    r16[bp] += r16[di];
    push(r16[di]);
    r16[cx] = 0xffff;
  case 0x1a48a:
    r16[ax] = ss;
    es = r16[ax];
    r8[al] = 0x03;
    r16[di] = pop();
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    if (r16[di] == r16[bp])
        { pc = 0x1a479; break; }
    push(r16[di]);
    r16[di] -= memoryAGet16(ds, 0xe6d8);
    r16[di] <<= 1;
    r16[si] = memoryAGet16(ds, r16[di] + 57862);
    r16[si] += memoryAGet16(ds, 0xe1e8);
    es = memoryAGet16(ds, 0xa7e9);
    r16[si] = memoryAGet16(es, r16[si]);
    if (!r16[si])
        { pc = 0x1a48a; break; }
    r16[bx] = r16[si];
    r16[bx] += 0x44a6;
    es = memoryAGet16(ds, 0xc8a1);
    if (!(memoryAGet(es, r16[bx]) & 0x80))
        { pc = 0x1a48a; break; }
    memoryASet(ds, 0x431a, 0x01);
    memoryASet(ds, 0x431b, 0x00);
    r16[di] = memoryAGet16(ds, r16[di] + 58478);
    r16[di] += memoryAGet16(ds, 0xa7b4);
    memoryASet16(cs, 0x000a, r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[si] <<= 1;
    ds = memoryAGet16(ds, r16[si] + 35107);
    r16[bx] = 0x0020;
  case 0x1a4e5:
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
    r8[ah] = memoryAGet(ss, 0x431a);
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r8[al] = 0x04;
    r8[ah] = memoryAGet(ss, 0x431b);
    out16(r16[dx], r16[ax]);
    r16[si] = 0;
    r16[di] = memoryAGet16(cs, 0x000a);
    r16[cx] = memoryAGet16(es, r16[di]);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di], r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 64);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 64, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 128);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 128, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 192);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 192, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 256);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 256, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 320);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 320, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 384);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 384, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 448);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 448, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 512);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 512, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 576);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 576, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 640);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 640, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 704);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 704, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 768);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 768, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 832);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 832, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 896);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 896, r16[cx]);
    r16[cx] = memoryAGet16(es, r16[di] + 960);
    r16[cx] &= memoryAGet16(ds, r16[si]);
    r16[cx] |= memoryAGet16(ds, r16[bx] + r16[si]);
    r16[si]++;
    r16[si]++;
    memoryASet16(es, r16[di] + 960, r16[cx]);
    r16[bx] += 0x0020;
    memoryASet(ss, 0x431b, memoryAGet(ss, 0x431b) + 1);
    memoryASet(ss, 0x431a, memoryAGet(ss, 0x431a) << 1);
    if (memoryAGet(ss, 0x431a) == 0x10)
        { pc = 0x1a614; break; }
    { pc = 0x1a4e5; break; }
  case 0x1a614:
    r16[ax] = ss;
    ds = r16[ax];
    r16[cx] = 0xffff;
    { pc = 0x1a48a; break; }
    return;
  }
}
function* sub_1a61e() // 1a61:000e +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x0043;
    r8[al] = 0x36;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x0040;
    r8[al] = r8[bl];
    out8(r16[dx], r8[al]);
    r16[ax] = r16[bx];
    r8[cl] = 0x08;
    r16[ax] >>= r8[cl];
    out8(r16[dx], r8[al]);
    memoryASet16(ds, 0x789a, 0x0000);
    memoryASet16(ds, 0x7898, r16[bx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a643() // 1a61:0033 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 6));
    r16[ax] = 0x0012;
    r16[dx] = 0x305e;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x1a61);
    push(r16[ax]);
    push(cs);
    yield* sub_1a61e();
    sp += 0x0002;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a68b() // 1a61:007b +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(flagAsReg());
    flags.interrupts = 0;
    memoryASet(ds, 0x7882, 0xff);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, 0x787c, r16[ax]);
    memoryASet16(ds, 0x787a, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] += 0x0006;
    memoryASet16(ds, 0x7880, r16[ax]);
    memoryASet16(ds, 0x787e, r16[dx]);
    flagsFromReg(pop());
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a6b9() // 1a61:00a9 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(flagAsReg());
    flags.interrupts = 0;
    memoryASet16(ds, 0x7880, 0x0000);
    memoryASet16(ds, 0x787e, 0x0000);
    r8[al] = in8(0x61);
    r8[al] &= 0xfd;
    out8(0x61, r8[al]);
    flagsFromReg(pop());
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a754() // 1a61:0144 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(flagAsReg());
    flags.interrupts = 0;
    memoryASet16(ds, 0x7880, 0x0000);
    memoryASet16(ds, 0x787e, 0x0000);
    r8[al] = in8(0x61);
    r8[al] &= 0xfc;
    out8(0x61, r8[al]);
    flagsFromReg(pop());
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a76e() // 1a61:015e +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(flagAsReg());
    flags.interrupts = 0;
    r16[dx] = 0x0388;
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    out8(r16[dx], r8[al]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r16[dx] = 0x0389;
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    out8(r16[dx], r8[al]);
    flagsFromReg(pop());
    r16[dx] = 0x0388;
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a7b0() // 1a61:01a0 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(flagAsReg());
    flags.interrupts = 0;
    memoryASet16(ds, 0x7678, 0x0000);
    memoryASet16(ds, 0x7676, 0x0000);
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0xb0;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    flagsFromReg(pop());
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1a7d1() // 1a61:01c1 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r8[al] = memoryAGet(ds, 0x432d);
    memoryASet(ss, r16[bp] - 2, r8[al]);
    r8[al] = memoryAGet(ds, 0x4324);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx]);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0x20;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 2);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0x40;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 4);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0x60;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 6);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0x80;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 8);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0xe0;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 1);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    r8[al] += 0x20;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 3);
    memoryASet(ss, r16[bp] - 3, r8[al]);
    if (!memoryAGet16(ds, 0xc637))
        { pc = 0x1a893; break; }
    r8[al] = 0x3f;
    r8[al] -= memoryAGet(ss, r16[bp] - 3);
    memoryASet(ss, r16[bp] - 3, r8[al]);
    r8[ah] = 0x00;
    r16[ax] = sar16(r16[ax], 0x0001);
    r8[dl] = memoryAGet(ss, r16[bp] - 3);
    r8[dh] = 0x00;
    r16[dx] = sar16(r16[dx], 0x0001);
    r16[dx] = sar16(r16[dx], 0x0001);
    r8[al] += r8[dl];
    memoryASet(ss, r16[bp] - 3, r8[al]);
    r8[al] = 0x3f;
    r8[al] -= memoryAGet(ss, r16[bp] - 3);
    memoryASet(ss, r16[bp] - 3, r8[al]);
  case 0x1a893:
    r8[al] = memoryAGet(ss, r16[bp] - 3);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    r8[al] += 0x40;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 5);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    r8[al] += 0x60;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 7);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    r8[al] += 0x80;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx] + 9);
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    r8[al] += 0xe0;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1a8e7() // 1a61:02d7 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(cs);
    yield* sub_1a7b0();
    push(flagAsReg());
    flags.interrupts = 0;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[dx] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, 0x7672, r16[ax]);
    memoryASet16(ds, 0x7670, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] += 0x0017;
    memoryASet16(ds, 0x7678, r16[ax]);
    memoryASet16(ds, 0x7676, r16[dx]);
    r8[al] = memoryAGet(es, r16[bx] + 22);
    r8[ah] = 0x00;
    r16[ax] &= 0x0007;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] |= 0x0020;
    memoryASet16(ds, 0x7674, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] += 0x0006;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r8[al] = memoryAGet(es, r16[bx] + 6);
    r8[al] |= memoryAGet(es, r16[bx] + 7);
    r8[ah] = 0x00;
    if (r16[ax])
        { pc = 0x1a954; break; }
    flagsFromReg(pop());
    r16[ax] = 0x434d;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1a61);
    sp += 0x0002;
  case 0x1a954:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs);
    yield* sub_1a7d1();
    sp += 0x0004;
    flagsFromReg(pop());
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1aaa1() // 1a61:0491 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(flagAsReg());
    flags.interrupts = 0;
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0xbd;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0xb0;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    push(ds);
    r16[ax] = 0x765c;
    push(r16[ax]);
    push(cs);
    yield* sub_1a7d1();
    sp += 0x0004;
    memoryASet16(ds, 0x7678, 0x0000);
    memoryASet16(ds, 0x7676, 0x0000);
    flagsFromReg(pop());
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1aadb() // 1a61:04cb +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(flagAsReg());
    flags.interrupts = 0;
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0xbd;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, 0x0001);
    { pc = 0x1ab08; break; }
  case 0x1aaf7:
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x1ab08:
    if (signed16(memoryAGet16(ss, r16[bp] - 2)) < signed16(0x00f5))
        { pc = 0x1aaf7; break; }
    flagsFromReg(pop());
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ab14() // 1a61:0504 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0x7658, 0x0000);
    r8[al] = memoryAGet(ds, 0x7658);
    push(r16[ax]);
    r8[al] = 0xbd;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    push(ds);
    r16[ax] = 0x765c;
    push(r16[ax]);
    push(cs);
    yield* sub_1a7d1();
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1ab39() // 1a61:0529 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r8[al] = 0x60;
    push(r16[ax]);
    r8[al] = 0x04;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r8[al] = 0x80;
    push(r16[ax]);
    r8[al] = 0x04;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[dx] = 0x0388;
    r8[al] = in8(r16[dx]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    r8[al] = 0xff;
    push(r16[ax]);
    r8[al] = 0x02;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r8[al] = 0x21;
    push(r16[ax]);
    r8[al] = 0x04;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[dx] = 0x0388;
    r16[cx] = 0x0064;
  case 0x1ab80:
    r8[al] = in8(r16[dx]);
    { pc = 0x1ab83; break; }
  case 0x1ab83:
    if (--r16[cx])
        { pc = 0x1ab80; break; }
    r16[dx] = 0x0388;
    r8[al] = in8(r16[dx]);
    memoryASet(ss, r16[bp] - 2, r8[al]);
    r8[al] = 0x60;
    push(r16[ax]);
    r8[al] = 0x04;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r8[al] = 0x80;
    push(r16[ax]);
    r8[al] = 0x04;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    if (memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x1abbf; break; }
    if (memoryAGet(ss, r16[bp] - 1) & 0xe0)
        { pc = 0x1abff; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[ah] = 0x00;
    r16[ax] &= 0x00e0;
    if (r16[ax] != 0x00c0)
        { pc = 0x1abff; break; }
  case 0x1abbf:
    memoryASet16(ss, r16[bp] - 4, 0x0001);
    { pc = 0x1abd7; break; }
  case 0x1abc6:
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 4);
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x1abd7:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) <= signed16(0x00f5))
        { pc = 0x1abc6; break; }
    r8[al] = 0x20;
    push(r16[ax]);
    r8[al] = 0x01;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0x08;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    r16[ax] = 0x0001;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1abff:
    r16[ax] = 0;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ace7() // 1a61:06d7 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (r16[ax] == 0x0001)
        { pc = 0x1acf9; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1acff; break; }
    { pc = 0x1ad03; break; }
  case 0x1acf9:
    push(cs);
    yield* sub_1a754();
    { pc = 0x1ad03; break; }
  case 0x1acff:
    push(cs);
    yield* sub_1aaa1();
  case 0x1ad03:
    memoryASet16(ds, 0xc635, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ad0b() // 1a61:06fb +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (memoryAGet16(ds, 0xc635) == 0x0002)
        { pc = 0x1ad1c; break; }
    if (memoryAGet16(ds, 0xc633) != 0x0001)
        { pc = 0x1ad20; break; }
  case 0x1ad1c:
    push(cs);
    yield* sub_1aadb();
  case 0x1ad20:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ad22() // 1a61:0712 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (r16[ax] == 0x0002)
        { pc = 0x1ad2f; break; }
    { pc = 0x1ad33; break; }
  case 0x1ad2f:
    push(cs);
    yield* sub_1ab14();
  case 0x1ad33:
    r16[ax] = 0;
    memoryASet16(ds, 0x788c, r16[ax]);
    memoryASet16(ds, 0x788e, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ad3d() // 1a61:072d +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    if (memoryAGet16(ds, 0xc633) != 0x0001)
        { pc = 0x1ad4d; break; }
    r16[si] = 0x0230;
    { pc = 0x1ad50; break; }
  case 0x1ad4d:
    r16[si] = 0x008c;
  case 0x1ad50:
    push(r16[si]);
    push(cs);
    yield* sub_1a643();
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ad5b() // 1a61:074b +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    push(cs);
    yield* sub_1b0e7();
    r16[ax] = r16[di];
    if (!r16[ax])
        { pc = 0x1ad7d; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1ad88; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1ad98; break; }
    { pc = 0x1adb1; break; }
  case 0x1ad7d:
    memoryASet16(ds, 0xe6f6, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1adb3; break; }
  case 0x1ad88:
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    memoryASet16(ds, 0xe6f6, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1adb3; break; }
  case 0x1ad98:
    if (!memoryAGet16(ds, 0xc639))
        { pc = 0x1adb3; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0034);
    memoryASet16(ds, 0xe6f6, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1adb3; break; }
    // gap 2 bytes
  case 0x1adb1:
    r16[si] = 0;
  case 0x1adb3:
    if (!r16[si])
        { pc = 0x1add4; break; }
    if (r16[di] == memoryAGet16(ds, 0xc635))
        { pc = 0x1add4; break; }
    push(cs);
    yield* sub_1ace7();
    memoryASet16(ds, 0xc635, r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] <<= 1;
    r16[ax] += 0xc75d;
    memoryASet16(ds, 0xe6f2, r16[ax]);
    push(cs);
    yield* sub_1ad22();
  case 0x1add4:
    push(cs);
    yield* sub_1ad3d();
    r16[ax] = r16[si];
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ade0() // 1a61:07d0 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    push(cs);
    yield* sub_1b1c4();
  case 0x1aded:
    push(cs);
    yield* sub_1b1d7();
    if (r16[ax])
        { pc = 0x1aded; break; }
    r16[ax] = r16[di];
    if (!r16[ax])
        { pc = 0x1ae03; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1ae0e; break; }
    { pc = 0x1ae22; break; }
  case 0x1ae03:
    memoryASet16(ds, 0xe6fc, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1ae24; break; }
  case 0x1ae0e:
    if (!memoryAGet16(ds, 0xc639))
        { pc = 0x1ae24; break; }
    memoryASet16(ds, 0xe6fc, 0x0001);
    r16[si] = 0x0001;
    { pc = 0x1ae24; break; }
    // gap 2 bytes
  case 0x1ae22:
    r16[si] = 0;
  case 0x1ae24:
    if (!r16[si])
        { pc = 0x1ae2c; break; }
    memoryASet16(ds, 0xc633, r16[di]);
  case 0x1ae2c:
    push(cs);
    yield* sub_1ad3d();
    r16[ax] = r16[si];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ae36() // 1a61:0826 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0;
    if (!memoryAGet16(ds, 0x78a6))
        { pc = 0x1ae47; break; }
    { pc = 0x1af1f; break; }
  case 0x1ae47:
    memoryASet16(ds, 0xe6f0, 0x0000);
    memoryASet16(ds, 0x767a, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1ae87; break; }
  case 0x1ae58:
    r16[ax] = 0x431e;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x1a61);
    sp += 0x0004;
    if (!r16[ax])
        { pc = 0x1ae7b; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1ae83; break; }
    { pc = 0x1ae86; break; }
  case 0x1ae7b:
    memoryASet16(ds, 0x767a, 0x0001);
    { pc = 0x1ae86; break; }
  case 0x1ae83:
    r16[di] = 0x0001;
  case 0x1ae86:
    r16[si]++;
  case 0x1ae87:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x1ae58; break; }
    memoryASet16(ds, 0x7892, 0x0000);
    memoryASet16(ds, 0x7890, 0x0000);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_395b(); assert(cs == 0x1a61);
    sp += 0x0002;
    memoryASet16(ds, 0x788a, r16[dx]);
    memoryASet16(ds, 0x7888, r16[ax]);
    r16[ax] = 0x1a61;
    push(r16[ax]);
    r16[ax] = 0x05f5;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_396a(); assert(cs == 0x1a61);
    sp += 0x0006;
    r16[ax] = 0;
    r16[dx] = 0;
    memoryASet16(ds, 0x766e, r16[ax]);
    memoryASet16(ds, 0x766c, r16[dx]);
    memoryASet16(ds, 0xa53f, r16[ax]);
    memoryASet16(ds, 0xa53d, r16[dx]);
    memoryASet16(ds, 0x7886, r16[ax]);
    memoryASet16(ds, 0x7884, r16[dx]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_1ad5b();
    sp += 0x0002;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_1ade0();
    sp += 0x0002;
    if (memoryAGet16(ds, 0x767a))
        { pc = 0x1aeff; break; }
    push(r16[di]);
    push(cs);
    yield* sub_1ab39();
    sp += 0x0002;
    memoryASet16(ds, 0xc639, r16[ax]);
  case 0x1aeff:
    r16[si] = 0;
    { pc = 0x1af13; break; }
  case 0x1af03:
    r16[ax] = r16[si];
    r16[dx] = 0x003c;
    imul16(r16[dx]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 30332, r16[ax]);
    r16[si]++;
  case 0x1af13:
    if (r16s[si] < signed16(0x00ff))
        { pc = 0x1af03; break; }
    memoryASet16(ds, 0x78a6, 0x0001);
  case 0x1af1f:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1af23() // 1a61:0913 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1af4f; break; }
    r16[ax] = r16[si];
    if (r16[ax] == 0x0002)
        { pc = 0x1af49; break; }
    { pc = 0x1af4f; break; }
  case 0x1af49:
    r16[ax] = memoryAGet16(ds, 0xc639);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
  case 0x1af4f:
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1af64; break; }
    if (!memoryAGet16(ds, 0xc639))
        { pc = 0x1af61; break; }
    r16[si] = 0x0002;
    { pc = 0x1af64; break; }
  case 0x1af61:
    r16[si] = 0x0001;
  case 0x1af64:
    if (r16[si] == memoryAGet16(ds, 0xc635))
        { pc = 0x1af72; break; }
    push(r16[si]);
    push(cs);
    yield* sub_1ad5b();
    sp += 0x0002;
  case 0x1af72:
    if (!memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1af87; break; }
    r16[ax] = r16[di];
    if (r16[ax] == 0x0002)
        { pc = 0x1af81; break; }
    { pc = 0x1af87; break; }
  case 0x1af81:
    r16[ax] = memoryAGet16(ds, 0xc639);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
  case 0x1af87:
    if (memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1af9b; break; }
    if (!memoryAGet16(ds, 0xc639))
        { pc = 0x1af99; break; }
    r16[di] = 0x0001;
    { pc = 0x1af9b; break; }
  case 0x1af99:
    r16[di] = 0;
  case 0x1af9b:
    if (r16[di] == memoryAGet16(ds, 0xc633))
        { pc = 0x1afa9; break; }
    push(r16[di]);
    push(cs);
    yield* sub_1ade0();
    sp += 0x0002;
  case 0x1afa9:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1afaf() // 1a61:099f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0x78a6))
        { pc = 0x1afed; break; }
    push(cs);
    yield* sub_1b125();
    push(cs);
    yield* sub_1ace7();
    push(cs);
    yield* sub_1ad0b();
    push(flagAsReg());
    flags.interrupts = 0;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_1a61e();
    sp += 0x0002;
    push(memoryAGet16(ds, 0x788a));
    push(memoryAGet16(ds, 0x7888));
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_396a(); assert(cs == 0x1a61);
    sp += 0x0006;
    flagsFromReg(pop());
    memoryASet16(ds, 0x78a6, 0x0000);
  case 0x1afed:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b001() // 1a61:09f1 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    if (memoryAGet16(ds, 0xc635))
        { pc = 0x1b015; break; }
    { pc = 0x1b09b; break; }
  case 0x1b015:
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0xe6f2);
    r16[bx] += r16[ax];
    r16[ax] = memoryAGet16(ds, r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] |= memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax])
        { pc = 0x1b03d; break; }
    r16[ax] = 0x4370;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1a61);
    sp += 0x0002;
  case 0x1b03d:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax] |= memoryAGet16(es, r16[bx] + 2);
    if (r16[ax])
        { pc = 0x1b055; break; }
    r16[ax] = 0x4390;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1a61);
    sp += 0x0002;
  case 0x1b055:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    if (r16[ax] < memoryAGet16(ds, 0x788c))
        { pc = 0x1b09b; break; }
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (r16[ax] == 0x0001)
        { pc = 0x1b071; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b080; break; }
    { pc = 0x1b08d; break; }
  case 0x1b071:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs);
    yield* sub_1a68b();
    sp += 0x0004;
    { pc = 0x1b08d; break; }
  case 0x1b080:
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs);
    yield* sub_1a8e7();
    sp += 0x0004;
  case 0x1b08d:
    memoryASet16(ds, 0x788e, r16[si]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    memoryASet16(ds, 0x788c, r16[ax]);
  case 0x1b09b:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b0a0() // 1a61:0a90 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = 0;
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (r16[ax] == 0x0001)
        { pc = 0x1b0b4; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b0c8; break; }
    { pc = 0x1b0da; break; }
  case 0x1b0b4:
    r16[ax] = memoryAGet16(ds, 0x787e);
    r16[ax] |= memoryAGet16(ds, 0x7880);
    if (!r16[ax])
        { pc = 0x1b0c2; break; }
    r16[ax] = 0x0001;
    { pc = 0x1b0c4; break; }
  case 0x1b0c2:
    r16[ax] = 0;
  case 0x1b0c4:
    r16[dx] = r16[ax];
    { pc = 0x1b0da; break; }
  case 0x1b0c8:
    r16[ax] = memoryAGet16(ds, 0x7676);
    r16[ax] |= memoryAGet16(ds, 0x7678);
    if (!r16[ax])
        { pc = 0x1b0d6; break; }
    r16[ax] = 0x0001;
    { pc = 0x1b0d8; break; }
  case 0x1b0d6:
    r16[ax] = 0;
  case 0x1b0d8:
    r16[dx] = r16[ax];
  case 0x1b0da:
    if (!r16[dx])
        { pc = 0x1b0e3; break; }
    r16[ax] = memoryAGet16(ds, 0x788e);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1b0e3:
    r16[ax] = 0;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b0e7() // 1a61:0ad7 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ds, 0xc635);
    if (r16[ax] == 0x0001)
        { pc = 0x1b0f9; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1b0ff; break; }
    { pc = 0x1b103; break; }
  case 0x1b0f9:
    push(cs);
    yield* sub_1a6b9();
    { pc = 0x1b103; break; }
  case 0x1b0ff:
    push(cs);
    yield* sub_1a7b0();
  case 0x1b103:
    r16[ax] = 0;
    memoryASet16(ds, 0x788c, r16[ax]);
    memoryASet16(ds, 0x788e, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b10d() // 1a61:0afd +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
  case 0x1b110:
    yield* sync();
    push(cs);
    yield* sub_1b0a0();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b11a() // 1a61:0b0a +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0x765a, 0x0001);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1b125() // 1a61:0b15 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    r16[ax] = memoryAGet16(ds, 0xc633);
    if (r16[ax] == 0x0001)
        { pc = 0x1b135; break; }
    { pc = 0x1b168; break; }
  case 0x1b135:
    memoryASet16(ds, 0x7658, 0x0000);
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = 0xbd;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    { pc = 0x1b162; break; }
  case 0x1b14f:
    r8[al] = 0x00;
    push(r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    r8[al] += 0xb1;
    push(r16[ax]);
    push(cs);
    yield* sub_1a76e();
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x1b162:
    if (memoryAGet16(ss, r16[bp] - 2) < 0x000a)
        { pc = 0x1b14f; break; }
  case 0x1b168:
    memoryASet16(ds, 0x765a, 0x0000);
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b172() // 1a61:0b62 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_1b125();
    push(flagAsReg());
    flags.interrupts = 0;
    if (memoryAGet16(ds, 0xc633) != 0x0001)
        { pc = 0x1b1c1; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] += 0x0002;
    memoryASet16(ds, 0x74fe, r16[ax]);
    memoryASet16(ds, 0x74fc, r16[dx]);
    memoryASet16(ds, 0x74fa, r16[ax]);
    memoryASet16(ds, 0x74f8, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ds, 0x74f6, r16[ax]);
    memoryASet16(ds, 0x74f4, r16[ax]);
    memoryASet16(ds, 0x74f2, 0x0000);
    memoryASet16(ds, 0x74f0, 0x0000);
    memoryASet16(ds, 0x766e, 0x0000);
    memoryASet16(ds, 0x766c, 0x0000);
    push(cs);
    yield* sub_1b11a();
  case 0x1b1c1:
    flagsFromReg(pop());
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b1c4() // 1a61:0bb4 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ds, 0xc633);
    if (r16[ax] == 0x0001)
        { pc = 0x1b1d1; break; }
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1b1d1:
    push(cs);
    yield* sub_1b125();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b1d7() // 1a61:0bc7 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ds, 0xc633);
    if (r16[ax] == 0x0001)
        { pc = 0x1b1e4; break; }
    { pc = 0x1b1e8; break; }
  case 0x1b1e4:
    r16[dx] = 0;
    { pc = 0x1b1ea; break; }
  case 0x1b1e8:
    r16[dx] = 0;
  case 0x1b1ea:
    r16[ax] = r16[dx];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b324() // 1b1e:0144 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = memoryAGet(ss, r16[bp] + 6);
    r8[al] += 0x30;
    memoryASet(ds, 0x45cb, r8[al]);
    r16[ax] = 0x45c4;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1b334() // 1b1e:0154 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xe800, r16[ax]);
    memoryASet16(ds, 0xe7fe, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, 0xe804, r16[ax]);
    memoryASet16(ds, 0xe802, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 16);
    r16[dx] = memoryAGet16(ss, r16[bp] + 14);
    memoryASet16(ds, 0xe7fc, r16[ax]);
    memoryASet16(ds, 0xe7fa, r16[dx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1b360() // 1b1e:0180 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000e;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x8001;
    push(r16[ax]);
    r16[ax] = 0x468c;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x1b1e);
    sp += 0x0004;
    r16[si] = r16[ax];
    if (r16[ax] != 0xffff)
        { pc = 0x1b382; break; }
    { pc = 0x1b4cc; break; }
  case 0x1b382:
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x4697;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_418a(); assert(cs == 0x1b1e);
    sp += 0x0004;
    if (r16[ax])
        { pc = 0x1b3be; break; }
    if (memoryAGet16(ss, r16[bp] - 8) == 0x0004)
        { pc = 0x1b3ca; break; }
  case 0x1b3be:
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1b1e);
    sp += 0x0002;
    { pc = 0x1b4cc; break; }
  case 0x1b3ca:
    r16[ax] = 0x0200;
    push(r16[ax]);
    r16[ax] = 0x43c4;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x3bc2;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc5cd;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xe6e8;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc637;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x7a14;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc5cf;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x0394;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc643;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0xcc05;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1b1e);
    sp += 0x0002;
    memoryASet16(ds, 0xa539, 0x0000);
    r16[di] = 0x0001;
    { pc = 0x1b4ef; break; }
  case 0x1b4cc:
    memoryASet16(ss, r16[bp] - 10, 0x0000);
    memoryASet16(ss, r16[bp] - 12, 0x0000);
    memoryASet16(ss, r16[bp] - 14, 0x0000);
    memoryASet16(ds, 0xc5cd, 0x0001);
    memoryASet16(ds, 0xc5cf, 0x0000);
    r16[di] = 0;
    memoryASet16(ds, 0xa539, 0x0001);
  case 0x1b4ef:
    push(memoryAGet16(ss, r16[bp] - 12));
    push(memoryAGet16(ss, r16[bp] - 10));
    if (!r16[di])
        { pc = 0x1b50b; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax] != memoryAGet16(ds, 0xc639))
        { pc = 0x1b507; break; }
    r16[ax] = 0x0001;
    { pc = 0x1b509; break; }
  case 0x1b507:
    r16[ax] = 0;
  case 0x1b509:
    { pc = 0x1b50d; break; }
  case 0x1b50b:
    r16[ax] = 0;
  case 0x1b50d:
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1af23(); assert(cs == 0x1b1e);
    sp += 0x0006;
    push(memoryAGet16(ss, r16[bp] - 14));
    push(r16[di]);
    push(cs); cs = 0x164d; yield* sub_16cf6(); assert(cs == 0x1b1e);
    sp += 0x0004;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b528() // 1b1e:0348 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    memoryASet16(ss, r16[bp] - 2, 0x0004);
    r16[ax] = 0x8180;
    push(r16[ax]);
    r16[ax] = 0x8102;
    push(r16[ax]);
    r16[ax] = 0x469b;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[si] = r16[ax];
    if (r16[si] != 0xffff)
        { pc = 0x1b552; break; }
    { pc = 0x1b66b; break; }
  case 0x1b552:
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x46a6;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0200;
    push(r16[ax]);
    r16[ax] = 0x43c4;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc635;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc633;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xcc0d;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x3bc2;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc5cd;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xe6e8;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc637;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc639;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0x7a14;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc5cf;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x0394;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0002;
    push(r16[ax]);
    r16[ax] = 0xc643;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0xcc05;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_3383(); assert(cs == 0x1b1e);
    sp += 0x0006;
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1b1e);
    sp += 0x0002;
  case 0x1b66b:
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b670() // 1b1e:0490 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[di] = 0;
    r16[si] = 0xe6fe;
    { pc = 0x1b719; break; }
  case 0x1b680:
    push(r16[di]);
    push(cs);
    yield* sub_1b324();
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    r16[ax] = 0x8001;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x01ed; yield* sub_3c5d(); assert(cs == 0x1b1e);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    if (r16[ax] == 0xffff)
        { pc = 0x1b6e4; break; }
    r16[ax] = 0x002a;
    push(r16[ax]);
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] - 6));
    push(cs); cs = 0x01ed; yield* sub_3de0(); assert(cs == 0x1b1e);
    sp += 0x0006;
    if (r16[ax] != 0x002a)
        { pc = 0x1b6d9; break; }
    r16[ax] = 0x46aa;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_418a(); assert(cs == 0x1b1e);
    sp += 0x0004;
    if (r16[ax])
        { pc = 0x1b6d9; break; }
    if (memoryAGet16(ds, r16[si] + 4) != 0xa537)
        { pc = 0x1b6d9; break; }
    memoryASet16(ss, r16[bp] - 2, 0x0001);
  case 0x1b6d9:
    push(memoryAGet16(ss, r16[bp] - 6));
    push(cs); cs = 0x01ed; yield* sub_213d(); assert(cs == 0x1b1e);
    sp += 0x0002;
  case 0x1b6e4:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1b6f1; break; }
    memoryASet16(ds, r16[si] + 6, 0x0001);
    { pc = 0x1b715; break; }
  case 0x1b6f1:
    r16[ax] = 0x46ae;
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    memoryASet16(ds, r16[si] + 6, 0x0000);
    r16[ax] = 0x46b2;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
  case 0x1b715:
    r16[di]++;
    r16[si] += 0x002a;
  case 0x1b719:
    if (r16[di] >= 0x0006)
        { pc = 0x1b721; break; }
    { pc = 0x1b680; break; }
  case 0x1b721:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b727() // 1b1e:0547 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    if (memoryAGet16(ds, 0x78d4))
        { pc = 0x1b79e; break; }
    r16[ax] = 0x1b1e;
    push(r16[ax]);
    r16[ax] = 0x000e;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_39b3(); assert(cs == 0x1b1e);
    sp += 0x0004;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1eef; yield* sub_1eef2(); assert(cs == 0x1b1e);
    sp += 0x0002;
    push(cs);
    yield* sub_1b360();
    r16[si] = 0x0001;
    { pc = 0x1b792; break; }
  case 0x1b757:
    r16[ax] = 0x43b8;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs);
    yield* sub_1b7df();
    sp += 0x0004;
    if (!r16[ax])
        { pc = 0x1b77a; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1b78b; break; }
    { pc = 0x1b791; break; }
  case 0x1b77a:
    if (memoryAGet16(ds, 0xe6ee) != 0x0002)
        { pc = 0x1b791; break; }
    memoryASet16(ds, 0xe6e8, 0x0001);
    { pc = 0x1b791; break; }
    // gap 2 bytes
  case 0x1b78b:
    memoryASet16(ds, 0xe6e8, 0x0000);
  case 0x1b791:
    r16[si]++;
  case 0x1b792:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x1b757; break; }
    memoryASet16(ds, 0x78d4, 0x0001);
  case 0x1b79e:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b7a1() // 1b1e:05c1 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xe804, 0x0000);
    memoryASet16(ds, 0xe802, 0x0000);
    memoryASet16(ds, 0xe800, 0x0000);
    memoryASet16(ds, 0xe7fe, 0x0000);
    push(cs);
    yield* sub_1b670();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1b7c2() // 1b1e:05e2 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0x78d4))
        { pc = 0x1b7dd; break; }
    if (memoryAGet16(ds, 0xe810))
        { pc = 0x1b7d7; break; }
    push(cs);
    yield* sub_1b528();
  case 0x1b7d7:
    memoryASet16(ds, 0x78d4, 0x0000);
  case 0x1b7dd:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b7df() // 1b1e:05ff +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    { pc = 0x1b7ec; break; }
  case 0x1b7e9:
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 1);
  case 0x1b7ec:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r8[al] = memoryAGet(ds, r16[bx]);
    cbw();
    r16[bx] = r16[ax];
    r8[al] = memoryAGet(ds, r16[bx] + 28297);
    cbw();
    if (!(r16[ax] & 0x000c))
        { pc = 0x1b7e9; break; }
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x1b87a; break; }
  case 0x1b805:
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ds, r16[bx]);
    memoryASet16(ss, r16[bp] + 8, memoryAGet16(ss, r16[bp] + 8) + 0x0002);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r8[al] = 0x00;
    memoryASet(ss, r16[bp] - 1, r8[al]);
    memoryASet(ss, r16[bp] - 2, r8[al]);
    { pc = 0x1b86f; break; }
  case 0x1b81b:
    r8[al] = memoryAGet(ds, r16[di]);
    memoryASet(ss, r16[bp] - 2, r8[al]);
    r16[di]++;
    cbw();
    if (r16[ax])
        { pc = 0x1b82f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1b82f:
    r8[al] = memoryAGet(ds, r16[si]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    r16[si]++;
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    cbw();
    r16[bx] = r16[ax];
    if (!(memoryAGet(ds, r16[bx] + 28297) & 0x04))
        { pc = 0x1b852; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_32ff(); assert(cs == 0x1b1e);
    sp += 0x0002;
    memoryASet(ss, r16[bp] - 2, r8[al]);
  case 0x1b852:
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    cbw();
    r16[bx] = r16[ax];
    if (!(memoryAGet(ds, r16[bx] + 28297) & 0x04))
        { pc = 0x1b86f; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    cbw();
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_32ff(); assert(cs == 0x1b1e);
    sp += 0x0002;
    memoryASet(ss, r16[bp] - 1, r8[al]);
  case 0x1b86f:
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    if (r8[al] == memoryAGet(ss, r16[bp] - 1))
        { pc = 0x1b81b; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x1b87a:
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    if (!memoryAGet16(ds, r16[bx]))
        { pc = 0x1b88c; break; }
    r16[bx] = memoryAGet16(ds, r16[bx]);
    if (!memoryAGet(ds, r16[bx]))
        { pc = 0x1b88c; break; }
    { pc = 0x1b805; break; }
  case 0x1b88c:
    r16[ax] = 0xffff;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b895() // 1b1e:06b5 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    memoryASet16(ss, r16[bp] - 2, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1b8d1; break; }
  case 0x1b8ac:
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs);
    yield* sub_1b7df();
    sp += 0x0004;
    if (r16[ax] == 0xffff)
        { pc = 0x1b8d0; break; }
    r16[ax] = 0x0001;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1b8d0:
    r16[si]++;
  case 0x1b8d1:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x1b8ac; break; }
    r16[ax] = 0;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b8de() // 1b1e:06fe +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r8[cl] = memoryAGet(ss, r16[bp] + 12);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = 0x00a0;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 2, 0xb800);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = r16[di];
    r16[ax]--;
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = 0x00a0;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[dx] += 0x0008;
    memoryASet16(ss, r16[bp] - 6, 0x21d1);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    { pc = 0x1b958; break; }
  case 0x1b926:
    r8[al] = memoryAGet(ds, r16[si]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(es, r16[bx], r8[al]);
    r16[si]++;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    if (r8[cl] == 0xff)
        { pc = 0x1b955; break; }
    r8[al] = r8[cl];
    r8[al] &= 0x8f;
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r8[dl] = memoryAGet(es, r16[bx]);
    r8[dl] &= 0x70;
    r8[al] |= r8[dl];
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(es, r16[bx], r8[al]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    { pc = 0x1b958; break; }
  case 0x1b955:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
  case 0x1b958:
    if (memoryAGet(ds, r16[si]))
        { pc = 0x1b926; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b963() // 1b1e:0783 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = 0x03;
    r8[ah] = 0x00;
    interrupt(0x10);
    r8[ah] = 0x0f;
    interrupt(0x10);
    r8[dl] = 0x00;
    r8[dh] = 0x18;
    r8[ah] = 0x02;
    interrupt(0x10);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1b97a() // 1b1e:079a +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    push(cs);
    yield* sub_1b963();
    r16[ax] = 0x0fa0;
    push(r16[ax]);
    r16[ax] = 0x21d1;
    push(r16[ax]);
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0xb800;
    r16[dx] = 0;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_561c(); assert(cs == 0x1b1e);
    sp += 0x000a;
    r16[si] = 0x0001;
    { pc = 0x1b9f4; break; }
  case 0x1b9a3:
    r16[ax] = 0x43b4;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs);
    yield* sub_1b7df();
    sp += 0x0004;
    r16[di] = r16[ax];
    if (r16[di])
        { pc = 0x1b9e4; break; }
    r16[ax] = r16[si];
    r16[ax]++;
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x01ed; yield* sub_349f(); assert(cs == 0x1b1e);
    sp += 0x0002;
    memoryASet16(ds, 0x7ada, r16[ax]);
    memoryASet16(ds, 0x7adc, 0x0001);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2 bytes
  case 0x1b9e4:
    if (r16[di] != 0x0001)
        { pc = 0x1b9f3; break; }
    memoryASet16(ds, 0x7ad8, 0x0001);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1b9f3:
    r16[si]++;
  case 0x1b9f4:
    if (r16[si] < memoryAGet16(ds, 0x743c))
        { pc = 0x1b9a3; break; }
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1b9fe() // 1b1e:081e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = r16[si];
    r16[ax]--;
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[dx] = 0x00a0;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    memoryASet16(ss, r16[bp] - 2, 0xb800);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[ax] = r16[si];
    r16[ax]--;
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[dx] = 0x00a0;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[dx] += 0x0006;
    memoryASet16(ss, r16[bp] - 6, 0x21d1);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1ba4d; break; }
    r8[al] = 0xfb;
    { pc = 0x1ba4f; break; }
  case 0x1ba4d:
    r8[al] = 0x20;
  case 0x1ba4f:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(es, r16[bx], r8[al]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 1);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1ba8a; break; }
    if (!memoryAGet16(ss, r16[bp] + 14))
        { pc = 0x1ba8a; break; }
    r16[cx]++;
    { pc = 0x1ba83; break; }
  case 0x1ba6b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[al] &= 0xf0;
    r8[al] |= 0x0f;
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet(es, r16[bx], r8[al]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0002);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
  case 0x1ba83:
    r16[ax] = r16[cx];
    r16[cx]--;
    if (r16[ax])
        { pc = 0x1ba6b; break; }
  case 0x1ba8a:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ba90() // 1b1e:08b0 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0010;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 16;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(cs); cs = 0x01ed; yield* sub_3b85(); assert(cs == 0x1b1e);
    sp += 0x0008;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x1b1e);
    sp += 0x0002;
    r16[si] = r16[ax];
    { pc = 0x1bad4; break; }
  case 0x1babe:
    r8[al] = 0xff;
    push(r16[ax]);
    r16[ax] = 0x46b8;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    r16[ax] = r16[di];
    r16[di]++;
    push(r16[ax]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
    r16[si]++;
  case 0x1bad4:
    if (r16[si] < 0x0005)
        { pc = 0x1babe; break; }
    r8[al] = 0xff;
    push(r16[ax]);
    r16[ax] = r16[bp] - 16;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1baf1() // 1b1e:0911 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000e;
    push(r16[si]);
    push(r16[di]);
    if (memoryAGet16(ds, 0xe6ee) != 0x0001)
        { pc = 0x1bb05; break; }
    r16[ax] = 0x0001;
    { pc = 0x1bb07; break; }
  case 0x1bb05:
    r16[ax] = 0;
  case 0x1bb07:
    r16[si] = r16[ax];
    push(r16[ax]);
    if (signed16(memoryAGet16(ds, 0xe812)) < signed16(0x0002))
        { pc = 0x1bb1d; break; }
    if (signed16(memoryAGet16(ds, 0xe812)) > signed16(0x0005))
        { pc = 0x1bb1d; break; }
    r16[ax] = 0x0001;
    { pc = 0x1bb1f; break; }
  case 0x1bb1d:
    r16[ax] = 0;
  case 0x1bb1f:
    push(r16[ax]);
    r16[ax] = 0x0004;
    push(r16[ax]);
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0x0015;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    if (memoryAGet16(ds, 0xe6ee) == 0x0002)
        { pc = 0x1bb41; break; }
    if (memoryAGet16(ds, 0xe6ee) != 0x0003)
        { pc = 0x1bb46; break; }
  case 0x1bb41:
    r16[ax] = 0x0001;
    { pc = 0x1bb48; break; }
  case 0x1bb46:
    r16[ax] = 0;
  case 0x1bb48:
    r16[si] = r16[ax];
    push(r16[ax]);
    if (signed16(memoryAGet16(ds, 0xe812)) < signed16(0x0003))
        { pc = 0x1bb5e; break; }
    if (signed16(memoryAGet16(ds, 0xe812)) > signed16(0x0005))
        { pc = 0x1bb5e; break; }
    r16[ax] = 0x0001;
    { pc = 0x1bb60; break; }
  case 0x1bb5e:
    r16[ax] = 0;
  case 0x1bb60:
    push(r16[ax]);
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0015;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    if (!memoryAGet16(ds, 0xe6e8))
        { pc = 0x1bb91; break; }
    r8[al] = 0x4f;
    push(r16[ax]);
    r16[ax] = 0x46ba;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0005;
    push(r16[ax]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
  case 0x1bb91:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcc46));
    r16[ax] = 0x000b;
    push(r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcc48));
    r16[ax] = 0x000b;
    push(r16[ax]);
    r16[ax] = 0x0009;
    push(r16[ax]);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xcc4a));
    r16[ax] = 0x0005;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x003c;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    if (memoryAGet16(ds, 0xc635) != 0x0001)
        { pc = 0x1bc06; break; }
    r16[ax] = 0x0001;
    { pc = 0x1bc08; break; }
  case 0x1bc06:
    r16[ax] = 0;
  case 0x1bc08:
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0x000b;
    push(r16[ax]);
    r16[ax] = 0x000e;
    push(r16[ax]);
    r16[ax] = 0x0015;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    if (memoryAGet16(ds, 0xc635) == 0x0002)
        { pc = 0x1bc2e; break; }
    if (memoryAGet16(ds, 0xc633) != 0x0001)
        { pc = 0x1bc33; break; }
  case 0x1bc2e:
    r16[ax] = 0x0001;
    { pc = 0x1bc35; break; }
  case 0x1bc33:
    r16[ax] = 0;
  case 0x1bc35:
    r16[si] = r16[ax];
    push(r16[ax]);
    push(memoryAGet16(ds, 0xc639));
    r16[ax] = 0x000e;
    push(r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x0015;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    if (!r16[si])
        { pc = 0x1bcc0; break; }
    if (!memoryAGet16(ds, 0xc639))
        { pc = 0x1bcc0; break; }
    r16[di] = 0x0015;
    memoryASet16(ss, r16[bp] - 14, 0x0010);
    r16[cx] = 0x000e;
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = 0x00a0;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[dx]--;
    memoryASet16(ss, r16[bp] - 6, 0xb800);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[ax] = r16[di];
    r16[ax] <<= 1;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[dx] = 0x00a0;
    imul16(r16[dx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[dx] += 0x0006;
    memoryASet16(ss, r16[bp] - 10, 0x21d1);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
    r16[cx]++;
    { pc = 0x1bcb9; break; }
  case 0x1bca1:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[al] &= 0xf0;
    r8[al] |= 0x0f;
    r16[bx] = memoryAGet16(ss, r16[bp] - 8); es = memoryAGet16(ss, r16[bp] - 6);
    memoryASet(es, r16[bx], r8[al]);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + 0x0002);
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0002);
  case 0x1bcb9:
    r16[ax] = r16[cx];
    r16[cx]--;
    if (r16[ax])
        { pc = 0x1bca1; break; }
  case 0x1bcc0:
    r16[ax] = 0;
    r16[dx] = 0x0400;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xa01d));
    push(memoryAGet16(ds, 0xa01b));
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x1b1e);
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x003f;
    push(r16[ax]);
    push(cs);
    yield* sub_1ba90();
    sp += 0x0008;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0017;
    push(r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x0035;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r16[ax] = 0;
    r16[dx] = 0x0400;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xa015));
    push(memoryAGet16(ds, 0xa013));
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x1b1e);
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    r16[ax] = 0x003f;
    push(r16[ax]);
    push(cs);
    yield* sub_1ba90();
    sp += 0x0008;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa013);
    r16[ax] |= memoryAGet16(ds, 0xa015);
    if (!r16[ax])
        { pc = 0x1bd34; break; }
    r16[ax] = 0x0001;
    { pc = 0x1bd36; break; }
  case 0x1bd34:
    r16[ax] = 0;
  case 0x1bd36:
    push(r16[ax]);
    r16[ax] = 0x0017;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    r16[ax] = 0x0035;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r16[ax] = 0;
    r16[dx] = 0x0400;
    push(r16[ax]);
    push(r16[dx]);
    push(memoryAGet16(ds, 0xa019));
    push(memoryAGet16(ds, 0xa017));
    push(cs); cs = 0x01ed; yield* sub_4f95(); assert(cs == 0x1b1e);
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0011;
    push(r16[ax]);
    r16[ax] = 0x003f;
    push(r16[ax]);
    push(cs);
    yield* sub_1ba90();
    sp += 0x0008;
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa017);
    r16[ax] |= memoryAGet16(ds, 0xa019);
    if (!r16[ax])
        { pc = 0x1bd81; break; }
    r16[ax] = 0x0001;
    { pc = 0x1bd83; break; }
  case 0x1bd81:
    r16[ax] = 0;
  case 0x1bd83:
    push(r16[ax]);
    r16[ax] = 0x0017;
    push(r16[ax]);
    r16[ax] = 0x0011;
    push(r16[ax]);
    r16[ax] = 0x0035;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0xa01d);
    r16[dx] = memoryAGet16(ds, 0xa01b);
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa013) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa013);
    r16[ax] += memoryAGet16(ds, 0xa015) + flags.carry;
    flags.carry = r16[dx] + memoryAGet16(ds, 0xa017) >= 0x10000;
    r16[dx] += memoryAGet16(ds, 0xa017);
    r16[ax] += memoryAGet16(ds, 0xa019) + flags.carry;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[dx] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r8[cl] = 0x0a;
    push(cs); cs = 0x01ed; yield* sub_5084(); assert(cs == 0x1b1e);
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    r16[ax] = 0x003f;
    push(r16[ax]);
    push(cs);
    yield* sub_1ba90();
    sp += 0x0008;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0017;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    r16[ax] = 0x0035;
    push(r16[ax]);
    push(cs);
    yield* sub_1b9fe();
    sp += 0x000a;
    r8[al] = 0xff;
    push(r16[ax]);
    r16[ax] = 0x46db;
    push(r16[ax]);
    r16[ax] = 0x0012;
    push(r16[ax]);
    r16[ax] = 0x0034;
    push(r16[ax]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
    r8[al] = 0x9c;
    push(r16[ax]);
    r16[ax] = 0x46dd;
    push(r16[ax]);
    r16[ax] = 0x0016;
    push(r16[ax]);
    r16[ax] = 0x001b;
    push(r16[ax]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1be1c() // 1b1e:0c3c +far +stackDrop2
{
  var pc = 0;
  var temp_cond0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    if (memoryAGet16(ds, 0x7adc))
        { pc = 0x1be95; break; }
    if (memoryAGet16(ds, 0x7ad8))
        { pc = 0x1be95; break; }
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1b1e);
    r16[si] = 0;
    r16[di] = 0x0001;
    { pc = 0x1be7c; break; }
  case 0x1be3e:
    r8[al] = memoryAGet(ds, r16[si] + 17873);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!r16[di])
        { pc = 0x1be5c; break; }
    r16[si]++;
    r16[ax] = r16[si];
    if (r16[ax] != 0x0009)
        { pc = 0x1be65; break; }
    r16[si] = 0x0008;
    r16[di] = 0;
    { pc = 0x1be65; break; }
    // gap 2 bytes
  case 0x1be5c:
    temp_cond0 = r16s[si] >= 1;
    r16[si]--;
    if (temp_cond0)
        { pc = 0x1be65; break; }
    r16[si] = 0x0001;
    r16[di] = 0x0001;
  case 0x1be65:
    r8[al] = memoryAGet(ss, r16[bp] - 2);
    push(r16[ax]);
    r16[ax] = 0x46ed;
    push(r16[ax]);
    r16[ax] = 0x0016;
    push(r16[ax]);
    r16[ax] = 0x001d;
    push(r16[ax]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
  case 0x1be7c:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[ax] = 0;
    r16[dx] = 0x0004;
    push(r16[ax]);
    push(r16[dx]);
    push(cs); cs = 0x164d; yield* sub_17462(); assert(cs == 0x1b1e);
    sp += 0x0006;
    if (!r16[ax])
        { pc = 0x1be3e; break; }
    { pc = 0x1beab; break; }
  case 0x1be95:
    r8[al] = 0x9a;
    push(r16[ax]);
    r16[ax] = 0x4707;
    push(r16[ax]);
    r16[ax] = 0x0016;
    push(r16[ax]);
    r16[ax] = 0x001d;
    push(r16[ax]);
    push(cs);
    yield* sub_1b8de();
    sp += 0x0008;
  case 0x1beab:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1b1e);
    push(cs);
    yield* sub_1b963();
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1beba() // 1b1e:0cda +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x43be, r16[ax]);
    memoryASet16(ds, 0x43bc, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ds, 0x43c2, r16[ax]);
    memoryASet16(ds, 0x43c0, r16[dx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1bed9() // 1b1e:0cf9 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    { pc = 0x1bf47; break; }
  case 0x1bee6:
    r16[si] = r16[di];
    { pc = 0x1beeb; break; }
  case 0x1beea:
    r16[si]++;
  case 0x1beeb:
    r8[al] = memoryAGet(ds, r16[si]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    if (!r8[al])
        { pc = 0x1befa; break; }
    if (memoryAGet(ss, r16[bp] - 1) != 0x0a)
        { pc = 0x1beea; break; }
  case 0x1befa:
    memoryASet(ds, r16[si], 0x00);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    push(ds);
    push(r16[di]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:0d27");
    }
    sp += 0x0008;
    r16[ax] = memoryAGet16(ds, 0xa537);
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa535);
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ds);
    push(r16[di]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:0d3c");
    }
    sp += 0x0004;
    r16[di] = r16[si];
    if (!memoryAGet(ss, r16[bp] - 1))
        { pc = 0x1bf40; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    memoryASet(ds, r16[si], r8[al]);
    r16[di]++;
    r16[ax] = memoryAGet16(ds, 0xa533);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + r16[ax]);
    { pc = 0x1bf47; break; }
  case 0x1bf40:
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa537, memoryAGet16(ds, 0xa537) + r16[ax]);
  case 0x1bf47:
    if (memoryAGet(ds, r16[di]))
        { pc = 0x1bee6; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1bf52() // 1b1e:0d72 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0020;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs); cs = 0x01ed; yield* sub_3b6b(); assert(cs == 0x1b1e);
    sp += 0x0008;
    push(r16[ax]);
    push(cs);
    yield* sub_1bed9();
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1bf7a() // 1b1e:0d9a +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0020;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = r16[bp] - 32;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs); cs = 0x01ed; yield* sub_3b85(); assert(cs == 0x1b1e);
    sp += 0x0008;
    push(r16[ax]);
    push(cs);
    yield* sub_1bed9();
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1bfa2() // 1b1e:0dc2 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(ds);
    push(r16[si]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:0dd6");
    }
    sp += 0x0008;
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 14);
    r16[ax] -= memoryAGet16(ss, r16[bp] + 10);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6020, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6022, r16[dx]);
    push(ds);
    push(r16[si]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:0e13");
    }
    sp += 0x0004;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1bfff() // 1b1e:0e1f +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    r16[ax] = memoryAGet16(ds, 0xa533);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7de);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] += memoryAGet16(ds, 0xa531);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    r16[ax] += memoryAGet16(ds, 0xa7dc);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[bp] - 8;
    r16[dx] = ss;
    r16[cx] = 0x0008;
    push(cs); cs = 0x01ed; yield* sub_51d7(); assert(cs == 0x1b1e);
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1bfa2();
    sp += 0x000a;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1c040() // 1b1e:0e60 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(ds);
    push(r16[si]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:0e74");
    }
    sp += 0x0008;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    if (r16[ax] <= memoryAGet16(ds, 0xa531))
        { pc = 0x1c070; break; }
    r16[ax] = 0x4721;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1b1e);
    sp += 0x0002;
  case 0x1c070:
    r16[ax] = memoryAGet16(ds, 0xa531);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ds, 0xa533);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6020, r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xa535);
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ds);
    push(r16[si]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:0eaa");
    }
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0xa535, memoryAGet16(ds, 0xa535) + r16[ax]);
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c09d() // 1b1e:0ebd +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    { pc = 0x1c0d7; break; }
  case 0x1c0aa:
    r16[si] = r16[di];
    { pc = 0x1c0af; break; }
  case 0x1c0ae:
    r16[si]++;
  case 0x1c0af:
    r8[al] = memoryAGet(ds, r16[si]);
    memoryASet(ss, r16[bp] - 1, r8[al]);
    if (!r8[al])
        { pc = 0x1c0be; break; }
    if (memoryAGet(ss, r16[bp] - 1) != 0x0a)
        { pc = 0x1c0ae; break; }
  case 0x1c0be:
    memoryASet(ds, r16[si], 0x00);
    push(r16[di]);
    push(cs);
    yield* sub_1c040();
    sp += 0x0002;
    r16[di] = r16[si];
    if (!memoryAGet(ss, r16[bp] - 1))
        { pc = 0x1c0d7; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 1);
    memoryASet(ds, r16[si], r8[al]);
    r16[di]++;
  case 0x1c0d7:
    if (memoryAGet(ds, r16[di]))
        { pc = 0x1c0aa; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c0e2() // 1b1e:0f02 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x000f;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7dc));
    push(memoryAGet16(ds, 0xa531));
    push(memoryAGet16(ds, 0xa7de));
    push(memoryAGet16(ds, 0xa533));
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x1b1e);
    sp += 0x000a;
    r16[ax] = memoryAGet16(ds, 0xa533);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7de);
    memoryASet16(ds, 0xa535, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1c10f() // 1b1e:0f2f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, 0xa533, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, 0xa7de, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, 0xa531, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ds, 0xa7dc, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa533);
    memoryASet16(ds, 0xa537, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7de);
    memoryASet16(ds, 0xa535, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax]--;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax]--;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0x0008;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += 0x0008;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    push(cs);
    yield* sub_1c0e2();
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0006;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += 0x0008;
    r16[si] = r16[ax];
    { pc = 0x1c1e0; break; }
  case 0x1c1bc:
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0007;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[si] += 0x0008;
  case 0x1c1e0:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= 0x0008;
    if (r16[ax] >= r16[si])
        { pc = 0x1c1bc; break; }
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    push(r16[ax]);
    push(r16[si]);
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = r16[di];
    r16[ax] += 0x0008;
    r16[si] = r16[ax];
    { pc = 0x1c23e; break; }
  case 0x1c217:
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[ax] = 0x0005;
    push(r16[ax]);
    push(r16[si]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] += memoryAGet16(ss, r16[bp] - 4);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fa3e(); assert(cs == 0x1b1e);
    sp += 0x0006;
    r16[si] += 0x0008;
  case 0x1c23e:
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    r16[ax] -= 0x0008;
    if (r16[ax] >= r16[si])
        { pc = 0x1c217; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c250() // 1b1e:1070 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    push(r16[di]);
    push(r16[si]);
    r16[ax] = 0x0019;
    r16[ax] -= r16[di];
    r16[ax] >>= 1;
    push(r16[ax]);
    r16[ax] = 0x0028;
    r16[ax] -= r16[si];
    r16[ax] >>= 1;
    push(r16[ax]);
    push(cs);
    yield* sub_1c10f();
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1c38f() // 1b1e:11af +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0084;
    push(r16[si]);
    r16[si] = memoryAGet16(ss, r16[bp] + 12);
    push(memoryAGet16(ss, r16[bp] + 10));
    r16[ax] = r16[bp] - 132;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    memoryASet(ss, r16[bp] + r16[si] + 65404, 0x00);
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 132;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:11dd");
    }
    sp += 0x0008;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    r16[ax]--;
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ds);
    r16[ax] = 0x4748;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:11f9");
    }
    sp += 0x0004;
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1c3e5() // 1b1e:1205 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0116;
    push(r16[si]);
    push(r16[di]);
    push(cs); cs = 0x1ef3; yield* sub_1f7bf(); assert(cs == 0x1b1e);
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1c40b; break; }
    push(memoryAGet16(ss, r16[bp] + 12));
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    { pc = 0x1c410; break; }
  case 0x1c40b:
    memoryASet(ss, r16[bp] + 65386, 0x00);
  case 0x1c410:
    memoryASet(ss, r16[bp] + 65258, 0x00);
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x1b1e);
    sp += 0x0002;
    r16[si] = r16[ax];
    r16[ax] = 0x0001;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = 0;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    memoryASet16(ss, r16[bp] - 22, r16[dx]);
    memoryASet(ds, 0xcc45, 0x00);
    memoryASet(ds, 0xa545, 0x00);
    { pc = 0x1c6fe; break; }
  case 0x1c44f:
    if (!memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1c468; break; }
    push(r16[si]);
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1c38f();
    sp += 0x0008;
  case 0x1c468:
    push(flagAsReg());
    flags.interrupts = 0;
    r8[al] = memoryAGet(ds, 0xa545);
    memoryASet(ss, r16[bp] - 11, r8[al]);
    memoryASet(ds, 0xa545, 0x00);
    r8[al] = memoryAGet(ds, 0xcc45);
    memoryASet(ss, r16[bp] - 12, r8[al]);
    memoryASet(ds, 0xcc45, 0x00);
    flagsFromReg(pop());
    r8[al] = memoryAGet(ss, r16[bp] - 11);
    r8[ah] = 0x00;
    if (r16[ax] != 0x004c)
        { pc = 0x1c48e; break; }
    { pc = 0x1c5bf; break; }
  case 0x1c48e:
    if (r16s[ax] > signed16(0x004c))
        { pc = 0x1c4c7; break; }
    if (r16[ax] == 0x0047)
        { pc = 0x1c500; break; }
    if (r16s[ax] > signed16(0x0047))
        { pc = 0x1c4af; break; }
    if (r16[ax] != 0x0001)
        { pc = 0x1c49f; break; }
    { pc = 0x1c549; break; }
  case 0x1c49f:
    if (r16[ax] != 0x000e)
        { pc = 0x1c4a7; break; }
    { pc = 0x1c55f; break; }
  case 0x1c4a7:
    if (r16[ax] == 0x001c)
        { pc = 0x1c529; break; }
    { pc = 0x1c5c3; break; }
  case 0x1c4af:
    if (r16[ax] != 0x0048)
        { pc = 0x1c4b7; break; }
    { pc = 0x1c5bf; break; }
  case 0x1c4b7:
    if (r16[ax] != 0x0049)
        { pc = 0x1c4bf; break; }
    { pc = 0x1c5bf; break; }
  case 0x1c4bf:
    if (r16[ax] == 0x004b)
        { pc = 0x1c4db; break; }
    { pc = 0x1c5c3; break; }
  case 0x1c4c7:
    r16[ax] -= 0x004d;
    r16[bx] = r16[ax];
    if (r16[bx] <= 0x0006)
        { pc = 0x1c4d4; break; }
    { pc = 0x1c5c3; break; }
  case 0x1c4d4:
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x1c4ec; break; }
        case 2: { pc = 0x1c5c3; break; }
        case 4: { pc = 0x1c50e; break; }
        case 6: { pc = 0x1c5bf; break; }
        case 8: { pc = 0x1c5bf; break; }
        case 10: { pc = 0x1c5bf; break; }
        case 12: { pc = 0x1c58e; break; }
        default:
            stop("ind 1b1e:12f6");
    }
    break;
  case 0x1c4db:
    if (!r16[si])
        { pc = 0x1c4e0; break; }
    r16[si]--;
  case 0x1c4e0:
    memoryASet(ss, r16[bp] - 12, 0x00);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x1c5c3; break; }
  case 0x1c4ec:
    if (!memoryAGet(ss, r16[bp] + r16[si] + 65386))
        { pc = 0x1c4f4; break; }
    r16[si]++;
  case 0x1c4f4:
    memoryASet(ss, r16[bp] - 12, 0x00);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x1c5c3; break; }
  case 0x1c500:
    r16[si] = 0;
    memoryASet(ss, r16[bp] - 12, 0x00);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x1c5c3; break; }
  case 0x1c50e:
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x1b1e);
    sp += 0x0002;
    r16[si] = r16[ax];
    memoryASet(ss, r16[bp] - 12, 0x00);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x1c5c3; break; }
  case 0x1c529:
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 8, 0x0001);
    memoryASet16(ss, r16[bp] - 10, 0x0001);
    memoryASet(ss, r16[bp] - 12, 0x00);
    { pc = 0x1c5c3; break; }
  case 0x1c549:
    if (!memoryAGet16(ss, r16[bp] + 14))
        { pc = 0x1c559; break; }
    memoryASet16(ss, r16[bp] - 8, 0x0001);
    memoryASet16(ss, r16[bp] - 10, 0x0000);
  case 0x1c559:
    memoryASet(ss, r16[bp] - 12, 0x00);
    { pc = 0x1c5c3; break; }
  case 0x1c55f:
    if (!r16[si])
        { pc = 0x1c583; break; }
    r16[ax] = r16[bp] - 150;
    r16[dx] = r16[si];
    r16[dx] += r16[ax];
    push(r16[dx]);
    r16[ax] = r16[bp] - 151;
    r16[dx] = r16[si];
    r16[dx] += r16[ax];
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    r16[si]--;
    memoryASet16(ss, r16[bp] - 2, 0x0001);
  case 0x1c583:
    memoryASet(ss, r16[bp] - 12, 0x00);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x1c5c3; break; }
  case 0x1c58e:
    if (!memoryAGet(ss, r16[bp] + r16[si] + 65386))
        { pc = 0x1c5b4; break; }
    r16[ax] = r16[bp] - 149;
    r16[dx] = r16[si];
    r16[dx] += r16[ax];
    push(r16[dx]);
    r16[ax] = r16[bp] - 150;
    r16[dx] = r16[si];
    r16[dx] += r16[ax];
    push(r16[dx]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, 0x0001);
  case 0x1c5b4:
    memoryASet(ss, r16[bp] - 12, 0x00);
    memoryASet16(ss, r16[bp] - 6, 0x0001);
    { pc = 0x1c5c3; break; }
  case 0x1c5bf:
    memoryASet(ss, r16[bp] - 12, 0x00);
  case 0x1c5c3:
    if (!memoryAGet(ss, r16[bp] - 12))
        { pc = 0x1c645; break; }
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41dd(); assert(cs == 0x1b1e);
    sp += 0x0002;
    memoryASet16(ss, r16[bp] - 18, r16[ax]);
    r16[ax] = r16[bp] - 16;
    push(r16[ax]);
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:1407");
    }
    sp += 0x0008;
    if (signed8(memoryAGet(ss, r16[bp] - 12)) < signed8(0x20))
        { pc = 0x1c645; break; }
    if (signed8(memoryAGet(ss, r16[bp] - 12)) > signed8(0x7e))
        { pc = 0x1c645; break; }
    if (memoryAGet16(ss, r16[bp] - 18) >= 0x007f)
        { pc = 0x1c645; break; }
    if (!memoryAGet16(ss, r16[bp] + 16))
        { pc = 0x1c60e; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] + 16))
        { pc = 0x1c645; break; }
  case 0x1c60e:
    if (!memoryAGet16(ss, r16[bp] + 18))
        { pc = 0x1c61c; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    if (r16[ax] >= memoryAGet16(ss, r16[bp] + 18))
        { pc = 0x1c645; break; }
  case 0x1c61c:
    r16[ax] = memoryAGet16(ss, r16[bp] - 18);
    r16[ax]++;
    r16[di] = r16[ax];
    { pc = 0x1c634; break; }
  case 0x1c624:
    r16[bx] = r16[di];
    r16[bx]--;
    r16[ax] = r16[bp] - 150;
    r16[bx] += r16[ax];
    r8[al] = memoryAGet(ds, r16[bx]);
    memoryASet(ss, r16[bp] + r16[di] + 65386, r8[al]);
    r16[di]--;
  case 0x1c634:
    if (r16[di] > r16[si])
        { pc = 0x1c624; break; }
    r8[al] = memoryAGet(ss, r16[bp] - 12);
    memoryASet(ss, r16[bp] + r16[si] + 65386, r8[al]);
    r16[si]++;
    memoryASet16(ss, r16[bp] - 2, 0x0001);
  case 0x1c645:
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1c694; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 278;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:147d");
    }
    sp += 0x0004;
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    r16[ax] = r16[bp] - 278;
    push(r16[ax]);
    push(cs); cs = 0x01ed; yield* sub_41b9(); assert(cs == 0x1b1e);
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:14a8");
    }
    sp += 0x0004;
    memoryASet16(ss, r16[bp] - 2, 0x0000);
  case 0x1c694:
    if (!memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x1c6b7; break; }
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    flags.carry = r16[dx] < 0x0046;
    r16[dx] -= 0x0046;
    r16[ax] -= (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    memoryASet16(ss, r16[bp] - 22, r16[dx]);
    memoryASet16(ss, r16[bp] - 6, 0x0000);
  case 0x1c6b7:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    flags.carry = r16[dx] < memoryAGet16(ss, r16[bp] - 22);
    r16[dx] -= memoryAGet16(ss, r16[bp] - 22);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 20) + flags.carry;
    if (false)
        { pc = 0x1c6e0; break; }
    if (!r16[ax])
        { pc = 0x1c6cf; break; }
    if (r16[dx] <= 0x0023)
        { pc = 0x1c6e0; break; }
  case 0x1c6cf:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    memoryASet16(ss, r16[bp] - 20, r16[ax]);
    memoryASet16(ss, r16[bp] - 22, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) ^ 0x0001);
  case 0x1c6e0:
    if (!memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1c6f9; break; }
    push(r16[si]);
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1c38f();
    sp += 0x0008;
  case 0x1c6f9:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x1b1e);
  case 0x1c6fe:
    if (memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1c707; break; }
    { pc = 0x1c44f; break; }
  case 0x1c707:
    if (!memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1c720; break; }
    push(r16[si]);
    r16[ax] = r16[bp] - 150;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1c38f();
    sp += 0x0008;
  case 0x1c720:
    if (memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x1c73f; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ss);
    r16[ax] = r16[bp] - 278;
    push(r16[ax]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1b1e); break;
        default:
            stop("ind 1b1e:1558");
    }
    sp += 0x0004;
  case 0x1c73f:
    push(cs); cs = 0x1ef3; yield* sub_1f7b6(); assert(cs == 0x1b1e);
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x1b1e);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1b1e);
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c765() // 1c76:0005 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xe834, 0x0000);
    r16[ax] = 0x21c5;
    r16[dx] = 0x00a2;
    memoryASet16(ds, 0xe816, r16[ax]);
    memoryASet16(ds, 0xe814, r16[dx]);
    memoryASet16(ds, 0xe81a, r16[ax]);
    memoryASet16(ds, 0xe818, r16[dx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1c784() // 1c76:0024 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xe834))
        { pc = 0x1c7a9; break; }
    memoryASet16(ds, 0xe834, memoryAGet16(ds, 0xe834) - 1);
    r16[bx] = memoryAGet16(ds, 0xe834);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 59418);
    r16[dx] = memoryAGet16(ds, r16[bx] + 59416);
    memoryASet16(ds, 0xe816, r16[ax]);
    memoryASet16(ds, 0xe814, r16[dx]);
  case 0x1c7a9:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c7ab() // 1c76:004b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (memoryAGet16(ds, 0xe834) == 0x0006)
        { pc = 0x1c7d6; break; }
    memoryASet16(ds, 0xe834, memoryAGet16(ds, 0xe834) + 1);
    r16[bx] = memoryAGet16(ds, 0xe834);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, r16[bx] + 59418, r16[ax]);
    memoryASet16(ds, r16[bx] + 59416, r16[dx]);
    memoryASet16(ds, 0xe816, r16[ax]);
    memoryASet16(ds, 0xe814, r16[dx]);
  case 0x1c7d6:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c7d8() // 1c76:0078 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[ax] |= memoryAGet16(es, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1c800; break; }
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs); cs = memoryAGet16(es, r16[bx] + 14); indirectCall(cs, memoryAGet16(es, r16[bx] + 12)); assert(cs == 0x1c76); // 1c76:0095
    sp += 0x0006;
    if (r16[ax])
        { pc = 0x1c86c; break; }
  case 0x1c800:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[si] = memoryAGet16(es, r16[bx] + 2);
    if (!(r16[si] & 0x0004))
        { pc = 0x1c822; break; }
    if (!(r16[si] & 0x0002))
        { pc = 0x1c818; break; }
    r16[ax] = 0x0005;
    { pc = 0x1c81b; break; }
  case 0x1c818:
    r16[ax] = 0x0004;
  case 0x1c81b:
    r16[ax] += 0x005c;
    r16[di] = r16[ax];
    { pc = 0x1c858; break; }
  case 0x1c822:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    if (memoryAGet16(es, r16[bx]) != 0x0002)
        { pc = 0x1c846; break; }
    if (r16[si] & 0x0001)
        { pc = 0x1c846; break; }
    if (!(r16[si] & 0x0002))
        { pc = 0x1c83c; break; }
    r16[ax] = 0x0003;
    { pc = 0x1c83f; break; }
  case 0x1c83c:
    r16[ax] = 0x0002;
  case 0x1c83f:
    r16[ax] += 0x005c;
    r16[di] = r16[ax];
    { pc = 0x1c858; break; }
  case 0x1c846:
    if (!(r16[si] & 0x0002))
        { pc = 0x1c851; break; }
    r16[ax] = 0x0001;
    { pc = 0x1c853; break; }
  case 0x1c851:
    r16[ax] = 0;
  case 0x1c853:
    r16[ax] += 0x005c;
    r16[di] = r16[ax];
  case 0x1c858:
    push(r16[di]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    push(memoryAGet16(es, r16[bx] + 16));
    push(memoryAGet16(es, r16[bx] + 14));
    push(cs); cs = 0x1ef3; yield* sub_1f9eb(); assert(cs == 0x1c76);
    sp += 0x0006;
  case 0x1c86c:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c870() // 1c76:0110 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[ax] |= memoryAGet16(es, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1c896; break; }
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(cs); cs = memoryAGet16(es, r16[bx] + 14); indirectCall(cs, memoryAGet16(es, r16[bx] + 12)); assert(cs == 0x1c76); // 1c76:012b
    sp += 0x0006;
    if (r16[ax])
        { pc = 0x1c904; break; }
  case 0x1c896:
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x009f;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    push(memoryAGet16(es, r16[bx] + 16));
    r16[ax] = 0x004b;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x1c76);
    sp += 0x000a;
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1c7d8();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    if (!(memoryAGet16(es, r16[bx] + 2) & 0x0002))
        { pc = 0x1c8d9; break; }
    if (memoryAGet16(es, r16[bx] + 2) & 0x0004)
        { pc = 0x1c8d9; break; }
    memoryASet(ds, 0x6025, 0x02);
    { pc = 0x1c8de; break; }
  case 0x1c8d9:
    memoryASet(ds, 0x6025, 0x0a);
  case 0x1c8de:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 14);
    r16[ax] += 0x0008;
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[ax]++;
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ds);
    push(memoryAGet16(es, r16[bx] + 6));
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:0198");
    }
    sp += 0x0004;
    memoryASet(ds, 0x6025, 0x0f);
  case 0x1c904:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1c906() // 1c76:01a6 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    memoryASet(ds, 0x6025, 0x0a);
    memoryASet16(ds, 0x6020, 0x004e);
    memoryASet16(ds, 0x6022, 0x0087);
    push(ds);
    push(memoryAGet16(ds, 0x78dc));
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:01c2");
    }
    sp += 0x0004;
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(ds);
    push(memoryAGet16(ds, 0x78da));
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:01d6");
    }
    sp += 0x0008;
    r16[ax] = 0x00e6;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ds, 0x6020, r16[ax]);
    push(ds);
    push(memoryAGet16(ds, 0x78da));
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:01eb");
    }
    sp += 0x0004;
    r16[ax] = r16[bp] - 4;
    push(r16[ax]);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    push(ds);
    push(memoryAGet16(ds, 0x78d8));
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:01ff");
    }
    sp += 0x0008;
    r16[ax] = 0x00a0;
    r16[ax] -= memoryAGet16(ss, r16[bp] - 2);
    r16[ax] >>= 1;
    r16[ax] += 0x004a;
    memoryASet16(ds, 0x6020, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] += memoryAGet16(ds, 0x6022);
    r16[ax]++;
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ds);
    push(memoryAGet16(ds, 0x78d8));
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:0224");
    }
    sp += 0x0004;
    memoryASet(ds, 0x6025, 0x00);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0085;
    push(r16[ax]);
    r16[ax] = 0x00e7;
    push(r16[ax]);
    r16[ax] = 0x004d;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x1c76);
    sp += 0x0008;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1c9ac() // 1c76:024c +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[ax] |= memoryAGet16(es, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1c9d8; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = memoryAGet16(es, r16[bx] + 14); indirectCall(cs, memoryAGet16(es, r16[bx] + 12)); assert(cs == 0x1c76); // 1c76:026a
    sp += 0x0006;
    if (!r16[ax])
        { pc = 0x1c9d8; break; }
    { pc = 0x1cab8; break; }
  case 0x1c9d8:
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    if (!memoryAGet16(es, r16[bx] + 4))
        { pc = 0x1ca13; break; }
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0037;
    push(r16[ax]);
    r16[ax] = 0x00e7;
    push(r16[ax]);
    r16[ax] = 0x004d;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x1c76);
    sp += 0x0008;
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    push(memoryAGet16(es, r16[bx] + 4));
    r16[ax] = 0x0030;
    push(r16[ax]);
    r16[ax] = 0x0050;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x1c76);
    sp += 0x0006;
  case 0x1ca13:
    push(cs);
    yield* sub_1c906();
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[ax] |= memoryAGet16(es, r16[bx] + 10);
    if (r16[ax])
        { pc = 0x1ca28; break; }
    { pc = 0x1cab8; break; }
  case 0x1ca28:
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx]);
    r16[ax] += 0x004a;
    r16[di] = r16[ax];
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    if (!r16[dx])
        { pc = 0x1ca4a; break; }
    r16[ax] = r16[di];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[ax] = 0x0008;
    r16[ax] -= r16[dx];
    r16[di] += r16[ax];
  case 0x1ca4a:
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    r16[ax] += 0x003c;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x1ca92; break; }
  case 0x1ca67:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 2) & 0x0008))
        { pc = 0x1ca75; break; }
    r16[si] += 0x0008;
  case 0x1ca75:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(es, r16[bx] + 14, r16[di]);
    memoryASet16(es, r16[bx] + 16, r16[si]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[bx]);
    push(cs);
    yield* sub_1c870();
    sp += 0x0004;
    r16[si] += 0x0008;
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0012);
  case 0x1ca92:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx]))
        { pc = 0x1ca67; break; }
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[ax] |= memoryAGet16(es, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1cab8; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(cs); cs = memoryAGet16(es, r16[bx] + 14); indirectCall(cs, memoryAGet16(es, r16[bx] + 12)); assert(cs == 0x1c76); // 1c76:0351
    sp += 0x0006;
  case 0x1cab8:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1cabe() // 1c76:035e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[ax] |= memoryAGet16(es, r16[bx] + 10);
    if (r16[ax])
        { pc = 0x1cad6; break; }
    if (!memoryAGet16(es, r16[bx] + 4))
        { pc = 0x1caea; break; }
  case 0x1cad6:
    r16[ax] = 0x0067;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fba9(); assert(cs == 0x1c76);
    sp += 0x0006;
    push(cs);
    yield* sub_1c9ac();
  case 0x1caea:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x1c76);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1caf1() // 1c76:0391 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] = 0x0079;
    push(r16[ax]);
    r16[ax] = 0x0030;
    push(r16[ax]);
    r16[ax] = 0x004a;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fc59(); assert(cs == 0x1c76);
    sp += 0x0006;
    r16[ax] = 0x00a0;
    r16[ax] -= memoryAGet16(ss, r16[bp] + 6);
    r16[ax] >>= 1;
    r16[ax] += 0x004a;
    memoryASet16(ds, r16[si], r16[ax]);
    r16[ax] = 0x0066;
    r16[ax] -= memoryAGet16(ss, r16[bp] + 8);
    r16[ax] >>= 1;
    r16[ax] += 0x0030;
    memoryASet16(ds, r16[di], r16[ax]);
    r16[ax] = 0x0008;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax]++;
    push(r16[ax]);
    push(memoryAGet16(ds, r16[di]));
    push(memoryAGet16(ds, r16[si]));
    push(cs); cs = 0x1ef3; yield* sub_1fd13(); assert(cs == 0x1c76);
    sp += 0x000a;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 6);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax]--;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x1c76);
    sp += 0x0008;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 6);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax]--;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x1c76);
    sp += 0x0008;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax]--;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x1c76);
    sp += 0x0008;
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[si]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 6);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax] += memoryAGet16(ss, r16[bp] + 8);
    r16[ax]++;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[ax]--;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1ff28(); assert(cs == 0x1c76);
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1cc96() // 1c76:0536 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x001e;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    r16[ax] = r16[bp] - 6;
    push(r16[ax]);
    push(ds);
    push(memoryAGet16(ss, r16[bp] + 6));
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:054d");
    }
    sp += 0x0008;
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    r16[ax] = r16[bp] - 8;
    push(r16[ax]);
    push(ds);
    push(memoryAGet16(ss, r16[bp] + 8));
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:0560");
    }
    sp += 0x0008;
    if (!r16[di])
        { pc = 0x1ccde; break; }
    r16[ax] = r16[bp] - 2;
    push(r16[ax]);
    r16[ax] = r16[bp] - 10;
    push(r16[ax]);
    push(ds);
    push(r16[di]);
    switch (memoryAGet32(ds, 0x43bc))
    {
        case 0x1ef3078d: push(cs); cs = 0x1ef3; yield* sub_1f6bd(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:0575");
    }
    sp += 0x0008;
    { pc = 0x1cce3; break; }
  case 0x1ccde:
    memoryASet16(ss, r16[bp] - 10, 0x0000);
  case 0x1cce3:
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1ccf7; break; }
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x1ccf2; break; }
    { pc = 0x1ccf5; break; }
  case 0x1ccf2:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
  case 0x1ccf5:
    { pc = 0x1cd04; break; }
  case 0x1ccf7:
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    if (r16[ax] <= memoryAGet16(ss, r16[bp] - 10))
        { pc = 0x1cd01; break; }
    { pc = 0x1cd04; break; }
  case 0x1cd01:
    r16[ax] = memoryAGet16(ss, r16[bp] - 10);
  case 0x1cd04:
    r16[si] = r16[ax];
    r16[si] += 0x0007;
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    if (!r16[di])
        { pc = 0x1cd18; break; }
    r16[ax] = 0x0005;
    { pc = 0x1cd1b; break; }
  case 0x1cd18:
    r16[ax] = 0x0004;
  case 0x1cd1b:
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = pop();
    imul16(r16[dx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[bp] - 14;
    push(r16[ax]);
    r16[ax] = r16[bp] - 12;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[si]);
    push(cs);
    yield* sub_1caf1();
    sp += 0x0008;
    memoryASet(ds, 0x6025, 0x02);
    r16[ax] = r16[si];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6020, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 14);
    r16[ax] += memoryAGet16(ss, r16[bp] - 4);
    r16[ax]++;
    memoryASet16(ds, 0x6022, r16[ax]);
    push(ds);
    push(memoryAGet16(ss, r16[bp] + 6));
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:05fb");
    }
    sp += 0x0004;
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] <<= 1;
    r16[ax]--;
    r16[dx] = memoryAGet16(ds, 0x6022);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6022, r16[dx]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] += r16[si];
    r16[ax] -= 0x0003;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    r16[ax] += 0x0003;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1fedf(); assert(cs == 0x1c76);
    sp += 0x0008;
    memoryASet16(ds, 0x6022, memoryAGet16(ds, 0x6022) + 0x0002);
    memoryASet(ds, 0x6025, 0x0a);
    r16[ax] = r16[si];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 8);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6020, r16[dx]);
    push(ds);
    push(memoryAGet16(ss, r16[bp] + 8));
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:064d");
    }
    sp += 0x0004;
    r16[ax] = memoryAGet16(ds, 0x6022);
    r16[ax] += memoryAGet16(ss, r16[bp] - 4);
    memoryASet16(ds, 0x6022, r16[ax]);
    if (!r16[di])
        { pc = 0x1cdda; break; }
    r16[ax] = r16[si];
    r16[ax] -= memoryAGet16(ss, r16[bp] - 10);
    r16[ax] >>= 1;
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] += r16[ax];
    memoryASet16(ds, 0x6020, r16[dx]);
    push(ds);
    push(r16[di]);
    switch (memoryAGet32(ds, 0x43c0))
    {
        case 0x1ef30e2c: push(cs); cs = 0x1ef3; yield* sub_1fd5c(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:0673");
    }
    sp += 0x0004;
  case 0x1cdda:
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x1c76);
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1c76);
  case 0x1cde4:
    r16[ax] = r16[bp] - 30;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16dc9(); assert(cs == 0x1c76);
    sp += 0x0002;
    if (!memoryAGet16(ss, r16[bp] - 30))
        { pc = 0x1cdfc; break; }
    memoryASet(ss, r16[bp] - 15, 0x15);
    { pc = 0x1ce0e; break; }
  case 0x1cdfc:
    if (!memoryAGet16(ss, r16[bp] - 28))
        { pc = 0x1ce08; break; }
    memoryASet(ss, r16[bp] - 15, 0x01);
    { pc = 0x1ce0e; break; }
  case 0x1ce08:
    r8[al] = memoryAGet(ds, 0xa545);
    memoryASet(ss, r16[bp] - 15, r8[al]);
  case 0x1ce0e:
    if (!memoryAGet(ss, r16[bp] - 15))
        { pc = 0x1cde4; break; }
  case 0x1ce14:
    r16[ax] = r16[bp] - 30;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16dc9(); assert(cs == 0x1c76);
    sp += 0x0002;
    if (memoryAGet16(ss, r16[bp] - 30))
        { pc = 0x1ce14; break; }
    if (memoryAGet16(ss, r16[bp] - 28))
        { pc = 0x1ce14; break; }
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1c76);
    push(cs);
    yield* sub_1cabe();
    if (memoryAGet(ss, r16[bp] - 15) != 0x15)
        { pc = 0x1ce40; break; }
    r16[ax] = 0x0001;
    { pc = 0x1ce42; break; }
  case 0x1ce40:
    r16[ax] = 0;
  case 0x1ce42:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ce48() // 1c76:06e8 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0006;
    push(r16[si]);
    push(r16[di]);
    if (memoryAGet16(ss, r16[bp] + 6))
        { pc = 0x1ce62; break; }
    r16[ax] = 0x4903;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1c76);
    sp += 0x0002;
  case 0x1ce62:
    memoryASet16(ss, r16[bp] - 2, 0x0001);
    r16[si] = 0;
    memoryASet16(ss, r16[bp] - 6, 0x4922);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] -= 0x0002;
    if (r16[bx] > 0x0005)
        { pc = 0x1cee2; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x1ce80; break; }
        case 2: { pc = 0x1ce9d; break; }
        case 4: { pc = 0x1ceaa; break; }
        case 6: { pc = 0x1cec7; break; }
        case 8: { pc = 0x1cec7; break; }
        case 10: { pc = 0x1cec7; break; }
        default:
            stop("ind 1c76:071b");
    }
    break;
  case 0x1ce80:
    r16[di] = 0x4932;
    memoryASet16(ss, r16[bp] - 4, 0x494b);
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x1cee2; break; }
    if (!memoryAGet16(ds, 0x78e2))
        { pc = 0x1cee2; break; }
    r16[si] = 0x0001;
    { pc = 0x1cee2; break; }
    // gap 2 bytes
  case 0x1ce9d:
    r16[di] = 0x495d;
    memoryASet16(ss, r16[bp] - 4, 0x496a);
    r16[si] = 0x0001;
    { pc = 0x1cee2; break; }
  case 0x1ceaa:
    r16[di] = 0x497a;
    memoryASet16(ss, r16[bp] - 4, 0x498b);
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x1cee2; break; }
    if (!memoryAGet16(ds, 0x78e2))
        { pc = 0x1cee2; break; }
    r16[si] = 0x0001;
    { pc = 0x1cee2; break; }
    // gap 2 bytes
  case 0x1cec7:
    r16[di] = 0x49a0;
    memoryASet16(ss, r16[bp] - 4, 0x49b1);
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x1cee2; break; }
    if (!memoryAGet16(ds, 0x78e2))
        { pc = 0x1cee2; break; }
    r16[si] = 0x0001;
    { pc = 0x1cee2; break; }
  case 0x1cee2:
    if (!r16[si])
        { pc = 0x1cef6; break; }
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(r16[di]);
    push(cs);
    yield* sub_1cc96();
    sp += 0x0006;
    { pc = 0x1cef9; break; }
  case 0x1cef6:
    r16[ax] = 0x0001;
  case 0x1cef9:
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1cf0e; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x78d6, r16[ax]);
    memoryASet16(ds, 0x78de, 0x0001);
  case 0x1cf0e:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1cfcb() // 1c76:086b +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xc5cd))
        { pc = 0x1cfda; break; }
    r16[ax] = 0x4a04;
    { pc = 0x1cfdd; break; }
  case 0x1cfda:
    r16[ax] = 0x4a13;
  case 0x1cfdd:
    r16[dx] = 0x2197;
    es = r16[dx];
    memoryASet16(es, 0x0006, r16[ax]);
    if (!memoryAGet16(ds, 0xc5cf))
        { pc = 0x1cff2; break; }
    r16[ax] = 0x4a23;
    { pc = 0x1cff5; break; }
  case 0x1cff2:
    r16[ax] = 0x4a3a;
  case 0x1cff5:
    r16[dx] = 0x2197;
    es = r16[dx];
    memoryASet16(es, 0x0018, r16[ax]);
    if (!memoryAGet16(ds, 0x7a14))
        { pc = 0x1d00a; break; }
    r16[ax] = 0x4a52;
    { pc = 0x1d00d; break; }
  case 0x1d00a:
    r16[ax] = 0x4a68;
  case 0x1d00d:
    r16[dx] = 0x2197;
    es = r16[dx];
    memoryASet16(es, 0x002a, r16[ax]);
    if (!memoryAGet16(ds, 0xe6e8))
        { pc = 0x1d022; break; }
    r16[ax] = 0x4a7f;
    { pc = 0x1d025; break; }
  case 0x1d022:
    r16[ax] = 0x4a97;
  case 0x1d025:
    r16[dx] = 0x2197;
    es = r16[dx];
    memoryASet16(es, 0x003c, r16[ax]);
    r16[ax] = 0x21aa;
    es = r16[ax];
    memoryASet16(es, 0x0026, memoryAGet16(es, 0x0026) & 0xfffb);
    if (!memoryAGet16(ds, 0xc5cf))
        { pc = 0x1d048; break; }
    es = r16[ax];
    memoryASet16(es, 0x0026, memoryAGet16(es, 0x0026) | 0x0004);
  case 0x1d048:
    r16[ax] = 0x21b9;
    es = r16[ax];
    memoryASet16(es, 0x006e, memoryAGet16(es, 0x006e) | 0x0004);
    if (memoryAGet16(ds, 0xcc0d) == 0x0002)
        { pc = 0x1d061; break; }
    if (memoryAGet16(ds, 0xcc0d) != 0x0003)
        { pc = 0x1d06c; break; }
  case 0x1d061:
    r16[ax] = 0x21b9;
    es = r16[ax];
    memoryASet16(es, 0x006e, memoryAGet16(es, 0x006e) & 0xfffb);
  case 0x1d06c:
    if (!memoryAGet16(ds, 0xc643))
        { pc = 0x1d078; break; }
    r16[ax] = 0x4ab0;
    { pc = 0x1d07b; break; }
  case 0x1d078:
    r16[ax] = 0x4ac8;
  case 0x1d07b:
    r16[dx] = 0x21b9;
    es = r16[dx];
    memoryASet16(es, 0x0072, r16[ax]);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e5fe() // 1c76:1e9e +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[ax] |= memoryAGet16(es, r16[bx] + 10);
    if (!r16[ax])
        { pc = 0x1e652; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    { pc = 0x1e649; break; }
  case 0x1e624:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) & 0xfff8);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[ax] |= memoryAGet16(es, r16[bx] + 12);
    if (!r16[ax])
        { pc = 0x1e645; break; }
    push(memoryAGet16(es, r16[bx] + 12));
    push(memoryAGet16(es, r16[bx] + 10));
    push(cs);
    yield* sub_1e5fe();
    sp += 0x0004;
  case 0x1e645:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0012);
  case 0x1e649:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx]))
        { pc = 0x1e624; break; }
  case 0x1e652:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e656() // 1c76:1ef6 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[cx] = 0;
    { pc = 0x1e687; break; }
  case 0x1e671:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 2) & 0x0001))
        { pc = 0x1e682; break; }
    r16[ax] = r16[cx];
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1e682:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0012);
    r16[cx]++;
  case 0x1e687:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx]))
        { pc = 0x1e671; break; }
    r16[ax] = 0xffff;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e697() // 1c76:1f37 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    if (memoryAGet16(es, r16[bx] + 16) == r16[di])
        { pc = 0x1e6e1; break; }
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    push(r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[bx] = 0x0012;
    push(r16[dx]);
    imul16(r16[bx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[ax] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) & 0xfffd);
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1e6e1; break; }
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[dx]);
    push(cs);
    yield* sub_1c870();
    sp += 0x0004;
  case 0x1e6e1:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(es, r16[bx] + 16, r16[di]);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    push(r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[bx] = 0x0012;
    push(r16[dx]);
    imul16(r16[bx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[ax] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    push(es);
    r16[si] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[si] + 16);
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[bx] += r16[ax];
    es = pop();
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) | 0x0002);
    if (!memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1e734; break; }
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs);
    yield* sub_1c870();
    sp += 0x0004;
  case 0x1e734:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e73a() // 1c76:1fda +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    push(r16[di]);
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1e697();
    sp += 0x0008;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[si] = 0;
    { pc = 0x1e7b8; break; }
  case 0x1e76b:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx]) != 0x0002)
        { pc = 0x1e7b3; break; }
    if (r16[si] != memoryAGet16(ss, r16[bp] + 10))
        { pc = 0x1e794; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) | 0x0001);
    if (!r16[di])
        { pc = 0x1e7b3; break; }
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[bx]);
    push(cs);
    yield* sub_1c870();
    sp += 0x0004;
    { pc = 0x1e7b3; break; }
    // gap 2 bytes
  case 0x1e794:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 2) & 0x0001))
        { pc = 0x1e7b3; break; }
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) & 0xfffe);
    if (!r16[di])
        { pc = 0x1e7b3; break; }
    push(memoryAGet16(ss, r16[bp] - 2));
    push(r16[bx]);
    push(cs);
    yield* sub_1c870();
    sp += 0x0004;
  case 0x1e7b3:
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0012);
    r16[si]++;
  case 0x1e7b8:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (memoryAGet16(es, r16[bx]))
        { pc = 0x1e76b; break; }
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e7c7() // 1c76:2067 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[ax]++;
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    r16[bx] += r16[ax];
    if (!memoryAGet16(es, r16[bx]))
        { pc = 0x1e7fe; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[ax]++;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xe816));
    push(r16[bx]);
    push(cs);
    yield* sub_1e697();
    sp += 0x0008;
  case 0x1e7fe:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e800() // 1c76:20a0 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    if (!memoryAGet16(es, r16[bx] + 16))
        { pc = 0x1e828; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[ax]--;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xe816));
    push(r16[bx]);
    push(cs);
    yield* sub_1e697();
    sp += 0x0008;
  case 0x1e828:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e82a() // 1c76:20ca +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0x78dc, 0x4e09);
    memoryASet16(ds, 0x78da, 0x4e15);
    if (!memoryAGet16(ds, 0xe834))
        { pc = 0x1e845; break; }
    r16[ax] = 0x4e23;
    { pc = 0x1e848; break; }
  case 0x1e845:
    r16[ax] = 0x4e33;
  case 0x1e848:
    memoryASet16(ds, 0x78d8, r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    push(memoryAGet16(es, r16[bx] + 16));
    push(memoryAGet16(ds, 0xe816));
    push(r16[bx]);
    push(cs);
    yield* sub_1e697();
    sp += 0x0008;
    push(cs);
    yield* sub_1cabe();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e868() // 1c76:2108 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] |= memoryAGet16(ss, r16[bp] + 8);
    if (r16[ax])
        { pc = 0x1e87f; break; }
    r16[ax] = 0x4e3f;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1c76);
    sp += 0x0002;
  case 0x1e87f:
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1c7ab();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[ax] |= memoryAGet16(es, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1e8ad; break; }
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    push(r16[ax]);
    push(cs); cs = memoryAGet16(es, r16[bx] + 14); indirectCall(cs, memoryAGet16(es, r16[bx] + 12)); assert(cs == 0x1c76); // 1c76:213e
    sp += 0x0006;
    if (!r16[ax])
        { pc = 0x1e8ad; break; }
    push(cs);
    yield* sub_1c784();
  case 0x1e8ad:
    push(cs);
    yield* sub_1e82a();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e8b3() // 1c76:2153 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    if (memoryAGet16(ds, 0xe834))
        { pc = 0x1e8cc; break; }
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs);
    yield* sub_1ce48();
    sp += 0x0002;
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1e8cc:
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 8);
    r16[ax] |= memoryAGet16(es, r16[bx] + 10);
    if (!r16[ax])
        { pc = 0x1e8f4; break; }
    r16[tx] = memoryAGet16(es, r16[bx] + 8); es = memoryAGet16(es, r16[bx] + 10); r16[bx] = r16[tx];
    push(es);
    r16[si] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[si] + 16);
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[bx] += r16[ax];
    es = pop();
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) & 0xfffd);
  case 0x1e8f4:
    push(cs);
    yield* sub_1c784();
    push(cs);
    yield* sub_1e82a();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e8ff() // 1c76:219f +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0004;
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    push(r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[bx] = 0x0012;
    push(r16[dx]);
    imul16(r16[bx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[ax] = pop();
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    memoryASet16(ss, r16[bp] - 4, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    if (!(memoryAGet16(es, r16[bx] + 2) & 0x0004))
        { pc = 0x1e941; break; }
    r16[ax] = 0x000e;
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1b001(); assert(cs == 0x1c76);
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1e941:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx]);
    if (r16[ax] == 0x0001)
        { pc = 0x1e95a; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1e993; break; }
    if (r16[ax] == 0x0003)
        { pc = 0x1e9af; break; }
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1e95a:
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 12);
    r16[ax] |= memoryAGet16(es, r16[bx] + 14);
    if (!r16[ax])
        { pc = 0x1e97d; break; }
    push(memoryAGet16(ss, r16[bp] - 2));
    push(memoryAGet16(ss, r16[bp] - 4));
    r16[ax] = 0x0005;
    push(r16[ax]);
    push(cs); cs = memoryAGet16(es, r16[bx] + 14); indirectCall(cs, memoryAGet16(es, r16[bx] + 12)); assert(cs == 0x1c76); // 1c76:2212
    sp += 0x0006;
    if (r16[ax])
        { pc = 0x1e9c1; break; }
  case 0x1e97d:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx] + 8));
    push(cs);
    yield* sub_1ce48();
    sp += 0x0002;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 4 bytes
  case 0x1e993:
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    push(memoryAGet16(es, r16[bx] + 16));
    push(memoryAGet16(ds, 0xe816));
    push(r16[bx]);
    push(cs);
    yield* sub_1e73a();
    sp += 0x0008;
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1e9af:
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    push(memoryAGet16(es, r16[bx] + 12));
    push(memoryAGet16(es, r16[bx] + 10));
    push(cs);
    yield* sub_1e868();
    sp += 0x0004;
  case 0x1e9c1:
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1e9c5() // 1c76:2265 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = memoryAGet16(ds, 0xc635);
    if (r16[si] != 0x0002)
        { pc = 0x1e9da; break; }
    if (!memoryAGet16(ds, 0xc637))
        { pc = 0x1e9da; break; }
    r16[si]++;
  case 0x1e9da:
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[si]);
    r16[ax] = 0x2174;
    push(r16[ax]);
    r16[ax] = 0x005a;
    push(r16[ax]);
    push(cs);
    yield* sub_1e73a();
    sp += 0x0008;
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xc633));
    r16[ax] = 0x217b;
    push(r16[ax]);
    r16[ax] = 0x0036;
    push(r16[ax]);
    push(cs);
    yield* sub_1e73a();
    sp += 0x0008;
    if (memoryAGet16(ds, 0xc639))
        { pc = 0x1ea28; break; }
    r16[ax] = 0x2174;
    es = r16[ax];
    memoryASet16(es, 0x0026, memoryAGet16(es, 0x0026) | 0x0004);
    es = r16[ax];
    memoryASet16(es, 0x0038, memoryAGet16(es, 0x0038) | 0x0004);
    r16[ax] = 0x217b;
    es = r16[ax];
    memoryASet16(es, 0x0014, memoryAGet16(es, 0x0014) | 0x0004);
  case 0x1ea28:
    if (memoryAGet16(ds, 0xcc46))
        { pc = 0x1ea3a; break; }
    r16[ax] = 0x21b9;
    es = r16[ax];
    memoryASet16(es, 0x004a, memoryAGet16(es, 0x004a) | 0x0004);
  case 0x1ea3a:
    if (memoryAGet16(ds, 0xcc48))
        { pc = 0x1ea4c; break; }
    r16[ax] = 0x21b9;
    es = r16[ax];
    memoryASet16(es, 0x005c, memoryAGet16(es, 0x005c) | 0x0004);
  case 0x1ea4c:
    if (memoryAGet16(ds, 0xcc46))
        { pc = 0x1ea65; break; }
    if (memoryAGet16(ds, 0xcc48))
        { pc = 0x1ea65; break; }
    r16[ax] = 0x21b9;
    es = r16[ax];
    memoryASet16(es, 0x006e, memoryAGet16(es, 0x006e) | 0x0004);
  case 0x1ea65:
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x1ea71; break; }
    r16[ax] = 0x4e5a;
    { pc = 0x1ea74; break; }
  case 0x1ea71:
    r16[ax] = 0x4e69;
  case 0x1ea74:
    r16[dx] = 0x21c5;
    es = r16[dx];
    memoryASet16(es, 0x004e, r16[ax]);
    if (memoryAGet16(ds, 0xc631))
        { pc = 0x1ea97; break; }
    r16[ax] = 0x21c5;
    es = r16[ax];
    memoryASet16(es, 0x0026, memoryAGet16(es, 0x0026) | 0x0004);
    es = r16[ax];
    memoryASet16(es, 0x005c, memoryAGet16(es, 0x005c) | 0x0004);
  case 0x1ea97:
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x1eaa3; break; }
    r16[ax] = 0x0004;
    { pc = 0x1eaa5; break; }
  case 0x1eaa3:
    r16[ax] = 0;
  case 0x1eaa5:
    r16[dx] = 0x21c5;
    es = r16[dx];
    memoryASet16(es, 0x00b2, r16[ax]);
    push(cs);
    yield* sub_1cfcb();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1eab5() // 1c76:2355 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(cs); cs = 0x1493; yield* sub_15dfd(); assert(cs == 0x1c76);
    r16[si] = 0x0058;
    { pc = 0x1ead2; break; }
  case 0x1eac3:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si], memoryAGet(es, r16[si]) | r8[dl]);
    r16[si]++;
  case 0x1ead2:
    if (r16s[si] <= signed16(0x0067))
        { pc = 0x1eac3; break; }
    r16[si] = 0x007c;
    { pc = 0x1eaeb; break; }
  case 0x1eadc:
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, r16[si], memoryAGet(es, r16[si]) | r8[dl]);
    r16[si]++;
  case 0x1eaeb:
    if (r16s[si] <= signed16(0x0080))
        { pc = 0x1eadc; break; }
    r16[ax] = 0x2c27;
    r8[dl] = memoryAGet(ds, 0x7aec);
    es = r16[ax];
    memoryASet(es, 0x0004, memoryAGet(es, 0x0004) | r8[dl]);
    es = r16[ax];
    memoryASet(es, 0x0079, memoryAGet(es, 0x0079) | r8[dl]);
    r16[ax] = 0x4e78;
    push(r16[ax]);
    push(cs); cs = 0x1493; yield* sub_1617b(); assert(cs == 0x1c76);
    sp += 0x0002;
    push(cs); cs = 0x1493; yield* sub_15458(); assert(cs == 0x1c76);
    memoryASet16(ds, 0xa550, 0x0001);
    r16[ax] = 0x1ef3;
    push(r16[ax]);
    r16[ax] = 0x0e2c;
    push(r16[ax]);
    r16[ax] = 0x1ef3;
    push(r16[ax]);
    r16[ax] = 0x078d;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1beba(); assert(cs == 0x1c76);
    sp += 0x0008;
    memoryASet(ds, 0x6025, 0x0f);
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x1c76);
    sp += 0x0002;
    push(cs); cs = 0x1841; yield* sub_18549(); assert(cs == 0x1c76);
    push(cs); cs = 0x1ef3; yield* sub_1f8b1(); assert(cs == 0x1c76);
    memoryASet16(ds, 0x78d6, 0x0000);
    r16[ax] = 0x21c5;
    push(r16[ax]);
    r16[ax] = 0x00a2;
    push(r16[ax]);
    push(cs);
    yield* sub_1e5fe();
    sp += 0x0004;
    push(cs);
    yield* sub_1e9c5();
    push(cs);
    yield* sub_1c765();
    push(cs);
    yield* sub_1e82a();
    if (!memoryAGet16(ds, 0xc631))
        { pc = 0x1eb7e; break; }
    memoryASet16(ds, 0x78e2, 0x0001);
  case 0x1eb7e:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1c76);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1eb86() // 1c76:2426 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx]--;
    if (r16[bx] > 0x0006)
        { pc = 0x1ebc3; break; }
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: { pc = 0x1ebcf; break; }
        case 2: { pc = 0x1eb9b; break; }
        case 4: { pc = 0x1eba3; break; }
        case 6: { pc = 0x1ebcf; break; }
        case 8: { pc = 0x1ebab; break; }
        case 10: { pc = 0x1ebb3; break; }
        case 12: { pc = 0x1ebbb; break; }
        default:
            stop("ind 1c76:2434");
    }
    break;
    // gap 2 bytes
  case 0x1eb9b:
    memoryASet16(ds, 0xc62f, 0x0001);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1eba3:
    memoryASet16(ds, 0x78e0, 0x0001);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1ebab:
    memoryASet16(ds, 0x474a, 0x0001);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1ebb3:
    memoryASet16(ds, 0x474a, 0x0002);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1ebbb:
    memoryASet16(ds, 0x474a, 0x0003);
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1ebc3:
    r16[ax] = 0x4e86;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1c76);
    sp += 0x0002;
  case 0x1ebcf:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ebe0() // 1c76:2480 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[ax] = 0x2174;
    push(r16[ax]);
    r16[ax] = 0x005a;
    push(r16[ax]);
    push(cs);
    yield* sub_1e656();
    sp += 0x0004;
    r16[si] = r16[ax];
    if (r16[si] != 0x0003)
        { pc = 0x1ec03; break; }
    memoryASet16(ds, 0xc637, 0x0001);
    r16[si]--;
    { pc = 0x1ec09; break; }
  case 0x1ec03:
    memoryASet16(ds, 0xc637, 0x0000);
  case 0x1ec09:
    if (r16[si] == memoryAGet16(ds, 0xc635))
        { pc = 0x1ec18; break; }
    push(r16[si]);
    push(cs); cs = 0x1a61; yield* sub_1ad5b(); assert(cs == 0x1c76);
    sp += 0x0002;
  case 0x1ec18:
    r16[ax] = 0x217b;
    push(r16[ax]);
    r16[ax] = 0x0036;
    push(r16[ax]);
    push(cs);
    yield* sub_1e656();
    sp += 0x0004;
    r16[si] = r16[ax];
    if (r16[si] == memoryAGet16(ds, 0xc633))
        { pc = 0x1ec38; break; }
    push(r16[ax]);
    push(cs); cs = 0x1a61; yield* sub_1ade0(); assert(cs == 0x1c76);
    sp += 0x0002;
  case 0x1ec38:
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ec3b() // 1c76:24db +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_1ebe0();
    if (!memoryAGet16(ds, 0x78d6))
        { pc = 0x1ec54; break; }
    push(memoryAGet16(ds, 0x78d6));
    push(cs);
    yield* sub_1eb86();
    sp += 0x0002;
  case 0x1ec54:
    memoryASet16(ds, 0xa550, 0x0000);
    memoryASet(ds, 0x6025, 0x0f);
    if (!memoryAGet16(ds, 0x474a))
        { pc = 0x1ec75; break; }
    r16[ax] = memoryAGet16(ds, 0xe7fa);
    r16[ax] |= memoryAGet16(ds, 0xe7fc);
    if (!r16[ax])
        { pc = 0x1ec75; break; }
    switch (memoryAGet32(ds, 0xe7fa))
    {
        case 0x07b10466: push(cs); cs = 0x07b1; yield* sub_7f76(); assert(cs == 0x1c76); break;
        default:
            stop("ind 1c76:250f");
    }
    { pc = 0x1ecc0; break; }
  case 0x1ec75:
    if (!memoryAGet16(ds, 0x78e0))
        { pc = 0x1ecc0; break; }
    if (!memoryAGet16(ds, 0x7adc))
        { pc = 0x1ec8a; break; }
    push(cs); cs = 0x056a; yield* sub_59c9(); assert(cs == 0x1c76);
    { pc = 0x1ecc0; break; }
  case 0x1ec8a:
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = 0x0014;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1c250(); assert(cs == 0x1c76);
    sp += 0x0004;
    memoryASet(ds, 0x6025, 0x03);
    r16[ax] = 0x4ea1;
    push(r16[ax]);
    push(cs); cs = 0x1b1e; yield* sub_1bfff(); assert(cs == 0x1c76);
    sp += 0x0002;
    memoryASet(ds, 0x6025, 0x0f);
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x1c76);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1c76);
    sp += 0x0002;
  case 0x1ecc0:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1c76);
    push(cs); cs = 0x1a61; yield* sub_1b10d(); assert(cs == 0x1c76);
    r16[ax] = 0x0003;
    push(r16[ax]);
    push(cs); cs = 0x1ef3; yield* sub_1f23d(); assert(cs == 0x1c76);
    sp += 0x0002;
    push(cs); cs = 0x1493; yield* sub_15e1d(); assert(cs == 0x1c76);
    push(cs); cs = 0x1493; yield* sub_15458(); assert(cs == 0x1c76);
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ece2() // 1c76:2582 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x001a;
    push(r16[si]);
    push(r16[di]);
    if (memoryAGet(ds, 0xa545) < 0x3b)
        { pc = 0x1ecf8; break; }
    if (memoryAGet(ds, 0xa545) <= 0x44)
        { pc = 0x1ecfd; break; }
  case 0x1ecf8:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1c76);
  case 0x1ecfd:
    push(cs);
    yield* sub_1eab5();
    push(cs);
    yield* sub_1cabe();
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    memoryASet16(ds, 0x78de, 0x0000);
    r16[ax] = 0x0001;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[si] = r16[ax];
    { pc = 0x1eedc; break; }
  case 0x1ed1b:
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    push(r16[ax]);
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    r16[bx] = 0x0012;
    push(r16[dx]);
    imul16(r16[bx]);
    r16[dx] = pop();
    r16[dx] += r16[ax];
    r16[ax] = pop();
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    if (!r16[si])
        { pc = 0x1ed55; break; }
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    flags.carry = r16[dx] + 0x0023 >= 0x10000;
    r16[dx] += 0x0023;
    r16[ax] += (0x0000 + flags.carry);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    memoryASet16(ss, r16[bp] - 8, r16[dx]);
    r16[si] = 0;
  case 0x1ed55:
    r16[ax] = memoryAGet16(ds, 0xa53f);
    r16[dx] = memoryAGet16(ds, 0xa53d);
    if (r16[ax] < memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x1ed92; break; }
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 6))
        { pc = 0x1ed68; break; }
    if (r16[dx] < memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1ed92; break; }
  case 0x1ed68:
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) ^ 0x0001);
    r16[si] = 0x0001;
    if (memoryAGet16(ss, r16[bp] - 2))
        { pc = 0x1ed7d; break; }
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) & 0xfffd);
  case 0x1ed7d:
    push(memoryAGet16(ss, r16[bp] - 10));
    push(memoryAGet16(ss, r16[bp] - 12));
    push(cs);
    yield* sub_1c7d8();
    sp += 0x0004;
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    memoryASet16(es, r16[bx] + 2, memoryAGet16(es, r16[bx] + 2) | 0x0002);
  case 0x1ed92:
    yield* sync();
    push(cs); cs = 0x1ef3; yield* sub_1f9cb(); assert(cs == 0x1c76);
    if (memoryAGet(ds, 0xa545))
        { pc = 0x1eda1; break; }
    { pc = 0x1ee64; break; }
  case 0x1eda1:
    r8[al] = memoryAGet(ds, 0xa545);
    r8[ah] = 0x00;
    if (r16[ax] == 0x003b)
        { pc = 0x1ede9; break; }
    if (r16s[ax] > signed16(0x003b))
        { pc = 0x1edb9; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1ede0; break; }
    if (r16[ax] == 0x001c)
        { pc = 0x1edd7; break; }
    { pc = 0x1edf5; break; }
  case 0x1edb9:
    if (r16[ax] == 0x0048)
        { pc = 0x1edc5; break; }
    if (r16[ax] == 0x0050)
        { pc = 0x1edce; break; }
    { pc = 0x1edf5; break; }
  case 0x1edc5:
    push(cs);
    yield* sub_1e800();
    r16[si] = 0x0001;
    { pc = 0x1edf5; break; }
  case 0x1edce:
    push(cs);
    yield* sub_1e7c7();
    r16[si] = 0x0001;
    { pc = 0x1edf5; break; }
  case 0x1edd7:
    push(cs);
    yield* sub_1e8ff();
    r16[si] = 0x0001;
    { pc = 0x1edf5; break; }
  case 0x1ede0:
    push(cs);
    yield* sub_1e8b3();
    r16[si] = 0x0001;
    { pc = 0x1edf5; break; }
  case 0x1ede9:
    push(cs); cs = 0x0b02; yield* sub_b9c5(); assert(cs == 0x1c76);
    push(cs);
    yield* sub_1cabe();
    r16[si] = 0x0001;
  case 0x1edf5:
    if (r16[si])
        { pc = 0x1ee0f; break; }
    r8[al] = memoryAGet(ds, 0xa545);
    if (r8[al] == memoryAGet(ds, 0x3bc2))
        { pc = 0x1ee08; break; }
    if (r8[al] != memoryAGet(ds, 0x3bc3))
        { pc = 0x1ee0f; break; }
  case 0x1ee08:
    push(cs);
    yield* sub_1e8ff();
    r16[si] = 0x0001;
  case 0x1ee0f:
    if (r16[si])
        { pc = 0x1ee5d; break; }
    r16[bx] = memoryAGet16(ds, 0xe814); es = memoryAGet16(ds, 0xe816);
    r16[ax] = memoryAGet16(es, r16[bx] + 10);
    r16[dx] = memoryAGet16(es, r16[bx] + 8);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    r16[di] = 0;
    { pc = 0x1ee54; break; }
  case 0x1ee29:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    r8[al] = memoryAGet(es, r16[bx] + 4);
    if (r8[al] != memoryAGet(ds, 0xa545))
        { pc = 0x1ee4f; break; }
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(r16[di]);
    push(memoryAGet16(ds, 0xe816));
    push(memoryAGet16(ds, 0xe814));
    push(cs);
    yield* sub_1e697();
    sp += 0x0008;
    r16[si] = 0x0001;
    { pc = 0x1ee5d; break; }
  case 0x1ee4f:
    memoryASet16(ss, r16[bp] - 12, memoryAGet16(ss, r16[bp] - 12) + 0x0012);
    r16[di]++;
  case 0x1ee54:
    r16[bx] = memoryAGet16(ss, r16[bp] - 12); es = memoryAGet16(ss, r16[bp] - 10);
    if (memoryAGet16(es, r16[bx]))
        { pc = 0x1ee29; break; }
  case 0x1ee5d:
    push(cs); cs = 0x164d; yield* sub_16d78(); assert(cs == 0x1c76);
    { pc = 0x1eedc; break; }
  case 0x1ee64:
    r16[ax] = r16[bp] - 26;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16dc9(); assert(cs == 0x1c76);
    sp += 0x0002;
    r16[ax] = memoryAGet16(ss, r16[bp] - 20);
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + r16[ax]);
    if (!memoryAGet16(ss, r16[bp] - 26))
        { pc = 0x1ee97; break; }
  case 0x1ee7c:
    r16[ax] = r16[bp] - 26;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16dc9(); assert(cs == 0x1c76);
    sp += 0x0002;
    if (memoryAGet16(ss, r16[bp] - 26))
        { pc = 0x1ee7c; break; }
    push(cs);
    yield* sub_1e8ff();
    r16[si] = 0x0001;
    { pc = 0x1eedc; break; }
  case 0x1ee97:
    if (!memoryAGet16(ss, r16[bp] - 24))
        { pc = 0x1eeb8; break; }
  case 0x1ee9d:
    r16[ax] = r16[bp] - 26;
    push(r16[ax]);
    push(cs); cs = 0x164d; yield* sub_16dc9(); assert(cs == 0x1c76);
    sp += 0x0002;
    if (memoryAGet16(ss, r16[bp] - 24))
        { pc = 0x1ee9d; break; }
    push(cs);
    yield* sub_1e8b3();
    r16[si] = 0x0001;
    { pc = 0x1eedc; break; }
  case 0x1eeb8:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0xffd8))
        { pc = 0x1eecb; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) + 0x0028);
    push(cs);
    yield* sub_1e800();
    r16[si] = 0x0001;
    { pc = 0x1eedc; break; }
  case 0x1eecb:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) <= signed16(0x0028))
        { pc = 0x1eedc; break; }
    memoryASet16(ss, r16[bp] - 4, memoryAGet16(ss, r16[bp] - 4) - 0x0028);
    push(cs);
    yield* sub_1e7c7();
    r16[si] = 0x0001;
  case 0x1eedc:
    if (memoryAGet16(ds, 0x78de))
        { pc = 0x1eee6; break; }
    { pc = 0x1ed1b; break; }
  case 0x1eee6:
    push(cs);
    yield* sub_1ec3b();
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1eef2() // 1eef:0002 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = 0x20c0;
    es = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    if (r16[ax])
        { pc = 0x1ef09; break; }
    r16[dx] = 0x0000;
    { pc = 0x1ef11; break; }
    // gap 1 bytes
  case 0x1ef09:
    r8[ah] = 0x2c;
    interrupt(0x21);
    r16[dx] &= 0x00ff;
  case 0x1ef11:
    memoryASet16(es, 0x0000, r16[dx]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ef1a() // 1eef:002a +far +stackDrop2
{
    sp -= 2;
    r16[ax] = 0x20c0;
    es = r16[ax];
    r16[bx] = memoryAGet16(es, 0x0000);
    r16[bx]++;
    r16[bx] &= 0x00ff;
    memoryASet16(es, 0x0000, r16[bx]);
    r8[al] = memoryAGet(es, r16[bx] + 2);
    r8[ah] = 0;
    sp += 2; cs = pop();
}
function* sub_1ef35() // 1ef3:0005 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    flags.direction = 0;
    memoryASet16(ds, 0xe812, 0x0000);
    r16[si] = 0x0001;
    { pc = 0x1ef78; break; }
  case 0x1ef46:
    r16[ax] = 0x4eae;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[bx] = memoryAGet16(ds, 0x743e);
    r16[bx] += r16[ax];
    push(memoryAGet16(ds, r16[bx]));
    push(cs); cs = 0x1b1e; yield* sub_1b7df(); assert(cs == 0x1ef3);
    sp += 0x0004;
    r16[di] = r16[ax];
    if (r16[di])
        { pc = 0x1ef6c; break; }
    memoryASet16(ds, 0xe812, 0x0003);
    { pc = 0x1ef77; break; }
  case 0x1ef6c:
    if (r16[di] != 0x0001)
        { pc = 0x1ef77; break; }
    memoryASet16(ds, 0x7ade, 0x0001);
  case 0x1ef77:
    r16[si]++;
  case 0x1ef78:
    if (r16s[si] < signed16(memoryAGet16(ds, 0x743c)))
        { pc = 0x1ef46; break; }
    if (memoryAGet16(ds, 0xe812))
        { pc = 0x1ef8d; break; }
    push(cs); cs = 0x1ff7; yield* sub_20a8a(); assert(cs == 0x1ef3);
    memoryASet16(ds, 0xe812, r16[ax]);
  case 0x1ef8d:
    memoryASet16(ds, 0xe6ee, 0x0002);
    if (memoryAGet16(ds, 0xe812) == 0x0003)
        { pc = 0x1efad; break; }
    if (memoryAGet16(ds, 0xe812) == 0x0005)
        { pc = 0x1efad; break; }
    r16[ax] = 0x4f4d;
    push(r16[ax]);
    push(cs); cs = 0x056a; yield* sub_58cf(); assert(cs == 0x1ef3);
    sp += 0x0002;
  case 0x1efad:
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    memoryASet16(ds, 0xe844, 0x0000);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1efc0() // 1ef3:0090 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    yield* sub_1efdc();
    sp += 0x0002;
    r16[ax] = 0x0050;
    push(r16[ax]);
    push(cs);
    yield* sub_1f20d();
    sp += 0x0002;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1efdc() // 1ef3:00ac +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    if (!r16[ax])
        { pc = 0x1eff2; break; }
    if (r16[ax] == 0x0001)
        { pc = 0x1eff9; break; }
    if (r16[ax] == 0x0002)
        { pc = 0x1f000; break; }
    { pc = 0x1f00b; break; }
  case 0x1eff2:
    r16[ax] = 0x0003;
    interrupt(0x10);
    { pc = 0x1f00b; break; }
  case 0x1eff9:
    r16[ax] = 0x0004;
    interrupt(0x10);
    { pc = 0x1f00b; break; }
  case 0x1f000:
    r16[ax] = 0x000d;
    interrupt(0x10);
    memoryASet16(ds, 0xa7ae, 0xa000);
  case 0x1f00b:
    r16[ax] = 0x0040;
    push(r16[ax]);
    push(cs);
    yield* sub_1f20d();
    sp += 0x0002;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f019() // 1ef3:00e9 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = memoryAGet16(ss, r16[bp] + 6);
    r8[ah] = 0x10;
    r8[al] = 0x01;
    r8[bh] = r8[dl];
    interrupt(0x10);
    memoryASet16(ds, 0xa54e, r16[dx]);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f082() // 1ef3:0152 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r8[al] = memoryAGet(ds, 0xa54e);
    memoryASet(ds, 0x4ef7, r8[al]);
    r16[ax] = ds;
    es = r16[ax];
    r16[dx] = 0x4ee7;
    r16[ax] = 0x1002;
    interrupt(0x10);
    memoryASet16(ds, 0xc757, 0x0000);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f09f() // 1ef3:016f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0x0003;
    { pc = 0x1f0e5; break; }
  case 0x1f0a8:
    r16[ax] = r16[si];
    r16[dx] = 0x0011;
    imul16(r16[dx]);
    r8[dl] = memoryAGet(ds, 0xa54e);
    r16[bx] = r16[ax];
    memoryASet(ds, r16[bx] + 20164, r8[dl]);
    r16[ax] = r16[si];
    r16[dx] = 0x0011;
    imul16(r16[dx]);
    r16[ax] += 0x4eb4;
    r16[ax] = ds;
    es = r16[ax];
    r16[ax] = r16[si];
    r16[dx] = 0x0011;
    imul16(r16[dx]);
    r16[ax] += 0x4eb4;
    r16[dx] = r16[ax];
    r16[ax] = 0x1002;
    interrupt(0x10);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x1ef3);
    sp += 0x0002;
    r16[si]--;
  case 0x1f0e5:
    if (r16s[si] >= 0)
        { pc = 0x1f0a8; break; }
    memoryASet16(ds, 0xc757, 0x0001);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f0f2() // 1ef3:01c2 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[si] = 0;
    { pc = 0x1f137; break; }
  case 0x1f0fa:
    r16[ax] = r16[si];
    r16[dx] = 0x0011;
    imul16(r16[dx]);
    r8[dl] = memoryAGet(ds, 0xa54e);
    r16[bx] = r16[ax];
    memoryASet(ds, r16[bx] + 20164, r8[dl]);
    r16[ax] = r16[si];
    r16[dx] = 0x0011;
    imul16(r16[dx]);
    r16[ax] += 0x4eb4;
    r16[ax] = ds;
    es = r16[ax];
    r16[ax] = r16[si];
    r16[dx] = 0x0011;
    imul16(r16[dx]);
    r16[ax] += 0x4eb4;
    r16[dx] = r16[ax];
    r16[ax] = 0x1002;
    interrupt(0x10);
    r16[ax] = 0x0006;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x1ef3);
    sp += 0x0002;
    r16[si]++;
  case 0x1f137:
    if (r16s[si] < signed16(0x0004))
        { pc = 0x1f0fa; break; }
    memoryASet16(ds, 0xc757, 0x0000);
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f20d() // 1ef3:02dd +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    r16[dx] = 0x03d4;
    r8[al] = 0x13;
    r8[ah] = memoryAGet(ss, r16[bp] + 6);
    r8[ah] >>= 1;
    out16(r16[dx], r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0xa7ac, r16[ax]);
    r16[si] = 0;
    r16[cx] = 0;
    { pc = 0x1f234; break; }
  case 0x1f228:
    r16[bx] = r16[cx];
    r16[bx] <<= 1;
    memoryASet16(ds, r16[bx] + 42324, r16[si]);
    r16[si] += memoryAGet16(ss, r16[bp] + 6);
    r16[cx]++;
  case 0x1f234:
    if (r16s[cx] < signed16(0x012c))
        { pc = 0x1f228; break; }
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f23d() // 1ef3:030d +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[di]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0205;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x08;
    r16[ax] <<= r8[cl];
    r16[ax] &= memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ss, r16[bp] + 6, r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_20a43(); assert(cs == 0x1ef3);
    sp += 0x0002;
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ds, 0xa7b2);
    r16[di] &= 0xfffe;
    r16[cx] = 0x8000;
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[di] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f28c() // 1ef3:035c +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0008;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = r16[si];
    r16[ax] -= 0x0006;
    r16[di] = r16[ax];
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += memoryAGet16(ss, r16[bp] + 6);
    r16[ax] += memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa552);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(memoryAGet16(ss, r16[bp] - 2));
    push(cs); cs = 0x1ff7; yield* sub_2044f(); assert(cs == 0x1ef3);
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f4ad() // 1ef3:057d +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0205;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] &= 0x0007;
    r8[al] = memoryAGet(ds, r16[bx] + 20267);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] &= 0x0007;
    r8[al] = memoryAGet(ds, r16[bx] + 20275);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] -= r16[si];
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += r16[si];
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    if (r16[si] != memoryAGet16(ss, r16[bp] - 4))
        { pc = 0x1f539; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    memoryASet16(ss, r16[bp] - 6, memoryAGet16(ss, r16[bp] - 6) & r16[ax]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = 0x03ce;
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] - 6);
    out16(r16[dx], r16[ax]);
    r8[al] = memoryAGet(ss, r16[bp] + 12);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[al]); r8[al] = r8[tl];
    { pc = 0x1f566; break; }
  case 0x1f539:
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = 0x03ce;
    r8[bh] = memoryAGet(ss, r16[bp] + 12);
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] - 6);
    out16(r16[dx], r16[ax]);
    r8[al] = r8[bh];
    r8[bl] = memoryAGet(es, r16[di]);
    stosb_ESDI(r8[al]);
    r16[ax] = 0xff08;
    out16(r16[dx], r16[ax]);
    r8[al] = r8[bh];
    r16[cx] = memoryAGet16(ss, r16[bp] - 10);
    for (; r16[cx] != 0; --r16[cx]) stosb_ESDI(r8[al]);
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] - 8);
    out16(r16[dx], r16[ax]);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bh]); r8[bh] = r8[tl];
  case 0x1f566:
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0xff08;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f57e() // 1ef3:064e +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000e;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] += memoryAGet16(ss, r16[bp] + 10);
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 4);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0205;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] &= 0x0007;
    r8[al] = memoryAGet(ds, r16[bx] + 20267);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4);
    r16[bx] &= 0x0007;
    r8[al] = memoryAGet(ds, r16[bx] + 20275);
    r8[ah] = 0x00;
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 6);
    r16[ax]--;
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    if (r16[ax] != memoryAGet16(ss, r16[bp] - 8))
        { pc = 0x1f627; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 10, memoryAGet16(ss, r16[bp] - 10) & r16[ax]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    r16[dx] = 0x03ce;
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] - 10);
    out16(r16[dx], r16[ax]);
    r8[ah] = memoryAGet(ss, r16[bp] + 14);
    r16[dx] = memoryAGet16(ds, 0xa7ac);
  case 0x1f619:
    r8[al] = r8[ah];
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[al]); r8[al] = r8[tl];
    r16[di] += r16[dx];
    memoryASet16(ss, r16[bp] + 12, memoryAGet16(ss, r16[bp] + 12) - 1);
    if (memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1f619; break; }
    { pc = 0x1f665; break; }
  case 0x1f627:
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ss, r16[bp] - 2);
    r8[bh] = memoryAGet(ss, r16[bp] + 14);
    r16[dx] = 0x03ce;
    r16[si] = memoryAGet16(ds, 0xa7ac);
    r16[si] -= memoryAGet16(ss, r16[bp] - 14);
    r16[si]--;
  case 0x1f63c:
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] - 10);
    out16(r16[dx], r16[ax]);
    r8[al] = r8[bh];
    r8[bl] = memoryAGet(es, r16[di]);
    stosb_ESDI(r8[al]);
    r16[ax] = 0xff08;
    out16(r16[dx], r16[ax]);
    r8[al] = r8[bh];
    r16[cx] = memoryAGet16(ss, r16[bp] - 14);
    for (; r16[cx] != 0; --r16[cx]) stosb_ESDI(r8[al]);
    r8[al] = 0x08;
    r8[ah] = memoryAGet(ss, r16[bp] - 12);
    out16(r16[dx], r16[ax]);
    r8[al] = r8[bh];
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[al]); r8[al] = r8[tl];
    r16[di] += r16[si];
    memoryASet16(ss, r16[bp] + 12, memoryAGet16(ss, r16[bp] + 12) - 1);
    if (memoryAGet16(ss, r16[bp] + 12))
        { pc = 0x1f63c; break; }
  case 0x1f665:
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0xff08;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    flags.interrupts = 0;
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    flags.interrupts = 1;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f67d() // 1ef3:074d +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ss, r16[bp] + 14);
    es = r16[dx];
    r16[ax] = memoryAGet16(es, 0x0000);
    memoryASet16(ds, r16[di], r16[ax]);
    memoryASet16(ds, r16[si], 0x0000);
    { pc = 0x1f6b0; break; }
  case 0x1f699:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0x00;
    es = r16[dx];
    r16[bx] = r16[ax];
    r8[al] = memoryAGet(es, r16[bx] + 514);
    cbw();
    memoryASet16(ds, r16[si], memoryAGet16(ds, r16[si]) + r16[ax]);
    memoryASet16(ss, r16[bp] + 6, memoryAGet16(ss, r16[bp] + 6) + 1);
  case 0x1f6b0:
    r16[bx] = memoryAGet16(ss, r16[bp] + 6); es = memoryAGet16(ss, r16[bp] + 8);
    if (memoryAGet(es, r16[bx]))
        { pc = 0x1f699; break; }
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f6bd() // 1ef3:078d +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xa550);
    r16[bx] += 0x0003;
    r16[bx] <<= 1;
    push(memoryAGet16(ds, r16[bx] + 31469));
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs);
    yield* sub_1f67d();
    sp += 0x000a;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f707() // 1ef3:07d7 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[bx] = memoryAGet16(ds, 0xe83a);
    r16[bx] += memoryAGet16(ds, 0xc759);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    r16[dx] = memoryAGet16(ds, 0xe83c);
    r16[dx] += memoryAGet16(ds, 0xc75b);
    r16[dx] >>= 1;
    r16[dx] >>= 1;
    r16[dx] >>= 1;
    r16[ax] += r16[dx];
    memoryASet16(ds, 0xe836, r16[ax]);
    push(memoryAGet16(ds, 0xe83e));
    push(memoryAGet16(ds, 0xe840));
    push(memoryAGet16(ds, 0xe838));
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2050f(); assert(cs == 0x1ef3);
    sp += 0x0008;
    push(memoryAGet16(ds, 0xe842));
    push(memoryAGet16(ds, 0xe83a));
    push(memoryAGet16(ds, 0xe83c));
    push(cs);
    yield* sub_1fda5();
    sp += 0x0006;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f759() // 1ef3:0829 +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(memoryAGet16(ds, 0xe83e));
    push(memoryAGet16(ds, 0xe840));
    push(memoryAGet16(ds, 0xe836));
    push(memoryAGet16(ds, 0xe838));
    push(cs); cs = 0x1ff7; yield* sub_2044f(); assert(cs == 0x1ef3);
    sp += 0x0008;
    r16[ax] = memoryAGet16(ds, 0xe83a);
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[ax] += memoryAGet16(ds, 0xe83e);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe840);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = memoryAGet16(ds, 0xe83c);
    r16[dx] += memoryAGet16(ds, 0xc75b);
    r16[dx] &= 0xfff8;
    r16[dx] += r16[ax];
    r16[dx]--;
    push(r16[dx]);
    r16[ax] = memoryAGet16(ds, 0xe83a);
    r16[ax] += memoryAGet16(ds, 0xc759);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe83c);
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[ax] &= 0xfff8;
    push(r16[ax]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f7b6() // 1ef3:0886 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xe844, memoryAGet16(ds, 0xe844) + 1);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f7bf() // 1ef3:088f +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    memoryASet16(ds, 0xe844, memoryAGet16(ds, 0xe844) - 1);
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f85b() // 1ef3:092b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (!memoryAGet16(ds, 0xe842))
        { pc = 0x1f8af; break; }
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe842);
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x1ef3);
    sp += 0x0004;
    r16[ax] = 0x0003;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xe842);
    r16[ax] <<= 1;
    r16[ax] += 0x7aed;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f02(); assert(cs == 0x1ef3);
    sp += 0x0004;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = 0xe838;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17f85(); assert(cs == 0x1ef3);
    sp += 0x0004;
    r16[ax] = 0xe838;
    push(r16[ax]);
    push(cs); cs = 0x174b; yield* sub_17e37(); assert(cs == 0x1ef3);
    sp += 0x0002;
    memoryASet16(ds, 0xe842, 0x0000);
  case 0x1f8af:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f8b1() // 1ef3:0981 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0xa7b2);
    r16[ax] += memoryAGet16(ds, 0xa7b0);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2074a(); assert(cs == 0x1ef3);
    sp += 0x0004;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f8c9() // 1ef3:0999 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[ax] = 0x00d0;
    push(r16[ax]);
    r16[ax] = 0x0054;
    push(r16[ax]);
    push(memoryAGet16(ds, 0xa7b4));
    push(memoryAGet16(ds, 0xa7b2));
    push(cs); cs = 0x1ff7; yield* sub_20405(); assert(cs == 0x1ef3);
    sp += 0x0008;
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1f8eb() // 1ef3:09bb +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000c;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] = sar16(r16[ax], r8[cl]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) >= signed16(0x0000))
        { pc = 0x1f922; break; }
    memoryASet16(ss, r16[bp] - 4, 0x0000);
    { pc = 0x1f930; break; }
  case 0x1f922:
    if (signed16(memoryAGet16(ss, r16[bp] - 4)) < signed16(0x0015))
        { pc = 0x1f930; break; }
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1f930:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) >= signed16(0x0000))
        { pc = 0x1f93d; break; }
    memoryASet16(ss, r16[bp] - 6, 0x0000);
    { pc = 0x1f94b; break; }
  case 0x1f93d:
    if (signed16(memoryAGet16(ss, r16[bp] - 6)) <= signed16(0x000e))
        { pc = 0x1f94b; break; }
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1f94b:
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) >= signed16(0x0000))
        { pc = 0x1f959; break; }
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1f959:
    if (signed16(memoryAGet16(ss, r16[bp] - 8)) < signed16(0x0015))
        { pc = 0x1f964; break; }
    memoryASet16(ss, r16[bp] - 8, 0x0014);
  case 0x1f964:
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) >= signed16(0x0000))
        { pc = 0x1f972; break; }
    r16[ax] = 0;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x1f972:
    if (signed16(memoryAGet16(ss, r16[bp] - 10)) < signed16(0x000e))
        { pc = 0x1f97d; break; }
    memoryASet16(ss, r16[bp] - 10, 0x000d);
  case 0x1f97d:
    r16[bx] = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xe6d8);
    r16[ax] += memoryAGet16(ds, r16[bx] + 57836);
    r16[ax] += memoryAGet16(ss, r16[bp] - 4);
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    r16[ax] -= memoryAGet16(ss, r16[bp] - 4);
    r16[dx] = 0x0016;
    r16[dx] -= r16[ax];
    r16[dx]--;
    memoryASet16(ss, r16[bp] - 12, r16[dx]);
    r16[ax] = memoryAGet16(ss, r16[bp] - 6);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    { pc = 0x1f9ba; break; }
  case 0x1f9a5:
    r16[di] = memoryAGet16(ss, r16[bp] - 4);
    { pc = 0x1f9af; break; }
  case 0x1f9aa:
    memoryASet(ds, r16[si], 0x01);
    r16[si]++;
    r16[di]++;
  case 0x1f9af:
    if (r16s[di] <= signed16(memoryAGet16(ss, r16[bp] - 8)))
        { pc = 0x1f9aa; break; }
    r16[si] += memoryAGet16(ss, r16[bp] - 12);
    memoryASet16(ss, r16[bp] - 2, memoryAGet16(ss, r16[bp] - 2) + 1);
  case 0x1f9ba:
    r16[ax] = memoryAGet16(ss, r16[bp] - 2);
    if (r16s[ax] <= signed16(memoryAGet16(ss, r16[bp] - 10)))
        { pc = 0x1f9a5; break; }
    r16[ax] = 0x0001;
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f9cb() // 1ef3:0a9b +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    if (signed16(memoryAGet16(ds, 0xe844)) <= signed16(0x0000))
        { pc = 0x1f9d9; break; }
    push(cs);
    yield* sub_1f707();
  case 0x1f9d9:
    push(cs); cs = 0x1ff7; yield* sub_2054a(); assert(cs == 0x1ef3);
    if (signed16(memoryAGet16(ds, 0xe844)) <= signed16(0x0000))
        { pc = 0x1f9e9; break; }
    push(cs);
    yield* sub_1f759();
  case 0x1f9e9:
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1f9eb() // 1ef3:0abb +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[ax] += 0x0007;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] &= 0xfff8;
    r16[ax] += 0x0007;
    push(r16[ax]);
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] &= 0xfff8;
    push(r16[ax]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1fa3a; break; }
    push(memoryAGet16(ss, r16[bp] + 10));
    push(r16[di]);
    r16[ax] = r16[si];
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    push(r16[ax]);
    push(cs); cs = 0x1ff7; yield* sub_2001f(); assert(cs == 0x1ef3);
    sp += 0x0006;
  case 0x1fa3a:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1fa3e() // 1ef3:0b0e +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x0002;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[ax] = r16[si];
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += 0x0007;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] &= 0xfff8;
    r16[ax] += 0x0007;
    push(r16[ax]);
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] &= 0xfff8;
    push(r16[ax]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1fab5; break; }
    r16[ax] = 0x0008;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x0001;
    push(r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += memoryAGet16(ss, r16[bp] - 2);
    push(r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = 0x0028;
    imul16(r16[dx]);
    push(r16[ax]);
    push(memoryAGet16(ds, 0x7f01));
    push(cs); cs = 0x1ff7; yield* sub_20085(); assert(cs == 0x1ef3);
    sp += 0x000c;
  case 0x1fab5:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1fba9() // 1ef3:0c79 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] += 0xfffa;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[bx] = 0x0008;
    r16[ax] = r16[si];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[si] = r16[ax];
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += r16[si];
    r16[ax] += memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xa552);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 10);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax]--;
    push(r16[ax]);
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    push(r16[ax]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1fc53; break; }
    push(memoryAGet16(ss, r16[bp] - 10));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 6));
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x1ff7; yield* sub_2044f(); assert(cs == 0x1ef3);
    sp += 0x0008;
  case 0x1fc53:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1fc59() // 1ef3:0d29 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000a;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] += 0xff87;
    memoryASet16(ss, r16[bp] - 2, r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[bx] = 0x0008;
    r16[ax] = r16[si];
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    r16[si] = r16[ax];
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 42324);
    r16[ax] += r16[si];
    r16[ax] += memoryAGet16(ds, 0xa7b4);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    es = memoryAGet16(ds, 0xcbab);
    r16[ax] = memoryAGet16(es, r16[bx]);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 2);
    r16[bx] <<= 1;
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 10);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ss, r16[bp] - 8);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax]--;
    push(r16[ax]);
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    push(r16[ax]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1fd0d; break; }
    r16[ax] = memoryAGet16(ss, r16[bp] - 8);
    imul16(memoryAGet16(ss, r16[bp] - 10));
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 10));
    push(memoryAGet16(ss, r16[bp] - 8));
    push(memoryAGet16(ss, r16[bp] - 6));
    r16[ax] = 0;
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] - 4));
    push(cs); cs = 0x1ff7; yield* sub_20085(); assert(cs == 0x1ef3);
    sp += 0x000c;
  case 0x1fd0d:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1fd13() // 1ef3:0de3 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[ax] += memoryAGet16(ss, r16[bp] + 12);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ss, r16[bp] + 10);
    push(r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1fd58; break; }
    push(memoryAGet16(ss, r16[bp] + 14));
    push(memoryAGet16(ss, r16[bp] + 12));
    push(memoryAGet16(ss, r16[bp] + 10));
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_1f57e();
    sp += 0x000a;
  case 0x1fd58:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1fd5c() // 1ef3:0e2c +nearfar +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[ax] = memoryAGet16(ds, 0x6020);
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ds, 0x6022);
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    push(memoryAGet16(ss, r16[bp] + 8));
    push(memoryAGet16(ss, r16[bp] + 6));
    push(cs); cs = 0x1ff7; yield* sub_20929(); assert(cs == 0x1ef3);
    sp += 0x0004;
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0x666e);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x666c);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[dx] = r16[si];
    r16[dx] += r16[ax];
    r16[dx]--;
    push(r16[dx]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1fda5() // 1ef3:0e75 +nearfar +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    sp -= 0x000e;
    push(r16[si]);
    push(r16[di]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
    r16[dx] = 0x0012;
    imul16(r16[dx]);
    r16[ax] += 0xf748;
    r16[dx] = memoryAGet16(ds, 0xc755);
    memoryASet16(ss, r16[bp] - 2, r16[dx]);
    memoryASet16(ss, r16[bp] - 4, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[bx] + 31469);
    memoryASet16(ss, r16[bp] - 6, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 6);
    r8[cl] = 0x04;
    r16[ax] = sar16(r16[ax], r8[cl]);
    r16[di] += r16[ax];
    r16[ax] = memoryAGet16(es, r16[bx] + 4);
    r16[ax] = sar16(r16[ax], r8[cl]);
    r16[si] += r16[ax];
    r16[ax] = r16[si];
    r16[ax] &= 0x0007;
    r16[bx] = 0x0002;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 10, r16[ax]);
    r16[bx] = r16[di];
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(ds, 0xa7b4);
    r16[ax] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ss, r16[bp] - 8, r16[ax]);
    if (r16s[si] < 0)
        { pc = 0x1fe26; break; }
    r16[ax] = r16[si];
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + r16[ax]);
    { pc = 0x1fe32; break; }
  case 0x1fe26:
    r16[ax] = r16[si];
    r16[ax]++;
    r16[bx] = 0x0008;
    r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    idiv16(r16[bx]);
    memoryASet16(ss, r16[bp] - 8, memoryAGet16(ss, r16[bp] - 8) + r16[ax]);
  case 0x1fe32:
    es = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    r16[ax] = memoryAGet16(es, r16[bx] + 16);
    memoryASet16(ss, r16[bp] - 12, r16[ax]);
    r16[bx] = memoryAGet16(ss, r16[bp] - 4); es = memoryAGet16(ss, r16[bp] - 2);
    r16[ax] = memoryAGet16(es, r16[bx] + 2);
    memoryASet16(ss, r16[bp] - 14, r16[ax]);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ss, r16[bp] - 14);
    r16[ax]--;
    push(r16[ax]);
    r16[ax] = r16[si];
    r16[ax] &= 0xfff8;
    r16[dx] = memoryAGet16(ss, r16[bp] - 12);
    r16[dx] <<= 1;
    r16[dx] <<= 1;
    r16[dx] <<= 1;
    r16[ax] += r16[dx];
    r16[ax]--;
    push(r16[ax]);
    push(r16[di]);
    r16[ax] = r16[si];
    r16[ax] &= 0xfff8;
    push(r16[ax]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1fe9e; break; }
    es = memoryAGet16(ss, r16[bp] - 6);
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    push(memoryAGet16(es, r16[bx] + 8));
    push(memoryAGet16(ss, r16[bp] - 14));
    push(memoryAGet16(ss, r16[bp] - 12));
    push(memoryAGet16(ss, r16[bp] - 8));
    r16[bx] = memoryAGet16(ss, r16[bp] - 10);
    r16[bx] <<= 1;
    push(memoryAGet16(es, r16[bx]));
    push(memoryAGet16(ss, r16[bp] - 6));
    push(cs); cs = 0x1ff7; yield* sub_20085(); assert(cs == 0x1ef3);
    sp += 0x000c;
  case 0x1fe9e:
    r16[di] = pop();
    r16[si] = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1fedf() // 1ef3:0faf +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] += memoryAGet16(ds, 0xc75b);
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[si] = r16[ax];
    push(r16[ax]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[ax]);
    push(r16[di]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1ff24; break; }
    push(memoryAGet16(ss, r16[bp] + 12));
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(cs);
    yield* sub_1f4ad();
    sp += 0x0008;
  case 0x1ff24:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ff28() // 1ef3:0ff8 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[di] = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = r16[si];
    r16[ax] += memoryAGet16(ds, 0xc75b);
    r16[si] = r16[ax];
    r16[ax] = r16[di];
    r16[ax] += memoryAGet16(ds, 0xc759);
    r16[di] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    r16[ax] += memoryAGet16(ds, 0xc759);
    memoryASet16(ss, r16[bp] + 8, r16[ax]);
    push(r16[ax]);
    push(r16[si]);
    push(r16[di]);
    push(r16[si]);
    push(cs);
    yield* sub_1f8eb();
    sp += 0x0008;
    if (!r16[ax])
        { pc = 0x1ff6c; break; }
    push(memoryAGet16(ss, r16[bp] + 12));
    push(r16[si]);
    push(memoryAGet16(ss, r16[bp] + 8));
    push(r16[di]);
    push(cs); cs = 0x1ff7; yield* sub_1ffbf(); assert(cs == 0x1ef3);
    sp += 0x0008;
  case 0x1ff6c:
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_1ff70() // 1ff7:0000 +far +stackDrop2
{
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0205;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ds, 0xa7b4);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[di] += memoryAGet16(ds, r16[bx] + 42324);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[bx];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[di] += r16[ax];
    r16[bx] &= 0x0007;
    r8[ah] = memoryAGet(ds, r16[bx] + 24546);
    r8[al] = 0x08;
    out16(r16[dx], r16[ax]);
    r8[bl] = memoryAGet(ss, r16[bp] + 10);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    r16[dx] = 0x03ce;
    r8[ah] = 0xff;
    out16(r16[dx], r16[ax]);
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
}
function* sub_1ffbf() // 1ff7:004f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0205;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ds, 0xa7b4);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[bx] <<= 1;
    r16[di] += memoryAGet16(ds, r16[bx] + 42324);
    r16[bx] = memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = r16[bx];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[di] += r16[ax];
    r16[bx] &= 0x0007;
    r8[ah] = memoryAGet(ds, r16[bx] + 24546);
    r8[al] = 0x08;
    out16(r16[dx], r16[ax]);
    r16[cx] = memoryAGet16(ss, r16[bp] + 8);
    r16[cx] -= memoryAGet16(ss, r16[bp] + 6);
    r16[cx]++;
    r8[bh] = memoryAGet(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ds, 0xa7ac);
  case 0x20008:
    r8[bl] = r8[bh];
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20008; break; }
    r16[dx] = 0x03ce;
    r8[ah] = 0xff;
    out16(r16[dx], r16[ax]);
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2001f() // 1ff7:00af +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ds, 0xa7b4);
    r16[di] += memoryAGet16(ss, r16[bp] + 6);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[di] += memoryAGet16(ds, r16[bx] + 42324);
    memoryASet16(ss, 0x4fce, r16[di]);
    r16[bx] = memoryAGet16(ds, 0xa7ac);
    r16[bx]--;
    r16[si] = memoryAGet16(ss, r16[bp] + 10);
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    ds = memoryAGet16(ds, 0x7eff);
    r16[cx] = 0x0004;
    r8[ah] = 0x01;
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
  case 0x2005d:
    out16(r16[dx], r16[ax]);
    r8[ah] <<= 1;
    r16[di] = memoryAGet16(ss, 0x4fce);
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    movsb_ESDI_DSSI();
    if (--r16[cx])
        { pc = 0x2005d; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_20085() // 1ff7:0115 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    memoryASet(ds, 0x4fcc, 0x01);
    memoryASet(ds, 0x4fcd, 0x00);
    r16[di] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ds, 0xa7ac);
    r16[dx] -= memoryAGet16(ss, r16[bp] + 12);
    memoryASet16(ds, 0x4fd0, r16[dx]);
    r16[bx] = memoryAGet16(ss, r16[bp] + 16);
    if (r16[di] <= 0x000a)
        { pc = 0x200b7; break; }
    memoryASet16(ds, 0x6016, 0x01a0);
    { pc = 0x200c7; break; }
    // gap 1 bytes
  case 0x200b7:
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    flags.carry = r16[cx] & 1;
    r16[cx] >>= 1;
    r16[di] = rcl16(r16[di], 0x0001);
    r16[di] <<= 1;
    r16[ax] = memoryAGet16(ds, r16[di] + 24554);
    memoryASet16(ds, 0x6016, r16[ax]);
  case 0x200c7:
    ds = memoryAGet16(ss, r16[bp] + 6);
  case 0x200ca:
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
    r8[ah] = memoryAGet(ss, 0x4fcc);
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r8[al] = 0x04;
    r8[ah] = memoryAGet(ss, 0x4fcd);
    out16(r16[dx], r16[ax]);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    r16[cx] = memoryAGet16(ss, r16[bp] + 14);
    r16[dx] = memoryAGet16(ss, 0x4fd0);
    switch (memoryAGet16(ss, 0x6016))
    {
        case 0x0198: { pc = 0x20108; break; }
        case 0x01ba: { pc = 0x2012a; break; }
        case 0x01c8: { pc = 0x20138; break; }
        case 0x01d6: { pc = 0x20146; break; }
        case 0x01ec: { pc = 0x2015c; break; }
        case 0x0202: { pc = 0x20172; break; }
        case 0x021a: { pc = 0x2018a; break; }
        case 0x0232: { pc = 0x201a2; break; }
        case 0x0252: { pc = 0x201c2; break; }
        case 0x0272: { pc = 0x201e2; break; }
        case 0x0292: { pc = 0x20202; break; }
        case 0x02b2: { pc = 0x20222; break; }
        case 0x02da: { pc = 0x2024a; break; }
        case 0x0302: { pc = 0x20272; break; }
        case 0x032a: { pc = 0x2029a; break; }
        case 0x0352: { pc = 0x202c2; break; }
        case 0x0382: { pc = 0x202f2; break; }
        case 0x03b2: { pc = 0x20322; break; }
        case 0x03e2: { pc = 0x20352; break; }
        case 0x0412: { pc = 0x20382; break; }
        case 0x01a0: { pc = 0x20110; break; }
        default:
            stop("ind 1ff7:017e");
    }
    break;
  case 0x200f3:
    r16[bx] += memoryAGet16(ss, r16[bp] + 16);
    memoryASet(ss, 0x4fcd, memoryAGet(ss, 0x4fcd) + 1);
    memoryASet(ss, 0x4fcc, memoryAGet(ss, 0x4fcc) << 1);
    if (memoryAGet(ss, 0x4fcc) != 0x10)
        { pc = 0x200ca; break; }
  case 0x20108:
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x20110:
    r16[dx] = r16[cx];
  case 0x20112:
    r16[cx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x20115:
    r8[al] = memoryAGet(es, r16[di]);
    r8[al] &= memoryAGet(ds, r16[si]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si]);
    r16[si]++;
    stosb_ESDI(r8[al]);
    if (--r16[cx])
        { pc = 0x20115; break; }
    r16[di] += memoryAGet16(ss, 0x4fd0);
    r16[dx]--;
    if (r16[dx])
        { pc = 0x20112; break; }
    { pc = 0x200f3; break; }
  case 0x2012a:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x2012a; break; }
    { pc = 0x200f3; break; }
  case 0x20138:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20138; break; }
    { pc = 0x200f3; break; }
  case 0x20146:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20146; break; }
    { pc = 0x200f3; break; }
  case 0x2015c:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x2015c; break; }
    { pc = 0x200f3; break; }
  case 0x20172:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20172; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x2018a:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x2018a; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x201a2:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x201a2; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x201c2:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x201c2; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x201e2:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x201e2; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x20202:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20202; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x20222:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20222; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x2024a:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x2024a; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x20272:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20272; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x2029a:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x2029a; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x202c2:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x202c2; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x202f2:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x202f2; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x20322:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20322; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x20352:
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20352; break; }
    { pc = 0x200f3; break; }
    // gap 1 bytes
  case 0x20382:
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r16[ax] = lodsw_DSSI();
    r16[ax] &= memoryAGet16(es, r16[di]);
    r16[ax] |= memoryAGet16(ds, r16[bx] + r16[si] - 2);
    stosw_ESDI(r16[ax]);
    r8[al] = lodsb_DSSI();
    r8[al] &= memoryAGet(es, r16[di]);
    r8[al] |= memoryAGet(ds, r16[bx] + r16[si] - 1);
    stosb_ESDI(r8[al]);
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20382; break; }
    { pc = 0x200f3; break; }
    return;
  }
}
function* sub_203b9() // 1ff7:0449 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x1003;
    out16(r16[dx], r16[ax]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[ax] = memoryAGet16(ss, r16[bp] + 12);
    r16[dx] = memoryAGet16(ds, 0xa7ac);
    r16[dx] -= r16[ax];
    ds = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = memoryAGet16(ss, r16[bp] + 8);
    r16[di] = memoryAGet16(ss, r16[bp] + 10);
    r16[bx] = memoryAGet16(ss, r16[bp] + 14);
  case 0x203e5:
    r16[cx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x203e8:
    r8[al] = lodsb_DSSI();
    r8[al] = ~r8[al];
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[al]); r8[al] = r8[tl];
    r16[di]++;
    if (--r16[cx])
        { pc = 0x203e8; break; }
    r16[di] += r16[dx];
    r16[bx]--;
    if (r16[bx])
        { pc = 0x203e5; break; }
    r16[dx] = 0x03ce;
    r16[ax] = 0x0003;
    out16(r16[dx], r16[ax]);
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_20405() // 1ff7:0495 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    push(flagAsReg());
    flags.interrupts = 0;
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0105;
    out16(r16[dx], r16[ax]);
    flagsFromReg(pop());
    r16[bx] = memoryAGet16(ds, 0xa7ac);
    r16[bx] -= memoryAGet16(ss, r16[bp] + 10);
    r16[ax] = memoryAGet16(ds, 0xa7ae);
    es = r16[ax];
    ds = r16[ax];
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
    r16[ax] = memoryAGet16(ss, r16[bp] + 10);
  case 0x20435:
    r16[cx] = r16[ax];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[bx];
    r16[di] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x20435; break; }
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2044f() // 1ff7:04df +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[bx] = memoryAGet16(ds, 0xa7ac);
    r16[bx] -= memoryAGet16(ss, r16[bp] + 10);
    ds = memoryAGet16(ss, r16[bp] + 6);
    r16[si] = 0;
    r16[di] = 0;
    flags.carry = memoryAGet16(ss, r16[bp] + 10) & 1;
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) >> 1);
    r16[di] = rcl16(r16[di], 0x0001);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    flags.carry = r16[ax] & 1;
    r16[ax] >>= 1;
    r16[di] = rcl16(r16[di], 0x0001);
    r16[di] <<= 1;
    r16[ax] = 0x0102;
    switch (r16[di])
    {
        case 0: { pc = 0x2047c; break; }
        case 2: { pc = 0x204c3; break; }
        case 4: { pc = 0x2049f; break; }
        case 6: { pc = 0x204eb; break; }
        default:
            stop("ind 1ff7:0507");
    }
    break;
  case 0x2047c:
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x20486:
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x20486; break; }
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x2047c; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x2049f:
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x204a9:
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x204a9; break; }
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x2049f; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x204c3:
    memoryASet16(ss, r16[bp] + 10, memoryAGet16(ss, r16[bp] + 10) - 1);
  case 0x204c6:
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x204d0:
    movsb_ESDI_DSSI();
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[di] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x204d0; break; }
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x204c6; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
  case 0x204eb:
    r16[dx] = 0x03c4;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ss, r16[bp] + 8);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x204f5:
    movsb_ESDI_DSSI();
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    for (; r16[cx] != 0; --r16[cx]) movsw_ESDI_DSSI();
    r16[di] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x204f5; break; }
    r8[ah] <<= 1;
    if (r8[ah] != 0x10)
        { pc = 0x204eb; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2050f() // 1ff7:059f +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] = memoryAGet16(ds, 0xa7ac);
    r16[bx] -= memoryAGet16(ss, r16[bp] + 10);
    ds = memoryAGet16(ds, 0xa7ae);
    r16[ax] = 0x0004;
    r16[di] = 0;
  case 0x20527:
    r16[dx] = 0x03ce;
    out16(r16[dx], r16[ax]);
    r16[si] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = memoryAGet16(ss, r16[bp] + 12);
  case 0x20531:
    r16[cx] = memoryAGet16(ss, r16[bp] + 10);
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[bx];
    r16[dx]--;
    if (r16[dx])
        { pc = 0x20531; break; }
    r8[ah]++;
    if (r8[ah] != 0x04)
        { pc = 0x20527; break; }
    r16[ax] = ss;
    ds = r16[ax];
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2054a() // 1ff7:05da +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[si]);
    push(r16[di]);
    push(r16[bp]);
    { pc = 0x20565; break; }
  case 0x2054f:
    r16[dx] = 0x03ce;
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    r16[ax] = 0;
    r16[cx] = 0x009a;
    r16[di] = memoryAGet16(ds, 0xe6d8);
    for (; r16[cx] != 0; --r16[cx]) stosw_ESDI(r16[ax]);
    r16[bp] = pop();
    r16[di] = pop();
    r16[si] = pop();
    sp += 2; cs = pop(); return;
  case 0x20565:
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0105;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ds, 0xe6d8);
    r16[bp] = r16[di];
    r16[bp] += 0x0135;
    push(r16[di]);
    r16[cx] = 0xffff;
  case 0x20581:
    r16[di] = pop();
    r16[ax] = ss;
    es = r16[ax];
    ds = r16[ax];
    r8[al] = 0x01;
    for (flags.zero = 0; r16[cx] != 0 && !flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    if (r16[di] >= r16[bp])
        { pc = 0x2054f; break; }
    if (memoryAGet(ds, r16[di]) != r8[al])
        { pc = 0x20597; break; }
    { pc = 0x2061a; break; }
  case 0x20597:
    r16[di]++;
    push(r16[di]);
    r16[di] -= memoryAGet16(ds, 0xe6d8);
    r16[di] <<= 1;
    r16[di] = memoryAGet16(ds, r16[di] + 58476);
    r16[si] = r16[di];
    r16[si] += memoryAGet16(ds, 0xa7b4);
    r16[di] += memoryAGet16(ds, 0xa7b2);
    r16[dx] = memoryAGet16(ds, 0xa7ac);
    r16[dx] -= 0x0002;
    r16[ax] = memoryAGet16(ds, 0xa7ae);
    ds = r16[ax];
    es = r16[ax];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    movsb_ESDI_DSSI();
    movsb_ESDI_DSSI();
    { pc = 0x20581; break; }
  case 0x2061a:
    r16[dx] = r16[di];
    r16[di]++;
    for (flags.zero = 1; r16[cx] != 0 && flags.zero; --r16[cx]) scasb_inv_ESDI(r8[al]);
    push(r16[di]);
    r16[bx] = r16[di];
    r16[bx] -= r16[dx];
    r16[bx] <<= 1;
    r16[di] = r16[dx];
    r16[di] -= memoryAGet16(ds, 0xe6d8);
    r16[di] <<= 1;
    r16[di] = memoryAGet16(ds, r16[di] + 58478);
    r16[si] = r16[di];
    r16[si] += memoryAGet16(ds, 0xa7b4);
    r16[di] += memoryAGet16(ds, 0xa7b2);
    r16[dx] = memoryAGet16(ds, 0xa7ac);
    r16[dx] -= r16[bx];
    r16[ax] = memoryAGet16(ds, 0xa7ae);
    ds = r16[ax];
    es = r16[ax];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[si] += r16[dx];
    r16[di] += r16[dx];
    r16[cx] = r16[bx];
    for (; r16[cx] != 0; --r16[cx]) movsb_ESDI_DSSI();
    r16[cx]--;
    { pc = 0x20581; break; }
    return;
  }
}
function* sub_206c9() // 1ff7:0759 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    yield* sync(); cs = pop(); return;
    sp -= 2;
    yield* sync(); cs = pop(); return;
    r16[dx] = 0x03da;
    r16[bx] = memoryAGet16(ds, 0xa53d);
    r16[bx] += 0x0003;
  case 0x206d3:
    flags.interrupts = 1;
    { pc = 0x206d6; break; }
  case 0x206d6:
    flags.interrupts = 0;
    if (memoryAGet16(ds, 0xa53d) == r16[bx])
        { pc = 0x20749; break; }
  case 0x206dd:
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x01)
        { pc = 0x206dd; break; }
  case 0x206e2:
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x01))
        { pc = 0x206e2; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    if (!(memoryAGet16(ds, 0x7a14) & 0x0001))
        { pc = 0x20749; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x206d3; break; }
    if (!(r8[al] & 0x01))
        { pc = 0x206d3; break; }
  case 0x20749:
    sp += 2; cs = pop(); return;
    return;
  }
}
function* sub_2074a() // 1ff7:07da +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(cs);
    yield* sub_206c9();
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
    r16[dx] = 0x03d4;
    r8[al] = 0x0c;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = r8[ch];
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = 0x0d;
    out8(r16[dx], r8[al]);
    r8[al] = r8[cl];
    r16[dx]++;
    out8(r16[dx], r8[al]);
    if (memoryAGet16(ds, 0x7ade) & 0x0001)
        { pc = 0x2077a; break; }
    r16[dx] = 0x03c0;
    r8[al] = 0x33;
    out8(r16[dx], r8[al]);
    { pc = 0x20776; break; }
  case 0x20776:
    r8[al] = memoryAGet(ss, r16[bp] + 8);
    out8(r16[dx], r8[al]);
  case 0x2077a:
    flags.interrupts = 1;
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_2077d() // 1ff7:080d
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    es = memoryAGet16(ds, 0xa7ae);
    r16[di] = memoryAGet16(ds, 0x6674);
    r16[bx] = memoryAGet16(ds, 0x666c);
    if (r16[bx])
        { pc = 0x2078e; break; }
    sp += 2; return;
  case 0x2078e:
    r16[ax] = memoryAGet16(ds, 0xa7ac);
    r16[ax] -= r16[bx];
    memoryASet16(ds, 0x6678, r16[ax]);
    r16[ax] = 0x0032;
    r16[ax] -= r16[bx];
    memoryASet16(ds, 0x6676, r16[ax]);
    r16[bx] = memoryAGet16(ds, 0x666e);
  case 0x207a2:
    r16[cx] = memoryAGet16(ds, 0x666c);
  case 0x207a6:
    r8[al] = lodsb_DSSI();
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[al]); r8[al] = r8[tl];
    r16[di]++;
    if (--r16[cx])
        { pc = 0x207a6; break; }
    r16[si] += memoryAGet16(ds, 0x6676);
    r16[di] += memoryAGet16(ds, 0x6678);
    r16[bx]--;
    if (r16[bx])
        { pc = 0x207a2; break; }
    sp += 2;
    return;
  }
}
function* sub_207b9() // 1ff7:0849 +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    { pc = 0x207b9; break; }
  case 0x1ff70:
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    es = memoryAGet16(ds, 0xa7ae);
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03ce;
    r16[ax] = 0x0205;
    out16(r16[dx], r16[ax]);
    r16[di] = memoryAGet16(ds, 0xa7b4);
    r16[bx] = memoryAGet16(ss, r16[bp] + 8);
    r16[bx] <<= 1;
    r16[di] += memoryAGet16(ds, r16[bx] + 42324);
    r16[bx] = memoryAGet16(ss, r16[bp] + 6);
    r16[ax] = r16[bx];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[di] += r16[ax];
    r16[bx] &= 0x0007;
    r8[ah] = memoryAGet(ds, r16[bx] + 24546);
    r8[al] = 0x08;
    out16(r16[dx], r16[ax]);
    r8[bl] = memoryAGet(ss, r16[bp] + 10);
    r8[tl] = memoryAGet(es, r16[di]); memoryASet(es, r16[di], r8[bl]); r8[bl] = r8[tl];
    r16[dx] = 0x03ce;
    r8[ah] = 0xff;
    out16(r16[dx], r16[ax]);
    r16[ax] = 0x0005;
    out16(r16[dx], r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop(); return;
    // gap 2042 bytes
  case 0x207b9:
    r16[si] = memoryAGet16(ds, 0xa550);
    r16[si] <<= 1;
    es = memoryAGet16(ds, r16[si] + 31475);
    r16[si] = memoryAGet16(es, r16[bx] + 514);
    r16[si] &= 0x00ff;
    r16[bx] <<= 1;
    r16[bx] = memoryAGet16(es, r16[bx] + 2);
    r16[di] = memoryAGet16(ds, 0x6672);
    r16[di] <<= 1;
    r16[bp] = memoryAGet16(ds, r16[di] + 24530);
    r16[di] = 0x602c;
    r16[di] += memoryAGet16(ds, 0x6670);
    r16[cx] = memoryAGet16(ds, 0x6672);
    r16[cx] += r16[si];
    r16[ax] = r16[cx];
    r16[ax] &= 0x0007;
    memoryASet16(ds, 0x6672, r16[ax]);
    r16[ax] = r16[cx];
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    memoryASet16(ds, 0x6670, memoryAGet16(ds, 0x6670) + r16[ax]);
    r16[si] += 0x0007;
    r16[si] >>= 1;
    r16[si] >>= 1;
    r16[si] >>= 1;
    r16[si] <<= 1;
    r16[cx] = memoryAGet16(es, 0x0000);
    r16[dx] = 0x0032;
    switch (r16[si])
    {
        case 0: { pc = 0x1ff70; break; }
        case 2: { pc = 0x20815; break; }
        case 4: { pc = 0x2082c; break; }
        default:
            stop("ind 1ff7:08a0");
    }
    break;
  case 0x20815:
    r16[dx]--;
  case 0x20816:
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0;
    r16[ax] <<= 1;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + r16[si]);
    memoryASet(ds, r16[di], memoryAGet(ds, r16[di]) | r8[al]);
    r16[di]++;
    memoryASet(ds, r16[di], r8[ah]);
    r16[bx]++;
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x20816; break; }
    sp += 2; return;
  case 0x2082c:
    r16[dx]--;
    r16[dx]--;
  case 0x2082e:
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0;
    r16[ax] <<= 1;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + r16[si]);
    memoryASet(ds, r16[di], memoryAGet(ds, r16[di]) | r8[al]);
    r16[di]++;
    memoryASet(ds, r16[di], r8[ah]);
    r16[bx]++;
    r8[al] = memoryAGet(es, r16[bx]);
    r8[ah] = 0;
    r16[ax] <<= 1;
    r16[si] = r16[ax];
    r16[ax] = memoryAGet16(ss, r16[bp] + r16[si]);
    memoryASet(ds, r16[di], memoryAGet(ds, r16[di]) | r8[al]);
    r16[di]++;
    memoryASet(ds, r16[di], r8[ah]);
    r16[bx]++;
    r16[di] += r16[dx];
    if (--r16[cx])
        { pc = 0x2082e; break; }
    sp += 2;
    return;
  }
}
function* sub_20929() // 1ff7:09b9 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(r16[si]);
    push(r16[di]);
    r8[al] = 0x00;
    memoryASet(ds, 0x602c, r8[al]);
    memoryASet(ds, 0x605e, r8[al]);
    memoryASet(ds, 0x6090, r8[al]);
    memoryASet(ds, 0x60c2, r8[al]);
    memoryASet(ds, 0x60f4, r8[al]);
    memoryASet(ds, 0x6126, r8[al]);
    memoryASet(ds, 0x6158, r8[al]);
    memoryASet(ds, 0x618a, r8[al]);
    memoryASet(ds, 0x61bc, r8[al]);
    memoryASet(ds, 0x61ee, r8[al]);
    memoryASet(ds, 0x6220, r8[al]);
    memoryASet(ds, 0x6252, r8[al]);
    memoryASet(ds, 0x6284, r8[al]);
    memoryASet(ds, 0x62b6, r8[al]);
    memoryASet(ds, 0x62e8, r8[al]);
    memoryASet(ds, 0x631a, r8[al]);
    memoryASet(ds, 0x634c, r8[al]);
    memoryASet(ds, 0x637e, r8[al]);
    memoryASet(ds, 0x63b0, r8[al]);
    memoryASet(ds, 0x63e2, r8[al]);
    memoryASet(ds, 0x6414, r8[al]);
    memoryASet(ds, 0x6446, r8[al]);
    memoryASet(ds, 0x6478, r8[al]);
    memoryASet(ds, 0x64aa, r8[al]);
    memoryASet(ds, 0x64dc, r8[al]);
    memoryASet(ds, 0x650e, r8[al]);
    memoryASet(ds, 0x6540, r8[al]);
    memoryASet(ds, 0x6572, r8[al]);
    memoryASet(ds, 0x65a4, r8[al]);
    memoryASet(ds, 0x65d6, r8[al]);
    memoryASet(ds, 0x6608, r8[al]);
    memoryASet(ds, 0x663a, r8[al]);
    r16[ax] = memoryAGet16(ds, 0x6020);
    r16[ax] &= 0x0007;
    memoryASet16(ds, 0x6672, r16[ax]);
    memoryASet16(ds, 0x6670, 0x0000);
    r16[ax] = memoryAGet16(ss, r16[bp] + 6);
    memoryASet16(ds, 0x6028, r16[ax]);
    r16[ax] = memoryAGet16(ss, r16[bp] + 8);
    memoryASet16(ds, 0x602a, r16[ax]);
  case 0x209ab:
    es = memoryAGet16(ds, 0x602a);
    r16[bx] = memoryAGet16(ds, 0x6028);
    memoryASet16(ds, 0x6028, memoryAGet16(ds, 0x6028) + 1);
    r16[bx] = memoryAGet16(es, r16[bx]);
    r8[bh] = 0;
    if (!r8[bl])
        { pc = 0x209c5; break; }
    yield* sub_207b9();
    { pc = 0x209ab; break; }
  case 0x209c5:
    r16[bx] = memoryAGet16(ds, 0x6022);
    r16[bx] <<= 1;
    r16[di] = memoryAGet16(ds, r16[bx] + 42324);
    r16[di] += memoryAGet16(ds, 0xa7b4);
    r16[di] += memoryAGet16(ds, 0xa7b0);
    r16[ax] = memoryAGet16(ds, 0x6020);
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[ax] >>= 1;
    r16[di] += r16[ax];
    memoryASet16(ds, 0x6674, r16[di]);
    r16[ax] = memoryAGet16(ds, 0x6670);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] |= memoryAGet16(ds, 0x6672);
    memoryASet16(ds, 0x6020, memoryAGet16(ds, 0x6020) + r16[ax]);
    r16[dx] = 0x03ce;
    r8[al] = 0x03;
    r8[ah] = memoryAGet(ds, 0x6024);
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
    r8[ah] = memoryAGet(ds, 0x6025);
    out16(r16[dx], r16[ax]);
    r16[ax] = memoryAGet16(ds, 0x6670);
    if (!(memoryAGet16(ds, 0x6672) & 0x0007))
        { pc = 0x20a17; break; }
    r16[ax]++;
  case 0x20a17:
    memoryASet16(ds, 0x666c, r16[ax]);
    r16[si] = memoryAGet16(ds, 0xa550);
    r16[si] <<= 1;
    es = memoryAGet16(ds, r16[si] + 31475);
    r16[ax] = memoryAGet16(es, 0x0000);
    memoryASet16(ds, 0x666e, r16[ax]);
    r16[si] = 0x602c;
    yield* sub_2077d();
    r16[dx] = 0x03ce;
    r16[ax] = 0x0003;
    out16(r16[dx], r16[ax]);
    r16[dx] = 0x03c4;
    r16[ax] = 0x0f02;
    out16(r16[dx], r16[ax]);
    r16[di] = pop();
    r16[si] = pop();
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_20a43() // 1ff7:0ad3 +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    r16[dx] = 0x03da;
    r16[cx] = memoryAGet16(ss, r16[bp] + 6);
  case 0x20a4c:
    r8[al] = in8(r16[dx]);
    if (r8[al] & 0x08)
        { pc = 0x20a4c; break; }
  case 0x20a51:
    r8[al] = in8(r16[dx]);
    if (!(r8[al] & 0x08))
        { pc = 0x20a51; break; }
    if (--r16[cx])
        { pc = 0x20a4c; break; }
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_20a8a() // 1ff7:0b1a +far +stackDrop2
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    push(r16[bp]);
    r16[bp] = sp;
    push(ds);
    push(r16[si]);
    push(r16[di]);
    push(cs);
    ds = pop();
    r16[di] = 0x0aea;
    memoryASet16(ds, r16[di], 0x0000);
    memoryASet16(ds, r16[di] + 2, 0x0000);
    memoryASet(ds, 0x0b14, 0x01);
    memoryASet(ds, 0x0b11, 0x01);
    memoryASet(ds, 0x0b17, 0x01);
    r16[cx] = 0x0004;
    r16[si] = 0x0b0e;
  case 0x20ab3:
    r8[al] = lodsb_DSSI();
    flags.zero = r8[al] == 0;
    r16[ax] = lodsw_DSSI();
    if (flags.zero)
        { pc = 0x20abf; break; }
    push(r16[si]);
    push(r16[cx]);
    switch (r16[ax])
    {
        case 0x0b60: yield* sub_20ad0(); break;
        default:
            stop("ind 1ff7:0b4b");
    }
    r16[cx] = pop();
    r16[si] = pop();
  case 0x20abf:
    if (--r16[cx])
        { pc = 0x20ab3; break; }
    yield* sub_20bb8();
    r8[al] = memoryAGet(ds, 0x0aea);
    r8[ah] = 0x00;
    r16[di] = pop();
    r16[si] = pop();
    ds = pop();
    sp = r16[bp];
    r16[bp] = pop();
    sp += 2; cs = pop();
    return;
  }
}
function* sub_20ad0() // 1ff7:0b60
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    r16[ax] = 0x1a00;
    interrupt(0x10);
    if (r8[al] != 0x1a)
        { pc = 0x20b1f; break; }
    r16[cx] = r16[bx];
    r8[bh] = 0;
    if (!r8[ch])
        { pc = 0x20af0; break; }
    r8[bl] = r8[ch];
    r16[bx] += r16[bx];
    r16[ax] = memoryAGet16(ds, r16[bx] + 2804);
    memoryASet16(ds, r16[di] + 2, r16[ax]);
    r8[bl] = r8[cl];
    r8[bh] = 0;
  case 0x20af0:
    r16[bx] += r16[bx];
    r16[ax] = memoryAGet16(ds, r16[bx] + 2804);
    memoryASet16(ds, r16[di], r16[ax]);
    memoryASet(ds, 0x0b14, 0x00);
    memoryASet(ds, 0x0b11, 0x00);
    memoryASet(ds, 0x0b17, 0x00);
    r16[bx] = r16[di];
    if (memoryAGet(ds, r16[bx]) == 0x01)
        { pc = 0x20b16; break; }
    r16[bx] = r16[di] + 2;
    if (memoryAGet(ds, r16[bx]) != 0x01)
        { pc = 0x20b1f; break; }
  case 0x20b16:
    memoryASet16(ds, r16[bx], 0x0000);
    memoryASet(ds, 0x0b17, 0x01);
  case 0x20b1f:
    sp += 2; return;
    return;
  }
}
function* sub_20bb8() // 1ff7:0c48
{
  var pc = 0;
  while (1) switch(pc)
  {
  case 0:
    sp -= 2;
    if (!memoryAGet16(ds, r16[di] + 2))
        { pc = 0x20be8; break; }
    if (signed8(memoryAGet(ds, r16[di])) >= signed8(0x04))
        { pc = 0x20be8; break; }
    if (signed8(memoryAGet(ds, r16[di] + 2)) >= signed8(0x04))
        { pc = 0x20be8; break; }
    r8[ah] = 0x0f;
    interrupt(0x10);
    r8[al] &= 0x07;
    if (r8[al] == 0x07)
        { pc = 0x20bdb; break; }
    if (memoryAGet(ds, r16[di] + 1) != 0x01)
        { pc = 0x20be8; break; }
    { pc = 0x20be1; break; }
  case 0x20bdb:
    if (memoryAGet(ds, r16[di] + 1) == 0x01)
        { pc = 0x20be8; break; }
  case 0x20be1:
    r16[ax] = memoryAGet16(ds, r16[di]);
    r16[tx] = memoryAGet16(ds, r16[di] + 2); memoryASet16(ds, r16[di] + 2, r16[ax]); r16[ax] = r16[tx];
    memoryASet16(ds, r16[di], r16[ax]);
  case 0x20be8:
    sp += 2; return;
    return;
  }
}
function fixReloc(seg)
{
        memoryASet16(seg, 0x0001, memoryAGet16(seg, 0x0001) + seg); // 2ee7 -> 30d4; lin=1
        memoryASet16(0x000d + seg, 0x000e, memoryAGet16(0x000d + seg, 0x000e) + seg); // 2ee7 -> 30d4; lin=de
        memoryASet16(0x0010 + seg, 0x000b, memoryAGet16(0x0010 + seg, 0x000b) + seg); // 037d -> 056a; lin=10b
        memoryASet16(0x0011 + seg, 0x0004, memoryAGet16(0x0011 + seg, 0x0004) + seg); // 2ee7 -> 30d4; lin=114
        memoryASet16(0x013a + seg, 0x0009, memoryAGet16(0x013a + seg, 0x0009) + seg); // 0000 -> 01ed; lin=13a9
        memoryASet16(0x01ab + seg, 0x0005, memoryAGet16(0x01ab + seg, 0x0005) + seg); // 2ee7 -> 30d4; lin=1ab5
        memoryASet16(0x0385 + seg, 0x0005, memoryAGet16(0x0385 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=3855
        memoryASet16(0x0385 + seg, 0x000a, memoryAGet16(0x0385 + seg, 0x000a) + seg); // 1874 -> 1a61; lin=385a
        memoryASet16(0x0385 + seg, 0x000f, memoryAGet16(0x0385 + seg, 0x000f) + seg); // 1460 -> 164d; lin=385f
        memoryASet16(0x0386 + seg, 0x0004, memoryAGet16(0x0386 + seg, 0x0004) + seg); // 1654 -> 1841; lin=3864
        memoryASet16(0x0386 + seg, 0x0009, memoryAGet16(0x0386 + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=3869
        memoryASet16(0x0386 + seg, 0x000e, memoryAGet16(0x0386 + seg, 0x000e) + seg); // 12a6 -> 1493; lin=386e
        memoryASet16(0x0387 + seg, 0x0003, memoryAGet16(0x0387 + seg, 0x0003) + seg); // 155e -> 174b; lin=3873
        memoryASet16(0x0389 + seg, 0x0007, memoryAGet16(0x0389 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=3897
        memoryASet16(0x038b + seg, 0x0000, memoryAGet16(0x038b + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=38b0
        memoryASet16(0x038b + seg, 0x0005, memoryAGet16(0x038b + seg, 0x0005) + seg); // 155e -> 174b; lin=38b5
        memoryASet16(0x038b + seg, 0x000a, memoryAGet16(0x038b + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=38ba
        memoryASet16(0x038b + seg, 0x000f, memoryAGet16(0x038b + seg, 0x000f) + seg); // 1654 -> 1841; lin=38bf
        memoryASet16(0x038c + seg, 0x0004, memoryAGet16(0x038c + seg, 0x0004) + seg); // 1460 -> 164d; lin=38c4
        memoryASet16(0x038c + seg, 0x0009, memoryAGet16(0x038c + seg, 0x0009) + seg); // 1874 -> 1a61; lin=38c9
        memoryASet16(0x038c + seg, 0x000e, memoryAGet16(0x038c + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=38ce
        memoryASet16(0x038d + seg, 0x0003, memoryAGet16(0x038d + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=38d3
        memoryASet16(0x038d + seg, 0x0008, memoryAGet16(0x038d + seg, 0x0008) + seg); // 12a6 -> 1493; lin=38d8
        memoryASet16(0x038d + seg, 0x000d, memoryAGet16(0x038d + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=38dd
        memoryASet16(0x038e + seg, 0x0000, memoryAGet16(0x038e + seg, 0x0000) + seg); // 05c4 -> 07b1; lin=38e0
        memoryASet16(0x038e + seg, 0x0008, memoryAGet16(0x038e + seg, 0x0008) + seg); // 05c4 -> 07b1; lin=38e8
        memoryASet16(0x038f + seg, 0x0000, memoryAGet16(0x038f + seg, 0x0000) + seg); // 05c4 -> 07b1; lin=38f0
        memoryASet16(0x038f + seg, 0x000a, memoryAGet16(0x038f + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=38fa
        memoryASet16(0x0390 + seg, 0x0003, memoryAGet16(0x0390 + seg, 0x0003) + seg); // 05c4 -> 07b1; lin=3903
        memoryASet16(0x0390 + seg, 0x000f, memoryAGet16(0x0390 + seg, 0x000f) + seg); // 05c4 -> 07b1; lin=390f
        memoryASet16(0x0391 + seg, 0x000b, memoryAGet16(0x0391 + seg, 0x000b) + seg); // 05c4 -> 07b1; lin=391b
        memoryASet16(0x0392 + seg, 0x0006, memoryAGet16(0x0392 + seg, 0x0006) + seg); // 12a6 -> 1493; lin=3926
        memoryASet16(0x0392 + seg, 0x0009, memoryAGet16(0x0392 + seg, 0x0009) + seg); // 2a3a -> 2c27; lin=3929
        memoryASet16(0x0395 + seg, 0x0008, memoryAGet16(0x0395 + seg, 0x0008) + seg); // 12a6 -> 1493; lin=3958
        memoryASet16(0x0396 + seg, 0x0008, memoryAGet16(0x0396 + seg, 0x0008) + seg); // 155e -> 174b; lin=3968
        memoryASet16(0x0397 + seg, 0x0008, memoryAGet16(0x0397 + seg, 0x0008) + seg); // 155e -> 174b; lin=3978
        memoryASet16(0x0398 + seg, 0x0008, memoryAGet16(0x0398 + seg, 0x0008) + seg); // 155e -> 174b; lin=3988
        memoryASet16(0x0399 + seg, 0x0008, memoryAGet16(0x0399 + seg, 0x0008) + seg); // 155e -> 174b; lin=3998
        memoryASet16(0x039a + seg, 0x0008, memoryAGet16(0x039a + seg, 0x0008) + seg); // 155e -> 174b; lin=39a8
        memoryASet16(0x039b + seg, 0x0005, memoryAGet16(0x039b + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=39b5
        memoryASet16(0x039b + seg, 0x0008, memoryAGet16(0x039b + seg, 0x0008) + seg); // 1fe4 -> 21d1; lin=39b8
        memoryASet16(0x039d + seg, 0x0001, memoryAGet16(0x039d + seg, 0x0001) + seg); // 155e -> 174b; lin=39d1
        memoryASet16(0x039d + seg, 0x000d, memoryAGet16(0x039d + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=39dd
        memoryASet16(0x039e + seg, 0x0009, memoryAGet16(0x039e + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=39e9
        memoryASet16(0x039f + seg, 0x0004, memoryAGet16(0x039f + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=39f4
        memoryASet16(0x03a1 + seg, 0x0000, memoryAGet16(0x03a1 + seg, 0x0000) + seg); // 12a6 -> 1493; lin=3a10
        memoryASet16(0x03a1 + seg, 0x0009, memoryAGet16(0x03a1 + seg, 0x0009) + seg); // 12a6 -> 1493; lin=3a19
        memoryASet16(0x03a2 + seg, 0x000a, memoryAGet16(0x03a2 + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=3a2a
        memoryASet16(0x03a3 + seg, 0x0006, memoryAGet16(0x03a3 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=3a36
        memoryASet16(0x03a4 + seg, 0x000c, memoryAGet16(0x03a4 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=3a4c
        memoryASet16(0x03a5 + seg, 0x000b, memoryAGet16(0x03a5 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=3a5b
        memoryASet16(0x03a6 + seg, 0x000f, memoryAGet16(0x03a6 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=3a6f
        memoryASet16(0x03a7 + seg, 0x000d, memoryAGet16(0x03a7 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=3a7d
        memoryASet16(0x03a8 + seg, 0x000c, memoryAGet16(0x03a8 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=3a8c
        memoryASet16(0x03a9 + seg, 0x0008, memoryAGet16(0x03a9 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=3a98
        memoryASet16(0x03ab + seg, 0x0009, memoryAGet16(0x03ab + seg, 0x0009) + seg); // 0000 -> 01ed; lin=3ab9
        memoryASet16(0x03ac + seg, 0x0009, memoryAGet16(0x03ac + seg, 0x0009) + seg); // 0000 -> 01ed; lin=3ac9
        memoryASet16(0x03ad + seg, 0x0005, memoryAGet16(0x03ad + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=3ad5
        memoryASet16(0x03ae + seg, 0x0004, memoryAGet16(0x03ae + seg, 0x0004) + seg); // 0000 -> 01ed; lin=3ae4
        memoryASet16(0x03ae + seg, 0x000f, memoryAGet16(0x03ae + seg, 0x000f) + seg); // 0000 -> 01ed; lin=3aef
        memoryASet16(0x03b1 + seg, 0x0002, memoryAGet16(0x03b1 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=3b12
        memoryASet16(0x03b5 + seg, 0x0002, memoryAGet16(0x03b5 + seg, 0x0002) + seg); // 12a6 -> 1493; lin=3b52
        memoryASet16(0x03b7 + seg, 0x0006, memoryAGet16(0x03b7 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=3b76
        memoryASet16(0x03b8 + seg, 0x0006, memoryAGet16(0x03b8 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=3b86
        memoryASet16(0x03b9 + seg, 0x0002, memoryAGet16(0x03b9 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=3b92
        memoryASet16(0x03ba + seg, 0x000d, memoryAGet16(0x03ba + seg, 0x000d) + seg); // 05c4 -> 07b1; lin=3bad
        memoryASet16(0x03bb + seg, 0x0002, memoryAGet16(0x03bb + seg, 0x0002) + seg); // 12a6 -> 1493; lin=3bb2
        memoryASet16(0x03bd + seg, 0x0008, memoryAGet16(0x03bd + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=3bd8
        memoryASet16(0x03bf + seg, 0x0008, memoryAGet16(0x03bf + seg, 0x0008) + seg); // 05c4 -> 07b1; lin=3bf8
        memoryASet16(0x03c2 + seg, 0x0002, memoryAGet16(0x03c2 + seg, 0x0002) + seg); // 03ed -> 05da; lin=3c22
        memoryASet16(0x03c2 + seg, 0x0009, memoryAGet16(0x03c2 + seg, 0x0009) + seg); // 03ed -> 05da; lin=3c29
        memoryASet16(0x03c3 + seg, 0x0005, memoryAGet16(0x03c3 + seg, 0x0005) + seg); // 03ed -> 05da; lin=3c35
        memoryASet16(0x03c3 + seg, 0x000f, memoryAGet16(0x03c3 + seg, 0x000f) + seg); // 03ed -> 05da; lin=3c3f
        memoryASet16(0x03c4 + seg, 0x000a, memoryAGet16(0x03c4 + seg, 0x000a) + seg); // 03ed -> 05da; lin=3c4a
        memoryASet16(0x03c5 + seg, 0x0004, memoryAGet16(0x03c5 + seg, 0x0004) + seg); // 03ed -> 05da; lin=3c54
        memoryASet16(0x03c5 + seg, 0x000f, memoryAGet16(0x03c5 + seg, 0x000f) + seg); // 03ed -> 05da; lin=3c5f
        memoryASet16(0x03c6 + seg, 0x000f, memoryAGet16(0x03c6 + seg, 0x000f) + seg); // 03ed -> 05da; lin=3c6f
        memoryASet16(0x03c7 + seg, 0x000b, memoryAGet16(0x03c7 + seg, 0x000b) + seg); // 05c4 -> 07b1; lin=3c7b
        memoryASet16(0x03c8 + seg, 0x0000, memoryAGet16(0x03c8 + seg, 0x0000) + seg); // 03ed -> 05da; lin=3c80
        memoryASet16(0x03c9 + seg, 0x0003, memoryAGet16(0x03c9 + seg, 0x0003) + seg); // 03ed -> 05da; lin=3c93
        memoryASet16(0x03cd + seg, 0x000a, memoryAGet16(0x03cd + seg, 0x000a) + seg); // 0000 -> 01ed; lin=3cda
        memoryASet16(0x03ce + seg, 0x000b, memoryAGet16(0x03ce + seg, 0x000b) + seg); // 0000 -> 01ed; lin=3ceb
        memoryASet16(0x03cf + seg, 0x000d, memoryAGet16(0x03cf + seg, 0x000d) + seg); // 0000 -> 01ed; lin=3cfd
        memoryASet16(0x03d0 + seg, 0x000d, memoryAGet16(0x03d0 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=3d0d
        memoryASet16(0x03d1 + seg, 0x000e, memoryAGet16(0x03d1 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=3d1e
        memoryASet16(0x03d2 + seg, 0x000a, memoryAGet16(0x03d2 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=3d2a
        memoryASet16(0x03d3 + seg, 0x000a, memoryAGet16(0x03d3 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=3d3a
        memoryASet16(0x03d4 + seg, 0x000d, memoryAGet16(0x03d4 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=3d4d
        memoryASet16(0x03d5 + seg, 0x0009, memoryAGet16(0x03d5 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=3d59
        memoryASet16(0x03d6 + seg, 0x000a, memoryAGet16(0x03d6 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=3d6a
        memoryASet16(0x03d7 + seg, 0x000a, memoryAGet16(0x03d7 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=3d7a
        memoryASet16(0x03d8 + seg, 0x000d, memoryAGet16(0x03d8 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=3d8d
        memoryASet16(0x03d9 + seg, 0x0009, memoryAGet16(0x03d9 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=3d99
        memoryASet16(0x03da + seg, 0x0002, memoryAGet16(0x03da + seg, 0x0002) + seg); // 0000 -> 01ed; lin=3da2
        memoryASet16(0x03db + seg, 0x0007, memoryAGet16(0x03db + seg, 0x0007) + seg); // 0000 -> 01ed; lin=3db7
        memoryASet16(0x03de + seg, 0x0004, memoryAGet16(0x03de + seg, 0x0004) + seg); // 12a6 -> 1493; lin=3de4
        memoryASet16(0x03df + seg, 0x000a, memoryAGet16(0x03df + seg, 0x000a) + seg); // 12a6 -> 1493; lin=3dfa
        memoryASet16(0x03e1 + seg, 0x000a, memoryAGet16(0x03e1 + seg, 0x000a) + seg); // 12a6 -> 1493; lin=3e1a
        memoryASet16(0x03e2 + seg, 0x000f, memoryAGet16(0x03e2 + seg, 0x000f) + seg); // 12a6 -> 1493; lin=3e2f
        memoryASet16(0x03e5 + seg, 0x0002, memoryAGet16(0x03e5 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=3e52
        memoryASet16(0x03e5 + seg, 0x000b, memoryAGet16(0x03e5 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=3e5b
        memoryASet16(0x03e6 + seg, 0x0004, memoryAGet16(0x03e6 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=3e64
        memoryASet16(0x03e7 + seg, 0x0000, memoryAGet16(0x03e7 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=3e70
        memoryASet16(0x03e8 + seg, 0x0009, memoryAGet16(0x03e8 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=3e89
        memoryASet16(0x03e9 + seg, 0x000f, memoryAGet16(0x03e9 + seg, 0x000f) + seg); // 1931 -> 1b1e; lin=3e9f
        memoryASet16(0x03ef + seg, 0x000b, memoryAGet16(0x03ef + seg, 0x000b) + seg); // 1460 -> 164d; lin=3efb
        memoryASet16(0x03f0 + seg, 0x0000, memoryAGet16(0x03f0 + seg, 0x0000) + seg); // 05c4 -> 07b1; lin=3f00
        memoryASet16(0x03f0 + seg, 0x000e, memoryAGet16(0x03f0 + seg, 0x000e) + seg); // 0915 -> 0b02; lin=3f0e
        memoryASet16(0x03f1 + seg, 0x0005, memoryAGet16(0x03f1 + seg, 0x0005) + seg); // 1a89 -> 1c76; lin=3f15
        memoryASet16(0x03f4 + seg, 0x000f, memoryAGet16(0x03f4 + seg, 0x000f) + seg); // 12a6 -> 1493; lin=3f4f
        memoryASet16(0x03fa + seg, 0x0008, memoryAGet16(0x03fa + seg, 0x0008) + seg); // 155e -> 174b; lin=3fa8
        memoryASet16(0x03ff + seg, 0x000b, memoryAGet16(0x03ff + seg, 0x000b) + seg); // 155e -> 174b; lin=3ffb
        memoryASet16(0x0436 + seg, 0x0005, memoryAGet16(0x0436 + seg, 0x0005) + seg); // 0000 -> 01ed; lin=4365
        memoryASet16(0x0436 + seg, 0x000c, memoryAGet16(0x0436 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=436c
        memoryASet16(0x0439 + seg, 0x0002, memoryAGet16(0x0439 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=4392
        memoryASet16(0x0439 + seg, 0x0009, memoryAGet16(0x0439 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=4399
        memoryASet16(0x044e + seg, 0x000b, memoryAGet16(0x044e + seg, 0x000b) + seg); // 1e0a -> 1ff7; lin=44eb
        memoryASet16(0x0453 + seg, 0x0005, memoryAGet16(0x0453 + seg, 0x0005) + seg); // 1460 -> 164d; lin=4535
        memoryASet16(0x0465 + seg, 0x0006, memoryAGet16(0x0465 + seg, 0x0006) + seg); // 155e -> 174b; lin=4656
        memoryASet16(0x0494 + seg, 0x000b, memoryAGet16(0x0494 + seg, 0x000b) + seg); // 155e -> 174b; lin=494b
        memoryASet16(0x049b + seg, 0x000c, memoryAGet16(0x049b + seg, 0x000c) + seg); // 0000 -> 01ed; lin=49bc
        memoryASet16(0x049c + seg, 0x0003, memoryAGet16(0x049c + seg, 0x0003) + seg); // 0000 -> 01ed; lin=49c3
        memoryASet16(0x04a1 + seg, 0x000c, memoryAGet16(0x04a1 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=4a1c
        memoryASet16(0x04a2 + seg, 0x0003, memoryAGet16(0x04a2 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=4a23
        memoryASet16(0x04a4 + seg, 0x0008, memoryAGet16(0x04a4 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=4a48
        memoryASet16(0x04a6 + seg, 0x000e, memoryAGet16(0x04a6 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=4a6e
        memoryASet16(0x04b1 + seg, 0x0003, memoryAGet16(0x04b1 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=4b13
        memoryASet16(0x04b3 + seg, 0x0006, memoryAGet16(0x04b3 + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=4b36
        memoryASet16(0x04ba + seg, 0x0002, memoryAGet16(0x04ba + seg, 0x0002) + seg); // 1460 -> 164d; lin=4ba2
        memoryASet16(0x04bc + seg, 0x000d, memoryAGet16(0x04bc + seg, 0x000d) + seg); // 155e -> 174b; lin=4bcd
        memoryASet16(0x04bd + seg, 0x0009, memoryAGet16(0x04bd + seg, 0x0009) + seg); // 155e -> 174b; lin=4bd9
        memoryASet16(0x04bf + seg, 0x000d, memoryAGet16(0x04bf + seg, 0x000d) + seg); // 0000 -> 01ed; lin=4bfd
        memoryASet16(0x04c3 + seg, 0x0001, memoryAGet16(0x04c3 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=4c31
        memoryASet16(0x04c4 + seg, 0x0000, memoryAGet16(0x04c4 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=4c40
        memoryASet16(0x04c4 + seg, 0x0007, memoryAGet16(0x04c4 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=4c47
        memoryASet16(0x04cb + seg, 0x000e, memoryAGet16(0x04cb + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=4cbe
        memoryASet16(0x04ce + seg, 0x000e, memoryAGet16(0x04ce + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=4cee
        memoryASet16(0x04cf + seg, 0x000e, memoryAGet16(0x04cf + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=4cfe
        memoryASet16(0x04e3 + seg, 0x0001, memoryAGet16(0x04e3 + seg, 0x0001) + seg); // 1e0a -> 1ff7; lin=4e31
        memoryASet16(0x04e3 + seg, 0x0009, memoryAGet16(0x04e3 + seg, 0x0009) + seg); // 1460 -> 164d; lin=4e39
        memoryASet16(0x04e9 + seg, 0x0004, memoryAGet16(0x04e9 + seg, 0x0004) + seg); // 1460 -> 164d; lin=4e94
        memoryASet16(0x04eb + seg, 0x0000, memoryAGet16(0x04eb + seg, 0x0000) + seg); // 12a6 -> 1493; lin=4eb0
        memoryASet16(0x04ec + seg, 0x000a, memoryAGet16(0x04ec + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=4eca
        memoryASet16(0x04ed + seg, 0x0006, memoryAGet16(0x04ed + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=4ed6
        memoryASet16(0x04ee + seg, 0x0002, memoryAGet16(0x04ee + seg, 0x0002) + seg); // 12a6 -> 1493; lin=4ee2
        memoryASet16(0x04ee + seg, 0x000e, memoryAGet16(0x04ee + seg, 0x000e) + seg); // 12a6 -> 1493; lin=4eee
        memoryASet16(0x04ef + seg, 0x000a, memoryAGet16(0x04ef + seg, 0x000a) + seg); // 12a6 -> 1493; lin=4efa
        memoryASet16(0x04f3 + seg, 0x0003, memoryAGet16(0x04f3 + seg, 0x0003) + seg); // 1e0a -> 1ff7; lin=4f33
        memoryASet16(0x04f9 + seg, 0x000a, memoryAGet16(0x04f9 + seg, 0x000a) + seg); // 1e0a -> 1ff7; lin=4f9a
        memoryASet16(0x04fd + seg, 0x000d, memoryAGet16(0x04fd + seg, 0x000d) + seg); // 155e -> 174b; lin=4fdd
        memoryASet16(0x0510 + seg, 0x0008, memoryAGet16(0x0510 + seg, 0x0008) + seg); // 155e -> 174b; lin=5108
        memoryASet16(0x0512 + seg, 0x0009, memoryAGet16(0x0512 + seg, 0x0009) + seg); // 155e -> 174b; lin=5129
        memoryASet16(0x0516 + seg, 0x0001, memoryAGet16(0x0516 + seg, 0x0001) + seg); // 155e -> 174b; lin=5161
        memoryASet16(0x0517 + seg, 0x0001, memoryAGet16(0x0517 + seg, 0x0001) + seg); // 155e -> 174b; lin=5171
        memoryASet16(0x0517 + seg, 0x000c, memoryAGet16(0x0517 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=517c
        memoryASet16(0x0518 + seg, 0x0008, memoryAGet16(0x0518 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=5188
        memoryASet16(0x0519 + seg, 0x0000, memoryAGet16(0x0519 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=5190
        memoryASet16(0x0519 + seg, 0x0005, memoryAGet16(0x0519 + seg, 0x0005) + seg); // 1654 -> 1841; lin=5195
        memoryASet16(0x0519 + seg, 0x000a, memoryAGet16(0x0519 + seg, 0x000a) + seg); // 12a6 -> 1493; lin=519a
        memoryASet16(0x051b + seg, 0x0000, memoryAGet16(0x051b + seg, 0x0000) + seg); // 0915 -> 0b02; lin=51b0
        memoryASet16(0x051c + seg, 0x0001, memoryAGet16(0x051c + seg, 0x0001) + seg); // 1654 -> 1841; lin=51c1
        memoryASet16(0x051c + seg, 0x000a, memoryAGet16(0x051c + seg, 0x000a) + seg); // 12a6 -> 1493; lin=51ca
        memoryASet16(0x051d + seg, 0x000a, memoryAGet16(0x051d + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=51da
        memoryASet16(0x051e + seg, 0x0009, memoryAGet16(0x051e + seg, 0x0009) + seg); // 1e0a -> 1ff7; lin=51e9
        memoryASet16(0x051f + seg, 0x0001, memoryAGet16(0x051f + seg, 0x0001) + seg); // 1460 -> 164d; lin=51f1
        memoryASet16(0x051f + seg, 0x0006, memoryAGet16(0x051f + seg, 0x0006) + seg); // 12a6 -> 1493; lin=51f6
        memoryASet16(0x0520 + seg, 0x000e, memoryAGet16(0x0520 + seg, 0x000e) + seg); // 1460 -> 164d; lin=520e
        memoryASet16(0x0521 + seg, 0x0003, memoryAGet16(0x0521 + seg, 0x0003) + seg); // 05c4 -> 07b1; lin=5213
        memoryASet16(0x0521 + seg, 0x000e, memoryAGet16(0x0521 + seg, 0x000e) + seg); // 1a89 -> 1c76; lin=521e
        memoryASet16(0x0525 + seg, 0x000c, memoryAGet16(0x0525 + seg, 0x000c) + seg); // 155e -> 174b; lin=525c
        memoryASet16(0x052d + seg, 0x0007, memoryAGet16(0x052d + seg, 0x0007) + seg); // 155e -> 174b; lin=52d7
        memoryASet16(0x0532 + seg, 0x0000, memoryAGet16(0x0532 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=5320
        memoryASet16(0x0535 + seg, 0x0001, memoryAGet16(0x0535 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=5351
        memoryASet16(0x0535 + seg, 0x0008, memoryAGet16(0x0535 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=5358
        memoryASet16(0x0536 + seg, 0x000a, memoryAGet16(0x0536 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=536a
        memoryASet16(0x0538 + seg, 0x0006, memoryAGet16(0x0538 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=5386
        memoryASet16(0x053e + seg, 0x000e, memoryAGet16(0x053e + seg, 0x000e) + seg); // 0000 -> 01ed; lin=53ee
        memoryASet16(0x054b + seg, 0x000b, memoryAGet16(0x054b + seg, 0x000b) + seg); // 1e0a -> 1ff7; lin=54bb
        memoryASet16(0x0558 + seg, 0x0002, memoryAGet16(0x0558 + seg, 0x0002) + seg); // 1ee4 -> 20d1; lin=5582
        memoryASet16(0x055c + seg, 0x0006, memoryAGet16(0x055c + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=55c6
        memoryASet16(0x055f + seg, 0x000d, memoryAGet16(0x055f + seg, 0x000d) + seg); // 155e -> 174b; lin=55fd
        memoryASet16(0x0561 + seg, 0x000e, memoryAGet16(0x0561 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=561e
        memoryASet16(0x0563 + seg, 0x000b, memoryAGet16(0x0563 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=563b
        memoryASet16(0x056f + seg, 0x0008, memoryAGet16(0x056f + seg, 0x0008) + seg); // 1e0a -> 1ff7; lin=56f8
        memoryASet16(0x0575 + seg, 0x000b, memoryAGet16(0x0575 + seg, 0x000b) + seg); // 1460 -> 164d; lin=575b
        memoryASet16(0x057a + seg, 0x0003, memoryAGet16(0x057a + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=57a3
        memoryASet16(0x057a + seg, 0x000f, memoryAGet16(0x057a + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=57af
        memoryASet16(0x057b + seg, 0x000b, memoryAGet16(0x057b + seg, 0x000b) + seg); // 1e0a -> 1ff7; lin=57bb
        memoryASet16(0x057c + seg, 0x000b, memoryAGet16(0x057c + seg, 0x000b) + seg); // 12a6 -> 1493; lin=57cb
        memoryASet16(0x057d + seg, 0x0004, memoryAGet16(0x057d + seg, 0x0004) + seg); // 12a6 -> 1493; lin=57d4
        memoryASet16(0x057f + seg, 0x0000, memoryAGet16(0x057f + seg, 0x0000) + seg); // 12a6 -> 1493; lin=57f0
        memoryASet16(0x0580 + seg, 0x0006, memoryAGet16(0x0580 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=5806
        memoryASet16(0x0580 + seg, 0x000e, memoryAGet16(0x0580 + seg, 0x000e) + seg); // 12a6 -> 1493; lin=580e
        memoryASet16(0x0583 + seg, 0x000c, memoryAGet16(0x0583 + seg, 0x000c) + seg); // 06bd -> 08aa; lin=583c
        memoryASet16(0x0584 + seg, 0x0008, memoryAGet16(0x0584 + seg, 0x0008) + seg); // 06bd -> 08aa; lin=5848
        memoryASet16(0x0585 + seg, 0x0001, memoryAGet16(0x0585 + seg, 0x0001) + seg); // 155e -> 174b; lin=5851
        memoryASet16(0x0585 + seg, 0x000d, memoryAGet16(0x0585 + seg, 0x000d) + seg); // 155e -> 174b; lin=585d
        memoryASet16(0x0586 + seg, 0x0009, memoryAGet16(0x0586 + seg, 0x0009) + seg); // 155e -> 174b; lin=5869
        memoryASet16(0x0587 + seg, 0x0004, memoryAGet16(0x0587 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=5874
        memoryASet16(0x0588 + seg, 0x0000, memoryAGet16(0x0588 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=5880
        memoryASet16(0x0588 + seg, 0x0008, memoryAGet16(0x0588 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=5888
        memoryASet16(0x0588 + seg, 0x000d, memoryAGet16(0x0588 + seg, 0x000d) + seg); // 1654 -> 1841; lin=588d
        memoryASet16(0x0589 + seg, 0x0002, memoryAGet16(0x0589 + seg, 0x0002) + seg); // 12a6 -> 1493; lin=5892
        memoryASet16(0x058a + seg, 0x000a, memoryAGet16(0x058a + seg, 0x000a) + seg); // 12a6 -> 1493; lin=58aa
        memoryASet16(0x058b + seg, 0x000a, memoryAGet16(0x058b + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=58ba
        memoryASet16(0x058c + seg, 0x0009, memoryAGet16(0x058c + seg, 0x0009) + seg); // 1e0a -> 1ff7; lin=58c9
        memoryASet16(0x058e + seg, 0x0001, memoryAGet16(0x058e + seg, 0x0001) + seg); // 1e0a -> 1ff7; lin=58e1
        memoryASet16(0x058f + seg, 0x0001, memoryAGet16(0x058f + seg, 0x0001) + seg); // 1460 -> 164d; lin=58f1
        memoryASet16(0x058f + seg, 0x0009, memoryAGet16(0x058f + seg, 0x0009) + seg); // 12a6 -> 1493; lin=58f9
        memoryASet16(0x0590 + seg, 0x000e, memoryAGet16(0x0590 + seg, 0x000e) + seg); // 05c4 -> 07b1; lin=590e
        memoryASet16(0x0591 + seg, 0x000b, memoryAGet16(0x0591 + seg, 0x000b) + seg); // 12a6 -> 1493; lin=591b
        memoryASet16(0x0594 + seg, 0x000e, memoryAGet16(0x0594 + seg, 0x000e) + seg); // 155e -> 174b; lin=594e
        memoryASet16(0x0595 + seg, 0x000e, memoryAGet16(0x0595 + seg, 0x000e) + seg); // 155e -> 174b; lin=595e
        memoryASet16(0x0597 + seg, 0x000d, memoryAGet16(0x0597 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=597d
        memoryASet16(0x0598 + seg, 0x000d, memoryAGet16(0x0598 + seg, 0x000d) + seg); // 155e -> 174b; lin=598d
        memoryASet16(0x0599 + seg, 0x000d, memoryAGet16(0x0599 + seg, 0x000d) + seg); // 1460 -> 164d; lin=599d
        memoryASet16(0x059a + seg, 0x0009, memoryAGet16(0x059a + seg, 0x0009) + seg); // 05c4 -> 07b1; lin=59a9
        memoryASet16(0x059b + seg, 0x000d, memoryAGet16(0x059b + seg, 0x000d) + seg); // 06bd -> 08aa; lin=59bd
        memoryASet16(0x059c + seg, 0x0002, memoryAGet16(0x059c + seg, 0x0002) + seg); // 1460 -> 164d; lin=59c2
        memoryASet16(0x059c + seg, 0x000b, memoryAGet16(0x059c + seg, 0x000b) + seg); // 155e -> 174b; lin=59cb
        memoryASet16(0x059d + seg, 0x0003, memoryAGet16(0x059d + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=59d3
        memoryASet16(0x059d + seg, 0x0008, memoryAGet16(0x059d + seg, 0x0008) + seg); // 12a6 -> 1493; lin=59d8
        memoryASet16(0x059f + seg, 0x0002, memoryAGet16(0x059f + seg, 0x0002) + seg); // 1654 -> 1841; lin=59f2
        memoryASet16(0x05a2 + seg, 0x0005, memoryAGet16(0x05a2 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=5a25
        memoryASet16(0x05a4 + seg, 0x0007, memoryAGet16(0x05a4 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=5a47
        memoryASet16(0x05a6 + seg, 0x000d, memoryAGet16(0x05a6 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=5a6d
        memoryASet16(0x05aa + seg, 0x0009, memoryAGet16(0x05aa + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=5aa9
        memoryASet16(0x05ae + seg, 0x0001, memoryAGet16(0x05ae + seg, 0x0001) + seg); // 0000 -> 01ed; lin=5ae1
        memoryASet16(0x05bc + seg, 0x0009, memoryAGet16(0x05bc + seg, 0x0009) + seg); // 05c4 -> 07b1; lin=5bc9
        memoryASet16(0x05bd + seg, 0x0005, memoryAGet16(0x05bd + seg, 0x0005) + seg); // 1654 -> 1841; lin=5bd5
        memoryASet16(0x05bd + seg, 0x000a, memoryAGet16(0x05bd + seg, 0x000a) + seg); // 1654 -> 1841; lin=5bda
        memoryASet16(0x05c1 + seg, 0x0004, memoryAGet16(0x05c1 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=5c14
        memoryASet16(0x05c3 + seg, 0x0001, memoryAGet16(0x05c3 + seg, 0x0001) + seg); // 1460 -> 164d; lin=5c31
        memoryASet16(0x05c6 + seg, 0x0009, memoryAGet16(0x05c6 + seg, 0x0009) + seg); // 155e -> 174b; lin=5c69
        memoryASet16(0x05c9 + seg, 0x0004, memoryAGet16(0x05c9 + seg, 0x0004) + seg); // 155e -> 174b; lin=5c94
        memoryASet16(0x05cb + seg, 0x0004, memoryAGet16(0x05cb + seg, 0x0004) + seg); // 0000 -> 01ed; lin=5cb4
        memoryASet16(0x05cd + seg, 0x0009, memoryAGet16(0x05cd + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=5cd9
        memoryASet16(0x05ce + seg, 0x0006, memoryAGet16(0x05ce + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=5ce6
        memoryASet16(0x05cf + seg, 0x0002, memoryAGet16(0x05cf + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=5cf2
        memoryASet16(0x05cf + seg, 0x000a, memoryAGet16(0x05cf + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=5cfa
        memoryASet16(0x05cf + seg, 0x000f, memoryAGet16(0x05cf + seg, 0x000f) + seg); // 1460 -> 164d; lin=5cff
        memoryASet16(0x05d0 + seg, 0x000c, memoryAGet16(0x05d0 + seg, 0x000c) + seg); // 1460 -> 164d; lin=5d0c
        memoryASet16(0x05d3 + seg, 0x0003, memoryAGet16(0x05d3 + seg, 0x0003) + seg); // 12a6 -> 1493; lin=5d33
        memoryASet16(0x05d5 + seg, 0x000d, memoryAGet16(0x05d5 + seg, 0x000d) + seg); // 155e -> 174b; lin=5d5d
        memoryASet16(0x05d7 + seg, 0x0007, memoryAGet16(0x05d7 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=5d77
        memoryASet16(0x05d8 + seg, 0x000d, memoryAGet16(0x05d8 + seg, 0x000d) + seg); // 12a6 -> 1493; lin=5d8d
        memoryASet16(0x05da + seg, 0x000f, memoryAGet16(0x05da + seg, 0x000f) + seg); // 12a6 -> 1493; lin=5daf
        memoryASet16(0x05db + seg, 0x000f, memoryAGet16(0x05db + seg, 0x000f) + seg); // 155e -> 174b; lin=5dbf
        memoryASet16(0x05de + seg, 0x0007, memoryAGet16(0x05de + seg, 0x0007) + seg); // 12a6 -> 1493; lin=5de7
        memoryASet16(0x05df + seg, 0x0007, memoryAGet16(0x05df + seg, 0x0007) + seg); // 155e -> 174b; lin=5df7
        memoryASet16(0x05e1 + seg, 0x0002, memoryAGet16(0x05e1 + seg, 0x0002) + seg); // 155e -> 174b; lin=5e12
        memoryASet16(0x05e3 + seg, 0x000b, memoryAGet16(0x05e3 + seg, 0x000b) + seg); // 12a6 -> 1493; lin=5e3b
        memoryASet16(0x05e7 + seg, 0x0007, memoryAGet16(0x05e7 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=5e77
        memoryASet16(0x05e8 + seg, 0x0008, memoryAGet16(0x05e8 + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=5e88
        memoryASet16(0x05e9 + seg, 0x0000, memoryAGet16(0x05e9 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=5e90
        memoryASet16(0x05e9 + seg, 0x0005, memoryAGet16(0x05e9 + seg, 0x0005) + seg); // 1460 -> 164d; lin=5e95
        memoryASet16(0x05eb + seg, 0x000a, memoryAGet16(0x05eb + seg, 0x000a) + seg); // 155e -> 174b; lin=5eba
        memoryASet16(0x05ec + seg, 0x000c, memoryAGet16(0x05ec + seg, 0x000c) + seg); // 155e -> 174b; lin=5ecc
        memoryASet16(0x05ed + seg, 0x0007, memoryAGet16(0x05ed + seg, 0x0007) + seg); // 155e -> 174b; lin=5ed7
        memoryASet16(0x05ef + seg, 0x0004, memoryAGet16(0x05ef + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=5ef4
        memoryASet16(0x05f0 + seg, 0x0005, memoryAGet16(0x05f0 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=5f05
        memoryASet16(0x05f0 + seg, 0x000d, memoryAGet16(0x05f0 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=5f0d
        memoryASet16(0x05f1 + seg, 0x0002, memoryAGet16(0x05f1 + seg, 0x0002) + seg); // 1460 -> 164d; lin=5f12
        memoryASet16(0x05f3 + seg, 0x0000, memoryAGet16(0x05f3 + seg, 0x0000) + seg); // 12a6 -> 1493; lin=5f30
        memoryASet16(0x05f4 + seg, 0x0000, memoryAGet16(0x05f4 + seg, 0x0000) + seg); // 155e -> 174b; lin=5f40
        memoryASet16(0x05f5 + seg, 0x000b, memoryAGet16(0x05f5 + seg, 0x000b) + seg); // 12a6 -> 1493; lin=5f5b
        memoryASet16(0x05f6 + seg, 0x000b, memoryAGet16(0x05f6 + seg, 0x000b) + seg); // 155e -> 174b; lin=5f6b
        memoryASet16(0x05f9 + seg, 0x0002, memoryAGet16(0x05f9 + seg, 0x0002) + seg); // 12a6 -> 1493; lin=5f92
        memoryASet16(0x05fa + seg, 0x0004, memoryAGet16(0x05fa + seg, 0x0004) + seg); // 155e -> 174b; lin=5fa4
        memoryASet16(0x05fa + seg, 0x000c, memoryAGet16(0x05fa + seg, 0x000c) + seg); // 06bd -> 08aa; lin=5fac
        memoryASet16(0x05fd + seg, 0x0001, memoryAGet16(0x05fd + seg, 0x0001) + seg); // 12a6 -> 1493; lin=5fd1
        memoryASet16(0x0601 + seg, 0x000f, memoryAGet16(0x0601 + seg, 0x000f) + seg); // 12a6 -> 1493; lin=601f
        memoryASet16(0x0607 + seg, 0x0009, memoryAGet16(0x0607 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=6079
        memoryASet16(0x060b + seg, 0x0008, memoryAGet16(0x060b + seg, 0x0008) + seg); // 12a6 -> 1493; lin=60b8
        memoryASet16(0x0614 + seg, 0x0008, memoryAGet16(0x0614 + seg, 0x0008) + seg); // 0d8f -> 0f7c; lin=6148
        memoryASet16(0x0615 + seg, 0x0006, memoryAGet16(0x0615 + seg, 0x0006) + seg); // 0d8f -> 0f7c; lin=6156
        memoryASet16(0x0618 + seg, 0x0007, memoryAGet16(0x0618 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=6187
        memoryASet16(0x0619 + seg, 0x0000, memoryAGet16(0x0619 + seg, 0x0000) + seg); // 05c4 -> 07b1; lin=6190
        memoryASet16(0x0619 + seg, 0x000a, memoryAGet16(0x0619 + seg, 0x000a) + seg); // 1654 -> 1841; lin=619a
        memoryASet16(0x061b + seg, 0x0003, memoryAGet16(0x061b + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=61b3
        memoryASet16(0x061b + seg, 0x000c, memoryAGet16(0x061b + seg, 0x000c) + seg); // 1654 -> 1841; lin=61bc
        memoryASet16(0x061e + seg, 0x0005, memoryAGet16(0x061e + seg, 0x0005) + seg); // 1d02 -> 1eef; lin=61e5
        memoryASet16(0x061f + seg, 0x0009, memoryAGet16(0x061f + seg, 0x0009) + seg); // 1d02 -> 1eef; lin=61f9
        memoryASet16(0x0620 + seg, 0x0005, memoryAGet16(0x0620 + seg, 0x0005) + seg); // 12a6 -> 1493; lin=6205
        memoryASet16(0x0620 + seg, 0x000d, memoryAGet16(0x0620 + seg, 0x000d) + seg); // 1654 -> 1841; lin=620d
        memoryASet16(0x0621 + seg, 0x0002, memoryAGet16(0x0621 + seg, 0x0002) + seg); // 12a6 -> 1493; lin=6212
        memoryASet16(0x0621 + seg, 0x0007, memoryAGet16(0x0621 + seg, 0x0007) + seg); // 0e8f -> 107c; lin=6217
        memoryASet16(0x0622 + seg, 0x0007, memoryAGet16(0x0622 + seg, 0x0007) + seg); // 1654 -> 1841; lin=6227
        memoryASet16(0x0622 + seg, 0x000f, memoryAGet16(0x0622 + seg, 0x000f) + seg); // 155e -> 174b; lin=622f
        memoryASet16(0x0623 + seg, 0x0007, memoryAGet16(0x0623 + seg, 0x0007) + seg); // 12a6 -> 1493; lin=6237
        memoryASet16(0x0624 + seg, 0x000a, memoryAGet16(0x0624 + seg, 0x000a) + seg); // 12a6 -> 1493; lin=624a
        memoryASet16(0x0625 + seg, 0x000f, memoryAGet16(0x0625 + seg, 0x000f) + seg); // 12a6 -> 1493; lin=625f
        memoryASet16(0x0627 + seg, 0x000e, memoryAGet16(0x0627 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=627e
        memoryASet16(0x0628 + seg, 0x000a, memoryAGet16(0x0628 + seg, 0x000a) + seg); // 12a6 -> 1493; lin=628a
        memoryASet16(0x0629 + seg, 0x0006, memoryAGet16(0x0629 + seg, 0x0006) + seg); // 155e -> 174b; lin=6296
        memoryASet16(0x062b + seg, 0x000b, memoryAGet16(0x062b + seg, 0x000b) + seg); // 155e -> 174b; lin=62bb
        memoryASet16(0x062f + seg, 0x0009, memoryAGet16(0x062f + seg, 0x0009) + seg); // 12a6 -> 1493; lin=62f9
        memoryASet16(0x062f + seg, 0x000f, memoryAGet16(0x062f + seg, 0x000f) + seg); // 2a3a -> 2c27; lin=62ff
        memoryASet16(0x0632 + seg, 0x0008, memoryAGet16(0x0632 + seg, 0x0008) + seg); // 155e -> 174b; lin=6328
        memoryASet16(0x0635 + seg, 0x0004, memoryAGet16(0x0635 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=6354
        memoryASet16(0x0636 + seg, 0x000f, memoryAGet16(0x0636 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=636f
        memoryASet16(0x0638 + seg, 0x0008, memoryAGet16(0x0638 + seg, 0x0008) + seg); // 2a3a -> 2c27; lin=6388
        memoryASet16(0x063a + seg, 0x0007, memoryAGet16(0x063a + seg, 0x0007) + seg); // 037d -> 056a; lin=63a7
        memoryASet16(0x063b + seg, 0x000f, memoryAGet16(0x063b + seg, 0x000f) + seg); // 1931 -> 1b1e; lin=63bf
        memoryASet16(0x063c + seg, 0x0007, memoryAGet16(0x063c + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=63c7
        memoryASet16(0x0641 + seg, 0x000a, memoryAGet16(0x0641 + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=641a
        memoryASet16(0x0642 + seg, 0x0002, memoryAGet16(0x0642 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=6422
        memoryASet16(0x0648 + seg, 0x0005, memoryAGet16(0x0648 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=6485
        memoryASet16(0x0648 + seg, 0x000d, memoryAGet16(0x0648 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=648d
        memoryASet16(0x064a + seg, 0x000a, memoryAGet16(0x064a + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=64aa
        memoryASet16(0x064b + seg, 0x0007, memoryAGet16(0x064b + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=64b7
        memoryASet16(0x064c + seg, 0x0008, memoryAGet16(0x064c + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=64c8
        memoryASet16(0x064d + seg, 0x0000, memoryAGet16(0x064d + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=64d0
        memoryASet16(0x064e + seg, 0x000f, memoryAGet16(0x064e + seg, 0x000f) + seg); // 1931 -> 1b1e; lin=64ef
        memoryASet16(0x0650 + seg, 0x0009, memoryAGet16(0x0650 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=6509
        memoryASet16(0x0652 + seg, 0x000a, memoryAGet16(0x0652 + seg, 0x000a) + seg); // 1460 -> 164d; lin=652a
        memoryASet16(0x0654 + seg, 0x000b, memoryAGet16(0x0654 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=654b
        memoryASet16(0x0655 + seg, 0x0000, memoryAGet16(0x0655 + seg, 0x0000) + seg); // 1460 -> 164d; lin=6550
        memoryASet16(0x0655 + seg, 0x0005, memoryAGet16(0x0655 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=6555
        memoryASet16(0x0656 + seg, 0x0002, memoryAGet16(0x0656 + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=6562
        memoryASet16(0x0657 + seg, 0x0003, memoryAGet16(0x0657 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=6573
        memoryASet16(0x0657 + seg, 0x000b, memoryAGet16(0x0657 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=657b
        memoryASet16(0x0659 + seg, 0x000a, memoryAGet16(0x0659 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=659a
        memoryASet16(0x065d + seg, 0x0000, memoryAGet16(0x065d + seg, 0x0000) + seg); // 0000 -> 01ed; lin=65d0
        memoryASet16(0x065e + seg, 0x0003, memoryAGet16(0x065e + seg, 0x0003) + seg); // 037d -> 056a; lin=65e3
        memoryASet16(0x065f + seg, 0x0004, memoryAGet16(0x065f + seg, 0x0004) + seg); // 0000 -> 01ed; lin=65f4
        memoryASet16(0x0660 + seg, 0x0005, memoryAGet16(0x0660 + seg, 0x0005) + seg); // 0000 -> 01ed; lin=6605
        memoryASet16(0x0661 + seg, 0x000a, memoryAGet16(0x0661 + seg, 0x000a) + seg); // 12a6 -> 1493; lin=661a
        memoryASet16(0x0662 + seg, 0x0003, memoryAGet16(0x0662 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=6623
        memoryASet16(0x0662 + seg, 0x000b, memoryAGet16(0x0662 + seg, 0x000b) + seg); // 1460 -> 164d; lin=662b
        memoryASet16(0x0665 + seg, 0x0002, memoryAGet16(0x0665 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=6652
        memoryASet16(0x0666 + seg, 0x0006, memoryAGet16(0x0666 + seg, 0x0006) + seg); // 037d -> 056a; lin=6666
        memoryASet16(0x0667 + seg, 0x0009, memoryAGet16(0x0667 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=6679
        memoryASet16(0x0668 + seg, 0x000f, memoryAGet16(0x0668 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=668f
        memoryASet16(0x0669 + seg, 0x000c, memoryAGet16(0x0669 + seg, 0x000c) + seg); // 1931 -> 1b1e; lin=669c
        memoryASet16(0x066a + seg, 0x000d, memoryAGet16(0x066a + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=66ad
        memoryASet16(0x066c + seg, 0x000d, memoryAGet16(0x066c + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=66cd
        memoryASet16(0x066e + seg, 0x0002, memoryAGet16(0x066e + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=66e2
        memoryASet16(0x066f + seg, 0x000c, memoryAGet16(0x066f + seg, 0x000c) + seg); // 1931 -> 1b1e; lin=66fc
        memoryASet16(0x0670 + seg, 0x0004, memoryAGet16(0x0670 + seg, 0x0004) + seg); // 1460 -> 164d; lin=6704
        memoryASet16(0x0672 + seg, 0x0005, memoryAGet16(0x0672 + seg, 0x0005) + seg); // 0000 -> 01ed; lin=6725
        memoryASet16(0x0674 + seg, 0x000e, memoryAGet16(0x0674 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=674e
        memoryASet16(0x0676 + seg, 0x000d, memoryAGet16(0x0676 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=676d
        memoryASet16(0x0678 + seg, 0x000e, memoryAGet16(0x0678 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=678e
        memoryASet16(0x067a + seg, 0x000f, memoryAGet16(0x067a + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=67af
        memoryASet16(0x067c + seg, 0x0009, memoryAGet16(0x067c + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=67c9
        memoryASet16(0x067e + seg, 0x0003, memoryAGet16(0x067e + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=67e3
        memoryASet16(0x0680 + seg, 0x0001, memoryAGet16(0x0680 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=6801
        memoryASet16(0x0681 + seg, 0x000f, memoryAGet16(0x0681 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=681f
        memoryASet16(0x0682 + seg, 0x0007, memoryAGet16(0x0682 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=6827
        memoryASet16(0x0684 + seg, 0x0003, memoryAGet16(0x0684 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=6843
        memoryASet16(0x0686 + seg, 0x0005, memoryAGet16(0x0686 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=6865
        memoryASet16(0x0688 + seg, 0x0009, memoryAGet16(0x0688 + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=6889
        memoryASet16(0x068a + seg, 0x000d, memoryAGet16(0x068a + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=68ad
        memoryASet16(0x068c + seg, 0x000a, memoryAGet16(0x068c + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=68ca
        memoryASet16(0x068e + seg, 0x0007, memoryAGet16(0x068e + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=68e7
        memoryASet16(0x0690 + seg, 0x0008, memoryAGet16(0x0690 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=6908
        memoryASet16(0x0692 + seg, 0x0009, memoryAGet16(0x0692 + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=6929
        memoryASet16(0x0693 + seg, 0x000e, memoryAGet16(0x0693 + seg, 0x000e) + seg); // 1460 -> 164d; lin=693e
        memoryASet16(0x0695 + seg, 0x0000, memoryAGet16(0x0695 + seg, 0x0000) + seg); // 1460 -> 164d; lin=6950
        memoryASet16(0x06a0 + seg, 0x0002, memoryAGet16(0x06a0 + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=6a02
        memoryASet16(0x06a1 + seg, 0x0003, memoryAGet16(0x06a1 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=6a13
        memoryASet16(0x06a1 + seg, 0x000b, memoryAGet16(0x06a1 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=6a1b
        memoryASet16(0x06a2 + seg, 0x0000, memoryAGet16(0x06a2 + seg, 0x0000) + seg); // 1460 -> 164d; lin=6a20
        memoryASet16(0x06a4 + seg, 0x0001, memoryAGet16(0x06a4 + seg, 0x0001) + seg); // 037d -> 056a; lin=6a41
        memoryASet16(0x06a4 + seg, 0x000f, memoryAGet16(0x06a4 + seg, 0x000f) + seg); // 1874 -> 1a61; lin=6a4f
        memoryASet16(0x06a5 + seg, 0x0004, memoryAGet16(0x06a5 + seg, 0x0004) + seg); // 06bd -> 08aa; lin=6a54
        memoryASet16(0x06a6 + seg, 0x000b, memoryAGet16(0x06a6 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=6a6b
        memoryASet16(0x06a7 + seg, 0x0003, memoryAGet16(0x06a7 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=6a73
        memoryASet16(0x06a9 + seg, 0x0000, memoryAGet16(0x06a9 + seg, 0x0000) + seg); // 037d -> 056a; lin=6a90
        memoryASet16(0x06ac + seg, 0x0006, memoryAGet16(0x06ac + seg, 0x0006) + seg); // 1874 -> 1a61; lin=6ac6
        memoryASet16(0x06ae + seg, 0x0000, memoryAGet16(0x06ae + seg, 0x0000) + seg); // 0e8f -> 107c; lin=6ae0
        memoryASet16(0x06af + seg, 0x0009, memoryAGet16(0x06af + seg, 0x0009) + seg); // 1654 -> 1841; lin=6af9
        memoryASet16(0x06af + seg, 0x000e, memoryAGet16(0x06af + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=6afe
        memoryASet16(0x06b0 + seg, 0x0003, memoryAGet16(0x06b0 + seg, 0x0003) + seg); // 0915 -> 0b02; lin=6b03
        memoryASet16(0x06b1 + seg, 0x0004, memoryAGet16(0x06b1 + seg, 0x0004) + seg); // 03ed -> 05da; lin=6b14
        memoryASet16(0x06b2 + seg, 0x000c, memoryAGet16(0x06b2 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=6b2c
        memoryASet16(0x06b5 + seg, 0x000a, memoryAGet16(0x06b5 + seg, 0x000a) + seg); // 1460 -> 164d; lin=6b5a
        memoryASet16(0x06b7 + seg, 0x0006, memoryAGet16(0x06b7 + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=6b76
        memoryASet16(0x06b8 + seg, 0x0007, memoryAGet16(0x06b8 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=6b87
        memoryASet16(0x06b9 + seg, 0x0007, memoryAGet16(0x06b9 + seg, 0x0007) + seg); // 1460 -> 164d; lin=6b97
        memoryASet16(0x06bb + seg, 0x0009, memoryAGet16(0x06bb + seg, 0x0009) + seg); // 03ed -> 05da; lin=6bb9
        memoryASet16(0x06c0 + seg, 0x0006, memoryAGet16(0x06c0 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=6c06
        memoryASet16(0x06c1 + seg, 0x0003, memoryAGet16(0x06c1 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=6c13
        memoryASet16(0x06c2 + seg, 0x0004, memoryAGet16(0x06c2 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=6c24
        memoryASet16(0x06c3 + seg, 0x0000, memoryAGet16(0x06c3 + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=6c30
        memoryASet16(0x06c3 + seg, 0x000c, memoryAGet16(0x06c3 + seg, 0x000c) + seg); // 1931 -> 1b1e; lin=6c3c
        memoryASet16(0x06c4 + seg, 0x000a, memoryAGet16(0x06c4 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=6c4a
        memoryASet16(0x06c5 + seg, 0x0002, memoryAGet16(0x06c5 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=6c52
        memoryASet16(0x06c5 + seg, 0x0007, memoryAGet16(0x06c5 + seg, 0x0007) + seg); // 1460 -> 164d; lin=6c57
        memoryASet16(0x06c6 + seg, 0x0005, memoryAGet16(0x06c6 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=6c65
        memoryASet16(0x06c7 + seg, 0x0002, memoryAGet16(0x06c7 + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=6c72
        memoryASet16(0x06c7 + seg, 0x000e, memoryAGet16(0x06c7 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=6c7e
        memoryASet16(0x06c8 + seg, 0x000a, memoryAGet16(0x06c8 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=6c8a
        memoryASet16(0x06c9 + seg, 0x0006, memoryAGet16(0x06c9 + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=6c96
        memoryASet16(0x06cb + seg, 0x000e, memoryAGet16(0x06cb + seg, 0x000e) + seg); // 0000 -> 01ed; lin=6cbe
        memoryASet16(0x06cc + seg, 0x0005, memoryAGet16(0x06cc + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=6cc5
        memoryASet16(0x06cd + seg, 0x0001, memoryAGet16(0x06cd + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6cd1
        memoryASet16(0x06ce + seg, 0x0000, memoryAGet16(0x06ce + seg, 0x0000) + seg); // 155e -> 174b; lin=6ce0
        memoryASet16(0x06ce + seg, 0x0007, memoryAGet16(0x06ce + seg, 0x0007) + seg); // 0000 -> 01ed; lin=6ce7
        memoryASet16(0x06ce + seg, 0x000e, memoryAGet16(0x06ce + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=6cee
        memoryASet16(0x06cf + seg, 0x000a, memoryAGet16(0x06cf + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=6cfa
        memoryASet16(0x06d0 + seg, 0x0009, memoryAGet16(0x06d0 + seg, 0x0009) + seg); // 155e -> 174b; lin=6d09
        memoryASet16(0x06d1 + seg, 0x0000, memoryAGet16(0x06d1 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=6d10
        memoryASet16(0x06d1 + seg, 0x0007, memoryAGet16(0x06d1 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=6d17
        memoryASet16(0x06d2 + seg, 0x0003, memoryAGet16(0x06d2 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=6d23
        memoryASet16(0x06d2 + seg, 0x000b, memoryAGet16(0x06d2 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=6d2b
        memoryASet16(0x06d3 + seg, 0x0000, memoryAGet16(0x06d3 + seg, 0x0000) + seg); // 1460 -> 164d; lin=6d30
        memoryASet16(0x06d3 + seg, 0x0005, memoryAGet16(0x06d3 + seg, 0x0005) + seg); // 155e -> 174b; lin=6d35
        memoryASet16(0x06d4 + seg, 0x0004, memoryAGet16(0x06d4 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=6d44
        memoryASet16(0x06d5 + seg, 0x0001, memoryAGet16(0x06d5 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6d51
        memoryASet16(0x06d6 + seg, 0x0007, memoryAGet16(0x06d6 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=6d67
        memoryASet16(0x06d7 + seg, 0x0003, memoryAGet16(0x06d7 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=6d73
        memoryASet16(0x06d9 + seg, 0x0007, memoryAGet16(0x06d9 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=6d97
        memoryASet16(0x06df + seg, 0x0001, memoryAGet16(0x06df + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=6df1
        memoryASet16(0x06e0 + seg, 0x000a, memoryAGet16(0x06e0 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=6e0a
        memoryASet16(0x06e1 + seg, 0x0006, memoryAGet16(0x06e1 + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=6e16
        memoryASet16(0x06e2 + seg, 0x000d, memoryAGet16(0x06e2 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=6e2d
        memoryASet16(0x06e3 + seg, 0x0009, memoryAGet16(0x06e3 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=6e39
        memoryASet16(0x06e5 + seg, 0x0001, memoryAGet16(0x06e5 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6e51
        memoryASet16(0x06e5 + seg, 0x000d, memoryAGet16(0x06e5 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=6e5d
        memoryASet16(0x06e7 + seg, 0x0005, memoryAGet16(0x06e7 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=6e75
        memoryASet16(0x06e8 + seg, 0x0001, memoryAGet16(0x06e8 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6e81
        memoryASet16(0x06e9 + seg, 0x0009, memoryAGet16(0x06e9 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=6e99
        memoryASet16(0x06ea + seg, 0x0005, memoryAGet16(0x06ea + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=6ea5
        memoryASet16(0x06eb + seg, 0x000d, memoryAGet16(0x06eb + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=6ebd
        memoryASet16(0x06ec + seg, 0x0009, memoryAGet16(0x06ec + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=6ec9
        memoryASet16(0x06ee + seg, 0x0001, memoryAGet16(0x06ee + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6ee1
        memoryASet16(0x06ee + seg, 0x000d, memoryAGet16(0x06ee + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=6eed
        memoryASet16(0x06f0 + seg, 0x0005, memoryAGet16(0x06f0 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=6f05
        memoryASet16(0x06f1 + seg, 0x0001, memoryAGet16(0x06f1 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6f11
        memoryASet16(0x06f2 + seg, 0x0009, memoryAGet16(0x06f2 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=6f29
        memoryASet16(0x06f3 + seg, 0x0005, memoryAGet16(0x06f3 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=6f35
        memoryASet16(0x06f4 + seg, 0x000d, memoryAGet16(0x06f4 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=6f4d
        memoryASet16(0x06f5 + seg, 0x0009, memoryAGet16(0x06f5 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=6f59
        memoryASet16(0x06f7 + seg, 0x0001, memoryAGet16(0x06f7 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=6f71
        memoryASet16(0x06fa + seg, 0x000b, memoryAGet16(0x06fa + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=6fab
        memoryASet16(0x06fb + seg, 0x0007, memoryAGet16(0x06fb + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=6fb7
        memoryASet16(0x06fd + seg, 0x0007, memoryAGet16(0x06fd + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=6fd7
        memoryASet16(0x06ff + seg, 0x0005, memoryAGet16(0x06ff + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=6ff5
        memoryASet16(0x0700 + seg, 0x0002, memoryAGet16(0x0700 + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=7002
        memoryASet16(0x0700 + seg, 0x000e, memoryAGet16(0x0700 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=700e
        memoryASet16(0x0702 + seg, 0x0008, memoryAGet16(0x0702 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=7028
        memoryASet16(0x0703 + seg, 0x0000, memoryAGet16(0x0703 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=7030
        memoryASet16(0x0703 + seg, 0x0005, memoryAGet16(0x0703 + seg, 0x0005) + seg); // 1460 -> 164d; lin=7035
        memoryASet16(0x070c + seg, 0x0006, memoryAGet16(0x070c + seg, 0x0006) + seg); // 1460 -> 164d; lin=70c6
        memoryASet16(0x070d + seg, 0x000b, memoryAGet16(0x070d + seg, 0x000b) + seg); // 1460 -> 164d; lin=70db
        memoryASet16(0x070e + seg, 0x0008, memoryAGet16(0x070e + seg, 0x0008) + seg); // 1874 -> 1a61; lin=70e8
        memoryASet16(0x070f + seg, 0x0000, memoryAGet16(0x070f + seg, 0x0000) + seg); // 1874 -> 1a61; lin=70f0
        memoryASet16(0x0710 + seg, 0x0002, memoryAGet16(0x0710 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=7102
        memoryASet16(0x0710 + seg, 0x000e, memoryAGet16(0x0710 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=710e
        memoryASet16(0x0711 + seg, 0x000a, memoryAGet16(0x0711 + seg, 0x000a) + seg); // 1e0a -> 1ff7; lin=711a
        memoryASet16(0x0714 + seg, 0x0007, memoryAGet16(0x0714 + seg, 0x0007) + seg); // 1e0a -> 1ff7; lin=7147
        memoryASet16(0x0717 + seg, 0x0008, memoryAGet16(0x0717 + seg, 0x0008) + seg); // 1e0a -> 1ff7; lin=7178
        memoryASet16(0x0718 + seg, 0x0005, memoryAGet16(0x0718 + seg, 0x0005) + seg); // 1460 -> 164d; lin=7185
        memoryASet16(0x0718 + seg, 0x000e, memoryAGet16(0x0718 + seg, 0x000e) + seg); // 1874 -> 1a61; lin=718e
        memoryASet16(0x0719 + seg, 0x0006, memoryAGet16(0x0719 + seg, 0x0006) + seg); // 1874 -> 1a61; lin=7196
        memoryASet16(0x0719 + seg, 0x000b, memoryAGet16(0x0719 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=719b
        memoryASet16(0x071a + seg, 0x0000, memoryAGet16(0x071a + seg, 0x0000) + seg); // 1874 -> 1a61; lin=71a0
        memoryASet16(0x071a + seg, 0x0005, memoryAGet16(0x071a + seg, 0x0005) + seg); // 1460 -> 164d; lin=71a5
        memoryASet16(0x071a + seg, 0x000a, memoryAGet16(0x071a + seg, 0x000a) + seg); // 1654 -> 1841; lin=71aa
        memoryASet16(0x071a + seg, 0x000f, memoryAGet16(0x071a + seg, 0x000f) + seg); // 12a6 -> 1493; lin=71af
        memoryASet16(0x071b + seg, 0x0004, memoryAGet16(0x071b + seg, 0x0004) + seg); // 155e -> 174b; lin=71b4
        memoryASet16(0x071b + seg, 0x000c, memoryAGet16(0x071b + seg, 0x000c) + seg); // 0000 -> 01ed; lin=71bc
        memoryASet16(0x071d + seg, 0x0000, memoryAGet16(0x071d + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=71d0
        memoryASet16(0x071d + seg, 0x0008, memoryAGet16(0x071d + seg, 0x0008) + seg); // 0000 -> 01ed; lin=71d8
        memoryASet16(0x0724 + seg, 0x000b, memoryAGet16(0x0724 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=724b
        memoryASet16(0x0725 + seg, 0x0008, memoryAGet16(0x0725 + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=7258
        memoryASet16(0x0726 + seg, 0x0004, memoryAGet16(0x0726 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=7264
        memoryASet16(0x0726 + seg, 0x000c, memoryAGet16(0x0726 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=726c
        memoryASet16(0x0727 + seg, 0x0007, memoryAGet16(0x0727 + seg, 0x0007) + seg); // 12a6 -> 1493; lin=7277
        memoryASet16(0x072f + seg, 0x0006, memoryAGet16(0x072f + seg, 0x0006) + seg); // 0000 -> 01ed; lin=72f6
        memoryASet16(0x0730 + seg, 0x0007, memoryAGet16(0x0730 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=7307
        memoryASet16(0x0731 + seg, 0x0007, memoryAGet16(0x0731 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=7317
        memoryASet16(0x0732 + seg, 0x0003, memoryAGet16(0x0732 + seg, 0x0003) + seg); // 037d -> 056a; lin=7323
        memoryASet16(0x0735 + seg, 0x000a, memoryAGet16(0x0735 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=735a
        memoryASet16(0x0736 + seg, 0x000b, memoryAGet16(0x0736 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=736b
        memoryASet16(0x0737 + seg, 0x000b, memoryAGet16(0x0737 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=737b
        memoryASet16(0x0738 + seg, 0x0007, memoryAGet16(0x0738 + seg, 0x0007) + seg); // 037d -> 056a; lin=7387
        memoryASet16(0x073c + seg, 0x000b, memoryAGet16(0x073c + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=73cb
        memoryASet16(0x073d + seg, 0x0008, memoryAGet16(0x073d + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=73d8
        memoryASet16(0x073e + seg, 0x0009, memoryAGet16(0x073e + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=73e9
        memoryASet16(0x073f + seg, 0x0001, memoryAGet16(0x073f + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=73f1
        memoryASet16(0x0741 + seg, 0x0000, memoryAGet16(0x0741 + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=7410
        memoryASet16(0x0742 + seg, 0x000a, memoryAGet16(0x0742 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=742a
        memoryASet16(0x0743 + seg, 0x000e, memoryAGet16(0x0743 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=743e
        memoryASet16(0x0747 + seg, 0x000f, memoryAGet16(0x0747 + seg, 0x000f) + seg); // 05c4 -> 07b1; lin=747f
        memoryASet16(0x0748 + seg, 0x000d, memoryAGet16(0x0748 + seg, 0x000d) + seg); // 05c4 -> 07b1; lin=748d
        memoryASet16(0x074b + seg, 0x0006, memoryAGet16(0x074b + seg, 0x0006) + seg); // 037d -> 056a; lin=74b6
        memoryASet16(0x074c + seg, 0x000f, memoryAGet16(0x074c + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=74cf
        memoryASet16(0x074d + seg, 0x000c, memoryAGet16(0x074d + seg, 0x000c) + seg); // 1931 -> 1b1e; lin=74dc
        memoryASet16(0x074e + seg, 0x000f, memoryAGet16(0x074e + seg, 0x000f) + seg); // 1931 -> 1b1e; lin=74ef
        memoryASet16(0x074f + seg, 0x000d, memoryAGet16(0x074f + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=74fd
        memoryASet16(0x0750 + seg, 0x0005, memoryAGet16(0x0750 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=7505
        memoryASet16(0x0750 + seg, 0x000a, memoryAGet16(0x0750 + seg, 0x000a) + seg); // 1460 -> 164d; lin=750a
        memoryASet16(0x0752 + seg, 0x0004, memoryAGet16(0x0752 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=7524
        memoryASet16(0x0753 + seg, 0x0001, memoryAGet16(0x0753 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=7531
        memoryASet16(0x0753 + seg, 0x000d, memoryAGet16(0x0753 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=753d
        memoryASet16(0x0756 + seg, 0x0005, memoryAGet16(0x0756 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=7565
        memoryASet16(0x0756 + seg, 0x000a, memoryAGet16(0x0756 + seg, 0x000a) + seg); // 1460 -> 164d; lin=756a
        memoryASet16(0x0759 + seg, 0x0000, memoryAGet16(0x0759 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=7590
        memoryASet16(0x0759 + seg, 0x000d, memoryAGet16(0x0759 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=759d
        memoryASet16(0x075b + seg, 0x0000, memoryAGet16(0x075b + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=75b0
        memoryASet16(0x075b + seg, 0x000e, memoryAGet16(0x075b + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=75be
        memoryASet16(0x075c + seg, 0x0006, memoryAGet16(0x075c + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=75c6
        memoryASet16(0x075c + seg, 0x000b, memoryAGet16(0x075c + seg, 0x000b) + seg); // 1460 -> 164d; lin=75cb
        memoryASet16(0x075f + seg, 0x0004, memoryAGet16(0x075f + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=75f4
        memoryASet16(0x0760 + seg, 0x0001, memoryAGet16(0x0760 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=7601
        memoryASet16(0x0761 + seg, 0x0007, memoryAGet16(0x0761 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=7617
        memoryASet16(0x0762 + seg, 0x000e, memoryAGet16(0x0762 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=762e
        memoryASet16(0x0763 + seg, 0x000f, memoryAGet16(0x0763 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=763f
        memoryASet16(0x0764 + seg, 0x0004, memoryAGet16(0x0764 + seg, 0x0004) + seg); // 1460 -> 164d; lin=7644
        memoryASet16(0x0765 + seg, 0x0009, memoryAGet16(0x0765 + seg, 0x0009) + seg); // 1460 -> 164d; lin=7659
        memoryASet16(0x0767 + seg, 0x000e, memoryAGet16(0x0767 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=767e
        memoryASet16(0x0768 + seg, 0x000b, memoryAGet16(0x0768 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=768b
        memoryASet16(0x0769 + seg, 0x000e, memoryAGet16(0x0769 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=769e
        memoryASet16(0x076a + seg, 0x000c, memoryAGet16(0x076a + seg, 0x000c) + seg); // 1931 -> 1b1e; lin=76ac
        memoryASet16(0x076b + seg, 0x0004, memoryAGet16(0x076b + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=76b4
        memoryASet16(0x076b + seg, 0x0009, memoryAGet16(0x076b + seg, 0x0009) + seg); // 1460 -> 164d; lin=76b9
        memoryASet16(0x076e + seg, 0x0005, memoryAGet16(0x076e + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=76e5
        memoryASet16(0x076f + seg, 0x0002, memoryAGet16(0x076f + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=76f2
        memoryASet16(0x0770 + seg, 0x0003, memoryAGet16(0x0770 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=7703
        memoryASet16(0x0770 + seg, 0x000b, memoryAGet16(0x0770 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=770b
        memoryASet16(0x0772 + seg, 0x000a, memoryAGet16(0x0772 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=772a
        memoryASet16(0x0774 + seg, 0x0004, memoryAGet16(0x0774 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=7744
        memoryASet16(0x0777 + seg, 0x0008, memoryAGet16(0x0777 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=7778
        memoryASet16(0x0778 + seg, 0x0005, memoryAGet16(0x0778 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=7785
        memoryASet16(0x0779 + seg, 0x0006, memoryAGet16(0x0779 + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=7796
        memoryASet16(0x0779 + seg, 0x000e, memoryAGet16(0x0779 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=779e
        memoryASet16(0x077b + seg, 0x000d, memoryAGet16(0x077b + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=77bd
        memoryASet16(0x077d + seg, 0x0007, memoryAGet16(0x077d + seg, 0x0007) + seg); // 0000 -> 01ed; lin=77d7
        memoryASet16(0x0781 + seg, 0x000e, memoryAGet16(0x0781 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=781e
        memoryASet16(0x0786 + seg, 0x0004, memoryAGet16(0x0786 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=7864
        memoryASet16(0x0787 + seg, 0x0005, memoryAGet16(0x0787 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=7875
        memoryASet16(0x0787 + seg, 0x000d, memoryAGet16(0x0787 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=787d
        memoryASet16(0x0788 + seg, 0x0002, memoryAGet16(0x0788 + seg, 0x0002) + seg); // 1460 -> 164d; lin=7882
        memoryASet16(0x0788 + seg, 0x0007, memoryAGet16(0x0788 + seg, 0x0007) + seg); // 1654 -> 1841; lin=7887
        memoryASet16(0x078c + seg, 0x000f, memoryAGet16(0x078c + seg, 0x000f) + seg); // 1460 -> 164d; lin=78cf
        memoryASet16(0x078d + seg, 0x0004, memoryAGet16(0x078d + seg, 0x0004) + seg); // 1654 -> 1841; lin=78d4
        memoryASet16(0x078e + seg, 0x000e, memoryAGet16(0x078e + seg, 0x000e) + seg); // 1874 -> 1a61; lin=78ee
        memoryASet16(0x078f + seg, 0x0003, memoryAGet16(0x078f + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=78f3
        memoryASet16(0x0790 + seg, 0x0000, memoryAGet16(0x0790 + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=7900
        memoryASet16(0x0790 + seg, 0x000c, memoryAGet16(0x0790 + seg, 0x000c) + seg); // 1931 -> 1b1e; lin=790c
        memoryASet16(0x0791 + seg, 0x0004, memoryAGet16(0x0791 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=7914
        memoryASet16(0x0791 + seg, 0x0009, memoryAGet16(0x0791 + seg, 0x0009) + seg); // 1460 -> 164d; lin=7919
        memoryASet16(0x0791 + seg, 0x000e, memoryAGet16(0x0791 + seg, 0x000e) + seg); // 1654 -> 1841; lin=791e
        memoryASet16(0x0792 + seg, 0x0009, memoryAGet16(0x0792 + seg, 0x0009) + seg); // 1874 -> 1a61; lin=7929
        memoryASet16(0x0793 + seg, 0x000a, memoryAGet16(0x0793 + seg, 0x000a) + seg); // 0915 -> 0b02; lin=793a
        memoryASet16(0x0796 + seg, 0x000a, memoryAGet16(0x0796 + seg, 0x000a) + seg); // 1654 -> 1841; lin=796a
        memoryASet16(0x0799 + seg, 0x0001, memoryAGet16(0x0799 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=7991
        memoryASet16(0x0799 + seg, 0x000b, memoryAGet16(0x0799 + seg, 0x000b) + seg); // 1a89 -> 1c76; lin=799b
        memoryASet16(0x079a + seg, 0x0000, memoryAGet16(0x079a + seg, 0x0000) + seg); // 1654 -> 1841; lin=79a0
        memoryASet16(0x079c + seg, 0x0009, memoryAGet16(0x079c + seg, 0x0009) + seg); // 1654 -> 1841; lin=79c9
        memoryASet16(0x079f + seg, 0x0000, memoryAGet16(0x079f + seg, 0x0000) + seg); // 1460 -> 164d; lin=79f0
        memoryASet16(0x07a0 + seg, 0x000b, memoryAGet16(0x07a0 + seg, 0x000b) + seg); // 1654 -> 1841; lin=7a0b
        memoryASet16(0x07a4 + seg, 0x0005, memoryAGet16(0x07a4 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=7a45
        memoryASet16(0x07a4 + seg, 0x000a, memoryAGet16(0x07a4 + seg, 0x000a) + seg); // 1874 -> 1a61; lin=7a4a
        memoryASet16(0x07a5 + seg, 0x0003, memoryAGet16(0x07a5 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=7a53
        memoryASet16(0x07a5 + seg, 0x000b, memoryAGet16(0x07a5 + seg, 0x000b) + seg); // 1460 -> 164d; lin=7a5b
        memoryASet16(0x07a6 + seg, 0x000b, memoryAGet16(0x07a6 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=7a6b
        memoryASet16(0x07a7 + seg, 0x0007, memoryAGet16(0x07a7 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=7a77
        memoryASet16(0x07a7 + seg, 0x000f, memoryAGet16(0x07a7 + seg, 0x000f) + seg); // 1654 -> 1841; lin=7a7f
        memoryASet16(0x07a8 + seg, 0x0004, memoryAGet16(0x07a8 + seg, 0x0004) + seg); // 1460 -> 164d; lin=7a84
        memoryASet16(0x07a9 + seg, 0x0007, memoryAGet16(0x07a9 + seg, 0x0007) + seg); // 1874 -> 1a61; lin=7a97
        memoryASet16(0x07ac + seg, 0x000b, memoryAGet16(0x07ac + seg, 0x000b) + seg); // 1654 -> 1841; lin=7acb
        memoryASet16(0x07af + seg, 0x000d, memoryAGet16(0x07af + seg, 0x000d) + seg); // 1874 -> 1a61; lin=7afd
        memoryASet16(0x07b0 + seg, 0x0008, memoryAGet16(0x07b0 + seg, 0x0008) + seg); // 1874 -> 1a61; lin=7b08
        memoryASet16(0x07b1 + seg, 0x000d, memoryAGet16(0x07b1 + seg, 0x000d) + seg); // 1874 -> 1a61; lin=7b1d
        memoryASet16(0x07b2 + seg, 0x000f, memoryAGet16(0x07b2 + seg, 0x000f) + seg); // 1874 -> 1a61; lin=7b2f
        memoryASet16(0x07b3 + seg, 0x000d, memoryAGet16(0x07b3 + seg, 0x000d) + seg); // 1874 -> 1a61; lin=7b3d
        memoryASet16(0x07b4 + seg, 0x0008, memoryAGet16(0x07b4 + seg, 0x0008) + seg); // 1874 -> 1a61; lin=7b48
        memoryASet16(0x07b5 + seg, 0x0000, memoryAGet16(0x07b5 + seg, 0x0000) + seg); // 12a6 -> 1493; lin=7b50
        memoryASet16(0x07b6 + seg, 0x0003, memoryAGet16(0x07b6 + seg, 0x0003) + seg); // 1460 -> 164d; lin=7b63
        memoryASet16(0x07b6 + seg, 0x000b, memoryAGet16(0x07b6 + seg, 0x000b) + seg); // 037d -> 056a; lin=7b6b
        memoryASet16(0x07b8 + seg, 0x000e, memoryAGet16(0x07b8 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=7b8e
        memoryASet16(0x07b9 + seg, 0x000a, memoryAGet16(0x07b9 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=7b9a
        memoryASet16(0x07bb + seg, 0x0001, memoryAGet16(0x07bb + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=7bb1
        memoryASet16(0x07bd + seg, 0x000e, memoryAGet16(0x07bd + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=7bde
        memoryASet16(0x07c1 + seg, 0x0006, memoryAGet16(0x07c1 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=7c16
        memoryASet16(0x07c2 + seg, 0x000b, memoryAGet16(0x07c2 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=7c2b
        memoryASet16(0x07c4 + seg, 0x0003, memoryAGet16(0x07c4 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=7c43
        memoryASet16(0x07c5 + seg, 0x0006, memoryAGet16(0x07c5 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=7c56
        memoryASet16(0x07c7 + seg, 0x0004, memoryAGet16(0x07c7 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=7c74
        memoryASet16(0x07c8 + seg, 0x0007, memoryAGet16(0x07c8 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=7c87
        memoryASet16(0x07ca + seg, 0x0000, memoryAGet16(0x07ca + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=7ca0
        memoryASet16(0x07cb + seg, 0x0004, memoryAGet16(0x07cb + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=7cb4
        memoryASet16(0x07cd + seg, 0x000f, memoryAGet16(0x07cd + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=7cdf
        memoryASet16(0x07cf + seg, 0x000d, memoryAGet16(0x07cf + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=7cfd
        memoryASet16(0x07d1 + seg, 0x0009, memoryAGet16(0x07d1 + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=7d19
        memoryASet16(0x07d3 + seg, 0x0006, memoryAGet16(0x07d3 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=7d36
        memoryASet16(0x07d4 + seg, 0x000a, memoryAGet16(0x07d4 + seg, 0x000a) + seg); // 037d -> 056a; lin=7d4a
        memoryASet16(0x07d6 + seg, 0x0007, memoryAGet16(0x07d6 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=7d67
        memoryASet16(0x07d8 + seg, 0x0005, memoryAGet16(0x07d8 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=7d85
        memoryASet16(0x07da + seg, 0x0000, memoryAGet16(0x07da + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=7da0
        memoryASet16(0x07dd + seg, 0x000d, memoryAGet16(0x07dd + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=7ddd
        memoryASet16(0x07df + seg, 0x0008, memoryAGet16(0x07df + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=7df8
        memoryASet16(0x07e3 + seg, 0x0005, memoryAGet16(0x07e3 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=7e35
        memoryASet16(0x07e5 + seg, 0x0000, memoryAGet16(0x07e5 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=7e50
        memoryASet16(0x07e7 + seg, 0x0000, memoryAGet16(0x07e7 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=7e70
        memoryASet16(0x07e9 + seg, 0x0009, memoryAGet16(0x07e9 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=7e99
        memoryASet16(0x07eb + seg, 0x0005, memoryAGet16(0x07eb + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=7eb5
        memoryASet16(0x07ee + seg, 0x0007, memoryAGet16(0x07ee + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=7ee7
        memoryASet16(0x07ef + seg, 0x0005, memoryAGet16(0x07ef + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=7ef5
        memoryASet16(0x07f0 + seg, 0x0003, memoryAGet16(0x07f0 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=7f03
        memoryASet16(0x07f1 + seg, 0x000b, memoryAGet16(0x07f1 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=7f1b
        memoryASet16(0x07f3 + seg, 0x0006, memoryAGet16(0x07f3 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=7f36
        memoryASet16(0x07f6 + seg, 0x0003, memoryAGet16(0x07f6 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=7f63
        memoryASet16(0x07f8 + seg, 0x0001, memoryAGet16(0x07f8 + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=7f81
        memoryASet16(0x07f9 + seg, 0x000c, memoryAGet16(0x07f9 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=7f9c
        memoryASet16(0x07fd + seg, 0x0001, memoryAGet16(0x07fd + seg, 0x0001) + seg); // 1931 -> 1b1e; lin=7fd1
        memoryASet16(0x07fe + seg, 0x0009, memoryAGet16(0x07fe + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=7fe9
        memoryASet16(0x0801 + seg, 0x000b, memoryAGet16(0x0801 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=801b
        memoryASet16(0x0803 + seg, 0x0006, memoryAGet16(0x0803 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=8036
        memoryASet16(0x0806 + seg, 0x000f, memoryAGet16(0x0806 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=806f
        memoryASet16(0x0809 + seg, 0x0004, memoryAGet16(0x0809 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=8094
        memoryASet16(0x080a + seg, 0x0002, memoryAGet16(0x080a + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=80a2
        memoryASet16(0x080c + seg, 0x0004, memoryAGet16(0x080c + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=80c4
        memoryASet16(0x080e + seg, 0x0002, memoryAGet16(0x080e + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=80e2
        memoryASet16(0x0813 + seg, 0x0000, memoryAGet16(0x0813 + seg, 0x0000) + seg); // 1e0a -> 1ff7; lin=8130
        memoryASet16(0x0815 + seg, 0x0005, memoryAGet16(0x0815 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=8155
        memoryASet16(0x081b + seg, 0x000d, memoryAGet16(0x081b + seg, 0x000d) + seg); // 1e0a -> 1ff7; lin=81bd
        memoryASet16(0x0820 + seg, 0x000a, memoryAGet16(0x0820 + seg, 0x000a) + seg); // 1e0a -> 1ff7; lin=820a
        memoryASet16(0x0824 + seg, 0x0002, memoryAGet16(0x0824 + seg, 0x0002) + seg); // 1e0a -> 1ff7; lin=8242
        memoryASet16(0x0828 + seg, 0x0006, memoryAGet16(0x0828 + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=8286
        memoryASet16(0x082b + seg, 0x0001, memoryAGet16(0x082b + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=82b1
        memoryASet16(0x082b + seg, 0x0009, memoryAGet16(0x082b + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=82b9
        memoryASet16(0x082f + seg, 0x0008, memoryAGet16(0x082f + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=82f8
        memoryASet16(0x0830 + seg, 0x0009, memoryAGet16(0x0830 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=8309
        memoryASet16(0x0831 + seg, 0x0001, memoryAGet16(0x0831 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=8311
        memoryASet16(0x0831 + seg, 0x0006, memoryAGet16(0x0831 + seg, 0x0006) + seg); // 1460 -> 164d; lin=8316
        memoryASet16(0x0832 + seg, 0x0001, memoryAGet16(0x0832 + seg, 0x0001) + seg); // 1654 -> 1841; lin=8321
        memoryASet16(0x0832 + seg, 0x0006, memoryAGet16(0x0832 + seg, 0x0006) + seg); // 1654 -> 1841; lin=8326
        memoryASet16(0x0833 + seg, 0x0001, memoryAGet16(0x0833 + seg, 0x0001) + seg); // 1654 -> 1841; lin=8331
        memoryASet16(0x0834 + seg, 0x000c, memoryAGet16(0x0834 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=834c
        memoryASet16(0x0836 + seg, 0x0004, memoryAGet16(0x0836 + seg, 0x0004) + seg); // 1e0a -> 1ff7; lin=8364
        memoryASet16(0x0837 + seg, 0x000c, memoryAGet16(0x0837 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=837c
        memoryASet16(0x0838 + seg, 0x000e, memoryAGet16(0x0838 + seg, 0x000e) + seg); // 1654 -> 1841; lin=838e
        memoryASet16(0x0839 + seg, 0x0007, memoryAGet16(0x0839 + seg, 0x0007) + seg); // 1874 -> 1a61; lin=8397
        memoryASet16(0x083a + seg, 0x0009, memoryAGet16(0x083a + seg, 0x0009) + seg); // 06bd -> 08aa; lin=83a9
        memoryASet16(0x083b + seg, 0x0003, memoryAGet16(0x083b + seg, 0x0003) + seg); // 1654 -> 1841; lin=83b3
        memoryASet16(0x083b + seg, 0x000b, memoryAGet16(0x083b + seg, 0x000b) + seg); // 1654 -> 1841; lin=83bb
        memoryASet16(0x083e + seg, 0x000d, memoryAGet16(0x083e + seg, 0x000d) + seg); // 1654 -> 1841; lin=83ed
        memoryASet16(0x083f + seg, 0x0006, memoryAGet16(0x083f + seg, 0x0006) + seg); // 1654 -> 1841; lin=83f6
        memoryASet16(0x083f + seg, 0x000e, memoryAGet16(0x083f + seg, 0x000e) + seg); // 1460 -> 164d; lin=83fe
        memoryASet16(0x0840 + seg, 0x0003, memoryAGet16(0x0840 + seg, 0x0003) + seg); // 1460 -> 164d; lin=8403
        memoryASet16(0x0840 + seg, 0x000c, memoryAGet16(0x0840 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=840c
        memoryASet16(0x0841 + seg, 0x000d, memoryAGet16(0x0841 + seg, 0x000d) + seg); // 06bd -> 08aa; lin=841d
        memoryASet16(0x0842 + seg, 0x0007, memoryAGet16(0x0842 + seg, 0x0007) + seg); // 1654 -> 1841; lin=8427
        memoryASet16(0x0842 + seg, 0x000f, memoryAGet16(0x0842 + seg, 0x000f) + seg); // 1654 -> 1841; lin=842f
        memoryASet16(0x0846 + seg, 0x0003, memoryAGet16(0x0846 + seg, 0x0003) + seg); // 1654 -> 1841; lin=8463
        memoryASet16(0x084d + seg, 0x000c, memoryAGet16(0x084d + seg, 0x000c) + seg); // 1654 -> 1841; lin=84dc
        memoryASet16(0x0862 + seg, 0x0006, memoryAGet16(0x0862 + seg, 0x0006) + seg); // 1654 -> 1841; lin=8626
        memoryASet16(0x086f + seg, 0x0004, memoryAGet16(0x086f + seg, 0x0004) + seg); // 1874 -> 1a61; lin=86f4
        memoryASet16(0x0870 + seg, 0x0002, memoryAGet16(0x0870 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=8702
        memoryASet16(0x088f + seg, 0x0007, memoryAGet16(0x088f + seg, 0x0007) + seg); // 1654 -> 1841; lin=88f7
        memoryASet16(0x08a0 + seg, 0x0003, memoryAGet16(0x08a0 + seg, 0x0003) + seg); // 037d -> 056a; lin=8a03
        memoryASet16(0x08a2 + seg, 0x0003, memoryAGet16(0x08a2 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=8a23
        memoryASet16(0x08a6 + seg, 0x000f, memoryAGet16(0x08a6 + seg, 0x000f) + seg); // 037d -> 056a; lin=8a6f
        memoryASet16(0x08a7 + seg, 0x000d, memoryAGet16(0x08a7 + seg, 0x000d) + seg); // 1654 -> 1841; lin=8a7d
        memoryASet16(0x08a9 + seg, 0x0000, memoryAGet16(0x08a9 + seg, 0x0000) + seg); // 1654 -> 1841; lin=8a90
        memoryASet16(0x08af + seg, 0x0004, memoryAGet16(0x08af + seg, 0x0004) + seg); // 1874 -> 1a61; lin=8af4
        memoryASet16(0x08b0 + seg, 0x000c, memoryAGet16(0x08b0 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=8b0c
        memoryASet16(0x08b2 + seg, 0x0004, memoryAGet16(0x08b2 + seg, 0x0004) + seg); // 1460 -> 164d; lin=8b24
        memoryASet16(0x08c6 + seg, 0x0009, memoryAGet16(0x08c6 + seg, 0x0009) + seg); // 1874 -> 1a61; lin=8c69
        memoryASet16(0x08c8 + seg, 0x0009, memoryAGet16(0x08c8 + seg, 0x0009) + seg); // 155e -> 174b; lin=8c89
        memoryASet16(0x08cb + seg, 0x0003, memoryAGet16(0x08cb + seg, 0x0003) + seg); // 037d -> 056a; lin=8cb3
        memoryASet16(0x08cb + seg, 0x000b, memoryAGet16(0x08cb + seg, 0x000b) + seg); // 1874 -> 1a61; lin=8cbb
        memoryASet16(0x08ce + seg, 0x0007, memoryAGet16(0x08ce + seg, 0x0007) + seg); // 155e -> 174b; lin=8ce7
        memoryASet16(0x08cf + seg, 0x0005, memoryAGet16(0x08cf + seg, 0x0005) + seg); // 12a6 -> 1493; lin=8cf5
        memoryASet16(0x08d0 + seg, 0x0001, memoryAGet16(0x08d0 + seg, 0x0001) + seg); // 155e -> 174b; lin=8d01
        memoryASet16(0x08d2 + seg, 0x0005, memoryAGet16(0x08d2 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=8d25
        memoryASet16(0x08d3 + seg, 0x0006, memoryAGet16(0x08d3 + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=8d36
        memoryASet16(0x08d3 + seg, 0x000e, memoryAGet16(0x08d3 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=8d3e
        memoryASet16(0x08d4 + seg, 0x000f, memoryAGet16(0x08d4 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=8d4f
        memoryASet16(0x08d5 + seg, 0x0004, memoryAGet16(0x08d5 + seg, 0x0004) + seg); // 1460 -> 164d; lin=8d54
        memoryASet16(0x08d6 + seg, 0x0001, memoryAGet16(0x08d6 + seg, 0x0001) + seg); // 1460 -> 164d; lin=8d61
        memoryASet16(0x08d6 + seg, 0x000f, memoryAGet16(0x08d6 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=8d6f
        memoryASet16(0x08d8 + seg, 0x000b, memoryAGet16(0x08d8 + seg, 0x000b) + seg); // 1874 -> 1a61; lin=8d8b
        memoryASet16(0x08de + seg, 0x0002, memoryAGet16(0x08de + seg, 0x0002) + seg); // 1d02 -> 1eef; lin=8de2
        memoryASet16(0x08df + seg, 0x0000, memoryAGet16(0x08df + seg, 0x0000) + seg); // 1d02 -> 1eef; lin=8df0
        memoryASet16(0x08ea + seg, 0x0002, memoryAGet16(0x08ea + seg, 0x0002) + seg); // 1d02 -> 1eef; lin=8ea2
        memoryASet16(0x08ec + seg, 0x0006, memoryAGet16(0x08ec + seg, 0x0006) + seg); // 1654 -> 1841; lin=8ec6
        memoryASet16(0x08ed + seg, 0x000e, memoryAGet16(0x08ed + seg, 0x000e) + seg); // 1654 -> 1841; lin=8ede
        memoryASet16(0x08ef + seg, 0x0005, memoryAGet16(0x08ef + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=8ef5
        memoryASet16(0x08f1 + seg, 0x000c, memoryAGet16(0x08f1 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=8f1c
        memoryASet16(0x08fc + seg, 0x0008, memoryAGet16(0x08fc + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=8fc8
        memoryASet16(0x08fd + seg, 0x0006, memoryAGet16(0x08fd + seg, 0x0006) + seg); // 0d8f -> 0f7c; lin=8fd6
        memoryASet16(0x0907 + seg, 0x000c, memoryAGet16(0x0907 + seg, 0x000c) + seg); // 0d8f -> 0f7c; lin=907c
        memoryASet16(0x0909 + seg, 0x0001, memoryAGet16(0x0909 + seg, 0x0001) + seg); // 1654 -> 1841; lin=9091
        memoryASet16(0x090b + seg, 0x000c, memoryAGet16(0x090b + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=90bc
        memoryASet16(0x090d + seg, 0x000d, memoryAGet16(0x090d + seg, 0x000d) + seg); // 1e0a -> 1ff7; lin=90dd
        memoryASet16(0x090f + seg, 0x0003, memoryAGet16(0x090f + seg, 0x0003) + seg); // 1460 -> 164d; lin=90f3
        memoryASet16(0x091c + seg, 0x0009, memoryAGet16(0x091c + seg, 0x0009) + seg); // 0000 -> 01ed; lin=91c9
        memoryASet16(0x0922 + seg, 0x0004, memoryAGet16(0x0922 + seg, 0x0004) + seg); // 1e0a -> 1ff7; lin=9224
        memoryASet16(0x0923 + seg, 0x000c, memoryAGet16(0x0923 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=923c
        memoryASet16(0x0927 + seg, 0x0001, memoryAGet16(0x0927 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=9271
        memoryASet16(0x0929 + seg, 0x0000, memoryAGet16(0x0929 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=9290
        memoryASet16(0x092d + seg, 0x000a, memoryAGet16(0x092d + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=92da
        memoryASet16(0x0930 + seg, 0x0009, memoryAGet16(0x0930 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=9309
        memoryASet16(0x093a + seg, 0x0003, memoryAGet16(0x093a + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=93a3
        memoryASet16(0x094d + seg, 0x0002, memoryAGet16(0x094d + seg, 0x0002) + seg); // 0000 -> 01ed; lin=94d2
        memoryASet16(0x0956 + seg, 0x0005, memoryAGet16(0x0956 + seg, 0x0005) + seg); // 037d -> 056a; lin=9565
        memoryASet16(0x0958 + seg, 0x0008, memoryAGet16(0x0958 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=9588
        memoryASet16(0x095b + seg, 0x000d, memoryAGet16(0x095b + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=95bd
        memoryASet16(0x0960 + seg, 0x000d, memoryAGet16(0x0960 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=960d
        memoryASet16(0x0961 + seg, 0x000d, memoryAGet16(0x0961 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=961d
        memoryASet16(0x0963 + seg, 0x0000, memoryAGet16(0x0963 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=9630
        memoryASet16(0x0964 + seg, 0x0004, memoryAGet16(0x0964 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=9644
        memoryASet16(0x0965 + seg, 0x000c, memoryAGet16(0x0965 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=965c
        memoryASet16(0x0967 + seg, 0x0002, memoryAGet16(0x0967 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=9672
        memoryASet16(0x096d + seg, 0x0003, memoryAGet16(0x096d + seg, 0x0003) + seg); // 0000 -> 01ed; lin=96d3
        memoryASet16(0x096e + seg, 0x0004, memoryAGet16(0x096e + seg, 0x0004) + seg); // 037d -> 056a; lin=96e4
        memoryASet16(0x0973 + seg, 0x000c, memoryAGet16(0x0973 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=973c
        memoryASet16(0x0975 + seg, 0x0000, memoryAGet16(0x0975 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=9750
        memoryASet16(0x0976 + seg, 0x0000, memoryAGet16(0x0976 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=9760
        memoryASet16(0x0977 + seg, 0x0000, memoryAGet16(0x0977 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=9770
        memoryASet16(0x0978 + seg, 0x0004, memoryAGet16(0x0978 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=9784
        memoryASet16(0x0979 + seg, 0x0004, memoryAGet16(0x0979 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=9794
        memoryASet16(0x097b + seg, 0x0002, memoryAGet16(0x097b + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=97b2
        memoryASet16(0x097e + seg, 0x0001, memoryAGet16(0x097e + seg, 0x0001) + seg); // 0000 -> 01ed; lin=97e1
        memoryASet16(0x0981 + seg, 0x0007, memoryAGet16(0x0981 + seg, 0x0007) + seg); // 2a3a -> 2c27; lin=9817
        memoryASet16(0x0985 + seg, 0x000d, memoryAGet16(0x0985 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=985d
        memoryASet16(0x0987 + seg, 0x000b, memoryAGet16(0x0987 + seg, 0x000b) + seg); // 12a6 -> 1493; lin=987b
        memoryASet16(0x0989 + seg, 0x000c, memoryAGet16(0x0989 + seg, 0x000c) + seg); // 2a3a -> 2c27; lin=989c
        memoryASet16(0x098b + seg, 0x0008, memoryAGet16(0x098b + seg, 0x0008) + seg); // 2a3a -> 2c27; lin=98b8
        memoryASet16(0x098e + seg, 0x0003, memoryAGet16(0x098e + seg, 0x0003) + seg); // 037d -> 056a; lin=98e3
        memoryASet16(0x0990 + seg, 0x0007, memoryAGet16(0x0990 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=9907
        memoryASet16(0x0991 + seg, 0x0003, memoryAGet16(0x0991 + seg, 0x0003) + seg); // 12a6 -> 1493; lin=9913
        memoryASet16(0x0991 + seg, 0x000f, memoryAGet16(0x0991 + seg, 0x000f) + seg); // 12a6 -> 1493; lin=991f
        memoryASet16(0x0992 + seg, 0x000b, memoryAGet16(0x0992 + seg, 0x000b) + seg); // 12a6 -> 1493; lin=992b
        memoryASet16(0x0993 + seg, 0x0007, memoryAGet16(0x0993 + seg, 0x0007) + seg); // 12a6 -> 1493; lin=9937
        memoryASet16(0x0994 + seg, 0x0003, memoryAGet16(0x0994 + seg, 0x0003) + seg); // 12a6 -> 1493; lin=9943
        memoryASet16(0x0994 + seg, 0x000f, memoryAGet16(0x0994 + seg, 0x000f) + seg); // 12a6 -> 1493; lin=994f
        memoryASet16(0x0995 + seg, 0x000f, memoryAGet16(0x0995 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=995f
        memoryASet16(0x0997 + seg, 0x0002, memoryAGet16(0x0997 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=9972
        memoryASet16(0x0998 + seg, 0x0006, memoryAGet16(0x0998 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=9986
        memoryASet16(0x0999 + seg, 0x000a, memoryAGet16(0x0999 + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=999a
        memoryASet16(0x099a + seg, 0x000e, memoryAGet16(0x099a + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=99ae
        memoryASet16(0x099b + seg, 0x0008, memoryAGet16(0x099b + seg, 0x0008) + seg); // 1460 -> 164d; lin=99b8
        memoryASet16(0x099e + seg, 0x000d, memoryAGet16(0x099e + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=99ed
        memoryASet16(0x099f + seg, 0x0005, memoryAGet16(0x099f + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=99f5
        memoryASet16(0x09a1 + seg, 0x0006, memoryAGet16(0x09a1 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=9a16
        memoryASet16(0x09a2 + seg, 0x0005, memoryAGet16(0x09a2 + seg, 0x0005) + seg); // 1460 -> 164d; lin=9a25
        memoryASet16(0x09a3 + seg, 0x0001, memoryAGet16(0x09a3 + seg, 0x0001) + seg); // 1460 -> 164d; lin=9a31
        memoryASet16(0x09a4 + seg, 0x0007, memoryAGet16(0x09a4 + seg, 0x0007) + seg); // 1460 -> 164d; lin=9a47
        memoryASet16(0x09a7 + seg, 0x0008, memoryAGet16(0x09a7 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=9a78
        memoryASet16(0x09a8 + seg, 0x000d, memoryAGet16(0x09a8 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=9a8d
        memoryASet16(0x09ab + seg, 0x000d, memoryAGet16(0x09ab + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=9abd
        memoryASet16(0x09b2 + seg, 0x0001, memoryAGet16(0x09b2 + seg, 0x0001) + seg); // 12a6 -> 1493; lin=9b21
        memoryASet16(0x09b2 + seg, 0x0006, memoryAGet16(0x09b2 + seg, 0x0006) + seg); // 12a6 -> 1493; lin=9b26
        memoryASet16(0x09b2 + seg, 0x000f, memoryAGet16(0x09b2 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=9b2f
        memoryASet16(0x09b3 + seg, 0x0007, memoryAGet16(0x09b3 + seg, 0x0007) + seg); // 1654 -> 1841; lin=9b37
        memoryASet16(0x09b4 + seg, 0x000f, memoryAGet16(0x09b4 + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=9b4f
        memoryASet16(0x09b6 + seg, 0x0001, memoryAGet16(0x09b6 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=9b61
        memoryASet16(0x09b6 + seg, 0x000e, memoryAGet16(0x09b6 + seg, 0x000e) + seg); // 12a6 -> 1493; lin=9b6e
        memoryASet16(0x09b7 + seg, 0x0003, memoryAGet16(0x09b7 + seg, 0x0003) + seg); // 1460 -> 164d; lin=9b73
        memoryASet16(0x09b8 + seg, 0x000e, memoryAGet16(0x09b8 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=9b8e
        memoryASet16(0x09b9 + seg, 0x0006, memoryAGet16(0x09b9 + seg, 0x0006) + seg); // 1654 -> 1841; lin=9b96
        memoryASet16(0x09ba + seg, 0x000a, memoryAGet16(0x09ba + seg, 0x000a) + seg); // 12a6 -> 1493; lin=9baa
        memoryASet16(0x09be + seg, 0x0002, memoryAGet16(0x09be + seg, 0x0002) + seg); // 1e0a -> 1ff7; lin=9be2
        memoryASet16(0x09c5 + seg, 0x0006, memoryAGet16(0x09c5 + seg, 0x0006) + seg); // 155e -> 174b; lin=9c56
        memoryASet16(0x09c5 + seg, 0x000e, memoryAGet16(0x09c5 + seg, 0x000e) + seg); // 1460 -> 164d; lin=9c5e
        memoryASet16(0x09c8 + seg, 0x000b, memoryAGet16(0x09c8 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=9c8b
        memoryASet16(0x09c9 + seg, 0x0003, memoryAGet16(0x09c9 + seg, 0x0003) + seg); // 1654 -> 1841; lin=9c93
        memoryASet16(0x09c9 + seg, 0x0008, memoryAGet16(0x09c9 + seg, 0x0008) + seg); // 12a6 -> 1493; lin=9c98
        memoryASet16(0x09c9 + seg, 0x000d, memoryAGet16(0x09c9 + seg, 0x000d) + seg); // 12a6 -> 1493; lin=9c9d
        memoryASet16(0x09ca + seg, 0x0006, memoryAGet16(0x09ca + seg, 0x0006) + seg); // 12a6 -> 1493; lin=9ca6
        memoryASet16(0x09cb + seg, 0x0002, memoryAGet16(0x09cb + seg, 0x0002) + seg); // 12a6 -> 1493; lin=9cb2
        memoryASet16(0x09cb + seg, 0x000e, memoryAGet16(0x09cb + seg, 0x000e) + seg); // 12a6 -> 1493; lin=9cbe
        memoryASet16(0x09cd + seg, 0x000d, memoryAGet16(0x09cd + seg, 0x000d) + seg); // 06bd -> 08aa; lin=9cdd
        memoryASet16(0x09cf + seg, 0x0002, memoryAGet16(0x09cf + seg, 0x0002) + seg); // 1460 -> 164d; lin=9cf2
        memoryASet16(0x09cf + seg, 0x000e, memoryAGet16(0x09cf + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=9cfe
        memoryASet16(0x09d1 + seg, 0x0002, memoryAGet16(0x09d1 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=9d12
        memoryASet16(0x09d1 + seg, 0x000e, memoryAGet16(0x09d1 + seg, 0x000e) + seg); // 1460 -> 164d; lin=9d1e
        memoryASet16(0x09d2 + seg, 0x000b, memoryAGet16(0x09d2 + seg, 0x000b) + seg); // 1e0a -> 1ff7; lin=9d2b
        memoryASet16(0x09d4 + seg, 0x0005, memoryAGet16(0x09d4 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=9d45
        memoryASet16(0x09d5 + seg, 0x0001, memoryAGet16(0x09d5 + seg, 0x0001) + seg); // 1460 -> 164d; lin=9d51
        memoryASet16(0x09d5 + seg, 0x000e, memoryAGet16(0x09d5 + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=9d5e
        memoryASet16(0x09d7 + seg, 0x000a, memoryAGet16(0x09d7 + seg, 0x000a) + seg); // 06bd -> 08aa; lin=9d7a
        memoryASet16(0x09d8 + seg, 0x0003, memoryAGet16(0x09d8 + seg, 0x0003) + seg); // 155e -> 174b; lin=9d83
        memoryASet16(0x09d8 + seg, 0x000f, memoryAGet16(0x09d8 + seg, 0x000f) + seg); // 155e -> 174b; lin=9d8f
        memoryASet16(0x09d9 + seg, 0x000b, memoryAGet16(0x09d9 + seg, 0x000b) + seg); // 155e -> 174b; lin=9d9b
        memoryASet16(0x09da + seg, 0x0003, memoryAGet16(0x09da + seg, 0x0003) + seg); // 12a6 -> 1493; lin=9da3
        memoryASet16(0x09da + seg, 0x0008, memoryAGet16(0x09da + seg, 0x0008) + seg); // 1460 -> 164d; lin=9da8
        memoryASet16(0x09db + seg, 0x0001, memoryAGet16(0x09db + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=9db1
        memoryASet16(0x09db + seg, 0x0009, memoryAGet16(0x09db + seg, 0x0009) + seg); // 1654 -> 1841; lin=9db9
        memoryASet16(0x09db + seg, 0x000e, memoryAGet16(0x09db + seg, 0x000e) + seg); // 12a6 -> 1493; lin=9dbe
        memoryASet16(0x0a7c + seg, 0x0002, memoryAGet16(0x0a7c + seg, 0x0002) + seg); // 037d -> 056a; lin=a7c2
        memoryASet16(0x0abc + seg, 0x0002, memoryAGet16(0x0abc + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=abc2
        memoryASet16(0x0ac0 + seg, 0x0004, memoryAGet16(0x0ac0 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=ac04
        memoryASet16(0x0ac6 + seg, 0x0000, memoryAGet16(0x0ac6 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=ac60
        memoryASet16(0x0aca + seg, 0x0001, memoryAGet16(0x0aca + seg, 0x0001) + seg); // 0b80 -> 0d6d; lin=aca1
        memoryASet16(0x0aed + seg, 0x000f, memoryAGet16(0x0aed + seg, 0x000f) + seg); // 06bd -> 08aa; lin=aedf
        memoryASet16(0x0b46 + seg, 0x0002, memoryAGet16(0x0b46 + seg, 0x0002) + seg); // 0d8f -> 0f7c; lin=b462
        memoryASet16(0x0b52 + seg, 0x0008, memoryAGet16(0x0b52 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=b528
        memoryASet16(0x0b54 + seg, 0x000d, memoryAGet16(0x0b54 + seg, 0x000d) + seg); // 1654 -> 1841; lin=b54d
        memoryASet16(0x0b57 + seg, 0x0006, memoryAGet16(0x0b57 + seg, 0x0006) + seg); // 1d02 -> 1eef; lin=b576
        memoryASet16(0x0b5a + seg, 0x0006, memoryAGet16(0x0b5a + seg, 0x0006) + seg); // 1d02 -> 1eef; lin=b5a6
        memoryASet16(0x0b5d + seg, 0x0003, memoryAGet16(0x0b5d + seg, 0x0003) + seg); // 1d02 -> 1eef; lin=b5d3
        memoryASet16(0x0b5f + seg, 0x000f, memoryAGet16(0x0b5f + seg, 0x000f) + seg); // 1654 -> 1841; lin=b5ff
        memoryASet16(0x0b62 + seg, 0x0008, memoryAGet16(0x0b62 + seg, 0x0008) + seg); // 1d02 -> 1eef; lin=b628
        memoryASet16(0x0b65 + seg, 0x0008, memoryAGet16(0x0b65 + seg, 0x0008) + seg); // 1d02 -> 1eef; lin=b658
        memoryASet16(0x0b68 + seg, 0x000e, memoryAGet16(0x0b68 + seg, 0x000e) + seg); // 1d02 -> 1eef; lin=b68e
        memoryASet16(0x0b6b + seg, 0x000a, memoryAGet16(0x0b6b + seg, 0x000a) + seg); // 1654 -> 1841; lin=b6ba
        memoryASet16(0x0b6c + seg, 0x000c, memoryAGet16(0x0b6c + seg, 0x000c) + seg); // 037d -> 056a; lin=b6cc
        memoryASet16(0x0b73 + seg, 0x0004, memoryAGet16(0x0b73 + seg, 0x0004) + seg); // 1654 -> 1841; lin=b734
        memoryASet16(0x0b7d + seg, 0x0006, memoryAGet16(0x0b7d + seg, 0x0006) + seg); // 1654 -> 1841; lin=b7d6
        memoryASet16(0x0b84 + seg, 0x000b, memoryAGet16(0x0b84 + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=b84b
        memoryASet16(0x0ba4 + seg, 0x0001, memoryAGet16(0x0ba4 + seg, 0x0001) + seg); // 1874 -> 1a61; lin=ba41
        memoryASet16(0x0ba5 + seg, 0x000a, memoryAGet16(0x0ba5 + seg, 0x000a) + seg); // 1874 -> 1a61; lin=ba5a
        memoryASet16(0x0bae + seg, 0x0003, memoryAGet16(0x0bae + seg, 0x0003) + seg); // 1874 -> 1a61; lin=bae3
        memoryASet16(0x0bb2 + seg, 0x0001, memoryAGet16(0x0bb2 + seg, 0x0001) + seg); // 1874 -> 1a61; lin=bb21
        memoryASet16(0x0bc7 + seg, 0x0003, memoryAGet16(0x0bc7 + seg, 0x0003) + seg); // 1460 -> 164d; lin=bc73
        memoryASet16(0x0bde + seg, 0x000c, memoryAGet16(0x0bde + seg, 0x000c) + seg); // 1874 -> 1a61; lin=bdec
        memoryASet16(0x0bef + seg, 0x0008, memoryAGet16(0x0bef + seg, 0x0008) + seg); // 1874 -> 1a61; lin=bef8
        memoryASet16(0x0bf3 + seg, 0x000f, memoryAGet16(0x0bf3 + seg, 0x000f) + seg); // 1874 -> 1a61; lin=bf3f
        memoryASet16(0x0bf8 + seg, 0x000e, memoryAGet16(0x0bf8 + seg, 0x000e) + seg); // 1874 -> 1a61; lin=bf8e
        memoryASet16(0x0bfb + seg, 0x0001, memoryAGet16(0x0bfb + seg, 0x0001) + seg); // 1874 -> 1a61; lin=bfb1
        memoryASet16(0x0c0a + seg, 0x0000, memoryAGet16(0x0c0a + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=c0a0
        memoryASet16(0x0c0a + seg, 0x000e, memoryAGet16(0x0c0a + seg, 0x000e) + seg); // 06bd -> 08aa; lin=c0ae
        memoryASet16(0x0c14 + seg, 0x0003, memoryAGet16(0x0c14 + seg, 0x0003) + seg); // 1654 -> 1841; lin=c143
        memoryASet16(0x0c14 + seg, 0x000f, memoryAGet16(0x0c14 + seg, 0x000f) + seg); // 1874 -> 1a61; lin=c14f
        memoryASet16(0x0c1e + seg, 0x0001, memoryAGet16(0x0c1e + seg, 0x0001) + seg); // 1654 -> 1841; lin=c1e1
        memoryASet16(0x0c29 + seg, 0x0005, memoryAGet16(0x0c29 + seg, 0x0005) + seg); // 1654 -> 1841; lin=c295
        memoryASet16(0x0c2a + seg, 0x0001, memoryAGet16(0x0c2a + seg, 0x0001) + seg); // 1874 -> 1a61; lin=c2a1
        memoryASet16(0x0c2a + seg, 0x000c, memoryAGet16(0x0c2a + seg, 0x000c) + seg); // 06bd -> 08aa; lin=c2ac
        memoryASet16(0x0c2e + seg, 0x0006, memoryAGet16(0x0c2e + seg, 0x0006) + seg); // 037d -> 056a; lin=c2e6
        memoryASet16(0x0c35 + seg, 0x0000, memoryAGet16(0x0c35 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=c350
        memoryASet16(0x0c3f + seg, 0x0000, memoryAGet16(0x0c3f + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=c3f0
        memoryASet16(0x0c3f + seg, 0x000b, memoryAGet16(0x0c3f + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=c3fb
        memoryASet16(0x0c43 + seg, 0x0008, memoryAGet16(0x0c43 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=c438
        memoryASet16(0x0c44 + seg, 0x0003, memoryAGet16(0x0c44 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=c443
        memoryASet16(0x0c4e + seg, 0x000d, memoryAGet16(0x0c4e + seg, 0x000d) + seg); // 1874 -> 1a61; lin=c4ed
        memoryASet16(0x0c51 + seg, 0x0005, memoryAGet16(0x0c51 + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=c515
        memoryASet16(0x0c52 + seg, 0x0000, memoryAGet16(0x0c52 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=c520
        memoryASet16(0x0c56 + seg, 0x0005, memoryAGet16(0x0c56 + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=c565
        memoryASet16(0x0c57 + seg, 0x0000, memoryAGet16(0x0c57 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=c570
        memoryASet16(0x0c59 + seg, 0x0004, memoryAGet16(0x0c59 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=c594
        memoryASet16(0x0c69 + seg, 0x0006, memoryAGet16(0x0c69 + seg, 0x0006) + seg); // 1874 -> 1a61; lin=c696
        memoryASet16(0x0c77 + seg, 0x0000, memoryAGet16(0x0c77 + seg, 0x0000) + seg); // 1874 -> 1a61; lin=c770
        memoryASet16(0x0c87 + seg, 0x0001, memoryAGet16(0x0c87 + seg, 0x0001) + seg); // 1874 -> 1a61; lin=c871
        memoryASet16(0x0c9b + seg, 0x000e, memoryAGet16(0x0c9b + seg, 0x000e) + seg); // 0d8f -> 0f7c; lin=c9be
        memoryASet16(0x0c9d + seg, 0x000a, memoryAGet16(0x0c9d + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=c9da
        memoryASet16(0x0ca0 + seg, 0x0001, memoryAGet16(0x0ca0 + seg, 0x0001) + seg); // 0d8f -> 0f7c; lin=ca01
        memoryASet16(0x0ca1 + seg, 0x0009, memoryAGet16(0x0ca1 + seg, 0x0009) + seg); // 0d8f -> 0f7c; lin=ca19
        memoryASet16(0x0ca3 + seg, 0x000a, memoryAGet16(0x0ca3 + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=ca3a
        memoryASet16(0x0ca5 + seg, 0x000a, memoryAGet16(0x0ca5 + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=ca5a
        memoryASet16(0x0ca7 + seg, 0x000a, memoryAGet16(0x0ca7 + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=ca7a
        memoryASet16(0x0caa + seg, 0x0001, memoryAGet16(0x0caa + seg, 0x0001) + seg); // 0d8f -> 0f7c; lin=caa1
        memoryASet16(0x0cab + seg, 0x000d, memoryAGet16(0x0cab + seg, 0x000d) + seg); // 0d8f -> 0f7c; lin=cabd
        memoryASet16(0x0cae + seg, 0x0003, memoryAGet16(0x0cae + seg, 0x0003) + seg); // 0d8f -> 0f7c; lin=cae3
        memoryASet16(0x0caf + seg, 0x000e, memoryAGet16(0x0caf + seg, 0x000e) + seg); // 0d8f -> 0f7c; lin=cafe
        memoryASet16(0x0cb2 + seg, 0x0005, memoryAGet16(0x0cb2 + seg, 0x0005) + seg); // 0d8f -> 0f7c; lin=cb25
        memoryASet16(0x0cb4 + seg, 0x0002, memoryAGet16(0x0cb4 + seg, 0x0002) + seg); // 0d8f -> 0f7c; lin=cb42
        memoryASet16(0x0cbc + seg, 0x0004, memoryAGet16(0x0cbc + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=cbc4
        memoryASet16(0x0cbd + seg, 0x0007, memoryAGet16(0x0cbd + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=cbd7
        memoryASet16(0x0cc3 + seg, 0x0004, memoryAGet16(0x0cc3 + seg, 0x0004) + seg); // 1d02 -> 1eef; lin=cc34
        memoryASet16(0x0cc4 + seg, 0x0006, memoryAGet16(0x0cc4 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=cc46
        memoryASet16(0x0cc5 + seg, 0x0008, memoryAGet16(0x0cc5 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=cc58
        memoryASet16(0x0cc6 + seg, 0x0004, memoryAGet16(0x0cc6 + seg, 0x0004) + seg); // 1d02 -> 1eef; lin=cc64
        memoryASet16(0x0cc7 + seg, 0x0006, memoryAGet16(0x0cc7 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=cc76
        memoryASet16(0x0cc8 + seg, 0x0008, memoryAGet16(0x0cc8 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=cc88
        memoryASet16(0x0cc9 + seg, 0x0004, memoryAGet16(0x0cc9 + seg, 0x0004) + seg); // 1874 -> 1a61; lin=cc94
        memoryASet16(0x0cd1 + seg, 0x0003, memoryAGet16(0x0cd1 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=cd13
        memoryASet16(0x0cd3 + seg, 0x0009, memoryAGet16(0x0cd3 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=cd39
        memoryASet16(0x0cd7 + seg, 0x0007, memoryAGet16(0x0cd7 + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=cd77
        memoryASet16(0x0cd9 + seg, 0x0007, memoryAGet16(0x0cd9 + seg, 0x0007) + seg); // 0e8f -> 107c; lin=cd97
        memoryASet16(0x0cd9 + seg, 0x000c, memoryAGet16(0x0cd9 + seg, 0x000c) + seg); // 1654 -> 1841; lin=cd9c
        memoryASet16(0x0cda + seg, 0x0002, memoryAGet16(0x0cda + seg, 0x0002) + seg); // 06bd -> 08aa; lin=cda2
        memoryASet16(0x0cdb + seg, 0x0002, memoryAGet16(0x0cdb + seg, 0x0002) + seg); // 1874 -> 1a61; lin=cdb2
        memoryASet16(0x0cdd + seg, 0x0007, memoryAGet16(0x0cdd + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=cdd7
        memoryASet16(0x0cdf + seg, 0x0000, memoryAGet16(0x0cdf + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=cdf0
        memoryASet16(0x0cdf + seg, 0x000c, memoryAGet16(0x0cdf + seg, 0x000c) + seg); // 0e8f -> 107c; lin=cdfc
        memoryASet16(0x0ce0 + seg, 0x0002, memoryAGet16(0x0ce0 + seg, 0x0002) + seg); // 06bd -> 08aa; lin=ce02
        memoryASet16(0x0ce0 + seg, 0x000a, memoryAGet16(0x0ce0 + seg, 0x000a) + seg); // 1654 -> 1841; lin=ce0a
        memoryASet16(0x0ce5 + seg, 0x000b, memoryAGet16(0x0ce5 + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=ce5b
        memoryASet16(0x0ce7 + seg, 0x0000, memoryAGet16(0x0ce7 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=ce70
        memoryASet16(0x0ce9 + seg, 0x0003, memoryAGet16(0x0ce9 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=ce93
        memoryASet16(0x0cea + seg, 0x000b, memoryAGet16(0x0cea + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=ceab
        memoryASet16(0x0cf1 + seg, 0x0005, memoryAGet16(0x0cf1 + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=cf15
        memoryASet16(0x0cf3 + seg, 0x0008, memoryAGet16(0x0cf3 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=cf38
        memoryASet16(0x0cf9 + seg, 0x0002, memoryAGet16(0x0cf9 + seg, 0x0002) + seg); // 1654 -> 1841; lin=cf92
        memoryASet16(0x0cfa + seg, 0x0002, memoryAGet16(0x0cfa + seg, 0x0002) + seg); // 1874 -> 1a61; lin=cfa2
        memoryASet16(0x0cfb + seg, 0x0002, memoryAGet16(0x0cfb + seg, 0x0002) + seg); // 06bd -> 08aa; lin=cfb2
        memoryASet16(0x0cfe + seg, 0x000b, memoryAGet16(0x0cfe + seg, 0x000b) + seg); // 06bd -> 08aa; lin=cfeb
        memoryASet16(0x0d02 + seg, 0x000d, memoryAGet16(0x0d02 + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=d02d
        memoryASet16(0x0d05 + seg, 0x000a, memoryAGet16(0x0d05 + seg, 0x000a) + seg); // 1654 -> 1841; lin=d05a
        memoryASet16(0x0d06 + seg, 0x0006, memoryAGet16(0x0d06 + seg, 0x0006) + seg); // 1874 -> 1a61; lin=d066
        memoryASet16(0x0d07 + seg, 0x0000, memoryAGet16(0x0d07 + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=d070
        memoryASet16(0x0d08 + seg, 0x000e, memoryAGet16(0x0d08 + seg, 0x000e) + seg); // 1874 -> 1a61; lin=d08e
        memoryASet16(0x0d09 + seg, 0x000e, memoryAGet16(0x0d09 + seg, 0x000e) + seg); // 06bd -> 08aa; lin=d09e
        memoryASet16(0x0d0d + seg, 0x0007, memoryAGet16(0x0d0d + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=d0d7
        memoryASet16(0x0d1e + seg, 0x000f, memoryAGet16(0x0d1e + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=d1ef
        memoryASet16(0x0d29 + seg, 0x000a, memoryAGet16(0x0d29 + seg, 0x000a) + seg); // 1654 -> 1841; lin=d29a
        memoryASet16(0x0d2b + seg, 0x0006, memoryAGet16(0x0d2b + seg, 0x0006) + seg); // 1874 -> 1a61; lin=d2b6
        memoryASet16(0x0d2d + seg, 0x0004, memoryAGet16(0x0d2d + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=d2d4
        memoryASet16(0x0d31 + seg, 0x0003, memoryAGet16(0x0d31 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=d313
        memoryASet16(0x0d33 + seg, 0x000a, memoryAGet16(0x0d33 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=d33a
        memoryASet16(0x0d35 + seg, 0x0007, memoryAGet16(0x0d35 + seg, 0x0007) + seg); // 1654 -> 1841; lin=d357
        memoryASet16(0x0d37 + seg, 0x0003, memoryAGet16(0x0d37 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=d373
        memoryASet16(0x0d39 + seg, 0x0001, memoryAGet16(0x0d39 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=d391
        memoryASet16(0x0d3c + seg, 0x000c, memoryAGet16(0x0d3c + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=d3cc
        memoryASet16(0x0d3e + seg, 0x000e, memoryAGet16(0x0d3e + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=d3ee
        memoryASet16(0x0d44 + seg, 0x0000, memoryAGet16(0x0d44 + seg, 0x0000) + seg); // 1654 -> 1841; lin=d440
        memoryASet16(0x0d4a + seg, 0x0006, memoryAGet16(0x0d4a + seg, 0x0006) + seg); // 1874 -> 1a61; lin=d4a6
        memoryASet16(0x0d51 + seg, 0x0006, memoryAGet16(0x0d51 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=d516
        memoryASet16(0x0d52 + seg, 0x000c, memoryAGet16(0x0d52 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=d52c
        memoryASet16(0x0d54 + seg, 0x0002, memoryAGet16(0x0d54 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=d542
        memoryASet16(0x0d55 + seg, 0x0001, memoryAGet16(0x0d55 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=d551
        memoryASet16(0x0d55 + seg, 0x000d, memoryAGet16(0x0d55 + seg, 0x000d) + seg); // 1874 -> 1a61; lin=d55d
        memoryASet16(0x0d68 + seg, 0x0002, memoryAGet16(0x0d68 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=d682
        memoryASet16(0x0d75 + seg, 0x0009, memoryAGet16(0x0d75 + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=d759
        memoryASet16(0x0d77 + seg, 0x0006, memoryAGet16(0x0d77 + seg, 0x0006) + seg); // 1654 -> 1841; lin=d776
        memoryASet16(0x0d7d + seg, 0x000b, memoryAGet16(0x0d7d + seg, 0x000b) + seg); // 1874 -> 1a61; lin=d7db
        memoryASet16(0x0d83 + seg, 0x000f, memoryAGet16(0x0d83 + seg, 0x000f) + seg); // 1874 -> 1a61; lin=d83f
        memoryASet16(0x0d84 + seg, 0x000c, memoryAGet16(0x0d84 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=d84c
        memoryASet16(0x0d86 + seg, 0x0009, memoryAGet16(0x0d86 + seg, 0x0009) + seg); // 1654 -> 1841; lin=d869
        memoryASet16(0x0d8c + seg, 0x000b, memoryAGet16(0x0d8c + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=d8cb
        memoryASet16(0x0d8e + seg, 0x0008, memoryAGet16(0x0d8e + seg, 0x0008) + seg); // 1654 -> 1841; lin=d8e8
        memoryASet16(0x0d94 + seg, 0x0001, memoryAGet16(0x0d94 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=d941
        memoryASet16(0x0d95 + seg, 0x0003, memoryAGet16(0x0d95 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=d953
        memoryASet16(0x0d95 + seg, 0x0009, memoryAGet16(0x0d95 + seg, 0x0009) + seg); // 2a3a -> 2c27; lin=d959
        memoryASet16(0x0d9e + seg, 0x000f, memoryAGet16(0x0d9e + seg, 0x000f) + seg); // 12a6 -> 1493; lin=d9ef
        memoryASet16(0x0da1 + seg, 0x0002, memoryAGet16(0x0da1 + seg, 0x0002) + seg); // 12a6 -> 1493; lin=da12
        memoryASet16(0x0da3 + seg, 0x0005, memoryAGet16(0x0da3 + seg, 0x0005) + seg); // 12a6 -> 1493; lin=da35
        memoryASet16(0x0dad + seg, 0x000f, memoryAGet16(0x0dad + seg, 0x000f) + seg); // 0000 -> 01ed; lin=dadf
        memoryASet16(0x0dae + seg, 0x000b, memoryAGet16(0x0dae + seg, 0x000b) + seg); // 0000 -> 01ed; lin=daeb
        memoryASet16(0x0dbc + seg, 0x0005, memoryAGet16(0x0dbc + seg, 0x0005) + seg); // 0000 -> 01ed; lin=dbc5
        memoryASet16(0x0dbd + seg, 0x000d, memoryAGet16(0x0dbd + seg, 0x000d) + seg); // 0000 -> 01ed; lin=dbdd
        memoryASet16(0x0dbe + seg, 0x0009, memoryAGet16(0x0dbe + seg, 0x0009) + seg); // 0000 -> 01ed; lin=dbe9
        memoryASet16(0x0dcb + seg, 0x0008, memoryAGet16(0x0dcb + seg, 0x0008) + seg); // 0000 -> 01ed; lin=dcb8
        memoryASet16(0x0dcd + seg, 0x0000, memoryAGet16(0x0dcd + seg, 0x0000) + seg); // 0000 -> 01ed; lin=dcd0
        memoryASet16(0x0dcd + seg, 0x000c, memoryAGet16(0x0dcd + seg, 0x000c) + seg); // 0000 -> 01ed; lin=dcdc
        memoryASet16(0x0dd9 + seg, 0x000d, memoryAGet16(0x0dd9 + seg, 0x000d) + seg); // 1654 -> 1841; lin=dd9d
        memoryASet16(0x0ddf + seg, 0x0002, memoryAGet16(0x0ddf + seg, 0x0002) + seg); // 1654 -> 1841; lin=ddf2
        memoryASet16(0x0dea + seg, 0x0009, memoryAGet16(0x0dea + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=dea9
        memoryASet16(0x0df1 + seg, 0x0007, memoryAGet16(0x0df1 + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=df17
        memoryASet16(0x0df8 + seg, 0x0003, memoryAGet16(0x0df8 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=df83
        memoryASet16(0x0e07 + seg, 0x000e, memoryAGet16(0x0e07 + seg, 0x000e) + seg); // 1874 -> 1a61; lin=e07e
        memoryASet16(0x0e09 + seg, 0x0003, memoryAGet16(0x0e09 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=e093
        memoryASet16(0x0e18 + seg, 0x0002, memoryAGet16(0x0e18 + seg, 0x0002) + seg); // 1874 -> 1a61; lin=e182
        memoryASet16(0x0e19 + seg, 0x0001, memoryAGet16(0x0e19 + seg, 0x0001) + seg); // 1874 -> 1a61; lin=e191
        memoryASet16(0x0e21 + seg, 0x0004, memoryAGet16(0x0e21 + seg, 0x0004) + seg); // 1874 -> 1a61; lin=e214
        memoryASet16(0x0e21 + seg, 0x000c, memoryAGet16(0x0e21 + seg, 0x000c) + seg); // 0e8f -> 107c; lin=e21c
        memoryASet16(0x0e22 + seg, 0x0001, memoryAGet16(0x0e22 + seg, 0x0001) + seg); // 1654 -> 1841; lin=e221
        memoryASet16(0x0e23 + seg, 0x000f, memoryAGet16(0x0e23 + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=e23f
        memoryASet16(0x0e2c + seg, 0x0001, memoryAGet16(0x0e2c + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=e2c1
        memoryASet16(0x0e2d + seg, 0x0004, memoryAGet16(0x0e2d + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=e2d4
        memoryASet16(0x0e2f + seg, 0x0006, memoryAGet16(0x0e2f + seg, 0x0006) + seg); // 06bd -> 08aa; lin=e2f6
        memoryASet16(0x0e32 + seg, 0x000d, memoryAGet16(0x0e32 + seg, 0x000d) + seg); // 1d02 -> 1eef; lin=e32d
        memoryASet16(0x0e34 + seg, 0x0004, memoryAGet16(0x0e34 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=e344
        memoryASet16(0x0e35 + seg, 0x0008, memoryAGet16(0x0e35 + seg, 0x0008) + seg); // 06bd -> 08aa; lin=e358
        memoryASet16(0x0e3e + seg, 0x0004, memoryAGet16(0x0e3e + seg, 0x0004) + seg); // 0000 -> 01ed; lin=e3e4
        memoryASet16(0x0e3e + seg, 0x000b, memoryAGet16(0x0e3e + seg, 0x000b) + seg); // 0000 -> 01ed; lin=e3eb
        memoryASet16(0x0e41 + seg, 0x0007, memoryAGet16(0x0e41 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=e417
        memoryASet16(0x0e41 + seg, 0x000e, memoryAGet16(0x0e41 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=e41e
        memoryASet16(0x0e4a + seg, 0x000a, memoryAGet16(0x0e4a + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=e4aa
        memoryASet16(0x0e4c + seg, 0x0005, memoryAGet16(0x0e4c + seg, 0x0005) + seg); // 1874 -> 1a61; lin=e4c5
        memoryASet16(0x0e4c + seg, 0x000e, memoryAGet16(0x0e4c + seg, 0x000e) + seg); // 1874 -> 1a61; lin=e4ce
        memoryASet16(0x0e53 + seg, 0x0009, memoryAGet16(0x0e53 + seg, 0x0009) + seg); // 1874 -> 1a61; lin=e539
        memoryASet16(0x0e55 + seg, 0x000e, memoryAGet16(0x0e55 + seg, 0x000e) + seg); // 1874 -> 1a61; lin=e55e
        memoryASet16(0x0e57 + seg, 0x0007, memoryAGet16(0x0e57 + seg, 0x0007) + seg); // 1874 -> 1a61; lin=e577
        memoryASet16(0x0e58 + seg, 0x0009, memoryAGet16(0x0e58 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=e589
        memoryASet16(0x0e5b + seg, 0x0003, memoryAGet16(0x0e5b + seg, 0x0003) + seg); // 1874 -> 1a61; lin=e5b3
        memoryASet16(0x0e60 + seg, 0x000e, memoryAGet16(0x0e60 + seg, 0x000e) + seg); // 037d -> 056a; lin=e60e
        memoryASet16(0x0e61 + seg, 0x000e, memoryAGet16(0x0e61 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=e61e
        memoryASet16(0x0e64 + seg, 0x0006, memoryAGet16(0x0e64 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=e646
        memoryASet16(0x0e65 + seg, 0x0002, memoryAGet16(0x0e65 + seg, 0x0002) + seg); // 1874 -> 1a61; lin=e652
        memoryASet16(0x0e6b + seg, 0x000d, memoryAGet16(0x0e6b + seg, 0x000d) + seg); // 06bd -> 08aa; lin=e6bd
        memoryASet16(0x0e86 + seg, 0x000a, memoryAGet16(0x0e86 + seg, 0x000a) + seg); // 1654 -> 1841; lin=e86a
        memoryASet16(0x0e8e + seg, 0x0008, memoryAGet16(0x0e8e + seg, 0x0008) + seg); // 1654 -> 1841; lin=e8e8
        memoryASet16(0x0e8f + seg, 0x000e, memoryAGet16(0x0e8f + seg, 0x000e) + seg); // 06bd -> 08aa; lin=e8fe
        memoryASet16(0x0e90 + seg, 0x000e, memoryAGet16(0x0e90 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=e90e
        memoryASet16(0x0e95 + seg, 0x000f, memoryAGet16(0x0e95 + seg, 0x000f) + seg); // 0b80 -> 0d6d; lin=e95f
        memoryASet16(0x0e96 + seg, 0x0007, memoryAGet16(0x0e96 + seg, 0x0007) + seg); // 0d8f -> 0f7c; lin=e967
        memoryASet16(0x0e97 + seg, 0x0000, memoryAGet16(0x0e97 + seg, 0x0000) + seg); // 2a3a -> 2c27; lin=e970
        memoryASet16(0x0e98 + seg, 0x000b, memoryAGet16(0x0e98 + seg, 0x000b) + seg); // 0b80 -> 0d6d; lin=e98b
        memoryASet16(0x0e99 + seg, 0x0003, memoryAGet16(0x0e99 + seg, 0x0003) + seg); // 0d8f -> 0f7c; lin=e993
        memoryASet16(0x0e99 + seg, 0x000c, memoryAGet16(0x0e99 + seg, 0x000c) + seg); // 2a3a -> 2c27; lin=e99c
        memoryASet16(0x0e9b + seg, 0x0003, memoryAGet16(0x0e9b + seg, 0x0003) + seg); // 0d8f -> 0f7c; lin=e9b3
        memoryASet16(0x0e9b + seg, 0x000b, memoryAGet16(0x0e9b + seg, 0x000b) + seg); // 0d8f -> 0f7c; lin=e9bb
        memoryASet16(0x0e9c + seg, 0x0004, memoryAGet16(0x0e9c + seg, 0x0004) + seg); // 2a3a -> 2c27; lin=e9c4
        memoryASet16(0x0e9d + seg, 0x000b, memoryAGet16(0x0e9d + seg, 0x000b) + seg); // 0fa8 -> 1195; lin=e9db
        memoryASet16(0x0ea0 + seg, 0x0004, memoryAGet16(0x0ea0 + seg, 0x0004) + seg); // 1080 -> 126d; lin=ea04
        memoryASet16(0x0ea1 + seg, 0x0009, memoryAGet16(0x0ea1 + seg, 0x0009) + seg); // 11a2 -> 138f; lin=ea19
        memoryASet16(0x0ea4 + seg, 0x0002, memoryAGet16(0x0ea4 + seg, 0x0002) + seg); // 1080 -> 126d; lin=ea42
        memoryASet16(0x0ea6 + seg, 0x000b, memoryAGet16(0x0ea6 + seg, 0x000b) + seg); // 0fa8 -> 1195; lin=ea6b
        memoryASet16(0x0ea8 + seg, 0x0000, memoryAGet16(0x0ea8 + seg, 0x0000) + seg); // 1080 -> 126d; lin=ea80
        memoryASet16(0x0ea9 + seg, 0x0005, memoryAGet16(0x0ea9 + seg, 0x0005) + seg); // 1080 -> 126d; lin=ea95
        memoryASet16(0x0eaa + seg, 0x0006, memoryAGet16(0x0eaa + seg, 0x0006) + seg); // 2a3a -> 2c27; lin=eaa6
        memoryASet16(0x0eac + seg, 0x0004, memoryAGet16(0x0eac + seg, 0x0004) + seg); // 1080 -> 126d; lin=eac4
        memoryASet16(0x0ead + seg, 0x0005, memoryAGet16(0x0ead + seg, 0x0005) + seg); // 2a3a -> 2c27; lin=ead5
        memoryASet16(0x0eaf + seg, 0x0003, memoryAGet16(0x0eaf + seg, 0x0003) + seg); // 1080 -> 126d; lin=eaf3
        memoryASet16(0x0eb0 + seg, 0x0008, memoryAGet16(0x0eb0 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=eb08
        memoryASet16(0x0eb3 + seg, 0x0007, memoryAGet16(0x0eb3 + seg, 0x0007) + seg); // 1080 -> 126d; lin=eb37
        memoryASet16(0x0eb6 + seg, 0x0000, memoryAGet16(0x0eb6 + seg, 0x0000) + seg); // 11a2 -> 138f; lin=eb60
        memoryASet16(0x0eb7 + seg, 0x0005, memoryAGet16(0x0eb7 + seg, 0x0005) + seg); // 11a2 -> 138f; lin=eb75
        memoryASet16(0x0eb9 + seg, 0x000e, memoryAGet16(0x0eb9 + seg, 0x000e) + seg); // 11a2 -> 138f; lin=eb9e
        memoryASet16(0x0ebb + seg, 0x0003, memoryAGet16(0x0ebb + seg, 0x0003) + seg); // 11a2 -> 138f; lin=ebb3
        memoryASet16(0x0ebc + seg, 0x0008, memoryAGet16(0x0ebc + seg, 0x0008) + seg); // 11a2 -> 138f; lin=ebc8
        memoryASet16(0x0ebf + seg, 0x0001, memoryAGet16(0x0ebf + seg, 0x0001) + seg); // 0fa8 -> 1195; lin=ebf1
        memoryASet16(0x0ec0 + seg, 0x0006, memoryAGet16(0x0ec0 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=ec06
        memoryASet16(0x0ec2 + seg, 0x000f, memoryAGet16(0x0ec2 + seg, 0x000f) + seg); // 0fa8 -> 1195; lin=ec2f
        memoryASet16(0x0ec4 + seg, 0x0008, memoryAGet16(0x0ec4 + seg, 0x0008) + seg); // 1654 -> 1841; lin=ec48
        memoryASet16(0x0ec5 + seg, 0x000a, memoryAGet16(0x0ec5 + seg, 0x000a) + seg); // 1654 -> 1841; lin=ec5a
        memoryASet16(0x0ec7 + seg, 0x0000, memoryAGet16(0x0ec7 + seg, 0x0000) + seg); // 1080 -> 126d; lin=ec70
        memoryASet16(0x0ec8 + seg, 0x0005, memoryAGet16(0x0ec8 + seg, 0x0005) + seg); // 1080 -> 126d; lin=ec85
        memoryASet16(0x0ec9 + seg, 0x000a, memoryAGet16(0x0ec9 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=ec9a
        memoryASet16(0x0ecb + seg, 0x0007, memoryAGet16(0x0ecb + seg, 0x0007) + seg); // 0fa8 -> 1195; lin=ecb7
        memoryASet16(0x0ecd + seg, 0x0005, memoryAGet16(0x0ecd + seg, 0x0005) + seg); // 11a2 -> 138f; lin=ecd5
        memoryASet16(0x0ecd + seg, 0x000b, memoryAGet16(0x0ecd + seg, 0x000b) + seg); // 2a3a -> 2c27; lin=ecdb
        memoryASet16(0x0ecf + seg, 0x000a, memoryAGet16(0x0ecf + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=ecfa
        memoryASet16(0x0ed0 + seg, 0x0008, memoryAGet16(0x0ed0 + seg, 0x0008) + seg); // 2a3a -> 2c27; lin=ed08
        memoryASet16(0x0ed1 + seg, 0x000d, memoryAGet16(0x0ed1 + seg, 0x000d) + seg); // 2a3a -> 2c27; lin=ed1d
        memoryASet16(0x0ed4 + seg, 0x0005, memoryAGet16(0x0ed4 + seg, 0x0005) + seg); // 11a2 -> 138f; lin=ed45
        memoryASet16(0x0ed6 + seg, 0x000b, memoryAGet16(0x0ed6 + seg, 0x000b) + seg); // 11a2 -> 138f; lin=ed6b
        memoryASet16(0x0ed8 + seg, 0x0007, memoryAGet16(0x0ed8 + seg, 0x0007) + seg); // 11a2 -> 138f; lin=ed87
        memoryASet16(0x0eda + seg, 0x0002, memoryAGet16(0x0eda + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=eda2
        memoryASet16(0x0edc + seg, 0x0008, memoryAGet16(0x0edc + seg, 0x0008) + seg); // 11a2 -> 138f; lin=edc8
        memoryASet16(0x0edf + seg, 0x0002, memoryAGet16(0x0edf + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=edf2
        memoryASet16(0x0ee5 + seg, 0x0008, memoryAGet16(0x0ee5 + seg, 0x0008) + seg); // 2a3a -> 2c27; lin=ee58
        memoryASet16(0x0ef3 + seg, 0x000b, memoryAGet16(0x0ef3 + seg, 0x000b) + seg); // 1874 -> 1a61; lin=ef3b
        memoryASet16(0x0ef4 + seg, 0x0000, memoryAGet16(0x0ef4 + seg, 0x0000) + seg); // 06bd -> 08aa; lin=ef40
        memoryASet16(0x0ef4 + seg, 0x0005, memoryAGet16(0x0ef4 + seg, 0x0005) + seg); // 12a6 -> 1493; lin=ef45
        memoryASet16(0x0ef4 + seg, 0x0008, memoryAGet16(0x0ef4 + seg, 0x0008) + seg); // 2a3a -> 2c27; lin=ef48
        memoryASet16(0x0ef6 + seg, 0x0009, memoryAGet16(0x0ef6 + seg, 0x0009) + seg); // 12a6 -> 1493; lin=ef69
        memoryASet16(0x0ef7 + seg, 0x0001, memoryAGet16(0x0ef7 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=ef71
        memoryASet16(0x0ef7 + seg, 0x000e, memoryAGet16(0x0ef7 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=ef7e
        memoryASet16(0x0ef9 + seg, 0x0002, memoryAGet16(0x0ef9 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=ef92
        memoryASet16(0x0efa + seg, 0x000d, memoryAGet16(0x0efa + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=efad
        memoryASet16(0x0efc + seg, 0x0000, memoryAGet16(0x0efc + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=efc0
        memoryASet16(0x0efc + seg, 0x000e, memoryAGet16(0x0efc + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=efce
        memoryASet16(0x0efd + seg, 0x0006, memoryAGet16(0x0efd + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=efd6
        memoryASet16(0x0efd + seg, 0x000f, memoryAGet16(0x0efd + seg, 0x000f) + seg); // 1874 -> 1a61; lin=efdf
        memoryASet16(0x0efe + seg, 0x000b, memoryAGet16(0x0efe + seg, 0x000b) + seg); // 1e0a -> 1ff7; lin=efeb
        memoryASet16(0x0eff + seg, 0x0003, memoryAGet16(0x0eff + seg, 0x0003) + seg); // 1460 -> 164d; lin=eff3
        memoryASet16(0x0eff + seg, 0x0008, memoryAGet16(0x0eff + seg, 0x0008) + seg); // 1460 -> 164d; lin=eff8
        memoryASet16(0x0f00 + seg, 0x0005, memoryAGet16(0x0f00 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=f005
        memoryASet16(0x0f02 + seg, 0x0000, memoryAGet16(0x0f02 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=f020
        memoryASet16(0x0f03 + seg, 0x000d, memoryAGet16(0x0f03 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=f03d
        memoryASet16(0x0f04 + seg, 0x000b, memoryAGet16(0x0f04 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=f04b
        memoryASet16(0x0f05 + seg, 0x0003, memoryAGet16(0x0f05 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=f053
        memoryASet16(0x0f05 + seg, 0x000c, memoryAGet16(0x0f05 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=f05c
        memoryASet16(0x0f06 + seg, 0x0004, memoryAGet16(0x0f06 + seg, 0x0004) + seg); // 1460 -> 164d; lin=f064
        memoryASet16(0x0f06 + seg, 0x0009, memoryAGet16(0x0f06 + seg, 0x0009) + seg); // 1460 -> 164d; lin=f069
        memoryASet16(0x0f07 + seg, 0x000e, memoryAGet16(0x0f07 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=f07e
        memoryASet16(0x0f08 + seg, 0x0006, memoryAGet16(0x0f08 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=f086
        memoryASet16(0x0f08 + seg, 0x000f, memoryAGet16(0x0f08 + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=f08f
        memoryASet16(0x0f09 + seg, 0x0007, memoryAGet16(0x0f09 + seg, 0x0007) + seg); // 1460 -> 164d; lin=f097
        memoryASet16(0x0f09 + seg, 0x000c, memoryAGet16(0x0f09 + seg, 0x000c) + seg); // 1460 -> 164d; lin=f09c
        memoryASet16(0x0f0a + seg, 0x0001, memoryAGet16(0x0f0a + seg, 0x0001) + seg); // 12a6 -> 1493; lin=f0a1
        memoryASet16(0x0f0a + seg, 0x000a, memoryAGet16(0x0f0a + seg, 0x000a) + seg); // 06bd -> 08aa; lin=f0aa
        memoryASet16(0x0f0d + seg, 0x0003, memoryAGet16(0x0f0d + seg, 0x0003) + seg); // 1874 -> 1a61; lin=f0d3
        memoryASet16(0x0f0d + seg, 0x0008, memoryAGet16(0x0f0d + seg, 0x0008) + seg); // 12a6 -> 1493; lin=f0d8
        memoryASet16(0x0f0d + seg, 0x000b, memoryAGet16(0x0f0d + seg, 0x000b) + seg); // 2a3a -> 2c27; lin=f0db
        memoryASet16(0x0f0f + seg, 0x000c, memoryAGet16(0x0f0f + seg, 0x000c) + seg); // 12a6 -> 1493; lin=f0fc
        memoryASet16(0x0f10 + seg, 0x0004, memoryAGet16(0x0f10 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=f104
        memoryASet16(0x0f10 + seg, 0x000d, memoryAGet16(0x0f10 + seg, 0x000d) + seg); // 06bd -> 08aa; lin=f10d
        memoryASet16(0x0f11 + seg, 0x000d, memoryAGet16(0x0f11 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=f11d
        memoryASet16(0x0f13 + seg, 0x0001, memoryAGet16(0x0f13 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=f131
        memoryASet16(0x0f14 + seg, 0x0006, memoryAGet16(0x0f14 + seg, 0x0006) + seg); // 1f58 -> 2145; lin=f146
        memoryASet16(0x0f15 + seg, 0x0006, memoryAGet16(0x0f15 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=f156
        memoryASet16(0x0f16 + seg, 0x0003, memoryAGet16(0x0f16 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=f163
        memoryASet16(0x0f16 + seg, 0x000b, memoryAGet16(0x0f16 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=f16b
        memoryASet16(0x0f17 + seg, 0x0004, memoryAGet16(0x0f17 + seg, 0x0004) + seg); // 1e0a -> 1ff7; lin=f174
        memoryASet16(0x0f17 + seg, 0x000c, memoryAGet16(0x0f17 + seg, 0x000c) + seg); // 1460 -> 164d; lin=f17c
        memoryASet16(0x0f18 + seg, 0x0001, memoryAGet16(0x0f18 + seg, 0x0001) + seg); // 1460 -> 164d; lin=f181
        memoryASet16(0x0f18 + seg, 0x000e, memoryAGet16(0x0f18 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=f18e
        memoryASet16(0x0f1a + seg, 0x0002, memoryAGet16(0x0f1a + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=f1a2
        memoryASet16(0x0f1b + seg, 0x0007, memoryAGet16(0x0f1b + seg, 0x0007) + seg); // 1f5e -> 214b; lin=f1b7
        memoryASet16(0x0f1c + seg, 0x0007, memoryAGet16(0x0f1c + seg, 0x0007) + seg); // 0000 -> 01ed; lin=f1c7
        memoryASet16(0x0f1d + seg, 0x0004, memoryAGet16(0x0f1d + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=f1d4
        memoryASet16(0x0f1d + seg, 0x000c, memoryAGet16(0x0f1d + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=f1dc
        memoryASet16(0x0f1e + seg, 0x0005, memoryAGet16(0x0f1e + seg, 0x0005) + seg); // 1e0a -> 1ff7; lin=f1e5
        memoryASet16(0x0f1e + seg, 0x000d, memoryAGet16(0x0f1e + seg, 0x000d) + seg); // 1460 -> 164d; lin=f1ed
        memoryASet16(0x0f1f + seg, 0x0002, memoryAGet16(0x0f1f + seg, 0x0002) + seg); // 1460 -> 164d; lin=f1f2
        memoryASet16(0x0f1f + seg, 0x000f, memoryAGet16(0x0f1f + seg, 0x000f) + seg); // 1931 -> 1b1e; lin=f1ff
        memoryASet16(0x0f21 + seg, 0x000a, memoryAGet16(0x0f21 + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=f21a
        memoryASet16(0x0f22 + seg, 0x000a, memoryAGet16(0x0f22 + seg, 0x000a) + seg); // 1f63 -> 2150; lin=f22a
        memoryASet16(0x0f23 + seg, 0x000a, memoryAGet16(0x0f23 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=f23a
        memoryASet16(0x0f24 + seg, 0x0007, memoryAGet16(0x0f24 + seg, 0x0007) + seg); // 1931 -> 1b1e; lin=f247
        memoryASet16(0x0f24 + seg, 0x000f, memoryAGet16(0x0f24 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=f24f
        memoryASet16(0x0f25 + seg, 0x0008, memoryAGet16(0x0f25 + seg, 0x0008) + seg); // 1e0a -> 1ff7; lin=f258
        memoryASet16(0x0f26 + seg, 0x0000, memoryAGet16(0x0f26 + seg, 0x0000) + seg); // 1460 -> 164d; lin=f260
        memoryASet16(0x0f26 + seg, 0x0005, memoryAGet16(0x0f26 + seg, 0x0005) + seg); // 1460 -> 164d; lin=f265
        memoryASet16(0x0f27 + seg, 0x0002, memoryAGet16(0x0f27 + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=f272
        memoryASet16(0x0f28 + seg, 0x0006, memoryAGet16(0x0f28 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=f286
        memoryASet16(0x0f29 + seg, 0x000b, memoryAGet16(0x0f29 + seg, 0x000b) + seg); // 1f65 -> 2152; lin=f29b
        memoryASet16(0x0f2a + seg, 0x000b, memoryAGet16(0x0f2a + seg, 0x000b) + seg); // 0000 -> 01ed; lin=f2ab
        memoryASet16(0x0f2b + seg, 0x0008, memoryAGet16(0x0f2b + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=f2b8
        memoryASet16(0x0f2c + seg, 0x0000, memoryAGet16(0x0f2c + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=f2c0
        memoryASet16(0x0f2c + seg, 0x0009, memoryAGet16(0x0f2c + seg, 0x0009) + seg); // 1e0a -> 1ff7; lin=f2c9
        memoryASet16(0x0f2d + seg, 0x0001, memoryAGet16(0x0f2d + seg, 0x0001) + seg); // 1460 -> 164d; lin=f2d1
        memoryASet16(0x0f2d + seg, 0x0006, memoryAGet16(0x0f2d + seg, 0x0006) + seg); // 1460 -> 164d; lin=f2d6
        memoryASet16(0x0f2e + seg, 0x0003, memoryAGet16(0x0f2e + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=f2e3
        memoryASet16(0x0f2f + seg, 0x000e, memoryAGet16(0x0f2f + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=f2fe
        memoryASet16(0x0f31 + seg, 0x000c, memoryAGet16(0x0f31 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=f31c
        memoryASet16(0x0f32 + seg, 0x0004, memoryAGet16(0x0f32 + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=f324
        memoryASet16(0x0f32 + seg, 0x000d, memoryAGet16(0x0f32 + seg, 0x000d) + seg); // 1e0a -> 1ff7; lin=f32d
        memoryASet16(0x0f33 + seg, 0x0005, memoryAGet16(0x0f33 + seg, 0x0005) + seg); // 1460 -> 164d; lin=f335
        memoryASet16(0x0f33 + seg, 0x000a, memoryAGet16(0x0f33 + seg, 0x000a) + seg); // 1460 -> 164d; lin=f33a
        memoryASet16(0x0f33 + seg, 0x000f, memoryAGet16(0x0f33 + seg, 0x000f) + seg); // 06bd -> 08aa; lin=f33f
        memoryASet16(0x0f34 + seg, 0x0004, memoryAGet16(0x0f34 + seg, 0x0004) + seg); // 12a6 -> 1493; lin=f344
        memoryASet16(0x0f34 + seg, 0x000d, memoryAGet16(0x0f34 + seg, 0x000d) + seg); // 06bd -> 08aa; lin=f34d
        memoryASet16(0x0f35 + seg, 0x000c, memoryAGet16(0x0f35 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=f35c
        memoryASet16(0x0f36 + seg, 0x0001, memoryAGet16(0x0f36 + seg, 0x0001) + seg); // 12a6 -> 1493; lin=f361
        memoryASet16(0x0f36 + seg, 0x000a, memoryAGet16(0x0f36 + seg, 0x000a) + seg); // 12a6 -> 1493; lin=f36a
        memoryASet16(0x0f37 + seg, 0x000a, memoryAGet16(0x0f37 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=f37a
        memoryASet16(0x0f39 + seg, 0x0005, memoryAGet16(0x0f39 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=f395
        memoryASet16(0x0f3a + seg, 0x000b, memoryAGet16(0x0f3a + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=f3ab
        memoryASet16(0x0f3b + seg, 0x0003, memoryAGet16(0x0f3b + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=f3b3
        memoryASet16(0x0f3b + seg, 0x000c, memoryAGet16(0x0f3b + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=f3bc
        memoryASet16(0x0f3c + seg, 0x0004, memoryAGet16(0x0f3c + seg, 0x0004) + seg); // 1460 -> 164d; lin=f3c4
        memoryASet16(0x0f3c + seg, 0x0009, memoryAGet16(0x0f3c + seg, 0x0009) + seg); // 1460 -> 164d; lin=f3c9
        memoryASet16(0x0f3c + seg, 0x000e, memoryAGet16(0x0f3c + seg, 0x000e) + seg); // 12a6 -> 1493; lin=f3ce
        memoryASet16(0x0f3d + seg, 0x0008, memoryAGet16(0x0f3d + seg, 0x0008) + seg); // 1874 -> 1a61; lin=f3d8
        memoryASet16(0x0f3d + seg, 0x000d, memoryAGet16(0x0f3d + seg, 0x000d) + seg); // 12a6 -> 1493; lin=f3dd
        memoryASet16(0x0f3e + seg, 0x0000, memoryAGet16(0x0f3e + seg, 0x0000) + seg); // 2a3a -> 2c27; lin=f3e0
        memoryASet16(0x0f3f + seg, 0x000a, memoryAGet16(0x0f3f + seg, 0x000a) + seg); // 12a6 -> 1493; lin=f3fa
        memoryASet16(0x0f40 + seg, 0x000a, memoryAGet16(0x0f40 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=f40a
        memoryASet16(0x0f42 + seg, 0x0005, memoryAGet16(0x0f42 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=f425
        memoryASet16(0x0f43 + seg, 0x000b, memoryAGet16(0x0f43 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=f43b
        memoryASet16(0x0f44 + seg, 0x0003, memoryAGet16(0x0f44 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=f443
        memoryASet16(0x0f44 + seg, 0x000c, memoryAGet16(0x0f44 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=f44c
        memoryASet16(0x0f45 + seg, 0x0004, memoryAGet16(0x0f45 + seg, 0x0004) + seg); // 1460 -> 164d; lin=f454
        memoryASet16(0x0f45 + seg, 0x0009, memoryAGet16(0x0f45 + seg, 0x0009) + seg); // 1460 -> 164d; lin=f459
        memoryASet16(0x0f46 + seg, 0x000e, memoryAGet16(0x0f46 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=f46e
        memoryASet16(0x0f47 + seg, 0x0006, memoryAGet16(0x0f47 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=f476
        memoryASet16(0x0f47 + seg, 0x000f, memoryAGet16(0x0f47 + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=f47f
        memoryASet16(0x0f48 + seg, 0x0007, memoryAGet16(0x0f48 + seg, 0x0007) + seg); // 1460 -> 164d; lin=f487
        memoryASet16(0x0f48 + seg, 0x000c, memoryAGet16(0x0f48 + seg, 0x000c) + seg); // 1460 -> 164d; lin=f48c
        memoryASet16(0x0f49 + seg, 0x0001, memoryAGet16(0x0f49 + seg, 0x0001) + seg); // 12a6 -> 1493; lin=f491
        memoryASet16(0x0f49 + seg, 0x000b, memoryAGet16(0x0f49 + seg, 0x000b) + seg); // 1874 -> 1a61; lin=f49b
        memoryASet16(0x0f4a + seg, 0x0000, memoryAGet16(0x0f4a + seg, 0x0000) + seg); // 12a6 -> 1493; lin=f4a0
        memoryASet16(0x0f4a + seg, 0x0003, memoryAGet16(0x0f4a + seg, 0x0003) + seg); // 2a3a -> 2c27; lin=f4a3
        memoryASet16(0x0f4c + seg, 0x0004, memoryAGet16(0x0f4c + seg, 0x0004) + seg); // 12a6 -> 1493; lin=f4c4
        memoryASet16(0x0f4d + seg, 0x0000, memoryAGet16(0x0f4d + seg, 0x0000) + seg); // 06bd -> 08aa; lin=f4d0
        memoryASet16(0x0f4d + seg, 0x0008, memoryAGet16(0x0f4d + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=f4d8
        memoryASet16(0x0f4e + seg, 0x0005, memoryAGet16(0x0f4e + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=f4e5
        memoryASet16(0x0f4f + seg, 0x0009, memoryAGet16(0x0f4f + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=f4f9
        memoryASet16(0x0f51 + seg, 0x000b, memoryAGet16(0x0f51 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=f51b
        memoryASet16(0x0f52 + seg, 0x0009, memoryAGet16(0x0f52 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=f529
        memoryASet16(0x0f53 + seg, 0x0001, memoryAGet16(0x0f53 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=f531
        memoryASet16(0x0f53 + seg, 0x000a, memoryAGet16(0x0f53 + seg, 0x000a) + seg); // 1e0a -> 1ff7; lin=f53a
        memoryASet16(0x0f54 + seg, 0x0002, memoryAGet16(0x0f54 + seg, 0x0002) + seg); // 1460 -> 164d; lin=f542
        memoryASet16(0x0f54 + seg, 0x0007, memoryAGet16(0x0f54 + seg, 0x0007) + seg); // 1460 -> 164d; lin=f547
        memoryASet16(0x0f55 + seg, 0x0004, memoryAGet16(0x0f55 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=f554
        memoryASet16(0x0f56 + seg, 0x000f, memoryAGet16(0x0f56 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=f56f
        memoryASet16(0x0f58 + seg, 0x000b, memoryAGet16(0x0f58 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=f58b
        memoryASet16(0x0f59 + seg, 0x0003, memoryAGet16(0x0f59 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=f593
        memoryASet16(0x0f59 + seg, 0x000c, memoryAGet16(0x0f59 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=f59c
        memoryASet16(0x0f5a + seg, 0x0004, memoryAGet16(0x0f5a + seg, 0x0004) + seg); // 1460 -> 164d; lin=f5a4
        memoryASet16(0x0f5a + seg, 0x0009, memoryAGet16(0x0f5a + seg, 0x0009) + seg); // 1460 -> 164d; lin=f5a9
        memoryASet16(0x0f5b + seg, 0x000e, memoryAGet16(0x0f5b + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=f5be
        memoryASet16(0x0f5c + seg, 0x0006, memoryAGet16(0x0f5c + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=f5c6
        memoryASet16(0x0f5c + seg, 0x000f, memoryAGet16(0x0f5c + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=f5cf
        memoryASet16(0x0f5d + seg, 0x0007, memoryAGet16(0x0f5d + seg, 0x0007) + seg); // 1460 -> 164d; lin=f5d7
        memoryASet16(0x0f5d + seg, 0x000c, memoryAGet16(0x0f5d + seg, 0x000c) + seg); // 1460 -> 164d; lin=f5dc
        memoryASet16(0x0f5e + seg, 0x0005, memoryAGet16(0x0f5e + seg, 0x0005) + seg); // 12a6 -> 1493; lin=f5e5
        memoryASet16(0x0f5e + seg, 0x000a, memoryAGet16(0x0f5e + seg, 0x000a) + seg); // 06bd -> 08aa; lin=f5ea
        memoryASet16(0x0f62 + seg, 0x000c, memoryAGet16(0x0f62 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=f62c
        memoryASet16(0x0f64 + seg, 0x0006, memoryAGet16(0x0f64 + seg, 0x0006) + seg); // 06bd -> 08aa; lin=f646
        memoryASet16(0x0f69 + seg, 0x0004, memoryAGet16(0x0f69 + seg, 0x0004) + seg); // 1d02 -> 1eef; lin=f694
        memoryASet16(0x0f6b + seg, 0x0005, memoryAGet16(0x0f6b + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=f6b5
        memoryASet16(0x0f6c + seg, 0x0007, memoryAGet16(0x0f6c + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=f6c7
        memoryASet16(0x0f6d + seg, 0x0009, memoryAGet16(0x0f6d + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=f6d9
        memoryASet16(0x0f6e + seg, 0x000b, memoryAGet16(0x0f6e + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=f6eb
        memoryASet16(0x0f6f + seg, 0x0007, memoryAGet16(0x0f6f + seg, 0x0007) + seg); // 1874 -> 1a61; lin=f6f7
        memoryASet16(0x0f98 + seg, 0x000c, memoryAGet16(0x0f98 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=f98c
        memoryASet16(0x0f9b + seg, 0x0002, memoryAGet16(0x0f9b + seg, 0x0002) + seg); // 06bd -> 08aa; lin=f9b2
        memoryASet16(0x0f9f + seg, 0x0000, memoryAGet16(0x0f9f + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=f9f0
        memoryASet16(0x0fa7 + seg, 0x0008, memoryAGet16(0x0fa7 + seg, 0x0008) + seg); // 1654 -> 1841; lin=fa78
        memoryASet16(0x0fa8 + seg, 0x0009, memoryAGet16(0x0fa8 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=fa89
        memoryASet16(0x0fb0 + seg, 0x0002, memoryAGet16(0x0fb0 + seg, 0x0002) + seg); // 1654 -> 1841; lin=fb02
        memoryASet16(0x0fb2 + seg, 0x000b, memoryAGet16(0x0fb2 + seg, 0x000b) + seg); // 1654 -> 1841; lin=fb2b
        memoryASet16(0x0fb5 + seg, 0x0003, memoryAGet16(0x0fb5 + seg, 0x0003) + seg); // 1654 -> 1841; lin=fb53
        memoryASet16(0x0fb7 + seg, 0x000b, memoryAGet16(0x0fb7 + seg, 0x000b) + seg); // 1654 -> 1841; lin=fb7b
        memoryASet16(0x0fba + seg, 0x0003, memoryAGet16(0x0fba + seg, 0x0003) + seg); // 1654 -> 1841; lin=fba3
        memoryASet16(0x0fbc + seg, 0x000b, memoryAGet16(0x0fbc + seg, 0x000b) + seg); // 1654 -> 1841; lin=fbcb
        memoryASet16(0x0fbf + seg, 0x0003, memoryAGet16(0x0fbf + seg, 0x0003) + seg); // 1654 -> 1841; lin=fbf3
        memoryASet16(0x0fc1 + seg, 0x000b, memoryAGet16(0x0fc1 + seg, 0x000b) + seg); // 1654 -> 1841; lin=fc1b
        memoryASet16(0x0fc3 + seg, 0x0000, memoryAGet16(0x0fc3 + seg, 0x0000) + seg); // 06bd -> 08aa; lin=fc30
        memoryASet16(0x0fc8 + seg, 0x0004, memoryAGet16(0x0fc8 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=fc84
        memoryASet16(0x0fc9 + seg, 0x0006, memoryAGet16(0x0fc9 + seg, 0x0006) + seg); // 06bd -> 08aa; lin=fc96
        memoryASet16(0x0fcc + seg, 0x0007, memoryAGet16(0x0fcc + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=fcc7
        memoryASet16(0x0fcf + seg, 0x0002, memoryAGet16(0x0fcf + seg, 0x0002) + seg); // 06bd -> 08aa; lin=fcf2
        memoryASet16(0x0fd2 + seg, 0x0001, memoryAGet16(0x0fd2 + seg, 0x0001) + seg); // 1d02 -> 1eef; lin=fd21
        memoryASet16(0x0fd4 + seg, 0x000d, memoryAGet16(0x0fd4 + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=fd4d
        memoryASet16(0x0fd6 + seg, 0x0001, memoryAGet16(0x0fd6 + seg, 0x0001) + seg); // 1d02 -> 1eef; lin=fd61
        memoryASet16(0x0fd8 + seg, 0x0007, memoryAGet16(0x0fd8 + seg, 0x0007) + seg); // 06bd -> 08aa; lin=fd87
        memoryASet16(0x0fdb + seg, 0x0006, memoryAGet16(0x0fdb + seg, 0x0006) + seg); // 1d02 -> 1eef; lin=fdb6
        memoryASet16(0x0fde + seg, 0x0002, memoryAGet16(0x0fde + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=fde2
        memoryASet16(0x0fdf + seg, 0x0003, memoryAGet16(0x0fdf + seg, 0x0003) + seg); // 1d02 -> 1eef; lin=fdf3
        memoryASet16(0x0fe1 + seg, 0x000e, memoryAGet16(0x0fe1 + seg, 0x000e) + seg); // 1874 -> 1a61; lin=fe1e
        memoryASet16(0x0fe3 + seg, 0x0004, memoryAGet16(0x0fe3 + seg, 0x0004) + seg); // 06bd -> 08aa; lin=fe34
        memoryASet16(0x0fe6 + seg, 0x0002, memoryAGet16(0x0fe6 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=fe62
        memoryASet16(0x0fe7 + seg, 0x000d, memoryAGet16(0x0fe7 + seg, 0x000d) + seg); // 0b80 -> 0d6d; lin=fe7d
        memoryASet16(0x0fe8 + seg, 0x000b, memoryAGet16(0x0fe8 + seg, 0x000b) + seg); // 1d02 -> 1eef; lin=fe8b
        memoryASet16(0x0fe9 + seg, 0x000b, memoryAGet16(0x0fe9 + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=fe9b
        memoryASet16(0x0fea + seg, 0x000b, memoryAGet16(0x0fea + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=feab
        memoryASet16(0x0fec + seg, 0x000e, memoryAGet16(0x0fec + seg, 0x000e) + seg); // 06bd -> 08aa; lin=fece
        memoryASet16(0x0ff0 + seg, 0x000c, memoryAGet16(0x0ff0 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=ff0c
        memoryASet16(0x0ff3 + seg, 0x0006, memoryAGet16(0x0ff3 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=ff36
        memoryASet16(0x0ff5 + seg, 0x0005, memoryAGet16(0x0ff5 + seg, 0x0005) + seg); // 0d8f -> 0f7c; lin=ff55
        memoryASet16(0x0ff6 + seg, 0x0006, memoryAGet16(0x0ff6 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=ff66
        memoryASet16(0x0ffa + seg, 0x0005, memoryAGet16(0x0ffa + seg, 0x0005) + seg); // 1874 -> 1a61; lin=ffa5
        memoryASet16(0x0ffb + seg, 0x0003, memoryAGet16(0x0ffb + seg, 0x0003) + seg); // 1874 -> 1a61; lin=ffb3
        memoryASet16(0x0ffd + seg, 0x0005, memoryAGet16(0x0ffd + seg, 0x0005) + seg); // 1654 -> 1841; lin=ffd5
        memoryASet16(0x0ffe + seg, 0x0006, memoryAGet16(0x0ffe + seg, 0x0006) + seg); // 06bd -> 08aa; lin=ffe6
        memoryASet16(0x1002 + seg, 0x0004, memoryAGet16(0x1002 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=10024
        memoryASet16(0x1004 + seg, 0x0003, memoryAGet16(0x1004 + seg, 0x0003) + seg); // 06bd -> 08aa; lin=10043
        memoryASet16(0x100a + seg, 0x0000, memoryAGet16(0x100a + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=100a0
        memoryASet16(0x100c + seg, 0x0008, memoryAGet16(0x100c + seg, 0x0008) + seg); // 0d8f -> 0f7c; lin=100c8
        memoryASet16(0x100d + seg, 0x000e, memoryAGet16(0x100d + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=100de
        memoryASet16(0x100e + seg, 0x000a, memoryAGet16(0x100e + seg, 0x000a) + seg); // 06bd -> 08aa; lin=100ea
        memoryASet16(0x1013 + seg, 0x000c, memoryAGet16(0x1013 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=1013c
        memoryASet16(0x1014 + seg, 0x0008, memoryAGet16(0x1014 + seg, 0x0008) + seg); // 06bd -> 08aa; lin=10148
        memoryASet16(0x1017 + seg, 0x0008, memoryAGet16(0x1017 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=10178
        memoryASet16(0x1018 + seg, 0x0004, memoryAGet16(0x1018 + seg, 0x0004) + seg); // 06bd -> 08aa; lin=10184
        memoryASet16(0x101b + seg, 0x0004, memoryAGet16(0x101b + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=101b4
        memoryASet16(0x101c + seg, 0x0000, memoryAGet16(0x101c + seg, 0x0000) + seg); // 06bd -> 08aa; lin=101c0
        memoryASet16(0x101f + seg, 0x0000, memoryAGet16(0x101f + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=101f0
        memoryASet16(0x1023 + seg, 0x0006, memoryAGet16(0x1023 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=10236
        memoryASet16(0x1028 + seg, 0x0007, memoryAGet16(0x1028 + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=10287
        memoryASet16(0x102a + seg, 0x0004, memoryAGet16(0x102a + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=102a4
        memoryASet16(0x102b + seg, 0x0008, memoryAGet16(0x102b + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=102b8
        memoryASet16(0x102d + seg, 0x0003, memoryAGet16(0x102d + seg, 0x0003) + seg); // 0b80 -> 0d6d; lin=102d3
        memoryASet16(0x102f + seg, 0x0001, memoryAGet16(0x102f + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=102f1
        memoryASet16(0x1031 + seg, 0x0008, memoryAGet16(0x1031 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=10318
        memoryASet16(0x1034 + seg, 0x0002, memoryAGet16(0x1034 + seg, 0x0002) + seg); // 1d02 -> 1eef; lin=10342
        memoryASet16(0x1035 + seg, 0x0002, memoryAGet16(0x1035 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=10352
        memoryASet16(0x1037 + seg, 0x0003, memoryAGet16(0x1037 + seg, 0x0003) + seg); // 1d02 -> 1eef; lin=10373
        memoryASet16(0x1038 + seg, 0x0003, memoryAGet16(0x1038 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=10383
        memoryASet16(0x103a + seg, 0x0000, memoryAGet16(0x103a + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=103a0
        memoryASet16(0x103b + seg, 0x000d, memoryAGet16(0x103b + seg, 0x000d) + seg); // 1654 -> 1841; lin=103bd
        memoryASet16(0x103d + seg, 0x000a, memoryAGet16(0x103d + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=103da
        memoryASet16(0x103f + seg, 0x0007, memoryAGet16(0x103f + seg, 0x0007) + seg); // 1654 -> 1841; lin=103f7
        memoryASet16(0x1042 + seg, 0x000c, memoryAGet16(0x1042 + seg, 0x000c) + seg); // 1654 -> 1841; lin=1042c
        memoryASet16(0x104a + seg, 0x0000, memoryAGet16(0x104a + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=104a0
        memoryASet16(0x104b + seg, 0x0005, memoryAGet16(0x104b + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=104b5
        memoryASet16(0x104c + seg, 0x000c, memoryAGet16(0x104c + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=104cc
        memoryASet16(0x1050 + seg, 0x0004, memoryAGet16(0x1050 + seg, 0x0004) + seg); // 1654 -> 1841; lin=10504
        memoryASet16(0x1051 + seg, 0x0007, memoryAGet16(0x1051 + seg, 0x0007) + seg); // 06bd -> 08aa; lin=10517
        memoryASet16(0x1054 + seg, 0x0006, memoryAGet16(0x1054 + seg, 0x0006) + seg); // 1d02 -> 1eef; lin=10546
        memoryASet16(0x1057 + seg, 0x0002, memoryAGet16(0x1057 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=10572
        memoryASet16(0x105b + seg, 0x0003, memoryAGet16(0x105b + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=105b3
        memoryASet16(0x105c + seg, 0x0003, memoryAGet16(0x105c + seg, 0x0003) + seg); // 0b80 -> 0d6d; lin=105c3
        memoryASet16(0x105d + seg, 0x000f, memoryAGet16(0x105d + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=105df
        memoryASet16(0x105f + seg, 0x0000, memoryAGet16(0x105f + seg, 0x0000) + seg); // 06bd -> 08aa; lin=105f0
        memoryASet16(0x1061 + seg, 0x000c, memoryAGet16(0x1061 + seg, 0x000c) + seg); // 1d02 -> 1eef; lin=1061c
        memoryASet16(0x1063 + seg, 0x000a, memoryAGet16(0x1063 + seg, 0x000a) + seg); // 1d02 -> 1eef; lin=1063a
        memoryASet16(0x1066 + seg, 0x0000, memoryAGet16(0x1066 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=10660
        memoryASet16(0x1067 + seg, 0x0001, memoryAGet16(0x1067 + seg, 0x0001) + seg); // 1d02 -> 1eef; lin=10671
        memoryASet16(0x1068 + seg, 0x000a, memoryAGet16(0x1068 + seg, 0x000a) + seg); // 1d02 -> 1eef; lin=1068a
        memoryASet16(0x106a + seg, 0x0000, memoryAGet16(0x106a + seg, 0x0000) + seg); // 1d02 -> 1eef; lin=106a0
        memoryASet16(0x106b + seg, 0x000f, memoryAGet16(0x106b + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=106bf
        memoryASet16(0x106c + seg, 0x000f, memoryAGet16(0x106c + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=106cf
        memoryASet16(0x106e + seg, 0x000a, memoryAGet16(0x106e + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=106ea
        memoryASet16(0x1072 + seg, 0x0007, memoryAGet16(0x1072 + seg, 0x0007) + seg); // 0d8f -> 0f7c; lin=10727
        memoryASet16(0x1075 + seg, 0x0008, memoryAGet16(0x1075 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=10758
        memoryASet16(0x1076 + seg, 0x0004, memoryAGet16(0x1076 + seg, 0x0004) + seg); // 1874 -> 1a61; lin=10764
        memoryASet16(0x107c + seg, 0x0001, memoryAGet16(0x107c + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=107c1
        memoryASet16(0x107f + seg, 0x000e, memoryAGet16(0x107f + seg, 0x000e) + seg); // 1654 -> 1841; lin=107fe
        memoryASet16(0x1080 + seg, 0x000f, memoryAGet16(0x1080 + seg, 0x000f) + seg); // 06bd -> 08aa; lin=1080f
        memoryASet16(0x1083 + seg, 0x000e, memoryAGet16(0x1083 + seg, 0x000e) + seg); // 1d02 -> 1eef; lin=1083e
        memoryASet16(0x1086 + seg, 0x000a, memoryAGet16(0x1086 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=1086a
        memoryASet16(0x1090 + seg, 0x0003, memoryAGet16(0x1090 + seg, 0x0003) + seg); // 1d02 -> 1eef; lin=10903
        memoryASet16(0x1094 + seg, 0x000d, memoryAGet16(0x1094 + seg, 0x000d) + seg); // 1874 -> 1a61; lin=1094d
        memoryASet16(0x1097 + seg, 0x0004, memoryAGet16(0x1097 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=10974
        memoryASet16(0x109a + seg, 0x000b, memoryAGet16(0x109a + seg, 0x000b) + seg); // 0b80 -> 0d6d; lin=109ab
        memoryASet16(0x109c + seg, 0x000b, memoryAGet16(0x109c + seg, 0x000b) + seg); // 06bd -> 08aa; lin=109cb
        memoryASet16(0x10a0 + seg, 0x0005, memoryAGet16(0x10a0 + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=10a05
        memoryASet16(0x10a1 + seg, 0x0006, memoryAGet16(0x10a1 + seg, 0x0006) + seg); // 1d02 -> 1eef; lin=10a16
        memoryASet16(0x10a4 + seg, 0x0000, memoryAGet16(0x10a4 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=10a40
        memoryASet16(0x10a8 + seg, 0x000a, memoryAGet16(0x10a8 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=10a8a
        memoryASet16(0x10b2 + seg, 0x0002, memoryAGet16(0x10b2 + seg, 0x0002) + seg); // 1654 -> 1841; lin=10b22
        memoryASet16(0x10b3 + seg, 0x0008, memoryAGet16(0x10b3 + seg, 0x0008) + seg); // 06bd -> 08aa; lin=10b38
        memoryASet16(0x10b6 + seg, 0x0009, memoryAGet16(0x10b6 + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=10b69
        memoryASet16(0x10b7 + seg, 0x0005, memoryAGet16(0x10b7 + seg, 0x0005) + seg); // 1874 -> 1a61; lin=10b75
        memoryASet16(0x10b9 + seg, 0x0003, memoryAGet16(0x10b9 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=10b93
        memoryASet16(0x10ba + seg, 0x0004, memoryAGet16(0x10ba + seg, 0x0004) + seg); // 06bd -> 08aa; lin=10ba4
        memoryASet16(0x10bd + seg, 0x0003, memoryAGet16(0x10bd + seg, 0x0003) + seg); // 1d02 -> 1eef; lin=10bd3
        memoryASet16(0x10c0 + seg, 0x0004, memoryAGet16(0x10c0 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=10c04
        memoryASet16(0x10c1 + seg, 0x0009, memoryAGet16(0x10c1 + seg, 0x0009) + seg); // 1d02 -> 1eef; lin=10c19
        memoryASet16(0x10c3 + seg, 0x000a, memoryAGet16(0x10c3 + seg, 0x000a) + seg); // 1d02 -> 1eef; lin=10c3a
        memoryASet16(0x10c4 + seg, 0x000f, memoryAGet16(0x10c4 + seg, 0x000f) + seg); // 1d02 -> 1eef; lin=10c4f
        memoryASet16(0x10c9 + seg, 0x0009, memoryAGet16(0x10c9 + seg, 0x0009) + seg); // 1874 -> 1a61; lin=10c99
        memoryASet16(0x10cb + seg, 0x0002, memoryAGet16(0x10cb + seg, 0x0002) + seg); // 06bd -> 08aa; lin=10cb2
        memoryASet16(0x10d0 + seg, 0x000f, memoryAGet16(0x10d0 + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=10d0f
        memoryASet16(0x10d4 + seg, 0x0007, memoryAGet16(0x10d4 + seg, 0x0007) + seg); // 0d8f -> 0f7c; lin=10d47
        memoryASet16(0x10d5 + seg, 0x0008, memoryAGet16(0x10d5 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=10d58
        memoryASet16(0x10d8 + seg, 0x0003, memoryAGet16(0x10d8 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=10d83
        memoryASet16(0x10d9 + seg, 0x0000, memoryAGet16(0x10d9 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=10d90
        memoryASet16(0x10da + seg, 0x000d, memoryAGet16(0x10da + seg, 0x000d) + seg); // 1654 -> 1841; lin=10dad
        memoryASet16(0x10e0 + seg, 0x0008, memoryAGet16(0x10e0 + seg, 0x0008) + seg); // 1654 -> 1841; lin=10e08
        memoryASet16(0x10e3 + seg, 0x0001, memoryAGet16(0x10e3 + seg, 0x0001) + seg); // 1d02 -> 1eef; lin=10e31
        memoryASet16(0x10e4 + seg, 0x0001, memoryAGet16(0x10e4 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=10e41
        memoryASet16(0x10e6 + seg, 0x0002, memoryAGet16(0x10e6 + seg, 0x0002) + seg); // 1d02 -> 1eef; lin=10e62
        memoryASet16(0x10e7 + seg, 0x0002, memoryAGet16(0x10e7 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=10e72
        memoryASet16(0x10e9 + seg, 0x0002, memoryAGet16(0x10e9 + seg, 0x0002) + seg); // 1d02 -> 1eef; lin=10e92
        memoryASet16(0x10ea + seg, 0x0002, memoryAGet16(0x10ea + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=10ea2
        memoryASet16(0x10eb + seg, 0x000b, memoryAGet16(0x10eb + seg, 0x000b) + seg); // 06bd -> 08aa; lin=10ebb
        memoryASet16(0x10ee + seg, 0x0007, memoryAGet16(0x10ee + seg, 0x0007) + seg); // 1d02 -> 1eef; lin=10ee7
        memoryASet16(0x10f1 + seg, 0x0003, memoryAGet16(0x10f1 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=10f13
        memoryASet16(0x10f1 + seg, 0x000b, memoryAGet16(0x10f1 + seg, 0x000b) + seg); // 1d02 -> 1eef; lin=10f1b
        memoryASet16(0x10f3 + seg, 0x0005, memoryAGet16(0x10f3 + seg, 0x0005) + seg); // 06bd -> 08aa; lin=10f35
        memoryASet16(0x10f6 + seg, 0x0009, memoryAGet16(0x10f6 + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=10f69
        memoryASet16(0x10fc + seg, 0x000f, memoryAGet16(0x10fc + seg, 0x000f) + seg); // 1874 -> 1a61; lin=10fcf
        memoryASet16(0x10fe + seg, 0x0005, memoryAGet16(0x10fe + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=10fe5
        memoryASet16(0x10ff + seg, 0x0001, memoryAGet16(0x10ff + seg, 0x0001) + seg); // 06bd -> 08aa; lin=10ff1
        memoryASet16(0x1101 + seg, 0x0009, memoryAGet16(0x1101 + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=11019
        memoryASet16(0x1102 + seg, 0x0005, memoryAGet16(0x1102 + seg, 0x0005) + seg); // 06bd -> 08aa; lin=11025
        memoryASet16(0x1104 + seg, 0x000d, memoryAGet16(0x1104 + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=1104d
        memoryASet16(0x1105 + seg, 0x0009, memoryAGet16(0x1105 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=11059
        memoryASet16(0x1108 + seg, 0x0001, memoryAGet16(0x1108 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=11081
        memoryASet16(0x1108 + seg, 0x000d, memoryAGet16(0x1108 + seg, 0x000d) + seg); // 06bd -> 08aa; lin=1108d
        memoryASet16(0x110b + seg, 0x0002, memoryAGet16(0x110b + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=110b2
        memoryASet16(0x110c + seg, 0x0009, memoryAGet16(0x110c + seg, 0x0009) + seg); // 06bd -> 08aa; lin=110c9
        memoryASet16(0x110f + seg, 0x0003, memoryAGet16(0x110f + seg, 0x0003) + seg); // 06bd -> 08aa; lin=110f3
        memoryASet16(0x1113 + seg, 0x0001, memoryAGet16(0x1113 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=11131
        memoryASet16(0x1116 + seg, 0x0000, memoryAGet16(0x1116 + seg, 0x0000) + seg); // 0d8f -> 0f7c; lin=11160
        memoryASet16(0x1116 + seg, 0x000d, memoryAGet16(0x1116 + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=1116d
        memoryASet16(0x111a + seg, 0x0004, memoryAGet16(0x111a + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=111a4
        memoryASet16(0x111b + seg, 0x0004, memoryAGet16(0x111b + seg, 0x0004) + seg); // 1874 -> 1a61; lin=111b4
        memoryASet16(0x1122 + seg, 0x0008, memoryAGet16(0x1122 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=11228
        memoryASet16(0x1123 + seg, 0x0007, memoryAGet16(0x1123 + seg, 0x0007) + seg); // 1d02 -> 1eef; lin=11237
        memoryASet16(0x1127 + seg, 0x0005, memoryAGet16(0x1127 + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=11275
        memoryASet16(0x1128 + seg, 0x0004, memoryAGet16(0x1128 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=11284
        memoryASet16(0x112b + seg, 0x000d, memoryAGet16(0x112b + seg, 0x000d) + seg); // 1654 -> 1841; lin=112bd
        memoryASet16(0x112d + seg, 0x0001, memoryAGet16(0x112d + seg, 0x0001) + seg); // 06bd -> 08aa; lin=112d1
        memoryASet16(0x112f + seg, 0x000d, memoryAGet16(0x112f + seg, 0x000d) + seg); // 1d02 -> 1eef; lin=112fd
        memoryASet16(0x1132 + seg, 0x0004, memoryAGet16(0x1132 + seg, 0x0004) + seg); // 1d02 -> 1eef; lin=11324
        memoryASet16(0x1133 + seg, 0x000b, memoryAGet16(0x1133 + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=1133b
        memoryASet16(0x113b + seg, 0x0001, memoryAGet16(0x113b + seg, 0x0001) + seg); // 1874 -> 1a61; lin=113b1
        memoryASet16(0x1141 + seg, 0x0006, memoryAGet16(0x1141 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=11416
        memoryASet16(0x1145 + seg, 0x000a, memoryAGet16(0x1145 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=1145a
        memoryASet16(0x1148 + seg, 0x0006, memoryAGet16(0x1148 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=11486
        memoryASet16(0x114a + seg, 0x0003, memoryAGet16(0x114a + seg, 0x0003) + seg); // 1654 -> 1841; lin=114a3
        memoryASet16(0x114b + seg, 0x0004, memoryAGet16(0x114b + seg, 0x0004) + seg); // 06bd -> 08aa; lin=114b4
        memoryASet16(0x1153 + seg, 0x0005, memoryAGet16(0x1153 + seg, 0x0005) + seg); // 09dc -> 0bc9; lin=11535
        memoryASet16(0x1177 + seg, 0x0006, memoryAGet16(0x1177 + seg, 0x0006) + seg); // 1654 -> 1841; lin=11776
        memoryASet16(0x1178 + seg, 0x0007, memoryAGet16(0x1178 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=11787
        memoryASet16(0x117b + seg, 0x0005, memoryAGet16(0x117b + seg, 0x0005) + seg); // 1654 -> 1841; lin=117b5
        memoryASet16(0x117c + seg, 0x000c, memoryAGet16(0x117c + seg, 0x000c) + seg); // 1654 -> 1841; lin=117cc
        memoryASet16(0x117e + seg, 0x000e, memoryAGet16(0x117e + seg, 0x000e) + seg); // 1654 -> 1841; lin=117ee
        memoryASet16(0x1181 + seg, 0x0007, memoryAGet16(0x1181 + seg, 0x0007) + seg); // 1654 -> 1841; lin=11817
        memoryASet16(0x1184 + seg, 0x0007, memoryAGet16(0x1184 + seg, 0x0007) + seg); // 1654 -> 1841; lin=11847
        memoryASet16(0x1186 + seg, 0x000d, memoryAGet16(0x1186 + seg, 0x000d) + seg); // 1654 -> 1841; lin=1186d
        memoryASet16(0x118a + seg, 0x0001, memoryAGet16(0x118a + seg, 0x0001) + seg); // 1654 -> 1841; lin=118a1
        memoryASet16(0x118c + seg, 0x0007, memoryAGet16(0x118c + seg, 0x0007) + seg); // 1654 -> 1841; lin=118c7
        memoryASet16(0x118d + seg, 0x000f, memoryAGet16(0x118d + seg, 0x000f) + seg); // 1654 -> 1841; lin=118df
        memoryASet16(0x118f + seg, 0x0003, memoryAGet16(0x118f + seg, 0x0003) + seg); // 1654 -> 1841; lin=118f3
        memoryASet16(0x1190 + seg, 0x0005, memoryAGet16(0x1190 + seg, 0x0005) + seg); // 06bd -> 08aa; lin=11905
        memoryASet16(0x1194 + seg, 0x0008, memoryAGet16(0x1194 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=11948
        memoryASet16(0x1199 + seg, 0x0001, memoryAGet16(0x1199 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=11991
        memoryASet16(0x11a3 + seg, 0x0007, memoryAGet16(0x11a3 + seg, 0x0007) + seg); // 06bd -> 08aa; lin=11a37
        memoryASet16(0x11a6 + seg, 0x0006, memoryAGet16(0x11a6 + seg, 0x0006) + seg); // 1d02 -> 1eef; lin=11a66
        memoryASet16(0x11a9 + seg, 0x0002, memoryAGet16(0x11a9 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=11a92
        memoryASet16(0x11c1 + seg, 0x000c, memoryAGet16(0x11c1 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=11c1c
        memoryASet16(0x11c7 + seg, 0x000c, memoryAGet16(0x11c7 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=11c7c
        memoryASet16(0x11c9 + seg, 0x0000, memoryAGet16(0x11c9 + seg, 0x0000) + seg); // 06bd -> 08aa; lin=11c90
        memoryASet16(0x11cb + seg, 0x000a, memoryAGet16(0x11cb + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=11cba
        memoryASet16(0x11cc + seg, 0x0006, memoryAGet16(0x11cc + seg, 0x0006) + seg); // 1874 -> 1a61; lin=11cc6
        memoryASet16(0x11cf + seg, 0x0000, memoryAGet16(0x11cf + seg, 0x0000) + seg); // 0d8f -> 0f7c; lin=11cf0
        memoryASet16(0x11cf + seg, 0x000d, memoryAGet16(0x11cf + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=11cfd
        memoryASet16(0x11d8 + seg, 0x000d, memoryAGet16(0x11d8 + seg, 0x000d) + seg); // 1654 -> 1841; lin=11d8d
        memoryASet16(0x11d9 + seg, 0x0009, memoryAGet16(0x11d9 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=11d99
        memoryASet16(0x11dc + seg, 0x000e, memoryAGet16(0x11dc + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=11dce
        memoryASet16(0x11e1 + seg, 0x000b, memoryAGet16(0x11e1 + seg, 0x000b) + seg); // 09dc -> 0bc9; lin=11e1b
        memoryASet16(0x11e5 + seg, 0x000f, memoryAGet16(0x11e5 + seg, 0x000f) + seg); // 1654 -> 1841; lin=11e5f
        memoryASet16(0x11e7 + seg, 0x0000, memoryAGet16(0x11e7 + seg, 0x0000) + seg); // 06bd -> 08aa; lin=11e70
        memoryASet16(0x11ea + seg, 0x000d, memoryAGet16(0x11ea + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=11ead
        memoryASet16(0x11fa + seg, 0x0005, memoryAGet16(0x11fa + seg, 0x0005) + seg); // 0d8f -> 0f7c; lin=11fa5
        memoryASet16(0x11fb + seg, 0x0002, memoryAGet16(0x11fb + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=11fb2
        memoryASet16(0x11fc + seg, 0x000e, memoryAGet16(0x11fc + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=11fce
        memoryASet16(0x11ff + seg, 0x0005, memoryAGet16(0x11ff + seg, 0x0005) + seg); // 1874 -> 1a61; lin=11ff5
        memoryASet16(0x1200 + seg, 0x0007, memoryAGet16(0x1200 + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=12007
        memoryASet16(0x1204 + seg, 0x0006, memoryAGet16(0x1204 + seg, 0x0006) + seg); // 1654 -> 1841; lin=12046
        memoryASet16(0x1206 + seg, 0x0002, memoryAGet16(0x1206 + seg, 0x0002) + seg); // 1874 -> 1a61; lin=12062
        memoryASet16(0x1206 + seg, 0x000f, memoryAGet16(0x1206 + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=1206f
        memoryASet16(0x120a + seg, 0x0008, memoryAGet16(0x120a + seg, 0x0008) + seg); // 1654 -> 1841; lin=120a8
        memoryASet16(0x120b + seg, 0x0009, memoryAGet16(0x120b + seg, 0x0009) + seg); // 06bd -> 08aa; lin=120b9
        memoryASet16(0x120e + seg, 0x000d, memoryAGet16(0x120e + seg, 0x000d) + seg); // 1d02 -> 1eef; lin=120ed
        memoryASet16(0x1211 + seg, 0x0009, memoryAGet16(0x1211 + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=12119
        memoryASet16(0x1216 + seg, 0x0001, memoryAGet16(0x1216 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=12161
        memoryASet16(0x1217 + seg, 0x000e, memoryAGet16(0x1217 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=1217e
        memoryASet16(0x1219 + seg, 0x0002, memoryAGet16(0x1219 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=12192
        memoryASet16(0x1225 + seg, 0x000c, memoryAGet16(0x1225 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=1225c
        memoryASet16(0x1227 + seg, 0x0003, memoryAGet16(0x1227 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=12273
        memoryASet16(0x1227 + seg, 0x000e, memoryAGet16(0x1227 + seg, 0x000e) + seg); // 06bd -> 08aa; lin=1227e
        memoryASet16(0x1234 + seg, 0x0000, memoryAGet16(0x1234 + seg, 0x0000) + seg); // 06bd -> 08aa; lin=12340
        memoryASet16(0x1238 + seg, 0x0000, memoryAGet16(0x1238 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=12380
        memoryASet16(0x1238 + seg, 0x000c, memoryAGet16(0x1238 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=1238c
        memoryASet16(0x1239 + seg, 0x000f, memoryAGet16(0x1239 + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=1239f
        memoryASet16(0x123a + seg, 0x0007, memoryAGet16(0x123a + seg, 0x0007) + seg); // 1d02 -> 1eef; lin=123a7
        memoryASet16(0x123c + seg, 0x0008, memoryAGet16(0x123c + seg, 0x0008) + seg); // 06bd -> 08aa; lin=123c8
        memoryASet16(0x123e + seg, 0x0008, memoryAGet16(0x123e + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=123e8
        memoryASet16(0x1240 + seg, 0x000b, memoryAGet16(0x1240 + seg, 0x000b) + seg); // 1874 -> 1a61; lin=1240b
        memoryASet16(0x1241 + seg, 0x0008, memoryAGet16(0x1241 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=12418
        memoryASet16(0x1244 + seg, 0x000e, memoryAGet16(0x1244 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=1244e
        memoryASet16(0x124b + seg, 0x000f, memoryAGet16(0x124b + seg, 0x000f) + seg); // 1654 -> 1841; lin=124bf
        memoryASet16(0x124d + seg, 0x0000, memoryAGet16(0x124d + seg, 0x0000) + seg); // 06bd -> 08aa; lin=124d0
        memoryASet16(0x1250 + seg, 0x000f, memoryAGet16(0x1250 + seg, 0x000f) + seg); // 09dc -> 0bc9; lin=1250f
        memoryASet16(0x1254 + seg, 0x0006, memoryAGet16(0x1254 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=12546
        memoryASet16(0x1256 + seg, 0x0003, memoryAGet16(0x1256 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=12563
        memoryASet16(0x1257 + seg, 0x0007, memoryAGet16(0x1257 + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=12577
        memoryASet16(0x1258 + seg, 0x0008, memoryAGet16(0x1258 + seg, 0x0008) + seg); // 06bd -> 08aa; lin=12588
        memoryASet16(0x125c + seg, 0x000a, memoryAGet16(0x125c + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=125ca
        memoryASet16(0x125e + seg, 0x0003, memoryAGet16(0x125e + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=125e3
        memoryASet16(0x1266 + seg, 0x0009, memoryAGet16(0x1266 + seg, 0x0009) + seg); // 06bd -> 08aa; lin=12669
        memoryASet16(0x1269 + seg, 0x0006, memoryAGet16(0x1269 + seg, 0x0006) + seg); // 1874 -> 1a61; lin=12696
        memoryASet16(0x126a + seg, 0x000d, memoryAGet16(0x126a + seg, 0x000d) + seg); // 09dc -> 0bc9; lin=126ad
        memoryASet16(0x126b + seg, 0x0009, memoryAGet16(0x126b + seg, 0x0009) + seg); // 1874 -> 1a61; lin=126b9
        memoryASet16(0x126e + seg, 0x0004, memoryAGet16(0x126e + seg, 0x0004) + seg); // 06bd -> 08aa; lin=126e4
        memoryASet16(0x1270 + seg, 0x0004, memoryAGet16(0x1270 + seg, 0x0004) + seg); // 1654 -> 1841; lin=12704
        memoryASet16(0x1271 + seg, 0x0005, memoryAGet16(0x1271 + seg, 0x0005) + seg); // 06bd -> 08aa; lin=12715
        memoryASet16(0x1279 + seg, 0x0006, memoryAGet16(0x1279 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=12796
        memoryASet16(0x127b + seg, 0x000c, memoryAGet16(0x127b + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=127bc
        memoryASet16(0x127c + seg, 0x0008, memoryAGet16(0x127c + seg, 0x0008) + seg); // 1874 -> 1a61; lin=127c8
        memoryASet16(0x127d + seg, 0x0000, memoryAGet16(0x127d + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=127d0
        memoryASet16(0x127d + seg, 0x000e, memoryAGet16(0x127d + seg, 0x000e) + seg); // 06bd -> 08aa; lin=127de
        memoryASet16(0x1281 + seg, 0x000a, memoryAGet16(0x1281 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=1281a
        memoryASet16(0x1283 + seg, 0x0003, memoryAGet16(0x1283 + seg, 0x0003) + seg); // 09dc -> 0bc9; lin=12833
        memoryASet16(0x1286 + seg, 0x0008, memoryAGet16(0x1286 + seg, 0x0008) + seg); // 06bd -> 08aa; lin=12868
        memoryASet16(0x128f + seg, 0x0006, memoryAGet16(0x128f + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=128f6
        memoryASet16(0x1291 + seg, 0x0004, memoryAGet16(0x1291 + seg, 0x0004) + seg); // 06bd -> 08aa; lin=12914
        memoryASet16(0x1295 + seg, 0x0007, memoryAGet16(0x1295 + seg, 0x0007) + seg); // 09dc -> 0bc9; lin=12957
        memoryASet16(0x1297 + seg, 0x0004, memoryAGet16(0x1297 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=12974
        memoryASet16(0x1299 + seg, 0x0001, memoryAGet16(0x1299 + seg, 0x0001) + seg); // 09dc -> 0bc9; lin=12991
        memoryASet16(0x129a + seg, 0x000e, memoryAGet16(0x129a + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=129ae
        memoryASet16(0x129b + seg, 0x000a, memoryAGet16(0x129b + seg, 0x000a) + seg); // 1874 -> 1a61; lin=129ba
        memoryASet16(0x129e + seg, 0x0009, memoryAGet16(0x129e + seg, 0x0009) + seg); // 1654 -> 1841; lin=129e9
        memoryASet16(0x129f + seg, 0x000a, memoryAGet16(0x129f + seg, 0x000a) + seg); // 06bd -> 08aa; lin=129fa
        memoryASet16(0x12a2 + seg, 0x0009, memoryAGet16(0x12a2 + seg, 0x0009) + seg); // 09dc -> 0bc9; lin=12a29
        memoryASet16(0x12a5 + seg, 0x0003, memoryAGet16(0x12a5 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=12a53
        memoryASet16(0x12a5 + seg, 0x000b, memoryAGet16(0x12a5 + seg, 0x000b) + seg); // 0e8f -> 107c; lin=12a5b
        memoryASet16(0x12a6 + seg, 0x0000, memoryAGet16(0x12a6 + seg, 0x0000) + seg); // 1654 -> 1841; lin=12a60
        memoryASet16(0x12ac + seg, 0x0009, memoryAGet16(0x12ac + seg, 0x0009) + seg); // 0000 -> 01ed; lin=12ac9
        memoryASet16(0x12ad + seg, 0x0009, memoryAGet16(0x12ad + seg, 0x0009) + seg); // 0000 -> 01ed; lin=12ad9
        memoryASet16(0x12ae + seg, 0x000d, memoryAGet16(0x12ae + seg, 0x000d) + seg); // 0000 -> 01ed; lin=12aed
        memoryASet16(0x12b0 + seg, 0x000f, memoryAGet16(0x12b0 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=12b0f
        memoryASet16(0x12b2 + seg, 0x0003, memoryAGet16(0x12b2 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=12b23
        memoryASet16(0x12b6 + seg, 0x000c, memoryAGet16(0x12b6 + seg, 0x000c) + seg); // 037d -> 056a; lin=12b6c
        memoryASet16(0x12bb + seg, 0x0008, memoryAGet16(0x12bb + seg, 0x0008) + seg); // 037d -> 056a; lin=12bb8
        memoryASet16(0x12c0 + seg, 0x0005, memoryAGet16(0x12c0 + seg, 0x0005) + seg); // 0000 -> 01ed; lin=12c05
        memoryASet16(0x12c1 + seg, 0x000d, memoryAGet16(0x12c1 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=12c1d
        memoryASet16(0x12c4 + seg, 0x0001, memoryAGet16(0x12c4 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=12c41
        memoryASet16(0x12c5 + seg, 0x0002, memoryAGet16(0x12c5 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=12c52
        memoryASet16(0x12c7 + seg, 0x0009, memoryAGet16(0x12c7 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=12c79
        memoryASet16(0x12c9 + seg, 0x0001, memoryAGet16(0x12c9 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=12c91
        memoryASet16(0x12ca + seg, 0x0004, memoryAGet16(0x12ca + seg, 0x0004) + seg); // 155e -> 174b; lin=12ca4
        memoryASet16(0x12cc + seg, 0x0004, memoryAGet16(0x12cc + seg, 0x0004) + seg); // 0000 -> 01ed; lin=12cc4
        memoryASet16(0x12cd + seg, 0x0005, memoryAGet16(0x12cd + seg, 0x0005) + seg); // 0000 -> 01ed; lin=12cd5
        memoryASet16(0x12d4 + seg, 0x000a, memoryAGet16(0x12d4 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=12d4a
        memoryASet16(0x12d5 + seg, 0x0009, memoryAGet16(0x12d5 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=12d59
        memoryASet16(0x12d6 + seg, 0x0008, memoryAGet16(0x12d6 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=12d68
        memoryASet16(0x12d7 + seg, 0x0007, memoryAGet16(0x12d7 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=12d77
        memoryASet16(0x12fc + seg, 0x0001, memoryAGet16(0x12fc + seg, 0x0001) + seg); // 0000 -> 01ed; lin=12fc1
        memoryASet16(0x12fd + seg, 0x0004, memoryAGet16(0x12fd + seg, 0x0004) + seg); // 0000 -> 01ed; lin=12fd4
        memoryASet16(0x12ff + seg, 0x0005, memoryAGet16(0x12ff + seg, 0x0005) + seg); // 0000 -> 01ed; lin=12ff5
        memoryASet16(0x1300 + seg, 0x0007, memoryAGet16(0x1300 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=13007
        memoryASet16(0x1302 + seg, 0x0003, memoryAGet16(0x1302 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=13023
        memoryASet16(0x1304 + seg, 0x000a, memoryAGet16(0x1304 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1304a
        memoryASet16(0x1305 + seg, 0x000f, memoryAGet16(0x1305 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1305f
        memoryASet16(0x1307 + seg, 0x0007, memoryAGet16(0x1307 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=13077
        memoryASet16(0x1309 + seg, 0x0006, memoryAGet16(0x1309 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=13096
        memoryASet16(0x130a + seg, 0x000c, memoryAGet16(0x130a + seg, 0x000c) + seg); // 0000 -> 01ed; lin=130ac
        memoryASet16(0x130c + seg, 0x0009, memoryAGet16(0x130c + seg, 0x0009) + seg); // 0000 -> 01ed; lin=130c9
        memoryASet16(0x130d + seg, 0x0000, memoryAGet16(0x130d + seg, 0x0000) + seg); // 0000 -> 01ed; lin=130d0
        memoryASet16(0x130f + seg, 0x000d, memoryAGet16(0x130f + seg, 0x000d) + seg); // 0000 -> 01ed; lin=130fd
        memoryASet16(0x1311 + seg, 0x0000, memoryAGet16(0x1311 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=13110
        memoryASet16(0x131b + seg, 0x0001, memoryAGet16(0x131b + seg, 0x0001) + seg); // 2108 -> 22f5; lin=131b1
        memoryASet16(0x131c + seg, 0x0009, memoryAGet16(0x131c + seg, 0x0009) + seg); // 0000 -> 01ed; lin=131c9
        memoryASet16(0x131d + seg, 0x000f, memoryAGet16(0x131d + seg, 0x000f) + seg); // 037d -> 056a; lin=131df
        memoryASet16(0x131f + seg, 0x0002, memoryAGet16(0x131f + seg, 0x0002) + seg); // 155e -> 174b; lin=131f2
        memoryASet16(0x1321 + seg, 0x0000, memoryAGet16(0x1321 + seg, 0x0000) + seg); // 155e -> 174b; lin=13210
        memoryASet16(0x1325 + seg, 0x0000, memoryAGet16(0x1325 + seg, 0x0000) + seg); // 155e -> 174b; lin=13250
        memoryASet16(0x1326 + seg, 0x0003, memoryAGet16(0x1326 + seg, 0x0003) + seg); // 155e -> 174b; lin=13263
        memoryASet16(0x1328 + seg, 0x0002, memoryAGet16(0x1328 + seg, 0x0002) + seg); // 155e -> 174b; lin=13282
        memoryASet16(0x132c + seg, 0x0002, memoryAGet16(0x132c + seg, 0x0002) + seg); // 155e -> 174b; lin=132c2
        memoryASet16(0x132d + seg, 0x0005, memoryAGet16(0x132d + seg, 0x0005) + seg); // 155e -> 174b; lin=132d5
        memoryASet16(0x132f + seg, 0x0004, memoryAGet16(0x132f + seg, 0x0004) + seg); // 155e -> 174b; lin=132f4
        memoryASet16(0x1333 + seg, 0x0004, memoryAGet16(0x1333 + seg, 0x0004) + seg); // 155e -> 174b; lin=13334
        memoryASet16(0x1334 + seg, 0x0004, memoryAGet16(0x1334 + seg, 0x0004) + seg); // 2483 -> 2670; lin=13344
        memoryASet16(0x1335 + seg, 0x0005, memoryAGet16(0x1335 + seg, 0x0005) + seg); // 0000 -> 01ed; lin=13355
        memoryASet16(0x1336 + seg, 0x0009, memoryAGet16(0x1336 + seg, 0x0009) + seg); // 037d -> 056a; lin=13369
        memoryASet16(0x1338 + seg, 0x0008, memoryAGet16(0x1338 + seg, 0x0008) + seg); // 20df -> 22cc; lin=13388
        memoryASet16(0x1339 + seg, 0x0009, memoryAGet16(0x1339 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=13399
        memoryASet16(0x133a + seg, 0x000d, memoryAGet16(0x133a + seg, 0x000d) + seg); // 037d -> 056a; lin=133ad
        memoryASet16(0x133d + seg, 0x0007, memoryAGet16(0x133d + seg, 0x0007) + seg); // 12a6 -> 1493; lin=133d7
        memoryASet16(0x133e + seg, 0x0003, memoryAGet16(0x133e + seg, 0x0003) + seg); // 12a6 -> 1493; lin=133e3
        memoryASet16(0x133e + seg, 0x000f, memoryAGet16(0x133e + seg, 0x000f) + seg); // 12a6 -> 1493; lin=133ef
        memoryASet16(0x1340 + seg, 0x0003, memoryAGet16(0x1340 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=13403
        memoryASet16(0x1340 + seg, 0x000f, memoryAGet16(0x1340 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1340f
        memoryASet16(0x1341 + seg, 0x000b, memoryAGet16(0x1341 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=1341b
        memoryASet16(0x1344 + seg, 0x0005, memoryAGet16(0x1344 + seg, 0x0005) + seg); // 155e -> 174b; lin=13445
        memoryASet16(0x1349 + seg, 0x0000, memoryAGet16(0x1349 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=13490
        memoryASet16(0x134d + seg, 0x0006, memoryAGet16(0x134d + seg, 0x0006) + seg); // 155e -> 174b; lin=134d6
        memoryASet16(0x134f + seg, 0x0000, memoryAGet16(0x134f + seg, 0x0000) + seg); // 155e -> 174b; lin=134f0
        memoryASet16(0x1353 + seg, 0x000a, memoryAGet16(0x1353 + seg, 0x000a) + seg); // 155e -> 174b; lin=1353a
        memoryASet16(0x1357 + seg, 0x000e, memoryAGet16(0x1357 + seg, 0x000e) + seg); // 155e -> 174b; lin=1357e
        memoryASet16(0x135c + seg, 0x0007, memoryAGet16(0x135c + seg, 0x0007) + seg); // 155e -> 174b; lin=135c7
        memoryASet16(0x1372 + seg, 0x0007, memoryAGet16(0x1372 + seg, 0x0007) + seg); // 155e -> 174b; lin=13727
        memoryASet16(0x1395 + seg, 0x000a, memoryAGet16(0x1395 + seg, 0x000a) + seg); // 037d -> 056a; lin=1395a
        memoryASet16(0x13a2 + seg, 0x0006, memoryAGet16(0x13a2 + seg, 0x0006) + seg); // 155e -> 174b; lin=13a26
        memoryASet16(0x13ac + seg, 0x0004, memoryAGet16(0x13ac + seg, 0x0004) + seg); // 0000 -> 01ed; lin=13ac4
        memoryASet16(0x13b0 + seg, 0x000a, memoryAGet16(0x13b0 + seg, 0x000a) + seg); // 155e -> 174b; lin=13b0a
        memoryASet16(0x13b2 + seg, 0x0001, memoryAGet16(0x13b2 + seg, 0x0001) + seg); // 155e -> 174b; lin=13b21
        memoryASet16(0x13b6 + seg, 0x000c, memoryAGet16(0x13b6 + seg, 0x000c) + seg); // 155e -> 174b; lin=13b6c
        memoryASet16(0x13b8 + seg, 0x0003, memoryAGet16(0x13b8 + seg, 0x0003) + seg); // 2a3a -> 2c27; lin=13b83
        memoryASet16(0x13ba + seg, 0x0009, memoryAGet16(0x13ba + seg, 0x0009) + seg); // 155e -> 174b; lin=13ba9
        memoryASet16(0x13c1 + seg, 0x0004, memoryAGet16(0x13c1 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=13c14
        memoryASet16(0x13c5 + seg, 0x000a, memoryAGet16(0x13c5 + seg, 0x000a) + seg); // 155e -> 174b; lin=13c5a
        memoryASet16(0x13c6 + seg, 0x000a, memoryAGet16(0x13c6 + seg, 0x000a) + seg); // 155e -> 174b; lin=13c6a
        memoryASet16(0x13cb + seg, 0x0005, memoryAGet16(0x13cb + seg, 0x0005) + seg); // 155e -> 174b; lin=13cb5
        memoryASet16(0x13ce + seg, 0x000f, memoryAGet16(0x13ce + seg, 0x000f) + seg); // 155e -> 174b; lin=13cef
        memoryASet16(0x13d0 + seg, 0x000e, memoryAGet16(0x13d0 + seg, 0x000e) + seg); // 155e -> 174b; lin=13d0e
        memoryASet16(0x13d5 + seg, 0x0005, memoryAGet16(0x13d5 + seg, 0x0005) + seg); // 037d -> 056a; lin=13d55
        memoryASet16(0x13d6 + seg, 0x000c, memoryAGet16(0x13d6 + seg, 0x000c) + seg); // 155e -> 174b; lin=13d6c
        memoryASet16(0x13d8 + seg, 0x0001, memoryAGet16(0x13d8 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=13d81
        memoryASet16(0x13db + seg, 0x0001, memoryAGet16(0x13db + seg, 0x0001) + seg); // 155e -> 174b; lin=13db1
        memoryASet16(0x13e2 + seg, 0x0002, memoryAGet16(0x13e2 + seg, 0x0002) + seg); // 155e -> 174b; lin=13e22
        memoryASet16(0x13e3 + seg, 0x0007, memoryAGet16(0x13e3 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=13e37
        memoryASet16(0x13e6 + seg, 0x0005, memoryAGet16(0x13e6 + seg, 0x0005) + seg); // 155e -> 174b; lin=13e65
        memoryASet16(0x13e7 + seg, 0x0005, memoryAGet16(0x13e7 + seg, 0x0005) + seg); // 155e -> 174b; lin=13e75
        memoryASet16(0x13eb + seg, 0x0009, memoryAGet16(0x13eb + seg, 0x0009) + seg); // 155e -> 174b; lin=13eb9
        memoryASet16(0x13ef + seg, 0x000e, memoryAGet16(0x13ef + seg, 0x000e) + seg); // 155e -> 174b; lin=13efe
        memoryASet16(0x13f1 + seg, 0x0009, memoryAGet16(0x13f1 + seg, 0x0009) + seg); // 155e -> 174b; lin=13f19
        memoryASet16(0x13f3 + seg, 0x000e, memoryAGet16(0x13f3 + seg, 0x000e) + seg); // 037d -> 056a; lin=13f3e
        memoryASet16(0x13f6 + seg, 0x0000, memoryAGet16(0x13f6 + seg, 0x0000) + seg); // 037d -> 056a; lin=13f60
        memoryASet16(0x13f8 + seg, 0x0003, memoryAGet16(0x13f8 + seg, 0x0003) + seg); // 2a3a -> 2c27; lin=13f83
        memoryASet16(0x13fa + seg, 0x0007, memoryAGet16(0x13fa + seg, 0x0007) + seg); // 2a3a -> 2c27; lin=13fa7
        memoryASet16(0x13fb + seg, 0x0001, memoryAGet16(0x13fb + seg, 0x0001) + seg); // 0000 -> 01ed; lin=13fb1
        memoryASet16(0x13fe + seg, 0x0004, memoryAGet16(0x13fe + seg, 0x0004) + seg); // 155e -> 174b; lin=13fe4
        memoryASet16(0x13ff + seg, 0x000e, memoryAGet16(0x13ff + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=13ffe
        memoryASet16(0x1401 + seg, 0x000e, memoryAGet16(0x1401 + seg, 0x000e) + seg); // 155e -> 174b; lin=1401e
        memoryASet16(0x1404 + seg, 0x0003, memoryAGet16(0x1404 + seg, 0x0003) + seg); // 155e -> 174b; lin=14043
        memoryASet16(0x1406 + seg, 0x000c, memoryAGet16(0x1406 + seg, 0x000c) + seg); // 155e -> 174b; lin=1406c
        memoryASet16(0x140a + seg, 0x0001, memoryAGet16(0x140a + seg, 0x0001) + seg); // 155e -> 174b; lin=140a1
        memoryASet16(0x140c + seg, 0x0007, memoryAGet16(0x140c + seg, 0x0007) + seg); // 0000 -> 01ed; lin=140c7
        memoryASet16(0x140d + seg, 0x000b, memoryAGet16(0x140d + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=140db
        memoryASet16(0x140f + seg, 0x0003, memoryAGet16(0x140f + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=140f3
        memoryASet16(0x1410 + seg, 0x0003, memoryAGet16(0x1410 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=14103
        memoryASet16(0x1412 + seg, 0x000e, memoryAGet16(0x1412 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1412e
        memoryASet16(0x1414 + seg, 0x0005, memoryAGet16(0x1414 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=14145
        memoryASet16(0x1415 + seg, 0x000c, memoryAGet16(0x1415 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=1415c
        memoryASet16(0x1417 + seg, 0x0003, memoryAGet16(0x1417 + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=14173
        memoryASet16(0x1418 + seg, 0x000d, memoryAGet16(0x1418 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=1418d
        memoryASet16(0x141a + seg, 0x0007, memoryAGet16(0x141a + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=141a7
        memoryASet16(0x141c + seg, 0x0002, memoryAGet16(0x141c + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=141c2
        memoryASet16(0x141d + seg, 0x0006, memoryAGet16(0x141d + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=141d6
        memoryASet16(0x141e + seg, 0x000a, memoryAGet16(0x141e + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=141ea
        memoryASet16(0x1421 + seg, 0x0008, memoryAGet16(0x1421 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=14218
        memoryASet16(0x1425 + seg, 0x000b, memoryAGet16(0x1425 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=1425b
        memoryASet16(0x1426 + seg, 0x000c, memoryAGet16(0x1426 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=1426c
        memoryASet16(0x1429 + seg, 0x0008, memoryAGet16(0x1429 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=14298
        memoryASet16(0x142a + seg, 0x0005, memoryAGet16(0x142a + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=142a5
        memoryASet16(0x142c + seg, 0x000d, memoryAGet16(0x142c + seg, 0x000d) + seg); // 2a3a -> 2c27; lin=142cd
        memoryASet16(0x142f + seg, 0x0005, memoryAGet16(0x142f + seg, 0x0005) + seg); // 155e -> 174b; lin=142f5
        memoryASet16(0x1431 + seg, 0x000d, memoryAGet16(0x1431 + seg, 0x000d) + seg); // 155e -> 174b; lin=1431d
        memoryASet16(0x1436 + seg, 0x0004, memoryAGet16(0x1436 + seg, 0x0004) + seg); // 2a3a -> 2c27; lin=14364
        memoryASet16(0x1445 + seg, 0x000e, memoryAGet16(0x1445 + seg, 0x000e) + seg); // 2a3a -> 2c27; lin=1445e
        memoryASet16(0x1450 + seg, 0x0009, memoryAGet16(0x1450 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=14509
        memoryASet16(0x1456 + seg, 0x0002, memoryAGet16(0x1456 + seg, 0x0002) + seg); // 155e -> 174b; lin=14562
        memoryASet16(0x1457 + seg, 0x000c, memoryAGet16(0x1457 + seg, 0x000c) + seg); // 155e -> 174b; lin=1457c
        memoryASet16(0x1459 + seg, 0x0001, memoryAGet16(0x1459 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=14591
        memoryASet16(0x145e + seg, 0x0003, memoryAGet16(0x145e + seg, 0x0003) + seg); // 155e -> 174b; lin=145e3
        memoryASet16(0x1461 + seg, 0x0005, memoryAGet16(0x1461 + seg, 0x0005) + seg); // 2ee7 -> 30d4; lin=14615
        memoryASet16(0x1471 + seg, 0x0003, memoryAGet16(0x1471 + seg, 0x0003) + seg); // 1f78 -> 2165; lin=14713
        memoryASet16(0x1474 + seg, 0x0002, memoryAGet16(0x1474 + seg, 0x0002) + seg); // 1f70 -> 215d; lin=14742
        memoryASet16(0x1477 + seg, 0x0002, memoryAGet16(0x1477 + seg, 0x0002) + seg); // 1f68 -> 2155; lin=14772
        memoryASet16(0x14a0 + seg, 0x000d, memoryAGet16(0x14a0 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=14a0d
        memoryASet16(0x14a2 + seg, 0x0004, memoryAGet16(0x14a2 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=14a24
        memoryASet16(0x14ae + seg, 0x0006, memoryAGet16(0x14ae + seg, 0x0006) + seg); // 0000 -> 01ed; lin=14ae6
        memoryASet16(0x14af + seg, 0x0003, memoryAGet16(0x14af + seg, 0x0003) + seg); // 1460 -> 164d; lin=14af3
        memoryASet16(0x14b0 + seg, 0x0001, memoryAGet16(0x14b0 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=14b01
        memoryASet16(0x14b2 + seg, 0x000f, memoryAGet16(0x14b2 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=14b2f
        memoryASet16(0x14b4 + seg, 0x0000, memoryAGet16(0x14b4 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=14b40
        memoryASet16(0x14b8 + seg, 0x0004, memoryAGet16(0x14b8 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=14b84
        memoryASet16(0x14b9 + seg, 0x000d, memoryAGet16(0x14b9 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=14b9d
        memoryASet16(0x14bb + seg, 0x0006, memoryAGet16(0x14bb + seg, 0x0006) + seg); // 0000 -> 01ed; lin=14bb6
        memoryASet16(0x14bc + seg, 0x000f, memoryAGet16(0x14bc + seg, 0x000f) + seg); // 0000 -> 01ed; lin=14bcf
        memoryASet16(0x14d7 + seg, 0x000c, memoryAGet16(0x14d7 + seg, 0x000c) + seg); // 1460 -> 164d; lin=14d7c
        memoryASet16(0x14d8 + seg, 0x000c, memoryAGet16(0x14d8 + seg, 0x000c) + seg); // 1874 -> 1a61; lin=14d8c
        memoryASet16(0x14dc + seg, 0x0003, memoryAGet16(0x14dc + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=14dc3
        memoryASet16(0x1505 + seg, 0x0001, memoryAGet16(0x1505 + seg, 0x0001) + seg); // 037d -> 056a; lin=15051
        memoryASet16(0x1530 + seg, 0x0000, memoryAGet16(0x1530 + seg, 0x0000) + seg); // 037d -> 056a; lin=15300
        memoryASet16(0x1535 + seg, 0x0004, memoryAGet16(0x1535 + seg, 0x0004) + seg); // 155e -> 174b; lin=15354
        memoryASet16(0x153d + seg, 0x0000, memoryAGet16(0x153d + seg, 0x0000) + seg); // 155e -> 174b; lin=153d0
        memoryASet16(0x153e + seg, 0x0004, memoryAGet16(0x153e + seg, 0x0004) + seg); // 1f80 -> 216d; lin=153e4
        memoryASet16(0x1568 + seg, 0x000d, memoryAGet16(0x1568 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1568d
        memoryASet16(0x156a + seg, 0x0000, memoryAGet16(0x156a + seg, 0x0000) + seg); // 0000 -> 01ed; lin=156a0
        memoryASet16(0x156b + seg, 0x0000, memoryAGet16(0x156b + seg, 0x0000) + seg); // 0000 -> 01ed; lin=156b0
        memoryASet16(0x156b + seg, 0x000c, memoryAGet16(0x156b + seg, 0x000c) + seg); // 037d -> 056a; lin=156bc
        memoryASet16(0x156e + seg, 0x0002, memoryAGet16(0x156e + seg, 0x0002) + seg); // 037d -> 056a; lin=156e2
        memoryASet16(0x1572 + seg, 0x0009, memoryAGet16(0x1572 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=15729
        memoryASet16(0x1573 + seg, 0x000c, memoryAGet16(0x1573 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1573c
        memoryASet16(0x1574 + seg, 0x000c, memoryAGet16(0x1574 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1574c
        memoryASet16(0x1575 + seg, 0x0008, memoryAGet16(0x1575 + seg, 0x0008) + seg); // 037d -> 056a; lin=15758
        memoryASet16(0x158a + seg, 0x000a, memoryAGet16(0x158a + seg, 0x000a) + seg); // 037d -> 056a; lin=158aa
        memoryASet16(0x15a0 + seg, 0x0002, memoryAGet16(0x15a0 + seg, 0x0002) + seg); // 037d -> 056a; lin=15a02
        memoryASet16(0x15a3 + seg, 0x000b, memoryAGet16(0x15a3 + seg, 0x000b) + seg); // 2b63 -> 2d50; lin=15a3b
        memoryASet16(0x15a5 + seg, 0x000a, memoryAGet16(0x15a5 + seg, 0x000a) + seg); // 2b63 -> 2d50; lin=15a5a
        memoryASet16(0x15a6 + seg, 0x0005, memoryAGet16(0x15a6 + seg, 0x0005) + seg); // 2b63 -> 2d50; lin=15a65
        memoryASet16(0x15a7 + seg, 0x000c, memoryAGet16(0x15a7 + seg, 0x000c) + seg); // 2b63 -> 2d50; lin=15a7c
        memoryASet16(0x15af + seg, 0x000a, memoryAGet16(0x15af + seg, 0x000a) + seg); // 0000 -> 01ed; lin=15afa
        memoryASet16(0x15b0 + seg, 0x0008, memoryAGet16(0x15b0 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=15b08
        memoryASet16(0x15b3 + seg, 0x0009, memoryAGet16(0x15b3 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=15b39
        memoryASet16(0x15b6 + seg, 0x000a, memoryAGet16(0x15b6 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=15b6a
        memoryASet16(0x15b7 + seg, 0x0009, memoryAGet16(0x15b7 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=15b79
        memoryASet16(0x15ba + seg, 0x000d, memoryAGet16(0x15ba + seg, 0x000d) + seg); // 0000 -> 01ed; lin=15bad
        memoryASet16(0x15c1 + seg, 0x0005, memoryAGet16(0x15c1 + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=15c15
        memoryASet16(0x15c5 + seg, 0x0002, memoryAGet16(0x15c5 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=15c52
        memoryASet16(0x15c7 + seg, 0x000f, memoryAGet16(0x15c7 + seg, 0x000f) + seg); // 1931 -> 1b1e; lin=15c7f
        memoryASet16(0x15cd + seg, 0x0007, memoryAGet16(0x15cd + seg, 0x0007) + seg); // 0000 -> 01ed; lin=15cd7
        memoryASet16(0x15ce + seg, 0x0003, memoryAGet16(0x15ce + seg, 0x0003) + seg); // 0000 -> 01ed; lin=15ce3
        memoryASet16(0x15d0 + seg, 0x000b, memoryAGet16(0x15d0 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=15d0b
        memoryASet16(0x15f5 + seg, 0x0000, memoryAGet16(0x15f5 + seg, 0x0000) + seg); // 037d -> 056a; lin=15f50
        memoryASet16(0x15fe + seg, 0x0008, memoryAGet16(0x15fe + seg, 0x0008) + seg); // 037d -> 056a; lin=15fe8
        memoryASet16(0x1609 + seg, 0x0007, memoryAGet16(0x1609 + seg, 0x0007) + seg); // 037d -> 056a; lin=16097
        memoryASet16(0x1611 + seg, 0x000a, memoryAGet16(0x1611 + seg, 0x000a) + seg); // 037d -> 056a; lin=1611a
        memoryASet16(0x1614 + seg, 0x0008, memoryAGet16(0x1614 + seg, 0x0008) + seg); // 1874 -> 1a61; lin=16148
        memoryASet16(0x1617 + seg, 0x000f, memoryAGet16(0x1617 + seg, 0x000f) + seg); // 1874 -> 1a61; lin=1617f
        memoryASet16(0x1618 + seg, 0x000e, memoryAGet16(0x1618 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1618e
        memoryASet16(0x1625 + seg, 0x000d, memoryAGet16(0x1625 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1625d
        memoryASet16(0x1628 + seg, 0x000a, memoryAGet16(0x1628 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1628a
        memoryASet16(0x162f + seg, 0x0009, memoryAGet16(0x162f + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=162f9
        memoryASet16(0x1632 + seg, 0x0008, memoryAGet16(0x1632 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=16328
        memoryASet16(0x1633 + seg, 0x0001, memoryAGet16(0x1633 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=16331
        memoryASet16(0x1634 + seg, 0x0009, memoryAGet16(0x1634 + seg, 0x0009) + seg); // 1e0a -> 1ff7; lin=16349
        memoryASet16(0x163a + seg, 0x0004, memoryAGet16(0x163a + seg, 0x0004) + seg); // 037d -> 056a; lin=163a4
        memoryASet16(0x163d + seg, 0x0001, memoryAGet16(0x163d + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=163d1
        memoryASet16(0x163e + seg, 0x0006, memoryAGet16(0x163e + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=163e6
        memoryASet16(0x1642 + seg, 0x0001, memoryAGet16(0x1642 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=16421
        memoryASet16(0x1644 + seg, 0x0005, memoryAGet16(0x1644 + seg, 0x0005) + seg); // 1460 -> 164d; lin=16445
        memoryASet16(0x1644 + seg, 0x000e, memoryAGet16(0x1644 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1644e
        memoryASet16(0x164b + seg, 0x000e, memoryAGet16(0x164b + seg, 0x000e) + seg); // 0000 -> 01ed; lin=164be
        memoryASet16(0x1653 + seg, 0x000c, memoryAGet16(0x1653 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1653c
        memoryASet16(0x166d + seg, 0x000c, memoryAGet16(0x166d + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=166dc
        memoryASet16(0x1674 + seg, 0x000a, memoryAGet16(0x1674 + seg, 0x000a) + seg); // 037d -> 056a; lin=1674a
        memoryASet16(0x1686 + seg, 0x000e, memoryAGet16(0x1686 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=1686e
        memoryASet16(0x168c + seg, 0x0003, memoryAGet16(0x168c + seg, 0x0003) + seg); // 2a3a -> 2c27; lin=168c3
        memoryASet16(0x1690 + seg, 0x0003, memoryAGet16(0x1690 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=16903
        memoryASet16(0x1691 + seg, 0x0006, memoryAGet16(0x1691 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=16916
        memoryASet16(0x1692 + seg, 0x0006, memoryAGet16(0x1692 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=16926
        memoryASet16(0x1693 + seg, 0x0002, memoryAGet16(0x1693 + seg, 0x0002) + seg); // 037d -> 056a; lin=16932
        memoryASet16(0x1696 + seg, 0x000f, memoryAGet16(0x1696 + seg, 0x000f) + seg); // 037d -> 056a; lin=1696f
        memoryASet16(0x169c + seg, 0x000c, memoryAGet16(0x169c + seg, 0x000c) + seg); // 2a3a -> 2c27; lin=169cc
        memoryASet16(0x169f + seg, 0x000f, memoryAGet16(0x169f + seg, 0x000f) + seg); // 0000 -> 01ed; lin=169ff
        memoryASet16(0x16a1 + seg, 0x0000, memoryAGet16(0x16a1 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=16a10
        memoryASet16(0x16a2 + seg, 0x0000, memoryAGet16(0x16a2 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=16a20
        memoryASet16(0x16a2 + seg, 0x000c, memoryAGet16(0x16a2 + seg, 0x000c) + seg); // 037d -> 056a; lin=16a2c
        memoryASet16(0x16a8 + seg, 0x000b, memoryAGet16(0x16a8 + seg, 0x000b) + seg); // 2a3a -> 2c27; lin=16a8b
        memoryASet16(0x16ac + seg, 0x000b, memoryAGet16(0x16ac + seg, 0x000b) + seg); // 0000 -> 01ed; lin=16acb
        memoryASet16(0x16ad + seg, 0x000e, memoryAGet16(0x16ad + seg, 0x000e) + seg); // 0000 -> 01ed; lin=16ade
        memoryASet16(0x16ae + seg, 0x000e, memoryAGet16(0x16ae + seg, 0x000e) + seg); // 0000 -> 01ed; lin=16aee
        memoryASet16(0x16af + seg, 0x000a, memoryAGet16(0x16af + seg, 0x000a) + seg); // 037d -> 056a; lin=16afa
        memoryASet16(0x16b4 + seg, 0x0000, memoryAGet16(0x16b4 + seg, 0x0000) + seg); // 037d -> 056a; lin=16b40
        memoryASet16(0x16b9 + seg, 0x000d, memoryAGet16(0x16b9 + seg, 0x000d) + seg); // 2a3a -> 2c27; lin=16b9d
        memoryASet16(0x16bd + seg, 0x0000, memoryAGet16(0x16bd + seg, 0x0000) + seg); // 0000 -> 01ed; lin=16bd0
        memoryASet16(0x16be + seg, 0x0001, memoryAGet16(0x16be + seg, 0x0001) + seg); // 0000 -> 01ed; lin=16be1
        memoryASet16(0x16bf + seg, 0x0001, memoryAGet16(0x16bf + seg, 0x0001) + seg); // 0000 -> 01ed; lin=16bf1
        memoryASet16(0x16bf + seg, 0x000d, memoryAGet16(0x16bf + seg, 0x000d) + seg); // 037d -> 056a; lin=16bfd
        memoryASet16(0x16ca + seg, 0x0007, memoryAGet16(0x16ca + seg, 0x0007) + seg); // 037d -> 056a; lin=16ca7
        memoryASet16(0x16d4 + seg, 0x0000, memoryAGet16(0x16d4 + seg, 0x0000) + seg); // 037d -> 056a; lin=16d40
        memoryASet16(0x16f3 + seg, 0x000f, memoryAGet16(0x16f3 + seg, 0x000f) + seg); // 037d -> 056a; lin=16f3f
        memoryASet16(0x16f5 + seg, 0x0007, memoryAGet16(0x16f5 + seg, 0x0007) + seg); // 1826 -> 1a13; lin=16f57
        memoryASet16(0x16fb + seg, 0x0000, memoryAGet16(0x16fb + seg, 0x0000) + seg); // 0000 -> 01ed; lin=16fb0
        memoryASet16(0x1707 + seg, 0x0001, memoryAGet16(0x1707 + seg, 0x0001) + seg); // 037d -> 056a; lin=17071
        memoryASet16(0x1709 + seg, 0x000a, memoryAGet16(0x1709 + seg, 0x000a) + seg); // 037d -> 056a; lin=1709a
        memoryASet16(0x1725 + seg, 0x0007, memoryAGet16(0x1725 + seg, 0x0007) + seg); // 037d -> 056a; lin=17257
        memoryASet16(0x1726 + seg, 0x0004, memoryAGet16(0x1726 + seg, 0x0004) + seg); // 1826 -> 1a13; lin=17264
        memoryASet16(0x1740 + seg, 0x000e, memoryAGet16(0x1740 + seg, 0x000e) + seg); // 1826 -> 1a13; lin=1740e
        memoryASet16(0x1752 + seg, 0x000d, memoryAGet16(0x1752 + seg, 0x000d) + seg); // 1826 -> 1a13; lin=1752d
        memoryASet16(0x176c + seg, 0x0009, memoryAGet16(0x176c + seg, 0x0009) + seg); // 0000 -> 01ed; lin=176c9
        memoryASet16(0x176e + seg, 0x0002, memoryAGet16(0x176e + seg, 0x0002) + seg); // 0000 -> 01ed; lin=176e2
        memoryASet16(0x1774 + seg, 0x0009, memoryAGet16(0x1774 + seg, 0x0009) + seg); // 1826 -> 1a13; lin=17749
        memoryASet16(0x178c + seg, 0x0008, memoryAGet16(0x178c + seg, 0x0008) + seg); // 1826 -> 1a13; lin=178c8
        memoryASet16(0x17a1 + seg, 0x0005, memoryAGet16(0x17a1 + seg, 0x0005) + seg); // 1e0a -> 1ff7; lin=17a15
        memoryASet16(0x17a3 + seg, 0x0002, memoryAGet16(0x17a3 + seg, 0x0002) + seg); // 1e0a -> 1ff7; lin=17a32
        memoryASet16(0x17bd + seg, 0x0003, memoryAGet16(0x17bd + seg, 0x0003) + seg); // 0000 -> 01ed; lin=17bd3
        memoryASet16(0x17bf + seg, 0x0000, memoryAGet16(0x17bf + seg, 0x0000) + seg); // 0000 -> 01ed; lin=17bf0
        memoryASet16(0x17c2 + seg, 0x0001, memoryAGet16(0x17c2 + seg, 0x0001) + seg); // 037d -> 056a; lin=17c21
        memoryASet16(0x17c9 + seg, 0x0002, memoryAGet16(0x17c9 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=17c92
        memoryASet16(0x17ca + seg, 0x0005, memoryAGet16(0x17ca + seg, 0x0005) + seg); // 0000 -> 01ed; lin=17ca5
        memoryASet16(0x17cb + seg, 0x0005, memoryAGet16(0x17cb + seg, 0x0005) + seg); // 0000 -> 01ed; lin=17cb5
        memoryASet16(0x17cc + seg, 0x0001, memoryAGet16(0x17cc + seg, 0x0001) + seg); // 037d -> 056a; lin=17cc1
        memoryASet16(0x17dd + seg, 0x0000, memoryAGet16(0x17dd + seg, 0x0000) + seg); // 0000 -> 01ed; lin=17dd0
        memoryASet16(0x17de + seg, 0x000d, memoryAGet16(0x17de + seg, 0x000d) + seg); // 0000 -> 01ed; lin=17ded
        memoryASet16(0x17f0 + seg, 0x0006, memoryAGet16(0x17f0 + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=17f06
        memoryASet16(0x17fc + seg, 0x0007, memoryAGet16(0x17fc + seg, 0x0007) + seg); // 1826 -> 1a13; lin=17fc7
        memoryASet16(0x1816 + seg, 0x0003, memoryAGet16(0x1816 + seg, 0x0003) + seg); // 1e0a -> 1ff7; lin=18163
        memoryASet16(0x1818 + seg, 0x0005, memoryAGet16(0x1818 + seg, 0x0005) + seg); // 1e0a -> 1ff7; lin=18185
        memoryASet16(0x181d + seg, 0x000b, memoryAGet16(0x181d + seg, 0x000b) + seg); // 1826 -> 1a13; lin=181db
        memoryASet16(0x1820 + seg, 0x000e, memoryAGet16(0x1820 + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=1820e
        memoryASet16(0x1843 + seg, 0x000f, memoryAGet16(0x1843 + seg, 0x000f) + seg); // 2ee7 -> 30d4; lin=1843f
        memoryASet16(0x1878 + seg, 0x0007, memoryAGet16(0x1878 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=18787
        memoryASet16(0x1879 + seg, 0x000d, memoryAGet16(0x1879 + seg, 0x000d) + seg); // 2ee7 -> 30d4; lin=1879d
        memoryASet16(0x18a7 + seg, 0x000f, memoryAGet16(0x18a7 + seg, 0x000f) + seg); // 037d -> 056a; lin=18a7f
        memoryASet16(0x18d3 + seg, 0x000f, memoryAGet16(0x18d3 + seg, 0x000f) + seg); // 2ee7 -> 30d4; lin=18d3f
        memoryASet16(0x18f9 + seg, 0x000b, memoryAGet16(0x18f9 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=18f9b
        memoryASet16(0x18fd + seg, 0x0000, memoryAGet16(0x18fd + seg, 0x0000) + seg); // 0000 -> 01ed; lin=18fd0
        memoryASet16(0x18fd + seg, 0x000d, memoryAGet16(0x18fd + seg, 0x000d) + seg); // 1874 -> 1a61; lin=18fdd
        memoryASet16(0x18fe + seg, 0x000b, memoryAGet16(0x18fe + seg, 0x000b) + seg); // 0000 -> 01ed; lin=18feb
        memoryASet16(0x1911 + seg, 0x0001, memoryAGet16(0x1911 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=19111
        memoryASet16(0x1916 + seg, 0x0008, memoryAGet16(0x1916 + seg, 0x0008) + seg); // 037d -> 056a; lin=19168
        memoryASet16(0x1918 + seg, 0x0000, memoryAGet16(0x1918 + seg, 0x0000) + seg); // 037d -> 056a; lin=19180
        memoryASet16(0x193c + seg, 0x0000, memoryAGet16(0x193c + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=193c0
        memoryASet16(0x193c + seg, 0x0005, memoryAGet16(0x193c + seg, 0x0005) + seg); // 1460 -> 164d; lin=193c5
        memoryASet16(0x193c + seg, 0x000b, memoryAGet16(0x193c + seg, 0x000b) + seg); // 1460 -> 164d; lin=193cb
        memoryASet16(0x1940 + seg, 0x0001, memoryAGet16(0x1940 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=19401
        memoryASet16(0x1942 + seg, 0x0001, memoryAGet16(0x1942 + seg, 0x0001) + seg); // 037d -> 056a; lin=19421
        memoryASet16(0x1942 + seg, 0x000f, memoryAGet16(0x1942 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1942f
        memoryASet16(0x1944 + seg, 0x0006, memoryAGet16(0x1944 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=19446
        memoryASet16(0x194a + seg, 0x0003, memoryAGet16(0x194a + seg, 0x0003) + seg); // 0000 -> 01ed; lin=194a3
        memoryASet16(0x194b + seg, 0x000e, memoryAGet16(0x194b + seg, 0x000e) + seg); // 0000 -> 01ed; lin=194be
        memoryASet16(0x194c + seg, 0x000f, memoryAGet16(0x194c + seg, 0x000f) + seg); // 0000 -> 01ed; lin=194cf
        memoryASet16(0x194d + seg, 0x000f, memoryAGet16(0x194d + seg, 0x000f) + seg); // 0000 -> 01ed; lin=194df
        memoryASet16(0x194f + seg, 0x0002, memoryAGet16(0x194f + seg, 0x0002) + seg); // 0000 -> 01ed; lin=194f2
        memoryASet16(0x1950 + seg, 0x0006, memoryAGet16(0x1950 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=19506
        memoryASet16(0x1951 + seg, 0x0007, memoryAGet16(0x1951 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=19517
        memoryASet16(0x1952 + seg, 0x0008, memoryAGet16(0x1952 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=19528
        memoryASet16(0x1953 + seg, 0x0009, memoryAGet16(0x1953 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=19539
        memoryASet16(0x1954 + seg, 0x000a, memoryAGet16(0x1954 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1954a
        memoryASet16(0x1955 + seg, 0x000b, memoryAGet16(0x1955 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=1955b
        memoryASet16(0x1956 + seg, 0x000c, memoryAGet16(0x1956 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1956c
        memoryASet16(0x1957 + seg, 0x000d, memoryAGet16(0x1957 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1957d
        memoryASet16(0x1958 + seg, 0x000e, memoryAGet16(0x1958 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=1958e
        memoryASet16(0x1959 + seg, 0x000f, memoryAGet16(0x1959 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1959f
        memoryASet16(0x195b + seg, 0x0000, memoryAGet16(0x195b + seg, 0x0000) + seg); // 0000 -> 01ed; lin=195b0
        memoryASet16(0x195c + seg, 0x0001, memoryAGet16(0x195c + seg, 0x0001) + seg); // 0000 -> 01ed; lin=195c1
        memoryASet16(0x195d + seg, 0x0002, memoryAGet16(0x195d + seg, 0x0002) + seg); // 0000 -> 01ed; lin=195d2
        memoryASet16(0x195e + seg, 0x0003, memoryAGet16(0x195e + seg, 0x0003) + seg); // 0000 -> 01ed; lin=195e3
        memoryASet16(0x195e + seg, 0x000c, memoryAGet16(0x195e + seg, 0x000c) + seg); // 0000 -> 01ed; lin=195ec
        memoryASet16(0x1964 + seg, 0x0001, memoryAGet16(0x1964 + seg, 0x0001) + seg); // 1874 -> 1a61; lin=19641
        memoryASet16(0x1964 + seg, 0x000d, memoryAGet16(0x1964 + seg, 0x000d) + seg); // 1460 -> 164d; lin=1964d
        memoryASet16(0x1967 + seg, 0x0003, memoryAGet16(0x1967 + seg, 0x0003) + seg); // 0000 -> 01ed; lin=19673
        memoryASet16(0x1968 + seg, 0x000e, memoryAGet16(0x1968 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=1968e
        memoryASet16(0x1969 + seg, 0x000f, memoryAGet16(0x1969 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1969f
        memoryASet16(0x196b + seg, 0x0000, memoryAGet16(0x196b + seg, 0x0000) + seg); // 0000 -> 01ed; lin=196b0
        memoryASet16(0x196c + seg, 0x0001, memoryAGet16(0x196c + seg, 0x0001) + seg); // 0000 -> 01ed; lin=196c1
        memoryASet16(0x196d + seg, 0x0002, memoryAGet16(0x196d + seg, 0x0002) + seg); // 0000 -> 01ed; lin=196d2
        memoryASet16(0x196e + seg, 0x0003, memoryAGet16(0x196e + seg, 0x0003) + seg); // 0000 -> 01ed; lin=196e3
        memoryASet16(0x196f + seg, 0x0004, memoryAGet16(0x196f + seg, 0x0004) + seg); // 0000 -> 01ed; lin=196f4
        memoryASet16(0x1970 + seg, 0x0005, memoryAGet16(0x1970 + seg, 0x0005) + seg); // 0000 -> 01ed; lin=19705
        memoryASet16(0x1971 + seg, 0x0006, memoryAGet16(0x1971 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=19716
        memoryASet16(0x1972 + seg, 0x0007, memoryAGet16(0x1972 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=19727
        memoryASet16(0x1973 + seg, 0x0008, memoryAGet16(0x1973 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=19738
        memoryASet16(0x1974 + seg, 0x0009, memoryAGet16(0x1974 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=19749
        memoryASet16(0x1975 + seg, 0x000a, memoryAGet16(0x1975 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1975a
        memoryASet16(0x1976 + seg, 0x000b, memoryAGet16(0x1976 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=1976b
        memoryASet16(0x1977 + seg, 0x000c, memoryAGet16(0x1977 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1977c
        memoryASet16(0x1978 + seg, 0x000d, memoryAGet16(0x1978 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1978d
        memoryASet16(0x1979 + seg, 0x0006, memoryAGet16(0x1979 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=19796
        memoryASet16(0x197c + seg, 0x000a, memoryAGet16(0x197c + seg, 0x000a) + seg); // 0000 -> 01ed; lin=197ca
        memoryASet16(0x197e + seg, 0x0002, memoryAGet16(0x197e + seg, 0x0002) + seg); // 0000 -> 01ed; lin=197e2
        memoryASet16(0x197f + seg, 0x0004, memoryAGet16(0x197f + seg, 0x0004) + seg); // 0000 -> 01ed; lin=197f4
        memoryASet16(0x1980 + seg, 0x000f, memoryAGet16(0x1980 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1980f
        memoryASet16(0x1982 + seg, 0x0009, memoryAGet16(0x1982 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=19829
        memoryASet16(0x1984 + seg, 0x0000, memoryAGet16(0x1984 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=19840
        memoryASet16(0x1986 + seg, 0x0003, memoryAGet16(0x1986 + seg, 0x0003) + seg); // 1931 -> 1b1e; lin=19863
        memoryASet16(0x1986 + seg, 0x000d, memoryAGet16(0x1986 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1986d
        memoryASet16(0x1987 + seg, 0x0009, memoryAGet16(0x1987 + seg, 0x0009) + seg); // 1d02 -> 1eef; lin=19879
        memoryASet16(0x1997 + seg, 0x000a, memoryAGet16(0x1997 + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1997a
        memoryASet16(0x1999 + seg, 0x0007, memoryAGet16(0x1999 + seg, 0x0007) + seg); // 0000 -> 01ed; lin=19997
        memoryASet16(0x19a4 + seg, 0x000f, memoryAGet16(0x19a4 + seg, 0x000f) + seg); // 1fe4 -> 21d1; lin=19a4f
        memoryASet16(0x19ab + seg, 0x0008, memoryAGet16(0x19ab + seg, 0x0008) + seg); // 1fe4 -> 21d1; lin=19ab8
        memoryASet16(0x19ac + seg, 0x0009, memoryAGet16(0x19ac + seg, 0x0009) + seg); // 0000 -> 01ed; lin=19ac9
        memoryASet16(0x19b0 + seg, 0x0000, memoryAGet16(0x19b0 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=19b00
        memoryASet16(0x19b6 + seg, 0x000e, memoryAGet16(0x19b6 + seg, 0x000e) + seg); // 1fe4 -> 21d1; lin=19b6e
        memoryASet16(0x19bd + seg, 0x000c, memoryAGet16(0x19bd + seg, 0x000c) + seg); // 0000 -> 01ed; lin=19bdc
        memoryASet16(0x19be + seg, 0x0005, memoryAGet16(0x19be + seg, 0x0005) + seg); // 0000 -> 01ed; lin=19be5
        memoryASet16(0x19dc + seg, 0x0005, memoryAGet16(0x19dc + seg, 0x0005) + seg); // 1fe4 -> 21d1; lin=19dc5
        memoryASet16(0x19e0 + seg, 0x0002, memoryAGet16(0x19e0 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=19e02
        memoryASet16(0x19e3 + seg, 0x000f, memoryAGet16(0x19e3 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=19e3f
        memoryASet16(0x19e8 + seg, 0x000c, memoryAGet16(0x19e8 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=19e8c
        memoryASet16(0x19ee + seg, 0x000f, memoryAGet16(0x19ee + seg, 0x000f) + seg); // 0000 -> 01ed; lin=19eef
        memoryASet16(0x19f6 + seg, 0x0005, memoryAGet16(0x19f6 + seg, 0x0005) + seg); // 1460 -> 164d; lin=19f65
        memoryASet16(0x19fb + seg, 0x000a, memoryAGet16(0x19fb + seg, 0x000a) + seg); // 1460 -> 164d; lin=19fba
        memoryASet16(0x19fd + seg, 0x000e, memoryAGet16(0x19fd + seg, 0x000e) + seg); // 1460 -> 164d; lin=19fde
        memoryASet16(0x1a09 + seg, 0x0009, memoryAGet16(0x1a09 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=1a099
        memoryASet16(0x1a0c + seg, 0x0001, memoryAGet16(0x1a0c + seg, 0x0001) + seg); // 0000 -> 01ed; lin=1a0c1
        memoryASet16(0x1a16 + seg, 0x0000, memoryAGet16(0x1a16 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=1a160
        memoryASet16(0x1a19 + seg, 0x000b, memoryAGet16(0x1a19 + seg, 0x000b) + seg); // 037d -> 056a; lin=1a19b
        memoryASet16(0x1a22 + seg, 0x000c, memoryAGet16(0x1a22 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=1a22c
        memoryASet16(0x1a2c + seg, 0x0008, memoryAGet16(0x1a2c + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1a2c8
        memoryASet16(0x1a2d + seg, 0x000d, memoryAGet16(0x1a2d + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=1a2dd
        memoryASet16(0x1a2f + seg, 0x0005, memoryAGet16(0x1a2f + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=1a2f5
        memoryASet16(0x1a30 + seg, 0x0008, memoryAGet16(0x1a30 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1a308
        memoryASet16(0x1a32 + seg, 0x0006, memoryAGet16(0x1a32 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=1a326
        memoryASet16(0x1a33 + seg, 0x0009, memoryAGet16(0x1a33 + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=1a339
        memoryASet16(0x1a35 + seg, 0x0002, memoryAGet16(0x1a35 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=1a352
        memoryASet16(0x1a36 + seg, 0x0006, memoryAGet16(0x1a36 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=1a366
        memoryASet16(0x1a3d + seg, 0x0008, memoryAGet16(0x1a3d + seg, 0x0008) + seg); // 155e -> 174b; lin=1a3d8
        memoryASet16(0x1a3f + seg, 0x000e, memoryAGet16(0x1a3f + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=1a3fe
        memoryASet16(0x1a45 + seg, 0x0002, memoryAGet16(0x1a45 + seg, 0x0002) + seg); // 1e0a -> 1ff7; lin=1a452
        memoryASet16(0x1a45 + seg, 0x000b, memoryAGet16(0x1a45 + seg, 0x000b) + seg); // 155e -> 174b; lin=1a45b
        memoryASet16(0x1a4d + seg, 0x0005, memoryAGet16(0x1a4d + seg, 0x0005) + seg); // 0000 -> 01ed; lin=1a4d5
        memoryASet16(0x1a52 + seg, 0x0001, memoryAGet16(0x1a52 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=1a521
        memoryASet16(0x1a53 + seg, 0x0004, memoryAGet16(0x1a53 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=1a534
        memoryASet16(0x1a54 + seg, 0x000d, memoryAGet16(0x1a54 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1a54d
        memoryASet16(0x1a64 + seg, 0x0006, memoryAGet16(0x1a64 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=1a646
        memoryASet16(0x1a66 + seg, 0x0004, memoryAGet16(0x1a66 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=1a664
        memoryASet16(0x1a6a + seg, 0x0008, memoryAGet16(0x1a6a + seg, 0x0008) + seg); // 0000 -> 01ed; lin=1a6a8
        memoryASet16(0x1a6d + seg, 0x000a, memoryAGet16(0x1a6d + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1a6da
        memoryASet16(0x1a70 + seg, 0x0001, memoryAGet16(0x1a70 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=1a701
        memoryASet16(0x1a7a + seg, 0x0001, memoryAGet16(0x1a7a + seg, 0x0001) + seg); // 0000 -> 01ed; lin=1a7a1
        memoryASet16(0x1a82 + seg, 0x000c, memoryAGet16(0x1a82 + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=1a82c
        memoryASet16(0x1a87 + seg, 0x0002, memoryAGet16(0x1a87 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=1a872
        memoryASet16(0x1a87 + seg, 0x0007, memoryAGet16(0x1a87 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1a877
        memoryASet16(0x1a87 + seg, 0x000c, memoryAGet16(0x1a87 + seg, 0x000c) + seg); // 1460 -> 164d; lin=1a87c
        memoryASet16(0x1a89 + seg, 0x000f, memoryAGet16(0x1a89 + seg, 0x000f) + seg); // 1fd8 -> 21c5; lin=1a89f
        memoryASet16(0x1a99 + seg, 0x0007, memoryAGet16(0x1a99 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1a997
        memoryASet16(0x1a9d + seg, 0x000d, memoryAGet16(0x1a9d + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=1a9dd
        memoryASet16(0x1aad + seg, 0x0003, memoryAGet16(0x1aad + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=1aad3
        memoryASet16(0x1ab2 + seg, 0x0006, memoryAGet16(0x1ab2 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=1ab26
        memoryASet16(0x1ab3 + seg, 0x000e, memoryAGet16(0x1ab3 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1ab3e
        memoryASet16(0x1ac1 + seg, 0x0001, memoryAGet16(0x1ac1 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=1ac11
        memoryASet16(0x1ac1 + seg, 0x000d, memoryAGet16(0x1ac1 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=1ac1d
        memoryASet16(0x1ac3 + seg, 0x000b, memoryAGet16(0x1ac3 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=1ac3b
        memoryASet16(0x1ac6 + seg, 0x000f, memoryAGet16(0x1ac6 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1ac6f
        memoryASet16(0x1ac8 + seg, 0x000a, memoryAGet16(0x1ac8 + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=1ac8a
        memoryASet16(0x1aca + seg, 0x0008, memoryAGet16(0x1aca + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1aca8
        memoryASet16(0x1acc + seg, 0x0003, memoryAGet16(0x1acc + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=1acc3
        memoryASet16(0x1ace + seg, 0x0001, memoryAGet16(0x1ace + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=1ace1
        memoryASet16(0x1ad0 + seg, 0x0000, memoryAGet16(0x1ad0 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=1ad00
        memoryASet16(0x1ad0 + seg, 0x000f, memoryAGet16(0x1ad0 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1ad0f
        memoryASet16(0x1ad1 + seg, 0x000f, memoryAGet16(0x1ad1 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1ad1f
        memoryASet16(0x1adb + seg, 0x000e, memoryAGet16(0x1adb + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1adbe
        memoryASet16(0x1aeb + seg, 0x000a, memoryAGet16(0x1aeb + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=1aeba
        memoryASet16(0x1af0 + seg, 0x000d, memoryAGet16(0x1af0 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=1af0d
        memoryASet16(0x1af1 + seg, 0x0002, memoryAGet16(0x1af1 + seg, 0x0002) + seg); // 1460 -> 164d; lin=1af12
        memoryASet16(0x1af1 + seg, 0x000b, memoryAGet16(0x1af1 + seg, 0x000b) + seg); // 1460 -> 164d; lin=1af1b
        memoryASet16(0x1af4 + seg, 0x000b, memoryAGet16(0x1af4 + seg, 0x000b) + seg); // 1460 -> 164d; lin=1af4b
        memoryASet16(0x1af5 + seg, 0x000f, memoryAGet16(0x1af5 + seg, 0x000f) + seg); // 1460 -> 164d; lin=1af5f
        memoryASet16(0x1af8 + seg, 0x000d, memoryAGet16(0x1af8 + seg, 0x000d) + seg); // 037d -> 056a; lin=1af8d
        memoryASet16(0x1b06 + seg, 0x0009, memoryAGet16(0x1b06 + seg, 0x0009) + seg); // 0000 -> 01ed; lin=1b069
        memoryASet16(0x1b07 + seg, 0x000d, memoryAGet16(0x1b07 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1b07d
        memoryASet16(0x1b09 + seg, 0x0004, memoryAGet16(0x1b09 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=1b094
        memoryASet16(0x1b0a + seg, 0x000b, memoryAGet16(0x1b0a + seg, 0x000b) + seg); // 0000 -> 01ed; lin=1b0ab
        memoryASet16(0x1b0c + seg, 0x0001, memoryAGet16(0x1b0c + seg, 0x0001) + seg); // 0000 -> 01ed; lin=1b0c1
        memoryASet16(0x1b0c + seg, 0x0009, memoryAGet16(0x1b0c + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=1b0c9
        memoryASet16(0x1b0e + seg, 0x0000, memoryAGet16(0x1b0e + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b0e0
        memoryASet16(0x1b0e + seg, 0x0005, memoryAGet16(0x1b0e + seg, 0x0005) + seg); // 1460 -> 164d; lin=1b0e5
        memoryASet16(0x1b0e + seg, 0x000a, memoryAGet16(0x1b0e + seg, 0x000a) + seg); // 1460 -> 164d; lin=1b0ea
        memoryASet16(0x1b0e + seg, 0x000f, memoryAGet16(0x1b0e + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1b0ef
        memoryASet16(0x1b0f + seg, 0x0004, memoryAGet16(0x1b0f + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=1b0f4
        memoryASet16(0x1b10 + seg, 0x000e, memoryAGet16(0x1b10 + seg, 0x000e) + seg); // 1faa -> 2197; lin=1b10e
        memoryASet16(0x1b12 + seg, 0x0006, memoryAGet16(0x1b12 + seg, 0x0006) + seg); // 1faa -> 2197; lin=1b126
        memoryASet16(0x1b13 + seg, 0x000e, memoryAGet16(0x1b13 + seg, 0x000e) + seg); // 1faa -> 2197; lin=1b13e
        memoryASet16(0x1b15 + seg, 0x0006, memoryAGet16(0x1b15 + seg, 0x0006) + seg); // 1faa -> 2197; lin=1b156
        memoryASet16(0x1b15 + seg, 0x000f, memoryAGet16(0x1b15 + seg, 0x000f) + seg); // 1fbd -> 21aa; lin=1b15f
        memoryASet16(0x1b17 + seg, 0x0009, memoryAGet16(0x1b17 + seg, 0x0009) + seg); // 1fcc -> 21b9; lin=1b179
        memoryASet16(0x1b19 + seg, 0x0002, memoryAGet16(0x1b19 + seg, 0x0002) + seg); // 1fcc -> 21b9; lin=1b192
        memoryASet16(0x1b1a + seg, 0x000c, memoryAGet16(0x1b1a + seg, 0x000c) + seg); // 1fcc -> 21b9; lin=1b1ac
        memoryASet16(0x1b37 + seg, 0x000b, memoryAGet16(0x1b37 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=1b37b
        memoryASet16(0x1b3a + seg, 0x0000, memoryAGet16(0x1b3a + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b3a0
        memoryASet16(0x1b3b + seg, 0x000f, memoryAGet16(0x1b3b + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1b3bf
        memoryASet16(0x1b3c + seg, 0x0007, memoryAGet16(0x1b3c + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1b3c7
        memoryASet16(0x1b3e + seg, 0x0003, memoryAGet16(0x1b3e + seg, 0x0003) + seg); // 1460 -> 164d; lin=1b3e3
        memoryASet16(0x1b3f + seg, 0x0001, memoryAGet16(0x1b3f + seg, 0x0001) + seg); // 1460 -> 164d; lin=1b3f1
        memoryASet16(0x1b47 + seg, 0x0009, memoryAGet16(0x1b47 + seg, 0x0009) + seg); // 1460 -> 164d; lin=1b479
        memoryASet16(0x1b4a + seg, 0x0009, memoryAGet16(0x1b4a + seg, 0x0009) + seg); // 1fb1 -> 219e; lin=1b4a9
        memoryASet16(0x1b4c + seg, 0x000c, memoryAGet16(0x1b4c + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1b4cc
        memoryASet16(0x1b4e + seg, 0x000a, memoryAGet16(0x1b4e + seg, 0x000a) + seg); // 0000 -> 01ed; lin=1b4ea
        memoryASet16(0x1b52 + seg, 0x0005, memoryAGet16(0x1b52 + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=1b525
        memoryASet16(0x1b58 + seg, 0x000f, memoryAGet16(0x1b58 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1b58f
        memoryASet16(0x1b5b + seg, 0x0004, memoryAGet16(0x1b5b + seg, 0x0004) + seg); // 1d06 -> 1ef3; lin=1b5b4
        memoryASet16(0x1b5d + seg, 0x000d, memoryAGet16(0x1b5d + seg, 0x000d) + seg); // 1460 -> 164d; lin=1b5dd
        memoryASet16(0x1b66 + seg, 0x0007, memoryAGet16(0x1b66 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1b667
        memoryASet16(0x1b6d + seg, 0x0001, memoryAGet16(0x1b6d + seg, 0x0001) + seg); // 1460 -> 164d; lin=1b6d1
        memoryASet16(0x1b72 + seg, 0x0000, memoryAGet16(0x1b72 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b720
        memoryASet16(0x1b72 + seg, 0x0008, memoryAGet16(0x1b72 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1b728
        memoryASet16(0x1b73 + seg, 0x000d, memoryAGet16(0x1b73 + seg, 0x000d) + seg); // 1460 -> 164d; lin=1b73d
        memoryASet16(0x1b75 + seg, 0x0008, memoryAGet16(0x1b75 + seg, 0x0008) + seg); // 1460 -> 164d; lin=1b758
        memoryASet16(0x1b79 + seg, 0x0000, memoryAGet16(0x1b79 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b790
        memoryASet16(0x1b7b + seg, 0x0007, memoryAGet16(0x1b7b + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1b7b7
        memoryASet16(0x1b7c + seg, 0x000f, memoryAGet16(0x1b7c + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1b7cf
        memoryASet16(0x1b7e + seg, 0x0007, memoryAGet16(0x1b7e + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1b7e7
        memoryASet16(0x1b7e + seg, 0x000f, memoryAGet16(0x1b7e + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1b7ef
        memoryASet16(0x1b84 + seg, 0x0000, memoryAGet16(0x1b84 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b840
        memoryASet16(0x1b85 + seg, 0x0008, memoryAGet16(0x1b85 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1b858
        memoryASet16(0x1b87 + seg, 0x0000, memoryAGet16(0x1b87 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b870
        memoryASet16(0x1b88 + seg, 0x0008, memoryAGet16(0x1b88 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1b888
        memoryASet16(0x1b89 + seg, 0x0000, memoryAGet16(0x1b89 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1b890
        memoryASet16(0x1b8c + seg, 0x0006, memoryAGet16(0x1b8c + seg, 0x0006) + seg); // 1460 -> 164d; lin=1b8c6
        memoryASet16(0x1b8e + seg, 0x000f, memoryAGet16(0x1b8e + seg, 0x000f) + seg); // 1460 -> 164d; lin=1b8ef
        memoryASet16(0x1b99 + seg, 0x000d, memoryAGet16(0x1b99 + seg, 0x000d) + seg); // 1d06 -> 1ef3; lin=1b99d
        memoryASet16(0x1ba9 + seg, 0x000e, memoryAGet16(0x1ba9 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1ba9e
        memoryASet16(0x1bae + seg, 0x0007, memoryAGet16(0x1bae + seg, 0x0007) + seg); // 1460 -> 164d; lin=1bae7
        memoryASet16(0x1bba + seg, 0x0000, memoryAGet16(0x1bba + seg, 0x0000) + seg); // 1460 -> 164d; lin=1bba0
        memoryASet16(0x1bc0 + seg, 0x0009, memoryAGet16(0x1bc0 + seg, 0x0009) + seg); // 1460 -> 164d; lin=1bc09
        memoryASet16(0x1bc4 + seg, 0x000d, memoryAGet16(0x1bc4 + seg, 0x000d) + seg); // 0000 -> 01ed; lin=1bc4d
        memoryASet16(0x1bc5 + seg, 0x000b, memoryAGet16(0x1bc5 + seg, 0x000b) + seg); // 0000 -> 01ed; lin=1bc5b
        memoryASet16(0x1bc9 + seg, 0x0009, memoryAGet16(0x1bc9 + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=1bc99
        memoryASet16(0x1bcb + seg, 0x0009, memoryAGet16(0x1bcb + seg, 0x0009) + seg); // 1d06 -> 1ef3; lin=1bcb9
        memoryASet16(0x1bcd + seg, 0x0005, memoryAGet16(0x1bcd + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=1bcd5
        memoryASet16(0x1bcf + seg, 0x0005, memoryAGet16(0x1bcf + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=1bcf5
        memoryASet16(0x1bd2 + seg, 0x000e, memoryAGet16(0x1bd2 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=1bd2e
        memoryASet16(0x1bd5 + seg, 0x0004, memoryAGet16(0x1bd5 + seg, 0x0004) + seg); // 1931 -> 1b1e; lin=1bd54
        memoryASet16(0x1bd6 + seg, 0x0006, memoryAGet16(0x1bd6 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=1bd66
        memoryASet16(0x1bd7 + seg, 0x000e, memoryAGet16(0x1bd7 + seg, 0x000e) + seg); // 0000 -> 01ed; lin=1bd7e
        memoryASet16(0x1bdc + seg, 0x0003, memoryAGet16(0x1bdc + seg, 0x0003) + seg); // 0000 -> 01ed; lin=1bdc3
        memoryASet16(0x1be3 + seg, 0x0001, memoryAGet16(0x1be3 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=1be31
        memoryASet16(0x1be3 + seg, 0x000d, memoryAGet16(0x1be3 + seg, 0x000d) + seg); // 1931 -> 1b1e; lin=1be3d
        memoryASet16(0x1be5 + seg, 0x000b, memoryAGet16(0x1be5 + seg, 0x000b) + seg); // 1f99 -> 2186; lin=1be5b
        memoryASet16(0x1be7 + seg, 0x0001, memoryAGet16(0x1be7 + seg, 0x0001) + seg); // 1f99 -> 2186; lin=1be71
        memoryASet16(0x1bec + seg, 0x0006, memoryAGet16(0x1bec + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=1bec6
        memoryASet16(0x1bee + seg, 0x0002, memoryAGet16(0x1bee + seg, 0x0002) + seg); // 0000 -> 01ed; lin=1bee2
        memoryASet16(0x1bf9 + seg, 0x000c, memoryAGet16(0x1bf9 + seg, 0x000c) + seg); // 0000 -> 01ed; lin=1bf9c
        memoryASet16(0x1bfd + seg, 0x0000, memoryAGet16(0x1bfd + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1bfd0
        memoryASet16(0x1c01 + seg, 0x0002, memoryAGet16(0x1c01 + seg, 0x0002) + seg); // 1931 -> 1b1e; lin=1c012
        memoryASet16(0x1c02 + seg, 0x0002, memoryAGet16(0x1c02 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=1c022
        memoryASet16(0x1c03 + seg, 0x0008, memoryAGet16(0x1c03 + seg, 0x0008) + seg); // 0000 -> 01ed; lin=1c038
        memoryASet16(0x1c05 + seg, 0x000b, memoryAGet16(0x1c05 + seg, 0x000b) + seg); // 1931 -> 1b1e; lin=1c05b
        memoryASet16(0x1c07 + seg, 0x0006, memoryAGet16(0x1c07 + seg, 0x0006) + seg); // 0000 -> 01ed; lin=1c076
        memoryASet16(0x1c08 + seg, 0x000f, memoryAGet16(0x1c08 + seg, 0x000f) + seg); // 0000 -> 01ed; lin=1c08f
        memoryASet16(0x1c0e + seg, 0x0004, memoryAGet16(0x1c0e + seg, 0x0004) + seg); // 0000 -> 01ed; lin=1c0e4
        memoryASet16(0x1c11 + seg, 0x0001, memoryAGet16(0x1c11 + seg, 0x0001) + seg); // 0000 -> 01ed; lin=1c111
        memoryASet16(0x1c15 + seg, 0x0002, memoryAGet16(0x1c15 + seg, 0x0002) + seg); // 0000 -> 01ed; lin=1c152
        memoryASet16(0x1c15 + seg, 0x000e, memoryAGet16(0x1c15 + seg, 0x000e) + seg); // 1931 -> 1b1e; lin=1c15e
        memoryASet16(0x1c16 + seg, 0x000c, memoryAGet16(0x1c16 + seg, 0x000c) + seg); // 1f99 -> 2186; lin=1c16c
        memoryASet16(0x1c1d + seg, 0x0008, memoryAGet16(0x1c1d + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1c1d8
        memoryASet16(0x1c1f + seg, 0x0008, memoryAGet16(0x1c1f + seg, 0x0008) + seg); // 1931 -> 1b1e; lin=1c1f8
        memoryASet16(0x1c21 + seg, 0x000a, memoryAGet16(0x1c21 + seg, 0x000a) + seg); // 1d06 -> 1ef3; lin=1c21a
        memoryASet16(0x1c23 + seg, 0x000a, memoryAGet16(0x1c23 + seg, 0x000a) + seg); // 1931 -> 1b1e; lin=1c23a
        memoryASet16(0x1c2f + seg, 0x000a, memoryAGet16(0x1c2f + seg, 0x000a) + seg); // 1460 -> 164d; lin=1c2fa
        memoryASet16(0x1c36 + seg, 0x0001, memoryAGet16(0x1c36 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=1c361
        memoryASet16(0x1c38 + seg, 0x000f, memoryAGet16(0x1c38 + seg, 0x000f) + seg); // 1d02 -> 1eef; lin=1c38f
        memoryASet16(0x1c3d + seg, 0x000f, memoryAGet16(0x1c3d + seg, 0x000f) + seg); // 1d02 -> 1eef; lin=1c3df
        memoryASet16(0x1c43 + seg, 0x0006, memoryAGet16(0x1c43 + seg, 0x0006) + seg); // 1874 -> 1a61; lin=1c436
        memoryASet16(0x1c46 + seg, 0x000b, memoryAGet16(0x1c46 + seg, 0x000b) + seg); // 1874 -> 1a61; lin=1c46b
        memoryASet16(0x1c4c + seg, 0x0001, memoryAGet16(0x1c4c + seg, 0x0001) + seg); // 1874 -> 1a61; lin=1c4c1
        memoryASet16(0x1c54 + seg, 0x0008, memoryAGet16(0x1c54 + seg, 0x0008) + seg); // 1874 -> 1a61; lin=1c548
        memoryASet16(0x1c5a + seg, 0x0002, memoryAGet16(0x1c5a + seg, 0x0002) + seg); // 1874 -> 1a61; lin=1c5a2
        memoryASet16(0x1c60 + seg, 0x000b, memoryAGet16(0x1c60 + seg, 0x000b) + seg); // 1d06 -> 1ef3; lin=1c60b
        memoryASet16(0x1c62 + seg, 0x000f, memoryAGet16(0x1c62 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1c62f
        memoryASet16(0x1c64 + seg, 0x000e, memoryAGet16(0x1c64 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1c64e
        memoryASet16(0x1c66 + seg, 0x0007, memoryAGet16(0x1c66 + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1c667
        memoryASet16(0x1c68 + seg, 0x0006, memoryAGet16(0x1c68 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=1c686
        memoryASet16(0x1c69 + seg, 0x000f, memoryAGet16(0x1c69 + seg, 0x000f) + seg); // 1d06 -> 1ef3; lin=1c69f
        memoryASet16(0x1c6a + seg, 0x0007, memoryAGet16(0x1c6a + seg, 0x0007) + seg); // 1d06 -> 1ef3; lin=1c6a7
        memoryASet16(0x1c6b + seg, 0x000c, memoryAGet16(0x1c6b + seg, 0x000c) + seg); // 1460 -> 164d; lin=1c6bc
        memoryASet16(0x1c6d + seg, 0x000c, memoryAGet16(0x1c6d + seg, 0x000c) + seg); // 1d06 -> 1ef3; lin=1c6dc
        memoryASet16(0x1c6f + seg, 0x0000, memoryAGet16(0x1c6f + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1c6f0
        memoryASet16(0x1c70 + seg, 0x0008, memoryAGet16(0x1c70 + seg, 0x0008) + seg); // 1d06 -> 1ef3; lin=1c708
        memoryASet16(0x1c72 + seg, 0x0000, memoryAGet16(0x1c72 + seg, 0x0000) + seg); // 1d06 -> 1ef3; lin=1c720
        memoryASet16(0x1c9a + seg, 0x000a, memoryAGet16(0x1c9a + seg, 0x000a) + seg); // 037d -> 056a; lin=1c9aa
        memoryASet16(0x1ca6 + seg, 0x0008, memoryAGet16(0x1ca6 + seg, 0x0008) + seg); // 1874 -> 1a61; lin=1ca68
        memoryASet16(0x1cb0 + seg, 0x000f, memoryAGet16(0x1cb0 + seg, 0x000f) + seg); // 1f87 -> 2174; lin=1cb0f
        memoryASet16(0x1cb2 + seg, 0x0005, memoryAGet16(0x1cb2 + seg, 0x0005) + seg); // 1f8e -> 217b; lin=1cb25
        memoryASet16(0x1cb3 + seg, 0x000b, memoryAGet16(0x1cb3 + seg, 0x000b) + seg); // 1f87 -> 2174; lin=1cb3b
        memoryASet16(0x1cb4 + seg, 0x000e, memoryAGet16(0x1cb4 + seg, 0x000e) + seg); // 1f8e -> 217b; lin=1cb4e
        memoryASet16(0x1cb6 + seg, 0x0000, memoryAGet16(0x1cb6 + seg, 0x0000) + seg); // 1fcc -> 21b9; lin=1cb60
        memoryASet16(0x1cb7 + seg, 0x0002, memoryAGet16(0x1cb7 + seg, 0x0002) + seg); // 1fcc -> 21b9; lin=1cb72
        memoryASet16(0x1cb8 + seg, 0x000b, memoryAGet16(0x1cb8 + seg, 0x000b) + seg); // 1fcc -> 21b9; lin=1cb8b
        memoryASet16(0x1cba + seg, 0x0005, memoryAGet16(0x1cba + seg, 0x0005) + seg); // 1fd8 -> 21c5; lin=1cba5
        memoryASet16(0x1cbb + seg, 0x0005, memoryAGet16(0x1cbb + seg, 0x0005) + seg); // 1fd8 -> 21c5; lin=1cbb5
        memoryASet16(0x1cbd + seg, 0x0006, memoryAGet16(0x1cbd + seg, 0x0006) + seg); // 1fd8 -> 21c5; lin=1cbd6
        memoryASet16(0x1cbe + seg, 0x000c, memoryAGet16(0x1cbe + seg, 0x000c) + seg); // 12a6 -> 1493; lin=1cbec
        memoryASet16(0x1cbf + seg, 0x0004, memoryAGet16(0x1cbf + seg, 0x0004) + seg); // 2a3a -> 2c27; lin=1cbf4
        memoryASet16(0x1cc0 + seg, 0x000d, memoryAGet16(0x1cc0 + seg, 0x000d) + seg); // 2a3a -> 2c27; lin=1cc0d
        memoryASet16(0x1cc2 + seg, 0x0002, memoryAGet16(0x1cc2 + seg, 0x0002) + seg); // 2a3a -> 2c27; lin=1cc22
        memoryASet16(0x1cc3 + seg, 0x000d, memoryAGet16(0x1cc3 + seg, 0x000d) + seg); // 12a6 -> 1493; lin=1cc3d
        memoryASet16(0x1cc4 + seg, 0x0005, memoryAGet16(0x1cc4 + seg, 0x0005) + seg); // 12a6 -> 1493; lin=1cc45
        memoryASet16(0x1cc4 + seg, 0x000e, memoryAGet16(0x1cc4 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1cc4e
        memoryASet16(0x1cc5 + seg, 0x0006, memoryAGet16(0x1cc5 + seg, 0x0006) + seg); // 1d06 -> 1ef3; lin=1cc56
        memoryASet16(0x1cc6 + seg, 0x0000, memoryAGet16(0x1cc6 + seg, 0x0000) + seg); // 1931 -> 1b1e; lin=1cc60
        memoryASet16(0x1cc7 + seg, 0x0001, memoryAGet16(0x1cc7 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=1cc71
        memoryASet16(0x1cc7 + seg, 0x0009, memoryAGet16(0x1cc7 + seg, 0x0009) + seg); // 1654 -> 1841; lin=1cc79
        memoryASet16(0x1cc7 + seg, 0x000e, memoryAGet16(0x1cc7 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=1cc7e
        memoryASet16(0x1cc8 + seg, 0x0007, memoryAGet16(0x1cc8 + seg, 0x0007) + seg); // 1fd8 -> 21c5; lin=1cc87
        memoryASet16(0x1ccb + seg, 0x0001, memoryAGet16(0x1ccb + seg, 0x0001) + seg); // 1460 -> 164d; lin=1ccb1
        memoryASet16(0x1ccf + seg, 0x000a, memoryAGet16(0x1ccf + seg, 0x000a) + seg); // 037d -> 056a; lin=1ccfa
        memoryASet16(0x1cd1 + seg, 0x0005, memoryAGet16(0x1cd1 + seg, 0x0005) + seg); // 1f87 -> 2174; lin=1cd15
        memoryASet16(0x1cd4 + seg, 0x0003, memoryAGet16(0x1cd4 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=1cd43
        memoryASet16(0x1cd4 + seg, 0x0009, memoryAGet16(0x1cd4 + seg, 0x0009) + seg); // 1f8e -> 217b; lin=1cd49
        memoryASet16(0x1cd6 + seg, 0x0003, memoryAGet16(0x1cd6 + seg, 0x0003) + seg); // 1874 -> 1a61; lin=1cd63
        memoryASet16(0x1cdb + seg, 0x0006, memoryAGet16(0x1cdb + seg, 0x0006) + seg); // 037d -> 056a; lin=1cdb6
        memoryASet16(0x1cdc + seg, 0x0005, memoryAGet16(0x1cdc + seg, 0x0005) + seg); // 1931 -> 1b1e; lin=1cdc5
        memoryASet16(0x1cdd + seg, 0x0006, memoryAGet16(0x1cdd + seg, 0x0006) + seg); // 1931 -> 1b1e; lin=1cdd6
        memoryASet16(0x1cde + seg, 0x0003, memoryAGet16(0x1cde + seg, 0x0003) + seg); // 1d06 -> 1ef3; lin=1cde3
        memoryASet16(0x1cde + seg, 0x000b, memoryAGet16(0x1cde + seg, 0x000b) + seg); // 037d -> 056a; lin=1cdeb
        memoryASet16(0x1cdf + seg, 0x0003, memoryAGet16(0x1cdf + seg, 0x0003) + seg); // 1460 -> 164d; lin=1cdf3
        memoryASet16(0x1cdf + seg, 0x0008, memoryAGet16(0x1cdf + seg, 0x0008) + seg); // 1874 -> 1a61; lin=1cdf8
        memoryASet16(0x1ce0 + seg, 0x0001, memoryAGet16(0x1ce0 + seg, 0x0001) + seg); // 1d06 -> 1ef3; lin=1ce01
        memoryASet16(0x1ce0 + seg, 0x0009, memoryAGet16(0x1ce0 + seg, 0x0009) + seg); // 12a6 -> 1493; lin=1ce09
        memoryASet16(0x1ce0 + seg, 0x000e, memoryAGet16(0x1ce0 + seg, 0x000e) + seg); // 12a6 -> 1493; lin=1ce0e
        memoryASet16(0x1ce2 + seg, 0x000b, memoryAGet16(0x1ce2 + seg, 0x000b) + seg); // 1460 -> 164d; lin=1ce2b
        memoryASet16(0x1cec + seg, 0x0005, memoryAGet16(0x1cec + seg, 0x0005) + seg); // 1d06 -> 1ef3; lin=1cec5
        memoryASet16(0x1cf1 + seg, 0x000c, memoryAGet16(0x1cf1 + seg, 0x000c) + seg); // 0915 -> 0b02; lin=1cf1c
        memoryASet16(0x1cf9 + seg, 0x0000, memoryAGet16(0x1cf9 + seg, 0x0000) + seg); // 1460 -> 164d; lin=1cf90
        memoryASet16(0x1cf9 + seg, 0x000b, memoryAGet16(0x1cf9 + seg, 0x000b) + seg); // 1460 -> 164d; lin=1cf9b
        memoryASet16(0x1cfb + seg, 0x0003, memoryAGet16(0x1cfb + seg, 0x0003) + seg); // 1460 -> 164d; lin=1cfb3
        memoryASet16(0x1cfd + seg, 0x0004, memoryAGet16(0x1cfd + seg, 0x0004) + seg); // 1460 -> 164d; lin=1cfd4
        memoryASet16(0x1d02 + seg, 0x0008, memoryAGet16(0x1d02 + seg, 0x0008) + seg); // 1ed3 -> 20c0; lin=1d028
        memoryASet16(0x1d04 + seg, 0x000b, memoryAGet16(0x1d04 + seg, 0x000b) + seg); // 1ed3 -> 20c0; lin=1d04b
        memoryASet16(0x1d08 + seg, 0x0009, memoryAGet16(0x1d08 + seg, 0x0009) + seg); // 1931 -> 1b1e; lin=1d089
        memoryASet16(0x1d0b + seg, 0x0008, memoryAGet16(0x1d0b + seg, 0x0008) + seg); // 1e0a -> 1ff7; lin=1d0b8
        memoryASet16(0x1d0d + seg, 0x0008, memoryAGet16(0x1d0d + seg, 0x0008) + seg); // 037d -> 056a; lin=1d0d8
        memoryASet16(0x1d20 + seg, 0x000f, memoryAGet16(0x1d20 + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=1d20f
        memoryASet16(0x1d26 + seg, 0x0001, memoryAGet16(0x1d26 + seg, 0x0001) + seg); // 1e0a -> 1ff7; lin=1d261
        memoryASet16(0x1d2b + seg, 0x0005, memoryAGet16(0x1d2b + seg, 0x0005) + seg); // 1e0a -> 1ff7; lin=1d2b5
        memoryASet16(0x1d30 + seg, 0x0009, memoryAGet16(0x1d30 + seg, 0x0009) + seg); // 1e0a -> 1ff7; lin=1d309
        memoryASet16(0x1d39 + seg, 0x0007, memoryAGet16(0x1d39 + seg, 0x0007) + seg); // 1e0a -> 1ff7; lin=1d397
        memoryASet16(0x1d41 + seg, 0x0006, memoryAGet16(0x1d41 + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=1d416
        memoryASet16(0x1d48 + seg, 0x0007, memoryAGet16(0x1d48 + seg, 0x0007) + seg); // 1e0a -> 1ff7; lin=1d487
        memoryASet16(0x1d52 + seg, 0x0006, memoryAGet16(0x1d52 + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=1d526
        memoryASet16(0x1d5d + seg, 0x0002, memoryAGet16(0x1d5d + seg, 0x0002) + seg); // 1e0a -> 1ff7; lin=1d5d2
        memoryASet16(0x1d86 + seg, 0x000e, memoryAGet16(0x1d86 + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=1d86e
        memoryASet16(0x1d89 + seg, 0x000f, memoryAGet16(0x1d89 + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=1d89f
        memoryASet16(0x1d91 + seg, 0x000d, memoryAGet16(0x1d91 + seg, 0x000d) + seg); // 12a6 -> 1493; lin=1d91d
        memoryASet16(0x1d93 + seg, 0x0001, memoryAGet16(0x1d93 + seg, 0x0001) + seg); // 155e -> 174b; lin=1d931
        memoryASet16(0x1d97 + seg, 0x0003, memoryAGet16(0x1d97 + seg, 0x0003) + seg); // 155e -> 174b; lin=1d973
        memoryASet16(0x1d98 + seg, 0x0003, memoryAGet16(0x1d98 + seg, 0x0003) + seg); // 155e -> 174b; lin=1d983
        memoryASet16(0x1d9a + seg, 0x0004, memoryAGet16(0x1d9a + seg, 0x0004) + seg); // 155e -> 174b; lin=1d9a4
        memoryASet16(0x1d9b + seg, 0x0009, memoryAGet16(0x1d9b + seg, 0x0009) + seg); // 155e -> 174b; lin=1d9b9
        memoryASet16(0x1d9c + seg, 0x0008, memoryAGet16(0x1d9c + seg, 0x0008) + seg); // 155e -> 174b; lin=1d9c8
        memoryASet16(0x1d9d + seg, 0x0004, memoryAGet16(0x1d9d + seg, 0x0004) + seg); // 155e -> 174b; lin=1d9d4
        memoryASet16(0x1d9f + seg, 0x0002, memoryAGet16(0x1d9f + seg, 0x0002) + seg); // 1e0a -> 1ff7; lin=1d9f2
        memoryASet16(0x1da0 + seg, 0x000f, memoryAGet16(0x1da0 + seg, 0x000f) + seg); // 1e0a -> 1ff7; lin=1da0f
        memoryASet16(0x1db0 + seg, 0x000c, memoryAGet16(0x1db0 + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=1db0c
        memoryASet16(0x1db6 + seg, 0x0005, memoryAGet16(0x1db6 + seg, 0x0005) + seg); // 1e0a -> 1ff7; lin=1db65
        memoryASet16(0x1dbe + seg, 0x0000, memoryAGet16(0x1dbe + seg, 0x0000) + seg); // 1e0a -> 1ff7; lin=1dbe0
        memoryASet16(0x1dc5 + seg, 0x0000, memoryAGet16(0x1dc5 + seg, 0x0000) + seg); // 1e0a -> 1ff7; lin=1dc50
        memoryASet16(0x1dcc + seg, 0x000e, memoryAGet16(0x1dcc + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=1dcce
        memoryASet16(0x1dd7 + seg, 0x000e, memoryAGet16(0x1dd7 + seg, 0x000e) + seg); // 1e0a -> 1ff7; lin=1dd7e
        memoryASet16(0x1de3 + seg, 0x0008, memoryAGet16(0x1de3 + seg, 0x0008) + seg); // 1e0a -> 1ff7; lin=1de38
        memoryASet16(0x1dea + seg, 0x000c, memoryAGet16(0x1dea + seg, 0x000c) + seg); // 1e0a -> 1ff7; lin=1deac
        memoryASet16(0x1dfc + seg, 0x0009, memoryAGet16(0x1dfc + seg, 0x0009) + seg); // 1e0a -> 1ff7; lin=1dfc9
        memoryASet16(0x1e00 + seg, 0x0006, memoryAGet16(0x1e00 + seg, 0x0006) + seg); // 1e0a -> 1ff7; lin=1e006
        memoryASet16(0x1e09 + seg, 0x0007, memoryAGet16(0x1e09 + seg, 0x0007) + seg); // 1e0a -> 1ff7; lin=1e097
        memoryASet16(0x1f85 + seg, 0x000e, memoryAGet16(0x1f85 + seg, 0x000e) + seg); // 1f83 -> 2170; lin=1f85e
        memoryASet16(0x1f8d + seg, 0x0004, memoryAGet16(0x1f8d + seg, 0x0004) + seg); // 1f87 -> 2174; lin=1f8d4
        memoryASet16(0x1f92 + seg, 0x0000, memoryAGet16(0x1f92 + seg, 0x0000) + seg); // 1f8e -> 217b; lin=1f920
        memoryASet16(0x1f98 + seg, 0x0002, memoryAGet16(0x1f98 + seg, 0x0002) + seg); // 1f93 -> 2180; lin=1f982
        memoryASet16(0x1fa1 + seg, 0x0008, memoryAGet16(0x1fa1 + seg, 0x0008) + seg); // 1f99 -> 2186; lin=1fa18
        memoryASet16(0x1fa1 + seg, 0x000c, memoryAGet16(0x1fa1 + seg, 0x000c) + seg); // 1a89 -> 1c76; lin=1fa1c
        memoryASet16(0x1fa2 + seg, 0x000e, memoryAGet16(0x1fa2 + seg, 0x000e) + seg); // 1f99 -> 2186; lin=1fa2e
        memoryASet16(0x1fa3 + seg, 0x0002, memoryAGet16(0x1fa3 + seg, 0x0002) + seg); // 1a89 -> 1c76; lin=1fa32
        memoryASet16(0x1fa4 + seg, 0x0008, memoryAGet16(0x1fa4 + seg, 0x0008) + seg); // 1a89 -> 1c76; lin=1fa48
        memoryASet16(0x1fa5 + seg, 0x000e, memoryAGet16(0x1fa5 + seg, 0x000e) + seg); // 1a89 -> 1c76; lin=1fa5e
        memoryASet16(0x1fa7 + seg, 0x0004, memoryAGet16(0x1fa7 + seg, 0x0004) + seg); // 1a89 -> 1c76; lin=1fa74
        memoryASet16(0x1fa8 + seg, 0x000a, memoryAGet16(0x1fa8 + seg, 0x000a) + seg); // 1a89 -> 1c76; lin=1fa8a
        memoryASet16(0x1faa + seg, 0x000c, memoryAGet16(0x1faa + seg, 0x000c) + seg); // 1f99 -> 2186; lin=1faac
        memoryASet16(0x1fab + seg, 0x000e, memoryAGet16(0x1fab + seg, 0x000e) + seg); // 1f99 -> 2186; lin=1fabe
        memoryASet16(0x1fad + seg, 0x0000, memoryAGet16(0x1fad + seg, 0x0000) + seg); // 1f99 -> 2186; lin=1fad0
        memoryASet16(0x1fae + seg, 0x0002, memoryAGet16(0x1fae + seg, 0x0002) + seg); // 1f99 -> 2186; lin=1fae2
        memoryASet16(0x1fb0 + seg, 0x0004, memoryAGet16(0x1fb0 + seg, 0x0004) + seg); // 1faa -> 2197; lin=1fb04
        memoryASet16(0x1fbb + seg, 0x000c, memoryAGet16(0x1fbb + seg, 0x000c) + seg); // 1fb1 -> 219e; lin=1fbbc
        memoryASet16(0x1fbc + seg, 0x0000, memoryAGet16(0x1fbc + seg, 0x0000) + seg); // 1a89 -> 1c76; lin=1fbc0
        memoryASet16(0x1fc2 + seg, 0x0002, memoryAGet16(0x1fc2 + seg, 0x0002) + seg); // 1fbd -> 21aa; lin=1fc22
        memoryASet16(0x1fc2 + seg, 0x0006, memoryAGet16(0x1fc2 + seg, 0x0006) + seg); // 1a89 -> 1c76; lin=1fc26
        memoryASet16(0x1fc3 + seg, 0x000c, memoryAGet16(0x1fc3 + seg, 0x000c) + seg); // 1fb1 -> 219e; lin=1fc3c
        memoryASet16(0x1fc4 + seg, 0x000e, memoryAGet16(0x1fc4 + seg, 0x000e) + seg); // 1fbd -> 21aa; lin=1fc4e
        memoryASet16(0x1fc7 + seg, 0x0000, memoryAGet16(0x1fc7 + seg, 0x0000) + seg); // 1fc3 -> 21b0; lin=1fc70
        memoryASet16(0x1fc7 + seg, 0x0004, memoryAGet16(0x1fc7 + seg, 0x0004) + seg); // 1a89 -> 1c76; lin=1fc74
        memoryASet16(0x1fc8 + seg, 0x000a, memoryAGet16(0x1fc8 + seg, 0x000a) + seg); // 1a89 -> 1c76; lin=1fc8a
        memoryASet16(0x1fca + seg, 0x0000, memoryAGet16(0x1fca + seg, 0x0000) + seg); // 1a89 -> 1c76; lin=1fca0
        memoryASet16(0x1fcb + seg, 0x0006, memoryAGet16(0x1fcb + seg, 0x0006) + seg); // 1a89 -> 1c76; lin=1fcb6
        memoryASet16(0x1fcc + seg, 0x000c, memoryAGet16(0x1fcc + seg, 0x000c) + seg); // 1f87 -> 2174; lin=1fccc
        memoryASet16(0x1fcd + seg, 0x000e, memoryAGet16(0x1fcd + seg, 0x000e) + seg); // 1f8e -> 217b; lin=1fcde
        memoryASet16(0x1fcf + seg, 0x0000, memoryAGet16(0x1fcf + seg, 0x0000) + seg); // 1faa -> 2197; lin=1fcf0
        memoryASet16(0x1fd0 + seg, 0x0002, memoryAGet16(0x1fd0 + seg, 0x0002) + seg); // 1fc3 -> 21b0; lin=1fd02
        memoryASet16(0x1fd1 + seg, 0x0004, memoryAGet16(0x1fd1 + seg, 0x0004) + seg); // 1fc3 -> 21b0; lin=1fd14
        memoryASet16(0x1fd2 + seg, 0x0006, memoryAGet16(0x1fd2 + seg, 0x0006) + seg); // 1fc3 -> 21b0; lin=1fd26
        memoryASet16(0x1fd3 + seg, 0x0008, memoryAGet16(0x1fd3 + seg, 0x0008) + seg); // 1fc3 -> 21b0; lin=1fd38
        memoryASet16(0x1fd5 + seg, 0x000a, memoryAGet16(0x1fd5 + seg, 0x000a) + seg); // 1fcc -> 21b9; lin=1fd5a
        memoryASet16(0x1fd5 + seg, 0x000e, memoryAGet16(0x1fd5 + seg, 0x000e) + seg); // 1a89 -> 1c76; lin=1fd5e
        memoryASet16(0x1fd7 + seg, 0x0004, memoryAGet16(0x1fd7 + seg, 0x0004) + seg); // 1a89 -> 1c76; lin=1fd74
        memoryASet16(0x1fd8 + seg, 0x000c, memoryAGet16(0x1fd8 + seg, 0x000c) + seg); // 1f93 -> 2180; lin=1fd8c
        memoryASet16(0x1fd9 + seg, 0x000e, memoryAGet16(0x1fd9 + seg, 0x000e) + seg); // 1f99 -> 2186; lin=1fd9e
        memoryASet16(0x1fdb + seg, 0x0000, memoryAGet16(0x1fdb + seg, 0x0000) + seg); // 1f99 -> 2186; lin=1fdb0
        memoryASet16(0x1fdc + seg, 0x0002, memoryAGet16(0x1fdc + seg, 0x0002) + seg); // 1fcc -> 21b9; lin=1fdc2
        memoryASet16(0x1fdf + seg, 0x0008, memoryAGet16(0x1fdf + seg, 0x0008) + seg); // 1fcc -> 21b9; lin=1fdf8
        memoryASet16(0x1fe2 + seg, 0x000c, memoryAGet16(0x1fe2 + seg, 0x000c) + seg); // 1fd8 -> 21c5; lin=1fe2c
        memoryASet16(0x2f73 + seg, 0x000c, memoryAGet16(0x2f73 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=2f73c
        memoryASet16(0x2f74 + seg, 0x0000, memoryAGet16(0x2f74 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=2f740
        memoryASet16(0x2f74 + seg, 0x0004, memoryAGet16(0x2f74 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=2f744
        memoryASet16(0x2f80 + seg, 0x000e, memoryAGet16(0x2f80 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f80e
        memoryASet16(0x2f81 + seg, 0x0002, memoryAGet16(0x2f81 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2f812
        memoryASet16(0x2f81 + seg, 0x0006, memoryAGet16(0x2f81 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2f816
        memoryASet16(0x2f82 + seg, 0x000c, memoryAGet16(0x2f82 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2f82c
        memoryASet16(0x2f83 + seg, 0x0000, memoryAGet16(0x2f83 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2f830
        memoryASet16(0x2f83 + seg, 0x0004, memoryAGet16(0x2f83 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2f834
        memoryASet16(0x2f84 + seg, 0x000a, memoryAGet16(0x2f84 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2f84a
        memoryASet16(0x2f84 + seg, 0x000e, memoryAGet16(0x2f84 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f84e
        memoryASet16(0x2f85 + seg, 0x0002, memoryAGet16(0x2f85 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2f852
        memoryASet16(0x2f86 + seg, 0x0008, memoryAGet16(0x2f86 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2f868
        memoryASet16(0x2f86 + seg, 0x000c, memoryAGet16(0x2f86 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2f86c
        memoryASet16(0x2f87 + seg, 0x0000, memoryAGet16(0x2f87 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2f870
        memoryASet16(0x2f88 + seg, 0x0006, memoryAGet16(0x2f88 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2f886
        memoryASet16(0x2f88 + seg, 0x000a, memoryAGet16(0x2f88 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2f88a
        memoryASet16(0x2f88 + seg, 0x000e, memoryAGet16(0x2f88 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f88e
        memoryASet16(0x2f8a + seg, 0x0004, memoryAGet16(0x2f8a + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2f8a4
        memoryASet16(0x2f8a + seg, 0x0008, memoryAGet16(0x2f8a + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2f8a8
        memoryASet16(0x2f8a + seg, 0x000c, memoryAGet16(0x2f8a + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2f8ac
        memoryASet16(0x2f8c + seg, 0x0002, memoryAGet16(0x2f8c + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2f8c2
        memoryASet16(0x2f8c + seg, 0x0006, memoryAGet16(0x2f8c + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2f8c6
        memoryASet16(0x2f8c + seg, 0x000a, memoryAGet16(0x2f8c + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2f8ca
        memoryASet16(0x2f8e + seg, 0x0000, memoryAGet16(0x2f8e + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2f8e0
        memoryASet16(0x2f8e + seg, 0x0004, memoryAGet16(0x2f8e + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2f8e4
        memoryASet16(0x2f8e + seg, 0x0008, memoryAGet16(0x2f8e + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2f8e8
        memoryASet16(0x2f8f + seg, 0x000e, memoryAGet16(0x2f8f + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f8fe
        memoryASet16(0x2f90 + seg, 0x0002, memoryAGet16(0x2f90 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2f902
        memoryASet16(0x2f90 + seg, 0x0006, memoryAGet16(0x2f90 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2f906
        memoryASet16(0x2f91 + seg, 0x000c, memoryAGet16(0x2f91 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2f91c
        memoryASet16(0x2f92 + seg, 0x0000, memoryAGet16(0x2f92 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2f920
        memoryASet16(0x2f92 + seg, 0x0004, memoryAGet16(0x2f92 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2f924
        memoryASet16(0x2f93 + seg, 0x000a, memoryAGet16(0x2f93 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2f93a
        memoryASet16(0x2f93 + seg, 0x000e, memoryAGet16(0x2f93 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f93e
        memoryASet16(0x2f94 + seg, 0x0002, memoryAGet16(0x2f94 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2f942
        memoryASet16(0x2f95 + seg, 0x000c, memoryAGet16(0x2f95 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2f95c
        memoryASet16(0x2f96 + seg, 0x0000, memoryAGet16(0x2f96 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2f960
        memoryASet16(0x2f97 + seg, 0x000a, memoryAGet16(0x2f97 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2f97a
        memoryASet16(0x2f97 + seg, 0x000e, memoryAGet16(0x2f97 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f97e
        memoryASet16(0x2f99 + seg, 0x0008, memoryAGet16(0x2f99 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2f998
        memoryASet16(0x2f99 + seg, 0x000c, memoryAGet16(0x2f99 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2f99c
        memoryASet16(0x2f9b + seg, 0x0006, memoryAGet16(0x2f9b + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2f9b6
        memoryASet16(0x2f9b + seg, 0x000a, memoryAGet16(0x2f9b + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2f9ba
        memoryASet16(0x2f9d + seg, 0x0000, memoryAGet16(0x2f9d + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2f9d0
        memoryASet16(0x2f9d + seg, 0x0004, memoryAGet16(0x2f9d + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2f9d4
        memoryASet16(0x2f9d + seg, 0x0008, memoryAGet16(0x2f9d + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2f9d8
        memoryASet16(0x2f9e + seg, 0x000e, memoryAGet16(0x2f9e + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2f9ee
        memoryASet16(0x2f9f + seg, 0x0002, memoryAGet16(0x2f9f + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2f9f2
        memoryASet16(0x2f9f + seg, 0x0006, memoryAGet16(0x2f9f + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2f9f6
        memoryASet16(0x2fa0 + seg, 0x000c, memoryAGet16(0x2fa0 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fa0c
        memoryASet16(0x2fa1 + seg, 0x0000, memoryAGet16(0x2fa1 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fa10
        memoryASet16(0x2fa1 + seg, 0x0004, memoryAGet16(0x2fa1 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fa14
        memoryASet16(0x2fa2 + seg, 0x000e, memoryAGet16(0x2fa2 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fa2e
        memoryASet16(0x2fa3 + seg, 0x0002, memoryAGet16(0x2fa3 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fa32
        memoryASet16(0x2fa4 + seg, 0x000c, memoryAGet16(0x2fa4 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fa4c
        memoryASet16(0x2fa5 + seg, 0x0000, memoryAGet16(0x2fa5 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fa50
        memoryASet16(0x2fa6 + seg, 0x000a, memoryAGet16(0x2fa6 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fa6a
        memoryASet16(0x2fa6 + seg, 0x000e, memoryAGet16(0x2fa6 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fa6e
        memoryASet16(0x2fa8 + seg, 0x0004, memoryAGet16(0x2fa8 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fa84
        memoryASet16(0x2fa8 + seg, 0x0008, memoryAGet16(0x2fa8 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fa88
        memoryASet16(0x2fa8 + seg, 0x000c, memoryAGet16(0x2fa8 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fa8c
        memoryASet16(0x2faa + seg, 0x0002, memoryAGet16(0x2faa + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2faa2
        memoryASet16(0x2faa + seg, 0x0006, memoryAGet16(0x2faa + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2faa6
        memoryASet16(0x2faa + seg, 0x000a, memoryAGet16(0x2faa + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2faaa
        memoryASet16(0x2fac + seg, 0x0000, memoryAGet16(0x2fac + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fac0
        memoryASet16(0x2fac + seg, 0x0004, memoryAGet16(0x2fac + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fac4
        memoryASet16(0x2fac + seg, 0x0008, memoryAGet16(0x2fac + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fac8
        memoryASet16(0x2fad + seg, 0x000e, memoryAGet16(0x2fad + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fade
        memoryASet16(0x2fae + seg, 0x0002, memoryAGet16(0x2fae + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fae2
        memoryASet16(0x2fae + seg, 0x0006, memoryAGet16(0x2fae + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fae6
        memoryASet16(0x2faf + seg, 0x000c, memoryAGet16(0x2faf + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fafc
        memoryASet16(0x2fb0 + seg, 0x0000, memoryAGet16(0x2fb0 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fb00
        memoryASet16(0x2fb0 + seg, 0x0004, memoryAGet16(0x2fb0 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fb04
        memoryASet16(0x2fb1 + seg, 0x000e, memoryAGet16(0x2fb1 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fb1e
        memoryASet16(0x2fb2 + seg, 0x0002, memoryAGet16(0x2fb2 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fb22
        memoryASet16(0x2fb3 + seg, 0x0008, memoryAGet16(0x2fb3 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fb38
        memoryASet16(0x2fb3 + seg, 0x000c, memoryAGet16(0x2fb3 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fb3c
        memoryASet16(0x2fb4 + seg, 0x0000, memoryAGet16(0x2fb4 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fb40
        memoryASet16(0x2fb5 + seg, 0x000e, memoryAGet16(0x2fb5 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=2fb5e
        memoryASet16(0x2fb7 + seg, 0x0004, memoryAGet16(0x2fb7 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fb74
        memoryASet16(0x2fb7 + seg, 0x000c, memoryAGet16(0x2fb7 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=2fb7c
        memoryASet16(0x2fb9 + seg, 0x0002, memoryAGet16(0x2fb9 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fb92
        memoryASet16(0x2fb9 + seg, 0x000a, memoryAGet16(0x2fb9 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=2fb9a
        memoryASet16(0x2fbb + seg, 0x0000, memoryAGet16(0x2fbb + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fbb0
        memoryASet16(0x2fbb + seg, 0x0008, memoryAGet16(0x2fbb + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=2fbb8
        memoryASet16(0x2fbc + seg, 0x000e, memoryAGet16(0x2fbc + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fbce
        memoryASet16(0x2fbd + seg, 0x0006, memoryAGet16(0x2fbd + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=2fbd6
        memoryASet16(0x2fbe + seg, 0x000c, memoryAGet16(0x2fbe + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fbec
        memoryASet16(0x2fbf + seg, 0x0000, memoryAGet16(0x2fbf + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fbf0
        memoryASet16(0x2fbf + seg, 0x0004, memoryAGet16(0x2fbf + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fbf4
        memoryASet16(0x2fc0 + seg, 0x000e, memoryAGet16(0x2fc0 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fc0e
        memoryASet16(0x2fc1 + seg, 0x0002, memoryAGet16(0x2fc1 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fc12
        memoryASet16(0x2fc2 + seg, 0x0008, memoryAGet16(0x2fc2 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fc28
        memoryASet16(0x2fc2 + seg, 0x000c, memoryAGet16(0x2fc2 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fc2c
        memoryASet16(0x2fc3 + seg, 0x0000, memoryAGet16(0x2fc3 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fc30
        memoryASet16(0x2fc4 + seg, 0x000a, memoryAGet16(0x2fc4 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fc4a
        memoryASet16(0x2fc4 + seg, 0x000e, memoryAGet16(0x2fc4 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fc4e
        memoryASet16(0x2fc6 + seg, 0x0004, memoryAGet16(0x2fc6 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fc64
        memoryASet16(0x2fc6 + seg, 0x000c, memoryAGet16(0x2fc6 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fc6c
        memoryASet16(0x2fc8 + seg, 0x000a, memoryAGet16(0x2fc8 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fc8a
        memoryASet16(0x2fca + seg, 0x0000, memoryAGet16(0x2fca + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fca0
        memoryASet16(0x2fca + seg, 0x0008, memoryAGet16(0x2fca + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fca8
        memoryASet16(0x2fcb + seg, 0x000e, memoryAGet16(0x2fcb + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fcbe
        memoryASet16(0x2fcc + seg, 0x0006, memoryAGet16(0x2fcc + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=2fcc6
        memoryASet16(0x2fcd + seg, 0x000c, memoryAGet16(0x2fcd + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fcdc
        memoryASet16(0x2fce + seg, 0x0004, memoryAGet16(0x2fce + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=2fce4
        memoryASet16(0x2fcf + seg, 0x000a, memoryAGet16(0x2fcf + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fcfa
        memoryASet16(0x2fd0 + seg, 0x0002, memoryAGet16(0x2fd0 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=2fd02
        memoryASet16(0x2fd1 + seg, 0x0008, memoryAGet16(0x2fd1 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fd18
        memoryASet16(0x2fd2 + seg, 0x0000, memoryAGet16(0x2fd2 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=2fd20
        memoryASet16(0x2fd3 + seg, 0x0006, memoryAGet16(0x2fd3 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fd36
        memoryASet16(0x2fd3 + seg, 0x000e, memoryAGet16(0x2fd3 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=2fd3e
        memoryASet16(0x2fd5 + seg, 0x0004, memoryAGet16(0x2fd5 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fd54
        memoryASet16(0x2fd5 + seg, 0x000c, memoryAGet16(0x2fd5 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=2fd5c
        memoryASet16(0x2fd7 + seg, 0x0002, memoryAGet16(0x2fd7 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fd72
        memoryASet16(0x2fd7 + seg, 0x0006, memoryAGet16(0x2fd7 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fd76
        memoryASet16(0x2fd7 + seg, 0x000a, memoryAGet16(0x2fd7 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fd7a
        memoryASet16(0x2fd9 + seg, 0x0000, memoryAGet16(0x2fd9 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fd90
        memoryASet16(0x2fd9 + seg, 0x0004, memoryAGet16(0x2fd9 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fd94
        memoryASet16(0x2fd9 + seg, 0x0008, memoryAGet16(0x2fd9 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fd98
        memoryASet16(0x2fda + seg, 0x000e, memoryAGet16(0x2fda + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fdae
        memoryASet16(0x2fdb + seg, 0x0002, memoryAGet16(0x2fdb + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fdb2
        memoryASet16(0x2fdb + seg, 0x0006, memoryAGet16(0x2fdb + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fdb6
        memoryASet16(0x2fdc + seg, 0x000c, memoryAGet16(0x2fdc + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fdcc
        memoryASet16(0x2fdd + seg, 0x0000, memoryAGet16(0x2fdd + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fdd0
        memoryASet16(0x2fdd + seg, 0x0004, memoryAGet16(0x2fdd + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fdd4
        memoryASet16(0x2fde + seg, 0x000a, memoryAGet16(0x2fde + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fdea
        memoryASet16(0x2fde + seg, 0x000e, memoryAGet16(0x2fde + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fdee
        memoryASet16(0x2fdf + seg, 0x0002, memoryAGet16(0x2fdf + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fdf2
        memoryASet16(0x2fe0 + seg, 0x0008, memoryAGet16(0x2fe0 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fe08
        memoryASet16(0x2fe0 + seg, 0x000c, memoryAGet16(0x2fe0 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fe0c
        memoryASet16(0x2fe1 + seg, 0x0000, memoryAGet16(0x2fe1 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fe10
        memoryASet16(0x2fe2 + seg, 0x0006, memoryAGet16(0x2fe2 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fe26
        memoryASet16(0x2fe2 + seg, 0x000a, memoryAGet16(0x2fe2 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fe2a
        memoryASet16(0x2fe2 + seg, 0x000e, memoryAGet16(0x2fe2 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fe2e
        memoryASet16(0x2fe4 + seg, 0x0004, memoryAGet16(0x2fe4 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fe44
        memoryASet16(0x2fe4 + seg, 0x0008, memoryAGet16(0x2fe4 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fe48
        memoryASet16(0x2fe4 + seg, 0x000c, memoryAGet16(0x2fe4 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fe4c
        memoryASet16(0x2fe6 + seg, 0x0002, memoryAGet16(0x2fe6 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fe62
        memoryASet16(0x2fe6 + seg, 0x0006, memoryAGet16(0x2fe6 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fe66
        memoryASet16(0x2fe6 + seg, 0x000a, memoryAGet16(0x2fe6 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2fe6a
        memoryASet16(0x2fe8 + seg, 0x0004, memoryAGet16(0x2fe8 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fe84
        memoryASet16(0x2fe8 + seg, 0x0008, memoryAGet16(0x2fe8 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2fe88
        memoryASet16(0x2fe9 + seg, 0x000e, memoryAGet16(0x2fe9 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fe9e
        memoryASet16(0x2fea + seg, 0x0002, memoryAGet16(0x2fea + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fea2
        memoryASet16(0x2fea + seg, 0x0006, memoryAGet16(0x2fea + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2fea6
        memoryASet16(0x2fec + seg, 0x0000, memoryAGet16(0x2fec + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fec0
        memoryASet16(0x2fec + seg, 0x0004, memoryAGet16(0x2fec + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2fec4
        memoryASet16(0x2fed + seg, 0x000a, memoryAGet16(0x2fed + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2feda
        memoryASet16(0x2fed + seg, 0x000e, memoryAGet16(0x2fed + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2fede
        memoryASet16(0x2fee + seg, 0x0002, memoryAGet16(0x2fee + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2fee2
        memoryASet16(0x2fef + seg, 0x000c, memoryAGet16(0x2fef + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2fefc
        memoryASet16(0x2ff0 + seg, 0x0000, memoryAGet16(0x2ff0 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2ff00
        memoryASet16(0x2ff1 + seg, 0x0006, memoryAGet16(0x2ff1 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2ff16
        memoryASet16(0x2ff1 + seg, 0x000a, memoryAGet16(0x2ff1 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2ff1a
        memoryASet16(0x2ff1 + seg, 0x000e, memoryAGet16(0x2ff1 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2ff1e
        memoryASet16(0x2ff3 + seg, 0x0004, memoryAGet16(0x2ff3 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2ff34
        memoryASet16(0x2ff3 + seg, 0x0008, memoryAGet16(0x2ff3 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2ff38
        memoryASet16(0x2ff3 + seg, 0x000c, memoryAGet16(0x2ff3 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2ff3c
        memoryASet16(0x2ff5 + seg, 0x0002, memoryAGet16(0x2ff5 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2ff52
        memoryASet16(0x2ff5 + seg, 0x0006, memoryAGet16(0x2ff5 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2ff56
        memoryASet16(0x2ff5 + seg, 0x000a, memoryAGet16(0x2ff5 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2ff5a
        memoryASet16(0x2ff7 + seg, 0x0000, memoryAGet16(0x2ff7 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2ff70
        memoryASet16(0x2ff7 + seg, 0x0004, memoryAGet16(0x2ff7 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2ff74
        memoryASet16(0x2ff7 + seg, 0x0008, memoryAGet16(0x2ff7 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2ff78
        memoryASet16(0x2ff8 + seg, 0x000e, memoryAGet16(0x2ff8 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2ff8e
        memoryASet16(0x2ff9 + seg, 0x0002, memoryAGet16(0x2ff9 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2ff92
        memoryASet16(0x2ff9 + seg, 0x0006, memoryAGet16(0x2ff9 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=2ff96
        memoryASet16(0x2ffa + seg, 0x000c, memoryAGet16(0x2ffa + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2ffac
        memoryASet16(0x2ffb + seg, 0x0000, memoryAGet16(0x2ffb + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2ffb0
        memoryASet16(0x2ffb + seg, 0x0004, memoryAGet16(0x2ffb + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=2ffb4
        memoryASet16(0x2ffc + seg, 0x000a, memoryAGet16(0x2ffc + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=2ffca
        memoryASet16(0x2ffc + seg, 0x000e, memoryAGet16(0x2ffc + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=2ffce
        memoryASet16(0x2ffd + seg, 0x0002, memoryAGet16(0x2ffd + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=2ffd2
        memoryASet16(0x2ffe + seg, 0x0008, memoryAGet16(0x2ffe + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=2ffe8
        memoryASet16(0x2ffe + seg, 0x000c, memoryAGet16(0x2ffe + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=2ffec
        memoryASet16(0x2fff + seg, 0x0000, memoryAGet16(0x2fff + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=2fff0
        memoryASet16(0x3000 + seg, 0x0006, memoryAGet16(0x3000 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=30006
        memoryASet16(0x3000 + seg, 0x000a, memoryAGet16(0x3000 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=3000a
        memoryASet16(0x3000 + seg, 0x000e, memoryAGet16(0x3000 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=3000e
        memoryASet16(0x3002 + seg, 0x0004, memoryAGet16(0x3002 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=30024
        memoryASet16(0x3002 + seg, 0x0008, memoryAGet16(0x3002 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=30028
        memoryASet16(0x3002 + seg, 0x000c, memoryAGet16(0x3002 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=3002c
        memoryASet16(0x3004 + seg, 0x0002, memoryAGet16(0x3004 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=30042
        memoryASet16(0x3004 + seg, 0x0006, memoryAGet16(0x3004 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=30046
        memoryASet16(0x3004 + seg, 0x000a, memoryAGet16(0x3004 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=3004a
        memoryASet16(0x3006 + seg, 0x0000, memoryAGet16(0x3006 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=30060
        memoryASet16(0x3006 + seg, 0x0004, memoryAGet16(0x3006 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=30064
        memoryASet16(0x3006 + seg, 0x0008, memoryAGet16(0x3006 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=30068
        memoryASet16(0x3007 + seg, 0x000e, memoryAGet16(0x3007 + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=3007e
        memoryASet16(0x3008 + seg, 0x0002, memoryAGet16(0x3008 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=30082
        memoryASet16(0x3008 + seg, 0x0006, memoryAGet16(0x3008 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=30086
        memoryASet16(0x3009 + seg, 0x000c, memoryAGet16(0x3009 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3009c
        memoryASet16(0x300a + seg, 0x0000, memoryAGet16(0x300a + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=300a0
        memoryASet16(0x300a + seg, 0x0004, memoryAGet16(0x300a + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=300a4
        memoryASet16(0x300b + seg, 0x000a, memoryAGet16(0x300b + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=300ba
        memoryASet16(0x300b + seg, 0x000e, memoryAGet16(0x300b + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=300be
        memoryASet16(0x300c + seg, 0x0002, memoryAGet16(0x300c + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=300c2
        memoryASet16(0x300d + seg, 0x0008, memoryAGet16(0x300d + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=300d8
        memoryASet16(0x300d + seg, 0x000c, memoryAGet16(0x300d + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=300dc
        memoryASet16(0x300e + seg, 0x0000, memoryAGet16(0x300e + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=300e0
        memoryASet16(0x300f + seg, 0x0006, memoryAGet16(0x300f + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=300f6
        memoryASet16(0x300f + seg, 0x000a, memoryAGet16(0x300f + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=300fa
        memoryASet16(0x300f + seg, 0x000e, memoryAGet16(0x300f + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=300fe
        memoryASet16(0x3011 + seg, 0x0004, memoryAGet16(0x3011 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=30114
        memoryASet16(0x3011 + seg, 0x0008, memoryAGet16(0x3011 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=30118
        memoryASet16(0x3011 + seg, 0x000c, memoryAGet16(0x3011 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=3011c
        memoryASet16(0x3013 + seg, 0x0002, memoryAGet16(0x3013 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=30132
        memoryASet16(0x3013 + seg, 0x0006, memoryAGet16(0x3013 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=30136
        memoryASet16(0x3013 + seg, 0x000a, memoryAGet16(0x3013 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=3013a
        memoryASet16(0x3015 + seg, 0x0000, memoryAGet16(0x3015 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=30150
        memoryASet16(0x3015 + seg, 0x0004, memoryAGet16(0x3015 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=30154
        memoryASet16(0x3015 + seg, 0x0008, memoryAGet16(0x3015 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=30158
        memoryASet16(0x3017 + seg, 0x0002, memoryAGet16(0x3017 + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=30172
        memoryASet16(0x3017 + seg, 0x0006, memoryAGet16(0x3017 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=30176
        memoryASet16(0x3018 + seg, 0x000c, memoryAGet16(0x3018 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=3018c
        memoryASet16(0x3019 + seg, 0x0000, memoryAGet16(0x3019 + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=30190
        memoryASet16(0x3019 + seg, 0x0004, memoryAGet16(0x3019 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=30194
        memoryASet16(0x301a + seg, 0x000a, memoryAGet16(0x301a + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=301aa
        memoryASet16(0x301a + seg, 0x000e, memoryAGet16(0x301a + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=301ae
        memoryASet16(0x301b + seg, 0x0002, memoryAGet16(0x301b + seg, 0x0002) + seg); // 0b80 -> 0d6d; lin=301b2
        memoryASet16(0x301c + seg, 0x0008, memoryAGet16(0x301c + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=301c8
        memoryASet16(0x301c + seg, 0x000c, memoryAGet16(0x301c + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=301cc
        memoryASet16(0x301d + seg, 0x0000, memoryAGet16(0x301d + seg, 0x0000) + seg); // 0b80 -> 0d6d; lin=301d0
        memoryASet16(0x301e + seg, 0x0006, memoryAGet16(0x301e + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=301e6
        memoryASet16(0x301e + seg, 0x000a, memoryAGet16(0x301e + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=301ea
        memoryASet16(0x301e + seg, 0x000e, memoryAGet16(0x301e + seg, 0x000e) + seg); // 0b80 -> 0d6d; lin=301ee
        memoryASet16(0x3020 + seg, 0x0004, memoryAGet16(0x3020 + seg, 0x0004) + seg); // 0b80 -> 0d6d; lin=30204
        memoryASet16(0x3020 + seg, 0x0008, memoryAGet16(0x3020 + seg, 0x0008) + seg); // 0b80 -> 0d6d; lin=30208
        memoryASet16(0x3020 + seg, 0x000c, memoryAGet16(0x3020 + seg, 0x000c) + seg); // 0b80 -> 0d6d; lin=3020c
        memoryASet16(0x3022 + seg, 0x0006, memoryAGet16(0x3022 + seg, 0x0006) + seg); // 0b80 -> 0d6d; lin=30226
        memoryASet16(0x3022 + seg, 0x000a, memoryAGet16(0x3022 + seg, 0x000a) + seg); // 0b80 -> 0d6d; lin=3022a
        memoryASet16(0x3031 + seg, 0x0004, memoryAGet16(0x3031 + seg, 0x0004) + seg); // 0d8f -> 0f7c; lin=30314
        memoryASet16(0x3031 + seg, 0x000c, memoryAGet16(0x3031 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3031c
        memoryASet16(0x3033 + seg, 0x0002, memoryAGet16(0x3033 + seg, 0x0002) + seg); // 0d8f -> 0f7c; lin=30332
        memoryASet16(0x3033 + seg, 0x000a, memoryAGet16(0x3033 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3033a
        memoryASet16(0x3035 + seg, 0x0000, memoryAGet16(0x3035 + seg, 0x0000) + seg); // 0d8f -> 0f7c; lin=30350
        memoryASet16(0x3035 + seg, 0x0008, memoryAGet16(0x3035 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30358
        memoryASet16(0x3036 + seg, 0x000e, memoryAGet16(0x3036 + seg, 0x000e) + seg); // 0d8f -> 0f7c; lin=3036e
        memoryASet16(0x3037 + seg, 0x0006, memoryAGet16(0x3037 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=30376
        memoryASet16(0x3038 + seg, 0x000c, memoryAGet16(0x3038 + seg, 0x000c) + seg); // 0d8f -> 0f7c; lin=3038c
        memoryASet16(0x3039 + seg, 0x0004, memoryAGet16(0x3039 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=30394
        memoryASet16(0x303a + seg, 0x000a, memoryAGet16(0x303a + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=303aa
        memoryASet16(0x303b + seg, 0x0002, memoryAGet16(0x303b + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=303b2
        memoryASet16(0x303c + seg, 0x0008, memoryAGet16(0x303c + seg, 0x0008) + seg); // 0d8f -> 0f7c; lin=303c8
        memoryASet16(0x303d + seg, 0x0000, memoryAGet16(0x303d + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=303d0
        memoryASet16(0x303e + seg, 0x0006, memoryAGet16(0x303e + seg, 0x0006) + seg); // 0d8f -> 0f7c; lin=303e6
        memoryASet16(0x303e + seg, 0x000e, memoryAGet16(0x303e + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=303ee
        memoryASet16(0x3040 + seg, 0x0004, memoryAGet16(0x3040 + seg, 0x0004) + seg); // 0d8f -> 0f7c; lin=30404
        memoryASet16(0x3040 + seg, 0x000c, memoryAGet16(0x3040 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3040c
        memoryASet16(0x3042 + seg, 0x0002, memoryAGet16(0x3042 + seg, 0x0002) + seg); // 0d8f -> 0f7c; lin=30422
        memoryASet16(0x3042 + seg, 0x000a, memoryAGet16(0x3042 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3042a
        memoryASet16(0x3047 + seg, 0x0008, memoryAGet16(0x3047 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30478
        memoryASet16(0x3049 + seg, 0x0006, memoryAGet16(0x3049 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=30496
        memoryASet16(0x304b + seg, 0x0004, memoryAGet16(0x304b + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=304b4
        memoryASet16(0x304d + seg, 0x0002, memoryAGet16(0x304d + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=304d2
        memoryASet16(0x304e + seg, 0x0008, memoryAGet16(0x304e + seg, 0x0008) + seg); // 0d8f -> 0f7c; lin=304e8
        memoryASet16(0x304f + seg, 0x0000, memoryAGet16(0x304f + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=304f0
        memoryASet16(0x3050 + seg, 0x0006, memoryAGet16(0x3050 + seg, 0x0006) + seg); // 0d8f -> 0f7c; lin=30506
        memoryASet16(0x3050 + seg, 0x000e, memoryAGet16(0x3050 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3050e
        memoryASet16(0x3052 + seg, 0x0004, memoryAGet16(0x3052 + seg, 0x0004) + seg); // 0d8f -> 0f7c; lin=30524
        memoryASet16(0x3052 + seg, 0x000c, memoryAGet16(0x3052 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3052c
        memoryASet16(0x3054 + seg, 0x0002, memoryAGet16(0x3054 + seg, 0x0002) + seg); // 0d8f -> 0f7c; lin=30542
        memoryASet16(0x3054 + seg, 0x000a, memoryAGet16(0x3054 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3054a
        memoryASet16(0x3056 + seg, 0x0000, memoryAGet16(0x3056 + seg, 0x0000) + seg); // 0d8f -> 0f7c; lin=30560
        memoryASet16(0x3056 + seg, 0x0008, memoryAGet16(0x3056 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30568
        memoryASet16(0x3057 + seg, 0x000e, memoryAGet16(0x3057 + seg, 0x000e) + seg); // 0d8f -> 0f7c; lin=3057e
        memoryASet16(0x3058 + seg, 0x0006, memoryAGet16(0x3058 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=30586
        memoryASet16(0x3059 + seg, 0x000c, memoryAGet16(0x3059 + seg, 0x000c) + seg); // 0d8f -> 0f7c; lin=3059c
        memoryASet16(0x305a + seg, 0x0004, memoryAGet16(0x305a + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=305a4
        memoryASet16(0x305b + seg, 0x000a, memoryAGet16(0x305b + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=305ba
        memoryASet16(0x305c + seg, 0x0002, memoryAGet16(0x305c + seg, 0x0002) + seg); // 0d8f -> 0f7c; lin=305c2
        memoryASet16(0x305d + seg, 0x0008, memoryAGet16(0x305d + seg, 0x0008) + seg); // 0d8f -> 0f7c; lin=305d8
        memoryASet16(0x305e + seg, 0x0000, memoryAGet16(0x305e + seg, 0x0000) + seg); // 0d8f -> 0f7c; lin=305e0
        memoryASet16(0x305f + seg, 0x0006, memoryAGet16(0x305f + seg, 0x0006) + seg); // 0d8f -> 0f7c; lin=305f6
        memoryASet16(0x305f + seg, 0x000e, memoryAGet16(0x305f + seg, 0x000e) + seg); // 0d8f -> 0f7c; lin=305fe
        memoryASet16(0x3061 + seg, 0x0004, memoryAGet16(0x3061 + seg, 0x0004) + seg); // 0d8f -> 0f7c; lin=30614
        memoryASet16(0x3061 + seg, 0x000c, memoryAGet16(0x3061 + seg, 0x000c) + seg); // 0d8f -> 0f7c; lin=3061c
        memoryASet16(0x3063 + seg, 0x000a, memoryAGet16(0x3063 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3063a
        memoryASet16(0x3065 + seg, 0x0008, memoryAGet16(0x3065 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30658
        memoryASet16(0x3066 + seg, 0x000e, memoryAGet16(0x3066 + seg, 0x000e) + seg); // 0d8f -> 0f7c; lin=3066e
        memoryASet16(0x3068 + seg, 0x000c, memoryAGet16(0x3068 + seg, 0x000c) + seg); // 0d8f -> 0f7c; lin=3068c
        memoryASet16(0x306a + seg, 0x000a, memoryAGet16(0x306a + seg, 0x000a) + seg); // 0d8f -> 0f7c; lin=306aa
        memoryASet16(0x3076 + seg, 0x0006, memoryAGet16(0x3076 + seg, 0x0006) + seg); // 1f04 -> 20f1; lin=30766
        memoryASet16(0x3076 + seg, 0x000a, memoryAGet16(0x3076 + seg, 0x000a) + seg); // 1f05 -> 20f2; lin=3076a
        memoryASet16(0x3076 + seg, 0x000e, memoryAGet16(0x3076 + seg, 0x000e) + seg); // 1f06 -> 20f3; lin=3076e
        memoryASet16(0x3077 + seg, 0x0002, memoryAGet16(0x3077 + seg, 0x0002) + seg); // 1f07 -> 20f4; lin=30772
        memoryASet16(0x3077 + seg, 0x0006, memoryAGet16(0x3077 + seg, 0x0006) + seg); // 1f09 -> 20f6; lin=30776
        memoryASet16(0x3077 + seg, 0x000a, memoryAGet16(0x3077 + seg, 0x000a) + seg); // 1f0b -> 20f8; lin=3077a
        memoryASet16(0x3077 + seg, 0x000e, memoryAGet16(0x3077 + seg, 0x000e) + seg); // 1f0c -> 20f9; lin=3077e
        memoryASet16(0x3078 + seg, 0x0002, memoryAGet16(0x3078 + seg, 0x0002) + seg); // 1f0d -> 20fa; lin=30782
        memoryASet16(0x3078 + seg, 0x0006, memoryAGet16(0x3078 + seg, 0x0006) + seg); // 1f0e -> 20fb; lin=30786
        memoryASet16(0x3078 + seg, 0x000a, memoryAGet16(0x3078 + seg, 0x000a) + seg); // 1f0f -> 20fc; lin=3078a
        memoryASet16(0x3078 + seg, 0x000e, memoryAGet16(0x3078 + seg, 0x000e) + seg); // 1f10 -> 20fd; lin=3078e
        memoryASet16(0x3079 + seg, 0x0002, memoryAGet16(0x3079 + seg, 0x0002) + seg); // 1f11 -> 20fe; lin=30792
        memoryASet16(0x3079 + seg, 0x0006, memoryAGet16(0x3079 + seg, 0x0006) + seg); // 1f13 -> 2100; lin=30796
        memoryASet16(0x3079 + seg, 0x000a, memoryAGet16(0x3079 + seg, 0x000a) + seg); // 1f15 -> 2102; lin=3079a
        memoryASet16(0x3079 + seg, 0x000e, memoryAGet16(0x3079 + seg, 0x000e) + seg); // 1f18 -> 2105; lin=3079e
        memoryASet16(0x307a + seg, 0x0002, memoryAGet16(0x307a + seg, 0x0002) + seg); // 1f1a -> 2107; lin=307a2
        memoryASet16(0x307a + seg, 0x0006, memoryAGet16(0x307a + seg, 0x0006) + seg); // 1f1b -> 2108; lin=307a6
        memoryASet16(0x307a + seg, 0x000a, memoryAGet16(0x307a + seg, 0x000a) + seg); // 1f1c -> 2109; lin=307aa
        memoryASet16(0x307a + seg, 0x000e, memoryAGet16(0x307a + seg, 0x000e) + seg); // 1f1d -> 210a; lin=307ae
        memoryASet16(0x307c + seg, 0x000a, memoryAGet16(0x307c + seg, 0x000a) + seg); // 1f1f -> 210c; lin=307ca
        memoryASet16(0x307c + seg, 0x000e, memoryAGet16(0x307c + seg, 0x000e) + seg); // 1f21 -> 210e; lin=307ce
        memoryASet16(0x307d + seg, 0x0002, memoryAGet16(0x307d + seg, 0x0002) + seg); // 1f24 -> 2111; lin=307d2
        memoryASet16(0x307d + seg, 0x0006, memoryAGet16(0x307d + seg, 0x0006) + seg); // 1f26 -> 2113; lin=307d6
        memoryASet16(0x307d + seg, 0x000a, memoryAGet16(0x307d + seg, 0x000a) + seg); // 1f29 -> 2116; lin=307da
        memoryASet16(0x307d + seg, 0x000e, memoryAGet16(0x307d + seg, 0x000e) + seg); // 1f2d -> 211a; lin=307de
        memoryASet16(0x307e + seg, 0x0002, memoryAGet16(0x307e + seg, 0x0002) + seg); // 1f30 -> 211d; lin=307e2
        memoryASet16(0x307e + seg, 0x0006, memoryAGet16(0x307e + seg, 0x0006) + seg); // 1f33 -> 2120; lin=307e6
        memoryASet16(0x307e + seg, 0x000a, memoryAGet16(0x307e + seg, 0x000a) + seg); // 1f35 -> 2122; lin=307ea
        memoryASet16(0x307e + seg, 0x000e, memoryAGet16(0x307e + seg, 0x000e) + seg); // 1f38 -> 2125; lin=307ee
        memoryASet16(0x307f + seg, 0x0002, memoryAGet16(0x307f + seg, 0x0002) + seg); // 1f3a -> 2127; lin=307f2
        memoryASet16(0x307f + seg, 0x0006, memoryAGet16(0x307f + seg, 0x0006) + seg); // 1f3d -> 212a; lin=307f6
        memoryASet16(0x307f + seg, 0x000a, memoryAGet16(0x307f + seg, 0x000a) + seg); // 1f40 -> 212d; lin=307fa
        memoryASet16(0x307f + seg, 0x000e, memoryAGet16(0x307f + seg, 0x000e) + seg); // 1f43 -> 2130; lin=307fe
        memoryASet16(0x3080 + seg, 0x0002, memoryAGet16(0x3080 + seg, 0x0002) + seg); // 1f47 -> 2134; lin=30802
        memoryASet16(0x3080 + seg, 0x0006, memoryAGet16(0x3080 + seg, 0x0006) + seg); // 1f4b -> 2138; lin=30806
        memoryASet16(0x3080 + seg, 0x000a, memoryAGet16(0x3080 + seg, 0x000a) + seg); // 1f4e -> 213b; lin=3080a
        memoryASet16(0x3080 + seg, 0x000e, memoryAGet16(0x3080 + seg, 0x000e) + seg); // 1f51 -> 213e; lin=3080e
        memoryASet16(0x3081 + seg, 0x0002, memoryAGet16(0x3081 + seg, 0x0002) + seg); // 1f54 -> 2141; lin=30812
        memoryASet16(0x3086 + seg, 0x000e, memoryAGet16(0x3086 + seg, 0x000e) + seg); // 0e8f -> 107c; lin=3086e
        memoryASet16(0x3087 + seg, 0x0002, memoryAGet16(0x3087 + seg, 0x0002) + seg); // 0e8f -> 107c; lin=30872
        memoryASet16(0x3087 + seg, 0x0006, memoryAGet16(0x3087 + seg, 0x0006) + seg); // 0e8f -> 107c; lin=30876
        memoryASet16(0x3088 + seg, 0x000c, memoryAGet16(0x3088 + seg, 0x000c) + seg); // 0e8f -> 107c; lin=3088c
        memoryASet16(0x3089 + seg, 0x0000, memoryAGet16(0x3089 + seg, 0x0000) + seg); // 0e8f -> 107c; lin=30890
        memoryASet16(0x3089 + seg, 0x0004, memoryAGet16(0x3089 + seg, 0x0004) + seg); // 0e8f -> 107c; lin=30894
        memoryASet16(0x308a + seg, 0x000a, memoryAGet16(0x308a + seg, 0x000a) + seg); // 0e8f -> 107c; lin=308aa
        memoryASet16(0x308a + seg, 0x000e, memoryAGet16(0x308a + seg, 0x000e) + seg); // 0e8f -> 107c; lin=308ae
        memoryASet16(0x308b + seg, 0x0002, memoryAGet16(0x308b + seg, 0x0002) + seg); // 0e8f -> 107c; lin=308b2
        memoryASet16(0x308c + seg, 0x0008, memoryAGet16(0x308c + seg, 0x0008) + seg); // 0e8f -> 107c; lin=308c8
        memoryASet16(0x308c + seg, 0x000c, memoryAGet16(0x308c + seg, 0x000c) + seg); // 0e8f -> 107c; lin=308cc
        memoryASet16(0x308d + seg, 0x0000, memoryAGet16(0x308d + seg, 0x0000) + seg); // 0e8f -> 107c; lin=308d0
        memoryASet16(0x308e + seg, 0x0006, memoryAGet16(0x308e + seg, 0x0006) + seg); // 11a2 -> 138f; lin=308e6
        memoryASet16(0x308e + seg, 0x000e, memoryAGet16(0x308e + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=308ee
        memoryASet16(0x3090 + seg, 0x0004, memoryAGet16(0x3090 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=30904
        memoryASet16(0x3090 + seg, 0x000c, memoryAGet16(0x3090 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3090c
        memoryASet16(0x3092 + seg, 0x0002, memoryAGet16(0x3092 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=30922
        memoryASet16(0x3092 + seg, 0x000a, memoryAGet16(0x3092 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3092a
        memoryASet16(0x3094 + seg, 0x0000, memoryAGet16(0x3094 + seg, 0x0000) + seg); // 11a2 -> 138f; lin=30940
        memoryASet16(0x3094 + seg, 0x0008, memoryAGet16(0x3094 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30948
        memoryASet16(0x30c7 + seg, 0x000e, memoryAGet16(0x30c7 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=30c7e
        memoryASet16(0x30c9 + seg, 0x000c, memoryAGet16(0x30c9 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=30c9c
        memoryASet16(0x30cb + seg, 0x000a, memoryAGet16(0x30cb + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=30cba
        memoryASet16(0x30cd + seg, 0x0008, memoryAGet16(0x30cd + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=30cd8
        memoryASet16(0x30cf + seg, 0x0006, memoryAGet16(0x30cf + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=30cf6
        memoryASet16(0x30d1 + seg, 0x0004, memoryAGet16(0x30d1 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=30d14
        memoryASet16(0x30d3 + seg, 0x0002, memoryAGet16(0x30d3 + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=30d32
        memoryASet16(0x30d5 + seg, 0x0000, memoryAGet16(0x30d5 + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=30d50
        memoryASet16(0x30d6 + seg, 0x000e, memoryAGet16(0x30d6 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=30d6e
        memoryASet16(0x30d7 + seg, 0x0006, memoryAGet16(0x30d7 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=30d76
        memoryASet16(0x30d8 + seg, 0x000c, memoryAGet16(0x30d8 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=30d8c
        memoryASet16(0x30d9 + seg, 0x0004, memoryAGet16(0x30d9 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=30d94
        memoryASet16(0x30db + seg, 0x0002, memoryAGet16(0x30db + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=30db2
        memoryASet16(0x30dd + seg, 0x0000, memoryAGet16(0x30dd + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=30dd0
        memoryASet16(0x30de + seg, 0x000e, memoryAGet16(0x30de + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=30dee
        memoryASet16(0x30e0 + seg, 0x000c, memoryAGet16(0x30e0 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=30e0c
        memoryASet16(0x30e3 + seg, 0x000a, memoryAGet16(0x30e3 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=30e3a
        memoryASet16(0x30e4 + seg, 0x0002, memoryAGet16(0x30e4 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=30e42
        memoryASet16(0x30e5 + seg, 0x0008, memoryAGet16(0x30e5 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=30e58
        memoryASet16(0x30e6 + seg, 0x0000, memoryAGet16(0x30e6 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=30e60
        memoryASet16(0x30e7 + seg, 0x000e, memoryAGet16(0x30e7 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=30e7e
        memoryASet16(0x30e9 + seg, 0x0008, memoryAGet16(0x30e9 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=30e98
        memoryASet16(0x30e9 + seg, 0x000c, memoryAGet16(0x30e9 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=30e9c
        memoryASet16(0x30eb + seg, 0x0002, memoryAGet16(0x30eb + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=30eb2
        memoryASet16(0x30eb + seg, 0x0006, memoryAGet16(0x30eb + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=30eb6
        memoryASet16(0x30eb + seg, 0x000a, memoryAGet16(0x30eb + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=30eba
        memoryASet16(0x30ed + seg, 0x0000, memoryAGet16(0x30ed + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=30ed0
        memoryASet16(0x30ed + seg, 0x0004, memoryAGet16(0x30ed + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=30ed4
        memoryASet16(0x30ed + seg, 0x0008, memoryAGet16(0x30ed + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30ed8
        memoryASet16(0x30ee + seg, 0x000e, memoryAGet16(0x30ee + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=30eee
        memoryASet16(0x30ef + seg, 0x0006, memoryAGet16(0x30ef + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=30ef6
        memoryASet16(0x30f0 + seg, 0x000c, memoryAGet16(0x30f0 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=30f0c
        memoryASet16(0x30f1 + seg, 0x0004, memoryAGet16(0x30f1 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=30f14
        memoryASet16(0x30f2 + seg, 0x000e, memoryAGet16(0x30f2 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=30f2e
        memoryASet16(0x30f3 + seg, 0x0002, memoryAGet16(0x30f3 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=30f32
        memoryASet16(0x30f5 + seg, 0x0000, memoryAGet16(0x30f5 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=30f50
        memoryASet16(0x30f6 + seg, 0x0006, memoryAGet16(0x30f6 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=30f66
        memoryASet16(0x30f6 + seg, 0x000a, memoryAGet16(0x30f6 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=30f6a
        memoryASet16(0x30f6 + seg, 0x000e, memoryAGet16(0x30f6 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=30f6e
        memoryASet16(0x30f8 + seg, 0x0004, memoryAGet16(0x30f8 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=30f84
        memoryASet16(0x30f8 + seg, 0x0008, memoryAGet16(0x30f8 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=30f88
        memoryASet16(0x30f8 + seg, 0x000c, memoryAGet16(0x30f8 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=30f8c
        memoryASet16(0x30fa + seg, 0x0006, memoryAGet16(0x30fa + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=30fa6
        memoryASet16(0x30fa + seg, 0x000a, memoryAGet16(0x30fa + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=30faa
        memoryASet16(0x30fc + seg, 0x0008, memoryAGet16(0x30fc + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=30fc8
        memoryASet16(0x30fd + seg, 0x000e, memoryAGet16(0x30fd + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=30fde
        memoryASet16(0x30fe + seg, 0x0006, memoryAGet16(0x30fe + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=30fe6
        memoryASet16(0x30ff + seg, 0x000c, memoryAGet16(0x30ff + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=30ffc
        memoryASet16(0x3100 + seg, 0x0004, memoryAGet16(0x3100 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=31004
        memoryASet16(0x3101 + seg, 0x000a, memoryAGet16(0x3101 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3101a
        memoryASet16(0x3102 + seg, 0x0002, memoryAGet16(0x3102 + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=31022
        memoryASet16(0x3103 + seg, 0x000c, memoryAGet16(0x3103 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=3103c
        memoryASet16(0x3104 + seg, 0x0000, memoryAGet16(0x3104 + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=31040
        memoryASet16(0x3105 + seg, 0x000a, memoryAGet16(0x3105 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3105a
        memoryASet16(0x3105 + seg, 0x000e, memoryAGet16(0x3105 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=3105e
        memoryASet16(0x3107 + seg, 0x0008, memoryAGet16(0x3107 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31078
        memoryASet16(0x3107 + seg, 0x000c, memoryAGet16(0x3107 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=3107c
        memoryASet16(0x3109 + seg, 0x0006, memoryAGet16(0x3109 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31096
        memoryASet16(0x3109 + seg, 0x000a, memoryAGet16(0x3109 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3109a
        memoryASet16(0x310b + seg, 0x0000, memoryAGet16(0x310b + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=310b0
        memoryASet16(0x310b + seg, 0x0004, memoryAGet16(0x310b + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=310b4
        memoryASet16(0x310b + seg, 0x0008, memoryAGet16(0x310b + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=310b8
        memoryASet16(0x310c + seg, 0x000e, memoryAGet16(0x310c + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=310ce
        memoryASet16(0x310d + seg, 0x0002, memoryAGet16(0x310d + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=310d2
        memoryASet16(0x310d + seg, 0x0006, memoryAGet16(0x310d + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=310d6
        memoryASet16(0x310e + seg, 0x000c, memoryAGet16(0x310e + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=310ec
        memoryASet16(0x310f + seg, 0x0000, memoryAGet16(0x310f + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=310f0
        memoryASet16(0x310f + seg, 0x0004, memoryAGet16(0x310f + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=310f4
        memoryASet16(0x3110 + seg, 0x000a, memoryAGet16(0x3110 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3110a
        memoryASet16(0x3110 + seg, 0x000e, memoryAGet16(0x3110 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=3110e
        memoryASet16(0x3111 + seg, 0x0002, memoryAGet16(0x3111 + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=31112
        memoryASet16(0x3112 + seg, 0x0008, memoryAGet16(0x3112 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31128
        memoryASet16(0x3112 + seg, 0x000c, memoryAGet16(0x3112 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=3112c
        memoryASet16(0x3113 + seg, 0x0000, memoryAGet16(0x3113 + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=31130
        memoryASet16(0x3114 + seg, 0x0006, memoryAGet16(0x3114 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31146
        memoryASet16(0x3114 + seg, 0x000a, memoryAGet16(0x3114 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3114a
        memoryASet16(0x3114 + seg, 0x000e, memoryAGet16(0x3114 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=3114e
        memoryASet16(0x3116 + seg, 0x0004, memoryAGet16(0x3116 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31164
        memoryASet16(0x3116 + seg, 0x0008, memoryAGet16(0x3116 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31168
        memoryASet16(0x3116 + seg, 0x000c, memoryAGet16(0x3116 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3116c
        memoryASet16(0x3118 + seg, 0x0006, memoryAGet16(0x3118 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31186
        memoryASet16(0x3118 + seg, 0x000a, memoryAGet16(0x3118 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3118a
        memoryASet16(0x311a + seg, 0x0004, memoryAGet16(0x311a + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=311a4
        memoryASet16(0x311a + seg, 0x0008, memoryAGet16(0x311a + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=311a8
        memoryASet16(0x311c + seg, 0x0002, memoryAGet16(0x311c + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=311c2
        memoryASet16(0x311c + seg, 0x0006, memoryAGet16(0x311c + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=311c6
        memoryASet16(0x311d + seg, 0x000c, memoryAGet16(0x311d + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=311dc
        memoryASet16(0x311e + seg, 0x0000, memoryAGet16(0x311e + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=311e0
        memoryASet16(0x311e + seg, 0x0004, memoryAGet16(0x311e + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=311e4
        memoryASet16(0x311f + seg, 0x000e, memoryAGet16(0x311f + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=311fe
        memoryASet16(0x3120 + seg, 0x0002, memoryAGet16(0x3120 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31202
        memoryASet16(0x3121 + seg, 0x000c, memoryAGet16(0x3121 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=3121c
        memoryASet16(0x3122 + seg, 0x0000, memoryAGet16(0x3122 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31220
        memoryASet16(0x3123 + seg, 0x000a, memoryAGet16(0x3123 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3123a
        memoryASet16(0x3123 + seg, 0x000e, memoryAGet16(0x3123 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3123e
        memoryASet16(0x3125 + seg, 0x0004, memoryAGet16(0x3125 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=31254
        memoryASet16(0x3125 + seg, 0x0008, memoryAGet16(0x3125 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31258
        memoryASet16(0x3125 + seg, 0x000c, memoryAGet16(0x3125 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3125c
        memoryASet16(0x3127 + seg, 0x0006, memoryAGet16(0x3127 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31276
        memoryASet16(0x3127 + seg, 0x000a, memoryAGet16(0x3127 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3127a
        memoryASet16(0x3129 + seg, 0x0004, memoryAGet16(0x3129 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=31294
        memoryASet16(0x3129 + seg, 0x0008, memoryAGet16(0x3129 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31298
        memoryASet16(0x312b + seg, 0x0002, memoryAGet16(0x312b + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=312b2
        memoryASet16(0x312b + seg, 0x0006, memoryAGet16(0x312b + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=312b6
        memoryASet16(0x312d + seg, 0x0000, memoryAGet16(0x312d + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=312d0
        memoryASet16(0x312d + seg, 0x0004, memoryAGet16(0x312d + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=312d4
        memoryASet16(0x312e + seg, 0x000e, memoryAGet16(0x312e + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=312ee
        memoryASet16(0x312f + seg, 0x0002, memoryAGet16(0x312f + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=312f2
        memoryASet16(0x3130 + seg, 0x0008, memoryAGet16(0x3130 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31308
        memoryASet16(0x3130 + seg, 0x000c, memoryAGet16(0x3130 + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=3130c
        memoryASet16(0x3131 + seg, 0x0000, memoryAGet16(0x3131 + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=31310
        memoryASet16(0x3132 + seg, 0x0006, memoryAGet16(0x3132 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31326
        memoryASet16(0x3132 + seg, 0x000a, memoryAGet16(0x3132 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3132a
        memoryASet16(0x3132 + seg, 0x000e, memoryAGet16(0x3132 + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=3132e
        memoryASet16(0x3134 + seg, 0x000c, memoryAGet16(0x3134 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3134c
        memoryASet16(0x3136 + seg, 0x0006, memoryAGet16(0x3136 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31366
        memoryASet16(0x3136 + seg, 0x000a, memoryAGet16(0x3136 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3136a
        memoryASet16(0x3138 + seg, 0x0004, memoryAGet16(0x3138 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=31384
        memoryASet16(0x3138 + seg, 0x0008, memoryAGet16(0x3138 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31388
        memoryASet16(0x313a + seg, 0x0002, memoryAGet16(0x313a + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=313a2
        memoryASet16(0x313a + seg, 0x0006, memoryAGet16(0x313a + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=313a6
        memoryASet16(0x313c + seg, 0x0000, memoryAGet16(0x313c + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=313c0
        memoryASet16(0x313c + seg, 0x0004, memoryAGet16(0x313c + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=313c4
        memoryASet16(0x313d + seg, 0x000e, memoryAGet16(0x313d + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=313de
        memoryASet16(0x313e + seg, 0x0002, memoryAGet16(0x313e + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=313e2
        memoryASet16(0x313f + seg, 0x000c, memoryAGet16(0x313f + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=313fc
        memoryASet16(0x3140 + seg, 0x0000, memoryAGet16(0x3140 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31400
        memoryASet16(0x3141 + seg, 0x000a, memoryAGet16(0x3141 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3141a
        memoryASet16(0x3141 + seg, 0x000e, memoryAGet16(0x3141 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3141e
        memoryASet16(0x3143 + seg, 0x0008, memoryAGet16(0x3143 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31438
        memoryASet16(0x3143 + seg, 0x000c, memoryAGet16(0x3143 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3143c
        memoryASet16(0x3145 + seg, 0x0006, memoryAGet16(0x3145 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31456
        memoryASet16(0x3145 + seg, 0x000a, memoryAGet16(0x3145 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3145a
        memoryASet16(0x3147 + seg, 0x0004, memoryAGet16(0x3147 + seg, 0x0004) + seg); // 0fa8 -> 1195; lin=31474
        memoryASet16(0x3147 + seg, 0x0008, memoryAGet16(0x3147 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31478
        memoryASet16(0x3149 + seg, 0x0002, memoryAGet16(0x3149 + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=31492
        memoryASet16(0x3149 + seg, 0x0006, memoryAGet16(0x3149 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31496
        memoryASet16(0x314b + seg, 0x0000, memoryAGet16(0x314b + seg, 0x0000) + seg); // 0fa8 -> 1195; lin=314b0
        memoryASet16(0x314b + seg, 0x0004, memoryAGet16(0x314b + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=314b4
        memoryASet16(0x314c + seg, 0x000e, memoryAGet16(0x314c + seg, 0x000e) + seg); // 0fa8 -> 1195; lin=314ce
        memoryASet16(0x314d + seg, 0x0002, memoryAGet16(0x314d + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=314d2
        memoryASet16(0x314e + seg, 0x000c, memoryAGet16(0x314e + seg, 0x000c) + seg); // 0fa8 -> 1195; lin=314ec
        memoryASet16(0x314f + seg, 0x0000, memoryAGet16(0x314f + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=314f0
        memoryASet16(0x3150 + seg, 0x000a, memoryAGet16(0x3150 + seg, 0x000a) + seg); // 0fa8 -> 1195; lin=3150a
        memoryASet16(0x3150 + seg, 0x000e, memoryAGet16(0x3150 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3150e
        memoryASet16(0x3152 + seg, 0x0008, memoryAGet16(0x3152 + seg, 0x0008) + seg); // 0fa8 -> 1195; lin=31528
        memoryASet16(0x3152 + seg, 0x000c, memoryAGet16(0x3152 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3152c
        memoryASet16(0x3154 + seg, 0x0002, memoryAGet16(0x3154 + seg, 0x0002) + seg); // 0fa8 -> 1195; lin=31542
        memoryASet16(0x3154 + seg, 0x0006, memoryAGet16(0x3154 + seg, 0x0006) + seg); // 0fa8 -> 1195; lin=31546
        memoryASet16(0x3154 + seg, 0x000a, memoryAGet16(0x3154 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3154a
        memoryASet16(0x3156 + seg, 0x0000, memoryAGet16(0x3156 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31560
        memoryASet16(0x3156 + seg, 0x0008, memoryAGet16(0x3156 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31568
        memoryASet16(0x3158 + seg, 0x0002, memoryAGet16(0x3158 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31582
        memoryASet16(0x3158 + seg, 0x0006, memoryAGet16(0x3158 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31586
        memoryASet16(0x315a + seg, 0x0000, memoryAGet16(0x315a + seg, 0x0000) + seg); // 1080 -> 126d; lin=315a0
        memoryASet16(0x315a + seg, 0x0004, memoryAGet16(0x315a + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=315a4
        memoryASet16(0x315b + seg, 0x000a, memoryAGet16(0x315b + seg, 0x000a) + seg); // 1080 -> 126d; lin=315ba
        memoryASet16(0x315b + seg, 0x000e, memoryAGet16(0x315b + seg, 0x000e) + seg); // 1080 -> 126d; lin=315be
        memoryASet16(0x315c + seg, 0x0002, memoryAGet16(0x315c + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=315c2
        memoryASet16(0x315d + seg, 0x000c, memoryAGet16(0x315d + seg, 0x000c) + seg); // 1080 -> 126d; lin=315dc
        memoryASet16(0x315e + seg, 0x0000, memoryAGet16(0x315e + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=315e0
        memoryASet16(0x315f + seg, 0x000a, memoryAGet16(0x315f + seg, 0x000a) + seg); // 1080 -> 126d; lin=315fa
        memoryASet16(0x315f + seg, 0x000e, memoryAGet16(0x315f + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=315fe
        memoryASet16(0x3161 + seg, 0x0008, memoryAGet16(0x3161 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31618
        memoryASet16(0x3161 + seg, 0x000c, memoryAGet16(0x3161 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3161c
        memoryASet16(0x3163 + seg, 0x0002, memoryAGet16(0x3163 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31632
        memoryASet16(0x3163 + seg, 0x0006, memoryAGet16(0x3163 + seg, 0x0006) + seg); // 1080 -> 126d; lin=31636
        memoryASet16(0x3163 + seg, 0x000a, memoryAGet16(0x3163 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3163a
        memoryASet16(0x3165 + seg, 0x0000, memoryAGet16(0x3165 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31650
        memoryASet16(0x3165 + seg, 0x0008, memoryAGet16(0x3165 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31658
        memoryASet16(0x3167 + seg, 0x0002, memoryAGet16(0x3167 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31672
        memoryASet16(0x3167 + seg, 0x0006, memoryAGet16(0x3167 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31676
        memoryASet16(0x3169 + seg, 0x0000, memoryAGet16(0x3169 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31690
        memoryASet16(0x3169 + seg, 0x0004, memoryAGet16(0x3169 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31694
        memoryASet16(0x316a + seg, 0x000e, memoryAGet16(0x316a + seg, 0x000e) + seg); // 1080 -> 126d; lin=316ae
        memoryASet16(0x316b + seg, 0x0002, memoryAGet16(0x316b + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=316b2
        memoryASet16(0x316c + seg, 0x000c, memoryAGet16(0x316c + seg, 0x000c) + seg); // 1080 -> 126d; lin=316cc
        memoryASet16(0x316d + seg, 0x0000, memoryAGet16(0x316d + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=316d0
        memoryASet16(0x316e + seg, 0x000a, memoryAGet16(0x316e + seg, 0x000a) + seg); // 1080 -> 126d; lin=316ea
        memoryASet16(0x316e + seg, 0x000e, memoryAGet16(0x316e + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=316ee
        memoryASet16(0x3170 + seg, 0x0004, memoryAGet16(0x3170 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31704
        memoryASet16(0x3170 + seg, 0x000c, memoryAGet16(0x3170 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3170c
        memoryASet16(0x3172 + seg, 0x0006, memoryAGet16(0x3172 + seg, 0x0006) + seg); // 1080 -> 126d; lin=31726
        memoryASet16(0x3172 + seg, 0x000a, memoryAGet16(0x3172 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3172a
        memoryASet16(0x3174 + seg, 0x0008, memoryAGet16(0x3174 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31748
        memoryASet16(0x3175 + seg, 0x000e, memoryAGet16(0x3175 + seg, 0x000e) + seg); // 1080 -> 126d; lin=3175e
        memoryASet16(0x3176 + seg, 0x0006, memoryAGet16(0x3176 + seg, 0x0006) + seg); // 1080 -> 126d; lin=31766
        memoryASet16(0x3177 + seg, 0x000c, memoryAGet16(0x3177 + seg, 0x000c) + seg); // 1080 -> 126d; lin=3177c
        memoryASet16(0x3178 + seg, 0x0004, memoryAGet16(0x3178 + seg, 0x0004) + seg); // 1080 -> 126d; lin=31784
        memoryASet16(0x3179 + seg, 0x000a, memoryAGet16(0x3179 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3179a
        memoryASet16(0x317a + seg, 0x0002, memoryAGet16(0x317a + seg, 0x0002) + seg); // 1080 -> 126d; lin=317a2
        memoryASet16(0x317c + seg, 0x0000, memoryAGet16(0x317c + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=317c0
        memoryASet16(0x317d + seg, 0x000e, memoryAGet16(0x317d + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=317de
        memoryASet16(0x317f + seg, 0x000c, memoryAGet16(0x317f + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=317fc
        memoryASet16(0x3181 + seg, 0x0002, memoryAGet16(0x3181 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31812
        memoryASet16(0x3181 + seg, 0x000a, memoryAGet16(0x3181 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3181a
        memoryASet16(0x3183 + seg, 0x0008, memoryAGet16(0x3183 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31838
        memoryASet16(0x3185 + seg, 0x0006, memoryAGet16(0x3185 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31856
        memoryASet16(0x3187 + seg, 0x0004, memoryAGet16(0x3187 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31874
        memoryASet16(0x3189 + seg, 0x0002, memoryAGet16(0x3189 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31892
        memoryASet16(0x318b + seg, 0x0000, memoryAGet16(0x318b + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=318b0
        memoryASet16(0x318c + seg, 0x000a, memoryAGet16(0x318c + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=318ca
        memoryASet16(0x318c + seg, 0x000e, memoryAGet16(0x318c + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=318ce
        memoryASet16(0x318e + seg, 0x0008, memoryAGet16(0x318e + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=318e8
        memoryASet16(0x318e + seg, 0x000c, memoryAGet16(0x318e + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=318ec
        memoryASet16(0x3190 + seg, 0x0006, memoryAGet16(0x3190 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31906
        memoryASet16(0x3190 + seg, 0x000a, memoryAGet16(0x3190 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3190a
        memoryASet16(0x3192 + seg, 0x0004, memoryAGet16(0x3192 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31924
        memoryASet16(0x3192 + seg, 0x0008, memoryAGet16(0x3192 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31928
        memoryASet16(0x3194 + seg, 0x0002, memoryAGet16(0x3194 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31942
        memoryASet16(0x3194 + seg, 0x0006, memoryAGet16(0x3194 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31946
        memoryASet16(0x3196 + seg, 0x0000, memoryAGet16(0x3196 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31960
        memoryASet16(0x3196 + seg, 0x0004, memoryAGet16(0x3196 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31964
        memoryASet16(0x3197 + seg, 0x000a, memoryAGet16(0x3197 + seg, 0x000a) + seg); // 1080 -> 126d; lin=3197a
        memoryASet16(0x3197 + seg, 0x000e, memoryAGet16(0x3197 + seg, 0x000e) + seg); // 1080 -> 126d; lin=3197e
        memoryASet16(0x3198 + seg, 0x0002, memoryAGet16(0x3198 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31982
        memoryASet16(0x3199 + seg, 0x0008, memoryAGet16(0x3199 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31998
        memoryASet16(0x3199 + seg, 0x000c, memoryAGet16(0x3199 + seg, 0x000c) + seg); // 1080 -> 126d; lin=3199c
        memoryASet16(0x319a + seg, 0x0000, memoryAGet16(0x319a + seg, 0x0000) + seg); // 1080 -> 126d; lin=319a0
        memoryASet16(0x319b + seg, 0x0006, memoryAGet16(0x319b + seg, 0x0006) + seg); // 1080 -> 126d; lin=319b6
        memoryASet16(0x319b + seg, 0x000a, memoryAGet16(0x319b + seg, 0x000a) + seg); // 1080 -> 126d; lin=319ba
        memoryASet16(0x319b + seg, 0x000e, memoryAGet16(0x319b + seg, 0x000e) + seg); // 1080 -> 126d; lin=319be
        memoryASet16(0x319d + seg, 0x0004, memoryAGet16(0x319d + seg, 0x0004) + seg); // 1080 -> 126d; lin=319d4
        memoryASet16(0x319d + seg, 0x0008, memoryAGet16(0x319d + seg, 0x0008) + seg); // 1080 -> 126d; lin=319d8
        memoryASet16(0x319d + seg, 0x000c, memoryAGet16(0x319d + seg, 0x000c) + seg); // 1080 -> 126d; lin=319dc
        memoryASet16(0x319f + seg, 0x0002, memoryAGet16(0x319f + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=319f2
        memoryASet16(0x319f + seg, 0x0006, memoryAGet16(0x319f + seg, 0x0006) + seg); // 1080 -> 126d; lin=319f6
        memoryASet16(0x319f + seg, 0x000a, memoryAGet16(0x319f + seg, 0x000a) + seg); // 1080 -> 126d; lin=319fa
        memoryASet16(0x31a1 + seg, 0x0000, memoryAGet16(0x31a1 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31a10
        memoryASet16(0x31a1 + seg, 0x0004, memoryAGet16(0x31a1 + seg, 0x0004) + seg); // 1080 -> 126d; lin=31a14
        memoryASet16(0x31a1 + seg, 0x0008, memoryAGet16(0x31a1 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31a18
        memoryASet16(0x31a2 + seg, 0x000e, memoryAGet16(0x31a2 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31a2e
        memoryASet16(0x31a3 + seg, 0x0002, memoryAGet16(0x31a3 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31a32
        memoryASet16(0x31a3 + seg, 0x0006, memoryAGet16(0x31a3 + seg, 0x0006) + seg); // 1080 -> 126d; lin=31a36
        memoryASet16(0x31a4 + seg, 0x000c, memoryAGet16(0x31a4 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=31a4c
        memoryASet16(0x31a5 + seg, 0x0000, memoryAGet16(0x31a5 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31a50
        memoryASet16(0x31a5 + seg, 0x0004, memoryAGet16(0x31a5 + seg, 0x0004) + seg); // 1080 -> 126d; lin=31a54
        memoryASet16(0x31a6 + seg, 0x000a, memoryAGet16(0x31a6 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31a6a
        memoryASet16(0x31a6 + seg, 0x000e, memoryAGet16(0x31a6 + seg, 0x000e) + seg); // 1080 -> 126d; lin=31a6e
        memoryASet16(0x31a7 + seg, 0x0002, memoryAGet16(0x31a7 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31a72
        memoryASet16(0x31a8 + seg, 0x0008, memoryAGet16(0x31a8 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31a88
        memoryASet16(0x31a8 + seg, 0x000c, memoryAGet16(0x31a8 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31a8c
        memoryASet16(0x31a9 + seg, 0x0000, memoryAGet16(0x31a9 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31a90
        memoryASet16(0x31aa + seg, 0x0006, memoryAGet16(0x31aa + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31aa6
        memoryASet16(0x31aa + seg, 0x000a, memoryAGet16(0x31aa + seg, 0x000a) + seg); // 1080 -> 126d; lin=31aaa
        memoryASet16(0x31aa + seg, 0x000e, memoryAGet16(0x31aa + seg, 0x000e) + seg); // 1080 -> 126d; lin=31aae
        memoryASet16(0x31ac + seg, 0x0004, memoryAGet16(0x31ac + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31ac4
        memoryASet16(0x31ac + seg, 0x0008, memoryAGet16(0x31ac + seg, 0x0008) + seg); // 1080 -> 126d; lin=31ac8
        memoryASet16(0x31ac + seg, 0x000c, memoryAGet16(0x31ac + seg, 0x000c) + seg); // 1080 -> 126d; lin=31acc
        memoryASet16(0x31ae + seg, 0x0002, memoryAGet16(0x31ae + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31ae2
        memoryASet16(0x31ae + seg, 0x0006, memoryAGet16(0x31ae + seg, 0x0006) + seg); // 1080 -> 126d; lin=31ae6
        memoryASet16(0x31ae + seg, 0x000a, memoryAGet16(0x31ae + seg, 0x000a) + seg); // 1080 -> 126d; lin=31aea
        memoryASet16(0x31b0 + seg, 0x0000, memoryAGet16(0x31b0 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31b00
        memoryASet16(0x31b0 + seg, 0x0004, memoryAGet16(0x31b0 + seg, 0x0004) + seg); // 1080 -> 126d; lin=31b04
        memoryASet16(0x31b0 + seg, 0x0008, memoryAGet16(0x31b0 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31b08
        memoryASet16(0x31b1 + seg, 0x000e, memoryAGet16(0x31b1 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31b1e
        memoryASet16(0x31b2 + seg, 0x0002, memoryAGet16(0x31b2 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31b22
        memoryASet16(0x31b2 + seg, 0x0006, memoryAGet16(0x31b2 + seg, 0x0006) + seg); // 1080 -> 126d; lin=31b26
        memoryASet16(0x31b3 + seg, 0x000c, memoryAGet16(0x31b3 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31b3c
        memoryASet16(0x31b4 + seg, 0x0000, memoryAGet16(0x31b4 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31b40
        memoryASet16(0x31b4 + seg, 0x0004, memoryAGet16(0x31b4 + seg, 0x0004) + seg); // 1080 -> 126d; lin=31b44
        memoryASet16(0x31b5 + seg, 0x000a, memoryAGet16(0x31b5 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31b5a
        memoryASet16(0x31b5 + seg, 0x000e, memoryAGet16(0x31b5 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31b5e
        memoryASet16(0x31b6 + seg, 0x0002, memoryAGet16(0x31b6 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31b62
        memoryASet16(0x31b7 + seg, 0x0008, memoryAGet16(0x31b7 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31b78
        memoryASet16(0x31b7 + seg, 0x000c, memoryAGet16(0x31b7 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=31b7c
        memoryASet16(0x31b8 + seg, 0x0000, memoryAGet16(0x31b8 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31b80
        memoryASet16(0x31b9 + seg, 0x000a, memoryAGet16(0x31b9 + seg, 0x000a) + seg); // 1080 -> 126d; lin=31b9a
        memoryASet16(0x31b9 + seg, 0x000e, memoryAGet16(0x31b9 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31b9e
        memoryASet16(0x31bb + seg, 0x0008, memoryAGet16(0x31bb + seg, 0x0008) + seg); // 1080 -> 126d; lin=31bb8
        memoryASet16(0x31bb + seg, 0x000c, memoryAGet16(0x31bb + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=31bbc
        memoryASet16(0x31bd + seg, 0x0006, memoryAGet16(0x31bd + seg, 0x0006) + seg); // 1080 -> 126d; lin=31bd6
        memoryASet16(0x31bd + seg, 0x000a, memoryAGet16(0x31bd + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31bda
        memoryASet16(0x31bf + seg, 0x0004, memoryAGet16(0x31bf + seg, 0x0004) + seg); // 1080 -> 126d; lin=31bf4
        memoryASet16(0x31bf + seg, 0x0008, memoryAGet16(0x31bf + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31bf8
        memoryASet16(0x31c1 + seg, 0x0002, memoryAGet16(0x31c1 + seg, 0x0002) + seg); // 1080 -> 126d; lin=31c12
        memoryASet16(0x31c1 + seg, 0x0006, memoryAGet16(0x31c1 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31c16
        memoryASet16(0x31c3 + seg, 0x0000, memoryAGet16(0x31c3 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31c30
        memoryASet16(0x31c3 + seg, 0x0004, memoryAGet16(0x31c3 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31c34
        memoryASet16(0x31c4 + seg, 0x000e, memoryAGet16(0x31c4 + seg, 0x000e) + seg); // 1080 -> 126d; lin=31c4e
        memoryASet16(0x31c5 + seg, 0x0002, memoryAGet16(0x31c5 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31c52
        memoryASet16(0x31c6 + seg, 0x000c, memoryAGet16(0x31c6 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31c6c
        memoryASet16(0x31c7 + seg, 0x0000, memoryAGet16(0x31c7 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31c70
        memoryASet16(0x31c8 + seg, 0x000a, memoryAGet16(0x31c8 + seg, 0x000a) + seg); // 1080 -> 126d; lin=31c8a
        memoryASet16(0x31c8 + seg, 0x000e, memoryAGet16(0x31c8 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31c8e
        memoryASet16(0x31ca + seg, 0x000c, memoryAGet16(0x31ca + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=31cac
        memoryASet16(0x31cc + seg, 0x000a, memoryAGet16(0x31cc + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31cca
        memoryASet16(0x31ce + seg, 0x0008, memoryAGet16(0x31ce + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31ce8
        memoryASet16(0x31d0 + seg, 0x0006, memoryAGet16(0x31d0 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31d06
        memoryASet16(0x31d1 + seg, 0x000c, memoryAGet16(0x31d1 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31d1c
        memoryASet16(0x31d2 + seg, 0x0000, memoryAGet16(0x31d2 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31d20
        memoryASet16(0x31d2 + seg, 0x0004, memoryAGet16(0x31d2 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31d24
        memoryASet16(0x31d3 + seg, 0x000a, memoryAGet16(0x31d3 + seg, 0x000a) + seg); // 1080 -> 126d; lin=31d3a
        memoryASet16(0x31d3 + seg, 0x000e, memoryAGet16(0x31d3 + seg, 0x000e) + seg); // 1080 -> 126d; lin=31d3e
        memoryASet16(0x31d4 + seg, 0x0002, memoryAGet16(0x31d4 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31d42
        memoryASet16(0x31d6 + seg, 0x0000, memoryAGet16(0x31d6 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31d60
        memoryASet16(0x31d7 + seg, 0x000a, memoryAGet16(0x31d7 + seg, 0x000a) + seg); // 1080 -> 126d; lin=31d7a
        memoryASet16(0x31d7 + seg, 0x000e, memoryAGet16(0x31d7 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31d7e
        memoryASet16(0x31d9 + seg, 0x0004, memoryAGet16(0x31d9 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31d94
        memoryASet16(0x31d9 + seg, 0x0008, memoryAGet16(0x31d9 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31d98
        memoryASet16(0x31d9 + seg, 0x000c, memoryAGet16(0x31d9 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31d9c
        memoryASet16(0x31db + seg, 0x0002, memoryAGet16(0x31db + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31db2
        memoryASet16(0x31db + seg, 0x0006, memoryAGet16(0x31db + seg, 0x0006) + seg); // 1080 -> 126d; lin=31db6
        memoryASet16(0x31db + seg, 0x000a, memoryAGet16(0x31db + seg, 0x000a) + seg); // 1080 -> 126d; lin=31dba
        memoryASet16(0x31dd + seg, 0x0000, memoryAGet16(0x31dd + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31dd0
        memoryASet16(0x31dd + seg, 0x0004, memoryAGet16(0x31dd + seg, 0x0004) + seg); // 1080 -> 126d; lin=31dd4
        memoryASet16(0x31dd + seg, 0x0008, memoryAGet16(0x31dd + seg, 0x0008) + seg); // 1080 -> 126d; lin=31dd8
        memoryASet16(0x31de + seg, 0x000e, memoryAGet16(0x31de + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31dee
        memoryASet16(0x31df + seg, 0x0002, memoryAGet16(0x31df + seg, 0x0002) + seg); // 1080 -> 126d; lin=31df2
        memoryASet16(0x31df + seg, 0x0006, memoryAGet16(0x31df + seg, 0x0006) + seg); // 1080 -> 126d; lin=31df6
        memoryASet16(0x31e0 + seg, 0x000c, memoryAGet16(0x31e0 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=31e0c
        memoryASet16(0x31e1 + seg, 0x0004, memoryAGet16(0x31e1 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31e14
        memoryASet16(0x31e2 + seg, 0x000a, memoryAGet16(0x31e2 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31e2a
        memoryASet16(0x31e3 + seg, 0x0002, memoryAGet16(0x31e3 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31e32
        memoryASet16(0x31e4 + seg, 0x0008, memoryAGet16(0x31e4 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31e48
        memoryASet16(0x31e4 + seg, 0x000c, memoryAGet16(0x31e4 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31e4c
        memoryASet16(0x31e5 + seg, 0x0000, memoryAGet16(0x31e5 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31e50
        memoryASet16(0x31e6 + seg, 0x0006, memoryAGet16(0x31e6 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31e66
        memoryASet16(0x31e6 + seg, 0x000a, memoryAGet16(0x31e6 + seg, 0x000a) + seg); // 1080 -> 126d; lin=31e6a
        memoryASet16(0x31e6 + seg, 0x000e, memoryAGet16(0x31e6 + seg, 0x000e) + seg); // 1080 -> 126d; lin=31e6e
        memoryASet16(0x31e8 + seg, 0x0004, memoryAGet16(0x31e8 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31e84
        memoryASet16(0x31e8 + seg, 0x0008, memoryAGet16(0x31e8 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31e88
        memoryASet16(0x31e8 + seg, 0x000c, memoryAGet16(0x31e8 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31e8c
        memoryASet16(0x31ea + seg, 0x0006, memoryAGet16(0x31ea + seg, 0x0006) + seg); // 1080 -> 126d; lin=31ea6
        memoryASet16(0x31ea + seg, 0x000a, memoryAGet16(0x31ea + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31eaa
        memoryASet16(0x31ec + seg, 0x0004, memoryAGet16(0x31ec + seg, 0x0004) + seg); // 1080 -> 126d; lin=31ec4
        memoryASet16(0x31ec + seg, 0x0008, memoryAGet16(0x31ec + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31ec8
        memoryASet16(0x31ee + seg, 0x0002, memoryAGet16(0x31ee + seg, 0x0002) + seg); // 1080 -> 126d; lin=31ee2
        memoryASet16(0x31ee + seg, 0x0006, memoryAGet16(0x31ee + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31ee6
        memoryASet16(0x31f0 + seg, 0x0000, memoryAGet16(0x31f0 + seg, 0x0000) + seg); // 1080 -> 126d; lin=31f00
        memoryASet16(0x31f0 + seg, 0x0004, memoryAGet16(0x31f0 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=31f04
        memoryASet16(0x31f1 + seg, 0x000e, memoryAGet16(0x31f1 + seg, 0x000e) + seg); // 1080 -> 126d; lin=31f1e
        memoryASet16(0x31f2 + seg, 0x0002, memoryAGet16(0x31f2 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=31f22
        memoryASet16(0x31f3 + seg, 0x000c, memoryAGet16(0x31f3 + seg, 0x000c) + seg); // 1080 -> 126d; lin=31f3c
        memoryASet16(0x31f4 + seg, 0x0000, memoryAGet16(0x31f4 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31f40
        memoryASet16(0x31f5 + seg, 0x000a, memoryAGet16(0x31f5 + seg, 0x000a) + seg); // 1080 -> 126d; lin=31f5a
        memoryASet16(0x31f5 + seg, 0x000e, memoryAGet16(0x31f5 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31f5e
        memoryASet16(0x31f7 + seg, 0x0008, memoryAGet16(0x31f7 + seg, 0x0008) + seg); // 1080 -> 126d; lin=31f78
        memoryASet16(0x31f7 + seg, 0x000c, memoryAGet16(0x31f7 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=31f7c
        memoryASet16(0x31f9 + seg, 0x0006, memoryAGet16(0x31f9 + seg, 0x0006) + seg); // 1080 -> 126d; lin=31f96
        memoryASet16(0x31f9 + seg, 0x000a, memoryAGet16(0x31f9 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=31f9a
        memoryASet16(0x31fb + seg, 0x0000, memoryAGet16(0x31fb + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=31fb0
        memoryASet16(0x31fb + seg, 0x0008, memoryAGet16(0x31fb + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=31fb8
        memoryASet16(0x31fc + seg, 0x000e, memoryAGet16(0x31fc + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=31fce
        memoryASet16(0x31fd + seg, 0x0006, memoryAGet16(0x31fd + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=31fd6
        memoryASet16(0x31fe + seg, 0x000c, memoryAGet16(0x31fe + seg, 0x000c) + seg); // 1080 -> 126d; lin=31fec
        memoryASet16(0x31ff + seg, 0x0004, memoryAGet16(0x31ff + seg, 0x0004) + seg); // 1080 -> 126d; lin=31ff4
        memoryASet16(0x3200 + seg, 0x000a, memoryAGet16(0x3200 + seg, 0x000a) + seg); // 1080 -> 126d; lin=3200a
        memoryASet16(0x3201 + seg, 0x0002, memoryAGet16(0x3201 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=32012
        memoryASet16(0x3202 + seg, 0x0008, memoryAGet16(0x3202 + seg, 0x0008) + seg); // 1080 -> 126d; lin=32028
        memoryASet16(0x3203 + seg, 0x0000, memoryAGet16(0x3203 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32030
        memoryASet16(0x3204 + seg, 0x0006, memoryAGet16(0x3204 + seg, 0x0006) + seg); // 1080 -> 126d; lin=32046
        memoryASet16(0x3204 + seg, 0x000e, memoryAGet16(0x3204 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3204e
        memoryASet16(0x3206 + seg, 0x0008, memoryAGet16(0x3206 + seg, 0x0008) + seg); // 11a2 -> 138f; lin=32068
        memoryASet16(0x3206 + seg, 0x000c, memoryAGet16(0x3206 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3206c
        memoryASet16(0x3208 + seg, 0x0002, memoryAGet16(0x3208 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=32082
        memoryASet16(0x3208 + seg, 0x0006, memoryAGet16(0x3208 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32086
        memoryASet16(0x3208 + seg, 0x000a, memoryAGet16(0x3208 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3208a
        memoryASet16(0x320a + seg, 0x0004, memoryAGet16(0x320a + seg, 0x0004) + seg); // 11a2 -> 138f; lin=320a4
        memoryASet16(0x320a + seg, 0x0008, memoryAGet16(0x320a + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=320a8
        memoryASet16(0x320c + seg, 0x0002, memoryAGet16(0x320c + seg, 0x0002) + seg); // 11a2 -> 138f; lin=320c2
        memoryASet16(0x320c + seg, 0x0006, memoryAGet16(0x320c + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=320c6
        memoryASet16(0x320e + seg, 0x0000, memoryAGet16(0x320e + seg, 0x0000) + seg); // 11a2 -> 138f; lin=320e0
        memoryASet16(0x320e + seg, 0x0004, memoryAGet16(0x320e + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=320e4
        memoryASet16(0x320f + seg, 0x000a, memoryAGet16(0x320f + seg, 0x000a) + seg); // 11a2 -> 138f; lin=320fa
        memoryASet16(0x320f + seg, 0x000e, memoryAGet16(0x320f + seg, 0x000e) + seg); // 11a2 -> 138f; lin=320fe
        memoryASet16(0x3210 + seg, 0x0002, memoryAGet16(0x3210 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=32102
        memoryASet16(0x3211 + seg, 0x000c, memoryAGet16(0x3211 + seg, 0x000c) + seg); // 11a2 -> 138f; lin=3211c
        memoryASet16(0x3212 + seg, 0x0000, memoryAGet16(0x3212 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32120
        memoryASet16(0x3213 + seg, 0x000a, memoryAGet16(0x3213 + seg, 0x000a) + seg); // 11a2 -> 138f; lin=3213a
        memoryASet16(0x3213 + seg, 0x000e, memoryAGet16(0x3213 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3213e
        memoryASet16(0x3215 + seg, 0x0008, memoryAGet16(0x3215 + seg, 0x0008) + seg); // 11a2 -> 138f; lin=32158
        memoryASet16(0x3215 + seg, 0x000c, memoryAGet16(0x3215 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3215c
        memoryASet16(0x3217 + seg, 0x0006, memoryAGet16(0x3217 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32176
        memoryASet16(0x3217 + seg, 0x000a, memoryAGet16(0x3217 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3217a
        memoryASet16(0x3219 + seg, 0x0000, memoryAGet16(0x3219 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32190
        memoryASet16(0x3219 + seg, 0x0004, memoryAGet16(0x3219 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=32194
        memoryASet16(0x3219 + seg, 0x0008, memoryAGet16(0x3219 + seg, 0x0008) + seg); // 11a2 -> 138f; lin=32198
        memoryASet16(0x321a + seg, 0x000e, memoryAGet16(0x321a + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=321ae
        memoryASet16(0x321b + seg, 0x0002, memoryAGet16(0x321b + seg, 0x0002) + seg); // 11a2 -> 138f; lin=321b2
        memoryASet16(0x321b + seg, 0x0006, memoryAGet16(0x321b + seg, 0x0006) + seg); // 11a2 -> 138f; lin=321b6
        memoryASet16(0x321c + seg, 0x000c, memoryAGet16(0x321c + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=321cc
        memoryASet16(0x321d + seg, 0x0000, memoryAGet16(0x321d + seg, 0x0000) + seg); // 11a2 -> 138f; lin=321d0
        memoryASet16(0x321d + seg, 0x0004, memoryAGet16(0x321d + seg, 0x0004) + seg); // 11a2 -> 138f; lin=321d4
        memoryASet16(0x321e + seg, 0x000a, memoryAGet16(0x321e + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=321ea
        memoryASet16(0x321e + seg, 0x000e, memoryAGet16(0x321e + seg, 0x000e) + seg); // 11a2 -> 138f; lin=321ee
        memoryASet16(0x321f + seg, 0x0002, memoryAGet16(0x321f + seg, 0x0002) + seg); // 11a2 -> 138f; lin=321f2
        memoryASet16(0x3220 + seg, 0x0008, memoryAGet16(0x3220 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=32208
        memoryASet16(0x3221 + seg, 0x0000, memoryAGet16(0x3221 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32210
        memoryASet16(0x3222 + seg, 0x0006, memoryAGet16(0x3222 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32226
        memoryASet16(0x3222 + seg, 0x000e, memoryAGet16(0x3222 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3222e
        memoryASet16(0x3224 + seg, 0x000c, memoryAGet16(0x3224 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3224c
        memoryASet16(0x3226 + seg, 0x000a, memoryAGet16(0x3226 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3226a
        memoryASet16(0x3228 + seg, 0x0008, memoryAGet16(0x3228 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=32288
        memoryASet16(0x322a + seg, 0x0006, memoryAGet16(0x322a + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=322a6
        memoryASet16(0x322b + seg, 0x000c, memoryAGet16(0x322b + seg, 0x000c) + seg); // 11a2 -> 138f; lin=322bc
        memoryASet16(0x322c + seg, 0x0004, memoryAGet16(0x322c + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=322c4
        memoryASet16(0x322d + seg, 0x000a, memoryAGet16(0x322d + seg, 0x000a) + seg); // 11a2 -> 138f; lin=322da
        memoryASet16(0x322d + seg, 0x000e, memoryAGet16(0x322d + seg, 0x000e) + seg); // 11a2 -> 138f; lin=322de
        memoryASet16(0x322e + seg, 0x0002, memoryAGet16(0x322e + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=322e2
        memoryASet16(0x322f + seg, 0x0008, memoryAGet16(0x322f + seg, 0x0008) + seg); // 11a2 -> 138f; lin=322f8
        memoryASet16(0x322f + seg, 0x000c, memoryAGet16(0x322f + seg, 0x000c) + seg); // 11a2 -> 138f; lin=322fc
        memoryASet16(0x3230 + seg, 0x0000, memoryAGet16(0x3230 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32300
        memoryASet16(0x3231 + seg, 0x0006, memoryAGet16(0x3231 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32316
        memoryASet16(0x3231 + seg, 0x000a, memoryAGet16(0x3231 + seg, 0x000a) + seg); // 11a2 -> 138f; lin=3231a
        memoryASet16(0x3231 + seg, 0x000e, memoryAGet16(0x3231 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3231e
        memoryASet16(0x3233 + seg, 0x0004, memoryAGet16(0x3233 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=32334
        memoryASet16(0x3233 + seg, 0x0008, memoryAGet16(0x3233 + seg, 0x0008) + seg); // 11a2 -> 138f; lin=32338
        memoryASet16(0x3233 + seg, 0x000c, memoryAGet16(0x3233 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3233c
        memoryASet16(0x3235 + seg, 0x0002, memoryAGet16(0x3235 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=32352
        memoryASet16(0x3235 + seg, 0x0006, memoryAGet16(0x3235 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32356
        memoryASet16(0x3235 + seg, 0x000a, memoryAGet16(0x3235 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3235a
        memoryASet16(0x3237 + seg, 0x0000, memoryAGet16(0x3237 + seg, 0x0000) + seg); // 11a2 -> 138f; lin=32370
        memoryASet16(0x3237 + seg, 0x0004, memoryAGet16(0x3237 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=32374
        memoryASet16(0x3237 + seg, 0x0008, memoryAGet16(0x3237 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=32378
        memoryASet16(0x3238 + seg, 0x000e, memoryAGet16(0x3238 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3238e
        memoryASet16(0x3239 + seg, 0x0002, memoryAGet16(0x3239 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=32392
        memoryASet16(0x3239 + seg, 0x0006, memoryAGet16(0x3239 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32396
        memoryASet16(0x323a + seg, 0x000c, memoryAGet16(0x323a + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=323ac
        memoryASet16(0x323b + seg, 0x0000, memoryAGet16(0x323b + seg, 0x0000) + seg); // 11a2 -> 138f; lin=323b0
        memoryASet16(0x323b + seg, 0x0004, memoryAGet16(0x323b + seg, 0x0004) + seg); // 11a2 -> 138f; lin=323b4
        memoryASet16(0x323c + seg, 0x000a, memoryAGet16(0x323c + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=323ca
        memoryASet16(0x323c + seg, 0x000e, memoryAGet16(0x323c + seg, 0x000e) + seg); // 11a2 -> 138f; lin=323ce
        memoryASet16(0x323d + seg, 0x0002, memoryAGet16(0x323d + seg, 0x0002) + seg); // 11a2 -> 138f; lin=323d2
        memoryASet16(0x323e + seg, 0x0008, memoryAGet16(0x323e + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=323e8
        memoryASet16(0x323e + seg, 0x000c, memoryAGet16(0x323e + seg, 0x000c) + seg); // 11a2 -> 138f; lin=323ec
        memoryASet16(0x323f + seg, 0x0000, memoryAGet16(0x323f + seg, 0x0000) + seg); // 11a2 -> 138f; lin=323f0
        memoryASet16(0x3240 + seg, 0x0006, memoryAGet16(0x3240 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32406
        memoryASet16(0x3240 + seg, 0x000e, memoryAGet16(0x3240 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3240e
        memoryASet16(0x3242 + seg, 0x0004, memoryAGet16(0x3242 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=32424
        memoryASet16(0x3242 + seg, 0x000c, memoryAGet16(0x3242 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3242c
        memoryASet16(0x3244 + seg, 0x0002, memoryAGet16(0x3244 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=32442
        memoryASet16(0x3244 + seg, 0x0006, memoryAGet16(0x3244 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32446
        memoryASet16(0x3244 + seg, 0x000a, memoryAGet16(0x3244 + seg, 0x000a) + seg); // 11a2 -> 138f; lin=3244a
        memoryASet16(0x3246 + seg, 0x0000, memoryAGet16(0x3246 + seg, 0x0000) + seg); // 11a2 -> 138f; lin=32460
        memoryASet16(0x3246 + seg, 0x0004, memoryAGet16(0x3246 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=32464
        memoryASet16(0x3246 + seg, 0x0008, memoryAGet16(0x3246 + seg, 0x0008) + seg); // 11a2 -> 138f; lin=32468
        memoryASet16(0x3247 + seg, 0x000e, memoryAGet16(0x3247 + seg, 0x000e) + seg); // 11a2 -> 138f; lin=3247e
        memoryASet16(0x3248 + seg, 0x0006, memoryAGet16(0x3248 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32486
        memoryASet16(0x324a + seg, 0x0004, memoryAGet16(0x324a + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=324a4
        memoryASet16(0x324b + seg, 0x000a, memoryAGet16(0x324b + seg, 0x000a) + seg); // 11a2 -> 138f; lin=324ba
        memoryASet16(0x324c + seg, 0x0002, memoryAGet16(0x324c + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=324c2
        memoryASet16(0x324e + seg, 0x0000, memoryAGet16(0x324e + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=324e0
        memoryASet16(0x324f + seg, 0x0006, memoryAGet16(0x324f + seg, 0x0006) + seg); // 11a2 -> 138f; lin=324f6
        memoryASet16(0x324f + seg, 0x000e, memoryAGet16(0x324f + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=324fe
        memoryASet16(0x3251 + seg, 0x000c, memoryAGet16(0x3251 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3251c
        memoryASet16(0x3253 + seg, 0x000a, memoryAGet16(0x3253 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3253a
        memoryASet16(0x3255 + seg, 0x0000, memoryAGet16(0x3255 + seg, 0x0000) + seg); // 11a2 -> 138f; lin=32550
        memoryASet16(0x3255 + seg, 0x0008, memoryAGet16(0x3255 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=32558
        memoryASet16(0x3256 + seg, 0x000e, memoryAGet16(0x3256 + seg, 0x000e) + seg); // 11a2 -> 138f; lin=3256e
        memoryASet16(0x3257 + seg, 0x0006, memoryAGet16(0x3257 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32576
        memoryASet16(0x3258 + seg, 0x000c, memoryAGet16(0x3258 + seg, 0x000c) + seg); // 11a2 -> 138f; lin=3258c
        memoryASet16(0x3259 + seg, 0x0004, memoryAGet16(0x3259 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=32594
        memoryASet16(0x325a + seg, 0x000a, memoryAGet16(0x325a + seg, 0x000a) + seg); // 11a2 -> 138f; lin=325aa
        memoryASet16(0x325b + seg, 0x0002, memoryAGet16(0x325b + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=325b2
        memoryASet16(0x325c + seg, 0x0008, memoryAGet16(0x325c + seg, 0x0008) + seg); // 11a2 -> 138f; lin=325c8
        memoryASet16(0x325d + seg, 0x0000, memoryAGet16(0x325d + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=325d0
        memoryASet16(0x325e + seg, 0x0006, memoryAGet16(0x325e + seg, 0x0006) + seg); // 11a2 -> 138f; lin=325e6
        memoryASet16(0x325e + seg, 0x000e, memoryAGet16(0x325e + seg, 0x000e) + seg); // 11a2 -> 138f; lin=325ee
        memoryASet16(0x3260 + seg, 0x0004, memoryAGet16(0x3260 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=32604
        memoryASet16(0x3260 + seg, 0x000c, memoryAGet16(0x3260 + seg, 0x000c) + seg); // 11a2 -> 138f; lin=3260c
        memoryASet16(0x3262 + seg, 0x0002, memoryAGet16(0x3262 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=32622
        memoryASet16(0x3262 + seg, 0x0006, memoryAGet16(0x3262 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32626
        memoryASet16(0x3262 + seg, 0x000a, memoryAGet16(0x3262 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3262a
        memoryASet16(0x3264 + seg, 0x0000, memoryAGet16(0x3264 + seg, 0x0000) + seg); // 11a2 -> 138f; lin=32640
        memoryASet16(0x3264 + seg, 0x0004, memoryAGet16(0x3264 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=32644
        memoryASet16(0x3264 + seg, 0x0008, memoryAGet16(0x3264 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=32648
        memoryASet16(0x3265 + seg, 0x000e, memoryAGet16(0x3265 + seg, 0x000e) + seg); // 11a2 -> 138f; lin=3265e
        memoryASet16(0x3266 + seg, 0x0002, memoryAGet16(0x3266 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=32662
        memoryASet16(0x3266 + seg, 0x0006, memoryAGet16(0x3266 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32666
        memoryASet16(0x3268 + seg, 0x0000, memoryAGet16(0x3268 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32680
        memoryASet16(0x3268 + seg, 0x0004, memoryAGet16(0x3268 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=32684
        memoryASet16(0x3269 + seg, 0x000e, memoryAGet16(0x3269 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3269e
        memoryASet16(0x326a + seg, 0x0002, memoryAGet16(0x326a + seg, 0x0002) + seg); // 11a2 -> 138f; lin=326a2
        memoryASet16(0x326b + seg, 0x000c, memoryAGet16(0x326b + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=326bc
        memoryASet16(0x326c + seg, 0x0000, memoryAGet16(0x326c + seg, 0x0000) + seg); // 11a2 -> 138f; lin=326c0
        memoryASet16(0x326d + seg, 0x000a, memoryAGet16(0x326d + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=326da
        memoryASet16(0x326d + seg, 0x000e, memoryAGet16(0x326d + seg, 0x000e) + seg); // 11a2 -> 138f; lin=326de
        memoryASet16(0x326f + seg, 0x0008, memoryAGet16(0x326f + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=326f8
        memoryASet16(0x326f + seg, 0x000c, memoryAGet16(0x326f + seg, 0x000c) + seg); // 11a2 -> 138f; lin=326fc
        memoryASet16(0x3271 + seg, 0x0002, memoryAGet16(0x3271 + seg, 0x0002) + seg); // 1080 -> 126d; lin=32712
        memoryASet16(0x3271 + seg, 0x0006, memoryAGet16(0x3271 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32716
        memoryASet16(0x3271 + seg, 0x000a, memoryAGet16(0x3271 + seg, 0x000a) + seg); // 09dc -> 0bc9; lin=3271a
        memoryASet16(0x3273 + seg, 0x0008, memoryAGet16(0x3273 + seg, 0x0008) + seg); // 09dc -> 0bc9; lin=32738
        memoryASet16(0x3275 + seg, 0x0006, memoryAGet16(0x3275 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32756
        memoryASet16(0x3276 + seg, 0x000c, memoryAGet16(0x3276 + seg, 0x000c) + seg); // 11a2 -> 138f; lin=3276c
        memoryASet16(0x3277 + seg, 0x0004, memoryAGet16(0x3277 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=32774
        memoryASet16(0x3278 + seg, 0x000a, memoryAGet16(0x3278 + seg, 0x000a) + seg); // 11a2 -> 138f; lin=3278a
        memoryASet16(0x3279 + seg, 0x0002, memoryAGet16(0x3279 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=32792
        memoryASet16(0x327a + seg, 0x0008, memoryAGet16(0x327a + seg, 0x0008) + seg); // 11a2 -> 138f; lin=327a8
        memoryASet16(0x327b + seg, 0x0000, memoryAGet16(0x327b + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=327b0
        memoryASet16(0x327c + seg, 0x0006, memoryAGet16(0x327c + seg, 0x0006) + seg); // 11a2 -> 138f; lin=327c6
        memoryASet16(0x327c + seg, 0x000e, memoryAGet16(0x327c + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=327ce
        memoryASet16(0x327e + seg, 0x0004, memoryAGet16(0x327e + seg, 0x0004) + seg); // 11a2 -> 138f; lin=327e4
        memoryASet16(0x3280 + seg, 0x0006, memoryAGet16(0x3280 + seg, 0x0006) + seg); // 09dc -> 0bc9; lin=32806
        memoryASet16(0x3280 + seg, 0x000a, memoryAGet16(0x3280 + seg, 0x000a) + seg); // 11a2 -> 138f; lin=3280a
        memoryASet16(0x3282 + seg, 0x0004, memoryAGet16(0x3282 + seg, 0x0004) + seg); // 09dc -> 0bc9; lin=32824
        memoryASet16(0x3282 + seg, 0x0008, memoryAGet16(0x3282 + seg, 0x0008) + seg); // 11a2 -> 138f; lin=32828
        memoryASet16(0x3284 + seg, 0x0002, memoryAGet16(0x3284 + seg, 0x0002) + seg); // 09dc -> 0bc9; lin=32842
        memoryASet16(0x3284 + seg, 0x0006, memoryAGet16(0x3284 + seg, 0x0006) + seg); // 11a2 -> 138f; lin=32846
        memoryASet16(0x3286 + seg, 0x0000, memoryAGet16(0x3286 + seg, 0x0000) + seg); // 09dc -> 0bc9; lin=32860
        memoryASet16(0x3286 + seg, 0x0004, memoryAGet16(0x3286 + seg, 0x0004) + seg); // 11a2 -> 138f; lin=32864
        memoryASet16(0x3287 + seg, 0x000e, memoryAGet16(0x3287 + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=3287e
        memoryASet16(0x3288 + seg, 0x0002, memoryAGet16(0x3288 + seg, 0x0002) + seg); // 11a2 -> 138f; lin=32882
        memoryASet16(0x3289 + seg, 0x000c, memoryAGet16(0x3289 + seg, 0x000c) + seg); // 09dc -> 0bc9; lin=3289c
        memoryASet16(0x328a + seg, 0x0000, memoryAGet16(0x328a + seg, 0x0000) + seg); // 11a2 -> 138f; lin=328a0
        memoryASet16(0x328b + seg, 0x000a, memoryAGet16(0x328b + seg, 0x000a) + seg); // 11a2 -> 138f; lin=328ba
        memoryASet16(0x328b + seg, 0x000e, memoryAGet16(0x328b + seg, 0x000e) + seg); // 09dc -> 0bc9; lin=328be
        memoryASet16(0x3322 + seg, 0x000e, memoryAGet16(0x3322 + seg, 0x000e) + seg); // 1d06 -> 1ef3; lin=3322e
        memoryASet16(0x3323 + seg, 0x0002, memoryAGet16(0x3323 + seg, 0x0002) + seg); // 1d06 -> 1ef3; lin=33232
        memoryASet16(0x35df + seg, 0x000c, memoryAGet16(0x35df + seg, 0x000c) + seg); // 0000 -> 01ed; lin=35dfc
        memoryASet16(0x35e0 + seg, 0x0000, memoryAGet16(0x35e0 + seg, 0x0000) + seg); // 0000 -> 01ed; lin=35e00
        memoryASet16(0x35e0 + seg, 0x0004, memoryAGet16(0x35e0 + seg, 0x0004) + seg); // 0000 -> 01ed; lin=35e04
}


