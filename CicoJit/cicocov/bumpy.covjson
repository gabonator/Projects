coverageData=[[[3,0,28,"header"],[1,28,128,"reloc"]],[[0,128,256,"reloc"]],[[0,256,384,"reloc"]],[[0,384,512,"reloc"]],[[0,512,640,"reloc"]],[[0,640,768,"reloc"]],[[0,768,896,"reloc"]],[[0,896,1024,"reloc"]],[[0,1024,1152,"reloc"]],[[0,1152,1280,"reloc"]],[[0,1280,1408,"reloc"]],[[0,1408,1536,"reloc"]],[[0,1536,1664,"reloc"]],[[0,1664,1792,"reloc"]],[[0,1792,1920,"reloc"]],[[0,1920,2048,"reloc"]],[[0,2048,2176,"reloc"]],[[0,2176,2304,"reloc"]],[[0,2304,2432,"reloc"]],[[0,2432,2560,"reloc"]],[[0,2560,2688,"reloc"]],[[0,2688,2816,"reloc"]],[[0,2816,2944,"reloc"]],[[0,2944,3072,"reloc"]],[[0,3072,3200,"reloc"]],[[0,3200,3328,"reloc"]],[[0,3328,3456,"reloc"]],[[0,3456,3584,"reloc"]],[[0,3584,3712,"reloc"]],[[0,3712,3840,"reloc"]],[[0,3840,3968,"reloc"]],[[0,3968,4096,"reloc"]],[[0,4096,4224,"reloc"]],[[2,4224,4228,"reloc"]],null,null,[[1,4608,4736,"method","sub_1ed0"]],[[0,4736,4864,"method","sub_1ed0"],[1,4854,4864,"method","sub_1fc6"]],[[2,4864,4911,"method","sub_1ed0"],[2,4864,4911,"method","sub_1fc6"],[3,4885,4911,"method","sub_1fe5"],[3,4911,4978,"method","sub_1fff"],[1,4978,4992,"method","sub_2042"],[3,4885,4911,"method","sub_ca53"]],[[1,5098,5120,"method","sub_1ed0"],[1,5104,5120,"method","sub_1fc6"],[1,5104,5120,"method","sub_1fe5"],[2,4992,5023,"method","sub_2042"],[3,5023,5090,"method","sub_206f"],[3,5090,5098,"method","sub_20b2"],[1,5098,5120,"method","sub_c91e"],[1,5104,5120,"method","sub_ca53"]],[[2,5120,5208,"method","sub_1ed0"],[2,5120,5208,"method","sub_1fc6"],[2,5120,5208,"method","sub_1fe5"],[3,5123,5208,"method","sub_20d3"],[1,5208,5248,"method","sub_2128"],[2,5120,5208,"method","sub_c91e"],[2,5120,5208,"method","sub_ca53"]],[[2,5248,5250,"method","sub_2128"],[1,5250,5376,"method","sub_2152"]],[[0,5376,5504,"method","sub_2152"]],[[2,5504,5610,"method","sub_2152"],[1,5610,5632,"method","sub_22ba"]],[[2,5632,5654,"method","sub_22ba"],[1,5654,5760,"method","sub_22e6"]],[[0,5760,5888,"method","sub_22e6"]],[[2,5888,5993,"method","sub_22e6"],[1,5993,6016,"method","sub_2439"]],[[2,6016,6119,"method","sub_2439"],[1,6119,6144,"method","sub_24b7"]],[[2,6144,6148,"method","sub_24b7"],[3,6148,6203,"method","sub_24d4"],[1,6203,6272,"method","sub_250b"]],[[2,6272,6296,"method","sub_250b"]],null,[[1,6640,6656,"method","sub_26c0"]],[[2,6656,6678,"method","sub_26c0"],[1,6678,6784,"method","sub_26e6"]],[[2,6784,6865,"method","sub_26e6"],[1,6865,6912,"method","sub_27a1"]],[[0,6912,7040,"method","sub_27a1"]],[[0,7040,7168,"method","sub_27a1"]],[[2,7168,7175,"method","sub_27a1"],[1,7175,7296,"method","sub_28d7"]],[[2,7296,7312,"method","sub_28d7"],[1,7312,7424,"method","sub_2960"]],[[0,7424,7552,"method","sub_2960"]],[[2,7552,7560,"method","sub_2960"],[3,7560,7673,"method","sub_2a58"],[1,7673,7680,"method","sub_2ac9"]],[[2,7680,7704,"method","sub_2ac9"],[1,7704,7808,"method","sub_2ae8"]],[[0,7808,7936,"method","sub_2ae8"]],[[0,7936,8064,"method","sub_2ae8"]],[[2,8064,8093,"method","sub_2ae8"],[1,8093,8192,"method","sub_2c6d"]],[[0,8192,8320,"method","sub_2c6d"]],[[0,8320,8448,"method","sub_2c6d"]],[[2,8448,8570,"method","sub_2c6d"],[1,8570,8576,"method","sub_2e4a"]],[[0,8576,8704,"method","sub_2e4a"]],[[0,8704,8832,"method","sub_2e4a"]],[[0,8832,8960,"method","sub_2e4a"]],[[0,8960,9088,"method","sub_2e4a"]],[[2,9088,9195,"method","sub_2e4a"],[1,9195,9216,"method","sub_30bb"]],[[0,9216,9344,"method","sub_30bb"]],[[0,9344,9472,"method","sub_30bb"]],[[2,9472,9545,"method","sub_30bb"],[1,9545,9600,"method","sub_3219"]],[[2,9600,9612,"method","sub_3219"],[3,9612,9650,"method","sub_325c"],[3,9650,9695,"method","sub_3282"],[1,9695,9728,"method","sub_32af"]],[[2,9728,9843,"method","sub_32af"],[1,9843,9856,"method","sub_3343"]],[[2,9856,9956,"method","sub_3343"],[1,9956,9984,"method","sub_33b4"]],[[0,9984,10112,"method","sub_33b4"]],[[2,10112,10145,"method","sub_33b4"],[1,10145,10240,"method","sub_3471"]],[[2,10240,10334,"method","sub_3471"],[1,10334,10368,"method","sub_352e"]],[[0,10368,10496,"method","sub_352e"]],[[0,10496,10624,"method","sub_352e"]],[[2,10624,10695,"method","sub_352e"],[1,10695,10752,"method","sub_3697"]],[[0,10752,10880,"method","sub_3697"]],[[0,10880,11008,"method","sub_3697"]],[[0,11008,11136,"method","sub_3697"]],[[2,11136,11169,"method","sub_3697"],[3,11169,11236,"method","sub_3871"],[1,11236,11264,"method","sub_38b4"]],[[2,11264,11296,"method","sub_38b4"],[3,11296,11367,"method","sub_38f0"],[1,11367,11392,"method","sub_3937"]],[[0,11392,11520,"method","sub_3937"]],[[2,11520,11563,"method","sub_3937"],[1,11563,11648,"method","sub_39fb"]],[[2,11648,11735,"method","sub_39fb"],[1,11735,11776,"method","sub_3aa7"]],[[2,11776,11841,"method","sub_3aa7"],[1,11841,11904,"method","sub_3b11"]],[[2,11904,11954,"method","sub_3b11"],[3,11954,12010,"method","sub_3b82"],[1,12010,12032,"method","sub_3bba"]],[[2,12032,12070,"method","sub_3bba"],[1,12070,12160,"method","sub_3bf6"]],[[2,12160,12254,"method","sub_3bf6"],[1,12254,12288,"method","sub_3cae"]],[[2,12288,12290,"method","sub_3cae"],[3,12290,12349,"method","sub_3cd2"],[3,12349,12382,"method","sub_3d0d"],[1,12382,12416,"method","sub_3d2e"]],[[2,12416,12432,"method","sub_3d2e"],[3,12432,12482,"method","sub_3d60"],[1,12482,12544,"method","sub_3d92"]],[[2,12544,12547,"method","sub_3d92"],[3,12547,12606,"method","sub_3dd3"],[3,12606,12671,"method","sub_3e0e"],[1,12671,12672,"method","sub_3e4f"]],[[2,12672,12734,"method","sub_3e4f"],[1,12734,12800,"method","sub_3e8e"]],[[2,12800,12925,"method","sub_3e8e"],[1,12925,12928,"method","sub_3f4d"]],[[0,12928,13056,"method","sub_3f4d"]],[[2,13056,13112,"method","sub_3f4d"],[1,13112,13184,"method","sub_4008"]],[[2,13184,13243,"method","sub_4008"],[3,13243,13287,"method","sub_408b"],[1,13287,13312,"method","sub_40b7"]],[[2,13312,13409,"method","sub_40b7"],[1,13409,13440,"method","sub_4131"]],[[2,13440,13453,"method","sub_4131"],[3,13453,13488,"method","sub_415d"],[3,13488,13505,"method","sub_4180"],[3,13505,13522,"method","sub_4191"],[3,13522,13564,"method","sub_41a2"],[1,13564,13568,"method","sub_41cc"]],[[2,13568,13626,"method","sub_41cc"],[3,13626,13679,"method","sub_420a"],[1,13679,13696,"method","sub_423f"]],[[2,13696,13710,"method","sub_423f"],[3,13710,13750,"method","sub_425e"],[1,13750,13824,"method","sub_4286"]],[[2,13824,13859,"method","sub_4286"],[3,13859,13936,"method","sub_42f3"],[1,13936,13952,"method","sub_4340"]],[[2,13952,13966,"method","sub_4340"],[3,13966,14039,"method","sub_435e"],[1,14039,14080,"method","sub_43a7"]],[[2,14080,14090,"method","sub_43a7"],[3,14090,14143,"method","sub_43da"],[1,14143,14208,"method","sub_440f"]],[[2,14208,14253,"method","sub_440f"],[1,14253,14336,"method","sub_447d"]],[[2,14336,14388,"method","sub_447d"],[1,14388,14464,"method","sub_4504"]],[[2,14464,14497,"method","sub_4504"],[1,14497,14592,"method","sub_4571"]],[[2,14592,14604,"method","sub_4571"],[3,14604,14710,"method","sub_45dc"],[1,14710,14720,"method","sub_4646"]],[[2,14720,14814,"method","sub_4646"],[1,14814,14848,"method","sub_46ae"]],[[2,14848,14864,"method","sub_46ae"],[1,14864,14976,"method","sub_46e0"]],[[2,14976,15072,"method","sub_46e0"],[3,15072,15097,"method","sub_47b0"],[1,15097,15104,"method","sub_47c9"]],[[2,15104,15205,"method","sub_47c9"],[1,15205,15232,"method","sub_4835"]],[[2,15232,15270,"method","sub_4835"],[1,15270,15360,"method","sub_4876"]],[[2,15360,15370,"method","sub_4876"],[3,15370,15480,"method","sub_48da"],[1,15480,15488,"method","sub_4948"]],[[0,15488,15616,"method","sub_4948"]],[[0,15616,15744,"method","sub_4948"]],[[0,15744,15872,"method","sub_4948"]],[[0,15872,16000,"method","sub_4948"]],[[0,16000,16128,"method","sub_4948"]],[[2,16128,16148,"method","sub_4948"],[1,16148,16256,"method","sub_4be4"]],[[0,16256,16384,"method","sub_4be4"]],[[0,16384,16512,"method","sub_4be4"]],[[2,16512,16632,"method","sub_4be4"],[1,16632,16640,"method","sub_4dc8"]],[[0,16640,16768,"method","sub_4dc8"]],[[2,16768,16812,"method","sub_4dc8"],[1,16812,16896,"method","sub_4e7c"]],[[0,16896,17024,"method","sub_4e7c"]],[[2,17024,17117,"method","sub_4e7c"],[1,17117,17152,"method","sub_4fad"]],[[0,17152,17280,"method","sub_4fad"]],[[2,17280,17374,"method","sub_4fad"],[1,17374,17408,"method","sub_50ae"]],[[0,17408,17536,"method","sub_50ae"]],[[2,17536,17551,"method","sub_50ae"],[3,17551,17584,"method","sub_515f"],[1,17584,17664,"method","sub_5180"]],[[0,17664,17792,"method","sub_5180"]],[[2,17792,17861,"method","sub_5180"],[1,17861,17920,"method","sub_5295"]],[[2,17920,18023,"method","sub_5295"],[1,18023,18048,"method","sub_5337"]],[[0,18048,18176,"method","sub_5337"]],[[0,18176,18304,"method","sub_5337"]],[[2,18304,18341,"method","sub_5337"],[1,18341,18432,"method","sub_5475"]],[[0,18432,18560,"method","sub_5475"]],[[0,18560,18688,"method","sub_5475"]],[[0,18688,18816,"method","sub_5475"]],[[0,18816,18944,"method","sub_5475"]],[[2,18944,19017,"method","sub_5475"],[3,19018,19024,"switch"],[1,19026,19072,"method","sub_5722"]],[[0,19072,19200,"method","sub_5722"]],[[0,19200,19328,"method","sub_5722"]],[[0,19328,19456,"method","sub_5722"]],[[0,19456,19584,"method","sub_5722"]],[[2,19584,19592,"method","sub_5722"],[3,19592,19634,"method","sub_5958"],[1,19634,19712,"method","sub_5982"]],[[2,19712,19727,"method","sub_5982"],[3,19727,19820,"method","sub_59df"],[1,19820,19840,"method","sub_5a3c"]],[[2,19840,19913,"method","sub_5a3c"],[1,19913,19968,"method","sub_5a99"]],[[2,19968,20006,"method","sub_5a99"],[3,20006,20047,"method","sub_5af6"],[1,20047,20096,"method","sub_5b1f"]],[[2,20096,20125,"method","sub_5b1f"],[3,20125,20215,"method","sub_5b6d"],[1,20215,20224,"method","sub_5bc7"]],[[0,20224,20352,"method","sub_5bc7"]],[[2,20352,20477,"method","sub_5bc7"],[1,20477,20480,"method","sub_5ccd"]],[[2,20480,20596,"method","sub_5ccd"],[1,20596,20608,"method","sub_5d44"]],[[2,20608,20618,"method","sub_5d44"],[3,20618,20692,"method","sub_5d5a"],[1,20692,20736,"method","sub_5da4"]],[[0,20736,20864,"method","sub_5da4"]],[[0,20864,20992,"method","sub_5da4"]],[[2,20992,21013,"method","sub_5da4"],[1,21013,21120,"method","sub_5ee5"]],[[0,21120,21248,"method","sub_5ee5"]],[[0,21248,21376,"method","sub_5ee5"]],[[0,21376,21504,"method","sub_5ee5"]],[[2,21504,21537,"method","sub_5ee5"],[3,21566,21603,"method","sub_5ee5"],[1,21603,21632,"method","sub_6133"]],[[2,21632,21721,"method","sub_6133"],[1,21721,21760,"method","sub_61a9"]],[[2,21760,21765,"method","sub_61a9"],[3,21765,21787,"method","sub_61d5"],[3,21787,21828,"method","sub_61eb"],[3,21828,21857,"method","sub_6214"],[1,21857,21888,"method","sub_6231"]],[[2,21888,21912,"method","sub_6231"],[3,21912,21941,"method","sub_6268"],[3,21941,21970,"method","sub_6285"],[3,21970,21999,"method","sub_62a2"],[1,21999,22016,"method","sub_62bf"]],[[2,22016,22028,"method","sub_62bf"],[3,22028,22071,"method","sub_62dc"],[3,22071,22100,"method","sub_6307"],[1,22100,22144,"method","sub_6324"]],[[2,22144,22154,"method","sub_6324"],[3,22154,22208,"method","sub_635a"],[1,22208,22272,"method","sub_6390"]],[[2,22272,22284,"method","sub_6390"],[3,22284,22322,"method","sub_63dc"],[3,22322,22394,"method","sub_6402"],[1,22394,22400,"method","sub_644a"]],[[2,22400,22432,"method","sub_644a"],[3,22432,22479,"method","sub_6470"],[1,22479,22528,"method","sub_649f"]],[[2,22528,22533,"method","sub_649f"],[3,22533,22589,"method","sub_64d5"],[3,22589,22622,"method","sub_650d"],[3,22622,22653,"method","sub_652e"],[1,22653,22656,"method","sub_654d"]],[[2,22656,22684,"method","sub_654d"],[3,22684,22715,"method","sub_656c"],[1,22715,22784,"method","sub_658b"]],[[2,22784,22821,"method","sub_658b"],[3,22821,22827,"switch"],[3,22829,22855,"method","sub_65fd"],[1,22855,22912,"method","sub_6617"]],[[2,22912,22987,"method","sub_6617"],[1,22987,23040,"method","sub_669b"]],[[2,23040,23042,"method","sub_669b"],[3,23042,23100,"method","sub_66d2"],[1,23100,23168,"method","sub_670c"]],[[2,23168,23209,"method","sub_670c"],[1,23209,23296,"method","sub_6779"]],[[2,23296,23302,"method","sub_6779"],[3,23302,23388,"method","sub_67d6"],[1,23388,23424,"method","sub_682c"]],[[2,23424,23445,"method","sub_682c"],[3,23445,23511,"method","sub_6865"],[1,23511,23552,"method","sub_68a7"]],[[0,23552,23680,"method","sub_68a7"]],[[0,23680,23808,"method","sub_68a7"]],[[2,23808,23886,"method","sub_68a7"],[1,23886,23936,"method","sub_6a1e"]],[[2,23936,24006,"method","sub_6a1e"],[1,24006,24064,"method","sub_6a96"]],[[2,24064,24084,"method","sub_6a96"],[1,24084,24192,"method","sub_6ae4"]],[[2,24192,24217,"method","sub_6ae4"],[1,24217,24320,"method","sub_6b69"]],[[0,24320,24448,"method","sub_6b69"]],[[2,24448,24511,"method","sub_6b69"],[3,24511,24570,"method","sub_6c8f"],[1,24570,24576,"method","sub_6cca"]],[[2,24576,24644,"method","sub_6cca"],[3,24644,24703,"method","sub_6d14"],[1,24703,24704,"method","sub_6d4f"]],[[2,24704,24777,"method","sub_6d4f"],[1,24777,24832,"method","sub_6d99"]],[[2,24832,24836,"method","sub_6d99"],[3,24836,24910,"method","sub_6dd4"],[1,24910,24960,"method","sub_6e1e"]],[[2,24960,24969,"method","sub_6e1e"],[3,24969,25043,"method","sub_6e59"],[1,25043,25088,"method","sub_6ea3"]],[[2,25088,25091,"method","sub_6ea3"],[3,25091,25125,"method","sub_6ed3"],[3,25125,25151,"method","sub_6ef5"],[3,25151,25177,"method","sub_6f0f"],[3,25177,25199,"method","sub_6f29"],[1,25199,25216,"method","sub_6f3f"]],[[2,25216,25221,"method","sub_6f3f"],[3,25221,25280,"method","sub_6f55"],[3,25280,25339,"method","sub_6f90"],[1,25339,25344,"method","sub_6fcb"]],[[0,25344,25472,"method","sub_6fcb"]],[[2,25472,25473,"method","sub_6fcb"],[3,25473,25560,"method","sub_7051"],[1,25560,25600,"method","sub_70a8"]],[[0,25600,25728,"method","sub_70a8"]],[[0,25728,25856,"method","sub_70a8"]],[[2,25856,25950,"method","sub_70a8"],[1,25950,25984,"method","sub_722e"]],[[0,25984,26112,"method","sub_722e"]],[[0,26112,26240,"method","sub_722e"]],[[0,26240,26368,"method","sub_722e"]],[[0,26368,26496,"method","sub_722e"]],[[0,26496,26624,"method","sub_722e"]],[[0,26624,26752,"method","sub_722e"]],[[2,26752,26753,"method","sub_722e"],[1,26753,26880,"method","sub_7551"]],[[0,26880,27008,"method","sub_7551"]],[[2,27008,27105,"method","sub_7551"],[1,27105,27136,"method","sub_76b1"]],[[0,27136,27264,"method","sub_76b1"]],[[0,27264,27392,"method","sub_76b1"]],[[0,27392,27520,"method","sub_76b1"]],[[2,27520,27603,"method","sub_76b1"],[1,27603,27648,"method","sub_78a3"]],[[0,27648,27776,"method","sub_78a3"]],[[0,27776,27904,"method","sub_78a3"]],[[0,27904,28032,"method","sub_78a3"]],[[0,28032,28160,"method","sub_78a3"]],[[0,28160,28288,"method","sub_78a3"]],[[2,28288,28295,"method","sub_78a3"],[1,28295,28416,"method","sub_7b57"]],[[0,28416,28544,"method","sub_7b57"]],[[0,28544,28672,"method","sub_7b57"]],[[0,28672,28800,"method","sub_7b57"]],[[0,28800,28928,"method","sub_7b57"]],[[0,28928,29056,"method","sub_7b57"]],[[2,29056,29147,"method","sub_7b57"],[1,29147,29184,"method","sub_7eab"]],[[2,29184,29245,"method","sub_7eab"],[1,29245,29312,"method","sub_7f0d"]],[[0,29312,29440,"method","sub_7f0d"]],[[2,29440,29488,"method","sub_7f0d"],[1,29488,29568,"method","sub_8000"]],[[2,29568,29571,"method","sub_8000"],[1,29571,29696,"method","sub_8053"]],[[0,29696,29824,"method","sub_8053"]],[[2,29824,29852,"method","sub_8053"],[1,29852,29952,"method","sub_816c"]],[[2,29952,29957,"method","sub_816c"],[3,29957,29990,"method","sub_81d5"],[3,29990,30066,"method","sub_81f6"],[1,30066,30080,"method","sub_8242"]],[[2,30080,30142,"method","sub_8242"],[1,30142,30208,"method","sub_828e"]],[[2,30208,30220,"method","sub_828e"],[3,30220,30301,"method","sub_82dc"],[3,30301,30334,"method","sub_832d"],[1,30334,30336,"method","sub_834e"]],[[2,30336,30401,"method","sub_834e"],[3,30401,30434,"method","sub_8391"],[3,30434,30463,"method","sub_83b2"],[1,30463,30464,"method","sub_83cf"]],[[2,30464,30492,"method","sub_83cf"],[3,30492,30517,"method","sub_83ec"],[3,30517,30542,"method","sub_8405"],[1,30542,30592,"method","sub_841e"]],[[2,30592,30599,"method","sub_841e"],[3,30599,30674,"method","sub_8457"],[3,30674,30693,"method","sub_84a2"],[3,30693,30715,"method","sub_84b5"],[1,30715,30720,"method","sub_84cb"]],[[2,30720,30737,"method","sub_84cb"],[3,30737,30759,"method","sub_84e1"],[3,30759,30792,"method","sub_84f7"],[1,30792,30848,"method","sub_8518"]],[[2,30848,30873,"method","sub_8518"],[3,30873,30936,"method","sub_8569"],[1,30936,30976,"method","sub_85a8"]],[[2,30976,30999,"method","sub_85a8"],[3,30999,31034,"method","sub_85e7"],[3,31034,31048,"method","sub_860a"],[1,31048,31104,"method","sub_8618"]],[[2,31104,31113,"method","sub_8618"],[3,31113,31178,"method","sub_8659"]],null,[[1,31486,31488,"method","sub_87ce"]],[[2,31488,31522,"method","sub_87ce"],[3,31546,31582,"method","sub_880a"],[1,31582,31616,"method","sub_882e"]],[[2,31616,31623,"method","sub_882e"],[3,31623,31658,"method","sub_8857"],[1,31658,31744,"method","sub_887a"]],[[0,31744,31872,"method","sub_887a"]],[[2,31872,31881,"method","sub_887a"],[1,31881,32000,"method","sub_8959"]],[[0,32000,32128,"method","sub_8959"]],[[2,32128,32181,"method","sub_8959"],[3,32181,32212,"method","sub_8a85"],[3,32212,32244,"method","sub_8aa4"],[1,32244,32256,"method","sub_8ac4"]],[[2,32256,32276,"method","sub_8ac4"],[1,32276,32384,"method","sub_8ae4"]],[[2,32384,32405,"method","sub_8ae4"],[1,32405,32512,"method","sub_8b65"]],[[2,32512,32550,"method","sub_8b65"],[3,32550,32618,"method","sub_8bf6"],[1,32618,32640,"method","sub_8c3a"]],[[2,32640,32660,"method","sub_8c3a"],[3,32660,32689,"method","sub_8c64"],[1,32739,32768,"method","sub_8cb3"]],[[2,32768,32785,"method","sub_8cb3"],[3,32785,32816,"method","sub_8ce1"],[1,32816,32896,"method","sub_8d00"]],[[0,32896,33024,"method","sub_8d00"]],[[0,33024,33152,"method","sub_8d00"]],[[0,33152,33280,"method","sub_8d00"]],[[0,33280,33408,"method","sub_8d00"]],[[2,33408,33474,"method","sub_8d00"],[3,33494,33511,"method","sub_8d00"],[1,33511,33536,"switch"]],[[2,33536,33549,"switch"],[3,33553,33567,"method","sub_8fe1"],[3,33568,33580,"method","sub_8ff0"]],null,[[1,33845,33920,"method","sub_9105"]],[[2,33920,34031,"method","sub_9105"],[1,34031,34048,"method","sub_91bf"]],[[2,34048,34055,"method","sub_91bf"],[3,34055,34073,"method","sub_91d7"],[3,34073,34090,"method","sub_91e9"],[1,34159,34176,"method","sub_923f"]],[[0,34176,34304,"method","sub_923f"]],[[2,34304,34398,"method","sub_923f"],[1,34398,34432,"method","sub_932e"]],[[2,34432,34442,"method","sub_932e"],[1,34517,34560,"method","sub_93a5"]],[[2,34560,34609,"method","sub_93a5"],[3,34610,34659,"method","sub_9402"],[3,34659,34683,"method","sub_9433"],[1,34683,34688,"method","sub_944b"]],[[2,34688,34722,"method","sub_944b"],[1,34722,34816,"method","sub_9472"]],[[3,34858,34868,"method","sub_944b"],[2,34816,34868,"method","sub_9472"]],null,[[1,35132,35200,"method","sub_960c"]],[[2,35200,35289,"method","sub_960c"],[1,35289,35328,"method","sub_96a9"]],[[2,35328,35418,"method","sub_96a9"],[1,35425,35456,"method","sub_9731"]],[[0,35456,35584,"method","sub_9731"]],[[0,35584,35712,"method","sub_9731"]],[[2,35712,35722,"method","sub_9731"],[3,35722,35814,"method","sub_985a"]],[[1,35959,35968,"method","sub_9947"]],[[2,35968,36020,"method","sub_9947"],[3,36020,36053,"method","sub_9984"],[3,36027,36053,"method","sub_998b"]],[[3,36097,36122,"method","sub_99d1"],[3,36170,36186,"method","sub_9a1a"],[3,36186,36214,"method","sub_9a2a"]],[[3,36243,36262,"method","sub_9a63"],[3,36263,36269,"method","sub_9a77"],[3,36269,36285,"method","sub_9a7d"],[3,36285,36298,"method","sub_9a8d"],[3,36298,36311,"method","sub_9a9a"],[3,36311,36317,"method","sub_9aa7"],[3,36317,36330,"method","sub_9aad"],[3,36346,36350,"method","sub_9aca"]],null,[[1,36574,36608,"method","sub_9bae"]],[[0,36608,36736,"method","sub_9bae"]],[[2,36736,36786,"method","sub_9bae"],[3,36786,36793,"method","sub_9c82"],[3,36793,36840,"method","sub_9c89"],[1,36857,36864,"method","sub_9cc9"]],[[2,36864,36888,"method","sub_9cc9"],[3,36888,36925,"method","sub_9ce8"],[3,36895,36925,"method","sub_9cef"],[3,36962,36986,"method","sub_9d32"]],null,null,[[3,37264,37274,"method","sub_9e60"],[3,37267,37274,"method","sub_9e63"],[3,37270,37274,"method","sub_9e66"],[3,37273,37274,"method","sub_9e69"],[3,37274,37296,"method","sub_9e6a"],[3,37296,37342,"method","sub_9e80"]],null,[[3,37518,37534,"method","sub_9f5e"],[3,37534,37547,"method","sub_9f6e"],[3,37548,37564,"method","sub_9f7c"],[3,37564,37580,"method","sub_9f8c"]],null,null,null,null,null,null,null,null,null,[[3,38837,38875,"method","sub_a485"],[1,38875,38912,"method","sub_a4ab"]],[[2,38912,38912,"method","sub_a4ab"],[3,38912,38950,"method","sub_a4d0"],[3,38950,38988,"method","sub_a4f6"]],[[1,39145,39168,"method","sub_a5b9"]],[[2,39168,39202,"method","sub_a5b9"],[3,39202,39214,"method","sub_a5f2"],[3,39214,39228,"method","sub_a5fe"],[1,39228,39296,"method","sub_a60c"]],[[2,39296,39330,"method","sub_a60c"],[3,39330,39373,"method","sub_a672"],[1,39373,39424,"method","sub_a847"]],[[1,39433,39552,"method","sub_a6d9"],[2,39424,39433,"method","sub_a847"]],[[2,39552,39569,"method","sub_a6d9"],[3,39569,39653,"method","sub_a761"],[1,39653,39680,"method","sub_a7b5"]],[[2,39680,39710,"method","sub_a7b5"],[3,39710,39799,"method","sub_a7ee"],[1,39799,39808,"method","sub_a847"]],[[2,39808,39833,"method","sub_a847"],[3,39833,39848,"method","sub_a869"],[3,39848,39865,"method","sub_a878"],[1,39906,39936,"method","sub_a8b2"]],[[2,39936,39943,"method","sub_a8b2"],[3,39943,39947,"method","sub_a8d7"],[3,39949,39971,"method","sub_a8d7"],[3,39971,39995,"method","sub_a8f3"],[1,40053,40064,"method","sub_a945"]],[[2,40064,40144,"method","sub_a945"],[3,40144,40182,"method","sub_a9a0"],[1,40182,40192,"method","sub_a9c6"]],[[2,40192,40196,"method","sub_a9c6"],[3,40196,40205,"method","sub_a9d4"],[3,40205,40234,"method","sub_a9dd"],[3,40234,40262,"method","sub_a9fa"],[1,40299,40320,"method","sub_aa3b"]],[[2,40320,40321,"method","sub_aa3b"],[3,40321,40392,"method","sub_aa51"],[1,40392,40448,"method","sub_aa98"]],[[0,40448,40576,"method","sub_aa98"]],[[0,40576,40704,"method","sub_aa98"]],[[0,40704,40832,"method","sub_aa98"]],[[0,40832,40960,"method","sub_aa98"]],[[2,40960,41007,"method","sub_aa98"],[3,41007,41032,"method","sub_acff"],[3,41032,41040,"method","sub_ad18"],[3,41040,41048,"method","sub_ad20"],[1,41048,41088,"method","sub_ad28"]],[[2,41088,41107,"method","sub_ad28"],[3,41118,41123,"method","sub_ad28"],[3,41159,41195,"method","sub_ad28"],[3,41107,41118,"method","sub_ad63"],[3,41123,41159,"method","sub_ad73"],[1,41195,41216,"method","sub_adbb"]],[[0,41216,41344,"method","sub_adbb"]],[[2,41344,41398,"method","sub_adbb"],[1,41398,41472,"method","sub_ae86"]],[[2,41472,41479,"method","sub_ae86"],[3,41479,41558,"method","sub_aed7"],[3,41558,41565,"method","sub_af26"],[1,41565,41600,"method","sub_af2d"]],[[0,41600,41728,"method","sub_af2d"]],[[2,41728,41749,"method","sub_af2d"],[3,41749,41782,"method","sub_afe5"]],[[3,41935,41943,"method","sub_b09f"],[3,41943,41951,"method","sub_b0a7"],[1,41951,41984,"method","sub_b0af"]],[[2,41984,42028,"method","sub_b0af"],[3,42028,42049,"method","sub_b0fc"],[1,42108,42112,"method","sub_b14c"]],[[2,42112,42164,"method","sub_b14c"]],null,[[3,42404,42417,"method","sub_b274"],[3,42417,42423,"method","sub_b281"],[3,42424,42440,"method","sub_b288"],[3,42440,42456,"method","sub_b298"],[3,42456,42466,"method","sub_b2a8"]],[[3,42502,42512,"method","sub_b2d6"],[3,42512,42522,"method","sub_b2e0"],[3,42532,42538,"method","sub_b2f4"],[3,42538,42548,"method","sub_b2fa"],[3,42548,42553,"method","sub_b304"],[3,42560,42587,"method","sub_b310"],[3,42577,42587,"method","sub_b321"],[3,42587,42604,"method","sub_b32b"],[1,42606,42624,"method","sub_b33e"]],[[2,42624,42632,"method","sub_b33e"],[1,42632,42752,"method","sub_b358"]],[[2,42752,42754,"method","sub_b358"],[3,42754,42861,"method","sub_b3d2"]],null,null,null,null,[[3,43428,43434,"method","sub_b674"],[3,43434,43438,"method","sub_b67a"],[3,43461,43477,"method","sub_b695"],[3,43477,43493,"method","sub_b6a5"],[3,43505,43511,"method","sub_b6c1"]],[[3,43524,43540,"method","sub_b6d4"],[3,43540,43553,"method","sub_b6e4"],[3,43553,43575,"method","sub_b6f1"],[3,43575,43591,"method","sub_b707"],[3,43620,43626,"method","sub_b734"]],[[3,43662,43705,"method","sub_b75e"],[3,43706,43741,"method","sub_b78a"],[1,43741,43776,"method","sub_b7ad"]],[[2,43776,43867,"method","sub_b7ad"],[1,43867,43904,"method","sub_b82b"]],[[2,43904,43930,"method","sub_b82b"],[1,43930,44032,"method","sub_b86a"]],[[2,44032,44039,"method","sub_b86a"],[1,44039,44160,"method","sub_b8d7"]],[[2,44160,44243,"method","sub_b8d7"],[1,44243,44288,"method","sub_b9a3"]],[[2,44288,44308,"method","sub_b9a3"],[1,44308,44416,"method","sub_b9e4"]],[[2,44416,44440,"method","sub_b9e4"],[1,44440,44544,"method","sub_ba68"]],[[2,44544,44564,"method","sub_ba68"],[1,44642,44672,"method","sub_bb32"]],[[2,44672,44755,"method","sub_bb32"],[1,44755,44800,"method","sub_bba3"]],[[0,44800,44928,"method","sub_bba3"]],[[2,44928,45030,"method","sub_bba3"],[1,45054,45056,"method","sub_bcce"]],[[0,45056,45184,"method","sub_bcce"]],[[2,45184,45260,"method","sub_bcce"],[1,45262,45312,"method","sub_bcce"]],[[2,45312,45349,"method","sub_bcce"]],[[3,45464,45493,"method","sub_be68"],[3,45493,45523,"method","sub_be85"]],null,[[3,45728,45745,"method","sub_bf70"],[1,45801,45824,"method","sub_bfb9"]],[[2,45824,45827,"method","sub_bfb9"],[3,45903,45944,"method","sub_c01f"],[1,45944,45952,"method","sub_c048"]],[[2,45952,46005,"method","sub_c048"],[3,46005,46022,"method","sub_c085"],[3,46022,46063,"method","sub_c096"],[1,46063,46080,"method","sub_c0bf"]],[[2,46080,46090,"method","sub_c0bf"],[3,46090,46108,"method","sub_c0da"],[1,46108,46208,"method","sub_c0ec"]],[[0,46208,46336,"method","sub_c0ec"]],[[2,46336,46432,"method","sub_c0ec"],[1,46432,46464,"method","sub_c230"]],[[2,46464,46510,"method","sub_c230"],[1,46510,46592,"method","sub_c27e"]],[[2,46592,46694,"method","sub_c27e"],[1,46694,46720,"method","sub_c336"]],[[2,46720,46722,"method","sub_c336"],[3,46722,46750,"method","sub_c352"],[3,46750,46823,"method","sub_c36e"],[1,46844,46848,"method","sub_c3cc"]],[[2,46848,46942,"method","sub_c3cc"],[1,46942,46976,"method","sub_c42e"]],[[2,46976,47096,"method","sub_c42e"],[3,47055,47096,"method","sub_c49f"],[1,47096,47104,"method","sub_c4c8"]],[[2,47104,47150,"method","sub_c4c8"],[3,47150,47191,"method","sub_c4fe"],[1,47191,47232,"method","sub_c527"]],[[2,47232,47288,"method","sub_c527"],[3,47288,47345,"method","sub_c588"],[1,47345,47360,"method","sub_c5c1"]],[[2,47360,47380,"method","sub_c5c1"],[3,47380,47390,"method","sub_c5e4"],[1,47399,47488,"method","sub_c5e4"]],[[2,47488,47515,"method","sub_c5e4"]],null,[[3,47854,47862,"method","sub_c7be"]],[[1,47876,48000,"method","sub_c7be"]],[[2,48000,48021,"method","sub_c7be"],[3,48021,48068,"method","sub_c865"],[3,48087,48117,"method","sub_c865"],[1,48117,48128,"method","sub_c8c5"]],[[2,48128,48148,"method","sub_c8c5"],[3,48148,48171,"method","sub_c8e4"],[3,48171,48204,"method","sub_c8fb"],[1,48206,48256,"method","sub_c91e"]],[[2,48256,48349,"method","sub_c91e"],[1,48349,48384,"method","sub_c9ad"]],[[3,48389,48497,"method","sub_c91e"],[2,48384,48389,"method","sub_c9ad"]],[[3,48515,48527,"method","sub_ca53"],[3,48528,48571,"method","sub_ca60"],[3,48529,48571,"method","sub_ca61"],[3,48530,48571,"method","sub_ca62"],[3,48531,48571,"method","sub_ca63"],[3,48571,48599,"method","sub_ca8b"],[1,48599,48640,"method","sub_caa7"]],[[3,48641,48642,"method","sub_ca8b"],[2,48640,48641,"method","sub_caa7"],[3,48642,48726,"method","sub_cad2"],[3,48726,48756,"method","sub_cb26"],[1,48756,48768,"method","sub_cb44"]],[[3,48804,48805,"method","sub_cb26"],[2,48768,48804,"method","sub_cb44"],[3,48805,48813,"method","sub_cb75"],[3,48827,48855,"method","sub_cb75"],[3,48813,48821,"method","sub_cb7d"],[3,48827,48855,"method","sub_cb7d"],[3,48821,48855,"method","sub_cb85"],[1,48855,48896,"method","sub_cba7"]],[[3,48903,48904,"method","sub_cb75"],[3,48903,48904,"method","sub_cb7d"],[3,48903,48904,"method","sub_cb85"],[2,48896,48903,"method","sub_cba7"],[3,48904,48905,"method","sub_cbd8"],[3,48905,48958,"method","sub_cbd9"],[3,48958,48959,"method","sub_cc0e"],[3,48959,48960,"method","sub_cc0f"],[3,48960,48961,"method","sub_cc10"],[1,49009,49024,"method","sub_cc41"]],[[2,49024,49038,"method","sub_cc41"],[3,49039,49067,"method","sub_cc5f"],[3,49067,49090,"method","sub_cc7b"],[1,49090,49152,"method","sub_cc92"]],[[2,49152,49187,"method","sub_cc92"],[3,49211,49217,"method","sub_cc92"],[3,49217,49246,"method","sub_cd11"],[1,49246,49280,"method","sub_cd2e"]],[[2,49280,49366,"method","sub_cd2e"],[3,49371,49377,"method","sub_cd2e"],[1,49377,49408,"method","sub_cdb1"]],[[2,49408,49428,"method","sub_cdb1"]],[[1,49591,49664,"method","sub_ce87"]],[[0,49664,49792,"method","sub_ce87"]],[[2,49792,49853,"method","sub_ce87"],[1,49853,49920,"method","sub_cf8d"]],[[2,49920,49990,"method","sub_cf8d"],[3,49990,50013,"method","sub_d016"],[3,50014,50015,"method","sub_d02e"],[1,50015,50048,"method","sub_d02f"]],[[2,50048,50068,"method","sub_d02f"],[3,50069,50070,"method","sub_d065"],[3,50070,50096,"method","sub_d066"],[3,50096,50139,"method","sub_d080"],[3,50139,50140,"method","sub_d0ab"],[3,50140,50141,"method","sub_d0ac"],[3,50141,50158,"method","sub_d0ad"],[3,50159,50160,"method","sub_d0bf"],[3,50161,50162,"method","sub_d0c1"],[1,50162,50176,"method","sub_d0c2"]],[[2,50176,50183,"method","sub_d0c2"],[3,50183,50253,"method","sub_d0d7"],[3,50253,50254,"method","sub_d11d"],[3,50254,50255,"method","sub_d11e"],[3,50255,50256,"method","sub_d11f"],[3,50257,50286,"method","sub_d121"]],null,null,[[3,50560,50611,"method","sub_d250"],[3,50611,50664,"method","sub_d283"],[1,50664,50688,"method","sub_d2b8"]],[[3,50721,50722,"method","sub_d283"],[2,50688,50721,"method","sub_d2b8"],[1,50722,50816,"method","sub_d2f2"]],[[2,50816,50862,"method","sub_d2f2"],[3,50862,50863,"method","sub_d37e"],[3,50863,50871,"method","sub_d37f"],[3,50885,50903,"method","sub_d37f"],[3,50871,50879,"method","sub_d387"],[3,50885,50903,"method","sub_d387"],[3,50879,50903,"method","sub_d38f"],[1,50903,50944,"method","sub_d3a7"]],[[3,50975,50976,"method","sub_d37f"],[3,50975,50976,"method","sub_d387"],[3,50975,50976,"method","sub_d38f"],[2,50944,50975,"method","sub_d3a7"],[3,50976,50977,"method","sub_d3f0"],[3,50977,50978,"method","sub_d3f1"],[3,50983,50984,"method","sub_d3f7"],[3,50984,50985,"method","sub_d3f8"],[3,50985,50986,"method","sub_d3f9"]],null,[[3,51203,51244,"method","sub_d4d3"],[3,51248,51296,"method","sub_d500"],[1,51296,51328,"method","sub_d530"]],[[2,51328,51395,"method","sub_d530"],[3,51395,51404,"method","sub_d593"],[1,51411,51456,"method","sub_d593"],[1,51404,51456,"method","sub_d59c"]],[[0,51456,51584,"method","sub_d593"],[0,51456,51584,"method","sub_d59c"]],[[2,51584,51597,"method","sub_d593"],[2,51584,51597,"method","sub_d59c"],[3,51597,51605,"method","sub_d65d"],[3,51619,51662,"method","sub_d65d"],[3,51605,51613,"method","sub_d665"],[3,51619,51662,"method","sub_d665"],[3,51613,51662,"method","sub_d66d"],[1,51662,51712,"method","sub_d69e"]],[[3,51726,51727,"method","sub_d65d"],[3,51726,51727,"method","sub_d665"],[3,51726,51727,"method","sub_d66d"],[2,51712,51726,"method","sub_d69e"],[3,51727,51728,"method","sub_d6df"],[3,51728,51729,"method","sub_d6e0"],[3,51734,51735,"method","sub_d6e6"],[3,51735,51736,"method","sub_d6e7"],[3,51736,51737,"method","sub_d6e8"]],null,[[3,51975,52024,"method","sub_d7d7"],[3,52032,52080,"method","sub_d810"],[1,52080,52096,"method","sub_d840"]],[[2,52096,52121,"method","sub_d840"],[3,52171,52172,"method","sub_d840"],[3,52121,52171,"method","sub_d869"]],[[3,52307,52308,"method","sub_d923"]],[[3,52421,52422,"method","sub_d995"]],null,[[3,52664,52712,"method","sub_da88"],[1,52720,52736,"method","sub_dac0"]],[[2,52736,52759,"method","sub_dac0"],[3,52759,52808,"method","sub_dae7"]],null,[[3,53094,53095,"method","sub_dc36"],[3,53100,53101,"method","sub_dc3c"],[3,53101,53102,"method","sub_dc3d"],[3,53102,53103,"method","sub_dc3e"]],[[1,53246,53248,"method","sub_dcce"]],[[2,53248,53303,"method","sub_dcce"]],[[3,53409,53435,"method","sub_dd71"],[3,53435,53477,"method","sub_dd8b"]],[[3,53515,53580,"method","sub_dddb"],[3,53580,53628,"method","sub_de1c"],[1,53628,53632,"method","sub_de4c"]],[[2,53632,53657,"method","sub_de4c"],[3,53657,53682,"method","sub_de69"],[3,53682,53713,"method","sub_de82"],[3,53713,53736,"method","sub_dea1"],[3,53736,53755,"method","sub_deb8"]],[[3,53790,53859,"method","sub_deee"],[3,53859,53886,"method","sub_df33"],[1,53887,53888,"method","sub_df4f"]],[[2,53888,53903,"method","sub_df4f"],[3,53949,53950,"method","sub_df4f"],[3,53903,53950,"method","sub_df5f"],[3,53952,53999,"method","sub_df90"],[1,53999,54016,"method","sub_dfbf"]],[[2,54016,54046,"method","sub_dfbf"],[3,54046,54093,"method","sub_dfee"],[1,54093,54144,"method","sub_e01d"]],[[2,54144,54166,"method","sub_e01d"],[3,54166,54167,"method","sub_e066"],[1,54167,54272,"method","sub_e067"]],[[2,54272,54385,"method","sub_e067"],[3,54385,54386,"method","sub_e141"],[3,54386,54387,"method","sub_e142"]],[[3,54400,54526,"method","sub_e150"],[1,54526,54528,"method","sub_e1ce"]],[[0,54528,54656,"method","sub_e1ce"]],[[0,54656,54784,"method","sub_e1ce"]],[[2,54784,54803,"method","sub_e1ce"],[3,54803,54804,"method","sub_e2e3"],[1,54804,54912,"method","sub_e2e4"]],[[0,54912,55040,"method","sub_e2e4"]],[[0,55040,55168,"method","sub_e2e4"]],[[0,55168,55296,"method","sub_e2e4"]],[[0,55296,55424,"method","sub_e2e4"]],[[0,55424,55552,"method","sub_e2e4"]],[[2,55552,55600,"method","sub_e2e4"],[3,55598,55599,"method","sub_e600"],[1,55600,55680,"method","sub_e600"]],[[0,55680,55808,"method","sub_e600"]],[[0,55808,55936,"method","sub_e600"]],[[0,55936,56064,"method","sub_e600"]],[[0,56064,56192,"method","sub_e600"]],[[0,56192,56320,"method","sub_e600"]],[[0,56320,56448,"method","sub_e600"]],[[0,56448,56576,"method","sub_e600"]],[[0,56576,56704,"method","sub_e600"]],[[0,56704,56832,"method","sub_e600"]],[[0,56832,56960,"method","sub_e600"]],[[2,56960,56969,"method","sub_e600"],[1,56969,57088,"method","sub_eb59"]],[[2,57088,57168,"method","sub_eb59"],[1,57168,57216,"method","sub_ec20"]],[[2,57216,57218,"method","sub_ec20"],[3,57218,57235,"method","sub_ec52"],[3,57248,57317,"method","sub_ec70"],[1,57317,57344,"method","sub_ecb5"]],[[2,57344,57385,"method","sub_ecb5"],[3,57385,57417,"method","sub_ecf9"],[3,57424,57455,"method","sub_ed20"],[1,57455,57472,"method","sub_ed3f"]],[[2,57472,57534,"method","sub_ed3f"]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[1,60660,60672,"method","sub_f9c4"],[3,60644,60660,"method","sub_fe71"]],[[2,60672,60727,"method","sub_f9c4"],[1,60727,60800,"method","sub_fa07"]],[[0,60800,60928,"method","sub_fa07"]],[[0,60928,61056,"method","sub_fa07"]],[[2,61056,61101,"method","sub_fa07"],[3,61103,61161,"method","sub_fb7f"],[3,61161,61172,"method","sub_fbb9"],[1,61172,61184,"method","sub_fbc4"]],[[2,61184,61192,"method","sub_fbc4"],[1,61192,61312,"method","sub_fbd8"]],[[2,61312,61377,"method","sub_fbd8"]],[[1,61456,61568,"method","sub_fce0"]],[[2,61568,61693,"method","sub_fce0"],[1,61693,61696,"method","sub_fdcd"]],[[2,61696,61754,"method","sub_fdcd"],[1,61798,61824,"method","sub_fdcd"]],[[2,61824,61857,"method","sub_fdcd"],[1,61857,61952,"method","sub_fe71"]],[[0,61952,62080,"method","sub_fe71"]],[[2,62080,62101,"method","sub_fe71"]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[1,65542,65664,"method","sub_fe71"],[3,65542,65542,"switch"]],[[0,65664,65792,"method","sub_fe71"],[3,65732,65732,"switch"]],[[0,65792,65920,"method","sub_fe71"],[3,65827,65827,"switch"]],[[0,65920,66048,"method","sub_fe71"],[3,65995,65995,"switch"]],[[2,66048,66050,"method","sub_fe71"]],null,null,null,null,null,null,null,null,[[3,67233,67238,"method","sub_fe71"]],null,null,null,null,null,null,null,null,null,null,null,null,null,[[3,69037,69065,"method","sub_11a7d"],[3,69077,69111,"method","sub_11aa5"]],[[3,69165,69212,"method","sub_11afd"],[1,69224,69248,"method","sub_11b38"]],[[2,69248,69254,"method","sub_11b38"],[3,69266,69293,"method","sub_11b62"],[1,69293,69376,"method","sub_11b7d"]],[[0,69376,69504,"method","sub_11b7d"]],[[0,69504,69632,"method","sub_11b7d"]],[[0,69632,69760,"method","sub_11b7d"]],[[0,69760,69888,"method","sub_11b7d"]],[[2,69888,69931,"method","sub_11b7d"]],[[1,70135,70144,"method","sub_11ec7"]],[[2,70144,70263,"method","sub_11ec7"],[1,70263,70272,"method","sub_11f47"]],[[2,70272,70350,"method","sub_11f47"]],null,null,null,[[1,70848,70912,"method","sub_12190"]],[[2,70912,70990,"method","sub_12190"],[3,70995,71001,"method","sub_12190"],[3,71008,71029,"method","sub_12230"],[1,71029,71040,"method","sub_12245"]],[[3,71074,71074,"switch"],[3,71080,71080,"switch"],[2,71040,71043,"method","sub_12245"]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[1,73082,73088,"switch"]],[[2,73088,73208,"switch"]],[[3,73248,73268,"switch"],[3,73228,73268,"switch"]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[1,88432,88448,"switch"]],[[0,88448,88576,"switch"]],[[0,88576,88704,"switch"]],[[0,88704,88832,"switch"]],[[0,88832,88960,"switch"]],[[0,88960,89088,"switch"]],[[0,89088,89216,"switch"]],[[0,89216,89344,"switch"]],[[0,89344,89472,"switch"]],[[0,89472,89600,"switch"]],[[2,89600,89630,"switch"]],null,null,null,null,null,null,null,null,null,[[1,91004,91008,"switch"]],[[3,91111,91133,"switch"],[3,91018,91030,"switch"],[2,91008,91016,"switch"]],null,null,null,null,null,null,null,null,null,null,null,[[3,92645,92671,"switch"]],[[3,92673,92675,"switch"],[3,92685,92695,"switch"],[3,92697,92701,"switch"],[3,92709,92713,"switch"]],[[1,92916,92928,"switch"],[1,92902,92928,"switch"]],[[2,92928,92952,"switch"],[3,92928,92952,"switch"],[2,92928,92952,"switch"]],null,[[3,93298,93308,"switch"],[3,93242,93246,"switch"]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[3,98042,98042,"switch"]],[[3,98050,98058,"switch"]]]
contentsData='33222212322231122211111111111111220033332222333233333323333333333223322233333233333333223333322333333223323323233333233232333333333333333222233333333323333333333333333233333322233323323332333333333333333222222323333333333233333323333323332232222222323222333333323333333333212333323323333233233200000012233333233233322222333333222332333233322333333333333332232333333322333323322333333332333223323322223223223222233222323323332332322222222222322323222222322223233222223322222322233323223322222222222222222222222222222222222222232223232232331332322222333313322220220220111222322233232331331333321133333323333333333233333333333322333221111333333333333333223333211111111111222231111222222222221113222222322221222233133000000011023231330000000000000000000000000000000002122333300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
fileData = (() => { var code="TVpAAN0AGgQgAdMA//9cGoAAAAAAAAAAHAAAAAEAAAANAAsABwAPAAwAUwcNAFcHAABZBw4AWgcBAF8HAQByBw4AcwcLAH0HAQCBBwUAhgcPAJgHDACbBwYAnQcKAKIHBQCnBwsApwcPAKsHAACyBwkAswcHALUHAwC3BwMAuAcAALkHAwC6BwoAugcKALsHBwC8BwQAvQcKAL0HBwC+BwcAvwcFAMMHBADFBw0AyQcPAMoHCgDLBwgA1QcHANYHCwDYBwMA/wcPAAEIBwADCAwABAgIAAUIBAAGCAMABwgLAAkICAAKCAkACwgJAAwIDwBoCAoAcAgBAHEIAwCWCAkAlwgKAJoICwCbCAIAnQgHAJ8IBgC4CAQAwAgBAO0IDgAACQEABwkGAAgJAAAMCQcAJAkHACUJAQA3CQsAOAkPADkJDgA6CQQAOwkFADwJBQA9CQ4APQkPAD4JCAA/CQIAQAkMAEAJBgBBCQAAQgkHAEIJAABDCQUATgkAAFUJCABZCQcAegkMAHsJAgB8CQIAfQkCAH4JCAB+CQ4AfgkEAH8JAQCACQEAgQkOAIEJBACDCQQAhAkBAIUJAQCGCQcAhgkLAAsKDQC6CgoAvQoAAMIKBwDHCgoAzQoAANEKAQDWCgcA1woBANsKBADdCg0A4goHAOQKBADmCgsA6goEAOsKCQDtCgEA7woKAPEKDgAPCwgAEAsKABMLBgAcCwQAOgsCAD0LDQA9Cw4APgsEAEILDgBNCwgAVAsDAFULBABWCwEAWwsKAGALAgBlCwQAaAsEAGkLDABtCwMAfQsNAIMLDwCECwAAiwsNAJALAgCWCw4AmAsNAJkLDgCcCwgAqAsMAK4LDQCvCwcAtQsIALYLDgC7CwkAwAsBAMILDQDECwsA0gsJANcLBwDcCwQA4AsGAOQLDADmCwcA6gsBAOwLCwDuCw4A7wsBAPELAwD1CwQA+gsIAPsLBwD9Cw4A/gsAAAYMDwATDAwAIQwGACgMAwArDAkALAwBAC4MBwA0DAAANgwMADcMAQA5DAIAQAwFAEEMCgBCDAQARQwHAEYMAQBHDAAASAwEAEwMAQBODAkAUQwAAFMMCwBUDAUAVgwHAFgMCABZDAYAXAwIAF4MCQBfDAcAYgwJAGQMCgBlDAMAZwwIAGkMAQBrDA0AbAwKAG4MDABvDAEAcwwIAHQMCQB2DAwAfQwDAIMMBACEDAsAhAwCAIYMCgCHDAYAkQwJAJIMBwCTDAgAlQwOAJwMDwCiDAAApAwHAKQMCwCnDAcAsgwMALYMCgC5DAgAvQwNAL8MCgDCDAkAxgwIAMcMAQDIDAYA2gwLAN4MBgDlDAUA5wwIAJkPCwC9DwkAwA8DAMMPDgDGDwQAyQ8GAMoPAwDLDwoAzQ8CANgPAAD0Dw0A/w8NAAcQDQAJEAQACxAGACwQDQAwEAYAMRAPADEQCAAyEAEANRACAEQQDABEEAYARRAAAEYQCgBGEAQARxAOAEcQCABIEAIASRAMAEkQBgCSEAwAqRAAAKoQBACqEAgAqhAMAKoQAACrEAQAqxAIAKsQDACrEAAAsRAEALEQCACxEAoAxhAOAMYQAgDHEAYAxxAKAMcQDgDHEAIAyBAGAMgQCgDIEA4AyBACAMkQBgDJEAoAyRAOAMkQAgDKEAoAyhACAMsQCgDLEAIAzBAKAMwQAgDNEAoAzRAEAM4QDgDOEAgAzxACANAQDADQEAYA0RAAANIQCgDSEAQA0xAOANMQCADUEAIA1RAMANUQBgDWEAAA1xAKANcQBADYEA4A2BAOAEcRAgBIEQYASBEKAEgRDgBIEQIASREGAEkRCgBJEQ4ASRECAEoRBgBKEQoAShEOAEoRAgBLEQYASxEKAEsRDgBLEQIATBEAAFURBABVEQgAVREMAFURAABWEQ4AcBECAHERBgBxEQoAcREOAHERAgByEQYAchEKAHIRBAB4EQgAfREMAIIRAgCGEQgAiREMAJERBACWEQwAmhECAJsRAgChEQoApxEMAKgRCgCwEQYAtBECALsRAADAEQgAxBEAAMkRDgDNEQwA0hECANkRCADfEQ4A5REEAOwRCADxEQ4A8REAAPgRBgD7EQgA/xEOAP8RDAAEEgIABRICAAoSCAAKEgoADhIAAA8SBAAUEgoAFBIMABgSBAAgEgYAKhIAAC0SAgAxEggAMRIIADcSDgA3EgoAPhIAAD8SCABDEg4AQxICAEkSCABJEgIATxIMAFQSBgBaEgAAYBIEAGASCABgEgwAYBIAAGESBABhEgwAYRIAAGISBABiEggAYhIMAGISBABjEggAYxIMAGMSAABkEgQAZBIIAGQSDABkEgAAZRIEAGUSCABlEgwAZRIAAGYSBABmEggAZhIMAGYSAABnEggAZxIMAGcSAABoEgQAaBIIAGgSDABoEggAaRIMAGkSAABqEgQAahIIAGoSDABqEgAAaxIEAGsSCABrEgwAaxIAAGwSBABsEggAbBIMAGwSAABtEgQAbRIIAG0SDABtEgAAbhIEAG4SCABuEgwAbhIAAG8SBABvEggAbxIMAG8SAABwEgYAcxIMAHYSDgB6EgQAexIAAH8SDACCEg4AhhIEAIcSDgCMEgYAjRIKAI0SDgCNEgIAjhIGAI4SCgCOEg4AjhICAI8SBgCPEgwAkRIOALwSDAC9EgAAvxIMAL8SCgDAEggAwRIMAMISAgDEEggAxRIAAMcSBgDIEgwAyRIEAMsSDgDMEggAzhIGANASBgDREgYA0hIMANMSCADUEgQA1RICANYSAADXEgQA2BIIANkSCgDaEgwA2xIGANwSAADdEgQA3hIGAN8SBgDgEgoA4RIOAOISBgDkEgYA5RIEAOYSAADoEgIA6RIEAOoSBgDrEgYA7BIGAO0SDgDuEgIA8BIAAPESDgDxEgIA8xIOAPMSAgD1EgAA9hIOAPYSAgD4Eg4A+BIOAPkSDgD6EgYA/BIIAP0SDgD+EggAABMCAAITDAACEwYAAxMIAAQTCgAFEwwABhMOAAcTAAAJEwIAChMEAAsTBgAMEwgADRMKAA4TAAAQEwoAERMCABMTBAAUEwgAFRMMABYTDgAXEwAAGRMCABoTCAAbEwoAHBMMAB0TDgAeEwQAIBMKACETCAAjEwQAJBMOACQTDAAlEwoAJhMOACcTDAAoEwQAKRMIACkTDAApEwAAKhMEACoTCAAqEwwAKhMAACsTBAArEwgAKxMMACsTAAAsEwQALBMIACwTDAAsEwAALRMEAC0TCAAtEwwALRMAAC4TBAAuEwgALhMMAC4TAAAvEwQALxMIAC8TDAAvEwAAMBMEADATCAAwEwwAMBMAADETBAAxEwgAMRMMADETAAAyEwQAMhMIADITDAAyEwAAMxMEADMTCAAzEwwAMxMAADQTBAA0EwgANBMMADQTAAA1EwQANRMIADUTDAA1EwAANhMEADYTCAA2EwwANhMAADcTBAA3EwgANxMMADcTAAA4EwQAOBMIADgTDAA4EwAAORMEADkTCAA5EwwAORMAADoTBAA6EwgAOhMMADoTAAA7EwQAOxMIADsTDAA7EwAAPBMEADwTCAA8EwwAPBMAAD0TBAA9EwgAPRMMAD0TAAA+EwQAPhMIAD4TDAA+EwAAPxMEAD8TCAA/EwwAPxMAAEATBABAEwgAQBMMAEATDgBBEwYAQxMOAEQTBgBGEwoARxMOAEgTBgBKEwQASxMCAEwTCgBNEw4AThMCAFATBgBREwoAUhMOAFMTDABUEwIAVhMIAFcTDgBYEwIAWhMGAFsTCgBdEwAAXxMEAGATDABgEwAAYRMEAGETCABhEwwAYRMAAGITBABiEwgAYhMMAGITAABjEwQAYxMIAGMTDABjEwAAZBMEAGQTCABkEwwAZBMAAGUTBABlEwgAZRMMAGUTAABmEwQAZhMIAGYTAAASFAQAEhQIABIUDAASFAAAExQEABMUCAATFAwAExQAABQUBAAUFAgAFBQMABQUAAAVFAQAFRQIABUUDAAVFAAAFhQEABYUCAAWFAwAFhQAABcUBAAXFAgAFxQMABcUAAAYFAQAGBQIABgUDAAYFAAAGRQEABkUCAAZFAwAGRQAABoUBAAaFAgAGhQMABoUAAAbFAQAGxQIABsUDAAbFAAAHBQEABwUCAAcFAwAHBQAAB0UBAAdFAgAHRQMAB0UAAAeFAQAHhQIAB4UDAAeFAAAHxQEAB8UCAAfFAwAHxQAACAUBAAgFAgAIBQMACAUAAAhFAQAIRQIACEUDAAhFAAAIhQEACIUCAAiFAwAIhQAACMUBAAjFAgAIxQMACMUAAAkFAQAJBQIACQUDAAkFAAAJRQEACUUCAAlFAwAJRQAACYUBAAmFAgAJhQMACYUAAAnFAQAJxQIACcUDAAnFAAAKBQEACgUCAAoFAwAKBQAACkUBAApFAgAKRQMACkUAAAqFAQAKhQIACoUDAAqFAAAKxQEACsUCAArFAwAKxQAACwUBAAsFAgALBQMACwUAAAtFAQALRQIAC0UDAAtFAAALhQEAC4UCAAuFAwALhQAAC8UBAAvFAgALxQMAC8UAAAwFAQAMBQIADAUDAAwFAAAMRQEADEUCAAxFAwAMRQAADIUBAAyFAgAMhQMADIUAAAzFAQAMxQIADMUDAAzFAAANBQEADQUCAA0FAwANBQAADUUBAA1FAgANRQMADUUAAA2FAQANhQIADYUDAA2FAAANxQEADcUCAA3FAwANxQAADgUBAA4FAgAOBQMADgUAAA5FAQAORQIADkUDAA5FAAAOhQEADoUCAA6FAwAOhQAADsUBAA7FAgAOxQMADsUAAA8FAQAPBQIADwUDAA8FAAAPRQEAD0UCAA9FAwAPRQAAD4UBAA+FAgAPhQMAD4UAAA/FAQAPxQIAD8UDAA/FAAAQBQEAEAUCABAFAwAQBQAAEEUBABBFAgAQRQMAEEUAABCFAQAQhQIAEIUDABCFAAAQxQMAEUUAABGFAQARhQIAEYUDABGFAAARxQEAEcUCABHFAwARxQAAEgUBABIFAgASBQMAEgUAABJFAQASRQIAEkUDABJFAAAShQEAEoUCABKFAwAShQAAEsUBABLFAgASxQMAEsUAABMFAQATBQIAEwUDABMFAAATRQEAE0UCABNFAwATRQAAE4UBABOFAgAThQMAE4UAABPFAQATxQIAE8UDABPFAAAUBQEAFAUCABQFAwAUBQAAFEUBABRFAgAURQMAFEUAABSFAQAUhQIAFIUDABSFAAAUxQEAFMUCABTFAwAUxQAAFQUBABUFAgAVBQMAFQUAABVFAQAVRQIAFUUDABVFAAAVhQEAFYUCABWFAwAVhQAAFcUBABXFAgAVxQMAFcUAABYFAQAWBQIAFgUDABYFAAAWRQEAFkUCABZFAwAWRQAAFoUBABaFAgAWhQMAFoUAABbFAQAWxQIAFsUDABbFAAAXBQEAFwUCABcFAwAXBQAAF0UBABdFAgAXRQMAF0UAABeFAQAXhQIAF4UDABeFAAAXxQEAF8UCABfFAwAXxQAAGAUAgACFQYAAhUKAAIVDgACFQ4ABhUCAAcVBgAHFQoABxUOAAcVBACEFQgAhBUOAIcVAACpFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAujsQLokW/wG0MM0hiy4CAIseLACO2qN7AIwGeQCJHnUAiS6NAOgHAcQ+cwCLx4vYuf9//PKu4zxDJjgFdfaAzYD32YkOcwC5AgDT44PDEIPj8IkedwCM0ivqiz5Ma4H/AAJzB78AAok+TGuxBNPvRzvvcwPpcwGL3wPaiR6FAIkeiQCheQAr2I7AtEpXzSFf0+f6jtKL54k+TGv7M8Aujgb/Ab+6a7kCoivP/POqtADNGokWfwCJDoEAM+24OhCO2L4AAL8MAOjVAC6OHv8BLsYGsQFyLsYGoAEA/zZxAP82bwD/Nm0A/zZrAP82aQDoEQFQ6MSXuDoQjti+DAC/DADomwAujh7/Af8WhGn/FoZp/xaIaS6OHv8B6FUAi+y0TIpGAs0huQ4Aui0A6cEAHrgANc0hiR5ZAIwGWwC4BDXNIYkeXQCMBl8AuAU1zSGJHmEAjAZjALgGNc0hiR5lAIwGZwC4ACWMyo7auiYBzSEfwx64ACXFFlkAzSEfHrgEJcUWXQDNIR8euAUlxRZhAM0hHx64BiXFFmUAzSEfw7T/i9eL3jvfdBSAP/90CjhnAXcFimcBi9ODwwbr6DvXdCCL2h4HBoA/AMYH/y6OHv8BdAcm/18CH+vFJv9XAh/rvsO0QLsCAM0hw7keALo7AC6OHv8B6Or/uAMAUOgW/wAAA0BVi+w5JkxrdwPodKmAfgQBdUHo/gG0AAvAdTjEXgYmi0cGJotXBIkW5Guj5mvoTwDocXnozgfoHADoKgPoNXjodHu4AwBQ6NRuREQzwFDoZpZERF3DVYvsOSZMa3cD6B+pxgayeQHo8lDodGvopgmAPjCdAHX2gD5thQB1713DVYvsOSZMa3cD6PWouKkGULiYBlDoVnCDxAQeuKxvUOgJeYPEBOg0eujdduiCcujJjx640ExQsABQ6KVyg8QG6BN56N2UsAJQ6PB4REToH5W4xwBQuD8BUDPAUFDoQJWDxAi4AQBQ6CmVRES4AQBQuA4AUOjNlIPEBB64kABQ6ARwg8QEsACi7Gu0AKMQc6ISc6LJa6IUc7AAohtzorprou11oux1out1os51sACiNGyiyGu0AKPCa6PAa6NAbKM+bKPIdcYGxWsBxgbEaxSwAKKqb6LidbAAos91osZ1ot9rosZrM8Cj+GujvmujvGszwKPWa6POazPAo9xro9BrM8Cj2muj2GuwAaL2a6ImbDPAo+Jro+BrxwYWc2wAsACiu2ui3mvGBsdrCcYG6nUAoRBzuiwD9+qLFtRrix7SawPYiR7Ka4kWzGuhEHO6wgD36osW9GuLHvJrA9iJHtB1iRbSdegCAF3DVYvsOSZMa3cD6I2n6CuQuMcAULg/AVAzwFBQ6P6Pg8QIuAEAUOj+j0REXcNVi+xMTDkmTGt3A+hfp8ZG/wCwAVAzwLrDB1BS6Fl8g8QGo9p1iRbcdbABUDPAupgIUFLoQnyDxAajLGyJFi5ssAFQM8C6BnhQUugrfIPEBqOmb4kWqG8LwnUExkb//4pG/7QAC8B1ILABULgBALpwXFBS6AJ8g8QGo8agiRbIoAvCdQTGRv//ikb/tAALwHUxsAFQM8C6li9QUujae4PEBqPoa4kW6msLwnUGxkb//+sQoeprixboa0JCiRbSa6PUa4pG/7QAC8B1H7ABUDPAugAFUFLooHuDxAajMGyJFjJsC8J1BMZG//+KRv+0AAvAdR+wAVAzwLpjfVBS6Hh7g8QGoyZ5iRYoeQvCdQTGRv//ikb/tAALwHUxsAFQM8C6YAtQUuhQe4PEBqPedYkW4HULwnUGxkb//+sQoeB1ixbedUJCiRbya6P0a4pG/4vlXcNVi+w5JkxrdwPoDqb/NuB1/zbedegee4PEBP82KHn/NiZ56BB7g8QE/zYybP82MGzoAnuDxAT/Nupr/zboa+j0eoPEBP82yKD/Nsag6OZ6g8QE/zaob/82pm/o2HqDxAT/Ni5s/zYsbOjKeoPEBP823HX/Ntp16Lx6g8QEXcNVi+w5JkxrdwjokKXrA+hskopGBP5OBArAdfNdw1WL7DkmTGt3A+hzpaDPdbQAC8B1EMQeymsmg38cAHQF6BQA6wXGBs91AR64eAVQ6JsCg8QEXcNVi+yD7ARWVzkmTGt3A+g3pcZG/wDrOopG/7QA0eDEHsprA9gmizeLxiX/ALEI0+CJRvyLxiUA/9Poi/iKRv+0ANHgi1b8C9eL2ImXeAX+Rv+Afv8QcsBfXovlXcNVi+w5JkxrdwPo36S4AQBdw1WL7DkmTGt3A+jOpDPAUOhZkURExB50BSbHBwAAJsdHBgAAJsdHCBQAoTJsixYwbCaJVxAmiUcSJsdHFAAAJsdHFgAAJsdHGBQAJsdHGgEAJsdHHAAAJsdHHhQAJsdHIAEA/zZ2Bf82dAXoooyDxASwFFCwA1AeuAYGUOiGAIPECMYGRIIA6wPoqhagRIK0AAvAdPTEHnQFoTJsixYwbCaJVwImiUcEJsdHBgAAJsdHCAAAJsdHChQAJsdHDAEAJsdHDgAAJsdHFAAAJsdHFhQAJsdHHAAAJsdHHhQAJsdHIAEA/zZ2Bf82dAXoJXmDxATrCMYGRIIA6DoWgD5EggB18V3DVYvsVlc5JkxrdwPoyKOKRgi0ANHg0eDR4Iv4ikYKtADR4NHg0eAFBwCL8FZX6FqQg8QE/3YG/3YE6BuQg8QEX15dw1WL7DkmTGt3A+iHo/92Cv92COgykIPEBP92Bv92BOjzj4PEBF3DVYvsg+wMOSZMa3cD6F6jgH4IB3YD6Y4Axkb1AOsTikb1/kb1tACNVvYDwovYNsYHIIpG9TpGCHblikYItACNVvYDwovYNsYHAOtFikYEiEb/M8C6CgBQUv92Bv92BOh3oIlGBIvYiVYGi8oz0rgKAOiLoYpW/yrQiFb/ikYItACNVvYDwopW/4DCMIvYNogXikYI/k4ICsB3sf92DP92ChaNRvbrCv92DP92Ch64LgZQ6Cb/g8QIi+Vdw1WL7IPsClY5JkxrdwPooqLHRvxCbIxe/oM+HVQBdTbHBpabQmyMHpibxkb6AOsdikb6tADEHpabA9iKRvq0AIvwioQOByaIRyP+RvqAfvoQct3pwwDGRvsA6bMAikb7tADR4MReBAPYJosHsQjT6IhG+YpG+7QA0eCLXgQD2CaLB4oW63W2ANPiK8KxBNPoiEb4ikb7tADR4IteBAPYJooHihbrdbEI0uKKHux1sQTS4wLTKsKIRveKRvu0ALoDAPfqxF78A9iKRvnQ4NDg0OAmiEczikb7tAC6AwD36ote/APYikb40ODQ4NDgJohHNIpG+7QAugMA9+qLXvwD2IpG99Dg0ODQ4CaIRzX+RvuAfvsQcwPpRP8zwFAeuEJsUOifcYPEBjPAUOjNcURE6GKOXovlXcNVi+xWOSZMa3cD6G+huAQAUFDoU2mDxASL8DPAUP82wAD/Nr4A/zbcdf822nVW6CZqg8QMVujaaERE/zbcdf822nXoiY2DxAS4BABQuAkAUOgVaYPEBIvwM8BQ/zbyAP828AD/Ni5s/zYsbFbo6GmDxAxW6JxoRET/Ni5s/zYsbOhOiYPEBF5dw1WL7ExMVlc5JkxrdwPo46ChqG+LFqZvg8IGxB50BSaJVwImiUcEJsdHChQAJsdHDBgAi0YKJolHDibHRxwGACbHRx4BAIN+CBh1CCbHRyABAOsKxB50BSbHRyACAIB+BPB2DsZG/gGw+ypGBIhG/+t5xkb+AMZG/wHrb4tGBronAPfqxB7KawPYi0YI0fi6AwD36gPYikb+tAAD2CaKRyAE/4hGBLQAuxQAmff70eCL8LoKAPfqilYEtgAr0Iv6xB50BSaJfwYmiXcIi0YGJolHFItGCCaJRxb/NnYF/zZ0BehIdYPEBP5G/opG/jpG/3KJX16L5V3DVYvsOSZMa3cD6O+fxB50BYtGCCaJRw6LRgQmiUcUi0YGJolHFibHRxwAACbHRx4BAIN+Bhh1CCbHRyABAOsKxB50BSbHRyACAMQedAUmxkciACbGRyMAJsZHJAAmxkclAP82dgX/NnQF6FZvg8QEXcNVi+w5JkxrdwPofp/oqCbobR7o0CWwAKIwnaJthV3DVYvsTEw5JkxrdwPoXZ/onCfozCLGBo2SAMYGGnkFsACitXm0AKPUoMcG1qAAAOsOgH7/AXUF6DBK6wPoJAPoTCmIRv8KwHXo6ScB6OwrgD6Nkv91Beh7Beu6oE6FtABIoxBz6Okn6Hj/oGKFUOg+P0REM8BQuAEAUOjtRIPEBOgYEOhNEOhk+bgBAFDoNm9ERLABUOg4+URE6Nsl6LwH6JQ+6M8G6PIG6BQP6HsP6MMG6OYG6NIM6BIN6J4H6HY+62/o1Iais3noqQbozAbo9gboKD/ohAfoXD7o7wfoqQjopgzo5gzoHw3oWgnowAroe0Pos0PoVw3oGA7owQ7oKA/olg/oyw+4AQBQ6LduREToHgboblXo9Q/oZT/oxEPoABawGVDodG1ERArAdAPojjyAPo2SAHURgD5thQB1CoA+MJ0AdQPpef+APo2S/3UI6IAE6BNJ6x3oFzEKwHQW/gayeYA+snkKdQXoTzHrBugTAOiHH6CNkrQAC8B1A+nK/ovlXcNVi+yD7A5WVzkmTGt3A+jVnRaNRvxQHrieEVC5BADoN5weuCgJUOhBZYPEBDPAUOhBhkREoSh5ixYmeYkWfoWjgIW4BABQuAMAUOiFZYPEBIvwM8BQumMAUFL/NoCF/zZ+hVboW2aDxAxW6A9lRESDPh1UAXU3oYCFixZ+hYkWlpujmJvGRvMA6x2KRvO0AMQelpsD2IpG87QAi/iKhR4HJohHI/5G84B+8xBy3egaJjPAUP82gIX/Nn6F6Dhtg8QGM8BQ6GZtRETo+4nGRvcExkb2BYtG/otW/IlW+IlG+opG9rQAsQTT4MQehIgmiUcCxkb0AOtAikb0tADEXvgD2CaKB4hG9cQehIi0AAV1ASaJRwSKRve0ALEE0+AmiQeAfvUgdAseuC55UOhfhYPEBP5G9/5G9IB+9A1yusZG9wfGRvYHoLJ5tADR4NHgi9iLh1YTi5dUE4lW+IlG+opG9rQAsQTT4MQehIgmiUcCxkb0AOs6ikb0tADEXvgD2CaKB4hG9cQehIi0AAV1ASaJRwSKRve0ALEE0+AmiQceuC55UOjnhIPEBP5G9/5G9IB+9AZywLAAUOhKZkREmKkQAHTyuAEAUOiphEREHriQAFDolmODxARfXovlXcNVi+yD7BZWVzkmTGt3A+j4mxaNRvxQHriiEVC5BADoWpoWjUb4UB64phFQuQQA6EqaFo1G9FAeuKoRULkEAOg6mh64KAlQ6ERjg8QEM8BQ6ESEREShKHmLFiZ5iRZ+haOAhbgEAFC4AwBQ6Ihjg8QEi/AzwFC6YwBQUv82gIX/Nn6FVuheZIPEDFboEmNERIM+HVQBdTehgIWLFn6FiRaWm6OYm8ZG6gDrHYpG6rQAxB6WmwPYikbqtACL+IqFHgcmiEcj/kbqgH7qEHLd6B0kM8BQ/zaAhf82foXoO2uDxAYzwFDoaWtEROj+h8ZG7wDGRu4Bi0b+i1b8iVbwiUbyikbutACxBNPgxB6EiCaJRwLGRuwA60CKRuy0AMRe8APYJooHiEbtxB6EiLQABXUBJolHBIpG77QAsQTT4CaJB4B+7SB0Cx64LnlQ6GKDg8QE/kbv/kbsgH7sE3K6xkbvB8ZG7gqKRu60ALEE0+DEHoSIJolHAsZG7ADrMcZG7UHEHoSIikbttAAFdQEmiUcEikbvtACxBNPgJokHHrgueVDoDIODxAT+Ru/+RuyAfuwGcsmwB1CwClDoUUuDxASIRusKwHQUi0b6i1b4iVbwiUbyikbrorJ56xGLRvaLVvSJVvCJRvLGBrJ5AcZG7wPGRu4GikbutACxBNPgxB6EiCaJRwLGRuwA60CKRuy0AMRe8APYJooHiEbtxB6EiLQABXUBJolHBIpG77QAsQTT4CaJB4B+7SB0Cx64LnlQ6G+Cg8QE/kbv/kbsgH7sDnK6xkbsAOsG6KEs/kbsgH7sA3L0uAEAUOgtgkREX16L5V3DVYvsg+wOVlc5JkxrdwPoh5kWjUb8UB64rhFQuQQA6OmXHrgoCVDo82CDxAQzwFDo84FERKEoeYsWJnmJFn6Fo4CFuAQAULgDAFDoN2GDxASL8DPAULpjAFBS/zaAhf82foVW6A1ig8QMVujBYEREgz4dVAF1N6GAhYsWfoWJFpabo5ibxkbzAOsdikbztADEHpabA9iKRvO0AIv4ioUeByaIRyP+RvOAfvMQct3ozCEzwFD/NoCF/zZ+hejqaIPEBjPAUOgYaURE6K2FsAaIRvaIRveLRv6LVvyJVviJRvqKRva0ALEE0+DEHoSIJolHAsZG9ADrQIpG9LQAxF74A9gmigeIRvXEHoSItAAFdQEmiUcEikb3tACxBNPgJokHgH71IHQLHrgueVDoEYGDxAT+Rvf+RvSAfvQJcrrGRvQA6wboQyv+RvSAfvQCcvS4AQBQ6M+ARERfXovlXcNVi+xMTDkmTGt3A+gsmMZG/gH2Bk+FAXQEsIDrArAAiEb/CsB0A/5G/qBPhbQA0fgKRv+iT4WKRv5Q6GHyRESL5V3DVYvsOSZMa3cD6OuXoXqFo4KIoXyFo4iOoTado3qFoTido3yFXcNVi+w5JkxrdwPoxZeAPnGF/3QYoViFo46SoVqFo5Sbocqgo1iFocygo1qFXcNVi+w5JkxrdwPomJegQoK0AAvAdX2APk2CAHR2gD4seQV0b4A+LHkLdGiAPix5HHRhxB6soSaLB6NKgoA+rpsAdBQmi0cC99iLFpCSA9CJFpCSi8LrD8QerKEmi0cCAQaQkqGQksQerKEmi0cEAQaSkoMGrKEGoE2CBP+iTYK0AAvAdQewAKIqeesH/gYqeaAqeV3DVYvsVlc5JkxrdwPoApfEHoSIJot/FCaLdxahkJIrx7EE0/hIozadoZKSK8bR+NH40fijOJ2DPjadAH0IxwY2nQAA6w2DPjadEn4GxwY2nRIAgz44nQB9CMcGOJ0AAOsNgz44nRZ+BscGOJ0WAF9eXcNVi+yD7AhWOSZMa3cD6I+WxgZshQCxAOmWAKBshbQA0eDR4IvYi4dyTIuXcEyJVviJRvrEXvgmgD8AdG4mi0cEJotXAokWvqCjwKDEHr6gJooHoniFxF74Jv9HAiaIRwaAPniF/3UGJsYHAOs9gD54hQB0NqB4hbQA0eDR4IvYi4dsPYuXaj2JVvyJRv7EXvgGxHb8JosEByaJRwjEXvwmi0cCxF74JolHCv4GbIX+wYD5A3MD6WL/XovlXcNVi+yD7AhWOSZMa3cD6NKVxgZmhQCxAOmWAKBmhbQA0eDR4IvYi4e+TIuXvEyJVviJRvrEXvgmgD8AdG4mi0cEJotXAokWwqCjxKDEHsKgJooHonmFxF74Jv9HAiaIRwaAPnmF/3UGJsYHAOs9gD55hQB0NqB5hbQA0eDR4IvYi4eoQIuXpkCJVvyJRv7EXvgGxHb8JosEByaJRwjEXvwmi0cCxF74JolHCv4GZoX+wYD5BHMD6WL/XovlXcNVi+yD7AxWVzkmTGt3A+gUlcZG/gCKRv60ANHg0eCL2IuHckyLl3BMiVb0iUb2xF70JooHiEb/gH7/AHUD6RcBgH7//3UD6Q4BJopHAYhG/bQA0eDR4IvYi7++MopG/bQA0eDR4IvYi7fAMsQe1Agmx0ccAAD2Rv0BdAsmi0ccDQAGJolHHMQe1AiLxyaJRxQmiUcGi8YmiUcWJolHCP821gj/NtQI6LVpg8QEikb9tADR4NHgi9iLh/QAiUb6ikb9tADR4NHgi9iLh/YAiUb4xB6EiItG+iaJB8Re9ItG+CYDRwjEHoSIJolHAsRe9CaLRwrEHoSIJolHBMRe9Cb3RwoAAnULHrgueVDovnyDxATEHuAIJol/BiaJdwiKRv60ALqAAffqBb55JolHECaMXxImx0ccAAD2Rv0BdAsmi0ccDQACJolHHP824gj/NuAI6AZ8g8QE/kb+gH7//3QD6bL+X16L5V3DVYvsg+wMVlc5JkxrdwPoq5PGRv4Aikb+tADR4NHgi9iLh75Mi5e8TIlW9IlG9sRe9CaKB4hG/4B+/wB1A+mIAYB+//91A+l/ASaKRwGIRv20ANHg0eCL2Iu/PjSKRv20ANHg0eCL2Iu3QDTEHsgIJol/BiaJdwj/NsoI/zbICOhjaIPEBMQezAgmx0cKAQAzwCaJRxYmiUcUJsdHHAQA9kb9AXQkJsdHArqfJoxfBP82zgj/NswI6Ctog8QExB7MCCbHRwK6nusmxB7MCCbHRwK6niaMXwT/Ns4I/zbMCOgDaIPEBMQezAgmx0cCup8mjF8ExB7MCCaJfxQmiXcW/zbOCP82zAjo62eDxATEHswIJsdHAoiIJoxfBCbHRwoDACbHRxwDAP82zgj/NswI6MNng8QEikb9tADR4NHgi9iLh/QDiUb6ikb9tADR4NHgi9iLh/YDiUb4xB6EiItG+iaJB8Re9ItG+CYDRwjEHoSIJolHAsRe9Cb3RwoAAnUaJotHCgXxAMQehIgmiUcEHrgueVDozHqDxATEHtAIJol/BiaJdwiKRv60ALEI0+AFPn4miUcQJoxfEv820gj/NtAI6Cx6g8QE/kb+gH7//3QD6UH+X16L5V3DVYvsOSZMa3cD6NaRgD5xhf90LsQe6AihjpImiUcUoZSbJolHFqE0nSaJRx6hMp0miUcg/zbqCP826Ajo3WaDxARdw1WL7DkmTGt3A+iTkcQexAihgogmiUcUoYiOJolHFqGkmyaJRx6hnJsmiUcg/zbGCP82xAjooWaDxARdw1WL7DkmTGt3A+hXkYA+qKEAdDL+DqihxB7kCKGamyaJRwahopsmiUcIoZqbJolHFKGimyaJRxb/NuYI/zbkCOhaZoPEBF3DVYvsg+wIOSZMa3cD6A2Rxkb+AIpG/rQA0eDR4IvYi4dyTIuXcEyJVviJRvrEXvgmigeIRv+Afv8AdHmAfv//dHMmikcBiEb9ikb+tAC6gAH36gW+ecQewAgmiUcCJoxfBIpG/bQA0eDR4IvYi4e+MosewAgmiUcUikb9tADR4NHgi9iLh8Ayix7ACCaJRxYmx0ccAAD2Rv0BdAsmi0ccDQAEJolHHP82wgj/NsAI6KRlg8QE/kb+gH7//3QD6VP/i+Vdw1WL7IPsCDkmTGt3A+hJkMZG/gCKRv60ANHg0eCL2IuHvkyLl7xMiVb4iUb6xF74JooHiEb/gH7/AHRhgH7//3RbJopHAYhG/YpG/rQAsQjT4AU+fsQevAgmiUcCJoxfBIpG/bQA0eDR4IvYi4c+NIsevAgmiUcUikb9tADR4NHgi9iLh0A0ix68CCaJRxb/Nr4I/za8COj4ZIPEBP5G/oB+//90A+lr/4vlXcNVi+w5JkxrdwPooI/HBqSbBACDPnqFEH4KuBQAKwZ6haOkm8cGnJsEAIM+fIUVfgq4GQArBnyFo5ybxB64CKF6hSaJRwahfIUmiUcIoaSbJolHHqGcmyaJRyD/NroI/za4COh8d4PEBF3DVYvsOSZMa3cD6DaPgD5xhf90XMcGNJ0EAIM+WIUQfgq4FAArBliFozSdxwYynQQAgz5ahRV+CrgZACsGWoWjMp3EHuwIoViFJolHBqFahSaJRwihNJ0miUceoTKdJolHIP827gj/NuwI6At3g8QEXcNVi+w5JkxrdwPoxY6DPkqCZHQjxB6EiKFKgiaJRwShkJImiQehkpImiUcCHrgueVDoRXeDxARdw1WL7DkmTGt3A+iNjoA+cYX/dCfEHp6bod6gAwZghSaJRwShunkmiQehvHkmiUcCHrhaeVDoCXeDxARdw1WL7DkmTGt3A+hRjrA7UOh8XURECsB0B8YGT4UA63awPFDoaV1ERArAdAfGBk+FiOtjsD1Q6FZdREQKwHQHxgZPharrULA+UOhDXURECsB0B8YGT4Xu6z2wP1DoMF1ERArAdAfGBk+F/+sqsAFQ6B1dREQKwHQF6FwF6xmwRFDoDF1ERArAdA3GBo2SAbAAojCdom2FgD6qoQB0BejIBOsV6KUF6BEAgD5NggB0Bei3BesD6CYAXcNVi+xMTDkmTGt3A+iXjbAAUOiwV0REiEb/CsB0A6JEgovlXcNVi+w5JkxrdwPodY3GBiN5AKAseaJShYA+zqAAdQmgp6G0AAvAdQ+gLHm0ANHgi9j/l8oH6wPoowldw1WL7DkmTGt3A+g6jbABojCdoqmh6DQcxB6qmybGBwFdw1WL7DkmTGt3A+gZjYA+UYUIdRiDPpxoBHQEsA/rArArUOiPT0RE6GAD6wXGBix5JF3DVYvsOSZMa3cD6OeMgD5RhQh1GIM+nGgEdASwD+sCsCtQ6F1PRETofwLrBcYGLHkjXcNVi+yD7AY5JkxrdwPosozGRv8Lxkb+BcdG+qQcjF78/3b8/3b6ikb+UIpG/1DoaiqDxAj2BkSCAnQD6AQAi+Vdw1WL7DkmTGt3A+h0jMYGLHkBxwasoQwUjB6uocYGTYIEsAmirpuiKnmgboWicIWwFlDoUktEROhSBF3DVYvsg+wGOSZMa3cD6DaMxkb/C8ZG/gXHRvq6HIxe/P92/P92+opG/lCKRv9Q6O4pg8QI9gZEggJ0A+gEAIvlXcNVi+w5JkxrdwPo+IvGBix5AscGrKFgFIwerqHGBk2CBMYGKnkJxgaumwCgboUE/6JwhbAWUOjSSkRE6NIDXcNVi+w5JkxrdwPouYvGBlGFAIM+nGgEdASwAusCsCZQ6DFORESgXoW0AAvAdQnGBlGFH7A4636gboUE/6JwhVDo1EtERKBRhbQAi9iAv1ZDOHUEsDjrXqBuhQT/UOiYS0REgD4heQt1BLA660iAPl6FAXUJxgZRhR+wNOs4oG6FBP6icIVQ6I5LRESgUYW0AIvYgL8WQzR1BLA06xigboUE/lDoUktERIA+IXkLdQSwNusCsBpQ6O0hREToEwNdw1WL7DkmTGt3A+j6isYGUYUAgz6caAR0BLAC6wKwJlDock1ERIA+XoUHdQnGBlGFH7A563ygboWicIVQ6BlLRESgUYW0AIvYgL92Qzl1BLA5616gboX+wFDo3UpERIA+IXkLdQSwO+tIgD5ehQZ1CcYGUYUfsDXrOKBuhf7AonCFUOjTSkREoFGFtACL2IC/NkM1dQSwNesYoG6FBAJQ6JdKRESAPiF5C3UEsDfrArAbUOgyIURE6FgCXcNVi+xMTDkmTGt3A+g9isYGUYUA9gZEghJ0HYM+nGgEdASwFesCsCpQ6K5MRESwMlDo+CBEROtFoF6FtAALwHUPxgZRhR+wJ1Do4CBEROstoG6FBP+icIVQ6EFKRESgUYW0AIvYiofWQohG/4B+/yV0CFDotiBEROsD6AcA6NcBi+Vdw1WL7DkmTGt3A+i8iaBuhQT/UOjlSUREgD4heQt1BLAp6wKwJVDogCBERF3DVYvsTEw5JkxrdwPojon2BkSCEnQdgz6caAR0BLAV6wKwKlDoBExERLAzUOhOIERE60GAPl6FB3UPxgZRhR+wKFDoOCBEROsroG6FonCFUOibSUREoFGFtACL2IqH9kKIRv+Afv8mdAhQ6BAgRETrA+gHAOgxAYvlXcNVi+w5JkxrdwPoFomgboX+wFDoP0lERIA+IXkLdQSwKusCsCZQ6NofRERdw1WL7DkmTGt3A+jqiMYGzqABsACiKnmiqqGwLlDotx9ERF3DVYvsOSZMa3cD6MeI6D0AXcNVi+w5JkxrdwPotojoLABdw1WL7DkmTGt3A+iliKDOoP7Aos6gPAN1BegPAOsLsC5Q6G4fRETolABdw1WL7FY5JkxrdwPoeojGBs6gAL7oA+sE6FkATgv2dfjGBm2FAaAaebQAC8B1B7D/oo2S6wf+Dhp5oBp5Xl3DVYvsOSZMa3cD6D2IgD6xoQB0IIA+UIUJdAb+BlCF6xPGBlCFAKByhaJvhbBaUOg/RkREXcNVi+w5JkxrdwPoCIigboW0AMQe2KAD2CaKB6IkeV3DVYvsOSZMa3cD6OmHoCx5tAC6IgD36ooWKnm2ANHiA8KL2P+XwENdw1WL7DkmTGt3A+jBh/YGRIIEdAXoaALrU/YGRIIIdAXoyQLrR4A+boUIchigboW0AI4G2qADBtigi9gmgH/4DnUC6yX2BkSCAnQe6EQjgz6caAR0CrAUUOgBSkRE6w2wKlDo90lEROsD6L0DXcNVi+yD7AY5JkxrdwPoUYfGRv8hxkb+BMdG+uoUjF78/3b8/3b6ikb+UIpG/1DoCSWDxAj2BkSCBHQF6NQB6wr2BkSCCHQD6DUCi+Vdw1WL7DkmTGt3A+gHh8YGTIIIsAtQ6NwdREToAv9dw1WL7IPsBjkmTGt3A+jmhsZG/yXGRv4Gx0b6ZBaMXvz/dvz/dvqKRv5Qikb/UOieJIPECPYGRIICdAuwDFDolR1EROi7/ovlXcNVi+w5JkxrdwPooIaAPiR5AHUWoG6FtACOBtqgAwbYoIvYJoB/CAt1BegHAOsD6NgDXcNVi+w5JkxrdwPobYb2BkSCBHQF6BQB6xv2BkSCCHQF6HUB6w/2BkSCAnQF6AcA6wPooQJdw1WL7DkmTGt3A+g4hoA+JHkPdQXorSLrE4A+JHkSdQLrB4A+JHkfdQPoRv3ojkCDPpxoBHQEsBTrArAJUOiTSERE/gZMgoA+TIIJdRWgboUE+KJvhbAkUOgRRERExgZMggCwDVDovRxEROjj/V3DVYvsTEw5JkxrdwPoyIXGRv4AoG6FiEb/62CKRv/+wIhG/zwwdQTGRv8Aikb/tADEHtigA9gmgD8PdT+KRv+ib4WiboXoEiOhkpIFDQCjkpKwJ1Dop0NERIM+nGgEdASwA+sCsChQ6PtHRESwD1DoRRxEROhr/cZG/gGKRv60AAvAdJeL5V3DVYvsTEw5JkxrdwPoQYXGBlGFAOh0PaBehbQAC8B1CcYGUYUfsBLrOKBuhQT/onCFUOhsRUREoFGFtACL2IqHVkKIRv88AXQC6xagcIVQ6DBFRESAPiF5C3UEsBbrArABUOjLG0RE6PH8i+Vdw1WL7ExMOSZMa3cD6NSExgZRhQDoBz2APl6FB3UJxgZRhR+wE+s4oG6FonCFUOgDRUREoFGFtACL2IqHdkKIRv88AnQC6xigboX+wFDoxURERIA+IXkLdQSwF+sCsAJQ6GAbRETohvyL5V3DVYvsTEw5JkxrdwPoaYTGBlGFAKBehbQAC8B1CcYGUYUfsBTrOKBuhQT/onCFUOiXREREoFGFtACL2IqHlkKIRv88CHQC6xagcIVQ6FtERESAPiF5C3UEsBjrArAIUOj2GkRE6Bz8i+Vdw1WL7ExMOSZMa3cD6P+DxgZRhQCAPl6FB3UJxgZRhR+wFes4oG6FonCFUOgxREREoFGFtACL2IqHtkKIRv88CXQC6xigboX+wFDo80NERIA+IXkLdQSwGesCsAlQ6I4aRETotPuL5V3DVYvsOSZMa3cD6JmDsACiI3mip6HGBrl5C4A+JHkRdQqwL1DoXxpEROsD6AUA6ID7XcNVi+yD7AQ5JkxrdwPoZIOAPlKFA3Q8gD5ShQ10NYA+UoUQdC6DPpxoBHQNoCJ5tACL2IqHnibrC6AiebQAi9iKh24miEb8gH78AHQGUOixRUREgD5uhQhzCLAGUOj0GetpoG6FBPiib4W0AMQe2KAD2CaKB4hG/6K5eYpG/7QA0eCL2IqHageIRv6KRv+0ANHgi9iKh2sHiEb9ikb+UOiyGUREgD4seQp1E4M+nGgEdASwFOsCsAlQ6EZFRESAfv0AdAmKRv1Q6NBARESL5V3DVYvsOSZMa3cD6JeCsARQ6HEZRETol/pdw1WL7DkmTGt3A+h+gsYGTIIIgD60eQB1B4A+JHkAdRbGBrR5AIA+boUocwXouf/rOuitGes1gD4keSB1E4M+nGgEdASwA+sCsChQ6MtERESAPiR5FnUF6LMZ6w+APiR5A3UF6N8c6wPoAgBdw1WL7DkmTGt3A+gSgvYGRIIEdAXoAh3rJ/YGRIIIdAXoFR3rG4A+JHkKdQXoOB7rD4A+JHkPdQXoYx7rA+gCAF3DVYvsOSZMa3cD6NGBgD5uhQhzBeiiHOtKoG6FBPiib4W0AMQe2KAD2CaAPw50BeiHHOsv9gZEggJ0Behc++sjgz6caAR0BLAU6wKwCVDoG0RERLAkUOisP0REsApQ6F0YRERdw1WL7ExMVlc5JkxrdwPoaYEz/+tPM/brQLgBAFBXVuhd4YPEBovGuicA9+rEHsprA9iLx9H4ugMA9+oD2CaKRyCIRv8KwHQQuAEAUFdWikb/UOgy4IPECEaD/hR8u4vHQECL+IP/GnysX16L5V3DVYvsg+wUVlc5JkxrdwPo+oDGBkBMAMYGTEwAxgZYTADGBoBMAMYGjEwAxgaYTADGBqRMAKFyTIsWcEyJVvCJRvKhvkyLFrxMiVbsiUbuxF7wsAEmiAeii47EXuywASaIB6KMjsRe8LABJohHBqJ4hcRe7LABJohHBqJ5hcQe2KAmioeQAKJuhYA+boUAdAT+Dm6FxB7YoCaKh5EAonKFgD5yhQB0BP4OcoXEHtigJoqHkgCiz6DEHtB1JoqHkwAE/6JxhSaKh5UAoiB5JoqHlACiYoUmioeWALQA0eCL2IuHRiWj3qDo2xzGRv4A6YUBxkb/AOlyAYpG/tDg0ODQ4AJG/4hG/YpG/rQA0eDR4NHgilb/tgADwo4G2qADBtigi9gmige0AIvwC8B0RoqEOj20AIvwi97R49Hji4dsPYuXaj2JVviJRvrEXvCKRv0miEcBBsR++CaLBQcmiUcIxF74JotHAsRe8CaJRwrodurofO6KRv60ANHg0eDR4MQe2KAD2IpG/7QAA9gmikcwtACL8AvAdEyAfv8HdEaKhIZAtACL8Ive0ePR44uHqECLl6ZAiVb0iUb2xF7sikb9JohHAQbEfvQmiwUHJolHCMRe9CaLRwLEXuwmiUcK6G/r6NDuikb+tADR4NHg0eDEHtigA9iKRv+0AAPYJopHYLQAi/ALwHRfikb/tADR4IpW/rYA0eLR4tHi0eIDwtHgi9iLh3QCxB6EiCaJB4pG/7QA0eCKVv62ANHi0eLR4tHiA8LR4IvYi4d2AosehIgmiUcCi8YFeQEmiUcEHrgueVDoT2eDxAT+Rv+Afv8IcwPphf7+Rv6Afv4GcwPpcv7EXvCwACaIRwYmiAfEXuywACaIRwYmiAdfXovlXcNVi+yD7AZWOSZMa3cD6F9+xkb7AYA+snkBdgygmhG0AAvAdQPo2hKAPpoR/3UFxgayeQGgsnm0ANHg0eCL2IuHyhCLl8gQiRZGgqNIgqCyebQA0eDR4IvYi4fuEIuX7BCJFlSFo1aFxgZOhQG4HwCjHnmjHHmAPrJ5AnQHgD6yeQV1H8cGHHlvAOsXikb7tAC6CQD36sQeRoID2CbGBwD+RvuKRvu0ALoJAPfqxB5GggPYJoA//3XTHriQAFDoM0WDxATEHpAAoLJ5BDAmiEcBxB6aAKCyeQQwJohHAcQe4ACgsnkEMCaIRwG4BABQM8BQ6GdFg8QEi/AzwFD/NpgA/zaWAP82qG//NqZvVug6RoPEDIlG/IlW/lbo6ERERP82mAD/NpYA/3b+/3b8/zaob/82pm/oDk2DxAy4BABQuAEAUOgVRYPEBIvwM8BQ/zaiAP82oAD/Nupr/zboa1bo6EWDxAyJRvyJVv5W6JZERET/NqIA/zagAP92/v92/P826mv/Nuhr6LxMg8QMuAQAULgIAFDow0SDxASL8DPAUP826AD/NuYA/zbgdf823nVW6JZFg8QMiUb8iVb+VuhERERE/zboAP825gD/dv7/dvz/NuB1/zbedehqTIPEDF6L5V3DVYvsg+wEVjkmTGt3A+h7fB64KAlQ6PdDg8QE6JYAuAQAUDPAUOhPRIPEBIvwM8BQ/zYwCf82Lgn/Nsig/zbGoFboIkWDxAxW6NZDRET/Nsig/zbGoOiIZIPEBLgEAFC4AQBQ6BFEg8QEi/AzwFD/NjoJ/zY4Cf82KHn/NiZ5VujkRIPEDIlG/IlW/lbokkNERDPAumN9UFL/dv7/dvz/Nih5/zYmeei5S4PEDOgxIl6L5V3DVYvsg+wGVlc5JkxrdwPoxnu4BABQuAIAUOinQ4PEBIvwM8BQ/zZECf82Qgn/Nih5/zYmeVboekSDxAyJRvyJVv5W6ChDREQzwLpjfVBS/3b+/3b8/zYoef82JnnoT0uDxAyDPh1UAXU3oSh5ixYmeYkWlpujmJvGRvsA6x2KRvu0AMQelpsD2IpG+7QAi/iKhToGJohHI/5G+4B++xBy3egYBKEoeYsWJnmDwmPEHnQFJolXAiaJRwQmx0cGAAAmx0cIAAAmx0cKFAAmx0cMGQAmx0cOAQAmx0cUAAAmx0cWAAAmx0ccAAAmx0ceFAAmx0cgGQD/NnYF/zZ0BegQUIPEBDPAUP82KHn/NiZ56NZKg8QGM8BQ6ARLRES4AQBQ6A5LRETokGfoBgBfXovlXcNVi+xMTFY5JkxrdwPol3rGRv8AuAQAUFDod0KDxASL8DPAUP82WAn/NlYJ/zYoef82JnlW6EpDg8QMVuj+QUREuAQAULgFAFDoR0KDxASL8DPAUP82Ygn/NmAJ/zbIoP82xqBW6BpDg8QMVujOQUREgT6caACAdGjrRbgBAFD/Nih5/zYmef82yKD/Nsag6AlYg8QK6xmhnBEFBwCjnBGwAFDoIERERKgQdATGRv8B6ApYC8B0CYpG/7QAC8B014pG/7QAC8B0sugAWIM+nGgAdSq4AQBQ6GJMRETos2LrHMYGRIIA6wzoF+yhnBEFBwCjnBGgRIK0AAvAdOtei+Vdw1WL7DkmTGt3A+iZecYGQoIAxgYqeQDHBkqCAADGBs6gALAAoniFoouOsACieYWijI7GBkSCAMYGp6EAxga0eQDGBiN5AMYGTIIAxgaooQDGBrGhAMYGUIUAxgZjhQDGBrChAMYGQ4IAxga3eQDHBqabhgiMHqibxB6mmybGB//ophboRhahkpIF9P+jkpLGBix5AMcGrKGUE4werqHGBk2CCrAEoq6boip5xgapoQBdw1WL7DkmTGt3A+joeMYGRIIA6wPoOeugRIK0AAvAdPRdw1WL7DkmTGt3A+jHeKEQc7rCAPfqixb0a4se8msD2Ike0HWJFtJ1oRBzuiwD9+qLFtRrix7SawPYiR7Ka4kWzGvHBtig5KCMHtqgsQDrVIrBtADEHtB1A9gmigeK0bYAxB7YoAPaJogHisG0AMQe0HUD2CaKRzCK0bYAxB7YoAPaJohHMIrBtADEHtB1A9gmikdgitG2AMQe2KAD2iaIR2D+wYD5MHKnxB7QdSaKh5AAxB7YoCaIh5AAxB7QdSaKh5EAxB7YoCaIh5EAxB7QdSaKh5IAxB7YoCaIh5IAxB7QdSaKh5MAxB7YoCaIh5MAxB7QdSaKh5QAxB7YoCaIh5QAxB7QdSaKh5UAxB7YoCaIh5UAXcNVi+w5JkxrdwPosnfHBoSILnmMHoaIxB6EiKHIoIsWxqAmiVcGJolHCCaATwqAJoBnCr8mgGcK3yaAZwrvJoBnCvfHBp6bWnmMHqCbxB6emyaJVwYmiUcIJoBPCoAmgGcKvyaAZwrfJoBnCu8mgGcK98cG0KCGeYwe0qDEHtCgJolXBiaJRwgmgE8KgCaAZwq/JoBnCt8mgGcK7yaAZwr3XcNVi+yD7GhWOSZMa3cD6Ax3xB50BSbGRyIAJsZHIwAmxkckACbGRyUAJsdHDgAAJsdHHAAAxkb+FMZG/RnGRv8A6bwAxB50BYpG/7QAJolHFIpG/7QAJolHFopG/rQAJolHHibHRyABAP82dgX/NnQF6HBGg8QE6IRjxB50BYpG/7QAuhgAK9AmiVcW/zZ2Bf82dAXoTUaDxAToYWOKRv4E/ohG/sQedAWKRv+0ACaJRxYmx0ceAQCKRv20ACaJRyD/NnYF/zZ0BegYRoPEBOgsY8QedAWKRv+0ALoTACvQJolXFP82dgX/NnQF6PVFg8QE6Aljikb9BP6IRv3+Rv+Afv8JdwPpO/8z9usPi97R441GmAPYNscHAABGg/4ycuwzwFAWjUaYUOgBRoPEBjPAUOgvRkRE6MRiXovlXcNVi+yD7AxWVzkmTGt3A+jNdcZG+wDGRvr/Fo1G9lAeuLIRULkDAOgndLgEAFC4EgBQ6JY9g8QEi/AzwFD/NuQJ/zbiCf82KHn/NiZ5VuhpPoPEDIlG/IlW/lboFz1ERDPAumN9UFL/dv7/dvz/Nih5/zYmeeg+RYPEDIM+HVQBdTehKHmLFiZ5iRaWm6OYm8ZG9QDrHYpG9bQAxB6WmwPYikb1tACL+IqFSgYmiEcj/kb1gH71EHLdM8BQ6K1dRETEHoSIoS5sixYsbCaJVwYmiUcIsACiT4WiRILo5P2hKHmLFiZ5g8JjxB50BSaJVwImiUcEJsdHBgAAJsdHCAAAJsdHChQAJsdHDBkAJsdHDgEAJsdHFAAAJsdHFgAAJsdHHAAAJsdHHhQAJsdHIBkA/zZ2Bf82dAXo3EmDxAQzwFD/Nih5/zYmeeiiRIPEBjPAUOjQRERE6QoBoLV5tADR4NHgi9iLh2AHi5deB8QedAUmiVcCJolHBCbHRwYAACbHRwgAACbHRwoGACbHRwwCACbHRxQLACbHRxYSACbHRx4GACbHRyACAP82dgX/NnQF6GNJg8QEuAEAUOh6REREuAEAUDPAUOgSGoPEBMQehIgmx0cEAAAmxwcwAIpG+7QAsQTT4AVwACaJRwIeuC55UOiRXIPEBOjFYOg85vYGRIIBdAuAfvsAdAX+TvvrRPYGRIICdAuAfvsDcwX+RvvrMvYGRIIQdCuKRvu0AIvYg/sDdx/R4y7/p0o4ikb7iEb66xD+BrV5gD61eQN1BcYGtXkAxgZEggCwAFDonz1ERArAdfSAfvr/dQPp7f6gtXm0AI1W9gPCi9g2igeiT4XEHoSIocigixbGoCaJVwYmiUcIuAEAUOjSW0REikb6X16L5V3DAOA34DfoN+A3VYvsg+wKVjkmTGt3A+ghc8ZG+wCgT4Wiio7GBk+FAMYGRIIAHrgoCVDoiTqDxAS4BABQoLJ5tAAFBwBQ6N46g8QEi/AzwFCgsnm0ALoKAPfqi9j/t3YJ/7d0Cf82KHn/NiZ5VuilO4PEDIlG/IlW/lboUzpERDPAumN9UFL/dv7/dvz/Nih5/zYmeeh6QoPEDIM+HVQBdVKhKHmLFiZ5iRaWm6OYm6CyebQA0eDR4IvYi4foBouX5gaJVvaJRvjGRvoA6x+KRvq0AMRe9gPYJooHilb6tgDEHpabA9omiEcj/kb6gH76EHLb6Cj7oSh5ixYmeYPCY8QedAUmiVcCJolHBCbHRwYAACbHRwgAACbHRwoUACbHRwwZACbHRw4BACbHRxQAACbHRxYAACbHRxwAACbHRx4UACbHRyAZAP82dgX/NnQF6CBHg8QEuAgAULgBAFCwB1D/Ntag/zbUoOhhzoPECuh1J+iRAqC2eaJOhTPAUP82KHn/NiZ56MFBg8QGoRx5o5CSoR55o5KSxwZKgiEAM8BQuAEAUOiQF4PEBOi74jPAUOjNQUREuAEAUOjXQURE6Fle6GXa6HvZ6MPh6HXZ6G4A61jov+P2BkSCAXQF6IkA60T2BkSCAnQF6NoA6zj2BkSCBHQF6CsB6yz2BkSCCHQF6HwB6yD2BkSCEHQF6J4C6xGwAVDoU0BERArAdAiw/6KNkohG+8YGRIIAikb7tAALwHSfoIqOok+FXovlXcNVi+w5JkxrdwPo73CgToW0ALoJAPfqixZIgoseRoID2IkeqpuJFqybXcNVi+yD7AY5JkxrdwPownChrJuLFqqbiVb6iUb8xF76JopHAYhG/4B+/wB0LaJOheik/8Re+iaKRwK0ANH40fiIRv/rD6GSkgX8/6OSkugkAf5O/4B+/wB164vlXcNVi+yD7AY5JkxrdwPoZXChrJuLFqqbiVb6iUb8xF76JopHA4hG/4B+/wB0LaJOhehH/8Re+iaKRwS0ANH40fiIRv/rD6GSkgUEAKOSkujHAP5O/4B+/wB164vlXcNVi+yD7AY5JkxrdwPoCHChrJuLFqqbiVb6iUb8xF76JopHBYhG/4B+/wB0LaJOhejq/sRe+iaKRwa0ANH40fiIRv/rD6GQkgX8/6OQkuhqAP5O/4B+/wB164vlXcNVi+yD7AY5JkxrdwPoq2+hrJuLFqqbiVb6iUb8xF76JopHB4hG/4B+/wB0LaJOheiN/sRe+iaKRwi0ANH40fiIRv/rD6GQkgUEAKOQkugNAP5O/4B+/wB164vlXcNVi+w5JkxrdwPoUW/oV9foO9joqd3omd/oceC4AQBQ6JU/RETo/NZdw1WL7ExMOSZMa3cD6CZvxkb/AKBOhaK2ecYGToUB6Bn+xB6qmyaAP/91BsZG/wHrDcQeqpsmgD8AdAPoEQD+Bk6Fikb/tAALwHTTi+Vdw1WL7DkmTGt3A+jabsQehIgmx0cE2gGgToW0AEjR4NHgxB5UhQPYJosHSMQehIgmiQegToW0AEjR4EDR4MQeVIUD2CaLB8QehIgmiUcCHrgueVDoOFeDxARdw1WL7IPsBjkmTGt3A+h9bsZG+wDGBix5AOgU/+gR/+hw/aGsm4sWqpuJVvyJRv7EXvwmige0AAvAdAPpwgCDPpxoBHQEsAPrArAoUOjMMERExgZPhaqhkpKjHnmhkJKjHHnHBqyhFBGMHq6hxgZNghahkJIF8f+jkJKhkpIFAwCjkpLHBkqCywDoYtzoLd/oT96hkJIFDwCjkJKhkpIF/f+jkpLHBkqCAADo6dXoVwDoCd+4AQBQ6C0+RETolNXoLNzoHN7o9N64AQBQ6Bg+RETof9Xov9XoD9booNboDtzo/t3o1t64AQBQ6Po9REToYdWAPk2CAHXb6IIAxkb7AYpG+4vlXcNVi+xWVzkmTGt3A+h4bcQehIgmi38UJot3FqGQkivHBQ4AsQTT+EijNp2hkpIrxgX2/9H40fjR+KM4nYM+Np0AfQjHBjadAADrDYM+Np0SfgbHBjadEgCDPjidAH0IxwY4nQAA6w2DPjidFn4GxwY4nRYAX15dw1WL7DkmTGt3A+gDbbAyUOhhx0REXcNVi+xMTDkmTGt3A+jrbLABisiIRv/rF4rBtAC6CQD36sQeRoID2CaKByBG//7BisG0ALoJAPfqxB5GggPYJoA//3XUikb/i+Vdw1WL7IPsBlZXOSZMa3cD6J5s6JkXuAQAULgRAFDofDSDxASL8DPAUP822gn/NtgJ/zYoef82JnlW6E81g8QMiUb8iVb+Vuj9M0REM8C6Y31QUv92/v92/P82KHn/NiZ56CQ8g8QMgz4dVAF1N6EoeYsWJnmJFpabo5ibxkb7AOsdikb7tADEHpabA9iKRvu0AIv4ioUuByaIRyP+RvuAfvsQct3o7fShKHmLFiZ5g8JjxB50BSaJVwImiUcEJsdHBgAAJsdHCAAAJsdHChQAJsdHDBkAJsdHDgEAJsdHFAAAJsdHFgAAJsdHHAAAJsdHHhQAJsdHIBkA/zZ2Bf82dAXo5UCDxAQzwFD/Nih5/zYmeeirO4PEBjPAUOjZO0REuAEAUOjjO0RE6GVYxgZEggDoiPKwAaKyeaKNkl9ei+Vdw1WL7IPsNlZXOSZMa3cD6F1rxkb7ABaNRtpQHri2EVC5IADou2kWjUbKUB641hFQuRAA6KtpM8BQ6MBTREQzwFDovFdERB64kABQ6KUyg8QE/zacEeg4U0REuAQAULgBAFDo9jKDxASL+DPAULpjAFBS/zbqa/826GtX6Mwzg8QMV+iAMkREgz4dVAF1O6Hqa4sW6GuJFpabo5ibxkb/AOshikb/tADEHpabA9iKRv+0AAZTi9iKh1oGWwcmiEcj/kb/gH7/EHLZxkb/AOsgikb/tADR4IvYi4c+B4pW/7YA0eLEHsprA9omiQf+Rv+Afv8QctroL8XGRvsA6S8B6JtSJQ8Ai/A9AgB884pCyohG/LAAiEb9iEb+xgaaEQHoMfMeuHgFUOiTx4PEBIve0eONRtoD2DaLB8QehIgmiUcEJscHkAAmx0cCZAAeuC55UOjCUoPEBLiHAFC4VABQHrgxE1DodcaDxAi4lgBQuJgAULACUIpG/rQAmVJQ6ILGg8QK63fGBkSCAOg93PYGRIIQdAbGRv0B60H2BkSCBHQXgH7+AHQR/k7+uJYAULiYAFAeuEsT6xz2BkSCCHQcgH7+Y3MW/kb+uJYAULiYAFAeuFATUOgExoPECLiWAFC4mABQsAJQikb+tACZUlDoEcaDxAqwBFDo2cNERIpG/bQAC8B0gIpG/ohG/OsduKgAULiMAFAeuFUTUOi/xYPECMYGmhH//kb76wTGRvv/gH77A3MD6cj+uAEAUOjCVUREuAEAUOi1UUREX16L5V3DVYvsg+wEOSZMa3cD6BFpxgZEggCgQoK0AAvAdVWKRgSiLHmAPix5BXRIgD4seQt0QYA+LHkcdDrGBtygALQA0eDR4IvYi4dUIouXUiKJVvyJRv7EXvwmigeiTYImikcBoq6bJotHBCaLVwKJFqyho66hi+Vdw1WL7DkmTGt3A+ieaIM+nGgEdASwA+sCsA1Q6BsrRESwLVDoZf9EROiL4F3DVYvsOSZMa3cD6HJoxgYseRzoSABdw1WL7DkmTGt3A+hcaPYGRIIEdAXoA+PrD/YGRIIIdAXoZOPrA+gfAF3DVYvsOSZMa3cD6DNo9gZEghB0BejB/+sD6DkAXcNVi+yD7AY5JkxrdwPoE2jGRv8Vxkb+BMdG+nAbjF78/3b8/3b6ikb+UIpG/1DoywWDxAiL5V3DVYvsOSZMa3cD6N9n9gZEggF0BeimAOsD6AIAXcNVi+w5JkxrdwPowmf2BkSCAnQF6L8A6wPoAgBdw1WL7DkmTGt3A+ilZ/YGRIIEdAXo2ADrA+gCAF3DVYvsOSZMa3cD6Ihn9gZEggh0BegtAesD6AIAXcNVi+w5JkxrdwPoa2egboWib4XoTt+APiR5FnUF6Nr+6wiwL1DoYSlERF3DVYvsOSZMa3cD6EBn9gZEghB0Bei//+sD6Eb/XcNVi+w5JkxrdwPoI2eAPm6FCHMF6Ev/6xygboUE+FDoWgFERArAdAXoN//rCLAdUOgaAUREXcNVi+w5JkxrdwPo7WaAPm6FKHIF6DL/6xygboUECFDoJAFERArAdAXoHv/rCLAeUOjkAEREXcNVi+w5JkxrdwPot2agXoW0AAvAdQXoF//rMKBuhQT/UOjsAERECsB0BeggAOscoG6FBP9Q6A4BREQKwHQF6AwA6wiwH1DomABERF3DVYvsOSZMa3cD6GtmgD4keRZ0DqBuhaJvhbAvUOhpKERE6AThXcNVi+w5JkxrdwPoRWaAPl6FB3UF6MT+6y6gboX+wFDofABERArAdAXoHgDrGqBuhVDooABERArAdAXoDADrCLAgUOgqAEREXcNVi+w5JkxrdwPo/WWAPiR5FnQOoG6Fom+FsC9Q6PsnREToA+Fdw1WL7DkmTGt3A+jXZYpGBFDosPxERIA+JHkAdA6gboWib4WwMFDozCdEROjB3V3DVYvsOSZMa3cD6KhlsgCKRgS0AMQe2KAD2CaAPwB0E4pGBLQAix7YoAPYJoA/GXQCsgGKwl3DVYvsOSZMa3cD6HJlsgCKRgS0AMQe2KAD2CaAfzAAdBSKRgS0AIse2KAD2CaAfzATdAKyAYrCXcNVi+w5JkxrdwPoOmX+BkKCgD5CggN1CMYGQoIA6AnjXcNVi+w5JkxrdwPoGWWgJHm0AIvYioe+NlDoQgBERF3DVYvsOSZMa3cD6PpkoCR5tACL2IqH7jZQ6CMARERdw1WL7DkmTGt3A+jbZKAkebQAi9iKhx43UOgEAEREXcNVi+w5JkxrdwPovGSKRgS0AD0IAHQ1fw6L2IP7A3dA0eMu/6clRz0JAHQlPRoAdCU9GwB0Jeso6FIA6yzoOt/rJ+ii3+si6Nrg6x3oA+DrGOho4OsT6KvY6w7oZdnrCYpGBFDoDABERF3D8kb3RvxGAUdVi+w5JkxrdwPoSmSKRgRQ6CP7REToSdxdw1WL7ExMOSZMa3cD6C5kgD5uhQhzBsZG/gDrIaBuhbQAjgbaoAMG2KCL2CaKR/iIRv+0AIvYiodON4hG/opG/rQAC8B1MoA+s3nrdgbGRv486yWAPrN513YGxkb+PesYgD6zecN2BsZG/j7rC4A+s3mvdgTGRv4/ikb+UOho/0REi+Vdw1WL7DkmTGt3A+isY/YGRIIEdAXoU97rHfYGRIIIdAXotN7rEaAsebQAi9iKh343UOi9/kREXcNVi+w5JkxrdwPodWODPpxoBHQEsAPrArAoUOjyJUREoG6Fom+FsCdQ6H0hRESwDlDoLvpEROhU213DVYvsOSZMa3cD6Dtj6L/hxB50BSbHBwEAJsdHBgAAJsdHCAAAoSh5ixYmeSaJVxAmiUcSJsdHFAAAJsdHFgAAJsdHGBQAJsdHGhkAJsdHHAAAJsdHHhQAJsdHIBkA/zZ2Bf82dAXoFEuDxARdw1WL7DkmTGt3A+jOYoA+cYX/dEigcYW0ANH40fjR+KJlhdDg0ODQ4IoWcYUq0IgWZIWgcYW0ANHg0eCL2IuHdAIFBwCjunmgcYW0ANHg0eCL2IuHdgIFBwCjvHldw1WL7DkmTGt3A+hxYqBuhbQA0fjR+NH4olyF0ODQ4NDgihZuhSrQiBZehaBuhbQA0eDR4IvYi4d0AgUHAKOQkqBuhbQA0eDR4IvYi4d2AgUPAKOSkl3DVYvsOSZMa3cD6Bti/gZdhaBdhTpGBnUS/3YK/3YIikYEUOgUAIPEBusNoF2FOkYGdgXGBl2FAF3DVYvsOSZMa3cD6OJhxgZdhQCg3KC0AECKVgS2ADvCfQn+BtygoNyg6wWwAKLcoKDcoLQA0eDEXgYD2CaLB6NKgl3DVYvsTEw5JkxrdwPonmHEHnQFJscHAAAmx0cGAAAmx0cIAAAmx0cQlJYmjF8SJsdHFAAAJsdHFgAAJsdHGBQAJsdHGgEAJsdHHAAAJsdHHhQAJsdHIAEA/zZ2Bf82dAXof0mDxAQzwFDo0k1ERDPAUOjGSUREuAcAUDPAULAHUP821qD/NtSg6LW9g8QK6MkWuAEAUOiiSUREuAEAUOidTUREsBlQ6DUwREQKwHX060uwHVDoJzBERArAdD+wIVDoGzBERArAdDPGRv8B6xeKRv+0ALoJAPfqxB5GggPYJsYHAf5G/4pG/7QAugkA9+rEHkaCA9gmgD//ddOwGVDo3C9ERJgLwHUNsABQ6L0qRESYC8B0m7AZUOjCL0RECsB19LAAUOikKkRECsB16MQedAUmx0cClJYmjF8EJsdHBgAAJsdHCAAAJsdHChQAJsdHDAEAJsdHDgAAJsdHFAAAJsdHFgAA/zZ2Bf82dAXodTWDxASL5V3DVYvsVlc5JkxrdwPoJ2CAPnGF/3RfxB6emyaLfxQmi3cWobp5K8exBNP4SKPKoKG8eSvG0fjR+NH4o8yggz7KoAB9CMcGyqAAAOsNgz7KoBJ+BscGyqASAIM+zKAAfQjHBsygAADrDYM+zKAWfgbHBsygFgBfXl3DVYvsg+wEOSZMa3cD6K5fikYEomKFtADR4NHgi9iLhyIli5cgJYlW/IlG/sRe/CaKB6KwoSaKRwGiL50mi0cEJotXAokWuqCjvKCL5V3DVYvsOSZMa3cD6GNfoEOCNAGiQ4KAPkOCAHRogD5xhf90YcQeuqAmiwejYIWAPi+dAHQUJotHAvfYixa6eQPQiRa6eYvC6w/EHrqgJotHAgEGunmhunnEHrqgJotHBAEGvHmDBrqgBqCwoQT/orChtAALwHUHsACiY4XrB/4GY4WgY4Vdw1WL7DkmTGt3A+jeXoA+Q4IAdQPpDgGAPnGF/3UD6QQBgD6woQB0BuhAA+n3ALABorKhouKgouGgouCggD5xhQhyHqBxhbQAjgbaoAMG2KCL2CaKR/i0AAvAdQXGBuCgAIA+cYUocxmgcYW0AMQe2KAD2CaKB7QAC8B1BcYG4aAAgD5khQB0MaBxhbQAxB7YoAPYJopHL7QAC8B1HMYG4qAAoHGFtAADBtigi9gmgH//C3UFxgbioAGAPmSFB3QxoHGFtADEHtigA9gmikcwtAALwHUcxgayoQCgcYW0AAMG2KCL2CaAfwELdQXGBrKhAaDgoLQAihbhoLYAA8KKFuKgtgADwooWsqG2AAPCPQQAdQXoJQLrDaBihbQA0eCL2P+XcAhdw1WL7DkmTGt3A+i4XaDgoLQAC8B1BegjAOsfoLKhtAALwHUF6KQB6xGg4qC0AAvAdQXoEQHrA+iHAF3DVYvsOSZMa3cD6H1doLN5OgYgeXIEsAHrKfYGs3kBdBWAPuKgAHQEsAHrF7ADUOib/URE6xOAPrKhAHQEsAHrArAEUOiG/UREXcNVi+w5JkxrdwPoM12g4aC0AAvAdQXoIwDrH6DioLQAC8B1BeiaAOsRoLKhtAALwHUF6BEB6wPoff9dw1WL7DkmTGt3A+j4XKCzeToGIHlyBLAC6yn2BrN5AXQVgD7ioAB0BLAC6xewA1DoFv1EROsTgD6yoQB0BLAC6wKwBFDoAf1ERF3DVYvsOSZMa3cD6K5coOKgtAALwHUF6CMA6x+g4KC0AAvAdQXoC//rEaDhoLQAC8B1BeiC/+sD6IcAXcNVi+w5JkxrdwPoc1ygs3k6BiB5cgSwA+sp9gazeQF0FYA+4KAAdASwA+sXsAFQ6JH8RETrE4A+4aAAdASwA+sCsAJQ6Hz8RERdw1WL7DkmTGt3A+gpXKCyobQAC8B1BegjAOsfoOGgtAALwHUF6Av/6xGg4KC0AAvAdQXoeP7rA+h9/13DVYvsOSZMa3cD6O5boLN5OgYgeXIEsATrKfYGs3kBdBWAPuCgAHQEsATrF7ABUOgM/ERE6xOAPuGgAHQEsATrArACUOj3+0REXcNVi+xMTDkmTGt3A+iiW6CzeSQDiEb+6MVDorN5JAECRv4EBYhG/1DoyftERIvlXcNVi+w5JkxrdwPodFuAPmOFBXUNoGKFtADR4IvY/5dcCF3DVYvsOSZMa3cD6FJboHGFBPiicYX+DmWFXcNVi+w5JkxrdwPoOFugcYUECKJxhf4GZYVdw1WL7DkmTGt3A+geW/4OcYX+DmSFXcNVi+w5JkxrdwPoCFv+BnGF/gZkhV3DVYvsOSZMa3cD6PJaoM6gtAALwHUkoZCSBfv/o0wIoZCSBQYAo04IoZKSBfv/o1AIoZKSBQUAo1IIXcNVi+w5JkxrdwPot1qgzqC0AAvAdSShunkF+/+jVAihunkFBgCjVgihvHkF+/+jWAihvHkFBQCjWghdw1WL7DkmTGt3A+h8WoA+cYX/dHGgzqC0AAvAdWigbYW0AAvAdV+APix5MHRYoVQIOwZOCH4HxgaqoQDrSKFMCDsGVgh+B8YGqqEA6zihWAg7BlIIfgfGBqqhAOsooVAIOwZaCH4HxgaqoQDrGMYGqqEBgz6caAR0BLAD6wKwDVDolBxERF3DVYvsOSZMa3cD6PZZxB50BYtGBCaJBybHRwYAACbHRwgAAItGBiaJRw4mx0cUAAAmx0cWAAAmx0ccAAAmx0ceFAAmx0cgGQD/NnYF/zZ0Bej1QYPEBF3DVYvsOSZMa3cD6J9ZoSh5ixYmeYPCY8QedAUmiVcCJolHBCbHRwYAACbHRwgAACbHRwoUACbHRwwZACbHRxA6nSaMXxImx0cUAAAmx0cWAAAmx0cYAwAmx0caAgAmx0ccAAAmx0ceAwAmx0cgAgD/NnYF/zZ0BehbLoPEBMQedAUmx0cGBAAmx0cQr5smjF8S/zZ2Bf82dAXoOS6DxATEHnQFJsdHBgAAJsdHCAgAJsdHELqeJoxfEibHRxgBACbHRxoEACbHRx4BACbHRyAEAP82dgX/NnQF6Pktg8QExB50BSbHRwgDACbHRxC6nyaMXxL/NnYF/zZ0BejXLYPEBMQedAUmx0cGAAAmx0cIDQAmx0cQiIsmjF8SJsdHGAYAJsdHGgIAJsdHHgYAJsdHIAIA/zZ2Bf82dAXoly2DxATEHnQFJsdHCBEAJsdHEE6CJoxfEv82dgX/NnQF6HUtg8QExB50BSbHRwgVACbHRxCChSaMXxL/NnYF/zZ0BehTLYPEBF3DVYvsOSZMa3cD6BlYxB50BSbGRyIAJsZHIwAmxkckACbGRyUAxB64CCbHBwEAJsdHEI2OJoxfEibHRxQAACbHRxYAACbHRxgEACbHRxoEACbHRxwAAMQe7AgmxwcBACbHRxCUkiaMXxImx0cUAAAmx0cWAAAmx0cYBAAmx0caBAAmx0ccAADEHrwIJsdHBgAAJsdHCAAAJsdHCgEAJsdHDAQAJsdHDgEAJsdHHAAAJsdHHgEAJsdHIAQAxB7ACCbHRwYAACbHRwgAACbHRwoDACbHRwwCACbHRw4BACbHRxwAACbHRx4CACbHRyACAMQexAgmx0cCjY4mjF8EJsdHBgAAJsdHCAAAJsdHCgQAJsdHDAQAJsdHDgEAJsdHHAAAxB7oCCbHRwKUkiaMXwQmx0cGAAAmx0cIAAAmx0cKBAAmx0cMBAAmx0cOAQAmx0ccAADEHsgIoSh5ixYmeSaJVwImiUcEJsdHChQAJsdHDBkAJsdHEIiIJoxfEibHRxQAACbHRxYAACbHRxgDACbHRxoEACbHRxwAACbHRx4BACbHRyAEAMQezAgmx0cGAAAmx0cIAAAmx0cMBAAmx0cQiIgmjF8SJsdHDgEAJsdHGAMAJsdHGgQAJsdHHgEAJsdHIAQAxB7QCCbHBwEAJsdHFAAAJsdHFgAAJsdHGAEAJsdHGgQAJsdHHAAAJsdHHgEAJsdHIAQAxB7UCCaJVwImiUcEJsdHChQAJsdHDBkAJsdHDgEAJsdHHgIAJsdHIAIAxB7YCCaJVwImiUcEJsdHChQAJsdHDBkAJsdHEIiIJoxfEibHRxQAACbHRxYAACbHRxgDACbHRxoEACbHRxwAACbHRx4DACbHRyACAMQe3Agmx0cGAAAmx0cIAAAmx0cKAwAmx0cOAQAmx0cQiIgmjF8SJsdHGAMAJsdHGgQAJsdHHgMAJsdHIAIAxB7gCCbHBwEAJsdHFAAAJsdHFgAAJsdHGAMAJsdHGgIAJsdHHgMAJsdHIAIAxB7kCCaJVwImiUcEJsdHChQAJsdHDBkAJsdHDgEAJsdHHAAAJsdHIAIAXcNVi+yD7AZWVzkmTGt3A+jxVB64KAlQ6G0cg8QEoSh5ixYmeYkWfoWjgIW4BABQuAMAUOi5HIPEBIvwM8BQ/zZOCf82TAn/NoCF/zZ+hVbojB2DxAyJRvyJVv5W6DocREQzwLpjfVBS/3b+/3b8/zaAhf82foXoYSSDxAyDPh1UAXU3oYCFixZ+hYkWlpujmJvGRvsA6x2KRvu0AMQelpsD2IpG+7QAi/iKhR4HJohHI/5G+4B++xBy3egq3aGAhYsWfoWDwmPEHnQFJolXAiaJRwQmx0cGAAAmx0cIAAAmx0cKFAAmx0cMGQAmx0cOAQAmx0cUAAAmx0cWAAAmx0ccAAAmx0ceFAAmx0cgGQD/NnYF/zZ0BegiKYPEBDPAUP82gIX/Nn6F6Ogjg8QGM8BQ6BYkRES4AQBQ6CAkRETookDEHnQFJsdHDgAAJsdHHgEAJsdHIAIA6AYAX16L5V3DVYvsg+wKOSZMa3cD6JNTM8BQ6Bo8RETGRvcAxkb/AOmmAYpG/7QA0eDR4NHgBfAIo3SFjB52hcQedIUmi0cGJotXBDsG1qB2A+nUAHIJOxbUoHID6ckAikb3tAALwHQD6b0Axkb3AYpG/4hG/qEiCYsWIAmJVvqJRvzGRvYG61OKRva0ANHg0eDR4IvYi4fqCIuX6AiKXva3ANHj0ePR44mX8AiJh/IIikb2tADR4NHg0eCL2IuH7giLl+wIil72twDR49Hj0eOJl/QIiYf2CP5O9opG9jpG/3elxB50hYtG/ItW+iaJFyaJRwLGRvYA6xXEHnSFJsQfikb2tAAD2CbGB0H+RvaAfvYIcuXEHnSFodagixbUoCaJVwQmiUcGikb/tACxBNPgBUEAxB6EiCaJRwLGRvkA61/EHnSFJsQfikb5tAAD2CaKB4hG+DwudReAfvcAdAyKRv46Rv91BLBb6wKwIIhG+MQehIiKRvi0AAV1ASaJRwSKRvm0ALEE0+AmiQeAfvggdAseuC55UOi2OoPEBP5G+YB++Qhym4pG/7QAsQTT4AVBAFC4sABQsAdQxB50hSb/dwYm/3cE6JoGg8QK/kb/gH7/B3MD6VH+gH73AHQLikb+UOgUAERE6wPoydi4AQBQ6EM6RESL5V3DVYvsg+wGOSZMa3cD6KFRxkb+AIpGBLQA0eDR4NHgBfAIo3SFjB52hcdG+rYBxB50hSbEH4pG/rQAA9gmxgdBxB50BYpG/rQAJolHFIpGBLQA0eAFCAAmiUcWsAFQ/3b6ikb+UIpGBLEE0uAEQVDolwWDxAjpFgL2Rv8BdGSBfvqsAX5d/076gX760AF1BcdG+qMBi0b6BYv+iUb6xB50hSbEH4pG/rQAA9iKRvomiAeDfvoudQXHRvpbAItG+gV1AYlG+rABUP92+opG/lCKRgSxBNLgBEFQ6C0Fg8QI6awB9kb/AnRkgX760AF9Xf9G+oF++tABdQXHRvqjAYtG+gWL/olG+sQedIUmxB+KRv60AAPYikb6JogHg376LnUFx0b6WwCLRvoFdQGJRvqwAVD/dvqKRv5QikYEsQTS4ARBUOjDBIPECOlCAfZG/wR1A+mEAIB+/gB0foF++tABdQXHRvqjAYtG+gWL/olG+sQedIUmxB+KRv60AAPYikb6JogH/k7+xB50hSbEH4pG/rQAA9gmige0AIlG+oN++i51BcdG+lsAi0b6BXUBiUb6HrgueVDonziDxASwAFD/dvqKRv5QikYEsQTS4ARBUOg2BIPECOm1APZG/wh1A+mDAIB+/gdzfYF++tABdQXHRvqjAYtG+gWL/olG+sQedIUmxB+KRv60AAPYikb6JogH/kb+xB50hSbEH4pG/rQAA9gmige0AIlG+oN++i51BcdG+lsAi0b6BXUBiUb6HrgueVDoEjiDxASwAFD/dvqKRv5QikYEsQTS4ARBUOipA4PECOsp/kb99kb9CHQN/zZ2Bf82dAXo/x7rCB64LnlQ6NU3g8QEsAFQ6ImpRESwAFDoPBlERIhG/7QAJRAAPRAAdAPp0v0euC55UOiqN4PEBIvlXcNVi+yD7BQ5JkxrdwPo7U4WjUb2UB64aiVQuQQA6E9NxB50BSbHRw4AACbHRxwAACbHRx4BACbHRyACALAAiEb6iEb9i0b4i1b2iVbyiUb0xkb+AOsRikb+tADEXvID2CbGB0H+Rv6Afv4GcunHRuy2AYpG/bQAxF7yA9gmxgdBxB50BYpGBrQAJolHFIpGBLQA0eAmiUcWsAFQ/3bsikYGUIpGBLEE0uBQ6KgCg8QI6fYB9kb/AXRegX7srAF+V/9O7IF+7NABdQXHRuyjAYtG7AWL/olG7IpG/bQAxF7yA9iKRuwmiAeDfuwudQXHRuxbAItG7AV1AYlG7LABUP927IpGBlCKRgSxBNLgUOhEAoPECOmSAfZG/wJ0XoF+7NABfVf/RuyBfuzQAXUFx0bsowGLRuwFi/6JRuyKRv20AMRe8gPYikbsJogHg37sLnUFx0bsWwCLRuwFdQGJRuywAVD/duyKRgZQikYEsQTS4FDo4AGDxAjpLgH2Rv8EdH2Afv0AdHeBfuzQAXUFx0bsowGLRuwFi/6JRuyKRv20AMRe8gPYikbsJogH/k79/k4Gikb9tACLXvID2CaKB7QAiUbsg37sLnUFx0bsWwCLRuwFdQGJRuweuC55UOjENYPEBLAAUP927IpGBlCKRgSxBNLgUOhdAYPECOmrAPZG/wh0fIB+/QVzdoF+7NABdQXHRuyjAYtG7AWL/olG7IpG/bQAxF7yA9iKRuwmiAf+Rv3+RgaKRv20AIte8gPYJooHtACJRuyDfuwudQXHRuxbAItG7AV1AYlG7B64LnlQ6EE1g8QEsABQ/3bsikYGUIpGBLEE0uBQ6NoAg8QI6yn+Rvr2RvoIdA3/NnYF/zZ0BegwHOsIHrgueVDoBjWDxASwAVDouqZERLAAUOhtFkREiEb/tAAlEAA9EAB0A+ny/R64LnlQ6Ns0g8QEsACIRvyIRv7raYpG/rQA0eDR4IvYi4deE4uXXBOJVu6JRvCwAIhG+4hG/esjikb9tADEXvID2CaKB4pW/bYAxF7uA9omOgd0BMZG+wH+Rv2Afv0GcwmKRvu0AAvAdM6KRvu0AAvAdQiKRv4EAohG/P5G/oB+/ghzCYpG/LQAC8B0iIpG/IvlXcNVi+w5JkxrdwPonEvEHnQFikYGtAAmiUcU/zZ2Bf82dAXoSxuDxATEHoSIi0YIJolHBIpGBrQAsQTT4CaJB4pGBLQAJolHAoB+CgB0Cx64LnlQ6Pozg8QEsAhQ6K6lRERdw1WL7IPsDFaLdgo5JkxrdwPoM0uKRgiIRvTGRvUA6xOKRvX+RvW0AI1W9gPCi9g2xgcgikb1OkYIcuWKRgi0AI1W9gPCi9g2xgcA60WKRgSIRv8zwLoKAFBS/3YG/3YE6E9IiUYEi9iJVgaLyjPSuAoA6GNJilb/KtCIVv+KRgi0AI1W9gPCilb/gMIwi9g2iBeKRgj+TggKwHexxB6EiItGDCaJRwLGRvUA6zqKRvW0AI1W9gPCi9g2ige0AAV8AcQehIgmiUcEikb1tACxBNPgi9YD0CaJFx64LnlQ6A0zg8QE/kb1ikb1Okb0cr5ei+Vdw1WL7ExMOSZMa3cD6EVKxB7QoCbHRwSqASbHRwIAAKAaeYhG/+sjikb/tADR4NHg0eAFUADEHtCgJokHHriGeVDotzKDxAT+Tv+Afv8AddeL5V3DVYvsTEw5JkxrdwPo8knHBqabhgiMHqibxB6mmybGB//GBqahALIA6x+KwrQAxB7YoAPYJopHMIrIgPkOcgiA+RJzA6Kmof7CgPowcwmgpqG0AAvAdNOAPqahAHUD6bUAsACIRv+K0OsmisK0AMQe2KAD2CaKRzCKyID5DnIPgPkScwo6BqahdATGRv8B/sKA+jBzCYpG/7QAC8B0zIpG/7QAC8B1b7AAiEb+iEb/sgDrJorCtADEHtigA9gmgH8wBXUTikb+tADEHqabA9iKwiaIB/5G/v7CgPowcwmKRv+0AAvAdMyKRv60AMQeppsD2CaAP/90HopG/rQAix6mmwPYJsYH/8cGppuGCIweqJvGBrd5AIvlXcNVi+w5JkxrdwPo20jEHqabJoA//3UUxwamm4YIjB6om8Qeppsmxgf/6z2gt3m0AAvAdTDGBrd5CsQeppsmigeicIWwGFDopQdERIM+nGgEdASwEesCsA5Q6BoLRET/Bqab6wT+Drd5XcNVi+w5JkxrdwPockiDPpxoBHQEsAPrArANUOjvCkREXcNVi+w5JkxrdwPoUUiAPl6FAHQ3oG6FtADEHtigA9gmgH8vDHUlxgYqeQDGBs6gAbAuUOgI30REgz6caAR0BLAD6wKwDVDoowpERF3DVYvsOSZMa3cD6AVIgD5ehQd0N6BuhbQAxB7YoAPYJoB/MAx1JcYGKnkAxgbOoAGwLlDovN5ERIM+nGgEdASwA+sCsA1Q6FcKRERdw1WL7ExMOSZMa3cD6LdHgD5ShQN0NYA+UoUPdC6DPpxoBHQNoCR5tACL2IqHPibrC6AkebQAi9iKhw4miEb/gH7/AHQGUOgLCkREi+Vdw1WL7ExMOSZMa3cD6GlHgz6caAR0DaBRhbQAi9iKh44n6wugUYW0AIvYioduJ4hG/4B+/wB0BlDoywlERIA+UYUOcgqAPlGFEnMD6Cr9i+Vdw1WL7DkmTGt3A+gaR4M+nGgEdASwC+sCsCxQ6JcJRERdw1WL7ExMOSZMa3cD6PdGgz6caAR0DaC5ebQAi9iKh/4m6wuguXm0AIvYiofOJohG/4B+/wB0BlDoWQlEROiRAIvlXcNVi+w5JkxrdwPotkaDPpxoBHQEsA7rArAhUOgzCUREXcNVi+w5JkxrdwPolUboIAGgboUE+KJuhf4OXIVdw1WL7DkmTGt3A+h4RugDAaBuhQQIom6F/gZchV3DVYvsOSZMa3cD6FtG6OYA/g5uhf4OXoVdw1WL7DkmTGt3A+hCRujNAP4GboX+Bl6FXcNVi+w5JkxrdwPoKUagI3m0AAvAdSL2BkSCEHUH9gZEggF0FKAkeaIiebQAi9iKh9o8UOjbA0REXcNVi+w5JkxrdwPo8EWgp6G0AAvAdTSAPiR5AnUt9gZEggJ0JoM+nGgEdASwBOsCsAlQ6FYIRESgboWib4XGBrR5NLA0UOjcA0REXcNVi+w5JkxrdwPopUXGBkSCAF3DVYvsOSZMa3cD6JJFoESCJBCiRIJdw1WL7DkmTGt3A+h8RaBEgiQdokSCXcNVi+w5JkxrdwPoZkWgRIIkD6JEgl3DVYvsOSZMa3cD6FBFoG6FUOi6BUREgD64eQB0A+jOBV3DVYvsTEw5JkxrdwPoLUWDPpxoBHQNoCR5tACL2IqH3iXrC6AkebQAi9iKh64liEb/gH7/AHQGUOiPB0REoCR5tACL2IqHCj1Q6PQCRESL5V3DVYvsOSZMa3cD6N5EgD5ShQN0EoA+UoUPdAseuHo8UOivBoPEBIA+XoUAdBGgUYW0AIvYioe+NVDotQNERF3DVYvsOSZMa3cD6J9EgD5ShQN0EoA+UoUPdAseuKo8UOhwBoPEBIA+XoUHdBGgUYW0AIvYiofeNVDodgNERF3DVYvsOSZMa3cD6GBEoG6Fom+F6PoFgD5shVt1BcYGsaEAXcNVi+w5JkxrdwPoPURdw1WL7DkmTGt3A+gvRIM+nGgEdASwCOsCsC9Q6KwGRESwGFDoJwZERIA+XoUAdBGgUYW0AIvYiof+NVDoBANERF3DVYvsOSZMa3cD6O5Dgz6caAR0BLAI6wKwL1DoawZERLAZUOjmBUREgD5ehQd0EaBRhbQAi9iKhx42UOjDAkREXcNVi+w5JkxrdwPorUOAPl6FAHQD6AIAXcNVi+w5JkxrdwPolUMeuD42UOh0AIPEBF3DVYvsOSZMa3cD6HxDgD5ehQd0A+gCAF3DVYvsOSZMa3cD6GRDoG6FonCFHrheNlDoPQCDxARdw1WL7DkmTGt3A+hFQx64PjZQ6CQAg8QEXcNVi+w5JkxrdwPoLEOgboWicIUeuF42UOgFAIPEBF3DVYvsOSZMa3cD6A1DoFGFtADEXgQD2CaKB1DoAgJERMYGRIIAXcNVi+w5JkxrdwPo50KAPl6FAHQWoFGFtACL2IqH/jVQ6NcBRETGBkSCAF3DVYvsOSZMa3cD6LxCgD5ehQd0FqBRhbQAi9iKhx42UOisAURExgZEggBdw1WL7DkmTGt3A+iRQoA+XoUAdAPoAgBdw1WL7DkmTGt3A+h5QqBRhbQAi9iKh342UOhwAURExgZEggBdw1WL7DkmTGt3A+hVQoA+XoUHdAPoAgBdw1WL7DkmTGt3A+g9QqBRhbQAi9iKh542UOg0AURExgZEggBdw1WL7DkmTGt3A+gZQqBuhaJvhYB+BAB0D4pGBKKnoYpGBFDoJwBERF3DVYvsOSZMa3cD6PBBoG6Fom+FgH4EAHQJikYEUOgEAEREXcNVi+yD7AhWOSZMa3cD6MlBikYEtADR4NHgi9iLh+Aui5feLolW/IlG/rEAisG0ANHg0eCL2IuHckyLl3BMiVb4iUb6xF74JooHiEYE/sG0AAvAdNeAfgT/dTyxAIrBtADR4NHgi9iLh3JMi5dwTIlW+IlG+sRe+CaKB4hGBP7BgH4EAHQGgH4E/3XRikYEtAALwHVG6w3EXvgmikcBOgZvhXWIxF74oG+FJohHAbQAxB7YoAPYBsR2/CaKBAcmiAfEXvwmi0cEJotXAsRe+CaJVwImiUcEJsYHAV6L5V3DVYvsg+wKVjkmTGt3A+jqQIpGBKJmhQrAdQPpCgGDPpxoBHQNikYEtACL2IqHTifrC4pGBLQAi9iKhy4niEb2gH72AHQGUOg/A0REikYEtADR4NHgi9iLh1gyi5dWMolW/IlG/sZG9wCKRve0ANHg0eCL2IuHvkyLl7xMiVb4iUb6xF74JooHiEYE/kb3tAALwHTVgH4E/3VGxkb3AIpG97QA0eDR4IvYi4e+TIuXvEyJVviJRvrEXvgmigeIRgT+RveAfgQAdAaAfgT/dc+KRgS0AAvAdBiAfgT/dUrrSMRe+CaKRwE6BnCFdAPpef/EXvigcIUmiEcBtADEHtigA9gGxHb8JooEByaIRzDEXvwmi0cEJotXAsRe+CaJVwImiUcEJsYHAV6L5V3DVYvsOSZMa3cD6MI/ikYEtADEHtigA9gmigeiIXldw1WL7DkmTGt3A+ijP4pGBLQAxB7YoAPYJopHMKJRhV3DVYvsOSZMa3cD6IM/ikYEtADEHtigA9gmikdgorh5XcNVi+w5JkxrdwPoYz/GBhAoD+htAKBuhbQAxB7YoAPYJsZHYACAPrh5AXRUgD64eSN0Tf4Oz6Cgz6C0AAvAdS2DPpxoBHQEsAvrArAsUOitAUREoHKFom+FsFlQ6Dj9RETGBrGhAcYGUIXy6xODPpxoBHQEsA7rArAhUOiAAUREXcNVi+w5JkxrdwPo4j7GBqihAqBuhbQA0eDR4IvYi4d0ArEE0/ijmpugboW0ANHg0eCL2IuHdgLR+NH40fijopv2Bm6FAXQFuAEA6wO4AgDEHuQIJolHHoEG1KD6AIMW1qAAgD64eSN1Bv4GGnnrIYA+uHkvdQiBBtSgFibrDYA+uHkwdQuBBtSgVsKDFtagAF3DVYvsTEw5JkxrdwPoTz6gboVQ6Hr+RESgIXm0AIvYioeWQ4hG/4B+/wB0FaAkeaIieYpG/6IjeYpG/1DoMABERIvlXcNVi+w5JkxrdwPoDT6gQoK0AAvAdROgJHm0AMReBAPYJooHUOj3+0REXcNVi+w5JkxrdwPo4z2gboWib4WKRgRQ6P37RERdw1WL7DkmTGt3A+jGPf4OboX+Dl6F6F7/XcNVi+w5JkxrdwPorT3+Bm6F/gZehehF/13DVYvsVjkmTGt3A+iTPYE+nGgAgHQW6Ooai/ChnGgjxqOcaP82nGjoEhtERF5dw1WL7DkmTGt3A+hmPYE+nGgAgHQJikYEUOgEAEREXcNVi+w5JkxrdwPoRz2DPpxoBHUpikYEtADR4IvYioevJ7QAUIpGBLQA0eCL2IqHrie0AFDooRuDxATpeQKKRgS0AEiL2IP7FHYD6WkC0eMu/6fncLgBAFBQuMIBULgKAFC4AQBQuOgD6TwCuAEAUFC4wgFQuPb/ULgBAFC4IANQuCgA6SUCuP//ULgEAFC48wFQuP//ULgBAFC4uAFQuJAB6QcCuAQAULgBAFC4ZABQuP//ULgBAFC43ABQuFoA6ekBuAIAULgBAFC4uAFQuAoAULgBAFC46ANQuBkA6csBuAUAULgCAFC4uAFQuAoAULgBAFC4TARQuBQA6a0BuAMAULgBAFC4uAFQuAoAULgBAFC4sARQuA8A6Y8BuAUAULgBAFC4ZABQuPv/ULgBAFC43ABQuCgA6XEBuAEAUFC4wgFQuBQAULgBAFC4MgDpVgG4CgBQuAEAULhdAVC4MgBQuAEAULjIAFC4DwDpPAG4/P9QuAEAULjzAVC4FABQuCgAULgCAFDoSSWDxAzpJgG4AgBQuAEAULikAVC4CgBQuAEAULiwBOn9ALgPAFC4AgBQuF0BULgyAFC4AQBQuMgAULgUAOnjADPAULgKAFC4yABQuAQAULgBAFC4CgBQuDIA6cYAuAEAULgCAFC4ZABQuAIAULgBAFC4LAFQuJAB6agAuAIAULgBAFC4pAFQuAoAULgBAFC4sATpigC4/P9QuAEAULjzAVC4FABQuCgAULgCAFDomySDxAzrebj8/1C4AgBQuPMBULgeAFC4UABQuAIAUOh7JIPEDOtZuAEAULgCAFC4ZABQuAEAUFC4LAFQuCAD6zQzwFC4CgBQuMgAULgEAFC4AQBQuAoAULgyAOsYuAEAUFC4wgFQuAoAULgBAFC4WAJQuB4AULgCAFDopiODxBBdw4Numm61btNu8W4Pby1vS29pb4Bvnm+/b9lv928UcDJwTHBscIxwpnDCcFWL7DkmTGt3A+hmOl3DAFWL7IpGBLQAzRBdw1WL7IPsLlYz9rgQAFAWjUbSUP92Bv92BOiMLoPECj3//3UGuP//6cMAgH7wLnRngH7nEHUIxF4IJsYAKkbGRv8A6xmKRv+0AI1W8APCi9g2igfEXggmiABG/kb/ikb/tACNVvADwovYNoA/AHXVgH7nEHUFuAEA6wIzwIpW/wLQiFb/6wvEXggmxgAgRv5G/4B+/w5y7xaNRtJQ6Dwug8QEC8B1CYH+agV9A+l7/zP26y/EXggmgDggdSXrAUbEXggmgDggdPaLxgX+/4vwA9gmxgcbQIvwi14IA9gmxgdMRsReCCaAOAB1yDPAXovlXcPoZS3DVYvs/3YI/3YG/3YE6EQug8QGXcNVi+yD7ApWV8ZG/wAz9sdG+gAAx0b8AADpfwCDfg4AfBd/B4F+DAD6dg6/APqBbgwA+oNeDgDrDYt+DMdGDAAAx0YOAABX/3YK/3YI/3YG/1YEg8QIi/A793QFuAEA6wIzwIhG/wF2+oNW/ACLRgiJRvbHRvgAAAF29oNW+ACLRvaJRgjHRvYAAItG9gtG+HQJg0YIAIFWCgAQi0YMC0YOdAyKRv+0AAvAdQPpbf+LVvyLRvpfXovlXcNVi+yLRgajuKH/dgTo6y1ERMYG5kwBXcNVi+yLRgaLVgSJFrSho7ahXcNVi+xW/3YE6GslRESL8F5dw1WL7IPsBFa4AIBQi0YEugoA9+rEHrShA9gm/3cCJv836M8ug8QGi/BW6N0sRESJRvyJVv5W6CwlRESLVv6LRvxei+Vdw1WL7ExMVleLfgTGRv8AoOZMtAALwHUGxwa4odR0i8e6CgD36sQetKED2CaAfwR6dEn/dgaLx7oKAPfqxB60oQPYJopHBFDoHQGDxASL8AvAdBqLx7oKAPfqxB60oQPYJopHBLQAUP8WuKFERAv2dAqKRv/+Rv88CnK3gH7/Cndni8e6CgD36sQetKED2CaKRwSi50y4gAFQi0YGDQSAUIvHugoA9+rEHrShA9gm/3cCJv836Pctg8QIi/ALwH0ai8e6CgD36sQetKED2CaKRwS0AFD/FrihREQL9n0Kikb//kb/PApyrYvGX16L5V3DVYvsg+wE/3YM/3YK/3YI/3YG/3YEuK6jUOi7/YPEDIlG/IlW/otG/IvlXcNVi+yD7AT/dgz/dgr/dgj/dgb/dgS4/p1Q6I/9g8QMiUb8iVb+i0b8i+Vdw1WL7P92BOjMKkREXcNVi+z/dgb/dgToniqDxARdw8NVi+xWuIABUItGBg0EgFAeuOhMUOgwLYPECIvwC/Z+NzPAULoEAFBSHri6oVBW6Fj/g8QMVugM/kREoLqhtACKVgS2ACvCi/CAPrqhenQGgH4EenUCM/aLxl5dwwCcUFNRUlZXHga4OxCO2I7A/L/yTLkgADPA86u4AADohgK4AQDogAIHH19eWllbWJ3DVYvsHgZWV4tGBDLkxHYG6AYAX14HH13DHro7EI7aPBByBrp2dumfAAPAA8C7OxCO27vyTAPYiTeMwIlHAh/DVYvsi0YEXR4GVle6OxCO2jLkPRAAcga6yHbrbJADwAPAu/JMA9jEN4zAC8Z1Bbo0dutVugAAJooERjz9cwtSVuhXAV5aCtXr7Tz/dDIeuDsQjtiLHkJNJooERjz9cxWK8CaKBEY8/XMLJH/XIsB08QrW6+08/nQGPP912+sBH19eBx+KwjLkw4zIjti0Cc0h6/5FcnJldXIgZGFucyBUc3RKb3k6IHV0aWxpc2F0aW9uIGQndW4gam95c3RpY2sgbG9naXF1ZSBub24gZGVmaW5pLiRFcnJldXIgZGFucyBEZWZKb3k6IHRlbnRhdGl2ZSBkJ2luaXRpYWxpc2F0aW9uIGQndW4gam95c3RpY2sgbG9naXF1ZSBob3JzIGxpbWl0ZS4kRXJyZXVyIGRhbnMgVHN0Sm95OiB0ZW50YXRpdmUgZCd1dGlsaXNhdGlvbiBkJ3VuIGpveXN0aWNrIGxvZ2lxdWUgaG9ycyBsaW1pdGUuJFWL7ItGBF0eU7s7EI7bu8pNJAF0A7vLTYoHMuQjwHkCM8BbH8MeuzsQjttQ6BsBWzLtPf//dEeD4wF0RDomO01zBYDNBOsJOiY9TXIDgM0IOgY6TXMFgM0B6wk6BjxNcgOAzQK6AQLs9tCoQHQDgM0QqIB0A4DNIIguNU3rAB/DOiY3TXMFgM0E6wk6JjlNcgOAzQg6BjZNcwWAzQHrCToGOE1yA4DNAroBAuz20KgQdAOAzRCoIHQDgM0giC40Teu8Hrs7EI7bu8pNI8B0A7vLTbEBiA+L2FBT6G0AW1k9//90T4D8AnI+PAJyOovI0OjQ7IvQA8kryrg7EI7Yg+MBdBKIFjpNiDY7TYgOPE2ILj1N6xCIFjZNiDY3TYgOOE2ILjlNH8NRuQAA4v5ZuP//6wIywLvKTSPJdAO7y02IB+viVYvsi0YEXZz6Hrs7EI7bJAF0FLsIBKDLTf7IdB7+wHQD6bAA6eYAuwIBoMpN/sh0Cv7AdAPpnADpvgC6AQIzyeyEw+D74wSEx+D14wLrA+mCALoBAu7shMd1JYTDdSGwBuZDUblkAOL+WeRAiuDkQIDkEHT15ECK4ORAgOQQdfUzyYkOMk256APkQIrg5ECA5BB09f8GMk3sItt0CITDdCUi/3QEhMd0D+RAiuDkQPbEEHX14tPrHKEyTaPGTTL/Itt0FevjoTJNo8hNMtsi/3QH69W4///rHYsWxk0j0nkCM9KxAdPqochNI8B5AjPAsQHT6IriH53DugEC7CQDddOwAaLKTbgAAOsS68e6AQLsJAx19rABostNuAEAU1C4//89//9YW3TiU+ja/lvrxlZXHga4OxCO2I7A/Is+Qk25QAC4AADzqwfoWwGhxE0jwHU1QKPETR4GsAm0Nc0hjMK4AACOwIkePk0miR5teokWQE0miRZverrmebsAAI7bsAm0Jc0hBx8fX17DnPpQU1EeV1ZSuEAAjti7gACLP4t3ArsaAIsPi1cCK/cr0XMEK/KL1oP6EHIHLqFxeolHAotHAi6jcXrkYDz/dCyKyLs7EI7bix5CTbQAJH+L+PbBgHQCMsCIAS7/HnN6Wl5fH1lbWJ0u/y5teuRhiuAMgOZhisTmYVpeXx9ZW7Ag5iBYnc/LAAAAAAAAbHoAAFZXHrg7EI7YocRNI8B0KjPAo8RNHgaLFj5Nix5ATY7bsAm0Jc0hBx/oXwC0C80hIsB0BrQHzSHr8h9fXsNVi+yLRgRdHlNXuzsQjtuLPkJNMuQkfwP4igVfWx8jwMNVi+yLRgRdUOjb/1h0+cNWV7QLzSEiwHQD6AcAMuQjwF9ew1ZXtAjNIV9ewx5QU7hAAI7Yu4AAiwe7GgCJB4lHAltYH8NVi+xQHrgAAI7Yi0YELqNzeotGBi6jdXofWF3DHlC4AACO2Fguo3N6LokWdXofwwBVi+yLVgaLRgRdmnkBuQrDVYvsi34Gi3YEi14Ki0YIi1YOi04MXZoAACgMw1WL7ItWBotGBF2awAG5CsNVi+yLXgRdmsEBuQrDVYvsi1YGi0YEi14IXZrhAbkKw8Oa/wG5CsNVi+yLVgaLRgRdmhsCuQrDVYvsik4EXZoyArkKw1WL7IteBF2asQK5CsOazgK5CsNVi+yLXgRdmlEDuQrDVYvsi1YGi0YEXZqEA7kKw+i+/svoAP/LLo8G2nwujwbcfC6PBth8Lv823Hwu/zbafC6jznwuiR7QfC6JDtJ8LokW1HyM2C6j1ny4OxCO2MUezFS5BgCLBwNHAj30AXwRLfQB/3cE/3cGugAAUrqHfFKJRwKDwwji3S6h1nyO2C6LHtB8LosO0nwuixbUfLAg5iAuodh8UJ0uoc58y/oujwbafC6PBtx8nFdWVR4GUFNRUroAAFK6uXxSLv823Hwu/zbafLg7EI7Y+/4G1VTLuDsQjtj+DtVUWllbWAcfXV5fnfvLAAAAAAAAAAAAAAAAAAAAAKDUVDLkIsB0A+nHAOjDAqPWVLkGAFG4AACL2UvoZQFZ4vO79lS5EAAzwIkHg8MC4vm7FlW5EAC4//+JB4PDAuL5uRIAodZUI8B0KT0A+HMkPVEJch+LyNHp0em4//8z0vfxA8CLyAPAA8ADwAPB0ejR6IvIi8G7AAC6AAC5en7oAgG4MgC7AQC6AAC5gH7o8wAGtDWwCM0hiR7QVIzDiR7SVAe4AQCi1FSc+h64AACO2LoCfLQlsAjNIR+d6BUABrgPNc0hiR7YVIzDiR7aVAe4AQDDuFEJ6OIBw6DUVDLkIsB0JR7FFthUtCWwDx+h1lToyAEexRbQVLQlsAjNIR+4AACi1FS4AQDDVYvsi14Ei0YGHsVOCIzaH10j23gYg/sEfRODwwIjwHgMPfQBfQfoUQC4AQDDM8DDVYvsi0YEXYvYI9t4FYP7BH0Qg8MCM8CLyIvQ6CwAuAEAwzPAw1WL7ItGBF2L2CPbeBWD+wR9EIPDAgPbA9sD24HDnFSLB8MzwMMD2wPbA9uBw5xUiQczwIlHAolPBolXBMOc/x7QVMu79lS5EAD/B4PDAuL5uQQAuxZViwc9//90B/8HO0cCfQaDwwji7cu4//+JB1FT/18EW1nr7FWL7ItGBItOBl0jwHgYPQ4AfRMFAgADwLv2VAPYi0YGiQ+4AQDDM8DDVYvsi0YEXSPAeBI9DgB9DQUCAAPAu/ZUA9iLB8MzwMNVi+yLRgRdix72VDvDc/gzwKP2VMOh9lTDVYvsi0YEXTPbiR74VDsG+FR/+sNVi+y7FlWLRgQjwHgpPQQAfSQDwAPAA8AD2ItGBolHAjPAiQcGxEYIiUcEjMCJRwYHuAEAXcMzwF3DVYvsuxZVi0YEI8B4Gj0EAH0VA8ADwAPAA9i4//+JRwKJB7gBAF3DM8Bdw+gAAOgAAOgAAMNQsDbmQ+ju/1jmQOjo/4rE5kDo4f/DU1G5GQAz27AG5kPo0v/65ECK4OjK/+RA+zrHcvF1BDrccwKK3Ir44uWLw1lbw1WL7ItGBItWCItOBugCAF3DBh5QuDsQjtig1FQiwFh0Rpz6UB6O2ovRtCWwCM0hH7gPNc0hiR7YVIzDiR7aVB64AACO2LqGgLQlsA/NIR9Yu95UA8AD2B64OxCO2IsHH6PcVOhW/50fB8Oc+h64OxCO2Ohf/TPbjtu4AACJRyK4AnyJRyC4OxCO2KHYVDPbjtuJRzy4OxCO2KHaVDPbjtuJRz4z2x+dw1CwIOYgWM8AVYvsi1YGi0YEXZoAANUMw1WL7ItGBl2aMgDVDMMAVYvsi1YGi0YEXZpzCrkKw1WL7ItWBotGBF2adw25CsMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIMAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAzP2N7xviatVwySK+drNjqeGf6JZwjnGG5n7Gdw1xtWq4ZBFfu1mxVPBPdEs4RzhDcz/jO4Y4WjVcMogv3SxYKvgnuiWcI5whuR/xHUMcrRouGcQXbhYsFfwT3RLOEc4Q3A/4DiEOVg2XDOILNwuWCv4JbgnnCGcI7gd8BxAHqwZLBvEFmwVLBf8EtwRzBDME9wO+A4gDVQMlA/gCzQKlAn8CWwI5AhkC+wHfAcQBqgGSAXwBZgFSAT8BLQEcAQwB/QDvAOIA1QDJAL4AAADAAEBCDwAAAAAAAAAAAP//AABTLoses4WD+wB1BehSC+sUg/sEdQXoAwXrCoP7AXUF6FgI6wBbw1AuobOFPQAAdQXo5wvrFD0EAHUF6AQF6wo9AQB1BehMCOsAWMNRLosOs4WD+QB1BejJC+sUg/kEdQXo7ATrCoP5AXUF6C4I6wBZw1Euiw6zhYP5AHUF6KsL6xSD+QR1BejPBOsKg/kBdQXoEAjrAFnDUFNRUlYeLosOoYWLwYP5AHQCeTwu/w6DhHQlLsU2hYSc+lBTUVJWVwZV6JAB6Dn/XQdfXlpZW1idLosOoYXrEPoeuDsQjti4AADohvcf60a7zIEui0dALotXQoP6/3UGQ0NDQ+vtSD0AAHQIPf//dRdK6xSD+gB1Dy7FN+hxAC6JN4zeLol3Ai6JR0AuiVdCQ0NDQ+K9H15aWVtYy1BTUVIuoaOFuUIP9+Euiw6lhS6LHqeFis2K6/fxi8geuDsQjtiLwboAALlMhrsAAOjd9h9aWVtYw1NSHgbowP8HH1pbw4rg6K8CrIrg6KkC4vjDUayogHUDrOtRMu088HwQdAk893UP6If+60Dop/7rO+jI/us2rTxRdQ6sLqKnha2G4C6jpYXrIzwvdQ2tuP//i9Au/w6hhescPCB1CKwuiIeAAOsGiswD8esA6PgAdQLroOiDAlnDLosOoYW7zIEuxTfo4QB1A+iH/y6JR0AuiVdCLok3jNguiUcCQ0NDQ+Lew1WL7AYeVleLRgwuo4OExHYIiTaAVYzGiTaCVcV2BC6JNoWEjNguo4eE6BAAI8B0Bugi/7gBAF9eHwddw4E8TVR1f5CQkEZGgTxoZHV0kJCQRkaDPAB1apCQkEZGgTwABnVfRkaBPAACdFdGRq2G4D0AAHRNPRAAf0guo6GFrYbg9sSAdTwuo6OFLosOoYW7zIHowgGtPU1UdSetPXJrdSGtPQAAdRutLok3Q0MujB9DQ4bgA/ByCuLY6Bn/uP//6wIzwMMzwIvQrKiAdESK4KyogHUJJX9/0ODR6Os0kqyogHUWhtSG8oHif3/R4NDg0OrR2NDq0djrGIrgrJKB4n9/0OLR6tHg0ODQ6tHY0OrR2FOL2AvaW8O5//+helUjwHUquAEAo3pVM8mjhFVR6HcBWbgEAHQCC8hR6CACWbgBAHQCC8guo7OFo4ZVi8EjwMO5//+helU9AQB1LrgCAKN6VVWL7ItGBF25AADR6HIKQYP5EHX2M8DrFbgAANHQ0+Auo7OFo4ZVi8iLwSPAw7sBALhkALoAALk2keiO9DPALqLugy6j74Pr1x64OxCO2KGGVT0AgLgAAHQNuAAA6JH0H+gj/Ok4/h8jwMMuoaGFI8B1Bi6hg4QjwMMeuDsQjti4AADoa/Qf6P37wx64OxCO2LgBAKOEVbgAAOhU9B/o5vvDHrg7EI7YoYRVI8B0A+gJ/R/DUTPJujED7KhA4Pt1BkqKxO5Zwx64OxCO2IkOfFUfLokOoYXr7LSZ6wK0iVWL7FLozv+KZgToyP+KZgbowv9aXcNQU4vGg+YP0ejR6NHo0eiM2wPDjthbWMNRuQQA4v5Zw1EuxwahhQAAuRAAt7Cze+gQALN56AsAswfoBgD+x+LtWcOK5+h4/4rj6HP/tH/obv/DUFNRUoM+fFUAdEa5iBO6MQPsqEDg+3UzsP/uuwMAuYgTujED7KiA4Pt1HbowA+w8/nUVuYgTujED7KhA4Pt1C7oxA7A/7usJS3XTxwZ8VQAAWllbWaF8VSPAw1JRU1C7CZC5fwCK5wLj6AH/iuHo/P4y5Oj3/uLt/st15lhbWVrDUFGsisis/snoLfxZWMNRigxG6CP8WcNRqA91BS4Kh4AAuQIAiuCA5PCA/MB1AUnoBvxZw7gBAKN+VeiDBHQF6LMD6wbHBn5VAAChflUjwMO4AQDoHwC4AgHoGQC4AwLoEwC4BAPoDQC4BQToBwC4BgXoAQDDUFdWUR5TBorYMv/oCAAHWx9ZXl9Yw1ZXHga+OxCO3sU2gFWLfAwD/gPbA9uLywPbA9kD+4sdA9uL+wPbA9sD2wPbK9+LfBAD/gP7M9seV4rEXx8y5OgFAAcfX17DUFNRUlC0CLAA6DMEWIoxIvZ0A+moAYrQgMLAinEEgOYH0OaKYQ6A5AGA9AEK9FCK4orG6AkEWDLkHle5OxCO2b+TVQP4igVfH4rQgMJAinEKgOY/imEC0OzQ7IDkwAr0UIriisbo1wNYitCAwmCKcQWA5g/Q5tDm0ObQ5ophCIDkDwr0UIriisboswNYitCAwoCKcQaA5g/Q5tDm0ObQ5ophCYDkDwr0UIriisbojwNYitCAwiCKcQOA5g+KYQsi5HQDgM6AimEMIuR0A4DOQIphByLkdAOAziCKYQ0i5HQDgM4QUIriisboUwNYitCAwkOKcReA5j+KYQ/Q7NDsgOTACvRQiuKKxugzA1iK0IDCY4pxEoDmD9Dm0ObQ5tDmimEVgOQPCvRQiuKKxugPA1iK0IDCg4pxE4DmD9Dm0ObQ5tDmimEWgOQPCvRQiuKKxujrAliK0IDCI4pxEIDmD4phGCLkdAOAzoCKYRki5HQDgM5AimEUIuR0A4DOIIphGiLkdAOAzhBQiuKKxuivAliK0IDC4IpxHIDmA1CK4orG6JsCWIrQgMLjinEdgOYDUIriisbohwJYWllbWMOwAYrQgMJAinEKgOY/imEC0OzQ7IDkwAr0UIriisboYAJYitCAwmCKcQWA5g/Q5tDm0ObQ5ophCIDkDwr0UIriisboPAJYitCAwoCKcQaA5g/Q5tDm0ObQ5ophCYDkDwr0UIriisboGAJYitCAwiCKcQOA5g+KYQsi5HQDgM6AimEMIuR0A4DOQIphByLkdAOAziCKYQ0i5HQDgM4QUIriisbo3AFY6VL/ULsBAFMzwFBQUOghAlhYWFtDg/sJfu1Yw1CstAAD8FjDUKy0AAPwWMNTUagPdQUuCoeAAIrggOQPgPwIfgLrFIrggOTwgPzAdBWA/JB0IID8gHRERiTwPMB0AUZZW8PoAgDr+CQPiuCKBOjP/EbD6AIA6+hQU1FSVwYkDzLkUKxQrFAjwHQDuCAAUOigAYPECAdfWllbWMNQJA8EsIrgHlO7AACO27vMgALcgNcAigdbHyTf6CEBrKxY66BQULRAsP/oEwFYULRBsP/oCgFYULRCsP/oAQFYULRIsP/o+ABYULRJsP/o7wBYULRKsP/o5gBYULRQsP/o3QBYULRRsP/o1ABYULRSsP/oywBYULRDsP/owgBYULREsP/ouQBYULRFsP/osABYULRLsP/opwBYULRMsP/ongBYULRNsP/olQBYULRTsP/ojABYULRUsP/ogwBYULRVsP/oegBYuAAB6HMA/sSA/EB19rgAYOhmAP7EgPz2dfa4BgToWQC4AL3oUwBYw1BRUrhgBOhIALiABOhCAOiOAFC4/wLoOAC4IQToMgC5xwDoewDi++h2AFC4YAToIAC4gAToGgBYWrQAJOCA4uA8wHUHgPoAdQK0ASLkWllYw5z6UFIeU7sAAI7bu8yAAtyA1wCIB1sfuogDhsTu7Ozs7OzsQobE7krs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7FpYncNSuogD7FrDVYvsU1FSHlC0CLAA6Jv/WFMeULs7EI7bi14KMv+Kl5NVgMJDiuIeU7sAAI7bu8yAAtyA1wCKB1sftCAqdgbQ7tDu0O7Q7oDmPyrmivSA5j8kwArwUlCK4orG6E3/WFpYH1u4OxCO2IteCL+0VYoJ/sm/FFaKATLki9gD27+cVYsBJf8DUIrgsKACRgqG4OgZ/1gfisQkA4DhB9Dh0OECwQJGBDLkUIrgsLACRgqGxOj4/lhaWVtdw1BTUbvMg7kPADLALogHQ+L6WVtYMsAuou6D5GEk/OZhwzPJu8yDLqHsg0A9AgByAjPALqPsg0C7c4QD2C6KD7vxgwLZgNcALooPMu27zIMD2C6KBzwKcwIywDLkA8AjwHQyBTAAA8G7iYQD2C6LBy47Bu+DdAVQ6CoAWC6j74MuoO6DIsB1DP7ALqLug+RhDAPmYcszwC6i7oMuo++D5GEk/OvtULC25kPoevhY5kLodPiKxOZC6G34w1CstAAD8FjDUKy0AAPwWMNQU4rggOTwgPzAdDyoD3UFLgqHgAC7zIOK4IDkDwLcgNcAJPA8kHQSPIB0BaysW1jDrKwywC6IB+v0rIrgrDwAdASKxOvv6+3oAgDr4SQPiuCKBFO7c4QC3IDXAC6IB1tGw1WL7B5WuAAAjti+cpKLXgS0Aegr+bgAAI7YvnKSikYGiASKRgiIRAGwAeg1/F4fXcMAAAAAAAAAAAAAV1ZVHga4AADNM6J0VjX//1C4BAC5AACL0c0zuAcAuQAAuoACzTO4CAC5AAC6yADNM1gHH11eX8NVi+xQU1FSVVdWHgagdFao/3QPuAMAzTOLTgTR4bgEAM0zBx9eX11aWVtYXcNVi+xQU1FSVVdWHgagdFao/3QNuAMAzTOLVgS4BADNMwcfXl9dWllbWF3DV1ZVHgagdFao/3QJuAMAzTPR+YvBBx9dXl/DV1ZVHgagdFao/3QHuAMAzTOLwgcfXV5fw1dWVR4GoHRWqP90CrgDAM0zi8MlAwAHH11eX8NVi+xXi0YGjsCLfgSLXgqLRgiaAADaDF9dw1WL7FeLRgaOwIt+BIteCotGCJpFANoMX13DVYvsV4tGBo7Ai34EmokA2gxfXcNVi+yLRgRdmgAA5QzDmh8A5QzDAFWL7ItWBotGBF2aKBC5CsNVi+yLVgaLRgRdmm4SuQrDVYvsmu0s7Axdw1WL7ItWBotGBF2aFS3sDMNVi+yaQy3sDF3DVYvsmm0t7Axdw1WL7JqoLewMXcNVi+ya0i3sDF3DVYvsmu0t7Axdw5o3MewMw1WL7Jq3MewMXcPrAOsAw6E+aD0AAMODPj5oAHUK5GEMA+jm/+Zhw+RhJPzo3P/mYcM9/wB0By45BmyUcgQuo2yUw/8AoT5oPQAAuP8AdAi4AADo3P/rBujX/+jK/8NVi+xXVlUeBpz6i0YE6MP/uP//cl2LRgYuo4iXi0YILqOKl4tGCi6jlpcuo4yXi0YMLqOOl4tGDi6jkJeLRhAuo5KXLqOYl4tGEi6jlJcuxgaalw+5MZYuiQ6hl7oAAC6JFp+Xi0YOuwIA6ATp6Ej/M8CdBx9dXl9dw1WL7FdWVR4GnPqLRgToSf+4//9yTotGBi6jiJeLRgguo4qXi0YKi0YKLqOQl4tGDC6jkpcuo5iXi0YOLqOUly7GBpqXD7nEli6JDqGXugAALokWn5eLRgq7AgDomejo3f4zwJ0HH11eX13DVYvsV1ZVHgac+otGBOje/rj//3IrLsYGmpcPi0YGLqOKl7m1lS6JDqGXugAALokWn5eLRgi7AgDoUejolf4zwJ0HH11eX13DUFNRUlVXVh4G6Hj+dWQu/gaaly72BpqXEHQ/LjMGm5cFRSMuMwacly4zBp2XJW3bLqOblwVnRS4zBpyXLqOdlzPALqKal7C05kPoMv4uoYqX5kLoKf6GxOZCLqGbl9HALqObl+RhgOQCgMwBJP0KxOZhBx9eX11aWVtYy1BTUVJVV1YeBuj8/XV7kJCQLv8OmJd1KS6hkpcuo5iXLqGQly4DBpSXLqOQly6LDqGXLosWn5cuoZCXuwIA6IfnLv8Olpd1QS7/DoiXdRG4/wDo1f24AgDok+fowv3rKS6hjJcuo5aXLqGKly4DBo6XLqOKl7C25kPoh/0uoYqX5kLofv2GxOZCBx9eX11aWVtYy1BTUVJVV1YeBuhp/XQD6akALv4Gmpcu9gaalxB0PC4zBpuXBUUjLjMGnJcuMwadly6jm5cFZ0UuMwacly6jnZczwC6impewtOZD6CP9LqGKl+ZC6Br9hsTmQi7/DpiXdUEu/w6Il3URuP8A6Cn9uAIA6Ofm6Bb960EuoZKXLqOYly6hkJcuAwaUly6jkJcuiw6hly6LFp+XLqGQl7sCAOiT5i6hm5fRwC6jm5fkYYDkAoDMAST9CsTmYQcfXl9dWllbWMsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmgAALBDD6A7jy+hQ48tVi+yKRgRdmrASuQrDmtUSuQrDVYvsi0YEi1YGXZoRE7kKw1WL7ItWBotGBF2aKxO5CsOaVRO5CsOaaBO5CsOaexO5CsNVi+yKRgRdmrwTuQrDVYvsi1YGi0YEXZrsE7kKw1WL7IteBF2aCRS5CsNVi+yLRgSLXgaLTgiLVgpdmiIUuQrDVYvsi0YEi1YGXZpBFLkKw1WL7IpGBF2aWBS5CsNVi+yLVgaLRgRdmmsUuQrDmgAANhDDVYvsgz6CaSB1BbgBAOsTix6CadHji0YEiYe+of8GgmkzwF3DVYvsVot2BAv2fAWD/hR8CbgGAFDo0wjrD4ve0ePHhxxr//9W6AAHWV5dw8NVi+zrCosegmnR4/+XvqGhgmn/DoJpC8B16/92BOgcaFldw1WL7FZXi0YGQIvwKzZ5AIvGBT8AsQbT6IvwOzaKaXUSi0YGi1YEiRaHAKOJALgBAOtGsQbT5os+jQCLxgMGeQA7x3YIi8crBnkAi/BW/zZ5AOhRC1lZi/iD//91C4vGsQbT6KOKaeu4oXkAA8fHBosAAACjjQAzwF9eXcIEAFWL7IsOhQCLHoMAi1YGi0YE6LwQciCLDo0Aix6LAItWBotGBOipEHcN/3YG/3YE6FD/C8B1Bbj//+sCM8Bdw1WL7IPsCIsWiQChhwCLTgaLXgTo5Q+JRvyJVv6LDoUAix6DAItG/OhnEHITiw6NAIseiwCLVv6LRvzoVBB2CLr//7j//+sioYkAixaHAIlW+IlG+v92/v92/Ojm/gvAdQLr3ItW+otG+IvlXcNVi+xWi0YEC0YGdQbovQDptQDEXgQmi0cSO0YEdAa4///ppQDEXgQmgz8AfE4m90cCCAB1FSaLRw6LVgSDwgU7RgZ1NSY5Vwx1L8ReBCbHBwAAJotHDotWBIPCBTtGBnUYJjlXDHUSJotHCiaLVwgmiVcMJolHDutO60zEXgQmi0cGJgMHQIvwJosHK8YmiQdWJotHCiaLVwgmiVcMJolHDlBSJopHBJhQ6EsDg8QIO8Z0FMReBCb3RwIAAnUJJoFPAhAA6Vf/M8BeXcNVi+yD7ARWVzP/vhQAx0b8jGmMXv7rG8Re/Cb3RwIDAHQM/3b+/3b86An/WVlHg0b8FIvGTgvAdd6Lx19ei+Vdw1WL7IPsBFZXxF4EJoM/AH0KJotHBiYDB0DrC8ReBCaLB5kzwivCi/CL+MReBCb3RwJAAHQC60PEXgQmi0cOJotXDIlW/IlG/iaDPwB9JesN/078xF78JoA/CnUBR4vGTgvAdezrFMRe/P9G/CaAPwp1AUeLxk4LwHXsi8dfXovlXcIEAFWL7P92Bv92BOhj/llZC8B0Bbj//+tjg34MAXUZxF4EJoM/AH4Q/3YG/3YE6E3/mSlGCBlWCsReBCaBZwJf/ibHBwAAJotHCiaLVwgmiVcMJolHDv92DP92Cv92CCaKRwSYUOjIBYPECIP6/3UKPf//dQW4///rAjPAXcNVi+yD7ATEXgQmikcEmFDowAFZiUb8iVb+xF4EJoM/AH0S/3YG/3YE6NX+mQFG/BFW/usQ/3YG/3YE6MP+mSlG/BlW/otW/otG/IvlXcOgkGmYUOhLBVkLwHUGgSaOaf/9uAACUPcGjmkAAnQFuAEA6wIzwFAzwDPSUFIeuIxpUOg8AIPEDKCkaZhQ6BMFWQvAdQaBJqJp//24AAJQ9waiaQACdAW4AgDrAjPAUDPAM9JQUh64oGlQ6AQAg8QMw1WL7FZXi34Mi3YOxF4EJotHEjtGBHULg/8CfwaB/v9/dga4///p5wCDPkprAHUPgX4EoGl1CMcGSmsBAOsUgz5IawB1DYF+BIxpdQbHBkhrAQDEXgQmgz8AdBa4AQBQM8Az0lBS/3YG/3YE6Ff+g8QKxF4EJvdHAgQAdA0m/3cKJv93COjUCFlZxF4EJoFnAvP/JsdHBgAAi0YGi1YEg8IFJolXCCaJRwomiVcMJolHDoP/AnRXC/Z2U8cGhGkln4tGCAtGCnUdVuh1CVmJRgiJVgoLwnQLxF4EJoFPAgQA6wPpPf/EXgSLRgqLVggmiVcMJolHDiaJVwgmiUcKJol3BoP/AXUGJoFPAggAM8BfXl3DVYvsuAEAUDPAM9JQUv92BOjNA4PECF3DVYvsgeyOAFZXi0YKQD0CAHMFM8DpCgGLXgTR4/eHHGsAgHQV/3YK/3YI/3YG/3YE6G0Gg8QI6egAi14E0eOBpxxr//2LRgiLVgaJVvSJRvaLRgqJRvrreP9O+sRe9P9G9CaKB4hG+TwKdQrEXvwmxgcN/0b8xF78ikb5JogH/0b8jYZy/4tW/DPbK9CD2wAL23xHdQaB+oAAcj+NhnL/i1b8M9sr0IPbAIvyVhZQ/3YE6OwFg8QIi/g7xnQTC/9zBbj//+tWi0YKK0b660rrTI2Gcv+JRvyMVv6DfvoAdAPpdf+NhnL/i1b8M9sr0IPbAIvyi8ILwHYlVhaNhnL/UP92BOiaBYPECIv4O8Z0Dwv/cwLrrItGCgPHK8brA4tGCl9ei+Vdw1WL7IPsBFa+BADHRvyMaYxe/usbxF78JvdHAgMAdAv/dv7/dvzouvpZWU6DRvwUC/Z14V6L5V3DVYvsimYEikYIi1YGzSFdw1WL7B60O8VWBM0hH3IEM8DrBFDo9QFdw7QZzSGYw1WL7LQOilYEzSGYXcNVi+wei04KtEOKRgjFVgTNIR9yA5HrBFDoxQFdw1WL7LQ+i14EzSFyDNHjx4cca///M8DrBFDopwFdw1WL7B60L80hBlO0GsVWCM0htE6LTgzFVgTNIZxZk7QaWh/NIVGdH3IEM8DrBFPodAFdw1WL7B60L80hBlO0GsVWBM0htE/NIZxZk7QaWh/NIVGdH3IEM8DrBFPoRwFdw1WL7IPsBLgBQoteBDPJM9LNIXIkUlC4AkIzyTPSzSGJRvyJVv5aWXIPuABCzSFyCItW/otG/OsFUOgJAZmL5V3DVYvsVh60R4pWBMV2Bs0hH3IEM8DrBFDo6gBeXcNVi+y0NYpGBM0hk4zCXcNVi+y0JYpGBB7FVgbNIR9dw1BTUVIGHlZXVb07EI7di+yJJgCi/3YE/3YA/3YQi0YCJf8AUP8W/qGDxAiJRhBdX14fB1pZW1jPVYvsi0YEo/6hDrixoFC4JABQ6KL/g8QGXcNVi+xWV4tGBIsmAKJdX14fB1pZW0REz19eXcNVi+xWVzPAUFC4VABQ6C/+g8QGi0YEoQCiBRoAi+CL6IBOFAFbWVpeX10fB89fXl3DVYvsHrREikYGi14Ei04MxVYIzSEfcgyDfgYAdQSLwusG6wRQ6AIAXcNVi+xWi3YEC/Z8FYP+WH4DvlcAiTZOa4qEUGuYi/DrEYvG99iL8IP+I3/lxwZOa///iTZ9ALj//15dwgIAVYvsuABEi14EzSGSJYAAXcNVi+yLXgTR44GnHGv//bRCikYKi14Ei04Ii1YGzSFyAusFUOiM/5ldw1WL7B6LTgS0PMVWBs0hH3IC6wRQ6HL/XcIGAFWL7IteBCvJK9K0QM0hXcICAFWL7IPsBFZXi3YI98YAwHUMoURrJQDAi9YL0Ivy98YAAXUD6YQAoUZrIUYKi0YKqYABdQe4AQBQ6CH/M8BQ/3YG/3YE6DX9g8QGiUb+Pf//dSz3RgqAAHQEM8DrA7gBAIlG/vfG8AB0LP92Bv92BDPAUOhe/4v4C8B9E+m+APfGAAR0JrhQAFDo0f7psABX6Af9Wesa/3YG/3YE/3b+6DL/i/gLwH106ZIAx0b+AABW/3YG/3YE6IsAg8QGi/gLwHxZM8BQV+hq/llZiUb8qYAAdCGBzgAg98YAgHQhJf8ADSAAM9JSULgBAFBX6ET+g8QI6wr3xgACdARX6PD+g37+AHQX98bwAHQRuAEAUFD/dgb/dgToZPyDxAgL/3wd98YAA3QFuAAQ6wIzwIvWgeL/+AvQi9/R44mXHGuLx19ei+Vdw1WL7ExMsAGLTgj3wQIAdQqwAvfBBAB1ArAAHsVWBLHwIk4ICsG0Pc0hH3IaiUb+i17+0eOLRggl//gNAICJhxxri0b+6wRQ6M79i+Vdw1WL7IPsBFZXi0YKQD0CAHINi14E0eP3hxxrAAJ0BTPA6Y8A/3YK/3YI/3YG/3YE6IYAg8QIiUb+QD0CAHINi14E0eP3hxxrAIB0BYtG/utii07+xHYGi/6L3vwmrDwadC48DXQFquLz6x3i7wZTuAEAUI1G/RZQ/3YE6DsAg8QIWwf8ikb9qjv7dQLrlusgU7gBAFD32RvAUFH/dgToeP2DxAiLXgTR44GPHGsAAlsr+5dfXovlXcNVi+wetD+LXgSLTgrFVgbNIR9yAusEUOj4/F3DVYvstEqLXgaORgTNIXIFuP//6wZTUOjd/Fhdw1WL7IteBNHj94ccawAIdBO4AgBQM8Az0lBS/3YE6Aj9g8QIHrRAi14Ei04KxVYGzSEfcg9Qi14E0eOBjxxrABBY6wRQ6JP8XcMAAAAAAAAAAAAAAAAAAAAAAAAAAAAuOxbwpHQ3jtqOHgIAgz4CAAB0By6MHvKk6ziM2C47BvCkdBWhCAAuo/KkHjPAUOihAC6OHvak6yMuixbwpC7HBvCkAAAuxwbypAAALscG9KQAAC6OHvakUjPAUOgA9FhYw47aHo4GAgDHBgIAAACMBggALjsW8KR0LiaDPgIAAHUmoQAAWwYmAQYAAIzBA9COwiaDPgIAAHUHJokOCADrCiaJDgIA6wPoUQAHjMAmAwYAAI7Ygz4CAAB0AcOhAAAmAQYAAIzAjNsDHgAAjsMmowIAjNs7HgYAdBmOBgYAjh4EAIwGBgAmjB4EAC6MHvSkjtvDLscG9KQAAMMuofSkC8B0IIzT+o7QNo4GBgA2jB4GAIwWBACO0/smjB4EAIwGBgDDLowe9KSMHgQAjB4GAMNVi+xWVy6MHvaki1YGC9J0Dy47FvKkdQXos/7rA+gQ/y6OHvakX15dw1Aujh72pDPAUFDoNvNbWyUPAHQTuhAAK9AzwC6OHvakUFLoHvNbW1hQM9uK3LEE0+vT4C6OHvakU1DoBvNbW1s9//90GC6JFvCkLokW8qSO2okeAACJFgIAuAQAwzPAmcNQM9uK3LEE0+vT4C6OHvakU1DozfJbW1s9//90GC6LDvKkLokW8qSO2okeAACJDgIAuAQAwzPAmcOL2ikGAAADFgAAjtqjAACJHgIAi9oDHgAAjtuJFgIAuAQAw1WL7DPSi0YE6wlVi+yLVgaLRgRWVy6MHvaki8gLynReBRMAg9IAckH3wvD/dTuxBNPo0+IK4i6LFvCkC9J0IC6LFvSkC9J0Eovajto5BgAAcxyLFgYAO9N18OhH/+sf6OH+6xrodv/rFTPAmesQd/ToSP6LHggAiR4CALgEAC6OHvakX15dw1Muizb4pFYuizb6pFboc/9bWwvSdQJbwx+OwgYeU4sWAAD8Sr8EAIv3uQYA86UL0nQ3jMBAjsCM2ECO2DP/i/eLyoH5ABB2A7kAENHh0eHR4fOlgeoAEHYQjMAFABCOwIzYBQAQjtjr0y6OHvak6CL+WlpauAQAwy47HvKkdEOL+wP4jseL8SvwJok2AAAmiR4CAAZQjsMmowAAi9MD0Y7CJoM+AgAAdAcmiT4CAOsFJok+CACL8+jZ/Vpai9a4BADDU47DJqMAAAPYUzPAUOju8FpaWrgEAMNVi+wz0usGVYvsi1YKi0YIi14GVlcujB72pC6JFvikLqP6pAvbdDKLyAvKdDMFEwCD0gCxBNPo0+IK4o7DJosOAAA7yHIOdweL07gEAOsb6E3/6xbo0P7rEVJQ6Ez+6whTUOhV/TPAmV9fLo4e9qRfXl3DWQ5RM8nrFlkOUbkBAOsOWQ5RuQIA6wZZDlG5AwBVVleL7Iv5i0YKi1YMi14Oi04QC8l1CAvSdGkL23Rl98cBAHUcC9J5Cvfa99iD2gCDzwwLyXkK99n324PZAIP3BIvpuSAAVzP/M/bR4NHS0dbR1zv9cgt3BDvzcgUr8xv9QOLnW/fDAgB0BovGi9fR6/fDBAB0B/fa99iD2gBfXl3KCAD38/fHAgB0AZIz0uvtBw4GC8l9DPfT99GDwwGD0QDrLwPDcwSBwgAQiumxBNLlAvWK6NPoA9CKxSUPAMsHDgYLyX0M99P30YPDAYPRAOvRK8NzBIHqABCK+bEE0ucy2yvTiujT6APQisUlDwDLBw4GVYvsVlcexXYGxH4K/NHp86UTyfOkH19eXcoIAFaWkoXAdAL34+MFkffmA8GW9+MD1l7DUYrosQTT6APQisWK49PrWQPLitwlDwCD4w870XUCO8PDAACPBrBrjwaya48GtGsujB5Mqok2tmuJPrhr/I4GeQC+gAAy5CasQIzFh9aTizZzAEZGuQEAgD57AANyEY4GdQCL/rF/MsDyruNugPF/UIvBA8NAJf7/i/wr+HJci+cGHxYHUUnzpDLAqo7dh/KH2YvDi9BD6BkAdwdyQOgSAHf5PCB0CDwNdAQ8CXXoMsDr5AvAdAdCqgrAdQFDhuAywPnjFaxJLCJ0DwQiPFx1B4A8InUCrEkL9sPp4lZZA8oujh5MqokeqmtDA9sD24v0i+wr63Lki+WJLqxrjBaua+MRiXYAjFYCg8UENqwKwOD6dO0zwIlGAIlGAi6OHkyqiza2a4s+uGv/NrRr/zaya6Gqa6NpAKGua6NtAKGsa6NrAP8msGtTdGFjayBvdmVyZmxvdyENCiQOH7pxq7QJzSHphlUAvuZN6EcGuQIA6BsEJotdHFOL3wboFgUfi/NbHrg7EI7Y0eOLh8xNH//Qw7sBAbrEA4rnsALv6JYF6AsA/sPQ54D/CH8s6+dXHr07EI7diy4pVIsWM1SLDjFUivEfOtV0Dv7K0enzq4rOK/kD/evuX8PDuwEBusQDiuewAu/oTwXrC/7D0OeA/wh/OuvoVx69OxCO3YsuKVSLFjNUiw4xVIrxH4vw99Y61XQX/srR6SYhNSYJBYPHAuL1is4r+QP96+Vf673DuwEBusQDiuewAu/o+wT30OgLAP7D0OeA/wh/MuvlVx69OxCO3YsuKVSLFjNUiw4xVIrxHzrVdBT+ytHpJiEFg8cC4viKziv5A/3r6F/Dwy7GBmYBIesOLsYGZgEJ6wYuxgZmATG7AQG6xAOK57AC7+iWBOgLAP7D0OeA/wh/MuvnVx69OxCO3YsuKVSLFjNUiw4xVIrxHzrVdBT+ytHpJiEFg8cC4viKziv5A/3r6F/Dw8NXVlUeBvy7OxCO247Ci/gmx0UYFAAmx0UaGQDGBh9UAsYGIFQBix4dVNHj/5faTQcfXV5fy8PDwwAAAAAAAAAAAAAAAAAAAMtXVlUeBoP7AHQQg/sBfwu4OxCO2EvGhxBTAAcfXV5fy1dWVR4GvTsQjt2OxYsuHVTR5T7/ljVUBx9dXl/Ly1dWVR4Gix4dVNHj/6ddVLgNAM0Q6wAHH11eX8tXVlUeBrs7EI7biRYTU6MRUwcfXV5fy1dWVR4GgPkAdQLrbYD5An9ouDsQjtiOwFG/EFO5AQD8MsDzqlm+FVQy7f7Jix4dVNHj/6dpVMdEAgCgxwQAAIM+HVQFdQ/HRAYApMdEBAAA6EkD6yTHRAYAosdEBAAA6xiA+QF8E1BSmgAA1QyJVAKJBIPGBFpY4u0HH11eX8tXVlUeBrg7EI7YjsCLLh1U0eU+/5ZBVAcfXV5fy1dWVR4GuDsQjti4AgDNEL6cUjL/ugEBtALNELQJi9bNIb60Ur+LVLcAuQYAuiEKgD0BdQ60As0QUrQJi9bNIVr+xoPGD0fi57A8mvp7AAB1C7A9mvp7AAB1EOvsxwYdVAEAxwYOU0AA6xPHBh1UAgDHBg5TQADrBZr+ewAABx9dXl/LV1ZVHgaD+wB0I4P7AX8euDsQjtgzyYaPD1O+FVSLLh1U0eU+/6Z1VOhFA+sABx9dXl/LV1ZVHga7OxCO247Ci/i+FVMmix2D+wB1A+mBAIP7AX98kJCQS4vDugABUtHqdATR4Ov4WgPwM8CKhxBT0eDR4NHgA/D+hxBTix4dVNHj/6eBVLsCAOsAJotFAlPR63QE0eDr+FuJBCaLRQZT0et0BNHg6/hbiUQEuwgAJotFBFPR63QE0eDr+FuJRAImi0UIU9HrdATR4Ov4W4lEBgcfXV5fyyaLRQZR0el0BNHg6/hZJvdFHAACdAdAJoFlHP/9oyNUuBQAgD4fVAF0BCaLRQpR0el0BNHg6/hZoytUJotFFFHR6XQE0eDr+Fkm90UcAAR0B0AmgWUc//ujIVS4FACAPiBUAXQEJotFGFHR6XQE0eDr+FmjKVQmi0UeUdHpdATR4Ov4WaMxVLkIACaLRQhR0el0BNHg6/hZJvdFHAABdAomA0UmJoFlHP4Aoy9UuBkAgD4fVAF0BCaLRQxR0el0BNHg6/hZoydUJotFFlHR6XQE0eDr+FmjLVS4GQCAPiBUAXQEJotFGlHR6XQE0eDr+FmjJVQmi0UgUdHpdATR4Ov4WaMzVMNQU1FSVYvfgD4fVAJ0O6EvVPcmK1QDBiNUi/CAPh9UAXUOJosv0eXR5T7FhhVU6wQmxUcCA/AGjNiOwIv+U5qJANoMW47ai/AHHrg7EI7YoS1U9yYpVAMGIVSL+IA+IFQBdRAmi28O0eXR5T7EhhVUH+sQJsRHEB8D+JqJANoMjsKL+F1aWVtYw4vT0eLR4ovC0eDR4NHgA9DR4APCK8PDw8MzwIpUIoTXdAKwAYpUI4TXdAIMAopUJITXdAIMBIpUJYTXdAIMCIrQ0OLQ4tDi0OIKworgw8PDvxFTxD2L8I7a6KT/A/iDxyODxiO5CADzpcO/EVPEPYvwjtroiv8D+IPHM4PGMx64OxCO2IM+HVQFdQODxzAfuRgA86XDw8O6zgO5BwCt7+L8usQDiwTvw8PDw8O+EVPENOhM/wPwg8Yji9a4AhDNEMO+EVPENOg3/wPwg8YzusgDsADuQrkIACaKBO4mikQB7iaKRALug8YD4u1KsBDuQrkIACaKBO4mikQB7iaKRALug8YD4u3Dw8PDw/q61AOwDO5C7LQgMsTu+9Hj0eOLRAKHQAKJRALDw8PDAIBAwCCgYOAQkFDQMLBw8AiISMgoqGjoGJhY2Di4ePgEhETEJKRk5BSUVNQ0tHT0DIxMzCysbOwcnFzcPLx8/AKCQsIiomLiEpJS0jKycvIKikrKKqpq6hqaWto6unr6BoZGxiamZuYWllbWNrZ29g6OTs4urm7uHp5e3j6+fv4BgUHBIaFh4RGRUdExsXHxCYlJySmpaekZmVnZObl5+QWFRcUlpWXlFZVV1TW1dfUNjU3NLa1t7R2dXd09vX39A4NDwyOjY+MTk1PTM7Nz8wuLS8srq2vrG5tb2zu7e/sHh0fHJ6dn5xeXV9c3t3f3D49Pzy+vb+8fn1/fP79//wAAAAAAAAAAAAAAAAAAALkCAOgx/KErVPcmJ1SL6KEpVPcmJVSL2CaLRRzoHv1THovYuDsQjtjR44uHNlUfW//Qw/wzwOgvAP7EgPwDf2ED9QP7UFNSVwaM2I7Ai/6aiQDaDI7ai/AHX5qJANoMjsKL+FpbWOvOU1VWVx67OxCO24seK1SLLilUixYzVIsOMVSK8R+A+gB0Ev7K0enzpYrOK/Er+QPzA/3r6V9eXVvDwx64OxCO2KEpVC6jnAqhK1SLFjNUiw4xVIrxH+NugPoAdGn+ytHpUFKLFAP1A/sLFAP1A/sLFAP1A/sLFPfSJosFI8ILBCaJBSv1K/smiwUjwgsEJokFK/Ur+yaLBSPCCwQmiQUr9Sv7JosFI8ILBCaJBYPGAoPHAuKuWliKzivxK/kD8C4DPpwK65LDwy7GBnMJIesOLsYGcwkJ6wYuxgZzCTEzwOgNAP7EgPwDf04D9QP76/BQU1VWVx67OxCO24seK1SLLilUixYzVIsOMVSK8R/jIoD6AHQd/srR6YsEJiEFg8YCg8cC4vOKzivxK/kD8wP9695fXl1bWMPDw8PDw8PDw8PDw/wzwOsv/sSA/AN/YQP1A/tQU1JXBozYjsCL/pqJANoMjtqL8AdfmokA2gyOwov4WltY689TVVZXHrs7EI7bix4rVIsuKVSLFjNUiw4xVIrxHzrVdBL+ytHp86WKzivxK/kD8wP96+pfXl1b65jD/DPA6w3+xID8A39bA/UD++vxUFNVVlceuDsQjtiLHitUiy4pVIsWM1SLDjFUivEfOtV0LP7KrIrg9sQPdAOAzA/2xPB0A4DM8PbUJiAlJggFR+Liis4r8Sv5A/MD/evQX15dW1jrnsPDw8NXVlUeBvy7OxCO247Ci/jGBh9UAMYGIFQAix4dVNHj/5dEVQcfXV5fywAAAAC+alXop/u5AgDoe/mhK1T3JidUi+gmi10cU4vf6G76Wx64OxCO2NHji4dQVR//0MP8usQDsALusAG6xQPu6yHQ4DwIf00D9VBTVwaM2I7Ai/6aiQDaDI7ai/AHX1tY69lWVx67OxCO24seK1SLFjNUiw4xVIrxHzrVdBP+ytHp86WKzivxK/kD84PHKOvpX17rrcMuxwaBC5CQ6wcuxwaBC/fQusQDuAIA7x67OxCO24seK1SLFjNUiw4xVIrxH+MC6wPplgA61XUD6Y8A/srR6VKLBAP1CwQD9QsEA/ULBFaQkIrsiuC6zgOwCO8migW6xQOwCO6KJCaIJdDo7iv1iiQmiCXQ6O4r9YokJogl0OjuK/WkiuVeRrrOA7AI7yaKBbrFA7AI7ookJogl0OjuK/WKJCaIJdDo7iv1iiQmiCXQ6O4r9aT+yXWHWjLtis4r8Sv5A/ODxyjpav/DLsYGYwwh6w4uxgZjDAnrBi7GBmMMMbrOA7AE7rrEA7AC7rAAtAG6zwPuhsS6xQPuhuDoDAD+wNDkPAN/RAP16+VQVlceuDsQjtiLHitUixYzVIsOMVSK8R/jIjrVdB7+ytHpiwQmIQWDxgKDxwLi84rOK/Er+QPzg8co695fXljDw8PDw8PDw8PDw8P8usQDsALusAG6xQPu6yHQ4DwIf2ID9VBTVwaM2I7Ai/6aiQDaDI7ai/AHX1tY69lQVldVHrg7EI7Yiy4rVIsWM1SLDjFUivEfOtV0JP7KrIrgJA/Q7NDs0OzQ7AUAAKvi7YrOK/Er+Sv5A/WDx1Dr2F1fXljrmMP8usQDsALusAG6xQPu6wrQ4DwIf10D9evwUFZXVR64OxCO2IsuK1SLFjNUiw4xVIrxHzrVdDb+yqyK4CQP0OzQ7NDs0OwFAAA8AHQDJogFgPwAdAQmiGUBg8cC4tuKzivxK/kr+QP1g8dQ68ZdX15Y653Dw8PDV1ZVHga7OxCO247Ci/gmi20Og/0BfxTGBh9UAMYGIFQBix4dVNHj/5deVQcfXV5fywAAAAAAAAAAvqRW6Jf4uQIA6Gv2oSlU9yYlVIvoJotdHFOL3+he91seuDsQjtjR44uHilYf/9DD/LrOA7AE7rAAus8D7ugZAP7APAN/RQP9UFNSmokA2gyOwov4WltY6+BWVx67OxCO24seKVSLFjNUiw4xVIrxH4D6AHQT/srR6fOlis4r8Sv5g8YoA/vr6F9ew8MeuDsQjtiLHilUixYzVIsOMVSK8R/jb4D6AHRq/srR6VNSus4DV7gFCO+LHLgFAO+4BADvJosFI8MLBCaJBQP9uAQB7yaLBSPDCwQmiQUD/bgEAu8miwUjwwsEJokFA/24BAPvJosFI8MLBCaJBV+DxgKDxwLirlpbis4r8Sv5g8YoA/vrkcPDLsYGGQ8h6w4uxgYZDwnrBi7GBhkPMbrOA7AE7rAAus8D7ugKAP7APAN/RQP96+9QVlceuDsQjtiLHilUixYzVIsOMVSK8R/jI4D6AHQe/srR6YsEJiEFg8YCg8cC4vOKzivxK/mDxigD++vdX15Yw8PDw8PDw8PDw8PD/LrOA7AE7rAAus8D7usZ/sA8A39VA/1QU1KaiQDaDI7Ci/haW1jr4VBWV1UeuDsQjtiLLilUixYzVIsOMVSK8R861XQf/sqt0OTQ5NDk0OQKxKri8orOK/Er8Sv5g8ZQA/3r3V1fXljrpcP8us4DsATusAC6zwPu6xn+wDwDf2UD/VBTUpqJANoMjsKL+FpbWOvhUFZXVR64OxCO2IsuKVSLFjNUiw4xVIrxHzrVdC/+yqyK4PbED3QDgMwP9sTwdAOAzPD21CYgJSYIBUfi4orOK/Er8Sv5g8ZQA/3rzV1fXljrlcPDw8NXVlUeBrs7EI7bjsKL+CaLLYP9AX8UxgYfVAHGBiBUAIseHVTR4/+XmFYHH11eX8sAAAAAAAAAAL7OVujn9bkCAOi78yaLXRxTi9/ot/RbHrg7EI7Y0eOLh7RWH//Qw/y6xAO4Ag/vHrg7EI7YixYzVIsOMVSK8R+A+gB0Ev7K86SKzivxK/mDxiiDxyjr6cO6zgMeuDsQjtiLHjNUiw4xVIr5H+MC6wPpggC6zgOA+wB0ev7L0em4BQjviwSL6LgFAO+4BADvusQDuAIB7yaLBSPFCwQmiQW4AgLvus4DuAQB7yaLBSPFCwQmiQW4BALvusQDuAIE7yaLBSPFCwQmiQW4Agjvus4DuAQD7yaLBSPFCwQmiQWDxgKDxwLimIrPK/Er+YPGKIPHKOuBw8Muxga4ESHrDi7GBrgRCesGLsYGuBExus4DsATuusQDsALusAC0AbrPA+6GxLrFA+6G4OgKAP7A0OQ8A39A6+dQVlceuDsQjtiLFjNUiw4xVIrx4yUfgPoAdB/+ytHpiwQmIQWDxgKDxwLi84rOK/Er+YPGKIPHKOvcX15Yw8PDw8PDw8PDw8PD/LrEA7gCD+8euDsQjtiLFjNUiw4xVIrxHzrVdBL+yvOkis4r8Sv5g8ZQg8dQ6+rD/LrOA7AE7rAAtAG6zwPuhsS6xQPuhuDrCv7A0OQ8A3866+hQVlceuDsQjtiLFjNUiw4xVIrxHzrVdBv+yqw6xXQDJogFR+L1is4r8Sv5g8ZQg8dQ6+FfXljrvsPDw8NXVlUeBrs7EI7bjsKL+CaLHYP7AX8dJottDoP9AX8UxgYfVAHGBiBUAYs2HVTR5v+UwlYHH11eX8sAAAAAAAAAAABXVlUeBrs7EI7bv6Joi10CjsOLPegMAjPAigQmAkUEBx9dXl/LV1ZVHgb8uzsQjtu/omiLXQKOw4s9MtImigWKyIrwDui5/zrCdgSK0IrOisb+wCY6RQF26AcfXV5fisHLV1ZVHga7OxCO24seHVTR4/+XRmkHH11eX8tXVlUeBrs7EI7biRakaKOiaL+iaItdAo7Diz0mikUDBAKiPmkHH11eX8tXVlUeBrg7EI7YoUJpBx9dXl/LV1ZVHga4OxCO2KFEaQcfXV5fy1dWVR4GuDsQjti4CgC6CgAO6LIAuAAAuwAAuT8BuscADuiDALsAAA7oYwCwCA7orAC4DwC6AAAO6Fv/Bx9dXl/LV1ZVHgb8uzsQjtu/omiLXQKOw4s9JjoFchAmOkUBcwqLHh1U0eP/l1JpBx9dXl/LV1ZVHgb8jtqL8IoEPAB0Bw7ovP9G6/MHH11eX8tXVlUeBoP7AX8JuDsQjtiJHkBpBx9dXl/LV1ZVHga9OxCO3aM2aYkeOGmJDjppiRY8aQcfXV5fy1dWVR4GuzsQjtuJFkRpo0JpBx9dXl/LV1ZVHga7OxCO26I+aQcfXV5fy1dWVR4G/I7ai/AzyYoEPAB0CQ7oL/4DyEbr8YvBBx9dXl/Lvl5pxwS2aIxcAosuQGnR5dHlPgOGFVSJRAg+i4YXVIlECjPAisOJRAyKx4lEDorBiUQQisWJRBKIVBaM2ovGmhUt7AzDJioFMuTR4IzDjtuL94PGBgPwiwSG4APHi/DDw76maOgKAL6uaIvC6AIA6y7HBAAAx0QCAACpAQB0A8YE/6kCAHQExkQB/6kEAHQGxkQC/3QAqQgAdATGRAP/w8PDUFI7BjZpfCMCx3MC/sRIOwY6aX8WOxY4aXwQAtNzAv7GSjsWPGl/A/jrAflaWMNQU1FSVVdWHga+rmi/tmi5gADR6dHpiwSJBYtEAolFAoPHBOLxBx9eX11aWVtYw+jO/+g//yaKRQImil0DijyKzyYCfQSKVAGKdAKDxgMevTsQjt2Oxb2maL+2aB/DUFNRUlVXVh4GMu3R6dHp0enR4dHhA/mKz4DhBzLA4x/50Nji+7kEAID7AHQS/ssmIAVH4vq5BAAr+YPHCOvpBx9eX11aWVtYw8PohP+A+QB1A+nLAFDop/+wCPbmMuQD+DLt/snR6dHp0elBivFTgPoAdFn+yldSigSK2Ir4JotGACPDi9Ami0YCI8ML0Aryitb30oP6/3QcJotGACPDJiEVJgkFJotGAiPDJiFVAiYJRQLrCffTJiEdJiFdAkaDxwTitFqKzl+Dxwjrolu4OxCO2Foy9vfaAxZEaaFCaQA+QmlzBoEGQmkAAeiF/nIw0eLR4tHii8rR4dHhA8qL0IPiB9Ho0ejR6APB/s/Q79Dv0O/+x4rPiuuzArco6LH96H/vw8PDAAAAAAAAAAAAAAAAAFdWVR4GvTsQjt2JPhBOiT4MTok2Dk6JNgpOjseL/okeFE6JHipOoxJOoyhOi9qLwZoAANoMiRYMTqMKTujKCXMFuAMA6zJWHr07EI7dizYxToHm/39O0eaLrDdOH17/1bg7EI7YoTVOoypOoTNOoyhOgz4xTgB/xAcfXV5fy4sWJk6JFhROoSROoxJOgCYSTvA7FhROdQY7BhJOdAuDBhJOEHME/wYUTqEMTqMYTqEKTqMWTqEYTo7Aiz4WToseFE6hEk6aRQDaDCT+iRYITqMGTo7Ci/iLHhROoRJOmgAA2gyJFvxNo/pNoRBOjsCLPg5Oix4UTqESTpoAANoMiRb4TaP2TY7Ci/gz27gQAJoAANoMiRYATqP+TTsW/E1yFXUGOwb6TXYNxwYUTgAAxwYSTgIAw4sOFE6LHhJOofxNjsCLPvpNizb2TaH4TY7Yg+4CcwiDxhCM2EiO2IPvAnMIg8cQjMBIjsCLBCaJBYPrAnMEg8MQSYP5AHXTg/sAdc64OxCO2McGFE4AAMcGEk4BAMPDuDsQjtihEE6OwIs+Dk4z27gMAJoAANoMiRYITqMGTo7Ci/gmigWiIk7/BgZOoRBOjsCLPg5Oix4mTqEkTpoAANoMiRb4TaP2TYseKk6hKE6aAADaDIkW/E2j+k24OxCOwL+XTjPbuAAEmgAA2gyJFgROowJOjsKL+IkWL06jLU6LNvpNofxNjti5AASD7gFzCIPGEIzYSI7Yg+8BcwiDxxCMwEiOwIoEJogFjNiL6bs7EI7bixYITosOBk6O2DvCdQQ78XRVi83iwozduDsQjtih+E2jBE6LPvZNiT4CTo7Ajt2D7gFzCIPGEIzYSI7Yg+8BcwiDxxCMwEiOwIoEJogFjNi7OxCO24sWCE6LDgZOjtg7wnXMO/F1yLg7EI7YoRBOowBOoQ5Oo/5NjMCO2Iv3igSM3bs7EI7boixOjt2L64PGAVdVBozYjsCL/pqJANoMjtqL8AddX4zbjt2LFvhNiw72TY7bO9p1FTvxdRGO3bg7EKMETr6XTok2Ak6O2IzduzsQjtugIk6KJixOjt06xHQD6ekAigSO26IeTo7di+uDxgFXVQaM2I7Ai/6aiQDaDI7ai/AHXV+M247dixb4TYsO9k2O2zvadRU78XURjt24OxCjBE6+l06JNgJOjtiM3bs7EI7boCJOiiYeTo7dOsR1A+mIAIoEjtuiFk6O3Yvrg8YBV1UGjNiOwIv+mokA2gyO2ovwB11fjNuO3YsW+E2LDvZNjts72nUVO/F1EY7duDsQowROvpdOiTYCTo7YjN27OxCO26EATo7Aiz7+TaAeTiaIBYPHAZqJANoMjsKL+IkWAE6j/k076nUHO/d1A+mjAP4OFk6O3XXE6yuM3bg7EI7YoQBOjsCLPv5NoCxOJogFg8cBmokA2gyOwov4iRYATqP+TY7djN2MwjvqdQQ793RiuzsQjtuLFi9Oiw4tTo7dO+p0A+lk/jvxdAPpXf64OxCO2FcGoSZOjsCLPiROmokA2gyJFiZOoyROB1+hDk4r+HMIg8cQjMBIjsCLHhBOjMArwzsGJk51Czs+JE51BbgBAMPDw7g7EI7YoRBOjsCLPg5Oix4mTqEkTpoAANoMOxYMTnfedQY7BgpOd9ahEE6OwIs+Dk4z27gMAJoAANoMiRb4TaP2TY7Ci/gmiwWG4KMiToMG9k0CixYmTokWIE6hJE6jHk6AJh5O4DsWIE51DTsGHk50DYsWIE6hHk4FIABzAULR6tHY0erR2NHq0diJFiBOox5OoQxOoxhOiz4KTok+Fk6OwIseIE6hHk6aRQDaDIkWGE6jFk6AJhZO/osWGE6JFvxNoRZOo/pNiRYATqP+TY7Ci/ihIE6jGE6hHk6jFk6LNvZNofhNjtiLRAImiUUCiwQmiQWDxgRXVQaM2I7Ai/6aiQDaDI7ai/AHXV+M3YPHBJqJANoMjsKL+Lg7EI7YVwahGE6OwIs+Fk4z27gEAJpFANoMB1+JFhhOoxZOjt2D+gB1pD0AAHWfuDsQjtiJLvhNiTb2TYzAowBOiT7+TaEmTlChJE5QofxNUKH6TVChDE5QoQpOUKH8TaMMTqH6TaMKTqEqTqMmTqEoTqMkTug8+lijCk5YowxOWKP6TVij/E1YoyROWKMmToM+FE4AdQqDPhJOAnUD6UP+oSZOUKEkTlChKk5QoShOUKEMTlChCk5QoQhOjsCLPgZOix4qTqEoTpoAANoMiRYETqMCToseIE6hHk6aAADaDI7Ci/gz27gOAJoAANoMiRYITqMGTqEMTqMATos+Ck6JPv5NjsAz27gABJpFANoMiRYATqP+TaH8TaMMTqH6TaMKTqEQTqP4TaEOTqP2TccGHE4AAMcGGk4AAMcGFE4AAMcGEk4AAMcGGE4AAMcGFk4AAIMuFk4Bgz4WTgB5SYzdizYKTqEMTo7Yi1QChvKLBIbgUFKDxgRXVQaM2I7Ai/6aiQDaDI7ai/AHXV9aWIzZjt2JDgxOiTYKTscGFk4fAKMmTokWJE6LFiZOoSRO0eDR0okWJk6jJE5zA+lOAaH4TY7Aiz72TYs2Bk6hCE6O2IoEJogFg8YBV1UGjNiOwIv+mokA2gyO2ovwB11fjN2DxwGaiQDaDI7Ci/i4OxCO2IkuCE6JNgZOjMCj+E2JPvZNgwYSTgFzBP8GFE6LFgBOof5NOxb4TXUeOwb2TXUYuDsQo/hNuJdOo/ZNxwYcTgAAxwYaTgEAixYITqEGTjsWBE51CTsGAk51A+kMAYsWCE6hBk47FvhNdgPp5f51CTsG9k12A+na/oM+HE4AdAPp0P6DPhpOAHQD6cb+oQxOo/xNoQpOo/pNixYITosOBk6h/E2OwIs++k2LNgJOoQROjtiD7gFzCIPGEIzYSI7Yg+8BcwiDxxCMwEiOwIoEJogFjNg70HXbO85117g7EI7YiS4ETok2Ak6MwKP8TYk++k2h/E2jCE6h+k2jBk6hDE6jBE6hCk6jAk7pRv6h+E2OwIs+9k2gIk4miAWDxwGaiQDaDI7Ci/iMwKP4TYk+9k2DBhJOAXME/wYUTosWAE6h/k07FvhNdR47BvZNdRi4OxCj+E24l06j9k3HBhxOAADHBhpOAQDp9P5YowpOWKMMTlijKE5YoypOWKMkTlijJk6gIk4miAWDxwGaiQDaDI7Ci/iDBhJOAXME/wYUTosWAE6h/k07FvhNdR47BvZNdRi4OxCj+E24l06j9k3HBhxOAADHBhpOAQCLFiZOoSROOxYUTnerdQY7BhJOd6O4OxCj+E24l06j9k25AATR6dHpoQBOjsCLPv5Nizb2TaH4TY7Yi0QCJolFAosEJokFg8YEV1UGjNiOwIv+mokA2gyO2ovwB11fg8cEmokA2gyOwov44s64OxCO2LgBAMOhKk5QoShOUKEMTlChCk5QoRBOjsBQoQ5Oi/hQJosFhuAmi10ChvujJk6JHiROozVOiR4zTj0PAHdzkJCQPQ8AdQWD+/93ZiaLRQaG4CaLXQSG+6MgTokeHk4mi0UIhuCjMU6L8IPmP4P+HndAA/aLnFtOhvuD+wB8M4vwgeYAf3Urix4mTqEkTos2MU4z8zPwiR4mTqMkTqEgToseHk4z8zPwJotFCobgO/B0AflYow5OWKMQTlijCk5YowxOWKMoTlijKk7DV1ZVHgYFDwBzAULR6tHY0erR2NHq0djR6tHYi9i0SM0hcgUz0pLrBDPSM8AHH11eX8tXVlUeBo7AtEnNIQcfXV5fywAAAAAAAAAAAAAAAABXVlUeBr07EI7dUFMO6HkAjsKL+FtYi8jR69HY0evR2NHr0djR69HYi9mD4w8D34vTjMMDw5I9DwB+BCUPAEIHH11eX8tXVlUeBr07EI7dUFMO6DQAjsKL+FtYi8jR69HY0evR2NHr0djR69HYi9mD4w8r+3MEg8cQQIvXjMMr2IvDkgcfXV5fy1dWVR4Gi8eD5w/R6NHo0ejR6IzDA8OL0IvHBx9dXl/LAAAAAAAAAFdWVR4GuzsQjtujdlbHBnhWAADHBnpWAAAHH11eX8tXVlUeBrg7EI7Yix54VosuelaLxQUyJDPDMwZ2Vovo0cgrBnZWM8MFEhwzxdHIA8XR2IvYoXZWA8U1Ejgzw6N2VokeeFaJLnpWBx9dXl/LAACLTgbR6dHpg8EBg+H+i34E0e/R74Pn/ivPg8EB0emLXgiD4/6LVgor09HquAC4jsCwKPbji9m+4lYD9wP4A8AD8IvDA8C9UACLy/OlK/Ar+IHHABAD9YvL86Ur8Cv4ge8AEAP9A/VKdd/DjMAmix2G+9HL0cvRy9HLA8OLyyaLXQILy3QkhvuLy4PhD4HBAAiD4/DR69Hr0evR6wPDJolFAiaJDYPHBOvBw1WL7FdWVR4GxXYExH4Ii0T8i1z+9+PR6NHoi8hRJooFJoplAiaKXQQmin0GuQgAM/Yz0jPt0OfR1dDj0dXQ5NHV0ODR1YHF+WfR5tHm0eLR4oH9+WeLbgB0B4PlAwv16wWD5QML1eLLJopFASaKZQMmil0FJop9ByaJNffSJolVArkIADP2M9Iz7dDn0dXQ49HV0OTR1dDg0dWBxfln0ebR5tHi0eKB/flni24AdAeD5QML9esFg+UDC9XiyyaJdQT30iaJVQaDxwhZSXQD6Uv/Bx9dXl9dw1WL7FdWVR4GxXYExH4Ii96KRPyKZP725NHo0egD8IvIUYonQ7kIADLA0ORzAayq4vZZ4uwHH11eX13DVYvsV1ZVHgbEfgTFdgiL3yaKRfwmimX+9uTR6NHoA/iLyFFTiwSLXAKLTASLVAaITAGIZAKIbAOIXASIVAWIfAZbM8C5CADQ5KwKwHQEqoDMAeLzJognQ1nix4t2BCv+i8cz0gcfXV5fXcOLTgbR6dHpg8EBg+H+i34E0e/R74Pn/okOFWgrz4k+DWiJDg9oi34IiT4RaItOCokOF2grz4kOE2jDxF4EC9t0A+gBAMuJHglojMaJNgtoi8MLxnQD6AEAw8QeCWgGJsQ/jMALx3QGU77iVusG63yQ63GQJopFCqiAdPUmiwUmK0UUi9iD4wMD24geO2jR+NH4oyFoJotFAiYrRRajI2iLFhdooSNoO9B+N4sWFWihIWg70H4si9Ami0UQA9B4saENaDvQfhuhI2iL0CaLRRID0HgOoRFoO9B+B1NX6B8BX1vrjVsHg8ME6XL/B8Mm9kUKgHUD63eQoSFoJgNFEHj0OwYNaH7uoSNoJgNFEnheOwYRaH5YOwYhaH5SoRdoOwYjaH5JxgY8aADHBhloAAChDWgrBiFoeQf32KMZaDPAox9oI8B0BYAOPGgCoRVoKwYhaHgcJitFEHgWgA48aAGhH2j32CYDRRCjNWjrFTPAw4AOPGgBoR9o99gDBhVoKwYhaKM1aMcGG2gAAKERaCsGI2h5B/fYoxtoM8CjHWihF2grBiNoeBEmK0USeAuhHWj32CYDRRLrDaEdaPfYAwYXaCsGI2ijN2ihG2gDBhFohcB0BLNQ9uMDxgMGGWgDBg1oo+hWgz41aP90EHgO9wY3aP//dAZ4BA0BAMPpb//oI/+hHWiFwHQGJopdEPbjAwYfaKPmVqE3aKM3aKE1aCaLVRCJFjFouVAAiQ4zaKM1aMR9DIzAoydoK0UIAwbsVqMraAM+5laJPiVoiT4paIs26FaJNi1ojNijL2i+JWgGV+gDAF8Hw4tEEkguoxMyikQXLqIVMotcDItEECvYLokeETKLXA4r2C6JHg8yqQEAuyIFdQO7PgUuiR4eBakBALu6CHUDu9YILoketgiTg+P+LouHFzIuoz8FLouHTzIuo9cILv82EzIeVsRsBIpcForLMv8ui7+HMsV0CIvX99IuoBUyqAJ0DiaKVv+2/9PK99cj1/fXuAAA/+AmimYAsP/TyIvYI8cLwiAkRkX314b7I9+L0/fXuAAA/+Ami0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cmi0YAhsTTyIvYI8cLwobEIQRGRkVF99cj34vT99cuoBUyJAF1BAvXIDQu/w4TMngNLgMuETIuAzYPMul2/F4fLo8GEzKKTBbELMV0CLoAAC6gFTKoAnQOJopW/zL208r31yPX99e4AAD/4CaKZgAywNPIi9gjxwvCCCRGRffXhvsj34vT99e4AAD/4CaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31yaLRgCGxNPIi9gjxwvChsQJBEZGRUX31yPfi9P31y6gFTIkAXUCCDQu/w4TMngNLgMuETIuAzYPMul5/MNQuAMAzRBYitC0As0hzSDDjMAmix2G+9HL0cvRy9HLA8OLyyaLXQILy3QnhvuLy4PhD4HBAAiD4/DR69Hr0evR6wPDJolFAiaJDegGAIPHBOu+wx5XVlBRoR1ULqPtDSbFPYtN/obpiU3+I8l4BHQC6wPpTgGLRfyG4IlF/ItF+obgiUX6i0X4huCJRfiLRfSG4IlF9ItF9obEiUX2JMB10Yv3LqHtDT0AAHQD6dkAi0X80ejR6IvQI9J4tnS0ikQCimQBiEQBikQEiGQEiEQCikQGimQDiEQDikQFiGQFiEQGiwTQ4NHT0OTR09Dg0dPQ5NHT0ODR09Dk0dPQ4NHT0OTR09Dg0dPQ5NHT0ODR09Dk0dPQ4NHT0OTR09Dg0dPQ5NHThvuJHItEBNDg0dPQ5NHT0ODR09Dk0dPQ4NHT0OTR09Dg0dPQ5NHT0ODR09Dk0dPQ4NHT0OTR09Dg0dPQ5NHT0ODR09Dk0dOG+4lcBDPAiUQCiUQGg8YISnUE4gXrQek5/+kn/4tF/NHo0eiL0CPSeC50LIpEAopkAYhEAYpEBIhkBIhEAopEBopkA4hEA4pEBYhkBYhEBoPGCEp11uLFWVheXx/DAACLRgTR6NHo0egl/v+jDWiLVghC0erR6tHqg+L+iRYPaCvQiRYVaItGBqMRaItWCokWE2gr0IkWF2jDxF4EC9t0A+gBAMOJHglojMaJNgtoi8MLxnQD6AEAw8QeCWgGJsQ/jMALx3QDU+sG6aMA6ZgAJopFCqiAdPUmiwUm9kUKIHQQJotdENHj0eMrwyYDRRTrBCYrRRQm9kUKAXQGBQQAJfj/i9iD4wcuiB4WMtH40fjR+KMhaCaLRQImK0UWoyNoixYTaKEjaDvQfqGLFg9ooSFoO9B+lovQJotFENHoA9B4iqENaDvQfIOhI2iL0CaLRRID0HgRoRFoO9B8ClNX6EsBX1vpZf9bB4PDBOlN/wfDJvZFCoB1A+mTACaLRRDR6AMGIWh48TsGDWh+6yaLRRI9ZAB94gMGI2h4cpCQkDsGEWh+aZCQkKEPaDsGIWh+XaERaAMGE2h4VDsGI2h+TsYGPGgAxwYZaAAAoQ1oKwYhaHkH99ijGWgzwKMfaCPAdAWADjxoAqEPaCsGIWh4ISaLXRDR60Mrw3gWJotFENHoKwYfaHkCM8CjNWjrFTPAw6EfaPfYAwYPaCsGIWiADjxoAaM1aMcGG2gAAKERaCsGI2h5B/fYoxtoM8CjHWihEWgDBhdoKwYjaHgRJitFEngLoR1o99gmA0US6xGhHWj32AMGEWgDBhdoKwYjaKM3aKEbaAMGEWiFwHQEsyj24wMG4lYDBhloAwYNaKPoVqE1aCPAdBR4EqE3aCPAdAt4CT1kAH0EDQEAw+lh/+gQ/6EdaIXAdAgmil0QAtv24wMGH2gDBh9oAwYfaAMGH2ij5lahNWgmi1UQ0eqxKCrIMu2K9cYGOmgA6yyhHWiFwHQGJopdEPbjAwYfaAMGH2ij5lahNWgmi1UQ0eqxKCrIMu3GBjpoAQZXLqAWMqI7aCbEbQwDLuZWiS4laIzAoydoizboVok2LWih5FajL2jHBjNoKACJFjFoviVo6AMAXwfDHopEFy6iFTKKRBYuohYyi0QSSC6jEzJ5A+k8EItcEItEDivDLqMPMotMDCvLikQVUlC6zgOwBe7rAOsAQrAA7lhaUlC6zgOwA+7rAOsAQrAA7lhaUlC6xAOwAu7rAOsAQrAP7lhaA9sy5APAi9ADwAPCvY8yA+gui1YELot+AC6LAS6j4iUui0YCUFMuoA4yu9oRJEB0A7viES6LBy6j1REuikcCLqLXES6KRwQuotgRLopHBi6i2RFbWMQsxXQILooeFjIy/wPbLou/JTOD+gR0FoP6AnQTg/oBdAqD+gN0BbQB6Vz66/kDyQPJLokOETL/4AAAAAAAAgECAAQACAACAQIACAAEACaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXJotGACaLVgKDxQRRLooOFjLTyNPKWVBSI8cj1wvYC8qLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCxGWVv314b7hukj3yPP99cmi0YAJotWAoPFBFEuig4WMtPI08pZUFIjxyPXC9gLyovDC8EK4LrOA7AI77rEAy6h1RHvisRCiiSIHC6g1xHuiDwuoNgR7ogMLqDZEe6ILEZZW/fXhvuG6SPfI8/31yaLRgAmi1YCg8UEUS6KDhYy08jTyllQUiPHI9cL2AvKi8MLwQrgus4DsAjvusQDLqHVEe+KxEKKJIgcLqDXEe6IPC6g2BHuiAwuoNkR7ogsRllb99eG+4bpI98jz/fXLqAVMiQBdTCLwwvBCuC6zgOwCO+6xAMuodUR74rEQookiBwuoNcR7og8LqDYEe6IDC6g2RHuiCwu/w4TMng4LgMuETIuAzYPMjPbM8kuoBUyJAJ0HyaLXvwmi0b+LooOFjLTy9PIi8j314b7hukj3yPP99fpqAS6zgO4CP/vH8Mmi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlomi0YAi9gK4IPFAlK6zgOwCO+6xAO4AgTvQookiBywCO6IPLAD7sYEAEZaJotGAIvYCuCDxQJSus4DsAjvusQDuAIE70KKJIgcsAjuiDywA+7GBABGWiaLRgCL2Argg8UCUrrOA7AI77rEA7gCBO9CiiSIHLAI7og8sAPuxgQARlou/w4TMngMLgMuETIuAzYPMusD6Vj7uAAA/+CLTgbR6YPBAYPh/ot+BNHvg+f+K8+DwQHR6YteCIPj/ItWCivT0erR6rgAuI7AsCj244vZvuJWA/cD+APAA/CLwwPAvaAAi8vzpSvwK/iBxwAgA/WLy/OlK/Ar+IHHACAD9YvL86Ur8Cv4gccAIAP1i8vzpSvwK/iB7wBgA/0D9Up1w8MeV1ZQU1FSJsU9i03chukjyXgGdASL9+sD6WgBi0XehuDR6NHoi9Aj0njudOyLReqG4D0DAHQD6UwBUVJXiwSLXAKLTASLVAaGxIbfhs2G1tHS0dfR0dHX0dPR19HQ0dfR0tHX0dHR19HT0dfR0NHX0dLR19HR0dfR09HX0dDR19HS0dfR0dHX0dPR19HQ0deXhsSJBJfR0tHX0dHR19HT0dfR0NHX0dLR19HR0dfR09HX0dDR19HS0dfR0dHX0dPR19HQ0dfR0tHX0dHR19HT0dfR0NHXl4bEiUQCl9HS0dfR0dHX0dPR19HQ0dfR0tHX0dHR19HT0dfR0NHX0dLR19HR0dfR09HX0dDR19HS0dfR0dHX0dPR19HQ0deXhsSJRASX0dLR19HR0dfR09HX0dDR19HS0dfR0dHX0dPR19HQ0dfR0tHX0dHR19HT0dfR0NHX0dLR19HR0dfR09HX0dDR15eGxIlEBpdfWlmDxghKdQ3iCFpZW1heXx/D6Zv+6bb+6/Dr7sR+BIzAJosdg/v/dDiG+9HL0cvRy9HLA8OLyyaLXQILy3QnhvuLy4PhD4HBAAiD4/DR69Hr0evR6wPDJolFAiaJDegz/oPHBOu5w4tOBtHpg8EBg+H+i34E0e+D5/4rz4k+DWiJDg9oi34IiT4RaItOCivPiQ4TaMPEXgQL23QD6AEAw4keCWiMxok2C2iLwwvGdAPoAQDDxB4JaAYmxD+MwAvHdANT6wbpjwDphAAmikUKqIB09SaLBSYrRRSL2IDjAQLbAtsuiB4WMtH4oyFoJotFAiYrRRajI2gmi0UQ0eh0yCaLRRIjwHTAixYXaKEjaDvQfrWLFhVooSFoO9B+qovQJotFENHoA9B4nqENaDvQfpehI2iL0CaLRRID0HgRoRFoO9B+ClNX6DkBX1vpef9bB4PDBOlh/wfDJvZFCoB1A+mKACaLRRDR6AMGIWh48TsGDWh+6yaLRRI9ZAB94gMGI2h4aZCQkDsGEWh+YKEVaDsGIWh+V6EXaDsGI2h+TsYGPGgAxwYZaAAAoQ1oKwYhaHkH99ijGWgzwKMfaCPAdAWADjxoAqEVaCsGIWh4ISaLXRDR60Mrw3gWJotFENHoKwYfaHkCM8CjNWjrFTPAw6EfaPfYAwYVaCsGIWiADjxoAaM1aMcGG2gAAKERaCsGI2h5B/fYoxtoM8CjHWihF2grBiNoeBEmK0USeAuhHWj32CYDRRLrDaEdaPfYAwYXaCsGI2ijN2ihG2gDBhFohcB0BLOg9uMF4lYDBhloAwYNaKPoVqE1aCPAdBR4EqE3aCPAdAt4CT1kAH0EDQEAw+lq/+gZ/6EdaIXAdAgmil0Q0Ov24wMGH2ij5lahNWgmi1UQ0eqxoCrIMu2K9cYGOmgA6yyhHWiFwHQGJopdEPbjAwYfaAMGH2ij5lahNWgmi1UQ0eqxoCrIMu3GBjpoAQZXLqAWMqI7aMRtDAMu5laJLiVojMCjJ2iLNuhWiTYtaLg7EKMvaMcGM2igAIkWMWi+JWjoAwBfB8MeikQXLqIVMopEFi6iFjKLRBJILqMTMnkD6dMAi1wQi0QOK8Muow8yi0wMK8uKRBWK8wPbMuQDwIv4A8ADx701MwPoLot+AC6LAS6j5Csui0YCxCzFdAguih4WMjL/0fvR+y6Kl/szLokOETL/4FIiyXUYJopeAEUy/y6KASIECsOIBEb+znXrWuszJopGAEUuig4WMtLIiuAiwgrYMv+KBC4iAQrDiARGitz20iLa9tL+znXWWi6gFTIkAXUALv8OEzJ4Ki4DLhEyLgM2DzIuig4WMr/oKzLbLqAVMiQCdAwmil7/0sv20iLa9tLrBB/D6/y4AAD/4P/w8PDw8PDw8PDw8PDw8PAPAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAADDw8PDw1dWVR4Guwktiz4dVAP/LosBxH4E/9AHH11eX8tqADQMNAzyJyQM6CxXVlUeBrs7EI7bjtqL8Ls3LYs+HVQD/y6LAf/QBx9dXl/LjgThEOEQ8CokDOksV1ZVHga4OxCO2LthLYs+HVQD/y6LAf/QBx9dXl/LAAAzDDMM5iUkDOosV1ZVHga4OxCO2B7FNt5WxTSM2B+JNuJWo+RWu5wtiz4dVAP/LosB/9AHH11eX8tiAikOKQ5rKCQM6yxXVlUeBrg7EI7Yu8Ytiz4dVAP/LosB/9AHH11eX8soAu8N7w09KCQM7CweuDsQjtiLRgTR4NHgBRVUo95WuDsQo+BWH8tXVlUeBrg7EI7YxHYExwbuVvBWBibEHIzAC8N1BwcHH11eX8smi0cE0eDR4L87EI7fJsV/BgP4xT0miX8MjNgmiUcOC8d1BibHRwoAAItF/iaJRxKLRfwmiUcQi0X6JolHFItF+CaJRxaLRfQmiUcYPQMAcgO4AwAmiUcYC8B0Ix5XBlZRi8iNdfSNfxpOTqVOTk5OpU5OTk6lTk7i71leB18fikX2JohHCyTAdQeDxgQH6V7/qEB1A+m/AVZXJop3Ciah7laL94PuDIv4BQwAJolHDLg7ECaJRw6OwLkGAPOli96KRPzQ6NDoimT+9uQD8IvI9sYgdQPpGgGLT/yL6dHhK/mD7wiLT/5Ri83R4dHhA/mLzdHp0elRig9DUzLkMsD2wYB0C4oEu/BmA9gmigdGiugywPbBQHQLigS78GYD2CaKB0aqMsD2wSB0C4oEu/BmA9gmigdGitAywPbBEHQLigS78GYD2CaKB0aqMsD2wQh0C4oEu/BmA9gmigdGivAywPbBBHQLigS78GYD2CaKB0aqMsD2wQJ0C4oEu/BmA9gmigdGiuAywPbBAXQOigS78GYC2IDXACaKB0aqiswuoe0NPQAAdRgmi0X+huAmiUX+JotF/IbgJolF/IbqhvGKxaqKwqqKxqqKwaqD7xBbWUkLyXQD6R7/WUkLyXQD6Qb/0eUD/YPHCCaJPu5WX17pmP5Rig9DM8DR4XMDigRGqtHhcwOKJEYywNHhcwOKBEaqMu3R4XMDiixGMsDR4XMDigRGqjLS0eFzA4oURjLA0eFzA4oERqqKxKqKxaqKwqoywNHhcwOKBEaqWeKlJok+7lZfXukz/ukw/lZXJqHuVov3g+4Mi/gFDAAmiUcMuDsQJolHDo7AuQYA86WLTPyL6dHhK/mD7wiLTP6MwIzajsKO2LvwZlGLzdHh0eED+YvN0enR6VEmigRG14rIJooERteK6CaKBEbXitAmigRG14rwJooERteIBUcmigRG14gFRyaKBEbXiAVHJooERteIBUcuoe0NPQAAdRSLRf6G4IlF/otF/IbgiUX8hvKG6YkNiVUCg+8MWeKbWeKJjMCM2o7CjtjR5QP9g8cIJok+7lZfXulk/VdWVR4GuDsQjti78Ga5AAChHVQ9AAB1NorR0OrQ2NDq0NTR4NDq0NjQ6tDU0eDQ6tDY0OrQ1NHg0OrQ2NDq0NTR4IgnQ0GB+f8AfszrLIrh0OzQ0NDs0NDQ7NDQ0OzQ0NDs0NDQ7NDQ0OzQ0NDs0NCIB0NBgfn/AH7UBx9dXl/LV1ZVHga4OxCO2ItGBKPwZ4tWBokW8meOwov4JopFCi6iDjKL7Lg7EFC48GdQVYvsg+0CDuj/+12L5YvsuDsQULjwZ1BVi+yD7QIO6Gj7XYvlBx9dXl/LAAAAAAAAAAAAeQhPCDEIEwj1B9cHuQebB30HXwdBByMHBQfnBskGqwaNBm8GUQYzBhUG9wXZBbsFnQV/BWEFQwUPDOcLyQurC40LbwtRCzMLFQv3CtkKuwqdCn8KYQpDCiUKBwrpCcsJrQmPCXEJUwk1CRcJ+QjbCP///z//D/8DmzILIQQA7TLcJQIA+iBjIAQgpR9GH+ceiB4pHsodax0MHa0cThzvG5AbMRvSGnMaFBq1GVYZ9xiYGDkY2hd7FxwXvRZeFv8VoBVBFeIUgxQkFMUTZhMHE6gSSRLqEcsloCV1JUolHyX0JMkkniRzJEgkHSTyI8cjnCNxI0YjGyPwIsUimiJvIkQiGSLuIcMhmCFtIUIh//9/fz8/Hx8PDwcHAwMBATszvysEAK4rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK14rXiteK/8PAAAAV1ZVHga4OxCO2LgCAM0QvkBoMv+6AQG0As0QtAmL1s0hvlhov55otwC5BAC6IQqAPQF1DrQCzRBStAmL1s0hWv7Gg8YRR+LnsD+aqpcAAHUdsECaqpcAAHUcsEGaqpcAAHUbsEKaqpcAAHUa69rHBpxoAIDrHccGnGgAAOsVxwacaAEA6w3HBpxoBADrBZqulwAABx9dXl/LAAAAAAAAAFdWVR4Gix4dVNHj/5d2aQcfXV5fy7raA+yoCHT77KgIdfvDw8O6ugPsJIB1++wkgHT7wwAAAAAAAAAAAAAAAAAAAmKcAAAAEE6qAAAAAAAAAAAAAFR1cmJvIEMrKyAtIENvcHlyaWdodCAxOTkwIEJvcmxhbmQgSW50bC4ARGl2aWRlIGVycm9yDQpBYm5vcm1hbCBwcm9ncmFtIHRlcm1pbmF0aW9uDQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmAU7EGIABngAAJ8FOxBiAJYvAACmBTsQYQC4CwAAswU7EGEAY30AAMAFOxBhAMMHAADNBTsQYQBjfQAA2gU7EGEA6IAAAOcFOxBhAGN9AAD0BTsQYgBgCwAA+wU7EGEAmAgAAAAAGAAoABgAUAAYAHgAGACgABgAyAAYAPAAGAAYARgAAAA4ACgAOABQADgAeAA4AKAAOADIADgA8AA4ABgBOAAAAFgAKABYAFAAWAB4AFgAoABYAMgAWADwAFgAGAFYAAAAeAAoAHgAUAB4AHgAeACgAHgAyAB4APAAeAAYAXgAAACYACgAmABQAJgAeACYAKAAmADIAJgA8ACYABgBmAAAALgAKAC4AFAAuAB4ALgAoAC4AMgAuADwALgAGAG4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgACAAwAAgAWAAIAIAACACoAAgA0AAIAPgACAAgAQgACAAoADAAKABYACgAgAAoAKgAKADQACgA+AAoACABKAAIAEgAMABIAFgASACAAEgAqABIANAASAD4AEgAIAFIAAgAaAAwAGgAWABoAIAAaACoAGgA0ABoAPgAaAAgAWgACACIADAAiABYAIgAgACIAKgAiADQAIgA+ACIACABiAAIAKgAMACoAFgAqACAAKgAqACoANAAqAD4AKgAIAGoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAABIAAAAcAAAAJgAAADAAAAA6AAAABABAAA4AQAAIAAgAEgAIABwACAAmAAgAMAAIADoACAAEAEgADgBIAAgAEAASABAAHAAQACYAEAAwABAAOgAQAAQAUAAOAFAACAAYABIAGAAcABgAJgAYADAAGAA6ABgABABYAA4AWAAIACAAEgAgABwAIAAmACAAMAAgADoAIAAEAGAADgBgAAgAKAASACgAHAAoACYAKAAwACgAOgAoAAQAaAAOAGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBzOxAAAAADBgAgBEQEZgAGBkAEYAYEBEQAIgJAAAQAUAB3B0QxLlBBVgBEMS5ERUMAU1BSSVRFICAuQklOAEdSSUxMRSAgLlZFQwBEREZOVDIgIC5DQVIAQlVNUFlPQkouVkVDAEJVTVBZU1BSLkJJTgBHUklMTE9CSi5WRUMARDEuQlVNAEZMRUNIRS5CSU4ASU5TRVJUIFRIRSBPVEhFUiBESVNLIEFORCBQUkVTUyBBIEtFWSAhAE9WRVIgRkxPVyAhAAAAAAQGDAwLCQQGDA4ODw8AAAAAAAAAAgoEBgYMDg8PAAABCQsFBAYMAgoJCwUHAAAABg4HCAQGCwIKAQkHCwAAAAQLBwgEBgwCCgEJBwcAAAAGDgsBDAYMAgoJCwkHAAAIBAcJAQQGDAIKAQkJBwAAAQkIBwkEBgwCCgkLCwcAAAgJBwEJBAYMAgoIAQsHAAAEBgwMAQQGDAIKCQkJBwAABwkJDQAEBgkCCgcJBQcAWgY7EGoGOxB6BjsQigY7EJoGOxCqBjsQugY7EMoGOxDaBjsQAAEJDgoFBAYMAgoJCwUHAAABCAgHCwsJAQkEBAYMDAEAAAAEBgwMCwkEBgwODg8PAAAAAgADB1AAQgMCBAAFIAYwACEAMgAnAjcEEwRDAAGIizsQToI7EIKFOxADAAZABkEGQgAAK0MrRAZFBkYGRwZIBwAGSQZKCiQGJwMzBkwsAAZNK1crWAZOBk8GUAM/BlEGUgZTBlQsVQZWBgAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD5KPko+Si2I/koIyT5KPko+Sj5KHAkjiTXJAolrSW2I7Ai+Sj5KPko+Sj5KPko+Sj5KPko+Sj5KERDN0Q3RDdEN0ReHpAewh4+Hzgh5yH5KPko+Sj5KPkosCLBItIiECg9Hvko+Sj5KPko+Sj5KPko+Sj5KPko+Sj5KPko+Sj5KAAAAAAAAAAAAAAAAAAAAAAAABFxJVA/UFlQb1ARcRFxEXERcRFxEXG/TUROyU5OT79Nv02/Tb9Nv00Rcf8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAenM7EKRzOxDOczsQ+HM7ECJ0OxBMdDsQdnQ7EKB0OxDKdDsQ9HQ7EB51OxBIdTsQcnU7EJx1OxDmETsQQEtMAO8ROxDAxi0A+BE7EEBCDwABEjsQQA0DAAoSOxAwdQAAExI7EKAPAAAcEjsQ9AEAACUSOxBhAJBfAQAyEjsQYQBjfQAAPxI7EGEAY30AAEwSOxBhAGN9AABWEjsQYgBcGgAAYBI7EGIARYkAAGoSOxB6AAAAAABsEjsQegAAAAAAbhI7EGEAY30AAHkSOxBhAGN9AACEEjsQYQBjfQAAjxI7EGEAY30AAJoSOxBhAGN9AAClEjsQYQBjfQAAsBI7EGEAY30AALsSOxBhAGN9AADGEjsQYQBjfQAA0RI7EGIAY30AAN0SOxBiAGN9AAAAAAAAAAAAAAAAAAAAAAAAAlAAAAAJYAFQAAAAAAAAAAAABFAAAAAHMANQAAAAAAAIMAAAAAAAAAAKMAAAB1AABDAAAAZQAAAABTAMMAAACVAAAmAAAAhQAAAABjAAAAAAC1AAAAAPMApQAAAACDAAAAAADVAAAAAAAAxQDlAAAAAAAA1QD1AACzAAAA5QAAD/AAAAAAAAAAAAIAAgAHAAIADAACAAEAEgACAAUADAAFAAEAFQACAAgABwAIAAwACAABABgAAgALAAcACwAMAAsAAQAbAAAAAAAAAAAAAAAAAABTAAAAAAAAAABjAAAAAAAAAABzAAAAAAAAAACDAAAAAAAAEwCTAAAAAAAAIwCjAAAAAAAAMwCzAAAAAAAAQwDDAAAAAAAAUwDTAAAAAAAAYwDjAAAAAAAAcwDzAAAAAAAAgwAAAAAA1QAAkwAAAMUA5QAAowAAANUA9QAAswAAAOUAAA/wAAAAAAAAAAAHAAIADAACAAEAEgACAAUABwAFAAwABQABABUAAgAIAAcACAAMAAgAAQAYAAIACwAHAAsADAALAAEAGwAAAAAAAAAAAAAAAAAAUwAAACUAAAAAAAAVADUAAAAAYwAlAAAAAAAAcwAAAAAAABMAgwAAAAAAADMAowAAAAAAAEMAswAAAAAAAFMAwwAAAJUAAAAA0wCFAKUAAGMA4wCVALUAAHMA8wClAAAAAIMAAAAAAAAAAJMAAAAAAAAAAKMAAAAAAAAAALMAAAAAAAAP8AAAAAAAAAAAAgACAAcAAgAMAAIAAQASAAIABQAMAAUAAQAVAAIACAAHAAgADAAIAAEAGAACAAsABwALAAwACwABABsAAAAAAAAAAAAAAAAAADMAAAAAAAAAAJYAAAAAAAATAGMAAAAAAAAAAHMAAAAAAAAAAIMAAAAAAAAzAAAAAAB1AABDALMAZQAAAABTAMMAAACVAAAmAAAAhQAAAAAAAAAAAAC1AABzAAAApQDFAACDAAAAtQAAD/AAAAAAAAAAAgACAAEAEgACAAUABwAFAAwABQACAAgABwAIAAwACAABABgAAgALAAcACwAMAAsAAAAAAAAAAAAAAAAAAAAAAAAlAAAAAFMAFQAAAAAAAAAAAABFAAAAAIMANQAAAAAjAJMAAABlAAAAAKMAVQAAAAAAAAAAAACFAABDALMAdQCVAABTAAAAhQAAAABjAMMAAAAAAACDAAAAAAAAAACjAAAAAAAAD/AAAAAAAAAABwACAAwAAgACAAUABwAFAAwABQABABUAAgAIAAcACAAMAAgAAQAYAAcACwABABsAAAAAAAAAAAAAAAAAAFMAAAAAAAAAAGMAAAA1AAAAAHMAJQAAAAAAAIMAAAAAAAATAMYAAABlAAAjAAAAVQAAAAAzAKMAAACFAABDALMAdQAAAAAAAAAAAAClAABzAOMAlQAAAACDAPMAAAAAAABWAAAAAAAAAAAAAAAAAADlAACjAAAA1QAAAACzAAAAAAAAD/AAAAAAAAAAAAIAAgAHAAIADAACAAEAEgACAAUABwAFAAwABQABABUABwAIAAwACAABABgAAgALAAcACwAMAAsAAQAbAAAAAAAAAAAAAAAAAAAAAAAAJQAAAABjABUANQAAAACWACUARQAAAABzADUAAAAAAACDAAAAAAAAIwC2AAAAAAAAQwDGAAAAAAAAUwCjAAAAAAAANgAAAAAAAAAAgwAAAAAAtQAAZgAAAKUAygAAdgAAALoAAA/wAAAAAAAAAAIAAgAHAAIADAACAAEAEgACAAUABwAFAAEAFQACAAgADAAIAAIACwAHAAsAAQAbAAAAAAAAAAAAAAAAAACGAAAAJQAAAABTABUANQAAAABjACUARgAAAAAAADYAAAAAIwCTAAAAAAAAMwCjAAAAdgAAAACzAGYAAAAAFgAAAAAAlQAAUwDTAIUApQAAYwDjAJUAtgAAcwDzAKYAAAAAAAAAAAAA1QAAkwAAAMUA5QAAowAAANUAAAAAswAAAAAAAA/wAAAAAAAAAAACAAIABwACAAwAAgACABIABwAFAAwABQACABUAAgAIAAcACAAMAAgAAgAYAAIACwAHAAsADAALAAIAGwAAAAAAAAAAAAAAAAAAdgAAAAAAAAAAUwAAADUAAAAAAAAlAAAAAAAAgwAAAFUAACMAAABFAAAAAAAAkwAAAAAAABYAowAAAAAAAEMAswAAAAAAAGMAwwAAAAAAAHMAAAAAALUAAIMAAAClAMoAAJMAAAC6AAAP8AAAAAAAAAACAAIADAACAAEAEgAHAAUADAAFAAEAFQACAAgABwAIAAEAGAACAAsABwALAAEAGwAOYJOxC8CjsQkgs7EGgMOxAWDTsQxA07EJoOOxBIDzsQHhA7EIAKOxBWCzsQLAw7EOYMOxCUDTsQXg47EBgPOxDiDzsQnBA7EAEAAAAAAAIAAAAAAAMAAAAAAAQAAAAAAAUAAAAAAAYAAAAAAAcAAAAAAAAAAAAAAAEAAAD9/wIAAAD+/wMAAAD+/wQAAAD//wUAAAAAAAYAAAABAAcAAAABAAAAAAABABMAAAABABYAAAADABkAAAADABwAAAADAB8AAAADAGQAAAAAACMBAABhHucSOxD1EjsQCRM7EBgTOxAnEzsQ/6oAAAAAAABGAE8AUQCTAJ8AqAC0ALMAvgDEAMoAywDaAOEAAAAEBgcFDxAYExwaGRsREkJJRyBKSU0uAFNVUEVSIEpPAFNURVZFLi4uAFdJTElBTS4uAEpPSE5OWS4uAEZSQU5LLi4uAE1JS0UuLi4uAEJVTVNQSkVVLkJJTgBNQVNLQlVNUC5WRUMAQlVNUFJFU0UuVkVDAFNDT1JFLlZFQwBCVU1QWS5CTksAQlVNUFkuTUlEACAAIABNT05ERTEuVkVDAE1PTkRFMi5WRUMATU9OREUzLlZFQwBNT05ERTQuVkVDAE1PTkRFNS5WRUMATU9OREU2LlZFQwBNT05ERTcuVkVDAE1PTkRFOC5WRUMATU9OREU5LlZFQwBERVNTRklOLlZFQwBUSVRSRS5WRUMAWU9VUiBQQVNTV09SRABFTlRFUiBZT1VSIFBBU1NXT1JEACBQQVNTV09SRCBPSyAgAFBBU1NXT1JEIEVSUk9SAEdBTUUgT1ZFUgBFbnRlciB0aGUgcGxhdGZvcm0gbnVtYmVyACAgICAAICAgIABFUlJPUgAAbiU7EHUlOxB8JTsQgyU7EIolOxCRJTsQmCU7EJ8lOxAAAAAA/P8AAAAA/f8AAAAA/f8AAAAA/v8AAAAA//8AAAAA//8AAAAAAAAAAAAAAAAAAAAAAQAAAAAAAQAAAAAAAgAAAAAAAwAAAAAAAwAAAAAABAAOAHwTOxAHAAIA/P8HAAIA/f8GAAIA/f8GAAQA/v8GAAQA/v8GAAQA//8GAAQAAAAGAAQAAQAGAAQAAgAHAAQAAgAHAAIAAwAAAAIAAwAAAAIABAANAdYTOxABAAIA/P8BAAIA/f8CAAIA/f8CAAQA/v8CAAQA/v8CAAQA//8CAAQAAAACAAQAAQACAAQAAgABAAQAAgABAAIAAwAAAAIAAwAAAAIABAANACoUOxALAAAA/P8LAAAA/P8LAAAA/P8LAAAA/P8AAAAA/P8AAAAA/P8AAAAA/P8AAAAA/P8IAH4UOxABAAAABAACAAAABAADAAAABAAEAAAABAAFAAAABAAGAAAABAAHAAAABAAAAAAABAAIALQUOxAJAAkACgAKAAsACwAAAAAABwAGAAYABwAAAAEAAgACAAEAAAAAAAwADQAOAA8AEAAJAAwADQAOAA8AEAAJAAgACQAAAAAA/P8AAAAA/P8AAAAA/P8AAAAA/v8RAAAA//8RAAAAAQAAAAAAAgAAAAAABAAAAAAABAAAAAAABAAKACwVOxAAAAAA/P8AAAAA/P8AAAAA/P8AAAAA/P8AAAAA/v8RAAAAAAARAAAAAgAAAAAABAAAAAAABAAAAAAABAAAAAAABAALAG4VOxALAAQA//8LAAQA/v8LAAQA/v8LAAQA/v8LAAQA/v8LAAQA//8LAAQAAAAAAAQAAQAAAAQAAwAAAAIAAwAAAAIAAwALAbYVOxALALYVOxAAAAAA/f8AAAAA+/8AAAAA+f8HAPz/AAAAAAQAAAABAAQAAAAAAPz/AAAHAP7/AAAAAAIAAAABAAIAAAAAAP7/AAAHAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAPAAQWOxAAAC0ALgAvADAAMQAyADMANAA1ADYANwAyAC8ALgAtAAAABwABAAcAAQAHAAEABwABAAoACgALAAsACgAKAAkACQAIAAgACQAJAAAAAAADAAsAAAAEAAAAAAAEAAAAAAAEAAQArhY7EAkAAAD+/wkAAAACAAIAzBY7EBMAAAAAABMAAAAAABQAAAABABQAAAAAABUAAAABABUAAAAAABYAAAABABYAAAAAABcAAAABABcAAAAAABgAAAABABgAAAAAABkAAAABABoAAAABABsAAAABABwAAAABAB0AAAABAB4AAAABAB8AAAABACAAAAABABQA3hY7ECAAAAAAAB8AAAD//x4AAAD//x0AAAD//xwAAAD//xoAAAD+/xgAAAD+/xUAAAD9/wAAAAD+/wkAXBc7ECIAAQACACIAAAAAACMA//8AACMAAAAAACQAAAAAACQAAAAAACUAAAABACUAAAAAACYAAAAAACYAAAAAACcAAAAAACcAAAAAACgAAAAAACgAAAAAACkAAAABACkAAAAAAGQAAAAAABEAmBc7EAsAAAD8/wsAAAD9/wsAAAD+/wsAAAD//wsAAAD//wAAAAAAAAAAAAAAAAAAAAABAAAAAAABAAAAAAACAAAAAAADAAAAAAAEAAwABBg7EAAA/v/8/wAA/v/9/wAA/v/9/wAA/P/+/xIAAAAAABIAAAAAABIAAgABAAAAAgACAAAAAgACAAAAAgADAAAAAgAEAAsAUhg7EAAAAgD8/wAAAgD9/wAAAgD9/wAAAgD+/xIAAAAAABIAAAAAABIA/v8BAAAAAAACAAAA/v8CAAAA/v8DAAAA/v8EAAsAmhg7EAsA/P///wsA/P/+/xIA/v/+/xIAAAD+/xIAAAD//xIAAAD//xIAAAD//xIAAgD//wAAAgABAAAAAgACAAAAAgAEAAAAAgAEAAwA4hg7EAsABAD//wsABAD+/xIAAAD+/xIAAAD+/xIAAAD//xIAAAD//xIA/v///xIA/v///wAAAAABAAAAAAACAAAA/v8EAAAA/v8EAAwAMBk7EAcA/v/8/wcA/v/9/wYA/v/9/wYA/P/+/wYA/P/+/wAA/P///xIA/v8AABIAAAD//xIAAAAAABIAAgAAAAAABAABAAAABAACAAAABAADAAAAAgADAAAAAgADAAAAAgAEABAAfhk7EAcAAgD8/wcAAgD9/wYAAgD9/wYABAD+/wYABAD+/wAABAD//xIAAAAAABIAAAD//xIAAAAAABIA/v8AAAAA/v8BAAAA/P8CAAAA/P8DAAAA/v8DAAAA/v8DAAAA/v8EABAA5Bk7EAsA/P///wsA/P/+/wsA/P/+/wsA/P/+/wAA/v/+/xIA/v///xIAAAD//xIAAAD//xIAAAD//xIAAgD//wAABAAAAAAABAACAAAABAACAAAAAgADAAAAAgADAAAAAgAEABAASho7EAsABAD//wsABAD+/wsABAD+/wsABAD+/wAAAgD+/xIAAAD//xIAAAD//xIAAAD//xIAAAD//xIA/v///wAA/v8AAAAA/P8CAAAA/P8CAAAA/v8DAAAA/v8DAAAA/v8EABAAsBo7EAAABgD7/wAACAD8/wAACAD9/wAACAD//wAACAD//wAACAAAAAAABgABAAAABgABAAAABgACAAAABAACAAAABAACAAAABAADAAAABAADAA0BFhs7EA0AFhs7EAcABgAGAAUABQAGAAYABwAAAAEAAgACAAMAAwACAAIAAQAAAAAAAAAAAAAAIQAAAPz/IQAAAPz/IQAAAPz/IQAAAPz/IQAAAPz/IQAAAPz/IQAAAPz/IQAAAPz/CACcGzsQIQAAAAQAIQAAAAQAIQAAAAQAIQAAAAQAIQAAAAQAIQAAAAQAIQAAAAQAIQAAAAQACADSGzsQIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAAIQAEAAAACgEIHDsQCgAIHDsQAAACAPz/AAACAP3/AAACAP3/AAAEAP7/AAAAAP3/AAAAAAMAAAAAAAMAAAAAAP3/AAAAAP7/AAAAAAIAAAAAAAIAAAAAAP7/DAFQHDsQDABQHDsQCAAJAAoACwAKAAoACQAKAAoACgAKAAgACQAKAAsACgAKAAkACgAKAAoACgAAAAgAAAAAAAgAAAAAAAgAAAAAAAgAAAAAAAgAAAAFAdAcOxAFANAcOxAAAAgAAAAAAAgAAAAAAAQAAAASAAIAAAASAAAAAAASAP7/AAAAAPz/AgAAAP7/AwAAAP7/AwAAAP7/BAAKAfocOxAKAPocOxAAAAgAAAAAAAgAAAAAAAgAAAAAAAQAAAASAAIAAAASAAAAAAASAP7/AAAAAPz/AAAAAPz/AQAAAPz/AgAAAP7/AgAAAP7/AwAAAP7/BAANAUIdOxANAEIdOxAAAAAA/P8AAAAA/P8AAAAA/v8RAAAA//8RAAAAAAARAAAAAQAAAAAAAAAAAAAAAgAAAAAABAAAAAAABAAKAJwdOxAAAAAA/P8AAAAA/P8iAAEA/v8iAAAAAAAjAP///v8jAAAAAAAkAAAA//8kAAAAAAAlAAAA//8lAAAAAAAmAAAA//8mAAAAAAAnAAAA//8nAAAAAAAoAAAA//8oAAAAAAApAAAA//8pAAAAAABkAAAAAAATAN4dOxALABIABgALAAoADAALAAAAEgALAPb/EAALAPH/CgALAO7/AAALAPD/9P8LAPr/7v8LAAQA7v8LAAwA8P8LABIA+v8LABIA/P8LABIAAAALABIA+v8LAAoA9P8LAAAA7v8LAPb/8P8LAPH/9v8LAO7/AAALAPD/DAALAPr/EgALAAQAEgALAAwAEAALABIABgALABIABAALABIAAAAaAFYeOxALAAAAAgALAAAAAgALAAAAAAALAAAAAAALAAAA/v8LAAAA/v8GAPgeOxALAPv/AAALAP3/AAALAP//AAALAP//AAALAAAAAAALAAAAAAALAAAAAgALAAAAAwALAAAAAwALAAAABAAKACIfOxAKASIfOxAAAAYA+/8AAAgA/P8AAAgA/f8AAAgA//8AAAgA//8AAAgAAAAAAAQAAAASAAIAAAASAAAAAAASAP7/AAAAAP7/AQAAAP7/AgAAAP7/AwAAAP7/BAAAAP7/BAAPAWofOxAPAGofOxAAAAYA+/8AAAgA/P8AAAgA/f8AAAgA//8AAAgA//8AAAgAAAAAAAgAAQAAAAQAAQASAAIAAAASAAAAAAASAP7/AAAAAPz/AAAAAPz/AQAAAPz/AgAAAP7/AgAAAP7/AwAAAP7/BAARAdAfOxARANAfOxAAAAYA+/8SAAQA/v8SAPz//v8AAPj//v8AAPj//v8AAPj///8AAPj/AAAAAPr/AgAAAPz/AwAAAP7/BAAAAP7/BQALAUIgOxALAEIgOxAAAAYA+/8AAAgA/P8SAAQA//8SAPr///8AAPj///8AAPj///8AAPj///8AAPj/AAAAAPr/AAAAAPr/AgAAAPz/AwAAAP7/BAAAAP7/BQANAZAgOxANAJAgOxAAAAAA/P84AAAA/f85AAAA/f86AAAA/v87AAAA//88AAAA//89AAAAAAA+AAAAAAAAAAAAAQAAAAAAAQAAAAAAAgAAAAAAAwAAAAAAAwAAAAAABAAOAOogOxDRAQAA/P/RAQAA/f/SAQAA/f/SAQAA/v/TAQAA///TAQAA///UAQAAAADUAQAAAADVAQAAAQDVAQAAAQDWAQAAAgDWAQAAAwDXAQAAAwAAAAAABAAOAEQhOxAAAAAA/P8+AAAA/f89AAAA/f88AAAA/v87AAAA//86AAAA//85AAAAAAA4AAAAAAAAAAAAAQAAAAAAAQAAAAAAAgAAAAAAAwAAAAAAAwAAAAAABAAOAJ4hOxDXAQAA/P/XAQAA/f/WAQAA/f/WAQAA/v/VAQAA///VAQAA///UAQAAAADUAQAAAADTAQAAAQDTAQAAAQDSAQAAAgDSAQAAAwDRAQAAAwAAAAAABAAOAPghOxDQEzsQJBQ7EHgUOxCuFDsQ5BQ7EAAAAABoFTsQsBU7EPgVOxD+FTsQXhY7EAAAAADGFjsQ2BY7EFYXOxCSFzsQ/hc7EEwYOxCUGDsQ3Bg7ECoZOxB4GTsQ3hk7EEQaOxCqGjsQEBs7EGQbOxBqGzsQAAAAAMwbOxACHDsQRBw7EEocOxCYHDsQnhw7EAAAAAAAAAAA7hw7EPQcOxA2HTsQPB07EJAdOxCWHTsQ2B07EFAeOxDkFDsQ8h47EBwfOxBWFzsQVhc7EF4fOxBkHzsQxB87EMofOxA2IDsQPCA7EIQgOxCKIDsQ3iA7EOQgOxA+ITsQmCE7EPIhOxBMIjsQAAAAAPz/AAAAAPz/AQAAAPz/AQAAAPz/AgAAAPz/AgAAAPz/AwAAAPz/AwAAAPz/CABSIzsQAAAAAAQAAAAAAAQAAQAAAAQAAQAAAAQAAgAAAAQAAgAAAAQAAwAAAAQAAwAAAAQACACIIzsQAQAEAAAAAQAEAAAAAgAEAAAAAgAEAAAAAQAEAAAAAQAEAAAAAgAEAAAAAgAEAAAAAwAEAAAAAwAEAAAACgG+IzsQCgC+IzsQAQAAAP3/AQAAAP7/AgAAAAAAAgAAAAMAAQAAAAMAAQAAAP3/AgAAAP3/AwAAAAIAAAAAAAMACQAGJDsQAQAAAAMAAQAAAAIAAgAAAAAAAwAAAP3/AgAAAP3/AQAAAAMAAAAAAAMAAQAAAP7/AAAAAP3/CQBCJDsQAAADAAAAAQADAAAAAgACAAAAAwAAAAAAAgD8/wAAAQD9/wAAAAD+/wAAAQD//wAAAgAAAAAAAwACAAAACgF+JDsQCgB+JDsQAQAAAAAAAQAAAAAAAgAAAAAAAgAAAAAAAQAAAAAAAQAAAAAAAgAAAAAAAgAAAAAAAwAAAAAAAwAAAAAAAgAAAAAAAgAAAAAAAwAAAAAAAAAAAAAADgDGJDsQAAAAAIIjOxC4IzsQ+iM7EAAkOxA8JDsQeCQ7ELokOxDAJDsQGiU7EFoBXgFiAWYBagFuAXIBdgHbAd8B4wHnAesB7wHzAfcB+wGmJTsQQUNDRVNTAEJVVFRPTgBJU0xBTkQAUFJFVFRZAFdJTk5FUgBaT01CSUUATE9WRUxZAFNZU1RFTQBBQUFBQUEAAAABAgADBAQFBgcIAAkKCwAMDQAAAAAADg4ADw8PDxARABIAAAAAAAAAAAAAAAAAAAABAQALCQkFBgcJAAkJAQABCgAAAAAAAQEACwsLCwsAAAEAAAAAAAAAAAAAAAAAAAATFBUWFxcYGRobABwdHh8gIREAAAAAIiIAIyMjIyQAACUAAAAAAAAAAAAAAAAAAAABAQ4LAwMFBgcBAAQBAQEBCBIAAAAAAQEACwsLCwsAAAEAAAAAAAAAAAAAAAAAAAAEBAQAAAAEBAQEAAQEBAAEAAAEBAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAACAgIAAAACAgICAAICAgACAAACAgIAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAADAwMAAwMDAwMDAwMDAAMAAxEDAwMAAwMAAwMDAxEDAwMAAAAAAAAAAAAAAAAAAAALCwsACwsJCQkJCwsLAAsACRILCwsACwsACwsLCxILCwsAAAAAAAAAAAAAAAAAAAAALy8vLy8AAAAAAAAAAAAHLy8vLy8AAAAAAAAAAAAAAAANDQ0NDQAAAAAAAAAAAAcNDQ0NDQAAAAAAAAAAAAAAAwMDAwMDAw4QEBASDgoKCgoDAAAAAAAAAAAAAAAAAwAMDAwMDAwMDhAQERIOCgoKCgwAAAAAAAAAAAAAAAALAAAjf0F/KH8mf0B/P38+fyd/VH9Df0d/QX9Nfz1/KX8qf1t/Ln8lfzh/T38ofyZ/QH8/fz5/Rn9gf0R/R38xfzh/Qn89fyl/LH8uf05/SX9Tf1V/WH9if1p/Y39jf0V/AAAABgAAAAABAf8AAQARKDsQBQAAAAABAf8BACAoOxACAAMAAgEEAAAAAQH/AAEALig7ELgAAAEB/wEAQig7EA8AAAAABwf/AwBOKDsQDgAAAAAHB/8DAFwoOxAIAAkACgsMAAANBwf/AAMAaig7EBkAAAAUABoAGwAcAB0d/wAIAH4oOxAYAAAAFAAaABsAHAAdHf8ACACUKDsQFQAWABUUFwAAGgAbABwAHR3/CACqKDsQIgAAAB0AIwAkACUAJib/AAkAwig7ECEAAAAdACMAJAAlACYm/wAJANgoOxAeAB8AHh0gAAAjACQAJQAmJv8JAO4oOxArAAAAJgAsAC0ALgAvADAAMbm5/wAABik7ECoAAAAmACwALQAuAC8AMAAxubn/AAAgKTsQJwAoACcmKQAALAAtAC4ALwAwADG5uf8AAAA6KTsQGgAbABwAHR3/AAgAWCk7ECMAJAAlACYm/wAJAGgpOxAsAC0ALgAvADAAMQC5uf8AAAB4KTsQEQAAEBD/BQCOKTsQEwAAEhL/BgCaKTsQNwAAAAAyMv8KAKYpOxA2AAAAADIy/woAtCk7EDMANAAzMjUAAAAyMv8ACgDCKTsQOAA5ADoAOwA8ADIy/wAKANYpOxA9AD4APwBAADIy/wAKAOopOxBBAEIAQwBEADIy/wAKAPwpOxBKSv8AFwAOKjsQSUn/ABgAGCo7EEYARwBGRUgAAABFRf8ADAAiKjsQRQBKAEUASQBFRf8ADAA2KjsQTE1OT1BRUrm5/wAASCo7ECIZABQbHSQmLS+5uf8ADQBYKjsQIRgAFBsdJCYtL7m5/wANAGwqOxAVABYAFRQXABsdJCYtL7m5/wANAIAqOxAUGx0kJi0vubn/DQCYKjsQU1VXWVtcXP8OAKgqOxBTAFQAVQBWAFcAWABZAFoAWwBcXP8ADgC2KjsQXQBeAF1cXwAAXFz/DgDSKjsQqwAAAFxTVVdcXP8ADgDkKjsQqgAAAFxTVVdcXP8ADgD2KjsQYwBiAGEAYGD/AA8ACCs7EGEAYgBjAGBg/wAPABgrOxBhAGIAYwBgAGEAYgBjAGBg/wAPACgrOxBlZmdoAAAAAGdmZWRk/xAAQCs7ELAAAAAAZGT/EABUKzsQrwAAAABkZP8QAGIrOxCsAK0ArGSuAAAAZGT/ABAAcCs7ELYAAGRk/xAAhCs7EI6PkJEAAAAAkI+OjY3/AgCQKzsQtQAAAACNjf8CAKQrOxC0AAAAAI2N/wIAsis7ELEAsgCxjbMAAACNjf8AAgDAKzsQtwAAjY3/AgDUKzsQbmltbm1uaWn/ABEA4Cs7EG5pbW5tbmlp/wARAPArOxBpAAAAagAAawBqaW1ubW5paf8RAAAsOxBuAG9wcXIAc7m5/wAAABgsOxB2d3h5ensAfH11fXV9dXX/EwAqLDsQhQAAAISDgoGAAACBgoMAhACFhf8UAEAsOxCLAAAAiomIh4YAAIeIiQCKAIuL/xUAWiw7EIyM/wAWAHQsOxC5uf8AAAB+LDsQAQAAAAC6AAAAAQH/AQCILDsQjQAAAAC7AAAAjY3/AgCaLDsQBwAAAAC8AAAABwf/AwCsLDsQEAAAAAARAAAAEBD/BQC+LDsQEgAAAAATAAAAEhL/BgDQLDsQFAAAAAC9AAAAFBT/BwDiLDsQHQAAAAC+AAAAHR3/CAD0LDsQJgAAAAC/AAAAJib/CQAGLTsQMgAAAADAAAAAMjL/CgAYLTsQRQAAAADBAAAARUX/DAAqLTsQuQAmAAC/AAAAJi0vubn/AA0APC07EGAAYQBiAGMAYABhAGIAYwBgYP8ADwBSLTsQaQAAAABtAABubW5tbm1paf8AEQBsLTsQdQAAAABsAAAAdXX/EwCELTsQhYUAAISDggCDhIWF/wAUAJYtOxCLiwAAiomIAImKi4v/ABUAqi07EIwAAAAAwgAAAIyM/xYAvi07EEoAAAAAwwAAAEpK/xcA0C07EEkAAAAAxAAAAElJ/xgA4i07EJgAAAAAmQAAAJoAmwC5uf8AAPQtOxCWAAAAAJcAAACYmP8aAAouOxCUAAAAAJUAAACWlv8bABwuOxCSAAAAAJMAAACUlP8cAC4uOxCeAJ8AoAChAKIAnACdnf8AHgBALjsQpQCmAKcAqACpAKMApKT/AB8AVi47EAIABAACAAQAAgQCBAIEAgQCBAIEfn7/ACAAbC47EH4AAH9//yAAii47EH5+/wAgAJYuOxAGAAAAAH5+/yEAoC47EAUAAAAAfn7/IQCuLjsQAgADAAIBBAAAAAF+fv8hALwuOxC4AAABfn7/ACEA0C47EAAAAAAaKDsQKCg7EDwoOxBIKDsQVig7EGQoOxB4KDsQjig7EKQoOxC8KDsQ0ig7EOgoOxAAKTsQGik7EDQpOxBSKTsQYik7EHIpOxCIKTsQrik7ELwpOxDQKTsQ5Ck7EPYpOxAIKjsQEio7EBwqOxAwKjsQQio7EGYqOxB6KjsQkio7EKIqOxDeKjsQsCo7EMwqOxASKzsQIis7EDorOxDqKzsQ+is7EBIsOxAkLDsQOiw7EFQsOxBuLDsQeCw7EIIsOxCUKTsQoCk7EE4rOxCeKzsQ8Co7EAIrOxBcKzsQais7EH4rOxCKKzsQrCs7ELorOxDOKzsQ2is7EFIqOxCULDsQpiw7ELgsOxDKLDsQ3Cw7EO4sOxAALTsQEi07ECQtOxA2LTsQTC07EGYtOxB+LTsQkC07EMotOxDcLTsQ7i07EAQuOxAWLjsQKC47EDouOxBQLjsQZi47EKQtOxC4LTsQhC47EJAuOxCaLjsQqC47ELYuOxDKLjsQ2C47EAAAAAABAAACAAEB/wEAYjA7EAQFBgcIAAAAAAkKCwwNDg7/AAMAcDA7EA8QERIIAAAAABMUFRYXGBj/AAQAiDA7EBkaGxwIAAAAAB0eHyAhAQH/AAEAoDA7ECMlJwAAAAAmJSQjIiL/BgC4MDsQKSstAAAAACwrKikoKP8HAMwwOxAwMTIzNDU2Nzg5Ojs8PS4vL/8IAOAwOxA+AABeAD8//woA+DA7ED8AAF4AQED/CwAGMTsQQAAAXgBBAEIAQwBEAEVqav8AAAAUMTsQXAAAAF0AXgBgAF9f/wAPACwxOxBfAAAAYABeAGIAYWH/ABAAQDE7EGEAAABiAF4AZABjY/8AEQBUMTsQYwAAAGQAXgBdAFxc/wAOAGgxOxBlZmdoaQAAaGdmZWpq/xIAfDE7EGhnZmVqav8AAACQMTsQBQYHCAAAAAkKCwwNDg7/AAMAnjE7EBAREggAAAATFBUWFxgY/wAEALQxOxAaGxwIAAAAHR4fICEBAf8AAQDKMTsQIyUnAAAAACYlJCMiIv8GAOAxOxApKy0AAAAALCsqKSgo/wcA9DE7EE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoATU3/AA0ACDI7EEcAAF4AXQBgAGIAZF5HR/8FACwyOxBIAEkASgBLAEwAamr/AAAAQjI7EAAAAABqMDsQgjA7EJowOxCyMDsQxjA7ENowOxDyMDsQADE7EA4xOxAmMTsQOjE7EE4xOxBiMTsQdjE7EIoxOxCYMTsQrjE7EMQxOxDaMTsQ7jE7EAIyOxAmMjsQPDI7EFAyOxAAAAAAAAADAAIAAwAFAAMABwADAAoAAwAMAAMADwADABEAAwAAAAcAAgAHAAUABwAHAAcACgAHAAwABwAPAAcAEQAHAAAACwACAAsABQALAAcACwAKAAsADAALAA8ACwARAAsAAAAPAAIADwAFAA8ABwAPAAoADwAMAA8ADwAPABEADwAAABMAAgATAAUAEwAHABMACgATAAwAEwAPABMAEQATAAAAFwACABcABQAXAAcAFwAKABcADAAXAA8AFwARABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAQAAAAHAAAACQAAAAwAAAAOAAAAEQAAABEAAAACAAQABAAEAAcABAAJAAQADAAEAA4ABAARAAQAEQAEAAIACAAEAAgABwAIAAkACAAMAAgADgAIABEACAARAAgAAgAMAAQADAAHAAwACQAMAAwADAAOAAwAEQAMABEADAACABAABAAQAAcAEAAJABAADAAQAA4AEAARABAAEQAQAAIAFAAEABQABwAUAAkAFAAMABQADgAUABEAFAARABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAECAwQXBQAHCAkKAAALDA0ODxAAAAAAAAAAAAAAAAAAAQIDBBcABgcICQoAAAsMDQ4PEAAAAAAAAAAAAAAAAAABAgMEFwUAAAgJCgAACwwNDg8QAAAAAAAAAAAAAAAAAAECAwQXAAYACAkKAAALDA0ODxAAAAAAAAAAAAAAAAAAARESExcUAAAICQoAAAsMDQ4PEAAAAAAAAAAAAAAAAAABERITFwAVAAgJCgAACwwNDg8QAAAAAAAAAAAAAAAAAAEREhMXFAAACAkKAAALDA0ODxAAAAAAAAAAAAAAAAAAARESExcAFQAICQoAAAsMDQ4PEAAAAAAAAAAAAAAAAAAAAAUAAQIAAAAAAAAAAA4AERADGhsAAQIDAAAAAAAQMAAAAAAAAAAAAAAAAAAAAAEBAQEBAQIBAQEBAAEBAQEBARADGhsAAQIDAQEBAQEQMAEAAAAAAAAAAAAAAAAAAAICAgICAQICAgICAAICAgICAhADGhsAAQIDAgICAgIQMAIAAAAAAAAAAAAAAAAAAAAAABEAEREAAAAAAAAAAAAAABEREREAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAICQAAAAAACAkAAAAAAAAAAAkICQgJCAkICAkAAAAAAAAAAAAAAAkICQgAAAAAAAAAAAAJCAkIAAAAAAAAAAAFAEAABQBBAAQAQgACAEMAAgBEAAIARQAFAEYABQBHAAQASAAFAEkABQBKAAEASwAFAEwAAgBNAAIATgADAE8AAwBQAAMAUQADAFIABQBTAAUAVAAEAFUAAgBWAAIAVwACAFgABQBZAAUAWgAFAFsABQBcAAUAXQAEAF4AAwBfAAMAYAADAGEABQBiAAUAYwAFAGQABQBlAAUAZgAFAGcABABoAAMAaQADAGoABQBrAAUAbAAFAG0ABgBuAAUAbwAEAHAABQBxAAUAcgAEAHMAAgB0AAIAdQACAHYAAwB3AAIAeAABAHkAAgB6AAMAewAEAHwAAwB9AAMAfgAEAH8ABACAAAMAgQADAIIABACDAAUAhAAFAIUABACGAAIAhwACAIgAAgCJAAUAigAFAIsABQCMAAUAjQAFAI4ABQCPAAUAkAAFAJEAAwCSAAAAkwADAJQAAACVAAAAlgAAAJcAAACYAAIAmQADAJoABQCbAAUAnAAEAJ0AAgCeAAIA5QACAOYAAgCfAAIAoAACAKEAAgCiAAUAowAFAKQABQClAAUApgAFAKcABQDnAAQA6AACAOkAAgDqAAIA6wAGAKMABACoAAQAqQAEAKoAAACrAAQArAAEAK0ABACuAAQArwAEALAABACxAAQAsgABALMAAAC0AAEAtQACALYAAwC3AAQAuAAFALkABgC6AAMAuwABALwAAgC9AAAAvgAAAL8AAADAAAAAwQAAAMIAAADDAAAAxAAAAMUAAADGAAAAxwAAAMgAAADJAAAAygACAMsABQDMAAUAzQAFAM4ABQDPAAUA0AAFAOwABADtAAIA7gACAO8AAgDwAAYAzAAFANEAAwDRAAUA0gADANIABQDTAAMA0wAFANQAAwDUAAUA1QAFANYABADXAAQA2AAEANkABADaAAQA2wAEANwABADdAAUA3gACAN8AAADgAAAA4QAAAOIAAADjAAIA5AAGAEAAAAAAAgMAQAADAMwAAwBGAAMAUwADAFwAAwBlAAMAcQADAIQAAADLAAAAiQAAAIgA5v8/AAIAAAACAAEAAgACAAIAAwACAAQAAgAFAAIABgARAAcADgAIAAwACQAKAAoACAALAAYADAACAA0AAgAOAAIADwACABAAAQARAA4AEgAMABMACgAUAAgAFQAGABYAAgAXAAIAGAACABkAAgAaAAMAGwAOABwADAAdAAoAHgAIAB8ABgAgAAIAIQAFACIACAAjAAsAJAAOACUAEAAmAAIAJwAFACgACAApAAsAKgAOACsAEAAsAAQALQAEAC4ABAAvAAQAMAAEADEABAAyAAQAMwAEADQABAA1AAQANgAEADcAAgA4AAIAOQACADoAAgA7AAIAPAABAD0AAQA+AAEA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArAHgBxgAdARUBJQFyAK4BAAAAAK8BsAEAAAAAAQACAAMABQAHDwj/AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAJMBkwGTAZQBkwGTAZMBkwGTAZMBkwGwBJMBkwGTAZMBkwGTAf//AAAAAAAAAAAAAAAAAQABAAEAAgACAAAAAQADAAMA/////wEA////////////////AwD/////AwADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"; return Uint8Array.from(atob(code), c => c.charCodeAt(0));})();
cicoCli = `
./cicodis $PWD/dos/B.EXE -load 01ed -ctx -reloc -recursive -asm -coverage \
  -jumptable 01ed:46dc 01ed:4725 4 jumpwords bx \
  -jumptable 01ed:37db 01ed:384a 4 jumpwords bx \
  -jumptable 01ed:6e7e 01ed:70e7 20 jumpwords bx \
  start  \
  -jumptable 01ed:ffff 1228:43c0 600 callwords indirect \
  -jumptable 01ed:ffff 1227:0002 1 callwords indirect \
  -jumptable 01ed:ffff 1227:0008 1 callwords indirect \
  -jumptable 0ca6:ffff 1228:694a 1 callwords indirect \
  -jumptable 0ca6:0264 1228:5469 3 jumpwords bx \
  -jumptable 0ca6:020a 1228:545d 6 jumpwords bx \
  -jumptable 0e15:ffff 1228:4e37 12 callwords indirect \
  -jumptable 0ca6:ffff 1228:4dda 7 callwords indirect \
  -jumptable 0ca6:ffff 1228:4dcc 7 callwords indirect \
  -jumptable 0ca6:ffff 1228:5435 14 callwords indirect \
  -jumptable 0ca6:ffff 1228:5451 2 callwords indirect \
  -jumptable 0ca6:ffff 1228:5544 19 callwords indirect \
  -jumptable 0ca6:ffff 1228:5550 13 callwords indirect \
  -jumptable 0ca6:ffff 1228:56c2 6 callwords indirect \
  -jumptable 0ca6:0374 1228:5475 3 jumpwords bp \
  -jumptable 0ed9:11d3 0ed9:210b 1 jumpfix ax \
  -jumptable 0ed9:25e4 0ed9:2004 1 jumpfix ax \
  -jumptable 0ed9:25e4 0ed9:2063 1 jumpfix ax \
  -jumptable 0ed9:25e4 0ed9:1f46 1 jumpfix ax \
  -jumptable 0ca6:ffff 1228:6952 5 callwords indirect \
  -jumptable 0ca6:ffff 1228:568a 3 callwords indirect \
  -jumptable 01ed:ffff 1228:07ca 64 callwords indirect \
  -jumptable 01ed:ffff 1228:0870 11 callwords indirect \
  -jumptable 01ed:ffff 1228:085c 21 callwords indirect \
  -jumptable 0ca6:ffff 1228:5536 26 callwords indirect \
  -indirect 0ed9:0def,01ed:a3ae,0ed9:0c34,1223:0015,0ca6:0aa0,0ca6:0823,0ca6:1087,0ed9:0e29,0ed9:10e1,0ca6:0db0 \
   > bumpy.clean
`
cicoData = `
#include "cicoemu.h"
using namespace CicoContext;

void sub_1ed0();
void fixReloc(uint16_t seg);

void start()
{
    headerSize = 0x1200;
    loadAddress = 0x01ed;
    cs = 0x01ed;
    ds = 0x01dd;
    es = 0x01dd;
    ss = 0x1c49;
    sp = 0x0080;
    load("/Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/bumpy2/dos", "B.EXE", 112704);
    fixReloc(cs);
    sub_1ed0();
}
void fixReloc(uint16_t seg)
{
    // coverage: 0x0-0x1c header
    // coverage: 0x1c-0x1084 reloc
    memory16(0x0000 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x000b + seg, 0x000d) += seg; // 103a -> 1227
    memory16(0x000f + seg, 0x0007) += seg; // 103a -> 1227
    memory16(0x0753 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x0757 + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0759 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x075a + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x075f + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0772 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0773 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x077d + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0781 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0786 + seg, 0x0005) += seg; // 103b -> 1228
    memory16(0x0798 + seg, 0x000f) += seg; // 103b -> 1228
    memory16(0x079b + seg, 0x000c) += seg; // 0000 -> 01ed
    memory16(0x079d + seg, 0x0006) += seg; // 0000 -> 01ed
    memory16(0x07a2 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x07a7 + seg, 0x0005) += seg; // 0000 -> 01ed
    memory16(0x07a7 + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x07ab + seg, 0x000f) += seg; // 103b -> 1228
    memory16(0x07b2 + seg, 0x0000) += seg; // 0000 -> 01ed
    memory16(0x07b3 + seg, 0x0009) += seg; // 0000 -> 01ed
    memory16(0x07b5 + seg, 0x0007) += seg; // 0ab9 -> 0ca6
    memory16(0x07b7 + seg, 0x0003) += seg; // 0c28 -> 0e15
    memory16(0x07b8 + seg, 0x0003) += seg; // 0ab9 -> 0ca6
    memory16(0x07b9 + seg, 0x0000) += seg; // 0ab9 -> 0ca6
    memory16(0x07ba + seg, 0x0003) += seg; // 0ab9 -> 0ca6
    memory16(0x07ba + seg, 0x000a) += seg; // 0ab9 -> 0ca6
    memory16(0x07bb + seg, 0x000a) += seg; // 0ab9 -> 0ca6
    memory16(0x07bc + seg, 0x0007) += seg; // 0ab9 -> 0ca6
    memory16(0x07bd + seg, 0x0004) += seg; // 0ab9 -> 0ca6
    memory16(0x07bd + seg, 0x000a) += seg; // 0ab9 -> 0ca6
    memory16(0x07be + seg, 0x0007) += seg; // 0ab9 -> 0ca6
    memory16(0x07bf + seg, 0x0007) += seg; // 0ab9 -> 0ca6
    memory16(0x07c3 + seg, 0x0005) += seg; // 103b -> 1228
    memory16(0x07c5 + seg, 0x0004) += seg; // 0000 -> 01ed
    memory16(0x07c9 + seg, 0x000d) += seg; // 0000 -> 01ed
    memory16(0x07ca + seg, 0x000f) += seg; // 103b -> 1228
    memory16(0x07cb + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x07d5 + seg, 0x0008) += seg; // 0000 -> 01ed
    memory16(0x07d6 + seg, 0x0007) += seg; // 0000 -> 01ed
    memory16(0x07d8 + seg, 0x000b) += seg; // 0000 -> 01ed
    memory16(0x07ff + seg, 0x0003) += seg; // 103b -> 1228
    memory16(0x0801 + seg, 0x000f) += seg; // 0000 -> 01ed
    memory16(0x0803 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0804 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x0805 + seg, 0x0008) += seg; // 0000 -> 01ed
    memory16(0x0806 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0807 + seg, 0x0003) += seg; // 103b -> 1228
    memory16(0x0809 + seg, 0x000b) += seg; // 0cd5 -> 0ec2
    memory16(0x080a + seg, 0x0008) += seg; // 0cd5 -> 0ec2
    memory16(0x080b + seg, 0x0009) += seg; // 0ab9 -> 0ca6
    memory16(0x080c + seg, 0x0009) += seg; // 0ab9 -> 0ca6
    memory16(0x0868 + seg, 0x000f) += seg; // 103b -> 1228
    memory16(0x0870 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0871 + seg, 0x0001) += seg; // 0000 -> 01ed
    memory16(0x0896 + seg, 0x0003) += seg; // 0000 -> 01ed
    memory16(0x0897 + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x089a + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x089b + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x089d + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x089f + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x08b8 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x08c0 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x08ed + seg, 0x0001) += seg; // 0000 -> 01ed
    memory16(0x0900 + seg, 0x000e) += seg; // 0000 -> 01ed
    memory16(0x0907 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0908 + seg, 0x0006) += seg; // 0000 -> 01ed
    memory16(0x090c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x0924 + seg, 0x0007) += seg; // 0000 -> 01ed
    memory16(0x0925 + seg, 0x0007) += seg; // 0000 -> 01ed
    memory16(0x0937 + seg, 0x0001) += seg; // 0cda -> 0ec7
    memory16(0x0938 + seg, 0x000b) += seg; // 0cda -> 0ec7
    memory16(0x0939 + seg, 0x000f) += seg; // 0cda -> 0ec7
    memory16(0x093a + seg, 0x000e) += seg; // 0ce5 -> 0ed2
    memory16(0x093b + seg, 0x0004) += seg; // 0ce5 -> 0ed2
    memory16(0x093c + seg, 0x0005) += seg; // 0ab9 -> 0ca6
    memory16(0x093d + seg, 0x0005) += seg; // 0ab9 -> 0ca6
    memory16(0x093d + seg, 0x000e) += seg; // 0cec -> 0ed9
    memory16(0x093e + seg, 0x000f) += seg; // 0cec -> 0ed9
    memory16(0x093f + seg, 0x0008) += seg; // 0cec -> 0ed9
    memory16(0x0940 + seg, 0x0002) += seg; // 0cec -> 0ed9
    memory16(0x0940 + seg, 0x000c) += seg; // 0cec -> 0ed9
    memory16(0x0941 + seg, 0x0006) += seg; // 0cec -> 0ed9
    memory16(0x0942 + seg, 0x0000) += seg; // 0cec -> 0ed9
    memory16(0x0942 + seg, 0x0007) += seg; // 0cec -> 0ed9
    memory16(0x0943 + seg, 0x0000) += seg; // 0cec -> 0ed9
    memory16(0x094e + seg, 0x0005) += seg; // 0000 -> 01ed
    memory16(0x0955 + seg, 0x0000) += seg; // 0000 -> 01ed
    memory16(0x0959 + seg, 0x0008) += seg; // 0000 -> 01ed
    memory16(0x097a + seg, 0x0007) += seg; // 102c -> 1219
    memory16(0x097b + seg, 0x000c) += seg; // 0ab9 -> 0ca6
    memory16(0x097c + seg, 0x0002) += seg; // 0ab9 -> 0ca6
    memory16(0x097d + seg, 0x0002) += seg; // 0ab9 -> 0ca6
    memory16(0x097e + seg, 0x0002) += seg; // 0ab9 -> 0ca6
    memory16(0x097e + seg, 0x0008) += seg; // 0ab9 -> 0ca6
    memory16(0x097e + seg, 0x000e) += seg; // 0ab9 -> 0ca6
    memory16(0x097f + seg, 0x0004) += seg; // 0ab9 -> 0ca6
    memory16(0x0980 + seg, 0x0001) += seg; // 0ab9 -> 0ca6
    memory16(0x0981 + seg, 0x0001) += seg; // 0ab9 -> 0ca6
    memory16(0x0981 + seg, 0x000e) += seg; // 0ab9 -> 0ca6
    memory16(0x0983 + seg, 0x0004) += seg; // 0ab9 -> 0ca6
    memory16(0x0984 + seg, 0x0004) += seg; // 0ab9 -> 0ca6
    memory16(0x0985 + seg, 0x0001) += seg; // 0ab9 -> 0ca6
    memory16(0x0986 + seg, 0x0001) += seg; // 0ab9 -> 0ca6
    memory16(0x0986 + seg, 0x0007) += seg; // 1036 -> 1223
    memory16(0x0a0b + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0aba + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0abd + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0ac2 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x0ac7 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0acd + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0ad1 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x0ad6 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0ad7 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0adb + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0add + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0ae2 + seg, 0x000d) += seg; // 0cd5 -> 0ec2
    memory16(0x0ae4 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0ae6 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0aea + seg, 0x000b) += seg; // 0000 -> 01ed
    memory16(0x0aeb + seg, 0x0004) += seg; // 0000 -> 01ed
    memory16(0x0aed + seg, 0x0009) += seg; // 0000 -> 01ed
    memory16(0x0aef + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0af1 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0b0f + seg, 0x000e) += seg; // 0cda -> 0ec7
    memory16(0x0b10 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0b13 + seg, 0x000a) += seg; // 0cda -> 0ec7
    memory16(0x0b1c + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x0b3a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0b3d + seg, 0x0002) += seg; // 0cda -> 0ec7
    memory16(0x0b3d + seg, 0x000d) += seg; // 0cda -> 0ec7
    memory16(0x0b3e + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0b42 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0b4d + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0b54 + seg, 0x0008) += seg; // 0cda -> 0ec7
    memory16(0x0b55 + seg, 0x0003) += seg; // 0cda -> 0ec7
    memory16(0x0b56 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0b5b + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0b60 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0b65 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x0b68 + seg, 0x0004) += seg; // 0cda -> 0ec7
    memory16(0x0b69 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0b6d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x0b7d + seg, 0x0003) += seg; // 103b -> 1228
    memory16(0x0b83 + seg, 0x000d) += seg; // 0cda -> 0ec7
    memory16(0x0b84 + seg, 0x000f) += seg; // 103b -> 1228
    memory16(0x0b8b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x0b90 + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0b96 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x0b98 + seg, 0x000e) += seg; // 0cda -> 0ec7
    memory16(0x0b99 + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0b9c + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0ba8 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0bae + seg, 0x000c) += seg; // 0cda -> 0ec7
    memory16(0x0baf + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0bb5 + seg, 0x0007) += seg; // 0cda -> 0ec7
    memory16(0x0bb6 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0bbb + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0bc0 + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0bc2 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0bc4 + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0bd2 + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0bd7 + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0bdc + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0be0 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0be4 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x0be6 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x0bea + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0bec + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0bee + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0bef + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0bf1 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0bf5 + seg, 0x0003) += seg; // 103b -> 1228
    memory16(0x0bfa + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0bfb + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0bfd + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0bfe + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0c06 + seg, 0x0000) += seg; // 0cec -> 0ed9
    memory16(0x0c13 + seg, 0x000f) += seg; // 103b -> 1228
    memory16(0x0c21 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x0c28 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x0c2b + seg, 0x0003) += seg; // 0cda -> 0ec7
    memory16(0x0c2c + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0c2e + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0c34 + seg, 0x0007) += seg; // 0cda -> 0ec7
    memory16(0x0c36 + seg, 0x0000) += seg; // 0cda -> 0ec7
    memory16(0x0c37 + seg, 0x000c) += seg; // 0cda -> 0ec7
    memory16(0x0c39 + seg, 0x0001) += seg; // 0cda -> 0ec7
    memory16(0x0c40 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x0c41 + seg, 0x0005) += seg; // 103b -> 1228
    memory16(0x0c42 + seg, 0x000a) += seg; // 0cda -> 0ec7
    memory16(0x0c45 + seg, 0x0004) += seg; // 0cda -> 0ec7
    memory16(0x0c46 + seg, 0x0007) += seg; // 0cda -> 0ec7
    memory16(0x0c47 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0c48 + seg, 0x0000) += seg; // 0cda -> 0ec7
    memory16(0x0c4c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0c4e + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0c51 + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0c53 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x0c54 + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0c56 + seg, 0x0005) += seg; // 0cda -> 0ec7
    memory16(0x0c58 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0c59 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0c5c + seg, 0x0006) += seg; // 0cda -> 0ec7
    memory16(0x0c5e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0c5f + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0c62 + seg, 0x0007) += seg; // 0cda -> 0ec7
    memory16(0x0c64 + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0c65 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0c67 + seg, 0x0003) += seg; // 0cda -> 0ec7
    memory16(0x0c69 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0c6b + seg, 0x0001) += seg; // 0cda -> 0ec7
    memory16(0x0c6c + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0c6e + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0c6f + seg, 0x000c) += seg; // 0cda -> 0ec7
    memory16(0x0c73 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0c74 + seg, 0x0008) += seg; // 0cda -> 0ec7
    memory16(0x0c76 + seg, 0x0009) += seg; // 0cda -> 0ec7
    memory16(0x0c7d + seg, 0x000c) += seg; // 0cda -> 0ec7
    memory16(0x0c83 + seg, 0x0003) += seg; // 0cda -> 0ec7
    memory16(0x0c84 + seg, 0x0004) += seg; // 0cda -> 0ec7
    memory16(0x0c84 + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0c86 + seg, 0x0002) += seg; // 0cda -> 0ec7
    memory16(0x0c87 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0c91 + seg, 0x0006) += seg; // 0cda -> 0ec7
    memory16(0x0c92 + seg, 0x0009) += seg; // 0cda -> 0ec7
    memory16(0x0c93 + seg, 0x0007) += seg; // 0cda -> 0ec7
    memory16(0x0c95 + seg, 0x0008) += seg; // 0cda -> 0ec7
    memory16(0x0c9c + seg, 0x000e) += seg; // 0cda -> 0ec7
    memory16(0x0ca2 + seg, 0x000f) += seg; // 0cda -> 0ec7
    memory16(0x0ca4 + seg, 0x0000) += seg; // 0cda -> 0ec7
    memory16(0x0ca4 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0ca7 + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0cb2 + seg, 0x0007) += seg; // 103b -> 1228
    memory16(0x0cb6 + seg, 0x000c) += seg; // 0cda -> 0ec7
    memory16(0x0cb9 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0cbd + seg, 0x0008) += seg; // 0cda -> 0ec7
    memory16(0x0cbf + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x0cc2 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0cc6 + seg, 0x0009) += seg; // 0cda -> 0ec7
    memory16(0x0cc7 + seg, 0x0008) += seg; // 0cda -> 0ec7
    memory16(0x0cc8 + seg, 0x0001) += seg; // 103b -> 1228
    memory16(0x0cda + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x0cde + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0ce5 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x0ce7 + seg, 0x0005) += seg; // 103b -> 1228
    memory16(0x0f99 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x0fbd + seg, 0x000b) += seg; // 103b -> 1228
    memory16(0x0fc0 + seg, 0x0009) += seg; // 103b -> 1228
    memory16(0x0fc3 + seg, 0x0003) += seg; // 103b -> 1228
    memory16(0x0fc6 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x0fc9 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x0fca + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x0fcb + seg, 0x0003) += seg; // 103b -> 1228
    memory16(0x0fcd + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x0fd8 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x0ff4 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x0fff + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x1007 + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x1009 + seg, 0x000d) += seg; // 103b -> 1228
    memory16(0x100b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x102c + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1030 + seg, 0x000d) += seg; // 0000 -> 01ed
    memory16(0x1031 + seg, 0x0006) += seg; // 0000 -> 01ed
    memory16(0x1031 + seg, 0x000f) += seg; // 0000 -> 01ed
    memory16(0x1032 + seg, 0x0008) += seg; // 0000 -> 01ed
    memory16(0x1035 + seg, 0x0001) += seg; // 0000 -> 01ed
    memory16(0x1044 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1044 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1045 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1046 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1046 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1047 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1047 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1048 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1049 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1049 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1092 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x10a9 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x10aa + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x10aa + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x10aa + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x10aa + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x10ab + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x10ab + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x10ab + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x10ab + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x10b1 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x10b1 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x10b1 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x10c6 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10c6 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x10c7 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10c7 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x10c7 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10c7 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x10c8 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10c8 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x10c8 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10c8 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x10c9 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10c9 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x10c9 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10c9 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x10ca + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10ca + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10cb + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10cb + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10cc + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10cc + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10cd + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10cd + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10ce + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x10ce + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x10cf + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x10d0 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10d0 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x10d1 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x10d2 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x10d2 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10d3 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x10d3 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x10d4 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x10d5 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x10d5 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x10d6 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x10d7 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x10d7 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x10d8 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x10d8 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1147 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1148 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1148 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1148 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1148 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1149 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1149 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1149 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1149 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x114a + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x114a + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x114a + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x114a + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x114b + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x114b + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x114b + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x114b + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x114c + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1155 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1155 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1155 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1155 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1156 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1170 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1171 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1171 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1171 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1171 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1172 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1172 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1172 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1178 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x117d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1182 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1186 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1189 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1191 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1196 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x119a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x119b + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x11a1 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x11a7 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x11a8 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x11b0 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x11b4 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x11bb + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x11c0 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x11c4 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x11c9 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x11cd + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x11d2 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x11d9 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x11df + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x11e5 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x11ec + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x11f1 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x11f1 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x11f8 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x11fb + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x11ff + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x11ff + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1204 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1205 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x120a + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x120a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x120e + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x120f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1214 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1214 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1218 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1220 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x122a + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x122d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1231 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1231 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1237 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1237 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x123e + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x123f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1243 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1243 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1249 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1249 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x124f + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1254 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x125a + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1260 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1260 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1260 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1260 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1261 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1261 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1261 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1262 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1262 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1262 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1262 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1263 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1263 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1263 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1264 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1264 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1264 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1264 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1265 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1265 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1265 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1265 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1266 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1266 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1266 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1266 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1267 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1267 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1267 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1268 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1268 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1268 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1268 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1269 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1269 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x126a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x126a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x126a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x126a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x126b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x126b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x126b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x126b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x126c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x126c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x126c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x126c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x126d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x126d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x126d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x126d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x126e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x126e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x126e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x126e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x126f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x126f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x126f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x126f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1270 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1273 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1276 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x127a + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x127b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x127f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1282 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1286 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1287 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x128c + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x128d + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x128d + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x128d + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x128e + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x128e + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x128e + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x128e + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x128f + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x128f + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1291 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12bc + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12bd + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12bf + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12bf + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12c0 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x12c1 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x12c2 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12c4 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12c5 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x12c7 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12c8 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12c9 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12cb + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x12cc + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12ce + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x12d0 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12d1 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12d2 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12d3 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12d4 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x12d5 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x12d6 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12d7 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12d8 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x12d9 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x12da + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x12db + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x12dc + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12dd + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12de + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x12df + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12e0 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12e1 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x12e2 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12e4 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12e5 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12e6 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x12e8 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12e9 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12ea + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x12eb + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12ec + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12ed + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12ee + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12f0 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12f1 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12f1 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12f3 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12f3 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12f5 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12f6 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x12f6 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12f8 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x12f8 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12f9 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12fa + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x12fc + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x12fd + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x12fe + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1300 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1302 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1302 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1303 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1304 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1305 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1306 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1307 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1309 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x130a + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x130b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x130c + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x130d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x130e + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1310 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1311 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1313 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1314 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1315 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1316 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1317 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1319 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x131a + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x131b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x131c + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x131d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x131e + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1320 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1321 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1323 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1324 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1324 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1325 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1326 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1327 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1328 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1329 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1329 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1329 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x132a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x132a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x132a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x132a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x132b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x132b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x132b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x132b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x132c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x132c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x132c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x132c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x132d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x132d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x132d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x132d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x132e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x132e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x132e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x132e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x132f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x132f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x132f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x132f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1330 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1330 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1330 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1330 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1331 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1331 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1331 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1331 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1332 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1332 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1332 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1332 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1333 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1333 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1333 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1333 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1334 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1334 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1334 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1334 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1335 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1335 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1335 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1335 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1336 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1336 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1336 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1336 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1337 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1337 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1337 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1337 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1338 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1338 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1338 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1338 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1339 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1339 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1339 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1339 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x133a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x133a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x133a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x133a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x133b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x133b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x133b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x133b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x133c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x133c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x133c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x133c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x133d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x133d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x133d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x133d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x133e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x133e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x133e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x133e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x133f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x133f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x133f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x133f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1340 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1340 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1340 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1340 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1341 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1343 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1344 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1346 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1347 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1348 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x134a + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x134b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x134c + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x134d + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x134e + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1350 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1351 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1352 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1353 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1354 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1356 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1357 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1358 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x135a + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x135b + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x135d + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x135f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1360 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1360 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1361 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1361 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1361 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1361 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1362 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1362 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1362 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1362 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1363 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1363 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1363 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1363 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1364 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1364 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1364 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1364 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1365 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1365 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1365 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1365 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1366 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1366 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1366 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1412 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1412 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1412 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1412 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1413 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1413 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1413 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1413 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1414 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1414 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1414 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1414 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1415 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1415 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1415 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1415 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1416 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1416 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1416 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1416 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1417 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1417 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1417 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1417 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1418 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1418 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1418 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1418 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1419 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1419 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1419 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1419 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x141a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x141a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x141a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x141a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x141b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x141b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x141b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x141b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x141c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x141c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x141c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x141c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x141d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x141d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x141d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x141d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x141e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x141e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x141e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x141e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x141f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x141f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x141f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x141f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1420 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1420 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1420 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1420 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1421 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1421 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1421 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1421 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1422 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1422 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1422 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1422 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1423 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1423 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1423 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1423 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1424 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1424 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1424 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1424 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1425 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1425 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1425 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1425 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1426 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1426 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1426 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1426 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1427 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1427 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1427 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1427 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1428 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1428 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1428 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1428 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1429 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1429 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1429 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1429 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x142a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x142a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x142a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x142a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x142b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x142b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x142b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x142b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x142c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x142c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x142c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x142c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x142d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x142d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x142d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x142d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x142e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x142e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x142e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x142e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x142f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x142f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x142f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x142f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1430 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1430 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1430 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1430 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1431 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1431 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1431 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1431 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1432 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1432 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1432 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1432 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1433 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1433 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1433 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1433 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1434 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1434 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1434 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1434 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1435 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1435 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1435 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1435 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1436 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1436 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1436 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1436 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1437 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1437 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1437 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1437 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1438 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1438 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1438 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1438 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1439 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1439 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1439 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1439 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x143a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x143a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x143a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x143a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x143b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x143b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x143b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x143b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x143c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x143c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x143c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x143c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x143d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x143d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x143d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x143d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x143e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x143e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x143e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x143e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x143f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x143f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x143f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x143f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1440 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1440 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1440 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1440 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1441 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1441 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1441 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1441 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1442 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1442 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1442 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1442 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1443 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1445 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1446 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1446 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1446 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1446 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1447 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1447 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1447 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1447 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1448 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1448 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1448 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1448 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1449 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1449 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1449 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1449 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x144a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x144a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x144a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x144a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x144b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x144b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x144b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x144b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x144c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x144c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x144c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x144c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x144d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x144d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x144d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x144d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x144e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x144e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x144e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x144e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x144f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x144f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x144f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x144f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1450 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1450 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1450 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1450 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1451 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1451 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1451 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1451 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1452 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1452 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1452 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1452 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1453 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1453 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1453 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1453 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1454 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1454 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1454 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1454 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1455 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1455 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1455 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1455 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1456 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1456 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1456 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1456 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1457 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1457 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1457 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1457 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1458 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1458 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1458 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1458 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1459 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1459 + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x1459 + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x1459 + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x145a + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x145a + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x145a + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x145a + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x145b + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x145b + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x145b + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x145b + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x145c + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x145c + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x145c + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x145c + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x145d + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x145d + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x145d + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x145d + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x145e + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x145e + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x145e + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x145e + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x145f + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x145f + seg, 0x0004) += seg; // 103b -> 1228
    memory16(0x145f + seg, 0x0008) += seg; // 103b -> 1228
    memory16(0x145f + seg, 0x000c) += seg; // 103b -> 1228
    memory16(0x1460 + seg, 0x0000) += seg; // 103b -> 1228
    memory16(0x1502 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1502 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1502 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1502 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1506 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1507 + seg, 0x0002) += seg; // 103b -> 1228
    memory16(0x1507 + seg, 0x0006) += seg; // 103b -> 1228
    memory16(0x1507 + seg, 0x000a) += seg; // 103b -> 1228
    memory16(0x1507 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x1584 + seg, 0x0004) += seg; // 0000 -> 01ed
    memory16(0x1584 + seg, 0x0008) += seg; // 0000 -> 01ed
    memory16(0x1587 + seg, 0x000e) += seg; // 103b -> 1228
    memory16(0x15a9 + seg, 0x0000) += seg; // 103b -> 1228
}
void sub_1ed0();
void sub_1fc6();
void sub_1fe5();
void sub_1fff();
void sub_2042();
void sub_206f();
void sub_20b2();
void sub_20d3();
void sub_2128();
void sub_2152();
void sub_22ba();
void sub_22e6();
void sub_2439();
void sub_24b7();
void sub_24d4();
void sub_250b();
void sub_26c0();
void sub_26e6();
void sub_27a1();
void sub_28d7();
void sub_2960();
void sub_2a58();
void sub_2ac9();
void sub_2ae8();
void sub_2c6d();
void sub_2e4a();
void sub_30bb();
void sub_3219();
void sub_325c();
void sub_3282();
void sub_32af();
void sub_3343();
void sub_33b4();
void sub_3471();
void sub_352e();
void sub_3697();
void sub_3871();
void sub_38b4();
void sub_38f0();
void sub_3937();
void sub_39fb();
void sub_3aa7();
void sub_3b11();
void sub_3b82();
void sub_3bba();
void sub_3bf6();
void sub_3cae();
void sub_3cd2();
void sub_3d0d();
void sub_3d2e();
void sub_3d60();
void sub_3d92();
void sub_3dd3();
void sub_3e0e();
void sub_3e4f();
void sub_3e8e();
void sub_3f4d();
void sub_4008();
void sub_408b();
void sub_40b7();
void sub_4131();
void sub_415d();
void sub_4180();
void sub_4191();
void sub_41a2();
void sub_41cc();
void sub_420a();
void sub_423f();
void sub_425e();
void sub_4286();
void sub_42f3();
void sub_4340();
void sub_435e();
void sub_43a7();
void sub_43da();
void sub_440f();
void sub_447d();
void sub_4504();
void sub_4571();
void sub_45dc();
void sub_4646();
void sub_46ae();
void sub_46e0();
void sub_47b0();
void sub_47c9();
void sub_4835();
void sub_4876();
void sub_48da();
void sub_4948();
void sub_4be4();
void sub_4dc8();
void sub_4e7c();
void sub_4fad();
void sub_50ae();
void sub_515f();
void sub_5180();
void sub_5295();
void sub_5337();
void sub_5475();
void sub_5722();
void sub_5958();
void sub_5982();
void sub_59df();
void sub_5a3c();
void sub_5a99();
void sub_5af6();
void sub_5b1f();
void sub_5b6d();
void sub_5bc7();
void sub_5ccd();
void sub_5d44();
void sub_5d5a();
void sub_5da4();
void sub_5ee5();
void sub_6133();
void sub_61a9();
void sub_61d5();
void sub_61eb();
void sub_6214();
void sub_6231();
void sub_6268();
void sub_6285();
void sub_62a2();
void sub_62bf();
void sub_62dc();
void sub_6307();
void sub_6324();
void sub_635a();
void sub_6390();
void sub_63dc();
void sub_6402();
void sub_644a();
void sub_6470();
void sub_649f();
void sub_64d5();
void sub_650d();
void sub_652e();
void sub_654d();
void sub_656c();
void sub_658b();
void sub_65fd();
void sub_6617();
void sub_669b();
void sub_66d2();
void sub_670c();
void sub_6779();
void sub_67d6();
void sub_682c();
void sub_6865();
void sub_68a7();
void sub_6a1e();
void sub_6a96();
void sub_6ae4();
void sub_6b69();
void sub_6c8f();
void sub_6cca();
void sub_6d14();
void sub_6d4f();
void sub_6d99();
void sub_6dd4();
void sub_6e1e();
void sub_6e59();
void sub_6ea3();
void sub_6ed3();
void sub_6ef5();
void sub_6f0f();
void sub_6f29();
void sub_6f3f();
void sub_6f55();
void sub_6f90();
void sub_6fcb();
void sub_7051();
void sub_70a8();
void sub_722e();
void sub_7551();
void sub_76b1();
void sub_78a3();
void sub_7b57();
void sub_7eab();
void sub_7f0d();
void sub_8000();
void sub_8053();
void sub_816c();
void sub_81d5();
void sub_81f6();
void sub_8242();
void sub_828e();
void sub_82dc();
void sub_832d();
void sub_834e();
void sub_8391();
void sub_83b2();
void sub_83cf();
void sub_83ec();
void sub_8405();
void sub_841e();
void sub_8457();
void sub_84a2();
void sub_84b5();
void sub_84cb();
void sub_84e1();
void sub_84f7();
void sub_8518();
void sub_8569();
void sub_85a8();
void sub_85e7();
void sub_860a();
void sub_8618();
void sub_8659();
void sub_87ce();
void sub_880a();
void sub_882e();
void sub_8857();
void sub_887a();
void sub_8959();
void sub_8a85();
void sub_8aa4();
void sub_8ac4();
void sub_8ae4();
void sub_8b65();
void sub_8bf6();
void sub_8c3a();
void sub_8c64();
void sub_8cb3();
void sub_8ce1();
void sub_8d00();
void sub_8fe1();
void sub_8ff0();
void sub_9105();
void sub_91bf();
void sub_91d7();
void sub_91e9();
void sub_923f();
void sub_932e();
void sub_93a5();
void sub_9402();
void sub_9433();
void sub_944b();
void sub_9472();
void sub_960c();
void sub_96a9();
void sub_9731();
void sub_985a();
void sub_9947();
void sub_9984();
void sub_998b();
void sub_99d1();
void sub_9a1a();
void sub_9a2a();
void sub_9a63();
void sub_9a77();
void sub_9a7d();
void sub_9a8d();
void sub_9a9a();
void sub_9aa7();
void sub_9aad();
void sub_9aca();
void sub_9bae();
void sub_9c82();
void sub_9c89();
void sub_9cc9();
void sub_9ce8();
void sub_9cef();
void sub_9d32();
void sub_9e60();
void sub_9e63();
void sub_9e66();
void sub_9e69();
void sub_9e6a();
void sub_9e80();
void sub_9f5e();
void sub_9f6e();
void sub_9f7c();
void sub_9f8c();
void sub_a485();
void sub_a4ab();
void sub_a4d0();
void sub_a4f6();
void sub_a5b9();
void sub_a5f2();
void sub_a5fe();
void sub_a60c();
void sub_a672();
void sub_a6d9();
void sub_a761();
void sub_a7b5();
void sub_a7ee();
void sub_a847();
void sub_a869();
void sub_a878();
void sub_a8b2();
void sub_a8d7();
void sub_a8f3();
void sub_a945();
void sub_a9a0();
void sub_a9c6();
void sub_a9d4();
void sub_a9dd();
void sub_a9fa();
void sub_aa3b();
void sub_aa51();
void sub_aa98();
void sub_acff();
void sub_ad18();
void sub_ad20();
void sub_ad28();
void sub_ad63();
void sub_ad73();
void sub_adbb();
void sub_ae86();
void sub_aed7();
void sub_af26();
void sub_af2d();
void sub_afe5();
void sub_b09f();
void sub_b0a7();
void sub_b0af();
void sub_b0fc();
void sub_b14c();
void sub_b274();
void sub_b281();
void sub_b288();
void sub_b298();
void sub_b2a8();
void sub_b2d6();
void sub_b2e0();
void sub_b2f4();
void sub_b2fa();
void sub_b304();
void sub_b310();
void sub_b321();
void sub_b32b();
void sub_b33e();
void sub_b358();
void sub_b3d2();
void sub_b674();
void sub_b67a();
void sub_b695();
void sub_b6a5();
void sub_b6c1();
void sub_b6d4();
void sub_b6e4();
void sub_b6f1();
void sub_b707();
void sub_b734();
void sub_b75e();
void sub_b78a();
void sub_b7ad();
void sub_b82b();
void sub_b86a();
void sub_b8d7();
void sub_b9a3();
void sub_b9e4();
void sub_ba68();
void sub_bb32();
void sub_bba3();
void sub_bcce();
void sub_be68();
void sub_be85();
void sub_bf70();
void sub_bfb9();
void sub_c01f();
void sub_c048();
void sub_c085();
void sub_c096();
void sub_c0bf();
void sub_c0da();
void sub_c0ec();
void sub_c230();
void sub_c27e();
void sub_c336();
void sub_c352();
void sub_c36e();
void sub_c3cc();
void sub_c42e();
void sub_c49f();
void sub_c4c8();
void sub_c4fe();
void sub_c527();
void sub_c588();
void sub_c5c1();
void sub_c5e4();
void sub_c7be();
void sub_c865();
void sub_c8c5();
void sub_c8e4();
void sub_c8fb();
void sub_c91e();
void sub_c9ad();
void sub_ca53();
void sub_ca60();
void sub_ca61();
void sub_ca62();
void sub_ca63();
void sub_ca8b();
void sub_caa7();
void sub_cad2();
void sub_cb26();
void sub_cb44();
void sub_cb75();
void sub_cb7d();
void sub_cb85();
void sub_cba7();
void sub_cbd8();
void sub_cbd9();
void sub_cc0e();
void sub_cc0f();
void sub_cc10();
void sub_cc41();
void sub_cc5f();
void sub_cc7b();
void sub_cc92();
void sub_cd11();
void sub_cd2e();
void sub_cdb1();
void sub_ce87();
void sub_cf8d();
void sub_d016();
void sub_d02e();
void sub_d02f();
void sub_d065();
void sub_d066();
void sub_d080();
void sub_d0ab();
void sub_d0ac();
void sub_d0ad();
void sub_d0bf();
void sub_d0c1();
void sub_d0c2();
void sub_d0d7();
void sub_d11d();
void sub_d11e();
void sub_d11f();
void sub_d121();
void sub_d250();
void sub_d283();
void sub_d2b8();
void sub_d2f2();
void sub_d37e();
void sub_d37f();
void sub_d387();
void sub_d38f();
void sub_d3a7();
void sub_d3f0();
void sub_d3f1();
void sub_d3f7();
void sub_d3f8();
void sub_d3f9();
void sub_d4d3();
void sub_d500();
void sub_d530();
void sub_d593();
void sub_d59c();
void sub_d65d();
void sub_d665();
void sub_d66d();
void sub_d69e();
void sub_d6df();
void sub_d6e0();
void sub_d6e6();
void sub_d6e7();
void sub_d6e8();
void sub_d7d7();
void sub_d810();
void sub_d840();
void sub_d869();
void sub_d923();
void sub_d995();
void sub_da88();
void sub_dac0();
void sub_dae7();
void sub_dc36();
void sub_dc3c();
void sub_dc3d();
void sub_dc3e();
void sub_dcce();
void sub_dd71();
void sub_dd8b();
void sub_dddb();
void sub_de1c();
void sub_de4c();
void sub_de69();
void sub_de82();
void sub_dea1();
void sub_deb8();
void sub_deee();
void sub_df33();
void sub_df4f();
void sub_df5f();
void sub_df90();
void sub_dfbf();
void sub_dfee();
void sub_e01d();
void sub_e066();
void sub_e067();
void sub_e141();
void sub_e142();
void sub_e150();
void sub_e1ce();
void sub_e2e3();
void sub_e2e4();
void sub_e600();
void sub_eb59();
void sub_ec20();
void sub_ec52();
void sub_ec70();
void sub_ecb5();
void sub_ecf9();
void sub_ed20();
void sub_ed3f();
void sub_f9c4();
void sub_fa07();
void sub_fb7f();
void sub_fbb9();
void sub_fbc4();
void sub_fbd8();
void sub_fce0();
void sub_fdcd();
void sub_fe71();
void sub_11a7d();
void sub_11aa5();
void sub_11afd();
void sub_11b38();
void sub_11b62();
void sub_11b7d();
void sub_11ec7();
void sub_11f47();
void sub_12190();
void sub_12230();
void sub_12245();

#ifdef callIndirect
#undef callIndirect
#endif

void callIndirect(int seg, int ofs)
{
    if(seg == 0x01ed)
    switch (ofs)
    {
        // coverage: 0x15970-0x15e1e switch
        case 0x6648: sub_8518(); return;
        case 0x7111: sub_8fe1(); return;
        case 0x6717: sub_85e7(); return;
        case 0x654e: sub_841e(); return;
        case 0x6587: sub_8457(); return;
        case 0x65fb: sub_84cb(); return;
        case 0x0: sub_1ed0(); return;
        case 0x6699: sub_8569(); return;
        case 0x6326: sub_81f6(); return;
        case 0x651c: sub_83ec(); return;
        case 0x65e5: sub_84b5(); return;
        case 0x6627: sub_84f7(); return;
        case 0x66d8: sub_85a8(); return;
        case 0x6372: sub_8242(); return;
        case 0x6535: sub_8405(); return;
        case 0x673a: sub_860a(); return;
        case 0x64e2: sub_83b2(); return;
        case 0x6611: sub_84e1(); return;
        case 0x64ff: sub_83cf(); return;
        case 0x647e: sub_834e(); return;
        case 0x6748: sub_8618(); return;
        case 0x6789: sub_8659(); return;
        case 0x6305: sub_81d5(); return;
        case 0x640c: sub_82dc(); return;
        case 0x645d: sub_832d(); return;
        case 0x65d2: sub_84a2(); return;
        case 0x68fe: sub_87ce(); return;
        case 0x693a: sub_880a(); return;
        case 0x64c1: sub_8391(); return;
        default:
            break;
    }
    if(seg == 0x01ed)
    switch (ofs)
    {
        // coverage: 0x115a2-0x115a2 switch
        case 0x9c62: sub_bb32(); return;
        default:
            break;
    }
    if(seg == 0x01ed)
    switch (ofs)
    {
        // coverage: 0x115a8-0x115a8 switch
        case 0xaa4e: sub_c91e(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x17efa-0x17efa switch
        case 0x14ef: sub_df4f(); return;
        default:
            break;
    }
    if(seg == 0x0e15)
    switch (ofs)
    {
        // coverage: 0x163e7-0x163fd switch
        case 0x193: sub_e2e3(); return;
        case 0x194: sub_e2e4(); return;
        case 0x4b0: sub_e600(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x1638a-0x16396 switch
        case 0x1ae: sub_cc0e(); return;
        case 0x0: sub_ca60(); return;
        case 0x1af: sub_cc0f(); return;
        case 0x1b0: sub_cc10(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x1637c-0x16388 switch
        case 0x2b: sub_ca8b(); return;
        case 0x178: sub_cbd8(); return;
        case 0xc6: sub_cb26(); return;
        case 0x11d: sub_cb7d(); return;
        case 0x115: sub_cb75(); return;
        case 0x125: sub_cb85(); return;
        case 0x72: sub_cad2(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x169e5-0x169ff switch
        case 0x605: sub_d065(); return;
        case 0x606: sub_d066(); return;
        case 0x620: sub_d080(); return;
        case 0x64b: sub_d0ab(); return;
        case 0x64c: sub_d0ac(); return;
        case 0x661: sub_d0c1(); return;
        case 0x662: sub_d0c2(); return;
        case 0x677: sub_d0d7(); return;
        case 0x6bd: sub_d11d(); return;
        case 0x6be: sub_d11e(); return;
        case 0x6bf: sub_d11f(); return;
        case 0x0: sub_ca60(); return;
        case 0x1: sub_ca61(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x16a01-0x16a03 switch
        case 0x2: sub_ca62(); return;
        case 0x3: sub_ca63(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x16af4-0x16b18 switch
        case 0x991: sub_d3f1(); return;
        case 0x7f0: sub_d250(); return;
        case 0x997: sub_d3f7(); return;
        case 0x998: sub_d3f8(); return;
        case 0x999: sub_d3f9(); return;
        case 0xad0: sub_d530(); return;
        case 0xc7f: sub_d6df(); return;
        case 0xb3c: sub_d59c(); return;
        case 0xc05: sub_d665(); return;
        case 0xbfd: sub_d65d(); return;
        case 0xc0d: sub_d66d(); return;
        case 0xb33: sub_d593(); return;
        case 0xc80: sub_d6e0(); return;
        case 0xaa0: sub_d500(); return;
        case 0xc86: sub_d6e6(); return;
        case 0xc87: sub_d6e7(); return;
        case 0xc88: sub_d6e8(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x16b00-0x16b18 switch
        case 0xad0: sub_d530(); return;
        case 0xc7f: sub_d6df(); return;
        case 0xb3c: sub_d59c(); return;
        case 0xc05: sub_d665(); return;
        case 0xbfd: sub_d65d(); return;
        case 0xc0d: sub_d66d(); return;
        case 0xb33: sub_d593(); return;
        case 0xc80: sub_d6e0(); return;
        case 0xaa0: sub_d500(); return;
        case 0xc86: sub_d6e6(); return;
        case 0xc87: sub_d6e7(); return;
        case 0xc88: sub_d6e8(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x16c72-0x16c7c switch
        case 0x11d6: sub_dc36(); return;
        case 0x1060: sub_dac0(); return;
        case 0x11dc: sub_dc3c(); return;
        case 0x11dd: sub_dc3d(); return;
        case 0x11de: sub_dc3e(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x17f02-0x17f0a switch
        case 0x1606: sub_e066(); return;
        case 0x1607: sub_e067(); return;
        case 0x16e2: sub_e142(); return;
        case 0x16e1: sub_e141(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x16c3a-0x16c3e switch
        case 0xde0: sub_d840(); return;
        case 0xf35: sub_d995(); return;
        case 0xec3: sub_d923(); return;
        default:
            break;
    }
    if(seg == 0x01ed)
    switch (ofs)
    {
        // coverage: 0x11d7a-0x11df8 switch
        case 0x28f9: sub_47c9(); return;
        case 0x23b6: sub_4286(); return;
        case 0x2423: sub_42f3(); return;
        case 0x2470: sub_4340(); return;
        case 0x248e: sub_435e(); return;
        case 0x24d7: sub_43a7(); return;
        case 0x250a: sub_43da(); return;
        case 0x25ad: sub_447d(); return;
        case 0x22b0: sub_4180(); return;
        case 0x4344: sub_6214(); return;
        case 0x4437: sub_6307(); return;
        case 0x1e5e: sub_3d2e(); return;
        case 0x1e90: sub_3d60(); return;
        case 0x1ec2: sub_3d92(); return;
        case 0x1f3e: sub_3e0e(); return;
        case 0x2138: sub_4008(); return;
        case 0x21e7: sub_40b7(); return;
        case 0x22c1: sub_4191(); return;
        case 0x22d2: sub_41a2(); return;
        case 0x2810: sub_46e0(); return;
        case 0x1e3d: sub_3d0d(); return;
        default:
            break;
    }
    if(seg == 0x01ed)
    switch (ofs)
    {
        // coverage: 0x11e20-0x11e34 switch
        case 0x7111: sub_8fe1(); return;
        case 0x4dbf: sub_6c8f(); return;
        case 0x4e44: sub_6d14(); return;
        case 0x4ec9: sub_6d99(); return;
        case 0x4f4e: sub_6e1e(); return;
        default:
            break;
    }
    if(seg == 0x01ed)
    switch (ofs)
    {
        // coverage: 0x11e0c-0x11e34 switch
        case 0x7111: sub_8fe1(); return;
        case 0x5025: sub_6ef5(); return;
        case 0x503f: sub_6f0f(); return;
        case 0x5059: sub_6f29(); return;
        case 0x506f: sub_6f3f(); return;
        case 0x4dbf: sub_6c8f(); return;
        case 0x4e44: sub_6d14(); return;
        case 0x4ec9: sub_6d99(); return;
        case 0x4f4e: sub_6e1e(); return;
        default:
            break;
    }
    if(seg == 0x0ca6)
    switch (ofs)
    {
        // coverage: 0x16ae6-0x16b18 switch
        case 0x823: sub_d283(); return;
        case 0x990: sub_d3f0(); return;
        case 0x91e: sub_d37e(); return;
        case 0x927: sub_d387(); return;
        case 0x91f: sub_d37f(); return;
        case 0x92f: sub_d38f(); return;
        case 0x892: sub_d2f2(); return;
        case 0x991: sub_d3f1(); return;
        case 0x7f0: sub_d250(); return;
        case 0x997: sub_d3f7(); return;
        case 0x998: sub_d3f8(); return;
        case 0x999: sub_d3f9(); return;
        case 0xad0: sub_d530(); return;
        case 0xc7f: sub_d6df(); return;
        case 0xb3c: sub_d59c(); return;
        case 0xc05: sub_d665(); return;
        case 0xbfd: sub_d65d(); return;
        case 0xc0d: sub_d66d(); return;
        case 0xb33: sub_d593(); return;
        case 0xc80: sub_d6e0(); return;
        case 0xaa0: sub_d500(); return;
        case 0xc86: sub_d6e6(); return;
        case 0xc87: sub_d6e7(); return;
        case 0xc88: sub_d6e8(); return;
        default:
            break;
    }
    switch (seg*0x10000+ofs)
    {
        case 0x1eda3ae: sub_c27e(); return;
        case 0xca60823: sub_d283(); return;
        case 0xca60aa0: sub_d500(); return;
        case 0xca60db0: sub_d810(); return;
        case 0xca61087: sub_dae7(); return;
        case 0xed90c34: sub_f9c4(); return;
        case 0xed90def: sub_fb7f(); return;
        case 0xed90e29: sub_fbb9(); return;
        case 0xed910e1: sub_fe71(); return;
        case 0x12230015: sub_12245(); return;
        default:
            break;
    }
    assert(0);
}
// INJECT: Error: cannot inject zero flag in sub_9aca() because no traceback!
// INJECT: Error: cannot inject zero flag in sub_a761()!
// INJECT: Error: cannot inject flag in sub_b32b() because of being label!
// INJECT: Error: cannot inject zero flag in sub_b67a() because no traceback!
// INJECT: Error: cannot inject flag in sub_c9ad() because of being label!
/* Assembly listing of 01ed:0000 sub_1ed0()
sub_1ed0 PROC
01ed:0000	mov	dx, 0x1228
01ed:0003	mov	word ptr cs:[0x1ff], dx
01ed:0008	mov	ah, 0x30
01ed:000a	int	0x21
01ed:000c	mov	bp, word ptr [2]
01ed:0010	mov	bx, word ptr [0x2c]
01ed:0014	mov	ds, dx
01ed:0016	mov	word ptr [0x7b], ax
01ed:0019	mov	word ptr [0x79], es
01ed:001d	mov	word ptr [0x75], bx
01ed:0021	mov	word ptr [0x8d], bp
01ed:0025	call	0x12f
01ed:0028	les	di, ptr [0x73]
01ed:002c	mov	ax, di
01ed:002e	mov	bx, ax
01ed:0030	mov	cx, 0x7fff
01ed:0033	cld	
        	loc_1f04:
01ed:0034	repne scasb	al, byte ptr es:[di]
01ed:0036	jcxz	loc_1f44
01ed:0038	inc	bx
01ed:0039	cmp	byte ptr es:[di], al
01ed:003c	jne	loc_1f04
01ed:003e	or	ch, 0x80
01ed:0041	neg	cx
01ed:0043	mov	word ptr [0x73], cx
01ed:0047	mov	cx, 2
01ed:004a	shl	bx, cl
01ed:004c	add	bx, 0x10
01ed:004f	and	bx, 0xfff0
01ed:0052	mov	word ptr [0x77], bx
01ed:0056	mov	dx, ss
01ed:0058	sub	bp, dx
01ed:005a	mov	di, word ptr [0x6b4c]
01ed:005e	cmp	di, 0x200
01ed:0062	jae	loc_1f3b
01ed:0064	mov	di, 0x200
01ed:0067	mov	word ptr [0x6b4c], di
        	loc_1f3b:
01ed:006b	mov	cl, 4
01ed:006d	shr	di, cl
01ed:006f	inc	di
01ed:0070	cmp	bp, di
01ed:0072	jae	loc_1f47
        	loc_1f44:
01ed:0074	jmp	loc_20ba
        	loc_1f47:
01ed:0077	mov	bx, di
01ed:0079	add	bx, dx
01ed:007b	mov	word ptr [0x85], bx
01ed:007f	mov	word ptr [0x89], bx
01ed:0083	mov	ax, word ptr [0x79]
01ed:0086	sub	bx, ax
01ed:0088	mov	es, ax
01ed:008a	mov	ah, 0x4a
01ed:008c	push	di
01ed:008d	int	0x21
01ed:008f	pop	di
01ed:0090	shl	di, cl
01ed:0092	cli	
01ed:0093	mov	ss, dx
01ed:0095	mov	sp, di
01ed:0097	mov	word ptr [0x6b4c], di
01ed:009b	sti	
01ed:009c	xor	ax, ax
01ed:009e	mov	es, word ptr cs:[0x1ff]
01ed:00a3	mov	di, 0x6bba
01ed:00a6	mov	cx, 0xa202
01ed:00a9	sub	cx, di
01ed:00ab	cld	
01ed:00ac	rep stosb	byte ptr es:[di], al
01ed:00ae	mov	ah, 0
01ed:00b0	int	0x1a
01ed:00b2	mov	word ptr [0x7f], dx
01ed:00b6	mov	word ptr [0x81], cx
01ed:00ba	xor	bp, bp
01ed:00bc	mov	ax, 0x1227
01ed:00bf	mov	ds, ax
01ed:00c1	mov	si, 0
01ed:00c4	mov	di, 0xc
01ed:00c7	call	0x19f
01ed:00ca	mov	ds, word ptr cs:[0x1ff]
01ed:00cf	mov	byte ptr cs:[0x1b1], 0x72
01ed:00d5	mov	byte ptr cs:[0x1a0], 0
01ed:00db	push	word ptr [0x71]
01ed:00df	push	word ptr [0x6f]
01ed:00e3	push	word ptr [0x6d]
01ed:00e7	push	word ptr [0x6b]
01ed:00eb	push	word ptr [0x69]
01ed:00ef	call	0x203
01ed:00f2	push	ax
01ed:00f3	call	0xffff98ba
01ed:00f6	mov	ax, 0x1227
01ed:00f9	mov	ds, ax
01ed:00fb	mov	si, 0xc
01ed:00fe	mov	di, 0xc
01ed:0101	call	0x19f
01ed:0104	mov	ds, word ptr cs:[0x1ff]
01ed:0109	call	word ptr [0x6984]
01ed:010d	call	word ptr [0x6986]
01ed:0111	call	word ptr [0x6988]
01ed:0115	mov	ds, word ptr cs:[0x1ff]
01ed:011a	call	0x172
01ed:011d	mov	bp, sp
01ed:011f	mov	ah, 0x4c
01ed:0121	mov	al, byte ptr [bp + 2]
01ed:0124	int	0x21
01ed:0126	mov	cx, 0xe
01ed:0129	mov	dx, 0x2d
01ed:012c	jmp	loc_20c0
01ed:012f		
        	loc_20ba:
01ed:01ea	mov	cx, 0x1e
01ed:01ed	mov	dx, 0x3b
        	loc_20c0:
01ed:01f0	mov	ds, word ptr cs:[0x1ff]
01ed:01f5	call	0x1e2
01ed:01f8	mov	ax, 3
01ed:01fb	push	ax
01ed:01fc	call	0x115
01ed:01ff	add	byte ptr [bx + si], al
01ed:0201	add	ax, word ptr [bx + si + 0x55]
01ed:0204	mov	bp, sp
01ed:0206	cmp	word ptr [0x6b4c], sp
01ed:020a	ja	loc_20df
01ed:020c	call	0xffffab83
        	loc_20df:
01ed:020f	cmp	byte ptr [bp + 4], 1
01ed:0213	jne	loc_2126
01ed:0215	call	0x416
01ed:0218	mov	ah, 0
01ed:021a	or	ax, ax
01ed:021c	jne	loc_2126
01ed:021e	les	bx, ptr [bp + 6]
01ed:0221	mov	ax, word ptr es:[bx + 6]
01ed:0225	mov	dx, word ptr es:[bx + 4]
01ed:0229	mov	word ptr [0x6be4], dx
01ed:022d	mov	word ptr [0x6be6], ax
01ed:0230	call	0x282
01ed:0233	call	0x7ba7
01ed:0236	call	0xa07
01ed:0239	call	0x258
01ed:023c	call	0x569
01ed:023f	call	0x7a77
01ed:0242	call	0x7db9
01ed:0245	mov	ax, 3
01ed:0248	push	ax
01ed:0249	call	0x7120
01ed:024c	inc	sp
01ed:024d	inc	sp
01ed:024e	xor	ax, ax
01ed:0250	push	ax
01ed:0251	call	0xffff98ba
01ed:0254	inc	sp
01ed:0255	inc	sp
        	loc_2126:
01ed:0256	pop	bp
01ed:0257	ret	
sub_1ed0 ENDP
*/
void sub_1ed0()
{
    // coverage: 0x1200-0x132f method sub_1ed0
    // coverage: 0x13ea-0x1458 method sub_1ed0
    push(0x7777);
    dx = 0x1228;
    memoryASet16(cs, 0x01ff, dx);
    ah = 0x30;
    interrupt(0x21);
    bp = memoryAGet16(ds, 0x0002);
    bx = memoryAGet16(ds, 0x002c);
    ds = dx;
    memoryASet16(ds, 0x007b, ax);
    memoryASet16(ds, 0x0079, es);
    memoryASet16(ds, 0x0075, bx);
    memoryASet16(ds, 0x008d, bp);
    sub_1fff();
    di = memoryAGet16(ds, 0x0073);
    es = memoryAGet16(ds, 0x0073 + 2);
    ax = di;
    bx = ax;
    cx = 0x7fff;
    flags.direction = false;
loc_1f04:
    repne_scasb<MemAuto, DirAuto>(al);
    if (cx == 0)
        goto loc_1f44;
    bx++;
    if (memoryAGet(es, di) != al)
        goto loc_1f04;
    ch |= 0x80;
    cx = -cx;
    memoryASet16(ds, 0x0073, cx);
    cx = 0x0002;
    bx <<= cl;
    bx += 0x0010;
    bx &= 0xfff0;
    memoryASet16(ds, 0x0077, bx);
    dx = ss;
    bp -= dx;
    di = memoryAGet16(ds, 0x6b4c);
    if (di >= 0x0200)
        goto loc_1f3b;
    di = 0x0200;
    memoryASet16(ds, 0x6b4c, di);
loc_1f3b:
    cl = 0x04;
    di >>= cl;
    di++;
    if (bp >= di)
        goto loc_1f47;
loc_1f44:
    goto loc_20ba;
loc_1f47:
    bx = di;
    bx += dx;
    memoryASet16(ds, 0x0085, bx);
    memoryASet16(ds, 0x0089, bx);
    ax = memoryAGet16(ds, 0x0079);
    bx -= ax;
    es = ax;
    ah = 0x4a;
    push(di);
    interrupt(0x21);
    di = pop();
    di <<= cl;
    flags.interrupts = false;
    ss = dx;
    sp = di;
    memoryASet16(ds, 0x6b4c, di);
    flags.interrupts = true;
    ax = 0;
    es = memoryAGet16(cs, 0x01ff);
    di = 0x6bba;
    cx = 0xa202;
    cx -= di;
    flags.direction = false;
    rep_stosb<MemAuto, DirAuto>();
    ah = 0x00;
    interrupt(0x1a);
    memoryASet16(ds, 0x007f, dx);
    memoryASet16(ds, 0x0081, cx);
    bp = 0;
    ax = 0x1227;
    ds = ax;
    si = 0x0000;
    di = 0x000c;
    sub_206f();
    ds = memoryAGet16(cs, 0x01ff);
    memoryASet(cs, 0x01b1, 0x72);
    memoryASet(cs, 0x01a0, 0x00);
    push(memoryAGet16(ds, 0x0071));
    push(memoryAGet16(ds, 0x006f));
    push(memoryAGet16(ds, 0x006d));
    push(memoryAGet16(ds, 0x006b));
    push(memoryAGet16(ds, 0x0069));
    sub_20d3();
    push(ax);
    sub_b78a();
    ax = 0x1227;
    ds = ax;
    si = 0x000c;
    di = 0x000c;
    sub_206f();
    ds = memoryAGet16(cs, 0x01ff);
    callIndirect(cs, memoryAGet16(ds, 0x6984));
    callIndirect(cs, memoryAGet16(ds, 0x6986));
    callIndirect(cs, memoryAGet16(ds, 0x6988));
    ds = memoryAGet16(cs, 0x01ff);
    sub_2042();
    bp = sp;
    ah = 0x4c;
    al = memoryAGet(ss, bp + 2);
    interrupt(0x21);
    cx = 0x000e;
    dx = 0x002d;
    goto loc_20c0;
    //   gap of 187 bytes
loc_20ba:
    cx = 0x001e;
    dx = 0x003b;
loc_20c0:
    ds = memoryAGet16(cs, 0x01ff);
    sub_20b2();
    ax = 0x0003;
    push(ax);
    sub_1fe5();
    memoryASet(ds, bx + si, memoryAGet(ds, bx + si) + al);
    ax += memoryAGet16(ds, bx + si + 85);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_20df;
    sub_ca53();
loc_20df:
    if (memoryAGet(ss, bp + 4) != 0x01)
        goto loc_2126;
    sub_22e6();
    ah = 0x00;
    if (ax)
        goto loc_2126;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x6be4, dx);
    memoryASet16(ds, 0x6be6, ax);
    sub_2152();
    sub_9a77();
    sub_28d7();
    sub_2128();
    sub_2439();
    sub_9947();
    sub_9c89();
    ax = 0x0003;
    push(ax);
    sub_8ff0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b78a();
    sp++;
    sp++;
loc_2126:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:00f6 sub_1fc6()
sub_1fc6 PROC
01ed:00f6	mov	ax, 0x1227
01ed:00f9	mov	ds, ax
01ed:00fb	mov	si, 0xc
01ed:00fe	mov	di, 0xc
01ed:0101	call	0x19f
01ed:0104	mov	ds, word ptr cs:[0x1ff]
01ed:0109	call	word ptr [0x6984]
01ed:010d	call	word ptr [0x6986]
01ed:0111	call	word ptr [0x6988]
01ed:0115	mov	ds, word ptr cs:[0x1ff]
01ed:011a	call	0x172
01ed:011d	mov	bp, sp
01ed:011f	mov	ah, 0x4c
01ed:0121	mov	al, byte ptr [bp + 2]
01ed:0124	int	0x21
01ed:0126	mov	cx, 0xe
01ed:0129	mov	dx, 0x2d
01ed:012c	jmp	loc_20c0
01ed:012f		
        	loc_20c0:
01ed:01f0	mov	ds, word ptr cs:[0x1ff]
01ed:01f5	call	0x1e2
01ed:01f8	mov	ax, 3
01ed:01fb	push	ax
01ed:01fc	call	0x115
01ed:01ff	add	byte ptr [bx + si], al
01ed:0201	add	ax, word ptr [bx + si + 0x55]
01ed:0204	mov	bp, sp
01ed:0206	cmp	word ptr [0x6b4c], sp
01ed:020a	ja	loc_20df
01ed:020c	call	0xffffab83
        	loc_20df:
01ed:020f	cmp	byte ptr [bp + 4], 1
01ed:0213	jne	loc_2126
01ed:0215	call	0x416
01ed:0218	mov	ah, 0
01ed:021a	or	ax, ax
01ed:021c	jne	loc_2126
01ed:021e	les	bx, ptr [bp + 6]
01ed:0221	mov	ax, word ptr es:[bx + 6]
01ed:0225	mov	dx, word ptr es:[bx + 4]
01ed:0229	mov	word ptr [0x6be4], dx
01ed:022d	mov	word ptr [0x6be6], ax
01ed:0230	call	0x282
01ed:0233	call	0x7ba7
01ed:0236	call	0xa07
01ed:0239	call	0x258
01ed:023c	call	0x569
01ed:023f	call	0x7a77
01ed:0242	call	0x7db9
01ed:0245	mov	ax, 3
01ed:0248	push	ax
01ed:0249	call	0x7120
01ed:024c	inc	sp
01ed:024d	inc	sp
01ed:024e	xor	ax, ax
01ed:0250	push	ax
01ed:0251	call	0xffff98ba
01ed:0254	inc	sp
01ed:0255	inc	sp
        	loc_2126:
01ed:0256	pop	bp
01ed:0257	ret	
sub_1fc6 ENDP
*/
void sub_1fc6()
{
    // coverage: 0x12f6-0x132f method sub_1fc6
    // coverage: 0x13f0-0x1458 method sub_1fc6
    push(0x7777);
    ax = 0x1227;
    ds = ax;
    si = 0x000c;
    di = 0x000c;
    sub_206f();
    ds = memoryAGet16(cs, 0x01ff);
    callIndirect(cs, memoryAGet16(ds, 0x6984));
    callIndirect(cs, memoryAGet16(ds, 0x6986));
    callIndirect(cs, memoryAGet16(ds, 0x6988));
    ds = memoryAGet16(cs, 0x01ff);
    sub_2042();
    bp = sp;
    ah = 0x4c;
    al = memoryAGet(ss, bp + 2);
    interrupt(0x21);
    cx = 0x000e;
    dx = 0x002d;
    goto loc_20c0;
    //   gap of 193 bytes
loc_20c0:
    ds = memoryAGet16(cs, 0x01ff);
    sub_20b2();
    ax = 0x0003;
    push(ax);
    sub_1fe5();
    memoryASet(ds, bx + si, memoryAGet(ds, bx + si) + al);
    ax += memoryAGet16(ds, bx + si + 85);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_20df;
    sub_ca53();
loc_20df:
    if (memoryAGet(ss, bp + 4) != 0x01)
        goto loc_2126;
    sub_22e6();
    ah = 0x00;
    if (ax)
        goto loc_2126;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x6be4, dx);
    memoryASet16(ds, 0x6be6, ax);
    sub_2152();
    sub_9a77();
    sub_28d7();
    sub_2128();
    sub_2439();
    sub_9947();
    sub_9c89();
    ax = 0x0003;
    push(ax);
    sub_8ff0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b78a();
    sp++;
    sp++;
loc_2126:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0115 sub_1fe5()
sub_1fe5 PROC
01ed:0115	mov	ds, word ptr cs:[0x1ff]
01ed:011a	call	0x172
01ed:011d	mov	bp, sp
01ed:011f	mov	ah, 0x4c
01ed:0121	mov	al, byte ptr [bp + 2]
01ed:0124	int	0x21
01ed:0126	mov	cx, 0xe
01ed:0129	mov	dx, 0x2d
01ed:012c	jmp	loc_20c0
01ed:012f		
        	loc_20c0:
01ed:01f0	mov	ds, word ptr cs:[0x1ff]
01ed:01f5	call	0x1e2
01ed:01f8	mov	ax, 3
01ed:01fb	push	ax
01ed:01fc	call	0x115
01ed:01ff	add	byte ptr [bx + si], al
01ed:0201	add	ax, word ptr [bx + si + 0x55]
01ed:0204	mov	bp, sp
01ed:0206	cmp	word ptr [0x6b4c], sp
01ed:020a	ja	loc_20df
01ed:020c	call	0xffffab83
        	loc_20df:
01ed:020f	cmp	byte ptr [bp + 4], 1
01ed:0213	jne	loc_2126
01ed:0215	call	0x416
01ed:0218	mov	ah, 0
01ed:021a	or	ax, ax
01ed:021c	jne	loc_2126
01ed:021e	les	bx, ptr [bp + 6]
01ed:0221	mov	ax, word ptr es:[bx + 6]
01ed:0225	mov	dx, word ptr es:[bx + 4]
01ed:0229	mov	word ptr [0x6be4], dx
01ed:022d	mov	word ptr [0x6be6], ax
01ed:0230	call	0x282
01ed:0233	call	0x7ba7
01ed:0236	call	0xa07
01ed:0239	call	0x258
01ed:023c	call	0x569
01ed:023f	call	0x7a77
01ed:0242	call	0x7db9
01ed:0245	mov	ax, 3
01ed:0248	push	ax
01ed:0249	call	0x7120
01ed:024c	inc	sp
01ed:024d	inc	sp
01ed:024e	xor	ax, ax
01ed:0250	push	ax
01ed:0251	call	0xffff98ba
01ed:0254	inc	sp
01ed:0255	inc	sp
        	loc_2126:
01ed:0256	pop	bp
01ed:0257	ret	
sub_1fe5 ENDP
*/
void sub_1fe5()
{
    // coverage: 0x1315-0x132f method sub_1fe5
    // coverage: 0x13f0-0x1458 method sub_1fe5
    push(0x7777);
    ds = memoryAGet16(cs, 0x01ff);
    sub_2042();
    bp = sp;
    ah = 0x4c;
    al = memoryAGet(ss, bp + 2);
    interrupt(0x21);
    cx = 0x000e;
    dx = 0x002d;
    goto loc_20c0;
    //   gap of 193 bytes
loc_20c0:
    ds = memoryAGet16(cs, 0x01ff);
    sub_20b2();
    ax = 0x0003;
    push(ax);
    sub_1fe5();
    memoryASet(ds, bx + si, memoryAGet(ds, bx + si) + al);
    ax += memoryAGet16(ds, bx + si + 85);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_20df;
    sub_ca53();
loc_20df:
    if (memoryAGet(ss, bp + 4) != 0x01)
        goto loc_2126;
    sub_22e6();
    ah = 0x00;
    if (ax)
        goto loc_2126;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x6be4, dx);
    memoryASet16(ds, 0x6be6, ax);
    sub_2152();
    sub_9a77();
    sub_28d7();
    sub_2128();
    sub_2439();
    sub_9947();
    sub_9c89();
    ax = 0x0003;
    push(ax);
    sub_8ff0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b78a();
    sp++;
    sp++;
loc_2126:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:012f sub_1fff()
sub_1fff PROC
01ed:012f	push	ds
01ed:0130	mov	ax, 0x3500
01ed:0133	int	0x21
01ed:0135	mov	word ptr [0x59], bx
01ed:0139	mov	word ptr [0x5b], es
01ed:013d	mov	ax, 0x3504
01ed:0140	int	0x21
01ed:0142	mov	word ptr [0x5d], bx
01ed:0146	mov	word ptr [0x5f], es
01ed:014a	mov	ax, 0x3505
01ed:014d	int	0x21
01ed:014f	mov	word ptr [0x61], bx
01ed:0153	mov	word ptr [0x63], es
01ed:0157	mov	ax, 0x3506
01ed:015a	int	0x21
01ed:015c	mov	word ptr [0x65], bx
01ed:0160	mov	word ptr [0x67], es
01ed:0164	mov	ax, 0x2500
01ed:0167	mov	dx, cs
01ed:0169	mov	ds, dx
01ed:016b	mov	dx, 0x126
01ed:016e	int	0x21
01ed:0170	pop	ds
01ed:0171	ret	
sub_1fff ENDP
*/
void sub_1fff()
{
    // coverage: 0x132f-0x1372 method sub_1fff
    push(ds);
    ax = 0x3500;
    interrupt(0x21);
    memoryASet16(ds, 0x0059, bx);
    memoryASet16(ds, 0x005b, es);
    ax = 0x3504;
    interrupt(0x21);
    memoryASet16(ds, 0x005d, bx);
    memoryASet16(ds, 0x005f, es);
    ax = 0x3505;
    interrupt(0x21);
    memoryASet16(ds, 0x0061, bx);
    memoryASet16(ds, 0x0063, es);
    ax = 0x3506;
    interrupt(0x21);
    memoryASet16(ds, 0x0065, bx);
    memoryASet16(ds, 0x0067, es);
    ax = 0x2500;
    dx = cs;
    ds = dx;
    dx = 0x0126;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 01ed:0172 sub_2042()
sub_2042 PROC
01ed:0172	push	ds
01ed:0173	mov	ax, 0x2500
01ed:0176	lds	dx, ptr [0x59]
01ed:017a	int	0x21
01ed:017c	pop	ds
01ed:017d	push	ds
01ed:017e	mov	ax, 0x2504
01ed:0181	lds	dx, ptr [0x5d]
01ed:0185	int	0x21
01ed:0187	pop	ds
01ed:0188	push	ds
01ed:0189	mov	ax, 0x2505
01ed:018c	lds	dx, ptr [0x61]
01ed:0190	int	0x21
01ed:0192	pop	ds
01ed:0193	push	ds
01ed:0194	mov	ax, 0x2506
01ed:0197	lds	dx, ptr [0x65]
01ed:019b	int	0x21
01ed:019d	pop	ds
01ed:019e	ret	
sub_2042 ENDP
*/
void sub_2042()
{
    // coverage: 0x1372-0x139f method sub_2042
    push(ds);
    ax = 0x2500;
    dx = memoryAGet16(ds, 0x0059);
    ds = memoryAGet16(ds, 0x0059 + 2);
    interrupt(0x21);
    ds = pop();
    push(ds);
    ax = 0x2504;
    dx = memoryAGet16(ds, 0x005d);
    ds = memoryAGet16(ds, 0x005d + 2);
    interrupt(0x21);
    ds = pop();
    push(ds);
    ax = 0x2505;
    dx = memoryAGet16(ds, 0x0061);
    ds = memoryAGet16(ds, 0x0061 + 2);
    interrupt(0x21);
    ds = pop();
    push(ds);
    ax = 0x2506;
    dx = memoryAGet16(ds, 0x0065);
    ds = memoryAGet16(ds, 0x0065 + 2);
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 01ed:019f sub_206f()
sub_206f PROC
        	loc_206f:
01ed:019f	mov	ah, 0xff
01ed:01a1	mov	dx, di
01ed:01a3	mov	bx, si
        	loc_2075:
01ed:01a5	cmp	bx, di
01ed:01a7	je	loc_208d
01ed:01a9	cmp	byte ptr [bx], 0xff
01ed:01ac	je	loc_2088
01ed:01ae	cmp	byte ptr [bx + 1], ah
01ed:01b1	ja	loc_2088
01ed:01b3	mov	ah, byte ptr [bx + 1]
01ed:01b6	mov	dx, bx
        	loc_2088:
01ed:01b8	add	bx, 6
01ed:01bb	jmp	loc_2075
        	loc_208d:
01ed:01bd	cmp	dx, di
01ed:01bf	je	loc_20b1
01ed:01c1	mov	bx, dx
01ed:01c3	push	ds
01ed:01c4	pop	es
01ed:01c5	push	es
01ed:01c6	cmp	byte ptr [bx], 0
01ed:01c9	mov	byte ptr [bx], 0xff
01ed:01cc	mov	ds, word ptr cs:[0x1ff]
01ed:01d1	je	loc_20aa
01ed:01d3	lcall	es:[bx + 2]
01ed:01d7	pop	ds
01ed:01d8	jmp	loc_206f
        	loc_20aa:
01ed:01da	call	word ptr es:[bx + 2]
01ed:01de	pop	ds
01ed:01df	jmp	loc_206f
        	loc_20b1:
01ed:01e1	ret	
sub_206f ENDP
*/
void sub_206f()
{
    // coverage: 0x139f-0x13e2 method sub_206f
loc_206f:
    ah = 0xff;
    dx = di;
    bx = si;
loc_2075:
    if (bx == di)
        goto loc_208d;
    if (memoryAGet(ds, bx) == 0xff)
        goto loc_2088;
    if (memoryAGet(ds, bx + 1) > ah)
        goto loc_2088;
    ah = memoryAGet(ds, bx + 1);
    dx = bx;
loc_2088:
    bx += 0x0006;
    goto loc_2075;
loc_208d:
    if (dx == di)
        return;
    bx = dx;
    push(ds);
    es = pop();
    push(es);
    tl = memoryAGet(ds, bx);
    memoryASet(ds, bx, 0xff);
    ds = memoryAGet16(cs, 0x01ff);
    if (stop("check inject: cmp byte ptr [bx], 0") && tl == 0x00)
        goto loc_20aa;
    push(cs);
    cs = memoryAGet16(es, bx + 2 + 2);
    callIndirect(memoryAGet16(es, bx + 2 + 2), memoryAGet16(es, bx + 2));
    assert(cs == 0x01ed);
    ds = pop();
    goto loc_206f;
loc_20aa:
    callIndirect(cs, memoryAGet16(es, bx + 2));
    ds = pop();
    goto loc_206f;
}
/* Assembly listing of 01ed:01e2 sub_20b2()
sub_20b2 PROC
01ed:01e2	mov	ah, 0x40
01ed:01e4	mov	bx, 2
01ed:01e7	int	0x21
01ed:01e9	ret	
sub_20b2 ENDP
*/
void sub_20b2()
{
    // coverage: 0x13e2-0x13ea method sub_20b2
    ah = 0x40;
    bx = 0x0002;
    interrupt(0x21);
}
/* Assembly listing of 01ed:0203 sub_20d3()
sub_20d3 PROC
01ed:0203	push	bp
01ed:0204	mov	bp, sp
01ed:0206	cmp	word ptr [0x6b4c], sp
01ed:020a	ja	loc_20df
01ed:020c	call	0xffffab83
        	loc_20df:
01ed:020f	cmp	byte ptr [bp + 4], 1
01ed:0213	jne	loc_2126
01ed:0215	call	0x416
01ed:0218	mov	ah, 0
01ed:021a	or	ax, ax
01ed:021c	jne	loc_2126
01ed:021e	les	bx, ptr [bp + 6]
01ed:0221	mov	ax, word ptr es:[bx + 6]
01ed:0225	mov	dx, word ptr es:[bx + 4]
01ed:0229	mov	word ptr [0x6be4], dx
01ed:022d	mov	word ptr [0x6be6], ax
01ed:0230	call	0x282
01ed:0233	call	0x7ba7
01ed:0236	call	0xa07
01ed:0239	call	0x258
01ed:023c	call	0x569
01ed:023f	call	0x7a77
01ed:0242	call	0x7db9
01ed:0245	mov	ax, 3
01ed:0248	push	ax
01ed:0249	call	0x7120
01ed:024c	inc	sp
01ed:024d	inc	sp
01ed:024e	xor	ax, ax
01ed:0250	push	ax
01ed:0251	call	0xffff98ba
01ed:0254	inc	sp
01ed:0255	inc	sp
        	loc_2126:
01ed:0256	pop	bp
01ed:0257	ret	
sub_20d3 ENDP
*/
void sub_20d3()
{
    // coverage: 0x1403-0x1458 method sub_20d3
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_20df;
    sub_ca53();
loc_20df:
    if (memoryAGet(ss, bp + 4) != 0x01)
        goto loc_2126;
    sub_22e6();
    ah = 0x00;
    if (ax)
        goto loc_2126;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x6be4, dx);
    memoryASet16(ds, 0x6be6, ax);
    sub_2152();
    sub_9a77();
    sub_28d7();
    sub_2128();
    sub_2439();
    sub_9947();
    sub_9c89();
    ax = 0x0003;
    push(ax);
    sub_8ff0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b78a();
    sp++;
    sp++;
loc_2126:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0258 sub_2128()
sub_2128 PROC
01ed:0258	push	bp
01ed:0259	mov	bp, sp
01ed:025b	cmp	word ptr [0x6b4c], sp
01ed:025f	ja	loc_2134
01ed:0261	call	0xffffab83
        	loc_2134:
01ed:0264	mov	byte ptr [0x79b2], 1
01ed:0269	call	0x535e
01ed:026c	call	0x6de3
        	loc_213f:
01ed:026f	call	0xc18
01ed:0272	cmp	byte ptr [0x9d30], 0
01ed:0277	jne	loc_213f
01ed:0279	cmp	byte ptr [0x856d], 0
01ed:027e	jne	loc_213f
01ed:0280	pop	bp
01ed:0281	ret	
sub_2128 ENDP
*/
void sub_2128()
{
    // coverage: 0x1458-0x1482 method sub_2128
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2134;
    sub_ca53();
loc_2134:
    memoryASet(ds, 0x79b2, 0x01);
    sub_722e();
    sub_8cb3();
loc_213f:
    sub_2ae8();
    if (memoryAGet(ds, 0x9d30) != 0x00)
        goto loc_213f;
    if (memoryAGet(ds, 0x856d) != 0x00)
        goto loc_213f;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0282 sub_2152()
sub_2152 PROC
01ed:0282	push	bp
01ed:0283	mov	bp, sp
01ed:0285	cmp	word ptr [0x6b4c], sp
01ed:0289	ja	loc_215e
01ed:028b	call	0xffffab83
        	loc_215e:
01ed:028e	mov	ax, 0x6a9
01ed:0291	push	ax
01ed:0292	mov	ax, 0x698
01ed:0295	push	ax
01ed:0296	call	0x72ef
01ed:0299	add	sp, 4
01ed:029c	push	ds
01ed:029d	mov	ax, 0x6fac
01ed:02a0	push	ax
01ed:02a1	call	0x7bad
01ed:02a4	add	sp, 4
01ed:02a7	call	0x7cde
01ed:02aa	call	0x798a
01ed:02ad	call	0x7532
01ed:02b0	call	0xffff927c
01ed:02b3	push	ds
01ed:02b4	mov	ax, 0x4cd0
01ed:02b7	push	ax
01ed:02b8	mov	al, 0
01ed:02ba	push	ax
01ed:02bb	call	0x7563
01ed:02be	add	sp, 6
01ed:02c1	call	0x7bd7
01ed:02c4	call	0xffff97a4
01ed:02c7	mov	al, 2
01ed:02c9	push	ax
01ed:02ca	call	0x7bbd
01ed:02cd	inc	sp
01ed:02ce	inc	sp
01ed:02cf	call	0xffff97f1
01ed:02d2	mov	ax, 0xc7
01ed:02d5	push	ax
01ed:02d6	mov	ax, 0x13f
01ed:02d9	push	ax
01ed:02da	xor	ax, ax
01ed:02dc	push	ax
01ed:02dd	push	ax
01ed:02de	call	0xffff9821
01ed:02e1	add	sp, 8
01ed:02e4	mov	ax, 1
01ed:02e7	push	ax
01ed:02e8	call	0xffff9814
01ed:02eb	inc	sp
01ed:02ec	inc	sp
01ed:02ed	mov	ax, 1
01ed:02f0	push	ax
01ed:02f1	mov	ax, 0xe
01ed:02f4	push	ax
01ed:02f5	call	0xffff97c5
01ed:02f8	add	sp, 4
01ed:02fb	push	ds
01ed:02fc	mov	ax, 0x90
01ed:02ff	push	ax
01ed:0300	call	0x7307
01ed:0303	add	sp, 4
01ed:0306	mov	al, 0
01ed:0308	mov	byte ptr [0x6bec], al
01ed:030b	mov	ah, 0
01ed:030d	mov	word ptr [0x7310], ax
01ed:0310	mov	byte ptr [0x7312], al
01ed:0313	mov	byte ptr [0x6bc9], al
01ed:0316	mov	byte ptr [0x7314], al
01ed:0319	mov	al, 0
01ed:031b	mov	byte ptr [0x731b], al
01ed:031e	mov	byte ptr [0x6bba], al
01ed:0321	mov	byte ptr [0x75ed], al
01ed:0324	mov	byte ptr [0x75ec], al
01ed:0327	mov	byte ptr [0x75eb], al
01ed:032a	mov	byte ptr [0x75ce], al
01ed:032d	mov	al, 0
01ed:032f	mov	byte ptr [0x6c34], al
01ed:0332	mov	byte ptr [0x6bc8], al
01ed:0335	mov	ah, 0
01ed:0337	mov	word ptr [0x6bc2], ax
01ed:033a	mov	word ptr [0x6bc0], ax
01ed:033d	mov	word ptr [0x6c40], ax
01ed:0340	mov	word ptr [0x6c3e], ax
01ed:0343	mov	word ptr [0x75c8], ax
01ed:0346	mov	byte ptr [0x6bc5], 1
01ed:034b	mov	byte ptr [0x6bc4], 0x14
01ed:0350	mov	al, 0
01ed:0352	mov	byte ptr [0x6faa], al
01ed:0355	mov	byte ptr [0x75e2], al
01ed:0358	mov	al, 0
01ed:035a	mov	byte ptr [0x75cf], al
01ed:035d	mov	byte ptr [0x75c6], al
01ed:0360	mov	byte ptr [0x6bdf], al
01ed:0363	mov	byte ptr [0x6bc6], al
01ed:0366	xor	ax, ax
01ed:0368	mov	word ptr [0x6bf8], ax
01ed:036b	mov	word ptr [0x6bbe], ax
01ed:036e	mov	word ptr [0x6bbc], ax
01ed:0371	xor	ax, ax
01ed:0373	mov	word ptr [0x6bd6], ax
01ed:0376	mov	word ptr [0x6bce], ax
01ed:0379	xor	ax, ax
01ed:037b	mov	word ptr [0x6bdc], ax
01ed:037e	mov	word ptr [0x6bd0], ax
01ed:0381	xor	ax, ax
01ed:0383	mov	word ptr [0x6bda], ax
01ed:0386	mov	word ptr [0x6bd8], ax
01ed:0389	mov	al, 1
01ed:038b	mov	byte ptr [0x6bf6], al
01ed:038e	mov	byte ptr [0x6c26], al
01ed:0391	xor	ax, ax
01ed:0393	mov	word ptr [0x6be2], ax
01ed:0396	mov	word ptr [0x6be0], ax
01ed:0399	mov	word ptr [0x7316], 0x6c
01ed:039f	mov	al, 0
01ed:03a1	mov	byte ptr [0x6bbb], al
01ed:03a4	mov	byte ptr [0x6bde], al
01ed:03a7	mov	byte ptr [0x6bc7], 9
01ed:03ac	mov	byte ptr [0x75ea], 0
01ed:03b1	mov	ax, word ptr [0x7310]
01ed:03b4	mov	dx, 0x32c
01ed:03b7	imul	dx
01ed:03b9	mov	dx, word ptr [0x6bd4]
01ed:03bd	mov	bx, word ptr [0x6bd2]
01ed:03c1	add	bx, ax
01ed:03c3	mov	word ptr [0x6bca], bx
01ed:03c7	mov	word ptr [0x6bcc], dx
01ed:03cb	mov	ax, word ptr [0x7310]
01ed:03ce	mov	dx, 0xc2
01ed:03d1	imul	dx
01ed:03d3	mov	dx, word ptr [0x6bf4]
01ed:03d7	mov	bx, word ptr [0x6bf2]
01ed:03db	add	bx, ax
01ed:03dd	mov	word ptr [0x75d0], bx
01ed:03e1	mov	word ptr [0x75d2], dx
01ed:03e5	call	0x3ea
01ed:03e8	pop	bp
01ed:03e9	ret	
sub_2152 ENDP
*/
void sub_2152()
{
    // coverage: 0x1482-0x15ea method sub_2152
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_215e;
    sub_ca53();
loc_215e:
    ax = 0x06a9;
    push(ax);
    ax = 0x0698;
    push(ax);
    sub_91bf();
    sp += 0x0004;
    push(ds);
    ax = 0x6fac;
    push(ax);
    sub_9a7d();
    sp += 0x0004;
    sub_9bae();
    sub_985a();
    sub_9402();
    sub_b14c();
    push(ds);
    ax = 0x4cd0;
    push(ax);
    al = 0x00;
    push(ax);
    sub_9433();
    sp += 0x0006;
    sub_9aa7();
    sub_b674();
    al = 0x02;
    push(ax);
    sub_9a8d();
    sp++;
    sp++;
    sub_b6c1();
    ax = 0x00c7;
    push(ax);
    ax = 0x013f;
    push(ax);
    ax = 0;
    push(ax);
    push(ax);
    sub_b6f1();
    sp += 0x0008;
    ax = 0x0001;
    push(ax);
    sub_b6e4();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    ax = 0x000e;
    push(ax);
    sub_b695();
    sp += 0x0004;
    push(ds);
    ax = 0x0090;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    al = 0x00;
    memoryASet(ds, 0x6bec, al);
    ah = 0x00;
    memoryASet16(ds, 0x7310, ax);
    memoryASet(ds, 0x7312, al);
    memoryASet(ds, 0x6bc9, al);
    memoryASet(ds, 0x7314, al);
    al = 0x00;
    memoryASet(ds, 0x731b, al);
    memoryASet(ds, 0x6bba, al);
    memoryASet(ds, 0x75ed, al);
    memoryASet(ds, 0x75ec, al);
    memoryASet(ds, 0x75eb, al);
    memoryASet(ds, 0x75ce, al);
    al = 0x00;
    memoryASet(ds, 0x6c34, al);
    memoryASet(ds, 0x6bc8, al);
    ah = 0x00;
    memoryASet16(ds, 0x6bc2, ax);
    memoryASet16(ds, 0x6bc0, ax);
    memoryASet16(ds, 0x6c40, ax);
    memoryASet16(ds, 0x6c3e, ax);
    memoryASet16(ds, 0x75c8, ax);
    memoryASet(ds, 0x6bc5, 0x01);
    memoryASet(ds, 0x6bc4, 0x14);
    al = 0x00;
    memoryASet(ds, 0x6faa, al);
    memoryASet(ds, 0x75e2, al);
    al = 0x00;
    memoryASet(ds, 0x75cf, al);
    memoryASet(ds, 0x75c6, al);
    memoryASet(ds, 0x6bdf, al);
    memoryASet(ds, 0x6bc6, al);
    ax = 0;
    memoryASet16(ds, 0x6bf8, ax);
    memoryASet16(ds, 0x6bbe, ax);
    memoryASet16(ds, 0x6bbc, ax);
    ax = 0;
    memoryASet16(ds, 0x6bd6, ax);
    memoryASet16(ds, 0x6bce, ax);
    ax = 0;
    memoryASet16(ds, 0x6bdc, ax);
    memoryASet16(ds, 0x6bd0, ax);
    ax = 0;
    memoryASet16(ds, 0x6bda, ax);
    memoryASet16(ds, 0x6bd8, ax);
    al = 0x01;
    memoryASet(ds, 0x6bf6, al);
    memoryASet(ds, 0x6c26, al);
    ax = 0;
    memoryASet16(ds, 0x6be2, ax);
    memoryASet16(ds, 0x6be0, ax);
    memoryASet16(ds, 0x7316, 0x006c);
    al = 0x00;
    memoryASet(ds, 0x6bbb, al);
    memoryASet(ds, 0x6bde, al);
    memoryASet(ds, 0x6bc7, 0x09);
    memoryASet(ds, 0x75ea, 0x00);
    ax = memoryAGet16(ds, 0x7310);
    dx = 0x032c;
    imul(dx);
    dx = memoryAGet16(ds, 0x6bd4);
    bx = memoryAGet16(ds, 0x6bd2);
    bx += ax;
    memoryASet16(ds, 0x6bca, bx);
    memoryASet16(ds, 0x6bcc, dx);
    ax = memoryAGet16(ds, 0x7310);
    dx = 0x00c2;
    imul(dx);
    dx = memoryAGet16(ds, 0x6bf4);
    bx = memoryAGet16(ds, 0x6bf2);
    bx += ax;
    memoryASet16(ds, 0x75d0, bx);
    memoryASet16(ds, 0x75d2, dx);
    sub_22ba();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:03ea sub_22ba()
sub_22ba PROC
01ed:03ea	push	bp
01ed:03eb	mov	bp, sp
01ed:03ed	cmp	word ptr [0x6b4c], sp
01ed:03f1	ja	loc_22c6
01ed:03f3	call	0xffffab83
        	loc_22c6:
01ed:03f6	call	0xffff9424
01ed:03f9	mov	ax, 0xc7
01ed:03fc	push	ax
01ed:03fd	mov	ax, 0x13f
01ed:0400	push	ax
01ed:0401	xor	ax, ax
01ed:0403	push	ax
01ed:0404	push	ax
01ed:0405	call	0xffff9406
01ed:0408	add	sp, 8
01ed:040b	mov	ax, 1
01ed:040e	push	ax
01ed:040f	call	0xffff9410
01ed:0412	inc	sp
01ed:0413	inc	sp
01ed:0414	pop	bp
01ed:0415	ret	
sub_22ba ENDP
*/
void sub_22ba()
{
    // coverage: 0x15ea-0x1616 method sub_22ba
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_22c6;
    sub_ca53();
loc_22c6:
    sub_b2f4();
    ax = 0x00c7;
    push(ax);
    ax = 0x013f;
    push(ax);
    ax = 0;
    push(ax);
    push(ax);
    sub_b2d6();
    sp += 0x0008;
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0416 sub_22e6()
sub_22e6 PROC
01ed:0416	push	bp
01ed:0417	mov	bp, sp
01ed:0419	dec	sp
01ed:041a	dec	sp
01ed:041b	cmp	word ptr [0x6b4c], sp
01ed:041f	ja	loc_22f4
01ed:0421	call	0xffffab83
        	loc_22f4:
01ed:0424	mov	byte ptr [bp - 1], 0
01ed:0428	mov	al, 1
01ed:042a	push	ax
01ed:042b	xor	ax, ax
01ed:042d	mov	dx, 0x7c3
01ed:0430	push	ax
01ed:0431	push	dx
01ed:0432	call	0x808e
01ed:0435	add	sp, 6
01ed:0438	mov	word ptr [0x75da], ax
01ed:043b	mov	word ptr [0x75dc], dx
01ed:043f	mov	al, 1
01ed:0441	push	ax
01ed:0442	xor	ax, ax
01ed:0444	mov	dx, 0x898
01ed:0447	push	ax
01ed:0448	push	dx
01ed:0449	call	0x808e
01ed:044c	add	sp, 6
01ed:044f	mov	word ptr [0x6c2c], ax
01ed:0452	mov	word ptr [0x6c2e], dx
01ed:0456	mov	al, 1
01ed:0458	push	ax
01ed:0459	xor	ax, ax
01ed:045b	mov	dx, 0x7806
01ed:045e	push	ax
01ed:045f	push	dx
01ed:0460	call	0x808e
01ed:0463	add	sp, 6
01ed:0466	mov	word ptr [0x6fa6], ax
01ed:0469	mov	word ptr [0x6fa8], dx
01ed:046d	or	ax, dx
01ed:046f	jne	loc_2345
01ed:0471	mov	byte ptr [bp - 1], 0xff
        	loc_2345:
01ed:0475	mov	al, byte ptr [bp - 1]
01ed:0478	mov	ah, 0
01ed:047a	or	ax, ax
01ed:047c	jne	loc_236e
01ed:047e	mov	al, 1
01ed:0480	push	ax
01ed:0481	mov	ax, 1
01ed:0484	mov	dx, 0x5c70
01ed:0487	push	ax
01ed:0488	push	dx
01ed:0489	call	0x808e
01ed:048c	add	sp, 6
01ed:048f	mov	word ptr [0xa0c6], ax
01ed:0492	mov	word ptr [0xa0c8], dx
01ed:0496	or	ax, dx
01ed:0498	jne	loc_236e
01ed:049a	mov	byte ptr [bp - 1], 0xff
        	loc_236e:
01ed:049e	mov	al, byte ptr [bp - 1]
01ed:04a1	mov	ah, 0
01ed:04a3	or	ax, ax
01ed:04a5	jne	loc_23a8
01ed:04a7	mov	al, 1
01ed:04a9	push	ax
01ed:04aa	xor	ax, ax
01ed:04ac	mov	dx, 0x2f96
01ed:04af	push	ax
01ed:04b0	push	dx
01ed:04b1	call	0x808e
01ed:04b4	add	sp, 6
01ed:04b7	mov	word ptr [0x6be8], ax
01ed:04ba	mov	word ptr [0x6bea], dx
01ed:04be	or	ax, dx
01ed:04c0	jne	loc_2398
01ed:04c2	mov	byte ptr [bp - 1], 0xff
01ed:04c6	jmp	loc_23a8
        	loc_2398:
01ed:04c8	mov	ax, word ptr [0x6bea]
01ed:04cb	mov	dx, word ptr [0x6be8]
01ed:04cf	inc	dx
01ed:04d0	inc	dx
01ed:04d1	mov	word ptr [0x6bd2], dx
01ed:04d5	mov	word ptr [0x6bd4], ax
        	loc_23a8:
01ed:04d8	mov	al, byte ptr [bp - 1]
01ed:04db	mov	ah, 0
01ed:04dd	or	ax, ax
01ed:04df	jne	loc_23d0
01ed:04e1	mov	al, 1
01ed:04e3	push	ax
01ed:04e4	xor	ax, ax
01ed:04e6	mov	dx, 0x500
01ed:04e9	push	ax
01ed:04ea	push	dx
01ed:04eb	call	0x808e
01ed:04ee	add	sp, 6
01ed:04f1	mov	word ptr [0x6c30], ax
01ed:04f4	mov	word ptr [0x6c32], dx
01ed:04f8	or	ax, dx
01ed:04fa	jne	loc_23d0
01ed:04fc	mov	byte ptr [bp - 1], 0xff
        	loc_23d0:
01ed:0500	mov	al, byte ptr [bp - 1]
01ed:0503	mov	ah, 0
01ed:0505	or	ax, ax
01ed:0507	jne	loc_23f8
01ed:0509	mov	al, 1
01ed:050b	push	ax
01ed:050c	xor	ax, ax
01ed:050e	mov	dx, 0x7d63
01ed:0511	push	ax
01ed:0512	push	dx
01ed:0513	call	0x808e
01ed:0516	add	sp, 6
01ed:0519	mov	word ptr [0x7926], ax
01ed:051c	mov	word ptr [0x7928], dx
01ed:0520	or	ax, dx
01ed:0522	jne	loc_23f8
01ed:0524	mov	byte ptr [bp - 1], 0xff
        	loc_23f8:
01ed:0528	mov	al, byte ptr [bp - 1]
01ed:052b	mov	ah, 0
01ed:052d	or	ax, ax
01ed:052f	jne	loc_2432
01ed:0531	mov	al, 1
01ed:0533	push	ax
01ed:0534	xor	ax, ax
01ed:0536	mov	dx, 0xb60
01ed:0539	push	ax
01ed:053a	push	dx
01ed:053b	call	0x808e
01ed:053e	add	sp, 6
01ed:0541	mov	word ptr [0x75de], ax
01ed:0544	mov	word ptr [0x75e0], dx
01ed:0548	or	ax, dx
01ed:054a	jne	loc_2422
01ed:054c	mov	byte ptr [bp - 1], 0xff
01ed:0550	jmp	loc_2432
        	loc_2422:
01ed:0552	mov	ax, word ptr [0x75e0]
01ed:0555	mov	dx, word ptr [0x75de]
01ed:0559	inc	dx
01ed:055a	inc	dx
01ed:055b	mov	word ptr [0x6bf2], dx
01ed:055f	mov	word ptr [0x6bf4], ax
        	loc_2432:
01ed:0562	mov	al, byte ptr [bp - 1]
01ed:0565	mov	sp, bp
01ed:0567	pop	bp
01ed:0568	ret	
sub_22e6 ENDP
*/
void sub_22e6()
{
    // coverage: 0x1616-0x1769 method sub_22e6
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_22f4;
    sub_ca53();
loc_22f4:
    memoryASet(ss, bp - 1, 0x00);
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x07c3;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x75da, ax);
    memoryASet16(ds, 0x75dc, dx);
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x0898;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x6c2c, ax);
    memoryASet16(ds, 0x6c2e, dx);
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x7806;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x6fa6, ax);
    memoryASet16(ds, 0x6fa8, dx);
    ax |= dx;
    if (ax)
        goto loc_2345;
    memoryASet(ss, bp - 1, 0xff);
loc_2345:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_236e;
    al = 0x01;
    push(ax);
    ax = 0x0001;
    dx = 0x5c70;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0xa0c6, ax);
    memoryASet16(ds, 0xa0c8, dx);
    ax |= dx;
    if (ax)
        goto loc_236e;
    memoryASet(ss, bp - 1, 0xff);
loc_236e:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_23a8;
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x2f96;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x6be8, ax);
    memoryASet16(ds, 0x6bea, dx);
    ax |= dx;
    if (ax)
        goto loc_2398;
    memoryASet(ss, bp - 1, 0xff);
    goto loc_23a8;
loc_2398:
    ax = memoryAGet16(ds, 0x6bea);
    dx = memoryAGet16(ds, 0x6be8);
    dx++;
    dx++;
    memoryASet16(ds, 0x6bd2, dx);
    memoryASet16(ds, 0x6bd4, ax);
loc_23a8:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_23d0;
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x0500;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x6c30, ax);
    memoryASet16(ds, 0x6c32, dx);
    ax |= dx;
    if (ax)
        goto loc_23d0;
    memoryASet(ss, bp - 1, 0xff);
loc_23d0:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_23f8;
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x7926, ax);
    memoryASet16(ds, 0x7928, dx);
    ax |= dx;
    if (ax)
        goto loc_23f8;
    memoryASet(ss, bp - 1, 0xff);
loc_23f8:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_2432;
    al = 0x01;
    push(ax);
    ax = 0;
    dx = 0x0b60;
    push(ax);
    push(dx);
    sub_9f5e();
    sp += 0x0006;
    memoryASet16(ds, 0x75de, ax);
    memoryASet16(ds, 0x75e0, dx);
    ax |= dx;
    if (ax)
        goto loc_2422;
    memoryASet(ss, bp - 1, 0xff);
    goto loc_2432;
loc_2422:
    ax = memoryAGet16(ds, 0x75e0);
    dx = memoryAGet16(ds, 0x75de);
    dx++;
    dx++;
    memoryASet16(ds, 0x6bf2, dx);
    memoryASet16(ds, 0x6bf4, ax);
loc_2432:
    al = memoryAGet(ss, bp - 1);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0569 sub_2439()
sub_2439 PROC
01ed:0569	push	bp
01ed:056a	mov	bp, sp
01ed:056c	cmp	word ptr [0x6b4c], sp
01ed:0570	ja	loc_2445
01ed:0572	call	0xffffab83
        	loc_2445:
01ed:0575	push	word ptr [0x75e0]
01ed:0579	push	word ptr [0x75de]
01ed:057d	call	0x809e
01ed:0580	add	sp, 4
01ed:0583	push	word ptr [0x7928]
01ed:0587	push	word ptr [0x7926]
01ed:058b	call	0x809e
01ed:058e	add	sp, 4
01ed:0591	push	word ptr [0x6c32]
01ed:0595	push	word ptr [0x6c30]
01ed:0599	call	0x809e
01ed:059c	add	sp, 4
01ed:059f	push	word ptr [0x6bea]
01ed:05a3	push	word ptr [0x6be8]
01ed:05a7	call	0x809e
01ed:05aa	add	sp, 4
01ed:05ad	push	word ptr [0xa0c8]
01ed:05b1	push	word ptr [0xa0c6]
01ed:05b5	call	0x809e
01ed:05b8	add	sp, 4
01ed:05bb	push	word ptr [0x6fa8]
01ed:05bf	push	word ptr [0x6fa6]
01ed:05c3	call	0x809e
01ed:05c6	add	sp, 4
01ed:05c9	push	word ptr [0x6c2e]
01ed:05cd	push	word ptr [0x6c2c]
01ed:05d1	call	0x809e
01ed:05d4	add	sp, 4
01ed:05d7	push	word ptr [0x75dc]
01ed:05db	push	word ptr [0x75da]
01ed:05df	call	0x809e
01ed:05e2	add	sp, 4
01ed:05e5	pop	bp
01ed:05e6	ret	
sub_2439 ENDP
*/
void sub_2439()
{
    // coverage: 0x1769-0x17e7 method sub_2439
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2445;
    sub_ca53();
loc_2445:
    push(memoryAGet16(ds, 0x75e0));
    push(memoryAGet16(ds, 0x75de));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x6c32));
    push(memoryAGet16(ds, 0x6c30));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x6bea));
    push(memoryAGet16(ds, 0x6be8));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0xa0c8));
    push(memoryAGet16(ds, 0xa0c6));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x6fa8));
    push(memoryAGet16(ds, 0x6fa6));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x6c2e));
    push(memoryAGet16(ds, 0x6c2c));
    sub_9f6e();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x75dc));
    push(memoryAGet16(ds, 0x75da));
    sub_9f6e();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:05e7 sub_24b7()
sub_24b7 PROC
01ed:05e7	push	bp
01ed:05e8	mov	bp, sp
01ed:05ea	cmp	word ptr [0x6b4c], sp
01ed:05ee	ja	loc_24c8
01ed:05f0	call	0xffffab83
01ed:05f3	jmp	loc_24c8
        	loc_24c5:
01ed:05f5	call	0xffff9864
        	loc_24c8:
01ed:05f8	mov	al, byte ptr [bp + 4]
01ed:05fb	dec	byte ptr [bp + 4]
01ed:05fe	or	al, al
01ed:0600	jne	loc_24c5
01ed:0602	pop	bp
01ed:0603	ret	
sub_24b7 ENDP
*/
void sub_24b7()
{
    // coverage: 0x17e7-0x1804 method sub_24b7
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_24c8;
    sub_ca53();
    goto loc_24c8;
loc_24c5:
    sub_b734();
loc_24c8:
    al = memoryAGet(ss, bp + 4);
    memoryASet(ss, bp + 4, memoryAGet(ss, bp + 4) - 1);
    if (al)
        goto loc_24c5;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0604 sub_24d4()
sub_24d4 PROC
01ed:0604	push	bp
01ed:0605	mov	bp, sp
01ed:0607	cmp	word ptr [0x6b4c], sp
01ed:060b	ja	loc_24e0
01ed:060d	call	0xffffab83
        	loc_24e0:
01ed:0610	mov	al, byte ptr [0x75cf]
01ed:0613	mov	ah, 0
01ed:0615	or	ax, ax
01ed:0617	jne	loc_24f9
01ed:0619	les	bx, ptr [0x6bca]
01ed:061d	cmp	word ptr es:[bx + 0x1c], 0
01ed:0622	je	loc_24f9
01ed:0624	call	0x63b
01ed:0627	jmp	loc_24fe
        	loc_24f9:
01ed:0629	mov	byte ptr [0x75cf], 1
        	loc_24fe:
01ed:062e	push	ds
01ed:062f	mov	ax, 0x578
01ed:0632	push	ax
01ed:0633	call	0x8d1
01ed:0636	add	sp, 4
01ed:0639	pop	bp
01ed:063a	ret	
sub_24d4 ENDP
*/
void sub_24d4()
{
    // coverage: 0x1804-0x183b method sub_24d4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_24e0;
    sub_ca53();
loc_24e0:
    al = memoryAGet(ds, 0x75cf);
    ah = 0x00;
    if (ax)
        goto loc_24f9;
    bx = memoryAGet16(ds, 0x6bca);
    es = memoryAGet16(ds, 0x6bca + 2);
    if (memoryAGet16(es, bx + 28) == 0x0000)
        goto loc_24f9;
    sub_250b();
    goto loc_24fe;
loc_24f9:
    memoryASet(ds, 0x75cf, 0x01);
loc_24fe:
    push(ds);
    ax = 0x0578;
    push(ax);
    sub_27a1();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:063b sub_250b()
sub_250b PROC
01ed:063b	push	bp
01ed:063c	mov	bp, sp
01ed:063e	sub	sp, 4
01ed:0641	push	si
01ed:0642	push	di
01ed:0643	cmp	word ptr [0x6b4c], sp
01ed:0647	ja	loc_251c
01ed:0649	call	0xffffab83
        	loc_251c:
01ed:064c	mov	byte ptr [bp - 1], 0
01ed:0650	jmp	loc_255c
        	loc_2522:
01ed:0652	mov	al, byte ptr [bp - 1]
01ed:0655	mov	ah, 0
01ed:0657	shl	ax, 1
01ed:0659	les	bx, ptr [0x6bca]
01ed:065d	add	bx, ax
01ed:065f	mov	si, word ptr es:[bx]
01ed:0662	mov	ax, si
01ed:0664	and	ax, 0xff
01ed:0667	mov	cl, 8
01ed:0669	shl	ax, cl
01ed:066b	mov	word ptr [bp - 4], ax
01ed:066e	mov	ax, si
01ed:0670	and	ax, 0xff00
01ed:0673	shr	ax, cl
01ed:0675	mov	di, ax
01ed:0677	mov	al, byte ptr [bp - 1]
01ed:067a	mov	ah, 0
01ed:067c	shl	ax, 1
01ed:067e	mov	dx, word ptr [bp - 4]
01ed:0681	or	dx, di
01ed:0683	mov	bx, ax
01ed:0685	mov	word ptr [bx + 0x578], dx
01ed:0689	inc	byte ptr [bp - 1]
        	loc_255c:
01ed:068c	cmp	byte ptr [bp - 1], 0x10
01ed:0690	jb	loc_2522
01ed:0692	pop	di
01ed:0693	pop	si
01ed:0694	mov	sp, bp
01ed:0696	pop	bp
01ed:0697	ret	
sub_250b ENDP
*/
void sub_250b()
{
    // coverage: 0x183b-0x1898 method sub_250b
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_251c;
    sub_ca53();
loc_251c:
    memoryASet(ss, bp - 1, 0x00);
    goto loc_255c;
loc_2522:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    bx = memoryAGet16(ds, 0x6bca);
    es = memoryAGet16(ds, 0x6bca + 2);
    bx += ax;
    si = memoryAGet16(es, bx);
    ax = si;
    ax &= 0x00ff;
    cl = 0x08;
    ax <<= cl;
    memoryASet16(ss, bp - 4, ax);
    ax = si;
    ax &= 0xff00;
    ax >>= cl;
    di = ax;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    dx = memoryAGet16(ss, bp - 4);
    dx |= di;
    bx = ax;
    memoryASet16(ds, bx + 1400, dx);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_255c:
    if (memoryAGet(ss, bp - 1) < 0x10)
        goto loc_2522;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:07f0 sub_26c0()
sub_26c0 PROC
01ed:07f0	push	bp
01ed:07f1	mov	bp, sp
01ed:07f3	cmp	word ptr [0x6b4c], sp
01ed:07f7	ja	loc_26cc
01ed:07f9	call	0xffffab83
        	loc_26cc:
01ed:07fc	push	word ptr [bp + 0xa]
01ed:07ff	push	word ptr [bp + 8]
01ed:0802	call	0xffff9837
01ed:0805	add	sp, 4
01ed:0808	push	word ptr [bp + 6]
01ed:080b	push	word ptr [bp + 4]
01ed:080e	call	0xffff9804
01ed:0811	add	sp, 4
01ed:0814	pop	bp
01ed:0815	ret	
sub_26c0 ENDP
*/
void sub_26c0()
{
    // coverage: 0x19f0-0x1a16 method sub_26c0
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_26cc;
    sub_ca53();
loc_26cc:
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    sub_b707();
    sp += 0x0004;
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_b6d4();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0816 sub_26e6()
sub_26e6 PROC
01ed:0816	push	bp
01ed:0817	mov	bp, sp
01ed:0819	sub	sp, 0xc
01ed:081c	cmp	word ptr [0x6b4c], sp
01ed:0820	ja	loc_26f5
01ed:0822	call	0xffffab83
        	loc_26f5:
01ed:0825	cmp	byte ptr [bp + 8], 7
01ed:0829	jbe	loc_26fe
01ed:082b	jmp	loc_278c
        	loc_26fe:
01ed:082e	mov	byte ptr [bp - 0xb], 0
01ed:0832	jmp	loc_2717
        	loc_2704:
01ed:0834	mov	al, byte ptr [bp - 0xb]
01ed:0837	inc	byte ptr [bp - 0xb]
01ed:083a	mov	ah, 0
01ed:083c	lea	dx, [bp - 0xa]
01ed:083f	add	ax, dx
01ed:0841	mov	bx, ax
01ed:0843	mov	byte ptr ss:[bx], 0x20
        	loc_2717:
01ed:0847	mov	al, byte ptr [bp - 0xb]
01ed:084a	cmp	al, byte ptr [bp + 8]
01ed:084d	jbe	loc_2704
01ed:084f	mov	al, byte ptr [bp + 8]
01ed:0852	mov	ah, 0
01ed:0854	lea	dx, [bp - 0xa]
01ed:0857	add	ax, dx
01ed:0859	mov	bx, ax
01ed:085b	mov	byte ptr ss:[bx], 0
01ed:085f	jmp	loc_2776
        	loc_2731:
01ed:0861	mov	al, byte ptr [bp + 4]
01ed:0864	mov	byte ptr [bp - 1], al
01ed:0867	xor	ax, ax
01ed:0869	mov	dx, 0xa
01ed:086c	push	ax
01ed:086d	push	dx
01ed:086e	push	word ptr [bp + 6]
01ed:0871	push	word ptr [bp + 4]
01ed:0874	call	0xffffa8ee
01ed:0877	mov	word ptr [bp + 4], ax
01ed:087a	mov	bx, ax
01ed:087c	mov	word ptr [bp + 6], dx
01ed:087f	mov	cx, dx
01ed:0881	xor	dx, dx
01ed:0883	mov	ax, 0xa
01ed:0886	call	0xffffaa14
01ed:0889	mov	dl, byte ptr [bp - 1]
01ed:088c	sub	dl, al
01ed:088e	mov	byte ptr [bp - 1], dl
01ed:0891	mov	al, byte ptr [bp + 8]
01ed:0894	mov	ah, 0
01ed:0896	lea	dx, [bp - 0xa]
01ed:0899	add	ax, dx
01ed:089b	mov	dl, byte ptr [bp - 1]
01ed:089e	add	dl, 0x30
01ed:08a1	mov	bx, ax
01ed:08a3	mov	byte ptr ss:[bx], dl
        	loc_2776:
01ed:08a6	mov	al, byte ptr [bp + 8]
01ed:08a9	dec	byte ptr [bp + 8]
01ed:08ac	or	al, al
01ed:08ae	ja	loc_2731
01ed:08b0	push	word ptr [bp + 0xc]
01ed:08b3	push	word ptr [bp + 0xa]
01ed:08b6	push	ss
01ed:08b7	lea	ax, [bp - 0xa]
01ed:08ba	jmp	loc_2796
        	loc_278c:
01ed:08bc	push	word ptr [bp + 0xc]
01ed:08bf	push	word ptr [bp + 0xa]
01ed:08c2	push	ds
01ed:08c3	mov	ax, 0x62e
        	loc_2796:
01ed:08c6	push	ax
01ed:08c7	call	0x7f0
01ed:08ca	add	sp, 8
01ed:08cd	mov	sp, bp
01ed:08cf	pop	bp
01ed:08d0	ret	
sub_26e6 ENDP
*/
void sub_26e6()
{
    // coverage: 0x1a16-0x1ad1 method sub_26e6
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000c;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_26f5;
    sub_ca53();
loc_26f5:
    if (memoryAGet(ss, bp + 8) <= 0x07)
        goto loc_26fe;
    goto loc_278c;
loc_26fe:
    memoryASet(ss, bp - 11, 0x00);
    goto loc_2717;
loc_2704:
    al = memoryAGet(ss, bp - 11);
    memoryASet(ss, bp - 11, memoryAGet(ss, bp - 11) + 1);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    bx = ax;
    memoryASet(ss, bx, 0x20);
loc_2717:
    al = memoryAGet(ss, bp - 11);
    if (al <= memoryAGet(ss, bp + 8))
        goto loc_2704;
    al = memoryAGet(ss, bp + 8);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    bx = ax;
    memoryASet(ss, bx, 0x00);
    goto loc_2776;
loc_2731:
    al = memoryAGet(ss, bp + 4);
    memoryASet(ss, bp - 1, al);
    ax = 0;
    dx = 0x000a;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_c7be();
    memoryASet16(ss, bp + 4, ax);
    bx = ax;
    memoryASet16(ss, bp + 6, dx);
    cx = dx;
    dx = 0;
    ax = 0x000a;
    sub_c8e4();
    dl = memoryAGet(ss, bp - 1);
    dl -= al;
    memoryASet(ss, bp - 1, dl);
    al = memoryAGet(ss, bp + 8);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    dl = memoryAGet(ss, bp - 1);
    dl += 0x30;
    bx = ax;
    memoryASet(ss, bx, dl);
loc_2776:
    al = memoryAGet(ss, bp + 8);
    memoryASet(ss, bp + 8, memoryAGet(ss, bp + 8) - 1);
    if (stop(/*condition!*/))
        goto loc_2731;
    push(memoryAGet16(ss, bp + 12));
    push(memoryAGet16(ss, bp + 10));
    push(ss);
    ax = bp - 0xa;
    goto loc_2796;
loc_278c:
    push(memoryAGet16(ss, bp + 12));
    push(memoryAGet16(ss, bp + 10));
    push(ds);
    ax = 0x062e;
loc_2796:
    push(ax);
    sub_26c0();
    sp += 0x0008;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:08d1 sub_27a1()
sub_27a1 PROC
01ed:08d1	push	bp
01ed:08d2	mov	bp, sp
01ed:08d4	sub	sp, 0xa
01ed:08d7	push	si
01ed:08d8	cmp	word ptr [0x6b4c], sp
01ed:08dc	ja	loc_27b1
01ed:08de	call	0xffffab83
        	loc_27b1:
01ed:08e1	mov	word ptr [bp - 4], 0x6c42
01ed:08e6	mov	word ptr [bp - 2], ds
01ed:08e9	cmp	word ptr [0x541d], 1
01ed:08ee	jne	loc_27f6
01ed:08f0	mov	word ptr [0x9b96], 0x6c42
01ed:08f6	mov	word ptr [0x9b98], ds
01ed:08fa	mov	byte ptr [bp - 6], 0
01ed:08fe	jmp	loc_27ed
        	loc_27d0:
01ed:0900	mov	al, byte ptr [bp - 6]
01ed:0903	mov	ah, 0
01ed:0905	les	bx, ptr [0x9b96]
01ed:0909	add	bx, ax
01ed:090b	mov	al, byte ptr [bp - 6]
01ed:090e	mov	ah, 0
01ed:0910	mov	si, ax
01ed:0912	mov	al, byte ptr [si + 0x70e]
01ed:0916	mov	byte ptr es:[bx + 0x23], al
01ed:091a	inc	byte ptr [bp - 6]
        	loc_27ed:
01ed:091d	cmp	byte ptr [bp - 6], 0x10
01ed:0921	jb	loc_27d0
01ed:0923	jmp	loc_28b9
        	loc_27f6:
01ed:0926	mov	byte ptr [bp - 5], 0
01ed:092a	jmp	loc_28b0
        	loc_27fd:
01ed:092d	mov	al, byte ptr [bp - 5]
01ed:0930	mov	ah, 0
01ed:0932	shl	ax, 1
01ed:0934	les	bx, ptr [bp + 4]
01ed:0937	add	bx, ax
01ed:0939	mov	ax, word ptr es:[bx]
01ed:093c	mov	cl, 8
01ed:093e	shr	ax, cl
01ed:0940	mov	byte ptr [bp - 7], al
01ed:0943	mov	al, byte ptr [bp - 5]
01ed:0946	mov	ah, 0
01ed:0948	shl	ax, 1
01ed:094a	mov	bx, word ptr [bp + 4]
01ed:094d	add	bx, ax
01ed:094f	mov	ax, word ptr es:[bx]
01ed:0952	mov	dl, byte ptr [0x75eb]
01ed:0956	mov	dh, 0
01ed:0958	shl	dx, cl
01ed:095a	sub	ax, dx
01ed:095c	mov	cl, 4
01ed:095e	shr	ax, cl
01ed:0960	mov	byte ptr [bp - 8], al
01ed:0963	mov	al, byte ptr [bp - 5]
01ed:0966	mov	ah, 0
01ed:0968	shl	ax, 1
01ed:096a	mov	bx, word ptr [bp + 4]
01ed:096d	add	bx, ax
01ed:096f	mov	al, byte ptr es:[bx]
01ed:0972	mov	dl, byte ptr [0x75eb]
01ed:0976	mov	cl, 8
01ed:0978	shl	dl, cl
01ed:097a	mov	bl, byte ptr [0x75ec]
01ed:097e	mov	cl, 4
01ed:0980	shl	bl, cl
01ed:0982	add	dl, bl
01ed:0984	sub	al, dl
01ed:0986	mov	byte ptr [bp - 9], al
01ed:0989	mov	al, byte ptr [bp - 5]
01ed:098c	mov	ah, 0
01ed:098e	mov	dx, 3
01ed:0991	imul	dx
01ed:0993	les	bx, ptr [bp - 4]
01ed:0996	add	bx, ax
01ed:0998	mov	al, byte ptr [bp - 7]
01ed:099b	shl	al, 1
01ed:099d	shl	al, 1
01ed:099f	shl	al, 1
01ed:09a1	mov	byte ptr es:[bx + 0x33], al
01ed:09a5	mov	al, byte ptr [bp - 5]
01ed:09a8	mov	ah, 0
01ed:09aa	mov	dx, 3
01ed:09ad	imul	dx
01ed:09af	mov	bx, word ptr [bp - 4]
01ed:09b2	add	bx, ax
01ed:09b4	mov	al, byte ptr [bp - 8]
01ed:09b7	shl	al, 1
01ed:09b9	shl	al, 1
01ed:09bb	shl	al, 1
01ed:09bd	mov	byte ptr es:[bx + 0x34], al
01ed:09c1	mov	al, byte ptr [bp - 5]
01ed:09c4	mov	ah, 0
01ed:09c6	mov	dx, 3
01ed:09c9	imul	dx
01ed:09cb	mov	bx, word ptr [bp - 4]
01ed:09ce	add	bx, ax
01ed:09d0	mov	al, byte ptr [bp - 9]
01ed:09d3	shl	al, 1
01ed:09d5	shl	al, 1
01ed:09d7	shl	al, 1
01ed:09d9	mov	byte ptr es:[bx + 0x35], al
01ed:09dd	inc	byte ptr [bp - 5]
        	loc_28b0:
01ed:09e0	cmp	byte ptr [bp - 5], 0x10
01ed:09e4	jae	loc_28b9
01ed:09e6	jmp	loc_27fd
        	loc_28b9:
01ed:09e9	xor	ax, ax
01ed:09eb	push	ax
01ed:09ec	push	ds
01ed:09ed	mov	ax, 0x6c42
01ed:09f0	push	ax
01ed:09f1	call	0x7b93
01ed:09f4	add	sp, 6
01ed:09f7	xor	ax, ax
01ed:09f9	push	ax
01ed:09fa	call	0x7bca
01ed:09fd	inc	sp
01ed:09fe	inc	sp
01ed:09ff	call	0xffff9864
01ed:0a02	pop	si
01ed:0a03	mov	sp, bp
01ed:0a05	pop	bp
01ed:0a06	ret	
sub_27a1 ENDP
*/
void sub_27a1()
{
    // coverage: 0x1ad1-0x1c07 method sub_27a1
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000a;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_27b1;
    sub_ca53();
loc_27b1:
    memoryASet16(ss, bp - 4, 0x6c42);
    memoryASet16(ss, bp - 2, ds);
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_27f6;
    memoryASet16(ds, 0x9b96, 0x6c42);
    memoryASet16(ds, 0x9b98, ds);
    memoryASet(ss, bp - 6, 0x00);
    goto loc_27ed;
loc_27d0:
    al = memoryAGet(ss, bp - 6);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 6);
    ah = 0x00;
    si = ax;
    al = memoryAGet(ds, si + 1806);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 6, memoryAGet(ss, bp - 6) + 1);
loc_27ed:
    if (memoryAGet(ss, bp - 6) < 0x10)
        goto loc_27d0;
    goto loc_28b9;
loc_27f6:
    memoryASet(ss, bp - 5, 0x00);
    goto loc_28b0;
loc_27fd:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    ax <<= 1;
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    bx += ax;
    ax = memoryAGet16(es, bx);
    cl = 0x08;
    ax >>= cl;
    memoryASet(ss, bp - 7, al);
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    ax <<= 1;
    bx = memoryAGet16(ss, bp + 4);
    bx += ax;
    ax = memoryAGet16(es, bx);
    dl = memoryAGet(ds, 0x75eb);
    dh = 0x00;
    dx <<= cl;
    ax -= dx;
    cl = 0x04;
    ax >>= cl;
    memoryASet(ss, bp - 8, al);
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    ax <<= 1;
    bx = memoryAGet16(ss, bp + 4);
    bx += ax;
    al = memoryAGet(es, bx);
    dl = memoryAGet(ds, 0x75eb);
    cl = 0x08;
    dl <<= cl;
    bl = memoryAGet(ds, 0x75ec);
    cl = 0x04;
    bl <<= cl;
    dl += bl;
    al -= dl;
    memoryASet(ss, bp - 9, al);
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    dx = 0x0003;
    imul(dx);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 7);
    al <<= 1;
    al <<= 1;
    al <<= 1;
    memoryASet(es, bx + 51, al);
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    dx = 0x0003;
    imul(dx);
    bx = memoryAGet16(ss, bp - 4);
    bx += ax;
    al = memoryAGet(ss, bp - 8);
    al <<= 1;
    al <<= 1;
    al <<= 1;
    memoryASet(es, bx + 52, al);
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    dx = 0x0003;
    imul(dx);
    bx = memoryAGet16(ss, bp - 4);
    bx += ax;
    al = memoryAGet(ss, bp - 9);
    al <<= 1;
    al <<= 1;
    al <<= 1;
    memoryASet(es, bx + 53, al);
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) + 1);
loc_28b0:
    if (memoryAGet(ss, bp - 5) >= 0x10)
        goto loc_28b9;
    goto loc_27fd;
loc_28b9:
    ax = 0;
    push(ax);
    push(ds);
    ax = 0x6c42;
    push(ax);
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    sub_b734();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0a07 sub_28d7()
sub_28d7 PROC
01ed:0a07	push	bp
01ed:0a08	mov	bp, sp
01ed:0a0a	push	si
01ed:0a0b	cmp	word ptr [0x6b4c], sp
01ed:0a0f	ja	loc_28e4
01ed:0a11	call	0xffffab83
        	loc_28e4:
01ed:0a14	mov	ax, 4
01ed:0a17	push	ax
01ed:0a18	push	ax
01ed:0a19	call	0x736f
01ed:0a1c	add	sp, 4
01ed:0a1f	mov	si, ax
01ed:0a21	xor	ax, ax
01ed:0a23	push	ax
01ed:0a24	push	word ptr [0xc0]
01ed:0a28	push	word ptr [0xbe]
01ed:0a2c	push	word ptr [0x75dc]
01ed:0a30	push	word ptr [0x75da]
01ed:0a34	push	si
01ed:0a35	call	0x745e
01ed:0a38	add	sp, 0xc
01ed:0a3b	push	si
01ed:0a3c	call	0x7319
01ed:0a3f	inc	sp
01ed:0a40	inc	sp
01ed:0a41	push	word ptr [0x75dc]
01ed:0a45	push	word ptr [0x75da]
01ed:0a49	call	0xffff97d5
01ed:0a4c	add	sp, 4
01ed:0a4f	mov	ax, 4
01ed:0a52	push	ax
01ed:0a53	mov	ax, 9
01ed:0a56	push	ax
01ed:0a57	call	0x736f
01ed:0a5a	add	sp, 4
01ed:0a5d	mov	si, ax
01ed:0a5f	xor	ax, ax
01ed:0a61	push	ax
01ed:0a62	push	word ptr [0xf2]
01ed:0a66	push	word ptr [0xf0]
01ed:0a6a	push	word ptr [0x6c2e]
01ed:0a6e	push	word ptr [0x6c2c]
01ed:0a72	push	si
01ed:0a73	call	0x745e
01ed:0a76	add	sp, 0xc
01ed:0a79	push	si
01ed:0a7a	call	0x7319
01ed:0a7d	inc	sp
01ed:0a7e	inc	sp
01ed:0a7f	push	word ptr [0x6c2e]
01ed:0a83	push	word ptr [0x6c2c]
01ed:0a87	call	0xffff93d8
01ed:0a8a	add	sp, 4
01ed:0a8d	pop	si
01ed:0a8e	pop	bp
01ed:0a8f	ret	
sub_28d7 ENDP
*/
void sub_28d7()
{
    // coverage: 0x1c07-0x1c90 method sub_28d7
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_28e4;
    sub_ca53();
loc_28e4:
    ax = 0x0004;
    push(ax);
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x00c0));
    push(memoryAGet16(ds, 0x00be));
    push(memoryAGet16(ds, 0x75dc));
    push(memoryAGet16(ds, 0x75da));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    push(memoryAGet16(ds, 0x75dc));
    push(memoryAGet16(ds, 0x75da));
    sub_b6a5();
    sp += 0x0004;
    ax = 0x0004;
    push(ax);
    ax = 0x0009;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x00f2));
    push(memoryAGet16(ds, 0x00f0));
    push(memoryAGet16(ds, 0x6c2e));
    push(memoryAGet16(ds, 0x6c2c));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    push(memoryAGet16(ds, 0x6c2e));
    push(memoryAGet16(ds, 0x6c2c));
    sub_b2a8();
    sp += 0x0004;
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0a90 sub_2960()
sub_2960 PROC
01ed:0a90	push	bp
01ed:0a91	mov	bp, sp
01ed:0a93	dec	sp
01ed:0a94	dec	sp
01ed:0a95	push	si
01ed:0a96	push	di
01ed:0a97	cmp	word ptr [0x6b4c], sp
01ed:0a9b	ja	loc_2970
01ed:0a9d	call	0xffffab83
        	loc_2970:
01ed:0aa0	mov	ax, word ptr [0x6fa8]
01ed:0aa3	mov	dx, word ptr [0x6fa6]
01ed:0aa7	add	dx, 6
01ed:0aaa	les	bx, ptr [0x574]
01ed:0aae	mov	word ptr es:[bx + 2], dx
01ed:0ab2	mov	word ptr es:[bx + 4], ax
01ed:0ab6	mov	word ptr es:[bx + 0xa], 0x14
01ed:0abc	mov	word ptr es:[bx + 0xc], 0x18
01ed:0ac2	mov	ax, word ptr [bp + 0xa]
01ed:0ac5	mov	word ptr es:[bx + 0xe], ax
01ed:0ac9	mov	word ptr es:[bx + 0x1c], 6
01ed:0acf	mov	word ptr es:[bx + 0x1e], 1
01ed:0ad5	cmp	word ptr [bp + 8], 0x18
01ed:0ad9	jne	loc_29b3
01ed:0adb	mov	word ptr es:[bx + 0x20], 1
01ed:0ae1	jmp	loc_29bd
        	loc_29b3:
01ed:0ae3	les	bx, ptr [0x574]
01ed:0ae7	mov	word ptr es:[bx + 0x20], 2
        	loc_29bd:
01ed:0aed	cmp	byte ptr [bp + 4], 0xf0
01ed:0af1	jbe	loc_29d1
01ed:0af3	mov	byte ptr [bp - 2], 1
01ed:0af7	mov	al, 0xfb
01ed:0af9	sub	al, byte ptr [bp + 4]
01ed:0afc	mov	byte ptr [bp - 1], al
01ed:0aff	jmp	loc_2a4a
        	loc_29d1:
01ed:0b01	mov	byte ptr [bp - 2], 0
01ed:0b05	mov	byte ptr [bp - 1], 1
01ed:0b09	jmp	loc_2a4a
        	loc_29db:
01ed:0b0b	mov	ax, word ptr [bp + 6]
01ed:0b0e	mov	dx, 0x27
01ed:0b11	imul	dx
01ed:0b13	les	bx, ptr [0x6bca]
01ed:0b17	add	bx, ax
01ed:0b19	mov	ax, word ptr [bp + 8]
01ed:0b1c	sar	ax, 1
01ed:0b1e	mov	dx, 3
01ed:0b21	imul	dx
01ed:0b23	add	bx, ax
01ed:0b25	mov	al, byte ptr [bp - 2]
01ed:0b28	mov	ah, 0
01ed:0b2a	add	bx, ax
01ed:0b2c	mov	al, byte ptr es:[bx + 0x20]
01ed:0b30	add	al, 0xff
01ed:0b32	mov	byte ptr [bp + 4], al
01ed:0b35	mov	ah, 0
01ed:0b37	mov	bx, 0x14
01ed:0b3a	cdq	
01ed:0b3b	idiv	bx
01ed:0b3d	shl	ax, 1
01ed:0b3f	mov	si, ax
01ed:0b41	mov	dx, 0xa
01ed:0b44	imul	dx
01ed:0b46	mov	dl, byte ptr [bp + 4]
01ed:0b49	mov	dh, 0
01ed:0b4b	sub	dx, ax
01ed:0b4d	mov	di, dx
01ed:0b4f	les	bx, ptr [0x574]
01ed:0b53	mov	word ptr es:[bx + 6], di
01ed:0b57	mov	word ptr es:[bx + 8], si
01ed:0b5b	mov	ax, word ptr [bp + 6]
01ed:0b5e	mov	word ptr es:[bx + 0x14], ax
01ed:0b62	mov	ax, word ptr [bp + 8]
01ed:0b65	mov	word ptr es:[bx + 0x16], ax
01ed:0b69	push	word ptr [0x576]
01ed:0b6d	push	word ptr [0x574]
01ed:0b71	call	0x80bc
01ed:0b74	add	sp, 4
01ed:0b77	inc	byte ptr [bp - 2]
        	loc_2a4a:
01ed:0b7a	mov	al, byte ptr [bp - 2]
01ed:0b7d	cmp	al, byte ptr [bp - 1]
01ed:0b80	jb	loc_29db
01ed:0b82	pop	di
01ed:0b83	pop	si
01ed:0b84	mov	sp, bp
01ed:0b86	pop	bp
01ed:0b87	ret	
sub_2960 ENDP
*/
void sub_2960()
{
    // coverage: 0x1c90-0x1d88 method sub_2960
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2970;
    sub_ca53();
loc_2970:
    ax = memoryAGet16(ds, 0x6fa8);
    dx = memoryAGet16(ds, 0x6fa6);
    dx += 0x0006;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0018);
    ax = memoryAGet16(ss, bp + 10);
    memoryASet16(es, bx + 14, ax);
    memoryASet16(es, bx + 28, 0x0006);
    memoryASet16(es, bx + 30, 0x0001);
    if (memoryAGet16(ss, bp + 8) != 0x0018)
        goto loc_29b3;
    memoryASet16(es, bx + 32, 0x0001);
    goto loc_29bd;
loc_29b3:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 32, 0x0002);
loc_29bd:
    if (memoryAGet(ss, bp + 4) <= 0xf0)
        goto loc_29d1;
    memoryASet(ss, bp - 2, 0x01);
    al = 0xfb;
    al -= memoryAGet(ss, bp + 4);
    memoryASet(ss, bp - 1, al);
    goto loc_2a4a;
loc_29d1:
    memoryASet(ss, bp - 2, 0x00);
    memoryASet(ss, bp - 1, 0x01);
    goto loc_2a4a;
loc_29db:
    ax = memoryAGet16(ss, bp + 6);
    dx = 0x0027;
    imul(dx);
    bx = memoryAGet16(ds, 0x6bca);
    es = memoryAGet16(ds, 0x6bca + 2);
    bx += ax;
    ax = memoryAGet16(ss, bp + 8);
    ax = sar(ax, 1);
    dx = 0x0003;
    imul(dx);
    bx += ax;
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(es, bx + 32);
    al += 0xff;
    memoryASet(ss, bp + 4, al);
    ah = 0x00;
    bx = 0x0014;
    dx = ax & 0x8000 ? 0xffff : 0x0000;
    idiv(bx);
    ax <<= 1;
    si = ax;
    dx = 0x000a;
    imul(dx);
    dl = memoryAGet(ss, bp + 4);
    dh = 0x00;
    dx -= ax;
    di = dx;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 6, di);
    memoryASet16(es, bx + 8, si);
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(es, bx + 20, ax);
    ax = memoryAGet16(ss, bp + 8);
    memoryASet16(es, bx + 22, ax);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
loc_2a4a:
    al = memoryAGet(ss, bp - 2);
    if (al < memoryAGet(ss, bp - 1))
        goto loc_29db;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0b88 sub_2a58()
sub_2a58 PROC
01ed:0b88	push	bp
01ed:0b89	mov	bp, sp
01ed:0b8b	cmp	word ptr [0x6b4c], sp
01ed:0b8f	ja	loc_2a64
01ed:0b91	call	0xffffab83
        	loc_2a64:
01ed:0b94	les	bx, ptr [0x574]
01ed:0b98	mov	ax, word ptr [bp + 8]
01ed:0b9b	mov	word ptr es:[bx + 0xe], ax
01ed:0b9f	mov	ax, word ptr [bp + 4]
01ed:0ba2	mov	word ptr es:[bx + 0x14], ax
01ed:0ba6	mov	ax, word ptr [bp + 6]
01ed:0ba9	mov	word ptr es:[bx + 0x16], ax
01ed:0bad	mov	word ptr es:[bx + 0x1c], 0
01ed:0bb3	mov	word ptr es:[bx + 0x1e], 1
01ed:0bb9	cmp	word ptr [bp + 6], 0x18
01ed:0bbd	jne	loc_2a97
01ed:0bbf	mov	word ptr es:[bx + 0x20], 1
01ed:0bc5	jmp	loc_2aa1
        	loc_2a97:
01ed:0bc7	les	bx, ptr [0x574]
01ed:0bcb	mov	word ptr es:[bx + 0x20], 2
        	loc_2aa1:
01ed:0bd1	les	bx, ptr [0x574]
01ed:0bd5	mov	byte ptr es:[bx + 0x22], 0
01ed:0bda	mov	byte ptr es:[bx + 0x23], 0
01ed:0bdf	mov	byte ptr es:[bx + 0x24], 0
01ed:0be4	mov	byte ptr es:[bx + 0x25], 0
01ed:0be9	push	word ptr [0x576]
01ed:0bed	push	word ptr [0x574]
01ed:0bf1	call	0x7b4a
01ed:0bf4	add	sp, 4
01ed:0bf7	pop	bp
01ed:0bf8	ret	
sub_2a58 ENDP
*/
void sub_2a58()
{
    // coverage: 0x1d88-0x1df9 method sub_2a58
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2a64;
    sub_ca53();
loc_2a64:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    ax = memoryAGet16(ss, bp + 8);
    memoryASet16(es, bx + 14, ax);
    ax = memoryAGet16(ss, bp + 4);
    memoryASet16(es, bx + 20, ax);
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(es, bx + 22, ax);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0001);
    if (memoryAGet16(ss, bp + 6) != 0x0018)
        goto loc_2a97;
    memoryASet16(es, bx + 32, 0x0001);
    goto loc_2aa1;
loc_2a97:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 32, 0x0002);
loc_2aa1:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet(es, bx + 34, 0x00);
    memoryASet(es, bx + 35, 0x00);
    memoryASet(es, bx + 36, 0x00);
    memoryASet(es, bx + 37, 0x00);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0bf9 sub_2ac9()
sub_2ac9 PROC
01ed:0bf9	push	bp
01ed:0bfa	mov	bp, sp
01ed:0bfc	cmp	word ptr [0x6b4c], sp
01ed:0c00	ja	loc_2ad5
01ed:0c02	call	0xffffab83
        	loc_2ad5:
01ed:0c05	call	0x32b0
01ed:0c08	call	0x2a78
01ed:0c0b	call	0x31de
01ed:0c0e	mov	al, 0
01ed:0c10	mov	byte ptr [0x9d30], al
01ed:0c13	mov	byte ptr [0x856d], al
01ed:0c16	pop	bp
01ed:0c17	ret	
sub_2ac9 ENDP
*/
void sub_2ac9()
{
    // coverage: 0x1df9-0x1e18 method sub_2ac9
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2ad5;
    sub_ca53();
loc_2ad5:
    sub_5180();
    sub_4948();
    sub_50ae();
    al = 0x00;
    memoryASet(ds, 0x9d30, al);
    memoryASet(ds, 0x856d, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0c18 sub_2ae8()
sub_2ae8 PROC
01ed:0c18	push	bp
01ed:0c19	mov	bp, sp
01ed:0c1b	dec	sp
01ed:0c1c	dec	sp
01ed:0c1d	cmp	word ptr [0x6b4c], sp
01ed:0c21	ja	loc_2af6
01ed:0c23	call	0xffffab83
        	loc_2af6:
01ed:0c26	call	0x33c5
01ed:0c29	call	0x2ef8
        	loc_2afc:
01ed:0c2c	mov	byte ptr [0x928d], 0
01ed:0c31	mov	byte ptr [0x791a], 5
01ed:0c36	mov	al, 0
01ed:0c38	mov	byte ptr [0x79b5], al
01ed:0c3b	mov	ah, 0
01ed:0c3d	mov	word ptr [0xa0d4], ax
01ed:0c40	mov	word ptr [0xa0d6], 0
01ed:0c46	jmp	loc_2b26
        	loc_2b18:
01ed:0c48	cmp	byte ptr [bp - 1], 1
01ed:0c4c	jne	loc_2b23
01ed:0c4e	call	0x5681
01ed:0c51	jmp	loc_2b26
        	loc_2b23:
01ed:0c53	call	0xf7a
        	loc_2b26:
01ed:0c56	call	0x35a5
01ed:0c59	mov	byte ptr [bp - 1], al
01ed:0c5c	or	al, al
01ed:0c5e	jne	loc_2b18
01ed:0c60	jmp	loc_2c5a
        	loc_2b33:
01ed:0c63	call	0x3852
01ed:0c66	cmp	byte ptr [0x928d], 0xff
01ed:0c6b	jne	loc_2b42
01ed:0c6d	call	0x11eb
01ed:0c70	jmp	loc_2afc
        	loc_2b42:
01ed:0c72	mov	al, byte ptr [0x854e]
01ed:0c75	mov	ah, 0
01ed:0c77	dec	ax
01ed:0c78	mov	word ptr [0x7310], ax
01ed:0c7b	call	0x3467
01ed:0c7e	call	0xbf9
01ed:0c81	mov	al, byte ptr [0x8562]
01ed:0c84	push	ax
01ed:0c85	call	0x4bc6
01ed:0c88	inc	sp
01ed:0c89	inc	sp
01ed:0c8a	xor	ax, ax
01ed:0c8c	push	ax
01ed:0c8d	mov	ax, 1
01ed:0c90	push	ax
01ed:0c91	call	0x5181
01ed:0c94	add	sp, 4
01ed:0c97	call	0x1cb2
01ed:0c9a	call	0x1cea
01ed:0c9d	call	0x604
01ed:0ca0	mov	ax, 1
01ed:0ca3	push	ax
01ed:0ca4	call	0x7bdd
01ed:0ca7	inc	sp
01ed:0ca8	inc	sp
01ed:0ca9	mov	al, 1
01ed:0cab	push	ax
01ed:0cac	call	0x5e7
01ed:0caf	inc	sp
01ed:0cb0	inc	sp
01ed:0cb1	call	0x328f
01ed:0cb4	call	0x1473
01ed:0cb7	call	0x4b4e
01ed:0cba	call	0x138c
01ed:0cbd	call	0x13b2
01ed:0cc0	call	0x1bd7
01ed:0cc3	call	0x1c41
01ed:0cc6	call	0x138c
01ed:0cc9	call	0x13b2
01ed:0ccc	call	0x19a1
01ed:0ccf	call	0x19e4
01ed:0cd2	call	0x1473
01ed:0cd5	call	0x4b4e
01ed:0cd8	jmp	loc_2c19
        	loc_2baa:
01ed:0cda	call	0xffff93b1
01ed:0cdd	mov	byte ptr [0x79b3], al
01ed:0ce0	call	0x138c
01ed:0ce3	call	0x13b2
01ed:0ce6	call	0x13df
01ed:0ce9	call	0x4c14
01ed:0cec	call	0x1473
01ed:0cef	call	0x4b4e
01ed:0cf2	call	0x14e4
01ed:0cf5	call	0x15a1
01ed:0cf8	call	0x19a1
01ed:0cfb	call	0x19e4
01ed:0cfe	call	0x1a20
01ed:0d01	call	0x165e
01ed:0d04	call	0x17c7
01ed:0d07	call	0x5085
01ed:0d0a	call	0x50c0
01ed:0d0d	call	0x1a67
01ed:0d10	call	0x1b2b
01ed:0d13	call	0x1bd7
01ed:0d16	call	0x1c41
01ed:0d19	call	0x1cb2
01ed:0d1c	call	0x1cea
01ed:0d1f	mov	ax, 1
01ed:0d22	push	ax
01ed:0d23	call	0x7bdd
01ed:0d26	inc	sp
01ed:0d27	inc	sp
01ed:0d28	call	0x1349
01ed:0d2b	call	0x629c
01ed:0d2e	call	0x1d26
01ed:0d31	call	0x4c99
01ed:0d34	call	0x50fb
01ed:0d37	call	0x233a
01ed:0d3a	mov	al, 0x19
01ed:0d3c	push	ax
01ed:0d3d	call	0x7ab4
01ed:0d40	inc	sp
01ed:0d41	inc	sp
01ed:0d42	or	al, al
01ed:0d44	je	loc_2c19
01ed:0d46	call	0x49d7
        	loc_2c19:
01ed:0d49	cmp	byte ptr [0x928d], 0
01ed:0d4e	jne	loc_2c31
01ed:0d50	cmp	byte ptr [0x856d], 0
01ed:0d55	jne	loc_2c31
01ed:0d57	cmp	byte ptr [0x9d30], 0
01ed:0d5c	jne	loc_2c31
01ed:0d5e	jmp	loc_2baa
        	loc_2c31:
01ed:0d61	cmp	byte ptr [0x928d], 0xff
01ed:0d66	jne	loc_2c40
01ed:0d68	call	0x11eb
01ed:0d6b	call	0x5681
01ed:0d6e	jmp	loc_2c5d
        	loc_2c40:
01ed:0d70	call	0x3e8a
01ed:0d73	or	al, al
01ed:0d75	je	loc_2c5d
01ed:0d77	inc	byte ptr [0x79b2]
01ed:0d7b	cmp	byte ptr [0x79b2], 0xa
01ed:0d80	jne	loc_2c57
01ed:0d82	call	0x3ed4
01ed:0d85	jmp	loc_2c5d
        	loc_2c57:
01ed:0d87	call	0xd9d
        	loc_2c5a:
01ed:0d8a	call	0x2d14
        	loc_2c5d:
01ed:0d8d	mov	al, byte ptr [0x928d]
01ed:0d90	mov	ah, 0
01ed:0d92	or	ax, ax
01ed:0d94	jne	loc_2c69
01ed:0d96	jmp	loc_2b33
        	loc_2c69:
01ed:0d99	mov	sp, bp
01ed:0d9b	pop	bp
01ed:0d9c	ret	
sub_2ae8 ENDP
*/
void sub_2ae8()
{
    // coverage: 0x1e18-0x1f9d method sub_2ae8
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2af6;
    sub_ca53();
loc_2af6:
    sub_5295();
    sub_4dc8();
loc_2afc:
    memoryASet(ds, 0x928d, 0x00);
    memoryASet(ds, 0x791a, 0x05);
    al = 0x00;
    memoryASet(ds, 0x79b5, al);
    ah = 0x00;
    memoryASet16(ds, 0xa0d4, ax);
    memoryASet16(ds, 0xa0d6, 0x0000);
    goto loc_2b26;
loc_2b18:
    if (memoryAGet(ss, bp - 1) != 0x01)
        goto loc_2b23;
    sub_7551();
    goto loc_2b26;
loc_2b23:
    sub_2e4a();
loc_2b26:
    sub_5475();
    memoryASet(ss, bp - 1, al);
    if (al)
        goto loc_2b18;
    goto loc_2c5a;
loc_2b33:
    sub_5722();
    if (memoryAGet(ds, 0x928d) != 0xff)
        goto loc_2b42;
    sub_30bb();
    goto loc_2afc;
loc_2b42:
    al = memoryAGet(ds, 0x854e);
    ah = 0x00;
    ax--;
    memoryASet16(ds, 0x7310, ax);
    sub_5337();
    sub_2ac9();
    al = memoryAGet(ds, 0x8562);
    push(ax);
    sub_6a96();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    ax = 0x0001;
    push(ax);
    sub_7051();
    sp += 0x0004;
    sub_3b82();
    sub_3bba();
    sub_24d4();
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    al = 0x01;
    push(ax);
    sub_24b7();
    sp++;
    sp++;
    sub_515f();
    sub_3343();
    sub_6a1e();
    sub_325c();
    sub_3282();
    sub_3aa7();
    sub_3b11();
    sub_325c();
    sub_3282();
    sub_3871();
    sub_38b4();
    sub_3343();
    sub_6a1e();
    goto loc_2c19;
loc_2baa:
    sub_b281();
    memoryASet(ds, 0x79b3, al);
    sub_325c();
    sub_3282();
    sub_32af();
    sub_6ae4();
    sub_3343();
    sub_6a1e();
    sub_33b4();
    sub_3471();
    sub_3871();
    sub_38b4();
    sub_38f0();
    sub_352e();
    sub_3697();
    sub_6f55();
    sub_6f90();
    sub_3937();
    sub_39fb();
    sub_3aa7();
    sub_3b11();
    sub_3b82();
    sub_3bba();
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_3219();
    sub_816c();
    sub_3bf6();
    sub_6b69();
    sub_6fcb();
    sub_420a();
    al = 0x19;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_2c19;
    sub_68a7();
loc_2c19:
    if (memoryAGet(ds, 0x928d) != 0x00)
        goto loc_2c31;
    if (memoryAGet(ds, 0x856d) != 0x00)
        goto loc_2c31;
    if (memoryAGet(ds, 0x9d30) != 0x00)
        goto loc_2c31;
    goto loc_2baa;
loc_2c31:
    if (memoryAGet(ds, 0x928d) != 0xff)
        goto loc_2c40;
    sub_30bb();
    sub_7551();
    goto loc_2c5d;
loc_2c40:
    sub_5d5a();
    if (!al)
        goto loc_2c5d;
    memoryASet(ds, 0x79b2, memoryAGet(ds, 0x79b2) + 1);
    if (memoryAGet(ds, 0x79b2) != 0x0a)
        goto loc_2c57;
    sub_5da4();
    goto loc_2c5d;
loc_2c57:
    sub_2c6d();
loc_2c5a:
    sub_4be4();
loc_2c5d:
    al = memoryAGet(ds, 0x928d);
    ah = 0x00;
    if (ax)
        goto loc_2c69;
    goto loc_2b33;
loc_2c69:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0d9d sub_2c6d()
sub_2c6d PROC
01ed:0d9d	push	bp
01ed:0d9e	mov	bp, sp
01ed:0da0	sub	sp, 0xe
01ed:0da3	push	si
01ed:0da4	push	di
01ed:0da5	cmp	word ptr [0x6b4c], sp
01ed:0da9	ja	loc_2c7e
01ed:0dab	call	0xffffab83
        	loc_2c7e:
01ed:0dae	push	ss
01ed:0daf	lea	ax, [bp - 4]
01ed:0db2	push	ax
01ed:0db3	push	ds
01ed:0db4	mov	ax, 0x119e
01ed:0db7	push	ax
01ed:0db8	mov	cx, 4
01ed:0dbb	call	0xffffa9f5
01ed:0dbe	push	ds
01ed:0dbf	mov	ax, 0x928
01ed:0dc2	push	ax
01ed:0dc3	call	0x7307
01ed:0dc6	add	sp, 4
01ed:0dc9	xor	ax, ax
01ed:0dcb	push	ax
01ed:0dcc	call	0xffff9410
01ed:0dcf	inc	sp
01ed:0dd0	inc	sp
01ed:0dd1	mov	ax, word ptr [0x7928]
01ed:0dd4	mov	dx, word ptr [0x7926]
01ed:0dd8	mov	word ptr [0x857e], dx
01ed:0ddc	mov	word ptr [0x8580], ax
01ed:0ddf	mov	ax, 4
01ed:0de2	push	ax
01ed:0de3	mov	ax, 3
01ed:0de6	push	ax
01ed:0de7	call	0x736f
01ed:0dea	add	sp, 4
01ed:0ded	mov	si, ax
01ed:0def	xor	ax, ax
01ed:0df1	push	ax
01ed:0df2	mov	dx, 0x63
01ed:0df5	push	ax
01ed:0df6	push	dx
01ed:0df7	push	word ptr [0x8580]
01ed:0dfb	push	word ptr [0x857e]
01ed:0dff	push	si
01ed:0e00	call	0x745e
01ed:0e03	add	sp, 0xc
01ed:0e06	push	si
01ed:0e07	call	0x7319
01ed:0e0a	inc	sp
01ed:0e0b	inc	sp
01ed:0e0c	cmp	word ptr [0x541d], 1
01ed:0e11	jne	loc_2d1a
01ed:0e13	mov	ax, word ptr [0x8580]
01ed:0e16	mov	dx, word ptr [0x857e]
01ed:0e1a	mov	word ptr [0x9b96], dx
01ed:0e1e	mov	word ptr [0x9b98], ax
01ed:0e21	mov	byte ptr [bp - 0xd], 0
01ed:0e25	jmp	loc_2d14
        	loc_2cf7:
01ed:0e27	mov	al, byte ptr [bp - 0xd]
01ed:0e2a	mov	ah, 0
01ed:0e2c	les	bx, ptr [0x9b96]
01ed:0e30	add	bx, ax
01ed:0e32	mov	al, byte ptr [bp - 0xd]
01ed:0e35	mov	ah, 0
01ed:0e37	mov	di, ax
01ed:0e39	mov	al, byte ptr [di + 0x71e]
01ed:0e3d	mov	byte ptr es:[bx + 0x23], al
01ed:0e41	inc	byte ptr [bp - 0xd]
        	loc_2d14:
01ed:0e44	cmp	byte ptr [bp - 0xd], 0x10
01ed:0e48	jb	loc_2cf7
        	loc_2d1a:
01ed:0e4a	call	0x3467
01ed:0e4d	xor	ax, ax
01ed:0e4f	push	ax
01ed:0e50	push	word ptr [0x8580]
01ed:0e54	push	word ptr [0x857e]
01ed:0e58	call	0x7b93
01ed:0e5b	add	sp, 6
01ed:0e5e	xor	ax, ax
01ed:0e60	push	ax
01ed:0e61	call	0x7bca
01ed:0e64	inc	sp
01ed:0e65	inc	sp
01ed:0e66	call	0xffff9864
01ed:0e69	mov	byte ptr [bp - 9], 4
01ed:0e6d	mov	byte ptr [bp - 0xa], 5
01ed:0e71	mov	ax, word ptr [bp - 2]
01ed:0e74	mov	dx, word ptr [bp - 4]
01ed:0e77	mov	word ptr [bp - 8], dx
01ed:0e7a	mov	word ptr [bp - 6], ax
01ed:0e7d	mov	al, byte ptr [bp - 0xa]
01ed:0e80	mov	ah, 0
01ed:0e82	mov	cl, 4
01ed:0e84	shl	ax, cl
01ed:0e86	les	bx, ptr [0x8884]
01ed:0e8a	mov	word ptr es:[bx + 2], ax
01ed:0e8e	mov	byte ptr [bp - 0xc], 0
01ed:0e92	jmp	loc_2da4
        	loc_2d64:
01ed:0e94	mov	al, byte ptr [bp - 0xc]
01ed:0e97	mov	ah, 0
01ed:0e99	les	bx, ptr [bp - 8]
01ed:0e9c	add	bx, ax
01ed:0e9e	mov	al, byte ptr es:[bx]
01ed:0ea1	mov	byte ptr [bp - 0xb], al
01ed:0ea4	les	bx, ptr [0x8884]
01ed:0ea8	mov	ah, 0
01ed:0eaa	add	ax, 0x175
01ed:0ead	mov	word ptr es:[bx + 4], ax
01ed:0eb1	mov	al, byte ptr [bp - 9]
01ed:0eb4	mov	ah, 0
01ed:0eb6	mov	cl, 4
01ed:0eb8	shl	ax, cl
01ed:0eba	mov	word ptr es:[bx], ax
01ed:0ebd	cmp	byte ptr [bp - 0xb], 0x20
01ed:0ec1	je	loc_2d9e
01ed:0ec3	push	ds
01ed:0ec4	mov	ax, 0x792e
01ed:0ec7	push	ax
01ed:0ec8	call	0xffff942a
01ed:0ecb	add	sp, 4
        	loc_2d9e:
01ed:0ece	inc	byte ptr [bp - 9]
01ed:0ed1	inc	byte ptr [bp - 0xc]
        	loc_2da4:
01ed:0ed4	cmp	byte ptr [bp - 0xc], 0xd
01ed:0ed8	jb	loc_2d64
01ed:0eda	mov	byte ptr [bp - 9], 7
01ed:0ede	mov	byte ptr [bp - 0xa], 7
01ed:0ee2	mov	al, byte ptr [0x79b2]
01ed:0ee5	mov	ah, 0
01ed:0ee7	shl	ax, 1
01ed:0ee9	shl	ax, 1
01ed:0eeb	mov	bx, ax
01ed:0eed	mov	ax, word ptr [bx + 0x1356]
01ed:0ef1	mov	dx, word ptr [bx + 0x1354]
01ed:0ef5	mov	word ptr [bp - 8], dx
01ed:0ef8	mov	word ptr [bp - 6], ax
01ed:0efb	mov	al, byte ptr [bp - 0xa]
01ed:0efe	mov	ah, 0
01ed:0f00	mov	cl, 4
01ed:0f02	shl	ax, cl
01ed:0f04	les	bx, ptr [0x8884]
01ed:0f08	mov	word ptr es:[bx + 2], ax
01ed:0f0c	mov	byte ptr [bp - 0xc], 0
01ed:0f10	jmp	loc_2e1c
        	loc_2de2:
01ed:0f12	mov	al, byte ptr [bp - 0xc]
01ed:0f15	mov	ah, 0
01ed:0f17	les	bx, ptr [bp - 8]
01ed:0f1a	add	bx, ax
01ed:0f1c	mov	al, byte ptr es:[bx]
01ed:0f1f	mov	byte ptr [bp - 0xb], al
01ed:0f22	les	bx, ptr [0x8884]
01ed:0f26	mov	ah, 0
01ed:0f28	add	ax, 0x175
01ed:0f2b	mov	word ptr es:[bx + 4], ax
01ed:0f2f	mov	al, byte ptr [bp - 9]
01ed:0f32	mov	ah, 0
01ed:0f34	mov	cl, 4
01ed:0f36	shl	ax, cl
01ed:0f38	mov	word ptr es:[bx], ax
01ed:0f3b	push	ds
01ed:0f3c	mov	ax, 0x792e
01ed:0f3f	push	ax
01ed:0f40	call	0xffff942a
01ed:0f43	add	sp, 4
01ed:0f46	inc	byte ptr [bp - 9]
01ed:0f49	inc	byte ptr [bp - 0xc]
        	loc_2e1c:
01ed:0f4c	cmp	byte ptr [bp - 0xc], 6
01ed:0f50	jb	loc_2de2
        	loc_2e22:
01ed:0f52	mov	al, 0
01ed:0f54	push	ax
01ed:0f55	call	0x75a2
01ed:0f58	inc	sp
01ed:0f59	inc	sp
01ed:0f5a	cwde	
01ed:0f5b	test	ax, 0x10
01ed:0f5e	je	loc_2e22
01ed:0f60	mov	ax, 1
01ed:0f63	push	ax
01ed:0f64	call	0xffff9410
01ed:0f67	inc	sp
01ed:0f68	inc	sp
01ed:0f69	push	ds
01ed:0f6a	mov	ax, 0x90
01ed:0f6d	push	ax
01ed:0f6e	call	0x7307
01ed:0f71	add	sp, 4
01ed:0f74	pop	di
01ed:0f75	pop	si
01ed:0f76	mov	sp, bp
01ed:0f78	pop	bp
01ed:0f79	ret	
sub_2c6d ENDP
*/
void sub_2c6d()
{
    // coverage: 0x1f9d-0x217a method sub_2c6d
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000e;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2c7e;
    sub_ca53();
loc_2c7e:
    push(ss);
    ax = bp - 0x4;
    push(ax);
    push(ds);
    ax = 0x119e;
    push(ax);
    cx = 0x0004;
    sub_c8c5();
    push(ds);
    ax = 0x0928;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x857e, dx);
    memoryASet16(ds, 0x8580, ax);
    ax = 0x0004;
    push(ax);
    ax = 0x0003;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    dx = 0x0063;
    push(ax);
    push(dx);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_2d1a;
    ax = memoryAGet16(ds, 0x8580);
    dx = memoryAGet16(ds, 0x857e);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 13, 0x00);
    goto loc_2d14;
loc_2cf7:
    al = memoryAGet(ss, bp - 13);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 13);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1822);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 13, memoryAGet(ss, bp - 13) + 1);
loc_2d14:
    if (memoryAGet(ss, bp - 13) < 0x10)
        goto loc_2cf7;
loc_2d1a:
    sub_5337();
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    sub_b734();
    memoryASet(ss, bp - 9, 0x04);
    memoryASet(ss, bp - 10, 0x05);
    ax = memoryAGet16(ss, bp - 2);
    dx = memoryAGet16(ss, bp - 4);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    al = memoryAGet(ss, bp - 10);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 12, 0x00);
    goto loc_2da4;
loc_2d64:
    al = memoryAGet(ss, bp - 12);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 11, al);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 9);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    if (memoryAGet(ss, bp - 11) == 0x20)
        goto loc_2d9e;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_2d9e:
    memoryASet(ss, bp - 9, memoryAGet(ss, bp - 9) + 1);
    memoryASet(ss, bp - 12, memoryAGet(ss, bp - 12) + 1);
loc_2da4:
    if (memoryAGet(ss, bp - 12) < 0x0d)
        goto loc_2d64;
    memoryASet(ss, bp - 9, 0x07);
    memoryASet(ss, bp - 10, 0x07);
    al = memoryAGet(ds, 0x79b2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 4950);
    dx = memoryAGet16(ds, bx + 4948);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    al = memoryAGet(ss, bp - 10);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 12, 0x00);
    goto loc_2e1c;
loc_2de2:
    al = memoryAGet(ss, bp - 12);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 11, al);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 9);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    memoryASet(ss, bp - 9, memoryAGet(ss, bp - 9) + 1);
    memoryASet(ss, bp - 12, memoryAGet(ss, bp - 12) + 1);
loc_2e1c:
    if (memoryAGet(ss, bp - 12) < 0x06)
        goto loc_2de2;
loc_2e22:
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    cbw();
    if (!(ax & 0x0010))
        goto loc_2e22;
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    push(ds);
    ax = 0x0090;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:0f7a sub_2e4a()
sub_2e4a PROC
01ed:0f7a	push	bp
01ed:0f7b	mov	bp, sp
01ed:0f7d	sub	sp, 0x16
01ed:0f80	push	si
01ed:0f81	push	di
01ed:0f82	cmp	word ptr [0x6b4c], sp
01ed:0f86	ja	loc_2e5b
01ed:0f88	call	0xffffab83
        	loc_2e5b:
01ed:0f8b	push	ss
01ed:0f8c	lea	ax, [bp - 4]
01ed:0f8f	push	ax
01ed:0f90	push	ds
01ed:0f91	mov	ax, 0x11a2
01ed:0f94	push	ax
01ed:0f95	mov	cx, 4
01ed:0f98	call	0xffffa9f5
01ed:0f9b	push	ss
01ed:0f9c	lea	ax, [bp - 8]
01ed:0f9f	push	ax
01ed:0fa0	push	ds
01ed:0fa1	mov	ax, 0x11a6
01ed:0fa4	push	ax
01ed:0fa5	mov	cx, 4
01ed:0fa8	call	0xffffa9f5
01ed:0fab	push	ss
01ed:0fac	lea	ax, [bp - 0xc]
01ed:0faf	push	ax
01ed:0fb0	push	ds
01ed:0fb1	mov	ax, 0x11aa
01ed:0fb4	push	ax
01ed:0fb5	mov	cx, 4
01ed:0fb8	call	0xffffa9f5
01ed:0fbb	push	ds
01ed:0fbc	mov	ax, 0x928
01ed:0fbf	push	ax
01ed:0fc0	call	0x7307
01ed:0fc3	add	sp, 4
01ed:0fc6	xor	ax, ax
01ed:0fc8	push	ax
01ed:0fc9	call	0xffff9410
01ed:0fcc	inc	sp
01ed:0fcd	inc	sp
01ed:0fce	mov	ax, word ptr [0x7928]
01ed:0fd1	mov	dx, word ptr [0x7926]
01ed:0fd5	mov	word ptr [0x857e], dx
01ed:0fd9	mov	word ptr [0x8580], ax
01ed:0fdc	mov	ax, 4
01ed:0fdf	push	ax
01ed:0fe0	mov	ax, 3
01ed:0fe3	push	ax
01ed:0fe4	call	0x736f
01ed:0fe7	add	sp, 4
01ed:0fea	mov	si, ax
01ed:0fec	xor	ax, ax
01ed:0fee	push	ax
01ed:0fef	mov	dx, 0x63
01ed:0ff2	push	ax
01ed:0ff3	push	dx
01ed:0ff4	push	word ptr [0x8580]
01ed:0ff8	push	word ptr [0x857e]
01ed:0ffc	push	si
01ed:0ffd	call	0x745e
01ed:1000	add	sp, 0xc
01ed:1003	push	si
01ed:1004	call	0x7319
01ed:1007	inc	sp
01ed:1008	inc	sp
01ed:1009	cmp	word ptr [0x541d], 1
01ed:100e	jne	loc_2f17
01ed:1010	mov	ax, word ptr [0x8580]
01ed:1013	mov	dx, word ptr [0x857e]
01ed:1017	mov	word ptr [0x9b96], dx
01ed:101b	mov	word ptr [0x9b98], ax
01ed:101e	mov	byte ptr [bp - 0x16], 0
01ed:1022	jmp	loc_2f11
        	loc_2ef4:
01ed:1024	mov	al, byte ptr [bp - 0x16]
01ed:1027	mov	ah, 0
01ed:1029	les	bx, ptr [0x9b96]
01ed:102d	add	bx, ax
01ed:102f	mov	al, byte ptr [bp - 0x16]
01ed:1032	mov	ah, 0
01ed:1034	mov	di, ax
01ed:1036	mov	al, byte ptr [di + 0x71e]
01ed:103a	mov	byte ptr es:[bx + 0x23], al
01ed:103e	inc	byte ptr [bp - 0x16]
        	loc_2f11:
01ed:1041	cmp	byte ptr [bp - 0x16], 0x10
01ed:1045	jb	loc_2ef4
        	loc_2f17:
01ed:1047	call	0x3467
01ed:104a	xor	ax, ax
01ed:104c	push	ax
01ed:104d	push	word ptr [0x8580]
01ed:1051	push	word ptr [0x857e]
01ed:1055	call	0x7b93
01ed:1058	add	sp, 6
01ed:105b	xor	ax, ax
01ed:105d	push	ax
01ed:105e	call	0x7bca
01ed:1061	inc	sp
01ed:1062	inc	sp
01ed:1063	call	0xffff9864
01ed:1066	mov	byte ptr [bp - 0x11], 0
01ed:106a	mov	byte ptr [bp - 0x12], 1
01ed:106e	mov	ax, word ptr [bp - 2]
01ed:1071	mov	dx, word ptr [bp - 4]
01ed:1074	mov	word ptr [bp - 0x10], dx
01ed:1077	mov	word ptr [bp - 0xe], ax
01ed:107a	mov	al, byte ptr [bp - 0x12]
01ed:107d	mov	ah, 0
01ed:107f	mov	cl, 4
01ed:1081	shl	ax, cl
01ed:1083	les	bx, ptr [0x8884]
01ed:1087	mov	word ptr es:[bx + 2], ax
01ed:108b	mov	byte ptr [bp - 0x14], 0
01ed:108f	jmp	loc_2fa1
        	loc_2f61:
01ed:1091	mov	al, byte ptr [bp - 0x14]
01ed:1094	mov	ah, 0
01ed:1096	les	bx, ptr [bp - 0x10]
01ed:1099	add	bx, ax
01ed:109b	mov	al, byte ptr es:[bx]
01ed:109e	mov	byte ptr [bp - 0x13], al
01ed:10a1	les	bx, ptr [0x8884]
01ed:10a5	mov	ah, 0
01ed:10a7	add	ax, 0x175
01ed:10aa	mov	word ptr es:[bx + 4], ax
01ed:10ae	mov	al, byte ptr [bp - 0x11]
01ed:10b1	mov	ah, 0
01ed:10b3	mov	cl, 4
01ed:10b5	shl	ax, cl
01ed:10b7	mov	word ptr es:[bx], ax
01ed:10ba	cmp	byte ptr [bp - 0x13], 0x20
01ed:10be	je	loc_2f9b
01ed:10c0	push	ds
01ed:10c1	mov	ax, 0x792e
01ed:10c4	push	ax
01ed:10c5	call	0xffff942a
01ed:10c8	add	sp, 4
        	loc_2f9b:
01ed:10cb	inc	byte ptr [bp - 0x11]
01ed:10ce	inc	byte ptr [bp - 0x14]
        	loc_2fa1:
01ed:10d1	cmp	byte ptr [bp - 0x14], 0x13
01ed:10d5	jb	loc_2f61
01ed:10d7	mov	byte ptr [bp - 0x11], 7
01ed:10db	mov	byte ptr [bp - 0x12], 0xa
01ed:10df	mov	al, byte ptr [bp - 0x12]
01ed:10e2	mov	ah, 0
01ed:10e4	mov	cl, 4
01ed:10e6	shl	ax, cl
01ed:10e8	les	bx, ptr [0x8884]
01ed:10ec	mov	word ptr es:[bx + 2], ax
01ed:10f0	mov	byte ptr [bp - 0x14], 0
01ed:10f4	jmp	loc_2ff7
        	loc_2fc6:
01ed:10f6	mov	byte ptr [bp - 0x13], 0x41
01ed:10fa	les	bx, ptr [0x8884]
01ed:10fe	mov	al, byte ptr [bp - 0x13]
01ed:1101	mov	ah, 0
01ed:1103	add	ax, 0x175
01ed:1106	mov	word ptr es:[bx + 4], ax
01ed:110a	mov	al, byte ptr [bp - 0x11]
01ed:110d	mov	ah, 0
01ed:110f	mov	cl, 4
01ed:1111	shl	ax, cl
01ed:1113	mov	word ptr es:[bx], ax
01ed:1116	push	ds
01ed:1117	mov	ax, 0x792e
01ed:111a	push	ax
01ed:111b	call	0xffff942a
01ed:111e	add	sp, 4
01ed:1121	inc	byte ptr [bp - 0x11]
01ed:1124	inc	byte ptr [bp - 0x14]
        	loc_2ff7:
01ed:1127	cmp	byte ptr [bp - 0x14], 6
01ed:112b	jb	loc_2fc6
01ed:112d	mov	al, 7
01ed:112f	push	ax
01ed:1130	mov	al, 0xa
01ed:1132	push	ax
01ed:1133	call	0x5c87
01ed:1136	add	sp, 4
01ed:1139	mov	byte ptr [bp - 0x15], al
01ed:113c	or	al, al
01ed:113e	je	loc_3024
01ed:1140	mov	ax, word ptr [bp - 6]
01ed:1143	mov	dx, word ptr [bp - 8]
01ed:1146	mov	word ptr [bp - 0x10], dx
01ed:1149	mov	word ptr [bp - 0xe], ax
01ed:114c	mov	al, byte ptr [bp - 0x15]
01ed:114f	mov	byte ptr [0x79b2], al
01ed:1152	jmp	loc_3035
        	loc_3024:
01ed:1154	mov	ax, word ptr [bp - 0xa]
01ed:1157	mov	dx, word ptr [bp - 0xc]
01ed:115a	mov	word ptr [bp - 0x10], dx
01ed:115d	mov	word ptr [bp - 0xe], ax
01ed:1160	mov	byte ptr [0x79b2], 1
        	loc_3035:
01ed:1165	mov	byte ptr [bp - 0x11], 3
01ed:1169	mov	byte ptr [bp - 0x12], 6
01ed:116d	mov	al, byte ptr [bp - 0x12]
01ed:1170	mov	ah, 0
01ed:1172	mov	cl, 4
01ed:1174	shl	ax, cl
01ed:1176	les	bx, ptr [0x8884]
01ed:117a	mov	word ptr es:[bx + 2], ax
01ed:117e	mov	byte ptr [bp - 0x14], 0
01ed:1182	jmp	loc_3094
        	loc_3054:
01ed:1184	mov	al, byte ptr [bp - 0x14]
01ed:1187	mov	ah, 0
01ed:1189	les	bx, ptr [bp - 0x10]
01ed:118c	add	bx, ax
01ed:118e	mov	al, byte ptr es:[bx]
01ed:1191	mov	byte ptr [bp - 0x13], al
01ed:1194	les	bx, ptr [0x8884]
01ed:1198	mov	ah, 0
01ed:119a	add	ax, 0x175
01ed:119d	mov	word ptr es:[bx + 4], ax
01ed:11a1	mov	al, byte ptr [bp - 0x11]
01ed:11a4	mov	ah, 0
01ed:11a6	mov	cl, 4
01ed:11a8	shl	ax, cl
01ed:11aa	mov	word ptr es:[bx], ax
01ed:11ad	cmp	byte ptr [bp - 0x13], 0x20
01ed:11b1	je	loc_308e
01ed:11b3	push	ds
01ed:11b4	mov	ax, 0x792e
01ed:11b7	push	ax
01ed:11b8	call	0xffff942a
01ed:11bb	add	sp, 4
        	loc_308e:
01ed:11be	inc	byte ptr [bp - 0x11]
01ed:11c1	inc	byte ptr [bp - 0x14]
        	loc_3094:
01ed:11c4	cmp	byte ptr [bp - 0x14], 0xe
01ed:11c8	jb	loc_3054
01ed:11ca	mov	byte ptr [bp - 0x14], 0
01ed:11ce	jmp	loc_30a6
        	loc_30a0:
01ed:11d0	call	0x3e74
01ed:11d3	inc	byte ptr [bp - 0x14]
        	loc_30a6:
01ed:11d6	cmp	byte ptr [bp - 0x14], 3
01ed:11da	jb	loc_30a0
01ed:11dc	mov	ax, 1
01ed:11df	push	ax
01ed:11e0	call	0xffff9410
01ed:11e3	inc	sp
01ed:11e4	inc	sp
01ed:11e5	pop	di
01ed:11e6	pop	si
01ed:11e7	mov	sp, bp
01ed:11e9	pop	bp
01ed:11ea	ret	
sub_2e4a ENDP
*/
void sub_2e4a()
{
    // coverage: 0x217a-0x23eb method sub_2e4a
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0016;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_2e5b;
    sub_ca53();
loc_2e5b:
    push(ss);
    ax = bp - 0x4;
    push(ax);
    push(ds);
    ax = 0x11a2;
    push(ax);
    cx = 0x0004;
    sub_c8c5();
    push(ss);
    ax = bp - 0x8;
    push(ax);
    push(ds);
    ax = 0x11a6;
    push(ax);
    cx = 0x0004;
    sub_c8c5();
    push(ss);
    ax = bp - 0xc;
    push(ax);
    push(ds);
    ax = 0x11aa;
    push(ax);
    cx = 0x0004;
    sub_c8c5();
    push(ds);
    ax = 0x0928;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x857e, dx);
    memoryASet16(ds, 0x8580, ax);
    ax = 0x0004;
    push(ax);
    ax = 0x0003;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    dx = 0x0063;
    push(ax);
    push(dx);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_2f17;
    ax = memoryAGet16(ds, 0x8580);
    dx = memoryAGet16(ds, 0x857e);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 22, 0x00);
    goto loc_2f11;
loc_2ef4:
    al = memoryAGet(ss, bp - 22);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 22);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1822);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 22, memoryAGet(ss, bp - 22) + 1);
loc_2f11:
    if (memoryAGet(ss, bp - 22) < 0x10)
        goto loc_2ef4;
loc_2f17:
    sub_5337();
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    sub_b734();
    memoryASet(ss, bp - 17, 0x00);
    memoryASet(ss, bp - 18, 0x01);
    ax = memoryAGet16(ss, bp - 2);
    dx = memoryAGet16(ss, bp - 4);
    memoryASet16(ss, bp - 16, dx);
    memoryASet16(ss, bp - 14, ax);
    al = memoryAGet(ss, bp - 18);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 20, 0x00);
    goto loc_2fa1;
loc_2f61:
    al = memoryAGet(ss, bp - 20);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 19, al);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 17);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    if (memoryAGet(ss, bp - 19) == 0x20)
        goto loc_2f9b;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_2f9b:
    memoryASet(ss, bp - 17, memoryAGet(ss, bp - 17) + 1);
    memoryASet(ss, bp - 20, memoryAGet(ss, bp - 20) + 1);
loc_2fa1:
    if (memoryAGet(ss, bp - 20) < 0x13)
        goto loc_2f61;
    memoryASet(ss, bp - 17, 0x07);
    memoryASet(ss, bp - 18, 0x0a);
    al = memoryAGet(ss, bp - 18);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 20, 0x00);
    goto loc_2ff7;
loc_2fc6:
    memoryASet(ss, bp - 19, 0x41);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    al = memoryAGet(ss, bp - 19);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 17);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    memoryASet(ss, bp - 17, memoryAGet(ss, bp - 17) + 1);
    memoryASet(ss, bp - 20, memoryAGet(ss, bp - 20) + 1);
loc_2ff7:
    if (memoryAGet(ss, bp - 20) < 0x06)
        goto loc_2fc6;
    al = 0x07;
    push(ax);
    al = 0x0a;
    push(ax);
    sub_7b57();
    sp += 0x0004;
    memoryASet(ss, bp - 21, al);
    if (!al)
        goto loc_3024;
    ax = memoryAGet16(ss, bp - 6);
    dx = memoryAGet16(ss, bp - 8);
    memoryASet16(ss, bp - 16, dx);
    memoryASet16(ss, bp - 14, ax);
    al = memoryAGet(ss, bp - 21);
    memoryASet(ds, 0x79b2, al);
    goto loc_3035;
loc_3024:
    ax = memoryAGet16(ss, bp - 10);
    dx = memoryAGet16(ss, bp - 12);
    memoryASet16(ss, bp - 16, dx);
    memoryASet16(ss, bp - 14, ax);
    memoryASet(ds, 0x79b2, 0x01);
loc_3035:
    memoryASet(ss, bp - 17, 0x03);
    memoryASet(ss, bp - 18, 0x06);
    al = memoryAGet(ss, bp - 18);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 20, 0x00);
    goto loc_3094;
loc_3054:
    al = memoryAGet(ss, bp - 20);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 19, al);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 17);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    if (memoryAGet(ss, bp - 19) == 0x20)
        goto loc_308e;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_308e:
    memoryASet(ss, bp - 17, memoryAGet(ss, bp - 17) + 1);
    memoryASet(ss, bp - 20, memoryAGet(ss, bp - 20) + 1);
loc_3094:
    if (memoryAGet(ss, bp - 20) < 0x0e)
        goto loc_3054;
    memoryASet(ss, bp - 20, 0x00);
    goto loc_30a6;
loc_30a0:
    sub_5d44();
    memoryASet(ss, bp - 20, memoryAGet(ss, bp - 20) + 1);
loc_30a6:
    if (memoryAGet(ss, bp - 20) < 0x03)
        goto loc_30a0;
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:11eb sub_30bb()
sub_30bb PROC
01ed:11eb	push	bp
01ed:11ec	mov	bp, sp
01ed:11ee	sub	sp, 0xe
01ed:11f1	push	si
01ed:11f2	push	di
01ed:11f3	cmp	word ptr [0x6b4c], sp
01ed:11f7	ja	loc_30cc
01ed:11f9	call	0xffffab83
        	loc_30cc:
01ed:11fc	push	ss
01ed:11fd	lea	ax, [bp - 4]
01ed:1200	push	ax
01ed:1201	push	ds
01ed:1202	mov	ax, 0x11ae
01ed:1205	push	ax
01ed:1206	mov	cx, 4
01ed:1209	call	0xffffa9f5
01ed:120c	push	ds
01ed:120d	mov	ax, 0x928
01ed:1210	push	ax
01ed:1211	call	0x7307
01ed:1214	add	sp, 4
01ed:1217	xor	ax, ax
01ed:1219	push	ax
01ed:121a	call	0xffff9410
01ed:121d	inc	sp
01ed:121e	inc	sp
01ed:121f	mov	ax, word ptr [0x7928]
01ed:1222	mov	dx, word ptr [0x7926]
01ed:1226	mov	word ptr [0x857e], dx
01ed:122a	mov	word ptr [0x8580], ax
01ed:122d	mov	ax, 4
01ed:1230	push	ax
01ed:1231	mov	ax, 3
01ed:1234	push	ax
01ed:1235	call	0x736f
01ed:1238	add	sp, 4
01ed:123b	mov	si, ax
01ed:123d	xor	ax, ax
01ed:123f	push	ax
01ed:1240	mov	dx, 0x63
01ed:1243	push	ax
01ed:1244	push	dx
01ed:1245	push	word ptr [0x8580]
01ed:1249	push	word ptr [0x857e]
01ed:124d	push	si
01ed:124e	call	0x745e
01ed:1251	add	sp, 0xc
01ed:1254	push	si
01ed:1255	call	0x7319
01ed:1258	inc	sp
01ed:1259	inc	sp
01ed:125a	cmp	word ptr [0x541d], 1
01ed:125f	jne	loc_3168
01ed:1261	mov	ax, word ptr [0x8580]
01ed:1264	mov	dx, word ptr [0x857e]
01ed:1268	mov	word ptr [0x9b96], dx
01ed:126c	mov	word ptr [0x9b98], ax
01ed:126f	mov	byte ptr [bp - 0xd], 0
01ed:1273	jmp	loc_3162
        	loc_3145:
01ed:1275	mov	al, byte ptr [bp - 0xd]
01ed:1278	mov	ah, 0
01ed:127a	les	bx, ptr [0x9b96]
01ed:127e	add	bx, ax
01ed:1280	mov	al, byte ptr [bp - 0xd]
01ed:1283	mov	ah, 0
01ed:1285	mov	di, ax
01ed:1287	mov	al, byte ptr [di + 0x71e]
01ed:128b	mov	byte ptr es:[bx + 0x23], al
01ed:128f	inc	byte ptr [bp - 0xd]
        	loc_3162:
01ed:1292	cmp	byte ptr [bp - 0xd], 0x10
01ed:1296	jb	loc_3145
        	loc_3168:
01ed:1298	call	0x3467
01ed:129b	xor	ax, ax
01ed:129d	push	ax
01ed:129e	push	word ptr [0x8580]
01ed:12a2	push	word ptr [0x857e]
01ed:12a6	call	0x7b93
01ed:12a9	add	sp, 6
01ed:12ac	xor	ax, ax
01ed:12ae	push	ax
01ed:12af	call	0x7bca
01ed:12b2	inc	sp
01ed:12b3	inc	sp
01ed:12b4	call	0xffff9864
01ed:12b7	mov	al, 6
01ed:12b9	mov	byte ptr [bp - 0xa], al
01ed:12bc	mov	byte ptr [bp - 9], al
01ed:12bf	mov	ax, word ptr [bp - 2]
01ed:12c2	mov	dx, word ptr [bp - 4]
01ed:12c5	mov	word ptr [bp - 8], dx
01ed:12c8	mov	word ptr [bp - 6], ax
01ed:12cb	mov	al, byte ptr [bp - 0xa]
01ed:12ce	mov	ah, 0
01ed:12d0	mov	cl, 4
01ed:12d2	shl	ax, cl
01ed:12d4	les	bx, ptr [0x8884]
01ed:12d8	mov	word ptr es:[bx + 2], ax
01ed:12dc	mov	byte ptr [bp - 0xc], 0
01ed:12e0	jmp	loc_31f2
        	loc_31b2:
01ed:12e2	mov	al, byte ptr [bp - 0xc]
01ed:12e5	mov	ah, 0
01ed:12e7	les	bx, ptr [bp - 8]
01ed:12ea	add	bx, ax
01ed:12ec	mov	al, byte ptr es:[bx]
01ed:12ef	mov	byte ptr [bp - 0xb], al
01ed:12f2	les	bx, ptr [0x8884]
01ed:12f6	mov	ah, 0
01ed:12f8	add	ax, 0x175
01ed:12fb	mov	word ptr es:[bx + 4], ax
01ed:12ff	mov	al, byte ptr [bp - 9]
01ed:1302	mov	ah, 0
01ed:1304	mov	cl, 4
01ed:1306	shl	ax, cl
01ed:1308	mov	word ptr es:[bx], ax
01ed:130b	cmp	byte ptr [bp - 0xb], 0x20
01ed:130f	je	loc_31ec
01ed:1311	push	ds
01ed:1312	mov	ax, 0x792e
01ed:1315	push	ax
01ed:1316	call	0xffff942a
01ed:1319	add	sp, 4
        	loc_31ec:
01ed:131c	inc	byte ptr [bp - 9]
01ed:131f	inc	byte ptr [bp - 0xc]
        	loc_31f2:
01ed:1322	cmp	byte ptr [bp - 0xc], 9
01ed:1326	jb	loc_31b2
01ed:1328	mov	byte ptr [bp - 0xc], 0
01ed:132c	jmp	loc_3204
        	loc_31fe:
01ed:132e	call	0x3e74
01ed:1331	inc	byte ptr [bp - 0xc]
        	loc_3204:
01ed:1334	cmp	byte ptr [bp - 0xc], 2
01ed:1338	jb	loc_31fe
01ed:133a	mov	ax, 1
01ed:133d	push	ax
01ed:133e	call	0xffff9410
01ed:1341	inc	sp
01ed:1342	inc	sp
01ed:1343	pop	di
01ed:1344	pop	si
01ed:1345	mov	sp, bp
01ed:1347	pop	bp
01ed:1348	ret	
sub_30bb ENDP
*/
void sub_30bb()
{
    // coverage: 0x23eb-0x2549 method sub_30bb
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000e;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_30cc;
    sub_ca53();
loc_30cc:
    push(ss);
    ax = bp - 0x4;
    push(ax);
    push(ds);
    ax = 0x11ae;
    push(ax);
    cx = 0x0004;
    sub_c8c5();
    push(ds);
    ax = 0x0928;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x857e, dx);
    memoryASet16(ds, 0x8580, ax);
    ax = 0x0004;
    push(ax);
    ax = 0x0003;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    dx = 0x0063;
    push(ax);
    push(dx);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_3168;
    ax = memoryAGet16(ds, 0x8580);
    dx = memoryAGet16(ds, 0x857e);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 13, 0x00);
    goto loc_3162;
loc_3145:
    al = memoryAGet(ss, bp - 13);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 13);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1822);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 13, memoryAGet(ss, bp - 13) + 1);
loc_3162:
    if (memoryAGet(ss, bp - 13) < 0x10)
        goto loc_3145;
loc_3168:
    sub_5337();
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    sub_b734();
    al = 0x06;
    memoryASet(ss, bp - 10, al);
    memoryASet(ss, bp - 9, al);
    ax = memoryAGet16(ss, bp - 2);
    dx = memoryAGet16(ss, bp - 4);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    al = memoryAGet(ss, bp - 10);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 12, 0x00);
    goto loc_31f2;
loc_31b2:
    al = memoryAGet(ss, bp - 12);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 11, al);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 9);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    if (memoryAGet(ss, bp - 11) == 0x20)
        goto loc_31ec;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_31ec:
    memoryASet(ss, bp - 9, memoryAGet(ss, bp - 9) + 1);
    memoryASet(ss, bp - 12, memoryAGet(ss, bp - 12) + 1);
loc_31f2:
    if (memoryAGet(ss, bp - 12) < 0x09)
        goto loc_31b2;
    memoryASet(ss, bp - 12, 0x00);
    goto loc_3204;
loc_31fe:
    sub_5d44();
    memoryASet(ss, bp - 12, memoryAGet(ss, bp - 12) + 1);
loc_3204:
    if (memoryAGet(ss, bp - 12) < 0x02)
        goto loc_31fe;
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1349 sub_3219()
sub_3219 PROC
01ed:1349	push	bp
01ed:134a	mov	bp, sp
01ed:134c	dec	sp
01ed:134d	dec	sp
01ed:134e	cmp	word ptr [0x6b4c], sp
01ed:1352	ja	loc_3227
01ed:1354	call	0xffffab83
        	loc_3227:
01ed:1357	mov	byte ptr [bp - 2], 1
01ed:135b	test	byte ptr [0x854f], 1
01ed:1360	je	loc_3236
01ed:1362	mov	al, 0x80
01ed:1364	jmp	loc_3238
        	loc_3236:
01ed:1366	mov	al, 0
        	loc_3238:
01ed:1368	mov	byte ptr [bp - 1], al
01ed:136b	or	al, al
01ed:136d	je	loc_3242
01ed:136f	inc	byte ptr [bp - 2]
        	loc_3242:
01ed:1372	mov	al, byte ptr [0x854f]
01ed:1375	mov	ah, 0
01ed:1377	sar	ax, 1
01ed:1379	or	al, byte ptr [bp - 1]
01ed:137c	mov	byte ptr [0x854f], al
01ed:137f	mov	al, byte ptr [bp - 2]
01ed:1382	push	ax
01ed:1383	call	0x5e7
01ed:1386	inc	sp
01ed:1387	inc	sp
01ed:1388	mov	sp, bp
01ed:138a	pop	bp
01ed:138b	ret	
sub_3219 ENDP
*/
void sub_3219()
{
    // coverage: 0x2549-0x258c method sub_3219
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3227;
    sub_ca53();
loc_3227:
    memoryASet(ss, bp - 2, 0x01);
    if (!(memoryAGet(ds, 0x854f) & 0x01))
        goto loc_3236;
    al = 0x80;
    goto loc_3238;
loc_3236:
    al = 0x00;
loc_3238:
    memoryASet(ss, bp - 1, al);
    if (!al)
        goto loc_3242;
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
loc_3242:
    al = memoryAGet(ds, 0x854f);
    ah = 0x00;
    ax = sar(ax, 1);
    al |= memoryAGet(ss, bp - 1);
    memoryASet(ds, 0x854f, al);
    al = memoryAGet(ss, bp - 2);
    push(ax);
    sub_24b7();
    sp++;
    sp++;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:138c sub_325c()
sub_325c PROC
01ed:138c	push	bp
01ed:138d	mov	bp, sp
01ed:138f	cmp	word ptr [0x6b4c], sp
01ed:1393	ja	loc_3268
01ed:1395	call	0xffffab83
        	loc_3268:
01ed:1398	mov	ax, word ptr [0x857a]
01ed:139b	mov	word ptr [0x8882], ax
01ed:139e	mov	ax, word ptr [0x857c]
01ed:13a1	mov	word ptr [0x8e88], ax
01ed:13a4	mov	ax, word ptr [0x9d36]
01ed:13a7	mov	word ptr [0x857a], ax
01ed:13aa	mov	ax, word ptr [0x9d38]
01ed:13ad	mov	word ptr [0x857c], ax
01ed:13b0	pop	bp
01ed:13b1	ret	
sub_325c ENDP
*/
void sub_325c()
{
    // coverage: 0x258c-0x25b2 method sub_325c
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3268;
    sub_ca53();
loc_3268:
    ax = memoryAGet16(ds, 0x857a);
    memoryASet16(ds, 0x8882, ax);
    ax = memoryAGet16(ds, 0x857c);
    memoryASet16(ds, 0x8e88, ax);
    ax = memoryAGet16(ds, 0x9d36);
    memoryASet16(ds, 0x857a, ax);
    ax = memoryAGet16(ds, 0x9d38);
    memoryASet16(ds, 0x857c, ax);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:13b2 sub_3282()
sub_3282 PROC
01ed:13b2	push	bp
01ed:13b3	mov	bp, sp
01ed:13b5	cmp	word ptr [0x6b4c], sp
01ed:13b9	ja	loc_328e
01ed:13bb	call	0xffffab83
        	loc_328e:
01ed:13be	cmp	byte ptr [0x8571], 0xff
01ed:13c3	je	loc_32ad
01ed:13c5	mov	ax, word ptr [0x8558]
01ed:13c8	mov	word ptr [0x928e], ax
01ed:13cb	mov	ax, word ptr [0x855a]
01ed:13ce	mov	word ptr [0x9b94], ax
01ed:13d1	mov	ax, word ptr [0xa0ca]
01ed:13d4	mov	word ptr [0x8558], ax
01ed:13d7	mov	ax, word ptr [0xa0cc]
01ed:13da	mov	word ptr [0x855a], ax
        	loc_32ad:
01ed:13dd	pop	bp
01ed:13de	ret	
sub_3282 ENDP
*/
void sub_3282()
{
    // coverage: 0x25b2-0x25df method sub_3282
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_328e;
    sub_ca53();
loc_328e:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_32ad;
    ax = memoryAGet16(ds, 0x8558);
    memoryASet16(ds, 0x928e, ax);
    ax = memoryAGet16(ds, 0x855a);
    memoryASet16(ds, 0x9b94, ax);
    ax = memoryAGet16(ds, 0xa0ca);
    memoryASet16(ds, 0x8558, ax);
    ax = memoryAGet16(ds, 0xa0cc);
    memoryASet16(ds, 0x855a, ax);
loc_32ad:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:13df sub_32af()
sub_32af PROC
01ed:13df	push	bp
01ed:13e0	mov	bp, sp
01ed:13e2	cmp	word ptr [0x6b4c], sp
01ed:13e6	ja	loc_32bb
01ed:13e8	call	0xffffab83
        	loc_32bb:
01ed:13eb	mov	al, byte ptr [0x8242]
01ed:13ee	mov	ah, 0
01ed:13f0	or	ax, ax
01ed:13f2	jne	loc_3341
01ed:13f4	cmp	byte ptr [0x824d], 0
01ed:13f9	je	loc_3341
01ed:13fb	cmp	byte ptr [0x792c], 5
01ed:1400	je	loc_3341
01ed:1402	cmp	byte ptr [0x792c], 0xb
01ed:1407	je	loc_3341
01ed:1409	cmp	byte ptr [0x792c], 0x1c
01ed:140e	je	loc_3341
01ed:1410	les	bx, ptr [0xa1ac]
01ed:1414	mov	ax, word ptr es:[bx]
01ed:1417	mov	word ptr [0x824a], ax
01ed:141a	cmp	byte ptr [0x9bae], 0
01ed:141f	je	loc_3305
01ed:1421	mov	ax, word ptr es:[bx + 2]
01ed:1425	neg	ax
01ed:1427	mov	dx, word ptr [0x9290]
01ed:142b	add	dx, ax
01ed:142d	mov	word ptr [0x9290], dx
01ed:1431	mov	ax, dx
01ed:1433	jmp	loc_3314
        	loc_3305:
01ed:1435	les	bx, ptr [0xa1ac]
01ed:1439	mov	ax, word ptr es:[bx + 2]
01ed:143d	add	word ptr [0x9290], ax
01ed:1441	mov	ax, word ptr [0x9290]
        	loc_3314:
01ed:1444	les	bx, ptr [0xa1ac]
01ed:1448	mov	ax, word ptr es:[bx + 4]
01ed:144c	add	word ptr [0x9292], ax
01ed:1450	add	word ptr [0xa1ac], 6
01ed:1455	mov	al, byte ptr [0x824d]
01ed:1458	add	al, 0xff
01ed:145a	mov	byte ptr [0x824d], al
01ed:145d	mov	ah, 0
01ed:145f	or	ax, ax
01ed:1461	jne	loc_333a
01ed:1463	mov	al, 0
01ed:1465	mov	byte ptr [0x792a], al
01ed:1468	jmp	loc_3341
        	loc_333a:
01ed:146a	inc	byte ptr [0x792a]
01ed:146e	mov	al, byte ptr [0x792a]
        	loc_3341:
01ed:1471	pop	bp
01ed:1472	ret	
sub_32af ENDP
*/
void sub_32af()
{
    // coverage: 0x25df-0x2673 method sub_32af
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_32bb;
    sub_ca53();
loc_32bb:
    al = memoryAGet(ds, 0x8242);
    ah = 0x00;
    if (ax)
        goto loc_3341;
    if (memoryAGet(ds, 0x824d) == 0x00)
        goto loc_3341;
    if (memoryAGet(ds, 0x792c) == 0x05)
        goto loc_3341;
    if (memoryAGet(ds, 0x792c) == 0x0b)
        goto loc_3341;
    if (memoryAGet(ds, 0x792c) == 0x1c)
        goto loc_3341;
    bx = memoryAGet16(ds, 0xa1ac);
    es = memoryAGet16(ds, 0xa1ac + 2);
    ax = memoryAGet16(es, bx);
    memoryASet16(ds, 0x824a, ax);
    if (memoryAGet(ds, 0x9bae) == 0x00)
        goto loc_3305;
    ax = memoryAGet16(es, bx + 2);
    ax = -ax;
    dx = memoryAGet16(ds, 0x9290);
    dx += ax;
    memoryASet16(ds, 0x9290, dx);
    ax = dx;
    goto loc_3314;
loc_3305:
    bx = memoryAGet16(ds, 0xa1ac);
    es = memoryAGet16(ds, 0xa1ac + 2);
    ax = memoryAGet16(es, bx + 2);
    memoryASet16(ds, 0x9290, memoryAGet16(ds, 0x9290) + ax);
    ax = memoryAGet16(ds, 0x9290);
loc_3314:
    bx = memoryAGet16(ds, 0xa1ac);
    es = memoryAGet16(ds, 0xa1ac + 2);
    ax = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x9292, memoryAGet16(ds, 0x9292) + ax);
    memoryASet16(ds, 0xa1ac, memoryAGet16(ds, 0xa1ac) + 0x0006);
    al = memoryAGet(ds, 0x824d);
    al += 0xff;
    memoryASet(ds, 0x824d, al);
    ah = 0x00;
    if (ax)
        goto loc_333a;
    al = 0x00;
    memoryASet(ds, 0x792a, al);
    goto loc_3341;
loc_333a:
    memoryASet(ds, 0x792a, memoryAGet(ds, 0x792a) + 1);
    al = memoryAGet(ds, 0x792a);
loc_3341:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1473 sub_3343()
sub_3343 PROC
01ed:1473	push	bp
01ed:1474	mov	bp, sp
01ed:1476	push	si
01ed:1477	push	di
01ed:1478	cmp	word ptr [0x6b4c], sp
01ed:147c	ja	loc_3351
01ed:147e	call	0xffffab83
        	loc_3351:
01ed:1481	les	bx, ptr [0x8884]
01ed:1485	mov	di, word ptr es:[bx + 0x14]
01ed:1489	mov	si, word ptr es:[bx + 0x16]
01ed:148d	mov	ax, word ptr [0x9290]
01ed:1490	sub	ax, di
01ed:1492	mov	cl, 4
01ed:1494	sar	ax, cl
01ed:1496	dec	ax
01ed:1497	mov	word ptr [0x9d36], ax
01ed:149a	mov	ax, word ptr [0x9292]
01ed:149d	sub	ax, si
01ed:149f	sar	ax, 1
01ed:14a1	sar	ax, 1
01ed:14a3	sar	ax, 1
01ed:14a5	mov	word ptr [0x9d38], ax
01ed:14a8	cmp	word ptr [0x9d36], 0
01ed:14ad	jge	loc_3387
01ed:14af	mov	word ptr [0x9d36], 0
01ed:14b5	jmp	loc_3394
        	loc_3387:
01ed:14b7	cmp	word ptr [0x9d36], 0x12
01ed:14bc	jle	loc_3394
01ed:14be	mov	word ptr [0x9d36], 0x12
        	loc_3394:
01ed:14c4	cmp	word ptr [0x9d38], 0
01ed:14c9	jge	loc_33a3
01ed:14cb	mov	word ptr [0x9d38], 0
01ed:14d1	jmp	loc_33b0
        	loc_33a3:
01ed:14d3	cmp	word ptr [0x9d38], 0x16
01ed:14d8	jle	loc_33b0
01ed:14da	mov	word ptr [0x9d38], 0x16
        	loc_33b0:
01ed:14e0	pop	di
01ed:14e1	pop	si
01ed:14e2	pop	bp
01ed:14e3	ret	
sub_3343 ENDP
*/
void sub_3343()
{
    // coverage: 0x2673-0x26e4 method sub_3343
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3351;
    sub_ca53();
loc_3351:
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    di = memoryAGet16(es, bx + 20);
    si = memoryAGet16(es, bx + 22);
    ax = memoryAGet16(ds, 0x9290);
    ax -= di;
    cl = 0x04;
    ax = sar(ax, cl);
    ax--;
    memoryASet16(ds, 0x9d36, ax);
    ax = memoryAGet16(ds, 0x9292);
    ax -= si;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet16(ds, 0x9d38, ax);
    if ((short)memoryAGet16(ds, 0x9d36) >= (short)0x0000)
        goto loc_3387;
    memoryASet16(ds, 0x9d36, 0x0000);
    goto loc_3394;
loc_3387:
    if ((short)memoryAGet16(ds, 0x9d36) <= (short)0x0012)
        goto loc_3394;
    memoryASet16(ds, 0x9d36, 0x0012);
loc_3394:
    if ((short)memoryAGet16(ds, 0x9d38) >= (short)0x0000)
        goto loc_33a3;
    memoryASet16(ds, 0x9d38, 0x0000);
    goto loc_33b0;
loc_33a3:
    if ((short)memoryAGet16(ds, 0x9d38) <= (short)0x0016)
        goto loc_33b0;
    memoryASet16(ds, 0x9d38, 0x0016);
loc_33b0:
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:14e4 sub_33b4()
sub_33b4 PROC
01ed:14e4	push	bp
01ed:14e5	mov	bp, sp
01ed:14e7	sub	sp, 8
01ed:14ea	push	si
01ed:14eb	cmp	word ptr [0x6b4c], sp
01ed:14ef	ja	loc_33c4
01ed:14f1	call	0xffffab83
        	loc_33c4:
01ed:14f4	mov	byte ptr [0x856c], 0
01ed:14f9	mov	cl, 0
01ed:14fb	jmp	loc_3464
        	loc_33ce:
01ed:14fe	mov	al, byte ptr [0x856c]
01ed:1501	mov	ah, 0
01ed:1503	shl	ax, 1
01ed:1505	shl	ax, 1
01ed:1507	mov	bx, ax
01ed:1509	mov	ax, word ptr [bx + 0x4c72]
01ed:150d	mov	dx, word ptr [bx + 0x4c70]
01ed:1511	mov	word ptr [bp - 8], dx
01ed:1514	mov	word ptr [bp - 6], ax
01ed:1517	les	bx, ptr [bp - 8]
01ed:151a	cmp	byte ptr es:[bx], 0
01ed:151e	je	loc_345e
01ed:1520	mov	ax, word ptr es:[bx + 4]
01ed:1524	mov	dx, word ptr es:[bx + 2]
01ed:1528	mov	word ptr [0xa0be], dx
01ed:152c	mov	word ptr [0xa0c0], ax
01ed:152f	les	bx, ptr [0xa0be]
01ed:1533	mov	al, byte ptr es:[bx]
01ed:1536	mov	byte ptr [0x8578], al
01ed:1539	les	bx, ptr [bp - 8]
01ed:153c	inc	word ptr es:[bx + 2]
01ed:1540	mov	byte ptr es:[bx + 6], al
01ed:1544	cmp	byte ptr [0x8578], 0xff
01ed:1549	jne	loc_3421
01ed:154b	mov	byte ptr es:[bx], 0
01ed:154f	jmp	loc_345e
        	loc_3421:
01ed:1551	cmp	byte ptr [0x8578], 0
01ed:1556	je	loc_345e
01ed:1558	mov	al, byte ptr [0x8578]
01ed:155b	mov	ah, 0
01ed:155d	shl	ax, 1
01ed:155f	shl	ax, 1
01ed:1561	mov	bx, ax
01ed:1563	mov	ax, word ptr [bx + 0x3d6c]
01ed:1567	mov	dx, word ptr [bx + 0x3d6a]
01ed:156b	mov	word ptr [bp - 4], dx
01ed:156e	mov	word ptr [bp - 2], ax
01ed:1571	les	bx, ptr [bp - 8]
01ed:1574	push	es
01ed:1575	les	si, ptr [bp - 4]
01ed:1578	mov	ax, word ptr es:[si]
01ed:157b	pop	es
01ed:157c	mov	word ptr es:[bx + 8], ax
01ed:1580	les	bx, ptr [bp - 4]
01ed:1583	mov	ax, word ptr es:[bx + 2]
01ed:1587	les	bx, ptr [bp - 8]
01ed:158a	mov	word ptr es:[bx + 0xa], ax
        	loc_345e:
01ed:158e	inc	byte ptr [0x856c]
01ed:1592	inc	cl
        	loc_3464:
01ed:1594	cmp	cl, 3
01ed:1597	jae	loc_346c
01ed:1599	jmp	loc_33ce
        	loc_346c:
01ed:159c	pop	si
01ed:159d	mov	sp, bp
01ed:159f	pop	bp
01ed:15a0	ret	
sub_33b4 ENDP
*/
void sub_33b4()
{
    // coverage: 0x26e4-0x27a1 method sub_33b4
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_33c4;
    sub_ca53();
loc_33c4:
    memoryASet(ds, 0x856c, 0x00);
    cl = 0x00;
    goto loc_3464;
loc_33ce:
    al = memoryAGet(ds, 0x856c);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19570);
    dx = memoryAGet16(ds, bx + 19568);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    if (memoryAGet(es, bx) == 0x00)
        goto loc_345e;
    ax = memoryAGet16(es, bx + 4);
    dx = memoryAGet16(es, bx + 2);
    memoryASet16(ds, 0xa0be, dx);
    memoryASet16(ds, 0xa0c0, ax);
    bx = memoryAGet16(ds, 0xa0be);
    es = memoryAGet16(ds, 0xa0be + 2);
    al = memoryAGet(es, bx);
    memoryASet(ds, 0x8578, al);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) + 1);
    memoryASet(es, bx + 6, al);
    if (memoryAGet(ds, 0x8578) != 0xff)
        goto loc_3421;
    memoryASet(es, bx, 0x00);
    goto loc_345e;
loc_3421:
    if (memoryAGet(ds, 0x8578) == 0x00)
        goto loc_345e;
    al = memoryAGet(ds, 0x8578);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 15724);
    dx = memoryAGet16(ds, bx + 15722);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    push(es);
    si = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    ax = memoryAGet16(es, si);
    es = pop();
    memoryASet16(es, bx + 8, ax);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    ax = memoryAGet16(es, bx + 2);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    memoryASet16(es, bx + 10, ax);
loc_345e:
    memoryASet(ds, 0x856c, memoryAGet(ds, 0x856c) + 1);
    cl++;
loc_3464:
    if (cl >= 0x03)
        goto loc_346c;
    goto loc_33ce;
loc_346c:
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:15a1 sub_3471()
sub_3471 PROC
01ed:15a1	push	bp
01ed:15a2	mov	bp, sp
01ed:15a4	sub	sp, 8
01ed:15a7	push	si
01ed:15a8	cmp	word ptr [0x6b4c], sp
01ed:15ac	ja	loc_3481
01ed:15ae	call	0xffffab83
        	loc_3481:
01ed:15b1	mov	byte ptr [0x8566], 0
01ed:15b6	mov	cl, 0
01ed:15b8	jmp	loc_3521
        	loc_348b:
01ed:15bb	mov	al, byte ptr [0x8566]
01ed:15be	mov	ah, 0
01ed:15c0	shl	ax, 1
01ed:15c2	shl	ax, 1
01ed:15c4	mov	bx, ax
01ed:15c6	mov	ax, word ptr [bx + 0x4cbe]
01ed:15ca	mov	dx, word ptr [bx + 0x4cbc]
01ed:15ce	mov	word ptr [bp - 8], dx
01ed:15d1	mov	word ptr [bp - 6], ax
01ed:15d4	les	bx, ptr [bp - 8]
01ed:15d7	cmp	byte ptr es:[bx], 0
01ed:15db	je	loc_351b
01ed:15dd	mov	ax, word ptr es:[bx + 4]
01ed:15e1	mov	dx, word ptr es:[bx + 2]
01ed:15e5	mov	word ptr [0xa0c2], dx
01ed:15e9	mov	word ptr [0xa0c4], ax
01ed:15ec	les	bx, ptr [0xa0c2]
01ed:15f0	mov	al, byte ptr es:[bx]
01ed:15f3	mov	byte ptr [0x8579], al
01ed:15f6	les	bx, ptr [bp - 8]
01ed:15f9	inc	word ptr es:[bx + 2]
01ed:15fd	mov	byte ptr es:[bx + 6], al
01ed:1601	cmp	byte ptr [0x8579], 0xff
01ed:1606	jne	loc_34de
01ed:1608	mov	byte ptr es:[bx], 0
01ed:160c	jmp	loc_351b
        	loc_34de:
01ed:160e	cmp	byte ptr [0x8579], 0
01ed:1613	je	loc_351b
01ed:1615	mov	al, byte ptr [0x8579]
01ed:1618	mov	ah, 0
01ed:161a	shl	ax, 1
01ed:161c	shl	ax, 1
01ed:161e	mov	bx, ax
01ed:1620	mov	ax, word ptr [bx + 0x40a8]
01ed:1624	mov	dx, word ptr [bx + 0x40a6]
01ed:1628	mov	word ptr [bp - 4], dx
01ed:162b	mov	word ptr [bp - 2], ax
01ed:162e	les	bx, ptr [bp - 8]
01ed:1631	push	es
01ed:1632	les	si, ptr [bp - 4]
01ed:1635	mov	ax, word ptr es:[si]
01ed:1638	pop	es
01ed:1639	mov	word ptr es:[bx + 8], ax
01ed:163d	les	bx, ptr [bp - 4]
01ed:1640	mov	ax, word ptr es:[bx + 2]
01ed:1644	les	bx, ptr [bp - 8]
01ed:1647	mov	word ptr es:[bx + 0xa], ax
        	loc_351b:
01ed:164b	inc	byte ptr [0x8566]
01ed:164f	inc	cl
        	loc_3521:
01ed:1651	cmp	cl, 4
01ed:1654	jae	loc_3529
01ed:1656	jmp	loc_348b
        	loc_3529:
01ed:1659	pop	si
01ed:165a	mov	sp, bp
01ed:165c	pop	bp
01ed:165d	ret	
sub_3471 ENDP
*/
void sub_3471()
{
    // coverage: 0x27a1-0x285e method sub_3471
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3481;
    sub_ca53();
loc_3481:
    memoryASet(ds, 0x8566, 0x00);
    cl = 0x00;
    goto loc_3521;
loc_348b:
    al = memoryAGet(ds, 0x8566);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19646);
    dx = memoryAGet16(ds, bx + 19644);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    if (memoryAGet(es, bx) == 0x00)
        goto loc_351b;
    ax = memoryAGet16(es, bx + 4);
    dx = memoryAGet16(es, bx + 2);
    memoryASet16(ds, 0xa0c2, dx);
    memoryASet16(ds, 0xa0c4, ax);
    bx = memoryAGet16(ds, 0xa0c2);
    es = memoryAGet16(ds, 0xa0c2 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ds, 0x8579, al);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) + 1);
    memoryASet(es, bx + 6, al);
    if (memoryAGet(ds, 0x8579) != 0xff)
        goto loc_34de;
    memoryASet(es, bx, 0x00);
    goto loc_351b;
loc_34de:
    if (memoryAGet(ds, 0x8579) == 0x00)
        goto loc_351b;
    al = memoryAGet(ds, 0x8579);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 16552);
    dx = memoryAGet16(ds, bx + 16550);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    push(es);
    si = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    ax = memoryAGet16(es, si);
    es = pop();
    memoryASet16(es, bx + 8, ax);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    ax = memoryAGet16(es, bx + 2);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    memoryASet16(es, bx + 10, ax);
loc_351b:
    memoryASet(ds, 0x8566, memoryAGet(ds, 0x8566) + 1);
    cl++;
loc_3521:
    if (cl >= 0x04)
        goto loc_3529;
    goto loc_348b;
loc_3529:
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:165e sub_352e()
sub_352e PROC
01ed:165e	push	bp
01ed:165f	mov	bp, sp
01ed:1661	sub	sp, 0xc
01ed:1664	push	si
01ed:1665	push	di
01ed:1666	cmp	word ptr [0x6b4c], sp
01ed:166a	ja	loc_353f
01ed:166c	call	0xffffab83
        	loc_353f:
01ed:166f	mov	byte ptr [bp - 2], 0
        	loc_3543:
01ed:1673	mov	al, byte ptr [bp - 2]
01ed:1676	mov	ah, 0
01ed:1678	shl	ax, 1
01ed:167a	shl	ax, 1
01ed:167c	mov	bx, ax
01ed:167e	mov	ax, word ptr [bx + 0x4c72]
01ed:1682	mov	dx, word ptr [bx + 0x4c70]
01ed:1686	mov	word ptr [bp - 0xc], dx
01ed:1689	mov	word ptr [bp - 0xa], ax
01ed:168c	les	bx, ptr [bp - 0xc]
01ed:168f	mov	al, byte ptr es:[bx]
01ed:1692	mov	byte ptr [bp - 1], al
01ed:1695	cmp	byte ptr [bp - 1], 0
01ed:1699	jne	loc_356e
01ed:169b	jmp	loc_3685
        	loc_356e:
01ed:169e	cmp	byte ptr [bp - 1], 0xff
01ed:16a2	jne	loc_3577
01ed:16a4	jmp	loc_3685
        	loc_3577:
01ed:16a7	mov	al, byte ptr es:[bx + 1]
01ed:16ab	mov	byte ptr [bp - 3], al
01ed:16ae	mov	ah, 0
01ed:16b0	shl	ax, 1
01ed:16b2	shl	ax, 1
01ed:16b4	mov	bx, ax
01ed:16b6	mov	di, word ptr [bx + 0x32be]
01ed:16ba	mov	al, byte ptr [bp - 3]
01ed:16bd	mov	ah, 0
01ed:16bf	shl	ax, 1
01ed:16c1	shl	ax, 1
01ed:16c3	mov	bx, ax
01ed:16c5	mov	si, word ptr [bx + 0x32c0]
01ed:16c9	les	bx, ptr [0x8d4]
01ed:16cd	mov	word ptr es:[bx + 0x1c], 0
01ed:16d3	test	byte ptr [bp - 3], 1
01ed:16d7	je	loc_35b4
01ed:16d9	mov	ax, word ptr es:[bx + 0x1c]
01ed:16dd	or	ax, 0x600
01ed:16e0	mov	word ptr es:[bx + 0x1c], ax
        	loc_35b4:
01ed:16e4	les	bx, ptr [0x8d4]
01ed:16e8	mov	ax, di
01ed:16ea	mov	word ptr es:[bx + 0x14], ax
01ed:16ee	mov	word ptr es:[bx + 6], ax
01ed:16f2	mov	ax, si
01ed:16f4	mov	word ptr es:[bx + 0x16], ax
01ed:16f8	mov	word ptr es:[bx + 8], ax
01ed:16fc	push	word ptr [0x8d6]
01ed:1700	push	word ptr [0x8d4]
01ed:1704	call	0x80bc
01ed:1707	add	sp, 4
01ed:170a	mov	al, byte ptr [bp - 3]
01ed:170d	mov	ah, 0
01ed:170f	shl	ax, 1
01ed:1711	shl	ax, 1
01ed:1713	mov	bx, ax
01ed:1715	mov	ax, word ptr [bx + 0xf4]
01ed:1719	mov	word ptr [bp - 6], ax
01ed:171c	mov	al, byte ptr [bp - 3]
01ed:171f	mov	ah, 0
01ed:1721	shl	ax, 1
01ed:1723	shl	ax, 1
01ed:1725	mov	bx, ax
01ed:1727	mov	ax, word ptr [bx + 0xf6]
01ed:172b	mov	word ptr [bp - 8], ax
01ed:172e	les	bx, ptr [0x8884]
01ed:1732	mov	ax, word ptr [bp - 6]
01ed:1735	mov	word ptr es:[bx], ax
01ed:1738	les	bx, ptr [bp - 0xc]
01ed:173b	mov	ax, word ptr [bp - 8]
01ed:173e	add	ax, word ptr es:[bx + 8]
01ed:1742	les	bx, ptr [0x8884]
01ed:1746	mov	word ptr es:[bx + 2], ax
01ed:174a	les	bx, ptr [bp - 0xc]
01ed:174d	mov	ax, word ptr es:[bx + 0xa]
01ed:1751	les	bx, ptr [0x8884]
01ed:1755	mov	word ptr es:[bx + 4], ax
01ed:1759	les	bx, ptr [bp - 0xc]
01ed:175c	test	word ptr es:[bx + 0xa], 0x200
01ed:1762	jne	loc_363f
01ed:1764	push	ds
01ed:1765	mov	ax, 0x792e
01ed:1768	push	ax
01ed:1769	call	0x942a
01ed:176c	add	sp, 4
        	loc_363f:
01ed:176f	les	bx, ptr [0x8e0]
01ed:1773	mov	word ptr es:[bx + 6], di
01ed:1777	mov	word ptr es:[bx + 8], si
01ed:177b	mov	al, byte ptr [bp - 2]
01ed:177e	mov	ah, 0
01ed:1780	mov	dx, 0x180
01ed:1783	imul	dx
01ed:1785	add	ax, 0x79be
01ed:1788	mov	word ptr es:[bx + 0x10], ax
01ed:178c	mov	word ptr es:[bx + 0x12], ds
01ed:1790	mov	word ptr es:[bx + 0x1c], 0
01ed:1796	test	byte ptr [bp - 3], 1
01ed:179a	je	loc_3677
01ed:179c	mov	ax, word ptr es:[bx + 0x1c]
01ed:17a0	or	ax, 0x200
01ed:17a3	mov	word ptr es:[bx + 0x1c], ax
        	loc_3677:
01ed:17a7	push	word ptr [0x8e2]
01ed:17ab	push	word ptr [0x8e0]
01ed:17af	call	0x93b8
01ed:17b2	add	sp, 4
        	loc_3685:
01ed:17b5	inc	byte ptr [bp - 2]
01ed:17b8	cmp	byte ptr [bp - 1], 0xff
01ed:17bc	je	loc_3691
01ed:17be	jmp	loc_3543
        	loc_3691:
01ed:17c1	pop	di
01ed:17c2	pop	si
01ed:17c3	mov	sp, bp
01ed:17c5	pop	bp
01ed:17c6	ret	
sub_352e ENDP
*/
void sub_352e()
{
    // coverage: 0x285e-0x29c7 method sub_352e
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000c;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_353f;
    sub_ca53();
loc_353f:
    memoryASet(ss, bp - 2, 0x00);
loc_3543:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19570);
    dx = memoryAGet16(ds, bx + 19568);
    memoryASet16(ss, bp - 12, dx);
    memoryASet16(ss, bp - 10, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_356e;
    goto loc_3685;
loc_356e:
    if (memoryAGet(ss, bp - 1) != 0xff)
        goto loc_3577;
    goto loc_3685;
loc_3577:
    al = memoryAGet(es, bx + 1);
    memoryASet(ss, bp - 3, al);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    di = memoryAGet16(ds, bx + 12990);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    si = memoryAGet16(ds, bx + 12992);
    bx = memoryAGet16(ds, 0x08d4);
    es = memoryAGet16(ds, 0x08d4 + 2);
    memoryASet16(es, bx + 28, 0x0000);
    if (!(memoryAGet(ss, bp - 3) & 0x01))
        goto loc_35b4;
    ax = memoryAGet16(es, bx + 28);
    ax |= 0x0600;
    memoryASet16(es, bx + 28, ax);
loc_35b4:
    bx = memoryAGet16(ds, 0x08d4);
    es = memoryAGet16(ds, 0x08d4 + 2);
    ax = di;
    memoryASet16(es, bx + 20, ax);
    memoryASet16(es, bx + 6, ax);
    ax = si;
    memoryASet16(es, bx + 22, ax);
    memoryASet16(es, bx + 8, ax);
    push(memoryAGet16(ds, 0x08d6));
    push(memoryAGet16(ds, 0x08d4));
    sub_9f8c();
    sp += 0x0004;
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 244);
    memoryASet16(ss, bp - 6, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 246);
    memoryASet16(ss, bp - 8, ax);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ss, bp - 6);
    memoryASet16(es, bx, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    ax = memoryAGet16(ss, bp - 8);
    ax += memoryAGet16(es, bx + 8);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    ax = memoryAGet16(es, bx + 10);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 4, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    if (memoryAGet16(es, bx + 10) & 0x0200)
        goto loc_363f;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_363f:
    bx = memoryAGet16(ds, 0x08e0);
    es = memoryAGet16(ds, 0x08e0 + 2);
    memoryASet16(es, bx + 6, di);
    memoryASet16(es, bx + 8, si);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    dx = 0x0180;
    imul(dx);
    ax += 0x79be;
    memoryASet16(es, bx + 16, ax);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 28, 0x0000);
    if (!(memoryAGet(ss, bp - 3) & 0x01))
        goto loc_3677;
    ax = memoryAGet16(es, bx + 28);
    ax |= 0x0200;
    memoryASet16(es, bx + 28, ax);
loc_3677:
    push(memoryAGet16(ds, 0x08e2));
    push(memoryAGet16(ds, 0x08e0));
    sub_b288();
    sp += 0x0004;
loc_3685:
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
    if (memoryAGet(ss, bp - 1) == 0xff)
        goto loc_3691;
    goto loc_3543;
loc_3691:
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:17c7 sub_3697()
sub_3697 PROC
01ed:17c7	push	bp
01ed:17c8	mov	bp, sp
01ed:17ca	sub	sp, 0xc
01ed:17cd	push	si
01ed:17ce	push	di
01ed:17cf	cmp	word ptr [0x6b4c], sp
01ed:17d3	ja	loc_36a8
01ed:17d5	call	0xffffab83
        	loc_36a8:
01ed:17d8	mov	byte ptr [bp - 2], 0
        	loc_36ac:
01ed:17dc	mov	al, byte ptr [bp - 2]
01ed:17df	mov	ah, 0
01ed:17e1	shl	ax, 1
01ed:17e3	shl	ax, 1
01ed:17e5	mov	bx, ax
01ed:17e7	mov	ax, word ptr [bx + 0x4cbe]
01ed:17eb	mov	dx, word ptr [bx + 0x4cbc]
01ed:17ef	mov	word ptr [bp - 0xc], dx
01ed:17f2	mov	word ptr [bp - 0xa], ax
01ed:17f5	les	bx, ptr [bp - 0xc]
01ed:17f8	mov	al, byte ptr es:[bx]
01ed:17fb	mov	byte ptr [bp - 1], al
01ed:17fe	cmp	byte ptr [bp - 1], 0
01ed:1802	jne	loc_36d7
01ed:1804	jmp	loc_385f
        	loc_36d7:
01ed:1807	cmp	byte ptr [bp - 1], 0xff
01ed:180b	jne	loc_36e0
01ed:180d	jmp	loc_385f
        	loc_36e0:
01ed:1810	mov	al, byte ptr es:[bx + 1]
01ed:1814	mov	byte ptr [bp - 3], al
01ed:1817	mov	ah, 0
01ed:1819	shl	ax, 1
01ed:181b	shl	ax, 1
01ed:181d	mov	bx, ax
01ed:181f	mov	di, word ptr [bx + 0x343e]
01ed:1823	mov	al, byte ptr [bp - 3]
01ed:1826	mov	ah, 0
01ed:1828	shl	ax, 1
01ed:182a	shl	ax, 1
01ed:182c	mov	bx, ax
01ed:182e	mov	si, word ptr [bx + 0x3440]
01ed:1832	les	bx, ptr [0x8c8]
01ed:1836	mov	word ptr es:[bx + 6], di
01ed:183a	mov	word ptr es:[bx + 8], si
01ed:183e	push	word ptr [0x8ca]
01ed:1842	push	word ptr [0x8c8]
01ed:1846	call	0x80ac
01ed:1849	add	sp, 4
01ed:184c	les	bx, ptr [0x8cc]
01ed:1850	mov	word ptr es:[bx + 0xa], 1
01ed:1856	xor	ax, ax
01ed:1858	mov	word ptr es:[bx + 0x16], ax
01ed:185c	mov	word ptr es:[bx + 0x14], ax
01ed:1860	mov	word ptr es:[bx + 0x1c], 4
01ed:1866	test	byte ptr [bp - 3], 1
01ed:186a	je	loc_3760
01ed:186c	mov	word ptr es:[bx + 2], 0x9fba
01ed:1872	mov	word ptr es:[bx + 4], ds
01ed:1876	push	word ptr [0x8ce]
01ed:187a	push	word ptr [0x8cc]
01ed:187e	call	0x80ac
01ed:1881	add	sp, 4
01ed:1884	les	bx, ptr [0x8cc]
01ed:1888	mov	word ptr es:[bx + 2], 0x9eba
01ed:188e	jmp	loc_3786
        	loc_3760:
01ed:1890	les	bx, ptr [0x8cc]
01ed:1894	mov	word ptr es:[bx + 2], 0x9eba
01ed:189a	mov	word ptr es:[bx + 4], ds
01ed:189e	push	word ptr [0x8ce]
01ed:18a2	push	word ptr [0x8cc]
01ed:18a6	call	0x80ac
01ed:18a9	add	sp, 4
01ed:18ac	les	bx, ptr [0x8cc]
01ed:18b0	mov	word ptr es:[bx + 2], 0x9fba
        	loc_3786:
01ed:18b6	mov	word ptr es:[bx + 4], ds
01ed:18ba	les	bx, ptr [0x8cc]
01ed:18be	mov	word ptr es:[bx + 0x14], di
01ed:18c2	mov	word ptr es:[bx + 0x16], si
01ed:18c6	push	word ptr [0x8ce]
01ed:18ca	push	word ptr [0x8cc]
01ed:18ce	call	0x80bc
01ed:18d1	add	sp, 4
01ed:18d4	les	bx, ptr [0x8cc]
01ed:18d8	mov	word ptr es:[bx + 2], 0x8888
01ed:18de	mov	word ptr es:[bx + 4], ds
01ed:18e2	mov	word ptr es:[bx + 0xa], 3
01ed:18e8	mov	word ptr es:[bx + 0x1c], 3
01ed:18ee	push	word ptr [0x8ce]
01ed:18f2	push	word ptr [0x8cc]
01ed:18f6	call	0x80bc
01ed:18f9	add	sp, 4
01ed:18fc	mov	al, byte ptr [bp - 3]
01ed:18ff	mov	ah, 0
01ed:1901	shl	ax, 1
01ed:1903	shl	ax, 1
01ed:1905	mov	bx, ax
01ed:1907	mov	ax, word ptr [bx + 0x3f4]
01ed:190b	mov	word ptr [bp - 6], ax
01ed:190e	mov	al, byte ptr [bp - 3]
01ed:1911	mov	ah, 0
01ed:1913	shl	ax, 1
01ed:1915	shl	ax, 1
01ed:1917	mov	bx, ax
01ed:1919	mov	ax, word ptr [bx + 0x3f6]
01ed:191d	mov	word ptr [bp - 8], ax
01ed:1920	les	bx, ptr [0x8884]
01ed:1924	mov	ax, word ptr [bp - 6]
01ed:1927	mov	word ptr es:[bx], ax
01ed:192a	les	bx, ptr [bp - 0xc]
01ed:192d	mov	ax, word ptr [bp - 8]
01ed:1930	add	ax, word ptr es:[bx + 8]
01ed:1934	les	bx, ptr [0x8884]
01ed:1938	mov	word ptr es:[bx + 2], ax
01ed:193c	les	bx, ptr [bp - 0xc]
01ed:193f	test	word ptr es:[bx + 0xa], 0x200
01ed:1945	jne	loc_3831
01ed:1947	mov	ax, word ptr es:[bx + 0xa]
01ed:194b	add	ax, 0xf1
01ed:194e	les	bx, ptr [0x8884]
01ed:1952	mov	word ptr es:[bx + 4], ax
01ed:1956	push	ds
01ed:1957	mov	ax, 0x792e
01ed:195a	push	ax
01ed:195b	call	0x942a
01ed:195e	add	sp, 4
        	loc_3831:
01ed:1961	les	bx, ptr [0x8d0]
01ed:1965	mov	word ptr es:[bx + 6], di
01ed:1969	mov	word ptr es:[bx + 8], si
01ed:196d	mov	al, byte ptr [bp - 2]
01ed:1970	mov	ah, 0
01ed:1972	mov	cl, 8
01ed:1974	shl	ax, cl
01ed:1976	add	ax, 0x7e3e
01ed:1979	mov	word ptr es:[bx + 0x10], ax
01ed:197d	mov	word ptr es:[bx + 0x12], ds
01ed:1981	push	word ptr [0x8d2]
01ed:1985	push	word ptr [0x8d0]
01ed:1989	call	0x93b8
01ed:198c	add	sp, 4
        	loc_385f:
01ed:198f	inc	byte ptr [bp - 2]
01ed:1992	cmp	byte ptr [bp - 1], 0xff
01ed:1996	je	loc_386b
01ed:1998	jmp	loc_36ac
        	loc_386b:
01ed:199b	pop	di
01ed:199c	pop	si
01ed:199d	mov	sp, bp
01ed:199f	pop	bp
01ed:19a0	ret	
sub_3697 ENDP
*/
void sub_3697()
{
    // coverage: 0x29c7-0x2ba1 method sub_3697
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000c;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_36a8;
    sub_ca53();
loc_36a8:
    memoryASet(ss, bp - 2, 0x00);
loc_36ac:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19646);
    dx = memoryAGet16(ds, bx + 19644);
    memoryASet16(ss, bp - 12, dx);
    memoryASet16(ss, bp - 10, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_36d7;
    goto loc_385f;
loc_36d7:
    if (memoryAGet(ss, bp - 1) != 0xff)
        goto loc_36e0;
    goto loc_385f;
loc_36e0:
    al = memoryAGet(es, bx + 1);
    memoryASet(ss, bp - 3, al);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    di = memoryAGet16(ds, bx + 13374);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    si = memoryAGet16(ds, bx + 13376);
    bx = memoryAGet16(ds, 0x08c8);
    es = memoryAGet16(ds, 0x08c8 + 2);
    memoryASet16(es, bx + 6, di);
    memoryASet16(es, bx + 8, si);
    push(memoryAGet16(ds, 0x08ca));
    push(memoryAGet16(ds, 0x08c8));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 10, 0x0001);
    ax = 0;
    memoryASet16(es, bx + 22, ax);
    memoryASet16(es, bx + 20, ax);
    memoryASet16(es, bx + 28, 0x0004);
    if (!(memoryAGet(ss, bp - 3) & 0x01))
        goto loc_3760;
    memoryASet16(es, bx + 2, 0x9fba);
    memoryASet16(es, bx + 4, ds);
    push(memoryAGet16(ds, 0x08ce));
    push(memoryAGet16(ds, 0x08cc));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 2, 0x9eba);
    goto loc_3786;
loc_3760:
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 2, 0x9eba);
    memoryASet16(es, bx + 4, ds);
    push(memoryAGet16(ds, 0x08ce));
    push(memoryAGet16(ds, 0x08cc));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 2, 0x9fba);
loc_3786:
    memoryASet16(es, bx + 4, ds);
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 20, di);
    memoryASet16(es, bx + 22, si);
    push(memoryAGet16(ds, 0x08ce));
    push(memoryAGet16(ds, 0x08cc));
    sub_9f8c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 2, 0x8888);
    memoryASet16(es, bx + 4, ds);
    memoryASet16(es, bx + 10, 0x0003);
    memoryASet16(es, bx + 28, 0x0003);
    push(memoryAGet16(ds, 0x08ce));
    push(memoryAGet16(ds, 0x08cc));
    sub_9f8c();
    sp += 0x0004;
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 1012);
    memoryASet16(ss, bp - 6, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 1014);
    memoryASet16(ss, bp - 8, ax);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ss, bp - 6);
    memoryASet16(es, bx, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    ax = memoryAGet16(ss, bp - 8);
    ax += memoryAGet16(es, bx + 8);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    if (memoryAGet16(es, bx + 10) & 0x0200)
        goto loc_3831;
    ax = memoryAGet16(es, bx + 10);
    ax += 0x00f1;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 4, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_3831:
    bx = memoryAGet16(ds, 0x08d0);
    es = memoryAGet16(ds, 0x08d0 + 2);
    memoryASet16(es, bx + 6, di);
    memoryASet16(es, bx + 8, si);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    cl = 0x08;
    ax <<= cl;
    ax += 0x7e3e;
    memoryASet16(es, bx + 16, ax);
    memoryASet16(es, bx + 18, ds);
    push(memoryAGet16(ds, 0x08d2));
    push(memoryAGet16(ds, 0x08d0));
    sub_b288();
    sp += 0x0004;
loc_385f:
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
    if (memoryAGet(ss, bp - 1) == 0xff)
        goto loc_386b;
    goto loc_36ac;
loc_386b:
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:19a1 sub_3871()
sub_3871 PROC
01ed:19a1	push	bp
01ed:19a2	mov	bp, sp
01ed:19a4	cmp	word ptr [0x6b4c], sp
01ed:19a8	ja	loc_387d
01ed:19aa	call	0xffffab83
        	loc_387d:
01ed:19ad	cmp	byte ptr [0x8571], 0xff
01ed:19b2	je	loc_38b2
01ed:19b4	les	bx, ptr [0x8e8]
01ed:19b8	mov	ax, word ptr [0x928e]
01ed:19bb	mov	word ptr es:[bx + 0x14], ax
01ed:19bf	mov	ax, word ptr [0x9b94]
01ed:19c2	mov	word ptr es:[bx + 0x16], ax
01ed:19c6	mov	ax, word ptr [0x9d34]
01ed:19c9	mov	word ptr es:[bx + 0x1e], ax
01ed:19cd	mov	ax, word ptr [0x9d32]
01ed:19d0	mov	word ptr es:[bx + 0x20], ax
01ed:19d4	push	word ptr [0x8ea]
01ed:19d8	push	word ptr [0x8e8]
01ed:19dc	call	0x80bc
01ed:19df	add	sp, 4
        	loc_38b2:
01ed:19e2	pop	bp
01ed:19e3	ret	
sub_3871 ENDP
*/
void sub_3871()
{
    // coverage: 0x2ba1-0x2be4 method sub_3871
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_387d;
    sub_ca53();
loc_387d:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_38b2;
    bx = memoryAGet16(ds, 0x08e8);
    es = memoryAGet16(ds, 0x08e8 + 2);
    ax = memoryAGet16(ds, 0x928e);
    memoryASet16(es, bx + 20, ax);
    ax = memoryAGet16(ds, 0x9b94);
    memoryASet16(es, bx + 22, ax);
    ax = memoryAGet16(ds, 0x9d34);
    memoryASet16(es, bx + 30, ax);
    ax = memoryAGet16(ds, 0x9d32);
    memoryASet16(es, bx + 32, ax);
    push(memoryAGet16(ds, 0x08ea));
    push(memoryAGet16(ds, 0x08e8));
    sub_9f8c();
    sp += 0x0004;
loc_38b2:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:19e4 sub_38b4()
sub_38b4 PROC
01ed:19e4	push	bp
01ed:19e5	mov	bp, sp
01ed:19e7	cmp	word ptr [0x6b4c], sp
01ed:19eb	ja	loc_38c0
01ed:19ed	call	0xffffab83
        	loc_38c0:
01ed:19f0	les	bx, ptr [0x8c4]
01ed:19f4	mov	ax, word ptr [0x8882]
01ed:19f7	mov	word ptr es:[bx + 0x14], ax
01ed:19fb	mov	ax, word ptr [0x8e88]
01ed:19fe	mov	word ptr es:[bx + 0x16], ax
01ed:1a02	mov	ax, word ptr [0x9ba4]
01ed:1a05	mov	word ptr es:[bx + 0x1e], ax
01ed:1a09	mov	ax, word ptr [0x9b9c]
01ed:1a0c	mov	word ptr es:[bx + 0x20], ax
01ed:1a10	push	word ptr [0x8c6]
01ed:1a14	push	word ptr [0x8c4]
01ed:1a18	call	0x80bc
01ed:1a1b	add	sp, 4
01ed:1a1e	pop	bp
01ed:1a1f	ret	
sub_38b4 ENDP
*/
void sub_38b4()
{
    // coverage: 0x2be4-0x2c20 method sub_38b4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_38c0;
    sub_ca53();
loc_38c0:
    bx = memoryAGet16(ds, 0x08c4);
    es = memoryAGet16(ds, 0x08c4 + 2);
    ax = memoryAGet16(ds, 0x8882);
    memoryASet16(es, bx + 20, ax);
    ax = memoryAGet16(ds, 0x8e88);
    memoryASet16(es, bx + 22, ax);
    ax = memoryAGet16(ds, 0x9ba4);
    memoryASet16(es, bx + 30, ax);
    ax = memoryAGet16(ds, 0x9b9c);
    memoryASet16(es, bx + 32, ax);
    push(memoryAGet16(ds, 0x08c6));
    push(memoryAGet16(ds, 0x08c4));
    sub_9f8c();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1a20 sub_38f0()
sub_38f0 PROC
01ed:1a20	push	bp
01ed:1a21	mov	bp, sp
01ed:1a23	cmp	word ptr [0x6b4c], sp
01ed:1a27	ja	loc_38fc
01ed:1a29	call	0xffffab83
        	loc_38fc:
01ed:1a2c	cmp	byte ptr [0xa1a8], 0
01ed:1a31	je	loc_3935
01ed:1a33	dec	byte ptr [0xa1a8]
01ed:1a37	les	bx, ptr [0x8e4]
01ed:1a3b	mov	ax, word ptr [0x9b9a]
01ed:1a3e	mov	word ptr es:[bx + 6], ax
01ed:1a42	mov	ax, word ptr [0x9ba2]
01ed:1a45	mov	word ptr es:[bx + 8], ax
01ed:1a49	mov	ax, word ptr [0x9b9a]
01ed:1a4c	mov	word ptr es:[bx + 0x14], ax
01ed:1a50	mov	ax, word ptr [0x9ba2]
01ed:1a53	mov	word ptr es:[bx + 0x16], ax
01ed:1a57	push	word ptr [0x8e6]
01ed:1a5b	push	word ptr [0x8e4]
01ed:1a5f	call	0x80bc
01ed:1a62	add	sp, 4
        	loc_3935:
01ed:1a65	pop	bp
01ed:1a66	ret	
sub_38f0 ENDP
*/
void sub_38f0()
{
    // coverage: 0x2c20-0x2c67 method sub_38f0
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_38fc;
    sub_ca53();
loc_38fc:
    if (memoryAGet(ds, 0xa1a8) == 0x00)
        goto loc_3935;
    memoryASet(ds, 0xa1a8, memoryAGet(ds, 0xa1a8) - 1);
    bx = memoryAGet16(ds, 0x08e4);
    es = memoryAGet16(ds, 0x08e4 + 2);
    ax = memoryAGet16(ds, 0x9b9a);
    memoryASet16(es, bx + 6, ax);
    ax = memoryAGet16(ds, 0x9ba2);
    memoryASet16(es, bx + 8, ax);
    ax = memoryAGet16(ds, 0x9b9a);
    memoryASet16(es, bx + 20, ax);
    ax = memoryAGet16(ds, 0x9ba2);
    memoryASet16(es, bx + 22, ax);
    push(memoryAGet16(ds, 0x08e6));
    push(memoryAGet16(ds, 0x08e4));
    sub_9f8c();
    sp += 0x0004;
loc_3935:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1a67 sub_3937()
sub_3937 PROC
01ed:1a67	push	bp
01ed:1a68	mov	bp, sp
01ed:1a6a	sub	sp, 8
01ed:1a6d	cmp	word ptr [0x6b4c], sp
01ed:1a71	ja	loc_3946
01ed:1a73	call	0xffffab83
        	loc_3946:
01ed:1a76	mov	byte ptr [bp - 2], 0
        	loc_394a:
01ed:1a7a	mov	al, byte ptr [bp - 2]
01ed:1a7d	mov	ah, 0
01ed:1a7f	shl	ax, 1
01ed:1a81	shl	ax, 1
01ed:1a83	mov	bx, ax
01ed:1a85	mov	ax, word ptr [bx + 0x4c72]
01ed:1a89	mov	dx, word ptr [bx + 0x4c70]
01ed:1a8d	mov	word ptr [bp - 8], dx
01ed:1a90	mov	word ptr [bp - 6], ax
01ed:1a93	les	bx, ptr [bp - 8]
01ed:1a96	mov	al, byte ptr es:[bx]
01ed:1a99	mov	byte ptr [bp - 1], al
01ed:1a9c	cmp	byte ptr [bp - 1], 0
01ed:1aa0	je	loc_39eb
01ed:1aa2	cmp	byte ptr [bp - 1], 0xff
01ed:1aa6	je	loc_39eb
01ed:1aa8	mov	al, byte ptr es:[bx + 1]
01ed:1aac	mov	byte ptr [bp - 3], al
01ed:1aaf	mov	al, byte ptr [bp - 2]
01ed:1ab2	mov	ah, 0
01ed:1ab4	mov	dx, 0x180
01ed:1ab7	imul	dx
01ed:1ab9	add	ax, 0x79be
01ed:1abc	les	bx, ptr [0x8c0]
01ed:1ac0	mov	word ptr es:[bx + 2], ax
01ed:1ac4	mov	word ptr es:[bx + 4], ds
01ed:1ac8	mov	al, byte ptr [bp - 3]
01ed:1acb	mov	ah, 0
01ed:1acd	shl	ax, 1
01ed:1acf	shl	ax, 1
01ed:1ad1	mov	bx, ax
01ed:1ad3	mov	ax, word ptr [bx + 0x32be]
01ed:1ad7	mov	bx, word ptr [0x8c0]
01ed:1adb	mov	word ptr es:[bx + 0x14], ax
01ed:1adf	mov	al, byte ptr [bp - 3]
01ed:1ae2	mov	ah, 0
01ed:1ae4	shl	ax, 1
01ed:1ae6	shl	ax, 1
01ed:1ae8	mov	bx, ax
01ed:1aea	mov	ax, word ptr [bx + 0x32c0]
01ed:1aee	mov	bx, word ptr [0x8c0]
01ed:1af2	mov	word ptr es:[bx + 0x16], ax
01ed:1af6	mov	word ptr es:[bx + 0x1c], 0
01ed:1afc	test	byte ptr [bp - 3], 1
01ed:1b00	je	loc_39dd
01ed:1b02	mov	ax, word ptr es:[bx + 0x1c]
01ed:1b06	or	ax, 0x400
01ed:1b09	mov	word ptr es:[bx + 0x1c], ax
        	loc_39dd:
01ed:1b0d	push	word ptr [0x8c2]
01ed:1b11	push	word ptr [0x8c0]
01ed:1b15	call	0x80bc
01ed:1b18	add	sp, 4
        	loc_39eb:
01ed:1b1b	inc	byte ptr [bp - 2]
01ed:1b1e	cmp	byte ptr [bp - 1], 0xff
01ed:1b22	je	loc_39f7
01ed:1b24	jmp	loc_394a
        	loc_39f7:
01ed:1b27	mov	sp, bp
01ed:1b29	pop	bp
01ed:1b2a	ret	
sub_3937 ENDP
*/
void sub_3937()
{
    // coverage: 0x2c67-0x2d2b method sub_3937
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3946;
    sub_ca53();
loc_3946:
    memoryASet(ss, bp - 2, 0x00);
loc_394a:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19570);
    dx = memoryAGet16(ds, bx + 19568);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_39eb;
    if (memoryAGet(ss, bp - 1) == 0xff)
        goto loc_39eb;
    al = memoryAGet(es, bx + 1);
    memoryASet(ss, bp - 3, al);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    dx = 0x0180;
    imul(dx);
    ax += 0x79be;
    bx = memoryAGet16(ds, 0x08c0);
    es = memoryAGet16(ds, 0x08c0 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet16(es, bx + 4, ds);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 12990);
    bx = memoryAGet16(ds, 0x08c0);
    memoryASet16(es, bx + 20, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 12992);
    bx = memoryAGet16(ds, 0x08c0);
    memoryASet16(es, bx + 22, ax);
    memoryASet16(es, bx + 28, 0x0000);
    if (!(memoryAGet(ss, bp - 3) & 0x01))
        goto loc_39dd;
    ax = memoryAGet16(es, bx + 28);
    ax |= 0x0400;
    memoryASet16(es, bx + 28, ax);
loc_39dd:
    push(memoryAGet16(ds, 0x08c2));
    push(memoryAGet16(ds, 0x08c0));
    sub_9f8c();
    sp += 0x0004;
loc_39eb:
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
    if (memoryAGet(ss, bp - 1) == 0xff)
        goto loc_39f7;
    goto loc_394a;
loc_39f7:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1b2b sub_39fb()
sub_39fb PROC
01ed:1b2b	push	bp
01ed:1b2c	mov	bp, sp
01ed:1b2e	sub	sp, 8
01ed:1b31	cmp	word ptr [0x6b4c], sp
01ed:1b35	ja	loc_3a0a
01ed:1b37	call	0xffffab83
        	loc_3a0a:
01ed:1b3a	mov	byte ptr [bp - 2], 0
        	loc_3a0e:
01ed:1b3e	mov	al, byte ptr [bp - 2]
01ed:1b41	mov	ah, 0
01ed:1b43	shl	ax, 1
01ed:1b45	shl	ax, 1
01ed:1b47	mov	bx, ax
01ed:1b49	mov	ax, word ptr [bx + 0x4cbe]
01ed:1b4d	mov	dx, word ptr [bx + 0x4cbc]
01ed:1b51	mov	word ptr [bp - 8], dx
01ed:1b54	mov	word ptr [bp - 6], ax
01ed:1b57	les	bx, ptr [bp - 8]
01ed:1b5a	mov	al, byte ptr es:[bx]
01ed:1b5d	mov	byte ptr [bp - 1], al
01ed:1b60	cmp	byte ptr [bp - 1], 0
01ed:1b64	je	loc_3a97
01ed:1b66	cmp	byte ptr [bp - 1], 0xff
01ed:1b6a	je	loc_3a97
01ed:1b6c	mov	al, byte ptr es:[bx + 1]
01ed:1b70	mov	byte ptr [bp - 3], al
01ed:1b73	mov	al, byte ptr [bp - 2]
01ed:1b76	mov	ah, 0
01ed:1b78	mov	cl, 8
01ed:1b7a	shl	ax, cl
01ed:1b7c	add	ax, 0x7e3e
01ed:1b7f	les	bx, ptr [0x8bc]
01ed:1b83	mov	word ptr es:[bx + 2], ax
01ed:1b87	mov	word ptr es:[bx + 4], ds
01ed:1b8b	mov	al, byte ptr [bp - 3]
01ed:1b8e	mov	ah, 0
01ed:1b90	shl	ax, 1
01ed:1b92	shl	ax, 1
01ed:1b94	mov	bx, ax
01ed:1b96	mov	ax, word ptr [bx + 0x343e]
01ed:1b9a	mov	bx, word ptr [0x8bc]
01ed:1b9e	mov	word ptr es:[bx + 0x14], ax
01ed:1ba2	mov	al, byte ptr [bp - 3]
01ed:1ba5	mov	ah, 0
01ed:1ba7	shl	ax, 1
01ed:1ba9	shl	ax, 1
01ed:1bab	mov	bx, ax
01ed:1bad	mov	ax, word ptr [bx + 0x3440]
01ed:1bb1	mov	bx, word ptr [0x8bc]
01ed:1bb5	mov	word ptr es:[bx + 0x16], ax
01ed:1bb9	push	word ptr [0x8be]
01ed:1bbd	push	word ptr [0x8bc]
01ed:1bc1	call	0x80bc
01ed:1bc4	add	sp, 4
        	loc_3a97:
01ed:1bc7	inc	byte ptr [bp - 2]
01ed:1bca	cmp	byte ptr [bp - 1], 0xff
01ed:1bce	je	loc_3aa3
01ed:1bd0	jmp	loc_3a0e
        	loc_3aa3:
01ed:1bd3	mov	sp, bp
01ed:1bd5	pop	bp
01ed:1bd6	ret	
sub_39fb ENDP
*/
void sub_39fb()
{
    // coverage: 0x2d2b-0x2dd7 method sub_39fb
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3a0a;
    sub_ca53();
loc_3a0a:
    memoryASet(ss, bp - 2, 0x00);
loc_3a0e:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19646);
    dx = memoryAGet16(ds, bx + 19644);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_3a97;
    if (memoryAGet(ss, bp - 1) == 0xff)
        goto loc_3a97;
    al = memoryAGet(es, bx + 1);
    memoryASet(ss, bp - 3, al);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    cl = 0x08;
    ax <<= cl;
    ax += 0x7e3e;
    bx = memoryAGet16(ds, 0x08bc);
    es = memoryAGet16(ds, 0x08bc + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet16(es, bx + 4, ds);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 13374);
    bx = memoryAGet16(ds, 0x08bc);
    memoryASet16(es, bx + 20, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 13376);
    bx = memoryAGet16(ds, 0x08bc);
    memoryASet16(es, bx + 22, ax);
    push(memoryAGet16(ds, 0x08be));
    push(memoryAGet16(ds, 0x08bc));
    sub_9f8c();
    sp += 0x0004;
loc_3a97:
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
    if (memoryAGet(ss, bp - 1) == 0xff)
        goto loc_3aa3;
    goto loc_3a0e;
loc_3aa3:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1bd7 sub_3aa7()
sub_3aa7 PROC
01ed:1bd7	push	bp
01ed:1bd8	mov	bp, sp
01ed:1bda	cmp	word ptr [0x6b4c], sp
01ed:1bde	ja	loc_3ab3
01ed:1be0	call	0xffffab83
        	loc_3ab3:
01ed:1be3	mov	word ptr [0x9ba4], 4
01ed:1be9	cmp	word ptr [0x857a], 0x10
01ed:1bee	jle	loc_3aca
01ed:1bf0	mov	ax, 0x14
01ed:1bf3	sub	ax, word ptr [0x857a]
01ed:1bf7	mov	word ptr [0x9ba4], ax
        	loc_3aca:
01ed:1bfa	mov	word ptr [0x9b9c], 4
01ed:1c00	cmp	word ptr [0x857c], 0x15
01ed:1c05	jle	loc_3ae1
01ed:1c07	mov	ax, 0x19
01ed:1c0a	sub	ax, word ptr [0x857c]
01ed:1c0e	mov	word ptr [0x9b9c], ax
        	loc_3ae1:
01ed:1c11	les	bx, ptr [0x8b8]
01ed:1c15	mov	ax, word ptr [0x857a]
01ed:1c18	mov	word ptr es:[bx + 6], ax
01ed:1c1c	mov	ax, word ptr [0x857c]
01ed:1c1f	mov	word ptr es:[bx + 8], ax
01ed:1c23	mov	ax, word ptr [0x9ba4]
01ed:1c26	mov	word ptr es:[bx + 0x1e], ax
01ed:1c2a	mov	ax, word ptr [0x9b9c]
01ed:1c2d	mov	word ptr es:[bx + 0x20], ax
01ed:1c31	push	word ptr [0x8ba]
01ed:1c35	push	word ptr [0x8b8]
01ed:1c39	call	0x93b8
01ed:1c3c	add	sp, 4
01ed:1c3f	pop	bp
01ed:1c40	ret	
sub_3aa7 ENDP
*/
void sub_3aa7()
{
    // coverage: 0x2dd7-0x2e41 method sub_3aa7
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3ab3;
    sub_ca53();
loc_3ab3:
    memoryASet16(ds, 0x9ba4, 0x0004);
    if ((short)memoryAGet16(ds, 0x857a) <= (short)0x0010)
        goto loc_3aca;
    ax = 0x0014;
    ax -= memoryAGet16(ds, 0x857a);
    memoryASet16(ds, 0x9ba4, ax);
loc_3aca:
    memoryASet16(ds, 0x9b9c, 0x0004);
    if ((short)memoryAGet16(ds, 0x857c) <= (short)0x0015)
        goto loc_3ae1;
    ax = 0x0019;
    ax -= memoryAGet16(ds, 0x857c);
    memoryASet16(ds, 0x9b9c, ax);
loc_3ae1:
    bx = memoryAGet16(ds, 0x08b8);
    es = memoryAGet16(ds, 0x08b8 + 2);
    ax = memoryAGet16(ds, 0x857a);
    memoryASet16(es, bx + 6, ax);
    ax = memoryAGet16(ds, 0x857c);
    memoryASet16(es, bx + 8, ax);
    ax = memoryAGet16(ds, 0x9ba4);
    memoryASet16(es, bx + 30, ax);
    ax = memoryAGet16(ds, 0x9b9c);
    memoryASet16(es, bx + 32, ax);
    push(memoryAGet16(ds, 0x08ba));
    push(memoryAGet16(ds, 0x08b8));
    sub_b288();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1c41 sub_3b11()
sub_3b11 PROC
01ed:1c41	push	bp
01ed:1c42	mov	bp, sp
01ed:1c44	cmp	word ptr [0x6b4c], sp
01ed:1c48	ja	loc_3b1d
01ed:1c4a	call	0xffffab83
        	loc_3b1d:
01ed:1c4d	cmp	byte ptr [0x8571], 0xff
01ed:1c52	je	loc_3b80
01ed:1c54	mov	word ptr [0x9d34], 4
01ed:1c5a	cmp	word ptr [0x8558], 0x10
01ed:1c5f	jle	loc_3b3b
01ed:1c61	mov	ax, 0x14
01ed:1c64	sub	ax, word ptr [0x8558]
01ed:1c68	mov	word ptr [0x9d34], ax
        	loc_3b3b:
01ed:1c6b	mov	word ptr [0x9d32], 4
01ed:1c71	cmp	word ptr [0x855a], 0x15
01ed:1c76	jle	loc_3b52
01ed:1c78	mov	ax, 0x19
01ed:1c7b	sub	ax, word ptr [0x855a]
01ed:1c7f	mov	word ptr [0x9d32], ax
        	loc_3b52:
01ed:1c82	les	bx, ptr [0x8ec]
01ed:1c86	mov	ax, word ptr [0x8558]
01ed:1c89	mov	word ptr es:[bx + 6], ax
01ed:1c8d	mov	ax, word ptr [0x855a]
01ed:1c90	mov	word ptr es:[bx + 8], ax
01ed:1c94	mov	ax, word ptr [0x9d34]
01ed:1c97	mov	word ptr es:[bx + 0x1e], ax
01ed:1c9b	mov	ax, word ptr [0x9d32]
01ed:1c9e	mov	word ptr es:[bx + 0x20], ax
01ed:1ca2	push	word ptr [0x8ee]
01ed:1ca6	push	word ptr [0x8ec]
01ed:1caa	call	0x93b8
01ed:1cad	add	sp, 4
        	loc_3b80:
01ed:1cb0	pop	bp
01ed:1cb1	ret	
sub_3b11 ENDP
*/
void sub_3b11()
{
    // coverage: 0x2e41-0x2eb2 method sub_3b11
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3b1d;
    sub_ca53();
loc_3b1d:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_3b80;
    memoryASet16(ds, 0x9d34, 0x0004);
    if ((short)memoryAGet16(ds, 0x8558) <= (short)0x0010)
        goto loc_3b3b;
    ax = 0x0014;
    ax -= memoryAGet16(ds, 0x8558);
    memoryASet16(ds, 0x9d34, ax);
loc_3b3b:
    memoryASet16(ds, 0x9d32, 0x0004);
    if ((short)memoryAGet16(ds, 0x855a) <= (short)0x0015)
        goto loc_3b52;
    ax = 0x0019;
    ax -= memoryAGet16(ds, 0x855a);
    memoryASet16(ds, 0x9d32, ax);
loc_3b52:
    bx = memoryAGet16(ds, 0x08ec);
    es = memoryAGet16(ds, 0x08ec + 2);
    ax = memoryAGet16(ds, 0x8558);
    memoryASet16(es, bx + 6, ax);
    ax = memoryAGet16(ds, 0x855a);
    memoryASet16(es, bx + 8, ax);
    ax = memoryAGet16(ds, 0x9d34);
    memoryASet16(es, bx + 30, ax);
    ax = memoryAGet16(ds, 0x9d32);
    memoryASet16(es, bx + 32, ax);
    push(memoryAGet16(ds, 0x08ee));
    push(memoryAGet16(ds, 0x08ec));
    sub_b288();
    sp += 0x0004;
loc_3b80:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1cb2 sub_3b82()
sub_3b82 PROC
01ed:1cb2	push	bp
01ed:1cb3	mov	bp, sp
01ed:1cb5	cmp	word ptr [0x6b4c], sp
01ed:1cb9	ja	loc_3b8e
01ed:1cbb	call	0xffffab83
        	loc_3b8e:
01ed:1cbe	cmp	word ptr [0x824a], 0x64
01ed:1cc3	je	loc_3bb8
01ed:1cc5	les	bx, ptr [0x8884]
01ed:1cc9	mov	ax, word ptr [0x824a]
01ed:1ccc	mov	word ptr es:[bx + 4], ax
01ed:1cd0	mov	ax, word ptr [0x9290]
01ed:1cd3	mov	word ptr es:[bx], ax
01ed:1cd6	mov	ax, word ptr [0x9292]
01ed:1cd9	mov	word ptr es:[bx + 2], ax
01ed:1cdd	push	ds
01ed:1cde	mov	ax, 0x792e
01ed:1ce1	push	ax
01ed:1ce2	call	0x942a
01ed:1ce5	add	sp, 4
        	loc_3bb8:
01ed:1ce8	pop	bp
01ed:1ce9	ret	
sub_3b82 ENDP
*/
void sub_3b82()
{
    // coverage: 0x2eb2-0x2eea method sub_3b82
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3b8e;
    sub_ca53();
loc_3b8e:
    if (memoryAGet16(ds, 0x824a) == 0x0064)
        goto loc_3bb8;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ds, 0x824a);
    memoryASet16(es, bx + 4, ax);
    ax = memoryAGet16(ds, 0x9290);
    memoryASet16(es, bx, ax);
    ax = memoryAGet16(ds, 0x9292);
    memoryASet16(es, bx + 2, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_3bb8:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1cea sub_3bba()
sub_3bba PROC
01ed:1cea	push	bp
01ed:1ceb	mov	bp, sp
01ed:1ced	cmp	word ptr [0x6b4c], sp
01ed:1cf1	ja	loc_3bc6
01ed:1cf3	call	0xffffab83
        	loc_3bc6:
01ed:1cf6	cmp	byte ptr [0x8571], 0xff
01ed:1cfb	je	loc_3bf4
01ed:1cfd	les	bx, ptr [0x9b9e]
01ed:1d01	mov	ax, word ptr [0xa0de]
01ed:1d04	add	ax, word ptr [0x8560]
01ed:1d08	mov	word ptr es:[bx + 4], ax
01ed:1d0c	mov	ax, word ptr [0x79ba]
01ed:1d0f	mov	word ptr es:[bx], ax
01ed:1d12	mov	ax, word ptr [0x79bc]
01ed:1d15	mov	word ptr es:[bx + 2], ax
01ed:1d19	push	ds
01ed:1d1a	mov	ax, 0x795a
01ed:1d1d	push	ax
01ed:1d1e	call	0x942a
01ed:1d21	add	sp, 4
        	loc_3bf4:
01ed:1d24	pop	bp
01ed:1d25	ret	
sub_3bba ENDP
*/
void sub_3bba()
{
    // coverage: 0x2eea-0x2f26 method sub_3bba
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3bc6;
    sub_ca53();
loc_3bc6:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_3bf4;
    bx = memoryAGet16(ds, 0x9b9e);
    es = memoryAGet16(ds, 0x9b9e + 2);
    ax = memoryAGet16(ds, 0xa0de);
    ax += memoryAGet16(ds, 0x8560);
    memoryASet16(es, bx + 4, ax);
    ax = memoryAGet16(ds, 0x79ba);
    memoryASet16(es, bx, ax);
    ax = memoryAGet16(ds, 0x79bc);
    memoryASet16(es, bx + 2, ax);
    push(ds);
    ax = 0x795a;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_3bf4:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1d26 sub_3bf6()
sub_3bf6 PROC
01ed:1d26	push	bp
01ed:1d27	mov	bp, sp
01ed:1d29	cmp	word ptr [0x6b4c], sp
01ed:1d2d	ja	loc_3c02
01ed:1d2f	call	0xffffab83
        	loc_3c02:
01ed:1d32	mov	al, 0x3b
01ed:1d34	push	ax
01ed:1d35	call	0x7ab4
01ed:1d38	inc	sp
01ed:1d39	inc	sp
01ed:1d3a	or	al, al
01ed:1d3c	je	loc_3c15
01ed:1d3e	mov	byte ptr [0x854f], 0
01ed:1d43	jmp	loc_3c8b
        	loc_3c15:
01ed:1d45	mov	al, 0x3c
01ed:1d47	push	ax
01ed:1d48	call	0x7ab4
01ed:1d4b	inc	sp
01ed:1d4c	inc	sp
01ed:1d4d	or	al, al
01ed:1d4f	je	loc_3c28
01ed:1d51	mov	byte ptr [0x854f], 0x88
01ed:1d56	jmp	loc_3c8b
        	loc_3c28:
01ed:1d58	mov	al, 0x3d
01ed:1d5a	push	ax
01ed:1d5b	call	0x7ab4
01ed:1d5e	inc	sp
01ed:1d5f	inc	sp
01ed:1d60	or	al, al
01ed:1d62	je	loc_3c3b
01ed:1d64	mov	byte ptr [0x854f], 0xaa
01ed:1d69	jmp	loc_3c8b
        	loc_3c3b:
01ed:1d6b	mov	al, 0x3e
01ed:1d6d	push	ax
01ed:1d6e	call	0x7ab4
01ed:1d71	inc	sp
01ed:1d72	inc	sp
01ed:1d73	or	al, al
01ed:1d75	je	loc_3c4e
01ed:1d77	mov	byte ptr [0x854f], 0xee
01ed:1d7c	jmp	loc_3c8b
        	loc_3c4e:
01ed:1d7e	mov	al, 0x3f
01ed:1d80	push	ax
01ed:1d81	call	0x7ab4
01ed:1d84	inc	sp
01ed:1d85	inc	sp
01ed:1d86	or	al, al
01ed:1d88	je	loc_3c61
01ed:1d8a	mov	byte ptr [0x854f], 0xff
01ed:1d8f	jmp	loc_3c8b
        	loc_3c61:
01ed:1d91	mov	al, 1
01ed:1d93	push	ax
01ed:1d94	call	0x7ab4
01ed:1d97	inc	sp
01ed:1d98	inc	sp
01ed:1d99	or	al, al
01ed:1d9b	je	loc_3c72
01ed:1d9d	call	0x22fc
01ed:1da0	jmp	loc_3c8b
        	loc_3c72:
01ed:1da2	mov	al, 0x44
01ed:1da4	push	ax
01ed:1da5	call	0x7ab4
01ed:1da8	inc	sp
01ed:1da9	inc	sp
01ed:1daa	or	al, al
01ed:1dac	je	loc_3c8b
01ed:1dae	mov	byte ptr [0x928d], 1
01ed:1db3	mov	al, 0
01ed:1db5	mov	byte ptr [0x9d30], al
01ed:1db8	mov	byte ptr [0x856d], al
        	loc_3c8b:
01ed:1dbb	cmp	byte ptr [0xa1aa], 0
01ed:1dc0	je	loc_3c97
01ed:1dc2	call	0x228d
01ed:1dc5	jmp	loc_3cac
        	loc_3c97:
01ed:1dc7	call	0x236f
01ed:1dca	call	0x1dde
01ed:1dcd	cmp	byte ptr [0x824d], 0
01ed:1dd2	je	loc_3ca9
01ed:1dd4	call	0x238e
01ed:1dd7	jmp	loc_3cac
        	loc_3ca9:
01ed:1dd9	call	0x1e02
        	loc_3cac:
01ed:1ddc	pop	bp
01ed:1ddd	ret	
sub_3bf6 ENDP
*/
void sub_3bf6()
{
    // coverage: 0x2f26-0x2fde method sub_3bf6
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3c02;
    sub_ca53();
loc_3c02:
    al = 0x3b;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c15;
    memoryASet(ds, 0x854f, 0x00);
    goto loc_3c8b;
loc_3c15:
    al = 0x3c;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c28;
    memoryASet(ds, 0x854f, 0x88);
    goto loc_3c8b;
loc_3c28:
    al = 0x3d;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c3b;
    memoryASet(ds, 0x854f, 0xaa);
    goto loc_3c8b;
loc_3c3b:
    al = 0x3e;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c4e;
    memoryASet(ds, 0x854f, 0xee);
    goto loc_3c8b;
loc_3c4e:
    al = 0x3f;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c61;
    memoryASet(ds, 0x854f, 0xff);
    goto loc_3c8b;
loc_3c61:
    al = 0x01;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c72;
    sub_41cc();
    goto loc_3c8b;
loc_3c72:
    al = 0x44;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_3c8b;
    memoryASet(ds, 0x928d, 0x01);
    al = 0x00;
    memoryASet(ds, 0x9d30, al);
    memoryASet(ds, 0x856d, al);
loc_3c8b:
    if (memoryAGet(ds, 0xa1aa) == 0x00)
        goto loc_3c97;
    sub_415d();
    goto loc_3cac;
loc_3c97:
    sub_423f();
    sub_3cae();
    if (memoryAGet(ds, 0x824d) == 0x00)
        goto loc_3ca9;
    sub_425e();
    goto loc_3cac;
loc_3ca9:
    sub_3cd2();
loc_3cac:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1dde sub_3cae()
sub_3cae PROC
01ed:1dde	push	bp
01ed:1ddf	mov	bp, sp
01ed:1de1	dec	sp
01ed:1de2	dec	sp
01ed:1de3	cmp	word ptr [0x6b4c], sp
01ed:1de7	ja	loc_3cbc
01ed:1de9	call	0xffffab83
        	loc_3cbc:
01ed:1dec	mov	al, 0
01ed:1dee	push	ax
01ed:1def	call	0x75a2
01ed:1df2	inc	sp
01ed:1df3	inc	sp
01ed:1df4	mov	byte ptr [bp - 1], al
01ed:1df7	or	al, al
01ed:1df9	je	loc_3cce
01ed:1dfb	mov	byte ptr [0x8244], al
        	loc_3cce:
01ed:1dfe	mov	sp, bp
01ed:1e00	pop	bp
01ed:1e01	ret	
sub_3cae ENDP
*/
void sub_3cae()
{
    // coverage: 0x2fde-0x3002 method sub_3cae
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3cbc;
    sub_ca53();
loc_3cbc:
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    memoryASet(ss, bp - 1, al);
    if (!al)
        goto loc_3cce;
    memoryASet(ds, 0x8244, al);
loc_3cce:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1e02 sub_3cd2()
sub_3cd2 PROC
01ed:1e02	push	bp
01ed:1e03	mov	bp, sp
01ed:1e05	cmp	word ptr [0x6b4c], sp
01ed:1e09	ja	loc_3cde
01ed:1e0b	call	0xffffab83
        	loc_3cde:
01ed:1e0e	mov	byte ptr [0x7923], 0
01ed:1e13	mov	al, byte ptr [0x792c]
01ed:1e16	mov	byte ptr [0x8552], al
01ed:1e19	cmp	byte ptr [0xa0ce], 0
01ed:1e1e	jne	loc_3cf9
01ed:1e20	mov	al, byte ptr [0xa1a7]
01ed:1e23	mov	ah, 0
01ed:1e25	or	ax, ax
01ed:1e27	jne	loc_3d08
        	loc_3cf9:
01ed:1e29	mov	al, byte ptr [0x792c]
01ed:1e2c	mov	ah, 0
01ed:1e2e	shl	ax, 1
01ed:1e30	mov	bx, ax
01ed:1e32	call	word ptr [bx + 0x7ca]
01ed:1e36	jmp	loc_3d0b
        	loc_3d08:
01ed:1e38	call	0x27de
        	loc_3d0b:
01ed:1e3b	pop	bp
01ed:1e3c	ret	
sub_3cd2 ENDP
*/
void sub_3cd2()
{
    // coverage: 0x3002-0x303d method sub_3cd2
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3cde;
    sub_ca53();
loc_3cde:
    memoryASet(ds, 0x7923, 0x00);
    al = memoryAGet(ds, 0x792c);
    memoryASet(ds, 0x8552, al);
    if (memoryAGet(ds, 0xa0ce) != 0x00)
        goto loc_3cf9;
    al = memoryAGet(ds, 0xa1a7);
    ah = 0x00;
    if (ax)
        goto loc_3d08;
loc_3cf9:
    al = memoryAGet(ds, 0x792c);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    callIndirect(cs, memoryAGet16(ds, bx + 1994));
    goto loc_3d0b;
loc_3d08:
    sub_46ae();
loc_3d0b:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1e3d sub_3d0d()
sub_3d0d PROC
01ed:1e3d	push	bp
01ed:1e3e	mov	bp, sp
01ed:1e40	cmp	word ptr [0x6b4c], sp
01ed:1e44	ja	loc_3d19
01ed:1e46	call	0xffffab83
        	loc_3d19:
01ed:1e49	mov	al, 1
01ed:1e4b	mov	byte ptr [0x9d30], al
01ed:1e4e	mov	byte ptr [0xa1a9], al
01ed:1e51	call	0x3a88
01ed:1e54	les	bx, ptr [0x9baa]
01ed:1e58	mov	byte ptr es:[bx], 1
01ed:1e5c	pop	bp
01ed:1e5d	ret	
sub_3d0d ENDP
*/
void sub_3d0d()
{
    // coverage: 0x303d-0x305e method sub_3d0d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3d19;
    sub_ca53();
loc_3d19:
    al = 0x01;
    memoryASet(ds, 0x9d30, al);
    memoryASet(ds, 0xa1a9, al);
    sub_5958();
    bx = memoryAGet16(ds, 0x9baa);
    es = memoryAGet16(ds, 0x9baa + 2);
    memoryASet(es, bx, 0x01);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1e5e sub_3d2e()
sub_3d2e PROC
01ed:1e5e	push	bp
01ed:1e5f	mov	bp, sp
01ed:1e61	cmp	word ptr [0x6b4c], sp
01ed:1e65	ja	loc_3d3a
01ed:1e67	call	0xffffab83
        	loc_3d3a:
01ed:1e6a	cmp	byte ptr [0x8551], 8
01ed:1e6f	jne	loc_3d59
01ed:1e71	cmp	word ptr [0x689c], 4
01ed:1e76	je	loc_3d4c
01ed:1e78	mov	al, 0xf
01ed:1e7a	jmp	loc_3d4e
        	loc_3d4c:
01ed:1e7c	mov	al, 0x2b
        	loc_3d4e:
01ed:1e7e	push	ax
01ed:1e7f	call	0x6e11
01ed:1e82	inc	sp
01ed:1e83	inc	sp
01ed:1e84	call	0x21e7
01ed:1e87	jmp	loc_3d5e
        	loc_3d59:
01ed:1e89	mov	byte ptr [0x792c], 0x24
        	loc_3d5e:
01ed:1e8e	pop	bp
01ed:1e8f	ret	
sub_3d2e ENDP
*/
void sub_3d2e()
{
    // coverage: 0x305e-0x3090 method sub_3d2e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3d3a;
    sub_ca53();
loc_3d3a:
    if (memoryAGet(ds, 0x8551) != 0x08)
        goto loc_3d59;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_3d4c;
    al = 0x0f;
    goto loc_3d4e;
loc_3d4c:
    al = 0x2b;
loc_3d4e:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    sub_40b7();
    goto loc_3d5e;
loc_3d59:
    memoryASet(ds, 0x792c, 0x24);
loc_3d5e:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1e90 sub_3d60()
sub_3d60 PROC
01ed:1e90	push	bp
01ed:1e91	mov	bp, sp
01ed:1e93	cmp	word ptr [0x6b4c], sp
01ed:1e97	ja	loc_3d6c
01ed:1e99	call	0xffffab83
        	loc_3d6c:
01ed:1e9c	cmp	byte ptr [0x8551], 8
01ed:1ea1	jne	loc_3d8b
01ed:1ea3	cmp	word ptr [0x689c], 4
01ed:1ea8	je	loc_3d7e
01ed:1eaa	mov	al, 0xf
01ed:1eac	jmp	loc_3d80
        	loc_3d7e:
01ed:1eae	mov	al, 0x2b
        	loc_3d80:
01ed:1eb0	push	ax
01ed:1eb1	call	0x6e11
01ed:1eb4	inc	sp
01ed:1eb5	inc	sp
01ed:1eb6	call	0x2138
01ed:1eb9	jmp	loc_3d90
        	loc_3d8b:
01ed:1ebb	mov	byte ptr [0x792c], 0x23
        	loc_3d90:
01ed:1ec0	pop	bp
01ed:1ec1	ret	
sub_3d60 ENDP
*/
void sub_3d60()
{
    // coverage: 0x3090-0x30c2 method sub_3d60
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3d6c;
    sub_ca53();
loc_3d6c:
    if (memoryAGet(ds, 0x8551) != 0x08)
        goto loc_3d8b;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_3d7e;
    al = 0x0f;
    goto loc_3d80;
loc_3d7e:
    al = 0x2b;
loc_3d80:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    sub_4008();
    goto loc_3d90;
loc_3d8b:
    memoryASet(ds, 0x792c, 0x23);
loc_3d90:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1ec2 sub_3d92()
sub_3d92 PROC
01ed:1ec2	push	bp
01ed:1ec3	mov	bp, sp
01ed:1ec5	sub	sp, 6
01ed:1ec8	cmp	word ptr [0x6b4c], sp
01ed:1ecc	ja	loc_3da1
01ed:1ece	call	0xffffab83
        	loc_3da1:
01ed:1ed1	mov	byte ptr [bp - 1], 0xb
01ed:1ed5	mov	byte ptr [bp - 2], 5
01ed:1ed9	mov	word ptr [bp - 6], 0x1ca4
01ed:1ede	mov	word ptr [bp - 4], ds
01ed:1ee1	push	word ptr [bp - 4]
01ed:1ee4	push	word ptr [bp - 6]
01ed:1ee7	mov	al, byte ptr [bp - 2]
01ed:1eea	push	ax
01ed:1eeb	mov	al, byte ptr [bp - 1]
01ed:1eee	push	ax
01ed:1eef	call	0x495c
01ed:1ef2	add	sp, 8
01ed:1ef5	test	byte ptr [0x8244], 2
01ed:1efa	je	loc_3dcf
01ed:1efc	call	0x1f03
        	loc_3dcf:
01ed:1eff	mov	sp, bp
01ed:1f01	pop	bp
01ed:1f02	ret	
sub_3d92 ENDP
*/
void sub_3d92()
{
    // coverage: 0x30c2-0x3103 method sub_3d92
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3da1;
    sub_ca53();
loc_3da1:
    memoryASet(ss, bp - 1, 0x0b);
    memoryASet(ss, bp - 2, 0x05);
    memoryASet16(ss, bp - 6, 0x1ca4);
    memoryASet16(ss, bp - 4, ds);
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_682c();
    sp += 0x0008;
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_3dcf;
    sub_3dd3();
loc_3dcf:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1f03 sub_3dd3()
sub_3dd3 PROC
01ed:1f03	push	bp
01ed:1f04	mov	bp, sp
01ed:1f06	cmp	word ptr [0x6b4c], sp
01ed:1f0a	ja	loc_3ddf
01ed:1f0c	call	0xffffab83
        	loc_3ddf:
01ed:1f0f	mov	byte ptr [0x792c], 1
01ed:1f14	mov	word ptr [0xa1ac], 0x140c
01ed:1f1a	mov	word ptr [0xa1ae], ds
01ed:1f1e	mov	byte ptr [0x824d], 4
01ed:1f23	mov	al, 9
01ed:1f25	mov	byte ptr [0x9bae], al
01ed:1f28	mov	byte ptr [0x792a], al
01ed:1f2b	mov	al, byte ptr [0x856e]
01ed:1f2e	mov	byte ptr [0x8570], al
01ed:1f31	mov	al, 0x16
01ed:1f33	push	ax
01ed:1f34	call	0x6a89
01ed:1f37	inc	sp
01ed:1f38	inc	sp
01ed:1f39	call	0x238e
01ed:1f3c	pop	bp
01ed:1f3d	ret	
sub_3dd3 ENDP
*/
void sub_3dd3()
{
    // coverage: 0x3103-0x313e method sub_3dd3
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3ddf;
    sub_ca53();
loc_3ddf:
    memoryASet(ds, 0x792c, 0x01);
    memoryASet16(ds, 0xa1ac, 0x140c);
    memoryASet16(ds, 0xa1ae, ds);
    memoryASet(ds, 0x824d, 0x04);
    al = 0x09;
    memoryASet(ds, 0x9bae, al);
    memoryASet(ds, 0x792a, al);
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x8570, al);
    al = 0x16;
    push(ax);
    sub_8959();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1f3e sub_3e0e()
sub_3e0e PROC
01ed:1f3e	push	bp
01ed:1f3f	mov	bp, sp
01ed:1f41	sub	sp, 6
01ed:1f44	cmp	word ptr [0x6b4c], sp
01ed:1f48	ja	loc_3e1d
01ed:1f4a	call	0xffffab83
        	loc_3e1d:
01ed:1f4d	mov	byte ptr [bp - 1], 0xb
01ed:1f51	mov	byte ptr [bp - 2], 5
01ed:1f55	mov	word ptr [bp - 6], 0x1cba
01ed:1f5a	mov	word ptr [bp - 4], ds
01ed:1f5d	push	word ptr [bp - 4]
01ed:1f60	push	word ptr [bp - 6]
01ed:1f63	mov	al, byte ptr [bp - 2]
01ed:1f66	push	ax
01ed:1f67	mov	al, byte ptr [bp - 1]
01ed:1f6a	push	ax
01ed:1f6b	call	0x495c
01ed:1f6e	add	sp, 8
01ed:1f71	test	byte ptr [0x8244], 2
01ed:1f76	je	loc_3e4b
01ed:1f78	call	0x1f7f
        	loc_3e4b:
01ed:1f7b	mov	sp, bp
01ed:1f7d	pop	bp
01ed:1f7e	ret	
sub_3e0e ENDP
*/
void sub_3e0e()
{
    // coverage: 0x313e-0x317f method sub_3e0e
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3e1d;
    sub_ca53();
loc_3e1d:
    memoryASet(ss, bp - 1, 0x0b);
    memoryASet(ss, bp - 2, 0x05);
    memoryASet16(ss, bp - 6, 0x1cba);
    memoryASet16(ss, bp - 4, ds);
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_682c();
    sp += 0x0008;
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_3e4b;
    sub_3e4f();
loc_3e4b:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1f7f sub_3e4f()
sub_3e4f PROC
01ed:1f7f	push	bp
01ed:1f80	mov	bp, sp
01ed:1f82	cmp	word ptr [0x6b4c], sp
01ed:1f86	ja	loc_3e5b
01ed:1f88	call	0xffffab83
        	loc_3e5b:
01ed:1f8b	mov	byte ptr [0x792c], 2
01ed:1f90	mov	word ptr [0xa1ac], 0x1460
01ed:1f96	mov	word ptr [0xa1ae], ds
01ed:1f9a	mov	byte ptr [0x824d], 4
01ed:1f9f	mov	byte ptr [0x792a], 9
01ed:1fa4	mov	byte ptr [0x9bae], 0
01ed:1fa9	mov	al, byte ptr [0x856e]
01ed:1fac	add	al, 0xff
01ed:1fae	mov	byte ptr [0x8570], al
01ed:1fb1	mov	al, 0x16
01ed:1fb3	push	ax
01ed:1fb4	call	0x6a89
01ed:1fb7	inc	sp
01ed:1fb8	inc	sp
01ed:1fb9	call	0x238e
01ed:1fbc	pop	bp
01ed:1fbd	ret	
sub_3e4f ENDP
*/
void sub_3e4f()
{
    // coverage: 0x317f-0x31be method sub_3e4f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3e5b;
    sub_ca53();
loc_3e5b:
    memoryASet(ds, 0x792c, 0x02);
    memoryASet16(ds, 0xa1ac, 0x1460);
    memoryASet16(ds, 0xa1ae, ds);
    memoryASet(ds, 0x824d, 0x04);
    memoryASet(ds, 0x792a, 0x09);
    memoryASet(ds, 0x9bae, 0x00);
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    memoryASet(ds, 0x8570, al);
    al = 0x16;
    push(ax);
    sub_8959();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:1fbe sub_3e8e()
sub_3e8e PROC
01ed:1fbe	push	bp
01ed:1fbf	mov	bp, sp
01ed:1fc1	cmp	word ptr [0x6b4c], sp
01ed:1fc5	ja	loc_3e9a
01ed:1fc7	call	0xffffab83
        	loc_3e9a:
01ed:1fca	mov	byte ptr [0x8551], 0
01ed:1fcf	cmp	word ptr [0x689c], 4
01ed:1fd4	je	loc_3eaa
01ed:1fd6	mov	al, 2
01ed:1fd8	jmp	loc_3eac
        	loc_3eaa:
01ed:1fda	mov	al, 0x26
        	loc_3eac:
01ed:1fdc	push	ax
01ed:1fdd	call	0x6e11
01ed:1fe0	inc	sp
01ed:1fe1	inc	sp
01ed:1fe2	mov	al, byte ptr [0x855e]
01ed:1fe5	mov	ah, 0
01ed:1fe7	or	ax, ax
01ed:1fe9	jne	loc_3ec4
01ed:1feb	mov	byte ptr [0x8551], 0x1f
01ed:1ff0	mov	al, 0x38
01ed:1ff2	jmp	loc_3f42
        	loc_3ec4:
01ed:1ff4	mov	al, byte ptr [0x856e]
01ed:1ff7	add	al, 0xff
01ed:1ff9	mov	byte ptr [0x8570], al
01ed:1ffc	push	ax
01ed:1ffd	call	0x6bd4
01ed:2000	inc	sp
01ed:2001	inc	sp
01ed:2002	mov	al, byte ptr [0x8551]
01ed:2005	mov	ah, 0
01ed:2007	mov	bx, ax
01ed:2009	cmp	byte ptr [bx + 0x4356], 0x38
01ed:200e	jne	loc_3ee4
01ed:2010	mov	al, 0x38
01ed:2012	jmp	loc_3f42
        	loc_3ee4:
01ed:2014	mov	al, byte ptr [0x856e]
01ed:2017	add	al, 0xff
01ed:2019	push	ax
01ed:201a	call	0x6bb5
01ed:201d	inc	sp
01ed:201e	inc	sp
01ed:201f	cmp	byte ptr [0x7921], 0xb
01ed:2024	jne	loc_3efa
01ed:2026	mov	al, 0x3a
01ed:2028	jmp	loc_3f42
        	loc_3efa:
01ed:202a	cmp	byte ptr [0x855e], 1
01ed:202f	jne	loc_3f0a
01ed:2031	mov	byte ptr [0x8551], 0x1f
01ed:2036	mov	al, 0x34
01ed:2038	jmp	loc_3f42
        	loc_3f0a:
01ed:203a	mov	al, byte ptr [0x856e]
01ed:203d	add	al, 0xfe
01ed:203f	mov	byte ptr [0x8570], al
01ed:2042	push	ax
01ed:2043	call	0x6bd4
01ed:2046	inc	sp
01ed:2047	inc	sp
01ed:2048	mov	al, byte ptr [0x8551]
01ed:204b	mov	ah, 0
01ed:204d	mov	bx, ax
01ed:204f	cmp	byte ptr [bx + 0x4316], 0x34
01ed:2054	jne	loc_3f2a
01ed:2056	mov	al, 0x34
01ed:2058	jmp	loc_3f42
        	loc_3f2a:
01ed:205a	mov	al, byte ptr [0x856e]
01ed:205d	add	al, 0xfe
01ed:205f	push	ax
01ed:2060	call	0x6bb5
01ed:2063	inc	sp
01ed:2064	inc	sp
01ed:2065	cmp	byte ptr [0x7921], 0xb
01ed:206a	jne	loc_3f40
01ed:206c	mov	al, 0x36
01ed:206e	jmp	loc_3f42
        	loc_3f40:
01ed:2070	mov	al, 0x1a
        	loc_3f42:
01ed:2072	push	ax
01ed:2073	call	0x4263
01ed:2076	inc	sp
01ed:2077	inc	sp
01ed:2078	call	0x238e
01ed:207b	pop	bp
01ed:207c	ret	
sub_3e8e ENDP
*/
void sub_3e8e()
{
    // coverage: 0x31be-0x327d method sub_3e8e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3e9a;
    sub_ca53();
loc_3e9a:
    memoryASet(ds, 0x8551, 0x00);
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_3eaa;
    al = 0x02;
    goto loc_3eac;
loc_3eaa:
    al = 0x26;
loc_3eac:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x855e);
    ah = 0x00;
    if (ax)
        goto loc_3ec4;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x38;
    goto loc_3f42;
loc_3ec4:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    if (memoryAGet(ds, bx + 17238) != 0x38)
        goto loc_3ee4;
    al = 0x38;
    goto loc_3f42;
loc_3ee4:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_3efa;
    al = 0x3a;
    goto loc_3f42;
loc_3efa:
    if (memoryAGet(ds, 0x855e) != 0x01)
        goto loc_3f0a;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x34;
    goto loc_3f42;
loc_3f0a:
    al = memoryAGet(ds, 0x856e);
    al += 0xfe;
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    if (memoryAGet(ds, bx + 17174) != 0x34)
        goto loc_3f2a;
    al = 0x34;
    goto loc_3f42;
loc_3f2a:
    al = memoryAGet(ds, 0x856e);
    al += 0xfe;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_3f40;
    al = 0x36;
    goto loc_3f42;
loc_3f40:
    al = 0x1a;
loc_3f42:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:207d sub_3f4d()
sub_3f4d PROC
01ed:207d	push	bp
01ed:207e	mov	bp, sp
01ed:2080	cmp	word ptr [0x6b4c], sp
01ed:2084	ja	loc_3f59
01ed:2086	call	0xffffab83
        	loc_3f59:
01ed:2089	mov	byte ptr [0x8551], 0
01ed:208e	cmp	word ptr [0x689c], 4
01ed:2093	je	loc_3f69
01ed:2095	mov	al, 2
01ed:2097	jmp	loc_3f6b
        	loc_3f69:
01ed:2099	mov	al, 0x26
        	loc_3f6b:
01ed:209b	push	ax
01ed:209c	call	0x6e11
01ed:209f	inc	sp
01ed:20a0	inc	sp
01ed:20a1	cmp	byte ptr [0x855e], 7
01ed:20a6	jne	loc_3f81
01ed:20a8	mov	byte ptr [0x8551], 0x1f
01ed:20ad	mov	al, 0x39
01ed:20af	jmp	loc_3ffd
        	loc_3f81:
01ed:20b1	mov	al, byte ptr [0x856e]
01ed:20b4	mov	byte ptr [0x8570], al
01ed:20b7	push	ax
01ed:20b8	call	0x6bd4
01ed:20bb	inc	sp
01ed:20bc	inc	sp
01ed:20bd	mov	al, byte ptr [0x8551]
01ed:20c0	mov	ah, 0
01ed:20c2	mov	bx, ax
01ed:20c4	cmp	byte ptr [bx + 0x4376], 0x39
01ed:20c9	jne	loc_3f9f
01ed:20cb	mov	al, 0x39
01ed:20cd	jmp	loc_3ffd
        	loc_3f9f:
01ed:20cf	mov	al, byte ptr [0x856e]
01ed:20d2	inc	al
01ed:20d4	push	ax
01ed:20d5	call	0x6bb5
01ed:20d8	inc	sp
01ed:20d9	inc	sp
01ed:20da	cmp	byte ptr [0x7921], 0xb
01ed:20df	jne	loc_3fb5
01ed:20e1	mov	al, 0x3b
01ed:20e3	jmp	loc_3ffd
        	loc_3fb5:
01ed:20e5	cmp	byte ptr [0x855e], 6
01ed:20ea	jne	loc_3fc5
01ed:20ec	mov	byte ptr [0x8551], 0x1f
01ed:20f1	mov	al, 0x35
01ed:20f3	jmp	loc_3ffd
        	loc_3fc5:
01ed:20f5	mov	al, byte ptr [0x856e]
01ed:20f8	inc	al
01ed:20fa	mov	byte ptr [0x8570], al
01ed:20fd	push	ax
01ed:20fe	call	0x6bd4
01ed:2101	inc	sp
01ed:2102	inc	sp
01ed:2103	mov	al, byte ptr [0x8551]
01ed:2106	mov	ah, 0
01ed:2108	mov	bx, ax
01ed:210a	cmp	byte ptr [bx + 0x4336], 0x35
01ed:210f	jne	loc_3fe5
01ed:2111	mov	al, 0x35
01ed:2113	jmp	loc_3ffd
        	loc_3fe5:
01ed:2115	mov	al, byte ptr [0x856e]
01ed:2118	add	al, 2
01ed:211a	push	ax
01ed:211b	call	0x6bb5
01ed:211e	inc	sp
01ed:211f	inc	sp
01ed:2120	cmp	byte ptr [0x7921], 0xb
01ed:2125	jne	loc_3ffb
01ed:2127	mov	al, 0x37
01ed:2129	jmp	loc_3ffd
        	loc_3ffb:
01ed:212b	mov	al, 0x1b
        	loc_3ffd:
01ed:212d	push	ax
01ed:212e	call	0x4263
01ed:2131	inc	sp
01ed:2132	inc	sp
01ed:2133	call	0x238e
01ed:2136	pop	bp
01ed:2137	ret	
sub_3f4d ENDP
*/
void sub_3f4d()
{
    // coverage: 0x327d-0x3338 method sub_3f4d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_3f59;
    sub_ca53();
loc_3f59:
    memoryASet(ds, 0x8551, 0x00);
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_3f69;
    al = 0x02;
    goto loc_3f6b;
loc_3f69:
    al = 0x26;
loc_3f6b:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x855e) != 0x07)
        goto loc_3f81;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x39;
    goto loc_3ffd;
loc_3f81:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    if (memoryAGet(ds, bx + 17270) != 0x39)
        goto loc_3f9f;
    al = 0x39;
    goto loc_3ffd;
loc_3f9f:
    al = memoryAGet(ds, 0x856e);
    al++;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_3fb5;
    al = 0x3b;
    goto loc_3ffd;
loc_3fb5:
    if (memoryAGet(ds, 0x855e) != 0x06)
        goto loc_3fc5;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x35;
    goto loc_3ffd;
loc_3fc5:
    al = memoryAGet(ds, 0x856e);
    al++;
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    if (memoryAGet(ds, bx + 17206) != 0x35)
        goto loc_3fe5;
    al = 0x35;
    goto loc_3ffd;
loc_3fe5:
    al = memoryAGet(ds, 0x856e);
    al += 0x02;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_3ffb;
    al = 0x37;
    goto loc_3ffd;
loc_3ffb:
    al = 0x1b;
loc_3ffd:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2138 sub_4008()
sub_4008 PROC
01ed:2138	push	bp
01ed:2139	mov	bp, sp
01ed:213b	dec	sp
01ed:213c	dec	sp
01ed:213d	cmp	word ptr [0x6b4c], sp
01ed:2141	ja	loc_4016
01ed:2143	call	0xffffab83
        	loc_4016:
01ed:2146	mov	byte ptr [0x8551], 0
01ed:214b	test	byte ptr [0x8244], 0x12
01ed:2150	je	loc_403f
01ed:2152	cmp	word ptr [0x689c], 4
01ed:2157	je	loc_402d
01ed:2159	mov	al, 0x15
01ed:215b	jmp	loc_402f
        	loc_402d:
01ed:215d	mov	al, 0x2a
        	loc_402f:
01ed:215f	push	ax
01ed:2160	call	0x6e11
01ed:2163	inc	sp
01ed:2164	inc	sp
01ed:2165	mov	al, 0x32
01ed:2167	push	ax
01ed:2168	call	0x4263
01ed:216b	inc	sp
01ed:216c	inc	sp
01ed:216d	jmp	loc_4084
        	loc_403f:
01ed:216f	mov	al, byte ptr [0x855e]
01ed:2172	mov	ah, 0
01ed:2174	or	ax, ax
01ed:2176	jne	loc_4057
01ed:2178	mov	byte ptr [0x8551], 0x1f
01ed:217d	mov	al, 0x27
01ed:217f	push	ax
01ed:2180	call	0x4263
01ed:2183	inc	sp
01ed:2184	inc	sp
01ed:2185	jmp	loc_4084
        	loc_4057:
01ed:2187	mov	al, byte ptr [0x856e]
01ed:218a	add	al, 0xff
01ed:218c	mov	byte ptr [0x8570], al
01ed:218f	push	ax
01ed:2190	call	0x6bd4
01ed:2193	inc	sp
01ed:2194	inc	sp
01ed:2195	mov	al, byte ptr [0x8551]
01ed:2198	mov	ah, 0
01ed:219a	mov	bx, ax
01ed:219c	mov	al, byte ptr [bx + 0x42d6]
01ed:21a0	mov	byte ptr [bp - 1], al
01ed:21a3	cmp	byte ptr [bp - 1], 0x25
01ed:21a7	je	loc_4081
01ed:21a9	push	ax
01ed:21aa	call	0x4263
01ed:21ad	inc	sp
01ed:21ae	inc	sp
01ed:21af	jmp	loc_4084
        	loc_4081:
01ed:21b1	call	0x21bb
        	loc_4084:
01ed:21b4	call	0x238e
01ed:21b7	mov	sp, bp
01ed:21b9	pop	bp
01ed:21ba	ret	
sub_4008 ENDP
*/
void sub_4008()
{
    // coverage: 0x3338-0x33bb method sub_4008
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4016;
    sub_ca53();
loc_4016:
    memoryASet(ds, 0x8551, 0x00);
    if (!(memoryAGet(ds, 0x8244) & 0x12))
        goto loc_403f;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_402d;
    al = 0x15;
    goto loc_402f;
loc_402d:
    al = 0x2a;
loc_402f:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x32;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_4084;
loc_403f:
    al = memoryAGet(ds, 0x855e);
    ah = 0x00;
    if (ax)
        goto loc_4057;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x27;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_4084;
loc_4057:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 17110);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x25)
        goto loc_4081;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_4084;
loc_4081:
    sub_408b();
loc_4084:
    sub_425e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:21bb sub_408b()
sub_408b PROC
01ed:21bb	push	bp
01ed:21bc	mov	bp, sp
01ed:21be	cmp	word ptr [0x6b4c], sp
01ed:21c2	ja	loc_4097
01ed:21c4	call	0xffffab83
        	loc_4097:
01ed:21c7	mov	al, byte ptr [0x856e]
01ed:21ca	add	al, 0xff
01ed:21cc	push	ax
01ed:21cd	call	0x6bb5
01ed:21d0	inc	sp
01ed:21d1	inc	sp
01ed:21d2	cmp	byte ptr [0x7921], 0xb
01ed:21d7	jne	loc_40ad
01ed:21d9	mov	al, 0x29
01ed:21db	jmp	loc_40af
        	loc_40ad:
01ed:21dd	mov	al, 0x25
        	loc_40af:
01ed:21df	push	ax
01ed:21e0	call	0x4263
01ed:21e3	inc	sp
01ed:21e4	inc	sp
01ed:21e5	pop	bp
01ed:21e6	ret	
sub_408b ENDP
*/
void sub_408b()
{
    // coverage: 0x33bb-0x33e7 method sub_408b
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4097;
    sub_ca53();
loc_4097:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_40ad;
    al = 0x29;
    goto loc_40af;
loc_40ad:
    al = 0x25;
loc_40af:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:21e7 sub_40b7()
sub_40b7 PROC
01ed:21e7	push	bp
01ed:21e8	mov	bp, sp
01ed:21ea	dec	sp
01ed:21eb	dec	sp
01ed:21ec	cmp	word ptr [0x6b4c], sp
01ed:21f0	ja	loc_40c5
01ed:21f2	call	0xffffab83
        	loc_40c5:
01ed:21f5	test	byte ptr [0x8244], 0x12
01ed:21fa	je	loc_40e9
01ed:21fc	cmp	word ptr [0x689c], 4
01ed:2201	je	loc_40d7
01ed:2203	mov	al, 0x15
01ed:2205	jmp	loc_40d9
        	loc_40d7:
01ed:2207	mov	al, 0x2a
        	loc_40d9:
01ed:2209	push	ax
01ed:220a	call	0x6e11
01ed:220d	inc	sp
01ed:220e	inc	sp
01ed:220f	mov	al, 0x33
01ed:2211	push	ax
01ed:2212	call	0x4263
01ed:2215	inc	sp
01ed:2216	inc	sp
01ed:2217	jmp	loc_412a
        	loc_40e9:
01ed:2219	cmp	byte ptr [0x855e], 7
01ed:221e	jne	loc_40ff
01ed:2220	mov	byte ptr [0x8551], 0x1f
01ed:2225	mov	al, 0x28
01ed:2227	push	ax
01ed:2228	call	0x4263
01ed:222b	inc	sp
01ed:222c	inc	sp
01ed:222d	jmp	loc_412a
        	loc_40ff:
01ed:222f	mov	al, byte ptr [0x856e]
01ed:2232	mov	byte ptr [0x8570], al
01ed:2235	push	ax
01ed:2236	call	0x6bd4
01ed:2239	inc	sp
01ed:223a	inc	sp
01ed:223b	mov	al, byte ptr [0x8551]
01ed:223e	mov	ah, 0
01ed:2240	mov	bx, ax
01ed:2242	mov	al, byte ptr [bx + 0x42f6]
01ed:2246	mov	byte ptr [bp - 1], al
01ed:2249	cmp	byte ptr [bp - 1], 0x26
01ed:224d	je	loc_4127
01ed:224f	push	ax
01ed:2250	call	0x4263
01ed:2253	inc	sp
01ed:2254	inc	sp
01ed:2255	jmp	loc_412a
        	loc_4127:
01ed:2257	call	0x2261
        	loc_412a:
01ed:225a	call	0x238e
01ed:225d	mov	sp, bp
01ed:225f	pop	bp
01ed:2260	ret	
sub_40b7 ENDP
*/
void sub_40b7()
{
    // coverage: 0x33e7-0x3461 method sub_40b7
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_40c5;
    sub_ca53();
loc_40c5:
    if (!(memoryAGet(ds, 0x8244) & 0x12))
        goto loc_40e9;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_40d7;
    al = 0x15;
    goto loc_40d9;
loc_40d7:
    al = 0x2a;
loc_40d9:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x33;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_412a;
loc_40e9:
    if (memoryAGet(ds, 0x855e) != 0x07)
        goto loc_40ff;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x28;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_412a;
loc_40ff:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 17142);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x26)
        goto loc_4127;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_412a;
loc_4127:
    sub_4131();
loc_412a:
    sub_425e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2261 sub_4131()
sub_4131 PROC
01ed:2261	push	bp
01ed:2262	mov	bp, sp
01ed:2264	cmp	word ptr [0x6b4c], sp
01ed:2268	ja	loc_413d
01ed:226a	call	0xffffab83
        	loc_413d:
01ed:226d	mov	al, byte ptr [0x856e]
01ed:2270	inc	al
01ed:2272	push	ax
01ed:2273	call	0x6bb5
01ed:2276	inc	sp
01ed:2277	inc	sp
01ed:2278	cmp	byte ptr [0x7921], 0xb
01ed:227d	jne	loc_4153
01ed:227f	mov	al, 0x2a
01ed:2281	jmp	loc_4155
        	loc_4153:
01ed:2283	mov	al, 0x26
        	loc_4155:
01ed:2285	push	ax
01ed:2286	call	0x4263
01ed:2289	inc	sp
01ed:228a	inc	sp
01ed:228b	pop	bp
01ed:228c	ret	
sub_4131 ENDP
*/
void sub_4131()
{
    // coverage: 0x3461-0x348d method sub_4131
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_413d;
    sub_ca53();
loc_413d:
    al = memoryAGet(ds, 0x856e);
    al++;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_4153;
    al = 0x2a;
    goto loc_4155;
loc_4153:
    al = 0x26;
loc_4155:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:228d sub_415d()
sub_415d PROC
01ed:228d	push	bp
01ed:228e	mov	bp, sp
01ed:2290	cmp	word ptr [0x6b4c], sp
01ed:2294	ja	loc_4169
01ed:2296	call	0xffffab83
        	loc_4169:
01ed:2299	mov	byte ptr [0xa0ce], 1
01ed:229e	mov	al, 0
01ed:22a0	mov	byte ptr [0x792a], al
01ed:22a3	mov	byte ptr [0xa1aa], al
01ed:22a6	mov	al, 0x2e
01ed:22a8	push	ax
01ed:22a9	call	0x4263
01ed:22ac	inc	sp
01ed:22ad	inc	sp
01ed:22ae	pop	bp
01ed:22af	ret	
sub_415d ENDP
*/
void sub_415d()
{
    // coverage: 0x348d-0x34b0 method sub_415d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4169;
    sub_ca53();
loc_4169:
    memoryASet(ds, 0xa0ce, 0x01);
    al = 0x00;
    memoryASet(ds, 0x792a, al);
    memoryASet(ds, 0xa1aa, al);
    al = 0x2e;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:22b0 sub_4180()
sub_4180 PROC
01ed:22b0	push	bp
01ed:22b1	mov	bp, sp
01ed:22b3	cmp	word ptr [0x6b4c], sp
01ed:22b7	ja	loc_418c
01ed:22b9	call	0xffffab83
        	loc_418c:
01ed:22bc	call	0x22fc
01ed:22bf	pop	bp
01ed:22c0	ret	
sub_4180 ENDP
*/
void sub_4180()
{
    // coverage: 0x34b0-0x34c1 method sub_4180
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_418c;
    sub_ca53();
loc_418c:
    sub_41cc();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:22c1 sub_4191()
sub_4191 PROC
01ed:22c1	push	bp
01ed:22c2	mov	bp, sp
01ed:22c4	cmp	word ptr [0x6b4c], sp
01ed:22c8	ja	loc_419d
01ed:22ca	call	0xffffab83
        	loc_419d:
01ed:22cd	call	0x22fc
01ed:22d0	pop	bp
01ed:22d1	ret	
sub_4191 ENDP
*/
void sub_4191()
{
    // coverage: 0x34c1-0x34d2 method sub_4191
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_419d;
    sub_ca53();
loc_419d:
    sub_41cc();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:22d2 sub_41a2()
sub_41a2 PROC
01ed:22d2	push	bp
01ed:22d3	mov	bp, sp
01ed:22d5	cmp	word ptr [0x6b4c], sp
01ed:22d9	ja	loc_41ae
01ed:22db	call	0xffffab83
        	loc_41ae:
01ed:22de	mov	al, byte ptr [0xa0ce]
01ed:22e1	inc	al
01ed:22e3	mov	byte ptr [0xa0ce], al
01ed:22e6	cmp	al, 3
01ed:22e8	jne	loc_41bf
01ed:22ea	call	0x22fc
01ed:22ed	jmp	loc_41ca
        	loc_41bf:
01ed:22ef	mov	al, 0x2e
01ed:22f1	push	ax
01ed:22f2	call	0x4263
01ed:22f5	inc	sp
01ed:22f6	inc	sp
01ed:22f7	call	0x238e
        	loc_41ca:
01ed:22fa	pop	bp
01ed:22fb	ret	
sub_41a2 ENDP
*/
void sub_41a2()
{
    // coverage: 0x34d2-0x34fc method sub_41a2
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_41ae;
    sub_ca53();
loc_41ae:
    al = memoryAGet(ds, 0xa0ce);
    al++;
    memoryASet(ds, 0xa0ce, al);
    if (al != 0x03)
        goto loc_41bf;
    sub_41cc();
    goto loc_41ca;
loc_41bf:
    al = 0x2e;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
loc_41ca:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:22fc sub_41cc()
sub_41cc PROC
01ed:22fc	push	bp
01ed:22fd	mov	bp, sp
01ed:22ff	push	si
01ed:2300	cmp	word ptr [0x6b4c], sp
01ed:2304	ja	loc_41d9
01ed:2306	call	0xffffab83
        	loc_41d9:
01ed:2309	mov	byte ptr [0xa0ce], 0
01ed:230e	mov	si, 0x3e8
01ed:2311	jmp	loc_41e7
        	loc_41e3:
01ed:2313	call	0x236f
01ed:2316	dec	si
        	loc_41e7:
01ed:2317	or	si, si
01ed:2319	jne	loc_41e3
01ed:231b	mov	byte ptr [0x856d], 1
01ed:2320	mov	al, byte ptr [0x791a]
01ed:2323	mov	ah, 0
01ed:2325	or	ax, ax
01ed:2327	jne	loc_4200
01ed:2329	mov	al, 0xff
01ed:232b	mov	byte ptr [0x928d], al
01ed:232e	jmp	loc_4207
        	loc_4200:
01ed:2330	dec	byte ptr [0x791a]
01ed:2334	mov	al, byte ptr [0x791a]
        	loc_4207:
01ed:2337	pop	si
01ed:2338	pop	bp
01ed:2339	ret	
sub_41cc ENDP
*/
void sub_41cc()
{
    // coverage: 0x34fc-0x353a method sub_41cc
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_41d9;
    sub_ca53();
loc_41d9:
    memoryASet(ds, 0xa0ce, 0x00);
    si = 0x03e8;
    goto loc_41e7;
loc_41e3:
    sub_423f();
    si--;
loc_41e7:
    if (si)
        goto loc_41e3;
    memoryASet(ds, 0x856d, 0x01);
    al = memoryAGet(ds, 0x791a);
    ah = 0x00;
    if (ax)
        goto loc_4200;
    al = 0xff;
    memoryASet(ds, 0x928d, al);
    goto loc_4207;
loc_4200:
    memoryASet(ds, 0x791a, memoryAGet(ds, 0x791a) - 1);
    al = memoryAGet(ds, 0x791a);
loc_4207:
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:233a sub_420a()
sub_420a PROC
01ed:233a	push	bp
01ed:233b	mov	bp, sp
01ed:233d	cmp	word ptr [0x6b4c], sp
01ed:2341	ja	loc_4216
01ed:2343	call	0xffffab83
        	loc_4216:
01ed:2346	cmp	byte ptr [0xa1b1], 0
01ed:234b	je	loc_423d
01ed:234d	cmp	byte ptr [0x8550], 9
01ed:2352	je	loc_422a
01ed:2354	inc	byte ptr [0x8550]
01ed:2358	jmp	loc_423d
        	loc_422a:
01ed:235a	mov	byte ptr [0x8550], 0
01ed:235f	mov	al, byte ptr [0x8572]
01ed:2362	mov	byte ptr [0x856f], al
01ed:2365	mov	al, 0x5a
01ed:2367	push	ax
01ed:2368	call	0x69aa
01ed:236b	inc	sp
01ed:236c	inc	sp
        	loc_423d:
01ed:236d	pop	bp
01ed:236e	ret	
sub_420a ENDP
*/
void sub_420a()
{
    // coverage: 0x353a-0x356f method sub_420a
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4216;
    sub_ca53();
loc_4216:
    if (memoryAGet(ds, 0xa1b1) == 0x00)
        goto loc_423d;
    if (memoryAGet(ds, 0x8550) == 0x09)
        goto loc_422a;
    memoryASet(ds, 0x8550, memoryAGet(ds, 0x8550) + 1);
    goto loc_423d;
loc_422a:
    memoryASet(ds, 0x8550, 0x00);
    al = memoryAGet(ds, 0x8572);
    memoryASet(ds, 0x856f, al);
    al = 0x5a;
    push(ax);
    sub_887a();
    sp++;
    sp++;
loc_423d:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:236f sub_423f()
sub_423f PROC
01ed:236f	push	bp
01ed:2370	mov	bp, sp
01ed:2372	cmp	word ptr [0x6b4c], sp
01ed:2376	ja	loc_424b
01ed:2378	call	0xffffab83
        	loc_424b:
01ed:237b	mov	al, byte ptr [0x856e]
01ed:237e	mov	ah, 0
01ed:2380	les	bx, ptr [0xa0d8]
01ed:2384	add	bx, ax
01ed:2386	mov	al, byte ptr es:[bx]
01ed:2389	mov	byte ptr [0x7924], al
01ed:238c	pop	bp
01ed:238d	ret	
sub_423f ENDP
*/
void sub_423f()
{
    // coverage: 0x356f-0x358e method sub_423f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_424b;
    sub_ca53();
loc_424b:
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ds, 0x7924, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:238e sub_425e()
sub_425e PROC
01ed:238e	push	bp
01ed:238f	mov	bp, sp
01ed:2391	cmp	word ptr [0x6b4c], sp
01ed:2395	ja	loc_426a
01ed:2397	call	0xffffab83
        	loc_426a:
01ed:239a	mov	al, byte ptr [0x792c]
01ed:239d	mov	ah, 0
01ed:239f	mov	dx, 0x22
01ed:23a2	imul	dx
01ed:23a4	mov	dl, byte ptr [0x792a]
01ed:23a8	mov	dh, 0
01ed:23aa	shl	dx, 1
01ed:23ac	add	ax, dx
01ed:23ae	mov	bx, ax
01ed:23b0	call	word ptr [bx + 0x43c0]
01ed:23b4	pop	bp
01ed:23b5	ret	
sub_425e ENDP
*/
void sub_425e()
{
    // coverage: 0x358e-0x35b6 method sub_425e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_426a;
    sub_ca53();
loc_426a:
    al = memoryAGet(ds, 0x792c);
    ah = 0x00;
    dx = 0x0022;
    imul(dx);
    dl = memoryAGet(ds, 0x792a);
    dh = 0x00;
    dx <<= 1;
    ax += dx;
    bx = ax;
    callIndirect(cs, memoryAGet16(ds, bx + 17344));
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:23b6 sub_4286()
sub_4286 PROC
01ed:23b6	push	bp
01ed:23b7	mov	bp, sp
01ed:23b9	cmp	word ptr [0x6b4c], sp
01ed:23bd	ja	loc_4292
01ed:23bf	call	0xffffab83
        	loc_4292:
01ed:23c2	test	byte ptr [0x8244], 4
01ed:23c7	je	loc_429e
01ed:23c9	call	0x2634
01ed:23cc	jmp	loc_42f1
        	loc_429e:
01ed:23ce	test	byte ptr [0x8244], 8
01ed:23d3	je	loc_42aa
01ed:23d5	call	0x26a1
01ed:23d8	jmp	loc_42f1
        	loc_42aa:
01ed:23da	cmp	byte ptr [0x856e], 8
01ed:23df	jb	loc_42c9
01ed:23e1	mov	al, byte ptr [0x856e]
01ed:23e4	mov	ah, 0
01ed:23e6	mov	es, word ptr [0xa0da]
01ed:23ea	add	ax, word ptr [0xa0d8]
01ed:23ee	mov	bx, ax
01ed:23f0	cmp	byte ptr es:[bx - 8], 0xe
01ed:23f5	jne	loc_42c9
01ed:23f7	jmp	loc_42ee
        	loc_42c9:
01ed:23f9	test	byte ptr [0x8244], 2
01ed:23fe	je	loc_42ee
01ed:2400	call	0x4747
01ed:2403	cmp	word ptr [0x689c], 4
01ed:2408	je	loc_42e4
01ed:240a	mov	al, 0x14
01ed:240c	push	ax
01ed:240d	call	0x6e11
01ed:2410	inc	sp
01ed:2411	inc	sp
01ed:2412	jmp	loc_42f1
        	loc_42e4:
01ed:2414	mov	al, 0x2a
01ed:2416	push	ax
01ed:2417	call	0x6e11
01ed:241a	inc	sp
01ed:241b	inc	sp
01ed:241c	jmp	loc_42f1
        	loc_42ee:
01ed:241e	call	0x27de
        	loc_42f1:
01ed:2421	pop	bp
01ed:2422	ret	
sub_4286 ENDP
*/
void sub_4286()
{
    // coverage: 0x35b6-0x3623 method sub_4286
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4292;
    sub_ca53();
loc_4292:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_429e;
    sub_4504();
    goto loc_42f1;
loc_429e:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_42aa;
    sub_4571();
    goto loc_42f1;
loc_42aa:
    if (memoryAGet(ds, 0x856e) < 0x08)
        goto loc_42c9;
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    es = memoryAGet16(ds, 0xa0da);
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    if (memoryAGet(es, bx + 65528) != 0x0e)
        goto loc_42c9;
    goto loc_42ee;
loc_42c9:
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_42ee;
    sub_6617();
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_42e4;
    al = 0x14;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    goto loc_42f1;
loc_42e4:
    al = 0x2a;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    goto loc_42f1;
loc_42ee:
    sub_46ae();
loc_42f1:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2423 sub_42f3()
sub_42f3 PROC
01ed:2423	push	bp
01ed:2424	mov	bp, sp
01ed:2426	sub	sp, 6
01ed:2429	cmp	word ptr [0x6b4c], sp
01ed:242d	ja	loc_4302
01ed:242f	call	0xffffab83
        	loc_4302:
01ed:2432	mov	byte ptr [bp - 1], 0x21
01ed:2436	mov	byte ptr [bp - 2], 4
01ed:243a	mov	word ptr [bp - 6], 0x14ea
01ed:243f	mov	word ptr [bp - 4], ds
01ed:2442	push	word ptr [bp - 4]
01ed:2445	push	word ptr [bp - 6]
01ed:2448	mov	al, byte ptr [bp - 2]
01ed:244b	push	ax
01ed:244c	mov	al, byte ptr [bp - 1]
01ed:244f	push	ax
01ed:2450	call	0x495c
01ed:2453	add	sp, 8
01ed:2456	test	byte ptr [0x8244], 4
01ed:245b	je	loc_4332
01ed:245d	call	0x2634
01ed:2460	jmp	loc_433c
        	loc_4332:
01ed:2462	test	byte ptr [0x8244], 8
01ed:2467	je	loc_433c
01ed:2469	call	0x26a1
        	loc_433c:
01ed:246c	mov	sp, bp
01ed:246e	pop	bp
01ed:246f	ret	
sub_42f3 ENDP
*/
void sub_42f3()
{
    // coverage: 0x3623-0x3670 method sub_42f3
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4302;
    sub_ca53();
loc_4302:
    memoryASet(ss, bp - 1, 0x21);
    memoryASet(ss, bp - 2, 0x04);
    memoryASet16(ss, bp - 6, 0x14ea);
    memoryASet16(ss, bp - 4, ds);
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_682c();
    sp += 0x0008;
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_4332;
    sub_4504();
    goto loc_433c;
loc_4332:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_433c;
    sub_4571();
loc_433c:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2470 sub_4340()
sub_4340 PROC
01ed:2470	push	bp
01ed:2471	mov	bp, sp
01ed:2473	cmp	word ptr [0x6b4c], sp
01ed:2477	ja	loc_434c
01ed:2479	call	0xffffab83
        	loc_434c:
01ed:247c	mov	byte ptr [0x824c], 8
01ed:2481	mov	al, 0xb
01ed:2483	push	ax
01ed:2484	call	0x4263
01ed:2487	inc	sp
01ed:2488	inc	sp
01ed:2489	call	0x238e
01ed:248c	pop	bp
01ed:248d	ret	
sub_4340 ENDP
*/
void sub_4340()
{
    // coverage: 0x3670-0x368e method sub_4340
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_434c;
    sub_ca53();
loc_434c:
    memoryASet(ds, 0x824c, 0x08);
    al = 0x0b;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:248e sub_435e()
sub_435e PROC
01ed:248e	push	bp
01ed:248f	mov	bp, sp
01ed:2491	sub	sp, 6
01ed:2494	cmp	word ptr [0x6b4c], sp
01ed:2498	ja	loc_436d
01ed:249a	call	0xffffab83
        	loc_436d:
01ed:249d	mov	byte ptr [bp - 1], 0x25
01ed:24a1	mov	byte ptr [bp - 2], 6
01ed:24a5	mov	word ptr [bp - 6], 0x1664
01ed:24aa	mov	word ptr [bp - 4], ds
01ed:24ad	push	word ptr [bp - 4]
01ed:24b0	push	word ptr [bp - 6]
01ed:24b3	mov	al, byte ptr [bp - 2]
01ed:24b6	push	ax
01ed:24b7	mov	al, byte ptr [bp - 1]
01ed:24ba	push	ax
01ed:24bb	call	0x495c
01ed:24be	add	sp, 8
01ed:24c1	test	byte ptr [0x8244], 2
01ed:24c6	je	loc_43a3
01ed:24c8	mov	al, 0xc
01ed:24ca	push	ax
01ed:24cb	call	0x4263
01ed:24ce	inc	sp
01ed:24cf	inc	sp
01ed:24d0	call	0x238e
        	loc_43a3:
01ed:24d3	mov	sp, bp
01ed:24d5	pop	bp
01ed:24d6	ret	
sub_435e ENDP
*/
void sub_435e()
{
    // coverage: 0x368e-0x36d7 method sub_435e
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_436d;
    sub_ca53();
loc_436d:
    memoryASet(ss, bp - 1, 0x25);
    memoryASet(ss, bp - 2, 0x06);
    memoryASet16(ss, bp - 6, 0x1664);
    memoryASet16(ss, bp - 4, ds);
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_682c();
    sp += 0x0008;
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_43a3;
    al = 0x0c;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
loc_43a3:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:24d7 sub_43a7()
sub_43a7 PROC
01ed:24d7	push	bp
01ed:24d8	mov	bp, sp
01ed:24da	cmp	word ptr [0x6b4c], sp
01ed:24de	ja	loc_43b3
01ed:24e0	call	0xffffab83
        	loc_43b3:
01ed:24e3	cmp	byte ptr [0x7924], 0
01ed:24e8	jne	loc_43d0
01ed:24ea	mov	al, byte ptr [0x856e]
01ed:24ed	mov	ah, 0
01ed:24ef	mov	es, word ptr [0xa0da]
01ed:24f3	add	ax, word ptr [0xa0d8]
01ed:24f7	mov	bx, ax
01ed:24f9	cmp	byte ptr es:[bx + 8], 0xb
01ed:24fe	jne	loc_43d5
        	loc_43d0:
01ed:2500	call	0x250a
01ed:2503	jmp	loc_43d8
        	loc_43d5:
01ed:2505	call	0x28e0
        	loc_43d8:
01ed:2508	pop	bp
01ed:2509	ret	
sub_43a7 ENDP
*/
void sub_43a7()
{
    // coverage: 0x36d7-0x370a method sub_43a7
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_43b3;
    sub_ca53();
loc_43b3:
    if (memoryAGet(ds, 0x7924) != 0x00)
        goto loc_43d0;
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    es = memoryAGet16(ds, 0xa0da);
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    if (memoryAGet(es, bx + 8) != 0x0b)
        goto loc_43d5;
loc_43d0:
    sub_43da();
    goto loc_43d8;
loc_43d5:
    sub_47b0();
loc_43d8:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:250a sub_43da()
sub_43da PROC
01ed:250a	push	bp
01ed:250b	mov	bp, sp
01ed:250d	cmp	word ptr [0x6b4c], sp
01ed:2511	ja	loc_43e6
01ed:2513	call	0xffffab83
        	loc_43e6:
01ed:2516	test	byte ptr [0x8244], 4
01ed:251b	je	loc_43f2
01ed:251d	call	0x2634
01ed:2520	jmp	loc_440d
        	loc_43f2:
01ed:2522	test	byte ptr [0x8244], 8
01ed:2527	je	loc_43fe
01ed:2529	call	0x26a1
01ed:252c	jmp	loc_440d
        	loc_43fe:
01ed:252e	test	byte ptr [0x8244], 2
01ed:2533	je	loc_440a
01ed:2535	call	0x253f
01ed:2538	jmp	loc_440d
        	loc_440a:
01ed:253a	call	0x27de
        	loc_440d:
01ed:253d	pop	bp
01ed:253e	ret	
sub_43da ENDP
*/
void sub_43da()
{
    // coverage: 0x370a-0x373f method sub_43da
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_43e6;
    sub_ca53();
loc_43e6:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_43f2;
    sub_4504();
    goto loc_440d;
loc_43f2:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_43fe;
    sub_4571();
    goto loc_440d;
loc_43fe:
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_440a;
    sub_440f();
    goto loc_440d;
loc_440a:
    sub_46ae();
loc_440d:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:253f sub_440f()
sub_440f PROC
01ed:253f	push	bp
01ed:2540	mov	bp, sp
01ed:2542	cmp	word ptr [0x6b4c], sp
01ed:2546	ja	loc_441b
01ed:2548	call	0xffffab83
        	loc_441b:
01ed:254b	cmp	byte ptr [0x7924], 0xf
01ed:2550	jne	loc_4427
01ed:2552	call	0x4802
01ed:2555	jmp	loc_443a
        	loc_4427:
01ed:2557	cmp	byte ptr [0x7924], 0x12
01ed:255c	jne	loc_4430
01ed:255e	jmp	loc_4437
        	loc_4430:
01ed:2560	cmp	byte ptr [0x7924], 0x1f
01ed:2565	jne	loc_443a
        	loc_4437:
01ed:2567	call	0x22b0
        	loc_443a:
01ed:256a	call	0x65fb
01ed:256d	cmp	word ptr [0x689c], 4
01ed:2572	je	loc_4448
01ed:2574	mov	al, 0x14
01ed:2576	jmp	loc_444a
        	loc_4448:
01ed:2578	mov	al, 9
        	loc_444a:
01ed:257a	push	ax
01ed:257b	call	0x6e11
01ed:257e	inc	sp
01ed:257f	inc	sp
01ed:2580	inc	byte ptr [0x824c]
01ed:2584	cmp	byte ptr [0x824c], 9
01ed:2589	jne	loc_4470
01ed:258b	mov	al, byte ptr [0x856e]
01ed:258e	add	al, 0xf8
01ed:2590	mov	byte ptr [0x856f], al
01ed:2593	mov	al, 0x24
01ed:2595	push	ax
01ed:2596	call	0x69aa
01ed:2599	inc	sp
01ed:259a	inc	sp
01ed:259b	mov	byte ptr [0x824c], 0
        	loc_4470:
01ed:25a0	mov	al, 0xd
01ed:25a2	push	ax
01ed:25a3	call	0x4263
01ed:25a6	inc	sp
01ed:25a7	inc	sp
01ed:25a8	call	0x238e
01ed:25ab	pop	bp
01ed:25ac	ret	
sub_440f ENDP
*/
void sub_440f()
{
    // coverage: 0x373f-0x37ad method sub_440f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_441b;
    sub_ca53();
loc_441b:
    if (memoryAGet(ds, 0x7924) != 0x0f)
        goto loc_4427;
    sub_66d2();
    goto loc_443a;
loc_4427:
    if (memoryAGet(ds, 0x7924) != 0x12)
        goto loc_4430;
    goto loc_4437;
loc_4430:
    if (memoryAGet(ds, 0x7924) != 0x1f)
        goto loc_443a;
loc_4437:
    sub_4180();
loc_443a:
    sub_84cb();
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_4448;
    al = 0x14;
    goto loc_444a;
loc_4448:
    al = 0x09;
loc_444a:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    memoryASet(ds, 0x824c, memoryAGet(ds, 0x824c) + 1);
    if (memoryAGet(ds, 0x824c) != 0x09)
        goto loc_4470;
    al = memoryAGet(ds, 0x856e);
    al += 0xf8;
    memoryASet(ds, 0x856f, al);
    al = 0x24;
    push(ax);
    sub_887a();
    sp++;
    sp++;
    memoryASet(ds, 0x824c, 0x00);
loc_4470:
    al = 0x0d;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:25ad sub_447d()
sub_447d PROC
01ed:25ad	push	bp
01ed:25ae	mov	bp, sp
01ed:25b0	dec	sp
01ed:25b1	dec	sp
01ed:25b2	cmp	word ptr [0x6b4c], sp
01ed:25b6	ja	loc_448b
01ed:25b8	call	0xffffab83
        	loc_448b:
01ed:25bb	mov	byte ptr [bp - 2], 0
01ed:25bf	mov	al, byte ptr [0x856e]
01ed:25c2	mov	byte ptr [bp - 1], al
01ed:25c5	jmp	loc_44f7
        	loc_4497:
01ed:25c7	mov	al, byte ptr [bp - 1]
01ed:25ca	inc	al
01ed:25cc	mov	byte ptr [bp - 1], al
01ed:25cf	cmp	al, 0x30
01ed:25d1	jne	loc_44a7
01ed:25d3	mov	byte ptr [bp - 1], 0
        	loc_44a7:
01ed:25d7	mov	al, byte ptr [bp - 1]
01ed:25da	mov	ah, 0
01ed:25dc	les	bx, ptr [0xa0d8]
01ed:25e0	add	bx, ax
01ed:25e2	cmp	byte ptr es:[bx], 0xf
01ed:25e6	jne	loc_44f7
01ed:25e8	mov	al, byte ptr [bp - 1]
01ed:25eb	mov	byte ptr [0x856f], al
01ed:25ee	mov	byte ptr [0x856e], al
01ed:25f1	call	0x4906
01ed:25f4	mov	ax, word ptr [0x9292]
01ed:25f7	add	ax, 0xd
01ed:25fa	mov	word ptr [0x9292], ax
01ed:25fd	mov	al, 0x27
01ed:25ff	push	ax
01ed:2600	call	0x69aa
01ed:2603	inc	sp
01ed:2604	inc	sp
01ed:2605	cmp	word ptr [0x689c], 4
01ed:260a	je	loc_44e0
01ed:260c	mov	al, 3
01ed:260e	jmp	loc_44e2
        	loc_44e0:
01ed:2610	mov	al, 0x28
        	loc_44e2:
01ed:2612	push	ax
01ed:2613	call	0x6e11
01ed:2616	inc	sp
01ed:2617	inc	sp
01ed:2618	mov	al, 0xf
01ed:261a	push	ax
01ed:261b	call	0x4263
01ed:261e	inc	sp
01ed:261f	inc	sp
01ed:2620	call	0x238e
01ed:2623	mov	byte ptr [bp - 2], 1
        	loc_44f7:
01ed:2627	mov	al, byte ptr [bp - 2]
01ed:262a	mov	ah, 0
01ed:262c	or	ax, ax
01ed:262e	je	loc_4497
01ed:2630	mov	sp, bp
01ed:2632	pop	bp
01ed:2633	ret	
sub_447d ENDP
*/
void sub_447d()
{
    // coverage: 0x37ad-0x3834 method sub_447d
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_448b;
    sub_ca53();
loc_448b:
    memoryASet(ss, bp - 2, 0x00);
    al = memoryAGet(ds, 0x856e);
    memoryASet(ss, bp - 1, al);
    goto loc_44f7;
loc_4497:
    al = memoryAGet(ss, bp - 1);
    al++;
    memoryASet(ss, bp - 1, al);
    if (al != 0x30)
        goto loc_44a7;
    memoryASet(ss, bp - 1, 0x00);
loc_44a7:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx) != 0x0f)
        goto loc_44f7;
    al = memoryAGet(ss, bp - 1);
    memoryASet(ds, 0x856f, al);
    memoryASet(ds, 0x856e, al);
    sub_67d6();
    ax = memoryAGet16(ds, 0x9292);
    ax += 0x000d;
    memoryASet16(ds, 0x9292, ax);
    al = 0x27;
    push(ax);
    sub_887a();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_44e0;
    al = 0x03;
    goto loc_44e2;
loc_44e0:
    al = 0x28;
loc_44e2:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x0f;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    memoryASet(ss, bp - 2, 0x01);
loc_44f7:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    if (!ax)
        goto loc_4497;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2634 sub_4504()
sub_4504 PROC
01ed:2634	push	bp
01ed:2635	mov	bp, sp
01ed:2637	dec	sp
01ed:2638	dec	sp
01ed:2639	cmp	word ptr [0x6b4c], sp
01ed:263d	ja	loc_4512
01ed:263f	call	0xffffab83
        	loc_4512:
01ed:2642	mov	byte ptr [0x8551], 0
01ed:2647	call	0x63be
01ed:264a	mov	al, byte ptr [0x855e]
01ed:264d	mov	ah, 0
01ed:264f	or	ax, ax
01ed:2651	jne	loc_452c
01ed:2653	mov	byte ptr [0x8551], 0x1f
01ed:2658	mov	al, 0x12
01ed:265a	jmp	loc_4564
        	loc_452c:
01ed:265c	mov	al, byte ptr [0x856e]
01ed:265f	add	al, 0xff
01ed:2661	mov	byte ptr [0x8570], al
01ed:2664	push	ax
01ed:2665	call	0x6bd4
01ed:2668	inc	sp
01ed:2669	inc	sp
01ed:266a	mov	al, byte ptr [0x8551]
01ed:266d	mov	ah, 0
01ed:266f	mov	bx, ax
01ed:2671	mov	al, byte ptr [bx + 0x4256]
01ed:2675	mov	byte ptr [bp - 1], al
01ed:2678	cmp	al, 1
01ed:267a	je	loc_454e
01ed:267c	jmp	loc_4564
        	loc_454e:
01ed:267e	mov	al, byte ptr [0x8570]
01ed:2681	push	ax
01ed:2682	call	0x6bb5
01ed:2685	inc	sp
01ed:2686	inc	sp
01ed:2687	cmp	byte ptr [0x7921], 0xb
01ed:268c	jne	loc_4562
01ed:268e	mov	al, 0x16
01ed:2690	jmp	loc_4564
        	loc_4562:
01ed:2692	mov	al, 1
        	loc_4564:
01ed:2694	push	ax
01ed:2695	call	0x4263
01ed:2698	inc	sp
01ed:2699	inc	sp
01ed:269a	call	0x238e
01ed:269d	mov	sp, bp
01ed:269f	pop	bp
01ed:26a0	ret	
sub_4504 ENDP
*/
void sub_4504()
{
    // coverage: 0x3834-0x38a1 method sub_4504
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4512;
    sub_ca53();
loc_4512:
    memoryASet(ds, 0x8551, 0x00);
    sub_828e();
    al = memoryAGet(ds, 0x855e);
    ah = 0x00;
    if (ax)
        goto loc_452c;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x12;
    goto loc_4564;
loc_452c:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 16982);
    memoryASet(ss, bp - 1, al);
    if (al == 0x01)
        goto loc_454e;
    goto loc_4564;
loc_454e:
    al = memoryAGet(ds, 0x8570);
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_4562;
    al = 0x16;
    goto loc_4564;
loc_4562:
    al = 0x01;
loc_4564:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:26a1 sub_4571()
sub_4571 PROC
01ed:26a1	push	bp
01ed:26a2	mov	bp, sp
01ed:26a4	dec	sp
01ed:26a5	dec	sp
01ed:26a6	cmp	word ptr [0x6b4c], sp
01ed:26aa	ja	loc_457f
01ed:26ac	call	0xffffab83
        	loc_457f:
01ed:26af	mov	byte ptr [0x8551], 0
01ed:26b4	call	0x63be
01ed:26b7	cmp	byte ptr [0x855e], 7
01ed:26bc	jne	loc_4597
01ed:26be	mov	byte ptr [0x8551], 0x1f
01ed:26c3	mov	al, 0x13
01ed:26c5	jmp	loc_45cf
        	loc_4597:
01ed:26c7	mov	al, byte ptr [0x856e]
01ed:26ca	mov	byte ptr [0x8570], al
01ed:26cd	push	ax
01ed:26ce	call	0x6bd4
01ed:26d1	inc	sp
01ed:26d2	inc	sp
01ed:26d3	mov	al, byte ptr [0x8551]
01ed:26d6	mov	ah, 0
01ed:26d8	mov	bx, ax
01ed:26da	mov	al, byte ptr [bx + 0x4276]
01ed:26de	mov	byte ptr [bp - 1], al
01ed:26e1	cmp	al, 2
01ed:26e3	je	loc_45b7
01ed:26e5	jmp	loc_45cf
        	loc_45b7:
01ed:26e7	mov	al, byte ptr [0x856e]
01ed:26ea	inc	al
01ed:26ec	push	ax
01ed:26ed	call	0x6bb5
01ed:26f0	inc	sp
01ed:26f1	inc	sp
01ed:26f2	cmp	byte ptr [0x7921], 0xb
01ed:26f7	jne	loc_45cd
01ed:26f9	mov	al, 0x17
01ed:26fb	jmp	loc_45cf
        	loc_45cd:
01ed:26fd	mov	al, 2
        	loc_45cf:
01ed:26ff	push	ax
01ed:2700	call	0x4263
01ed:2703	inc	sp
01ed:2704	inc	sp
01ed:2705	call	0x238e
01ed:2708	mov	sp, bp
01ed:270a	pop	bp
01ed:270b	ret	
sub_4571 ENDP
*/
void sub_4571()
{
    // coverage: 0x38a1-0x390c method sub_4571
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_457f;
    sub_ca53();
loc_457f:
    memoryASet(ds, 0x8551, 0x00);
    sub_828e();
    if (memoryAGet(ds, 0x855e) != 0x07)
        goto loc_4597;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x13;
    goto loc_45cf;
loc_4597:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 17014);
    memoryASet(ss, bp - 1, al);
    if (al == 0x02)
        goto loc_45b7;
    goto loc_45cf;
loc_45b7:
    al = memoryAGet(ds, 0x856e);
    al++;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_45cd;
    al = 0x17;
    goto loc_45cf;
loc_45cd:
    al = 0x02;
loc_45cf:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:270c sub_45dc()
sub_45dc PROC
01ed:270c	push	bp
01ed:270d	mov	bp, sp
01ed:270f	dec	sp
01ed:2710	dec	sp
01ed:2711	cmp	word ptr [0x6b4c], sp
01ed:2715	ja	loc_45ea
01ed:2717	call	0xffffab83
        	loc_45ea:
01ed:271a	mov	byte ptr [0x8551], 0
01ed:271f	mov	al, byte ptr [0x855e]
01ed:2722	mov	ah, 0
01ed:2724	or	ax, ax
01ed:2726	jne	loc_4601
01ed:2728	mov	byte ptr [0x8551], 0x1f
01ed:272d	mov	al, 0x14
01ed:272f	jmp	loc_4639
        	loc_4601:
01ed:2731	mov	al, byte ptr [0x856e]
01ed:2734	add	al, 0xff
01ed:2736	mov	byte ptr [0x8570], al
01ed:2739	push	ax
01ed:273a	call	0x6bd4
01ed:273d	inc	sp
01ed:273e	inc	sp
01ed:273f	mov	al, byte ptr [0x8551]
01ed:2742	mov	ah, 0
01ed:2744	mov	bx, ax
01ed:2746	mov	al, byte ptr [bx + 0x4296]
01ed:274a	mov	byte ptr [bp - 1], al
01ed:274d	cmp	al, 8
01ed:274f	je	loc_4623
01ed:2751	jmp	loc_4639
        	loc_4623:
01ed:2753	mov	al, byte ptr [0x8570]
01ed:2756	push	ax
01ed:2757	call	0x6bb5
01ed:275a	inc	sp
01ed:275b	inc	sp
01ed:275c	cmp	byte ptr [0x7921], 0xb
01ed:2761	jne	loc_4637
01ed:2763	mov	al, 0x18
01ed:2765	jmp	loc_4639
        	loc_4637:
01ed:2767	mov	al, 8
        	loc_4639:
01ed:2769	push	ax
01ed:276a	call	0x4263
01ed:276d	inc	sp
01ed:276e	inc	sp
01ed:276f	call	0x238e
01ed:2772	mov	sp, bp
01ed:2774	pop	bp
01ed:2775	ret	
sub_45dc ENDP
*/
void sub_45dc()
{
    // coverage: 0x390c-0x3976 method sub_45dc
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_45ea;
    sub_ca53();
loc_45ea:
    memoryASet(ds, 0x8551, 0x00);
    al = memoryAGet(ds, 0x855e);
    ah = 0x00;
    if (ax)
        goto loc_4601;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x14;
    goto loc_4639;
loc_4601:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 17046);
    memoryASet(ss, bp - 1, al);
    if (al == 0x08)
        goto loc_4623;
    goto loc_4639;
loc_4623:
    al = memoryAGet(ds, 0x8570);
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_4637;
    al = 0x18;
    goto loc_4639;
loc_4637:
    al = 0x08;
loc_4639:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2776 sub_4646()
sub_4646 PROC
01ed:2776	push	bp
01ed:2777	mov	bp, sp
01ed:2779	dec	sp
01ed:277a	dec	sp
01ed:277b	cmp	word ptr [0x6b4c], sp
01ed:277f	ja	loc_4654
01ed:2781	call	0xffffab83
        	loc_4654:
01ed:2784	mov	byte ptr [0x8551], 0
01ed:2789	cmp	byte ptr [0x855e], 7
01ed:278e	jne	loc_4669
01ed:2790	mov	byte ptr [0x8551], 0x1f
01ed:2795	mov	al, 0x15
01ed:2797	jmp	loc_46a1
        	loc_4669:
01ed:2799	mov	al, byte ptr [0x856e]
01ed:279c	mov	byte ptr [0x8570], al
01ed:279f	push	ax
01ed:27a0	call	0x6bd4
01ed:27a3	inc	sp
01ed:27a4	inc	sp
01ed:27a5	mov	al, byte ptr [0x8551]
01ed:27a8	mov	ah, 0
01ed:27aa	mov	bx, ax
01ed:27ac	mov	al, byte ptr [bx + 0x42b6]
01ed:27b0	mov	byte ptr [bp - 1], al
01ed:27b3	cmp	al, 9
01ed:27b5	je	loc_4689
01ed:27b7	jmp	loc_46a1
        	loc_4689:
01ed:27b9	mov	al, byte ptr [0x856e]
01ed:27bc	inc	al
01ed:27be	push	ax
01ed:27bf	call	0x6bb5
01ed:27c2	inc	sp
01ed:27c3	inc	sp
01ed:27c4	cmp	byte ptr [0x7921], 0xb
01ed:27c9	jne	loc_469f
01ed:27cb	mov	al, 0x19
01ed:27cd	jmp	loc_46a1
        	loc_469f:
01ed:27cf	mov	al, 9
        	loc_46a1:
01ed:27d1	push	ax
01ed:27d2	call	0x4263
01ed:27d5	inc	sp
01ed:27d6	inc	sp
01ed:27d7	call	0x238e
01ed:27da	mov	sp, bp
01ed:27dc	pop	bp
01ed:27dd	ret	
sub_4646 ENDP
*/
void sub_4646()
{
    // coverage: 0x3976-0x39de method sub_4646
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4654;
    sub_ca53();
loc_4654:
    memoryASet(ds, 0x8551, 0x00);
    if (memoryAGet(ds, 0x855e) != 0x07)
        goto loc_4669;
    memoryASet(ds, 0x8551, 0x1f);
    al = 0x15;
    goto loc_46a1;
loc_4669:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x8570, al);
    push(ax);
    sub_8aa4();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 17078);
    memoryASet(ss, bp - 1, al);
    if (al == 0x09)
        goto loc_4689;
    goto loc_46a1;
loc_4689:
    al = memoryAGet(ds, 0x856e);
    al++;
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7921) != 0x0b)
        goto loc_469f;
    al = 0x19;
    goto loc_46a1;
loc_469f:
    al = 0x09;
loc_46a1:
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:27de sub_46ae()
sub_46ae PROC
01ed:27de	push	bp
01ed:27df	mov	bp, sp
01ed:27e1	cmp	word ptr [0x6b4c], sp
01ed:27e5	ja	loc_46ba
01ed:27e7	call	0xffffab83
        	loc_46ba:
01ed:27ea	mov	al, 0
01ed:27ec	mov	byte ptr [0x7923], al
01ed:27ef	mov	byte ptr [0xa1a7], al
01ed:27f2	mov	byte ptr [0x79b9], 0xb
01ed:27f7	cmp	byte ptr [0x7924], 0x11
01ed:27fc	jne	loc_46d8
01ed:27fe	mov	al, 0x2f
01ed:2800	push	ax
01ed:2801	call	0x4263
01ed:2804	inc	sp
01ed:2805	inc	sp
01ed:2806	jmp	loc_46db
        	loc_46d8:
01ed:2808	call	0x2810
        	loc_46db:
01ed:280b	call	0x238e
01ed:280e	pop	bp
01ed:280f	ret	
sub_46ae ENDP
*/
void sub_46ae()
{
    // coverage: 0x39de-0x3a10 method sub_46ae
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_46ba;
    sub_ca53();
loc_46ba:
    al = 0x00;
    memoryASet(ds, 0x7923, al);
    memoryASet(ds, 0xa1a7, al);
    memoryASet(ds, 0x79b9, 0x0b);
    if (memoryAGet(ds, 0x7924) != 0x11)
        goto loc_46d8;
    al = 0x2f;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    goto loc_46db;
loc_46d8:
    sub_46e0();
loc_46db:
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2810 sub_46e0()
sub_46e0 PROC
01ed:2810	push	bp
01ed:2811	mov	bp, sp
01ed:2813	sub	sp, 4
01ed:2816	cmp	word ptr [0x6b4c], sp
01ed:281a	ja	loc_46ef
01ed:281c	call	0xffffab83
        	loc_46ef:
01ed:281f	cmp	byte ptr [0x8552], 3
01ed:2824	je	loc_4732
01ed:2826	cmp	byte ptr [0x8552], 0xd
01ed:282b	je	loc_4732
01ed:282d	cmp	byte ptr [0x8552], 0x10
01ed:2832	je	loc_4732
01ed:2834	cmp	word ptr [0x689c], 4
01ed:2839	je	loc_4718
01ed:283b	mov	al, byte ptr [0x7922]
01ed:283e	mov	ah, 0
01ed:2840	mov	bx, ax
01ed:2842	mov	al, byte ptr [bx + 0x269e]
01ed:2846	jmp	loc_4723
        	loc_4718:
01ed:2848	mov	al, byte ptr [0x7922]
01ed:284b	mov	ah, 0
01ed:284d	mov	bx, ax
01ed:284f	mov	al, byte ptr [bx + 0x266e]
        	loc_4723:
01ed:2853	mov	byte ptr [bp - 4], al
01ed:2856	cmp	byte ptr [bp - 4], 0
01ed:285a	je	loc_4732
01ed:285c	push	ax
01ed:285d	call	0x6e11
01ed:2860	inc	sp
01ed:2861	inc	sp
        	loc_4732:
01ed:2862	cmp	byte ptr [0x856e], 8
01ed:2867	jae	loc_4741
01ed:2869	mov	al, 6
01ed:286b	push	ax
01ed:286c	call	0x4263
01ed:286f	jmp	loc_47aa
        	loc_4741:
01ed:2871	mov	al, byte ptr [0x856e]
01ed:2874	add	al, 0xf8
01ed:2876	mov	byte ptr [0x856f], al
01ed:2879	mov	ah, 0
01ed:287b	les	bx, ptr [0xa0d8]
01ed:287f	add	bx, ax
01ed:2881	mov	al, byte ptr es:[bx]
01ed:2884	mov	byte ptr [bp - 1], al
01ed:2887	mov	byte ptr [0x79b9], al
01ed:288a	mov	al, byte ptr [bp - 1]
01ed:288d	mov	ah, 0
01ed:288f	shl	ax, 1
01ed:2891	mov	bx, ax
01ed:2893	mov	al, byte ptr [bx + 0x76a]
01ed:2897	mov	byte ptr [bp - 2], al
01ed:289a	mov	al, byte ptr [bp - 1]
01ed:289d	mov	ah, 0
01ed:289f	shl	ax, 1
01ed:28a1	mov	bx, ax
01ed:28a3	mov	al, byte ptr [bx + 0x76b]
01ed:28a7	mov	byte ptr [bp - 3], al
01ed:28aa	mov	al, byte ptr [bp - 2]
01ed:28ad	push	ax
01ed:28ae	call	0x4263
01ed:28b1	inc	sp
01ed:28b2	inc	sp
01ed:28b3	cmp	byte ptr [0x792c], 0xa
01ed:28b8	jne	loc_479d
01ed:28ba	cmp	word ptr [0x689c], 4
01ed:28bf	je	loc_4795
01ed:28c1	mov	al, 0x14
01ed:28c3	jmp	loc_4797
        	loc_4795:
01ed:28c5	mov	al, 9
        	loc_4797:
01ed:28c7	push	ax
01ed:28c8	call	0x6e11
01ed:28cb	inc	sp
01ed:28cc	inc	sp
        	loc_479d:
01ed:28cd	cmp	byte ptr [bp - 3], 0
01ed:28d1	je	loc_47ac
01ed:28d3	mov	al, byte ptr [bp - 3]
01ed:28d6	push	ax
01ed:28d7	call	0x69aa
        	loc_47aa:
01ed:28da	inc	sp
01ed:28db	inc	sp
        	loc_47ac:
01ed:28dc	mov	sp, bp
01ed:28de	pop	bp
01ed:28df	ret	
sub_46e0 ENDP
*/
void sub_46e0()
{
    // coverage: 0x3a10-0x3ae0 method sub_46e0
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_46ef;
    sub_ca53();
loc_46ef:
    if (memoryAGet(ds, 0x8552) == 0x03)
        goto loc_4732;
    if (memoryAGet(ds, 0x8552) == 0x0d)
        goto loc_4732;
    if (memoryAGet(ds, 0x8552) == 0x10)
        goto loc_4732;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_4718;
    al = memoryAGet(ds, 0x7922);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9886);
    goto loc_4723;
loc_4718:
    al = memoryAGet(ds, 0x7922);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9838);
loc_4723:
    memoryASet(ss, bp - 4, al);
    if (memoryAGet(ss, bp - 4) == 0x00)
        goto loc_4732;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_4732:
    if (memoryAGet(ds, 0x856e) >= 0x08)
        goto loc_4741;
    al = 0x06;
    push(ax);
    sub_6133();
    goto loc_47aa;
loc_4741:
    al = memoryAGet(ds, 0x856e);
    al += 0xf8;
    memoryASet(ds, 0x856f, al);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 1, al);
    memoryASet(ds, 0x79b9, al);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    al = memoryAGet(ds, bx + 1898);
    memoryASet(ss, bp - 2, al);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    al = memoryAGet(ds, bx + 1899);
    memoryASet(ss, bp - 3, al);
    al = memoryAGet(ss, bp - 2);
    push(ax);
    sub_6133();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x792c) != 0x0a)
        goto loc_479d;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_4795;
    al = 0x14;
    goto loc_4797;
loc_4795:
    al = 0x09;
loc_4797:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_479d:
    if (memoryAGet(ss, bp - 3) == 0x00)
        goto loc_47ac;
    al = memoryAGet(ss, bp - 3);
    push(ax);
    sub_887a();
loc_47aa:
    sp++;
    sp++;
loc_47ac:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:28e0 sub_47b0()
sub_47b0 PROC
01ed:28e0	push	bp
01ed:28e1	mov	bp, sp
01ed:28e3	cmp	word ptr [0x6b4c], sp
01ed:28e7	ja	loc_47bc
01ed:28e9	call	0xffffab83
        	loc_47bc:
01ed:28ec	mov	al, 4
01ed:28ee	push	ax
01ed:28ef	call	0x4263
01ed:28f2	inc	sp
01ed:28f3	inc	sp
01ed:28f4	call	0x238e
01ed:28f7	pop	bp
01ed:28f8	ret	
sub_47b0 ENDP
*/
void sub_47b0()
{
    // coverage: 0x3ae0-0x3af9 method sub_47b0
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_47bc;
    sub_ca53();
loc_47bc:
    al = 0x04;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:28f9 sub_47c9()
sub_47c9 PROC
01ed:28f9	push	bp
01ed:28fa	mov	bp, sp
01ed:28fc	cmp	word ptr [0x6b4c], sp
01ed:2900	ja	loc_47d5
01ed:2902	call	0xffffab83
        	loc_47d5:
01ed:2905	mov	byte ptr [0x824c], 8
01ed:290a	cmp	byte ptr [0x79b4], 0
01ed:290f	jne	loc_47e8
01ed:2911	cmp	byte ptr [0x7924], 0
01ed:2916	jne	loc_47fe
        	loc_47e8:
01ed:2918	mov	byte ptr [0x79b4], 0
01ed:291d	cmp	byte ptr [0x856e], 0x28
01ed:2922	jae	loc_47f9
01ed:2924	call	0x28e0
01ed:2927	jmp	loc_4833
        	loc_47f9:
01ed:2929	call	0x42d9
01ed:292c	jmp	loc_4833
        	loc_47fe:
01ed:292e	cmp	byte ptr [0x7924], 0x20
01ed:2933	jne	loc_4818
01ed:2935	cmp	word ptr [0x689c], 4
01ed:293a	je	loc_4810
01ed:293c	mov	al, 3
01ed:293e	jmp	loc_4812
        	loc_4810:
01ed:2940	mov	al, 0x28
        	loc_4812:
01ed:2942	push	ax
01ed:2943	call	0x6e11
01ed:2946	inc	sp
01ed:2947	inc	sp
        	loc_4818:
01ed:2948	cmp	byte ptr [0x7924], 0x16
01ed:294d	jne	loc_4824
01ed:294f	call	0x4305
01ed:2952	jmp	loc_4833
        	loc_4824:
01ed:2954	cmp	byte ptr [0x7924], 3
01ed:2959	jne	loc_4830
01ed:295b	call	0x463d
01ed:295e	jmp	loc_4833
        	loc_4830:
01ed:2960	call	0x2965
        	loc_4833:
01ed:2963	pop	bp
01ed:2964	ret	
sub_47c9 ENDP
*/
void sub_47c9()
{
    // coverage: 0x3af9-0x3b65 method sub_47c9
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_47d5;
    sub_ca53();
loc_47d5:
    memoryASet(ds, 0x824c, 0x08);
    if (memoryAGet(ds, 0x79b4) != 0x00)
        goto loc_47e8;
    if (memoryAGet(ds, 0x7924) != 0x00)
        goto loc_47fe;
loc_47e8:
    memoryASet(ds, 0x79b4, 0x00);
    if (memoryAGet(ds, 0x856e) >= 0x28)
        goto loc_47f9;
    sub_47b0();
    goto loc_4833;
loc_47f9:
    sub_61a9();
    goto loc_4833;
loc_47fe:
    if (memoryAGet(ds, 0x7924) != 0x20)
        goto loc_4818;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_4810;
    al = 0x03;
    goto loc_4812;
loc_4810:
    al = 0x28;
loc_4812:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_4818:
    if (memoryAGet(ds, 0x7924) != 0x16)
        goto loc_4824;
    sub_61d5();
    goto loc_4833;
loc_4824:
    if (memoryAGet(ds, 0x7924) != 0x03)
        goto loc_4830;
    sub_650d();
    goto loc_4833;
loc_4830:
    sub_4835();
loc_4833:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2965 sub_4835()
sub_4835 PROC
01ed:2965	push	bp
01ed:2966	mov	bp, sp
01ed:2968	cmp	word ptr [0x6b4c], sp
01ed:296c	ja	loc_4841
01ed:296e	call	0xffffab83
        	loc_4841:
01ed:2971	test	byte ptr [0x8244], 4
01ed:2976	je	loc_484d
01ed:2978	call	0x467d
01ed:297b	jmp	loc_4874
        	loc_484d:
01ed:297d	test	byte ptr [0x8244], 8
01ed:2982	je	loc_4859
01ed:2984	call	0x469c
01ed:2987	jmp	loc_4874
        	loc_4859:
01ed:2989	cmp	byte ptr [0x7924], 0xa
01ed:298e	jne	loc_4865
01ed:2990	call	0x47cb
01ed:2993	jmp	loc_4874
        	loc_4865:
01ed:2995	cmp	byte ptr [0x7924], 0xf
01ed:299a	jne	loc_4871
01ed:299c	call	0x4802
01ed:299f	jmp	loc_4874
        	loc_4871:
01ed:29a1	call	0x29a6
        	loc_4874:
01ed:29a4	pop	bp
01ed:29a5	ret	
sub_4835 ENDP
*/
void sub_4835()
{
    // coverage: 0x3b65-0x3ba6 method sub_4835
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4841;
    sub_ca53();
loc_4841:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_484d;
    sub_654d();
    goto loc_4874;
loc_484d:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_4859;
    sub_656c();
    goto loc_4874;
loc_4859:
    if (memoryAGet(ds, 0x7924) != 0x0a)
        goto loc_4865;
    sub_669b();
    goto loc_4874;
loc_4865:
    if (memoryAGet(ds, 0x7924) != 0x0f)
        goto loc_4871;
    sub_66d2();
    goto loc_4874;
loc_4871:
    sub_4876();
loc_4874:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:29a6 sub_4876()
sub_4876 PROC
01ed:29a6	push	bp
01ed:29a7	mov	bp, sp
01ed:29a9	cmp	word ptr [0x6b4c], sp
01ed:29ad	ja	loc_4882
01ed:29af	call	0xffffab83
        	loc_4882:
01ed:29b2	cmp	byte ptr [0x856e], 8
01ed:29b7	jae	loc_488e
01ed:29b9	call	0x465e
01ed:29bc	jmp	loc_48d8
        	loc_488e:
01ed:29be	mov	al, byte ptr [0x856e]
01ed:29c1	add	al, 0xf8
01ed:29c3	mov	byte ptr [0x856f], al
01ed:29c6	mov	ah, 0
01ed:29c8	les	bx, ptr [0xa0d8]
01ed:29cc	add	bx, ax
01ed:29ce	cmp	byte ptr es:[bx], 0xe
01ed:29d2	je	loc_48a9
01ed:29d4	call	0x465e
01ed:29d7	jmp	loc_48d8
        	loc_48a9:
01ed:29d9	test	byte ptr [0x8244], 2
01ed:29de	je	loc_48b5
01ed:29e0	call	0x253f
01ed:29e3	jmp	loc_48d8
        	loc_48b5:
01ed:29e5	cmp	word ptr [0x689c], 4
01ed:29ea	je	loc_48c0
01ed:29ec	mov	al, 0x14
01ed:29ee	jmp	loc_48c2
        	loc_48c0:
01ed:29f0	mov	al, 9
        	loc_48c2:
01ed:29f2	push	ax
01ed:29f3	call	0x6e11
01ed:29f6	inc	sp
01ed:29f7	inc	sp
01ed:29f8	mov	al, 0x24
01ed:29fa	push	ax
01ed:29fb	call	0x69aa
01ed:29fe	inc	sp
01ed:29ff	inc	sp
01ed:2a00	mov	al, 0xa
01ed:2a02	push	ax
01ed:2a03	call	0x4263
01ed:2a06	inc	sp
01ed:2a07	inc	sp
        	loc_48d8:
01ed:2a08	pop	bp
01ed:2a09	ret	
sub_4876 ENDP
*/
void sub_4876()
{
    // coverage: 0x3ba6-0x3c0a method sub_4876
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4882;
    sub_ca53();
loc_4882:
    if (memoryAGet(ds, 0x856e) >= 0x08)
        goto loc_488e;
    sub_652e();
    goto loc_48d8;
loc_488e:
    al = memoryAGet(ds, 0x856e);
    al += 0xf8;
    memoryASet(ds, 0x856f, al);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx) == 0x0e)
        goto loc_48a9;
    sub_652e();
    goto loc_48d8;
loc_48a9:
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_48b5;
    sub_440f();
    goto loc_48d8;
loc_48b5:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_48c0;
    al = 0x14;
    goto loc_48c2;
loc_48c0:
    al = 0x09;
loc_48c2:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x24;
    push(ax);
    sub_887a();
    sp++;
    sp++;
    al = 0x0a;
    push(ax);
    sub_6133();
    sp++;
    sp++;
loc_48d8:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2a0a sub_48da()
sub_48da PROC
01ed:2a0a	push	bp
01ed:2a0b	mov	bp, sp
01ed:2a0d	dec	sp
01ed:2a0e	dec	sp
01ed:2a0f	push	si
01ed:2a10	push	di
01ed:2a11	cmp	word ptr [0x6b4c], sp
01ed:2a15	ja	loc_48ea
01ed:2a17	call	0xffffab83
        	loc_48ea:
01ed:2a1a	xor	di, di
01ed:2a1c	jmp	loc_493d
        	loc_48ee:
01ed:2a1e	xor	si, si
01ed:2a20	jmp	loc_4932
        	loc_48f2:
01ed:2a22	mov	ax, 1
01ed:2a25	push	ax
01ed:2a26	push	di
01ed:2a27	push	si
01ed:2a28	call	0xb88
01ed:2a2b	add	sp, 6
01ed:2a2e	mov	ax, si
01ed:2a30	mov	dx, 0x27
01ed:2a33	imul	dx
01ed:2a35	les	bx, ptr [0x6bca]
01ed:2a39	add	bx, ax
01ed:2a3b	mov	ax, di
01ed:2a3d	sar	ax, 1
01ed:2a3f	mov	dx, 3
01ed:2a42	imul	dx
01ed:2a44	add	bx, ax
01ed:2a46	mov	al, byte ptr es:[bx + 0x20]
01ed:2a4a	mov	byte ptr [bp - 1], al
01ed:2a4d	or	al, al
01ed:2a4f	je	loc_4931
01ed:2a51	mov	ax, 1
01ed:2a54	push	ax
01ed:2a55	push	di
01ed:2a56	push	si
01ed:2a57	mov	al, byte ptr [bp - 1]
01ed:2a5a	push	ax
01ed:2a5b	call	0xa90
01ed:2a5e	add	sp, 8
        	loc_4931:
01ed:2a61	inc	si
        	loc_4932:
01ed:2a62	cmp	si, 0x14
01ed:2a65	jl	loc_48f2
01ed:2a67	mov	ax, di
01ed:2a69	inc	ax
01ed:2a6a	inc	ax
01ed:2a6b	mov	di, ax
        	loc_493d:
01ed:2a6d	cmp	di, 0x1a
01ed:2a70	jl	loc_48ee
01ed:2a72	pop	di
01ed:2a73	pop	si
01ed:2a74	mov	sp, bp
01ed:2a76	pop	bp
01ed:2a77	ret	
sub_48da ENDP
*/
void sub_48da()
{
    // coverage: 0x3c0a-0x3c78 method sub_48da
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_48ea;
    sub_ca53();
loc_48ea:
    di = 0;
    goto loc_493d;
loc_48ee:
    si = 0;
    goto loc_4932;
loc_48f2:
    ax = 0x0001;
    push(ax);
    push(di);
    push(si);
    sub_2a58();
    sp += 0x0006;
    ax = si;
    dx = 0x0027;
    imul(dx);
    bx = memoryAGet16(ds, 0x6bca);
    es = memoryAGet16(ds, 0x6bca + 2);
    bx += ax;
    ax = di;
    ax = sar(ax, 1);
    dx = 0x0003;
    imul(dx);
    bx += ax;
    al = memoryAGet(es, bx + 32);
    memoryASet(ss, bp - 1, al);
    if (!al)
        goto loc_4931;
    ax = 0x0001;
    push(ax);
    push(di);
    push(si);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_2960();
    sp += 0x0008;
loc_4931:
    si++;
loc_4932:
    if ((short)si < (short)0x0014)
        goto loc_48f2;
    ax = di;
    ax++;
    ax++;
    di = ax;
loc_493d:
    if ((short)di < (short)0x001a)
        goto loc_48ee;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2a78 sub_4948()
sub_4948 PROC
01ed:2a78	push	bp
01ed:2a79	mov	bp, sp
01ed:2a7b	sub	sp, 0x14
01ed:2a7e	push	si
01ed:2a7f	push	di
01ed:2a80	cmp	word ptr [0x6b4c], sp
01ed:2a84	ja	loc_4959
01ed:2a86	call	0xffffab83
        	loc_4959:
01ed:2a89	mov	byte ptr [0x4c40], 0
01ed:2a8e	mov	byte ptr [0x4c4c], 0
01ed:2a93	mov	byte ptr [0x4c58], 0
01ed:2a98	mov	byte ptr [0x4c80], 0
01ed:2a9d	mov	byte ptr [0x4c8c], 0
01ed:2aa2	mov	byte ptr [0x4c98], 0
01ed:2aa7	mov	byte ptr [0x4ca4], 0
01ed:2aac	mov	ax, word ptr [0x4c72]
01ed:2aaf	mov	dx, word ptr [0x4c70]
01ed:2ab3	mov	word ptr [bp - 0x10], dx
01ed:2ab6	mov	word ptr [bp - 0xe], ax
01ed:2ab9	mov	ax, word ptr [0x4cbe]
01ed:2abc	mov	dx, word ptr [0x4cbc]
01ed:2ac0	mov	word ptr [bp - 0x14], dx
01ed:2ac3	mov	word ptr [bp - 0x12], ax
01ed:2ac6	les	bx, ptr [bp - 0x10]
01ed:2ac9	mov	al, 1
01ed:2acb	mov	byte ptr es:[bx], al
01ed:2ace	mov	byte ptr [0x8e8b], al
01ed:2ad1	les	bx, ptr [bp - 0x14]
01ed:2ad4	mov	al, 1
01ed:2ad6	mov	byte ptr es:[bx], al
01ed:2ad9	mov	byte ptr [0x8e8c], al
01ed:2adc	les	bx, ptr [bp - 0x10]
01ed:2adf	mov	al, 1
01ed:2ae1	mov	byte ptr es:[bx + 6], al
01ed:2ae5	mov	byte ptr [0x8578], al
01ed:2ae8	les	bx, ptr [bp - 0x14]
01ed:2aeb	mov	al, 1
01ed:2aed	mov	byte ptr es:[bx + 6], al
01ed:2af1	mov	byte ptr [0x8579], al
01ed:2af4	les	bx, ptr [0xa0d8]
01ed:2af8	mov	al, byte ptr es:[bx + 0x90]
01ed:2afd	mov	byte ptr [0x856e], al
01ed:2b00	cmp	byte ptr [0x856e], 0
01ed:2b05	je	loc_49db
01ed:2b07	dec	byte ptr [0x856e]
        	loc_49db:
01ed:2b0b	les	bx, ptr [0xa0d8]
01ed:2b0f	mov	al, byte ptr es:[bx + 0x91]
01ed:2b14	mov	byte ptr [0x8572], al
01ed:2b17	cmp	byte ptr [0x8572], 0
01ed:2b1c	je	loc_49f2
01ed:2b1e	dec	byte ptr [0x8572]
        	loc_49f2:
01ed:2b22	les	bx, ptr [0xa0d8]
01ed:2b26	mov	al, byte ptr es:[bx + 0x92]
01ed:2b2b	mov	byte ptr [0xa0cf], al
01ed:2b2e	les	bx, ptr [0x75d0]
01ed:2b32	mov	al, byte ptr es:[bx + 0x93]
01ed:2b37	add	al, 0xff
01ed:2b39	mov	byte ptr [0x8571], al
01ed:2b3c	mov	al, byte ptr es:[bx + 0x95]
01ed:2b41	mov	byte ptr [0x7920], al
01ed:2b44	mov	al, byte ptr es:[bx + 0x94]
01ed:2b49	mov	byte ptr [0x8562], al
01ed:2b4c	mov	al, byte ptr es:[bx + 0x96]
01ed:2b51	mov	ah, 0
01ed:2b53	shl	ax, 1
01ed:2b55	mov	bx, ax
01ed:2b57	mov	ax, word ptr [bx + 0x2546]
01ed:2b5b	mov	word ptr [0xa0de], ax
01ed:2b5e	call	0x483c
01ed:2b61	mov	byte ptr [bp - 2], 0
01ed:2b65	jmp	loc_4bbd
        	loc_4a38:
01ed:2b68	mov	byte ptr [bp - 1], 0
01ed:2b6c	jmp	loc_4bb1
        	loc_4a3f:
01ed:2b6f	mov	al, byte ptr [bp - 2]
01ed:2b72	shl	al, 1
01ed:2b74	shl	al, 1
01ed:2b76	shl	al, 1
01ed:2b78	add	al, byte ptr [bp - 1]
01ed:2b7b	mov	byte ptr [bp - 3], al
01ed:2b7e	mov	al, byte ptr [bp - 2]
01ed:2b81	mov	ah, 0
01ed:2b83	shl	ax, 1
01ed:2b85	shl	ax, 1
01ed:2b87	shl	ax, 1
01ed:2b89	mov	dl, byte ptr [bp - 1]
01ed:2b8c	mov	dh, 0
01ed:2b8e	add	ax, dx
01ed:2b90	mov	es, word ptr [0xa0da]
01ed:2b94	add	ax, word ptr [0xa0d8]
01ed:2b98	mov	bx, ax
01ed:2b9a	mov	al, byte ptr es:[bx]
01ed:2b9d	mov	ah, 0
01ed:2b9f	mov	si, ax
01ed:2ba1	or	ax, ax
01ed:2ba3	je	loc_4abb
01ed:2ba5	mov	al, byte ptr [si + 0x3d3a]
01ed:2ba9	mov	ah, 0
01ed:2bab	mov	si, ax
01ed:2bad	mov	bx, si
01ed:2baf	shl	bx, 1
01ed:2bb1	shl	bx, 1
01ed:2bb3	mov	ax, word ptr [bx + 0x3d6c]
01ed:2bb7	mov	dx, word ptr [bx + 0x3d6a]
01ed:2bbb	mov	word ptr [bp - 8], dx
01ed:2bbe	mov	word ptr [bp - 6], ax
01ed:2bc1	les	bx, ptr [bp - 0x10]
01ed:2bc4	mov	al, byte ptr [bp - 3]
01ed:2bc7	mov	byte ptr es:[bx + 1], al
01ed:2bcb	push	es
01ed:2bcc	les	di, ptr [bp - 8]
01ed:2bcf	mov	ax, word ptr es:[di]
01ed:2bd2	pop	es
01ed:2bd3	mov	word ptr es:[bx + 8], ax
01ed:2bd7	les	bx, ptr [bp - 8]
01ed:2bda	mov	ax, word ptr es:[bx + 2]
01ed:2bde	les	bx, ptr [bp - 0x10]
01ed:2be1	mov	word ptr es:[bx + 0xa], ax
01ed:2be5	call	0x165e
01ed:2be8	call	0x1a67
        	loc_4abb:
01ed:2beb	mov	al, byte ptr [bp - 2]
01ed:2bee	mov	ah, 0
01ed:2bf0	shl	ax, 1
01ed:2bf2	shl	ax, 1
01ed:2bf4	shl	ax, 1
01ed:2bf6	les	bx, ptr [0xa0d8]
01ed:2bfa	add	bx, ax
01ed:2bfc	mov	al, byte ptr [bp - 1]
01ed:2bff	mov	ah, 0
01ed:2c01	add	bx, ax
01ed:2c03	mov	al, byte ptr es:[bx + 0x30]
01ed:2c07	mov	ah, 0
01ed:2c09	mov	si, ax
01ed:2c0b	or	ax, ax
01ed:2c0d	je	loc_4b2b
01ed:2c0f	cmp	byte ptr [bp - 1], 7
01ed:2c13	je	loc_4b2b
01ed:2c15	mov	al, byte ptr [si + 0x4086]
01ed:2c19	mov	ah, 0
01ed:2c1b	mov	si, ax
01ed:2c1d	mov	bx, si
01ed:2c1f	shl	bx, 1
01ed:2c21	shl	bx, 1
01ed:2c23	mov	ax, word ptr [bx + 0x40a8]
01ed:2c27	mov	dx, word ptr [bx + 0x40a6]
01ed:2c2b	mov	word ptr [bp - 0xc], dx
01ed:2c2e	mov	word ptr [bp - 0xa], ax
01ed:2c31	les	bx, ptr [bp - 0x14]
01ed:2c34	mov	al, byte ptr [bp - 3]
01ed:2c37	mov	byte ptr es:[bx + 1], al
01ed:2c3b	push	es
01ed:2c3c	les	di, ptr [bp - 0xc]
01ed:2c3f	mov	ax, word ptr es:[di]
01ed:2c42	pop	es
01ed:2c43	mov	word ptr es:[bx + 8], ax
01ed:2c47	les	bx, ptr [bp - 0xc]
01ed:2c4a	mov	ax, word ptr es:[bx + 2]
01ed:2c4e	les	bx, ptr [bp - 0x14]
01ed:2c51	mov	word ptr es:[bx + 0xa], ax
01ed:2c55	call	0x17c7
01ed:2c58	call	0x1b2b
        	loc_4b2b:
01ed:2c5b	mov	al, byte ptr [bp - 2]
01ed:2c5e	mov	ah, 0
01ed:2c60	shl	ax, 1
01ed:2c62	shl	ax, 1
01ed:2c64	shl	ax, 1
01ed:2c66	les	bx, ptr [0xa0d8]
01ed:2c6a	add	bx, ax
01ed:2c6c	mov	al, byte ptr [bp - 1]
01ed:2c6f	mov	ah, 0
01ed:2c71	add	bx, ax
01ed:2c73	mov	al, byte ptr es:[bx + 0x60]
01ed:2c77	mov	ah, 0
01ed:2c79	mov	si, ax
01ed:2c7b	or	ax, ax
01ed:2c7d	je	loc_4bae
01ed:2c7f	mov	al, byte ptr [bp - 1]
01ed:2c82	mov	ah, 0
01ed:2c84	shl	ax, 1
01ed:2c86	mov	dl, byte ptr [bp - 2]
01ed:2c89	mov	dh, 0
01ed:2c8b	shl	dx, 1
01ed:2c8d	shl	dx, 1
01ed:2c8f	shl	dx, 1
01ed:2c91	shl	dx, 1
01ed:2c93	add	ax, dx
01ed:2c95	shl	ax, 1
01ed:2c97	mov	bx, ax
01ed:2c99	mov	ax, word ptr [bx + 0x274]
01ed:2c9d	les	bx, ptr [0x8884]
01ed:2ca1	mov	word ptr es:[bx], ax
01ed:2ca4	mov	al, byte ptr [bp - 1]
01ed:2ca7	mov	ah, 0
01ed:2ca9	shl	ax, 1
01ed:2cab	mov	dl, byte ptr [bp - 2]
01ed:2cae	mov	dh, 0
01ed:2cb0	shl	dx, 1
01ed:2cb2	shl	dx, 1
01ed:2cb4	shl	dx, 1
01ed:2cb6	shl	dx, 1
01ed:2cb8	add	ax, dx
01ed:2cba	shl	ax, 1
01ed:2cbc	mov	bx, ax
01ed:2cbe	mov	ax, word ptr [bx + 0x276]
01ed:2cc2	mov	bx, word ptr [0x8884]
01ed:2cc6	mov	word ptr es:[bx + 2], ax
01ed:2cca	mov	ax, si
01ed:2ccc	add	ax, 0x179
01ed:2ccf	mov	word ptr es:[bx + 4], ax
01ed:2cd3	push	ds
01ed:2cd4	mov	ax, 0x792e
01ed:2cd7	push	ax
01ed:2cd8	call	0x942a
01ed:2cdb	add	sp, 4
        	loc_4bae:
01ed:2cde	inc	byte ptr [bp - 1]
        	loc_4bb1:
01ed:2ce1	cmp	byte ptr [bp - 1], 8
01ed:2ce5	jae	loc_4bba
01ed:2ce7	jmp	loc_4a3f
        	loc_4bba:
01ed:2cea	inc	byte ptr [bp - 2]
        	loc_4bbd:
01ed:2ced	cmp	byte ptr [bp - 2], 6
01ed:2cf1	jae	loc_4bc6
01ed:2cf3	jmp	loc_4a38
        	loc_4bc6:
01ed:2cf6	les	bx, ptr [bp - 0x10]
01ed:2cf9	mov	al, 0
01ed:2cfb	mov	byte ptr es:[bx + 6], al
01ed:2cff	mov	byte ptr es:[bx], al
01ed:2d02	les	bx, ptr [bp - 0x14]
01ed:2d05	mov	al, 0
01ed:2d07	mov	byte ptr es:[bx + 6], al
01ed:2d0b	mov	byte ptr es:[bx], al
01ed:2d0e	pop	di
01ed:2d0f	pop	si
01ed:2d10	mov	sp, bp
01ed:2d12	pop	bp
01ed:2d13	ret	
sub_4948 ENDP
*/
void sub_4948()
{
    // coverage: 0x3c78-0x3f14 method sub_4948
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0014;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4959;
    sub_ca53();
loc_4959:
    memoryASet(ds, 0x4c40, 0x00);
    memoryASet(ds, 0x4c4c, 0x00);
    memoryASet(ds, 0x4c58, 0x00);
    memoryASet(ds, 0x4c80, 0x00);
    memoryASet(ds, 0x4c8c, 0x00);
    memoryASet(ds, 0x4c98, 0x00);
    memoryASet(ds, 0x4ca4, 0x00);
    ax = memoryAGet16(ds, 0x4c72);
    dx = memoryAGet16(ds, 0x4c70);
    memoryASet16(ss, bp - 16, dx);
    memoryASet16(ss, bp - 14, ax);
    ax = memoryAGet16(ds, 0x4cbe);
    dx = memoryAGet16(ds, 0x4cbc);
    memoryASet16(ss, bp - 20, dx);
    memoryASet16(ss, bp - 18, ax);
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    al = 0x01;
    memoryASet(es, bx, al);
    memoryASet(ds, 0x8e8b, al);
    bx = memoryAGet16(ss, bp - 20);
    es = memoryAGet16(ss, bp - 20 + 2);
    al = 0x01;
    memoryASet(es, bx, al);
    memoryASet(ds, 0x8e8c, al);
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    al = 0x01;
    memoryASet(es, bx + 6, al);
    memoryASet(ds, 0x8578, al);
    bx = memoryAGet16(ss, bp - 20);
    es = memoryAGet16(ss, bp - 20 + 2);
    al = 0x01;
    memoryASet(es, bx + 6, al);
    memoryASet(ds, 0x8579, al);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    al = memoryAGet(es, bx + 144);
    memoryASet(ds, 0x856e, al);
    if (memoryAGet(ds, 0x856e) == 0x00)
        goto loc_49db;
    memoryASet(ds, 0x856e, memoryAGet(ds, 0x856e) - 1);
loc_49db:
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    al = memoryAGet(es, bx + 145);
    memoryASet(ds, 0x8572, al);
    if (memoryAGet(ds, 0x8572) == 0x00)
        goto loc_49f2;
    memoryASet(ds, 0x8572, memoryAGet(ds, 0x8572) - 1);
loc_49f2:
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    al = memoryAGet(es, bx + 146);
    memoryASet(ds, 0xa0cf, al);
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 147);
    al += 0xff;
    memoryASet(ds, 0x8571, al);
    al = memoryAGet(es, bx + 149);
    memoryASet(ds, 0x7920, al);
    al = memoryAGet(es, bx + 148);
    memoryASet(ds, 0x8562, al);
    al = memoryAGet(es, bx + 150);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 9542);
    memoryASet16(ds, 0xa0de, ax);
    sub_670c();
    memoryASet(ss, bp - 2, 0x00);
    goto loc_4bbd;
loc_4a38:
    memoryASet(ss, bp - 1, 0x00);
    goto loc_4bb1;
loc_4a3f:
    al = memoryAGet(ss, bp - 2);
    al <<= 1;
    al <<= 1;
    al <<= 1;
    al += memoryAGet(ss, bp - 1);
    memoryASet(ss, bp - 3, al);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    dl = memoryAGet(ss, bp - 1);
    dh = 0x00;
    ax += dx;
    es = memoryAGet16(ds, 0xa0da);
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    al = memoryAGet(es, bx);
    ah = 0x00;
    si = ax;
    if (!ax)
        goto loc_4abb;
    al = memoryAGet(ds, si + 15674);
    ah = 0x00;
    si = ax;
    bx = si;
    bx <<= 1;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 15724);
    dx = memoryAGet16(ds, bx + 15722);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    al = memoryAGet(ss, bp - 3);
    memoryASet(es, bx + 1, al);
    push(es);
    di = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    ax = memoryAGet16(es, di);
    es = pop();
    memoryASet16(es, bx + 8, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    ax = memoryAGet16(es, bx + 2);
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    memoryASet16(es, bx + 10, ax);
    sub_352e();
    sub_3937();
loc_4abb:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(es, bx + 48);
    ah = 0x00;
    si = ax;
    if (!ax)
        goto loc_4b2b;
    if (memoryAGet(ss, bp - 1) == 0x07)
        goto loc_4b2b;
    al = memoryAGet(ds, si + 16518);
    ah = 0x00;
    si = ax;
    bx = si;
    bx <<= 1;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 16552);
    dx = memoryAGet16(ds, bx + 16550);
    memoryASet16(ss, bp - 12, dx);
    memoryASet16(ss, bp - 10, ax);
    bx = memoryAGet16(ss, bp - 20);
    es = memoryAGet16(ss, bp - 20 + 2);
    al = memoryAGet(ss, bp - 3);
    memoryASet(es, bx + 1, al);
    push(es);
    di = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    ax = memoryAGet16(es, di);
    es = pop();
    memoryASet16(es, bx + 8, ax);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    ax = memoryAGet16(es, bx + 2);
    bx = memoryAGet16(ss, bp - 20);
    es = memoryAGet16(ss, bp - 20 + 2);
    memoryASet16(es, bx + 10, ax);
    sub_3697();
    sub_39fb();
loc_4b2b:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(es, bx + 96);
    ah = 0x00;
    si = ax;
    if (!ax)
        goto loc_4bae;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    dl = memoryAGet(ss, bp - 2);
    dh = 0x00;
    dx <<= 1;
    dx <<= 1;
    dx <<= 1;
    dx <<= 1;
    ax += dx;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 628);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx, ax);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    dl = memoryAGet(ss, bp - 2);
    dh = 0x00;
    dx <<= 1;
    dx <<= 1;
    dx <<= 1;
    dx <<= 1;
    ax += dx;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 630);
    bx = memoryAGet16(ds, 0x8884);
    memoryASet16(es, bx + 2, ax);
    ax = si;
    ax += 0x0179;
    memoryASet16(es, bx + 4, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_4bae:
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_4bb1:
    if (memoryAGet(ss, bp - 1) >= 0x08)
        goto loc_4bba;
    goto loc_4a3f;
loc_4bba:
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
loc_4bbd:
    if (memoryAGet(ss, bp - 2) >= 0x06)
        goto loc_4bc6;
    goto loc_4a38;
loc_4bc6:
    bx = memoryAGet16(ss, bp - 16);
    es = memoryAGet16(ss, bp - 16 + 2);
    al = 0x00;
    memoryASet(es, bx + 6, al);
    memoryASet(es, bx, al);
    bx = memoryAGet16(ss, bp - 20);
    es = memoryAGet16(ss, bp - 20 + 2);
    al = 0x00;
    memoryASet(es, bx + 6, al);
    memoryASet(es, bx, al);
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2d14 sub_4be4()
sub_4be4 PROC
01ed:2d14	push	bp
01ed:2d15	mov	bp, sp
01ed:2d17	sub	sp, 6
01ed:2d1a	push	si
01ed:2d1b	cmp	word ptr [0x6b4c], sp
01ed:2d1f	ja	loc_4bf4
01ed:2d21	call	0xab83
        	loc_4bf4:
01ed:2d24	mov	byte ptr [bp - 5], 1
01ed:2d28	cmp	byte ptr [0x79b2], 1
01ed:2d2d	jbe	loc_4c0b
01ed:2d2f	mov	al, byte ptr [0x119a]
01ed:2d32	mov	ah, 0
01ed:2d34	or	ax, ax
01ed:2d36	jne	loc_4c0b
01ed:2d38	call	0x4015
        	loc_4c0b:
01ed:2d3b	cmp	byte ptr [0x119a], 0xff
01ed:2d40	jne	loc_4c17
01ed:2d42	mov	byte ptr [0x79b2], 1
        	loc_4c17:
01ed:2d47	mov	al, byte ptr [0x79b2]
01ed:2d4a	mov	ah, 0
01ed:2d4c	shl	ax, 1
01ed:2d4e	shl	ax, 1
01ed:2d50	mov	bx, ax
01ed:2d52	mov	ax, word ptr [bx + 0x10ca]
01ed:2d56	mov	dx, word ptr [bx + 0x10c8]
01ed:2d5a	mov	word ptr [0x8246], dx
01ed:2d5e	mov	word ptr [0x8248], ax
01ed:2d61	mov	al, byte ptr [0x79b2]
01ed:2d64	mov	ah, 0
01ed:2d66	shl	ax, 1
01ed:2d68	shl	ax, 1
01ed:2d6a	mov	bx, ax
01ed:2d6c	mov	ax, word ptr [bx + 0x10ee]
01ed:2d70	mov	dx, word ptr [bx + 0x10ec]
01ed:2d74	mov	word ptr [0x8554], dx
01ed:2d78	mov	word ptr [0x8556], ax
01ed:2d7b	mov	byte ptr [0x854e], 1
01ed:2d80	mov	ax, 0x1f
01ed:2d83	mov	word ptr [0x791e], ax
01ed:2d86	mov	word ptr [0x791c], ax
01ed:2d89	cmp	byte ptr [0x79b2], 2
01ed:2d8e	je	loc_4c67
01ed:2d90	cmp	byte ptr [0x79b2], 5
01ed:2d95	jne	loc_4c86
        	loc_4c67:
01ed:2d97	mov	word ptr [0x791c], 0x6f
01ed:2d9d	jmp	loc_4c86
        	loc_4c6f:
01ed:2d9f	mov	al, byte ptr [bp - 5]
01ed:2da2	mov	ah, 0
01ed:2da4	mov	dx, 9
01ed:2da7	imul	dx
01ed:2da9	les	bx, ptr [0x8246]
01ed:2dad	add	bx, ax
01ed:2daf	mov	byte ptr es:[bx], 0
01ed:2db3	inc	byte ptr [bp - 5]
        	loc_4c86:
01ed:2db6	mov	al, byte ptr [bp - 5]
01ed:2db9	mov	ah, 0
01ed:2dbb	mov	dx, 9
01ed:2dbe	imul	dx
01ed:2dc0	les	bx, ptr [0x8246]
01ed:2dc4	add	bx, ax
01ed:2dc6	cmp	byte ptr es:[bx], 0xff
01ed:2dca	jne	loc_4c6f
01ed:2dcc	push	ds
01ed:2dcd	mov	ax, 0x90
01ed:2dd0	push	ax
01ed:2dd1	call	0x7307
01ed:2dd4	add	sp, 4
01ed:2dd7	les	bx, ptr [0x90]
01ed:2ddb	mov	al, byte ptr [0x79b2]
01ed:2dde	add	al, 0x30
01ed:2de0	mov	byte ptr es:[bx + 1], al
01ed:2de4	les	bx, ptr [0x9a]
01ed:2de8	mov	al, byte ptr [0x79b2]
01ed:2deb	add	al, 0x30
01ed:2ded	mov	byte ptr es:[bx + 1], al
01ed:2df1	les	bx, ptr [0xe0]
01ed:2df5	mov	al, byte ptr [0x79b2]
01ed:2df8	add	al, 0x30
01ed:2dfa	mov	byte ptr es:[bx + 1], al
01ed:2dfe	mov	ax, 4
01ed:2e01	push	ax
01ed:2e02	xor	ax, ax
01ed:2e04	push	ax
01ed:2e05	call	0x736f
01ed:2e08	add	sp, 4
01ed:2e0b	mov	si, ax
01ed:2e0d	xor	ax, ax
01ed:2e0f	push	ax
01ed:2e10	push	word ptr [0x98]
01ed:2e14	push	word ptr [0x96]
01ed:2e18	push	word ptr [0x6fa8]
01ed:2e1c	push	word ptr [0x6fa6]
01ed:2e20	push	si
01ed:2e21	call	0x745e
01ed:2e24	add	sp, 0xc
01ed:2e27	mov	word ptr [bp - 4], ax
01ed:2e2a	mov	word ptr [bp - 2], dx
01ed:2e2d	push	si
01ed:2e2e	call	0x7319
01ed:2e31	inc	sp
01ed:2e32	inc	sp
01ed:2e33	push	word ptr [0x98]
01ed:2e37	push	word ptr [0x96]
01ed:2e3b	push	word ptr [bp - 2]
01ed:2e3e	push	word ptr [bp - 4]
01ed:2e41	push	word ptr [0x6fa8]
01ed:2e45	push	word ptr [0x6fa6]
01ed:2e49	call	0x7b5a
01ed:2e4c	add	sp, 0xc
01ed:2e4f	mov	ax, 4
01ed:2e52	push	ax
01ed:2e53	mov	ax, 1
01ed:2e56	push	ax
01ed:2e57	call	0x736f
01ed:2e5a	add	sp, 4
01ed:2e5d	mov	si, ax
01ed:2e5f	xor	ax, ax
01ed:2e61	push	ax
01ed:2e62	push	word ptr [0xa2]
01ed:2e66	push	word ptr [0xa0]
01ed:2e6a	push	word ptr [0x6bea]
01ed:2e6e	push	word ptr [0x6be8]
01ed:2e72	push	si
01ed:2e73	call	0x745e
01ed:2e76	add	sp, 0xc
01ed:2e79	mov	word ptr [bp - 4], ax
01ed:2e7c	mov	word ptr [bp - 2], dx
01ed:2e7f	push	si
01ed:2e80	call	0x7319
01ed:2e83	inc	sp
01ed:2e84	inc	sp
01ed:2e85	push	word ptr [0xa2]
01ed:2e89	push	word ptr [0xa0]
01ed:2e8d	push	word ptr [bp - 2]
01ed:2e90	push	word ptr [bp - 4]
01ed:2e93	push	word ptr [0x6bea]
01ed:2e97	push	word ptr [0x6be8]
01ed:2e9b	call	0x7b5a
01ed:2e9e	add	sp, 0xc
01ed:2ea1	mov	ax, 4
01ed:2ea4	push	ax
01ed:2ea5	mov	ax, 8
01ed:2ea8	push	ax
01ed:2ea9	call	0x736f
01ed:2eac	add	sp, 4
01ed:2eaf	mov	si, ax
01ed:2eb1	xor	ax, ax
01ed:2eb3	push	ax
01ed:2eb4	push	word ptr [0xe8]
01ed:2eb8	push	word ptr [0xe6]
01ed:2ebc	push	word ptr [0x75e0]
01ed:2ec0	push	word ptr [0x75de]
01ed:2ec4	push	si
01ed:2ec5	call	0x745e
01ed:2ec8	add	sp, 0xc
01ed:2ecb	mov	word ptr [bp - 4], ax
01ed:2ece	mov	word ptr [bp - 2], dx
01ed:2ed1	push	si
01ed:2ed2	call	0x7319
01ed:2ed5	inc	sp
01ed:2ed6	inc	sp
01ed:2ed7	push	word ptr [0xe8]
01ed:2edb	push	word ptr [0xe6]
01ed:2edf	push	word ptr [bp - 2]
01ed:2ee2	push	word ptr [bp - 4]
01ed:2ee5	push	word ptr [0x75e0]
01ed:2ee9	push	word ptr [0x75de]
01ed:2eed	call	0x7b5a
01ed:2ef0	add	sp, 0xc
01ed:2ef3	pop	si
01ed:2ef4	mov	sp, bp
01ed:2ef6	pop	bp
01ed:2ef7	ret	
sub_4be4 ENDP
*/
void sub_4be4()
{
    // coverage: 0x3f14-0x40f8 method sub_4be4
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4bf4;
    sub_ca53();
loc_4bf4:
    memoryASet(ss, bp - 5, 0x01);
    if (memoryAGet(ds, 0x79b2) <= 0x01)
        goto loc_4c0b;
    al = memoryAGet(ds, 0x119a);
    ah = 0x00;
    if (ax)
        goto loc_4c0b;
    sub_5ee5();
loc_4c0b:
    if (memoryAGet(ds, 0x119a) != 0xff)
        goto loc_4c17;
    memoryASet(ds, 0x79b2, 0x01);
loc_4c17:
    al = memoryAGet(ds, 0x79b2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 4298);
    dx = memoryAGet16(ds, bx + 4296);
    memoryASet16(ds, 0x8246, dx);
    memoryASet16(ds, 0x8248, ax);
    al = memoryAGet(ds, 0x79b2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 4334);
    dx = memoryAGet16(ds, bx + 4332);
    memoryASet16(ds, 0x8554, dx);
    memoryASet16(ds, 0x8556, ax);
    memoryASet(ds, 0x854e, 0x01);
    ax = 0x001f;
    memoryASet16(ds, 0x791e, ax);
    memoryASet16(ds, 0x791c, ax);
    if (memoryAGet(ds, 0x79b2) == 0x02)
        goto loc_4c67;
    if (memoryAGet(ds, 0x79b2) != 0x05)
        goto loc_4c86;
loc_4c67:
    memoryASet16(ds, 0x791c, 0x006f);
    goto loc_4c86;
loc_4c6f:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    bx = memoryAGet16(ds, 0x8246);
    es = memoryAGet16(ds, 0x8246 + 2);
    bx += ax;
    memoryASet(es, bx, 0x00);
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) + 1);
loc_4c86:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    bx = memoryAGet16(ds, 0x8246);
    es = memoryAGet16(ds, 0x8246 + 2);
    bx += ax;
    if (memoryAGet(es, bx) != 0xff)
        goto loc_4c6f;
    push(ds);
    ax = 0x0090;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0090);
    es = memoryAGet16(ds, 0x0090 + 2);
    al = memoryAGet(ds, 0x79b2);
    al += 0x30;
    memoryASet(es, bx + 1, al);
    bx = memoryAGet16(ds, 0x009a);
    es = memoryAGet16(ds, 0x009a + 2);
    al = memoryAGet(ds, 0x79b2);
    al += 0x30;
    memoryASet(es, bx + 1, al);
    bx = memoryAGet16(ds, 0x00e0);
    es = memoryAGet16(ds, 0x00e0 + 2);
    al = memoryAGet(ds, 0x79b2);
    al += 0x30;
    memoryASet(es, bx + 1, al);
    ax = 0x0004;
    push(ax);
    ax = 0;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x0098));
    push(memoryAGet16(ds, 0x0096));
    push(memoryAGet16(ds, 0x6fa8));
    push(memoryAGet16(ds, 0x6fa6));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    push(memoryAGet16(ds, 0x0098));
    push(memoryAGet16(ds, 0x0096));
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x6fa8));
    push(memoryAGet16(ds, 0x6fa6));
    sub_9a2a();
    sp += 0x000c;
    ax = 0x0004;
    push(ax);
    ax = 0x0001;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x00a2));
    push(memoryAGet16(ds, 0x00a0));
    push(memoryAGet16(ds, 0x6bea));
    push(memoryAGet16(ds, 0x6be8));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    push(memoryAGet16(ds, 0x00a2));
    push(memoryAGet16(ds, 0x00a0));
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x6bea));
    push(memoryAGet16(ds, 0x6be8));
    sub_9a2a();
    sp += 0x000c;
    ax = 0x0004;
    push(ax);
    ax = 0x0008;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x00e8));
    push(memoryAGet16(ds, 0x00e6));
    push(memoryAGet16(ds, 0x75e0));
    push(memoryAGet16(ds, 0x75de));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    push(memoryAGet16(ds, 0x00e8));
    push(memoryAGet16(ds, 0x00e6));
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x75e0));
    push(memoryAGet16(ds, 0x75de));
    sub_9a2a();
    sp += 0x000c;
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2ef8 sub_4dc8()
sub_4dc8 PROC
01ed:2ef8	push	bp
01ed:2ef9	mov	bp, sp
01ed:2efb	sub	sp, 4
01ed:2efe	push	si
01ed:2eff	cmp	word ptr [0x6b4c], sp
01ed:2f03	ja	loc_4dd8
01ed:2f05	call	0xab83
        	loc_4dd8:
01ed:2f08	push	ds
01ed:2f09	mov	ax, 0x928
01ed:2f0c	push	ax
01ed:2f0d	call	0x7307
01ed:2f10	add	sp, 4
01ed:2f13	call	0x2fac
01ed:2f16	mov	ax, 4
01ed:2f19	push	ax
01ed:2f1a	xor	ax, ax
01ed:2f1c	push	ax
01ed:2f1d	call	0x736f
01ed:2f20	add	sp, 4
01ed:2f23	mov	si, ax
01ed:2f25	xor	ax, ax
01ed:2f27	push	ax
01ed:2f28	push	word ptr [0x930]
01ed:2f2c	push	word ptr [0x92e]
01ed:2f30	push	word ptr [0xa0c8]
01ed:2f34	push	word ptr [0xa0c6]
01ed:2f38	push	si
01ed:2f39	call	0x745e
01ed:2f3c	add	sp, 0xc
01ed:2f3f	push	si
01ed:2f40	call	0x7319
01ed:2f43	inc	sp
01ed:2f44	inc	sp
01ed:2f45	push	word ptr [0xa0c8]
01ed:2f49	push	word ptr [0xa0c6]
01ed:2f4d	call	0x93d8
01ed:2f50	add	sp, 4
01ed:2f53	mov	ax, 4
01ed:2f56	push	ax
01ed:2f57	mov	ax, 1
01ed:2f5a	push	ax
01ed:2f5b	call	0x736f
01ed:2f5e	add	sp, 4
01ed:2f61	mov	si, ax
01ed:2f63	xor	ax, ax
01ed:2f65	push	ax
01ed:2f66	push	word ptr [0x93a]
01ed:2f6a	push	word ptr [0x938]
01ed:2f6e	push	word ptr [0x7928]
01ed:2f72	push	word ptr [0x7926]
01ed:2f76	push	si
01ed:2f77	call	0x745e
01ed:2f7a	add	sp, 0xc
01ed:2f7d	mov	word ptr [bp - 4], ax
01ed:2f80	mov	word ptr [bp - 2], dx
01ed:2f83	push	si
01ed:2f84	call	0x7319
01ed:2f87	inc	sp
01ed:2f88	inc	sp
01ed:2f89	xor	ax, ax
01ed:2f8b	mov	dx, 0x7d63
01ed:2f8e	push	ax
01ed:2f8f	push	dx
01ed:2f90	push	word ptr [bp - 2]
01ed:2f93	push	word ptr [bp - 4]
01ed:2f96	push	word ptr [0x7928]
01ed:2f9a	push	word ptr [0x7926]
01ed:2f9e	call	0x7b5a
01ed:2fa1	add	sp, 0xc
01ed:2fa4	call	0x51d8
01ed:2fa7	pop	si
01ed:2fa8	mov	sp, bp
01ed:2faa	pop	bp
01ed:2fab	ret	
sub_4dc8 ENDP
*/
void sub_4dc8()
{
    // coverage: 0x40f8-0x41ac method sub_4dc8
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4dd8;
    sub_ca53();
loc_4dd8:
    push(ds);
    ax = 0x0928;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    sub_4e7c();
    ax = 0x0004;
    push(ax);
    ax = 0;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x0930));
    push(memoryAGet16(ds, 0x092e));
    push(memoryAGet16(ds, 0xa0c8));
    push(memoryAGet16(ds, 0xa0c6));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    push(memoryAGet16(ds, 0xa0c8));
    push(memoryAGet16(ds, 0xa0c6));
    sub_b2a8();
    sp += 0x0004;
    ax = 0x0004;
    push(ax);
    ax = 0x0001;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x093a));
    push(memoryAGet16(ds, 0x0938));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a2a();
    sp += 0x000c;
    sub_70a8();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:2fac sub_4e7c()
sub_4e7c PROC
01ed:2fac	push	bp
01ed:2fad	mov	bp, sp
01ed:2faf	sub	sp, 6
01ed:2fb2	push	si
01ed:2fb3	push	di
01ed:2fb4	cmp	word ptr [0x6b4c], sp
01ed:2fb8	ja	loc_4e8d
01ed:2fba	call	0xab83
        	loc_4e8d:
01ed:2fbd	mov	ax, 4
01ed:2fc0	push	ax
01ed:2fc1	mov	ax, 2
01ed:2fc4	push	ax
01ed:2fc5	call	0x736f
01ed:2fc8	add	sp, 4
01ed:2fcb	mov	si, ax
01ed:2fcd	xor	ax, ax
01ed:2fcf	push	ax
01ed:2fd0	push	word ptr [0x944]
01ed:2fd4	push	word ptr [0x942]
01ed:2fd8	push	word ptr [0x7928]
01ed:2fdc	push	word ptr [0x7926]
01ed:2fe0	push	si
01ed:2fe1	call	0x745e
01ed:2fe4	add	sp, 0xc
01ed:2fe7	mov	word ptr [bp - 4], ax
01ed:2fea	mov	word ptr [bp - 2], dx
01ed:2fed	push	si
01ed:2fee	call	0x7319
01ed:2ff1	inc	sp
01ed:2ff2	inc	sp
01ed:2ff3	xor	ax, ax
01ed:2ff5	mov	dx, 0x7d63
01ed:2ff8	push	ax
01ed:2ff9	push	dx
01ed:2ffa	push	word ptr [bp - 2]
01ed:2ffd	push	word ptr [bp - 4]
01ed:3000	push	word ptr [0x7928]
01ed:3004	push	word ptr [0x7926]
01ed:3008	call	0x7b5a
01ed:300b	add	sp, 0xc
01ed:300e	cmp	word ptr [0x541d], 1
01ed:3013	jne	loc_4f1c
01ed:3015	mov	ax, word ptr [0x7928]
01ed:3018	mov	dx, word ptr [0x7926]
01ed:301c	mov	word ptr [0x9b96], dx
01ed:3020	mov	word ptr [0x9b98], ax
01ed:3023	mov	byte ptr [bp - 5], 0
01ed:3027	jmp	loc_4f16
        	loc_4ef9:
01ed:3029	mov	al, byte ptr [bp - 5]
01ed:302c	mov	ah, 0
01ed:302e	les	bx, ptr [0x9b96]
01ed:3032	add	bx, ax
01ed:3034	mov	al, byte ptr [bp - 5]
01ed:3037	mov	ah, 0
01ed:3039	mov	di, ax
01ed:303b	mov	al, byte ptr [di + 0x63a]
01ed:303f	mov	byte ptr es:[bx + 0x23], al
01ed:3043	inc	byte ptr [bp - 5]
        	loc_4f16:
01ed:3046	cmp	byte ptr [bp - 5], 0x10
01ed:304a	jb	loc_4ef9
        	loc_4f1c:
01ed:304c	call	0x3467
01ed:304f	mov	ax, word ptr [0x7928]
01ed:3052	mov	dx, word ptr [0x7926]
01ed:3056	add	dx, 0x63
01ed:3059	les	bx, ptr [0x574]
01ed:305d	mov	word ptr es:[bx + 2], dx
01ed:3061	mov	word ptr es:[bx + 4], ax
01ed:3065	mov	word ptr es:[bx + 6], 0
01ed:306b	mov	word ptr es:[bx + 8], 0
01ed:3071	mov	word ptr es:[bx + 0xa], 0x14
01ed:3077	mov	word ptr es:[bx + 0xc], 0x19
01ed:307d	mov	word ptr es:[bx + 0xe], 1
01ed:3083	mov	word ptr es:[bx + 0x14], 0
01ed:3089	mov	word ptr es:[bx + 0x16], 0
01ed:308f	mov	word ptr es:[bx + 0x1c], 0
01ed:3095	mov	word ptr es:[bx + 0x1e], 0x14
01ed:309b	mov	word ptr es:[bx + 0x20], 0x19
01ed:30a1	push	word ptr [0x576]
01ed:30a5	push	word ptr [0x574]
01ed:30a9	call	0x80bc
01ed:30ac	add	sp, 4
01ed:30af	xor	ax, ax
01ed:30b1	push	ax
01ed:30b2	push	word ptr [0x7928]
01ed:30b6	push	word ptr [0x7926]
01ed:30ba	call	0x7b93
01ed:30bd	add	sp, 6
01ed:30c0	xor	ax, ax
01ed:30c2	push	ax
01ed:30c3	call	0x7bca
01ed:30c6	inc	sp
01ed:30c7	inc	sp
01ed:30c8	mov	ax, 1
01ed:30cb	push	ax
01ed:30cc	call	0x7bdd
01ed:30cf	inc	sp
01ed:30d0	inc	sp
01ed:30d1	call	0x9864
01ed:30d4	call	0x30dd
01ed:30d7	pop	di
01ed:30d8	pop	si
01ed:30d9	mov	sp, bp
01ed:30db	pop	bp
01ed:30dc	ret	
sub_4e7c ENDP
*/
void sub_4e7c()
{
    // coverage: 0x41ac-0x42dd method sub_4e7c
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4e8d;
    sub_ca53();
loc_4e8d:
    ax = 0x0004;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x0944));
    push(memoryAGet16(ds, 0x0942));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a2a();
    sp += 0x000c;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_4f1c;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 5, 0x00);
    goto loc_4f16;
loc_4ef9:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1594);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) + 1);
loc_4f16:
    if (memoryAGet(ss, bp - 5) < 0x10)
        goto loc_4ef9;
loc_4f1c:
    sub_5337();
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    dx += 0x0063;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_b734();
    sub_4fad();
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:30dd sub_4fad()
sub_4fad PROC
01ed:30dd	push	bp
01ed:30de	mov	bp, sp
01ed:30e0	dec	sp
01ed:30e1	dec	sp
01ed:30e2	push	si
01ed:30e3	cmp	word ptr [0x6b4c], sp
01ed:30e7	ja	loc_4fbc
01ed:30e9	call	0xab83
        	loc_4fbc:
01ed:30ec	mov	byte ptr [bp - 1], 0
01ed:30f0	mov	ax, 4
01ed:30f3	push	ax
01ed:30f4	push	ax
01ed:30f5	call	0x736f
01ed:30f8	add	sp, 4
01ed:30fb	mov	si, ax
01ed:30fd	xor	ax, ax
01ed:30ff	push	ax
01ed:3100	push	word ptr [0x958]
01ed:3104	push	word ptr [0x956]
01ed:3108	push	word ptr [0x7928]
01ed:310c	push	word ptr [0x7926]
01ed:3110	push	si
01ed:3111	call	0x745e
01ed:3114	add	sp, 0xc
01ed:3117	push	si
01ed:3118	call	0x7319
01ed:311b	inc	sp
01ed:311c	inc	sp
01ed:311d	mov	ax, 4
01ed:3120	push	ax
01ed:3121	mov	ax, 5
01ed:3124	push	ax
01ed:3125	call	0x736f
01ed:3128	add	sp, 4
01ed:312b	mov	si, ax
01ed:312d	xor	ax, ax
01ed:312f	push	ax
01ed:3130	push	word ptr [0x962]
01ed:3134	push	word ptr [0x960]
01ed:3138	push	word ptr [0xa0c8]
01ed:313c	push	word ptr [0xa0c6]
01ed:3140	push	si
01ed:3141	call	0x745e
01ed:3144	add	sp, 0xc
01ed:3147	push	si
01ed:3148	call	0x7319
01ed:314b	inc	sp
01ed:314c	inc	sp
01ed:314d	cmp	word ptr [0x689c], 0x8000
01ed:3153	je	loc_508d
01ed:3155	jmp	loc_506c
        	loc_5027:
01ed:3157	mov	ax, 1
01ed:315a	push	ax
01ed:315b	push	word ptr [0x7928]
01ed:315f	push	word ptr [0x7926]
01ed:3163	push	word ptr [0xa0c8]
01ed:3167	push	word ptr [0xa0c6]
01ed:316b	call	0x8977
01ed:316e	add	sp, 0xa
01ed:3171	jmp	loc_505c
        	loc_5043:
01ed:3173	mov	ax, word ptr [0x119c]
01ed:3176	add	ax, 7
01ed:3179	mov	word ptr [0x119c], ax
01ed:317c	mov	al, 0
01ed:317e	push	ax
01ed:317f	call	0x75a2
01ed:3182	inc	sp
01ed:3183	inc	sp
01ed:3184	test	al, 0x10
01ed:3186	je	loc_505c
01ed:3188	mov	byte ptr [bp - 1], 1
        	loc_505c:
01ed:318c	call	0x8999
01ed:318f	or	ax, ax
01ed:3191	je	loc_506c
01ed:3193	mov	al, byte ptr [bp - 1]
01ed:3196	mov	ah, 0
01ed:3198	or	ax, ax
01ed:319a	je	loc_5043
        	loc_506c:
01ed:319c	mov	al, byte ptr [bp - 1]
01ed:319f	mov	ah, 0
01ed:31a1	or	ax, ax
01ed:31a3	je	loc_5027
01ed:31a5	call	0x89a8
01ed:31a8	cmp	word ptr [0x689c], 0
01ed:31ad	jne	loc_50a9
01ed:31af	mov	ax, 1
01ed:31b2	push	ax
01ed:31b3	call	0x7e18
01ed:31b6	inc	sp
01ed:31b7	inc	sp
01ed:31b8	call	0x946e
01ed:31bb	jmp	loc_50a9
        	loc_508d:
01ed:31bd	mov	byte ptr [0x8244], 0
01ed:31c2	jmp	loc_50a0
        	loc_5094:
01ed:31c4	call	0x1dde
01ed:31c7	mov	ax, word ptr [0x119c]
01ed:31ca	add	ax, 7
01ed:31cd	mov	word ptr [0x119c], ax
        	loc_50a0:
01ed:31d0	mov	al, byte ptr [0x8244]
01ed:31d3	mov	ah, 0
01ed:31d5	or	ax, ax
01ed:31d7	je	loc_5094
        	loc_50a9:
01ed:31d9	pop	si
01ed:31da	mov	sp, bp
01ed:31dc	pop	bp
01ed:31dd	ret	
sub_4fad ENDP
*/
void sub_4fad()
{
    // coverage: 0x42dd-0x43de method sub_4fad
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_4fbc;
    sub_ca53();
loc_4fbc:
    memoryASet(ss, bp - 1, 0x00);
    ax = 0x0004;
    push(ax);
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x0958));
    push(memoryAGet16(ds, 0x0956));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0x0004;
    push(ax);
    ax = 0x0005;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x0962));
    push(memoryAGet16(ds, 0x0960));
    push(memoryAGet16(ds, 0xa0c8));
    push(memoryAGet16(ds, 0xa0c6));
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x689c) == 0x8000)
        goto loc_508d;
    goto loc_506c;
loc_5027:
    ax = 0x0001;
    push(ax);
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(memoryAGet16(ds, 0xa0c8));
    push(memoryAGet16(ds, 0xa0c6));
    sub_a847();
    sp += 0x000a;
    goto loc_505c;
loc_5043:
    ax = memoryAGet16(ds, 0x119c);
    ax += 0x0007;
    memoryASet16(ds, 0x119c, ax);
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    if (!(al & 0x10))
        goto loc_505c;
    memoryASet(ss, bp - 1, 0x01);
loc_505c:
    sub_a869();
    if (!ax)
        goto loc_506c;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (!ax)
        goto loc_5043;
loc_506c:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (!ax)
        goto loc_5027;
    sub_a878();
    if (memoryAGet16(ds, 0x689c) != 0x0000)
        goto loc_50a9;
    ax = 0x0001;
    push(ax);
    sub_9ce8();
    sp++;
    sp++;
    sub_b33e();
    goto loc_50a9;
loc_508d:
    memoryASet(ds, 0x8244, 0x00);
    goto loc_50a0;
loc_5094:
    sub_3cae();
    ax = memoryAGet16(ds, 0x119c);
    ax += 0x0007;
    memoryASet16(ds, 0x119c, ax);
loc_50a0:
    al = memoryAGet(ds, 0x8244);
    ah = 0x00;
    if (!ax)
        goto loc_5094;
loc_50a9:
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:31de sub_50ae()
sub_50ae PROC
01ed:31de	push	bp
01ed:31df	mov	bp, sp
01ed:31e1	cmp	word ptr [0x6b4c], sp
01ed:31e5	ja	loc_50ba
01ed:31e7	call	0xab83
        	loc_50ba:
01ed:31ea	mov	byte ptr [0x8242], 0
01ed:31ef	mov	byte ptr [0x792a], 0
01ed:31f4	mov	word ptr [0x824a], 0
01ed:31fa	mov	byte ptr [0xa0ce], 0
01ed:31ff	mov	al, 0
01ed:3201	mov	byte ptr [0x8578], al
01ed:3204	mov	byte ptr [0x8e8b], al
01ed:3207	mov	al, 0
01ed:3209	mov	byte ptr [0x8579], al
01ed:320c	mov	byte ptr [0x8e8c], al
01ed:320f	mov	byte ptr [0x8244], 0
01ed:3214	mov	byte ptr [0xa1a7], 0
01ed:3219	mov	byte ptr [0x79b4], 0
01ed:321e	mov	byte ptr [0x7923], 0
01ed:3223	mov	byte ptr [0x824c], 0
01ed:3228	mov	byte ptr [0xa1a8], 0
01ed:322d	mov	byte ptr [0xa1b1], 0
01ed:3232	mov	byte ptr [0x8550], 0
01ed:3237	mov	byte ptr [0x8563], 0
01ed:323c	mov	byte ptr [0xa1b0], 0
01ed:3241	mov	byte ptr [0x8243], 0
01ed:3246	mov	byte ptr [0x79b7], 0
01ed:324b	mov	word ptr [0x9ba6], 0x886
01ed:3251	mov	word ptr [0x9ba8], ds
01ed:3255	les	bx, ptr [0x9ba6]
01ed:3259	mov	byte ptr es:[bx], 0xff
01ed:325d	call	0x4906
01ed:3260	call	0x48a9
01ed:3263	mov	ax, word ptr [0x9292]
01ed:3266	add	ax, 0xfff4
01ed:3269	mov	word ptr [0x9292], ax
01ed:326c	mov	byte ptr [0x792c], 0
01ed:3271	mov	word ptr [0xa1ac], 0x1394
01ed:3277	mov	word ptr [0xa1ae], ds
01ed:327b	mov	byte ptr [0x824d], 0xa
01ed:3280	mov	al, 4
01ed:3282	mov	byte ptr [0x9bae], al
01ed:3285	mov	byte ptr [0x792a], al
01ed:3288	mov	byte ptr [0xa1a9], 0
01ed:328d	pop	bp
01ed:328e	ret	
sub_50ae ENDP
*/
void sub_50ae()
{
    // coverage: 0x43de-0x448f method sub_50ae
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_50ba;
    sub_ca53();
loc_50ba:
    memoryASet(ds, 0x8242, 0x00);
    memoryASet(ds, 0x792a, 0x00);
    memoryASet16(ds, 0x824a, 0x0000);
    memoryASet(ds, 0xa0ce, 0x00);
    al = 0x00;
    memoryASet(ds, 0x8578, al);
    memoryASet(ds, 0x8e8b, al);
    al = 0x00;
    memoryASet(ds, 0x8579, al);
    memoryASet(ds, 0x8e8c, al);
    memoryASet(ds, 0x8244, 0x00);
    memoryASet(ds, 0xa1a7, 0x00);
    memoryASet(ds, 0x79b4, 0x00);
    memoryASet(ds, 0x7923, 0x00);
    memoryASet(ds, 0x824c, 0x00);
    memoryASet(ds, 0xa1a8, 0x00);
    memoryASet(ds, 0xa1b1, 0x00);
    memoryASet(ds, 0x8550, 0x00);
    memoryASet(ds, 0x8563, 0x00);
    memoryASet(ds, 0xa1b0, 0x00);
    memoryASet(ds, 0x8243, 0x00);
    memoryASet(ds, 0x79b7, 0x00);
    memoryASet16(ds, 0x9ba6, 0x0886);
    memoryASet16(ds, 0x9ba8, ds);
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    memoryASet(es, bx, 0xff);
    sub_67d6();
    sub_6779();
    ax = memoryAGet16(ds, 0x9292);
    ax += 0xfff4;
    memoryASet16(ds, 0x9292, ax);
    memoryASet(ds, 0x792c, 0x00);
    memoryASet16(ds, 0xa1ac, 0x1394);
    memoryASet16(ds, 0xa1ae, ds);
    memoryASet(ds, 0x824d, 0x0a);
    al = 0x04;
    memoryASet(ds, 0x9bae, al);
    memoryASet(ds, 0x792a, al);
    memoryASet(ds, 0xa1a9, 0x00);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:328f sub_515f()
sub_515f PROC
01ed:328f	push	bp
01ed:3290	mov	bp, sp
01ed:3292	cmp	word ptr [0x6b4c], sp
01ed:3296	ja	loc_516b
01ed:3298	call	0xab83
        	loc_516b:
01ed:329b	mov	byte ptr [0x8244], 0
01ed:32a0	jmp	loc_5175
        	loc_5172:
01ed:32a2	call	0x1dde
        	loc_5175:
01ed:32a5	mov	al, byte ptr [0x8244]
01ed:32a8	mov	ah, 0
01ed:32aa	or	ax, ax
01ed:32ac	je	loc_5172
01ed:32ae	pop	bp
01ed:32af	ret	
sub_515f ENDP
*/
void sub_515f()
{
    // coverage: 0x448f-0x44b0 method sub_515f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_516b;
    sub_ca53();
loc_516b:
    memoryASet(ds, 0x8244, 0x00);
    goto loc_5175;
loc_5172:
    sub_3cae();
loc_5175:
    al = memoryAGet(ds, 0x8244);
    ah = 0x00;
    if (!ax)
        goto loc_5172;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:32b0 sub_5180()
sub_5180 PROC
01ed:32b0	push	bp
01ed:32b1	mov	bp, sp
01ed:32b3	cmp	word ptr [0x6b4c], sp
01ed:32b7	ja	loc_518c
01ed:32b9	call	0xab83
        	loc_518c:
01ed:32bc	mov	ax, word ptr [0x7310]
01ed:32bf	mov	dx, 0xc2
01ed:32c2	imul	dx
01ed:32c4	mov	dx, word ptr [0x6bf4]
01ed:32c8	mov	bx, word ptr [0x6bf2]
01ed:32cc	add	bx, ax
01ed:32ce	mov	word ptr [0x75d0], bx
01ed:32d2	mov	word ptr [0x75d2], dx
01ed:32d6	mov	ax, word ptr [0x7310]
01ed:32d9	mov	dx, 0x32c
01ed:32dc	imul	dx
01ed:32de	mov	dx, word ptr [0x6bd4]
01ed:32e2	mov	bx, word ptr [0x6bd2]
01ed:32e6	add	bx, ax
01ed:32e8	mov	word ptr [0x6bca], bx
01ed:32ec	mov	word ptr [0x6bcc], dx
01ed:32f0	mov	word ptr [0xa0d8], 0xa0e4
01ed:32f6	mov	word ptr [0xa0da], ds
01ed:32fa	mov	cl, 0
01ed:32fc	jmp	loc_5222
        	loc_51ce:
01ed:32fe	mov	al, cl
01ed:3300	mov	ah, 0
01ed:3302	les	bx, ptr [0x75d0]
01ed:3306	add	bx, ax
01ed:3308	mov	al, byte ptr es:[bx]
01ed:330b	mov	dl, cl
01ed:330d	mov	dh, 0
01ed:330f	les	bx, ptr [0xa0d8]
01ed:3313	add	bx, dx
01ed:3315	mov	byte ptr es:[bx], al
01ed:3318	mov	al, cl
01ed:331a	mov	ah, 0
01ed:331c	les	bx, ptr [0x75d0]
01ed:3320	add	bx, ax
01ed:3322	mov	al, byte ptr es:[bx + 0x30]
01ed:3326	mov	dl, cl
01ed:3328	mov	dh, 0
01ed:332a	les	bx, ptr [0xa0d8]
01ed:332e	add	bx, dx
01ed:3330	mov	byte ptr es:[bx + 0x30], al
01ed:3334	mov	al, cl
01ed:3336	mov	ah, 0
01ed:3338	les	bx, ptr [0x75d0]
01ed:333c	add	bx, ax
01ed:333e	mov	al, byte ptr es:[bx + 0x60]
01ed:3342	mov	dl, cl
01ed:3344	mov	dh, 0
01ed:3346	les	bx, ptr [0xa0d8]
01ed:334a	add	bx, dx
01ed:334c	mov	byte ptr es:[bx + 0x60], al
01ed:3350	inc	cl
        	loc_5222:
01ed:3352	cmp	cl, 0x30
01ed:3355	jb	loc_51ce
01ed:3357	les	bx, ptr [0x75d0]
01ed:335b	mov	al, byte ptr es:[bx + 0x90]
01ed:3360	les	bx, ptr [0xa0d8]
01ed:3364	mov	byte ptr es:[bx + 0x90], al
01ed:3369	les	bx, ptr [0x75d0]
01ed:336d	mov	al, byte ptr es:[bx + 0x91]
01ed:3372	les	bx, ptr [0xa0d8]
01ed:3376	mov	byte ptr es:[bx + 0x91], al
01ed:337b	les	bx, ptr [0x75d0]
01ed:337f	mov	al, byte ptr es:[bx + 0x92]
01ed:3384	les	bx, ptr [0xa0d8]
01ed:3388	mov	byte ptr es:[bx + 0x92], al
01ed:338d	les	bx, ptr [0x75d0]
01ed:3391	mov	al, byte ptr es:[bx + 0x93]
01ed:3396	les	bx, ptr [0xa0d8]
01ed:339a	mov	byte ptr es:[bx + 0x93], al
01ed:339f	les	bx, ptr [0x75d0]
01ed:33a3	mov	al, byte ptr es:[bx + 0x94]
01ed:33a8	les	bx, ptr [0xa0d8]
01ed:33ac	mov	byte ptr es:[bx + 0x94], al
01ed:33b1	les	bx, ptr [0x75d0]
01ed:33b5	mov	al, byte ptr es:[bx + 0x95]
01ed:33ba	les	bx, ptr [0xa0d8]
01ed:33be	mov	byte ptr es:[bx + 0x95], al
01ed:33c3	pop	bp
01ed:33c4	ret	
sub_5180 ENDP
*/
void sub_5180()
{
    // coverage: 0x44b0-0x45c5 method sub_5180
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_518c;
    sub_ca53();
loc_518c:
    ax = memoryAGet16(ds, 0x7310);
    dx = 0x00c2;
    imul(dx);
    dx = memoryAGet16(ds, 0x6bf4);
    bx = memoryAGet16(ds, 0x6bf2);
    bx += ax;
    memoryASet16(ds, 0x75d0, bx);
    memoryASet16(ds, 0x75d2, dx);
    ax = memoryAGet16(ds, 0x7310);
    dx = 0x032c;
    imul(dx);
    dx = memoryAGet16(ds, 0x6bd4);
    bx = memoryAGet16(ds, 0x6bd2);
    bx += ax;
    memoryASet16(ds, 0x6bca, bx);
    memoryASet16(ds, 0x6bcc, dx);
    memoryASet16(ds, 0xa0d8, 0xa0e4);
    memoryASet16(ds, 0xa0da, ds);
    cl = 0x00;
    goto loc_5222;
loc_51ce:
    al = cl;
    ah = 0x00;
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    dl = cl;
    dh = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += dx;
    memoryASet(es, bx, al);
    al = cl;
    ah = 0x00;
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 48);
    dl = cl;
    dh = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += dx;
    memoryASet(es, bx + 48, al);
    al = cl;
    ah = 0x00;
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 96);
    dl = cl;
    dh = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += dx;
    memoryASet(es, bx + 96, al);
    cl++;
loc_5222:
    if (cl < 0x30)
        goto loc_51ce;
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 144);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    memoryASet(es, bx + 144, al);
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 145);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    memoryASet(es, bx + 145, al);
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 146);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    memoryASet(es, bx + 146, al);
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 147);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    memoryASet(es, bx + 147, al);
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 148);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    memoryASet(es, bx + 148, al);
    bx = memoryAGet16(ds, 0x75d0);
    es = memoryAGet16(ds, 0x75d0 + 2);
    al = memoryAGet(es, bx + 149);
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    memoryASet(es, bx + 149, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:33c5 sub_5295()
sub_5295 PROC
01ed:33c5	push	bp
01ed:33c6	mov	bp, sp
01ed:33c8	cmp	word ptr [0x6b4c], sp
01ed:33cc	ja	loc_52a1
01ed:33ce	call	0xab83
        	loc_52a1:
01ed:33d1	mov	word ptr [0x8884], 0x792e
01ed:33d7	mov	word ptr [0x8886], ds
01ed:33db	les	bx, ptr [0x8884]
01ed:33df	mov	ax, word ptr [0xa0c8]
01ed:33e2	mov	dx, word ptr [0xa0c6]
01ed:33e6	mov	word ptr es:[bx + 6], dx
01ed:33ea	mov	word ptr es:[bx + 8], ax
01ed:33ee	or	byte ptr es:[bx + 0xa], 0x80
01ed:33f3	and	byte ptr es:[bx + 0xa], 0xbf
01ed:33f8	and	byte ptr es:[bx + 0xa], 0xdf
01ed:33fd	and	byte ptr es:[bx + 0xa], 0xef
01ed:3402	and	byte ptr es:[bx + 0xa], 0xf7
01ed:3407	mov	word ptr [0x9b9e], 0x795a
01ed:340d	mov	word ptr [0x9ba0], ds
01ed:3411	les	bx, ptr [0x9b9e]
01ed:3415	mov	word ptr es:[bx + 6], dx
01ed:3419	mov	word ptr es:[bx + 8], ax
01ed:341d	or	byte ptr es:[bx + 0xa], 0x80
01ed:3422	and	byte ptr es:[bx + 0xa], 0xbf
01ed:3427	and	byte ptr es:[bx + 0xa], 0xdf
01ed:342c	and	byte ptr es:[bx + 0xa], 0xef
01ed:3431	and	byte ptr es:[bx + 0xa], 0xf7
01ed:3436	mov	word ptr [0xa0d0], 0x7986
01ed:343c	mov	word ptr [0xa0d2], ds
01ed:3440	les	bx, ptr [0xa0d0]
01ed:3444	mov	word ptr es:[bx + 6], dx
01ed:3448	mov	word ptr es:[bx + 8], ax
01ed:344c	or	byte ptr es:[bx + 0xa], 0x80
01ed:3451	and	byte ptr es:[bx + 0xa], 0xbf
01ed:3456	and	byte ptr es:[bx + 0xa], 0xdf
01ed:345b	and	byte ptr es:[bx + 0xa], 0xef
01ed:3460	and	byte ptr es:[bx + 0xa], 0xf7
01ed:3465	pop	bp
01ed:3466	ret	
sub_5295 ENDP
*/
void sub_5295()
{
    // coverage: 0x45c5-0x4667 method sub_5295
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_52a1;
    sub_ca53();
loc_52a1:
    memoryASet16(ds, 0x8884, 0x792e);
    memoryASet16(ds, 0x8886, ds);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ds, 0xa0c8);
    dx = memoryAGet16(ds, 0xa0c6);
    memoryASet16(es, bx + 6, dx);
    memoryASet16(es, bx + 8, ax);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) | 0x80);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xbf);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xdf);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xef);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xf7);
    memoryASet16(ds, 0x9b9e, 0x795a);
    memoryASet16(ds, 0x9ba0, ds);
    bx = memoryAGet16(ds, 0x9b9e);
    es = memoryAGet16(ds, 0x9b9e + 2);
    memoryASet16(es, bx + 6, dx);
    memoryASet16(es, bx + 8, ax);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) | 0x80);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xbf);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xdf);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xef);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xf7);
    memoryASet16(ds, 0xa0d0, 0x7986);
    memoryASet16(ds, 0xa0d2, ds);
    bx = memoryAGet16(ds, 0xa0d0);
    es = memoryAGet16(ds, 0xa0d0 + 2);
    memoryASet16(es, bx + 6, dx);
    memoryASet16(es, bx + 8, ax);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) | 0x80);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xbf);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xdf);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xef);
    memoryASet(es, bx + 10, memoryAGet(es, bx + 10) & 0xf7);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3467 sub_5337()
sub_5337 PROC
01ed:3467	push	bp
01ed:3468	mov	bp, sp
01ed:346a	sub	sp, 0x68
01ed:346d	push	si
01ed:346e	cmp	word ptr [0x6b4c], sp
01ed:3472	ja	loc_5347
01ed:3474	call	0xab83
        	loc_5347:
01ed:3477	les	bx, ptr [0x574]
01ed:347b	mov	byte ptr es:[bx + 0x22], 0
01ed:3480	mov	byte ptr es:[bx + 0x23], 0
01ed:3485	mov	byte ptr es:[bx + 0x24], 0
01ed:348a	mov	byte ptr es:[bx + 0x25], 0
01ed:348f	mov	word ptr es:[bx + 0xe], 0
01ed:3495	mov	word ptr es:[bx + 0x1c], 0
01ed:349b	mov	byte ptr [bp - 2], 0x14
01ed:349f	mov	byte ptr [bp - 3], 0x19
01ed:34a3	mov	byte ptr [bp - 1], 0
01ed:34a7	jmp	loc_5436
        	loc_537a:
01ed:34aa	les	bx, ptr [0x574]
01ed:34ae	mov	al, byte ptr [bp - 1]
01ed:34b1	mov	ah, 0
01ed:34b3	mov	word ptr es:[bx + 0x14], ax
01ed:34b7	mov	al, byte ptr [bp - 1]
01ed:34ba	mov	ah, 0
01ed:34bc	mov	word ptr es:[bx + 0x16], ax
01ed:34c0	mov	al, byte ptr [bp - 2]
01ed:34c3	mov	ah, 0
01ed:34c5	mov	word ptr es:[bx + 0x1e], ax
01ed:34c9	mov	word ptr es:[bx + 0x20], 1
01ed:34cf	push	word ptr [0x576]
01ed:34d3	push	word ptr [0x574]
01ed:34d7	call	0x7b4a
01ed:34da	add	sp, 4
01ed:34dd	call	0x9864
01ed:34e0	les	bx, ptr [0x574]
01ed:34e4	mov	al, byte ptr [bp - 1]
01ed:34e7	mov	ah, 0
01ed:34e9	mov	dx, 0x18
01ed:34ec	sub	dx, ax
01ed:34ee	mov	word ptr es:[bx + 0x16], dx
01ed:34f2	push	word ptr [0x576]
01ed:34f6	push	word ptr [0x574]
01ed:34fa	call	0x7b4a
01ed:34fd	add	sp, 4
01ed:3500	call	0x9864
01ed:3503	mov	al, byte ptr [bp - 2]
01ed:3506	add	al, 0xfe
01ed:3508	mov	byte ptr [bp - 2], al
01ed:350b	les	bx, ptr [0x574]
01ed:350f	mov	al, byte ptr [bp - 1]
01ed:3512	mov	ah, 0
01ed:3514	mov	word ptr es:[bx + 0x16], ax
01ed:3518	mov	word ptr es:[bx + 0x1e], 1
01ed:351e	mov	al, byte ptr [bp - 3]
01ed:3521	mov	ah, 0
01ed:3523	mov	word ptr es:[bx + 0x20], ax
01ed:3527	push	word ptr [0x576]
01ed:352b	push	word ptr [0x574]
01ed:352f	call	0x7b4a
01ed:3532	add	sp, 4
01ed:3535	call	0x9864
01ed:3538	les	bx, ptr [0x574]
01ed:353c	mov	al, byte ptr [bp - 1]
01ed:353f	mov	ah, 0
01ed:3541	mov	dx, 0x13
01ed:3544	sub	dx, ax
01ed:3546	mov	word ptr es:[bx + 0x14], dx
01ed:354a	push	word ptr [0x576]
01ed:354e	push	word ptr [0x574]
01ed:3552	call	0x7b4a
01ed:3555	add	sp, 4
01ed:3558	call	0x9864
01ed:355b	mov	al, byte ptr [bp - 3]
01ed:355e	add	al, 0xfe
01ed:3560	mov	byte ptr [bp - 3], al
01ed:3563	inc	byte ptr [bp - 1]
        	loc_5436:
01ed:3566	cmp	byte ptr [bp - 1], 9
01ed:356a	ja	loc_543f
01ed:356c	jmp	loc_537a
        	loc_543f:
01ed:356f	xor	si, si
01ed:3571	jmp	loc_5452
        	loc_5443:
01ed:3573	mov	bx, si
01ed:3575	shl	bx, 1
01ed:3577	lea	ax, [bp - 0x68]
01ed:357a	add	bx, ax
01ed:357c	mov	word ptr ss:[bx], 0
01ed:3581	inc	si
        	loc_5452:
01ed:3582	cmp	si, 0x32
01ed:3585	jb	loc_5443
01ed:3587	xor	ax, ax
01ed:3589	push	ax
01ed:358a	push	ss
01ed:358b	lea	ax, [bp - 0x68]
01ed:358e	push	ax
01ed:358f	call	0x7b93
01ed:3592	add	sp, 6
01ed:3595	xor	ax, ax
01ed:3597	push	ax
01ed:3598	call	0x7bca
01ed:359b	inc	sp
01ed:359c	inc	sp
01ed:359d	call	0x9864
01ed:35a0	pop	si
01ed:35a1	mov	sp, bp
01ed:35a3	pop	bp
01ed:35a4	ret	
sub_5337 ENDP
*/
void sub_5337()
{
    // coverage: 0x4667-0x47a5 method sub_5337
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0068;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5347;
    sub_ca53();
loc_5347:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet(es, bx + 34, 0x00);
    memoryASet(es, bx + 35, 0x00);
    memoryASet(es, bx + 36, 0x00);
    memoryASet(es, bx + 37, 0x00);
    memoryASet16(es, bx + 14, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet(ss, bp - 2, 0x14);
    memoryASet(ss, bp - 3, 0x19);
    memoryASet(ss, bp - 1, 0x00);
    goto loc_5436;
loc_537a:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    memoryASet16(es, bx + 20, ax);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    memoryASet16(es, bx + 22, ax);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    memoryASet16(es, bx + 30, ax);
    memoryASet16(es, bx + 32, 0x0001);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    sp += 0x0004;
    sub_b734();
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    dx = 0x0018;
    dx -= ax;
    memoryASet16(es, bx + 22, dx);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    sp += 0x0004;
    sub_b734();
    al = memoryAGet(ss, bp - 2);
    al += 0xfe;
    memoryASet(ss, bp - 2, al);
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    memoryASet16(es, bx + 22, ax);
    memoryASet16(es, bx + 30, 0x0001);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    memoryASet16(es, bx + 32, ax);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    sp += 0x0004;
    sub_b734();
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    dx = 0x0013;
    dx -= ax;
    memoryASet16(es, bx + 20, dx);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    sp += 0x0004;
    sub_b734();
    al = memoryAGet(ss, bp - 3);
    al += 0xfe;
    memoryASet(ss, bp - 3, al);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_5436:
    if (memoryAGet(ss, bp - 1) > 0x09)
        goto loc_543f;
    goto loc_537a;
loc_543f:
    si = 0;
    goto loc_5452;
loc_5443:
    bx = si;
    bx <<= 1;
    ax = bp - 0x68;
    bx += ax;
    memoryASet16(ss, bx, 0x0000);
    si++;
loc_5452:
    if (si < 0x0032)
        goto loc_5443;
    ax = 0;
    push(ax);
    push(ss);
    ax = bp - 0x68;
    push(ax);
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    sub_b734();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:35a5 sub_5475()
sub_5475 PROC
01ed:35a5	push	bp
01ed:35a6	mov	bp, sp
01ed:35a8	sub	sp, 0xc
01ed:35ab	push	si
01ed:35ac	push	di
01ed:35ad	cmp	word ptr [0x6b4c], sp
01ed:35b1	ja	loc_5486
01ed:35b3	call	0xab83
        	loc_5486:
01ed:35b6	mov	byte ptr [bp - 5], 0
01ed:35ba	mov	byte ptr [bp - 6], 0xff
01ed:35be	push	ss
01ed:35bf	lea	ax, [bp - 0xa]
01ed:35c2	push	ax
01ed:35c3	push	ds
01ed:35c4	mov	ax, 0x11b2
01ed:35c7	push	ax
01ed:35c8	mov	cx, 3
01ed:35cb	call	0xa9f5
01ed:35ce	mov	ax, 4
01ed:35d1	push	ax
01ed:35d2	mov	ax, 0x12
01ed:35d5	push	ax
01ed:35d6	call	0x736f
01ed:35d9	add	sp, 4
01ed:35dc	mov	si, ax
01ed:35de	xor	ax, ax
01ed:35e0	push	ax
01ed:35e1	push	word ptr [0x9e4]
01ed:35e5	push	word ptr [0x9e2]
01ed:35e9	push	word ptr [0x7928]
01ed:35ed	push	word ptr [0x7926]
01ed:35f1	push	si
01ed:35f2	call	0x745e
01ed:35f5	add	sp, 0xc
01ed:35f8	mov	word ptr [bp - 4], ax
01ed:35fb	mov	word ptr [bp - 2], dx
01ed:35fe	push	si
01ed:35ff	call	0x7319
01ed:3602	inc	sp
01ed:3603	inc	sp
01ed:3604	xor	ax, ax
01ed:3606	mov	dx, 0x7d63
01ed:3609	push	ax
01ed:360a	push	dx
01ed:360b	push	word ptr [bp - 2]
01ed:360e	push	word ptr [bp - 4]
01ed:3611	push	word ptr [0x7928]
01ed:3615	push	word ptr [0x7926]
01ed:3619	call	0x7b5a
01ed:361c	add	sp, 0xc
01ed:361f	cmp	word ptr [0x541d], 1
01ed:3624	jne	loc_552d
01ed:3626	mov	ax, word ptr [0x7928]
01ed:3629	mov	dx, word ptr [0x7926]
01ed:362d	mov	word ptr [0x9b96], dx
01ed:3631	mov	word ptr [0x9b98], ax
01ed:3634	mov	byte ptr [bp - 0xb], 0
01ed:3638	jmp	loc_5527
        	loc_550a:
01ed:363a	mov	al, byte ptr [bp - 0xb]
01ed:363d	mov	ah, 0
01ed:363f	les	bx, ptr [0x9b96]
01ed:3643	add	bx, ax
01ed:3645	mov	al, byte ptr [bp - 0xb]
01ed:3648	mov	ah, 0
01ed:364a	mov	di, ax
01ed:364c	mov	al, byte ptr [di + 0x64a]
01ed:3650	mov	byte ptr es:[bx + 0x23], al
01ed:3654	inc	byte ptr [bp - 0xb]
        	loc_5527:
01ed:3657	cmp	byte ptr [bp - 0xb], 0x10
01ed:365b	jb	loc_550a
        	loc_552d:
01ed:365d	xor	ax, ax
01ed:365f	push	ax
01ed:3660	call	0x9410
01ed:3663	inc	sp
01ed:3664	inc	sp
01ed:3665	les	bx, ptr [0x8884]
01ed:3669	mov	ax, word ptr [0x6c2e]
01ed:366c	mov	dx, word ptr [0x6c2c]
01ed:3670	mov	word ptr es:[bx + 6], dx
01ed:3674	mov	word ptr es:[bx + 8], ax
01ed:3678	mov	al, 0
01ed:367a	mov	byte ptr [0x854f], al
01ed:367d	mov	byte ptr [0x8244], al
01ed:3680	call	0x3467
01ed:3683	mov	ax, word ptr [0x7928]
01ed:3686	mov	dx, word ptr [0x7926]
01ed:368a	add	dx, 0x63
01ed:368d	les	bx, ptr [0x574]
01ed:3691	mov	word ptr es:[bx + 2], dx
01ed:3695	mov	word ptr es:[bx + 4], ax
01ed:3699	mov	word ptr es:[bx + 6], 0
01ed:369f	mov	word ptr es:[bx + 8], 0
01ed:36a5	mov	word ptr es:[bx + 0xa], 0x14
01ed:36ab	mov	word ptr es:[bx + 0xc], 0x19
01ed:36b1	mov	word ptr es:[bx + 0xe], 1
01ed:36b7	mov	word ptr es:[bx + 0x14], 0
01ed:36bd	mov	word ptr es:[bx + 0x16], 0
01ed:36c3	mov	word ptr es:[bx + 0x1c], 0
01ed:36c9	mov	word ptr es:[bx + 0x1e], 0x14
01ed:36cf	mov	word ptr es:[bx + 0x20], 0x19
01ed:36d5	push	word ptr [0x576]
01ed:36d9	push	word ptr [0x574]
01ed:36dd	call	0x80bc
01ed:36e0	add	sp, 4
01ed:36e3	xor	ax, ax
01ed:36e5	push	ax
01ed:36e6	push	word ptr [0x7928]
01ed:36ea	push	word ptr [0x7926]
01ed:36ee	call	0x7b93
01ed:36f1	add	sp, 6
01ed:36f4	xor	ax, ax
01ed:36f6	push	ax
01ed:36f7	call	0x7bca
01ed:36fa	inc	sp
01ed:36fb	inc	sp
01ed:36fc	jmp	loc_56d9
        	loc_55cf:
01ed:36ff	mov	al, byte ptr [0x79b5]
01ed:3702	mov	ah, 0
01ed:3704	shl	ax, 1
01ed:3706	shl	ax, 1
01ed:3708	mov	bx, ax
01ed:370a	mov	ax, word ptr [bx + 0x760]
01ed:370e	mov	dx, word ptr [bx + 0x75e]
01ed:3712	les	bx, ptr [0x574]
01ed:3716	mov	word ptr es:[bx + 2], dx
01ed:371a	mov	word ptr es:[bx + 4], ax
01ed:371e	mov	word ptr es:[bx + 6], 0
01ed:3724	mov	word ptr es:[bx + 8], 0
01ed:372a	mov	word ptr es:[bx + 0xa], 6
01ed:3730	mov	word ptr es:[bx + 0xc], 2
01ed:3736	mov	word ptr es:[bx + 0x14], 0xb
01ed:373c	mov	word ptr es:[bx + 0x16], 0x12
01ed:3742	mov	word ptr es:[bx + 0x1e], 6
01ed:3748	mov	word ptr es:[bx + 0x20], 2
01ed:374e	push	word ptr [0x576]
01ed:3752	push	word ptr [0x574]
01ed:3756	call	0x80bc
01ed:3759	add	sp, 4
01ed:375c	mov	ax, 1
01ed:375f	push	ax
01ed:3760	call	0x7bdd
01ed:3763	inc	sp
01ed:3764	inc	sp
01ed:3765	mov	ax, 1
01ed:3768	push	ax
01ed:3769	xor	ax, ax
01ed:376b	push	ax
01ed:376c	call	0x5181
01ed:376f	add	sp, 4
01ed:3772	les	bx, ptr [0x8884]
01ed:3776	mov	word ptr es:[bx + 4], 0
01ed:377c	mov	word ptr es:[bx], 0x30
01ed:3781	mov	al, byte ptr [bp - 5]
01ed:3784	mov	ah, 0
01ed:3786	mov	cl, 4
01ed:3788	shl	ax, cl
01ed:378a	add	ax, 0x70
01ed:378d	mov	word ptr es:[bx + 2], ax
01ed:3791	push	ds
01ed:3792	mov	ax, 0x792e
01ed:3795	push	ax
01ed:3796	call	0x942a
01ed:3799	add	sp, 4
01ed:379c	call	0x9864
01ed:379f	call	0x1dde
01ed:37a2	test	byte ptr [0x8244], 1
01ed:37a7	je	loc_5684
01ed:37a9	cmp	byte ptr [bp - 5], 0
01ed:37ad	je	loc_5684
01ed:37af	dec	byte ptr [bp - 5]
01ed:37b2	jmp	loc_56c8
        	loc_5684:
01ed:37b4	test	byte ptr [0x8244], 2
01ed:37b9	je	loc_5696
01ed:37bb	cmp	byte ptr [bp - 5], 3
01ed:37bf	jae	loc_5696
01ed:37c1	inc	byte ptr [bp - 5]
01ed:37c4	jmp	loc_56c8
        	loc_5696:
01ed:37c6	test	byte ptr [0x8244], 0x10
01ed:37cb	je	loc_56c8
01ed:37cd	mov	al, byte ptr [bp - 5]
01ed:37d0	mov	ah, 0
01ed:37d2	mov	bx, ax
01ed:37d4	cmp	bx, 3
01ed:37d7	ja	loc_56c8
01ed:37d9	shl	bx, 1
01ed:37db	jmp	word ptr cs:[bx + 0x384a]
        	loc_56b0:
01ed:37e0	mov	al, byte ptr [bp - 5]
01ed:37e3	mov	byte ptr [bp - 6], al
01ed:37e6	jmp	loc_56c8
        	loc_56b8:
01ed:37e8	inc	byte ptr [0x79b5]
01ed:37ec	cmp	byte ptr [0x79b5], 3
01ed:37f1	jne	loc_56c8
01ed:37f3	mov	byte ptr [0x79b5], 0
        	loc_56c8:
01ed:37f8	mov	byte ptr [0x8244], 0
        	loc_56cd:
01ed:37fd	mov	al, 0
01ed:37ff	push	ax
01ed:3800	call	0x75a2
01ed:3803	inc	sp
01ed:3804	inc	sp
01ed:3805	or	al, al
01ed:3807	jne	loc_56cd
        	loc_56d9:
01ed:3809	cmp	byte ptr [bp - 6], 0xff
01ed:380d	jne	loc_56e2
01ed:380f	jmp	loc_55cf
        	loc_56e2:
01ed:3812	mov	al, byte ptr [0x79b5]
01ed:3815	mov	ah, 0
01ed:3817	lea	dx, [bp - 0xa]
01ed:381a	add	ax, dx
01ed:381c	mov	bx, ax
01ed:381e	mov	al, byte ptr ss:[bx]
01ed:3821	mov	byte ptr [0x854f], al
01ed:3824	les	bx, ptr [0x8884]
01ed:3828	mov	ax, word ptr [0xa0c8]
01ed:382b	mov	dx, word ptr [0xa0c6]
01ed:382f	mov	word ptr es:[bx + 6], dx
01ed:3833	mov	word ptr es:[bx + 8], ax
01ed:3837	mov	ax, 1
01ed:383a	push	ax
01ed:383b	call	0x9410
01ed:383e	inc	sp
01ed:383f	inc	sp
01ed:3840	mov	al, byte ptr [bp - 6]
01ed:3843	pop	di
01ed:3844	pop	si
01ed:3845	mov	sp, bp
01ed:3847	pop	bp
01ed:3848	ret	
sub_5475 ENDP
*/
void sub_5475()
{
    // coverage: 0x47a5-0x4a49 method sub_5475
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000c;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5486;
    sub_ca53();
loc_5486:
    memoryASet(ss, bp - 5, 0x00);
    memoryASet(ss, bp - 6, 0xff);
    push(ss);
    ax = bp - 0xa;
    push(ax);
    push(ds);
    ax = 0x11b2;
    push(ax);
    cx = 0x0003;
    sub_c8c5();
    ax = 0x0004;
    push(ax);
    ax = 0x0012;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x09e4));
    push(memoryAGet16(ds, 0x09e2));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a2a();
    sp += 0x000c;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_552d;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 11, 0x00);
    goto loc_5527;
loc_550a:
    al = memoryAGet(ss, bp - 11);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 11);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1610);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 11, memoryAGet(ss, bp - 11) + 1);
loc_5527:
    if (memoryAGet(ss, bp - 11) < 0x10)
        goto loc_550a;
loc_552d:
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ds, 0x6c2e);
    dx = memoryAGet16(ds, 0x6c2c);
    memoryASet16(es, bx + 6, dx);
    memoryASet16(es, bx + 8, ax);
    al = 0x00;
    memoryASet(ds, 0x854f, al);
    memoryASet(ds, 0x8244, al);
    sub_5337();
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    dx += 0x0063;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    goto loc_56d9;
loc_55cf:
    al = memoryAGet(ds, 0x79b5);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 1888);
    dx = memoryAGet16(ds, bx + 1886);
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0006);
    memoryASet16(es, bx + 12, 0x0002);
    memoryASet16(es, bx + 20, 0x000b);
    memoryASet16(es, bx + 22, 0x0012);
    memoryASet16(es, bx + 30, 0x0006);
    memoryASet16(es, bx + 32, 0x0002);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    ax = 0;
    push(ax);
    sub_7051();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 4, 0x0000);
    memoryASet16(es, bx, 0x0030);
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    ax += 0x0070;
    memoryASet16(es, bx + 2, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    sub_b734();
    sub_3cae();
    if (!(memoryAGet(ds, 0x8244) & 0x01))
        goto loc_5684;
    if (memoryAGet(ss, bp - 5) == 0x00)
        goto loc_5684;
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) - 1);
    goto loc_56c8;
loc_5684:
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_5696;
    if (memoryAGet(ss, bp - 5) >= 0x03)
        goto loc_5696;
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) + 1);
    goto loc_56c8;
loc_5696:
    if (!(memoryAGet(ds, 0x8244) & 0x10))
        goto loc_56c8;
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    bx = ax;
    if (bx > 0x0003)
        goto loc_56c8;
    bx <<= 1;
    switch (bx)
    {
        // coverage: 0x4a4a-0x4a50 switch
        case 0: goto loc_56b0;
        case 2: goto loc_56b0;
        case 4: goto loc_56b8;
        case 6: goto loc_56b0;
        default:
        assert(0);
    }
loc_56b0:
    al = memoryAGet(ss, bp - 5);
    memoryASet(ss, bp - 6, al);
    goto loc_56c8;
loc_56b8:
    memoryASet(ds, 0x79b5, memoryAGet(ds, 0x79b5) + 1);
    if (memoryAGet(ds, 0x79b5) != 0x03)
        goto loc_56c8;
    memoryASet(ds, 0x79b5, 0x00);
loc_56c8:
    memoryASet(ds, 0x8244, 0x00);
loc_56cd:
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    if (al)
        goto loc_56cd;
loc_56d9:
    if (memoryAGet(ss, bp - 6) != 0xff)
        goto loc_56e2;
    goto loc_55cf;
loc_56e2:
    al = memoryAGet(ds, 0x79b5);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    bx = ax;
    al = memoryAGet(ss, bx);
    memoryASet(ds, 0x854f, al);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ds, 0xa0c8);
    dx = memoryAGet16(ds, 0xa0c6);
    memoryASet16(es, bx + 6, dx);
    memoryASet16(es, bx + 8, ax);
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    al = memoryAGet(ss, bp - 6);
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3852 sub_5722()
sub_5722 PROC
01ed:3852	push	bp
01ed:3853	mov	bp, sp
01ed:3855	sub	sp, 0xa
01ed:3858	push	si
01ed:3859	cmp	word ptr [0x6b4c], sp
01ed:385d	ja	loc_5732
01ed:385f	call	0xab83
        	loc_5732:
01ed:3862	mov	byte ptr [bp - 5], 0
01ed:3866	mov	al, byte ptr [0x854f]
01ed:3869	mov	byte ptr [0x8e8a], al
01ed:386c	mov	byte ptr [0x854f], 0
01ed:3871	mov	byte ptr [0x8244], 0
01ed:3876	push	ds
01ed:3877	mov	ax, 0x928
01ed:387a	push	ax
01ed:387b	call	0x7307
01ed:387e	add	sp, 4
01ed:3881	mov	ax, 4
01ed:3884	push	ax
01ed:3885	mov	al, byte ptr [0x79b2]
01ed:3888	mov	ah, 0
01ed:388a	add	ax, 7
01ed:388d	push	ax
01ed:388e	call	0x736f
01ed:3891	add	sp, 4
01ed:3894	mov	si, ax
01ed:3896	xor	ax, ax
01ed:3898	push	ax
01ed:3899	mov	al, byte ptr [0x79b2]
01ed:389c	mov	ah, 0
01ed:389e	mov	dx, 0xa
01ed:38a1	imul	dx
01ed:38a3	mov	bx, ax
01ed:38a5	push	word ptr [bx + 0x976]
01ed:38a9	push	word ptr [bx + 0x974]
01ed:38ad	push	word ptr [0x7928]
01ed:38b1	push	word ptr [0x7926]
01ed:38b5	push	si
01ed:38b6	call	0x745e
01ed:38b9	add	sp, 0xc
01ed:38bc	mov	word ptr [bp - 4], ax
01ed:38bf	mov	word ptr [bp - 2], dx
01ed:38c2	push	si
01ed:38c3	call	0x7319
01ed:38c6	inc	sp
01ed:38c7	inc	sp
01ed:38c8	xor	ax, ax
01ed:38ca	mov	dx, 0x7d63
01ed:38cd	push	ax
01ed:38ce	push	dx
01ed:38cf	push	word ptr [bp - 2]
01ed:38d2	push	word ptr [bp - 4]
01ed:38d5	push	word ptr [0x7928]
01ed:38d9	push	word ptr [0x7926]
01ed:38dd	call	0x7b5a
01ed:38e0	add	sp, 0xc
01ed:38e3	cmp	word ptr [0x541d], 1
01ed:38e8	jne	loc_580c
01ed:38ea	mov	ax, word ptr [0x7928]
01ed:38ed	mov	dx, word ptr [0x7926]
01ed:38f1	mov	word ptr [0x9b96], dx
01ed:38f5	mov	word ptr [0x9b98], ax
01ed:38f8	mov	al, byte ptr [0x79b2]
01ed:38fb	mov	ah, 0
01ed:38fd	shl	ax, 1
01ed:38ff	shl	ax, 1
01ed:3901	mov	bx, ax
01ed:3903	mov	ax, word ptr [bx + 0x6e8]
01ed:3907	mov	dx, word ptr [bx + 0x6e6]
01ed:390b	mov	word ptr [bp - 0xa], dx
01ed:390e	mov	word ptr [bp - 8], ax
01ed:3911	mov	byte ptr [bp - 6], 0
01ed:3915	jmp	loc_5806
        	loc_57e7:
01ed:3917	mov	al, byte ptr [bp - 6]
01ed:391a	mov	ah, 0
01ed:391c	les	bx, ptr [bp - 0xa]
01ed:391f	add	bx, ax
01ed:3921	mov	al, byte ptr es:[bx]
01ed:3924	mov	dl, byte ptr [bp - 6]
01ed:3927	mov	dh, 0
01ed:3929	les	bx, ptr [0x9b96]
01ed:392d	add	bx, dx
01ed:392f	mov	byte ptr es:[bx + 0x23], al
01ed:3933	inc	byte ptr [bp - 6]
        	loc_5806:
01ed:3936	cmp	byte ptr [bp - 6], 0x10
01ed:393a	jb	loc_57e7
        	loc_580c:
01ed:393c	call	0x3467
01ed:393f	mov	ax, word ptr [0x7928]
01ed:3942	mov	dx, word ptr [0x7926]
01ed:3946	add	dx, 0x63
01ed:3949	les	bx, ptr [0x574]
01ed:394d	mov	word ptr es:[bx + 2], dx
01ed:3951	mov	word ptr es:[bx + 4], ax
01ed:3955	mov	word ptr es:[bx + 6], 0
01ed:395b	mov	word ptr es:[bx + 8], 0
01ed:3961	mov	word ptr es:[bx + 0xa], 0x14
01ed:3967	mov	word ptr es:[bx + 0xc], 0x19
01ed:396d	mov	word ptr es:[bx + 0xe], 1
01ed:3973	mov	word ptr es:[bx + 0x14], 0
01ed:3979	mov	word ptr es:[bx + 0x16], 0
01ed:397f	mov	word ptr es:[bx + 0x1c], 0
01ed:3985	mov	word ptr es:[bx + 0x1e], 0x14
01ed:398b	mov	word ptr es:[bx + 0x20], 0x19
01ed:3991	push	word ptr [0x576]
01ed:3995	push	word ptr [0x574]
01ed:3999	call	0x80bc
01ed:399c	add	sp, 4
01ed:399f	mov	ax, 8
01ed:39a2	push	ax
01ed:39a3	mov	ax, 1
01ed:39a6	push	ax
01ed:39a7	mov	al, 7
01ed:39a9	push	ax
01ed:39aa	push	word ptr [0xa0d6]
01ed:39ae	push	word ptr [0xa0d4]
01ed:39b2	call	0x816
01ed:39b5	add	sp, 0xa
01ed:39b8	call	0x6130
01ed:39bb	call	0x3c4f
01ed:39be	mov	al, byte ptr [0x79b6]
01ed:39c1	mov	byte ptr [0x854e], al
01ed:39c4	xor	ax, ax
01ed:39c6	push	ax
01ed:39c7	push	word ptr [0x7928]
01ed:39cb	push	word ptr [0x7926]
01ed:39cf	call	0x7b93
01ed:39d2	add	sp, 6
01ed:39d5	mov	ax, word ptr [0x791c]
01ed:39d8	mov	word ptr [0x9290], ax
01ed:39db	mov	ax, word ptr [0x791e]
01ed:39de	mov	word ptr [0x9292], ax
01ed:39e1	mov	word ptr [0x824a], 0x21
01ed:39e7	xor	ax, ax
01ed:39e9	push	ax
01ed:39ea	mov	ax, 1
01ed:39ed	push	ax
01ed:39ee	call	0x5181
01ed:39f1	add	sp, 4
01ed:39f4	call	0x1cb2
01ed:39f7	xor	ax, ax
01ed:39f9	push	ax
01ed:39fa	call	0x7bca
01ed:39fd	inc	sp
01ed:39fe	inc	sp
01ed:39ff	mov	ax, 1
01ed:3a02	push	ax
01ed:3a03	call	0x7bdd
01ed:3a06	inc	sp
01ed:3a07	inc	sp
01ed:3a08	call	0x9864
01ed:3a0b	call	0x1473
01ed:3a0e	call	0x138c
01ed:3a11	call	0x1bd7
01ed:3a14	call	0x138c
01ed:3a17	call	0x3a88
01ed:3a1a	jmp	loc_5944
        	loc_58ec:
01ed:3a1c	call	0x1dde
01ed:3a1f	test	byte ptr [0x8244], 1
01ed:3a24	je	loc_58fb
01ed:3a26	call	0x3ab2
01ed:3a29	jmp	loc_593f
        	loc_58fb:
01ed:3a2b	test	byte ptr [0x8244], 2
01ed:3a30	je	loc_5907
01ed:3a32	call	0x3b0f
01ed:3a35	jmp	loc_593f
        	loc_5907:
01ed:3a37	test	byte ptr [0x8244], 4
01ed:3a3c	je	loc_5913
01ed:3a3e	call	0x3b6c
01ed:3a41	jmp	loc_593f
        	loc_5913:
01ed:3a43	test	byte ptr [0x8244], 8
01ed:3a48	je	loc_591f
01ed:3a4a	call	0x3bc9
01ed:3a4d	jmp	loc_593f
        	loc_591f:
01ed:3a4f	test	byte ptr [0x8244], 0x10
01ed:3a54	je	loc_592b
01ed:3a56	call	0x3cf7
01ed:3a59	jmp	loc_593c
        	loc_592b:
01ed:3a5b	mov	al, 1
01ed:3a5d	push	ax
01ed:3a5e	call	0x7ab4
01ed:3a61	inc	sp
01ed:3a62	inc	sp
01ed:3a63	or	al, al
01ed:3a65	je	loc_593f
01ed:3a67	mov	al, 0xff
01ed:3a69	mov	byte ptr [0x928d], al
        	loc_593c:
01ed:3a6c	mov	byte ptr [bp - 5], al
        	loc_593f:
01ed:3a6f	mov	byte ptr [0x8244], 0
        	loc_5944:
01ed:3a74	mov	al, byte ptr [bp - 5]
01ed:3a77	mov	ah, 0
01ed:3a79	or	ax, ax
01ed:3a7b	je	loc_58ec
01ed:3a7d	mov	al, byte ptr [0x8e8a]
01ed:3a80	mov	byte ptr [0x854f], al
01ed:3a83	pop	si
01ed:3a84	mov	sp, bp
01ed:3a86	pop	bp
01ed:3a87	ret	
sub_5722 ENDP
*/
void sub_5722()
{
    // coverage: 0x4a52-0x4c88 method sub_5722
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000a;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5732;
    sub_ca53();
loc_5732:
    memoryASet(ss, bp - 5, 0x00);
    al = memoryAGet(ds, 0x854f);
    memoryASet(ds, 0x8e8a, al);
    memoryASet(ds, 0x854f, 0x00);
    memoryASet(ds, 0x8244, 0x00);
    push(ds);
    ax = 0x0928;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    ax = 0x0004;
    push(ax);
    al = memoryAGet(ds, 0x79b2);
    ah = 0x00;
    ax += 0x0007;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    al = memoryAGet(ds, 0x79b2);
    ah = 0x00;
    dx = 0x000a;
    imul(dx);
    bx = ax;
    push(memoryAGet16(ds, bx + 2422));
    push(memoryAGet16(ds, bx + 2420));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a2a();
    sp += 0x000c;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_580c;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    al = memoryAGet(ds, 0x79b2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 1768);
    dx = memoryAGet16(ds, bx + 1766);
    memoryASet16(ss, bp - 10, dx);
    memoryASet16(ss, bp - 8, ax);
    memoryASet(ss, bp - 6, 0x00);
    goto loc_5806;
loc_57e7:
    al = memoryAGet(ss, bp - 6);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 10);
    es = memoryAGet16(ss, bp - 10 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    dl = memoryAGet(ss, bp - 6);
    dh = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += dx;
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 6, memoryAGet(ss, bp - 6) + 1);
loc_5806:
    if (memoryAGet(ss, bp - 6) < 0x10)
        goto loc_57e7;
loc_580c:
    sub_5337();
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    dx += 0x0063;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    ax = 0x0008;
    push(ax);
    ax = 0x0001;
    push(ax);
    al = 0x07;
    push(ax);
    push(memoryAGet16(ds, 0xa0d6));
    push(memoryAGet16(ds, 0xa0d4));
    sub_26e6();
    sp += 0x000a;
    sub_8000();
    sub_5b1f();
    al = memoryAGet(ds, 0x79b6);
    memoryASet(ds, 0x854e, al);
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a63();
    sp += 0x0006;
    ax = memoryAGet16(ds, 0x791c);
    memoryASet16(ds, 0x9290, ax);
    ax = memoryAGet16(ds, 0x791e);
    memoryASet16(ds, 0x9292, ax);
    memoryASet16(ds, 0x824a, 0x0021);
    ax = 0;
    push(ax);
    ax = 0x0001;
    push(ax);
    sub_7051();
    sp += 0x0004;
    sub_3b82();
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_b734();
    sub_3343();
    sub_325c();
    sub_3aa7();
    sub_325c();
    sub_5958();
    goto loc_5944;
loc_58ec:
    sub_3cae();
    if (!(memoryAGet(ds, 0x8244) & 0x01))
        goto loc_58fb;
    sub_5982();
    goto loc_593f;
loc_58fb:
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_5907;
    sub_59df();
    goto loc_593f;
loc_5907:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_5913;
    sub_5a3c();
    goto loc_593f;
loc_5913:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_591f;
    sub_5a99();
    goto loc_593f;
loc_591f:
    if (!(memoryAGet(ds, 0x8244) & 0x10))
        goto loc_592b;
    sub_5bc7();
    goto loc_593c;
loc_592b:
    al = 0x01;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_593f;
    al = 0xff;
    memoryASet(ds, 0x928d, al);
loc_593c:
    memoryASet(ss, bp - 5, al);
loc_593f:
    memoryASet(ds, 0x8244, 0x00);
loc_5944:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    if (!ax)
        goto loc_58ec;
    al = memoryAGet(ds, 0x8e8a);
    memoryASet(ds, 0x854f, al);
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3a88 sub_5958()
sub_5958 PROC
01ed:3a88	push	bp
01ed:3a89	mov	bp, sp
01ed:3a8b	cmp	word ptr [0x6b4c], sp
01ed:3a8f	ja	loc_5964
01ed:3a91	call	0xab83
        	loc_5964:
01ed:3a94	mov	al, byte ptr [0x854e]
01ed:3a97	mov	ah, 0
01ed:3a99	mov	dx, 9
01ed:3a9c	imul	dx
01ed:3a9e	mov	dx, word ptr [0x8248]
01ed:3aa2	mov	bx, word ptr [0x8246]
01ed:3aa6	add	bx, ax
01ed:3aa8	mov	word ptr [0x9baa], bx
01ed:3aac	mov	word ptr [0x9bac], dx
01ed:3ab0	pop	bp
01ed:3ab1	ret	
sub_5958 ENDP
*/
void sub_5958()
{
    // coverage: 0x4c88-0x4cb2 method sub_5958
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5964;
    sub_ca53();
loc_5964:
    al = memoryAGet(ds, 0x854e);
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    dx = memoryAGet16(ds, 0x8248);
    bx = memoryAGet16(ds, 0x8246);
    bx += ax;
    memoryASet16(ds, 0x9baa, bx);
    memoryASet16(ds, 0x9bac, dx);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3ab2 sub_5982()
sub_5982 PROC
01ed:3ab2	push	bp
01ed:3ab3	mov	bp, sp
01ed:3ab5	sub	sp, 6
01ed:3ab8	cmp	word ptr [0x6b4c], sp
01ed:3abc	ja	loc_5991
01ed:3abe	call	0xab83
        	loc_5991:
01ed:3ac1	mov	ax, word ptr [0x9bac]
01ed:3ac4	mov	dx, word ptr [0x9baa]
01ed:3ac8	mov	word ptr [bp - 6], dx
01ed:3acb	mov	word ptr [bp - 4], ax
01ed:3ace	les	bx, ptr [bp - 6]
01ed:3ad1	mov	al, byte ptr es:[bx + 1]
01ed:3ad5	mov	byte ptr [bp - 1], al
01ed:3ad8	cmp	byte ptr [bp - 1], 0
01ed:3adc	je	loc_59db
01ed:3ade	mov	byte ptr [0x854e], al
01ed:3ae1	call	0x3a88
01ed:3ae4	les	bx, ptr [bp - 6]
01ed:3ae7	mov	al, byte ptr es:[bx + 2]
01ed:3aeb	mov	ah, 0
01ed:3aed	sar	ax, 1
01ed:3aef	sar	ax, 1
01ed:3af1	mov	byte ptr [bp - 1], al
01ed:3af4	jmp	loc_59d5
        	loc_59c6:
01ed:3af6	mov	ax, word ptr [0x9292]
01ed:3af9	add	ax, 0xfffc
01ed:3afc	mov	word ptr [0x9292], ax
01ed:3aff	call	0x3c26
01ed:3b02	dec	byte ptr [bp - 1]
        	loc_59d5:
01ed:3b05	cmp	byte ptr [bp - 1], 0
01ed:3b09	jne	loc_59c6
        	loc_59db:
01ed:3b0b	mov	sp, bp
01ed:3b0d	pop	bp
01ed:3b0e	ret	
sub_5982 ENDP
*/
void sub_5982()
{
    // coverage: 0x4cb2-0x4d0f method sub_5982
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5991;
    sub_ca53();
loc_5991:
    ax = memoryAGet16(ds, 0x9bac);
    dx = memoryAGet16(ds, 0x9baa);
    memoryASet16(ss, bp - 6, dx);
    memoryASet16(ss, bp - 4, ax);
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 1);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_59db;
    memoryASet(ds, 0x854e, al);
    sub_5958();
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 2);
    ah = 0x00;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ss, bp - 1, al);
    goto loc_59d5;
loc_59c6:
    ax = memoryAGet16(ds, 0x9292);
    ax += 0xfffc;
    memoryASet16(ds, 0x9292, ax);
    sub_5af6();
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) - 1);
loc_59d5:
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_59c6;
loc_59db:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3b0f sub_59df()
sub_59df PROC
01ed:3b0f	push	bp
01ed:3b10	mov	bp, sp
01ed:3b12	sub	sp, 6
01ed:3b15	cmp	word ptr [0x6b4c], sp
01ed:3b19	ja	loc_59ee
01ed:3b1b	call	0xab83
        	loc_59ee:
01ed:3b1e	mov	ax, word ptr [0x9bac]
01ed:3b21	mov	dx, word ptr [0x9baa]
01ed:3b25	mov	word ptr [bp - 6], dx
01ed:3b28	mov	word ptr [bp - 4], ax
01ed:3b2b	les	bx, ptr [bp - 6]
01ed:3b2e	mov	al, byte ptr es:[bx + 3]
01ed:3b32	mov	byte ptr [bp - 1], al
01ed:3b35	cmp	byte ptr [bp - 1], 0
01ed:3b39	je	loc_5a38
01ed:3b3b	mov	byte ptr [0x854e], al
01ed:3b3e	call	0x3a88
01ed:3b41	les	bx, ptr [bp - 6]
01ed:3b44	mov	al, byte ptr es:[bx + 4]
01ed:3b48	mov	ah, 0
01ed:3b4a	sar	ax, 1
01ed:3b4c	sar	ax, 1
01ed:3b4e	mov	byte ptr [bp - 1], al
01ed:3b51	jmp	loc_5a32
        	loc_5a23:
01ed:3b53	mov	ax, word ptr [0x9292]
01ed:3b56	add	ax, 4
01ed:3b59	mov	word ptr [0x9292], ax
01ed:3b5c	call	0x3c26
01ed:3b5f	dec	byte ptr [bp - 1]
        	loc_5a32:
01ed:3b62	cmp	byte ptr [bp - 1], 0
01ed:3b66	jne	loc_5a23
        	loc_5a38:
01ed:3b68	mov	sp, bp
01ed:3b6a	pop	bp
01ed:3b6b	ret	
sub_59df ENDP
*/
void sub_59df()
{
    // coverage: 0x4d0f-0x4d6c method sub_59df
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_59ee;
    sub_ca53();
loc_59ee:
    ax = memoryAGet16(ds, 0x9bac);
    dx = memoryAGet16(ds, 0x9baa);
    memoryASet16(ss, bp - 6, dx);
    memoryASet16(ss, bp - 4, ax);
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 3);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_5a38;
    memoryASet(ds, 0x854e, al);
    sub_5958();
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 4);
    ah = 0x00;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ss, bp - 1, al);
    goto loc_5a32;
loc_5a23:
    ax = memoryAGet16(ds, 0x9292);
    ax += 0x0004;
    memoryASet16(ds, 0x9292, ax);
    sub_5af6();
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) - 1);
loc_5a32:
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_5a23;
loc_5a38:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3b6c sub_5a3c()
sub_5a3c PROC
01ed:3b6c	push	bp
01ed:3b6d	mov	bp, sp
01ed:3b6f	sub	sp, 6
01ed:3b72	cmp	word ptr [0x6b4c], sp
01ed:3b76	ja	loc_5a4b
01ed:3b78	call	0xab83
        	loc_5a4b:
01ed:3b7b	mov	ax, word ptr [0x9bac]
01ed:3b7e	mov	dx, word ptr [0x9baa]
01ed:3b82	mov	word ptr [bp - 6], dx
01ed:3b85	mov	word ptr [bp - 4], ax
01ed:3b88	les	bx, ptr [bp - 6]
01ed:3b8b	mov	al, byte ptr es:[bx + 5]
01ed:3b8f	mov	byte ptr [bp - 1], al
01ed:3b92	cmp	byte ptr [bp - 1], 0
01ed:3b96	je	loc_5a95
01ed:3b98	mov	byte ptr [0x854e], al
01ed:3b9b	call	0x3a88
01ed:3b9e	les	bx, ptr [bp - 6]
01ed:3ba1	mov	al, byte ptr es:[bx + 6]
01ed:3ba5	mov	ah, 0
01ed:3ba7	sar	ax, 1
01ed:3ba9	sar	ax, 1
01ed:3bab	mov	byte ptr [bp - 1], al
01ed:3bae	jmp	loc_5a8f
        	loc_5a80:
01ed:3bb0	mov	ax, word ptr [0x9290]
01ed:3bb3	add	ax, 0xfffc
01ed:3bb6	mov	word ptr [0x9290], ax
01ed:3bb9	call	0x3c26
01ed:3bbc	dec	byte ptr [bp - 1]
        	loc_5a8f:
01ed:3bbf	cmp	byte ptr [bp - 1], 0
01ed:3bc3	jne	loc_5a80
        	loc_5a95:
01ed:3bc5	mov	sp, bp
01ed:3bc7	pop	bp
01ed:3bc8	ret	
sub_5a3c ENDP
*/
void sub_5a3c()
{
    // coverage: 0x4d6c-0x4dc9 method sub_5a3c
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5a4b;
    sub_ca53();
loc_5a4b:
    ax = memoryAGet16(ds, 0x9bac);
    dx = memoryAGet16(ds, 0x9baa);
    memoryASet16(ss, bp - 6, dx);
    memoryASet16(ss, bp - 4, ax);
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 5);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_5a95;
    memoryASet(ds, 0x854e, al);
    sub_5958();
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 6);
    ah = 0x00;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ss, bp - 1, al);
    goto loc_5a8f;
loc_5a80:
    ax = memoryAGet16(ds, 0x9290);
    ax += 0xfffc;
    memoryASet16(ds, 0x9290, ax);
    sub_5af6();
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) - 1);
loc_5a8f:
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_5a80;
loc_5a95:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3bc9 sub_5a99()
sub_5a99 PROC
01ed:3bc9	push	bp
01ed:3bca	mov	bp, sp
01ed:3bcc	sub	sp, 6
01ed:3bcf	cmp	word ptr [0x6b4c], sp
01ed:3bd3	ja	loc_5aa8
01ed:3bd5	call	0xab83
        	loc_5aa8:
01ed:3bd8	mov	ax, word ptr [0x9bac]
01ed:3bdb	mov	dx, word ptr [0x9baa]
01ed:3bdf	mov	word ptr [bp - 6], dx
01ed:3be2	mov	word ptr [bp - 4], ax
01ed:3be5	les	bx, ptr [bp - 6]
01ed:3be8	mov	al, byte ptr es:[bx + 7]
01ed:3bec	mov	byte ptr [bp - 1], al
01ed:3bef	cmp	byte ptr [bp - 1], 0
01ed:3bf3	je	loc_5af2
01ed:3bf5	mov	byte ptr [0x854e], al
01ed:3bf8	call	0x3a88
01ed:3bfb	les	bx, ptr [bp - 6]
01ed:3bfe	mov	al, byte ptr es:[bx + 8]
01ed:3c02	mov	ah, 0
01ed:3c04	sar	ax, 1
01ed:3c06	sar	ax, 1
01ed:3c08	mov	byte ptr [bp - 1], al
01ed:3c0b	jmp	loc_5aec
        	loc_5add:
01ed:3c0d	mov	ax, word ptr [0x9290]
01ed:3c10	add	ax, 4
01ed:3c13	mov	word ptr [0x9290], ax
01ed:3c16	call	0x3c26
01ed:3c19	dec	byte ptr [bp - 1]
        	loc_5aec:
01ed:3c1c	cmp	byte ptr [bp - 1], 0
01ed:3c20	jne	loc_5add
        	loc_5af2:
01ed:3c22	mov	sp, bp
01ed:3c24	pop	bp
01ed:3c25	ret	
sub_5a99 ENDP
*/
void sub_5a99()
{
    // coverage: 0x4dc9-0x4e26 method sub_5a99
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5aa8;
    sub_ca53();
loc_5aa8:
    ax = memoryAGet16(ds, 0x9bac);
    dx = memoryAGet16(ds, 0x9baa);
    memoryASet16(ss, bp - 6, dx);
    memoryASet16(ss, bp - 4, ax);
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 7);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_5af2;
    memoryASet(ds, 0x854e, al);
    sub_5958();
    bx = memoryAGet16(ss, bp - 6);
    es = memoryAGet16(ss, bp - 6 + 2);
    al = memoryAGet(es, bx + 8);
    ah = 0x00;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ss, bp - 1, al);
    goto loc_5aec;
loc_5add:
    ax = memoryAGet16(ds, 0x9290);
    ax += 0x0004;
    memoryASet16(ds, 0x9290, ax);
    sub_5af6();
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) - 1);
loc_5aec:
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_5add;
loc_5af2:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3c26 sub_5af6()
sub_5af6 PROC
01ed:3c26	push	bp
01ed:3c27	mov	bp, sp
01ed:3c29	cmp	word ptr [0x6b4c], sp
01ed:3c2d	ja	loc_5b02
01ed:3c2f	call	0xab83
        	loc_5b02:
01ed:3c32	call	0x138c
01ed:3c35	call	0x1473
01ed:3c38	call	0x19e4
01ed:3c3b	call	0x1bd7
01ed:3c3e	call	0x1cb2
01ed:3c41	mov	ax, 1
01ed:3c44	push	ax
01ed:3c45	call	0x7bdd
01ed:3c48	inc	sp
01ed:3c49	inc	sp
01ed:3c4a	call	0x1349
01ed:3c4d	pop	bp
01ed:3c4e	ret	
sub_5af6 ENDP
*/
void sub_5af6()
{
    // coverage: 0x4e26-0x4e4f method sub_5af6
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5b02;
    sub_ca53();
loc_5b02:
    sub_325c();
    sub_3343();
    sub_38b4();
    sub_3aa7();
    sub_3b82();
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_3219();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3c4f sub_5b1f()
sub_5b1f PROC
01ed:3c4f	push	bp
01ed:3c50	mov	bp, sp
01ed:3c52	dec	sp
01ed:3c53	dec	sp
01ed:3c54	cmp	word ptr [0x6b4c], sp
01ed:3c58	ja	loc_5b2d
01ed:3c5a	call	0xab83
        	loc_5b2d:
01ed:3c5d	mov	byte ptr [bp - 1], 0
01ed:3c61	mov	al, byte ptr [0x854e]
01ed:3c64	mov	byte ptr [0x79b6], al
01ed:3c67	mov	byte ptr [0x854e], 1
        	loc_5b3c:
01ed:3c6c	call	0x3a88
01ed:3c6f	les	bx, ptr [0x9baa]
01ed:3c73	cmp	byte ptr es:[bx], 0xff
01ed:3c77	jne	loc_5b4f
01ed:3c79	mov	byte ptr [bp - 1], 1
01ed:3c7d	jmp	loc_5b5c
        	loc_5b4f:
01ed:3c7f	les	bx, ptr [0x9baa]
01ed:3c83	cmp	byte ptr es:[bx], 0
01ed:3c87	je	loc_5b5c
01ed:3c89	call	0x3c9d
        	loc_5b5c:
01ed:3c8c	inc	byte ptr [0x854e]
01ed:3c90	mov	al, byte ptr [bp - 1]
01ed:3c93	mov	ah, 0
01ed:3c95	or	ax, ax
01ed:3c97	je	loc_5b3c
01ed:3c99	mov	sp, bp
01ed:3c9b	pop	bp
01ed:3c9c	ret	
sub_5b1f ENDP
*/
void sub_5b1f()
{
    // coverage: 0x4e4f-0x4e9d method sub_5b1f
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5b2d;
    sub_ca53();
loc_5b2d:
    memoryASet(ss, bp - 1, 0x00);
    al = memoryAGet(ds, 0x854e);
    memoryASet(ds, 0x79b6, al);
    memoryASet(ds, 0x854e, 0x01);
loc_5b3c:
    sub_5958();
    bx = memoryAGet16(ds, 0x9baa);
    es = memoryAGet16(ds, 0x9baa + 2);
    if (memoryAGet(es, bx) != 0xff)
        goto loc_5b4f;
    memoryASet(ss, bp - 1, 0x01);
    goto loc_5b5c;
loc_5b4f:
    bx = memoryAGet16(ds, 0x9baa);
    es = memoryAGet16(ds, 0x9baa + 2);
    if (memoryAGet(es, bx) == 0x00)
        goto loc_5b5c;
    sub_5b6d();
loc_5b5c:
    memoryASet(ds, 0x854e, memoryAGet(ds, 0x854e) + 1);
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (!ax)
        goto loc_5b3c;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3c9d sub_5b6d()
sub_5b6d PROC
01ed:3c9d	push	bp
01ed:3c9e	mov	bp, sp
01ed:3ca0	cmp	word ptr [0x6b4c], sp
01ed:3ca4	ja	loc_5b79
01ed:3ca6	call	0xab83
        	loc_5b79:
01ed:3ca9	les	bx, ptr [0x8884]
01ed:3cad	mov	word ptr es:[bx + 4], 0x1da
01ed:3cb3	mov	al, byte ptr [0x854e]
01ed:3cb6	mov	ah, 0
01ed:3cb8	dec	ax
01ed:3cb9	shl	ax, 1
01ed:3cbb	shl	ax, 1
01ed:3cbd	les	bx, ptr [0x8554]
01ed:3cc1	add	bx, ax
01ed:3cc3	mov	ax, word ptr es:[bx]
01ed:3cc6	dec	ax
01ed:3cc7	les	bx, ptr [0x8884]
01ed:3ccb	mov	word ptr es:[bx], ax
01ed:3cce	mov	al, byte ptr [0x854e]
01ed:3cd1	mov	ah, 0
01ed:3cd3	dec	ax
01ed:3cd4	shl	ax, 1
01ed:3cd6	inc	ax
01ed:3cd7	shl	ax, 1
01ed:3cd9	les	bx, ptr [0x8554]
01ed:3cdd	add	bx, ax
01ed:3cdf	mov	ax, word ptr es:[bx]
01ed:3ce2	les	bx, ptr [0x8884]
01ed:3ce6	mov	word ptr es:[bx + 2], ax
01ed:3cea	push	ds
01ed:3ceb	mov	ax, 0x792e
01ed:3cee	push	ax
01ed:3cef	call	0x942a
01ed:3cf2	add	sp, 4
01ed:3cf5	pop	bp
01ed:3cf6	ret	
sub_5b6d ENDP
*/
void sub_5b6d()
{
    // coverage: 0x4e9d-0x4ef7 method sub_5b6d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5b79;
    sub_ca53();
loc_5b79:
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 4, 0x01da);
    al = memoryAGet(ds, 0x854e);
    ah = 0x00;
    ax--;
    ax <<= 1;
    ax <<= 1;
    bx = memoryAGet16(ds, 0x8554);
    es = memoryAGet16(ds, 0x8554 + 2);
    bx += ax;
    ax = memoryAGet16(es, bx);
    ax--;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx, ax);
    al = memoryAGet(ds, 0x854e);
    ah = 0x00;
    ax--;
    ax <<= 1;
    ax++;
    ax <<= 1;
    bx = memoryAGet16(ds, 0x8554);
    es = memoryAGet16(ds, 0x8554 + 2);
    bx += ax;
    ax = memoryAGet16(es, bx);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3cf7 sub_5bc7()
sub_5bc7 PROC
01ed:3cf7	push	bp
01ed:3cf8	mov	bp, sp
01ed:3cfa	sub	sp, 6
01ed:3cfd	cmp	word ptr [0x6b4c], sp
01ed:3d01	ja	loc_5bd6
01ed:3d03	call	0xab83
        	loc_5bd6:
01ed:3d06	mov	byte ptr [bp - 5], 0
01ed:3d0a	mov	byte ptr [0x792c], 0
01ed:3d0f	call	0x3c26
01ed:3d12	call	0x3c26
01ed:3d15	call	0x3a88
01ed:3d18	mov	ax, word ptr [0x9bac]
01ed:3d1b	mov	dx, word ptr [0x9baa]
01ed:3d1f	mov	word ptr [bp - 4], dx
01ed:3d22	mov	word ptr [bp - 2], ax
01ed:3d25	les	bx, ptr [bp - 4]
01ed:3d28	mov	al, byte ptr es:[bx]
01ed:3d2b	mov	ah, 0
01ed:3d2d	or	ax, ax
01ed:3d2f	je	loc_5c04
01ed:3d31	jmp	loc_5cc6
        	loc_5c04:
01ed:3d34	cmp	word ptr [0x689c], 4
01ed:3d39	je	loc_5c0f
01ed:3d3b	mov	al, 3
01ed:3d3d	jmp	loc_5c11
        	loc_5c0f:
01ed:3d3f	mov	al, 0x28
        	loc_5c11:
01ed:3d41	push	ax
01ed:3d42	call	0x6e11
01ed:3d45	inc	sp
01ed:3d46	inc	sp
01ed:3d47	mov	byte ptr [0x854f], 0xaa
01ed:3d4c	mov	ax, word ptr [0x9292]
01ed:3d4f	mov	word ptr [0x791e], ax
01ed:3d52	mov	ax, word ptr [0x9290]
01ed:3d55	mov	word ptr [0x791c], ax
01ed:3d58	mov	word ptr [0xa1ac], 0x1114
01ed:3d5e	mov	word ptr [0xa1ae], ds
01ed:3d62	mov	byte ptr [0x824d], 0x16
01ed:3d67	mov	ax, word ptr [0x9290]
01ed:3d6a	add	ax, 0xfff1
01ed:3d6d	mov	word ptr [0x9290], ax
01ed:3d70	mov	ax, word ptr [0x9292]
01ed:3d73	add	ax, 3
01ed:3d76	mov	word ptr [0x9292], ax
01ed:3d79	mov	word ptr [0x824a], 0xcb
01ed:3d7f	call	0x19e4
01ed:3d82	call	0x1cb2
01ed:3d85	call	0x1bd7
01ed:3d88	mov	ax, word ptr [0x9290]
01ed:3d8b	add	ax, 0xf
01ed:3d8e	mov	word ptr [0x9290], ax
01ed:3d91	mov	ax, word ptr [0x9292]
01ed:3d94	add	ax, 0xfffd
01ed:3d97	mov	word ptr [0x9292], ax
01ed:3d9a	mov	word ptr [0x824a], 0
01ed:3da0	call	0x138c
01ed:3da3	call	0x3dfd
01ed:3da6	call	0x1cb2
01ed:3da9	mov	ax, 1
01ed:3dac	push	ax
01ed:3dad	call	0x7bdd
01ed:3db0	inc	sp
01ed:3db1	inc	sp
01ed:3db2	call	0x1349
01ed:3db5	call	0x19e4
01ed:3db8	call	0x1bd7
01ed:3dbb	call	0x1cb2
01ed:3dbe	mov	ax, 1
01ed:3dc1	push	ax
01ed:3dc2	call	0x7bdd
01ed:3dc5	inc	sp
01ed:3dc6	inc	sp
01ed:3dc7	call	0x1349
        	loc_5c9a:
01ed:3dca	call	0x138c
01ed:3dcd	call	0x13df
01ed:3dd0	call	0x1473
01ed:3dd3	call	0x19e4
01ed:3dd6	call	0x1bd7
01ed:3dd9	call	0x1cb2
01ed:3ddc	mov	ax, 1
01ed:3ddf	push	ax
01ed:3de0	call	0x7bdd
01ed:3de3	inc	sp
01ed:3de4	inc	sp
01ed:3de5	call	0x1349
01ed:3de8	cmp	byte ptr [0x824d], 0
01ed:3ded	jne	loc_5c9a
01ed:3def	call	0x3e74
01ed:3df2	mov	byte ptr [bp - 5], 1
        	loc_5cc6:
01ed:3df6	mov	al, byte ptr [bp - 5]
01ed:3df9	mov	sp, bp
01ed:3dfb	pop	bp
01ed:3dfc	ret	
sub_5bc7 ENDP
*/
void sub_5bc7()
{
    // coverage: 0x4ef7-0x4ffd method sub_5bc7
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5bd6;
    sub_ca53();
loc_5bd6:
    memoryASet(ss, bp - 5, 0x00);
    memoryASet(ds, 0x792c, 0x00);
    sub_5af6();
    sub_5af6();
    sub_5958();
    ax = memoryAGet16(ds, 0x9bac);
    dx = memoryAGet16(ds, 0x9baa);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    al = memoryAGet(es, bx);
    ah = 0x00;
    if (!ax)
        goto loc_5c04;
    goto loc_5cc6;
loc_5c04:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_5c0f;
    al = 0x03;
    goto loc_5c11;
loc_5c0f:
    al = 0x28;
loc_5c11:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    memoryASet(ds, 0x854f, 0xaa);
    ax = memoryAGet16(ds, 0x9292);
    memoryASet16(ds, 0x791e, ax);
    ax = memoryAGet16(ds, 0x9290);
    memoryASet16(ds, 0x791c, ax);
    memoryASet16(ds, 0xa1ac, 0x1114);
    memoryASet16(ds, 0xa1ae, ds);
    memoryASet(ds, 0x824d, 0x16);
    ax = memoryAGet16(ds, 0x9290);
    ax += 0xfff1;
    memoryASet16(ds, 0x9290, ax);
    ax = memoryAGet16(ds, 0x9292);
    ax += 0x0003;
    memoryASet16(ds, 0x9292, ax);
    memoryASet16(ds, 0x824a, 0x00cb);
    sub_38b4();
    sub_3b82();
    sub_3aa7();
    ax = memoryAGet16(ds, 0x9290);
    ax += 0x000f;
    memoryASet16(ds, 0x9290, ax);
    ax = memoryAGet16(ds, 0x9292);
    ax += 0xfffd;
    memoryASet16(ds, 0x9292, ax);
    memoryASet16(ds, 0x824a, 0x0000);
    sub_325c();
    sub_5ccd();
    sub_3b82();
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_3219();
    sub_38b4();
    sub_3aa7();
    sub_3b82();
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_3219();
loc_5c9a:
    sub_325c();
    sub_32af();
    sub_3343();
    sub_38b4();
    sub_3aa7();
    sub_3b82();
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_3219();
    if (memoryAGet(ds, 0x824d) != 0x00)
        goto loc_5c9a;
    sub_5d44();
    memoryASet(ss, bp - 5, 0x01);
loc_5cc6:
    al = memoryAGet(ss, bp - 5);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3dfd sub_5ccd()
sub_5ccd PROC
01ed:3dfd	push	bp
01ed:3dfe	mov	bp, sp
01ed:3e00	push	si
01ed:3e01	push	di
01ed:3e02	cmp	word ptr [0x6b4c], sp
01ed:3e06	ja	loc_5cdb
01ed:3e08	call	0xab83
        	loc_5cdb:
01ed:3e0b	les	bx, ptr [0x8884]
01ed:3e0f	mov	di, word ptr es:[bx + 0x14]
01ed:3e13	mov	si, word ptr es:[bx + 0x16]
01ed:3e17	mov	ax, word ptr [0x9290]
01ed:3e1a	sub	ax, di
01ed:3e1c	add	ax, 0xe
01ed:3e1f	mov	cl, 4
01ed:3e21	sar	ax, cl
01ed:3e23	dec	ax
01ed:3e24	mov	word ptr [0x9d36], ax
01ed:3e27	mov	ax, word ptr [0x9292]
01ed:3e2a	sub	ax, si
01ed:3e2c	add	ax, 0xfff6
01ed:3e2f	sar	ax, 1
01ed:3e31	sar	ax, 1
01ed:3e33	sar	ax, 1
01ed:3e35	mov	word ptr [0x9d38], ax
01ed:3e38	cmp	word ptr [0x9d36], 0
01ed:3e3d	jge	loc_5d17
01ed:3e3f	mov	word ptr [0x9d36], 0
01ed:3e45	jmp	loc_5d24
        	loc_5d17:
01ed:3e47	cmp	word ptr [0x9d36], 0x12
01ed:3e4c	jle	loc_5d24
01ed:3e4e	mov	word ptr [0x9d36], 0x12
        	loc_5d24:
01ed:3e54	cmp	word ptr [0x9d38], 0
01ed:3e59	jge	loc_5d33
01ed:3e5b	mov	word ptr [0x9d38], 0
01ed:3e61	jmp	loc_5d40
        	loc_5d33:
01ed:3e63	cmp	word ptr [0x9d38], 0x16
01ed:3e68	jle	loc_5d40
01ed:3e6a	mov	word ptr [0x9d38], 0x16
        	loc_5d40:
01ed:3e70	pop	di
01ed:3e71	pop	si
01ed:3e72	pop	bp
01ed:3e73	ret	
sub_5ccd ENDP
*/
void sub_5ccd()
{
    // coverage: 0x4ffd-0x5074 method sub_5ccd
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5cdb;
    sub_ca53();
loc_5cdb:
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    di = memoryAGet16(es, bx + 20);
    si = memoryAGet16(es, bx + 22);
    ax = memoryAGet16(ds, 0x9290);
    ax -= di;
    ax += 0x000e;
    cl = 0x04;
    ax = sar(ax, cl);
    ax--;
    memoryASet16(ds, 0x9d36, ax);
    ax = memoryAGet16(ds, 0x9292);
    ax -= si;
    ax += 0xfff6;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet16(ds, 0x9d38, ax);
    if ((short)memoryAGet16(ds, 0x9d36) >= (short)0x0000)
        goto loc_5d17;
    memoryASet16(ds, 0x9d36, 0x0000);
    goto loc_5d24;
loc_5d17:
    if ((short)memoryAGet16(ds, 0x9d36) <= (short)0x0012)
        goto loc_5d24;
    memoryASet16(ds, 0x9d36, 0x0012);
loc_5d24:
    if ((short)memoryAGet16(ds, 0x9d38) >= (short)0x0000)
        goto loc_5d33;
    memoryASet16(ds, 0x9d38, 0x0000);
    goto loc_5d40;
loc_5d33:
    if ((short)memoryAGet16(ds, 0x9d38) <= (short)0x0016)
        goto loc_5d40;
    memoryASet16(ds, 0x9d38, 0x0016);
loc_5d40:
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3e74 sub_5d44()
sub_5d44 PROC
01ed:3e74	push	bp
01ed:3e75	mov	bp, sp
01ed:3e77	cmp	word ptr [0x6b4c], sp
01ed:3e7b	ja	loc_5d50
01ed:3e7d	call	0xab83
        	loc_5d50:
01ed:3e80	mov	al, 0x32
01ed:3e82	push	ax
01ed:3e83	call	0x5e7
01ed:3e86	inc	sp
01ed:3e87	inc	sp
01ed:3e88	pop	bp
01ed:3e89	ret	
sub_5d44 ENDP
*/
void sub_5d44()
{
    // coverage: 0x5074-0x508a method sub_5d44
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5d50;
    sub_ca53();
loc_5d50:
    al = 0x32;
    push(ax);
    sub_24b7();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3e8a sub_5d5a()
sub_5d5a PROC
01ed:3e8a	push	bp
01ed:3e8b	mov	bp, sp
01ed:3e8d	dec	sp
01ed:3e8e	dec	sp
01ed:3e8f	cmp	word ptr [0x6b4c], sp
01ed:3e93	ja	loc_5d68
01ed:3e95	call	0xab83
        	loc_5d68:
01ed:3e98	mov	al, 1
01ed:3e9a	mov	cl, al
01ed:3e9c	mov	byte ptr [bp - 1], al
01ed:3e9f	jmp	loc_5d88
        	loc_5d71:
01ed:3ea1	mov	al, cl
01ed:3ea3	mov	ah, 0
01ed:3ea5	mov	dx, 9
01ed:3ea8	imul	dx
01ed:3eaa	les	bx, ptr [0x8246]
01ed:3eae	add	bx, ax
01ed:3eb0	mov	al, byte ptr es:[bx]
01ed:3eb3	and	byte ptr [bp - 1], al
01ed:3eb6	inc	cl
        	loc_5d88:
01ed:3eb8	mov	al, cl
01ed:3eba	mov	ah, 0
01ed:3ebc	mov	dx, 9
01ed:3ebf	imul	dx
01ed:3ec1	les	bx, ptr [0x8246]
01ed:3ec5	add	bx, ax
01ed:3ec7	cmp	byte ptr es:[bx], 0xff
01ed:3ecb	jne	loc_5d71
01ed:3ecd	mov	al, byte ptr [bp - 1]
01ed:3ed0	mov	sp, bp
01ed:3ed2	pop	bp
01ed:3ed3	ret	
sub_5d5a ENDP
*/
void sub_5d5a()
{
    // coverage: 0x508a-0x50d4 method sub_5d5a
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5d68;
    sub_ca53();
loc_5d68:
    al = 0x01;
    cl = al;
    memoryASet(ss, bp - 1, al);
    goto loc_5d88;
loc_5d71:
    al = cl;
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    bx = memoryAGet16(ds, 0x8246);
    es = memoryAGet16(ds, 0x8246 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) & al);
    cl++;
loc_5d88:
    al = cl;
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    bx = memoryAGet16(ds, 0x8246);
    es = memoryAGet16(ds, 0x8246 + 2);
    bx += ax;
    if (memoryAGet(es, bx) != 0xff)
        goto loc_5d71;
    al = memoryAGet(ss, bp - 1);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:3ed4 sub_5da4()
sub_5da4 PROC
01ed:3ed4	push	bp
01ed:3ed5	mov	bp, sp
01ed:3ed7	sub	sp, 6
01ed:3eda	push	si
01ed:3edb	push	di
01ed:3edc	cmp	word ptr [0x6b4c], sp
01ed:3ee0	ja	loc_5db5
01ed:3ee2	call	0xab83
        	loc_5db5:
01ed:3ee5	call	0x5681
01ed:3ee8	mov	ax, 4
01ed:3eeb	push	ax
01ed:3eec	mov	ax, 0x11
01ed:3eef	push	ax
01ed:3ef0	call	0x736f
01ed:3ef3	add	sp, 4
01ed:3ef6	mov	si, ax
01ed:3ef8	xor	ax, ax
01ed:3efa	push	ax
01ed:3efb	push	word ptr [0x9da]
01ed:3eff	push	word ptr [0x9d8]
01ed:3f03	push	word ptr [0x7928]
01ed:3f07	push	word ptr [0x7926]
01ed:3f0b	push	si
01ed:3f0c	call	0x745e
01ed:3f0f	add	sp, 0xc
01ed:3f12	mov	word ptr [bp - 4], ax
01ed:3f15	mov	word ptr [bp - 2], dx
01ed:3f18	push	si
01ed:3f19	call	0x7319
01ed:3f1c	inc	sp
01ed:3f1d	inc	sp
01ed:3f1e	xor	ax, ax
01ed:3f20	mov	dx, 0x7d63
01ed:3f23	push	ax
01ed:3f24	push	dx
01ed:3f25	push	word ptr [bp - 2]
01ed:3f28	push	word ptr [bp - 4]
01ed:3f2b	push	word ptr [0x7928]
01ed:3f2f	push	word ptr [0x7926]
01ed:3f33	call	0x7b5a
01ed:3f36	add	sp, 0xc
01ed:3f39	cmp	word ptr [0x541d], 1
01ed:3f3e	jne	loc_5e47
01ed:3f40	mov	ax, word ptr [0x7928]
01ed:3f43	mov	dx, word ptr [0x7926]
01ed:3f47	mov	word ptr [0x9b96], dx
01ed:3f4b	mov	word ptr [0x9b98], ax
01ed:3f4e	mov	byte ptr [bp - 5], 0
01ed:3f52	jmp	loc_5e41
        	loc_5e24:
01ed:3f54	mov	al, byte ptr [bp - 5]
01ed:3f57	mov	ah, 0
01ed:3f59	les	bx, ptr [0x9b96]
01ed:3f5d	add	bx, ax
01ed:3f5f	mov	al, byte ptr [bp - 5]
01ed:3f62	mov	ah, 0
01ed:3f64	mov	di, ax
01ed:3f66	mov	al, byte ptr [di + 0x72e]
01ed:3f6a	mov	byte ptr es:[bx + 0x23], al
01ed:3f6e	inc	byte ptr [bp - 5]
        	loc_5e41:
01ed:3f71	cmp	byte ptr [bp - 5], 0x10
01ed:3f75	jb	loc_5e24
        	loc_5e47:
01ed:3f77	call	0x3467
01ed:3f7a	mov	ax, word ptr [0x7928]
01ed:3f7d	mov	dx, word ptr [0x7926]
01ed:3f81	add	dx, 0x63
01ed:3f84	les	bx, ptr [0x574]
01ed:3f88	mov	word ptr es:[bx + 2], dx
01ed:3f8c	mov	word ptr es:[bx + 4], ax
01ed:3f90	mov	word ptr es:[bx + 6], 0
01ed:3f96	mov	word ptr es:[bx + 8], 0
01ed:3f9c	mov	word ptr es:[bx + 0xa], 0x14
01ed:3fa2	mov	word ptr es:[bx + 0xc], 0x19
01ed:3fa8	mov	word ptr es:[bx + 0xe], 1
01ed:3fae	mov	word ptr es:[bx + 0x14], 0
01ed:3fb4	mov	word ptr es:[bx + 0x16], 0
01ed:3fba	mov	word ptr es:[bx + 0x1c], 0
01ed:3fc0	mov	word ptr es:[bx + 0x1e], 0x14
01ed:3fc6	mov	word ptr es:[bx + 0x20], 0x19
01ed:3fcc	push	word ptr [0x576]
01ed:3fd0	push	word ptr [0x574]
01ed:3fd4	call	0x80bc
01ed:3fd7	add	sp, 4
01ed:3fda	xor	ax, ax
01ed:3fdc	push	ax
01ed:3fdd	push	word ptr [0x7928]
01ed:3fe1	push	word ptr [0x7926]
01ed:3fe5	call	0x7b93
01ed:3fe8	add	sp, 6
01ed:3feb	xor	ax, ax
01ed:3fed	push	ax
01ed:3fee	call	0x7bca
01ed:3ff1	inc	sp
01ed:3ff2	inc	sp
01ed:3ff3	mov	ax, 1
01ed:3ff6	push	ax
01ed:3ff7	call	0x7bdd
01ed:3ffa	inc	sp
01ed:3ffb	inc	sp
01ed:3ffc	call	0x9864
01ed:3fff	mov	byte ptr [0x8244], 0
01ed:4004	call	0x328f
01ed:4007	mov	al, 1
01ed:4009	mov	byte ptr [0x79b2], al
01ed:400c	mov	byte ptr [0x928d], al
01ed:400f	pop	di
01ed:4010	pop	si
01ed:4011	mov	sp, bp
01ed:4013	pop	bp
01ed:4014	ret	
sub_5da4 ENDP
*/
void sub_5da4()
{
    // coverage: 0x50d4-0x5215 method sub_5da4
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5db5;
    sub_ca53();
loc_5db5:
    sub_7551();
    ax = 0x0004;
    push(ax);
    ax = 0x0011;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x09da));
    push(memoryAGet16(ds, 0x09d8));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a2a();
    sp += 0x000c;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_5e47;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 5, 0x00);
    goto loc_5e41;
loc_5e24:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1838);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) + 1);
loc_5e41:
    if (memoryAGet(ss, bp - 5) < 0x10)
        goto loc_5e24;
loc_5e47:
    sub_5337();
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    dx += 0x0063;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x7928));
    push(memoryAGet16(ds, 0x7926));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_b734();
    memoryASet(ds, 0x8244, 0x00);
    sub_515f();
    al = 0x01;
    memoryASet(ds, 0x79b2, al);
    memoryASet(ds, 0x928d, al);
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4015 sub_5ee5()
sub_5ee5 PROC
01ed:4015	push	bp
01ed:4016	mov	bp, sp
01ed:4018	sub	sp, 0x36
01ed:401b	push	si
01ed:401c	push	di
01ed:401d	cmp	word ptr [0x6b4c], sp
01ed:4021	ja	loc_5ef6
01ed:4023	call	0xab83
        	loc_5ef6:
01ed:4026	mov	byte ptr [bp - 5], 0
01ed:402a	push	ss
01ed:402b	lea	ax, [bp - 0x26]
01ed:402e	push	ax
01ed:402f	push	ds
01ed:4030	mov	ax, 0x11b6
01ed:4033	push	ax
01ed:4034	mov	cx, 0x20
01ed:4037	call	0xa9f5
01ed:403a	push	ss
01ed:403b	lea	ax, [bp - 0x36]
01ed:403e	push	ax
01ed:403f	push	ds
01ed:4040	mov	ax, 0x11d6
01ed:4043	push	ax
01ed:4044	mov	cx, 0x10
01ed:4047	call	0xa9f5
01ed:404a	xor	ax, ax
01ed:404c	push	ax
01ed:404d	call	0x9410
01ed:4050	inc	sp
01ed:4051	inc	sp
01ed:4052	xor	ax, ax
01ed:4054	push	ax
01ed:4055	call	0x9814
01ed:4058	inc	sp
01ed:4059	inc	sp
01ed:405a	push	ds
01ed:405b	mov	ax, 0x90
01ed:405e	push	ax
01ed:405f	call	0x7307
01ed:4062	add	sp, 4
01ed:4065	push	word ptr [0x119c]
01ed:4069	call	0x93a4
01ed:406c	inc	sp
01ed:406d	inc	sp
01ed:406e	mov	ax, 4
01ed:4071	push	ax
01ed:4072	mov	ax, 1
01ed:4075	push	ax
01ed:4076	call	0x736f
01ed:4079	add	sp, 4
01ed:407c	mov	di, ax
01ed:407e	xor	ax, ax
01ed:4080	push	ax
01ed:4081	mov	dx, 0x63
01ed:4084	push	ax
01ed:4085	push	dx
01ed:4086	push	word ptr [0x6bea]
01ed:408a	push	word ptr [0x6be8]
01ed:408e	push	di
01ed:408f	call	0x745e
01ed:4092	add	sp, 0xc
01ed:4095	push	di
01ed:4096	call	0x7319
01ed:4099	inc	sp
01ed:409a	inc	sp
01ed:409b	cmp	word ptr [0x541d], 1
01ed:40a0	jne	loc_5fad
01ed:40a2	mov	ax, word ptr [0x6bea]
01ed:40a5	mov	dx, word ptr [0x6be8]
01ed:40a9	mov	word ptr [0x9b96], dx
01ed:40ad	mov	word ptr [0x9b98], ax
01ed:40b0	mov	byte ptr [bp - 1], 0
01ed:40b4	jmp	loc_5fa7
        	loc_5f86:
01ed:40b6	mov	al, byte ptr [bp - 1]
01ed:40b9	mov	ah, 0
01ed:40bb	les	bx, ptr [0x9b96]
01ed:40bf	add	bx, ax
01ed:40c1	mov	al, byte ptr [bp - 1]
01ed:40c4	mov	ah, 0
01ed:40c6	push	es
01ed:40c7	push	bx
01ed:40c8	mov	bx, ax
01ed:40ca	mov	al, byte ptr [bx + 0x65a]
01ed:40ce	pop	bx
01ed:40cf	pop	es
01ed:40d0	mov	byte ptr es:[bx + 0x23], al
01ed:40d4	inc	byte ptr [bp - 1]
        	loc_5fa7:
01ed:40d7	cmp	byte ptr [bp - 1], 0x10
01ed:40db	jb	loc_5f86
        	loc_5fad:
01ed:40dd	mov	byte ptr [bp - 1], 0
01ed:40e1	jmp	loc_5fd3
        	loc_5fb3:
01ed:40e3	mov	al, byte ptr [bp - 1]
01ed:40e6	mov	ah, 0
01ed:40e8	shl	ax, 1
01ed:40ea	mov	bx, ax
01ed:40ec	mov	ax, word ptr [bx + 0x73e]
01ed:40f0	mov	dl, byte ptr [bp - 1]
01ed:40f3	mov	dh, 0
01ed:40f5	shl	dx, 1
01ed:40f7	les	bx, ptr [0x6bca]
01ed:40fb	add	bx, dx
01ed:40fd	mov	word ptr es:[bx], ax
01ed:4100	inc	byte ptr [bp - 1]
        	loc_5fd3:
01ed:4103	cmp	byte ptr [bp - 1], 0x10
01ed:4107	jb	loc_5fb3
01ed:4109	call	0x63b
01ed:410c	mov	byte ptr [bp - 5], 0
01ed:4110	jmp	loc_6112
        	loc_5fe3:
01ed:4113	call	0x93b1
01ed:4116	and	ax, 0xf
01ed:4119	mov	si, ax
01ed:411b	cmp	ax, 2
01ed:411e	jl	loc_5fe3
01ed:4120	mov	al, byte ptr [bp + si - 0x36]
01ed:4123	mov	byte ptr [bp - 4], al
01ed:4126	mov	al, 0
01ed:4128	mov	byte ptr [bp - 3], al
01ed:412b	mov	byte ptr [bp - 2], al
01ed:412e	mov	byte ptr [0x119a], 1
01ed:4133	call	0x3467
01ed:4136	push	ds
01ed:4137	mov	ax, 0x578
01ed:413a	push	ax
01ed:413b	call	0x8d1
01ed:413e	add	sp, 4
01ed:4141	mov	bx, si
01ed:4143	shl	bx, 1
01ed:4145	lea	ax, [bp - 0x26]
01ed:4148	add	bx, ax
01ed:414a	mov	ax, word ptr ss:[bx]
01ed:414d	les	bx, ptr [0x8884]
01ed:4151	mov	word ptr es:[bx + 4], ax
01ed:4155	mov	word ptr es:[bx], 0x90
01ed:415a	mov	word ptr es:[bx + 2], 0x64
01ed:4160	push	ds
01ed:4161	mov	ax, 0x792e
01ed:4164	push	ax
01ed:4165	call	0x942a
01ed:4168	add	sp, 4
01ed:416b	mov	ax, 0x87
01ed:416e	push	ax
01ed:416f	mov	ax, 0x54
01ed:4172	push	ax
01ed:4173	push	ds
01ed:4174	mov	ax, 0x1331
01ed:4177	push	ax
01ed:4178	call	0x7f0
01ed:417b	add	sp, 8
01ed:417e	mov	ax, 0x96
01ed:4181	push	ax
01ed:4182	mov	ax, 0x98
01ed:4185	push	ax
01ed:4186	mov	al, 2
01ed:4188	push	ax
01ed:4189	mov	al, byte ptr [bp - 2]
01ed:418c	mov	ah, 0
01ed:418e	cdq	
01ed:418f	push	dx
01ed:4190	push	ax
01ed:4191	call	0x816
01ed:4194	add	sp, 0xa
01ed:4197	jmp	loc_60e0
        	loc_6069:
01ed:4199	mov	byte ptr [0x8244], 0
01ed:419e	call	0x1dde
01ed:41a1	test	byte ptr [0x8244], 0x10
01ed:41a6	je	loc_607e
01ed:41a8	mov	byte ptr [bp - 3], 1
01ed:41ac	jmp	loc_60bf
        	loc_607e:
01ed:41ae	test	byte ptr [0x8244], 4
01ed:41b3	je	loc_609c
01ed:41b5	cmp	byte ptr [bp - 2], 0
01ed:41b9	je	loc_609c
01ed:41bb	dec	byte ptr [bp - 2]
01ed:41be	mov	ax, 0x96
01ed:41c1	push	ax
01ed:41c2	mov	ax, 0x98
01ed:41c5	push	ax
01ed:41c6	push	ds
01ed:41c7	mov	ax, 0x134b
01ed:41ca	jmp	loc_60b8
        	loc_609c:
01ed:41cc	test	byte ptr [0x8244], 8
01ed:41d1	je	loc_60bf
01ed:41d3	cmp	byte ptr [bp - 2], 0x63
01ed:41d7	jae	loc_60bf
01ed:41d9	inc	byte ptr [bp - 2]
01ed:41dc	mov	ax, 0x96
01ed:41df	push	ax
01ed:41e0	mov	ax, 0x98
01ed:41e3	push	ax
01ed:41e4	push	ds
01ed:41e5	mov	ax, 0x1350
        	loc_60b8:
01ed:41e8	push	ax
01ed:41e9	call	0x7f0
01ed:41ec	add	sp, 8
        	loc_60bf:
01ed:41ef	mov	ax, 0x96
01ed:41f2	push	ax
01ed:41f3	mov	ax, 0x98
01ed:41f6	push	ax
01ed:41f7	mov	al, 2
01ed:41f9	push	ax
01ed:41fa	mov	al, byte ptr [bp - 2]
01ed:41fd	mov	ah, 0
01ed:41ff	cdq	
01ed:4200	push	dx
01ed:4201	push	ax
01ed:4202	call	0x816
01ed:4205	add	sp, 0xa
01ed:4208	mov	al, 4
01ed:420a	push	ax
01ed:420b	call	0x5e7
01ed:420e	inc	sp
01ed:420f	inc	sp
        	loc_60e0:
01ed:4210	mov	al, byte ptr [bp - 3]
01ed:4213	mov	ah, 0
01ed:4215	or	ax, ax
01ed:4217	je	loc_6069
01ed:4219	mov	al, byte ptr [bp - 2]
01ed:421c	mov	byte ptr [bp - 4], al
01ed:421f	jmp	loc_610e
01ed:4221		
        	loc_610e:
01ed:423e	mov	byte ptr [bp - 5], 0xff
        	loc_6112:
01ed:4242	cmp	byte ptr [bp - 5], 3
01ed:4246	jae	loc_611b
01ed:4248	jmp	loc_5fe3
        	loc_611b:
01ed:424b	mov	ax, 1
01ed:424e	push	ax
01ed:424f	call	0x9814
01ed:4252	inc	sp
01ed:4253	inc	sp
01ed:4254	mov	ax, 1
01ed:4257	push	ax
01ed:4258	call	0x9410
01ed:425b	inc	sp
01ed:425c	inc	sp
01ed:425d	pop	di
01ed:425e	pop	si
01ed:425f	mov	sp, bp
01ed:4261	pop	bp
01ed:4262	ret	
sub_5ee5 ENDP
*/
void sub_5ee5()
{
    // coverage: 0x5215-0x5421 method sub_5ee5
    // coverage: 0x543e-0x5463 method sub_5ee5
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0036;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_5ef6;
    sub_ca53();
loc_5ef6:
    memoryASet(ss, bp - 5, 0x00);
    push(ss);
    ax = bp - 0x26;
    push(ax);
    push(ds);
    ax = 0x11b6;
    push(ax);
    cx = 0x0020;
    sub_c8c5();
    push(ss);
    ax = bp - 0x36;
    push(ax);
    push(ds);
    ax = 0x11d6;
    push(ax);
    cx = 0x0010;
    sub_c8c5();
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b6e4();
    sp++;
    sp++;
    push(ds);
    ax = 0x0090;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    push(memoryAGet16(ds, 0x119c));
    sub_b274();
    sp++;
    sp++;
    ax = 0x0004;
    push(ax);
    ax = 0x0001;
    push(ax);
    sub_923f();
    sp += 0x0004;
    di = ax;
    ax = 0;
    push(ax);
    dx = 0x0063;
    push(ax);
    push(dx);
    push(memoryAGet16(ds, 0x6bea));
    push(memoryAGet16(ds, 0x6be8));
    push(di);
    sub_932e();
    sp += 0x000c;
    push(di);
    sub_91e9();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_5fad;
    ax = memoryAGet16(ds, 0x6bea);
    dx = memoryAGet16(ds, 0x6be8);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 1, 0x00);
    goto loc_5fa7;
loc_5f86:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    push(es);
    push(bx);
    bx = ax;
    al = memoryAGet(ds, bx + 1626);
    bx = pop();
    es = pop();
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_5fa7:
    if (memoryAGet(ss, bp - 1) < 0x10)
        goto loc_5f86;
loc_5fad:
    memoryASet(ss, bp - 1, 0x00);
    goto loc_5fd3;
loc_5fb3:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 1854);
    dl = memoryAGet(ss, bp - 1);
    dh = 0x00;
    dx <<= 1;
    bx = memoryAGet16(ds, 0x6bca);
    es = memoryAGet16(ds, 0x6bca + 2);
    bx += dx;
    memoryASet16(es, bx, ax);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_5fd3:
    if (memoryAGet(ss, bp - 1) < 0x10)
        goto loc_5fb3;
    sub_250b();
    memoryASet(ss, bp - 5, 0x00);
    goto loc_6112;
loc_5fe3:
    sub_b281();
    ax &= 0x000f;
    si = ax;
    if ((short)ax < (short)0x0002)
        goto loc_5fe3;
    al = memoryAGet(ss, bp + si + 65482);
    memoryASet(ss, bp - 4, al);
    al = 0x00;
    memoryASet(ss, bp - 3, al);
    memoryASet(ss, bp - 2, al);
    memoryASet(ds, 0x119a, 0x01);
    sub_5337();
    push(ds);
    ax = 0x0578;
    push(ax);
    sub_27a1();
    sp += 0x0004;
    bx = si;
    bx <<= 1;
    ax = bp - 0x26;
    bx += ax;
    ax = memoryAGet16(ss, bx);
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx, 0x0090);
    memoryASet16(es, bx + 2, 0x0064);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    ax = 0x0087;
    push(ax);
    ax = 0x0054;
    push(ax);
    push(ds);
    ax = 0x1331;
    push(ax);
    sub_26c0();
    sp += 0x0008;
    ax = 0x0096;
    push(ax);
    ax = 0x0098;
    push(ax);
    al = 0x02;
    push(ax);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    dx = ax & 0x8000 ? 0xffff : 0x0000;
    push(dx);
    push(ax);
    sub_26e6();
    sp += 0x000a;
    goto loc_60e0;
loc_6069:
    memoryASet(ds, 0x8244, 0x00);
    sub_3cae();
    if (!(memoryAGet(ds, 0x8244) & 0x10))
        goto loc_607e;
    memoryASet(ss, bp - 3, 0x01);
    goto loc_60bf;
loc_607e:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_609c;
    if (memoryAGet(ss, bp - 2) == 0x00)
        goto loc_609c;
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) - 1);
    ax = 0x0096;
    push(ax);
    ax = 0x0098;
    push(ax);
    push(ds);
    ax = 0x134b;
    goto loc_60b8;
loc_609c:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_60bf;
    if (memoryAGet(ss, bp - 2) >= 0x63)
        goto loc_60bf;
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
    ax = 0x0096;
    push(ax);
    ax = 0x0098;
    push(ax);
    push(ds);
    ax = 0x1350;
loc_60b8:
    push(ax);
    sub_26c0();
    sp += 0x0008;
loc_60bf:
    ax = 0x0096;
    push(ax);
    ax = 0x0098;
    push(ax);
    al = 0x02;
    push(ax);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    dx = ax & 0x8000 ? 0xffff : 0x0000;
    push(dx);
    push(ax);
    sub_26e6();
    sp += 0x000a;
    al = 0x04;
    push(ax);
    sub_24b7();
    sp++;
    sp++;
loc_60e0:
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    if (!ax)
        goto loc_6069;
    al = memoryAGet(ss, bp - 2);
    memoryASet(ss, bp - 4, al);
    goto loc_610e;
    //   gap of 29 bytes
loc_610e:
    memoryASet(ss, bp - 5, 0xff);
loc_6112:
    if (memoryAGet(ss, bp - 5) >= 0x03)
        goto loc_611b;
    goto loc_5fe3;
loc_611b:
    ax = 0x0001;
    push(ax);
    sub_b6e4();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4263 sub_6133()
sub_6133 PROC
01ed:4263	push	bp
01ed:4264	mov	bp, sp
01ed:4266	sub	sp, 4
01ed:4269	cmp	word ptr [0x6b4c], sp
01ed:426d	ja	loc_6142
01ed:426f	call	0xab83
        	loc_6142:
01ed:4272	mov	byte ptr [0x8244], 0
01ed:4277	mov	al, byte ptr [0x8242]
01ed:427a	mov	ah, 0
01ed:427c	or	ax, ax
01ed:427e	jne	loc_61a5
01ed:4280	mov	al, byte ptr [bp + 4]
01ed:4283	mov	byte ptr [0x792c], al
01ed:4286	cmp	byte ptr [0x792c], 5
01ed:428b	je	loc_61a5
01ed:428d	cmp	byte ptr [0x792c], 0xb
01ed:4292	je	loc_61a5
01ed:4294	cmp	byte ptr [0x792c], 0x1c
01ed:4299	je	loc_61a5
01ed:429b	mov	byte ptr [0xa0dc], 0
01ed:42a0	mov	ah, 0
01ed:42a2	shl	ax, 1
01ed:42a4	shl	ax, 1
01ed:42a6	mov	bx, ax
01ed:42a8	mov	ax, word ptr [bx + 0x2254]
01ed:42ac	mov	dx, word ptr [bx + 0x2252]
01ed:42b0	mov	word ptr [bp - 4], dx
01ed:42b3	mov	word ptr [bp - 2], ax
01ed:42b6	les	bx, ptr [bp - 4]
01ed:42b9	mov	al, byte ptr es:[bx]
01ed:42bc	mov	byte ptr [0x824d], al
01ed:42bf	mov	al, byte ptr es:[bx + 1]
01ed:42c3	mov	byte ptr [0x9bae], al
01ed:42c6	mov	ax, word ptr es:[bx + 4]
01ed:42ca	mov	dx, word ptr es:[bx + 2]
01ed:42ce	mov	word ptr [0xa1ac], dx
01ed:42d2	mov	word ptr [0xa1ae], ax
        	loc_61a5:
01ed:42d5	mov	sp, bp
01ed:42d7	pop	bp
01ed:42d8	ret	
sub_6133 ENDP
*/
void sub_6133()
{
    // coverage: 0x5463-0x54d9 method sub_6133
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6142;
    sub_ca53();
loc_6142:
    memoryASet(ds, 0x8244, 0x00);
    al = memoryAGet(ds, 0x8242);
    ah = 0x00;
    if (ax)
        goto loc_61a5;
    al = memoryAGet(ss, bp + 4);
    memoryASet(ds, 0x792c, al);
    if (memoryAGet(ds, 0x792c) == 0x05)
        goto loc_61a5;
    if (memoryAGet(ds, 0x792c) == 0x0b)
        goto loc_61a5;
    if (memoryAGet(ds, 0x792c) == 0x1c)
        goto loc_61a5;
    memoryASet(ds, 0xa0dc, 0x00);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 8788);
    dx = memoryAGet16(ds, bx + 8786);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ds, 0x824d, al);
    al = memoryAGet(es, bx + 1);
    memoryASet(ds, 0x9bae, al);
    ax = memoryAGet16(es, bx + 4);
    dx = memoryAGet16(es, bx + 2);
    memoryASet16(ds, 0xa1ac, dx);
    memoryASet16(ds, 0xa1ae, ax);
loc_61a5:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:42d9 sub_61a9()
sub_61a9 PROC
01ed:42d9	push	bp
01ed:42da	mov	bp, sp
01ed:42dc	cmp	word ptr [0x6b4c], sp
01ed:42e0	ja	loc_61b5
01ed:42e2	call	0xab83
        	loc_61b5:
01ed:42e5	cmp	word ptr [0x689c], 4
01ed:42ea	je	loc_61c0
01ed:42ec	mov	al, 3
01ed:42ee	jmp	loc_61c2
        	loc_61c0:
01ed:42f0	mov	al, 0xd
        	loc_61c2:
01ed:42f2	push	ax
01ed:42f3	call	0x6e11
01ed:42f6	inc	sp
01ed:42f7	inc	sp
01ed:42f8	mov	al, 0x2d
01ed:42fa	push	ax
01ed:42fb	call	0x4263
01ed:42fe	inc	sp
01ed:42ff	inc	sp
01ed:4300	call	0x238e
01ed:4303	pop	bp
01ed:4304	ret	
sub_61a9 ENDP
*/
void sub_61a9()
{
    // coverage: 0x54d9-0x5505 method sub_61a9
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_61b5;
    sub_ca53();
loc_61b5:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_61c0;
    al = 0x03;
    goto loc_61c2;
loc_61c0:
    al = 0x0d;
loc_61c2:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x2d;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4305 sub_61d5()
sub_61d5 PROC
01ed:4305	push	bp
01ed:4306	mov	bp, sp
01ed:4308	cmp	word ptr [0x6b4c], sp
01ed:430c	ja	loc_61e1
01ed:430e	call	0xab83
        	loc_61e1:
01ed:4311	mov	byte ptr [0x792c], 0x1c
01ed:4316	call	0x4361
01ed:4319	pop	bp
01ed:431a	ret	
sub_61d5 ENDP
*/
void sub_61d5()
{
    // coverage: 0x5505-0x551b method sub_61d5
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_61e1;
    sub_ca53();
loc_61e1:
    memoryASet(ds, 0x792c, 0x1c);
    sub_6231();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:431b sub_61eb()
sub_61eb PROC
01ed:431b	push	bp
01ed:431c	mov	bp, sp
01ed:431e	cmp	word ptr [0x6b4c], sp
01ed:4322	ja	loc_61f7
01ed:4324	call	0xab83
        	loc_61f7:
01ed:4327	test	byte ptr [0x8244], 4
01ed:432c	je	loc_6203
01ed:432e	call	0x2634
01ed:4331	jmp	loc_6212
        	loc_6203:
01ed:4333	test	byte ptr [0x8244], 8
01ed:4338	je	loc_620f
01ed:433a	call	0x26a1
01ed:433d	jmp	loc_6212
        	loc_620f:
01ed:433f	call	0x4361
        	loc_6212:
01ed:4342	pop	bp
01ed:4343	ret	
sub_61eb ENDP
*/
void sub_61eb()
{
    // coverage: 0x551b-0x5544 method sub_61eb
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_61f7;
    sub_ca53();
loc_61f7:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_6203;
    sub_4504();
    goto loc_6212;
loc_6203:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_620f;
    sub_4571();
    goto loc_6212;
loc_620f:
    sub_6231();
loc_6212:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4344 sub_6214()
sub_6214 PROC
01ed:4344	push	bp
01ed:4345	mov	bp, sp
01ed:4347	cmp	word ptr [0x6b4c], sp
01ed:434b	ja	loc_6220
01ed:434d	call	0xab83
        	loc_6220:
01ed:4350	test	byte ptr [0x8244], 0x10
01ed:4355	je	loc_622c
01ed:4357	call	0x431b
01ed:435a	jmp	loc_622f
        	loc_622c:
01ed:435c	call	0x4398
        	loc_622f:
01ed:435f	pop	bp
01ed:4360	ret	
sub_6214 ENDP
*/
void sub_6214()
{
    // coverage: 0x5544-0x5561 method sub_6214
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6220;
    sub_ca53();
loc_6220:
    if (!(memoryAGet(ds, 0x8244) & 0x10))
        goto loc_622c;
    sub_61eb();
    goto loc_622f;
loc_622c:
    sub_6268();
loc_622f:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4361 sub_6231()
sub_6231 PROC
01ed:4361	push	bp
01ed:4362	mov	bp, sp
01ed:4364	sub	sp, 6
01ed:4367	cmp	word ptr [0x6b4c], sp
01ed:436b	ja	loc_6240
01ed:436d	call	0xab83
        	loc_6240:
01ed:4370	mov	byte ptr [bp - 1], 0x15
01ed:4374	mov	byte ptr [bp - 2], 4
01ed:4378	mov	word ptr [bp - 6], 0x1b70
01ed:437d	mov	word ptr [bp - 4], ds
01ed:4380	push	word ptr [bp - 4]
01ed:4383	push	word ptr [bp - 6]
01ed:4386	mov	al, byte ptr [bp - 2]
01ed:4389	push	ax
01ed:438a	mov	al, byte ptr [bp - 1]
01ed:438d	push	ax
01ed:438e	call	0x495c
01ed:4391	add	sp, 8
01ed:4394	mov	sp, bp
01ed:4396	pop	bp
01ed:4397	ret	
sub_6231 ENDP
*/
void sub_6231()
{
    // coverage: 0x5561-0x5598 method sub_6231
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6240;
    sub_ca53();
loc_6240:
    memoryASet(ss, bp - 1, 0x15);
    memoryASet(ss, bp - 2, 0x04);
    memoryASet16(ss, bp - 6, 0x1b70);
    memoryASet16(ss, bp - 4, ds);
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_682c();
    sp += 0x0008;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4398 sub_6268()
sub_6268 PROC
01ed:4398	push	bp
01ed:4399	mov	bp, sp
01ed:439b	cmp	word ptr [0x6b4c], sp
01ed:439f	ja	loc_6274
01ed:43a1	call	0xab83
        	loc_6274:
01ed:43a4	test	byte ptr [0x8244], 1
01ed:43a9	je	loc_6280
01ed:43ab	call	0x4454
01ed:43ae	jmp	loc_6283
        	loc_6280:
01ed:43b0	call	0x43b5
        	loc_6283:
01ed:43b3	pop	bp
01ed:43b4	ret	
sub_6268 ENDP
*/
void sub_6268()
{
    // coverage: 0x5598-0x55b5 method sub_6268
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6274;
    sub_ca53();
loc_6274:
    if (!(memoryAGet(ds, 0x8244) & 0x01))
        goto loc_6280;
    sub_6324();
    goto loc_6283;
loc_6280:
    sub_6285();
loc_6283:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:43b5 sub_6285()
sub_6285 PROC
01ed:43b5	push	bp
01ed:43b6	mov	bp, sp
01ed:43b8	cmp	word ptr [0x6b4c], sp
01ed:43bc	ja	loc_6291
01ed:43be	call	0xab83
        	loc_6291:
01ed:43c1	test	byte ptr [0x8244], 2
01ed:43c6	je	loc_629d
01ed:43c8	call	0x448a
01ed:43cb	jmp	loc_62a0
        	loc_629d:
01ed:43cd	call	0x43d2
        	loc_62a0:
01ed:43d0	pop	bp
01ed:43d1	ret	
sub_6285 ENDP
*/
void sub_6285()
{
    // coverage: 0x55b5-0x55d2 method sub_6285
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6291;
    sub_ca53();
loc_6291:
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_629d;
    sub_635a();
    goto loc_62a0;
loc_629d:
    sub_62a2();
loc_62a0:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:43d2 sub_62a2()
sub_62a2 PROC
01ed:43d2	push	bp
01ed:43d3	mov	bp, sp
01ed:43d5	cmp	word ptr [0x6b4c], sp
01ed:43d9	ja	loc_62ae
01ed:43db	call	0xab83
        	loc_62ae:
01ed:43de	test	byte ptr [0x8244], 4
01ed:43e3	je	loc_62ba
01ed:43e5	call	0x44c0
01ed:43e8	jmp	loc_62bd
        	loc_62ba:
01ed:43ea	call	0x43ef
        	loc_62bd:
01ed:43ed	pop	bp
01ed:43ee	ret	
sub_62a2 ENDP
*/
void sub_62a2()
{
    // coverage: 0x55d2-0x55ef method sub_62a2
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_62ae;
    sub_ca53();
loc_62ae:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_62ba;
    sub_6390();
    goto loc_62bd;
loc_62ba:
    sub_62bf();
loc_62bd:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:43ef sub_62bf()
sub_62bf PROC
01ed:43ef	push	bp
01ed:43f0	mov	bp, sp
01ed:43f2	cmp	word ptr [0x6b4c], sp
01ed:43f6	ja	loc_62cb
01ed:43f8	call	0xab83
        	loc_62cb:
01ed:43fb	test	byte ptr [0x8244], 8
01ed:4400	je	loc_62d7
01ed:4402	call	0x4532
01ed:4405	jmp	loc_62da
        	loc_62d7:
01ed:4407	call	0x440c
        	loc_62da:
01ed:440a	pop	bp
01ed:440b	ret	
sub_62bf ENDP
*/
void sub_62bf()
{
    // coverage: 0x55ef-0x560c method sub_62bf
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_62cb;
    sub_ca53();
loc_62cb:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_62d7;
    sub_6402();
    goto loc_62da;
loc_62d7:
    sub_62dc();
loc_62da:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:440c sub_62dc()
sub_62dc PROC
01ed:440c	push	bp
01ed:440d	mov	bp, sp
01ed:440f	cmp	word ptr [0x6b4c], sp
01ed:4413	ja	loc_62e8
01ed:4415	call	0xab83
        	loc_62e8:
01ed:4418	mov	al, byte ptr [0x856e]
01ed:441b	mov	byte ptr [0x856f], al
01ed:441e	call	0x236f
01ed:4421	cmp	byte ptr [0x7924], 0x16
01ed:4426	jne	loc_62fd
01ed:4428	call	0x4305
01ed:442b	jmp	loc_6305
        	loc_62fd:
01ed:442d	mov	al, 0x2f
01ed:442f	push	ax
01ed:4430	call	0x6d94
01ed:4433	inc	sp
01ed:4434	inc	sp
        	loc_6305:
01ed:4435	pop	bp
01ed:4436	ret	
sub_62dc ENDP
*/
void sub_62dc()
{
    // coverage: 0x560c-0x5637 method sub_62dc
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_62e8;
    sub_ca53();
loc_62e8:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    sub_423f();
    if (memoryAGet(ds, 0x7924) != 0x16)
        goto loc_62fd;
    sub_61d5();
    goto loc_6305;
loc_62fd:
    al = 0x2f;
    push(ax);
    sub_8c64();
    sp++;
    sp++;
loc_6305:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4437 sub_6307()
sub_6307 PROC
01ed:4437	push	bp
01ed:4438	mov	bp, sp
01ed:443a	cmp	word ptr [0x6b4c], sp
01ed:443e	ja	loc_6313
01ed:4440	call	0xab83
        	loc_6313:
01ed:4443	test	byte ptr [0x8244], 0x10
01ed:4448	je	loc_631f
01ed:444a	call	0x440c
01ed:444d	jmp	loc_6322
        	loc_631f:
01ed:444f	call	0x4398
        	loc_6322:
01ed:4452	pop	bp
01ed:4453	ret	
sub_6307 ENDP
*/
void sub_6307()
{
    // coverage: 0x5637-0x5654 method sub_6307
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6313;
    sub_ca53();
loc_6313:
    if (!(memoryAGet(ds, 0x8244) & 0x10))
        goto loc_631f;
    sub_62dc();
    goto loc_6322;
loc_631f:
    sub_6268();
loc_6322:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4454 sub_6324()
sub_6324 PROC
01ed:4454	push	bp
01ed:4455	mov	bp, sp
01ed:4457	cmp	word ptr [0x6b4c], sp
01ed:445b	ja	loc_6330
01ed:445d	call	0xab83
        	loc_6330:
01ed:4460	cmp	byte ptr [0x856e], 8
01ed:4465	jae	loc_633c
01ed:4467	call	0x43b5
01ed:446a	jmp	loc_6358
        	loc_633c:
01ed:446c	mov	al, byte ptr [0x856e]
01ed:446f	add	al, 0xf8
01ed:4471	push	ax
01ed:4472	call	0x45cf
01ed:4475	inc	sp
01ed:4476	inc	sp
01ed:4477	or	al, al
01ed:4479	je	loc_6350
01ed:447b	call	0x43b5
01ed:447e	jmp	loc_6358
        	loc_6350:
01ed:4480	mov	al, 0x1d
01ed:4482	push	ax
01ed:4483	call	0x45a0
01ed:4486	inc	sp
01ed:4487	inc	sp
        	loc_6358:
01ed:4488	pop	bp
01ed:4489	ret	
sub_6324 ENDP
*/
void sub_6324()
{
    // coverage: 0x5654-0x568a method sub_6324
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6330;
    sub_ca53();
loc_6330:
    if (memoryAGet(ds, 0x856e) >= 0x08)
        goto loc_633c;
    sub_6285();
    goto loc_6358;
loc_633c:
    al = memoryAGet(ds, 0x856e);
    al += 0xf8;
    push(ax);
    sub_649f();
    sp++;
    sp++;
    if (!al)
        goto loc_6350;
    sub_6285();
    goto loc_6358;
loc_6350:
    al = 0x1d;
    push(ax);
    sub_6470();
    sp++;
    sp++;
loc_6358:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:448a sub_635a()
sub_635a PROC
01ed:448a	push	bp
01ed:448b	mov	bp, sp
01ed:448d	cmp	word ptr [0x6b4c], sp
01ed:4491	ja	loc_6366
01ed:4493	call	0xab83
        	loc_6366:
01ed:4496	cmp	byte ptr [0x856e], 0x28
01ed:449b	jb	loc_6372
01ed:449d	call	0x43d2
01ed:44a0	jmp	loc_638e
        	loc_6372:
01ed:44a2	mov	al, byte ptr [0x856e]
01ed:44a5	add	al, 8
01ed:44a7	push	ax
01ed:44a8	call	0x45cf
01ed:44ab	inc	sp
01ed:44ac	inc	sp
01ed:44ad	or	al, al
01ed:44af	je	loc_6386
01ed:44b1	call	0x43d2
01ed:44b4	jmp	loc_638e
        	loc_6386:
01ed:44b6	mov	al, 0x1e
01ed:44b8	push	ax
01ed:44b9	call	0x45a0
01ed:44bc	inc	sp
01ed:44bd	inc	sp
        	loc_638e:
01ed:44be	pop	bp
01ed:44bf	ret	
sub_635a ENDP
*/
void sub_635a()
{
    // coverage: 0x568a-0x56c0 method sub_635a
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6366;
    sub_ca53();
loc_6366:
    if (memoryAGet(ds, 0x856e) < 0x28)
        goto loc_6372;
    sub_62a2();
    goto loc_638e;
loc_6372:
    al = memoryAGet(ds, 0x856e);
    al += 0x08;
    push(ax);
    sub_649f();
    sp++;
    sp++;
    if (!al)
        goto loc_6386;
    sub_62a2();
    goto loc_638e;
loc_6386:
    al = 0x1e;
    push(ax);
    sub_6470();
    sp++;
    sp++;
loc_638e:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:44c0 sub_6390()
sub_6390 PROC
01ed:44c0	push	bp
01ed:44c1	mov	bp, sp
01ed:44c3	cmp	word ptr [0x6b4c], sp
01ed:44c7	ja	loc_639c
01ed:44c9	call	0xab83
        	loc_639c:
01ed:44cc	mov	al, byte ptr [0x855e]
01ed:44cf	mov	ah, 0
01ed:44d1	or	ax, ax
01ed:44d3	jne	loc_63aa
01ed:44d5	call	0x43ef
01ed:44d8	jmp	loc_63da
        	loc_63aa:
01ed:44da	mov	al, byte ptr [0x856e]
01ed:44dd	add	al, 0xff
01ed:44df	push	ax
01ed:44e0	call	0x45cf
01ed:44e3	inc	sp
01ed:44e4	inc	sp
01ed:44e5	or	al, al
01ed:44e7	je	loc_63be
01ed:44e9	call	0x450c
01ed:44ec	jmp	loc_63da
        	loc_63be:
01ed:44ee	mov	al, byte ptr [0x856e]
01ed:44f1	add	al, 0xff
01ed:44f3	push	ax
01ed:44f4	call	0x4605
01ed:44f7	inc	sp
01ed:44f8	inc	sp
01ed:44f9	or	al, al
01ed:44fb	je	loc_63d2
01ed:44fd	call	0x450c
01ed:4500	jmp	loc_63da
        	loc_63d2:
01ed:4502	mov	al, 0x1f
01ed:4504	push	ax
01ed:4505	call	0x45a0
01ed:4508	inc	sp
01ed:4509	inc	sp
        	loc_63da:
01ed:450a	pop	bp
01ed:450b	ret	
sub_6390 ENDP
*/
void sub_6390()
{
    // coverage: 0x56c0-0x570c method sub_6390
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_639c;
    sub_ca53();
loc_639c:
    al = memoryAGet(ds, 0x855e);
    ah = 0x00;
    if (ax)
        goto loc_63aa;
    sub_62bf();
    goto loc_63da;
loc_63aa:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    push(ax);
    sub_649f();
    sp++;
    sp++;
    if (!al)
        goto loc_63be;
    sub_63dc();
    goto loc_63da;
loc_63be:
    al = memoryAGet(ds, 0x856e);
    al += 0xff;
    push(ax);
    sub_64d5();
    sp++;
    sp++;
    if (!al)
        goto loc_63d2;
    sub_63dc();
    goto loc_63da;
loc_63d2:
    al = 0x1f;
    push(ax);
    sub_6470();
    sp++;
    sp++;
loc_63da:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:450c sub_63dc()
sub_63dc PROC
01ed:450c	push	bp
01ed:450d	mov	bp, sp
01ed:450f	cmp	word ptr [0x6b4c], sp
01ed:4513	ja	loc_63e8
01ed:4515	call	0xab83
        	loc_63e8:
01ed:4518	cmp	byte ptr [0x7924], 0x16
01ed:451d	je	loc_63fd
01ed:451f	mov	al, byte ptr [0x856e]
01ed:4522	mov	byte ptr [0x856f], al
01ed:4525	mov	al, 0x2f
01ed:4527	push	ax
01ed:4528	call	0x6d94
01ed:452b	inc	sp
01ed:452c	inc	sp
        	loc_63fd:
01ed:452d	call	0x2634
01ed:4530	pop	bp
01ed:4531	ret	
sub_63dc ENDP
*/
void sub_63dc()
{
    // coverage: 0x570c-0x5732 method sub_63dc
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_63e8;
    sub_ca53();
loc_63e8:
    if (memoryAGet(ds, 0x7924) == 0x16)
        goto loc_63fd;
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    al = 0x2f;
    push(ax);
    sub_8c64();
    sp++;
    sp++;
loc_63fd:
    sub_4504();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4532 sub_6402()
sub_6402 PROC
01ed:4532	push	bp
01ed:4533	mov	bp, sp
01ed:4535	cmp	word ptr [0x6b4c], sp
01ed:4539	ja	loc_640e
01ed:453b	call	0xab83
        	loc_640e:
01ed:453e	cmp	byte ptr [0x855e], 7
01ed:4543	jne	loc_641a
01ed:4545	call	0x440c
01ed:4548	jmp	loc_6448
        	loc_641a:
01ed:454a	mov	al, byte ptr [0x856e]
01ed:454d	inc	al
01ed:454f	push	ax
01ed:4550	call	0x45cf
01ed:4553	inc	sp
01ed:4554	inc	sp
01ed:4555	or	al, al
01ed:4557	je	loc_642e
01ed:4559	call	0x457a
01ed:455c	jmp	loc_6448
        	loc_642e:
01ed:455e	mov	al, byte ptr [0x856e]
01ed:4561	push	ax
01ed:4562	call	0x4605
01ed:4565	inc	sp
01ed:4566	inc	sp
01ed:4567	or	al, al
01ed:4569	je	loc_6440
01ed:456b	call	0x457a
01ed:456e	jmp	loc_6448
        	loc_6440:
01ed:4570	mov	al, 0x20
01ed:4572	push	ax
01ed:4573	call	0x45a0
01ed:4576	inc	sp
01ed:4577	inc	sp
        	loc_6448:
01ed:4578	pop	bp
01ed:4579	ret	
sub_6402 ENDP
*/
void sub_6402()
{
    // coverage: 0x5732-0x577a method sub_6402
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_640e;
    sub_ca53();
loc_640e:
    if (memoryAGet(ds, 0x855e) != 0x07)
        goto loc_641a;
    sub_62dc();
    goto loc_6448;
loc_641a:
    al = memoryAGet(ds, 0x856e);
    al++;
    push(ax);
    sub_649f();
    sp++;
    sp++;
    if (!al)
        goto loc_642e;
    sub_644a();
    goto loc_6448;
loc_642e:
    al = memoryAGet(ds, 0x856e);
    push(ax);
    sub_64d5();
    sp++;
    sp++;
    if (!al)
        goto loc_6440;
    sub_644a();
    goto loc_6448;
loc_6440:
    al = 0x20;
    push(ax);
    sub_6470();
    sp++;
    sp++;
loc_6448:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:457a sub_644a()
sub_644a PROC
01ed:457a	push	bp
01ed:457b	mov	bp, sp
01ed:457d	cmp	word ptr [0x6b4c], sp
01ed:4581	ja	loc_6456
01ed:4583	call	0xab83
        	loc_6456:
01ed:4586	cmp	byte ptr [0x7924], 0x16
01ed:458b	je	loc_646b
01ed:458d	mov	al, byte ptr [0x856e]
01ed:4590	mov	byte ptr [0x856f], al
01ed:4593	mov	al, 0x2f
01ed:4595	push	ax
01ed:4596	call	0x6d94
01ed:4599	inc	sp
01ed:459a	inc	sp
        	loc_646b:
01ed:459b	call	0x26a1
01ed:459e	pop	bp
01ed:459f	ret	
sub_644a ENDP
*/
void sub_644a()
{
    // coverage: 0x577a-0x57a0 method sub_644a
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6456;
    sub_ca53();
loc_6456:
    if (memoryAGet(ds, 0x7924) == 0x16)
        goto loc_646b;
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    al = 0x2f;
    push(ax);
    sub_8c64();
    sp++;
    sp++;
loc_646b:
    sub_4571();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:45a0 sub_6470()
sub_6470 PROC
01ed:45a0	push	bp
01ed:45a1	mov	bp, sp
01ed:45a3	cmp	word ptr [0x6b4c], sp
01ed:45a7	ja	loc_647c
01ed:45a9	call	0xab83
        	loc_647c:
01ed:45ac	mov	al, byte ptr [bp + 4]
01ed:45af	push	ax
01ed:45b0	call	0x4263
01ed:45b3	inc	sp
01ed:45b4	inc	sp
01ed:45b5	cmp	byte ptr [0x7924], 0
01ed:45ba	je	loc_649a
01ed:45bc	mov	al, byte ptr [0x856e]
01ed:45bf	mov	byte ptr [0x856f], al
01ed:45c2	mov	al, 0x30
01ed:45c4	push	ax
01ed:45c5	call	0x6d94
01ed:45c8	inc	sp
01ed:45c9	inc	sp
        	loc_649a:
01ed:45ca	call	0x238e
01ed:45cd	pop	bp
01ed:45ce	ret	
sub_6470 ENDP
*/
void sub_6470()
{
    // coverage: 0x57a0-0x57cf method sub_6470
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_647c;
    sub_ca53();
loc_647c:
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_6133();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x7924) == 0x00)
        goto loc_649a;
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    al = 0x30;
    push(ax);
    sub_8c64();
    sp++;
    sp++;
loc_649a:
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:45cf sub_649f()
sub_649f PROC
01ed:45cf	push	bp
01ed:45d0	mov	bp, sp
01ed:45d2	cmp	word ptr [0x6b4c], sp
01ed:45d6	ja	loc_64ab
01ed:45d8	call	0xab83
        	loc_64ab:
01ed:45db	mov	dl, 0
01ed:45dd	mov	al, byte ptr [bp + 4]
01ed:45e0	mov	ah, 0
01ed:45e2	les	bx, ptr [0xa0d8]
01ed:45e6	add	bx, ax
01ed:45e8	cmp	byte ptr es:[bx], 0
01ed:45ec	je	loc_64d1
01ed:45ee	mov	al, byte ptr [bp + 4]
01ed:45f1	mov	ah, 0
01ed:45f3	mov	bx, word ptr [0xa0d8]
01ed:45f7	add	bx, ax
01ed:45f9	cmp	byte ptr es:[bx], 0x19
01ed:45fd	je	loc_64d1
01ed:45ff	mov	dl, 1
        	loc_64d1:
01ed:4601	mov	al, dl
01ed:4603	pop	bp
01ed:4604	ret	
sub_649f ENDP
*/
void sub_649f()
{
    // coverage: 0x57cf-0x5805 method sub_649f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_64ab;
    sub_ca53();
loc_64ab:
    dl = 0x00;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx) == 0x00)
        goto loc_64d1;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    bx += ax;
    if (memoryAGet(es, bx) == 0x19)
        goto loc_64d1;
    dl = 0x01;
loc_64d1:
    al = dl;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4605 sub_64d5()
sub_64d5 PROC
01ed:4605	push	bp
01ed:4606	mov	bp, sp
01ed:4608	cmp	word ptr [0x6b4c], sp
01ed:460c	ja	loc_64e1
01ed:460e	call	0xab83
        	loc_64e1:
01ed:4611	mov	dl, 0
01ed:4613	mov	al, byte ptr [bp + 4]
01ed:4616	mov	ah, 0
01ed:4618	les	bx, ptr [0xa0d8]
01ed:461c	add	bx, ax
01ed:461e	cmp	byte ptr es:[bx + 0x30], 0
01ed:4623	je	loc_6509
01ed:4625	mov	al, byte ptr [bp + 4]
01ed:4628	mov	ah, 0
01ed:462a	mov	bx, word ptr [0xa0d8]
01ed:462e	add	bx, ax
01ed:4630	cmp	byte ptr es:[bx + 0x30], 0x13
01ed:4635	je	loc_6509
01ed:4637	mov	dl, 1
        	loc_6509:
01ed:4639	mov	al, dl
01ed:463b	pop	bp
01ed:463c	ret	
sub_64d5 ENDP
*/
void sub_64d5()
{
    // coverage: 0x5805-0x583d method sub_64d5
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_64e1;
    sub_ca53();
loc_64e1:
    dl = 0x00;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx + 48) == 0x00)
        goto loc_6509;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    bx += ax;
    if (memoryAGet(es, bx + 48) == 0x13)
        goto loc_6509;
    dl = 0x01;
loc_6509:
    al = dl;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:463d sub_650d()
sub_650d PROC
01ed:463d	push	bp
01ed:463e	mov	bp, sp
01ed:4640	cmp	word ptr [0x6b4c], sp
01ed:4644	ja	loc_6519
01ed:4646	call	0xab83
        	loc_6519:
01ed:4649	inc	byte ptr [0x8242]
01ed:464d	cmp	byte ptr [0x8242], 3
01ed:4652	jne	loc_652c
01ed:4654	mov	byte ptr [0x8242], 0
01ed:4659	call	0x2965
        	loc_652c:
01ed:465c	pop	bp
01ed:465d	ret	
sub_650d ENDP
*/
void sub_650d()
{
    // coverage: 0x583d-0x585e method sub_650d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6519;
    sub_ca53();
loc_6519:
    memoryASet(ds, 0x8242, memoryAGet(ds, 0x8242) + 1);
    if (memoryAGet(ds, 0x8242) != 0x03)
        goto loc_652c;
    memoryASet(ds, 0x8242, 0x00);
    sub_4835();
loc_652c:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:465e sub_652e()
sub_652e PROC
01ed:465e	push	bp
01ed:465f	mov	bp, sp
01ed:4661	cmp	word ptr [0x6b4c], sp
01ed:4665	ja	loc_653a
01ed:4667	call	0xab83
        	loc_653a:
01ed:466a	mov	al, byte ptr [0x7924]
01ed:466d	mov	ah, 0
01ed:466f	mov	bx, ax
01ed:4671	mov	al, byte ptr [bx + 0x36be]
01ed:4675	push	ax
01ed:4676	call	0x46bb
01ed:4679	inc	sp
01ed:467a	inc	sp
01ed:467b	pop	bp
01ed:467c	ret	
sub_652e ENDP
*/
void sub_652e()
{
    // coverage: 0x585e-0x587d method sub_652e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_653a;
    sub_ca53();
loc_653a:
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 14014);
    push(ax);
    sub_658b();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:467d sub_654d()
sub_654d PROC
01ed:467d	push	bp
01ed:467e	mov	bp, sp
01ed:4680	cmp	word ptr [0x6b4c], sp
01ed:4684	ja	loc_6559
01ed:4686	call	0xab83
        	loc_6559:
01ed:4689	mov	al, byte ptr [0x7924]
01ed:468c	mov	ah, 0
01ed:468e	mov	bx, ax
01ed:4690	mov	al, byte ptr [bx + 0x36ee]
01ed:4694	push	ax
01ed:4695	call	0x46bb
01ed:4698	inc	sp
01ed:4699	inc	sp
01ed:469a	pop	bp
01ed:469b	ret	
sub_654d ENDP
*/
void sub_654d()
{
    // coverage: 0x587d-0x589c method sub_654d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6559;
    sub_ca53();
loc_6559:
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 14062);
    push(ax);
    sub_658b();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:469c sub_656c()
sub_656c PROC
01ed:469c	push	bp
01ed:469d	mov	bp, sp
01ed:469f	cmp	word ptr [0x6b4c], sp
01ed:46a3	ja	loc_6578
01ed:46a5	call	0xab83
        	loc_6578:
01ed:46a8	mov	al, byte ptr [0x7924]
01ed:46ab	mov	ah, 0
01ed:46ad	mov	bx, ax
01ed:46af	mov	al, byte ptr [bx + 0x371e]
01ed:46b3	push	ax
01ed:46b4	call	0x46bb
01ed:46b7	inc	sp
01ed:46b8	inc	sp
01ed:46b9	pop	bp
01ed:46ba	ret	
sub_656c ENDP
*/
void sub_656c()
{
    // coverage: 0x589c-0x58bb method sub_656c
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6578;
    sub_ca53();
loc_6578:
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 14110);
    push(ax);
    sub_658b();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:46bb sub_658b()
sub_658b PROC
01ed:46bb	push	bp
01ed:46bc	mov	bp, sp
01ed:46be	cmp	word ptr [0x6b4c], sp
01ed:46c2	ja	loc_6597
01ed:46c4	call	0xab83
        	loc_6597:
01ed:46c7	mov	al, byte ptr [bp + 4]
01ed:46ca	mov	ah, 0
01ed:46cc	cmp	ax, 8
01ed:46cf	je	loc_65d6
01ed:46d1	jg	loc_65b1
01ed:46d3	mov	bx, ax
01ed:46d5	cmp	bx, 3
01ed:46d8	ja	loc_65ea
01ed:46da	shl	bx, 1
01ed:46dc	jmp	word ptr cs:[bx + 0x4725]
        	loc_65b1:
01ed:46e1	cmp	ax, 9
01ed:46e4	je	loc_65db
01ed:46e6	cmp	ax, 0x1a
01ed:46e9	je	loc_65e0
01ed:46eb	cmp	ax, 0x1b
01ed:46ee	je	loc_65e5
01ed:46f0	jmp	loc_65ea
        	loc_65c2:
01ed:46f2	call	0x4747
01ed:46f5	jmp	loc_65f3
        	loc_65c7:
01ed:46f7	call	0x2634
01ed:46fa	jmp	loc_65f3
        	loc_65cc:
01ed:46fc	call	0x26a1
01ed:46ff	jmp	loc_65f3
        	loc_65d1:
01ed:4701	call	0x27de
01ed:4704	jmp	loc_65f3
        	loc_65d6:
01ed:4706	call	0x270c
01ed:4709	jmp	loc_65f3
        	loc_65db:
01ed:470b	call	0x2776
01ed:470e	jmp	loc_65f3
        	loc_65e0:
01ed:4710	call	0x1fbe
01ed:4713	jmp	loc_65f3
        	loc_65e5:
01ed:4715	call	0x207d
01ed:4718	jmp	loc_65f3
        	loc_65ea:
01ed:471a	mov	al, byte ptr [bp + 4]
01ed:471d	push	ax
01ed:471e	call	0x472d
01ed:4721	inc	sp
01ed:4722	inc	sp
        	loc_65f3:
01ed:4723	pop	bp
01ed:4724	ret	
sub_658b ENDP
*/
void sub_658b()
{
    // coverage: 0x58bb-0x5925 method sub_658b
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6597;
    sub_ca53();
loc_6597:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    if (ax == 0x0008)
        goto loc_65d6;
    if ((short)ax > (short)0x0008)
        goto loc_65b1;
    bx = ax;
    if (bx > 0x0003)
        goto loc_65ea;
    bx <<= 1;
    switch (bx)
    {
        // coverage: 0x5925-0x592b switch
        case 0: goto loc_65c2;
        case 2: goto loc_65c7;
        case 4: goto loc_65cc;
        case 6: goto loc_65d1;
        default:
        assert(0);
    }
loc_65b1:
    if (ax == 0x0009)
        goto loc_65db;
    if (ax == 0x001a)
        goto loc_65e0;
    if (ax == 0x001b)
        goto loc_65e5;
    goto loc_65ea;
loc_65c2:
    sub_6617();
    goto loc_65f3;
loc_65c7:
    sub_4504();
    goto loc_65f3;
loc_65cc:
    sub_4571();
    goto loc_65f3;
loc_65d1:
    sub_46ae();
    goto loc_65f3;
loc_65d6:
    sub_45dc();
    goto loc_65f3;
loc_65db:
    sub_4646();
    goto loc_65f3;
loc_65e0:
    sub_3e8e();
    goto loc_65f3;
loc_65e5:
    sub_3f4d();
    goto loc_65f3;
loc_65ea:
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_65fd();
    sp++;
    sp++;
loc_65f3:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:472d sub_65fd()
sub_65fd PROC
01ed:472d	push	bp
01ed:472e	mov	bp, sp
01ed:4730	cmp	word ptr [0x6b4c], sp
01ed:4734	ja	loc_6609
01ed:4736	call	0xab83
        	loc_6609:
01ed:4739	mov	al, byte ptr [bp + 4]
01ed:473c	push	ax
01ed:473d	call	0x4263
01ed:4740	inc	sp
01ed:4741	inc	sp
01ed:4742	call	0x238e
01ed:4745	pop	bp
01ed:4746	ret	
sub_65fd ENDP
*/
void sub_65fd()
{
    // coverage: 0x592d-0x5947 method sub_65fd
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6609;
    sub_ca53();
loc_6609:
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4747 sub_6617()
sub_6617 PROC
01ed:4747	push	bp
01ed:4748	mov	bp, sp
01ed:474a	dec	sp
01ed:474b	dec	sp
01ed:474c	cmp	word ptr [0x6b4c], sp
01ed:4750	ja	loc_6625
01ed:4752	call	0xab83
        	loc_6625:
01ed:4755	cmp	byte ptr [0x856e], 8
01ed:475a	jae	loc_6632
01ed:475c	mov	byte ptr [bp - 2], 0
01ed:4760	jmp	loc_6653
        	loc_6632:
01ed:4762	mov	al, byte ptr [0x856e]
01ed:4765	mov	ah, 0
01ed:4767	mov	es, word ptr [0xa0da]
01ed:476b	add	ax, word ptr [0xa0d8]
01ed:476f	mov	bx, ax
01ed:4771	mov	al, byte ptr es:[bx - 8]
01ed:4775	mov	byte ptr [bp - 1], al
01ed:4778	mov	ah, 0
01ed:477a	mov	bx, ax
01ed:477c	mov	al, byte ptr [bx + 0x374e]
01ed:4780	mov	byte ptr [bp - 2], al
        	loc_6653:
01ed:4783	mov	al, byte ptr [bp - 2]
01ed:4786	mov	ah, 0
01ed:4788	or	ax, ax
01ed:478a	jne	loc_668e
01ed:478c	cmp	byte ptr [0x79b3], 0xeb
01ed:4791	jbe	loc_6669
01ed:4793	mov	byte ptr [bp - 2], 0x3c
01ed:4797	jmp	loc_668e
        	loc_6669:
01ed:4799	cmp	byte ptr [0x79b3], 0xd7
01ed:479e	jbe	loc_6676
01ed:47a0	mov	byte ptr [bp - 2], 0x3d
01ed:47a4	jmp	loc_668e
        	loc_6676:
01ed:47a6	cmp	byte ptr [0x79b3], 0xc3
01ed:47ab	jbe	loc_6683
01ed:47ad	mov	byte ptr [bp - 2], 0x3e
01ed:47b1	jmp	loc_668e
        	loc_6683:
01ed:47b3	cmp	byte ptr [0x79b3], 0xaf
01ed:47b8	jbe	loc_668e
01ed:47ba	mov	byte ptr [bp - 2], 0x3f
        	loc_668e:
01ed:47be	mov	al, byte ptr [bp - 2]
01ed:47c1	push	ax
01ed:47c2	call	0x472d
01ed:47c5	inc	sp
01ed:47c6	inc	sp
01ed:47c7	mov	sp, bp
01ed:47c9	pop	bp
01ed:47ca	ret	
sub_6617 ENDP
*/
void sub_6617()
{
    // coverage: 0x5947-0x59cb method sub_6617
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6625;
    sub_ca53();
loc_6625:
    if (memoryAGet(ds, 0x856e) >= 0x08)
        goto loc_6632;
    memoryASet(ss, bp - 2, 0x00);
    goto loc_6653;
loc_6632:
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    es = memoryAGet16(ds, 0xa0da);
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    al = memoryAGet(es, bx + 65528);
    memoryASet(ss, bp - 1, al);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 14158);
    memoryASet(ss, bp - 2, al);
loc_6653:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    if (ax)
        goto loc_668e;
    if (memoryAGet(ds, 0x79b3) <= 0xeb)
        goto loc_6669;
    memoryASet(ss, bp - 2, 0x3c);
    goto loc_668e;
loc_6669:
    if (memoryAGet(ds, 0x79b3) <= 0xd7)
        goto loc_6676;
    memoryASet(ss, bp - 2, 0x3d);
    goto loc_668e;
loc_6676:
    if (memoryAGet(ds, 0x79b3) <= 0xc3)
        goto loc_6683;
    memoryASet(ss, bp - 2, 0x3e);
    goto loc_668e;
loc_6683:
    if (memoryAGet(ds, 0x79b3) <= 0xaf)
        goto loc_668e;
    memoryASet(ss, bp - 2, 0x3f);
loc_668e:
    al = memoryAGet(ss, bp - 2);
    push(ax);
    sub_65fd();
    sp++;
    sp++;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:47cb sub_669b()
sub_669b PROC
01ed:47cb	push	bp
01ed:47cc	mov	bp, sp
01ed:47ce	cmp	word ptr [0x6b4c], sp
01ed:47d2	ja	loc_66a7
01ed:47d4	call	0xab83
        	loc_66a7:
01ed:47d7	test	byte ptr [0x8244], 4
01ed:47dc	je	loc_66b3
01ed:47de	call	0x2634
01ed:47e1	jmp	loc_66d0
        	loc_66b3:
01ed:47e3	test	byte ptr [0x8244], 8
01ed:47e8	je	loc_66bf
01ed:47ea	call	0x26a1
01ed:47ed	jmp	loc_66d0
        	loc_66bf:
01ed:47ef	mov	al, byte ptr [0x792c]
01ed:47f2	mov	ah, 0
01ed:47f4	mov	bx, ax
01ed:47f6	mov	al, byte ptr [bx + 0x377e]
01ed:47fa	push	ax
01ed:47fb	call	0x46bb
01ed:47fe	inc	sp
01ed:47ff	inc	sp
        	loc_66d0:
01ed:4800	pop	bp
01ed:4801	ret	
sub_669b ENDP
*/
void sub_669b()
{
    // coverage: 0x59cb-0x5a02 method sub_669b
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_66a7;
    sub_ca53();
loc_66a7:
    if (!(memoryAGet(ds, 0x8244) & 0x04))
        goto loc_66b3;
    sub_4504();
    goto loc_66d0;
loc_66b3:
    if (!(memoryAGet(ds, 0x8244) & 0x08))
        goto loc_66bf;
    sub_4571();
    goto loc_66d0;
loc_66bf:
    al = memoryAGet(ds, 0x792c);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 14206);
    push(ax);
    sub_658b();
    sp++;
    sp++;
loc_66d0:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4802 sub_66d2()
sub_66d2 PROC
01ed:4802	push	bp
01ed:4803	mov	bp, sp
01ed:4805	cmp	word ptr [0x6b4c], sp
01ed:4809	ja	loc_66de
01ed:480b	call	0xab83
        	loc_66de:
01ed:480e	cmp	word ptr [0x689c], 4
01ed:4813	je	loc_66e9
01ed:4815	mov	al, 3
01ed:4817	jmp	loc_66eb
        	loc_66e9:
01ed:4819	mov	al, 0x28
        	loc_66eb:
01ed:481b	push	ax
01ed:481c	call	0x6e11
01ed:481f	inc	sp
01ed:4820	inc	sp
01ed:4821	mov	al, byte ptr [0x856e]
01ed:4824	mov	byte ptr [0x856f], al
01ed:4827	mov	al, 0x27
01ed:4829	push	ax
01ed:482a	call	0x69aa
01ed:482d	inc	sp
01ed:482e	inc	sp
01ed:482f	mov	al, 0xe
01ed:4831	push	ax
01ed:4832	call	0x4263
01ed:4835	inc	sp
01ed:4836	inc	sp
01ed:4837	call	0x238e
01ed:483a	pop	bp
01ed:483b	ret	
sub_66d2 ENDP
*/
void sub_66d2()
{
    // coverage: 0x5a02-0x5a3c method sub_66d2
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_66de;
    sub_ca53();
loc_66de:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_66e9;
    al = 0x03;
    goto loc_66eb;
loc_66e9:
    al = 0x28;
loc_66eb:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    al = 0x27;
    push(ax);
    sub_887a();
    sp++;
    sp++;
    al = 0x0e;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    sub_425e();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:483c sub_670c()
sub_670c PROC
01ed:483c	push	bp
01ed:483d	mov	bp, sp
01ed:483f	cmp	word ptr [0x6b4c], sp
01ed:4843	ja	loc_6718
01ed:4845	call	0xab83
        	loc_6718:
01ed:4848	call	0x2a0a
01ed:484b	les	bx, ptr [0x574]
01ed:484f	mov	word ptr es:[bx], 1
01ed:4854	mov	word ptr es:[bx + 6], 0
01ed:485a	mov	word ptr es:[bx + 8], 0
01ed:4860	mov	ax, word ptr [0x7928]
01ed:4863	mov	dx, word ptr [0x7926]
01ed:4867	mov	word ptr es:[bx + 0x10], dx
01ed:486b	mov	word ptr es:[bx + 0x12], ax
01ed:486f	mov	word ptr es:[bx + 0x14], 0
01ed:4875	mov	word ptr es:[bx + 0x16], 0
01ed:487b	mov	word ptr es:[bx + 0x18], 0x14
01ed:4881	mov	word ptr es:[bx + 0x1a], 0x19
01ed:4887	mov	word ptr es:[bx + 0x1c], 0
01ed:488d	mov	word ptr es:[bx + 0x1e], 0x14
01ed:4893	mov	word ptr es:[bx + 0x20], 0x19
01ed:4899	push	word ptr [0x576]
01ed:489d	push	word ptr [0x574]
01ed:48a1	call	0x93b8
01ed:48a4	add	sp, 4
01ed:48a7	pop	bp
01ed:48a8	ret	
sub_670c ENDP
*/
void sub_670c()
{
    // coverage: 0x5a3c-0x5aa9 method sub_670c
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6718;
    sub_ca53();
loc_6718:
    sub_48da();
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx, 0x0001);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(es, bx + 16, dx);
    memoryASet16(es, bx + 18, ax);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0014);
    memoryASet16(es, bx + 26, 0x0019);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_b288();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:48a9 sub_6779()
sub_6779 PROC
01ed:48a9	push	bp
01ed:48aa	mov	bp, sp
01ed:48ac	cmp	word ptr [0x6b4c], sp
01ed:48b0	ja	loc_6785
01ed:48b2	call	0xab83
        	loc_6785:
01ed:48b5	cmp	byte ptr [0x8571], 0xff
01ed:48ba	je	loc_67d4
01ed:48bc	mov	al, byte ptr [0x8571]
01ed:48bf	mov	ah, 0
01ed:48c1	sar	ax, 1
01ed:48c3	sar	ax, 1
01ed:48c5	sar	ax, 1
01ed:48c7	mov	byte ptr [0x8565], al
01ed:48ca	shl	al, 1
01ed:48cc	shl	al, 1
01ed:48ce	shl	al, 1
01ed:48d0	mov	dl, byte ptr [0x8571]
01ed:48d4	sub	dl, al
01ed:48d6	mov	byte ptr [0x8564], dl
01ed:48da	mov	al, byte ptr [0x8571]
01ed:48dd	mov	ah, 0
01ed:48df	shl	ax, 1
01ed:48e1	shl	ax, 1
01ed:48e3	mov	bx, ax
01ed:48e5	mov	ax, word ptr [bx + 0x274]
01ed:48e9	add	ax, 7
01ed:48ec	mov	word ptr [0x79ba], ax
01ed:48ef	mov	al, byte ptr [0x8571]
01ed:48f2	mov	ah, 0
01ed:48f4	shl	ax, 1
01ed:48f6	shl	ax, 1
01ed:48f8	mov	bx, ax
01ed:48fa	mov	ax, word ptr [bx + 0x276]
01ed:48fe	add	ax, 7
01ed:4901	mov	word ptr [0x79bc], ax
        	loc_67d4:
01ed:4904	pop	bp
01ed:4905	ret	
sub_6779 ENDP
*/
void sub_6779()
{
    // coverage: 0x5aa9-0x5b06 method sub_6779
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6785;
    sub_ca53();
loc_6785:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_67d4;
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ds, 0x8565, al);
    al <<= 1;
    al <<= 1;
    al <<= 1;
    dl = memoryAGet(ds, 0x8571);
    dl -= al;
    memoryASet(ds, 0x8564, dl);
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 628);
    ax += 0x0007;
    memoryASet16(ds, 0x79ba, ax);
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 630);
    ax += 0x0007;
    memoryASet16(ds, 0x79bc, ax);
loc_67d4:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4906 sub_67d6()
sub_67d6 PROC
01ed:4906	push	bp
01ed:4907	mov	bp, sp
01ed:4909	cmp	word ptr [0x6b4c], sp
01ed:490d	ja	loc_67e2
01ed:490f	call	0xab83
        	loc_67e2:
01ed:4912	mov	al, byte ptr [0x856e]
01ed:4915	mov	ah, 0
01ed:4917	sar	ax, 1
01ed:4919	sar	ax, 1
01ed:491b	sar	ax, 1
01ed:491d	mov	byte ptr [0x855c], al
01ed:4920	shl	al, 1
01ed:4922	shl	al, 1
01ed:4924	shl	al, 1
01ed:4926	mov	dl, byte ptr [0x856e]
01ed:492a	sub	dl, al
01ed:492c	mov	byte ptr [0x855e], dl
01ed:4930	mov	al, byte ptr [0x856e]
01ed:4933	mov	ah, 0
01ed:4935	shl	ax, 1
01ed:4937	shl	ax, 1
01ed:4939	mov	bx, ax
01ed:493b	mov	ax, word ptr [bx + 0x274]
01ed:493f	add	ax, 7
01ed:4942	mov	word ptr [0x9290], ax
01ed:4945	mov	al, byte ptr [0x856e]
01ed:4948	mov	ah, 0
01ed:494a	shl	ax, 1
01ed:494c	shl	ax, 1
01ed:494e	mov	bx, ax
01ed:4950	mov	ax, word ptr [bx + 0x276]
01ed:4954	add	ax, 0xf
01ed:4957	mov	word ptr [0x9292], ax
01ed:495a	pop	bp
01ed:495b	ret	
sub_67d6 ENDP
*/
void sub_67d6()
{
    // coverage: 0x5b06-0x5b5c method sub_67d6
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_67e2;
    sub_ca53();
loc_67e2:
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ds, 0x855c, al);
    al <<= 1;
    al <<= 1;
    al <<= 1;
    dl = memoryAGet(ds, 0x856e);
    dl -= al;
    memoryASet(ds, 0x855e, dl);
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 628);
    ax += 0x0007;
    memoryASet16(ds, 0x9290, ax);
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 630);
    ax += 0x000f;
    memoryASet16(ds, 0x9292, ax);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:495c sub_682c()
sub_682c PROC
01ed:495c	push	bp
01ed:495d	mov	bp, sp
01ed:495f	cmp	word ptr [0x6b4c], sp
01ed:4963	ja	loc_6838
01ed:4965	call	0xab83
        	loc_6838:
01ed:4968	inc	byte ptr [0x855d]
01ed:496c	mov	al, byte ptr [0x855d]
01ed:496f	cmp	al, byte ptr [bp + 6]
01ed:4972	jne	loc_6856
01ed:4974	push	word ptr [bp + 0xa]
01ed:4977	push	word ptr [bp + 8]
01ed:497a	mov	al, byte ptr [bp + 4]
01ed:497d	push	ax
01ed:497e	call	0x4995
01ed:4981	add	sp, 6
01ed:4984	jmp	loc_6863
        	loc_6856:
01ed:4986	mov	al, byte ptr [0x855d]
01ed:4989	cmp	al, byte ptr [bp + 6]
01ed:498c	jbe	loc_6863
01ed:498e	mov	byte ptr [0x855d], 0
        	loc_6863:
01ed:4993	pop	bp
01ed:4994	ret	
sub_682c ENDP
*/
void sub_682c()
{
    // coverage: 0x5b5c-0x5b95 method sub_682c
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6838;
    sub_ca53();
loc_6838:
    memoryASet(ds, 0x855d, memoryAGet(ds, 0x855d) + 1);
    al = memoryAGet(ds, 0x855d);
    if (al != memoryAGet(ss, bp + 6))
        goto loc_6856;
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_6865();
    sp += 0x0006;
    goto loc_6863;
loc_6856:
    al = memoryAGet(ds, 0x855d);
    if (al <= memoryAGet(ss, bp + 6))
        goto loc_6863;
    memoryASet(ds, 0x855d, 0x00);
loc_6863:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4995 sub_6865()
sub_6865 PROC
01ed:4995	push	bp
01ed:4996	mov	bp, sp
01ed:4998	cmp	word ptr [0x6b4c], sp
01ed:499c	ja	loc_6871
01ed:499e	call	0xab83
        	loc_6871:
01ed:49a1	mov	byte ptr [0x855d], 0
01ed:49a6	mov	al, byte ptr [0xa0dc]
01ed:49a9	mov	ah, 0
01ed:49ab	inc	ax
01ed:49ac	mov	dl, byte ptr [bp + 4]
01ed:49af	mov	dh, 0
01ed:49b1	cmp	ax, dx
01ed:49b3	jge	loc_688e
01ed:49b5	inc	byte ptr [0xa0dc]
01ed:49b9	mov	al, byte ptr [0xa0dc]
01ed:49bc	jmp	loc_6893
        	loc_688e:
01ed:49be	mov	al, 0
01ed:49c0	mov	byte ptr [0xa0dc], al
        	loc_6893:
01ed:49c3	mov	al, byte ptr [0xa0dc]
01ed:49c6	mov	ah, 0
01ed:49c8	shl	ax, 1
01ed:49ca	les	bx, ptr [bp + 6]
01ed:49cd	add	bx, ax
01ed:49cf	mov	ax, word ptr es:[bx]
01ed:49d2	mov	word ptr [0x824a], ax
01ed:49d5	pop	bp
01ed:49d6	ret	
sub_6865 ENDP
*/
void sub_6865()
{
    // coverage: 0x5b95-0x5bd7 method sub_6865
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6871;
    sub_ca53();
loc_6871:
    memoryASet(ds, 0x855d, 0x00);
    al = memoryAGet(ds, 0xa0dc);
    ah = 0x00;
    ax++;
    dl = memoryAGet(ss, bp + 4);
    dh = 0x00;
    if ((short)ax >= (short)dx)
        goto loc_688e;
    memoryASet(ds, 0xa0dc, memoryAGet(ds, 0xa0dc) + 1);
    al = memoryAGet(ds, 0xa0dc);
    goto loc_6893;
loc_688e:
    al = 0x00;
    memoryASet(ds, 0xa0dc, al);
loc_6893:
    al = memoryAGet(ds, 0xa0dc);
    ah = 0x00;
    ax <<= 1;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    bx += ax;
    ax = memoryAGet16(es, bx);
    memoryASet16(ds, 0x824a, ax);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:49d7 sub_68a7()
sub_68a7 PROC
01ed:49d7	push	bp
01ed:49d8	mov	bp, sp
01ed:49da	dec	sp
01ed:49db	dec	sp
01ed:49dc	cmp	word ptr [0x6b4c], sp
01ed:49e0	ja	loc_68b5
01ed:49e2	call	0xab83
        	loc_68b5:
01ed:49e5	les	bx, ptr [0x574]
01ed:49e9	mov	word ptr es:[bx], 0
01ed:49ee	mov	word ptr es:[bx + 6], 0
01ed:49f4	mov	word ptr es:[bx + 8], 0
01ed:49fa	mov	word ptr es:[bx + 0x10], 0x9694
01ed:4a00	mov	word ptr es:[bx + 0x12], ds
01ed:4a04	mov	word ptr es:[bx + 0x14], 0
01ed:4a0a	mov	word ptr es:[bx + 0x16], 0
01ed:4a10	mov	word ptr es:[bx + 0x18], 0x14
01ed:4a16	mov	word ptr es:[bx + 0x1a], 1
01ed:4a1c	mov	word ptr es:[bx + 0x1c], 0
01ed:4a22	mov	word ptr es:[bx + 0x1e], 0x14
01ed:4a28	mov	word ptr es:[bx + 0x20], 1
01ed:4a2e	push	word ptr [0x576]
01ed:4a32	push	word ptr [0x574]
01ed:4a36	call	0x93b8
01ed:4a39	add	sp, 4
01ed:4a3c	xor	ax, ax
01ed:4a3e	push	ax
01ed:4a3f	call	0x9814
01ed:4a42	inc	sp
01ed:4a43	inc	sp
01ed:4a44	xor	ax, ax
01ed:4a46	push	ax
01ed:4a47	call	0x9410
01ed:4a4a	inc	sp
01ed:4a4b	inc	sp
01ed:4a4c	mov	ax, 7
01ed:4a4f	push	ax
01ed:4a50	xor	ax, ax
01ed:4a52	push	ax
01ed:4a53	mov	al, 7
01ed:4a55	push	ax
01ed:4a56	push	word ptr [0xa0d6]
01ed:4a5a	push	word ptr [0xa0d4]
01ed:4a5e	call	0x816
01ed:4a61	add	sp, 0xa
01ed:4a64	call	0x6130
01ed:4a67	mov	ax, 1
01ed:4a6a	push	ax
01ed:4a6b	call	0x9410
01ed:4a6e	inc	sp
01ed:4a6f	inc	sp
01ed:4a70	mov	ax, 1
01ed:4a73	push	ax
01ed:4a74	call	0x9814
01ed:4a77	inc	sp
01ed:4a78	inc	sp
        	loc_6949:
01ed:4a79	mov	al, 0x19
01ed:4a7b	push	ax
01ed:4a7c	call	0x7ab4
01ed:4a7f	inc	sp
01ed:4a80	inc	sp
01ed:4a81	or	al, al
01ed:4a83	jne	loc_6949
01ed:4a85	jmp	loc_69a2
        	loc_6957:
01ed:4a87	mov	al, 0x1d
01ed:4a89	push	ax
01ed:4a8a	call	0x7ab4
01ed:4a8d	inc	sp
01ed:4a8e	inc	sp
01ed:4a8f	or	al, al
01ed:4a91	je	loc_69a2
01ed:4a93	mov	al, 0x21
01ed:4a95	push	ax
01ed:4a96	call	0x7ab4
01ed:4a99	inc	sp
01ed:4a9a	inc	sp
01ed:4a9b	or	al, al
01ed:4a9d	je	loc_69a2
01ed:4a9f	mov	byte ptr [bp - 1], 1
01ed:4aa3	jmp	loc_698c
        	loc_6975:
01ed:4aa5	mov	al, byte ptr [bp - 1]
01ed:4aa8	mov	ah, 0
01ed:4aaa	mov	dx, 9
01ed:4aad	imul	dx
01ed:4aaf	les	bx, ptr [0x8246]
01ed:4ab3	add	bx, ax
01ed:4ab5	mov	byte ptr es:[bx], 1
01ed:4ab9	inc	byte ptr [bp - 1]
        	loc_698c:
01ed:4abc	mov	al, byte ptr [bp - 1]
01ed:4abf	mov	ah, 0
01ed:4ac1	mov	dx, 9
01ed:4ac4	imul	dx
01ed:4ac6	les	bx, ptr [0x8246]
01ed:4aca	add	bx, ax
01ed:4acc	cmp	byte ptr es:[bx], 0xff
01ed:4ad0	jne	loc_6975
        	loc_69a2:
01ed:4ad2	mov	al, 0x19
01ed:4ad4	push	ax
01ed:4ad5	call	0x7ab4
01ed:4ad8	inc	sp
01ed:4ad9	inc	sp
01ed:4ada	cwde	
01ed:4adb	or	ax, ax
01ed:4add	jne	loc_69bc
01ed:4adf	mov	al, 0
01ed:4ae1	push	ax
01ed:4ae2	call	0x75a2
01ed:4ae5	inc	sp
01ed:4ae6	inc	sp
01ed:4ae7	cwde	
01ed:4ae8	or	ax, ax
01ed:4aea	je	loc_6957
        	loc_69bc:
01ed:4aec	mov	al, 0x19
01ed:4aee	push	ax
01ed:4aef	call	0x7ab4
01ed:4af2	inc	sp
01ed:4af3	inc	sp
01ed:4af4	or	al, al
01ed:4af6	jne	loc_69bc
01ed:4af8	mov	al, 0
01ed:4afa	push	ax
01ed:4afb	call	0x75a2
01ed:4afe	inc	sp
01ed:4aff	inc	sp
01ed:4b00	or	al, al
01ed:4b02	jne	loc_69bc
01ed:4b04	les	bx, ptr [0x574]
01ed:4b08	mov	word ptr es:[bx + 2], 0x9694
01ed:4b0e	mov	word ptr es:[bx + 4], ds
01ed:4b12	mov	word ptr es:[bx + 6], 0
01ed:4b18	mov	word ptr es:[bx + 8], 0
01ed:4b1e	mov	word ptr es:[bx + 0xa], 0x14
01ed:4b24	mov	word ptr es:[bx + 0xc], 1
01ed:4b2a	mov	word ptr es:[bx + 0xe], 0
01ed:4b30	mov	word ptr es:[bx + 0x14], 0
01ed:4b36	mov	word ptr es:[bx + 0x16], 0
01ed:4b3c	push	word ptr [0x576]
01ed:4b40	push	word ptr [0x574]
01ed:4b44	call	0x80bc
01ed:4b47	add	sp, 4
01ed:4b4a	mov	sp, bp
01ed:4b4c	pop	bp
01ed:4b4d	ret	
sub_68a7 ENDP
*/
void sub_68a7()
{
    // coverage: 0x5bd7-0x5d4e method sub_68a7
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_68b5;
    sub_ca53();
loc_68b5:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx, 0x0000);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 16, 0x9694);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0014);
    memoryASet16(es, bx + 26, 0x0001);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0001);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_b288();
    sp += 0x0004;
    ax = 0;
    push(ax);
    sub_b6e4();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    ax = 0x0007;
    push(ax);
    ax = 0;
    push(ax);
    al = 0x07;
    push(ax);
    push(memoryAGet16(ds, 0xa0d6));
    push(memoryAGet16(ds, 0xa0d4));
    sub_26e6();
    sp += 0x000a;
    sub_8000();
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    sub_b6e4();
    sp++;
    sp++;
loc_6949:
    al = 0x19;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (al)
        goto loc_6949;
    goto loc_69a2;
loc_6957:
    al = 0x1d;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_69a2;
    al = 0x21;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (!al)
        goto loc_69a2;
    memoryASet(ss, bp - 1, 0x01);
    goto loc_698c;
loc_6975:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    bx = memoryAGet16(ds, 0x8246);
    es = memoryAGet16(ds, 0x8246 + 2);
    bx += ax;
    memoryASet(es, bx, 0x01);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_698c:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    dx = 0x0009;
    imul(dx);
    bx = memoryAGet16(ds, 0x8246);
    es = memoryAGet16(ds, 0x8246 + 2);
    bx += ax;
    if (memoryAGet(es, bx) != 0xff)
        goto loc_6975;
loc_69a2:
    al = 0x19;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    cbw();
    if (ax)
        goto loc_69bc;
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    cbw();
    if (!ax)
        goto loc_6957;
loc_69bc:
    al = 0x19;
    push(ax);
    sub_9984();
    sp++;
    sp++;
    if (al)
        goto loc_69bc;
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    if (al)
        goto loc_69bc;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, 0x9694);
    memoryASet16(es, bx + 4, ds);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0001);
    memoryASet16(es, bx + 14, 0x0000);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4b4e sub_6a1e()
sub_6a1e PROC
01ed:4b4e	push	bp
01ed:4b4f	mov	bp, sp
01ed:4b51	push	si
01ed:4b52	push	di
01ed:4b53	cmp	word ptr [0x6b4c], sp
01ed:4b57	ja	loc_6a2c
01ed:4b59	call	0xab83
        	loc_6a2c:
01ed:4b5c	cmp	byte ptr [0x8571], 0xff
01ed:4b61	je	loc_6a92
01ed:4b63	les	bx, ptr [0x9b9e]
01ed:4b67	mov	di, word ptr es:[bx + 0x14]
01ed:4b6b	mov	si, word ptr es:[bx + 0x16]
01ed:4b6f	mov	ax, word ptr [0x79ba]
01ed:4b72	sub	ax, di
01ed:4b74	mov	cl, 4
01ed:4b76	sar	ax, cl
01ed:4b78	dec	ax
01ed:4b79	mov	word ptr [0xa0ca], ax
01ed:4b7c	mov	ax, word ptr [0x79bc]
01ed:4b7f	sub	ax, si
01ed:4b81	sar	ax, 1
01ed:4b83	sar	ax, 1
01ed:4b85	sar	ax, 1
01ed:4b87	mov	word ptr [0xa0cc], ax
01ed:4b8a	cmp	word ptr [0xa0ca], 0
01ed:4b8f	jge	loc_6a69
01ed:4b91	mov	word ptr [0xa0ca], 0
01ed:4b97	jmp	loc_6a76
        	loc_6a69:
01ed:4b99	cmp	word ptr [0xa0ca], 0x12
01ed:4b9e	jle	loc_6a76
01ed:4ba0	mov	word ptr [0xa0ca], 0x12
        	loc_6a76:
01ed:4ba6	cmp	word ptr [0xa0cc], 0
01ed:4bab	jge	loc_6a85
01ed:4bad	mov	word ptr [0xa0cc], 0
01ed:4bb3	jmp	loc_6a92
        	loc_6a85:
01ed:4bb5	cmp	word ptr [0xa0cc], 0x16
01ed:4bba	jle	loc_6a92
01ed:4bbc	mov	word ptr [0xa0cc], 0x16
        	loc_6a92:
01ed:4bc2	pop	di
01ed:4bc3	pop	si
01ed:4bc4	pop	bp
01ed:4bc5	ret	
sub_6a1e ENDP
*/
void sub_6a1e()
{
    // coverage: 0x5d4e-0x5dc6 method sub_6a1e
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6a2c;
    sub_ca53();
loc_6a2c:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_6a92;
    bx = memoryAGet16(ds, 0x9b9e);
    es = memoryAGet16(ds, 0x9b9e + 2);
    di = memoryAGet16(es, bx + 20);
    si = memoryAGet16(es, bx + 22);
    ax = memoryAGet16(ds, 0x79ba);
    ax -= di;
    cl = 0x04;
    ax = sar(ax, cl);
    ax--;
    memoryASet16(ds, 0xa0ca, ax);
    ax = memoryAGet16(ds, 0x79bc);
    ax -= si;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet16(ds, 0xa0cc, ax);
    if ((short)memoryAGet16(ds, 0xa0ca) >= (short)0x0000)
        goto loc_6a69;
    memoryASet16(ds, 0xa0ca, 0x0000);
    goto loc_6a76;
loc_6a69:
    if ((short)memoryAGet16(ds, 0xa0ca) <= (short)0x0012)
        goto loc_6a76;
    memoryASet16(ds, 0xa0ca, 0x0012);
loc_6a76:
    if ((short)memoryAGet16(ds, 0xa0cc) >= (short)0x0000)
        goto loc_6a85;
    memoryASet16(ds, 0xa0cc, 0x0000);
    goto loc_6a92;
loc_6a85:
    if ((short)memoryAGet16(ds, 0xa0cc) <= (short)0x0016)
        goto loc_6a92;
    memoryASet16(ds, 0xa0cc, 0x0016);
loc_6a92:
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4bc6 sub_6a96()
sub_6a96 PROC
01ed:4bc6	push	bp
01ed:4bc7	mov	bp, sp
01ed:4bc9	sub	sp, 4
01ed:4bcc	cmp	word ptr [0x6b4c], sp
01ed:4bd0	ja	loc_6aa5
01ed:4bd2	call	0xab83
        	loc_6aa5:
01ed:4bd5	mov	al, byte ptr [bp + 4]
01ed:4bd8	mov	byte ptr [0x8562], al
01ed:4bdb	mov	ah, 0
01ed:4bdd	shl	ax, 1
01ed:4bdf	shl	ax, 1
01ed:4be1	mov	bx, ax
01ed:4be3	mov	ax, word ptr [bx + 0x2522]
01ed:4be7	mov	dx, word ptr [bx + 0x2520]
01ed:4beb	mov	word ptr [bp - 4], dx
01ed:4bee	mov	word ptr [bp - 2], ax
01ed:4bf1	les	bx, ptr [bp - 4]
01ed:4bf4	mov	al, byte ptr es:[bx]
01ed:4bf7	mov	byte ptr [0xa1b0], al
01ed:4bfa	mov	al, byte ptr es:[bx + 1]
01ed:4bfe	mov	byte ptr [0x9d2f], al
01ed:4c01	mov	ax, word ptr es:[bx + 4]
01ed:4c05	mov	dx, word ptr es:[bx + 2]
01ed:4c09	mov	word ptr [0xa0ba], dx
01ed:4c0d	mov	word ptr [0xa0bc], ax
01ed:4c10	mov	sp, bp
01ed:4c12	pop	bp
01ed:4c13	ret	
sub_6a96 ENDP
*/
void sub_6a96()
{
    // coverage: 0x5dc6-0x5e14 method sub_6a96
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6aa5;
    sub_ca53();
loc_6aa5:
    al = memoryAGet(ss, bp + 4);
    memoryASet(ds, 0x8562, al);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 9506);
    dx = memoryAGet16(ds, bx + 9504);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ds, 0xa1b0, al);
    al = memoryAGet(es, bx + 1);
    memoryASet(ds, 0x9d2f, al);
    ax = memoryAGet16(es, bx + 4);
    dx = memoryAGet16(es, bx + 2);
    memoryASet16(ds, 0xa0ba, dx);
    memoryASet16(ds, 0xa0bc, ax);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4c14 sub_6ae4()
sub_6ae4 PROC
01ed:4c14	push	bp
01ed:4c15	mov	bp, sp
01ed:4c17	cmp	word ptr [0x6b4c], sp
01ed:4c1b	ja	loc_6af0
01ed:4c1d	call	0xab83
        	loc_6af0:
01ed:4c20	mov	al, byte ptr [0x8243]
01ed:4c23	xor	al, 1
01ed:4c25	mov	byte ptr [0x8243], al
01ed:4c28	cmp	byte ptr [0x8243], 0
01ed:4c2d	je	loc_6b67
01ed:4c2f	cmp	byte ptr [0x8571], 0xff
01ed:4c34	je	loc_6b67
01ed:4c36	les	bx, ptr [0xa0ba]
01ed:4c3a	mov	ax, word ptr es:[bx]
01ed:4c3d	mov	word ptr [0x8560], ax
01ed:4c40	cmp	byte ptr [0x9d2f], 0
01ed:4c45	je	loc_6b2b
01ed:4c47	mov	ax, word ptr es:[bx + 2]
01ed:4c4b	neg	ax
01ed:4c4d	mov	dx, word ptr [0x79ba]
01ed:4c51	add	dx, ax
01ed:4c53	mov	word ptr [0x79ba], dx
01ed:4c57	mov	ax, dx
01ed:4c59	jmp	loc_6b3a
        	loc_6b2b:
01ed:4c5b	les	bx, ptr [0xa0ba]
01ed:4c5f	mov	ax, word ptr es:[bx + 2]
01ed:4c63	add	word ptr [0x79ba], ax
01ed:4c67	mov	ax, word ptr [0x79ba]
        	loc_6b3a:
01ed:4c6a	les	bx, ptr [0xa0ba]
01ed:4c6e	mov	ax, word ptr es:[bx + 4]
01ed:4c72	add	word ptr [0x79bc], ax
01ed:4c76	add	word ptr [0xa0ba], 6
01ed:4c7b	mov	al, byte ptr [0xa1b0]
01ed:4c7e	add	al, 0xff
01ed:4c80	mov	byte ptr [0xa1b0], al
01ed:4c83	mov	ah, 0
01ed:4c85	or	ax, ax
01ed:4c87	jne	loc_6b60
01ed:4c89	mov	al, 0
01ed:4c8b	mov	byte ptr [0x8563], al
01ed:4c8e	jmp	loc_6b67
        	loc_6b60:
01ed:4c90	inc	byte ptr [0x8563]
01ed:4c94	mov	al, byte ptr [0x8563]
        	loc_6b67:
01ed:4c97	pop	bp
01ed:4c98	ret	
sub_6ae4 ENDP
*/
void sub_6ae4()
{
    // coverage: 0x5e14-0x5e99 method sub_6ae4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6af0;
    sub_ca53();
loc_6af0:
    al = memoryAGet(ds, 0x8243);
    al ^= 0x01;
    memoryASet(ds, 0x8243, al);
    if (memoryAGet(ds, 0x8243) == 0x00)
        goto loc_6b67;
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_6b67;
    bx = memoryAGet16(ds, 0xa0ba);
    es = memoryAGet16(ds, 0xa0ba + 2);
    ax = memoryAGet16(es, bx);
    memoryASet16(ds, 0x8560, ax);
    if (memoryAGet(ds, 0x9d2f) == 0x00)
        goto loc_6b2b;
    ax = memoryAGet16(es, bx + 2);
    ax = -ax;
    dx = memoryAGet16(ds, 0x79ba);
    dx += ax;
    memoryASet16(ds, 0x79ba, dx);
    ax = dx;
    goto loc_6b3a;
loc_6b2b:
    bx = memoryAGet16(ds, 0xa0ba);
    es = memoryAGet16(ds, 0xa0ba + 2);
    ax = memoryAGet16(es, bx + 2);
    memoryASet16(ds, 0x79ba, memoryAGet16(ds, 0x79ba) + ax);
    ax = memoryAGet16(ds, 0x79ba);
loc_6b3a:
    bx = memoryAGet16(ds, 0xa0ba);
    es = memoryAGet16(ds, 0xa0ba + 2);
    ax = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x79bc, memoryAGet16(ds, 0x79bc) + ax);
    memoryASet16(ds, 0xa0ba, memoryAGet16(ds, 0xa0ba) + 0x0006);
    al = memoryAGet(ds, 0xa1b0);
    al += 0xff;
    memoryASet(ds, 0xa1b0, al);
    ah = 0x00;
    if (ax)
        goto loc_6b60;
    al = 0x00;
    memoryASet(ds, 0x8563, al);
    goto loc_6b67;
loc_6b60:
    memoryASet(ds, 0x8563, memoryAGet(ds, 0x8563) + 1);
    al = memoryAGet(ds, 0x8563);
loc_6b67:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4c99 sub_6b69()
sub_6b69 PROC
01ed:4c99	push	bp
01ed:4c9a	mov	bp, sp
01ed:4c9c	cmp	word ptr [0x6b4c], sp
01ed:4ca0	ja	loc_6b75
01ed:4ca2	call	0xab83
        	loc_6b75:
01ed:4ca5	cmp	byte ptr [0x8243], 0
01ed:4caa	jne	loc_6b7f
01ed:4cac	jmp	loc_6c8d
        	loc_6b7f:
01ed:4caf	cmp	byte ptr [0x8571], 0xff
01ed:4cb4	jne	loc_6b89
01ed:4cb6	jmp	loc_6c8d
        	loc_6b89:
01ed:4cb9	cmp	byte ptr [0xa1b0], 0
01ed:4cbe	je	loc_6b96
01ed:4cc0	call	0x5003
01ed:4cc3	jmp	loc_6c8d
        	loc_6b96:
01ed:4cc6	mov	al, 1
01ed:4cc8	mov	byte ptr [0xa1b2], al
01ed:4ccb	mov	byte ptr [0xa0e2], al
01ed:4cce	mov	byte ptr [0xa0e1], al
01ed:4cd1	mov	byte ptr [0xa0e0], al
01ed:4cd4	cmp	byte ptr [0x8571], 8
01ed:4cd9	jb	loc_6bc9
01ed:4cdb	mov	al, byte ptr [0x8571]
01ed:4cde	mov	ah, 0
01ed:4ce0	mov	es, word ptr [0xa0da]
01ed:4ce4	add	ax, word ptr [0xa0d8]
01ed:4ce8	mov	bx, ax
01ed:4cea	mov	al, byte ptr es:[bx - 8]
01ed:4cee	mov	ah, 0
01ed:4cf0	or	ax, ax
01ed:4cf2	jne	loc_6bc9
01ed:4cf4	mov	byte ptr [0xa0e0], 0
        	loc_6bc9:
01ed:4cf9	cmp	byte ptr [0x8571], 0x28
01ed:4cfe	jae	loc_6be9
01ed:4d00	mov	al, byte ptr [0x8571]
01ed:4d03	mov	ah, 0
01ed:4d05	les	bx, ptr [0xa0d8]
01ed:4d09	add	bx, ax
01ed:4d0b	mov	al, byte ptr es:[bx]
01ed:4d0e	mov	ah, 0
01ed:4d10	or	ax, ax
01ed:4d12	jne	loc_6be9
01ed:4d14	mov	byte ptr [0xa0e1], 0
        	loc_6be9:
01ed:4d19	cmp	byte ptr [0x8564], 0
01ed:4d1e	je	loc_6c21
01ed:4d20	mov	al, byte ptr [0x8571]
01ed:4d23	mov	ah, 0
01ed:4d25	les	bx, ptr [0xa0d8]
01ed:4d29	add	bx, ax
01ed:4d2b	mov	al, byte ptr es:[bx + 0x2f]
01ed:4d2f	mov	ah, 0
01ed:4d31	or	ax, ax
01ed:4d33	jne	loc_6c21
01ed:4d35	mov	byte ptr [0xa0e2], 0
01ed:4d3a	mov	al, byte ptr [0x8571]
01ed:4d3d	mov	ah, 0
01ed:4d3f	add	ax, word ptr [0xa0d8]
01ed:4d43	mov	bx, ax
01ed:4d45	cmp	byte ptr es:[bx - 1], 0xb
01ed:4d4a	jne	loc_6c21
01ed:4d4c	mov	byte ptr [0xa0e2], 1
        	loc_6c21:
01ed:4d51	cmp	byte ptr [0x8564], 7
01ed:4d56	je	loc_6c59
01ed:4d58	mov	al, byte ptr [0x8571]
01ed:4d5b	mov	ah, 0
01ed:4d5d	les	bx, ptr [0xa0d8]
01ed:4d61	add	bx, ax
01ed:4d63	mov	al, byte ptr es:[bx + 0x30]
01ed:4d67	mov	ah, 0
01ed:4d69	or	ax, ax
01ed:4d6b	jne	loc_6c59
01ed:4d6d	mov	byte ptr [0xa1b2], 0
01ed:4d72	mov	al, byte ptr [0x8571]
01ed:4d75	mov	ah, 0
01ed:4d77	add	ax, word ptr [0xa0d8]
01ed:4d7b	mov	bx, ax
01ed:4d7d	cmp	byte ptr es:[bx + 1], 0xb
01ed:4d82	jne	loc_6c59
01ed:4d84	mov	byte ptr [0xa1b2], 1
        	loc_6c59:
01ed:4d89	mov	al, byte ptr [0xa0e0]
01ed:4d8c	mov	ah, 0
01ed:4d8e	mov	dl, byte ptr [0xa0e1]
01ed:4d92	mov	dh, 0
01ed:4d94	add	ax, dx
01ed:4d96	mov	dl, byte ptr [0xa0e2]
01ed:4d9a	mov	dh, 0
01ed:4d9c	add	ax, dx
01ed:4d9e	mov	dl, byte ptr [0xa1b2]
01ed:4da2	mov	dh, 0
01ed:4da4	add	ax, dx
01ed:4da6	cmp	ax, 4
01ed:4da9	jne	loc_6c80
01ed:4dab	call	0x4fd3
01ed:4dae	jmp	loc_6c8d
        	loc_6c80:
01ed:4db0	mov	al, byte ptr [0x8562]
01ed:4db3	mov	ah, 0
01ed:4db5	shl	ax, 1
01ed:4db7	mov	bx, ax
01ed:4db9	call	word ptr [bx + 0x870]
        	loc_6c8d:
01ed:4dbd	pop	bp
01ed:4dbe	ret	
sub_6b69 ENDP
*/
void sub_6b69()
{
    // coverage: 0x5e99-0x5fbf method sub_6b69
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6b75;
    sub_ca53();
loc_6b75:
    if (memoryAGet(ds, 0x8243) != 0x00)
        goto loc_6b7f;
    goto loc_6c8d;
loc_6b7f:
    if (memoryAGet(ds, 0x8571) != 0xff)
        goto loc_6b89;
    goto loc_6c8d;
loc_6b89:
    if (memoryAGet(ds, 0xa1b0) == 0x00)
        goto loc_6b96;
    sub_6ed3();
    goto loc_6c8d;
loc_6b96:
    al = 0x01;
    memoryASet(ds, 0xa1b2, al);
    memoryASet(ds, 0xa0e2, al);
    memoryASet(ds, 0xa0e1, al);
    memoryASet(ds, 0xa0e0, al);
    if (memoryAGet(ds, 0x8571) < 0x08)
        goto loc_6bc9;
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    es = memoryAGet16(ds, 0xa0da);
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    al = memoryAGet(es, bx + 65528);
    ah = 0x00;
    if (ax)
        goto loc_6bc9;
    memoryASet(ds, 0xa0e0, 0x00);
loc_6bc9:
    if (memoryAGet(ds, 0x8571) >= 0x28)
        goto loc_6be9;
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    ah = 0x00;
    if (ax)
        goto loc_6be9;
    memoryASet(ds, 0xa0e1, 0x00);
loc_6be9:
    if (memoryAGet(ds, 0x8564) == 0x00)
        goto loc_6c21;
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 47);
    ah = 0x00;
    if (ax)
        goto loc_6c21;
    memoryASet(ds, 0xa0e2, 0x00);
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    if (memoryAGet(es, bx + 65535) != 0x0b)
        goto loc_6c21;
    memoryASet(ds, 0xa0e2, 0x01);
loc_6c21:
    if (memoryAGet(ds, 0x8564) == 0x07)
        goto loc_6c59;
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 48);
    ah = 0x00;
    if (ax)
        goto loc_6c59;
    memoryASet(ds, 0xa1b2, 0x00);
    al = memoryAGet(ds, 0x8571);
    ah = 0x00;
    ax += memoryAGet16(ds, 0xa0d8);
    bx = ax;
    if (memoryAGet(es, bx + 1) != 0x0b)
        goto loc_6c59;
    memoryASet(ds, 0xa1b2, 0x01);
loc_6c59:
    al = memoryAGet(ds, 0xa0e0);
    ah = 0x00;
    dl = memoryAGet(ds, 0xa0e1);
    dh = 0x00;
    ax += dx;
    dl = memoryAGet(ds, 0xa0e2);
    dh = 0x00;
    ax += dx;
    dl = memoryAGet(ds, 0xa1b2);
    dh = 0x00;
    ax += dx;
    if (ax != 0x0004)
        goto loc_6c80;
    sub_6ea3();
    goto loc_6c8d;
loc_6c80:
    al = memoryAGet(ds, 0x8562);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    callIndirect(cs, memoryAGet16(ds, bx + 2160));
loc_6c8d:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4dbf sub_6c8f()
sub_6c8f PROC
01ed:4dbf	push	bp
01ed:4dc0	mov	bp, sp
01ed:4dc2	cmp	word ptr [0x6b4c], sp
01ed:4dc6	ja	loc_6c9b
01ed:4dc8	call	0xab83
        	loc_6c9b:
01ed:4dcb	mov	al, byte ptr [0xa0e0]
01ed:4dce	mov	ah, 0
01ed:4dd0	or	ax, ax
01ed:4dd2	jne	loc_6ca9
01ed:4dd4	call	0x4dfa
01ed:4dd7	jmp	loc_6cc8
        	loc_6ca9:
01ed:4dd9	mov	al, byte ptr [0xa1b2]
01ed:4ddc	mov	ah, 0
01ed:4dde	or	ax, ax
01ed:4de0	jne	loc_6cb7
01ed:4de2	call	0x4f89
01ed:4de5	jmp	loc_6cc8
        	loc_6cb7:
01ed:4de7	mov	al, byte ptr [0xa0e2]
01ed:4dea	mov	ah, 0
01ed:4dec	or	ax, ax
01ed:4dee	jne	loc_6cc5
01ed:4df0	call	0x4f04
01ed:4df3	jmp	loc_6cc8
        	loc_6cc5:
01ed:4df5	call	0x4e7f
        	loc_6cc8:
01ed:4df8	pop	bp
01ed:4df9	ret	
sub_6c8f ENDP
*/
void sub_6c8f()
{
    // coverage: 0x5fbf-0x5ffa method sub_6c8f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6c9b;
    sub_ca53();
loc_6c9b:
    al = memoryAGet(ds, 0xa0e0);
    ah = 0x00;
    if (ax)
        goto loc_6ca9;
    sub_6cca();
    goto loc_6cc8;
loc_6ca9:
    al = memoryAGet(ds, 0xa1b2);
    ah = 0x00;
    if (ax)
        goto loc_6cb7;
    sub_6e59();
    goto loc_6cc8;
loc_6cb7:
    al = memoryAGet(ds, 0xa0e2);
    ah = 0x00;
    if (ax)
        goto loc_6cc5;
    sub_6dd4();
    goto loc_6cc8;
loc_6cc5:
    sub_6d4f();
loc_6cc8:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4dfa sub_6cca()
sub_6cca PROC
01ed:4dfa	push	bp
01ed:4dfb	mov	bp, sp
01ed:4dfd	cmp	word ptr [0x6b4c], sp
01ed:4e01	ja	loc_6cd6
01ed:4e03	call	0xab83
        	loc_6cd6:
01ed:4e06	mov	al, byte ptr [0x79b3]
01ed:4e09	cmp	al, byte ptr [0x7920]
01ed:4e0d	jb	loc_6ce3
01ed:4e0f	mov	al, 1
01ed:4e11	jmp	loc_6d0c
        	loc_6ce3:
01ed:4e13	test	byte ptr [0x79b3], 1
01ed:4e18	je	loc_6cff
01ed:4e1a	cmp	byte ptr [0xa0e2], 0
01ed:4e1f	je	loc_6cf5
01ed:4e21	mov	al, 1
01ed:4e23	jmp	loc_6d0c
        	loc_6cf5:
01ed:4e25	mov	al, 3
01ed:4e27	push	ax
01ed:4e28	call	0x4bc6
01ed:4e2b	inc	sp
01ed:4e2c	inc	sp
01ed:4e2d	jmp	loc_6d12
        	loc_6cff:
01ed:4e2f	cmp	byte ptr [0xa1b2], 0
01ed:4e34	je	loc_6d0a
01ed:4e36	mov	al, 1
01ed:4e38	jmp	loc_6d0c
        	loc_6d0a:
01ed:4e3a	mov	al, 4
        	loc_6d0c:
01ed:4e3c	push	ax
01ed:4e3d	call	0x4bc6
01ed:4e40	inc	sp
01ed:4e41	inc	sp
        	loc_6d12:
01ed:4e42	pop	bp
01ed:4e43	ret	
sub_6cca ENDP
*/
void sub_6cca()
{
    // coverage: 0x5ffa-0x6044 method sub_6cca
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6cd6;
    sub_ca53();
loc_6cd6:
    al = memoryAGet(ds, 0x79b3);
    if (al < memoryAGet(ds, 0x7920))
        goto loc_6ce3;
    al = 0x01;
    goto loc_6d0c;
loc_6ce3:
    if (!(memoryAGet(ds, 0x79b3) & 0x01))
        goto loc_6cff;
    if (memoryAGet(ds, 0xa0e2) == 0x00)
        goto loc_6cf5;
    al = 0x01;
    goto loc_6d0c;
loc_6cf5:
    al = 0x03;
    push(ax);
    sub_6a96();
    sp++;
    sp++;
    goto loc_6d12;
loc_6cff:
    if (memoryAGet(ds, 0xa1b2) == 0x00)
        goto loc_6d0a;
    al = 0x01;
    goto loc_6d0c;
loc_6d0a:
    al = 0x04;
loc_6d0c:
    push(ax);
    sub_6a96();
    sp++;
    sp++;
loc_6d12:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4e44 sub_6d14()
sub_6d14 PROC
01ed:4e44	push	bp
01ed:4e45	mov	bp, sp
01ed:4e47	cmp	word ptr [0x6b4c], sp
01ed:4e4b	ja	loc_6d20
01ed:4e4d	call	0xab83
        	loc_6d20:
01ed:4e50	mov	al, byte ptr [0xa0e1]
01ed:4e53	mov	ah, 0
01ed:4e55	or	ax, ax
01ed:4e57	jne	loc_6d2e
01ed:4e59	call	0x4e7f
01ed:4e5c	jmp	loc_6d4d
        	loc_6d2e:
01ed:4e5e	mov	al, byte ptr [0xa0e2]
01ed:4e61	mov	ah, 0
01ed:4e63	or	ax, ax
01ed:4e65	jne	loc_6d3c
01ed:4e67	call	0x4f04
01ed:4e6a	jmp	loc_6d4d
        	loc_6d3c:
01ed:4e6c	mov	al, byte ptr [0xa1b2]
01ed:4e6f	mov	ah, 0
01ed:4e71	or	ax, ax
01ed:4e73	jne	loc_6d4a
01ed:4e75	call	0x4f89
01ed:4e78	jmp	loc_6d4d
        	loc_6d4a:
01ed:4e7a	call	0x4dfa
        	loc_6d4d:
01ed:4e7d	pop	bp
01ed:4e7e	ret	
sub_6d14 ENDP
*/
void sub_6d14()
{
    // coverage: 0x6044-0x607f method sub_6d14
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6d20;
    sub_ca53();
loc_6d20:
    al = memoryAGet(ds, 0xa0e1);
    ah = 0x00;
    if (ax)
        goto loc_6d2e;
    sub_6d4f();
    goto loc_6d4d;
loc_6d2e:
    al = memoryAGet(ds, 0xa0e2);
    ah = 0x00;
    if (ax)
        goto loc_6d3c;
    sub_6dd4();
    goto loc_6d4d;
loc_6d3c:
    al = memoryAGet(ds, 0xa1b2);
    ah = 0x00;
    if (ax)
        goto loc_6d4a;
    sub_6e59();
    goto loc_6d4d;
loc_6d4a:
    sub_6cca();
loc_6d4d:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4e7f sub_6d4f()
sub_6d4f PROC
01ed:4e7f	push	bp
01ed:4e80	mov	bp, sp
01ed:4e82	cmp	word ptr [0x6b4c], sp
01ed:4e86	ja	loc_6d5b
01ed:4e88	call	0xab83
        	loc_6d5b:
01ed:4e8b	mov	al, byte ptr [0x79b3]
01ed:4e8e	cmp	al, byte ptr [0x7920]
01ed:4e92	jb	loc_6d68
01ed:4e94	mov	al, 2
01ed:4e96	jmp	loc_6d91
        	loc_6d68:
01ed:4e98	test	byte ptr [0x79b3], 1
01ed:4e9d	je	loc_6d84
01ed:4e9f	cmp	byte ptr [0xa0e2], 0
01ed:4ea4	je	loc_6d7a
01ed:4ea6	mov	al, 2
01ed:4ea8	jmp	loc_6d91
        	loc_6d7a:
01ed:4eaa	mov	al, 3
01ed:4eac	push	ax
01ed:4ead	call	0x4bc6
01ed:4eb0	inc	sp
01ed:4eb1	inc	sp
01ed:4eb2	jmp	loc_6d97
        	loc_6d84:
01ed:4eb4	cmp	byte ptr [0xa1b2], 0
01ed:4eb9	je	loc_6d8f
01ed:4ebb	mov	al, 2
01ed:4ebd	jmp	loc_6d91
        	loc_6d8f:
01ed:4ebf	mov	al, 4
        	loc_6d91:
01ed:4ec1	push	ax
01ed:4ec2	call	0x4bc6
01ed:4ec5	inc	sp
01ed:4ec6	inc	sp
        	loc_6d97:
01ed:4ec7	pop	bp
01ed:4ec8	ret	
sub_6d4f ENDP
*/
void sub_6d4f()
{
    // coverage: 0x607f-0x60c9 method sub_6d4f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6d5b;
    sub_ca53();
loc_6d5b:
    al = memoryAGet(ds, 0x79b3);
    if (al < memoryAGet(ds, 0x7920))
        goto loc_6d68;
    al = 0x02;
    goto loc_6d91;
loc_6d68:
    if (!(memoryAGet(ds, 0x79b3) & 0x01))
        goto loc_6d84;
    if (memoryAGet(ds, 0xa0e2) == 0x00)
        goto loc_6d7a;
    al = 0x02;
    goto loc_6d91;
loc_6d7a:
    al = 0x03;
    push(ax);
    sub_6a96();
    sp++;
    sp++;
    goto loc_6d97;
loc_6d84:
    if (memoryAGet(ds, 0xa1b2) == 0x00)
        goto loc_6d8f;
    al = 0x02;
    goto loc_6d91;
loc_6d8f:
    al = 0x04;
loc_6d91:
    push(ax);
    sub_6a96();
    sp++;
    sp++;
loc_6d97:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4ec9 sub_6d99()
sub_6d99 PROC
01ed:4ec9	push	bp
01ed:4eca	mov	bp, sp
01ed:4ecc	cmp	word ptr [0x6b4c], sp
01ed:4ed0	ja	loc_6da5
01ed:4ed2	call	0xab83
        	loc_6da5:
01ed:4ed5	mov	al, byte ptr [0xa0e2]
01ed:4ed8	mov	ah, 0
01ed:4eda	or	ax, ax
01ed:4edc	jne	loc_6db3
01ed:4ede	call	0x4f04
01ed:4ee1	jmp	loc_6dd2
        	loc_6db3:
01ed:4ee3	mov	al, byte ptr [0xa0e0]
01ed:4ee6	mov	ah, 0
01ed:4ee8	or	ax, ax
01ed:4eea	jne	loc_6dc1
01ed:4eec	call	0x4dfa
01ed:4eef	jmp	loc_6dd2
        	loc_6dc1:
01ed:4ef1	mov	al, byte ptr [0xa0e1]
01ed:4ef4	mov	ah, 0
01ed:4ef6	or	ax, ax
01ed:4ef8	jne	loc_6dcf
01ed:4efa	call	0x4e7f
01ed:4efd	jmp	loc_6dd2
        	loc_6dcf:
01ed:4eff	call	0x4f89
        	loc_6dd2:
01ed:4f02	pop	bp
01ed:4f03	ret	
sub_6d99 ENDP
*/
void sub_6d99()
{
    // coverage: 0x60c9-0x6104 method sub_6d99
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6da5;
    sub_ca53();
loc_6da5:
    al = memoryAGet(ds, 0xa0e2);
    ah = 0x00;
    if (ax)
        goto loc_6db3;
    sub_6dd4();
    goto loc_6dd2;
loc_6db3:
    al = memoryAGet(ds, 0xa0e0);
    ah = 0x00;
    if (ax)
        goto loc_6dc1;
    sub_6cca();
    goto loc_6dd2;
loc_6dc1:
    al = memoryAGet(ds, 0xa0e1);
    ah = 0x00;
    if (ax)
        goto loc_6dcf;
    sub_6d4f();
    goto loc_6dd2;
loc_6dcf:
    sub_6e59();
loc_6dd2:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4f04 sub_6dd4()
sub_6dd4 PROC
01ed:4f04	push	bp
01ed:4f05	mov	bp, sp
01ed:4f07	cmp	word ptr [0x6b4c], sp
01ed:4f0b	ja	loc_6de0
01ed:4f0d	call	0xab83
        	loc_6de0:
01ed:4f10	mov	al, byte ptr [0x79b3]
01ed:4f13	cmp	al, byte ptr [0x7920]
01ed:4f17	jb	loc_6ded
01ed:4f19	mov	al, 3
01ed:4f1b	jmp	loc_6e16
        	loc_6ded:
01ed:4f1d	test	byte ptr [0x79b3], 1
01ed:4f22	je	loc_6e09
01ed:4f24	cmp	byte ptr [0xa0e0], 0
01ed:4f29	je	loc_6dff
01ed:4f2b	mov	al, 3
01ed:4f2d	jmp	loc_6e16
        	loc_6dff:
01ed:4f2f	mov	al, 1
01ed:4f31	push	ax
01ed:4f32	call	0x4bc6
01ed:4f35	inc	sp
01ed:4f36	inc	sp
01ed:4f37	jmp	loc_6e1c
        	loc_6e09:
01ed:4f39	cmp	byte ptr [0xa0e1], 0
01ed:4f3e	je	loc_6e14
01ed:4f40	mov	al, 3
01ed:4f42	jmp	loc_6e16
        	loc_6e14:
01ed:4f44	mov	al, 2
        	loc_6e16:
01ed:4f46	push	ax
01ed:4f47	call	0x4bc6
01ed:4f4a	inc	sp
01ed:4f4b	inc	sp
        	loc_6e1c:
01ed:4f4c	pop	bp
01ed:4f4d	ret	
sub_6dd4 ENDP
*/
void sub_6dd4()
{
    // coverage: 0x6104-0x614e method sub_6dd4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6de0;
    sub_ca53();
loc_6de0:
    al = memoryAGet(ds, 0x79b3);
    if (al < memoryAGet(ds, 0x7920))
        goto loc_6ded;
    al = 0x03;
    goto loc_6e16;
loc_6ded:
    if (!(memoryAGet(ds, 0x79b3) & 0x01))
        goto loc_6e09;
    if (memoryAGet(ds, 0xa0e0) == 0x00)
        goto loc_6dff;
    al = 0x03;
    goto loc_6e16;
loc_6dff:
    al = 0x01;
    push(ax);
    sub_6a96();
    sp++;
    sp++;
    goto loc_6e1c;
loc_6e09:
    if (memoryAGet(ds, 0xa0e1) == 0x00)
        goto loc_6e14;
    al = 0x03;
    goto loc_6e16;
loc_6e14:
    al = 0x02;
loc_6e16:
    push(ax);
    sub_6a96();
    sp++;
    sp++;
loc_6e1c:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4f4e sub_6e1e()
sub_6e1e PROC
01ed:4f4e	push	bp
01ed:4f4f	mov	bp, sp
01ed:4f51	cmp	word ptr [0x6b4c], sp
01ed:4f55	ja	loc_6e2a
01ed:4f57	call	0xab83
        	loc_6e2a:
01ed:4f5a	mov	al, byte ptr [0xa1b2]
01ed:4f5d	mov	ah, 0
01ed:4f5f	or	ax, ax
01ed:4f61	jne	loc_6e38
01ed:4f63	call	0x4f89
01ed:4f66	jmp	loc_6e57
        	loc_6e38:
01ed:4f68	mov	al, byte ptr [0xa0e1]
01ed:4f6b	mov	ah, 0
01ed:4f6d	or	ax, ax
01ed:4f6f	jne	loc_6e46
01ed:4f71	call	0x4e7f
01ed:4f74	jmp	loc_6e57
        	loc_6e46:
01ed:4f76	mov	al, byte ptr [0xa0e0]
01ed:4f79	mov	ah, 0
01ed:4f7b	or	ax, ax
01ed:4f7d	jne	loc_6e54
01ed:4f7f	call	0x4dfa
01ed:4f82	jmp	loc_6e57
        	loc_6e54:
01ed:4f84	call	0x4f04
        	loc_6e57:
01ed:4f87	pop	bp
01ed:4f88	ret	
sub_6e1e ENDP
*/
void sub_6e1e()
{
    // coverage: 0x614e-0x6189 method sub_6e1e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6e2a;
    sub_ca53();
loc_6e2a:
    al = memoryAGet(ds, 0xa1b2);
    ah = 0x00;
    if (ax)
        goto loc_6e38;
    sub_6e59();
    goto loc_6e57;
loc_6e38:
    al = memoryAGet(ds, 0xa0e1);
    ah = 0x00;
    if (ax)
        goto loc_6e46;
    sub_6d4f();
    goto loc_6e57;
loc_6e46:
    al = memoryAGet(ds, 0xa0e0);
    ah = 0x00;
    if (ax)
        goto loc_6e54;
    sub_6cca();
    goto loc_6e57;
loc_6e54:
    sub_6dd4();
loc_6e57:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4f89 sub_6e59()
sub_6e59 PROC
01ed:4f89	push	bp
01ed:4f8a	mov	bp, sp
01ed:4f8c	cmp	word ptr [0x6b4c], sp
01ed:4f90	ja	loc_6e65
01ed:4f92	call	0xab83
        	loc_6e65:
01ed:4f95	mov	al, byte ptr [0x79b3]
01ed:4f98	cmp	al, byte ptr [0x7920]
01ed:4f9c	jb	loc_6e72
01ed:4f9e	mov	al, 4
01ed:4fa0	jmp	loc_6e9b
        	loc_6e72:
01ed:4fa2	test	byte ptr [0x79b3], 1
01ed:4fa7	je	loc_6e8e
01ed:4fa9	cmp	byte ptr [0xa0e0], 0
01ed:4fae	je	loc_6e84
01ed:4fb0	mov	al, 4
01ed:4fb2	jmp	loc_6e9b
        	loc_6e84:
01ed:4fb4	mov	al, 1
01ed:4fb6	push	ax
01ed:4fb7	call	0x4bc6
01ed:4fba	inc	sp
01ed:4fbb	inc	sp
01ed:4fbc	jmp	loc_6ea1
        	loc_6e8e:
01ed:4fbe	cmp	byte ptr [0xa0e1], 0
01ed:4fc3	je	loc_6e99
01ed:4fc5	mov	al, 4
01ed:4fc7	jmp	loc_6e9b
        	loc_6e99:
01ed:4fc9	mov	al, 2
        	loc_6e9b:
01ed:4fcb	push	ax
01ed:4fcc	call	0x4bc6
01ed:4fcf	inc	sp
01ed:4fd0	inc	sp
        	loc_6ea1:
01ed:4fd1	pop	bp
01ed:4fd2	ret	
sub_6e59 ENDP
*/
void sub_6e59()
{
    // coverage: 0x6189-0x61d3 method sub_6e59
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6e65;
    sub_ca53();
loc_6e65:
    al = memoryAGet(ds, 0x79b3);
    if (al < memoryAGet(ds, 0x7920))
        goto loc_6e72;
    al = 0x04;
    goto loc_6e9b;
loc_6e72:
    if (!(memoryAGet(ds, 0x79b3) & 0x01))
        goto loc_6e8e;
    if (memoryAGet(ds, 0xa0e0) == 0x00)
        goto loc_6e84;
    al = 0x04;
    goto loc_6e9b;
loc_6e84:
    al = 0x01;
    push(ax);
    sub_6a96();
    sp++;
    sp++;
    goto loc_6ea1;
loc_6e8e:
    if (memoryAGet(ds, 0xa0e1) == 0x00)
        goto loc_6e99;
    al = 0x04;
    goto loc_6e9b;
loc_6e99:
    al = 0x02;
loc_6e9b:
    push(ax);
    sub_6a96();
    sp++;
    sp++;
loc_6ea1:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:4fd3 sub_6ea3()
sub_6ea3 PROC
01ed:4fd3	push	bp
01ed:4fd4	mov	bp, sp
01ed:4fd6	dec	sp
01ed:4fd7	dec	sp
01ed:4fd8	cmp	word ptr [0x6b4c], sp
01ed:4fdc	ja	loc_6eb1
01ed:4fde	call	0xab83
        	loc_6eb1:
01ed:4fe1	mov	al, byte ptr [0x79b3]
01ed:4fe4	and	al, 3
01ed:4fe6	mov	byte ptr [bp - 2], al
01ed:4fe9	call	0x93b1
01ed:4fec	mov	byte ptr [0x79b3], al
01ed:4fef	and	al, 1
01ed:4ff1	add	al, byte ptr [bp - 2]
01ed:4ff4	add	al, 5
01ed:4ff6	mov	byte ptr [bp - 1], al
01ed:4ff9	push	ax
01ed:4ffa	call	0x4bc6
01ed:4ffd	inc	sp
01ed:4ffe	inc	sp
01ed:4fff	mov	sp, bp
01ed:5001	pop	bp
01ed:5002	ret	
sub_6ea3 ENDP
*/
void sub_6ea3()
{
    // coverage: 0x61d3-0x6203 method sub_6ea3
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6eb1;
    sub_ca53();
loc_6eb1:
    al = memoryAGet(ds, 0x79b3);
    al &= 0x03;
    memoryASet(ss, bp - 2, al);
    sub_b281();
    memoryASet(ds, 0x79b3, al);
    al &= 0x01;
    al += memoryAGet(ss, bp - 2);
    al += 0x05;
    memoryASet(ss, bp - 1, al);
    push(ax);
    sub_6a96();
    sp++;
    sp++;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5003 sub_6ed3()
sub_6ed3 PROC
01ed:5003	push	bp
01ed:5004	mov	bp, sp
01ed:5006	cmp	word ptr [0x6b4c], sp
01ed:500a	ja	loc_6edf
01ed:500c	call	0xab83
        	loc_6edf:
01ed:500f	cmp	byte ptr [0x8563], 5
01ed:5014	jne	loc_6ef3
01ed:5016	mov	al, byte ptr [0x8562]
01ed:5019	mov	ah, 0
01ed:501b	shl	ax, 1
01ed:501d	mov	bx, ax
01ed:501f	call	word ptr [bx + 0x85c]
        	loc_6ef3:
01ed:5023	pop	bp
01ed:5024	ret	
sub_6ed3 ENDP
*/
void sub_6ed3()
{
    // coverage: 0x6203-0x6225 method sub_6ed3
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6edf;
    sub_ca53();
loc_6edf:
    if (memoryAGet(ds, 0x8563) != 0x05)
        goto loc_6ef3;
    al = memoryAGet(ds, 0x8562);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    callIndirect(cs, memoryAGet16(ds, bx + 2140));
loc_6ef3:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5025 sub_6ef5()
sub_6ef5 PROC
01ed:5025	push	bp
01ed:5026	mov	bp, sp
01ed:5028	cmp	word ptr [0x6b4c], sp
01ed:502c	ja	loc_6f01
01ed:502e	call	0xab83
        	loc_6f01:
01ed:5031	mov	al, byte ptr [0x8571]
01ed:5034	add	al, 0xf8
01ed:5036	mov	byte ptr [0x8571], al
01ed:5039	dec	byte ptr [0x8565]
01ed:503d	pop	bp
01ed:503e	ret	
sub_6ef5 ENDP
*/
void sub_6ef5()
{
    // coverage: 0x6225-0x623f method sub_6ef5
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6f01;
    sub_ca53();
loc_6f01:
    al = memoryAGet(ds, 0x8571);
    al += 0xf8;
    memoryASet(ds, 0x8571, al);
    memoryASet(ds, 0x8565, memoryAGet(ds, 0x8565) - 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:503f sub_6f0f()
sub_6f0f PROC
01ed:503f	push	bp
01ed:5040	mov	bp, sp
01ed:5042	cmp	word ptr [0x6b4c], sp
01ed:5046	ja	loc_6f1b
01ed:5048	call	0xab83
        	loc_6f1b:
01ed:504b	mov	al, byte ptr [0x8571]
01ed:504e	add	al, 8
01ed:5050	mov	byte ptr [0x8571], al
01ed:5053	inc	byte ptr [0x8565]
01ed:5057	pop	bp
01ed:5058	ret	
sub_6f0f ENDP
*/
void sub_6f0f()
{
    // coverage: 0x623f-0x6259 method sub_6f0f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6f1b;
    sub_ca53();
loc_6f1b:
    al = memoryAGet(ds, 0x8571);
    al += 0x08;
    memoryASet(ds, 0x8571, al);
    memoryASet(ds, 0x8565, memoryAGet(ds, 0x8565) + 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5059 sub_6f29()
sub_6f29 PROC
01ed:5059	push	bp
01ed:505a	mov	bp, sp
01ed:505c	cmp	word ptr [0x6b4c], sp
01ed:5060	ja	loc_6f35
01ed:5062	call	0xab83
        	loc_6f35:
01ed:5065	dec	byte ptr [0x8571]
01ed:5069	dec	byte ptr [0x8564]
01ed:506d	pop	bp
01ed:506e	ret	
sub_6f29 ENDP
*/
void sub_6f29()
{
    // coverage: 0x6259-0x626f method sub_6f29
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6f35;
    sub_ca53();
loc_6f35:
    memoryASet(ds, 0x8571, memoryAGet(ds, 0x8571) - 1);
    memoryASet(ds, 0x8564, memoryAGet(ds, 0x8564) - 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:506f sub_6f3f()
sub_6f3f PROC
01ed:506f	push	bp
01ed:5070	mov	bp, sp
01ed:5072	cmp	word ptr [0x6b4c], sp
01ed:5076	ja	loc_6f4b
01ed:5078	call	0xab83
        	loc_6f4b:
01ed:507b	inc	byte ptr [0x8571]
01ed:507f	inc	byte ptr [0x8564]
01ed:5083	pop	bp
01ed:5084	ret	
sub_6f3f ENDP
*/
void sub_6f3f()
{
    // coverage: 0x626f-0x6285 method sub_6f3f
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6f4b;
    sub_ca53();
loc_6f4b:
    memoryASet(ds, 0x8571, memoryAGet(ds, 0x8571) + 1);
    memoryASet(ds, 0x8564, memoryAGet(ds, 0x8564) + 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5085 sub_6f55()
sub_6f55 PROC
01ed:5085	push	bp
01ed:5086	mov	bp, sp
01ed:5088	cmp	word ptr [0x6b4c], sp
01ed:508c	ja	loc_6f61
01ed:508e	call	0xab83
        	loc_6f61:
01ed:5091	mov	al, byte ptr [0xa0ce]
01ed:5094	mov	ah, 0
01ed:5096	or	ax, ax
01ed:5098	jne	loc_6f8e
01ed:509a	mov	ax, word ptr [0x9290]
01ed:509d	add	ax, 0xfffb
01ed:50a0	mov	word ptr [0x84c], ax
01ed:50a3	mov	ax, word ptr [0x9290]
01ed:50a6	add	ax, 6
01ed:50a9	mov	word ptr [0x84e], ax
01ed:50ac	mov	ax, word ptr [0x9292]
01ed:50af	add	ax, 0xfffb
01ed:50b2	mov	word ptr [0x850], ax
01ed:50b5	mov	ax, word ptr [0x9292]
01ed:50b8	add	ax, 5
01ed:50bb	mov	word ptr [0x852], ax
        	loc_6f8e:
01ed:50be	pop	bp
01ed:50bf	ret	
sub_6f55 ENDP
*/
void sub_6f55()
{
    // coverage: 0x6285-0x62c0 method sub_6f55
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6f61;
    sub_ca53();
loc_6f61:
    al = memoryAGet(ds, 0xa0ce);
    ah = 0x00;
    if (ax)
        goto loc_6f8e;
    ax = memoryAGet16(ds, 0x9290);
    ax += 0xfffb;
    memoryASet16(ds, 0x084c, ax);
    ax = memoryAGet16(ds, 0x9290);
    ax += 0x0006;
    memoryASet16(ds, 0x084e, ax);
    ax = memoryAGet16(ds, 0x9292);
    ax += 0xfffb;
    memoryASet16(ds, 0x0850, ax);
    ax = memoryAGet16(ds, 0x9292);
    ax += 0x0005;
    memoryASet16(ds, 0x0852, ax);
loc_6f8e:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:50c0 sub_6f90()
sub_6f90 PROC
01ed:50c0	push	bp
01ed:50c1	mov	bp, sp
01ed:50c3	cmp	word ptr [0x6b4c], sp
01ed:50c7	ja	loc_6f9c
01ed:50c9	call	0xab83
        	loc_6f9c:
01ed:50cc	mov	al, byte ptr [0xa0ce]
01ed:50cf	mov	ah, 0
01ed:50d1	or	ax, ax
01ed:50d3	jne	loc_6fc9
01ed:50d5	mov	ax, word ptr [0x79ba]
01ed:50d8	add	ax, 0xfffb
01ed:50db	mov	word ptr [0x854], ax
01ed:50de	mov	ax, word ptr [0x79ba]
01ed:50e1	add	ax, 6
01ed:50e4	mov	word ptr [0x856], ax
01ed:50e7	mov	ax, word ptr [0x79bc]
01ed:50ea	add	ax, 0xfffb
01ed:50ed	mov	word ptr [0x858], ax
01ed:50f0	mov	ax, word ptr [0x79bc]
01ed:50f3	add	ax, 5
01ed:50f6	mov	word ptr [0x85a], ax
        	loc_6fc9:
01ed:50f9	pop	bp
01ed:50fa	ret	
sub_6f90 ENDP
*/
void sub_6f90()
{
    // coverage: 0x62c0-0x62fb method sub_6f90
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6f9c;
    sub_ca53();
loc_6f9c:
    al = memoryAGet(ds, 0xa0ce);
    ah = 0x00;
    if (ax)
        goto loc_6fc9;
    ax = memoryAGet16(ds, 0x79ba);
    ax += 0xfffb;
    memoryASet16(ds, 0x0854, ax);
    ax = memoryAGet16(ds, 0x79ba);
    ax += 0x0006;
    memoryASet16(ds, 0x0856, ax);
    ax = memoryAGet16(ds, 0x79bc);
    ax += 0xfffb;
    memoryASet16(ds, 0x0858, ax);
    ax = memoryAGet16(ds, 0x79bc);
    ax += 0x0005;
    memoryASet16(ds, 0x085a, ax);
loc_6fc9:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:50fb sub_6fcb()
sub_6fcb PROC
01ed:50fb	push	bp
01ed:50fc	mov	bp, sp
01ed:50fe	cmp	word ptr [0x6b4c], sp
01ed:5102	ja	loc_6fd7
01ed:5104	call	0xab83
        	loc_6fd7:
01ed:5107	cmp	byte ptr [0x8571], 0xff
01ed:510c	je	loc_704f
01ed:510e	mov	al, byte ptr [0xa0ce]
01ed:5111	mov	ah, 0
01ed:5113	or	ax, ax
01ed:5115	jne	loc_704f
01ed:5117	mov	al, byte ptr [0x856d]
01ed:511a	mov	ah, 0
01ed:511c	or	ax, ax
01ed:511e	jne	loc_704f
01ed:5120	cmp	byte ptr [0x792c], 0x30
01ed:5125	je	loc_704f
01ed:5127	mov	ax, word ptr [0x854]
01ed:512a	cmp	ax, word ptr [0x84e]
01ed:512e	jle	loc_7007
01ed:5130	mov	byte ptr [0xa1aa], 0
01ed:5135	jmp	loc_704f
        	loc_7007:
01ed:5137	mov	ax, word ptr [0x84c]
01ed:513a	cmp	ax, word ptr [0x856]
01ed:513e	jle	loc_7017
01ed:5140	mov	byte ptr [0xa1aa], 0
01ed:5145	jmp	loc_704f
        	loc_7017:
01ed:5147	mov	ax, word ptr [0x858]
01ed:514a	cmp	ax, word ptr [0x852]
01ed:514e	jle	loc_7027
01ed:5150	mov	byte ptr [0xa1aa], 0
01ed:5155	jmp	loc_704f
        	loc_7027:
01ed:5157	mov	ax, word ptr [0x850]
01ed:515a	cmp	ax, word ptr [0x85a]
01ed:515e	jle	loc_7037
01ed:5160	mov	byte ptr [0xa1aa], 0
01ed:5165	jmp	loc_704f
        	loc_7037:
01ed:5167	mov	byte ptr [0xa1aa], 1
01ed:516c	cmp	word ptr [0x689c], 4
01ed:5171	je	loc_7047
01ed:5173	mov	al, 3
01ed:5175	jmp	loc_7049
        	loc_7047:
01ed:5177	mov	al, 0xd
        	loc_7049:
01ed:5179	push	ax
01ed:517a	call	0x6e11
01ed:517d	inc	sp
01ed:517e	inc	sp
        	loc_704f:
01ed:517f	pop	bp
01ed:5180	ret	
sub_6fcb ENDP
*/
void sub_6fcb()
{
    // coverage: 0x62fb-0x6381 method sub_6fcb
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_6fd7;
    sub_ca53();
loc_6fd7:
    if (memoryAGet(ds, 0x8571) == 0xff)
        goto loc_704f;
    al = memoryAGet(ds, 0xa0ce);
    ah = 0x00;
    if (ax)
        goto loc_704f;
    al = memoryAGet(ds, 0x856d);
    ah = 0x00;
    if (ax)
        goto loc_704f;
    if (memoryAGet(ds, 0x792c) == 0x30)
        goto loc_704f;
    ax = memoryAGet16(ds, 0x0854);
    if ((short)ax <= (short)memoryAGet16(ds, 0x084e))
        goto loc_7007;
    memoryASet(ds, 0xa1aa, 0x00);
    goto loc_704f;
loc_7007:
    ax = memoryAGet16(ds, 0x084c);
    if ((short)ax <= (short)memoryAGet16(ds, 0x0856))
        goto loc_7017;
    memoryASet(ds, 0xa1aa, 0x00);
    goto loc_704f;
loc_7017:
    ax = memoryAGet16(ds, 0x0858);
    if ((short)ax <= (short)memoryAGet16(ds, 0x0852))
        goto loc_7027;
    memoryASet(ds, 0xa1aa, 0x00);
    goto loc_704f;
loc_7027:
    ax = memoryAGet16(ds, 0x0850);
    if ((short)ax <= (short)memoryAGet16(ds, 0x085a))
        goto loc_7037;
    memoryASet(ds, 0xa1aa, 0x00);
    goto loc_704f;
loc_7037:
    memoryASet(ds, 0xa1aa, 0x01);
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_7047;
    al = 0x03;
    goto loc_7049;
loc_7047:
    al = 0x0d;
loc_7049:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_704f:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5181 sub_7051()
sub_7051 PROC
01ed:5181	push	bp
01ed:5182	mov	bp, sp
01ed:5184	cmp	word ptr [0x6b4c], sp
01ed:5188	ja	loc_705d
01ed:518a	call	0xab83
        	loc_705d:
01ed:518d	les	bx, ptr [0x574]
01ed:5191	mov	ax, word ptr [bp + 4]
01ed:5194	mov	word ptr es:[bx], ax
01ed:5197	mov	word ptr es:[bx + 6], 0
01ed:519d	mov	word ptr es:[bx + 8], 0
01ed:51a3	mov	ax, word ptr [bp + 6]
01ed:51a6	mov	word ptr es:[bx + 0xe], ax
01ed:51aa	mov	word ptr es:[bx + 0x14], 0
01ed:51b0	mov	word ptr es:[bx + 0x16], 0
01ed:51b6	mov	word ptr es:[bx + 0x1c], 0
01ed:51bc	mov	word ptr es:[bx + 0x1e], 0x14
01ed:51c2	mov	word ptr es:[bx + 0x20], 0x19
01ed:51c8	push	word ptr [0x576]
01ed:51cc	push	word ptr [0x574]
01ed:51d0	call	0x93c8
01ed:51d3	add	sp, 4
01ed:51d6	pop	bp
01ed:51d7	ret	
sub_7051 ENDP
*/
void sub_7051()
{
    // coverage: 0x6381-0x63d8 method sub_7051
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_705d;
    sub_ca53();
loc_705d:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    ax = memoryAGet16(ss, bp + 4);
    memoryASet16(es, bx, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(es, bx + 14, ax);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_b298();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:51d8 sub_70a8()
sub_70a8 PROC
01ed:51d8	push	bp
01ed:51d9	mov	bp, sp
01ed:51db	cmp	word ptr [0x6b4c], sp
01ed:51df	ja	loc_70b4
01ed:51e1	call	0xab83
        	loc_70b4:
01ed:51e4	mov	ax, word ptr [0x7928]
01ed:51e7	mov	dx, word ptr [0x7926]
01ed:51eb	add	dx, 0x63
01ed:51ee	les	bx, ptr [0x574]
01ed:51f2	mov	word ptr es:[bx + 2], dx
01ed:51f6	mov	word ptr es:[bx + 4], ax
01ed:51fa	mov	word ptr es:[bx + 6], 0
01ed:5200	mov	word ptr es:[bx + 8], 0
01ed:5206	mov	word ptr es:[bx + 0xa], 0x14
01ed:520c	mov	word ptr es:[bx + 0xc], 0x19
01ed:5212	mov	word ptr es:[bx + 0x10], 0x9d3a
01ed:5218	mov	word ptr es:[bx + 0x12], ds
01ed:521c	mov	word ptr es:[bx + 0x14], 0
01ed:5222	mov	word ptr es:[bx + 0x16], 0
01ed:5228	mov	word ptr es:[bx + 0x18], 3
01ed:522e	mov	word ptr es:[bx + 0x1a], 2
01ed:5234	mov	word ptr es:[bx + 0x1c], 0
01ed:523a	mov	word ptr es:[bx + 0x1e], 3
01ed:5240	mov	word ptr es:[bx + 0x20], 2
01ed:5246	push	word ptr [0x576]
01ed:524a	push	word ptr [0x574]
01ed:524e	call	0x80ac
01ed:5251	add	sp, 4
01ed:5254	les	bx, ptr [0x574]
01ed:5258	mov	word ptr es:[bx + 6], 4
01ed:525e	mov	word ptr es:[bx + 0x10], 0x9baf
01ed:5264	mov	word ptr es:[bx + 0x12], ds
01ed:5268	push	word ptr [0x576]
01ed:526c	push	word ptr [0x574]
01ed:5270	call	0x80ac
01ed:5273	add	sp, 4
01ed:5276	les	bx, ptr [0x574]
01ed:527a	mov	word ptr es:[bx + 6], 0
01ed:5280	mov	word ptr es:[bx + 8], 8
01ed:5286	mov	word ptr es:[bx + 0x10], 0x9eba
01ed:528c	mov	word ptr es:[bx + 0x12], ds
01ed:5290	mov	word ptr es:[bx + 0x18], 1
01ed:5296	mov	word ptr es:[bx + 0x1a], 4
01ed:529c	mov	word ptr es:[bx + 0x1e], 1
01ed:52a2	mov	word ptr es:[bx + 0x20], 4
01ed:52a8	push	word ptr [0x576]
01ed:52ac	push	word ptr [0x574]
01ed:52b0	call	0x80ac
01ed:52b3	add	sp, 4
01ed:52b6	les	bx, ptr [0x574]
01ed:52ba	mov	word ptr es:[bx + 8], 3
01ed:52c0	mov	word ptr es:[bx + 0x10], 0x9fba
01ed:52c6	mov	word ptr es:[bx + 0x12], ds
01ed:52ca	push	word ptr [0x576]
01ed:52ce	push	word ptr [0x574]
01ed:52d2	call	0x80ac
01ed:52d5	add	sp, 4
01ed:52d8	les	bx, ptr [0x574]
01ed:52dc	mov	word ptr es:[bx + 6], 0
01ed:52e2	mov	word ptr es:[bx + 8], 0xd
01ed:52e8	mov	word ptr es:[bx + 0x10], 0x8b88
01ed:52ee	mov	word ptr es:[bx + 0x12], ds
01ed:52f2	mov	word ptr es:[bx + 0x18], 6
01ed:52f8	mov	word ptr es:[bx + 0x1a], 2
01ed:52fe	mov	word ptr es:[bx + 0x1e], 6
01ed:5304	mov	word ptr es:[bx + 0x20], 2
01ed:530a	push	word ptr [0x576]
01ed:530e	push	word ptr [0x574]
01ed:5312	call	0x80ac
01ed:5315	add	sp, 4
01ed:5318	les	bx, ptr [0x574]
01ed:531c	mov	word ptr es:[bx + 8], 0x11
01ed:5322	mov	word ptr es:[bx + 0x10], 0x824e
01ed:5328	mov	word ptr es:[bx + 0x12], ds
01ed:532c	push	word ptr [0x576]
01ed:5330	push	word ptr [0x574]
01ed:5334	call	0x80ac
01ed:5337	add	sp, 4
01ed:533a	les	bx, ptr [0x574]
01ed:533e	mov	word ptr es:[bx + 8], 0x15
01ed:5344	mov	word ptr es:[bx + 0x10], 0x8582
01ed:534a	mov	word ptr es:[bx + 0x12], ds
01ed:534e	push	word ptr [0x576]
01ed:5352	push	word ptr [0x574]
01ed:5356	call	0x80ac
01ed:5359	add	sp, 4
01ed:535c	pop	bp
01ed:535d	ret	
sub_70a8 ENDP
*/
void sub_70a8()
{
    // coverage: 0x63d8-0x655e method sub_70a8
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_70b4;
    sub_ca53();
loc_70b4:
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    dx += 0x0063;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 16, 0x9d3a);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0003);
    memoryASet16(es, bx + 26, 0x0002);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0003);
    memoryASet16(es, bx + 32, 0x0002);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 6, 0x0004);
    memoryASet16(es, bx + 16, 0x9baf);
    memoryASet16(es, bx + 18, ds);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0008);
    memoryASet16(es, bx + 16, 0x9eba);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 24, 0x0001);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0004);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 8, 0x0003);
    memoryASet16(es, bx + 16, 0x9fba);
    memoryASet16(es, bx + 18, ds);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x000d);
    memoryASet16(es, bx + 16, 0x8b88);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 24, 0x0006);
    memoryASet16(es, bx + 26, 0x0002);
    memoryASet16(es, bx + 30, 0x0006);
    memoryASet16(es, bx + 32, 0x0002);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 8, 0x0011);
    memoryASet16(es, bx + 16, 0x824e);
    memoryASet16(es, bx + 18, ds);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 8, 0x0015);
    memoryASet16(es, bx + 16, 0x8582);
    memoryASet16(es, bx + 18, ds);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f7c();
    sp += 0x0004;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:535e sub_722e()
sub_722e PROC
01ed:535e	push	bp
01ed:535f	mov	bp, sp
01ed:5361	cmp	word ptr [0x6b4c], sp
01ed:5365	ja	loc_723a
01ed:5367	call	0xab83
        	loc_723a:
01ed:536a	les	bx, ptr [0x574]
01ed:536e	mov	byte ptr es:[bx + 0x22], 0
01ed:5373	mov	byte ptr es:[bx + 0x23], 0
01ed:5378	mov	byte ptr es:[bx + 0x24], 0
01ed:537d	mov	byte ptr es:[bx + 0x25], 0
01ed:5382	les	bx, ptr [0x8b8]
01ed:5386	mov	word ptr es:[bx], 1
01ed:538b	mov	word ptr es:[bx + 0x10], 0x8e8d
01ed:5391	mov	word ptr es:[bx + 0x12], ds
01ed:5395	mov	word ptr es:[bx + 0x14], 0
01ed:539b	mov	word ptr es:[bx + 0x16], 0
01ed:53a1	mov	word ptr es:[bx + 0x18], 4
01ed:53a7	mov	word ptr es:[bx + 0x1a], 4
01ed:53ad	mov	word ptr es:[bx + 0x1c], 0
01ed:53b3	les	bx, ptr [0x8ec]
01ed:53b7	mov	word ptr es:[bx], 1
01ed:53bc	mov	word ptr es:[bx + 0x10], 0x9294
01ed:53c2	mov	word ptr es:[bx + 0x12], ds
01ed:53c6	mov	word ptr es:[bx + 0x14], 0
01ed:53cc	mov	word ptr es:[bx + 0x16], 0
01ed:53d2	mov	word ptr es:[bx + 0x18], 4
01ed:53d8	mov	word ptr es:[bx + 0x1a], 4
01ed:53de	mov	word ptr es:[bx + 0x1c], 0
01ed:53e4	les	bx, ptr [0x8bc]
01ed:53e8	mov	word ptr es:[bx + 6], 0
01ed:53ee	mov	word ptr es:[bx + 8], 0
01ed:53f4	mov	word ptr es:[bx + 0xa], 1
01ed:53fa	mov	word ptr es:[bx + 0xc], 4
01ed:5400	mov	word ptr es:[bx + 0xe], 1
01ed:5406	mov	word ptr es:[bx + 0x1c], 0
01ed:540c	mov	word ptr es:[bx + 0x1e], 1
01ed:5412	mov	word ptr es:[bx + 0x20], 4
01ed:5418	les	bx, ptr [0x8c0]
01ed:541c	mov	word ptr es:[bx + 6], 0
01ed:5422	mov	word ptr es:[bx + 8], 0
01ed:5428	mov	word ptr es:[bx + 0xa], 3
01ed:542e	mov	word ptr es:[bx + 0xc], 2
01ed:5434	mov	word ptr es:[bx + 0xe], 1
01ed:543a	mov	word ptr es:[bx + 0x1c], 0
01ed:5440	mov	word ptr es:[bx + 0x1e], 2
01ed:5446	mov	word ptr es:[bx + 0x20], 2
01ed:544c	les	bx, ptr [0x8c4]
01ed:5450	mov	word ptr es:[bx + 2], 0x8e8d
01ed:5456	mov	word ptr es:[bx + 4], ds
01ed:545a	mov	word ptr es:[bx + 6], 0
01ed:5460	mov	word ptr es:[bx + 8], 0
01ed:5466	mov	word ptr es:[bx + 0xa], 4
01ed:546c	mov	word ptr es:[bx + 0xc], 4
01ed:5472	mov	word ptr es:[bx + 0xe], 1
01ed:5478	mov	word ptr es:[bx + 0x1c], 0
01ed:547e	les	bx, ptr [0x8e8]
01ed:5482	mov	word ptr es:[bx + 2], 0x9294
01ed:5488	mov	word ptr es:[bx + 4], ds
01ed:548c	mov	word ptr es:[bx + 6], 0
01ed:5492	mov	word ptr es:[bx + 8], 0
01ed:5498	mov	word ptr es:[bx + 0xa], 4
01ed:549e	mov	word ptr es:[bx + 0xc], 4
01ed:54a4	mov	word ptr es:[bx + 0xe], 1
01ed:54aa	mov	word ptr es:[bx + 0x1c], 0
01ed:54b0	les	bx, ptr [0x8c8]
01ed:54b4	mov	ax, word ptr [0x7928]
01ed:54b7	mov	dx, word ptr [0x7926]
01ed:54bb	mov	word ptr es:[bx + 2], dx
01ed:54bf	mov	word ptr es:[bx + 4], ax
01ed:54c3	mov	word ptr es:[bx + 0xa], 0x14
01ed:54c9	mov	word ptr es:[bx + 0xc], 0x19
01ed:54cf	mov	word ptr es:[bx + 0x10], 0x8888
01ed:54d5	mov	word ptr es:[bx + 0x12], ds
01ed:54d9	mov	word ptr es:[bx + 0x14], 0
01ed:54df	mov	word ptr es:[bx + 0x16], 0
01ed:54e5	mov	word ptr es:[bx + 0x18], 3
01ed:54eb	mov	word ptr es:[bx + 0x1a], 4
01ed:54f1	mov	word ptr es:[bx + 0x1c], 0
01ed:54f7	mov	word ptr es:[bx + 0x1e], 1
01ed:54fd	mov	word ptr es:[bx + 0x20], 4
01ed:5503	les	bx, ptr [0x8cc]
01ed:5507	mov	word ptr es:[bx + 6], 0
01ed:550d	mov	word ptr es:[bx + 8], 0
01ed:5513	mov	word ptr es:[bx + 0xc], 4
01ed:5519	mov	word ptr es:[bx + 0x10], 0x8888
01ed:551f	mov	word ptr es:[bx + 0x12], ds
01ed:5523	mov	word ptr es:[bx + 0xe], 1
01ed:5529	mov	word ptr es:[bx + 0x18], 3
01ed:552f	mov	word ptr es:[bx + 0x1a], 4
01ed:5535	mov	word ptr es:[bx + 0x1e], 1
01ed:553b	mov	word ptr es:[bx + 0x20], 4
01ed:5541	les	bx, ptr [0x8d0]
01ed:5545	mov	word ptr es:[bx], 1
01ed:554a	mov	word ptr es:[bx + 0x14], 0
01ed:5550	mov	word ptr es:[bx + 0x16], 0
01ed:5556	mov	word ptr es:[bx + 0x18], 1
01ed:555c	mov	word ptr es:[bx + 0x1a], 4
01ed:5562	mov	word ptr es:[bx + 0x1c], 0
01ed:5568	mov	word ptr es:[bx + 0x1e], 1
01ed:556e	mov	word ptr es:[bx + 0x20], 4
01ed:5574	les	bx, ptr [0x8d4]
01ed:5578	mov	word ptr es:[bx + 2], dx
01ed:557c	mov	word ptr es:[bx + 4], ax
01ed:5580	mov	word ptr es:[bx + 0xa], 0x14
01ed:5586	mov	word ptr es:[bx + 0xc], 0x19
01ed:558c	mov	word ptr es:[bx + 0xe], 1
01ed:5592	mov	word ptr es:[bx + 0x1e], 2
01ed:5598	mov	word ptr es:[bx + 0x20], 2
01ed:559e	les	bx, ptr [0x8d8]
01ed:55a2	mov	word ptr es:[bx + 2], dx
01ed:55a6	mov	word ptr es:[bx + 4], ax
01ed:55aa	mov	word ptr es:[bx + 0xa], 0x14
01ed:55b0	mov	word ptr es:[bx + 0xc], 0x19
01ed:55b6	mov	word ptr es:[bx + 0x10], 0x8888
01ed:55bc	mov	word ptr es:[bx + 0x12], ds
01ed:55c0	mov	word ptr es:[bx + 0x14], 0
01ed:55c6	mov	word ptr es:[bx + 0x16], 0
01ed:55cc	mov	word ptr es:[bx + 0x18], 3
01ed:55d2	mov	word ptr es:[bx + 0x1a], 4
01ed:55d8	mov	word ptr es:[bx + 0x1c], 0
01ed:55de	mov	word ptr es:[bx + 0x1e], 3
01ed:55e4	mov	word ptr es:[bx + 0x20], 2
01ed:55ea	les	bx, ptr [0x8dc]
01ed:55ee	mov	word ptr es:[bx + 6], 0
01ed:55f4	mov	word ptr es:[bx + 8], 0
01ed:55fa	mov	word ptr es:[bx + 0xa], 3
01ed:5600	mov	word ptr es:[bx + 0xe], 1
01ed:5606	mov	word ptr es:[bx + 0x10], 0x8888
01ed:560c	mov	word ptr es:[bx + 0x12], ds
01ed:5610	mov	word ptr es:[bx + 0x18], 3
01ed:5616	mov	word ptr es:[bx + 0x1a], 4
01ed:561c	mov	word ptr es:[bx + 0x1e], 3
01ed:5622	mov	word ptr es:[bx + 0x20], 2
01ed:5628	les	bx, ptr [0x8e0]
01ed:562c	mov	word ptr es:[bx], 1
01ed:5631	mov	word ptr es:[bx + 0x14], 0
01ed:5637	mov	word ptr es:[bx + 0x16], 0
01ed:563d	mov	word ptr es:[bx + 0x18], 3
01ed:5643	mov	word ptr es:[bx + 0x1a], 2
01ed:5649	mov	word ptr es:[bx + 0x1e], 3
01ed:564f	mov	word ptr es:[bx + 0x20], 2
01ed:5655	les	bx, ptr [0x8e4]
01ed:5659	mov	word ptr es:[bx + 2], dx
01ed:565d	mov	word ptr es:[bx + 4], ax
01ed:5661	mov	word ptr es:[bx + 0xa], 0x14
01ed:5667	mov	word ptr es:[bx + 0xc], 0x19
01ed:566d	mov	word ptr es:[bx + 0xe], 1
01ed:5673	mov	word ptr es:[bx + 0x1c], 0
01ed:5679	mov	word ptr es:[bx + 0x20], 2
01ed:567f	pop	bp
01ed:5680	ret	
sub_722e ENDP
*/
void sub_722e()
{
    // coverage: 0x655e-0x6881 method sub_722e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_723a;
    sub_ca53();
loc_723a:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet(es, bx + 34, 0x00);
    memoryASet(es, bx + 35, 0x00);
    memoryASet(es, bx + 36, 0x00);
    memoryASet(es, bx + 37, 0x00);
    bx = memoryAGet16(ds, 0x08b8);
    es = memoryAGet16(ds, 0x08b8 + 2);
    memoryASet16(es, bx, 0x0001);
    memoryASet16(es, bx + 16, 0x8e8d);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0004);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 28, 0x0000);
    bx = memoryAGet16(ds, 0x08ec);
    es = memoryAGet16(ds, 0x08ec + 2);
    memoryASet16(es, bx, 0x0001);
    memoryASet16(es, bx + 16, 0x9294);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0004);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 28, 0x0000);
    bx = memoryAGet16(ds, 0x08bc);
    es = memoryAGet16(ds, 0x08bc + 2);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0001);
    memoryASet16(es, bx + 12, 0x0004);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0004);
    bx = memoryAGet16(ds, 0x08c0);
    es = memoryAGet16(ds, 0x08c0 + 2);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0003);
    memoryASet16(es, bx + 12, 0x0002);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0002);
    memoryASet16(es, bx + 32, 0x0002);
    bx = memoryAGet16(ds, 0x08c4);
    es = memoryAGet16(ds, 0x08c4 + 2);
    memoryASet16(es, bx + 2, 0x8e8d);
    memoryASet16(es, bx + 4, ds);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0004);
    memoryASet16(es, bx + 12, 0x0004);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 28, 0x0000);
    bx = memoryAGet16(ds, 0x08e8);
    es = memoryAGet16(ds, 0x08e8 + 2);
    memoryASet16(es, bx + 2, 0x9294);
    memoryASet16(es, bx + 4, ds);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0004);
    memoryASet16(es, bx + 12, 0x0004);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 28, 0x0000);
    bx = memoryAGet16(ds, 0x08c8);
    es = memoryAGet16(ds, 0x08c8 + 2);
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 16, 0x8888);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0003);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0004);
    bx = memoryAGet16(ds, 0x08cc);
    es = memoryAGet16(ds, 0x08cc + 2);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 12, 0x0004);
    memoryASet16(es, bx + 16, 0x8888);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 24, 0x0003);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0004);
    bx = memoryAGet16(ds, 0x08d0);
    es = memoryAGet16(ds, 0x08d0 + 2);
    memoryASet16(es, bx, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0001);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0004);
    bx = memoryAGet16(ds, 0x08d4);
    es = memoryAGet16(ds, 0x08d4 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 30, 0x0002);
    memoryASet16(es, bx + 32, 0x0002);
    bx = memoryAGet16(ds, 0x08d8);
    es = memoryAGet16(ds, 0x08d8 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 16, 0x8888);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0003);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0003);
    memoryASet16(es, bx + 32, 0x0002);
    bx = memoryAGet16(ds, 0x08dc);
    es = memoryAGet16(ds, 0x08dc + 2);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0003);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 16, 0x8888);
    memoryASet16(es, bx + 18, ds);
    memoryASet16(es, bx + 24, 0x0003);
    memoryASet16(es, bx + 26, 0x0004);
    memoryASet16(es, bx + 30, 0x0003);
    memoryASet16(es, bx + 32, 0x0002);
    bx = memoryAGet16(ds, 0x08e0);
    es = memoryAGet16(ds, 0x08e0 + 2);
    memoryASet16(es, bx, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 24, 0x0003);
    memoryASet16(es, bx + 26, 0x0002);
    memoryASet16(es, bx + 30, 0x0003);
    memoryASet16(es, bx + 32, 0x0002);
    bx = memoryAGet16(ds, 0x08e4);
    es = memoryAGet16(ds, 0x08e4 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 32, 0x0002);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5681 sub_7551()
sub_7551 PROC
01ed:5681	push	bp
01ed:5682	mov	bp, sp
01ed:5684	sub	sp, 6
01ed:5687	push	si
01ed:5688	push	di
01ed:5689	cmp	word ptr [0x6b4c], sp
01ed:568d	ja	loc_7562
01ed:568f	call	0xab83
        	loc_7562:
01ed:5692	push	ds
01ed:5693	mov	ax, 0x928
01ed:5696	push	ax
01ed:5697	call	0x7307
01ed:569a	add	sp, 4
01ed:569d	mov	ax, word ptr [0x7928]
01ed:56a0	mov	dx, word ptr [0x7926]
01ed:56a4	mov	word ptr [0x857e], dx
01ed:56a8	mov	word ptr [0x8580], ax
01ed:56ab	mov	ax, 4
01ed:56ae	push	ax
01ed:56af	mov	ax, 3
01ed:56b2	push	ax
01ed:56b3	call	0x736f
01ed:56b6	add	sp, 4
01ed:56b9	mov	si, ax
01ed:56bb	xor	ax, ax
01ed:56bd	push	ax
01ed:56be	push	word ptr [0x94e]
01ed:56c2	push	word ptr [0x94c]
01ed:56c6	push	word ptr [0x8580]
01ed:56ca	push	word ptr [0x857e]
01ed:56ce	push	si
01ed:56cf	call	0x745e
01ed:56d2	add	sp, 0xc
01ed:56d5	mov	word ptr [bp - 4], ax
01ed:56d8	mov	word ptr [bp - 2], dx
01ed:56db	push	si
01ed:56dc	call	0x7319
01ed:56df	inc	sp
01ed:56e0	inc	sp
01ed:56e1	xor	ax, ax
01ed:56e3	mov	dx, 0x7d63
01ed:56e6	push	ax
01ed:56e7	push	dx
01ed:56e8	push	word ptr [bp - 2]
01ed:56eb	push	word ptr [bp - 4]
01ed:56ee	push	word ptr [0x8580]
01ed:56f2	push	word ptr [0x857e]
01ed:56f6	call	0x7b5a
01ed:56f9	add	sp, 0xc
01ed:56fc	cmp	word ptr [0x541d], 1
01ed:5701	jne	loc_760a
01ed:5703	mov	ax, word ptr [0x8580]
01ed:5706	mov	dx, word ptr [0x857e]
01ed:570a	mov	word ptr [0x9b96], dx
01ed:570e	mov	word ptr [0x9b98], ax
01ed:5711	mov	byte ptr [bp - 5], 0
01ed:5715	jmp	loc_7604
        	loc_75e7:
01ed:5717	mov	al, byte ptr [bp - 5]
01ed:571a	mov	ah, 0
01ed:571c	les	bx, ptr [0x9b96]
01ed:5720	add	bx, ax
01ed:5722	mov	al, byte ptr [bp - 5]
01ed:5725	mov	ah, 0
01ed:5727	mov	di, ax
01ed:5729	mov	al, byte ptr [di + 0x71e]
01ed:572d	mov	byte ptr es:[bx + 0x23], al
01ed:5731	inc	byte ptr [bp - 5]
        	loc_7604:
01ed:5734	cmp	byte ptr [bp - 5], 0x10
01ed:5738	jb	loc_75e7
        	loc_760a:
01ed:573a	call	0x3467
01ed:573d	mov	ax, word ptr [0x8580]
01ed:5740	mov	dx, word ptr [0x857e]
01ed:5744	add	dx, 0x63
01ed:5747	les	bx, ptr [0x574]
01ed:574b	mov	word ptr es:[bx + 2], dx
01ed:574f	mov	word ptr es:[bx + 4], ax
01ed:5753	mov	word ptr es:[bx + 6], 0
01ed:5759	mov	word ptr es:[bx + 8], 0
01ed:575f	mov	word ptr es:[bx + 0xa], 0x14
01ed:5765	mov	word ptr es:[bx + 0xc], 0x19
01ed:576b	mov	word ptr es:[bx + 0xe], 1
01ed:5771	mov	word ptr es:[bx + 0x14], 0
01ed:5777	mov	word ptr es:[bx + 0x16], 0
01ed:577d	mov	word ptr es:[bx + 0x1c], 0
01ed:5783	mov	word ptr es:[bx + 0x1e], 0x14
01ed:5789	mov	word ptr es:[bx + 0x20], 0x19
01ed:578f	push	word ptr [0x576]
01ed:5793	push	word ptr [0x574]
01ed:5797	call	0x80bc
01ed:579a	add	sp, 4
01ed:579d	xor	ax, ax
01ed:579f	push	ax
01ed:57a0	push	word ptr [0x8580]
01ed:57a4	push	word ptr [0x857e]
01ed:57a8	call	0x7b93
01ed:57ab	add	sp, 6
01ed:57ae	xor	ax, ax
01ed:57b0	push	ax
01ed:57b1	call	0x7bca
01ed:57b4	inc	sp
01ed:57b5	inc	sp
01ed:57b6	mov	ax, 1
01ed:57b9	push	ax
01ed:57ba	call	0x7bdd
01ed:57bd	inc	sp
01ed:57be	inc	sp
01ed:57bf	call	0x9864
01ed:57c2	les	bx, ptr [0x574]
01ed:57c6	mov	word ptr es:[bx + 0xe], 0
01ed:57cc	mov	word ptr es:[bx + 0x1e], 1
01ed:57d2	mov	word ptr es:[bx + 0x20], 2
01ed:57d8	call	0x57e1
01ed:57db	pop	di
01ed:57dc	pop	si
01ed:57dd	mov	sp, bp
01ed:57df	pop	bp
01ed:57e0	ret	
sub_7551 ENDP
*/
void sub_7551()
{
    // coverage: 0x6881-0x69e1 method sub_7551
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    push(si);
    push(di);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_7562;
    sub_ca53();
loc_7562:
    push(ds);
    ax = 0x0928;
    push(ax);
    sub_91d7();
    sp += 0x0004;
    ax = memoryAGet16(ds, 0x7928);
    dx = memoryAGet16(ds, 0x7926);
    memoryASet16(ds, 0x857e, dx);
    memoryASet16(ds, 0x8580, ax);
    ax = 0x0004;
    push(ax);
    ax = 0x0003;
    push(ax);
    sub_923f();
    sp += 0x0004;
    si = ax;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x094e));
    push(memoryAGet16(ds, 0x094c));
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    push(si);
    sub_932e();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    push(si);
    sub_91e9();
    sp++;
    sp++;
    ax = 0;
    dx = 0x7d63;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    sub_9a2a();
    sp += 0x000c;
    if (memoryAGet16(ds, 0x541d) != 0x0001)
        goto loc_760a;
    ax = memoryAGet16(ds, 0x8580);
    dx = memoryAGet16(ds, 0x857e);
    memoryASet16(ds, 0x9b96, dx);
    memoryASet16(ds, 0x9b98, ax);
    memoryASet(ss, bp - 5, 0x00);
    goto loc_7604;
loc_75e7:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9b96);
    es = memoryAGet16(ds, 0x9b96 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, di + 1822);
    memoryASet(es, bx + 35, al);
    memoryASet(ss, bp - 5, memoryAGet(ss, bp - 5) + 1);
loc_7604:
    if (memoryAGet(ss, bp - 5) < 0x10)
        goto loc_75e7;
loc_760a:
    sub_5337();
    ax = memoryAGet16(ds, 0x8580);
    dx = memoryAGet16(ds, 0x857e);
    dx += 0x0063;
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet16(es, bx + 6, 0x0000);
    memoryASet16(es, bx + 8, 0x0000);
    memoryASet16(es, bx + 10, 0x0014);
    memoryASet16(es, bx + 12, 0x0019);
    memoryASet16(es, bx + 14, 0x0001);
    memoryASet16(es, bx + 20, 0x0000);
    memoryASet16(es, bx + 22, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0014);
    memoryASet16(es, bx + 32, 0x0019);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9f8c();
    sp += 0x0004;
    ax = 0;
    push(ax);
    push(memoryAGet16(ds, 0x8580));
    push(memoryAGet16(ds, 0x857e));
    sub_9a63();
    sp += 0x0006;
    ax = 0;
    push(ax);
    sub_9a9a();
    sp++;
    sp++;
    ax = 0x0001;
    push(ax);
    sub_9aad();
    sp++;
    sp++;
    sub_b734();
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 14, 0x0000);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0002);
    sub_76b1();
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:57e1 sub_76b1()
sub_76b1 PROC
01ed:57e1	push	bp
01ed:57e2	mov	bp, sp
01ed:57e4	sub	sp, 0xa
01ed:57e7	cmp	word ptr [0x6b4c], sp
01ed:57eb	ja	loc_76c0
01ed:57ed	call	0xab83
        	loc_76c0:
01ed:57f0	xor	ax, ax
01ed:57f2	push	ax
01ed:57f3	call	0x9410
01ed:57f6	inc	sp
01ed:57f7	inc	sp
01ed:57f8	mov	byte ptr [bp - 9], 0
01ed:57fc	mov	byte ptr [bp - 1], 0
01ed:5800	jmp	loc_7879
        	loc_76d3:
01ed:5803	mov	al, byte ptr [bp - 1]
01ed:5806	mov	ah, 0
01ed:5808	shl	ax, 1
01ed:580a	shl	ax, 1
01ed:580c	shl	ax, 1
01ed:580e	add	ax, 0x8f0
01ed:5811	mov	word ptr [0x8574], ax
01ed:5814	mov	word ptr [0x8576], ds
01ed:5818	les	bx, ptr [0x8574]
01ed:581c	mov	ax, word ptr es:[bx + 6]
01ed:5820	mov	dx, word ptr es:[bx + 4]
01ed:5824	cmp	ax, word ptr [0xa0d6]
01ed:5828	jbe	loc_76fd
01ed:582a	jmp	loc_77d1
        	loc_76fd:
01ed:582d	jb	loc_7708
01ed:582f	cmp	dx, word ptr [0xa0d4]
01ed:5833	jb	loc_7708
01ed:5835	jmp	loc_77d1
        	loc_7708:
01ed:5838	mov	al, byte ptr [bp - 9]
01ed:583b	mov	ah, 0
01ed:583d	or	ax, ax
01ed:583f	je	loc_7714
01ed:5841	jmp	loc_77d1
        	loc_7714:
01ed:5844	mov	byte ptr [bp - 9], 1
01ed:5848	mov	al, byte ptr [bp - 1]
01ed:584b	mov	byte ptr [bp - 2], al
01ed:584e	mov	ax, word ptr [0x922]
01ed:5851	mov	dx, word ptr [0x920]
01ed:5855	mov	word ptr [bp - 6], dx
01ed:5858	mov	word ptr [bp - 4], ax
01ed:585b	mov	byte ptr [bp - 0xa], 6
01ed:585f	jmp	loc_7784
        	loc_7731:
01ed:5861	mov	al, byte ptr [bp - 0xa]
01ed:5864	mov	ah, 0
01ed:5866	shl	ax, 1
01ed:5868	shl	ax, 1
01ed:586a	shl	ax, 1
01ed:586c	mov	bx, ax
01ed:586e	mov	ax, word ptr [bx + 0x8ea]
01ed:5872	mov	dx, word ptr [bx + 0x8e8]
01ed:5876	mov	bl, byte ptr [bp - 0xa]
01ed:5879	mov	bh, 0
01ed:587b	shl	bx, 1
01ed:587d	shl	bx, 1
01ed:587f	shl	bx, 1
01ed:5881	mov	word ptr [bx + 0x8f0], dx
01ed:5885	mov	word ptr [bx + 0x8f2], ax
01ed:5889	mov	al, byte ptr [bp - 0xa]
01ed:588c	mov	ah, 0
01ed:588e	shl	ax, 1
01ed:5890	shl	ax, 1
01ed:5892	shl	ax, 1
01ed:5894	mov	bx, ax
01ed:5896	mov	ax, word ptr [bx + 0x8ee]
01ed:589a	mov	dx, word ptr [bx + 0x8ec]
01ed:589e	mov	bl, byte ptr [bp - 0xa]
01ed:58a1	mov	bh, 0
01ed:58a3	shl	bx, 1
01ed:58a5	shl	bx, 1
01ed:58a7	shl	bx, 1
01ed:58a9	mov	word ptr [bx + 0x8f4], dx
01ed:58ad	mov	word ptr [bx + 0x8f6], ax
01ed:58b1	dec	byte ptr [bp - 0xa]
        	loc_7784:
01ed:58b4	mov	al, byte ptr [bp - 0xa]
01ed:58b7	cmp	al, byte ptr [bp - 1]
01ed:58ba	ja	loc_7731
01ed:58bc	les	bx, ptr [0x8574]
01ed:58c0	mov	ax, word ptr [bp - 4]
01ed:58c3	mov	dx, word ptr [bp - 6]
01ed:58c6	mov	word ptr es:[bx], dx
01ed:58c9	mov	word ptr es:[bx + 2], ax
01ed:58cd	mov	byte ptr [bp - 0xa], 0
01ed:58d1	jmp	loc_77b8
        	loc_77a3:
01ed:58d3	les	bx, ptr [0x8574]
01ed:58d7	les	bx, ptr es:[bx]
01ed:58da	mov	al, byte ptr [bp - 0xa]
01ed:58dd	mov	ah, 0
01ed:58df	add	bx, ax
01ed:58e1	mov	byte ptr es:[bx], 0x41
01ed:58e5	inc	byte ptr [bp - 0xa]
        	loc_77b8:
01ed:58e8	cmp	byte ptr [bp - 0xa], 8
01ed:58ec	jb	loc_77a3
01ed:58ee	les	bx, ptr [0x8574]
01ed:58f2	mov	ax, word ptr [0xa0d6]
01ed:58f5	mov	dx, word ptr [0xa0d4]
01ed:58f9	mov	word ptr es:[bx + 4], dx
01ed:58fd	mov	word ptr es:[bx + 6], ax
        	loc_77d1:
01ed:5901	mov	al, byte ptr [bp - 1]
01ed:5904	mov	ah, 0
01ed:5906	mov	cl, 4
01ed:5908	shl	ax, cl
01ed:590a	add	ax, 0x41
01ed:590d	les	bx, ptr [0x8884]
01ed:5911	mov	word ptr es:[bx + 2], ax
01ed:5915	mov	byte ptr [bp - 7], 0
01ed:5919	jmp	loc_784a
        	loc_77eb:
01ed:591b	les	bx, ptr [0x8574]
01ed:591f	les	bx, ptr es:[bx]
01ed:5922	mov	al, byte ptr [bp - 7]
01ed:5925	mov	ah, 0
01ed:5927	add	bx, ax
01ed:5929	mov	al, byte ptr es:[bx]
01ed:592c	mov	byte ptr [bp - 8], al
01ed:592f	cmp	al, 0x2e
01ed:5931	jne	loc_781a
01ed:5933	cmp	byte ptr [bp - 9], 0
01ed:5937	je	loc_7815
01ed:5939	mov	al, byte ptr [bp - 2]
01ed:593c	cmp	al, byte ptr [bp - 1]
01ed:593f	jne	loc_7815
01ed:5941	mov	al, 0x5b
01ed:5943	jmp	loc_7817
        	loc_7815:
01ed:5945	mov	al, 0x20
        	loc_7817:
01ed:5947	mov	byte ptr [bp - 8], al
        	loc_781a:
01ed:594a	les	bx, ptr [0x8884]
01ed:594e	mov	al, byte ptr [bp - 8]
01ed:5951	mov	ah, 0
01ed:5953	add	ax, 0x175
01ed:5956	mov	word ptr es:[bx + 4], ax
01ed:595a	mov	al, byte ptr [bp - 7]
01ed:595d	mov	ah, 0
01ed:595f	mov	cl, 4
01ed:5961	shl	ax, cl
01ed:5963	mov	word ptr es:[bx], ax
01ed:5966	cmp	byte ptr [bp - 8], 0x20
01ed:596a	je	loc_7847
01ed:596c	push	ds
01ed:596d	mov	ax, 0x792e
01ed:5970	push	ax
01ed:5971	call	0x942a
01ed:5974	add	sp, 4
        	loc_7847:
01ed:5977	inc	byte ptr [bp - 7]
        	loc_784a:
01ed:597a	cmp	byte ptr [bp - 7], 8
01ed:597e	jb	loc_77eb
01ed:5980	mov	al, byte ptr [bp - 1]
01ed:5983	mov	ah, 0
01ed:5985	mov	cl, 4
01ed:5987	shl	ax, cl
01ed:5989	add	ax, 0x41
01ed:598c	push	ax
01ed:598d	mov	ax, 0xb0
01ed:5990	push	ax
01ed:5991	mov	al, 7
01ed:5993	push	ax
01ed:5994	les	bx, ptr [0x8574]
01ed:5998	push	word ptr es:[bx + 6]
01ed:599c	push	word ptr es:[bx + 4]
01ed:59a0	call	0x603d
01ed:59a3	add	sp, 0xa
01ed:59a6	inc	byte ptr [bp - 1]
        	loc_7879:
01ed:59a9	cmp	byte ptr [bp - 1], 7
01ed:59ad	jae	loc_7882
01ed:59af	jmp	loc_76d3
        	loc_7882:
01ed:59b2	cmp	byte ptr [bp - 9], 0
01ed:59b6	je	loc_7893
01ed:59b8	mov	al, byte ptr [bp - 2]
01ed:59bb	push	ax
01ed:59bc	call	0x59d3
01ed:59bf	inc	sp
01ed:59c0	inc	sp
01ed:59c1	jmp	loc_7896
        	loc_7893:
01ed:59c3	call	0x328f
        	loc_7896:
01ed:59c6	mov	ax, 1
01ed:59c9	push	ax
01ed:59ca	call	0x9410
01ed:59cd	inc	sp
01ed:59ce	inc	sp
01ed:59cf	mov	sp, bp
01ed:59d1	pop	bp
01ed:59d2	ret	
sub_76b1 ENDP
*/
void sub_76b1()
{
    // coverage: 0x69e1-0x6bd3 method sub_76b1
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000a;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_76c0;
    sub_ca53();
loc_76c0:
    ax = 0;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    memoryASet(ss, bp - 9, 0x00);
    memoryASet(ss, bp - 1, 0x00);
    goto loc_7879;
loc_76d3:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax += 0x08f0;
    memoryASet16(ds, 0x8574, ax);
    memoryASet16(ds, 0x8576, ds);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    if (ax <= memoryAGet16(ds, 0xa0d6))
        goto loc_76fd;
    goto loc_77d1;
loc_76fd:
    if (ax < memoryAGet16(ds, 0xa0d6))
        goto loc_7708;
    if (dx < memoryAGet16(ds, 0xa0d4))
        goto loc_7708;
    goto loc_77d1;
loc_7708:
    al = memoryAGet(ss, bp - 9);
    ah = 0x00;
    if (!ax)
        goto loc_7714;
    goto loc_77d1;
loc_7714:
    memoryASet(ss, bp - 9, 0x01);
    al = memoryAGet(ss, bp - 1);
    memoryASet(ss, bp - 2, al);
    ax = memoryAGet16(ds, 0x0922);
    dx = memoryAGet16(ds, 0x0920);
    memoryASet16(ss, bp - 6, dx);
    memoryASet16(ss, bp - 4, ax);
    memoryASet(ss, bp - 10, 0x06);
    goto loc_7784;
loc_7731:
    al = memoryAGet(ss, bp - 10);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 2282);
    dx = memoryAGet16(ds, bx + 2280);
    bl = memoryAGet(ss, bp - 10);
    bh = 0x00;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    memoryASet16(ds, bx + 2288, dx);
    memoryASet16(ds, bx + 2290, ax);
    al = memoryAGet(ss, bp - 10);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 2286);
    dx = memoryAGet16(ds, bx + 2284);
    bl = memoryAGet(ss, bp - 10);
    bh = 0x00;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    memoryASet16(ds, bx + 2292, dx);
    memoryASet16(ds, bx + 2294, ax);
    memoryASet(ss, bp - 10, memoryAGet(ss, bp - 10) - 1);
loc_7784:
    al = memoryAGet(ss, bp - 10);
    if (al > memoryAGet(ss, bp - 1))
        goto loc_7731;
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    ax = memoryAGet16(ss, bp - 4);
    dx = memoryAGet16(ss, bp - 6);
    memoryASet16(es, bx, dx);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 10, 0x00);
    goto loc_77b8;
loc_77a3:
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 10);
    ah = 0x00;
    bx += ax;
    memoryASet(es, bx, 0x41);
    memoryASet(ss, bp - 10, memoryAGet(ss, bp - 10) + 1);
loc_77b8:
    if (memoryAGet(ss, bp - 10) < 0x08)
        goto loc_77a3;
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    ax = memoryAGet16(ds, 0xa0d6);
    dx = memoryAGet16(ds, 0xa0d4);
    memoryASet16(es, bx + 4, dx);
    memoryASet16(es, bx + 6, ax);
loc_77d1:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    ax += 0x0041;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 7, 0x00);
    goto loc_784a;
loc_77eb:
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 7);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 8, al);
    if (al != 0x2e)
        goto loc_781a;
    if (memoryAGet(ss, bp - 9) == 0x00)
        goto loc_7815;
    al = memoryAGet(ss, bp - 2);
    if (al != memoryAGet(ss, bp - 1))
        goto loc_7815;
    al = 0x5b;
    goto loc_7817;
loc_7815:
    al = 0x20;
loc_7817:
    memoryASet(ss, bp - 8, al);
loc_781a:
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    al = memoryAGet(ss, bp - 8);
    ah = 0x00;
    ax += 0x0175;
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 7);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    if (memoryAGet(ss, bp - 8) == 0x20)
        goto loc_7847;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_7847:
    memoryASet(ss, bp - 7, memoryAGet(ss, bp - 7) + 1);
loc_784a:
    if (memoryAGet(ss, bp - 7) < 0x08)
        goto loc_77eb;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    ax += 0x0041;
    push(ax);
    ax = 0x00b0;
    push(ax);
    al = 0x07;
    push(ax);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    push(memoryAGet16(es, bx + 6));
    push(memoryAGet16(es, bx + 4));
    sub_7f0d();
    sp += 0x000a;
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
loc_7879:
    if (memoryAGet(ss, bp - 1) >= 0x07)
        goto loc_7882;
    goto loc_76d3;
loc_7882:
    if (memoryAGet(ss, bp - 9) == 0x00)
        goto loc_7893;
    al = memoryAGet(ss, bp - 2);
    push(ax);
    sub_78a3();
    sp++;
    sp++;
    goto loc_7896;
loc_7893:
    sub_515f();
loc_7896:
    ax = 0x0001;
    push(ax);
    sub_b2e0();
    sp++;
    sp++;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:59d3 sub_78a3()
sub_78a3 PROC
01ed:59d3	push	bp
01ed:59d4	mov	bp, sp
01ed:59d6	sub	sp, 6
01ed:59d9	cmp	word ptr [0x6b4c], sp
01ed:59dd	ja	loc_78b2
01ed:59df	call	0xab83
        	loc_78b2:
01ed:59e2	mov	byte ptr [bp - 2], 0
01ed:59e6	mov	al, byte ptr [bp + 4]
01ed:59e9	mov	ah, 0
01ed:59eb	shl	ax, 1
01ed:59ed	shl	ax, 1
01ed:59ef	shl	ax, 1
01ed:59f1	add	ax, 0x8f0
01ed:59f4	mov	word ptr [0x8574], ax
01ed:59f7	mov	word ptr [0x8576], ds
01ed:59fb	mov	word ptr [bp - 6], 0x1b6
01ed:5a00	les	bx, ptr [0x8574]
01ed:5a04	les	bx, ptr es:[bx]
01ed:5a07	mov	al, byte ptr [bp - 2]
01ed:5a0a	mov	ah, 0
01ed:5a0c	add	bx, ax
01ed:5a0e	mov	byte ptr es:[bx], 0x41
01ed:5a12	les	bx, ptr [0x574]
01ed:5a16	mov	al, byte ptr [bp - 2]
01ed:5a19	mov	ah, 0
01ed:5a1b	mov	word ptr es:[bx + 0x14], ax
01ed:5a1f	mov	al, byte ptr [bp + 4]
01ed:5a22	mov	ah, 0
01ed:5a24	shl	ax, 1
01ed:5a26	add	ax, 8
01ed:5a29	mov	word ptr es:[bx + 0x16], ax
01ed:5a2d	mov	al, 1
01ed:5a2f	push	ax
01ed:5a30	push	word ptr [bp - 6]
01ed:5a33	mov	al, byte ptr [bp - 2]
01ed:5a36	push	ax
01ed:5a37	mov	al, byte ptr [bp + 4]
01ed:5a3a	mov	cl, 4
01ed:5a3c	shl	al, cl
01ed:5a3e	add	al, 0x41
01ed:5a40	push	ax
01ed:5a41	call	0x5fdb
01ed:5a44	add	sp, 8
01ed:5a47	jmp	loc_7b30
        	loc_791a:
01ed:5a4a	test	byte ptr [bp - 1], 1
01ed:5a4e	je	loc_7984
01ed:5a50	cmp	word ptr [bp - 6], 0x1ac
01ed:5a55	jle	loc_7984
01ed:5a57	dec	word ptr [bp - 6]
01ed:5a5a	cmp	word ptr [bp - 6], 0x1d0
01ed:5a5f	jne	loc_7936
01ed:5a61	mov	word ptr [bp - 6], 0x1a3
        	loc_7936:
01ed:5a66	mov	ax, word ptr [bp - 6]
01ed:5a69	add	ax, 0xfe8b
01ed:5a6c	mov	word ptr [bp - 6], ax
01ed:5a6f	les	bx, ptr [0x8574]
01ed:5a73	les	bx, ptr es:[bx]
01ed:5a76	mov	al, byte ptr [bp - 2]
01ed:5a79	mov	ah, 0
01ed:5a7b	add	bx, ax
01ed:5a7d	mov	al, byte ptr [bp - 6]
01ed:5a80	mov	byte ptr es:[bx], al
01ed:5a83	cmp	word ptr [bp - 6], 0x2e
01ed:5a87	jne	loc_795e
01ed:5a89	mov	word ptr [bp - 6], 0x5b
        	loc_795e:
01ed:5a8e	mov	ax, word ptr [bp - 6]
01ed:5a91	add	ax, 0x175
01ed:5a94	mov	word ptr [bp - 6], ax
01ed:5a97	mov	al, 1
01ed:5a99	push	ax
01ed:5a9a	push	word ptr [bp - 6]
01ed:5a9d	mov	al, byte ptr [bp - 2]
01ed:5aa0	push	ax
01ed:5aa1	mov	al, byte ptr [bp + 4]
01ed:5aa4	mov	cl, 4
01ed:5aa6	shl	al, cl
01ed:5aa8	add	al, 0x41
01ed:5aaa	push	ax
01ed:5aab	call	0x5fdb
01ed:5aae	add	sp, 8
01ed:5ab1	jmp	loc_7b30
        	loc_7984:
01ed:5ab4	test	byte ptr [bp - 1], 2
01ed:5ab8	je	loc_79ee
01ed:5aba	cmp	word ptr [bp - 6], 0x1d0
01ed:5abf	jge	loc_79ee
01ed:5ac1	inc	word ptr [bp - 6]
01ed:5ac4	cmp	word ptr [bp - 6], 0x1d0
01ed:5ac9	jne	loc_79a0
01ed:5acb	mov	word ptr [bp - 6], 0x1a3
        	loc_79a0:
01ed:5ad0	mov	ax, word ptr [bp - 6]
01ed:5ad3	add	ax, 0xfe8b
01ed:5ad6	mov	word ptr [bp - 6], ax
01ed:5ad9	les	bx, ptr [0x8574]
01ed:5add	les	bx, ptr es:[bx]
01ed:5ae0	mov	al, byte ptr [bp - 2]
01ed:5ae3	mov	ah, 0
01ed:5ae5	add	bx, ax
01ed:5ae7	mov	al, byte ptr [bp - 6]
01ed:5aea	mov	byte ptr es:[bx], al
01ed:5aed	cmp	word ptr [bp - 6], 0x2e
01ed:5af1	jne	loc_79c8
01ed:5af3	mov	word ptr [bp - 6], 0x5b
        	loc_79c8:
01ed:5af8	mov	ax, word ptr [bp - 6]
01ed:5afb	add	ax, 0x175
01ed:5afe	mov	word ptr [bp - 6], ax
01ed:5b01	mov	al, 1
01ed:5b03	push	ax
01ed:5b04	push	word ptr [bp - 6]
01ed:5b07	mov	al, byte ptr [bp - 2]
01ed:5b0a	push	ax
01ed:5b0b	mov	al, byte ptr [bp + 4]
01ed:5b0e	mov	cl, 4
01ed:5b10	shl	al, cl
01ed:5b12	add	al, 0x41
01ed:5b14	push	ax
01ed:5b15	call	0x5fdb
01ed:5b18	add	sp, 8
01ed:5b1b	jmp	loc_7b30
        	loc_79ee:
01ed:5b1e	test	byte ptr [bp - 1], 4
01ed:5b22	jne	loc_79f7
01ed:5b24	jmp	loc_7a7b
        	loc_79f7:
01ed:5b27	cmp	byte ptr [bp - 2], 0
01ed:5b2b	je	loc_7a7b
01ed:5b2d	cmp	word ptr [bp - 6], 0x1d0
01ed:5b32	jne	loc_7a09
01ed:5b34	mov	word ptr [bp - 6], 0x1a3
        	loc_7a09:
01ed:5b39	mov	ax, word ptr [bp - 6]
01ed:5b3c	add	ax, 0xfe8b
01ed:5b3f	mov	word ptr [bp - 6], ax
01ed:5b42	les	bx, ptr [0x8574]
01ed:5b46	les	bx, ptr es:[bx]
01ed:5b49	mov	al, byte ptr [bp - 2]
01ed:5b4c	mov	ah, 0
01ed:5b4e	add	bx, ax
01ed:5b50	mov	al, byte ptr [bp - 6]
01ed:5b53	mov	byte ptr es:[bx], al
01ed:5b56	dec	byte ptr [bp - 2]
01ed:5b59	les	bx, ptr [0x8574]
01ed:5b5d	les	bx, ptr es:[bx]
01ed:5b60	mov	al, byte ptr [bp - 2]
01ed:5b63	mov	ah, 0
01ed:5b65	add	bx, ax
01ed:5b67	mov	al, byte ptr es:[bx]
01ed:5b6a	mov	ah, 0
01ed:5b6c	mov	word ptr [bp - 6], ax
01ed:5b6f	cmp	word ptr [bp - 6], 0x2e
01ed:5b73	jne	loc_7a4a
01ed:5b75	mov	word ptr [bp - 6], 0x5b
        	loc_7a4a:
01ed:5b7a	mov	ax, word ptr [bp - 6]
01ed:5b7d	add	ax, 0x175
01ed:5b80	mov	word ptr [bp - 6], ax
01ed:5b83	push	ds
01ed:5b84	mov	ax, 0x792e
01ed:5b87	push	ax
01ed:5b88	call	0x942a
01ed:5b8b	add	sp, 4
01ed:5b8e	mov	al, 0
01ed:5b90	push	ax
01ed:5b91	push	word ptr [bp - 6]
01ed:5b94	mov	al, byte ptr [bp - 2]
01ed:5b97	push	ax
01ed:5b98	mov	al, byte ptr [bp + 4]
01ed:5b9b	mov	cl, 4
01ed:5b9d	shl	al, cl
01ed:5b9f	add	al, 0x41
01ed:5ba1	push	ax
01ed:5ba2	call	0x5fdb
01ed:5ba5	add	sp, 8
01ed:5ba8	jmp	loc_7b30
        	loc_7a7b:
01ed:5bab	test	byte ptr [bp - 1], 8
01ed:5baf	jne	loc_7a84
01ed:5bb1	jmp	loc_7b07
        	loc_7a84:
01ed:5bb4	cmp	byte ptr [bp - 2], 7
01ed:5bb8	jae	loc_7b07
01ed:5bba	cmp	word ptr [bp - 6], 0x1d0
01ed:5bbf	jne	loc_7a96
01ed:5bc1	mov	word ptr [bp - 6], 0x1a3
        	loc_7a96:
01ed:5bc6	mov	ax, word ptr [bp - 6]
01ed:5bc9	add	ax, 0xfe8b
01ed:5bcc	mov	word ptr [bp - 6], ax
01ed:5bcf	les	bx, ptr [0x8574]
01ed:5bd3	les	bx, ptr es:[bx]
01ed:5bd6	mov	al, byte ptr [bp - 2]
01ed:5bd9	mov	ah, 0
01ed:5bdb	add	bx, ax
01ed:5bdd	mov	al, byte ptr [bp - 6]
01ed:5be0	mov	byte ptr es:[bx], al
01ed:5be3	inc	byte ptr [bp - 2]
01ed:5be6	les	bx, ptr [0x8574]
01ed:5bea	les	bx, ptr es:[bx]
01ed:5bed	mov	al, byte ptr [bp - 2]
01ed:5bf0	mov	ah, 0
01ed:5bf2	add	bx, ax
01ed:5bf4	mov	al, byte ptr es:[bx]
01ed:5bf7	mov	ah, 0
01ed:5bf9	mov	word ptr [bp - 6], ax
01ed:5bfc	cmp	word ptr [bp - 6], 0x2e
01ed:5c00	jne	loc_7ad7
01ed:5c02	mov	word ptr [bp - 6], 0x5b
        	loc_7ad7:
01ed:5c07	mov	ax, word ptr [bp - 6]
01ed:5c0a	add	ax, 0x175
01ed:5c0d	mov	word ptr [bp - 6], ax
01ed:5c10	push	ds
01ed:5c11	mov	ax, 0x792e
01ed:5c14	push	ax
01ed:5c15	call	0x942a
01ed:5c18	add	sp, 4
01ed:5c1b	mov	al, 0
01ed:5c1d	push	ax
01ed:5c1e	push	word ptr [bp - 6]
01ed:5c21	mov	al, byte ptr [bp - 2]
01ed:5c24	push	ax
01ed:5c25	mov	al, byte ptr [bp + 4]
01ed:5c28	mov	cl, 4
01ed:5c2a	shl	al, cl
01ed:5c2c	add	al, 0x41
01ed:5c2e	push	ax
01ed:5c2f	call	0x5fdb
01ed:5c32	add	sp, 8
01ed:5c35	jmp	loc_7b30
        	loc_7b07:
01ed:5c37	inc	byte ptr [bp - 3]
01ed:5c3a	test	byte ptr [bp - 3], 8
01ed:5c3e	je	loc_7b1d
01ed:5c40	push	word ptr [0x576]
01ed:5c44	push	word ptr [0x574]
01ed:5c48	call	0x7b4a
01ed:5c4b	jmp	loc_7b25
        	loc_7b1d:
01ed:5c4d	push	ds
01ed:5c4e	mov	ax, 0x792e
01ed:5c51	push	ax
01ed:5c52	call	0x942a
        	loc_7b25:
01ed:5c55	add	sp, 4
01ed:5c58	mov	al, 1
01ed:5c5a	push	ax
01ed:5c5b	call	0x5e7
01ed:5c5e	inc	sp
01ed:5c5f	inc	sp
        	loc_7b30:
01ed:5c60	mov	al, 0
01ed:5c62	push	ax
01ed:5c63	call	0x75a2
01ed:5c66	inc	sp
01ed:5c67	inc	sp
01ed:5c68	mov	byte ptr [bp - 1], al
01ed:5c6b	mov	ah, 0
01ed:5c6d	and	ax, 0x10
01ed:5c70	cmp	ax, 0x10
01ed:5c73	je	loc_7b48
01ed:5c75	jmp	loc_791a
        	loc_7b48:
01ed:5c78	push	ds
01ed:5c79	mov	ax, 0x792e
01ed:5c7c	push	ax
01ed:5c7d	call	0x942a
01ed:5c80	add	sp, 4
01ed:5c83	mov	sp, bp
01ed:5c85	pop	bp
01ed:5c86	ret	
sub_78a3 ENDP
*/
void sub_78a3()
{
    // coverage: 0x6bd3-0x6e87 method sub_78a3
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_78b2;
    sub_ca53();
loc_78b2:
    memoryASet(ss, bp - 2, 0x00);
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax += 0x08f0;
    memoryASet16(ds, 0x8574, ax);
    memoryASet16(ds, 0x8576, ds);
    memoryASet16(ss, bp - 6, 0x01b6);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    memoryASet(es, bx, 0x41);
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    memoryASet16(es, bx + 20, ax);
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    ax += 0x0008;
    memoryASet16(es, bx + 22, ax);
    al = 0x01;
    push(ax);
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    al += 0x41;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7b30;
loc_791a:
    if (!(memoryAGet(ss, bp - 1) & 0x01))
        goto loc_7984;
    if ((short)memoryAGet16(ss, bp - 6) <= (short)0x01ac)
        goto loc_7984;
    memoryASet16(ss, bp - 6, memoryAGet16(ss, bp - 6) - 1);
    if (memoryAGet16(ss, bp - 6) != 0x01d0)
        goto loc_7936;
    memoryASet16(ss, bp - 6, 0x01a3);
loc_7936:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(ss, bp - 6);
    memoryASet(es, bx, al);
    if (memoryAGet16(ss, bp - 6) != 0x002e)
        goto loc_795e;
    memoryASet16(ss, bp - 6, 0x005b);
loc_795e:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0x0175;
    memoryASet16(ss, bp - 6, ax);
    al = 0x01;
    push(ax);
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    al += 0x41;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7b30;
loc_7984:
    if (!(memoryAGet(ss, bp - 1) & 0x02))
        goto loc_79ee;
    if ((short)memoryAGet16(ss, bp - 6) >= (short)0x01d0)
        goto loc_79ee;
    memoryASet16(ss, bp - 6, memoryAGet16(ss, bp - 6) + 1);
    if (memoryAGet16(ss, bp - 6) != 0x01d0)
        goto loc_79a0;
    memoryASet16(ss, bp - 6, 0x01a3);
loc_79a0:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(ss, bp - 6);
    memoryASet(es, bx, al);
    if (memoryAGet16(ss, bp - 6) != 0x002e)
        goto loc_79c8;
    memoryASet16(ss, bp - 6, 0x005b);
loc_79c8:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0x0175;
    memoryASet16(ss, bp - 6, ax);
    al = 0x01;
    push(ax);
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    al += 0x41;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7b30;
loc_79ee:
    if (memoryAGet(ss, bp - 1) & 0x04)
        goto loc_79f7;
    goto loc_7a7b;
loc_79f7:
    if (memoryAGet(ss, bp - 2) == 0x00)
        goto loc_7a7b;
    if (memoryAGet16(ss, bp - 6) != 0x01d0)
        goto loc_7a09;
    memoryASet16(ss, bp - 6, 0x01a3);
loc_7a09:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(ss, bp - 6);
    memoryASet(es, bx, al);
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) - 1);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(es, bx);
    ah = 0x00;
    memoryASet16(ss, bp - 6, ax);
    if (memoryAGet16(ss, bp - 6) != 0x002e)
        goto loc_7a4a;
    memoryASet16(ss, bp - 6, 0x005b);
loc_7a4a:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0x0175;
    memoryASet16(ss, bp - 6, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    al = 0x00;
    push(ax);
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    al += 0x41;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7b30;
loc_7a7b:
    if (memoryAGet(ss, bp - 1) & 0x08)
        goto loc_7a84;
    goto loc_7b07;
loc_7a84:
    if (memoryAGet(ss, bp - 2) >= 0x07)
        goto loc_7b07;
    if (memoryAGet16(ss, bp - 6) != 0x01d0)
        goto loc_7a96;
    memoryASet16(ss, bp - 6, 0x01a3);
loc_7a96:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(ss, bp - 6);
    memoryASet(es, bx, al);
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
    bx = memoryAGet16(ds, 0x8574);
    es = memoryAGet16(ds, 0x8574 + 2);
    tx = bx;
    bx = memoryAGet16(es, tx);
    es = memoryAGet16(es, tx + 2);
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx += ax;
    al = memoryAGet(es, bx);
    ah = 0x00;
    memoryASet16(ss, bp - 6, ax);
    if (memoryAGet16(ss, bp - 6) != 0x002e)
        goto loc_7ad7;
    memoryASet16(ss, bp - 6, 0x005b);
loc_7ad7:
    ax = memoryAGet16(ss, bp - 6);
    ax += 0x0175;
    memoryASet16(ss, bp - 6, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    al = 0x00;
    push(ax);
    push(memoryAGet16(ss, bp - 6));
    al = memoryAGet(ss, bp - 2);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    al += 0x41;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7b30;
loc_7b07:
    memoryASet(ss, bp - 3, memoryAGet(ss, bp - 3) + 1);
    if (!(memoryAGet(ss, bp - 3) & 0x08))
        goto loc_7b1d;
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    goto loc_7b25;
loc_7b1d:
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
loc_7b25:
    sp += 0x0004;
    al = 0x01;
    push(ax);
    sub_24b7();
    sp++;
    sp++;
loc_7b30:
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    memoryASet(ss, bp - 1, al);
    ah = 0x00;
    ax &= 0x0010;
    if (ax == 0x0010)
        goto loc_7b48;
    goto loc_791a;
loc_7b48:
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5c87 sub_7b57()
sub_7b57 PROC
01ed:5c87	push	bp
01ed:5c88	mov	bp, sp
01ed:5c8a	sub	sp, 0x14
01ed:5c8d	cmp	word ptr [0x6b4c], sp
01ed:5c91	ja	loc_7b66
01ed:5c93	call	0xab83
        	loc_7b66:
01ed:5c96	push	ss
01ed:5c97	lea	ax, [bp - 0xa]
01ed:5c9a	push	ax
01ed:5c9b	push	ds
01ed:5c9c	mov	ax, 0x256a
01ed:5c9f	push	ax
01ed:5ca0	mov	cx, 4
01ed:5ca3	call	0xa9f5
01ed:5ca6	les	bx, ptr [0x574]
01ed:5caa	mov	word ptr es:[bx + 0xe], 0
01ed:5cb0	mov	word ptr es:[bx + 0x1c], 0
01ed:5cb6	mov	word ptr es:[bx + 0x1e], 1
01ed:5cbc	mov	word ptr es:[bx + 0x20], 2
01ed:5cc2	mov	al, 0
01ed:5cc4	mov	byte ptr [bp - 6], al
01ed:5cc7	mov	byte ptr [bp - 3], al
01ed:5cca	mov	ax, word ptr [bp - 8]
01ed:5ccd	mov	dx, word ptr [bp - 0xa]
01ed:5cd0	mov	word ptr [bp - 0xe], dx
01ed:5cd3	mov	word ptr [bp - 0xc], ax
01ed:5cd6	mov	byte ptr [bp - 2], 0
01ed:5cda	jmp	loc_7bbd
        	loc_7bac:
01ed:5cdc	mov	al, byte ptr [bp - 2]
01ed:5cdf	mov	ah, 0
01ed:5ce1	les	bx, ptr [bp - 0xe]
01ed:5ce4	add	bx, ax
01ed:5ce6	mov	byte ptr es:[bx], 0x41
01ed:5cea	inc	byte ptr [bp - 2]
        	loc_7bbd:
01ed:5ced	cmp	byte ptr [bp - 2], 6
01ed:5cf1	jb	loc_7bac
01ed:5cf3	mov	word ptr [bp - 0x14], 0x1b6
01ed:5cf8	mov	al, byte ptr [bp - 3]
01ed:5cfb	mov	ah, 0
01ed:5cfd	les	bx, ptr [bp - 0xe]
01ed:5d00	add	bx, ax
01ed:5d02	mov	byte ptr es:[bx], 0x41
01ed:5d06	les	bx, ptr [0x574]
01ed:5d0a	mov	al, byte ptr [bp + 6]
01ed:5d0d	mov	ah, 0
01ed:5d0f	mov	word ptr es:[bx + 0x14], ax
01ed:5d13	mov	al, byte ptr [bp + 4]
01ed:5d16	mov	ah, 0
01ed:5d18	shl	ax, 1
01ed:5d1a	mov	word ptr es:[bx + 0x16], ax
01ed:5d1e	mov	al, 1
01ed:5d20	push	ax
01ed:5d21	push	word ptr [bp - 0x14]
01ed:5d24	mov	al, byte ptr [bp + 6]
01ed:5d27	push	ax
01ed:5d28	mov	al, byte ptr [bp + 4]
01ed:5d2b	mov	cl, 4
01ed:5d2d	shl	al, cl
01ed:5d2f	push	ax
01ed:5d30	call	0x5fdb
01ed:5d33	add	sp, 8
01ed:5d36	jmp	loc_7dff
        	loc_7c09:
01ed:5d39	test	byte ptr [bp - 1], 1
01ed:5d3d	je	loc_7c6d
01ed:5d3f	cmp	word ptr [bp - 0x14], 0x1ac
01ed:5d44	jle	loc_7c6d
01ed:5d46	dec	word ptr [bp - 0x14]
01ed:5d49	cmp	word ptr [bp - 0x14], 0x1d0
01ed:5d4e	jne	loc_7c25
01ed:5d50	mov	word ptr [bp - 0x14], 0x1a3
        	loc_7c25:
01ed:5d55	mov	ax, word ptr [bp - 0x14]
01ed:5d58	add	ax, 0xfe8b
01ed:5d5b	mov	word ptr [bp - 0x14], ax
01ed:5d5e	mov	al, byte ptr [bp - 3]
01ed:5d61	mov	ah, 0
01ed:5d63	les	bx, ptr [bp - 0xe]
01ed:5d66	add	bx, ax
01ed:5d68	mov	al, byte ptr [bp - 0x14]
01ed:5d6b	mov	byte ptr es:[bx], al
01ed:5d6e	cmp	word ptr [bp - 0x14], 0x2e
01ed:5d72	jne	loc_7c49
01ed:5d74	mov	word ptr [bp - 0x14], 0x5b
        	loc_7c49:
01ed:5d79	mov	ax, word ptr [bp - 0x14]
01ed:5d7c	add	ax, 0x175
01ed:5d7f	mov	word ptr [bp - 0x14], ax
01ed:5d82	mov	al, 1
01ed:5d84	push	ax
01ed:5d85	push	word ptr [bp - 0x14]
01ed:5d88	mov	al, byte ptr [bp + 6]
01ed:5d8b	push	ax
01ed:5d8c	mov	al, byte ptr [bp + 4]
01ed:5d8f	mov	cl, 4
01ed:5d91	shl	al, cl
01ed:5d93	push	ax
01ed:5d94	call	0x5fdb
01ed:5d97	add	sp, 8
01ed:5d9a	jmp	loc_7dff
        	loc_7c6d:
01ed:5d9d	test	byte ptr [bp - 1], 2
01ed:5da1	je	loc_7cd1
01ed:5da3	cmp	word ptr [bp - 0x14], 0x1d0
01ed:5da8	jge	loc_7cd1
01ed:5daa	inc	word ptr [bp - 0x14]
01ed:5dad	cmp	word ptr [bp - 0x14], 0x1d0
01ed:5db2	jne	loc_7c89
01ed:5db4	mov	word ptr [bp - 0x14], 0x1a3
        	loc_7c89:
01ed:5db9	mov	ax, word ptr [bp - 0x14]
01ed:5dbc	add	ax, 0xfe8b
01ed:5dbf	mov	word ptr [bp - 0x14], ax
01ed:5dc2	mov	al, byte ptr [bp - 3]
01ed:5dc5	mov	ah, 0
01ed:5dc7	les	bx, ptr [bp - 0xe]
01ed:5dca	add	bx, ax
01ed:5dcc	mov	al, byte ptr [bp - 0x14]
01ed:5dcf	mov	byte ptr es:[bx], al
01ed:5dd2	cmp	word ptr [bp - 0x14], 0x2e
01ed:5dd6	jne	loc_7cad
01ed:5dd8	mov	word ptr [bp - 0x14], 0x5b
        	loc_7cad:
01ed:5ddd	mov	ax, word ptr [bp - 0x14]
01ed:5de0	add	ax, 0x175
01ed:5de3	mov	word ptr [bp - 0x14], ax
01ed:5de6	mov	al, 1
01ed:5de8	push	ax
01ed:5de9	push	word ptr [bp - 0x14]
01ed:5dec	mov	al, byte ptr [bp + 6]
01ed:5def	push	ax
01ed:5df0	mov	al, byte ptr [bp + 4]
01ed:5df3	mov	cl, 4
01ed:5df5	shl	al, cl
01ed:5df7	push	ax
01ed:5df8	call	0x5fdb
01ed:5dfb	add	sp, 8
01ed:5dfe	jmp	loc_7dff
        	loc_7cd1:
01ed:5e01	test	byte ptr [bp - 1], 4
01ed:5e05	je	loc_7d54
01ed:5e07	cmp	byte ptr [bp - 3], 0
01ed:5e0b	je	loc_7d54
01ed:5e0d	cmp	word ptr [bp - 0x14], 0x1d0
01ed:5e12	jne	loc_7ce9
01ed:5e14	mov	word ptr [bp - 0x14], 0x1a3
        	loc_7ce9:
01ed:5e19	mov	ax, word ptr [bp - 0x14]
01ed:5e1c	add	ax, 0xfe8b
01ed:5e1f	mov	word ptr [bp - 0x14], ax
01ed:5e22	mov	al, byte ptr [bp - 3]
01ed:5e25	mov	ah, 0
01ed:5e27	les	bx, ptr [bp - 0xe]
01ed:5e2a	add	bx, ax
01ed:5e2c	mov	al, byte ptr [bp - 0x14]
01ed:5e2f	mov	byte ptr es:[bx], al
01ed:5e32	dec	byte ptr [bp - 3]
01ed:5e35	dec	byte ptr [bp + 6]
01ed:5e38	mov	al, byte ptr [bp - 3]
01ed:5e3b	mov	ah, 0
01ed:5e3d	mov	bx, word ptr [bp - 0xe]
01ed:5e40	add	bx, ax
01ed:5e42	mov	al, byte ptr es:[bx]
01ed:5e45	mov	ah, 0
01ed:5e47	mov	word ptr [bp - 0x14], ax
01ed:5e4a	cmp	word ptr [bp - 0x14], 0x2e
01ed:5e4e	jne	loc_7d25
01ed:5e50	mov	word ptr [bp - 0x14], 0x5b
        	loc_7d25:
01ed:5e55	mov	ax, word ptr [bp - 0x14]
01ed:5e58	add	ax, 0x175
01ed:5e5b	mov	word ptr [bp - 0x14], ax
01ed:5e5e	push	ds
01ed:5e5f	mov	ax, 0x792e
01ed:5e62	push	ax
01ed:5e63	call	0x942a
01ed:5e66	add	sp, 4
01ed:5e69	mov	al, 0
01ed:5e6b	push	ax
01ed:5e6c	push	word ptr [bp - 0x14]
01ed:5e6f	mov	al, byte ptr [bp + 6]
01ed:5e72	push	ax
01ed:5e73	mov	al, byte ptr [bp + 4]
01ed:5e76	mov	cl, 4
01ed:5e78	shl	al, cl
01ed:5e7a	push	ax
01ed:5e7b	call	0x5fdb
01ed:5e7e	add	sp, 8
01ed:5e81	jmp	loc_7dff
        	loc_7d54:
01ed:5e84	test	byte ptr [bp - 1], 8
01ed:5e88	je	loc_7dd6
01ed:5e8a	cmp	byte ptr [bp - 3], 5
01ed:5e8e	jae	loc_7dd6
01ed:5e90	cmp	word ptr [bp - 0x14], 0x1d0
01ed:5e95	jne	loc_7d6c
01ed:5e97	mov	word ptr [bp - 0x14], 0x1a3
        	loc_7d6c:
01ed:5e9c	mov	ax, word ptr [bp - 0x14]
01ed:5e9f	add	ax, 0xfe8b
01ed:5ea2	mov	word ptr [bp - 0x14], ax
01ed:5ea5	mov	al, byte ptr [bp - 3]
01ed:5ea8	mov	ah, 0
01ed:5eaa	les	bx, ptr [bp - 0xe]
01ed:5ead	add	bx, ax
01ed:5eaf	mov	al, byte ptr [bp - 0x14]
01ed:5eb2	mov	byte ptr es:[bx], al
01ed:5eb5	inc	byte ptr [bp - 3]
01ed:5eb8	inc	byte ptr [bp + 6]
01ed:5ebb	mov	al, byte ptr [bp - 3]
01ed:5ebe	mov	ah, 0
01ed:5ec0	mov	bx, word ptr [bp - 0xe]
01ed:5ec3	add	bx, ax
01ed:5ec5	mov	al, byte ptr es:[bx]
01ed:5ec8	mov	ah, 0
01ed:5eca	mov	word ptr [bp - 0x14], ax
01ed:5ecd	cmp	word ptr [bp - 0x14], 0x2e
01ed:5ed1	jne	loc_7da8
01ed:5ed3	mov	word ptr [bp - 0x14], 0x5b
        	loc_7da8:
01ed:5ed8	mov	ax, word ptr [bp - 0x14]
01ed:5edb	add	ax, 0x175
01ed:5ede	mov	word ptr [bp - 0x14], ax
01ed:5ee1	push	ds
01ed:5ee2	mov	ax, 0x792e
01ed:5ee5	push	ax
01ed:5ee6	call	0x942a
01ed:5ee9	add	sp, 4
01ed:5eec	mov	al, 0
01ed:5eee	push	ax
01ed:5eef	push	word ptr [bp - 0x14]
01ed:5ef2	mov	al, byte ptr [bp + 6]
01ed:5ef5	push	ax
01ed:5ef6	mov	al, byte ptr [bp + 4]
01ed:5ef9	mov	cl, 4
01ed:5efb	shl	al, cl
01ed:5efd	push	ax
01ed:5efe	call	0x5fdb
01ed:5f01	add	sp, 8
01ed:5f04	jmp	loc_7dff
        	loc_7dd6:
01ed:5f06	inc	byte ptr [bp - 6]
01ed:5f09	test	byte ptr [bp - 6], 8
01ed:5f0d	je	loc_7dec
01ed:5f0f	push	word ptr [0x576]
01ed:5f13	push	word ptr [0x574]
01ed:5f17	call	0x7b4a
01ed:5f1a	jmp	loc_7df4
        	loc_7dec:
01ed:5f1c	push	ds
01ed:5f1d	mov	ax, 0x792e
01ed:5f20	push	ax
01ed:5f21	call	0x942a
        	loc_7df4:
01ed:5f24	add	sp, 4
01ed:5f27	mov	al, 1
01ed:5f29	push	ax
01ed:5f2a	call	0x5e7
01ed:5f2d	inc	sp
01ed:5f2e	inc	sp
        	loc_7dff:
01ed:5f2f	mov	al, 0
01ed:5f31	push	ax
01ed:5f32	call	0x75a2
01ed:5f35	inc	sp
01ed:5f36	inc	sp
01ed:5f37	mov	byte ptr [bp - 1], al
01ed:5f3a	mov	ah, 0
01ed:5f3c	and	ax, 0x10
01ed:5f3f	cmp	ax, 0x10
01ed:5f42	je	loc_7e17
01ed:5f44	jmp	loc_7c09
        	loc_7e17:
01ed:5f47	push	ds
01ed:5f48	mov	ax, 0x792e
01ed:5f4b	push	ax
01ed:5f4c	call	0x942a
01ed:5f4f	add	sp, 4
01ed:5f52	mov	al, 0
01ed:5f54	mov	byte ptr [bp - 4], al
01ed:5f57	mov	byte ptr [bp - 2], al
01ed:5f5a	jmp	loc_7e95
        	loc_7e2c:
01ed:5f5c	mov	al, byte ptr [bp - 2]
01ed:5f5f	mov	ah, 0
01ed:5f61	shl	ax, 1
01ed:5f63	shl	ax, 1
01ed:5f65	mov	bx, ax
01ed:5f67	mov	ax, word ptr [bx + 0x135e]
01ed:5f6b	mov	dx, word ptr [bx + 0x135c]
01ed:5f6f	mov	word ptr [bp - 0x12], dx
01ed:5f72	mov	word ptr [bp - 0x10], ax
01ed:5f75	mov	al, 0
01ed:5f77	mov	byte ptr [bp - 5], al
01ed:5f7a	mov	byte ptr [bp - 3], al
01ed:5f7d	jmp	loc_7e72
        	loc_7e4f:
01ed:5f7f	mov	al, byte ptr [bp - 3]
01ed:5f82	mov	ah, 0
01ed:5f84	les	bx, ptr [bp - 0xe]
01ed:5f87	add	bx, ax
01ed:5f89	mov	al, byte ptr es:[bx]
01ed:5f8c	mov	dl, byte ptr [bp - 3]
01ed:5f8f	mov	dh, 0
01ed:5f91	les	bx, ptr [bp - 0x12]
01ed:5f94	add	bx, dx
01ed:5f96	cmp	al, byte ptr es:[bx]
01ed:5f99	je	loc_7e6f
01ed:5f9b	mov	byte ptr [bp - 5], 1
        	loc_7e6f:
01ed:5f9f	inc	byte ptr [bp - 3]
        	loc_7e72:
01ed:5fa2	cmp	byte ptr [bp - 3], 6
01ed:5fa6	jae	loc_7e81
01ed:5fa8	mov	al, byte ptr [bp - 5]
01ed:5fab	mov	ah, 0
01ed:5fad	or	ax, ax
01ed:5faf	je	loc_7e4f
        	loc_7e81:
01ed:5fb1	mov	al, byte ptr [bp - 5]
01ed:5fb4	mov	ah, 0
01ed:5fb6	or	ax, ax
01ed:5fb8	jne	loc_7e92
01ed:5fba	mov	al, byte ptr [bp - 2]
01ed:5fbd	add	al, 2
01ed:5fbf	mov	byte ptr [bp - 4], al
        	loc_7e92:
01ed:5fc2	inc	byte ptr [bp - 2]
        	loc_7e95:
01ed:5fc5	cmp	byte ptr [bp - 2], 8
01ed:5fc9	jae	loc_7ea4
01ed:5fcb	mov	al, byte ptr [bp - 4]
01ed:5fce	mov	ah, 0
01ed:5fd0	or	ax, ax
01ed:5fd2	je	loc_7e2c
        	loc_7ea4:
01ed:5fd4	mov	al, byte ptr [bp - 4]
01ed:5fd7	mov	sp, bp
01ed:5fd9	pop	bp
01ed:5fda	ret	
sub_7b57 ENDP
*/
void sub_7b57()
{
    // coverage: 0x6e87-0x71db method sub_7b57
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0014;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_7b66;
    sub_ca53();
loc_7b66:
    push(ss);
    ax = bp - 0xa;
    push(ax);
    push(ds);
    ax = 0x256a;
    push(ax);
    cx = 0x0004;
    sub_c8c5();
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    memoryASet16(es, bx + 14, 0x0000);
    memoryASet16(es, bx + 28, 0x0000);
    memoryASet16(es, bx + 30, 0x0001);
    memoryASet16(es, bx + 32, 0x0002);
    al = 0x00;
    memoryASet(ss, bp - 6, al);
    memoryASet(ss, bp - 3, al);
    ax = memoryAGet16(ss, bp - 8);
    dx = memoryAGet16(ss, bp - 10);
    memoryASet16(ss, bp - 14, dx);
    memoryASet16(ss, bp - 12, ax);
    memoryASet(ss, bp - 2, 0x00);
    goto loc_7bbd;
loc_7bac:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    memoryASet(es, bx, 0x41);
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
loc_7bbd:
    if (memoryAGet(ss, bp - 2) < 0x06)
        goto loc_7bac;
    memoryASet16(ss, bp - 20, 0x01b6);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    memoryASet(es, bx, 0x41);
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp + 6);
    ah = 0x00;
    memoryASet16(es, bx + 20, ax);
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    memoryASet16(es, bx + 22, ax);
    al = 0x01;
    push(ax);
    push(memoryAGet16(ss, bp - 20));
    al = memoryAGet(ss, bp + 6);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7dff;
loc_7c09:
    if (!(memoryAGet(ss, bp - 1) & 0x01))
        goto loc_7c6d;
    if ((short)memoryAGet16(ss, bp - 20) <= (short)0x01ac)
        goto loc_7c6d;
    memoryASet16(ss, bp - 20, memoryAGet16(ss, bp - 20) - 1);
    if (memoryAGet16(ss, bp - 20) != 0x01d0)
        goto loc_7c25;
    memoryASet16(ss, bp - 20, 0x01a3);
loc_7c25:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 20, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 20);
    memoryASet(es, bx, al);
    if (memoryAGet16(ss, bp - 20) != 0x002e)
        goto loc_7c49;
    memoryASet16(ss, bp - 20, 0x005b);
loc_7c49:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0x0175;
    memoryASet16(ss, bp - 20, ax);
    al = 0x01;
    push(ax);
    push(memoryAGet16(ss, bp - 20));
    al = memoryAGet(ss, bp + 6);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7dff;
loc_7c6d:
    if (!(memoryAGet(ss, bp - 1) & 0x02))
        goto loc_7cd1;
    if ((short)memoryAGet16(ss, bp - 20) >= (short)0x01d0)
        goto loc_7cd1;
    memoryASet16(ss, bp - 20, memoryAGet16(ss, bp - 20) + 1);
    if (memoryAGet16(ss, bp - 20) != 0x01d0)
        goto loc_7c89;
    memoryASet16(ss, bp - 20, 0x01a3);
loc_7c89:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 20, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 20);
    memoryASet(es, bx, al);
    if (memoryAGet16(ss, bp - 20) != 0x002e)
        goto loc_7cad;
    memoryASet16(ss, bp - 20, 0x005b);
loc_7cad:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0x0175;
    memoryASet16(ss, bp - 20, ax);
    al = 0x01;
    push(ax);
    push(memoryAGet16(ss, bp - 20));
    al = memoryAGet(ss, bp + 6);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7dff;
loc_7cd1:
    if (!(memoryAGet(ss, bp - 1) & 0x04))
        goto loc_7d54;
    if (memoryAGet(ss, bp - 3) == 0x00)
        goto loc_7d54;
    if (memoryAGet16(ss, bp - 20) != 0x01d0)
        goto loc_7ce9;
    memoryASet16(ss, bp - 20, 0x01a3);
loc_7ce9:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 20, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 20);
    memoryASet(es, bx, al);
    memoryASet(ss, bp - 3, memoryAGet(ss, bp - 3) - 1);
    memoryASet(ss, bp + 6, memoryAGet(ss, bp + 6) - 1);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    bx += ax;
    al = memoryAGet(es, bx);
    ah = 0x00;
    memoryASet16(ss, bp - 20, ax);
    if (memoryAGet16(ss, bp - 20) != 0x002e)
        goto loc_7d25;
    memoryASet16(ss, bp - 20, 0x005b);
loc_7d25:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0x0175;
    memoryASet16(ss, bp - 20, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    al = 0x00;
    push(ax);
    push(memoryAGet16(ss, bp - 20));
    al = memoryAGet(ss, bp + 6);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7dff;
loc_7d54:
    if (!(memoryAGet(ss, bp - 1) & 0x08))
        goto loc_7dd6;
    if (memoryAGet(ss, bp - 3) >= 0x05)
        goto loc_7dd6;
    if (memoryAGet16(ss, bp - 20) != 0x01d0)
        goto loc_7d6c;
    memoryASet16(ss, bp - 20, 0x01a3);
loc_7d6c:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0xfe8b;
    memoryASet16(ss, bp - 20, ax);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    al = memoryAGet(ss, bp - 20);
    memoryASet(es, bx, al);
    memoryASet(ss, bp - 3, memoryAGet(ss, bp - 3) + 1);
    memoryASet(ss, bp + 6, memoryAGet(ss, bp + 6) + 1);
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    bx += ax;
    al = memoryAGet(es, bx);
    ah = 0x00;
    memoryASet16(ss, bp - 20, ax);
    if (memoryAGet16(ss, bp - 20) != 0x002e)
        goto loc_7da8;
    memoryASet16(ss, bp - 20, 0x005b);
loc_7da8:
    ax = memoryAGet16(ss, bp - 20);
    ax += 0x0175;
    memoryASet16(ss, bp - 20, ax);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    al = 0x00;
    push(ax);
    push(memoryAGet16(ss, bp - 20));
    al = memoryAGet(ss, bp + 6);
    push(ax);
    al = memoryAGet(ss, bp + 4);
    cl = 0x04;
    al <<= cl;
    push(ax);
    sub_7eab();
    sp += 0x0008;
    goto loc_7dff;
loc_7dd6:
    memoryASet(ss, bp - 6, memoryAGet(ss, bp - 6) + 1);
    if (!(memoryAGet(ss, bp - 6) & 0x08))
        goto loc_7dec;
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    goto loc_7df4;
loc_7dec:
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
loc_7df4:
    sp += 0x0004;
    al = 0x01;
    push(ax);
    sub_24b7();
    sp++;
    sp++;
loc_7dff:
    al = 0x00;
    push(ax);
    sub_9472();
    sp++;
    sp++;
    memoryASet(ss, bp - 1, al);
    ah = 0x00;
    ax &= 0x0010;
    if (ax == 0x0010)
        goto loc_7e17;
    goto loc_7c09;
loc_7e17:
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    al = 0x00;
    memoryASet(ss, bp - 4, al);
    memoryASet(ss, bp - 2, al);
    goto loc_7e95;
loc_7e2c:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 4958);
    dx = memoryAGet16(ds, bx + 4956);
    memoryASet16(ss, bp - 18, dx);
    memoryASet16(ss, bp - 16, ax);
    al = 0x00;
    memoryASet(ss, bp - 5, al);
    memoryASet(ss, bp - 3, al);
    goto loc_7e72;
loc_7e4f:
    al = memoryAGet(ss, bp - 3);
    ah = 0x00;
    bx = memoryAGet16(ss, bp - 14);
    es = memoryAGet16(ss, bp - 14 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    dl = memoryAGet(ss, bp - 3);
    dh = 0x00;
    bx = memoryAGet16(ss, bp - 18);
    es = memoryAGet16(ss, bp - 18 + 2);
    bx += dx;
    if (al == memoryAGet(es, bx))
        goto loc_7e6f;
    memoryASet(ss, bp - 5, 0x01);
loc_7e6f:
    memoryASet(ss, bp - 3, memoryAGet(ss, bp - 3) + 1);
loc_7e72:
    if (memoryAGet(ss, bp - 3) >= 0x06)
        goto loc_7e81;
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    if (!ax)
        goto loc_7e4f;
loc_7e81:
    al = memoryAGet(ss, bp - 5);
    ah = 0x00;
    if (ax)
        goto loc_7e92;
    al = memoryAGet(ss, bp - 2);
    al += 0x02;
    memoryASet(ss, bp - 4, al);
loc_7e92:
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
loc_7e95:
    if (memoryAGet(ss, bp - 2) >= 0x08)
        goto loc_7ea4;
    al = memoryAGet(ss, bp - 4);
    ah = 0x00;
    if (!ax)
        goto loc_7e2c;
loc_7ea4:
    al = memoryAGet(ss, bp - 4);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:5fdb sub_7eab()
sub_7eab PROC
01ed:5fdb	push	bp
01ed:5fdc	mov	bp, sp
01ed:5fde	cmp	word ptr [0x6b4c], sp
01ed:5fe2	ja	loc_7eb7
01ed:5fe4	call	0xab83
        	loc_7eb7:
01ed:5fe7	les	bx, ptr [0x574]
01ed:5feb	mov	al, byte ptr [bp + 6]
01ed:5fee	mov	ah, 0
01ed:5ff0	mov	word ptr es:[bx + 0x14], ax
01ed:5ff4	push	word ptr [0x576]
01ed:5ff8	push	word ptr [0x574]
01ed:5ffc	call	0x7b4a
01ed:5fff	add	sp, 4
01ed:6002	les	bx, ptr [0x8884]
01ed:6006	mov	ax, word ptr [bp + 8]
01ed:6009	mov	word ptr es:[bx + 4], ax
01ed:600d	mov	al, byte ptr [bp + 6]
01ed:6010	mov	ah, 0
01ed:6012	mov	cl, 4
01ed:6014	shl	ax, cl
01ed:6016	mov	word ptr es:[bx], ax
01ed:6019	mov	al, byte ptr [bp + 4]
01ed:601c	mov	ah, 0
01ed:601e	mov	word ptr es:[bx + 2], ax
01ed:6022	cmp	byte ptr [bp + 0xa], 0
01ed:6026	je	loc_7f03
01ed:6028	push	ds
01ed:6029	mov	ax, 0x792e
01ed:602c	push	ax
01ed:602d	call	0x942a
01ed:6030	add	sp, 4
        	loc_7f03:
01ed:6033	mov	al, 8
01ed:6035	push	ax
01ed:6036	call	0x5e7
01ed:6039	inc	sp
01ed:603a	inc	sp
01ed:603b	pop	bp
01ed:603c	ret	
sub_7eab ENDP
*/
void sub_7eab()
{
    // coverage: 0x71db-0x723d method sub_7eab
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_7eb7;
    sub_ca53();
loc_7eb7:
    bx = memoryAGet16(ds, 0x0574);
    es = memoryAGet16(ds, 0x0574 + 2);
    al = memoryAGet(ss, bp + 6);
    ah = 0x00;
    memoryASet16(es, bx + 20, ax);
    push(memoryAGet16(ds, 0x0576));
    push(memoryAGet16(ds, 0x0574));
    sub_9a1a();
    sp += 0x0004;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ss, bp + 8);
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp + 6);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    memoryASet16(es, bx, ax);
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    memoryASet16(es, bx + 2, ax);
    if (memoryAGet(ss, bp + 10) == 0x00)
        goto loc_7f03;
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
loc_7f03:
    al = 0x08;
    push(ax);
    sub_24b7();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:603d sub_7f0d()
sub_7f0d PROC
01ed:603d	push	bp
01ed:603e	mov	bp, sp
01ed:6040	sub	sp, 0xc
01ed:6043	push	si
01ed:6044	mov	si, word ptr [bp + 0xa]
01ed:6047	cmp	word ptr [0x6b4c], sp
01ed:604b	ja	loc_7f20
01ed:604d	call	0xab83
        	loc_7f20:
01ed:6050	mov	al, byte ptr [bp + 8]
01ed:6053	mov	byte ptr [bp - 0xc], al
01ed:6056	mov	byte ptr [bp - 0xb], 0
01ed:605a	jmp	loc_7f3f
        	loc_7f2c:
01ed:605c	mov	al, byte ptr [bp - 0xb]
01ed:605f	inc	byte ptr [bp - 0xb]
01ed:6062	mov	ah, 0
01ed:6064	lea	dx, [bp - 0xa]
01ed:6067	add	ax, dx
01ed:6069	mov	bx, ax
01ed:606b	mov	byte ptr ss:[bx], 0x20
        	loc_7f3f:
01ed:606f	mov	al, byte ptr [bp - 0xb]
01ed:6072	cmp	al, byte ptr [bp + 8]
01ed:6075	jb	loc_7f2c
01ed:6077	mov	al, byte ptr [bp + 8]
01ed:607a	mov	ah, 0
01ed:607c	lea	dx, [bp - 0xa]
01ed:607f	add	ax, dx
01ed:6081	mov	bx, ax
01ed:6083	mov	byte ptr ss:[bx], 0
01ed:6087	jmp	loc_7f9e
        	loc_7f59:
01ed:6089	mov	al, byte ptr [bp + 4]
01ed:608c	mov	byte ptr [bp - 1], al
01ed:608f	xor	ax, ax
01ed:6091	mov	dx, 0xa
01ed:6094	push	ax
01ed:6095	push	dx
01ed:6096	push	word ptr [bp + 6]
01ed:6099	push	word ptr [bp + 4]
01ed:609c	call	0xa8ee
01ed:609f	mov	word ptr [bp + 4], ax
01ed:60a2	mov	bx, ax
01ed:60a4	mov	word ptr [bp + 6], dx
01ed:60a7	mov	cx, dx
01ed:60a9	xor	dx, dx
01ed:60ab	mov	ax, 0xa
01ed:60ae	call	0xaa14
01ed:60b1	mov	dl, byte ptr [bp - 1]
01ed:60b4	sub	dl, al
01ed:60b6	mov	byte ptr [bp - 1], dl
01ed:60b9	mov	al, byte ptr [bp + 8]
01ed:60bc	mov	ah, 0
01ed:60be	lea	dx, [bp - 0xa]
01ed:60c1	add	ax, dx
01ed:60c3	mov	dl, byte ptr [bp - 1]
01ed:60c6	add	dl, 0x30
01ed:60c9	mov	bx, ax
01ed:60cb	mov	byte ptr ss:[bx], dl
        	loc_7f9e:
01ed:60ce	mov	al, byte ptr [bp + 8]
01ed:60d1	dec	byte ptr [bp + 8]
01ed:60d4	or	al, al
01ed:60d6	ja	loc_7f59
01ed:60d8	les	bx, ptr [0x8884]
01ed:60dc	mov	ax, word ptr [bp + 0xc]
01ed:60df	mov	word ptr es:[bx + 2], ax
01ed:60e3	mov	byte ptr [bp - 0xb], 0
01ed:60e7	jmp	loc_7ff3
        	loc_7fb9:
01ed:60e9	mov	al, byte ptr [bp - 0xb]
01ed:60ec	mov	ah, 0
01ed:60ee	lea	dx, [bp - 0xa]
01ed:60f1	add	ax, dx
01ed:60f3	mov	bx, ax
01ed:60f5	mov	al, byte ptr ss:[bx]
01ed:60f8	mov	ah, 0
01ed:60fa	add	ax, 0x17c
01ed:60fd	les	bx, ptr [0x8884]
01ed:6101	mov	word ptr es:[bx + 4], ax
01ed:6105	mov	al, byte ptr [bp - 0xb]
01ed:6108	mov	ah, 0
01ed:610a	mov	cl, 4
01ed:610c	shl	ax, cl
01ed:610e	mov	dx, si
01ed:6110	add	dx, ax
01ed:6112	mov	word ptr es:[bx], dx
01ed:6115	push	ds
01ed:6116	mov	ax, 0x792e
01ed:6119	push	ax
01ed:611a	call	0x942a
01ed:611d	add	sp, 4
01ed:6120	inc	byte ptr [bp - 0xb]
        	loc_7ff3:
01ed:6123	mov	al, byte ptr [bp - 0xb]
01ed:6126	cmp	al, byte ptr [bp - 0xc]
01ed:6129	jb	loc_7fb9
01ed:612b	pop	si
01ed:612c	mov	sp, bp
01ed:612e	pop	bp
01ed:612f	ret	
sub_7f0d ENDP
*/
void sub_7f0d()
{
    // coverage: 0x723d-0x7330 method sub_7f0d
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000c;
    push(si);
    si = memoryAGet16(ss, bp + 10);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_7f20;
    sub_ca53();
loc_7f20:
    al = memoryAGet(ss, bp + 8);
    memoryASet(ss, bp - 12, al);
    memoryASet(ss, bp - 11, 0x00);
    goto loc_7f3f;
loc_7f2c:
    al = memoryAGet(ss, bp - 11);
    memoryASet(ss, bp - 11, memoryAGet(ss, bp - 11) + 1);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    bx = ax;
    memoryASet(ss, bx, 0x20);
loc_7f3f:
    al = memoryAGet(ss, bp - 11);
    if (al < memoryAGet(ss, bp + 8))
        goto loc_7f2c;
    al = memoryAGet(ss, bp + 8);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    bx = ax;
    memoryASet(ss, bx, 0x00);
    goto loc_7f9e;
loc_7f59:
    al = memoryAGet(ss, bp + 4);
    memoryASet(ss, bp - 1, al);
    ax = 0;
    dx = 0x000a;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_c7be();
    memoryASet16(ss, bp + 4, ax);
    bx = ax;
    memoryASet16(ss, bp + 6, dx);
    cx = dx;
    dx = 0;
    ax = 0x000a;
    sub_c8e4();
    dl = memoryAGet(ss, bp - 1);
    dl -= al;
    memoryASet(ss, bp - 1, dl);
    al = memoryAGet(ss, bp + 8);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    dl = memoryAGet(ss, bp - 1);
    dl += 0x30;
    bx = ax;
    memoryASet(ss, bx, dl);
loc_7f9e:
    al = memoryAGet(ss, bp + 8);
    memoryASet(ss, bp + 8, memoryAGet(ss, bp + 8) - 1);
    if (stop(/*condition!*/))
        goto loc_7f59;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    ax = memoryAGet16(ss, bp + 12);
    memoryASet16(es, bx + 2, ax);
    memoryASet(ss, bp - 11, 0x00);
    goto loc_7ff3;
loc_7fb9:
    al = memoryAGet(ss, bp - 11);
    ah = 0x00;
    dx = bp - 0xa;
    ax += dx;
    bx = ax;
    al = memoryAGet(ss, bx);
    ah = 0x00;
    ax += 0x017c;
    bx = memoryAGet16(ds, 0x8884);
    es = memoryAGet16(ds, 0x8884 + 2);
    memoryASet16(es, bx + 4, ax);
    al = memoryAGet(ss, bp - 11);
    ah = 0x00;
    cl = 0x04;
    ax <<= cl;
    dx = si;
    dx += ax;
    memoryASet16(es, bx, dx);
    push(ds);
    ax = 0x792e;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    memoryASet(ss, bp - 11, memoryAGet(ss, bp - 11) + 1);
loc_7ff3:
    al = memoryAGet(ss, bp - 11);
    if (al < memoryAGet(ss, bp - 12))
        goto loc_7fb9;
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6130 sub_8000()
sub_8000 PROC
01ed:6130	push	bp
01ed:6131	mov	bp, sp
01ed:6133	dec	sp
01ed:6134	dec	sp
01ed:6135	cmp	word ptr [0x6b4c], sp
01ed:6139	ja	loc_800e
01ed:613b	call	0xab83
        	loc_800e:
01ed:613e	les	bx, ptr [0xa0d0]
01ed:6142	mov	word ptr es:[bx + 4], 0x1aa
01ed:6148	mov	word ptr es:[bx + 2], 0
01ed:614e	mov	al, byte ptr [0x791a]
01ed:6151	mov	byte ptr [bp - 1], al
01ed:6154	jmp	loc_8049
        	loc_8026:
01ed:6156	mov	al, byte ptr [bp - 1]
01ed:6159	mov	ah, 0
01ed:615b	shl	ax, 1
01ed:615d	shl	ax, 1
01ed:615f	shl	ax, 1
01ed:6161	add	ax, 0x50
01ed:6164	les	bx, ptr [0xa0d0]
01ed:6168	mov	word ptr es:[bx], ax
01ed:616b	push	ds
01ed:616c	mov	ax, 0x7986
01ed:616f	push	ax
01ed:6170	call	0x942a
01ed:6173	add	sp, 4
01ed:6176	dec	byte ptr [bp - 1]
        	loc_8049:
01ed:6179	cmp	byte ptr [bp - 1], 0
01ed:617d	jne	loc_8026
01ed:617f	mov	sp, bp
01ed:6181	pop	bp
01ed:6182	ret	
sub_8000 ENDP
*/
void sub_8000()
{
    // coverage: 0x7330-0x7383 method sub_8000
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_800e;
    sub_ca53();
loc_800e:
    bx = memoryAGet16(ds, 0xa0d0);
    es = memoryAGet16(ds, 0xa0d0 + 2);
    memoryASet16(es, bx + 4, 0x01aa);
    memoryASet16(es, bx + 2, 0x0000);
    al = memoryAGet(ds, 0x791a);
    memoryASet(ss, bp - 1, al);
    goto loc_8049;
loc_8026:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax += 0x0050;
    bx = memoryAGet16(ds, 0xa0d0);
    es = memoryAGet16(ds, 0xa0d0 + 2);
    memoryASet16(es, bx, ax);
    push(ds);
    ax = 0x7986;
    push(ax);
    sub_b2fa();
    sp += 0x0004;
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) - 1);
loc_8049:
    if (memoryAGet(ss, bp - 1) != 0x00)
        goto loc_8026;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6183 sub_8053()
sub_8053 PROC
01ed:6183	push	bp
01ed:6184	mov	bp, sp
01ed:6186	dec	sp
01ed:6187	dec	sp
01ed:6188	cmp	word ptr [0x6b4c], sp
01ed:618c	ja	loc_8061
01ed:618e	call	0xab83
        	loc_8061:
01ed:6191	mov	word ptr [0x9ba6], 0x886
01ed:6197	mov	word ptr [0x9ba8], ds
01ed:619b	les	bx, ptr [0x9ba6]
01ed:619f	mov	byte ptr es:[bx], 0xff
01ed:61a3	mov	byte ptr [0xa1a6], 0
01ed:61a8	mov	dl, 0
01ed:61aa	jmp	loc_809b
        	loc_807c:
01ed:61ac	mov	al, dl
01ed:61ae	mov	ah, 0
01ed:61b0	les	bx, ptr [0xa0d8]
01ed:61b4	add	bx, ax
01ed:61b6	mov	al, byte ptr es:[bx + 0x30]
01ed:61ba	mov	cl, al
01ed:61bc	cmp	cl, 0xe
01ed:61bf	jb	loc_8099
01ed:61c1	cmp	cl, 0x12
01ed:61c4	jae	loc_8099
01ed:61c6	mov	byte ptr [0xa1a6], al
        	loc_8099:
01ed:61c9	inc	dl
        	loc_809b:
01ed:61cb	cmp	dl, 0x30
01ed:61ce	jae	loc_80a9
01ed:61d0	mov	al, byte ptr [0xa1a6]
01ed:61d3	mov	ah, 0
01ed:61d5	or	ax, ax
01ed:61d7	je	loc_807c
        	loc_80a9:
01ed:61d9	cmp	byte ptr [0xa1a6], 0
01ed:61de	jne	loc_80b3
01ed:61e0	jmp	loc_8168
        	loc_80b3:
01ed:61e3	mov	al, 0
01ed:61e5	mov	byte ptr [bp - 1], al
01ed:61e8	mov	dl, al
01ed:61ea	jmp	loc_80e2
        	loc_80bc:
01ed:61ec	mov	al, dl
01ed:61ee	mov	ah, 0
01ed:61f0	les	bx, ptr [0xa0d8]
01ed:61f4	add	bx, ax
01ed:61f6	mov	al, byte ptr es:[bx + 0x30]
01ed:61fa	mov	cl, al
01ed:61fc	cmp	cl, 0xe
01ed:61ff	jb	loc_80e0
01ed:6201	cmp	cl, 0x12
01ed:6204	jae	loc_80e0
01ed:6206	cmp	al, byte ptr [0xa1a6]
01ed:620a	je	loc_80e0
01ed:620c	mov	byte ptr [bp - 1], 1
        	loc_80e0:
01ed:6210	inc	dl
        	loc_80e2:
01ed:6212	cmp	dl, 0x30
01ed:6215	jae	loc_80f0
01ed:6217	mov	al, byte ptr [bp - 1]
01ed:621a	mov	ah, 0
01ed:621c	or	ax, ax
01ed:621e	je	loc_80bc
        	loc_80f0:
01ed:6220	mov	al, byte ptr [bp - 1]
01ed:6223	mov	ah, 0
01ed:6225	or	ax, ax
01ed:6227	jne	loc_8168
01ed:6229	mov	al, 0
01ed:622b	mov	byte ptr [bp - 2], al
01ed:622e	mov	byte ptr [bp - 1], al
01ed:6231	mov	dl, 0
01ed:6233	jmp	loc_812b
        	loc_8105:
01ed:6235	mov	al, dl
01ed:6237	mov	ah, 0
01ed:6239	les	bx, ptr [0xa0d8]
01ed:623d	add	bx, ax
01ed:623f	cmp	byte ptr es:[bx + 0x30], 5
01ed:6244	jne	loc_8129
01ed:6246	mov	al, byte ptr [bp - 2]
01ed:6249	mov	ah, 0
01ed:624b	les	bx, ptr [0x9ba6]
01ed:624f	add	bx, ax
01ed:6251	mov	al, dl
01ed:6253	mov	byte ptr es:[bx], al
01ed:6256	inc	byte ptr [bp - 2]
        	loc_8129:
01ed:6259	inc	dl
        	loc_812b:
01ed:625b	cmp	dl, 0x30
01ed:625e	jae	loc_8139
01ed:6260	mov	al, byte ptr [bp - 1]
01ed:6263	mov	ah, 0
01ed:6265	or	ax, ax
01ed:6267	je	loc_8105
        	loc_8139:
01ed:6269	mov	al, byte ptr [bp - 2]
01ed:626c	mov	ah, 0
01ed:626e	les	bx, ptr [0x9ba6]
01ed:6272	add	bx, ax
01ed:6274	cmp	byte ptr es:[bx], 0xff
01ed:6278	je	loc_8168
01ed:627a	mov	al, byte ptr [bp - 2]
01ed:627d	mov	ah, 0
01ed:627f	mov	bx, word ptr [0x9ba6]
01ed:6283	add	bx, ax
01ed:6285	mov	byte ptr es:[bx], 0xff
01ed:6289	mov	word ptr [0x9ba6], 0x886
01ed:628f	mov	word ptr [0x9ba8], ds
01ed:6293	mov	byte ptr [0x79b7], 0
        	loc_8168:
01ed:6298	mov	sp, bp
01ed:629a	pop	bp
01ed:629b	ret	
sub_8053 ENDP
*/
void sub_8053()
{
    // coverage: 0x7383-0x749c method sub_8053
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8061;
    sub_ca53();
loc_8061:
    memoryASet16(ds, 0x9ba6, 0x0886);
    memoryASet16(ds, 0x9ba8, ds);
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    memoryASet(es, bx, 0xff);
    memoryASet(ds, 0xa1a6, 0x00);
    dl = 0x00;
    goto loc_809b;
loc_807c:
    al = dl;
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 48);
    cl = al;
    if (cl < 0x0e)
        goto loc_8099;
    if (cl >= 0x12)
        goto loc_8099;
    memoryASet(ds, 0xa1a6, al);
loc_8099:
    dl++;
loc_809b:
    if (dl >= 0x30)
        goto loc_80a9;
    al = memoryAGet(ds, 0xa1a6);
    ah = 0x00;
    if (!ax)
        goto loc_807c;
loc_80a9:
    if (memoryAGet(ds, 0xa1a6) != 0x00)
        goto loc_80b3;
    goto loc_8168;
loc_80b3:
    al = 0x00;
    memoryASet(ss, bp - 1, al);
    dl = al;
    goto loc_80e2;
loc_80bc:
    al = dl;
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 48);
    cl = al;
    if (cl < 0x0e)
        goto loc_80e0;
    if (cl >= 0x12)
        goto loc_80e0;
    if (al == memoryAGet(ds, 0xa1a6))
        goto loc_80e0;
    memoryASet(ss, bp - 1, 0x01);
loc_80e0:
    dl++;
loc_80e2:
    if (dl >= 0x30)
        goto loc_80f0;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (!ax)
        goto loc_80bc;
loc_80f0:
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_8168;
    al = 0x00;
    memoryASet(ss, bp - 2, al);
    memoryASet(ss, bp - 1, al);
    dl = 0x00;
    goto loc_812b;
loc_8105:
    al = dl;
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx + 48) != 0x05)
        goto loc_8129;
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    bx += ax;
    al = dl;
    memoryASet(es, bx, al);
    memoryASet(ss, bp - 2, memoryAGet(ss, bp - 2) + 1);
loc_8129:
    dl++;
loc_812b:
    if (dl >= 0x30)
        goto loc_8139;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (!ax)
        goto loc_8105;
loc_8139:
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    bx += ax;
    if (memoryAGet(es, bx) == 0xff)
        goto loc_8168;
    al = memoryAGet(ss, bp - 2);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x9ba6);
    bx += ax;
    memoryASet(es, bx, 0xff);
    memoryASet16(ds, 0x9ba6, 0x0886);
    memoryASet16(ds, 0x9ba8, ds);
    memoryASet(ds, 0x79b7, 0x00);
loc_8168:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:629c sub_816c()
sub_816c PROC
01ed:629c	push	bp
01ed:629d	mov	bp, sp
01ed:629f	cmp	word ptr [0x6b4c], sp
01ed:62a3	ja	loc_8178
01ed:62a5	call	0xab83
        	loc_8178:
01ed:62a8	les	bx, ptr [0x9ba6]
01ed:62ac	cmp	byte ptr es:[bx], 0xff
01ed:62b0	jne	loc_8196
01ed:62b2	mov	word ptr [0x9ba6], 0x886
01ed:62b8	mov	word ptr [0x9ba8], ds
01ed:62bc	les	bx, ptr [0x9ba6]
01ed:62c0	mov	byte ptr es:[bx], 0xff
01ed:62c4	jmp	loc_81d3
        	loc_8196:
01ed:62c6	mov	al, byte ptr [0x79b7]
01ed:62c9	mov	ah, 0
01ed:62cb	or	ax, ax
01ed:62cd	jne	loc_81cf
01ed:62cf	mov	byte ptr [0x79b7], 0xa
01ed:62d4	les	bx, ptr [0x9ba6]
01ed:62d8	mov	al, byte ptr es:[bx]
01ed:62db	mov	byte ptr [0x8570], al
01ed:62de	mov	al, 0x18
01ed:62e0	push	ax
01ed:62e1	call	0x6a89
01ed:62e4	inc	sp
01ed:62e5	inc	sp
01ed:62e6	cmp	word ptr [0x689c], 4
01ed:62eb	je	loc_81c1
01ed:62ed	mov	al, 0x11
01ed:62ef	jmp	loc_81c3
        	loc_81c1:
01ed:62f1	mov	al, 0xe
        	loc_81c3:
01ed:62f3	push	ax
01ed:62f4	call	0x6e11
01ed:62f7	inc	sp
01ed:62f8	inc	sp
01ed:62f9	inc	word ptr [0x9ba6]
01ed:62fd	jmp	loc_81d3
        	loc_81cf:
01ed:62ff	dec	byte ptr [0x79b7]
        	loc_81d3:
01ed:6303	pop	bp
01ed:6304	ret	
sub_816c ENDP
*/
void sub_816c()
{
    // coverage: 0x749c-0x7505 method sub_816c
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8178;
    sub_ca53();
loc_8178:
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    if (memoryAGet(es, bx) != 0xff)
        goto loc_8196;
    memoryASet16(ds, 0x9ba6, 0x0886);
    memoryASet16(ds, 0x9ba8, ds);
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    memoryASet(es, bx, 0xff);
    goto loc_81d3;
loc_8196:
    al = memoryAGet(ds, 0x79b7);
    ah = 0x00;
    if (ax)
        goto loc_81cf;
    memoryASet(ds, 0x79b7, 0x0a);
    bx = memoryAGet16(ds, 0x9ba6);
    es = memoryAGet16(ds, 0x9ba6 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ds, 0x8570, al);
    al = 0x18;
    push(ax);
    sub_8959();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_81c1;
    al = 0x11;
    goto loc_81c3;
loc_81c1:
    al = 0x0e;
loc_81c3:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    memoryASet16(ds, 0x9ba6, memoryAGet16(ds, 0x9ba6) + 1);
    goto loc_81d3;
loc_81cf:
    memoryASet(ds, 0x79b7, memoryAGet(ds, 0x79b7) - 1);
loc_81d3:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6305 sub_81d5()
sub_81d5 PROC
01ed:6305	push	bp
01ed:6306	mov	bp, sp
01ed:6308	cmp	word ptr [0x6b4c], sp
01ed:630c	ja	loc_81e1
01ed:630e	call	0xab83
        	loc_81e1:
01ed:6311	cmp	word ptr [0x689c], 4
01ed:6316	je	loc_81ec
01ed:6318	mov	al, 3
01ed:631a	jmp	loc_81ee
        	loc_81ec:
01ed:631c	mov	al, 0xd
        	loc_81ee:
01ed:631e	push	ax
01ed:631f	call	0x6e11
01ed:6322	inc	sp
01ed:6323	inc	sp
01ed:6324	pop	bp
01ed:6325	ret	
sub_81d5 ENDP
*/
void sub_81d5()
{
    // coverage: 0x7505-0x7526 method sub_81d5
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_81e1;
    sub_ca53();
loc_81e1:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_81ec;
    al = 0x03;
    goto loc_81ee;
loc_81ec:
    al = 0x0d;
loc_81ee:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6326 sub_81f6()
sub_81f6 PROC
01ed:6326	push	bp
01ed:6327	mov	bp, sp
01ed:6329	cmp	word ptr [0x6b4c], sp
01ed:632d	ja	loc_8202
01ed:632f	call	0xab83
        	loc_8202:
01ed:6332	cmp	byte ptr [0x855e], 0
01ed:6337	je	loc_8240
01ed:6339	mov	al, byte ptr [0x856e]
01ed:633c	mov	ah, 0
01ed:633e	les	bx, ptr [0xa0d8]
01ed:6342	add	bx, ax
01ed:6344	cmp	byte ptr es:[bx + 0x2f], 0xc
01ed:6349	jne	loc_8240
01ed:634b	mov	byte ptr [0x792a], 0
01ed:6350	mov	byte ptr [0xa0ce], 1
01ed:6355	mov	al, 0x2e
01ed:6357	push	ax
01ed:6358	call	0x4263
01ed:635b	inc	sp
01ed:635c	inc	sp
01ed:635d	cmp	word ptr [0x689c], 4
01ed:6362	je	loc_8238
01ed:6364	mov	al, 3
01ed:6366	jmp	loc_823a
        	loc_8238:
01ed:6368	mov	al, 0xd
        	loc_823a:
01ed:636a	push	ax
01ed:636b	call	0x6e11
01ed:636e	inc	sp
01ed:636f	inc	sp
        	loc_8240:
01ed:6370	pop	bp
01ed:6371	ret	
sub_81f6 ENDP
*/
void sub_81f6()
{
    // coverage: 0x7526-0x7572 method sub_81f6
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8202;
    sub_ca53();
loc_8202:
    if (memoryAGet(ds, 0x855e) == 0x00)
        goto loc_8240;
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx + 47) != 0x0c)
        goto loc_8240;
    memoryASet(ds, 0x792a, 0x00);
    memoryASet(ds, 0xa0ce, 0x01);
    al = 0x2e;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8238;
    al = 0x03;
    goto loc_823a;
loc_8238:
    al = 0x0d;
loc_823a:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_8240:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6372 sub_8242()
sub_8242 PROC
01ed:6372	push	bp
01ed:6373	mov	bp, sp
01ed:6375	cmp	word ptr [0x6b4c], sp
01ed:6379	ja	loc_824e
01ed:637b	call	0xab83
        	loc_824e:
01ed:637e	cmp	byte ptr [0x855e], 7
01ed:6383	je	loc_828c
01ed:6385	mov	al, byte ptr [0x856e]
01ed:6388	mov	ah, 0
01ed:638a	les	bx, ptr [0xa0d8]
01ed:638e	add	bx, ax
01ed:6390	cmp	byte ptr es:[bx + 0x30], 0xc
01ed:6395	jne	loc_828c
01ed:6397	mov	byte ptr [0x792a], 0
01ed:639c	mov	byte ptr [0xa0ce], 1
01ed:63a1	mov	al, 0x2e
01ed:63a3	push	ax
01ed:63a4	call	0x4263
01ed:63a7	inc	sp
01ed:63a8	inc	sp
01ed:63a9	cmp	word ptr [0x689c], 4
01ed:63ae	je	loc_8284
01ed:63b0	mov	al, 3
01ed:63b2	jmp	loc_8286
        	loc_8284:
01ed:63b4	mov	al, 0xd
        	loc_8286:
01ed:63b6	push	ax
01ed:63b7	call	0x6e11
01ed:63ba	inc	sp
01ed:63bb	inc	sp
        	loc_828c:
01ed:63bc	pop	bp
01ed:63bd	ret	
sub_8242 ENDP
*/
void sub_8242()
{
    // coverage: 0x7572-0x75be method sub_8242
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_824e;
    sub_ca53();
loc_824e:
    if (memoryAGet(ds, 0x855e) == 0x07)
        goto loc_828c;
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    if (memoryAGet(es, bx + 48) != 0x0c)
        goto loc_828c;
    memoryASet(ds, 0x792a, 0x00);
    memoryASet(ds, 0xa0ce, 0x01);
    al = 0x2e;
    push(ax);
    sub_6133();
    sp++;
    sp++;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8284;
    al = 0x03;
    goto loc_8286;
loc_8284:
    al = 0x0d;
loc_8286:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_828c:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:63be sub_828e()
sub_828e PROC
01ed:63be	push	bp
01ed:63bf	mov	bp, sp
01ed:63c1	dec	sp
01ed:63c2	dec	sp
01ed:63c3	cmp	word ptr [0x6b4c], sp
01ed:63c7	ja	loc_829c
01ed:63c9	call	0xab83
        	loc_829c:
01ed:63cc	cmp	byte ptr [0x8552], 3
01ed:63d1	je	loc_82d8
01ed:63d3	cmp	byte ptr [0x8552], 0xf
01ed:63d8	je	loc_82d8
01ed:63da	cmp	word ptr [0x689c], 4
01ed:63df	je	loc_82be
01ed:63e1	mov	al, byte ptr [0x7924]
01ed:63e4	mov	ah, 0
01ed:63e6	mov	bx, ax
01ed:63e8	mov	al, byte ptr [bx + 0x263e]
01ed:63ec	jmp	loc_82c9
        	loc_82be:
01ed:63ee	mov	al, byte ptr [0x7924]
01ed:63f1	mov	ah, 0
01ed:63f3	mov	bx, ax
01ed:63f5	mov	al, byte ptr [bx + 0x260e]
        	loc_82c9:
01ed:63f9	mov	byte ptr [bp - 1], al
01ed:63fc	cmp	byte ptr [bp - 1], 0
01ed:6400	je	loc_82d8
01ed:6402	push	ax
01ed:6403	call	0x6e11
01ed:6406	inc	sp
01ed:6407	inc	sp
        	loc_82d8:
01ed:6408	mov	sp, bp
01ed:640a	pop	bp
01ed:640b	ret	
sub_828e ENDP
*/
void sub_828e()
{
    // coverage: 0x75be-0x760c method sub_828e
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_829c;
    sub_ca53();
loc_829c:
    if (memoryAGet(ds, 0x8552) == 0x03)
        goto loc_82d8;
    if (memoryAGet(ds, 0x8552) == 0x0f)
        goto loc_82d8;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_82be;
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9790);
    goto loc_82c9;
loc_82be:
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9742);
loc_82c9:
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_82d8;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_82d8:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:640c sub_82dc()
sub_82dc PROC
01ed:640c	push	bp
01ed:640d	mov	bp, sp
01ed:640f	dec	sp
01ed:6410	dec	sp
01ed:6411	cmp	word ptr [0x6b4c], sp
01ed:6415	ja	loc_82ea
01ed:6417	call	0xab83
        	loc_82ea:
01ed:641a	cmp	word ptr [0x689c], 4
01ed:641f	je	loc_82fe
01ed:6421	mov	al, byte ptr [0x8551]
01ed:6424	mov	ah, 0
01ed:6426	mov	bx, ax
01ed:6428	mov	al, byte ptr [bx + 0x278e]
01ed:642c	jmp	loc_8309
        	loc_82fe:
01ed:642e	mov	al, byte ptr [0x8551]
01ed:6431	mov	ah, 0
01ed:6433	mov	bx, ax
01ed:6435	mov	al, byte ptr [bx + 0x276e]
        	loc_8309:
01ed:6439	mov	byte ptr [bp - 1], al
01ed:643c	cmp	byte ptr [bp - 1], 0
01ed:6440	je	loc_8318
01ed:6442	push	ax
01ed:6443	call	0x6e11
01ed:6446	inc	sp
01ed:6447	inc	sp
        	loc_8318:
01ed:6448	cmp	byte ptr [0x8551], 0xe
01ed:644d	jb	loc_8329
01ed:644f	cmp	byte ptr [0x8551], 0x12
01ed:6454	jae	loc_8329
01ed:6456	call	0x6183
        	loc_8329:
01ed:6459	mov	sp, bp
01ed:645b	pop	bp
01ed:645c	ret	
sub_82dc ENDP
*/
void sub_82dc()
{
    // coverage: 0x760c-0x765d method sub_82dc
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_82ea;
    sub_ca53();
loc_82ea:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_82fe;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 10126);
    goto loc_8309;
loc_82fe:
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 10094);
loc_8309:
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_8318;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_8318:
    if (memoryAGet(ds, 0x8551) < 0x0e)
        goto loc_8329;
    if (memoryAGet(ds, 0x8551) >= 0x12)
        goto loc_8329;
    sub_8053();
loc_8329:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:645d sub_832d()
sub_832d PROC
01ed:645d	push	bp
01ed:645e	mov	bp, sp
01ed:6460	cmp	word ptr [0x6b4c], sp
01ed:6464	ja	loc_8339
01ed:6466	call	0xab83
        	loc_8339:
01ed:6469	cmp	word ptr [0x689c], 4
01ed:646e	je	loc_8344
01ed:6470	mov	al, 0xb
01ed:6472	jmp	loc_8346
        	loc_8344:
01ed:6474	mov	al, 0x2c
        	loc_8346:
01ed:6476	push	ax
01ed:6477	call	0x6e11
01ed:647a	inc	sp
01ed:647b	inc	sp
01ed:647c	pop	bp
01ed:647d	ret	
sub_832d ENDP
*/
void sub_832d()
{
    // coverage: 0x765d-0x767e method sub_832d
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8339;
    sub_ca53();
loc_8339:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8344;
    al = 0x0b;
    goto loc_8346;
loc_8344:
    al = 0x2c;
loc_8346:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:647e sub_834e()
sub_834e PROC
01ed:647e	push	bp
01ed:647f	mov	bp, sp
01ed:6481	dec	sp
01ed:6482	dec	sp
01ed:6483	cmp	word ptr [0x6b4c], sp
01ed:6487	ja	loc_835c
01ed:6489	call	0xab83
        	loc_835c:
01ed:648c	cmp	word ptr [0x689c], 4
01ed:6491	je	loc_8370
01ed:6493	mov	al, byte ptr [0x79b9]
01ed:6496	mov	ah, 0
01ed:6498	mov	bx, ax
01ed:649a	mov	al, byte ptr [bx + 0x26fe]
01ed:649e	jmp	loc_837b
        	loc_8370:
01ed:64a0	mov	al, byte ptr [0x79b9]
01ed:64a3	mov	ah, 0
01ed:64a5	mov	bx, ax
01ed:64a7	mov	al, byte ptr [bx + 0x26ce]
        	loc_837b:
01ed:64ab	mov	byte ptr [bp - 1], al
01ed:64ae	cmp	byte ptr [bp - 1], 0
01ed:64b2	je	loc_838a
01ed:64b4	push	ax
01ed:64b5	call	0x6e11
01ed:64b8	inc	sp
01ed:64b9	inc	sp
        	loc_838a:
01ed:64ba	call	0x654e
01ed:64bd	mov	sp, bp
01ed:64bf	pop	bp
01ed:64c0	ret	
sub_834e ENDP
*/
void sub_834e()
{
    // coverage: 0x767e-0x76c1 method sub_834e
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_835c;
    sub_ca53();
loc_835c:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8370;
    al = memoryAGet(ds, 0x79b9);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9982);
    goto loc_837b;
loc_8370:
    al = memoryAGet(ds, 0x79b9);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9934);
loc_837b:
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_838a;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_838a:
    sub_841e();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:64c1 sub_8391()
sub_8391 PROC
01ed:64c1	push	bp
01ed:64c2	mov	bp, sp
01ed:64c4	cmp	word ptr [0x6b4c], sp
01ed:64c8	ja	loc_839d
01ed:64ca	call	0xab83
        	loc_839d:
01ed:64cd	cmp	word ptr [0x689c], 4
01ed:64d2	je	loc_83a8
01ed:64d4	mov	al, 0xe
01ed:64d6	jmp	loc_83aa
        	loc_83a8:
01ed:64d8	mov	al, 0x21
        	loc_83aa:
01ed:64da	push	ax
01ed:64db	call	0x6e11
01ed:64de	inc	sp
01ed:64df	inc	sp
01ed:64e0	pop	bp
01ed:64e1	ret	
sub_8391 ENDP
*/
void sub_8391()
{
    // coverage: 0x76c1-0x76e2 method sub_8391
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_839d;
    sub_ca53();
loc_839d:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_83a8;
    al = 0x0e;
    goto loc_83aa;
loc_83a8:
    al = 0x21;
loc_83aa:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:64e2 sub_83b2()
sub_83b2 PROC
01ed:64e2	push	bp
01ed:64e3	mov	bp, sp
01ed:64e5	cmp	word ptr [0x6b4c], sp
01ed:64e9	ja	loc_83be
01ed:64eb	call	0xab83
        	loc_83be:
01ed:64ee	call	0x6611
01ed:64f1	mov	al, byte ptr [0x856e]
01ed:64f4	add	al, 0xf8
01ed:64f6	mov	byte ptr [0x856e], al
01ed:64f9	dec	byte ptr [0x855c]
01ed:64fd	pop	bp
01ed:64fe	ret	
sub_83b2 ENDP
*/
void sub_83b2()
{
    // coverage: 0x76e2-0x76ff method sub_83b2
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_83be;
    sub_ca53();
loc_83be:
    sub_84e1();
    al = memoryAGet(ds, 0x856e);
    al += 0xf8;
    memoryASet(ds, 0x856e, al);
    memoryASet(ds, 0x855c, memoryAGet(ds, 0x855c) - 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:64ff sub_83cf()
sub_83cf PROC
01ed:64ff	push	bp
01ed:6500	mov	bp, sp
01ed:6502	cmp	word ptr [0x6b4c], sp
01ed:6506	ja	loc_83db
01ed:6508	call	0xab83
        	loc_83db:
01ed:650b	call	0x6611
01ed:650e	mov	al, byte ptr [0x856e]
01ed:6511	add	al, 8
01ed:6513	mov	byte ptr [0x856e], al
01ed:6516	inc	byte ptr [0x855c]
01ed:651a	pop	bp
01ed:651b	ret	
sub_83cf ENDP
*/
void sub_83cf()
{
    // coverage: 0x76ff-0x771c method sub_83cf
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_83db;
    sub_ca53();
loc_83db:
    sub_84e1();
    al = memoryAGet(ds, 0x856e);
    al += 0x08;
    memoryASet(ds, 0x856e, al);
    memoryASet(ds, 0x855c, memoryAGet(ds, 0x855c) + 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:651c sub_83ec()
sub_83ec PROC
01ed:651c	push	bp
01ed:651d	mov	bp, sp
01ed:651f	cmp	word ptr [0x6b4c], sp
01ed:6523	ja	loc_83f8
01ed:6525	call	0xab83
        	loc_83f8:
01ed:6528	call	0x6611
01ed:652b	dec	byte ptr [0x856e]
01ed:652f	dec	byte ptr [0x855e]
01ed:6533	pop	bp
01ed:6534	ret	
sub_83ec ENDP
*/
void sub_83ec()
{
    // coverage: 0x771c-0x7735 method sub_83ec
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_83f8;
    sub_ca53();
loc_83f8:
    sub_84e1();
    memoryASet(ds, 0x856e, memoryAGet(ds, 0x856e) - 1);
    memoryASet(ds, 0x855e, memoryAGet(ds, 0x855e) - 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6535 sub_8405()
sub_8405 PROC
01ed:6535	push	bp
01ed:6536	mov	bp, sp
01ed:6538	cmp	word ptr [0x6b4c], sp
01ed:653c	ja	loc_8411
01ed:653e	call	0xab83
        	loc_8411:
01ed:6541	call	0x6611
01ed:6544	inc	byte ptr [0x856e]
01ed:6548	inc	byte ptr [0x855e]
01ed:654c	pop	bp
01ed:654d	ret	
sub_8405 ENDP
*/
void sub_8405()
{
    // coverage: 0x7735-0x774e method sub_8405
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8411;
    sub_ca53();
loc_8411:
    sub_84e1();
    memoryASet(ds, 0x856e, memoryAGet(ds, 0x856e) + 1);
    memoryASet(ds, 0x855e, memoryAGet(ds, 0x855e) + 1);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:654e sub_841e()
sub_841e PROC
01ed:654e	push	bp
01ed:654f	mov	bp, sp
01ed:6551	cmp	word ptr [0x6b4c], sp
01ed:6555	ja	loc_842a
01ed:6557	call	0xab83
        	loc_842a:
01ed:655a	mov	al, byte ptr [0x7923]
01ed:655d	mov	ah, 0
01ed:655f	or	ax, ax
01ed:6561	jne	loc_8455
01ed:6563	test	byte ptr [0x8244], 0x10
01ed:6568	jne	loc_8441
01ed:656a	test	byte ptr [0x8244], 1
01ed:656f	je	loc_8455
        	loc_8441:
01ed:6571	mov	al, byte ptr [0x7924]
01ed:6574	mov	byte ptr [0x7922], al
01ed:6577	mov	ah, 0
01ed:6579	mov	bx, ax
01ed:657b	mov	al, byte ptr [bx + 0x3cda]
01ed:657f	push	ax
01ed:6580	call	0x695e
01ed:6583	inc	sp
01ed:6584	inc	sp
        	loc_8455:
01ed:6585	pop	bp
01ed:6586	ret	
sub_841e ENDP
*/
void sub_841e()
{
    // coverage: 0x774e-0x7787 method sub_841e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_842a;
    sub_ca53();
loc_842a:
    al = memoryAGet(ds, 0x7923);
    ah = 0x00;
    if (ax)
        goto loc_8455;
    if (memoryAGet(ds, 0x8244) & 0x10)
        goto loc_8441;
    if (!(memoryAGet(ds, 0x8244) & 0x01))
        goto loc_8455;
loc_8441:
    al = memoryAGet(ds, 0x7924);
    memoryASet(ds, 0x7922, al);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 15578);
    push(ax);
    sub_882e();
    sp++;
    sp++;
loc_8455:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6587 sub_8457()
sub_8457 PROC
01ed:6587	push	bp
01ed:6588	mov	bp, sp
01ed:658a	cmp	word ptr [0x6b4c], sp
01ed:658e	ja	loc_8463
01ed:6590	call	0xab83
        	loc_8463:
01ed:6593	mov	al, byte ptr [0xa1a7]
01ed:6596	mov	ah, 0
01ed:6598	or	ax, ax
01ed:659a	jne	loc_84a0
01ed:659c	cmp	byte ptr [0x7924], 2
01ed:65a1	jne	loc_84a0
01ed:65a3	test	byte ptr [0x8244], 2
01ed:65a8	je	loc_84a0
01ed:65aa	cmp	word ptr [0x689c], 4
01ed:65af	je	loc_8485
01ed:65b1	mov	al, 4
01ed:65b3	jmp	loc_8487
        	loc_8485:
01ed:65b5	mov	al, 9
        	loc_8487:
01ed:65b7	push	ax
01ed:65b8	call	0x6e11
01ed:65bb	inc	sp
01ed:65bc	inc	sp
01ed:65bd	mov	al, byte ptr [0x856e]
01ed:65c0	mov	byte ptr [0x856f], al
01ed:65c3	mov	byte ptr [0x79b4], 0x34
01ed:65c8	mov	al, 0x34
01ed:65ca	push	ax
01ed:65cb	call	0x69aa
01ed:65ce	inc	sp
01ed:65cf	inc	sp
        	loc_84a0:
01ed:65d0	pop	bp
01ed:65d1	ret	
sub_8457 ENDP
*/
void sub_8457()
{
    // coverage: 0x7787-0x77d2 method sub_8457
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8463;
    sub_ca53();
loc_8463:
    al = memoryAGet(ds, 0xa1a7);
    ah = 0x00;
    if (ax)
        goto loc_84a0;
    if (memoryAGet(ds, 0x7924) != 0x02)
        goto loc_84a0;
    if (!(memoryAGet(ds, 0x8244) & 0x02))
        goto loc_84a0;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8485;
    al = 0x04;
    goto loc_8487;
loc_8485:
    al = 0x09;
loc_8487:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    memoryASet(ds, 0x79b4, 0x34);
    al = 0x34;
    push(ax);
    sub_887a();
    sp++;
    sp++;
loc_84a0:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:65d2 sub_84a2()
sub_84a2 PROC
01ed:65d2	push	bp
01ed:65d3	mov	bp, sp
01ed:65d5	cmp	word ptr [0x6b4c], sp
01ed:65d9	ja	loc_84ae
01ed:65db	call	0xab83
        	loc_84ae:
01ed:65de	mov	byte ptr [0x8244], 0
01ed:65e3	pop	bp
01ed:65e4	ret	
sub_84a2 ENDP
*/
void sub_84a2()
{
    // coverage: 0x77d2-0x77e5 method sub_84a2
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_84ae;
    sub_ca53();
loc_84ae:
    memoryASet(ds, 0x8244, 0x00);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:65e5 sub_84b5()
sub_84b5 PROC
01ed:65e5	push	bp
01ed:65e6	mov	bp, sp
01ed:65e8	cmp	word ptr [0x6b4c], sp
01ed:65ec	ja	loc_84c1
01ed:65ee	call	0xab83
        	loc_84c1:
01ed:65f1	mov	al, byte ptr [0x8244]
01ed:65f4	and	al, 0x10
01ed:65f6	mov	byte ptr [0x8244], al
01ed:65f9	pop	bp
01ed:65fa	ret	
sub_84b5 ENDP
*/
void sub_84b5()
{
    // coverage: 0x77e5-0x77fb method sub_84b5
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_84c1;
    sub_ca53();
loc_84c1:
    al = memoryAGet(ds, 0x8244);
    al &= 0x10;
    memoryASet(ds, 0x8244, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:65fb sub_84cb()
sub_84cb PROC
01ed:65fb	push	bp
01ed:65fc	mov	bp, sp
01ed:65fe	cmp	word ptr [0x6b4c], sp
01ed:6602	ja	loc_84d7
01ed:6604	call	0xab83
        	loc_84d7:
01ed:6607	mov	al, byte ptr [0x8244]
01ed:660a	and	al, 0x1d
01ed:660c	mov	byte ptr [0x8244], al
01ed:660f	pop	bp
01ed:6610	ret	
sub_84cb ENDP
*/
void sub_84cb()
{
    // coverage: 0x77fb-0x7811 method sub_84cb
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_84d7;
    sub_ca53();
loc_84d7:
    al = memoryAGet(ds, 0x8244);
    al &= 0x1d;
    memoryASet(ds, 0x8244, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6611 sub_84e1()
sub_84e1 PROC
01ed:6611	push	bp
01ed:6612	mov	bp, sp
01ed:6614	cmp	word ptr [0x6b4c], sp
01ed:6618	ja	loc_84ed
01ed:661a	call	0xab83
        	loc_84ed:
01ed:661d	mov	al, byte ptr [0x8244]
01ed:6620	and	al, 0xf
01ed:6622	mov	byte ptr [0x8244], al
01ed:6625	pop	bp
01ed:6626	ret	
sub_84e1 ENDP
*/
void sub_84e1()
{
    // coverage: 0x7811-0x7827 method sub_84e1
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_84ed;
    sub_ca53();
loc_84ed:
    al = memoryAGet(ds, 0x8244);
    al &= 0x0f;
    memoryASet(ds, 0x8244, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6627 sub_84f7()
sub_84f7 PROC
01ed:6627	push	bp
01ed:6628	mov	bp, sp
01ed:662a	cmp	word ptr [0x6b4c], sp
01ed:662e	ja	loc_8503
01ed:6630	call	0xab83
        	loc_8503:
01ed:6633	mov	al, byte ptr [0x856e]
01ed:6636	push	ax
01ed:6637	call	0x6bf4
01ed:663a	inc	sp
01ed:663b	inc	sp
01ed:663c	cmp	byte ptr [0x79b8], 0
01ed:6641	je	loc_8516
01ed:6643	call	0x6c14
        	loc_8516:
01ed:6646	pop	bp
01ed:6647	ret	
sub_84f7 ENDP
*/
void sub_84f7()
{
    // coverage: 0x7827-0x7848 method sub_84f7
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8503;
    sub_ca53();
loc_8503:
    al = memoryAGet(ds, 0x856e);
    push(ax);
    sub_8ac4();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x79b8) == 0x00)
        goto loc_8516;
    sub_8ae4();
loc_8516:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6648 sub_8518()
sub_8518 PROC
01ed:6648	push	bp
01ed:6649	mov	bp, sp
01ed:664b	dec	sp
01ed:664c	dec	sp
01ed:664d	cmp	word ptr [0x6b4c], sp
01ed:6651	ja	loc_8526
01ed:6653	call	0xab83
        	loc_8526:
01ed:6656	cmp	word ptr [0x689c], 4
01ed:665b	je	loc_853a
01ed:665d	mov	al, byte ptr [0x7924]
01ed:6660	mov	ah, 0
01ed:6662	mov	bx, ax
01ed:6664	mov	al, byte ptr [bx + 0x25de]
01ed:6668	jmp	loc_8545
        	loc_853a:
01ed:666a	mov	al, byte ptr [0x7924]
01ed:666d	mov	ah, 0
01ed:666f	mov	bx, ax
01ed:6671	mov	al, byte ptr [bx + 0x25ae]
        	loc_8545:
01ed:6675	mov	byte ptr [bp - 1], al
01ed:6678	cmp	byte ptr [bp - 1], 0
01ed:667c	je	loc_8554
01ed:667e	push	ax
01ed:667f	call	0x6e11
01ed:6682	inc	sp
01ed:6683	inc	sp
        	loc_8554:
01ed:6684	mov	al, byte ptr [0x7924]
01ed:6687	mov	ah, 0
01ed:6689	mov	bx, ax
01ed:668b	mov	al, byte ptr [bx + 0x3d0a]
01ed:668f	push	ax
01ed:6690	call	0x6987
01ed:6693	inc	sp
01ed:6694	inc	sp
01ed:6695	mov	sp, bp
01ed:6697	pop	bp
01ed:6698	ret	
sub_8518 ENDP
*/
void sub_8518()
{
    // coverage: 0x7848-0x7899 method sub_8518
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8526;
    sub_ca53();
loc_8526:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_853a;
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9694);
    goto loc_8545;
loc_853a:
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 9646);
loc_8545:
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_8554;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_8554:
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 15626);
    push(ax);
    sub_8857();
    sp++;
    sp++;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6699 sub_8569()
sub_8569 PROC
01ed:6699	push	bp
01ed:669a	mov	bp, sp
01ed:669c	cmp	word ptr [0x6b4c], sp
01ed:66a0	ja	loc_8575
01ed:66a2	call	0xab83
        	loc_8575:
01ed:66a5	cmp	byte ptr [0x8552], 3
01ed:66aa	je	loc_858e
01ed:66ac	cmp	byte ptr [0x8552], 0xf
01ed:66b1	je	loc_858e
01ed:66b3	push	ds
01ed:66b4	mov	ax, 0x3c7a
01ed:66b7	push	ax
01ed:66b8	call	0x6d6a
01ed:66bb	add	sp, 4
        	loc_858e:
01ed:66be	cmp	byte ptr [0x855e], 0
01ed:66c3	je	loc_85a6
01ed:66c5	mov	al, byte ptr [0x8551]
01ed:66c8	mov	ah, 0
01ed:66ca	mov	bx, ax
01ed:66cc	mov	al, byte ptr [bx + 0x35be]
01ed:66d0	push	ax
01ed:66d1	call	0x6a89
01ed:66d4	inc	sp
01ed:66d5	inc	sp
        	loc_85a6:
01ed:66d6	pop	bp
01ed:66d7	ret	
sub_8569 ENDP
*/
void sub_8569()
{
    // coverage: 0x7899-0x78d8 method sub_8569
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8575;
    sub_ca53();
loc_8575:
    if (memoryAGet(ds, 0x8552) == 0x03)
        goto loc_858e;
    if (memoryAGet(ds, 0x8552) == 0x0f)
        goto loc_858e;
    push(ds);
    ax = 0x3c7a;
    push(ax);
    sub_8c3a();
    sp += 0x0004;
loc_858e:
    if (memoryAGet(ds, 0x855e) == 0x00)
        goto loc_85a6;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 13758);
    push(ax);
    sub_8959();
    sp++;
    sp++;
loc_85a6:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:66d8 sub_85a8()
sub_85a8 PROC
01ed:66d8	push	bp
01ed:66d9	mov	bp, sp
01ed:66db	cmp	word ptr [0x6b4c], sp
01ed:66df	ja	loc_85b4
01ed:66e1	call	0xab83
        	loc_85b4:
01ed:66e4	cmp	byte ptr [0x8552], 3
01ed:66e9	je	loc_85cd
01ed:66eb	cmp	byte ptr [0x8552], 0xf
01ed:66f0	je	loc_85cd
01ed:66f2	push	ds
01ed:66f3	mov	ax, 0x3caa
01ed:66f6	push	ax
01ed:66f7	call	0x6d6a
01ed:66fa	add	sp, 4
        	loc_85cd:
01ed:66fd	cmp	byte ptr [0x855e], 7
01ed:6702	je	loc_85e5
01ed:6704	mov	al, byte ptr [0x8551]
01ed:6707	mov	ah, 0
01ed:6709	mov	bx, ax
01ed:670b	mov	al, byte ptr [bx + 0x35de]
01ed:670f	push	ax
01ed:6710	call	0x6a89
01ed:6713	inc	sp
01ed:6714	inc	sp
        	loc_85e5:
01ed:6715	pop	bp
01ed:6716	ret	
sub_85a8 ENDP
*/
void sub_85a8()
{
    // coverage: 0x78d8-0x7917 method sub_85a8
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_85b4;
    sub_ca53();
loc_85b4:
    if (memoryAGet(ds, 0x8552) == 0x03)
        goto loc_85cd;
    if (memoryAGet(ds, 0x8552) == 0x0f)
        goto loc_85cd;
    push(ds);
    ax = 0x3caa;
    push(ax);
    sub_8c3a();
    sp += 0x0004;
loc_85cd:
    if (memoryAGet(ds, 0x855e) == 0x07)
        goto loc_85e5;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 13790);
    push(ax);
    sub_8959();
    sp++;
    sp++;
loc_85e5:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6717 sub_85e7()
sub_85e7 PROC
01ed:6717	push	bp
01ed:6718	mov	bp, sp
01ed:671a	cmp	word ptr [0x6b4c], sp
01ed:671e	ja	loc_85f3
01ed:6720	call	0xab83
        	loc_85f3:
01ed:6723	mov	al, byte ptr [0x856e]
01ed:6726	mov	byte ptr [0x856f], al
01ed:6729	call	0x6d26
01ed:672c	cmp	byte ptr [0x856c], 0x5b
01ed:6731	jne	loc_8608
01ed:6733	mov	byte ptr [0xa1b1], 0
        	loc_8608:
01ed:6738	pop	bp
01ed:6739	ret	
sub_85e7 ENDP
*/
void sub_85e7()
{
    // coverage: 0x7917-0x793a method sub_85e7
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_85f3;
    sub_ca53();
loc_85f3:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    sub_8bf6();
    if (memoryAGet(ds, 0x856c) != 0x5b)
        goto loc_8608;
    memoryASet(ds, 0xa1b1, 0x00);
loc_8608:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:673a sub_860a()
sub_860a PROC
01ed:673a	push	bp
01ed:673b	mov	bp, sp
01ed:673d	cmp	word ptr [0x6b4c], sp
01ed:6741	ja	loc_8616
01ed:6743	call	0xab83
        	loc_8616:
01ed:6746	pop	bp
01ed:6747	ret	
sub_860a ENDP
*/
void sub_860a()
{
    // coverage: 0x793a-0x7948 method sub_860a
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8616;
    sub_ca53();
loc_8616:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6748 sub_8618()
sub_8618 PROC
01ed:6748	push	bp
01ed:6749	mov	bp, sp
01ed:674b	cmp	word ptr [0x6b4c], sp
01ed:674f	ja	loc_8624
01ed:6751	call	0xab83
        	loc_8624:
01ed:6754	cmp	word ptr [0x689c], 4
01ed:6759	je	loc_862f
01ed:675b	mov	al, 8
01ed:675d	jmp	loc_8631
        	loc_862f:
01ed:675f	mov	al, 0x2f
        	loc_8631:
01ed:6761	push	ax
01ed:6762	call	0x6e11
01ed:6765	inc	sp
01ed:6766	inc	sp
01ed:6767	mov	al, 0x18
01ed:6769	push	ax
01ed:676a	call	0x6d94
01ed:676d	inc	sp
01ed:676e	inc	sp
01ed:676f	cmp	byte ptr [0x855e], 0
01ed:6774	je	loc_8657
01ed:6776	mov	al, byte ptr [0x8551]
01ed:6779	mov	ah, 0
01ed:677b	mov	bx, ax
01ed:677d	mov	al, byte ptr [bx + 0x35fe]
01ed:6781	push	ax
01ed:6782	call	0x6a89
01ed:6785	inc	sp
01ed:6786	inc	sp
        	loc_8657:
01ed:6787	pop	bp
01ed:6788	ret	
sub_8618 ENDP
*/
void sub_8618()
{
    // coverage: 0x7948-0x7989 method sub_8618
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8624;
    sub_ca53();
loc_8624:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_862f;
    al = 0x08;
    goto loc_8631;
loc_862f:
    al = 0x2f;
loc_8631:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x18;
    push(ax);
    sub_8c64();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x855e) == 0x00)
        goto loc_8657;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 13822);
    push(ax);
    sub_8959();
    sp++;
    sp++;
loc_8657:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6789 sub_8659()
sub_8659 PROC
01ed:6789	push	bp
01ed:678a	mov	bp, sp
01ed:678c	cmp	word ptr [0x6b4c], sp
01ed:6790	ja	loc_8665
01ed:6792	call	0xab83
        	loc_8665:
01ed:6795	cmp	word ptr [0x689c], 4
01ed:679a	je	loc_8670
01ed:679c	mov	al, 8
01ed:679e	jmp	loc_8672
        	loc_8670:
01ed:67a0	mov	al, 0x2f
        	loc_8672:
01ed:67a2	push	ax
01ed:67a3	call	0x6e11
01ed:67a6	inc	sp
01ed:67a7	inc	sp
01ed:67a8	mov	al, 0x19
01ed:67aa	push	ax
01ed:67ab	call	0x6d94
01ed:67ae	inc	sp
01ed:67af	inc	sp
01ed:67b0	cmp	byte ptr [0x855e], 7
01ed:67b5	je	loc_8698
01ed:67b7	mov	al, byte ptr [0x8551]
01ed:67ba	mov	ah, 0
01ed:67bc	mov	bx, ax
01ed:67be	mov	al, byte ptr [bx + 0x361e]
01ed:67c2	push	ax
01ed:67c3	call	0x6a89
01ed:67c6	inc	sp
01ed:67c7	inc	sp
        	loc_8698:
01ed:67c8	pop	bp
01ed:67c9	ret	
sub_8659 ENDP
*/
void sub_8659()
{
    // coverage: 0x7989-0x79ca method sub_8659
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8665;
    sub_ca53();
loc_8665:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8670;
    al = 0x08;
    goto loc_8672;
loc_8670:
    al = 0x2f;
loc_8672:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = 0x19;
    push(ax);
    sub_8c64();
    sp++;
    sp++;
    if (memoryAGet(ds, 0x855e) == 0x07)
        goto loc_8698;
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 13854);
    push(ax);
    sub_8959();
    sp++;
    sp++;
loc_8698:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:68fe sub_87ce()
sub_87ce PROC
01ed:68fe	push	bp
01ed:68ff	mov	bp, sp
01ed:6901	cmp	word ptr [0x6b4c], sp
01ed:6905	ja	loc_87da
01ed:6907	call	0xab83
        	loc_87da:
01ed:690a	mov	al, byte ptr [0x8551]
01ed:690d	mov	ah, 0
01ed:690f	mov	bx, ax
01ed:6911	mov	al, byte ptr [bx + 0x367e]
01ed:6915	push	ax
01ed:6916	call	0x6a89
01ed:6919	inc	sp
01ed:691a	inc	sp
01ed:691b	mov	byte ptr [0x8244], 0
01ed:6920	pop	bp
01ed:6921	ret	
sub_87ce ENDP
*/
void sub_87ce()
{
    // coverage: 0x7afe-0x7b22 method sub_87ce
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_87da;
    sub_ca53();
loc_87da:
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 13950);
    push(ax);
    sub_8959();
    sp++;
    sp++;
    memoryASet(ds, 0x8244, 0x00);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:693a sub_880a()
sub_880a PROC
01ed:693a	push	bp
01ed:693b	mov	bp, sp
01ed:693d	cmp	word ptr [0x6b4c], sp
01ed:6941	ja	loc_8816
01ed:6943	call	0xab83
        	loc_8816:
01ed:6946	mov	al, byte ptr [0x8551]
01ed:6949	mov	ah, 0
01ed:694b	mov	bx, ax
01ed:694d	mov	al, byte ptr [bx + 0x369e]
01ed:6951	push	ax
01ed:6952	call	0x6a89
01ed:6955	inc	sp
01ed:6956	inc	sp
01ed:6957	mov	byte ptr [0x8244], 0
01ed:695c	pop	bp
01ed:695d	ret	
sub_880a ENDP
*/
void sub_880a()
{
    // coverage: 0x7b3a-0x7b5e method sub_880a
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8816;
    sub_ca53();
loc_8816:
    al = memoryAGet(ds, 0x8551);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 13982);
    push(ax);
    sub_8959();
    sp++;
    sp++;
    memoryASet(ds, 0x8244, 0x00);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:695e sub_882e()
sub_882e PROC
01ed:695e	push	bp
01ed:695f	mov	bp, sp
01ed:6961	cmp	word ptr [0x6b4c], sp
01ed:6965	ja	loc_883a
01ed:6967	call	0xab83
        	loc_883a:
01ed:696a	mov	al, byte ptr [0x856e]
01ed:696d	mov	byte ptr [0x856f], al
01ed:6970	cmp	byte ptr [bp + 4], 0
01ed:6974	je	loc_8855
01ed:6976	mov	al, byte ptr [bp + 4]
01ed:6979	mov	byte ptr [0xa1a7], al
01ed:697c	mov	al, byte ptr [bp + 4]
01ed:697f	push	ax
01ed:6980	call	0x69aa
01ed:6983	inc	sp
01ed:6984	inc	sp
        	loc_8855:
01ed:6985	pop	bp
01ed:6986	ret	
sub_882e ENDP
*/
void sub_882e()
{
    // coverage: 0x7b5e-0x7b87 method sub_882e
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_883a;
    sub_ca53();
loc_883a:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    if (memoryAGet(ss, bp + 4) == 0x00)
        goto loc_8855;
    al = memoryAGet(ss, bp + 4);
    memoryASet(ds, 0xa1a7, al);
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_887a();
    sp++;
    sp++;
loc_8855:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6987 sub_8857()
sub_8857 PROC
01ed:6987	push	bp
01ed:6988	mov	bp, sp
01ed:698a	cmp	word ptr [0x6b4c], sp
01ed:698e	ja	loc_8863
01ed:6990	call	0xab83
        	loc_8863:
01ed:6993	mov	al, byte ptr [0x856e]
01ed:6996	mov	byte ptr [0x856f], al
01ed:6999	cmp	byte ptr [bp + 4], 0
01ed:699d	je	loc_8878
01ed:699f	mov	al, byte ptr [bp + 4]
01ed:69a2	push	ax
01ed:69a3	call	0x69aa
01ed:69a6	inc	sp
01ed:69a7	inc	sp
        	loc_8878:
01ed:69a8	pop	bp
01ed:69a9	ret	
sub_8857 ENDP
*/
void sub_8857()
{
    // coverage: 0x7b87-0x7baa method sub_8857
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8863;
    sub_ca53();
loc_8863:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    if (memoryAGet(ss, bp + 4) == 0x00)
        goto loc_8878;
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_887a();
    sp++;
    sp++;
loc_8878:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:69aa sub_887a()
sub_887a PROC
01ed:69aa	push	bp
01ed:69ab	mov	bp, sp
01ed:69ad	sub	sp, 8
01ed:69b0	push	si
01ed:69b1	cmp	word ptr [0x6b4c], sp
01ed:69b5	ja	loc_888a
01ed:69b7	call	0xab83
        	loc_888a:
01ed:69ba	mov	al, byte ptr [bp + 4]
01ed:69bd	mov	ah, 0
01ed:69bf	shl	ax, 1
01ed:69c1	shl	ax, 1
01ed:69c3	mov	bx, ax
01ed:69c5	mov	ax, word ptr [bx + 0x2ee0]
01ed:69c9	mov	dx, word ptr [bx + 0x2ede]
01ed:69cd	mov	word ptr [bp - 4], dx
01ed:69d0	mov	word ptr [bp - 2], ax
01ed:69d3	mov	cl, 0
        	loc_88a5:
01ed:69d5	mov	al, cl
01ed:69d7	mov	ah, 0
01ed:69d9	shl	ax, 1
01ed:69db	shl	ax, 1
01ed:69dd	mov	bx, ax
01ed:69df	mov	ax, word ptr [bx + 0x4c72]
01ed:69e3	mov	dx, word ptr [bx + 0x4c70]
01ed:69e7	mov	word ptr [bp - 8], dx
01ed:69ea	mov	word ptr [bp - 6], ax
01ed:69ed	les	bx, ptr [bp - 8]
01ed:69f0	mov	al, byte ptr es:[bx]
01ed:69f3	mov	byte ptr [bp + 4], al
01ed:69f6	inc	cl
01ed:69f8	mov	ah, 0
01ed:69fa	or	ax, ax
01ed:69fc	je	loc_88a5
01ed:69fe	cmp	byte ptr [bp + 4], 0xff
01ed:6a02	jne	loc_8910
01ed:6a04	mov	cl, 0
        	loc_88d6:
01ed:6a06	mov	al, cl
01ed:6a08	mov	ah, 0
01ed:6a0a	shl	ax, 1
01ed:6a0c	shl	ax, 1
01ed:6a0e	mov	bx, ax
01ed:6a10	mov	ax, word ptr [bx + 0x4c72]
01ed:6a14	mov	dx, word ptr [bx + 0x4c70]
01ed:6a18	mov	word ptr [bp - 8], dx
01ed:6a1b	mov	word ptr [bp - 6], ax
01ed:6a1e	les	bx, ptr [bp - 8]
01ed:6a21	mov	al, byte ptr es:[bx]
01ed:6a24	mov	byte ptr [bp + 4], al
01ed:6a27	inc	cl
01ed:6a29	cmp	byte ptr [bp + 4], 0
01ed:6a2d	je	loc_8905
01ed:6a2f	cmp	byte ptr [bp + 4], 0xff
01ed:6a33	jne	loc_88d6
        	loc_8905:
01ed:6a35	mov	al, byte ptr [bp + 4]
01ed:6a38	mov	ah, 0
01ed:6a3a	or	ax, ax
01ed:6a3c	jne	loc_8954
01ed:6a3e	jmp	loc_891d
        	loc_8910:
01ed:6a40	les	bx, ptr [bp - 8]
01ed:6a43	mov	al, byte ptr es:[bx + 1]
01ed:6a47	cmp	al, byte ptr [0x856f]
01ed:6a4b	jne	loc_88a5
        	loc_891d:
01ed:6a4d	les	bx, ptr [bp - 8]
01ed:6a50	mov	al, byte ptr [0x856f]
01ed:6a53	mov	byte ptr es:[bx + 1], al
01ed:6a57	mov	ah, 0
01ed:6a59	les	bx, ptr [0xa0d8]
01ed:6a5d	add	bx, ax
01ed:6a5f	push	es
01ed:6a60	les	si, ptr [bp - 4]
01ed:6a63	mov	al, byte ptr es:[si]
01ed:6a66	pop	es
01ed:6a67	mov	byte ptr es:[bx], al
01ed:6a6a	les	bx, ptr [bp - 4]
01ed:6a6d	mov	ax, word ptr es:[bx + 4]
01ed:6a71	mov	dx, word ptr es:[bx + 2]
01ed:6a75	les	bx, ptr [bp - 8]
01ed:6a78	mov	word ptr es:[bx + 2], dx
01ed:6a7c	mov	word ptr es:[bx + 4], ax
01ed:6a80	mov	byte ptr es:[bx], 1
        	loc_8954:
01ed:6a84	pop	si
01ed:6a85	mov	sp, bp
01ed:6a87	pop	bp
01ed:6a88	ret	
sub_887a ENDP
*/
void sub_887a()
{
    // coverage: 0x7baa-0x7c89 method sub_887a
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_888a;
    sub_ca53();
loc_888a:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 12000);
    dx = memoryAGet16(ds, bx + 11998);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    cl = 0x00;
loc_88a5:
    al = cl;
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19570);
    dx = memoryAGet16(ds, bx + 19568);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp + 4, al);
    cl++;
    ah = 0x00;
    if (!ax)
        goto loc_88a5;
    if (memoryAGet(ss, bp + 4) != 0xff)
        goto loc_8910;
    cl = 0x00;
loc_88d6:
    al = cl;
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19570);
    dx = memoryAGet16(ds, bx + 19568);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp + 4, al);
    cl++;
    if (memoryAGet(ss, bp + 4) == 0x00)
        goto loc_8905;
    if (memoryAGet(ss, bp + 4) != 0xff)
        goto loc_88d6;
loc_8905:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    if (ax)
        goto loc_8954;
    goto loc_891d;
loc_8910:
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx + 1);
    if (al != memoryAGet(ds, 0x856f))
        goto loc_88a5;
loc_891d:
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(ds, 0x856f);
    memoryASet(es, bx + 1, al);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    push(es);
    si = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    al = memoryAGet(es, si);
    es = pop();
    memoryASet(es, bx, al);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    ax = memoryAGet16(es, bx + 4);
    dx = memoryAGet16(es, bx + 2);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet(es, bx, 0x01);
loc_8954:
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6a89 sub_8959()
sub_8959 PROC
01ed:6a89	push	bp
01ed:6a8a	mov	bp, sp
01ed:6a8c	sub	sp, 0xa
01ed:6a8f	push	si
01ed:6a90	cmp	word ptr [0x6b4c], sp
01ed:6a94	ja	loc_8969
01ed:6a96	call	0xab83
        	loc_8969:
01ed:6a99	mov	al, byte ptr [bp + 4]
01ed:6a9c	mov	byte ptr [0x8566], al
01ed:6a9f	or	al, al
01ed:6aa1	jne	loc_8976
01ed:6aa3	jmp	loc_8a80
        	loc_8976:
01ed:6aa6	cmp	word ptr [0x689c], 4
01ed:6aab	je	loc_898a
01ed:6aad	mov	al, byte ptr [bp + 4]
01ed:6ab0	mov	ah, 0
01ed:6ab2	mov	bx, ax
01ed:6ab4	mov	al, byte ptr [bx + 0x274e]
01ed:6ab8	jmp	loc_8995
        	loc_898a:
01ed:6aba	mov	al, byte ptr [bp + 4]
01ed:6abd	mov	ah, 0
01ed:6abf	mov	bx, ax
01ed:6ac1	mov	al, byte ptr [bx + 0x272e]
        	loc_8995:
01ed:6ac5	mov	byte ptr [bp - 0xa], al
01ed:6ac8	cmp	byte ptr [bp - 0xa], 0
01ed:6acc	je	loc_89a4
01ed:6ace	push	ax
01ed:6acf	call	0x6e11
01ed:6ad2	inc	sp
01ed:6ad3	inc	sp
        	loc_89a4:
01ed:6ad4	mov	al, byte ptr [bp + 4]
01ed:6ad7	mov	ah, 0
01ed:6ad9	shl	ax, 1
01ed:6adb	shl	ax, 1
01ed:6add	mov	bx, ax
01ed:6adf	mov	ax, word ptr [bx + 0x3258]
01ed:6ae3	mov	dx, word ptr [bx + 0x3256]
01ed:6ae7	mov	word ptr [bp - 4], dx
01ed:6aea	mov	word ptr [bp - 2], ax
01ed:6aed	mov	byte ptr [bp - 9], 0
        	loc_89c1:
01ed:6af1	mov	al, byte ptr [bp - 9]
01ed:6af4	mov	ah, 0
01ed:6af6	shl	ax, 1
01ed:6af8	shl	ax, 1
01ed:6afa	mov	bx, ax
01ed:6afc	mov	ax, word ptr [bx + 0x4cbe]
01ed:6b00	mov	dx, word ptr [bx + 0x4cbc]
01ed:6b04	mov	word ptr [bp - 8], dx
01ed:6b07	mov	word ptr [bp - 6], ax
01ed:6b0a	les	bx, ptr [bp - 8]
01ed:6b0d	mov	al, byte ptr es:[bx]
01ed:6b10	mov	byte ptr [bp + 4], al
01ed:6b13	inc	byte ptr [bp - 9]
01ed:6b16	mov	ah, 0
01ed:6b18	or	ax, ax
01ed:6b1a	je	loc_89c1
01ed:6b1c	cmp	byte ptr [bp + 4], 0xff
01ed:6b20	jne	loc_8a38
01ed:6b22	mov	byte ptr [bp - 9], 0
        	loc_89f6:
01ed:6b26	mov	al, byte ptr [bp - 9]
01ed:6b29	mov	ah, 0
01ed:6b2b	shl	ax, 1
01ed:6b2d	shl	ax, 1
01ed:6b2f	mov	bx, ax
01ed:6b31	mov	ax, word ptr [bx + 0x4cbe]
01ed:6b35	mov	dx, word ptr [bx + 0x4cbc]
01ed:6b39	mov	word ptr [bp - 8], dx
01ed:6b3c	mov	word ptr [bp - 6], ax
01ed:6b3f	les	bx, ptr [bp - 8]
01ed:6b42	mov	al, byte ptr es:[bx]
01ed:6b45	mov	byte ptr [bp + 4], al
01ed:6b48	inc	byte ptr [bp - 9]
01ed:6b4b	cmp	byte ptr [bp + 4], 0
01ed:6b4f	je	loc_8a27
01ed:6b51	cmp	byte ptr [bp + 4], 0xff
01ed:6b55	jne	loc_89f6
        	loc_8a27:
01ed:6b57	mov	al, byte ptr [bp + 4]
01ed:6b5a	mov	ah, 0
01ed:6b5c	or	ax, ax
01ed:6b5e	je	loc_8a48
01ed:6b60	cmp	byte ptr [bp + 4], 0xff
01ed:6b64	jne	loc_8a80
01ed:6b66	jmp	loc_8a80
        	loc_8a38:
01ed:6b68	les	bx, ptr [bp - 8]
01ed:6b6b	mov	al, byte ptr es:[bx + 1]
01ed:6b6f	cmp	al, byte ptr [0x8570]
01ed:6b73	je	loc_8a48
01ed:6b75	jmp	loc_89c1
        	loc_8a48:
01ed:6b78	les	bx, ptr [bp - 8]
01ed:6b7b	mov	al, byte ptr [0x8570]
01ed:6b7e	mov	byte ptr es:[bx + 1], al
01ed:6b82	mov	ah, 0
01ed:6b84	les	bx, ptr [0xa0d8]
01ed:6b88	add	bx, ax
01ed:6b8a	push	es
01ed:6b8b	les	si, ptr [bp - 4]
01ed:6b8e	mov	al, byte ptr es:[si]
01ed:6b91	pop	es
01ed:6b92	mov	byte ptr es:[bx + 0x30], al
01ed:6b96	les	bx, ptr [bp - 4]
01ed:6b99	mov	ax, word ptr es:[bx + 4]
01ed:6b9d	mov	dx, word ptr es:[bx + 2]
01ed:6ba1	les	bx, ptr [bp - 8]
01ed:6ba4	mov	word ptr es:[bx + 2], dx
01ed:6ba8	mov	word ptr es:[bx + 4], ax
01ed:6bac	mov	byte ptr es:[bx], 1
        	loc_8a80:
01ed:6bb0	pop	si
01ed:6bb1	mov	sp, bp
01ed:6bb3	pop	bp
01ed:6bb4	ret	
sub_8959 ENDP
*/
void sub_8959()
{
    // coverage: 0x7c89-0x7db5 method sub_8959
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000a;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8969;
    sub_ca53();
loc_8969:
    al = memoryAGet(ss, bp + 4);
    memoryASet(ds, 0x8566, al);
    if (al)
        goto loc_8976;
    goto loc_8a80;
loc_8976:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_898a;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 10062);
    goto loc_8995;
loc_898a:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 10030);
loc_8995:
    memoryASet(ss, bp - 10, al);
    if (memoryAGet(ss, bp - 10) == 0x00)
        goto loc_89a4;
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_89a4:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 12888);
    dx = memoryAGet16(ds, bx + 12886);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    memoryASet(ss, bp - 9, 0x00);
loc_89c1:
    al = memoryAGet(ss, bp - 9);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19646);
    dx = memoryAGet16(ds, bx + 19644);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp + 4, al);
    memoryASet(ss, bp - 9, memoryAGet(ss, bp - 9) + 1);
    ah = 0x00;
    if (!ax)
        goto loc_89c1;
    if (memoryAGet(ss, bp + 4) != 0xff)
        goto loc_8a38;
    memoryASet(ss, bp - 9, 0x00);
loc_89f6:
    al = memoryAGet(ss, bp - 9);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 19646);
    dx = memoryAGet16(ds, bx + 19644);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp + 4, al);
    memoryASet(ss, bp - 9, memoryAGet(ss, bp - 9) + 1);
    if (memoryAGet(ss, bp + 4) == 0x00)
        goto loc_8a27;
    if (memoryAGet(ss, bp + 4) != 0xff)
        goto loc_89f6;
loc_8a27:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    if (!ax)
        goto loc_8a48;
    if (memoryAGet(ss, bp + 4) != 0xff)
        goto loc_8a80;
    goto loc_8a80;
loc_8a38:
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(es, bx + 1);
    if (al == memoryAGet(ds, 0x8570))
        goto loc_8a48;
    goto loc_89c1;
loc_8a48:
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    al = memoryAGet(ds, 0x8570);
    memoryASet(es, bx + 1, al);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    push(es);
    si = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    al = memoryAGet(es, si);
    es = pop();
    memoryASet(es, bx + 48, al);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    ax = memoryAGet16(es, bx + 4);
    dx = memoryAGet16(es, bx + 2);
    bx = memoryAGet16(ss, bp - 8);
    es = memoryAGet16(ss, bp - 8 + 2);
    memoryASet16(es, bx + 2, dx);
    memoryASet16(es, bx + 4, ax);
    memoryASet(es, bx, 0x01);
loc_8a80:
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6bb5 sub_8a85()
sub_8a85 PROC
01ed:6bb5	push	bp
01ed:6bb6	mov	bp, sp
01ed:6bb8	cmp	word ptr [0x6b4c], sp
01ed:6bbc	ja	loc_8a91
01ed:6bbe	call	0xab83
        	loc_8a91:
01ed:6bc1	mov	al, byte ptr [bp + 4]
01ed:6bc4	mov	ah, 0
01ed:6bc6	les	bx, ptr [0xa0d8]
01ed:6bca	add	bx, ax
01ed:6bcc	mov	al, byte ptr es:[bx]
01ed:6bcf	mov	byte ptr [0x7921], al
01ed:6bd2	pop	bp
01ed:6bd3	ret	
sub_8a85 ENDP
*/
void sub_8a85()
{
    // coverage: 0x7db5-0x7dd4 method sub_8a85
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8a91;
    sub_ca53();
loc_8a91:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    memoryASet(ds, 0x7921, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6bd4 sub_8aa4()
sub_8aa4 PROC
01ed:6bd4	push	bp
01ed:6bd5	mov	bp, sp
01ed:6bd7	cmp	word ptr [0x6b4c], sp
01ed:6bdb	ja	loc_8ab0
01ed:6bdd	call	0xab83
        	loc_8ab0:
01ed:6be0	mov	al, byte ptr [bp + 4]
01ed:6be3	mov	ah, 0
01ed:6be5	les	bx, ptr [0xa0d8]
01ed:6be9	add	bx, ax
01ed:6beb	mov	al, byte ptr es:[bx + 0x30]
01ed:6bef	mov	byte ptr [0x8551], al
01ed:6bf2	pop	bp
01ed:6bf3	ret	
sub_8aa4 ENDP
*/
void sub_8aa4()
{
    // coverage: 0x7dd4-0x7df4 method sub_8aa4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8ab0;
    sub_ca53();
loc_8ab0:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 48);
    memoryASet(ds, 0x8551, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6bf4 sub_8ac4()
sub_8ac4 PROC
01ed:6bf4	push	bp
01ed:6bf5	mov	bp, sp
01ed:6bf7	cmp	word ptr [0x6b4c], sp
01ed:6bfb	ja	loc_8ad0
01ed:6bfd	call	0xab83
        	loc_8ad0:
01ed:6c00	mov	al, byte ptr [bp + 4]
01ed:6c03	mov	ah, 0
01ed:6c05	les	bx, ptr [0xa0d8]
01ed:6c09	add	bx, ax
01ed:6c0b	mov	al, byte ptr es:[bx + 0x60]
01ed:6c0f	mov	byte ptr [0x79b8], al
01ed:6c12	pop	bp
01ed:6c13	ret	
sub_8ac4 ENDP
*/
void sub_8ac4()
{
    // coverage: 0x7df4-0x7e14 method sub_8ac4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8ad0;
    sub_ca53();
loc_8ad0:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 96);
    memoryASet(ds, 0x79b8, al);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6c14 sub_8ae4()
sub_8ae4 PROC
01ed:6c14	push	bp
01ed:6c15	mov	bp, sp
01ed:6c17	cmp	word ptr [0x6b4c], sp
01ed:6c1b	ja	loc_8af0
01ed:6c1d	call	0xab83
        	loc_8af0:
01ed:6c20	mov	byte ptr [0x2810], 0xf
01ed:6c25	call	0x6c95
01ed:6c28	mov	al, byte ptr [0x856e]
01ed:6c2b	mov	ah, 0
01ed:6c2d	les	bx, ptr [0xa0d8]
01ed:6c31	add	bx, ax
01ed:6c33	mov	byte ptr es:[bx + 0x60], 0
01ed:6c38	cmp	byte ptr [0x79b8], 1
01ed:6c3d	je	loc_8b63
01ed:6c3f	cmp	byte ptr [0x79b8], 0x23
01ed:6c44	je	loc_8b63
01ed:6c46	dec	byte ptr [0xa0cf]
01ed:6c4a	mov	al, byte ptr [0xa0cf]
01ed:6c4d	mov	ah, 0
01ed:6c4f	or	ax, ax
01ed:6c51	jne	loc_8b50
01ed:6c53	cmp	word ptr [0x689c], 4
01ed:6c58	je	loc_8b2e
01ed:6c5a	mov	al, 0xb
01ed:6c5c	jmp	loc_8b30
        	loc_8b2e:
01ed:6c5e	mov	al, 0x2c
        	loc_8b30:
01ed:6c60	push	ax
01ed:6c61	call	0x6e11
01ed:6c64	inc	sp
01ed:6c65	inc	sp
01ed:6c66	mov	al, byte ptr [0x8572]
01ed:6c69	mov	byte ptr [0x856f], al
01ed:6c6c	mov	al, 0x59
01ed:6c6e	push	ax
01ed:6c6f	call	0x69aa
01ed:6c72	inc	sp
01ed:6c73	inc	sp
01ed:6c74	mov	byte ptr [0xa1b1], 1
01ed:6c79	mov	byte ptr [0x8550], 0xf2
01ed:6c7e	jmp	loc_8b63
        	loc_8b50:
01ed:6c80	cmp	word ptr [0x689c], 4
01ed:6c85	je	loc_8b5b
01ed:6c87	mov	al, 0xe
01ed:6c89	jmp	loc_8b5d
        	loc_8b5b:
01ed:6c8b	mov	al, 0x21
        	loc_8b5d:
01ed:6c8d	push	ax
01ed:6c8e	call	0x6e11
01ed:6c91	inc	sp
01ed:6c92	inc	sp
        	loc_8b63:
01ed:6c93	pop	bp
01ed:6c94	ret	
sub_8ae4 ENDP
*/
void sub_8ae4()
{
    // coverage: 0x7e14-0x7e95 method sub_8ae4
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8af0;
    sub_ca53();
loc_8af0:
    memoryASet(ds, 0x2810, 0x0f);
    sub_8b65();
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    bx = memoryAGet16(ds, 0xa0d8);
    es = memoryAGet16(ds, 0xa0d8 + 2);
    bx += ax;
    memoryASet(es, bx + 96, 0x00);
    if (memoryAGet(ds, 0x79b8) == 0x01)
        goto loc_8b63;
    if (memoryAGet(ds, 0x79b8) == 0x23)
        goto loc_8b63;
    memoryASet(ds, 0xa0cf, memoryAGet(ds, 0xa0cf) - 1);
    al = memoryAGet(ds, 0xa0cf);
    ah = 0x00;
    if (ax)
        goto loc_8b50;
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8b2e;
    al = 0x0b;
    goto loc_8b30;
loc_8b2e:
    al = 0x2c;
loc_8b30:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x8572);
    memoryASet(ds, 0x856f, al);
    al = 0x59;
    push(ax);
    sub_887a();
    sp++;
    sp++;
    memoryASet(ds, 0xa1b1, 0x01);
    memoryASet(ds, 0x8550, 0xf2);
    goto loc_8b63;
loc_8b50:
    if (memoryAGet16(ds, 0x689c) == 0x0004)
        goto loc_8b5b;
    al = 0x0e;
    goto loc_8b5d;
loc_8b5b:
    al = 0x21;
loc_8b5d:
    push(ax);
    sub_8ce1();
    sp++;
    sp++;
loc_8b63:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6c95 sub_8b65()
sub_8b65 PROC
01ed:6c95	push	bp
01ed:6c96	mov	bp, sp
01ed:6c98	cmp	word ptr [0x6b4c], sp
01ed:6c9c	ja	loc_8b71
01ed:6c9e	call	0xab83
        	loc_8b71:
01ed:6ca1	mov	byte ptr [0xa1a8], 2
01ed:6ca6	mov	al, byte ptr [0x856e]
01ed:6ca9	mov	ah, 0
01ed:6cab	shl	ax, 1
01ed:6cad	shl	ax, 1
01ed:6caf	mov	bx, ax
01ed:6cb1	mov	ax, word ptr [bx + 0x274]
01ed:6cb5	mov	cl, 4
01ed:6cb7	sar	ax, cl
01ed:6cb9	mov	word ptr [0x9b9a], ax
01ed:6cbc	mov	al, byte ptr [0x856e]
01ed:6cbf	mov	ah, 0
01ed:6cc1	shl	ax, 1
01ed:6cc3	shl	ax, 1
01ed:6cc5	mov	bx, ax
01ed:6cc7	mov	ax, word ptr [bx + 0x276]
01ed:6ccb	sar	ax, 1
01ed:6ccd	sar	ax, 1
01ed:6ccf	sar	ax, 1
01ed:6cd1	mov	word ptr [0x9ba2], ax
01ed:6cd4	test	byte ptr [0x856e], 1
01ed:6cd9	je	loc_8bb0
01ed:6cdb	mov	ax, 1
01ed:6cde	jmp	loc_8bb3
        	loc_8bb0:
01ed:6ce0	mov	ax, 2
        	loc_8bb3:
01ed:6ce3	les	bx, ptr [0x8e4]
01ed:6ce7	mov	word ptr es:[bx + 0x1e], ax
01ed:6ceb	add	word ptr [0xa0d4], 0xfa
01ed:6cf1	adc	word ptr [0xa0d6], 0
01ed:6cf6	cmp	byte ptr [0x79b8], 0x23
01ed:6cfb	jne	loc_8bd3
01ed:6cfd	inc	byte ptr [0x791a]
01ed:6d01	jmp	loc_8bf4
        	loc_8bd3:
01ed:6d03	cmp	byte ptr [0x79b8], 0x2f
01ed:6d08	jne	loc_8be2
01ed:6d0a	add	word ptr [0xa0d4], 0x2616
01ed:6d10	jmp	loc_8bef
        	loc_8be2:
01ed:6d12	cmp	byte ptr [0x79b8], 0x30
01ed:6d17	jne	loc_8bf4
01ed:6d19	add	word ptr [0xa0d4], 0xc256
        	loc_8bef:
01ed:6d1f	adc	word ptr [0xa0d6], 0
        	loc_8bf4:
01ed:6d24	pop	bp
01ed:6d25	ret	
sub_8b65 ENDP
*/
void sub_8b65()
{
    // coverage: 0x7e95-0x7f26 method sub_8b65
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8b71;
    sub_ca53();
loc_8b71:
    memoryASet(ds, 0xa1a8, 0x02);
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 628);
    cl = 0x04;
    ax = sar(ax, cl);
    memoryASet16(ds, 0x9b9a, ax);
    al = memoryAGet(ds, 0x856e);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax = memoryAGet16(ds, bx + 630);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet16(ds, 0x9ba2, ax);
    if (!(memoryAGet(ds, 0x856e) & 0x01))
        goto loc_8bb0;
    ax = 0x0001;
    goto loc_8bb3;
loc_8bb0:
    ax = 0x0002;
loc_8bb3:
    bx = memoryAGet16(ds, 0x08e4);
    es = memoryAGet16(ds, 0x08e4 + 2);
    memoryASet16(es, bx + 30, ax);
    flags.carry = (memoryAGet16(ds, 0xa0d4) + 0x00fa) >= 0x10000;
    memoryASet16(ds, 0xa0d4, memoryAGet16(ds, 0xa0d4) + 0x00fa);
    memoryASet16(ds, 0xa0d6, memoryAGet16(ds, 0xa0d6) + flags.carry);
    if (memoryAGet(ds, 0x79b8) != 0x23)
        goto loc_8bd3;
    memoryASet(ds, 0x791a, memoryAGet(ds, 0x791a) + 1);
    goto loc_8bf4;
loc_8bd3:
    if (memoryAGet(ds, 0x79b8) != 0x2f)
        goto loc_8be2;
    memoryASet16(ds, 0xa0d4, memoryAGet16(ds, 0xa0d4) + 0x2616);
    goto loc_8bef;
loc_8be2:
    if (memoryAGet(ds, 0x79b8) != 0x30)
        goto loc_8bf4;
    memoryASet16(ds, 0xa0d4, memoryAGet16(ds, 0xa0d4) + 0xc256);
loc_8bef:
    stop(/*8*/); // inject carry failed
    memoryASet16(ds, 0xa0d6, memoryAGet16(ds, 0xa0d6) + flags.carry);
loc_8bf4:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6d26 sub_8bf6()
sub_8bf6 PROC
01ed:6d26	push	bp
01ed:6d27	mov	bp, sp
01ed:6d29	dec	sp
01ed:6d2a	dec	sp
01ed:6d2b	cmp	word ptr [0x6b4c], sp
01ed:6d2f	ja	loc_8c04
01ed:6d31	call	0xab83
        	loc_8c04:
01ed:6d34	mov	al, byte ptr [0x856e]
01ed:6d37	push	ax
01ed:6d38	call	0x6bb5
01ed:6d3b	inc	sp
01ed:6d3c	inc	sp
01ed:6d3d	mov	al, byte ptr [0x7921]
01ed:6d40	mov	ah, 0
01ed:6d42	mov	bx, ax
01ed:6d44	mov	al, byte ptr [bx + 0x4396]
01ed:6d48	mov	byte ptr [bp - 1], al
01ed:6d4b	cmp	byte ptr [bp - 1], 0
01ed:6d4f	je	loc_8c36
01ed:6d51	mov	al, byte ptr [0x7924]
01ed:6d54	mov	byte ptr [0x7922], al
01ed:6d57	mov	al, byte ptr [bp - 1]
01ed:6d5a	mov	byte ptr [0x7923], al
01ed:6d5d	mov	al, byte ptr [bp - 1]
01ed:6d60	push	ax
01ed:6d61	call	0x6d94
01ed:6d64	inc	sp
01ed:6d65	inc	sp
        	loc_8c36:
01ed:6d66	mov	sp, bp
01ed:6d68	pop	bp
01ed:6d69	ret	
sub_8bf6 ENDP
*/
void sub_8bf6()
{
    // coverage: 0x7f26-0x7f6a method sub_8bf6
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8c04;
    sub_ca53();
loc_8c04:
    al = memoryAGet(ds, 0x856e);
    push(ax);
    sub_8a85();
    sp++;
    sp++;
    al = memoryAGet(ds, 0x7921);
    ah = 0x00;
    bx = ax;
    al = memoryAGet(ds, bx + 17302);
    memoryASet(ss, bp - 1, al);
    if (memoryAGet(ss, bp - 1) == 0x00)
        goto loc_8c36;
    al = memoryAGet(ds, 0x7924);
    memoryASet(ds, 0x7922, al);
    al = memoryAGet(ss, bp - 1);
    memoryASet(ds, 0x7923, al);
    al = memoryAGet(ss, bp - 1);
    push(ax);
    sub_8c64();
    sp++;
    sp++;
loc_8c36:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6d6a sub_8c3a()
sub_8c3a PROC
01ed:6d6a	push	bp
01ed:6d6b	mov	bp, sp
01ed:6d6d	cmp	word ptr [0x6b4c], sp
01ed:6d71	ja	loc_8c46
01ed:6d73	call	0xab83
        	loc_8c46:
01ed:6d76	mov	al, byte ptr [0x8242]
01ed:6d79	mov	ah, 0
01ed:6d7b	or	ax, ax
01ed:6d7d	jne	loc_8c62
01ed:6d7f	mov	al, byte ptr [0x7924]
01ed:6d82	mov	ah, 0
01ed:6d84	les	bx, ptr [bp + 4]
01ed:6d87	add	bx, ax
01ed:6d89	mov	al, byte ptr es:[bx]
01ed:6d8c	push	ax
01ed:6d8d	call	0x6987
01ed:6d90	inc	sp
01ed:6d91	inc	sp
        	loc_8c62:
01ed:6d92	pop	bp
01ed:6d93	ret	
sub_8c3a ENDP
*/
void sub_8c3a()
{
    // coverage: 0x7f6a-0x7f94 method sub_8c3a
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8c46;
    sub_ca53();
loc_8c46:
    al = memoryAGet(ds, 0x8242);
    ah = 0x00;
    if (ax)
        goto loc_8c62;
    al = memoryAGet(ds, 0x7924);
    ah = 0x00;
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    bx += ax;
    al = memoryAGet(es, bx);
    push(ax);
    sub_8857();
    sp++;
    sp++;
loc_8c62:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6d94 sub_8c64()
sub_8c64 PROC
01ed:6d94	push	bp
01ed:6d95	mov	bp, sp
01ed:6d97	cmp	word ptr [0x6b4c], sp
01ed:6d9b	ja	loc_8c70
01ed:6d9d	call	0xab83
        	loc_8c70:
01ed:6da0	mov	al, byte ptr [0x856e]
01ed:6da3	mov	byte ptr [0x856f], al
01ed:6da6	mov	al, byte ptr [bp + 4]
01ed:6da9	push	ax
01ed:6daa	call	0x69aa
01ed:6dad	inc	sp
01ed:6dae	inc	sp
01ed:6daf	pop	bp
01ed:6db0	ret	
sub_8c64 ENDP
*/
void sub_8c64()
{
    // coverage: 0x7f94-0x7fb1 method sub_8c64
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8c70;
    sub_ca53();
loc_8c70:
    al = memoryAGet(ds, 0x856e);
    memoryASet(ds, 0x856f, al);
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_887a();
    sp++;
    sp++;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6de3 sub_8cb3()
sub_8cb3 PROC
01ed:6de3	push	bp
01ed:6de4	mov	bp, sp
01ed:6de6	push	si
01ed:6de7	cmp	word ptr [0x6b4c], sp
01ed:6deb	ja	loc_8cc0
01ed:6ded	call	0xab83
        	loc_8cc0:
01ed:6df0	cmp	word ptr [0x689c], 0x8000
01ed:6df6	je	loc_8cde
01ed:6df8	call	0x88e5
01ed:6dfb	mov	si, ax
01ed:6dfd	mov	ax, word ptr [0x689c]
01ed:6e00	and	ax, si
01ed:6e02	mov	word ptr [0x689c], ax
01ed:6e05	push	word ptr [0x689c]
01ed:6e09	call	0x891e
01ed:6e0c	inc	sp
01ed:6e0d	inc	sp
        	loc_8cde:
01ed:6e0e	pop	si
01ed:6e0f	pop	bp
01ed:6e10	ret	
sub_8cb3 ENDP
*/
void sub_8cb3()
{
    // coverage: 0x7fe3-0x8011 method sub_8cb3
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8cc0;
    sub_ca53();
loc_8cc0:
    if (memoryAGet16(ds, 0x689c) == 0x8000)
        goto loc_8cde;
    sub_a7b5();
    si = ax;
    ax = memoryAGet16(ds, 0x689c);
    ax &= si;
    memoryASet16(ds, 0x689c, ax);
    push(memoryAGet16(ds, 0x689c));
    sub_a7ee();
    sp++;
    sp++;
loc_8cde:
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6e11 sub_8ce1()
sub_8ce1 PROC
01ed:6e11	push	bp
01ed:6e12	mov	bp, sp
01ed:6e14	cmp	word ptr [0x6b4c], sp
01ed:6e18	ja	loc_8ced
01ed:6e1a	call	0xab83
        	loc_8ced:
01ed:6e1d	cmp	word ptr [0x689c], 0x8000
01ed:6e23	je	loc_8cfe
01ed:6e25	mov	al, byte ptr [bp + 4]
01ed:6e28	push	ax
01ed:6e29	call	0x6e30
01ed:6e2c	inc	sp
01ed:6e2d	inc	sp
        	loc_8cfe:
01ed:6e2e	pop	bp
01ed:6e2f	ret	
sub_8ce1 ENDP
*/
void sub_8ce1()
{
    // coverage: 0x8011-0x8030 method sub_8ce1
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8ced;
    sub_ca53();
loc_8ced:
    if (memoryAGet16(ds, 0x689c) == 0x8000)
        goto loc_8cfe;
    al = memoryAGet(ss, bp + 4);
    push(ax);
    sub_8d00();
    sp++;
    sp++;
loc_8cfe:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:6e30 sub_8d00()
sub_8d00 PROC
01ed:6e30	push	bp
01ed:6e31	mov	bp, sp
01ed:6e33	cmp	word ptr [0x6b4c], sp
01ed:6e37	ja	loc_8d0c
01ed:6e39	call	0xab83
        	loc_8d0c:
01ed:6e3c	cmp	word ptr [0x689c], 4
01ed:6e41	jne	loc_8d3c
01ed:6e43	mov	al, byte ptr [bp + 4]
01ed:6e46	mov	ah, 0
01ed:6e48	shl	ax, 1
01ed:6e4a	mov	bx, ax
01ed:6e4c	mov	al, byte ptr [bx + 0x27af]
01ed:6e50	mov	ah, 0
01ed:6e52	push	ax
01ed:6e53	mov	al, byte ptr [bp + 4]
01ed:6e56	mov	ah, 0
01ed:6e58	shl	ax, 1
01ed:6e5a	mov	bx, ax
01ed:6e5c	mov	al, byte ptr [bx + 0x27ae]
01ed:6e60	mov	ah, 0
01ed:6e62	push	ax
01ed:6e63	call	0x8a07
01ed:6e66	add	sp, 4
01ed:6e69	jmp	loc_8fb5
        	loc_8d3c:
01ed:6e6c	mov	al, byte ptr [bp + 4]
01ed:6e6f	mov	ah, 0
01ed:6e71	dec	ax
01ed:6e72	mov	bx, ax
01ed:6e74	cmp	bx, 0x14
01ed:6e77	jbe	loc_8d4c
01ed:6e79	jmp	loc_8fb5
        	loc_8d4c:
01ed:6e7c	shl	bx, 1
01ed:6e7e	jmp	word ptr cs:[bx + 0x70e7]
        	loc_8d53:
01ed:6e83	mov	ax, 1
01ed:6e86	push	ax
01ed:6e87	push	ax
01ed:6e88	mov	ax, 0x1c2
01ed:6e8b	push	ax
01ed:6e8c	mov	ax, 0xa
01ed:6e8f	push	ax
01ed:6e90	mov	ax, 1
01ed:6e93	push	ax
01ed:6e94	mov	ax, 0x3e8
01ed:6e97	jmp	loc_8fa6
        	loc_8d6a:
01ed:6e9a	mov	ax, 1
01ed:6e9d	push	ax
01ed:6e9e	push	ax
01ed:6e9f	mov	ax, 0x1c2
01ed:6ea2	push	ax
01ed:6ea3	mov	ax, 0xfff6
01ed:6ea6	push	ax
01ed:6ea7	mov	ax, 1
01ed:6eaa	push	ax
01ed:6eab	mov	ax, 0x320
01ed:6eae	push	ax
01ed:6eaf	mov	ax, 0x28
01ed:6eb2	jmp	loc_8faa
        	loc_8d85:
01ed:6eb5	mov	ax, 0xffff
01ed:6eb8	push	ax
01ed:6eb9	mov	ax, 4
01ed:6ebc	push	ax
01ed:6ebd	mov	ax, 0x1f3
01ed:6ec0	push	ax
01ed:6ec1	mov	ax, 0xffff
01ed:6ec4	push	ax
01ed:6ec5	mov	ax, 1
01ed:6ec8	push	ax
01ed:6ec9	mov	ax, 0x1b8
01ed:6ecc	push	ax
01ed:6ecd	mov	ax, 0x190
01ed:6ed0	jmp	loc_8faa
        	loc_8da3:
01ed:6ed3	mov	ax, 4
01ed:6ed6	push	ax
01ed:6ed7	mov	ax, 1
01ed:6eda	push	ax
01ed:6edb	mov	ax, 0x64
01ed:6ede	push	ax
01ed:6edf	mov	ax, 0xffff
01ed:6ee2	push	ax
01ed:6ee3	mov	ax, 1
01ed:6ee6	push	ax
01ed:6ee7	mov	ax, 0xdc
01ed:6eea	push	ax
01ed:6eeb	mov	ax, 0x5a
01ed:6eee	jmp	loc_8faa
        	loc_8dc1:
01ed:6ef1	mov	ax, 2
01ed:6ef4	push	ax
01ed:6ef5	mov	ax, 1
01ed:6ef8	push	ax
01ed:6ef9	mov	ax, 0x1b8
01ed:6efc	push	ax
01ed:6efd	mov	ax, 0xa
01ed:6f00	push	ax
01ed:6f01	mov	ax, 1
01ed:6f04	push	ax
01ed:6f05	mov	ax, 0x3e8
01ed:6f08	push	ax
01ed:6f09	mov	ax, 0x19
01ed:6f0c	jmp	loc_8faa
        	loc_8ddf:
01ed:6f0f	mov	ax, 5
01ed:6f12	push	ax
01ed:6f13	mov	ax, 2
01ed:6f16	push	ax
01ed:6f17	mov	ax, 0x1b8
01ed:6f1a	push	ax
01ed:6f1b	mov	ax, 0xa
01ed:6f1e	push	ax
01ed:6f1f	mov	ax, 1
01ed:6f22	push	ax
01ed:6f23	mov	ax, 0x44c
01ed:6f26	push	ax
01ed:6f27	mov	ax, 0x14
01ed:6f2a	jmp	loc_8faa
        	loc_8dfd:
01ed:6f2d	mov	ax, 3
01ed:6f30	push	ax
01ed:6f31	mov	ax, 1
01ed:6f34	push	ax
01ed:6f35	mov	ax, 0x1b8
01ed:6f38	push	ax
01ed:6f39	mov	ax, 0xa
01ed:6f3c	push	ax
01ed:6f3d	mov	ax, 1
01ed:6f40	push	ax
01ed:6f41	mov	ax, 0x4b0
01ed:6f44	push	ax
01ed:6f45	mov	ax, 0xf
01ed:6f48	jmp	loc_8faa
        	loc_8e1b:
01ed:6f4b	mov	ax, 5
01ed:6f4e	push	ax
01ed:6f4f	mov	ax, 1
01ed:6f52	push	ax
01ed:6f53	mov	ax, 0x64
01ed:6f56	push	ax
01ed:6f57	mov	ax, 0xfffb
01ed:6f5a	push	ax
01ed:6f5b	mov	ax, 1
01ed:6f5e	push	ax
01ed:6f5f	mov	ax, 0xdc
01ed:6f62	push	ax
01ed:6f63	mov	ax, 0x28
01ed:6f66	jmp	loc_8faa
        	loc_8e39:
01ed:6f69	mov	ax, 1
01ed:6f6c	push	ax
01ed:6f6d	push	ax
01ed:6f6e	mov	ax, 0x1c2
01ed:6f71	push	ax
01ed:6f72	mov	ax, 0x14
01ed:6f75	push	ax
01ed:6f76	mov	ax, 1
01ed:6f79	push	ax
01ed:6f7a	mov	ax, 0x32
01ed:6f7d	jmp	loc_8fa6
        	loc_8e50:
01ed:6f80	mov	ax, 0xa
01ed:6f83	push	ax
01ed:6f84	mov	ax, 1
01ed:6f87	push	ax
01ed:6f88	mov	ax, 0x15d
01ed:6f8b	push	ax
01ed:6f8c	mov	ax, 0x32
01ed:6f8f	push	ax
01ed:6f90	mov	ax, 1
01ed:6f93	push	ax
01ed:6f94	mov	ax, 0xc8
01ed:6f97	push	ax
01ed:6f98	mov	ax, 0xf
01ed:6f9b	jmp	loc_8faa
        	loc_8e6e:
01ed:6f9e	mov	ax, 0xfffc
01ed:6fa1	push	ax
01ed:6fa2	mov	ax, 1
01ed:6fa5	push	ax
01ed:6fa6	mov	ax, 0x1f3
01ed:6fa9	push	ax
01ed:6faa	mov	ax, 0x14
01ed:6fad	push	ax
01ed:6fae	mov	ax, 0x28
01ed:6fb1	push	ax
01ed:6fb2	mov	ax, 2
01ed:6fb5	push	ax
01ed:6fb6	call	0x9502
01ed:6fb9	add	sp, 0xc
01ed:6fbc	jmp	loc_8fb5
        	loc_8e8f:
01ed:6fbf	mov	ax, 2
01ed:6fc2	push	ax
01ed:6fc3	mov	ax, 1
01ed:6fc6	push	ax
01ed:6fc7	mov	ax, 0x1a4
01ed:6fca	push	ax
01ed:6fcb	mov	ax, 0xa
01ed:6fce	push	ax
01ed:6fcf	mov	ax, 1
01ed:6fd2	push	ax
01ed:6fd3	mov	ax, 0x4b0
01ed:6fd6	jmp	loc_8fa6
        	loc_8ea9:
01ed:6fd9	mov	ax, 0xf
01ed:6fdc	push	ax
01ed:6fdd	mov	ax, 2
01ed:6fe0	push	ax
01ed:6fe1	mov	ax, 0x15d
01ed:6fe4	push	ax
01ed:6fe5	mov	ax, 0x32
01ed:6fe8	push	ax
01ed:6fe9	mov	ax, 1
01ed:6fec	push	ax
01ed:6fed	mov	ax, 0xc8
01ed:6ff0	push	ax
01ed:6ff1	mov	ax, 0x14
01ed:6ff4	jmp	loc_8faa
        	loc_8ec7:
01ed:6ff7	xor	ax, ax
01ed:6ff9	push	ax
01ed:6ffa	mov	ax, 0xa
01ed:6ffd	push	ax
01ed:6ffe	mov	ax, 0xc8
01ed:7001	push	ax
01ed:7002	mov	ax, 4
01ed:7005	push	ax
01ed:7006	mov	ax, 1
01ed:7009	push	ax
01ed:700a	mov	ax, 0xa
01ed:700d	push	ax
01ed:700e	mov	ax, 0x32
01ed:7011	jmp	loc_8faa
        	loc_8ee4:
01ed:7014	mov	ax, 1
01ed:7017	push	ax
01ed:7018	mov	ax, 2
01ed:701b	push	ax
01ed:701c	mov	ax, 0x64
01ed:701f	push	ax
01ed:7020	mov	ax, 2
01ed:7023	push	ax
01ed:7024	mov	ax, 1
01ed:7027	push	ax
01ed:7028	mov	ax, 0x12c
01ed:702b	push	ax
01ed:702c	mov	ax, 0x190
01ed:702f	jmp	loc_8faa
        	loc_8f02:
01ed:7032	mov	ax, 2
01ed:7035	push	ax
01ed:7036	mov	ax, 1
01ed:7039	push	ax
01ed:703a	mov	ax, 0x1a4
01ed:703d	push	ax
01ed:703e	mov	ax, 0xa
01ed:7041	push	ax
01ed:7042	mov	ax, 1
01ed:7045	push	ax
01ed:7046	mov	ax, 0x4b0
01ed:7049	jmp	loc_8fa6
        	loc_8f1c:
01ed:704c	mov	ax, 0xfffc
01ed:704f	push	ax
01ed:7050	mov	ax, 1
01ed:7053	push	ax
01ed:7054	mov	ax, 0x1f3
01ed:7057	push	ax
01ed:7058	mov	ax, 0x14
01ed:705b	push	ax
01ed:705c	mov	ax, 0x28
01ed:705f	push	ax
01ed:7060	mov	ax, 2
01ed:7063	push	ax
01ed:7064	call	0x9502
01ed:7067	add	sp, 0xc
01ed:706a	jmp	loc_8fb5
        	loc_8f3c:
01ed:706c	mov	ax, 0xfffc
01ed:706f	push	ax
01ed:7070	mov	ax, 2
01ed:7073	push	ax
01ed:7074	mov	ax, 0x1f3
01ed:7077	push	ax
01ed:7078	mov	ax, 0x1e
01ed:707b	push	ax
01ed:707c	mov	ax, 0x50
01ed:707f	push	ax
01ed:7080	mov	ax, 2
01ed:7083	push	ax
01ed:7084	call	0x9502
01ed:7087	add	sp, 0xc
01ed:708a	jmp	loc_8fb5
        	loc_8f5c:
01ed:708c	mov	ax, 1
01ed:708f	push	ax
01ed:7090	mov	ax, 2
01ed:7093	push	ax
01ed:7094	mov	ax, 0x64
01ed:7097	push	ax
01ed:7098	mov	ax, 1
01ed:709b	push	ax
01ed:709c	push	ax
01ed:709d	mov	ax, 0x12c
01ed:70a0	push	ax
01ed:70a1	mov	ax, 0x320
01ed:70a4	jmp	loc_8faa
        	loc_8f76:
01ed:70a6	xor	ax, ax
01ed:70a8	push	ax
01ed:70a9	mov	ax, 0xa
01ed:70ac	push	ax
01ed:70ad	mov	ax, 0xc8
01ed:70b0	push	ax
01ed:70b1	mov	ax, 4
01ed:70b4	push	ax
01ed:70b5	mov	ax, 1
01ed:70b8	push	ax
01ed:70b9	mov	ax, 0xa
01ed:70bc	push	ax
01ed:70bd	mov	ax, 0x32
01ed:70c0	jmp	loc_8faa
01ed:70c2		
        	loc_8fa6:
01ed:70d6	push	ax
01ed:70d7	mov	ax, 0x1e
        	loc_8faa:
01ed:70da	push	ax
01ed:70db	mov	ax, 2
01ed:70de	push	ax
01ed:70df	call	0x9488
01ed:70e2	add	sp, 0x10
        	loc_8fb5:
01ed:70e5	pop	bp
01ed:70e6	ret	
sub_8d00 ENDP
*/
void sub_8d00()
{
    // coverage: 0x8030-0x82c2 method sub_8d00
    // coverage: 0x82d6-0x82e7 method sub_8d00
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8d0c;
    sub_ca53();
loc_8d0c:
    if (memoryAGet16(ds, 0x689c) != 0x0004)
        goto loc_8d3c;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    al = memoryAGet(ds, bx + 10159);
    ah = 0x00;
    push(ax);
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax <<= 1;
    bx = ax;
    al = memoryAGet(ds, bx + 10158);
    ah = 0x00;
    push(ax);
    sub_a8d7();
    sp += 0x0004;
    goto loc_8fb5;
loc_8d3c:
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    ax--;
    bx = ax;
    if (bx <= 0x0014)
        goto loc_8d4c;
    goto loc_8fb5;
loc_8d4c:
    bx <<= 1;
    switch (bx)
    {
        // coverage: 0x82e7-0x830d switch
        case 0: goto loc_8d53;
        case 2: goto loc_8d6a;
        case 4: goto loc_8d85;
        case 6: goto loc_8da3;
        case 8: goto loc_8dc1;
        case 10: goto loc_8ddf;
        case 12: goto loc_8dfd;
        case 14: goto loc_8e1b;
        case 16: goto loc_8e39;
        case 18: goto loc_8e50;
        case 20: goto loc_8e6e;
        case 22: goto loc_8e8f;
        case 24: goto loc_8ea9;
        case 26: goto loc_8ec7;
        case 28: goto loc_8ee4;
        case 30: goto loc_8f02;
        case 32: goto loc_8f1c;
        case 34: goto loc_8f3c;
        case 36: goto loc_8f5c;
        case 38: goto loc_8f76;
        default:
        assert(0);
    }
loc_8d53:
    ax = 0x0001;
    push(ax);
    push(ax);
    ax = 0x01c2;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x03e8;
    goto loc_8fa6;
loc_8d6a:
    ax = 0x0001;
    push(ax);
    push(ax);
    ax = 0x01c2;
    push(ax);
    ax = 0xfff6;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0320;
    push(ax);
    ax = 0x0028;
    goto loc_8faa;
loc_8d85:
    ax = 0xffff;
    push(ax);
    ax = 0x0004;
    push(ax);
    ax = 0x01f3;
    push(ax);
    ax = 0xffff;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01b8;
    push(ax);
    ax = 0x0190;
    goto loc_8faa;
loc_8da3:
    ax = 0x0004;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0064;
    push(ax);
    ax = 0xffff;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x00dc;
    push(ax);
    ax = 0x005a;
    goto loc_8faa;
loc_8dc1:
    ax = 0x0002;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01b8;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x03e8;
    push(ax);
    ax = 0x0019;
    goto loc_8faa;
loc_8ddf:
    ax = 0x0005;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x01b8;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x044c;
    push(ax);
    ax = 0x0014;
    goto loc_8faa;
loc_8dfd:
    ax = 0x0003;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01b8;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x04b0;
    push(ax);
    ax = 0x000f;
    goto loc_8faa;
loc_8e1b:
    ax = 0x0005;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0064;
    push(ax);
    ax = 0xfffb;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x00dc;
    push(ax);
    ax = 0x0028;
    goto loc_8faa;
loc_8e39:
    ax = 0x0001;
    push(ax);
    push(ax);
    ax = 0x01c2;
    push(ax);
    ax = 0x0014;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0032;
    goto loc_8fa6;
loc_8e50:
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x015d;
    push(ax);
    ax = 0x0032;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x00c8;
    push(ax);
    ax = 0x000f;
    goto loc_8faa;
loc_8e6e:
    ax = 0xfffc;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01f3;
    push(ax);
    ax = 0x0014;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_b3d2();
    sp += 0x000c;
    goto loc_8fb5;
loc_8e8f:
    ax = 0x0002;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01a4;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x04b0;
    goto loc_8fa6;
loc_8ea9:
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x015d;
    push(ax);
    ax = 0x0032;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x00c8;
    push(ax);
    ax = 0x0014;
    goto loc_8faa;
loc_8ec7:
    ax = 0;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x00c8;
    push(ax);
    ax = 0x0004;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0032;
    goto loc_8faa;
loc_8ee4:
    ax = 0x0001;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x0064;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x012c;
    push(ax);
    ax = 0x0190;
    goto loc_8faa;
loc_8f02:
    ax = 0x0002;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01a4;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x04b0;
    goto loc_8fa6;
loc_8f1c:
    ax = 0xfffc;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x01f3;
    push(ax);
    ax = 0x0014;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_b3d2();
    sp += 0x000c;
    goto loc_8fb5;
loc_8f3c:
    ax = 0xfffc;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x01f3;
    push(ax);
    ax = 0x001e;
    push(ax);
    ax = 0x0050;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_b3d2();
    sp += 0x000c;
    goto loc_8fb5;
loc_8f5c:
    ax = 0x0001;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x0064;
    push(ax);
    ax = 0x0001;
    push(ax);
    push(ax);
    ax = 0x012c;
    push(ax);
    ax = 0x0320;
    goto loc_8faa;
loc_8f76:
    ax = 0;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x00c8;
    push(ax);
    ax = 0x0004;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x000a;
    push(ax);
    ax = 0x0032;
    goto loc_8faa;
    //   gap of 20 bytes
loc_8fa6:
    push(ax);
    ax = 0x001e;
loc_8faa:
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_b358();
    sp += 0x0010;
loc_8fb5:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7111 sub_8fe1()
sub_8fe1 PROC
01ed:7111	push	bp
01ed:7112	mov	bp, sp
01ed:7114	cmp	word ptr [0x6b4c], sp
01ed:7118	ja	loc_8fed
01ed:711a	call	0xab83
        	loc_8fed:
01ed:711d	pop	bp
01ed:711e	ret	
sub_8fe1 ENDP
*/
void sub_8fe1()
{
    // coverage: 0x8311-0x831f method sub_8fe1
    push(0x7777);
    push(bp);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_8fed;
    sub_ca53();
loc_8fed:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7120 sub_8ff0()
sub_8ff0 PROC
01ed:7120	push	bp
01ed:7121	mov	bp, sp
01ed:7123	mov	al, byte ptr [bp + 4]
01ed:7126	mov	ah, 0
01ed:7128	int	0x10
01ed:712a	pop	bp
01ed:712b	ret	
sub_8ff0 ENDP
*/
void sub_8ff0()
{
    // coverage: 0x8320-0x832c method sub_8ff0
    push(0x7777);
    push(bp);
    bp = sp;
    al = memoryAGet(ss, bp + 4);
    ah = 0x00;
    interrupt(0x10);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7235 sub_9105()
sub_9105 PROC
01ed:7235	push	bp
01ed:7236	mov	bp, sp
01ed:7238	sub	sp, 0xa
01ed:723b	push	si
01ed:723c	push	di
01ed:723d	mov	byte ptr [bp - 1], 0
01ed:7241	xor	si, si
01ed:7243	mov	word ptr [bp - 6], 0
01ed:7248	mov	word ptr [bp - 4], 0
01ed:724d	jmp	loc_919f
        	loc_9120:
01ed:7250	cmp	word ptr [bp + 0xe], 0
01ed:7254	jl	loc_913d
01ed:7256	jg	loc_912f
01ed:7258	cmp	word ptr [bp + 0xc], 0xfa00
01ed:725d	jbe	loc_913d
        	loc_912f:
01ed:725f	mov	di, 0xfa00
01ed:7262	sub	word ptr [bp + 0xc], 0xfa00
01ed:7267	sbb	word ptr [bp + 0xe], 0
01ed:726b	jmp	loc_914a
        	loc_913d:
01ed:726d	mov	di, word ptr [bp + 0xc]
01ed:7270	mov	word ptr [bp + 0xc], 0
01ed:7275	mov	word ptr [bp + 0xe], 0
        	loc_914a:
01ed:727a	push	di
01ed:727b	push	word ptr [bp + 0xa]
01ed:727e	push	word ptr [bp + 8]
01ed:7281	push	word ptr [bp + 6]
01ed:7284	call	word ptr [bp + 4]
01ed:7287	add	sp, 8
01ed:728a	mov	si, ax
01ed:728c	cmp	si, di
01ed:728e	je	loc_9165
01ed:7290	mov	ax, 1
01ed:7293	jmp	loc_9167
        	loc_9165:
01ed:7295	xor	ax, ax
        	loc_9167:
01ed:7297	mov	byte ptr [bp - 1], al
01ed:729a	add	word ptr [bp - 6], si
01ed:729d	adc	word ptr [bp - 4], 0
01ed:72a1	mov	ax, word ptr [bp + 8]
01ed:72a4	mov	word ptr [bp - 0xa], ax
01ed:72a7	mov	word ptr [bp - 8], 0
01ed:72ac	add	word ptr [bp - 0xa], si
01ed:72af	adc	word ptr [bp - 8], 0
01ed:72b3	mov	ax, word ptr [bp - 0xa]
01ed:72b6	mov	word ptr [bp + 8], ax
01ed:72b9	mov	word ptr [bp - 0xa], 0
01ed:72be	mov	ax, word ptr [bp - 0xa]
01ed:72c1	or	ax, word ptr [bp - 8]
01ed:72c4	je	loc_919f
01ed:72c6	add	word ptr [bp + 8], 0
01ed:72ca	adc	word ptr [bp + 0xa], 0x1000
        	loc_919f:
01ed:72cf	mov	ax, word ptr [bp + 0xc]
01ed:72d2	or	ax, word ptr [bp + 0xe]
01ed:72d5	je	loc_91b3
01ed:72d7	mov	al, byte ptr [bp - 1]
01ed:72da	mov	ah, 0
01ed:72dc	or	ax, ax
01ed:72de	jne	loc_91b3
01ed:72e0	jmp	loc_9120
        	loc_91b3:
01ed:72e3	mov	dx, word ptr [bp - 4]
01ed:72e6	mov	ax, word ptr [bp - 6]
01ed:72e9	pop	di
01ed:72ea	pop	si
01ed:72eb	mov	sp, bp
01ed:72ed	pop	bp
01ed:72ee	ret	
sub_9105 ENDP
*/
void sub_9105()
{
    // coverage: 0x8435-0x84ef method sub_9105
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x000a;
    push(si);
    push(di);
    memoryASet(ss, bp - 1, 0x00);
    si = 0;
    memoryASet16(ss, bp - 6, 0x0000);
    memoryASet16(ss, bp - 4, 0x0000);
    goto loc_919f;
loc_9120:
    if ((short)memoryAGet16(ss, bp + 14) < (short)0x0000)
        goto loc_913d;
    if ((short)memoryAGet16(ss, bp + 14) > (short)0x0000)
        goto loc_912f;
    if (memoryAGet16(ss, bp + 12) <= 0xfa00)
        goto loc_913d;
loc_912f:
    di = 0xfa00;
    flags.carry = memoryAGet16(ss, bp + 12) < 0xfa00;
    memoryASet16(ss, bp + 12, memoryAGet16(ss, bp + 12) - 0xfa00);
    memoryASet16(ss, bp + 14, memoryAGet16(ss, bp + 14) - flags.carry);
    goto loc_914a;
loc_913d:
    di = memoryAGet16(ss, bp + 12);
    memoryASet16(ss, bp + 12, 0x0000);
    memoryASet16(ss, bp + 14, 0x0000);
loc_914a:
    push(di);
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    push(memoryAGet16(ss, bp + 6));
    callIndirect(cs, memoryAGet16(ss, bp + 4));
    sp += 0x0008;
    si = ax;
    if (si == di)
        goto loc_9165;
    ax = 0x0001;
    goto loc_9167;
loc_9165:
    ax = 0;
loc_9167:
    memoryASet(ss, bp - 1, al);
    flags.carry = (memoryAGet16(ss, bp - 6) + si) >= 0x10000;
    memoryASet16(ss, bp - 6, memoryAGet16(ss, bp - 6) + si);
    memoryASet16(ss, bp - 4, memoryAGet16(ss, bp - 4) + flags.carry);
    ax = memoryAGet16(ss, bp + 8);
    memoryASet16(ss, bp - 10, ax);
    memoryASet16(ss, bp - 8, 0x0000);
    flags.carry = (memoryAGet16(ss, bp - 10) + si) >= 0x10000;
    memoryASet16(ss, bp - 10, memoryAGet16(ss, bp - 10) + si);
    memoryASet16(ss, bp - 8, memoryAGet16(ss, bp - 8) + flags.carry);
    ax = memoryAGet16(ss, bp - 10);
    memoryASet16(ss, bp + 8, ax);
    memoryASet16(ss, bp - 10, 0x0000);
    ax = memoryAGet16(ss, bp - 10);
    ax |= memoryAGet16(ss, bp - 8);
    if (!ax)
        goto loc_919f;
    flags.carry = (memoryAGet16(ss, bp + 8) + 0x0000) >= 0x10000;
    memoryASet16(ss, bp + 8, memoryAGet16(ss, bp + 8) + 0x0000);
    memoryASet16(ss, bp + 10, memoryAGet16(ss, bp + 10) + (0x1000 + flags.carry));
loc_919f:
    ax = memoryAGet16(ss, bp + 12);
    ax |= memoryAGet16(ss, bp + 14);
    if (!ax)
        goto loc_91b3;
    al = memoryAGet(ss, bp - 1);
    ah = 0x00;
    if (ax)
        goto loc_91b3;
    goto loc_9120;
loc_91b3:
    dx = memoryAGet16(ss, bp - 4);
    ax = memoryAGet16(ss, bp - 6);
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:72ef sub_91bf()
sub_91bf PROC
01ed:72ef	push	bp
01ed:72f0	mov	bp, sp
01ed:72f2	mov	ax, word ptr [bp + 6]
01ed:72f5	mov	word ptr [0xa1b8], ax
01ed:72f8	push	word ptr [bp + 4]
01ed:72fb	call	0xa0e9
01ed:72fe	inc	sp
01ed:72ff	inc	sp
01ed:7300	mov	byte ptr [0x4ce6], 1
01ed:7305	pop	bp
01ed:7306	ret	
sub_91bf ENDP
*/
void sub_91bf()
{
    // coverage: 0x84ef-0x8507 method sub_91bf
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(ds, 0xa1b8, ax);
    push(memoryAGet16(ss, bp + 4));
    sub_bfb9();
    sp++;
    sp++;
    memoryASet(ds, 0x4ce6, 0x01);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7307 sub_91d7()
sub_91d7 PROC
01ed:7307	push	bp
01ed:7308	mov	bp, sp
01ed:730a	mov	ax, word ptr [bp + 6]
01ed:730d	mov	dx, word ptr [bp + 4]
01ed:7310	mov	word ptr [0xa1b4], dx
01ed:7314	mov	word ptr [0xa1b6], ax
01ed:7317	pop	bp
01ed:7318	ret	
sub_91d7 ENDP
*/
void sub_91d7()
{
    // coverage: 0x8507-0x8519 method sub_91d7
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 6);
    dx = memoryAGet16(ss, bp + 4);
    memoryASet16(ds, 0xa1b4, dx);
    memoryASet16(ds, 0xa1b6, ax);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7319 sub_91e9()
sub_91e9 PROC
01ed:7319	push	bp
01ed:731a	mov	bp, sp
01ed:731c	push	si
01ed:731d	push	word ptr [bp + 4]
01ed:7320	call	0x988e
01ed:7323	inc	sp
01ed:7324	inc	sp
01ed:7325	mov	si, ax
01ed:7327	pop	si
01ed:7328	pop	bp
01ed:7329	ret	
sub_91e9 ENDP
*/
void sub_91e9()
{
    // coverage: 0x8519-0x852a method sub_91e9
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(memoryAGet16(ss, bp + 4));
    sub_b75e();
    sp++;
    sp++;
    si = ax;
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:736f sub_923f()
sub_923f PROC
01ed:736f	push	bp
01ed:7370	mov	bp, sp
01ed:7372	dec	sp
01ed:7373	dec	sp
01ed:7374	push	si
01ed:7375	push	di
01ed:7376	mov	di, word ptr [bp + 4]
01ed:7379	mov	byte ptr [bp - 1], 0
01ed:737d	mov	al, byte ptr [0x4ce6]
01ed:7380	mov	ah, 0
01ed:7382	or	ax, ax
01ed:7384	jne	loc_925c
01ed:7386	mov	word ptr [0xa1b8], 0x74d4
        	loc_925c:
01ed:738c	mov	ax, di
01ed:738e	mov	dx, 0xa
01ed:7391	imul	dx
01ed:7393	les	bx, ptr [0xa1b4]
01ed:7397	add	bx, ax
01ed:7399	cmp	byte ptr es:[bx + 4], 0x7a
01ed:739e	je	loc_92b9
        	loc_9270:
01ed:73a0	push	word ptr [bp + 6]
01ed:73a3	mov	ax, di
01ed:73a5	mov	dx, 0xa
01ed:73a8	imul	dx
01ed:73aa	les	bx, ptr [0xa1b4]
01ed:73ae	add	bx, ax
01ed:73b0	mov	al, byte ptr es:[bx + 4]
01ed:73b4	push	ax
01ed:73b5	call	0x74d5
01ed:73b8	add	sp, 4
01ed:73bb	mov	si, ax
01ed:73bd	or	ax, ax
01ed:73bf	je	loc_92ab
01ed:73c1	mov	ax, di
01ed:73c3	mov	dx, 0xa
01ed:73c6	imul	dx
01ed:73c8	les	bx, ptr [0xa1b4]
01ed:73cc	add	bx, ax
01ed:73ce	mov	al, byte ptr es:[bx + 4]
01ed:73d2	mov	ah, 0
01ed:73d4	push	ax
01ed:73d5	call	word ptr [0xa1b8]
01ed:73d9	inc	sp
01ed:73da	inc	sp
        	loc_92ab:
01ed:73db	or	si, si
01ed:73dd	je	loc_92b9
01ed:73df	mov	al, byte ptr [bp - 1]
01ed:73e2	inc	byte ptr [bp - 1]
01ed:73e5	cmp	al, 0xa
01ed:73e7	jb	loc_9270
        	loc_92b9:
01ed:73e9	cmp	byte ptr [bp - 1], 0xa
01ed:73ed	ja	loc_9326
01ed:73ef	mov	ax, di
01ed:73f1	mov	dx, 0xa
01ed:73f4	imul	dx
01ed:73f6	les	bx, ptr [0xa1b4]
01ed:73fa	add	bx, ax
01ed:73fc	mov	al, byte ptr es:[bx + 4]
01ed:7400	mov	byte ptr [0x4ce7], al
        	loc_92d3:
01ed:7403	mov	ax, 0x180
01ed:7406	push	ax
01ed:7407	mov	ax, word ptr [bp + 6]
01ed:740a	or	ax, 0x8004
01ed:740d	push	ax
01ed:740e	mov	ax, di
01ed:7410	mov	dx, 0xa
01ed:7413	imul	dx
01ed:7415	les	bx, ptr [0xa1b4]
01ed:7419	add	bx, ax
01ed:741b	push	word ptr es:[bx + 2]
01ed:741f	push	word ptr es:[bx]
01ed:7422	call	0xa21c
01ed:7425	add	sp, 8
01ed:7428	mov	si, ax
01ed:742a	or	ax, ax
01ed:742c	jge	loc_9318
01ed:742e	mov	ax, di
01ed:7430	mov	dx, 0xa
01ed:7433	imul	dx
01ed:7435	les	bx, ptr [0xa1b4]
01ed:7439	add	bx, ax
01ed:743b	mov	al, byte ptr es:[bx + 4]
01ed:743f	mov	ah, 0
01ed:7441	push	ax
01ed:7442	call	word ptr [0xa1b8]
01ed:7446	inc	sp
01ed:7447	inc	sp
        	loc_9318:
01ed:7448	or	si, si
01ed:744a	jge	loc_9326
01ed:744c	mov	al, byte ptr [bp - 1]
01ed:744f	inc	byte ptr [bp - 1]
01ed:7452	cmp	al, 0xa
01ed:7454	jb	loc_92d3
        	loc_9326:
01ed:7456	mov	ax, si
01ed:7458	pop	di
01ed:7459	pop	si
01ed:745a	mov	sp, bp
01ed:745c	pop	bp
01ed:745d	ret	
sub_923f ENDP
*/
void sub_923f()
{
    // coverage: 0x856f-0x865e method sub_923f
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    push(si);
    push(di);
    di = memoryAGet16(ss, bp + 4);
    memoryASet(ss, bp - 1, 0x00);
    al = memoryAGet(ds, 0x4ce6);
    ah = 0x00;
    if (ax)
        goto loc_925c;
    memoryASet16(ds, 0xa1b8, 0x74d4);
loc_925c:
    ax = di;
    dx = 0x000a;
    imul(dx);
    bx = memoryAGet16(ds, 0xa1b4);
    es = memoryAGet16(ds, 0xa1b4 + 2);
    bx += ax;
    if (memoryAGet(es, bx + 4) == 0x7a)
        goto loc_92b9;
loc_9270:
    push(memoryAGet16(ss, bp + 6));
    ax = di;
    dx = 0x000a;
    imul(dx);
    bx = memoryAGet16(ds, 0xa1b4);
    es = memoryAGet16(ds, 0xa1b4 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 4);
    push(ax);
    sub_93a5();
    sp += 0x0004;
    si = ax;
    if (!ax)
        goto loc_92ab;
    ax = di;
    dx = 0x000a;
    imul(dx);
    bx = memoryAGet16(ds, 0xa1b4);
    es = memoryAGet16(ds, 0xa1b4 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 4);
    ah = 0x00;
    push(ax);
    callIndirect(cs, memoryAGet16(ds, 0xa1b8));
    sp++;
    sp++;
loc_92ab:
    if (!si)
        goto loc_92b9;
    al = memoryAGet(ss, bp - 1);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
    if (al < 0x0a)
        goto loc_9270;
loc_92b9:
    if (memoryAGet(ss, bp - 1) > 0x0a)
        goto loc_9326;
    ax = di;
    dx = 0x000a;
    imul(dx);
    bx = memoryAGet16(ds, 0xa1b4);
    es = memoryAGet16(ds, 0xa1b4 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 4);
    memoryASet(ds, 0x4ce7, al);
loc_92d3:
    ax = 0x0180;
    push(ax);
    ax = memoryAGet16(ss, bp + 6);
    ax |= 0x8004;
    push(ax);
    ax = di;
    dx = 0x000a;
    imul(dx);
    bx = memoryAGet16(ds, 0xa1b4);
    es = memoryAGet16(ds, 0xa1b4 + 2);
    bx += ax;
    push(memoryAGet16(es, bx + 2));
    push(memoryAGet16(es, bx));
    sub_c0ec();
    sp += 0x0008;
    si = ax;
    if ((short)ax >= 0)
        goto loc_9318;
    ax = di;
    dx = 0x000a;
    imul(dx);
    bx = memoryAGet16(ds, 0xa1b4);
    es = memoryAGet16(ds, 0xa1b4 + 2);
    bx += ax;
    al = memoryAGet(es, bx + 4);
    ah = 0x00;
    push(ax);
    callIndirect(cs, memoryAGet16(ds, 0xa1b8));
    sp++;
    sp++;
loc_9318:
    if ((short)si >= 0)
        goto loc_9326;
    al = memoryAGet(ss, bp - 1);
    memoryASet(ss, bp - 1, memoryAGet(ss, bp - 1) + 1);
    if (al < 0x0a)
        goto loc_92d3;
loc_9326:
    ax = si;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:745e sub_932e()
sub_932e PROC
01ed:745e	push	bp
01ed:745f	mov	bp, sp
01ed:7461	sub	sp, 4
01ed:7464	push	word ptr [bp + 0xc]
01ed:7467	push	word ptr [bp + 0xa]
01ed:746a	push	word ptr [bp + 8]
01ed:746d	push	word ptr [bp + 6]
01ed:7470	push	word ptr [bp + 4]
01ed:7473	mov	ax, 0xa3ae
01ed:7476	push	ax
01ed:7477	call	0x7235
01ed:747a	add	sp, 0xc
01ed:747d	mov	word ptr [bp - 4], ax
01ed:7480	mov	word ptr [bp - 2], dx
01ed:7483	mov	ax, word ptr [bp - 4]
01ed:7486	mov	sp, bp
01ed:7488	pop	bp
01ed:7489	ret	
sub_932e ENDP
*/
void sub_932e()
{
    // coverage: 0x865e-0x868a method sub_932e
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(memoryAGet16(ss, bp + 12));
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    ax = 0xa3ae;
    push(ax);
    sub_9105();
    sp += 0x000c;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    ax = memoryAGet16(ss, bp - 4);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:74d5 sub_93a5()
sub_93a5 PROC
01ed:74d5	push	bp
01ed:74d6	mov	bp, sp
01ed:74d8	push	si
01ed:74d9	mov	ax, 0x180
01ed:74dc	push	ax
01ed:74dd	mov	ax, word ptr [bp + 6]
01ed:74e0	or	ax, 0x8004
01ed:74e3	push	ax
01ed:74e4	push	ds
01ed:74e5	mov	ax, 0x4ce8
01ed:74e8	push	ax
01ed:74e9	call	0xa21c
01ed:74ec	add	sp, 8
01ed:74ef	mov	si, ax
01ed:74f1	or	si, si
01ed:74f3	jle	loc_93fc
01ed:74f5	xor	ax, ax
01ed:74f7	push	ax
01ed:74f8	mov	dx, 4
01ed:74fb	push	ax
01ed:74fc	push	dx
01ed:74fd	push	ds
01ed:74fe	mov	ax, 0xa1ba
01ed:7501	push	ax
01ed:7502	push	si
01ed:7503	call	0x745e
01ed:7506	add	sp, 0xc
01ed:7509	push	si
01ed:750a	call	0x7319
01ed:750d	inc	sp
01ed:750e	inc	sp
01ed:750f	mov	al, byte ptr [0xa1ba]
01ed:7512	mov	ah, 0
01ed:7514	mov	dl, byte ptr [bp + 4]
01ed:7517	mov	dh, 0
01ed:7519	sub	ax, dx
01ed:751b	mov	si, ax
01ed:751d	cmp	byte ptr [0xa1ba], 0x7a
01ed:7522	je	loc_93fa
01ed:7524	cmp	byte ptr [bp + 4], 0x7a
01ed:7528	jne	loc_93fc
        	loc_93fa:
01ed:752a	xor	si, si
        	loc_93fc:
01ed:752c	mov	ax, si
01ed:752e	pop	si
01ed:752f	pop	bp
01ed:7530	ret	
sub_93a5 ENDP
*/
void sub_93a5()
{
    // coverage: 0x86d5-0x8731 method sub_93a5
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    ax = 0x0180;
    push(ax);
    ax = memoryAGet16(ss, bp + 6);
    ax |= 0x8004;
    push(ax);
    push(ds);
    ax = 0x4ce8;
    push(ax);
    sub_c0ec();
    sp += 0x0008;
    si = ax;
    if ((short)si <= 0)
        goto loc_93fc;
    ax = 0;
    push(ax);
    dx = 0x0004;
    push(ax);
    push(dx);
    push(ds);
    ax = 0xa1ba;
    push(ax);
    push(si);
    sub_932e();
    sp += 0x000c;
    push(si);
    sub_91e9();
    sp++;
    sp++;
    al = memoryAGet(ds, 0xa1ba);
    ah = 0x00;
    dl = memoryAGet(ss, bp + 4);
    dh = 0x00;
    ax -= dx;
    si = ax;
    if (memoryAGet(ds, 0xa1ba) == 0x7a)
        goto loc_93fa;
    if (memoryAGet(ss, bp + 4) != 0x7a)
        goto loc_93fc;
loc_93fa:
    si = 0;
loc_93fc:
    ax = si;
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7532 sub_9402()
sub_9402 PROC
01ed:7532	pushf	
01ed:7533	push	ax
01ed:7534	push	bx
01ed:7535	push	cx
01ed:7536	push	dx
01ed:7537	push	si
01ed:7538	push	di
01ed:7539	push	ds
01ed:753a	push	es
01ed:753b	mov	ax, 0x1228
01ed:753e	mov	ds, ax
01ed:7540	mov	es, ax
01ed:7542	cld	
01ed:7543	mov	di, 0x4cf2
01ed:7546	mov	cx, 0x20
01ed:7549	xor	ax, ax
01ed:754b	rep stosw	word ptr es:[di], ax
01ed:754d	mov	ax, 0
01ed:7550	call	0x77d9
01ed:7553	mov	ax, 1
01ed:7556	call	0x77d9
01ed:7559	pop	es
01ed:755a	pop	ds
01ed:755b	pop	di
01ed:755c	pop	si
01ed:755d	pop	dx
01ed:755e	pop	cx
01ed:755f	pop	bx
01ed:7560	pop	ax
01ed:7561	popf	
01ed:7562	ret	
sub_9402 ENDP
*/
void sub_9402()
{
    // coverage: 0x8732-0x8763 method sub_9402
    tx = flags.carry | (flags.zero << 1);
    push(tx);
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    push(si);
    push(di);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    es = ax;
    flags.direction = false;
    di = 0x4cf2;
    cx = 0x0020;
    ax = 0;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x0000;
    sub_96a9();
    ax = 0x0001;
    sub_96a9();
    es = pop();
    ds = pop();
    di = pop();
    si = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
    tx = pop();
    flags.carry = tx & 1;
    flags.zero = (tx << 1) & 1;
}
/* Assembly listing of 01ed:7563 sub_9433()
sub_9433 PROC
01ed:7563	push	bp
01ed:7564	mov	bp, sp
01ed:7566	push	ds
01ed:7567	push	es
01ed:7568	push	si
01ed:7569	push	di
01ed:756a	mov	ax, word ptr [bp + 4]
01ed:756d	xor	ah, ah
01ed:756f	les	si, ptr [bp + 6]
01ed:7572	call	0x757b
01ed:7575	pop	di
01ed:7576	pop	si
01ed:7577	pop	es
01ed:7578	pop	ds
01ed:7579	pop	bp
01ed:757a	ret	
sub_9433 ENDP
*/
void sub_9433()
{
    // coverage: 0x8763-0x877b method sub_9433
    push(0x7777);
    push(bp);
    bp = sp;
    push(ds);
    push(es);
    push(si);
    push(di);
    ax = memoryAGet16(ss, bp + 4);
    ah = 0;
    si = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    sub_944b();
    di = pop();
    si = pop();
    es = pop();
    ds = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:757b sub_944b()
sub_944b PROC
01ed:757b	push	ds
01ed:757c	mov	dx, 0x1228
01ed:757f	mov	ds, dx
01ed:7581	cmp	al, 0x10
01ed:7583	jb	loc_945b
01ed:7585	mov	dx, 0x7676
01ed:7588	jmp	loc_94fa
        	loc_945b:
01ed:758b	add	ax, ax
01ed:758d	add	ax, ax
01ed:758f	mov	bx, 0x1228
01ed:7592	mov	ds, bx
01ed:7594	mov	bx, 0x4cf2
01ed:7597	add	bx, ax
01ed:7599	mov	word ptr [bx], si
01ed:759b	mov	ax, es
01ed:759d	mov	word ptr [bx + 2], ax
01ed:75a0	pop	ds
01ed:75a1	ret	
01ed:75a2		
        	loc_94fa:
01ed:762a	mov	ax, cs
01ed:762c	mov	ds, ax
01ed:762e	mov	ah, 9
01ed:7630	int	0x21
        	loc_9502:
01ed:7632	jmp	loc_9502
sub_944b ENDP
*/
void sub_944b()
{
    // coverage: 0x877b-0x87a2 method sub_944b
    // coverage: 0x882a-0x8834 method sub_944b
    push(ds);
    dx = 0x1228;
    ds = dx;
    if (al < 0x10)
        goto loc_945b;
    dx = 0x7676;
    goto loc_94fa;
loc_945b:
    ax += ax;
    ax += ax;
    bx = 0x1228;
    ds = bx;
    bx = 0x4cf2;
    bx += ax;
    memoryASet16(ds, bx, si);
    ax = es;
    memoryASet16(ds, bx + 2, ax);
    ds = pop();
    return;
    //   gap of 136 bytes
loc_94fa:
    ax = cs;
    ds = ax;
    ah = 0x09;
    interrupt(0x21);
loc_9502:
    goto loc_9502;
}
/* Assembly listing of 01ed:75a2 sub_9472()
sub_9472 PROC
01ed:75a2	push	bp
01ed:75a3	mov	bp, sp
01ed:75a5	mov	ax, word ptr [bp + 4]
01ed:75a8	pop	bp
01ed:75a9	push	ds
01ed:75aa	push	es
01ed:75ab	push	si
01ed:75ac	push	di
01ed:75ad	mov	dx, 0x1228
01ed:75b0	mov	ds, dx
01ed:75b2	xor	ah, ah
01ed:75b4	cmp	ax, 0x10
01ed:75b7	jb	loc_948f
01ed:75b9	mov	dx, 0x76c8
01ed:75bc	jmp	loc_94fa
01ed:75be		
        	loc_948f:
01ed:75bf	add	ax, ax
01ed:75c1	add	ax, ax
01ed:75c3	mov	bx, 0x4cf2
01ed:75c6	add	bx, ax
01ed:75c8	les	si, ptr [bx]
01ed:75ca	mov	ax, es
01ed:75cc	or	ax, si
01ed:75ce	jne	loc_94a5
01ed:75d0	mov	dx, 0x7634
01ed:75d3	jmp	loc_94fa
        	loc_94a5:
01ed:75d5	mov	dx, 0
        	loc_94a8:
01ed:75d8	mov	al, byte ptr es:[si]
01ed:75db	inc	si
01ed:75dc	cmp	al, 0xfd
01ed:75de	jae	loc_94bb
01ed:75e0	push	dx
01ed:75e1	push	si
01ed:75e2	call	0x773c
01ed:75e5	pop	si
01ed:75e6	pop	dx
01ed:75e7	or	dl, ch
01ed:75e9	jmp	loc_94a8
        	loc_94bb:
01ed:75eb	cmp	al, 0xff
01ed:75ed	je	loc_94f1
01ed:75ef	push	ds
01ed:75f0	mov	ax, 0x1228
01ed:75f3	mov	ds, ax
01ed:75f5	mov	bx, word ptr [0x4d42]
        	loc_94c9:
01ed:75f9	mov	al, byte ptr es:[si]
01ed:75fc	inc	si
01ed:75fd	cmp	al, 0xfd
01ed:75ff	jae	loc_94e6
01ed:7601	mov	dh, al
        	loc_94d3:
01ed:7603	mov	al, byte ptr es:[si]
01ed:7606	inc	si
01ed:7607	cmp	al, 0xfd
01ed:7609	jae	loc_94e6
01ed:760b	and	al, 0x7f
01ed:760d	xlatb	
01ed:760e	and	al, al
01ed:7610	je	loc_94d3
01ed:7612	or	dl, dh
01ed:7614	jmp	loc_94d3
        	loc_94e6:
01ed:7616	cmp	al, 0xfe
01ed:7618	je	loc_94f0
01ed:761a	cmp	al, 0xff
01ed:761c	jne	loc_94c9
01ed:761e	jmp	loc_94f1
        	loc_94f0:
01ed:7620	pop	ds
        	loc_94f1:
01ed:7621	pop	di
01ed:7622	pop	si
01ed:7623	pop	es
01ed:7624	pop	ds
01ed:7625	mov	al, dl
01ed:7627	xor	ah, ah
01ed:7629	ret	
        	loc_94fa:
01ed:762a	mov	ax, cs
01ed:762c	mov	ds, ax
01ed:762e	mov	ah, 9
01ed:7630	int	0x21
        	loc_9502:
01ed:7632	jmp	loc_9502
sub_9472 ENDP
*/
void sub_9472()
{
    // coverage: 0x87a2-0x8834 method sub_9472
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(ds);
    push(es);
    push(si);
    push(di);
    dx = 0x1228;
    ds = dx;
    ah = 0;
    if (ax < 0x0010)
        goto loc_948f;
    dx = 0x76c8;
    goto loc_94fa;
loc_948f:
    ax += ax;
    ax += ax;
    bx = 0x4cf2;
    bx += ax;
    si = memoryAGet16(ds, bx);
    es = memoryAGet16(ds, bx + 2);
    ax = es;
    ax |= si;
    if (ax)
        goto loc_94a5;
    dx = 0x7634;
    goto loc_94fa;
loc_94a5:
    dx = 0x0000;
loc_94a8:
    al = memoryAGet(es, si);
    si++;
    if (al >= 0xfd)
        goto loc_94bb;
    push(dx);
    push(si);
    sub_960c();
    si = pop();
    dx = pop();
    dl |= ch;
    goto loc_94a8;
loc_94bb:
    if (al == 0xff)
        goto loc_94f1;
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx = memoryAGet16(ds, 0x4d42);
loc_94c9:
    al = memoryAGet(es, si);
    si++;
    if (al >= 0xfd)
        goto loc_94e6;
    dh = al;
loc_94d3:
    al = memoryAGet(es, si);
    si++;
    if (al >= 0xfd)
        goto loc_94e6;
    al &= 0x7f;
    al = memoryAGet(ds, bx+al);
    if (al == 0)
        goto loc_94d3;
    dl |= dh;
    goto loc_94d3;
loc_94e6:
    if (al == 0xfe)
        goto loc_94f0;
    if (al != 0xff)
        goto loc_94c9;
    goto loc_94f1;
loc_94f0:
    ds = pop();
loc_94f1:
    di = pop();
    si = pop();
    es = pop();
    ds = pop();
    al = dl;
    ah = 0;
    assert(pop() == 0x7777);
    return;
loc_94fa:
    ax = cs;
    ds = ax;
    ah = 0x09;
    interrupt(0x21);
loc_9502:
    goto loc_9502;
}
/* Assembly listing of 01ed:773c sub_960c()
sub_960c PROC
01ed:773c	push	ds
01ed:773d	mov	bx, 0x1228
01ed:7740	mov	ds, bx
01ed:7742	push	ax
01ed:7743	call	0x7861
01ed:7746	pop	bx
01ed:7747	xor	ch, ch
01ed:7749	cmp	ax, 0xffff
01ed:774c	je	loc_9665
01ed:774e	and	bx, 1
01ed:7751	je	loc_9667
01ed:7753	cmp	ah, byte ptr [0x4d3b]
01ed:7757	jae	loc_962e
01ed:7759	or	ch, 4
01ed:775c	jmp	loc_9637
        	loc_962e:
01ed:775e	cmp	ah, byte ptr [0x4d3d]
01ed:7762	jb	loc_9637
01ed:7764	or	ch, 8
        	loc_9637:
01ed:7767	cmp	al, byte ptr [0x4d3a]
01ed:776b	jae	loc_9642
01ed:776d	or	ch, 1
01ed:7770	jmp	loc_964b
        	loc_9642:
01ed:7772	cmp	al, byte ptr [0x4d3c]
01ed:7776	jb	loc_964b
01ed:7778	or	ch, 2
        	loc_964b:
01ed:777b	mov	dx, 0x201
01ed:777e	in	al, dx
01ed:777f	not	al
01ed:7781	test	al, 0x40
01ed:7783	je	loc_9658
01ed:7785	or	ch, 0x10
        	loc_9658:
01ed:7788	test	al, 0x80
01ed:778a	je	loc_965f
01ed:778c	or	ch, 0x20
        	loc_965f:
01ed:778f	mov	byte ptr [0x4d35], ch
01ed:7793	jmp	loc_9665
        	loc_9665:
01ed:7795	pop	ds
01ed:7796	ret	
        	loc_9667:
01ed:7797	cmp	ah, byte ptr [0x4d37]
01ed:779b	jae	loc_9672
01ed:779d	or	ch, 4
01ed:77a0	jmp	loc_967b
        	loc_9672:
01ed:77a2	cmp	ah, byte ptr [0x4d39]
01ed:77a6	jb	loc_967b
01ed:77a8	or	ch, 8
        	loc_967b:
01ed:77ab	cmp	al, byte ptr [0x4d36]
01ed:77af	jae	loc_9686
01ed:77b1	or	ch, 1
01ed:77b4	jmp	loc_968f
        	loc_9686:
01ed:77b6	cmp	al, byte ptr [0x4d38]
01ed:77ba	jb	loc_968f
01ed:77bc	or	ch, 2
        	loc_968f:
01ed:77bf	mov	dx, 0x201
01ed:77c2	in	al, dx
01ed:77c3	not	al
01ed:77c5	test	al, 0x10
01ed:77c7	je	loc_969c
01ed:77c9	or	ch, 0x10
        	loc_969c:
01ed:77cc	test	al, 0x20
01ed:77ce	je	loc_96a3
01ed:77d0	or	ch, 0x20
        	loc_96a3:
01ed:77d3	mov	byte ptr [0x4d34], ch
01ed:77d7	jmp	loc_9665
sub_960c ENDP
*/
void sub_960c()
{
    // coverage: 0x893c-0x89d9 method sub_960c
    push(ds);
    bx = 0x1228;
    ds = bx;
    push(ax);
    sub_9731();
    bx = pop();
    ch = 0;
    if (ax == 0xffff)
        goto loc_9665;
    bx &= 0x0001;
    if (bx == 0)
        goto loc_9667;
    if (ah >= memoryAGet(ds, 0x4d3b))
        goto loc_962e;
    ch |= 0x04;
    goto loc_9637;
loc_962e:
    if (ah < memoryAGet(ds, 0x4d3d))
        goto loc_9637;
    ch |= 0x08;
loc_9637:
    if (al >= memoryAGet(ds, 0x4d3a))
        goto loc_9642;
    ch |= 0x01;
    goto loc_964b;
loc_9642:
    if (al < memoryAGet(ds, 0x4d3c))
        goto loc_964b;
    ch |= 0x02;
loc_964b:
    dx = 0x0201;
    in(al, dx);
    al = ~al;
    if (!(al & 0x40))
        goto loc_9658;
    ch |= 0x10;
loc_9658:
    if (!(al & 0x80))
        goto loc_965f;
    ch |= 0x20;
loc_965f:
    memoryASet(ds, 0x4d35, ch);
loc_9665:
    ds = pop();
    return;
loc_9667:
    if (ah >= memoryAGet(ds, 0x4d37))
        goto loc_9672;
    ch |= 0x04;
    goto loc_967b;
loc_9672:
    if (ah < memoryAGet(ds, 0x4d39))
        goto loc_967b;
    ch |= 0x08;
loc_967b:
    if (al >= memoryAGet(ds, 0x4d36))
        goto loc_9686;
    ch |= 0x01;
    goto loc_968f;
loc_9686:
    if (al < memoryAGet(ds, 0x4d38))
        goto loc_968f;
    ch |= 0x02;
loc_968f:
    dx = 0x0201;
    in(al, dx);
    al = ~al;
    if (!(al & 0x10))
        goto loc_969c;
    ch |= 0x10;
loc_969c:
    if (!(al & 0x20))
        goto loc_96a3;
    ch |= 0x20;
loc_96a3:
    memoryASet(ds, 0x4d34, ch);
    goto loc_9665;
}
/* Assembly listing of 01ed:77d9 sub_96a9()
sub_96a9 PROC
01ed:77d9	push	ds
01ed:77da	mov	bx, 0x1228
01ed:77dd	mov	ds, bx
01ed:77df	mov	bx, 0x4dca
01ed:77e2	and	ax, ax
01ed:77e4	je	loc_96b9
01ed:77e6	mov	bx, 0x4dcb
        	loc_96b9:
01ed:77e9	mov	cl, 1
01ed:77eb	mov	byte ptr [bx], cl
01ed:77ed	mov	bx, ax
01ed:77ef	push	ax
01ed:77f0	push	bx
01ed:77f1	call	0x7861
01ed:77f4	pop	bx
01ed:77f5	pop	cx
01ed:77f6	cmp	ax, 0xffff
01ed:77f9	je	loc_971a
01ed:77fb	cmp	ah, 2
01ed:77fe	jb	loc_970e
01ed:7800	cmp	al, 2
01ed:7802	jb	loc_970e
01ed:7804	mov	cx, ax
01ed:7806	shr	al, 1
01ed:7808	shr	ah, 1
01ed:780a	mov	dx, ax
01ed:780c	add	cx, cx
01ed:780e	sub	cx, dx
01ed:7810	mov	ax, 0x1228
01ed:7813	mov	ds, ax
01ed:7815	and	bx, 1
01ed:7818	je	loc_96fc
01ed:781a	mov	byte ptr [0x4d3a], dl
01ed:781e	mov	byte ptr [0x4d3b], dh
01ed:7822	mov	byte ptr [0x4d3c], cl
01ed:7826	mov	byte ptr [0x4d3d], ch
01ed:782a	jmp	loc_970c
        	loc_96fc:
01ed:782c	mov	byte ptr [0x4d36], dl
01ed:7830	mov	byte ptr [0x4d37], dh
01ed:7834	mov	byte ptr [0x4d38], cl
01ed:7838	mov	byte ptr [0x4d39], ch
        	loc_970c:
01ed:783c	pop	ds
01ed:783d	ret	
        	loc_970e:
01ed:783e	push	cx
01ed:783f	mov	cx, 0
        	loc_9712:
01ed:7842	loop	loc_9712
01ed:7844	pop	cx
01ed:7845	mov	ax, 0xffff
01ed:7848	jmp	loc_971c
        	loc_971a:
01ed:784a	xor	al, al
        	loc_971c:
01ed:784c	mov	bx, 0x4dca
01ed:784f	and	cx, cx
01ed:7851	je	loc_9726
01ed:7853	mov	bx, 0x4dcb
        	loc_9726:
01ed:7856	mov	byte ptr [bx], al
01ed:7858	jmp	loc_970c
sub_96a9 ENDP
*/
void sub_96a9()
{
    // coverage: 0x89d9-0x8a5a method sub_96a9
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = 0x4dca;
    if (ax == 0)
        goto loc_96b9;
    bx = 0x4dcb;
loc_96b9:
    cl = 0x01;
    memoryASet(ds, bx, cl);
    bx = ax;
    push(ax);
    push(bx);
    sub_9731();
    bx = pop();
    cx = pop();
    if (ax == 0xffff)
        goto loc_971a;
    if (ah < 0x02)
        goto loc_970e;
    if (al < 0x02)
        goto loc_970e;
    cx = ax;
    al >>= 1;
    ah >>= 1;
    dx = ax;
    cx += cx;
    cx -= dx;
    ax = 0x1228;
    ds = ax;
    bx &= 0x0001;
    if (bx == 0)
        goto loc_96fc;
    memoryASet(ds, 0x4d3a, dl);
    memoryASet(ds, 0x4d3b, dh);
    memoryASet(ds, 0x4d3c, cl);
    memoryASet(ds, 0x4d3d, ch);
    goto loc_970c;
loc_96fc:
    memoryASet(ds, 0x4d36, dl);
    memoryASet(ds, 0x4d37, dh);
    memoryASet(ds, 0x4d38, cl);
    memoryASet(ds, 0x4d39, ch);
loc_970c:
    ds = pop();
    return;
loc_970e:
    push(cx);
    cx = 0x0000;
loc_9712:
    if (--cx)
        goto loc_9712;
    cx = pop();
    ax = 0xffff;
    goto loc_971c;
loc_971a:
    al = 0;
loc_971c:
    bx = 0x4dca;
    if (cx == 0)
        goto loc_9726;
    bx = 0x4dcb;
loc_9726:
    memoryASet(ds, bx, al);
    goto loc_970c;
}
/* Assembly listing of 01ed:7861 sub_9731()
sub_9731 PROC
01ed:7861	pushf	
01ed:7862	cli	
01ed:7863	push	ds
01ed:7864	mov	bx, 0x1228
01ed:7867	mov	ds, bx
01ed:7869	and	al, 1
01ed:786b	je	loc_9751
01ed:786d	mov	bx, 0x408
01ed:7870	mov	al, byte ptr [0x4dcb]
01ed:7873	dec	al
01ed:7875	je	loc_9765
01ed:7877	inc	al
01ed:7879	je	loc_974e
01ed:787b	jmp	loc_97fe
        	loc_974e:
01ed:787e	jmp	loc_9837
        	loc_9751:
01ed:7881	mov	bx, 0x102
01ed:7884	mov	al, byte ptr [0x4dca]
01ed:7887	dec	al
01ed:7889	je	loc_9765
01ed:788b	inc	al
01ed:788d	je	loc_9762
01ed:788f	jmp	loc_97fe
        	loc_9762:
01ed:7892	jmp	loc_9823
        	loc_9765:
01ed:7895	mov	dx, 0x201
01ed:7898	xor	cx, cx
        	loc_976a:
01ed:789a	in	al, dx
01ed:789b	test	bl, al
01ed:789d	loopne	loc_976a
01ed:789f	jcxz	loc_9775
01ed:78a1	test	bh, al
01ed:78a3	loopne	loc_976a
        	loc_9775:
01ed:78a5	jcxz	loc_9779
01ed:78a7	jmp	loc_977c
        	loc_9779:
01ed:78a9	jmp	loc_97fe
        	loc_977c:
01ed:78ac	mov	dx, 0x201
01ed:78af	out	dx, al
01ed:78b0	in	al, dx
01ed:78b1	test	bh, al
01ed:78b3	jne	loc_97aa
01ed:78b5	test	bl, al
01ed:78b7	jne	loc_97aa
01ed:78b9	mov	al, 6
01ed:78bb	out	0x43, al
01ed:78bd	push	cx
01ed:78be	mov	cx, 0x64
        	loc_9791:
01ed:78c1	loop	loc_9791
01ed:78c3	pop	cx
        	loc_9794:
01ed:78c4	in	al, 0x40
01ed:78c6	mov	ah, al
01ed:78c8	in	al, 0x40
01ed:78ca	and	ah, 0x10
01ed:78cd	je	loc_9794
        	loc_979f:
01ed:78cf	in	al, 0x40
01ed:78d1	mov	ah, al
01ed:78d3	in	al, 0x40
01ed:78d5	and	ah, 0x10
01ed:78d8	jne	loc_979f
        	loc_97aa:
01ed:78da	xor	cx, cx
01ed:78dc	mov	word ptr [0x4d32], cx
01ed:78e0	mov	cx, 0x3e8
        	loc_97b3:
01ed:78e3	in	al, 0x40
01ed:78e5	mov	ah, al
01ed:78e7	in	al, 0x40
01ed:78e9	and	ah, 0x10
01ed:78ec	je	loc_97b3
01ed:78ee	inc	word ptr [0x4d32]
01ed:78f2	in	al, dx
01ed:78f3	and	bl, bl
01ed:78f5	je	loc_97cf
01ed:78f7	test	bl, al
01ed:78f9	je	loc_97f0
01ed:78fb	and	bh, bh
01ed:78fd	je	loc_97d3
        	loc_97cf:
01ed:78ff	test	bh, al
01ed:7901	je	loc_97e2
        	loc_97d3:
01ed:7903	in	al, 0x40
01ed:7905	mov	ah, al
01ed:7907	in	al, 0x40
01ed:7909	test	ah, 0x10
01ed:790c	jne	loc_97d3
01ed:790e	loop	loc_97b3
01ed:7910	jmp	loc_97fe
        	loc_97e2:
01ed:7912	mov	ax, word ptr [0x4d32]
01ed:7915	mov	word ptr [0x4dc6], ax
01ed:7918	xor	bh, bh
01ed:791a	and	bl, bl
01ed:791c	je	loc_9803
01ed:791e	jmp	loc_97d3
        	loc_97f0:
01ed:7920	mov	ax, word ptr [0x4d32]
01ed:7923	mov	word ptr [0x4dc8], ax
01ed:7926	xor	bl, bl
01ed:7928	and	bh, bh
01ed:792a	je	loc_9803
01ed:792c	jmp	loc_97d3
        	loc_97fe:
01ed:792e	mov	ax, 0xffff
01ed:7931	jmp	loc_9820
        	loc_9803:
01ed:7933	mov	dx, word ptr [0x4dc6]
01ed:7937	and	dx, dx
01ed:7939	jns	loc_980d
01ed:793b	xor	dx, dx
        	loc_980d:
01ed:793d	mov	cl, 1
01ed:793f	shr	dx, cl
01ed:7941	mov	ax, word ptr [0x4dc8]
01ed:7944	and	ax, ax
01ed:7946	jns	loc_981a
01ed:7948	xor	ax, ax
        	loc_981a:
01ed:794a	mov	cl, 1
01ed:794c	shr	ax, cl
01ed:794e	mov	ah, dl
        	loc_9820:
01ed:7950	pop	ds
01ed:7951	popf	
01ed:7952	ret	
        	loc_9823:
01ed:7953	mov	dx, 0x201
01ed:7956	in	al, dx
01ed:7957	and	al, 3
01ed:7959	jne	loc_97fe
01ed:795b	mov	al, 1
01ed:795d	mov	byte ptr [0x4dca], al
01ed:7960	mov	ax, 0
01ed:7963	jmp	loc_9847
        	loc_9835:
01ed:7965	jmp	loc_97fe
        	loc_9837:
01ed:7967	mov	dx, 0x201
01ed:796a	in	al, dx
01ed:796b	and	al, 0xc
01ed:796d	jne	loc_9835
01ed:796f	mov	al, 1
01ed:7971	mov	byte ptr [0x4dcb], al
01ed:7974	mov	ax, 1
        	loc_9847:
01ed:7977	push	bx
01ed:7978	push	ax
01ed:7979	mov	ax, 0xffff
01ed:797c	cmp	ax, 0xffff
01ed:797f	pop	ax
01ed:7980	pop	bx
01ed:7981	je	loc_9835
01ed:7983	push	bx
01ed:7984	call	0x7861
01ed:7987	pop	bx
01ed:7988	jmp	loc_9820
sub_9731 ENDP
*/
void sub_9731()
{
    // coverage: 0x8a61-0x8b8a method sub_9731
    tx = flags.carry | (flags.zero << 1);
    push(tx);
    flags.interrupts = false;
    push(ds);
    bx = 0x1228;
    ds = bx;
    al &= 0x01;
    if (al == 0)
        goto loc_9751;
    bx = 0x0408;
    al = memoryAGet(ds, 0x4dcb);
    tl = al;
    al--;
    if (tl == 1)
        goto loc_9765;
    al++;
    if (al == 0)
        goto loc_974e;
    goto loc_97fe;
loc_974e:
    goto loc_9837;
loc_9751:
    bx = 0x0102;
    al = memoryAGet(ds, 0x4dca);
    tl = al;
    al--;
    if (tl == 1)
        goto loc_9765;
    al++;
    if (al == 0)
        goto loc_9762;
    goto loc_97fe;
loc_9762:
    goto loc_9823;
loc_9765:
    dx = 0x0201;
    cx = 0;
loc_976a:
    in(al, dx);
    if (--cx && bl & al)
        goto loc_976a;
    if (cx == 0)
        goto loc_9775;
    if (--cx && bh & al)
        goto loc_976a;
loc_9775:
    if (cx == 0)
        goto loc_9779;
    goto loc_977c;
loc_9779:
    goto loc_97fe;
loc_977c:
    dx = 0x0201;
    out(dx, al);
    in(al, dx);
    if (bh & al)
        goto loc_97aa;
    if (bl & al)
        goto loc_97aa;
    al = 0x06;
    out(0x43, al);
    push(cx);
    cx = 0x0064;
loc_9791:
    if (--cx)
        goto loc_9791;
    cx = pop();
loc_9794:
    in(al, 0x40);
    ah = al;
    in(al, 0x40);
    ah &= 0x10;
    if (ah == 0)
        goto loc_9794;
loc_979f:
    in(al, 0x40);
    ah = al;
    in(al, 0x40);
    ah &= 0x10;
    if (ah != 0)
        goto loc_979f;
loc_97aa:
    cx = 0;
    memoryASet16(ds, 0x4d32, cx);
    cx = 0x03e8;
loc_97b3:
    in(al, 0x40);
    ah = al;
    in(al, 0x40);
    ah &= 0x10;
    if (ah == 0)
        goto loc_97b3;
    memoryASet16(ds, 0x4d32, memoryAGet16(ds, 0x4d32) + 1);
    in(al, dx);
    if (bl == 0)
        goto loc_97cf;
    if (!(bl & al))
        goto loc_97f0;
    if (bh == 0)
        goto loc_97d3;
loc_97cf:
    if (!(bh & al))
        goto loc_97e2;
loc_97d3:
    in(al, 0x40);
    ah = al;
    in(al, 0x40);
    if (ah & 0x10)
        goto loc_97d3;
    if (--cx)
        goto loc_97b3;
    goto loc_97fe;
loc_97e2:
    ax = memoryAGet16(ds, 0x4d32);
    memoryASet16(ds, 0x4dc6, ax);
    bh = 0;
    if (bl == 0)
        goto loc_9803;
    goto loc_97d3;
loc_97f0:
    ax = memoryAGet16(ds, 0x4d32);
    memoryASet16(ds, 0x4dc8, ax);
    bl = 0;
    if (bh == 0)
        goto loc_9803;
    goto loc_97d3;
loc_97fe:
    ax = 0xffff;
    goto loc_9820;
loc_9803:
    dx = memoryAGet16(ds, 0x4dc6);
    if ((short)dx >= 0)
        goto loc_980d;
    dx = 0;
loc_980d:
    cl = 0x01;
    dx >>= cl;
    ax = memoryAGet16(ds, 0x4dc8);
    if ((short)ax >= 0)
        goto loc_981a;
    ax = 0;
loc_981a:
    cl = 0x01;
    ax >>= cl;
    ah = dl;
loc_9820:
    ds = pop();
    tx = pop();
    flags.carry = tx & 1;
    flags.zero = (tx << 1) & 1;
    return;
loc_9823:
    dx = 0x0201;
    in(al, dx);
    al &= 0x03;
    if (al != 0)
        goto loc_97fe;
    al = 0x01;
    memoryASet(ds, 0x4dca, al);
    ax = 0x0000;
    goto loc_9847;
loc_9835:
    goto loc_97fe;
loc_9837:
    dx = 0x0201;
    in(al, dx);
    al &= 0x0c;
    if (al != 0)
        goto loc_9835;
    al = 0x01;
    memoryASet(ds, 0x4dcb, al);
    ax = 0x0001;
loc_9847:
    push(bx);
    push(ax);
    ax = 0xffff;
    ax = pop();
    bx = pop();
    if (ax == 0xffff)
        goto loc_9835;
    push(bx);
    sub_9731();
    bx = pop();
    goto loc_9820;
}
/* Assembly listing of 01ed:798a sub_985a()
sub_985a PROC
01ed:798a	push	si
01ed:798b	push	di
01ed:798c	push	ds
01ed:798d	push	es
01ed:798e	mov	ax, 0x1228
01ed:7991	mov	ds, ax
01ed:7993	mov	es, ax
01ed:7995	cld	
01ed:7996	mov	di, word ptr [0x4d42]
01ed:799a	mov	cx, 0x40
01ed:799d	mov	ax, 0
01ed:79a0	rep stosw	word ptr es:[di], ax
01ed:79a2	pop	es
01ed:79a3	call	0x7b01
01ed:79a6	mov	ax, word ptr [0x4dc4]
01ed:79a9	and	ax, ax
01ed:79ab	jne	loc_98b2
01ed:79ad	inc	ax
01ed:79ae	mov	word ptr [0x4dc4], ax
01ed:79b1	push	ds
01ed:79b2	push	es
01ed:79b3	mov	al, 9
01ed:79b5	mov	ah, 0x35
01ed:79b7	int	0x21
01ed:79b9	mov	dx, es
01ed:79bb	mov	ax, 0x1ed
01ed:79be	mov	es, ax
01ed:79c0	mov	word ptr [0x4d3e], bx
01ed:79c4	mov	word ptr es:[0x7a6d], bx
01ed:79c9	mov	word ptr [0x4d40], dx
01ed:79cd	mov	word ptr es:[0x7a6f], dx
01ed:79d2	mov	dx, 0x79e6
01ed:79d5	mov	bx, 0x1ed
01ed:79d8	mov	ds, bx
01ed:79da	mov	al, 9
01ed:79dc	mov	ah, 0x25
01ed:79de	int	0x21
01ed:79e0	pop	es
01ed:79e1	pop	ds
        	loc_98b2:
01ed:79e2	pop	ds
01ed:79e3	pop	di
01ed:79e4	pop	si
01ed:79e5	ret	
sub_985a ENDP
*/
void sub_985a()
{
    // coverage: 0x8b8a-0x8be6 method sub_985a
    push(si);
    push(di);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    es = ax;
    flags.direction = false;
    di = memoryAGet16(ds, 0x4d42);
    cx = 0x0040;
    ax = 0x0000;
    rep_stosw<MemAuto, DirAuto>();
    es = pop();
    sub_99d1();
    ax = memoryAGet16(ds, 0x4dc4);
    if (ax != 0)
        goto loc_98b2;
    ax++;
    memoryASet16(ds, 0x4dc4, ax);
    push(ds);
    push(es);
    al = 0x09;
    ah = 0x35;
    interrupt(0x21);
    dx = es;
    ax = 0x01ed;
    es = ax;
    memoryASet16(ds, 0x4d3e, bx);
    memoryASet16(es, 0x7a6d, bx);
    memoryASet16(ds, 0x4d40, dx);
    memoryASet16(es, 0x7a6f, dx);
    dx = 0x79e6;
    bx = 0x01ed;
    ds = bx;
    al = 0x09;
    ah = 0x25;
    interrupt(0x21);
    es = pop();
    ds = pop();
loc_98b2:
    ds = pop();
    di = pop();
    si = pop();
}
/* Assembly listing of 01ed:7a77 sub_9947()
sub_9947 PROC
01ed:7a77	push	si
01ed:7a78	push	di
01ed:7a79	push	ds
01ed:7a7a	mov	ax, 0x1228
01ed:7a7d	mov	ds, ax
01ed:7a7f	mov	ax, word ptr [0x4dc4]
01ed:7a82	and	ax, ax
01ed:7a84	je	loc_9980
01ed:7a86	xor	ax, ax
01ed:7a88	mov	word ptr [0x4dc4], ax
01ed:7a8b	push	ds
01ed:7a8c	push	es
01ed:7a8d	mov	dx, word ptr [0x4d3e]
01ed:7a91	mov	bx, word ptr [0x4d40]
01ed:7a95	mov	ds, bx
01ed:7a97	mov	al, 9
01ed:7a99	mov	ah, 0x25
01ed:7a9b	int	0x21
01ed:7a9d	pop	es
01ed:7a9e	pop	ds
01ed:7a9f	call	0x7b01
        	loc_9972:
01ed:7aa2	mov	ah, 0xb
01ed:7aa4	int	0x21
01ed:7aa6	and	al, al
01ed:7aa8	je	loc_9980
01ed:7aaa	mov	ah, 7
01ed:7aac	int	0x21
01ed:7aae	jmp	loc_9972
        	loc_9980:
01ed:7ab0	pop	ds
01ed:7ab1	pop	di
01ed:7ab2	pop	si
01ed:7ab3	ret	
sub_9947 ENDP
*/
void sub_9947()
{
    // coverage: 0x8c77-0x8cb4 method sub_9947
    push(si);
    push(di);
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4dc4);
    if (ax == 0)
        goto loc_9980;
    ax = 0;
    memoryASet16(ds, 0x4dc4, ax);
    push(ds);
    push(es);
    dx = memoryAGet16(ds, 0x4d3e);
    bx = memoryAGet16(ds, 0x4d40);
    ds = bx;
    al = 0x09;
    ah = 0x25;
    interrupt(0x21);
    es = pop();
    ds = pop();
    sub_99d1();
loc_9972:
    ah = 0x0b;
    interrupt(0x21);
    if (al == 0)
        goto loc_9980;
    ah = 0x07;
    interrupt(0x21);
    goto loc_9972;
loc_9980:
    ds = pop();
    di = pop();
    si = pop();
}
/* Assembly listing of 01ed:7ab4 sub_9984()
sub_9984 PROC
01ed:7ab4	push	bp
01ed:7ab5	mov	bp, sp
01ed:7ab7	mov	ax, word ptr [bp + 4]
01ed:7aba	pop	bp
01ed:7abb	push	ds
01ed:7abc	push	bx
01ed:7abd	push	di
01ed:7abe	mov	bx, 0x1228
01ed:7ac1	mov	ds, bx
01ed:7ac3	mov	di, word ptr [0x4d42]
01ed:7ac7	xor	ah, ah
01ed:7ac9	and	al, 0x7f
01ed:7acb	add	di, ax
01ed:7acd	mov	al, byte ptr [di]
01ed:7acf	pop	di
01ed:7ad0	pop	bx
01ed:7ad1	pop	ds
01ed:7ad2	and	ax, ax
01ed:7ad4	ret	
sub_9984 ENDP
*/
void sub_9984()
{
    // coverage: 0x8cb4-0x8cd5 method sub_9984
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(ds);
    push(bx);
    push(di);
    bx = 0x1228;
    ds = bx;
    di = memoryAGet16(ds, 0x4d42);
    ah = 0;
    al &= 0x7f;
    di += ax;
    al = memoryAGet(ds, di);
    di = pop();
    bx = pop();
    ds = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7abb sub_998b()
sub_998b PROC
01ed:7abb	push	ds
01ed:7abc	push	bx
01ed:7abd	push	di
01ed:7abe	mov	bx, 0x1228
01ed:7ac1	mov	ds, bx
01ed:7ac3	mov	di, word ptr [0x4d42]
01ed:7ac7	xor	ah, ah
01ed:7ac9	and	al, 0x7f
01ed:7acb	add	di, ax
01ed:7acd	mov	al, byte ptr [di]
01ed:7acf	pop	di
01ed:7ad0	pop	bx
01ed:7ad1	pop	ds
01ed:7ad2	and	ax, ax
01ed:7ad4	ret	
sub_998b ENDP
*/
void sub_998b()
{
    // coverage: 0x8cbb-0x8cd5 method sub_998b
    push(ds);
    push(bx);
    push(di);
    bx = 0x1228;
    ds = bx;
    di = memoryAGet16(ds, 0x4d42);
    ah = 0;
    al &= 0x7f;
    di += ax;
    al = memoryAGet(ds, di);
    di = pop();
    bx = pop();
    ds = pop();
}
/* Assembly listing of 01ed:7b01 sub_99d1()
sub_99d1 PROC
01ed:7b01	push	ds
01ed:7b02	push	ax
01ed:7b03	push	bx
01ed:7b04	mov	ax, 0x40
01ed:7b07	mov	ds, ax
01ed:7b09	mov	bx, 0x80
01ed:7b0c	mov	ax, word ptr [bx]
01ed:7b0e	mov	bx, 0x1a
01ed:7b11	mov	word ptr [bx], ax
01ed:7b13	mov	word ptr [bx + 2], ax
01ed:7b16	pop	bx
01ed:7b17	pop	ax
01ed:7b18	pop	ds
01ed:7b19	ret	
sub_99d1 ENDP
*/
void sub_99d1()
{
    // coverage: 0x8d01-0x8d1a method sub_99d1
    push(ds);
    push(ax);
    push(bx);
    ax = 0x0040;
    ds = ax;
    bx = 0x0080;
    ax = memoryAGet16(ds, bx);
    bx = 0x001a;
    memoryASet16(ds, bx, ax);
    memoryASet16(ds, bx + 2, ax);
    bx = pop();
    ax = pop();
    ds = pop();
}
/* Assembly listing of 01ed:7b4a sub_9a1a()
sub_9a1a PROC
01ed:7b4a	push	bp
01ed:7b4b	mov	bp, sp
01ed:7b4d	mov	dx, word ptr [bp + 6]
01ed:7b50	mov	ax, word ptr [bp + 4]
01ed:7b53	pop	bp
01ed:7b54	lcall	0xca6, 0x179
01ed:7b59	ret	
sub_9a1a ENDP
*/
void sub_9a1a()
{
    // coverage: 0x8d4a-0x8d5a method sub_9a1a
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_cbd9();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7b5a sub_9a2a()
sub_9a2a PROC
01ed:7b5a	push	bp
01ed:7b5b	mov	bp, sp
01ed:7b5d	mov	di, word ptr [bp + 6]
01ed:7b60	mov	si, word ptr [bp + 4]
01ed:7b63	mov	bx, word ptr [bp + 0xa]
01ed:7b66	mov	ax, word ptr [bp + 8]
01ed:7b69	mov	dx, word ptr [bp + 0xe]
01ed:7b6c	mov	cx, word ptr [bp + 0xc]
01ed:7b6f	pop	bp
01ed:7b70	lcall	0xe15, 0
01ed:7b75	ret	
sub_9a2a ENDP
*/
void sub_9a2a()
{
    // coverage: 0x8d5a-0x8d76 method sub_9a2a
    push(0x7777);
    push(bp);
    bp = sp;
    di = memoryAGet16(ss, bp + 6);
    si = memoryAGet16(ss, bp + 4);
    bx = memoryAGet16(ss, bp + 10);
    ax = memoryAGet16(ss, bp + 8);
    dx = memoryAGet16(ss, bp + 14);
    cx = memoryAGet16(ss, bp + 12);
    bp = pop();
    push(cs);
    cs = 0x0e15;
    sub_e150();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7b93 sub_9a63()
sub_9a63 PROC
01ed:7b93	push	bp
01ed:7b94	mov	bp, sp
01ed:7b96	mov	dx, word ptr [bp + 6]
01ed:7b99	mov	ax, word ptr [bp + 4]
01ed:7b9c	mov	bx, word ptr [bp + 8]
01ed:7b9f	pop	bp
01ed:7ba0	lcall	0xca6, 0x1e1
01ed:7ba5	ret	
sub_9a63 ENDP
*/
void sub_9a63()
{
    // coverage: 0x8d93-0x8da6 method sub_9a63
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bx = memoryAGet16(ss, bp + 8);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_cc41();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7ba7 sub_9a77()
sub_9a77 PROC
01ed:7ba7	lcall	0xca6, 0x1ff
01ed:7bac	ret	
sub_9a77 ENDP
*/
void sub_9a77()
{
    // coverage: 0x8da7-0x8dad method sub_9a77
    push(cs);
    cs = 0x0ca6;
    sub_cc5f();
    assert(cs == 0x01ed);
}
/* Assembly listing of 01ed:7bad sub_9a7d()
sub_9a7d PROC
01ed:7bad	push	bp
01ed:7bae	mov	bp, sp
01ed:7bb0	mov	dx, word ptr [bp + 6]
01ed:7bb3	mov	ax, word ptr [bp + 4]
01ed:7bb6	pop	bp
01ed:7bb7	lcall	0xca6, 0x21b
01ed:7bbc	ret	
sub_9a7d ENDP
*/
void sub_9a7d()
{
    // coverage: 0x8dad-0x8dbd method sub_9a7d
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_cc7b();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7bbd sub_9a8d()
sub_9a8d PROC
01ed:7bbd	push	bp
01ed:7bbe	mov	bp, sp
01ed:7bc0	mov	cl, byte ptr [bp + 4]
01ed:7bc3	pop	bp
01ed:7bc4	lcall	0xca6, 0x232
01ed:7bc9	ret	
sub_9a8d ENDP
*/
void sub_9a8d()
{
    // coverage: 0x8dbd-0x8dca method sub_9a8d
    push(0x7777);
    push(bp);
    bp = sp;
    cl = memoryAGet(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_cc92();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7bca sub_9a9a()
sub_9a9a PROC
01ed:7bca	push	bp
01ed:7bcb	mov	bp, sp
01ed:7bcd	mov	bx, word ptr [bp + 4]
01ed:7bd0	pop	bp
01ed:7bd1	lcall	0xca6, 0x2b1
01ed:7bd6	ret	
sub_9a9a ENDP
*/
void sub_9a9a()
{
    // coverage: 0x8dca-0x8dd7 method sub_9a9a
    push(0x7777);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_cd11();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7bd7 sub_9aa7()
sub_9aa7 PROC
01ed:7bd7	lcall	0xca6, 0x2ce
01ed:7bdc	ret	
sub_9aa7 ENDP
*/
void sub_9aa7()
{
    // coverage: 0x8dd7-0x8ddd method sub_9aa7
    push(cs);
    cs = 0x0ca6;
    sub_cd2e();
    assert(cs == 0x01ed);
}
/* Assembly listing of 01ed:7bdd sub_9aad()
sub_9aad PROC
01ed:7bdd	push	bp
01ed:7bde	mov	bp, sp
01ed:7be0	mov	bx, word ptr [bp + 4]
01ed:7be3	pop	bp
01ed:7be4	lcall	0xca6, 0x351
01ed:7be9	ret	
sub_9aad ENDP
*/
void sub_9aad()
{
    // coverage: 0x8ddd-0x8dea method sub_9aad
    push(0x7777);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_cdb1();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
// INJECT: Error: cannot inject zero flag in sub_9aca() because no traceback!
/* Assembly listing of 01ed:7bfa sub_9aca()
sub_9aca PROC
01ed:7bfa	call	0x7abb
01ed:7bfd	retf	
sub_9aca ENDP
*/
void sub_9aca()
{
    // coverage: 0x8dfa-0x8dfe method sub_9aca
    sub_998b();
    stop(/*inject ret*/);
    cs = pop();
}
/* Assembly listing of 01ed:7cde sub_9bae()
sub_9bae PROC
01ed:7cde	mov	al, byte ptr [0x54d4]
01ed:7ce1	xor	ah, ah
01ed:7ce3	and	al, al
01ed:7ce5	je	loc_9bba
01ed:7ce7	jmp	loc_9c81
        	loc_9bba:
01ed:7cea	call	0x7fb0
01ed:7ced	mov	word ptr [0x54d6], ax
01ed:7cf0	mov	cx, 6
        	loc_9bc3:
01ed:7cf3	push	cx
01ed:7cf4	mov	ax, 0
01ed:7cf7	mov	bx, cx
01ed:7cf9	dec	bx
01ed:7cfa	call	0x7e62
01ed:7cfd	pop	cx
01ed:7cfe	loop	loc_9bc3
01ed:7d00	mov	bx, 0x54f6
01ed:7d03	mov	cx, 0x10
01ed:7d06	xor	ax, ax
        	loc_9bd8:
01ed:7d08	mov	word ptr [bx], ax
01ed:7d0a	add	bx, 2
01ed:7d0d	loop	loc_9bd8
01ed:7d0f	mov	bx, 0x5516
01ed:7d12	mov	cx, 0x10
01ed:7d15	mov	ax, 0xffff
        	loc_9be8:
01ed:7d18	mov	word ptr [bx], ax
01ed:7d1a	add	bx, 2
01ed:7d1d	loop	loc_9be8
01ed:7d1f	mov	cx, 0x12
01ed:7d22	mov	ax, word ptr [0x54d6]
01ed:7d25	and	ax, ax
01ed:7d27	je	loc_9c22
01ed:7d29	cmp	ax, 0xf800
01ed:7d2c	jae	loc_9c22
01ed:7d2e	cmp	ax, 0x951
01ed:7d31	jb	loc_9c22
01ed:7d33	mov	cx, ax
01ed:7d35	shr	cx, 1
01ed:7d37	shr	cx, 1
01ed:7d39	mov	ax, 0xffff
01ed:7d3c	xor	dx, dx
01ed:7d3e	div	cx
01ed:7d40	add	ax, ax
01ed:7d42	mov	cx, ax
01ed:7d44	add	ax, ax
01ed:7d46	add	ax, ax
01ed:7d48	add	ax, ax
01ed:7d4a	add	ax, cx
01ed:7d4c	shr	ax, 1
01ed:7d4e	shr	ax, 1
01ed:7d50	mov	cx, ax
        	loc_9c22:
01ed:7d52	mov	ax, cx
01ed:7d54	mov	bx, 0
01ed:7d57	mov	dx, 0x1ed
01ed:7d5a	mov	cx, 0x7e7a
01ed:7d5d	call	0x7e62
01ed:7d60	mov	ax, 0x32
01ed:7d63	mov	bx, 1
01ed:7d66	mov	dx, 0x1ed
01ed:7d69	mov	cx, 0x7e80
01ed:7d6c	call	0x7e62
01ed:7d6f	push	es
01ed:7d70	mov	ah, 0x35
01ed:7d72	mov	al, 8
01ed:7d74	int	0x21
01ed:7d76	mov	word ptr [0x54d0], bx
01ed:7d7a	mov	bx, es
01ed:7d7c	mov	word ptr [0x54d2], bx
01ed:7d80	pop	es
01ed:7d81	mov	ax, 1
01ed:7d84	mov	byte ptr [0x54d4], al
01ed:7d87	pushf	
01ed:7d88	cli	
01ed:7d89	push	ds
01ed:7d8a	mov	ax, 0x1ed
01ed:7d8d	mov	ds, ax
01ed:7d8f	mov	dx, 0x7c02
01ed:7d92	mov	ah, 0x25
01ed:7d94	mov	al, 8
01ed:7d96	int	0x21
01ed:7d98	pop	ds
01ed:7d99	popf	
01ed:7d9a	call	0x7db2
01ed:7d9d	push	es
01ed:7d9e	mov	ax, 0x350f
01ed:7da1	int	0x21
01ed:7da3	mov	word ptr [0x54d8], bx
01ed:7da7	mov	bx, es
01ed:7da9	mov	word ptr [0x54da], bx
01ed:7dad	pop	es
01ed:7dae	mov	ax, 1
        	loc_9c81:
01ed:7db1	ret	
sub_9bae ENDP
*/
void sub_9bae()
{
    // coverage: 0x8ede-0x8fb2 method sub_9bae
    al = memoryAGet(ds, 0x54d4);
    ah = 0;
    if (al == 0)
        goto loc_9bba;
    return;
loc_9bba:
    sub_9e80();
    memoryASet16(ds, 0x54d6, ax);
    cx = 0x0006;
loc_9bc3:
    push(cx);
    ax = 0x0000;
    bx = cx;
    bx--;
    sub_9d32();
    cx = pop();
    if (--cx)
        goto loc_9bc3;
    bx = 0x54f6;
    cx = 0x0010;
    ax = 0;
loc_9bd8:
    memoryASet16(ds, bx, ax);
    bx += 0x0002;
    if (--cx)
        goto loc_9bd8;
    bx = 0x5516;
    cx = 0x0010;
    ax = 0xffff;
loc_9be8:
    memoryASet16(ds, bx, ax);
    bx += 0x0002;
    if (--cx)
        goto loc_9be8;
    cx = 0x0012;
    ax = memoryAGet16(ds, 0x54d6);
    if (ax == 0)
        goto loc_9c22;
    if (ax >= 0xf800)
        goto loc_9c22;
    if (ax < 0x0951)
        goto loc_9c22;
    cx = ax;
    cx >>= 1;
    cx >>= 1;
    ax = 0xffff;
    dx = 0;
    div(cx);
    ax += ax;
    cx = ax;
    ax += ax;
    ax += ax;
    ax += ax;
    ax += cx;
    ax >>= 1;
    ax >>= 1;
    cx = ax;
loc_9c22:
    ax = cx;
    bx = 0x0000;
    dx = 0x01ed;
    cx = 0x7e7a;
    sub_9d32();
    ax = 0x0032;
    bx = 0x0001;
    dx = 0x01ed;
    cx = 0x7e80;
    sub_9d32();
    push(es);
    ah = 0x35;
    al = 0x08;
    interrupt(0x21);
    memoryASet16(ds, 0x54d0, bx);
    bx = es;
    memoryASet16(ds, 0x54d2, bx);
    es = pop();
    ax = 0x0001;
    memoryASet(ds, 0x54d4, al);
    tx = flags.carry | (flags.zero << 1);
    push(tx);
    flags.interrupts = false;
    push(ds);
    ax = 0x01ed;
    ds = ax;
    dx = 0x7c02;
    ah = 0x25;
    al = 0x08;
    interrupt(0x21);
    ds = pop();
    tx = pop();
    flags.carry = tx & 1;
    flags.zero = (tx << 1) & 1;
    sub_9c82();
    push(es);
    ax = 0x350f;
    interrupt(0x21);
    memoryASet16(ds, 0x54d8, bx);
    bx = es;
    memoryASet16(ds, 0x54da, bx);
    es = pop();
    ax = 0x0001;
}
/* Assembly listing of 01ed:7db2 sub_9c82()
sub_9c82 PROC
01ed:7db2	mov	ax, 0x951
01ed:7db5	call	0x7f9a
01ed:7db8	ret	
sub_9c82 ENDP
*/
void sub_9c82()
{
    // coverage: 0x8fb2-0x8fb9 method sub_9c82
    ax = 0x0951;
    sub_9e6a();
}
/* Assembly listing of 01ed:7db9 sub_9c89()
sub_9c89 PROC
01ed:7db9	mov	al, byte ptr [0x54d4]
01ed:7dbc	xor	ah, ah
01ed:7dbe	and	al, al
01ed:7dc0	je	loc_9cb7
01ed:7dc2	push	ds
01ed:7dc3	lds	dx, ptr [0x54d8]
01ed:7dc7	mov	ah, 0x25
01ed:7dc9	mov	al, 0xf
01ed:7dcb	pop	ds
01ed:7dcc	mov	ax, word ptr [0x54d6]
01ed:7dcf	call	0x7f9a
01ed:7dd2	push	ds
01ed:7dd3	lds	dx, ptr [0x54d0]
01ed:7dd7	mov	ah, 0x25
01ed:7dd9	mov	al, 8
01ed:7ddb	int	0x21
01ed:7ddd	pop	ds
01ed:7dde	mov	ax, 0
01ed:7de1	mov	byte ptr [0x54d4], al
01ed:7de4	mov	ax, 1
        	loc_9cb7:
01ed:7de7	ret	
sub_9c89 ENDP
*/
void sub_9c89()
{
    // coverage: 0x8fb9-0x8fe8 method sub_9c89
    al = memoryAGet(ds, 0x54d4);
    ah = 0;
    if (al == 0)
        return;
    push(ds);
    dx = memoryAGet16(ds, 0x54d8);
    ds = memoryAGet16(ds, 0x54d8 + 2);
    ah = 0x25;
    al = 0x0f;
    ds = pop();
    ax = memoryAGet16(ds, 0x54d6);
    sub_9e6a();
    push(ds);
    dx = memoryAGet16(ds, 0x54d0);
    ds = memoryAGet16(ds, 0x54d0 + 2);
    ah = 0x25;
    al = 0x08;
    interrupt(0x21);
    ds = pop();
    ax = 0x0000;
    memoryASet(ds, 0x54d4, al);
    ax = 0x0001;
}
/* Assembly listing of 01ed:7df9 sub_9cc9()
sub_9cc9 PROC
01ed:7df9	and	bx, bx
01ed:7dfb	js	loc_9ce5
01ed:7dfd	cmp	bx, 4
01ed:7e00	jge	loc_9ce5
01ed:7e02	add	bx, 2
01ed:7e05	and	ax, ax
01ed:7e07	js	loc_9ce5
01ed:7e09	cmp	ax, 0x1f4
01ed:7e0c	jge	loc_9ce5
01ed:7e0e	call	0x7e62
01ed:7e11	mov	ax, 1
01ed:7e14	ret	
        	loc_9ce5:
01ed:7e15	xor	ax, ax
01ed:7e17	ret	
sub_9cc9 ENDP
*/
void sub_9cc9()
{
    // coverage: 0x8ff9-0x9018 method sub_9cc9
    if ((short)bx < 0)
        goto loc_9ce5;
    if ((short)bx >= (short)0x0004)
        goto loc_9ce5;
    bx += 0x0002;
    if ((short)ax < 0)
        goto loc_9ce5;
    if ((short)ax >= (short)0x01f4)
        goto loc_9ce5;
    sub_9d32();
    ax = 0x0001;
    return;
loc_9ce5:
    ax = 0;
}
/* Assembly listing of 01ed:7e18 sub_9ce8()
sub_9ce8 PROC
01ed:7e18	push	bp
01ed:7e19	mov	bp, sp
01ed:7e1b	mov	ax, word ptr [bp + 4]
01ed:7e1e	pop	bp
01ed:7e1f	mov	bx, ax
01ed:7e21	and	bx, bx
01ed:7e23	js	loc_9d0a
01ed:7e25	cmp	bx, 4
01ed:7e28	jge	loc_9d0a
01ed:7e2a	add	bx, 2
01ed:7e2d	xor	ax, ax
01ed:7e2f	mov	cx, ax
01ed:7e31	mov	dx, ax
01ed:7e33	call	0x7e62
01ed:7e36	mov	ax, 1
01ed:7e39	ret	
        	loc_9d0a:
01ed:7e3a	xor	ax, ax
01ed:7e3c	ret	
sub_9ce8 ENDP
*/
void sub_9ce8()
{
    // coverage: 0x9018-0x903d method sub_9ce8
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    bx = ax;
    if ((short)bx < 0)
        goto loc_9d0a;
    if ((short)bx >= (short)0x0004)
        goto loc_9d0a;
    bx += 0x0002;
    ax = 0;
    cx = ax;
    dx = ax;
    sub_9d32();
    ax = 0x0001;
    assert(pop() == 0x7777);
    return;
loc_9d0a:
    ax = 0;
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:7e1f sub_9cef()
sub_9cef PROC
01ed:7e1f	mov	bx, ax
01ed:7e21	and	bx, bx
01ed:7e23	js	loc_9d0a
01ed:7e25	cmp	bx, 4
01ed:7e28	jge	loc_9d0a
01ed:7e2a	add	bx, 2
01ed:7e2d	xor	ax, ax
01ed:7e2f	mov	cx, ax
01ed:7e31	mov	dx, ax
01ed:7e33	call	0x7e62
01ed:7e36	mov	ax, 1
01ed:7e39	ret	
        	loc_9d0a:
01ed:7e3a	xor	ax, ax
01ed:7e3c	ret	
sub_9cef ENDP
*/
void sub_9cef()
{
    // coverage: 0x901f-0x903d method sub_9cef
    bx = ax;
    if ((short)bx < 0)
        goto loc_9d0a;
    if ((short)bx >= (short)0x0004)
        goto loc_9d0a;
    bx += 0x0002;
    ax = 0;
    cx = ax;
    dx = ax;
    sub_9d32();
    ax = 0x0001;
    return;
loc_9d0a:
    ax = 0;
}
/* Assembly listing of 01ed:7e62 sub_9d32()
sub_9d32 PROC
01ed:7e62	add	bx, bx
01ed:7e64	add	bx, bx
01ed:7e66	add	bx, bx
01ed:7e68	add	bx, 0x549c
01ed:7e6c	mov	word ptr [bx], ax
01ed:7e6e	xor	ax, ax
01ed:7e70	mov	word ptr [bx + 2], ax
01ed:7e73	mov	word ptr [bx + 6], cx
01ed:7e76	mov	word ptr [bx + 4], dx
01ed:7e79	ret	
sub_9d32 ENDP
*/
void sub_9d32()
{
    // coverage: 0x9062-0x907a method sub_9d32
    bx += bx;
    bx += bx;
    bx += bx;
    bx += 0x549c;
    memoryASet16(ds, bx, ax);
    ax = 0;
    memoryASet16(ds, bx + 2, ax);
    memoryASet16(ds, bx + 6, cx);
    memoryASet16(ds, bx + 4, dx);
}
/* Assembly listing of 01ed:7f90 sub_9e60()
sub_9e60 PROC
01ed:7f90	call	0x7f93
01ed:7f93	call	0x7f96
01ed:7f96	call	0x7f99
01ed:7f99	ret	
sub_9e60 ENDP
*/
void sub_9e60()
{
    // coverage: 0x9190-0x919a method sub_9e60
    sub_9e63();
    sub_9e66();
    sub_9e69();
}
/* Assembly listing of 01ed:7f93 sub_9e63()
sub_9e63 PROC
01ed:7f93	call	0x7f96
01ed:7f96	call	0x7f99
01ed:7f99	ret	
sub_9e63 ENDP
*/
void sub_9e63()
{
    // coverage: 0x9193-0x919a method sub_9e63
    sub_9e66();
    sub_9e69();
}
/* Assembly listing of 01ed:7f96 sub_9e66()
sub_9e66 PROC
01ed:7f96	call	0x7f99
01ed:7f99	ret	
sub_9e66 ENDP
*/
void sub_9e66()
{
    // coverage: 0x9196-0x919a method sub_9e66
    sub_9e69();
}
/* Assembly listing of 01ed:7f99 sub_9e69()
sub_9e69 PROC
01ed:7f99	ret	
sub_9e69 ENDP
*/
void sub_9e69()
{
    // coverage: 0x9199-0x919a method sub_9e69
}
/* Assembly listing of 01ed:7f9a sub_9e6a()
sub_9e6a PROC
01ed:7f9a	push	ax
01ed:7f9b	mov	al, 0x36
01ed:7f9d	out	0x43, al
01ed:7f9f	call	0x7f90
01ed:7fa2	pop	ax
01ed:7fa3	out	0x40, al
01ed:7fa5	call	0x7f90
01ed:7fa8	mov	al, ah
01ed:7faa	out	0x40, al
01ed:7fac	call	0x7f90
01ed:7faf	ret	
sub_9e6a ENDP
*/
void sub_9e6a()
{
    // coverage: 0x919a-0x91b0 method sub_9e6a
    push(ax);
    al = 0x36;
    out(0x43, al);
    sub_9e60();
    ax = pop();
    out(0x40, al);
    sub_9e60();
    al = ah;
    out(0x40, al);
    sub_9e60();
}
/* Assembly listing of 01ed:7fb0 sub_9e80()
sub_9e80 PROC
01ed:7fb0	push	bx
01ed:7fb1	push	cx
01ed:7fb2	mov	cx, 0x19
01ed:7fb5	xor	bx, bx
01ed:7fb7	mov	al, 6
01ed:7fb9	out	0x43, al
01ed:7fbb	call	0x7f90
        	loc_9e8e:
01ed:7fbe	cli	
01ed:7fbf	in	al, 0x40
01ed:7fc1	mov	ah, al
01ed:7fc3	call	0x7f90
01ed:7fc6	in	al, 0x40
01ed:7fc8	sti	
01ed:7fc9	cmp	al, bh
01ed:7fcb	jb	loc_9e8e
01ed:7fcd	jne	loc_9ea3
01ed:7fcf	cmp	bl, ah
01ed:7fd1	jae	loc_9ea5
        	loc_9ea3:
01ed:7fd3	mov	bl, ah
        	loc_9ea5:
01ed:7fd5	mov	bh, al
01ed:7fd7	loop	loc_9e8e
01ed:7fd9	mov	ax, bx
01ed:7fdb	pop	cx
01ed:7fdc	pop	bx
01ed:7fdd	ret	
sub_9e80 ENDP
*/
void sub_9e80()
{
    // coverage: 0x91b0-0x91de method sub_9e80
    push(bx);
    push(cx);
    cx = 0x0019;
    bx = 0;
    al = 0x06;
    out(0x43, al);
    sub_9e60();
loc_9e8e:
    flags.interrupts = false;
    in(al, 0x40);
    ah = al;
    sub_9e60();
    in(al, 0x40);
    flags.interrupts = true;
    if (al < bh)
        goto loc_9e8e;
    if (al != bh)
        goto loc_9ea3;
    if (bl >= ah)
        goto loc_9ea5;
loc_9ea3:
    bl = ah;
loc_9ea5:
    bh = al;
    if (--cx)
        goto loc_9e8e;
    ax = bx;
    cx = pop();
    bx = pop();
}
/* Assembly listing of 01ed:808e sub_9f5e()
sub_9f5e PROC
01ed:808e	push	bp
01ed:808f	mov	bp, sp
01ed:8091	mov	dx, word ptr [bp + 6]
01ed:8094	mov	ax, word ptr [bp + 4]
01ed:8097	pop	bp
01ed:8098	lcall	0xec2, 0
01ed:809d	ret	
sub_9f5e ENDP
*/
void sub_9f5e()
{
    // coverage: 0x928e-0x929e method sub_9f5e
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ec2;
    sub_ec20();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:809e sub_9f6e()
sub_9f6e PROC
01ed:809e	push	bp
01ed:809f	mov	bp, sp
01ed:80a1	mov	ax, word ptr [bp + 6]
01ed:80a4	pop	bp
01ed:80a5	lcall	0xec2, 0x32
01ed:80aa	ret	
sub_9f6e ENDP
*/
void sub_9f6e()
{
    // coverage: 0x929e-0x92ab method sub_9f6e
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 6);
    bp = pop();
    push(cs);
    cs = 0x0ec2;
    sub_ec52();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:80ac sub_9f7c()
sub_9f7c PROC
01ed:80ac	push	bp
01ed:80ad	mov	bp, sp
01ed:80af	mov	dx, word ptr [bp + 6]
01ed:80b2	mov	ax, word ptr [bp + 4]
01ed:80b5	pop	bp
01ed:80b6	lcall	0xca6, 0xa73
01ed:80bb	ret	
sub_9f7c ENDP
*/
void sub_9f7c()
{
    // coverage: 0x92ac-0x92bc method sub_9f7c
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_d4d3();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:80bc sub_9f8c()
sub_9f8c PROC
01ed:80bc	push	bp
01ed:80bd	mov	bp, sp
01ed:80bf	mov	dx, word ptr [bp + 6]
01ed:80c2	mov	ax, word ptr [bp + 4]
01ed:80c5	pop	bp
01ed:80c6	lcall	0xca6, 0xd77
01ed:80cb	ret	
sub_9f8c ENDP
*/
void sub_9f8c()
{
    // coverage: 0x92bc-0x92cc method sub_9f8c
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_d7d7();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:85b5 sub_a485()
sub_a485 PROC
01ed:85b5	push	bx
01ed:85b6	mov	bx, word ptr cs:[0x85b3]
01ed:85bb	cmp	bx, 0
01ed:85be	jne	loc_a495
01ed:85c0	call	0x9115
01ed:85c3	jmp	loc_a4a9
        	loc_a495:
01ed:85c5	cmp	bx, 4
01ed:85c8	jne	loc_a49f
01ed:85ca	call	0x8ad0
01ed:85cd	jmp	loc_a4a9
        	loc_a49f:
01ed:85cf	cmp	bx, 1
01ed:85d2	jne	loc_a4a9
01ed:85d4	call	0x8e2f
01ed:85d7	jmp	loc_a4a9
        	loc_a4a9:
01ed:85d9	pop	bx
01ed:85da	ret	
sub_a485 ENDP
*/
void sub_a485()
{
    // coverage: 0x97b5-0x97db method sub_a485
    push(bx);
    bx = memoryAGet16(cs, 0x85b3);
    if (bx != 0x0000)
        goto loc_a495;
    sub_afe5();
    goto loc_a4a9;
loc_a495:
    if (bx != 0x0004)
        goto loc_a49f;
    sub_a9a0();
    goto loc_a4a9;
loc_a49f:
    if (bx != 0x0001)
        goto loc_a4a9;
    sub_acff();
loc_a4a9:
    bx = pop();
}
/* Assembly listing of 01ed:85db sub_a4ab()
sub_a4ab PROC
01ed:85db	push	ax
01ed:85dc	mov	ax, word ptr cs:[0x85b3]
01ed:85e0	cmp	ax, 0
01ed:85e3	jne	loc_a4ba
01ed:85e5	call	0x91cf
01ed:85e8	jmp	loc_a4ce
        	loc_a4ba:
01ed:85ea	cmp	ax, 4
01ed:85ed	jne	loc_a4c4
01ed:85ef	call	0x8af6
01ed:85f2	jmp	loc_a4ce
        	loc_a4c4:
01ed:85f4	cmp	ax, 1
01ed:85f7	jne	loc_a4ce
01ed:85f9	call	0x8e48
01ed:85fc	jmp	loc_a4ce
        	loc_a4ce:
01ed:85fe	pop	ax
01ed:85ff	ret	
sub_a4ab ENDP
*/
void sub_a4ab()
{
    // coverage: 0x97db-0x9800 method sub_a4ab
    push(ax);
    ax = memoryAGet16(cs, 0x85b3);
    if (ax != 0x0000)
        goto loc_a4ba;
    sub_b09f();
    goto loc_a4ce;
loc_a4ba:
    if (ax != 0x0004)
        goto loc_a4c4;
    sub_a9c6();
    goto loc_a4ce;
loc_a4c4:
    if (ax != 0x0001)
        goto loc_a4ce;
    sub_ad18();
loc_a4ce:
    ax = pop();
}
/* Assembly listing of 01ed:8600 sub_a4d0()
sub_a4d0 PROC
01ed:8600	push	cx
01ed:8601	mov	cx, word ptr cs:[0x85b3]
01ed:8606	cmp	cx, 0
01ed:8609	jne	loc_a4e0
01ed:860b	call	0x91d7
01ed:860e	jmp	loc_a4f4
        	loc_a4e0:
01ed:8610	cmp	cx, 4
01ed:8613	jne	loc_a4ea
01ed:8615	call	0x8b04
01ed:8618	jmp	loc_a4f4
        	loc_a4ea:
01ed:861a	cmp	cx, 1
01ed:861d	jne	loc_a4f4
01ed:861f	call	0x8e50
01ed:8622	jmp	loc_a4f4
        	loc_a4f4:
01ed:8624	pop	cx
01ed:8625	ret	
sub_a4d0 ENDP
*/
void sub_a4d0()
{
    // coverage: 0x9800-0x9826 method sub_a4d0
    push(cx);
    cx = memoryAGet16(cs, 0x85b3);
    if (cx != 0x0000)
        goto loc_a4e0;
    sub_b0a7();
    goto loc_a4f4;
loc_a4e0:
    if (cx != 0x0004)
        goto loc_a4ea;
    sub_a9d4();
    goto loc_a4f4;
loc_a4ea:
    if (cx != 0x0001)
        goto loc_a4f4;
    sub_ad20();
loc_a4f4:
    cx = pop();
}
/* Assembly listing of 01ed:8626 sub_a4f6()
sub_a4f6 PROC
01ed:8626	push	cx
01ed:8627	mov	cx, word ptr cs:[0x85b3]
01ed:862c	cmp	cx, 0
01ed:862f	jne	loc_a506
01ed:8631	call	0x91df
01ed:8634	jmp	loc_a51a
        	loc_a506:
01ed:8636	cmp	cx, 4
01ed:8639	jne	loc_a510
01ed:863b	call	0x8b0d
01ed:863e	jmp	loc_a51a
        	loc_a510:
01ed:8640	cmp	cx, 1
01ed:8643	jne	loc_a51a
01ed:8645	call	0x8e58
01ed:8648	jmp	loc_a51a
        	loc_a51a:
01ed:864a	pop	cx
01ed:864b	ret	
sub_a4f6 ENDP
*/
void sub_a4f6()
{
    // coverage: 0x9826-0x984c method sub_a4f6
    push(cx);
    cx = memoryAGet16(cs, 0x85b3);
    if (cx != 0x0000)
        goto loc_a506;
    sub_b0af();
    goto loc_a51a;
loc_a506:
    if (cx != 0x0004)
        goto loc_a510;
    sub_a9dd();
    goto loc_a51a;
loc_a510:
    if (cx != 0x0001)
        goto loc_a51a;
    sub_ad28();
loc_a51a:
    cx = pop();
}
/* Assembly listing of 01ed:86e9 sub_a5b9()
sub_a5b9 PROC
01ed:86e9	push	ax
01ed:86ea	push	bx
01ed:86eb	push	cx
01ed:86ec	push	dx
01ed:86ed	mov	ax, word ptr cs:[0x85a3]
01ed:86f1	mov	cx, 0xf42
01ed:86f4	mul	cx
01ed:86f6	mov	cx, word ptr cs:[0x85a5]
01ed:86fb	mov	bx, word ptr cs:[0x85a7]
01ed:8700	mov	cl, ch
01ed:8702	mov	ch, bl
01ed:8704	div	cx
01ed:8706	mov	cx, ax
01ed:8708	push	ds
01ed:8709	mov	ax, 0x1228
01ed:870c	mov	ds, ax
01ed:870e	mov	ax, cx
01ed:8710	mov	dx, 0x1ed
01ed:8713	mov	cx, 0x864c
01ed:8716	mov	bx, 0
01ed:8719	call	0x7df9
01ed:871c	pop	ds
01ed:871d	pop	dx
01ed:871e	pop	cx
01ed:871f	pop	bx
01ed:8720	pop	ax
01ed:8721	ret	
sub_a5b9 ENDP
*/
void sub_a5b9()
{
    // coverage: 0x98e9-0x9922 method sub_a5b9
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    ax = memoryAGet16(cs, 0x85a3);
    cx = 0x0f42;
    mul(cx);
    cx = memoryAGet16(cs, 0x85a5);
    bx = memoryAGet16(cs, 0x85a7);
    cl = ch;
    ch = bl;
    div(cx);
    cx = ax;
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = cx;
    dx = 0x01ed;
    cx = 0x864c;
    bx = 0x0000;
    sub_9cc9();
    ds = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
}
/* Assembly listing of 01ed:8722 sub_a5f2()
sub_a5f2 PROC
01ed:8722	push	bx
01ed:8723	push	dx
01ed:8724	push	ds
01ed:8725	push	es
01ed:8726	call	0x86e9
01ed:8729	pop	es
01ed:872a	pop	ds
01ed:872b	pop	dx
01ed:872c	pop	bx
01ed:872d	ret	
sub_a5f2 ENDP
*/
void sub_a5f2()
{
    // coverage: 0x9922-0x992e method sub_a5f2
    push(bx);
    push(dx);
    push(ds);
    push(es);
    sub_a5b9();
    es = pop();
    ds = pop();
    dx = pop();
    bx = pop();
}
/* Assembly listing of 01ed:872e sub_a5fe()
sub_a5fe PROC
01ed:872e	mov	ah, al
01ed:8730	call	0x89e2
        	loc_a603:
01ed:8733	lodsb	al, byte ptr [si]
01ed:8734	mov	ah, al
01ed:8736	call	0x89e2
01ed:8739	loop	loc_a603
01ed:873b	ret	
sub_a5fe ENDP
*/
void sub_a5fe()
{
    // coverage: 0x992e-0x993c method sub_a5fe
    ah = al;
    sub_a8b2();
loc_a603:
    lodsb<MemAuto, DirAuto>();
    ah = al;
    sub_a8b2();
    if (--cx)
        goto loc_a603;
}
/* Assembly listing of 01ed:873c sub_a60c()
sub_a60c PROC
01ed:873c	push	cx
        	loc_a60d:
01ed:873d	lodsb	al, byte ptr [si]
01ed:873e	test	al, 0x80
01ed:8740	jne	loc_a615
01ed:8742	lodsb	al, byte ptr [si]
01ed:8743	jmp	loc_a666
        	loc_a615:
01ed:8745	xor	ch, ch
01ed:8747	cmp	al, 0xf0
01ed:8749	jl	loc_a62b
01ed:874b	je	loc_a626
01ed:874d	cmp	al, 0xf7
01ed:874f	jne	loc_a630
01ed:8751	call	0x85db
01ed:8754	jmp	loc_a666
        	loc_a626:
01ed:8756	call	0x8600
01ed:8759	jmp	loc_a666
        	loc_a62b:
01ed:875b	call	0x8626
01ed:875e	jmp	loc_a666
        	loc_a630:
01ed:8760	lodsw	ax, word ptr [si]
01ed:8761	cmp	al, 0x51
01ed:8763	jne	loc_a643
01ed:8765	lodsb	al, byte ptr [si]
01ed:8766	mov	byte ptr cs:[0x85a7], al
01ed:876a	lodsw	ax, word ptr [si]
01ed:876b	xchg	al, ah
01ed:876d	mov	word ptr cs:[0x85a5], ax
01ed:8771	jmp	loc_a666
        	loc_a643:
01ed:8773	cmp	al, 0x2f
01ed:8775	jne	loc_a654
01ed:8777	lodsw	ax, word ptr [si]
01ed:8778	mov	ax, 0xffff
01ed:877b	mov	dx, ax
01ed:877d	dec	word ptr cs:[0x85a1]
01ed:8782	jmp	loc_a670
        	loc_a654:
01ed:8784	cmp	al, 0x20
01ed:8786	jne	loc_a660
01ed:8788	lodsb	al, byte ptr [si]
01ed:8789	mov	byte ptr cs:[bx + 0x80], al
01ed:878e	jmp	loc_a666
        	loc_a660:
01ed:8790	mov	cl, ah
01ed:8792	add	si, cx
01ed:8794	jmp	loc_a666
        	loc_a666:
01ed:8796	call	0x8891
01ed:8799	jne	loc_a66d
01ed:879b	jmp	loc_a60d
        	loc_a66d:
01ed:879d	call	0x8a23
        	loc_a670:
01ed:87a0	pop	cx
01ed:87a1	ret	
sub_a60c ENDP
*/
void sub_a60c()
{
    // coverage: 0x993c-0x99a2 method sub_a60c
    push(cx);
loc_a60d:
    lodsb<MemAuto, DirAuto>();
    if (al & 0x80)
        goto loc_a615;
    lodsb<MemAuto, DirAuto>();
    goto loc_a666;
loc_a615:
    ch = 0;
    if ((char)al < (char)0xf0)
        goto loc_a62b;
    if (al == 0xf0)
        goto loc_a626;
    if (al != 0xf7)
        goto loc_a630;
    sub_a4ab();
    goto loc_a666;
loc_a626:
    sub_a4d0();
    goto loc_a666;
loc_a62b:
    sub_a4f6();
    goto loc_a666;
loc_a630:
    lodsw<MemAuto, DirAuto>();
    if (al != 0x51)
        goto loc_a643;
    lodsb<MemAuto, DirAuto>();
    memoryASet(cs, 0x85a7, al);
    lodsw<MemAuto, DirAuto>();
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(cs, 0x85a5, ax);
    goto loc_a666;
loc_a643:
    if (al != 0x2f)
        goto loc_a654;
    lodsw<MemAuto, DirAuto>();
    ax = 0xffff;
    dx = ax;
    memoryASet16(cs, 0x85a1, memoryAGet16(cs, 0x85a1) - 1);
    goto loc_a670;
loc_a654:
    if (al != 0x20)
        goto loc_a660;
    lodsb<MemAuto, DirAuto>();
    memoryASet(cs, bx + 128, al);
    goto loc_a666;
loc_a660:
    cl = ah;
    si += cx;
loc_a666:
    sub_a761();
    if (!flags.zero)
        goto loc_a66d;
    goto loc_a60d;
loc_a66d:
    sub_a8f3();
loc_a670:
    cx = pop();
}
/* Assembly listing of 01ed:87a2 sub_a672()
sub_a672 PROC
01ed:87a2	mov	cx, word ptr cs:[0x85a1]
01ed:87a7	mov	bx, 0x81cc
        	loc_a67a:
01ed:87aa	lds	si, ptr cs:[bx]
01ed:87ad	call	0x8891
01ed:87b0	jne	loc_a685
01ed:87b2	call	0x873c
        	loc_a685:
01ed:87b5	mov	word ptr cs:[bx + 0x40], ax
01ed:87b9	mov	word ptr cs:[bx + 0x42], dx
01ed:87bd	mov	word ptr cs:[bx], si
01ed:87c0	mov	ax, ds
01ed:87c2	mov	word ptr cs:[bx + 2], ax
01ed:87c6	inc	bx
01ed:87c7	inc	bx
01ed:87c8	inc	bx
01ed:87c9	inc	bx
01ed:87ca	loop	loc_a67a
01ed:87cc	ret	
sub_a672 ENDP
*/
void sub_a672()
{
    // coverage: 0x99a2-0x99cd method sub_a672
    cx = memoryAGet16(cs, 0x85a1);
    bx = 0x81cc;
loc_a67a:
    si = memoryAGet16(cs, bx);
    ds = memoryAGet16(cs, bx + 2);
    sub_a761();
    if (!flags.zero)
        goto loc_a685;
    sub_a60c();
loc_a685:
    memoryASet16(cs, bx + 64, ax);
    memoryASet16(cs, bx + 66, dx);
    memoryASet16(cs, bx, si);
    ax = ds;
    memoryASet16(cs, bx + 2, ax);
    bx++;
    bx++;
    bx++;
    bx++;
    if (--cx)
        goto loc_a67a;
}
/* Assembly listing of 01ed:8809 sub_a6d9()
sub_a6d9 PROC
01ed:8809	cmp	word ptr [si], 0x544d
01ed:880d	jne	loc_a75e
01ed:880f	nop	
01ed:8810	nop	
01ed:8811	nop	
01ed:8812	inc	si
01ed:8813	inc	si
01ed:8814	cmp	word ptr [si], 0x6468
01ed:8818	jne	loc_a75e
01ed:881a	nop	
01ed:881b	nop	
01ed:881c	nop	
01ed:881d	inc	si
01ed:881e	inc	si
01ed:881f	cmp	word ptr [si], 0
01ed:8822	jne	loc_a75e
01ed:8824	nop	
01ed:8825	nop	
01ed:8826	nop	
01ed:8827	inc	si
01ed:8828	inc	si
01ed:8829	cmp	word ptr [si], 0x600
01ed:882d	jne	loc_a75e
01ed:882f	inc	si
01ed:8830	inc	si
01ed:8831	cmp	word ptr [si], 0x200
01ed:8835	je	loc_a75e
01ed:8837	inc	si
01ed:8838	inc	si
01ed:8839	lodsw	ax, word ptr [si]
01ed:883a	xchg	al, ah
01ed:883c	cmp	ax, 0
01ed:883f	je	loc_a75e
01ed:8841	cmp	ax, 0x10
01ed:8844	jg	loc_a75e
01ed:8846	mov	word ptr cs:[0x85a1], ax
01ed:884a	lodsw	ax, word ptr [si]
01ed:884b	xchg	al, ah
01ed:884d	test	ah, 0x80
01ed:8850	jne	loc_a75e
01ed:8852	mov	word ptr cs:[0x85a3], ax
01ed:8856	mov	cx, word ptr cs:[0x85a1]
01ed:885b	mov	bx, 0x81cc
        	loc_a72e:
01ed:885e	call	0x8a23
01ed:8861	lodsw	ax, word ptr [si]
01ed:8862	cmp	ax, 0x544d
01ed:8865	jne	loc_a75e
01ed:8867	lodsw	ax, word ptr [si]
01ed:8868	cmp	ax, 0x6b72
01ed:886b	jne	loc_a75e
01ed:886d	lodsw	ax, word ptr [si]
01ed:886e	cmp	ax, 0
01ed:8871	jne	loc_a75e
01ed:8873	lodsw	ax, word ptr [si]
01ed:8874	mov	word ptr cs:[bx], si
01ed:8877	inc	bx
01ed:8878	inc	bx
01ed:8879	mov	word ptr cs:[bx], ds
01ed:887c	inc	bx
01ed:887d	inc	bx
01ed:887e	xchg	al, ah
01ed:8880	add	si, ax
01ed:8882	jb	loc_a75e
01ed:8884	loop	loc_a72e
01ed:8886	call	0x87a2
01ed:8889	mov	ax, 0xffff
01ed:888c	jmp	loc_a760
        	loc_a75e:
01ed:888e	xor	ax, ax
        	loc_a760:
01ed:8890	ret	
sub_a6d9 ENDP
*/
void sub_a6d9()
{
    // coverage: 0x9a09-0x9a91 method sub_a6d9
    if (memoryAGet16(ds, si) != 0x544d)
        goto loc_a75e;
    si++;
    si++;
    if (memoryAGet16(ds, si) != 0x6468)
        goto loc_a75e;
    si++;
    si++;
    if (memoryAGet16(ds, si) != 0x0000)
        goto loc_a75e;
    si++;
    si++;
    if (memoryAGet16(ds, si) != 0x0600)
        goto loc_a75e;
    si++;
    si++;
    if (memoryAGet16(ds, si) == 0x0200)
        goto loc_a75e;
    si++;
    si++;
    lodsw<MemAuto, DirAuto>();
    tl = al;
    al = ah;
    ah = tl;
    if (ax == 0x0000)
        goto loc_a75e;
    if ((short)ax > (short)0x0010)
        goto loc_a75e;
    memoryASet16(cs, 0x85a1, ax);
    lodsw<MemAuto, DirAuto>();
    tl = al;
    al = ah;
    ah = tl;
    if (ah & 0x80)
        goto loc_a75e;
    memoryASet16(cs, 0x85a3, ax);
    cx = memoryAGet16(cs, 0x85a1);
    bx = 0x81cc;
loc_a72e:
    sub_a8f3();
    lodsw<MemAuto, DirAuto>();
    if (ax != 0x544d)
        goto loc_a75e;
    lodsw<MemAuto, DirAuto>();
    if (ax != 0x6b72)
        goto loc_a75e;
    lodsw<MemAuto, DirAuto>();
    if (ax != 0x0000)
        goto loc_a75e;
    lodsw<MemAuto, DirAuto>();
    memoryASet16(cs, bx, si);
    bx++;
    bx++;
    memoryASet16(cs, bx, ds);
    bx++;
    bx++;
    tl = al;
    al = ah;
    ah = tl;
    flags.carry = (si + ax) >= 0x10000;
    si += ax;
    if (flags.carry)
        goto loc_a75e;
    if (--cx)
        goto loc_a72e;
    sub_a672();
    ax = 0xffff;
    return;
loc_a75e:
    ax = 0;
}
// INJECT: Error: cannot inject zero flag in sub_a761()!
/* Assembly listing of 01ed:8891 sub_a761()
sub_a761 PROC
01ed:8891	xor	ax, ax
01ed:8893	mov	dx, ax
01ed:8895	lodsb	al, byte ptr [si]
01ed:8896	test	al, 0x80
01ed:8898	je	loc_a7ae
01ed:889a	mov	ah, al
01ed:889c	lodsb	al, byte ptr [si]
01ed:889d	test	al, 0x80
01ed:889f	jne	loc_a77a
01ed:88a1	and	ax, 0x7f7f
01ed:88a4	shl	al, 1
01ed:88a6	shr	ax, 1
01ed:88a8	jmp	loc_a7ae
        	loc_a77a:
01ed:88aa	xchg	dx, ax
01ed:88ab	lodsb	al, byte ptr [si]
01ed:88ac	test	al, 0x80
01ed:88ae	jne	loc_a796
01ed:88b0	xchg	ah, dl
01ed:88b2	xchg	dl, dh
01ed:88b4	and	dx, 0x7f7f
01ed:88b8	shl	ax, 1
01ed:88ba	shl	al, 1
01ed:88bc	shr	dl, 1
01ed:88be	rcr	ax, 1
01ed:88c0	shr	dl, 1
01ed:88c2	rcr	ax, 1
01ed:88c4	jmp	loc_a7ae
        	loc_a796:
01ed:88c6	mov	ah, al
01ed:88c8	lodsb	al, byte ptr [si]
01ed:88c9	xchg	dx, ax
01ed:88ca	and	dx, 0x7f7f
01ed:88ce	shl	dl, 1
01ed:88d0	shr	dx, 1
01ed:88d2	shl	ax, 1
01ed:88d4	shl	al, 1
01ed:88d6	shr	dl, 1
01ed:88d8	rcr	ax, 1
01ed:88da	shr	dl, 1
01ed:88dc	rcr	ax, 1
        	loc_a7ae:
01ed:88de	push	bx
01ed:88df	mov	bx, ax
01ed:88e1	or	bx, dx
01ed:88e3	pop	bx
01ed:88e4	ret	
sub_a761 ENDP
*/
void sub_a761()
{
    // coverage: 0x9a91-0x9ae5 method sub_a761
    ax = 0;
    dx = ax;
    lodsb<MemAuto, DirAuto>();
    if (!(al & 0x80))
        goto loc_a7ae;
    ah = al;
    lodsb<MemAuto, DirAuto>();
    if (al & 0x80)
        goto loc_a77a;
    ax &= 0x7f7f;
    al <<= 1;
    ax >>= 1;
    goto loc_a7ae;
loc_a77a:
    tx = dx;
    dx = ax;
    ax = tx;
    lodsb<MemAuto, DirAuto>();
    if (al & 0x80)
        goto loc_a796;
    tl = ah;
    ah = dl;
    dl = tl;
    tl = dl;
    dl = dh;
    dh = tl;
    dx &= 0x7f7f;
    ax <<= 1;
    al <<= 1;
    flags.carry = dl & 1;
    dl >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dl & 1;
    dl >>= 1;
    ax = rcr(ax, 0x0001);
    goto loc_a7ae;
loc_a796:
    ah = al;
    lodsb<MemAuto, DirAuto>();
    tx = dx;
    dx = ax;
    ax = tx;
    dx &= 0x7f7f;
    dl <<= 1;
    dx >>= 1;
    ax <<= 1;
    al <<= 1;
    flags.carry = dl & 1;
    dl >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dl & 1;
    dl >>= 1;
    ax = rcr(ax, 0x0001);
loc_a7ae:
    push(bx);
    bx = ax;
    bx |= dx;
    bx = pop();
    stop(/*inject ret*/);
}
/* Assembly listing of 01ed:88e5 sub_a7b5()
sub_a7b5 PROC
01ed:88e5	mov	cx, 0xffff
01ed:88e8	mov	ax, word ptr [0x557a]
01ed:88eb	and	ax, ax
01ed:88ed	jne	loc_a7e9
01ed:88ef	mov	ax, 1
01ed:88f2	mov	word ptr [0x557a], ax
01ed:88f5	xor	cx, cx
01ed:88f7	mov	word ptr [0x5584], ax
01ed:88fa	push	cx
01ed:88fb	call	0x8a75
01ed:88fe	pop	cx
01ed:88ff	mov	ax, 4
01ed:8902	je	loc_a7d6
01ed:8904	or	cx, ax
        	loc_a7d6:
01ed:8906	push	cx
01ed:8907	call	0x8b2a
01ed:890a	pop	cx
01ed:890b	mov	ax, 1
01ed:890e	je	loc_a7e2
01ed:8910	or	cx, ax
        	loc_a7e2:
01ed:8912	mov	word ptr cs:[0x85b3], ax
01ed:8916	mov	word ptr [0x5586], ax
        	loc_a7e9:
01ed:8919	mov	ax, cx
01ed:891b	and	ax, ax
01ed:891d	ret	
sub_a7b5 ENDP
*/
void sub_a7b5()
{
    // coverage: 0x9ae5-0x9b1e method sub_a7b5
    cx = 0xffff;
    ax = memoryAGet16(ds, 0x557a);
    if (ax != 0)
        goto loc_a7e9;
    ax = 0x0001;
    memoryASet16(ds, 0x557a, ax);
    cx = 0;
    memoryASet16(ds, 0x5584, ax);
    push(cx);
    sub_a945();
    cx = pop();
    ax = 0x0004;
    if (flags.zero)
        goto loc_a7d6;
    cx |= ax;
loc_a7d6:
    push(cx);
    sub_a9fa();
    cx = pop();
    ax = 0x0001;
    if (flags.zero)
        goto loc_a7e2;
    cx |= ax;
loc_a7e2:
    memoryASet16(cs, 0x85b3, ax);
    memoryASet16(ds, 0x5586, ax);
loc_a7e9:
    ax = cx;
}
/* Assembly listing of 01ed:891e sub_a7ee()
sub_a7ee PROC
01ed:891e	mov	cx, 0xffff
01ed:8921	mov	ax, word ptr [0x557a]
01ed:8924	cmp	ax, 1
01ed:8927	jne	loc_a827
01ed:8929	mov	ax, 2
01ed:892c	mov	word ptr [0x557a], ax
01ed:892f	push	bp
01ed:8930	mov	bp, sp
01ed:8932	mov	ax, word ptr [bp + 4]
01ed:8935	pop	bp
01ed:8936	mov	cx, 0
        	loc_a809:
01ed:8939	shr	ax, 1
01ed:893b	jb	loc_a817
01ed:893d	inc	cx
01ed:893e	cmp	cx, 0x10
01ed:8941	jne	loc_a809
01ed:8943	xor	ax, ax
01ed:8945	jmp	loc_a82c
        	loc_a817:
01ed:8947	mov	ax, 0
01ed:894a	rcl	ax, 1
01ed:894c	shl	ax, cl
        	loc_a81e:
01ed:894e	mov	word ptr cs:[0x85b3], ax
01ed:8952	mov	word ptr [0x5586], ax
01ed:8955	mov	cx, ax
        	loc_a827:
01ed:8957	mov	ax, cx
01ed:8959	and	ax, ax
01ed:895b	ret	
        	loc_a82c:
01ed:895c	mov	bx, 1
01ed:895f	mov	ax, 0x64
01ed:8962	mov	dx, 0x1ed
01ed:8965	mov	cx, 0x9136
01ed:8968	call	0x7df9
01ed:896b	xor	ax, ax
01ed:896d	mov	byte ptr cs:[0x83ee], al
01ed:8971	mov	word ptr cs:[0x83ef], ax
01ed:8975	jmp	loc_a81e
sub_a7ee ENDP
*/
void sub_a7ee()
{
    // coverage: 0x9b1e-0x9b77 method sub_a7ee
    push(0x7777);
    cx = 0xffff;
    ax = memoryAGet16(ds, 0x557a);
    if (ax != 0x0001)
        goto loc_a827;
    ax = 0x0002;
    memoryASet16(ds, 0x557a, ax);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    cx = 0x0000;
loc_a809:
    flags.carry = ax & 1;
    ax >>= 1;
    if (flags.carry)
        goto loc_a817;
    cx++;
    if (cx != 0x0010)
        goto loc_a809;
    ax = 0;
    goto loc_a82c;
loc_a817:
    ax = 0x0000;
    stop(/*carry2*/);
    ax = rcl(ax, 0x0001);
    ax <<= cl;
loc_a81e:
    memoryASet16(cs, 0x85b3, ax);
    memoryASet16(ds, 0x5586, ax);
    cx = ax;
loc_a827:
    ax = cx;
    assert(pop() == 0x7777);
    return;
loc_a82c:
    bx = 0x0001;
    ax = 0x0064;
    dx = 0x01ed;
    cx = 0x9136;
    sub_9cc9();
    ax = 0;
    memoryASet(cs, 0x83ee, al);
    memoryASet16(cs, 0x83ef, ax);
    goto loc_a81e;
}
/* Assembly listing of 01ed:8977 sub_a847()
sub_a847 PROC
01ed:8977		
        	loc_a69d:
01ed:87cd	push	bp
01ed:87ce	mov	bp, sp
01ed:87d0	push	es
01ed:87d1	push	ds
01ed:87d2	push	si
01ed:87d3	push	di
01ed:87d4	mov	ax, word ptr [bp + 0xc]
01ed:87d7	mov	word ptr cs:[0x8483], ax
01ed:87db	les	si, ptr [bp + 8]
01ed:87de	mov	word ptr [0x5580], si
01ed:87e2	mov	si, es
01ed:87e4	mov	word ptr [0x5582], si
01ed:87e8	lds	si, ptr [bp + 4]
01ed:87eb	mov	word ptr cs:[0x8485], si
01ed:87f0	mov	ax, ds
01ed:87f2	mov	word ptr cs:[0x8487], ax
01ed:87f6	call	0x8809
01ed:87f9	and	ax, ax
01ed:87fb	je	loc_a6d3
01ed:87fd	call	0x8722
01ed:8800	mov	ax, 1
        	loc_a6d3:
01ed:8803	pop	di
01ed:8804	pop	si
01ed:8805	pop	ds
01ed:8806	pop	es
01ed:8807	pop	bp
01ed:8808	ret	
01ed:8809		
        	loc_a847:
01ed:8977	push	ds
01ed:8978	mov	ax, 0x1228
01ed:897b	mov	ds, ax
01ed:897d	mov	ax, word ptr [0x5586]
01ed:8980	cmp	ax, 0x8000
01ed:8983	mov	ax, 0
01ed:8986	je	loc_a865
01ed:8988	mov	ax, 0
01ed:898b	call	0x7e1f
01ed:898e	pop	ds
01ed:898f	call	0x85b5
01ed:8992	jmp	loc_a69d
        	loc_a865:
01ed:8995	pop	ds
01ed:8996	and	ax, ax
01ed:8998	ret	
sub_a847 ENDP
*/
void sub_a847()
{
    // coverage: 0x99cd-0x9a09 method sub_a847
    // coverage: 0x9b77-0x9b99 method sub_a847
    push(0x7777);
    goto loc_a847;
loc_a69d:
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(si);
    push(di);
    ax = memoryAGet16(ss, bp + 12);
    memoryASet16(cs, 0x8483, ax);
    si = memoryAGet16(ss, bp + 8);
    es = memoryAGet16(ss, bp + 8 + 2);
    memoryASet16(ds, 0x5580, si);
    si = es;
    memoryASet16(ds, 0x5582, si);
    si = memoryAGet16(ss, bp + 4);
    ds = memoryAGet16(ss, bp + 4 + 2);
    memoryASet16(cs, 0x8485, si);
    ax = ds;
    memoryASet16(cs, 0x8487, ax);
    sub_a6d9();
    if (ax == 0)
        goto loc_a6d3;
    sub_a5f2();
    ax = 0x0001;
loc_a6d3:
    di = pop();
    si = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    return;
    //   gap of 366 bytes
loc_a847:
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x5586);
    tx = ax;
    ax = 0x0000;
    if (stop("check inject: cmp ax, 0x8000") && tx == 0x8000)
        goto loc_a865;
    ax = 0x0000;
    sub_9cef();
    ds = pop();
    sub_a485();
    goto loc_a69d;
loc_a865:
    ds = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:8999 sub_a869()
sub_a869 PROC
01ed:8999	mov	ax, word ptr cs:[0x85a1]
01ed:899d	and	ax, ax
01ed:899f	jne	loc_a877
01ed:89a1	mov	ax, word ptr cs:[0x8483]
01ed:89a5	and	ax, ax
        	loc_a877:
01ed:89a7	ret	
sub_a869 ENDP
*/
void sub_a869()
{
    // coverage: 0x9b99-0x9ba8 method sub_a869
    ax = memoryAGet16(cs, 0x85a1);
    if (ax != 0)
        return;
    ax = memoryAGet16(cs, 0x8483);
}
/* Assembly listing of 01ed:89a8 sub_a878()
sub_a878 PROC
01ed:89a8	push	ds
01ed:89a9	mov	ax, 0x1228
01ed:89ac	mov	ds, ax
01ed:89ae	mov	ax, 0
01ed:89b1	call	0x7e1f
01ed:89b4	pop	ds
01ed:89b5	call	0x85b5
01ed:89b8	ret	
sub_a878 ENDP
*/
void sub_a878()
{
    // coverage: 0x9ba8-0x9bb9 method sub_a878
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = 0x0000;
    sub_9cef();
    ds = pop();
    sub_a485();
}
/* Assembly listing of 01ed:89e2 sub_a8b2()
sub_a8b2 PROC
01ed:89e2	push	cx
01ed:89e3	xor	cx, cx
01ed:89e5	mov	dx, 0x331
        	loc_a8b8:
01ed:89e8	in	al, dx
01ed:89e9	test	al, 0x40
01ed:89eb	loopne	loc_a8b8
01ed:89ed	jne	loc_a8c5
01ed:89ef	dec	dx
01ed:89f0	mov	al, ah
01ed:89f2	out	dx, al
        	loc_a8c3:
01ed:89f3	pop	cx
01ed:89f4	ret	
        	loc_a8c5:
01ed:89f5	push	ds
01ed:89f6	mov	ax, 0x1228
01ed:89f9	mov	ds, ax
01ed:89fb	mov	word ptr [0x557c], cx
01ed:89ff	pop	ds
01ed:8a00	mov	word ptr cs:[0x85a1], cx
01ed:8a05	jmp	loc_a8c3
sub_a8b2 ENDP
*/
void sub_a8b2()
{
    // coverage: 0x9be2-0x9c07 method sub_a8b2
    push(cx);
    cx = 0;
    dx = 0x0331;
loc_a8b8:
    in(al, dx);
    if (--cx && al & 0x40)
        goto loc_a8b8;
    if (al & 0x40)
        goto loc_a8c5;
    dx--;
    al = ah;
    out(dx, al);
loc_a8c3:
    cx = pop();
    return;
loc_a8c5:
    push(ds);
    ax = 0x1228;
    ds = ax;
    memoryASet16(ds, 0x557c, cx);
    ds = pop();
    memoryASet16(cs, 0x85a1, cx);
    goto loc_a8c3;
}
/* Assembly listing of 01ed:8a07 sub_a8d7()
sub_a8d7 PROC
01ed:8a07	mov	ah, 0x99
01ed:8a09	jmp	loc_a8dd
01ed:8a0b		
        	loc_a8dd:
01ed:8a0d	push	bp
01ed:8a0e	mov	bp, sp
01ed:8a10	push	dx
01ed:8a11	call	0x89e2
01ed:8a14	mov	ah, byte ptr [bp + 4]
01ed:8a17	call	0x89e2
01ed:8a1a	mov	ah, byte ptr [bp + 6]
01ed:8a1d	call	0x89e2
01ed:8a20	pop	dx
01ed:8a21	pop	bp
01ed:8a22	ret	
sub_a8d7 ENDP
*/
void sub_a8d7()
{
    // coverage: 0x9c07-0x9c0b method sub_a8d7
    // coverage: 0x9c0d-0x9c23 method sub_a8d7
    push(0x7777);
    ah = 0x99;
    goto loc_a8dd;
    //   gap of 2 bytes
loc_a8dd:
    push(bp);
    bp = sp;
    push(dx);
    sub_a8b2();
    ah = memoryAGet(ss, bp + 4);
    sub_a8b2();
    ah = memoryAGet(ss, bp + 6);
    sub_a8b2();
    dx = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:8a23 sub_a8f3()
sub_a8f3 PROC
01ed:8a23	push	ax
01ed:8a24	push	bx
01ed:8a25	mov	ax, si
01ed:8a27	and	si, 0xf
01ed:8a2a	shr	ax, 1
01ed:8a2c	shr	ax, 1
01ed:8a2e	shr	ax, 1
01ed:8a30	shr	ax, 1
01ed:8a32	mov	bx, ds
01ed:8a34	add	ax, bx
01ed:8a36	mov	ds, ax
01ed:8a38	pop	bx
01ed:8a39	pop	ax
01ed:8a3a	ret	
sub_a8f3 ENDP
*/
void sub_a8f3()
{
    // coverage: 0x9c23-0x9c3b method sub_a8f3
    push(ax);
    push(bx);
    ax = si;
    si &= 0x000f;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    bx = ds;
    ax += bx;
    ds = ax;
    bx = pop();
    ax = pop();
}
/* Assembly listing of 01ed:8a75 sub_a945()
sub_a945 PROC
01ed:8a75	push	ax
01ed:8a76	push	bx
01ed:8a77	push	cx
01ed:8a78	push	dx
01ed:8a79	cmp	word ptr [0x557c], 0
01ed:8a7e	je	loc_a996
01ed:8a80	mov	cx, 0x1388
01ed:8a83	mov	dx, 0x331
        	loc_a956:
01ed:8a86	in	al, dx
01ed:8a87	test	al, 0x40
01ed:8a89	loopne	loc_a956
01ed:8a8b	jne	loc_a990
01ed:8a8d	mov	al, 0xff
01ed:8a8f	out	dx, al
01ed:8a90	mov	bx, 3
        	loc_a963:
01ed:8a93	mov	cx, 0x1388
01ed:8a96	mov	dx, 0x331
        	loc_a969:
01ed:8a99	in	al, dx
01ed:8a9a	test	al, 0x80
01ed:8a9c	loopne	loc_a969
01ed:8a9e	jne	loc_a98d
01ed:8aa0	mov	dx, 0x330
01ed:8aa3	in	al, dx
01ed:8aa4	cmp	al, 0xfe
01ed:8aa6	jne	loc_a98d
01ed:8aa8	mov	cx, 0x1388
01ed:8aab	mov	dx, 0x331
        	loc_a97e:
01ed:8aae	in	al, dx
01ed:8aaf	test	al, 0x40
01ed:8ab1	loopne	loc_a97e
01ed:8ab3	jne	loc_a990
01ed:8ab5	mov	dx, 0x331
01ed:8ab8	mov	al, 0x3f
01ed:8aba	out	dx, al
01ed:8abb	jmp	loc_a996
        	loc_a98d:
01ed:8abd	dec	bx
01ed:8abe	jne	loc_a963
        	loc_a990:
01ed:8ac0	mov	word ptr [0x557c], 0
        	loc_a996:
01ed:8ac6	pop	dx
01ed:8ac7	pop	cx
01ed:8ac8	pop	bx
01ed:8ac9	pop	cx
01ed:8aca	mov	ax, word ptr [0x557c]
01ed:8acd	and	ax, ax
01ed:8acf	ret	
sub_a945 ENDP
*/
void sub_a945()
{
    // coverage: 0x9c75-0x9cd0 method sub_a945
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    if (memoryAGet16(ds, 0x557c) == 0x0000)
        goto loc_a996;
    cx = 0x1388;
    dx = 0x0331;
loc_a956:
    in(al, dx);
    if (--cx && al & 0x40)
        goto loc_a956;
    if (al & 0x40)
        goto loc_a990;
    al = 0xff;
    out(dx, al);
    bx = 0x0003;
loc_a963:
    cx = 0x1388;
    dx = 0x0331;
loc_a969:
    in(al, dx);
    if (--cx && al & 0x80)
        goto loc_a969;
    if (al & 0x80)
        goto loc_a98d;
    dx = 0x0330;
    in(al, dx);
    if (al != 0xfe)
        goto loc_a98d;
    cx = 0x1388;
    dx = 0x0331;
loc_a97e:
    in(al, dx);
    if (--cx && al & 0x40)
        goto loc_a97e;
    if (al & 0x40)
        goto loc_a990;
    dx = 0x0331;
    al = 0x3f;
    out(dx, al);
    goto loc_a996;
loc_a98d:
    tx = bx;
    bx--;
    if (tx != 1)
        goto loc_a963;
loc_a990:
    memoryASet16(ds, 0x557c, 0x0000);
loc_a996:
    dx = pop();
    cx = pop();
    bx = pop();
    cx = pop();
    ax = memoryAGet16(ds, 0x557c);
    flags.zero = ax == 0;
}
/* Assembly listing of 01ed:8ad0 sub_a9a0()
sub_a9a0 PROC
01ed:8ad0	push	dx
01ed:8ad1	push	cx
01ed:8ad2	push	bx
01ed:8ad3	push	ax
01ed:8ad4	mov	bx, 0x9009
        	loc_a9a7:
01ed:8ad7	mov	cx, 0x7f
        	loc_a9aa:
01ed:8ada	mov	ah, bh
01ed:8adc	add	ah, bl
01ed:8ade	call	0x89e2
01ed:8ae1	mov	ah, cl
01ed:8ae3	call	0x89e2
01ed:8ae6	xor	ah, ah
01ed:8ae8	call	0x89e2
01ed:8aeb	loop	loc_a9aa
01ed:8aed	dec	bl
01ed:8aef	jne	loc_a9a7
01ed:8af1	pop	ax
01ed:8af2	pop	bx
01ed:8af3	pop	cx
01ed:8af4	pop	dx
01ed:8af5	ret	
sub_a9a0 ENDP
*/
void sub_a9a0()
{
    // coverage: 0x9cd0-0x9cf6 method sub_a9a0
    push(dx);
    push(cx);
    push(bx);
    push(ax);
    bx = 0x9009;
loc_a9a7:
    cx = 0x007f;
loc_a9aa:
    ah = bh;
    ah += bl;
    sub_a8b2();
    ah = cl;
    sub_a8b2();
    ah = 0;
    sub_a8b2();
    if (--cx)
        goto loc_a9aa;
    tl = bl;
    bl--;
    if (tl != 1)
        goto loc_a9a7;
    ax = pop();
    bx = pop();
    cx = pop();
    dx = pop();
}
/* Assembly listing of 01ed:8af6 sub_a9c6()
sub_a9c6 PROC
01ed:8af6	push	ax
01ed:8af7	push	cx
01ed:8af8	lodsb	al, byte ptr [si]
01ed:8af9	mov	cl, al
01ed:8afb	lodsb	al, byte ptr [si]
01ed:8afc	dec	cl
01ed:8afe	call	0x872e
01ed:8b01	pop	cx
01ed:8b02	pop	ax
01ed:8b03	ret	
sub_a9c6 ENDP
*/
void sub_a9c6()
{
    // coverage: 0x9cf6-0x9d04 method sub_a9c6
    push(ax);
    push(cx);
    lodsb<MemAuto, DirAuto>();
    cl = al;
    lodsb<MemAuto, DirAuto>();
    cl--;
    sub_a5fe();
    cx = pop();
    ax = pop();
}
/* Assembly listing of 01ed:8b04 sub_a9d4()
sub_a9d4 PROC
01ed:8b04	push	cx
01ed:8b05	mov	cl, byte ptr [si]
01ed:8b07	inc	si
01ed:8b08	call	0x872e
01ed:8b0b	pop	cx
01ed:8b0c	ret	
sub_a9d4 ENDP
*/
void sub_a9d4()
{
    // coverage: 0x9d04-0x9d0d method sub_a9d4
    push(cx);
    cl = memoryAGet(ds, si);
    si++;
    sub_a5fe();
    cx = pop();
}
/* Assembly listing of 01ed:8b0d sub_a9dd()
sub_a9dd PROC
01ed:8b0d	push	cx
01ed:8b0e	test	al, 0xf
01ed:8b10	jne	loc_a9e7
01ed:8b12	or	al, byte ptr cs:[bx + 0x80]
        	loc_a9e7:
01ed:8b17	mov	cx, 2
01ed:8b1a	mov	ah, al
01ed:8b1c	and	ah, 0xf0
01ed:8b1f	cmp	ah, 0xc0
01ed:8b22	jne	loc_a9f5
01ed:8b24	dec	cx
        	loc_a9f5:
01ed:8b25	call	0x872e
01ed:8b28	pop	cx
01ed:8b29	ret	
sub_a9dd ENDP
*/
void sub_a9dd()
{
    // coverage: 0x9d0d-0x9d2a method sub_a9dd
    push(cx);
    if (al & 0x0f)
        goto loc_a9e7;
    al |= memoryAGet(cs, bx + 128);
loc_a9e7:
    cx = 0x0002;
    ah = al;
    ah &= 0xf0;
    if (ah != 0xc0)
        goto loc_a9f5;
    cx--;
loc_a9f5:
    sub_a5fe();
    cx = pop();
}
/* Assembly listing of 01ed:8b2a sub_a9fa()
sub_a9fa PROC
01ed:8b2a	mov	ax, 1
01ed:8b2d	mov	word ptr [0x557e], ax
01ed:8b30	call	0x8fb6
01ed:8b33	je	loc_aa0a
01ed:8b35	call	0x8eeb
01ed:8b38	jmp	loc_aa10
        	loc_aa0a:
01ed:8b3a	mov	word ptr [0x557e], 0
        	loc_aa10:
01ed:8b40	mov	ax, word ptr [0x557e]
01ed:8b43	and	ax, ax
01ed:8b45	ret	
sub_a9fa ENDP
*/
void sub_a9fa()
{
    // coverage: 0x9d2a-0x9d46 method sub_a9fa
    ax = 0x0001;
    memoryASet16(ds, 0x557e, ax);
    sub_ae86();
    if (flags.zero)
        goto loc_aa0a;
    sub_adbb();
    goto loc_aa10;
loc_aa0a:
    memoryASet16(ds, 0x557e, 0x0000);
loc_aa10:
    ax = memoryAGet16(ds, 0x557e);
    flags.zero = ax == 0;
}
/* Assembly listing of 01ed:8b6b sub_aa3b()
sub_aa3b PROC
01ed:8b6b	push	ax
01ed:8b6c	push	di
01ed:8b6d	push	si
01ed:8b6e	push	cx
01ed:8b6f	push	ds
01ed:8b70	push	bx
01ed:8b71	push	es
01ed:8b72	mov	bl, al
01ed:8b74	xor	bh, bh
01ed:8b76	call	0x8b81
01ed:8b79	pop	es
01ed:8b7a	pop	bx
01ed:8b7b	pop	ds
01ed:8b7c	pop	cx
01ed:8b7d	pop	si
01ed:8b7e	pop	di
01ed:8b7f	pop	ax
01ed:8b80	ret	
sub_aa3b ENDP
*/
void sub_aa3b()
{
    // coverage: 0x9d6b-0x9d81 method sub_aa3b
    push(ax);
    push(di);
    push(si);
    push(cx);
    push(ds);
    push(bx);
    push(es);
    bl = al;
    bh = 0;
    sub_aa51();
    es = pop();
    bx = pop();
    ds = pop();
    cx = pop();
    si = pop();
    di = pop();
    ax = pop();
}
/* Assembly listing of 01ed:8b81 sub_aa51()
sub_aa51 PROC
01ed:8b81	push	si
01ed:8b82	push	di
01ed:8b83	push	ds
01ed:8b84	push	es
01ed:8b85	mov	si, 0x1228
01ed:8b88	mov	ds, si
01ed:8b8a	lds	si, ptr [0x5580]
01ed:8b8e	mov	di, word ptr [si + 0xc]
01ed:8b91	add	di, si
01ed:8b93	add	bx, bx
01ed:8b95	add	bx, bx
01ed:8b97	mov	cx, bx
01ed:8b99	add	bx, bx
01ed:8b9b	add	bx, cx
01ed:8b9d	add	di, bx
01ed:8b9f	mov	bx, word ptr [di]
01ed:8ba1	add	bx, bx
01ed:8ba3	mov	di, bx
01ed:8ba5	add	bx, bx
01ed:8ba7	add	bx, bx
01ed:8ba9	add	bx, bx
01ed:8bab	add	bx, bx
01ed:8bad	sub	bx, di
01ed:8baf	mov	di, word ptr [si + 0x10]
01ed:8bb2	add	di, si
01ed:8bb4	add	di, bx
01ed:8bb6	xor	bx, bx
01ed:8bb8	push	ds
01ed:8bb9	push	di
01ed:8bba	mov	al, ah
01ed:8bbc	pop	di
01ed:8bbd	pop	ds
01ed:8bbe	xor	ah, ah
01ed:8bc0	call	0x8bc8
01ed:8bc3	pop	es
01ed:8bc4	pop	ds
01ed:8bc5	pop	di
01ed:8bc6	pop	si
01ed:8bc7	ret	
sub_aa51 ENDP
*/
void sub_aa51()
{
    // coverage: 0x9d81-0x9dc8 method sub_aa51
    push(si);
    push(di);
    push(ds);
    push(es);
    si = 0x1228;
    ds = si;
    si = memoryAGet16(ds, 0x5580);
    ds = memoryAGet16(ds, 0x5580 + 2);
    di = memoryAGet16(ds, si + 12);
    di += si;
    bx += bx;
    bx += bx;
    cx = bx;
    bx += bx;
    bx += cx;
    di += bx;
    bx = memoryAGet16(ds, di);
    bx += bx;
    di = bx;
    bx += bx;
    bx += bx;
    bx += bx;
    bx += bx;
    bx -= di;
    di = memoryAGet16(ds, si + 16);
    di += si;
    di += bx;
    bx = 0;
    push(ds);
    push(di);
    al = ah;
    di = pop();
    ds = pop();
    ah = 0;
    sub_aa98();
    es = pop();
    ds = pop();
    di = pop();
    si = pop();
}
/* Assembly listing of 01ed:8bc8 sub_aa98()
sub_aa98 PROC
01ed:8bc8	push	ax
01ed:8bc9	push	bx
01ed:8bca	push	cx
01ed:8bcb	push	dx
01ed:8bcc	push	ax
01ed:8bcd	mov	ah, 8
01ed:8bcf	mov	al, 0
01ed:8bd1	call	0x9007
01ed:8bd4	pop	ax
01ed:8bd5	mov	dh, byte ptr [bx + di]
01ed:8bd7	and	dh, dh
01ed:8bd9	je	loc_aaae
01ed:8bdb	jmp	loc_ac56
        	loc_aaae:
01ed:8bde	mov	dl, al
01ed:8be0	add	dl, 0xc0
01ed:8be3	mov	dh, byte ptr [bx + di + 4]
01ed:8be6	and	dh, 7
01ed:8be9	shl	dh, 1
01ed:8beb	mov	ah, byte ptr [bx + di + 0xe]
01ed:8bee	and	ah, 1
01ed:8bf1	xor	ah, 1
01ed:8bf4	or	dh, ah
01ed:8bf6	push	ax
01ed:8bf7	mov	ah, dl
01ed:8bf9	mov	al, dh
01ed:8bfb	call	0x9007
01ed:8bfe	pop	ax
01ed:8bff	xor	ah, ah
01ed:8c01	push	ds
01ed:8c02	push	di
01ed:8c03	mov	cx, 0x1228
01ed:8c06	mov	ds, cx
01ed:8c08	mov	di, 0x5593
01ed:8c0b	add	di, ax
01ed:8c0d	mov	al, byte ptr [di]
01ed:8c0f	pop	di
01ed:8c10	pop	ds
01ed:8c11	mov	dl, al
01ed:8c13	add	dl, 0x40
01ed:8c16	mov	dh, byte ptr [bx + di + 0xa]
01ed:8c19	and	dh, 0x3f
01ed:8c1c	mov	ah, byte ptr [bx + di + 2]
01ed:8c1f	shr	ah, 1
01ed:8c21	shr	ah, 1
01ed:8c23	and	ah, 0xc0
01ed:8c26	or	dh, ah
01ed:8c28	push	ax
01ed:8c29	mov	ah, dl
01ed:8c2b	mov	al, dh
01ed:8c2d	call	0x9007
01ed:8c30	pop	ax
01ed:8c31	mov	dl, al
01ed:8c33	add	dl, 0x60
01ed:8c36	mov	dh, byte ptr [bx + di + 5]
01ed:8c39	and	dh, 0xf
01ed:8c3c	shl	dh, 1
01ed:8c3e	shl	dh, 1
01ed:8c40	shl	dh, 1
01ed:8c42	shl	dh, 1
01ed:8c44	mov	ah, byte ptr [bx + di + 8]
01ed:8c47	and	ah, 0xf
01ed:8c4a	or	dh, ah
01ed:8c4c	push	ax
01ed:8c4d	mov	ah, dl
01ed:8c4f	mov	al, dh
01ed:8c51	call	0x9007
01ed:8c54	pop	ax
01ed:8c55	mov	dl, al
01ed:8c57	add	dl, 0x80
01ed:8c5a	mov	dh, byte ptr [bx + di + 6]
01ed:8c5d	and	dh, 0xf
01ed:8c60	shl	dh, 1
01ed:8c62	shl	dh, 1
01ed:8c64	shl	dh, 1
01ed:8c66	shl	dh, 1
01ed:8c68	mov	ah, byte ptr [bx + di + 9]
01ed:8c6b	and	ah, 0xf
01ed:8c6e	or	dh, ah
01ed:8c70	push	ax
01ed:8c71	mov	ah, dl
01ed:8c73	mov	al, dh
01ed:8c75	call	0x9007
01ed:8c78	pop	ax
01ed:8c79	mov	dl, al
01ed:8c7b	add	dl, 0x20
01ed:8c7e	mov	dh, byte ptr [bx + di + 3]
01ed:8c81	and	dh, 0xf
01ed:8c84	mov	ah, byte ptr [bx + di + 0xb]
01ed:8c87	and	ah, ah
01ed:8c89	je	loc_ab5e
01ed:8c8b	or	dh, 0x80
        	loc_ab5e:
01ed:8c8e	mov	ah, byte ptr [bx + di + 0xc]
01ed:8c91	and	ah, ah
01ed:8c93	je	loc_ab68
01ed:8c95	or	dh, 0x40
        	loc_ab68:
01ed:8c98	mov	ah, byte ptr [bx + di + 7]
01ed:8c9b	and	ah, ah
01ed:8c9d	je	loc_ab72
01ed:8c9f	or	dh, 0x20
        	loc_ab72:
01ed:8ca2	mov	ah, byte ptr [bx + di + 0xd]
01ed:8ca5	and	ah, ah
01ed:8ca7	je	loc_ab7c
01ed:8ca9	or	dh, 0x10
        	loc_ab7c:
01ed:8cac	push	ax
01ed:8cad	mov	ah, dl
01ed:8caf	mov	al, dh
01ed:8cb1	call	0x9007
01ed:8cb4	pop	ax
01ed:8cb5	mov	dl, al
01ed:8cb7	add	dl, 0x43
01ed:8cba	mov	dh, byte ptr [bx + di + 0x17]
01ed:8cbd	and	dh, 0x3f
01ed:8cc0	mov	ah, byte ptr [bx + di + 0xf]
01ed:8cc3	shr	ah, 1
01ed:8cc5	shr	ah, 1
01ed:8cc7	and	ah, 0xc0
01ed:8cca	or	dh, ah
01ed:8ccc	push	ax
01ed:8ccd	mov	ah, dl
01ed:8ccf	mov	al, dh
01ed:8cd1	call	0x9007
01ed:8cd4	pop	ax
01ed:8cd5	mov	dl, al
01ed:8cd7	add	dl, 0x63
01ed:8cda	mov	dh, byte ptr [bx + di + 0x12]
01ed:8cdd	and	dh, 0xf
01ed:8ce0	shl	dh, 1
01ed:8ce2	shl	dh, 1
01ed:8ce4	shl	dh, 1
01ed:8ce6	shl	dh, 1
01ed:8ce8	mov	ah, byte ptr [bx + di + 0x15]
01ed:8ceb	and	ah, 0xf
01ed:8cee	or	dh, ah
01ed:8cf0	push	ax
01ed:8cf1	mov	ah, dl
01ed:8cf3	mov	al, dh
01ed:8cf5	call	0x9007
01ed:8cf8	pop	ax
01ed:8cf9	mov	dl, al
01ed:8cfb	add	dl, 0x83
01ed:8cfe	mov	dh, byte ptr [bx + di + 0x13]
01ed:8d01	and	dh, 0xf
01ed:8d04	shl	dh, 1
01ed:8d06	shl	dh, 1
01ed:8d08	shl	dh, 1
01ed:8d0a	shl	dh, 1
01ed:8d0c	mov	ah, byte ptr [bx + di + 0x16]
01ed:8d0f	and	ah, 0xf
01ed:8d12	or	dh, ah
01ed:8d14	push	ax
01ed:8d15	mov	ah, dl
01ed:8d17	mov	al, dh
01ed:8d19	call	0x9007
01ed:8d1c	pop	ax
01ed:8d1d	mov	dl, al
01ed:8d1f	add	dl, 0x23
01ed:8d22	mov	dh, byte ptr [bx + di + 0x10]
01ed:8d25	and	dh, 0xf
01ed:8d28	mov	ah, byte ptr [bx + di + 0x18]
01ed:8d2b	and	ah, ah
01ed:8d2d	je	loc_ac02
01ed:8d2f	or	dh, 0x80
        	loc_ac02:
01ed:8d32	mov	ah, byte ptr [bx + di + 0x19]
01ed:8d35	and	ah, ah
01ed:8d37	je	loc_ac0c
01ed:8d39	or	dh, 0x40
        	loc_ac0c:
01ed:8d3c	mov	ah, byte ptr [bx + di + 0x14]
01ed:8d3f	and	ah, ah
01ed:8d41	je	loc_ac16
01ed:8d43	or	dh, 0x20
        	loc_ac16:
01ed:8d46	mov	ah, byte ptr [bx + di + 0x1a]
01ed:8d49	and	ah, ah
01ed:8d4b	je	loc_ac20
01ed:8d4d	or	dh, 0x10
        	loc_ac20:
01ed:8d50	push	ax
01ed:8d51	mov	ah, dl
01ed:8d53	mov	al, dh
01ed:8d55	call	0x9007
01ed:8d58	pop	ax
01ed:8d59	mov	dl, al
01ed:8d5b	add	dl, 0xe0
01ed:8d5e	mov	dh, byte ptr [bx + di + 0x1c]
01ed:8d61	and	dh, 3
01ed:8d64	push	ax
01ed:8d65	mov	ah, dl
01ed:8d67	mov	al, dh
01ed:8d69	call	0x9007
01ed:8d6c	pop	ax
01ed:8d6d	mov	dl, al
01ed:8d6f	add	dl, 0xe3
01ed:8d72	mov	dh, byte ptr [bx + di + 0x1d]
01ed:8d75	and	dh, 3
01ed:8d78	push	ax
01ed:8d79	mov	ah, dl
01ed:8d7b	mov	al, dh
01ed:8d7d	call	0x9007
01ed:8d80	pop	ax
        	loc_ac51:
01ed:8d81	pop	dx
01ed:8d82	pop	cx
01ed:8d83	pop	bx
01ed:8d84	pop	ax
01ed:8d85	ret	
        	loc_ac56:
01ed:8d86	mov	al, 1
01ed:8d88	mov	dl, al
01ed:8d8a	add	dl, 0x40
01ed:8d8d	mov	dh, byte ptr [bx + di + 0xa]
01ed:8d90	and	dh, 0x3f
01ed:8d93	mov	ah, byte ptr [bx + di + 2]
01ed:8d96	shr	ah, 1
01ed:8d98	shr	ah, 1
01ed:8d9a	and	ah, 0xc0
01ed:8d9d	or	dh, ah
01ed:8d9f	push	ax
01ed:8da0	mov	ah, dl
01ed:8da2	mov	al, dh
01ed:8da4	call	0x9007
01ed:8da7	pop	ax
01ed:8da8	mov	dl, al
01ed:8daa	add	dl, 0x60
01ed:8dad	mov	dh, byte ptr [bx + di + 5]
01ed:8db0	and	dh, 0xf
01ed:8db3	shl	dh, 1
01ed:8db5	shl	dh, 1
01ed:8db7	shl	dh, 1
01ed:8db9	shl	dh, 1
01ed:8dbb	mov	ah, byte ptr [bx + di + 8]
01ed:8dbe	and	ah, 0xf
01ed:8dc1	or	dh, ah
01ed:8dc3	push	ax
01ed:8dc4	mov	ah, dl
01ed:8dc6	mov	al, dh
01ed:8dc8	call	0x9007
01ed:8dcb	pop	ax
01ed:8dcc	mov	dl, al
01ed:8dce	add	dl, 0x80
01ed:8dd1	mov	dh, byte ptr [bx + di + 6]
01ed:8dd4	and	dh, 0xf
01ed:8dd7	shl	dh, 1
01ed:8dd9	shl	dh, 1
01ed:8ddb	shl	dh, 1
01ed:8ddd	shl	dh, 1
01ed:8ddf	mov	ah, byte ptr [bx + di + 9]
01ed:8de2	and	ah, 0xf
01ed:8de5	or	dh, ah
01ed:8de7	push	ax
01ed:8de8	mov	ah, dl
01ed:8dea	mov	al, dh
01ed:8dec	call	0x9007
01ed:8def	pop	ax
01ed:8df0	mov	dl, al
01ed:8df2	add	dl, 0x20
01ed:8df5	mov	dh, byte ptr [bx + di + 3]
01ed:8df8	and	dh, 0xf
01ed:8dfb	mov	ah, byte ptr [bx + di + 0xb]
01ed:8dfe	and	ah, ah
01ed:8e00	je	loc_acd5
01ed:8e02	or	dh, 0x80
        	loc_acd5:
01ed:8e05	mov	ah, byte ptr [bx + di + 0xc]
01ed:8e08	and	ah, ah
01ed:8e0a	je	loc_acdf
01ed:8e0c	or	dh, 0x40
        	loc_acdf:
01ed:8e0f	mov	ah, byte ptr [bx + di + 7]
01ed:8e12	and	ah, ah
01ed:8e14	je	loc_ace9
01ed:8e16	or	dh, 0x20
        	loc_ace9:
01ed:8e19	mov	ah, byte ptr [bx + di + 0xd]
01ed:8e1c	and	ah, ah
01ed:8e1e	je	loc_acf3
01ed:8e20	or	dh, 0x10
        	loc_acf3:
01ed:8e23	push	ax
01ed:8e24	mov	ah, dl
01ed:8e26	mov	al, dh
01ed:8e28	call	0x9007
01ed:8e2b	pop	ax
01ed:8e2c	jmp	loc_ac51
sub_aa98 ENDP
*/
void sub_aa98()
{
    // coverage: 0x9dc8-0xa02f method sub_aa98
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    push(ax);
    ah = 0x08;
    al = 0x00;
    sub_aed7();
    ax = pop();
    dh = memoryAGet(ds, bx + di);
    if (dh == 0)
        goto loc_aaae;
    goto loc_ac56;
loc_aaae:
    dl = al;
    dl += 0xc0;
    dh = memoryAGet(ds, bx + di + 4);
    dh &= 0x07;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 14);
    ah &= 0x01;
    ah ^= 0x01;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    ah = 0;
    push(ds);
    push(di);
    cx = 0x1228;
    ds = cx;
    di = 0x5593;
    di += ax;
    al = memoryAGet(ds, di);
    di = pop();
    ds = pop();
    dl = al;
    dl += 0x40;
    dh = memoryAGet(ds, bx + di + 10);
    dh &= 0x3f;
    ah = memoryAGet(ds, bx + di + 2);
    ah >>= 1;
    ah >>= 1;
    ah &= 0xc0;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x60;
    dh = memoryAGet(ds, bx + di + 5);
    dh &= 0x0f;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 8);
    ah &= 0x0f;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x80;
    dh = memoryAGet(ds, bx + di + 6);
    dh &= 0x0f;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 9);
    ah &= 0x0f;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x20;
    dh = memoryAGet(ds, bx + di + 3);
    dh &= 0x0f;
    ah = memoryAGet(ds, bx + di + 11);
    if (ah == 0)
        goto loc_ab5e;
    dh |= 0x80;
loc_ab5e:
    ah = memoryAGet(ds, bx + di + 12);
    if (ah == 0)
        goto loc_ab68;
    dh |= 0x40;
loc_ab68:
    ah = memoryAGet(ds, bx + di + 7);
    if (ah == 0)
        goto loc_ab72;
    dh |= 0x20;
loc_ab72:
    ah = memoryAGet(ds, bx + di + 13);
    if (ah == 0)
        goto loc_ab7c;
    dh |= 0x10;
loc_ab7c:
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x43;
    dh = memoryAGet(ds, bx + di + 23);
    dh &= 0x3f;
    ah = memoryAGet(ds, bx + di + 15);
    ah >>= 1;
    ah >>= 1;
    ah &= 0xc0;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x63;
    dh = memoryAGet(ds, bx + di + 18);
    dh &= 0x0f;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 21);
    ah &= 0x0f;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x83;
    dh = memoryAGet(ds, bx + di + 19);
    dh &= 0x0f;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 22);
    ah &= 0x0f;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x23;
    dh = memoryAGet(ds, bx + di + 16);
    dh &= 0x0f;
    ah = memoryAGet(ds, bx + di + 24);
    if (ah == 0)
        goto loc_ac02;
    dh |= 0x80;
loc_ac02:
    ah = memoryAGet(ds, bx + di + 25);
    if (ah == 0)
        goto loc_ac0c;
    dh |= 0x40;
loc_ac0c:
    ah = memoryAGet(ds, bx + di + 20);
    if (ah == 0)
        goto loc_ac16;
    dh |= 0x20;
loc_ac16:
    ah = memoryAGet(ds, bx + di + 26);
    if (ah == 0)
        goto loc_ac20;
    dh |= 0x10;
loc_ac20:
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0xe0;
    dh = memoryAGet(ds, bx + di + 28);
    dh &= 0x03;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0xe3;
    dh = memoryAGet(ds, bx + di + 29);
    dh &= 0x03;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
loc_ac51:
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
    return;
loc_ac56:
    al = 0x01;
    dl = al;
    dl += 0x40;
    dh = memoryAGet(ds, bx + di + 10);
    dh &= 0x3f;
    ah = memoryAGet(ds, bx + di + 2);
    ah >>= 1;
    ah >>= 1;
    ah &= 0xc0;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x60;
    dh = memoryAGet(ds, bx + di + 5);
    dh &= 0x0f;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 8);
    ah &= 0x0f;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x80;
    dh = memoryAGet(ds, bx + di + 6);
    dh &= 0x0f;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    dh <<= 1;
    ah = memoryAGet(ds, bx + di + 9);
    ah &= 0x0f;
    dh |= ah;
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dl = al;
    dl += 0x20;
    dh = memoryAGet(ds, bx + di + 3);
    dh &= 0x0f;
    ah = memoryAGet(ds, bx + di + 11);
    if (ah == 0)
        goto loc_acd5;
    dh |= 0x80;
loc_acd5:
    ah = memoryAGet(ds, bx + di + 12);
    if (ah == 0)
        goto loc_acdf;
    dh |= 0x40;
loc_acdf:
    ah = memoryAGet(ds, bx + di + 7);
    if (ah == 0)
        goto loc_ace9;
    dh |= 0x20;
loc_ace9:
    ah = memoryAGet(ds, bx + di + 13);
    if (ah == 0)
        goto loc_acf3;
    dh |= 0x10;
loc_acf3:
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    goto loc_ac51;
}
/* Assembly listing of 01ed:8e2f sub_acff()
sub_acff PROC
01ed:8e2f	push	ax
01ed:8e30	mov	bx, 1
        	loc_ad03:
01ed:8e33	push	bx
01ed:8e34	xor	ax, ax
01ed:8e36	push	ax
01ed:8e37	push	ax
01ed:8e38	push	ax
01ed:8e39	call	0x905d
01ed:8e3c	pop	ax
01ed:8e3d	pop	ax
01ed:8e3e	pop	ax
01ed:8e3f	pop	bx
01ed:8e40	inc	bx
01ed:8e41	cmp	bx, 9
01ed:8e44	jle	loc_ad03
01ed:8e46	pop	ax
01ed:8e47	ret	
sub_acff ENDP
*/
void sub_acff()
{
    // coverage: 0xa02f-0xa048 method sub_acff
    push(ax);
    bx = 0x0001;
loc_ad03:
    push(bx);
    ax = 0;
    push(ax);
    push(ax);
    push(ax);
    sub_af2d();
    ax = pop();
    ax = pop();
    ax = pop();
    bx = pop();
    bx++;
    if ((short)bx <= (short)0x0009)
        goto loc_ad03;
    ax = pop();
}
/* Assembly listing of 01ed:8e48 sub_ad18()
sub_ad18 PROC
01ed:8e48	push	ax
01ed:8e49	lodsb	al, byte ptr [si]
01ed:8e4a	mov	ah, 0
01ed:8e4c	add	si, ax
01ed:8e4e	pop	ax
01ed:8e4f	ret	
sub_ad18 ENDP
*/
void sub_ad18()
{
    // coverage: 0xa048-0xa050 method sub_ad18
    push(ax);
    lodsb<MemAuto, DirAuto>();
    ah = 0x00;
    si += ax;
    ax = pop();
}
/* Assembly listing of 01ed:8e50 sub_ad20()
sub_ad20 PROC
01ed:8e50	push	ax
01ed:8e51	lodsb	al, byte ptr [si]
01ed:8e52	mov	ah, 0
01ed:8e54	add	si, ax
01ed:8e56	pop	ax
01ed:8e57	ret	
sub_ad20 ENDP
*/
void sub_ad20()
{
    // coverage: 0xa050-0xa058 method sub_ad20
    push(ax);
    lodsb<MemAuto, DirAuto>();
    ah = 0x00;
    si += ax;
    ax = pop();
}
/* Assembly listing of 01ed:8e58 sub_ad28()
sub_ad28 PROC
01ed:8e58	push	bx
01ed:8e59	push	cx
01ed:8e5a	test	al, 0xf
01ed:8e5c	jne	loc_ad33
01ed:8e5e	or	al, byte ptr cs:[bx + 0x80]
        	loc_ad33:
01ed:8e63	mov	ah, al
01ed:8e65	and	ah, 0xf
01ed:8e68	cmp	ah, 8
01ed:8e6b	jle	loc_ad3f
01ed:8e6d	jmp	loc_ad53
        	loc_ad3f:
01ed:8e6f	mov	ah, al
01ed:8e71	and	ah, 0xf0
01ed:8e74	cmp	ah, 0xc0
01ed:8e77	je	loc_ad5e
01ed:8e79	cmp	ah, 0x90
01ed:8e7c	je	loc_ad6e
01ed:8e7e	cmp	ah, 0x80
01ed:8e81	je	loc_ad97
        	loc_ad53:
01ed:8e83	inc	si
01ed:8e84	and	al, 0xf0
01ed:8e86	cmp	al, 0xc0
01ed:8e88	je	loc_ad5b
01ed:8e8a	inc	si
        	loc_ad5b:
01ed:8e8b	pop	cx
01ed:8e8c	pop	bx
01ed:8e8d	ret	
        	loc_ad5e:
01ed:8e8e	call	0x8e93
01ed:8e91	jmp	loc_ad5b
01ed:8e93		
        	loc_ad6e:
01ed:8e9e	call	0x8ea3
01ed:8ea1	jmp	loc_ad5b
01ed:8ea3		
        	loc_ad97:
01ed:8ec7	push	ax
01ed:8ec8	and	al, 0xf
01ed:8eca	add	al, 0xb0
01ed:8ecc	mov	ah, al
01ed:8ece	push	ds
01ed:8ecf	push	bx
01ed:8ed0	mov	bx, 0x1ed
01ed:8ed3	mov	ds, bx
01ed:8ed5	mov	bx, 0x80cc
01ed:8ed8	add	bl, ah
01ed:8eda	adc	bh, 0
01ed:8edd	mov	al, byte ptr [bx]
01ed:8edf	pop	bx
01ed:8ee0	pop	ds
01ed:8ee1	and	al, 0xdf
01ed:8ee3	call	0x9007
01ed:8ee6	lodsb	al, byte ptr [si]
01ed:8ee7	lodsb	al, byte ptr [si]
01ed:8ee8	pop	ax
01ed:8ee9	jmp	loc_ad5b
sub_ad28 ENDP
*/
void sub_ad28()
{
    // coverage: 0xa058-0xa093 method sub_ad28
    // coverage: 0xa09e-0xa0a3 method sub_ad28
    // coverage: 0xa0c7-0xa0eb method sub_ad28
    push(bx);
    push(cx);
    if (al & 0x0f)
        goto loc_ad33;
    al |= memoryAGet(cs, bx + 128);
loc_ad33:
    ah = al;
    ah &= 0x0f;
    if ((char)ah <= (char)0x08)
        goto loc_ad3f;
    goto loc_ad53;
loc_ad3f:
    ah = al;
    ah &= 0xf0;
    if (ah == 0xc0)
        goto loc_ad5e;
    if (ah == 0x90)
        goto loc_ad6e;
    if (ah == 0x80)
        goto loc_ad97;
loc_ad53:
    si++;
    al &= 0xf0;
    if (al == 0xc0)
        goto loc_ad5b;
    si++;
loc_ad5b:
    cx = pop();
    bx = pop();
    return;
loc_ad5e:
    sub_ad63();
    goto loc_ad5b;
    //   gap of 11 bytes
loc_ad6e:
    sub_ad73();
    goto loc_ad5b;
    //   gap of 36 bytes
loc_ad97:
    push(ax);
    al &= 0x0f;
    al += 0xb0;
    ah = al;
    push(ds);
    push(bx);
    bx = 0x01ed;
    ds = bx;
    bx = 0x80cc;
    flags.carry = (bl + ah) >= 0x100;
    bl += ah;
    bh += flags.carry;
    al = memoryAGet(ds, bx);
    bx = pop();
    ds = pop();
    al &= 0xdf;
    sub_aed7();
    lodsb<MemAuto, DirAuto>();
    lodsb<MemAuto, DirAuto>();
    ax = pop();
    goto loc_ad5b;
}
/* Assembly listing of 01ed:8e93 sub_ad63()
sub_ad63 PROC
01ed:8e93	and	al, 0xf
01ed:8e95	mov	ah, al
01ed:8e97	mov	al, byte ptr [si]
01ed:8e99	call	0x8b6b
01ed:8e9c	inc	si
01ed:8e9d	ret	
sub_ad63 ENDP
*/
void sub_ad63()
{
    // coverage: 0xa093-0xa09e method sub_ad63
    al &= 0x0f;
    ah = al;
    al = memoryAGet(ds, si);
    sub_aa3b();
    si++;
}
/* Assembly listing of 01ed:8ea3 sub_ad73()
sub_ad73 PROC
01ed:8ea3	push	ax
01ed:8ea4	push	bx
01ed:8ea5	push	cx
01ed:8ea6	push	dx
01ed:8ea7	push	di
01ed:8ea8	push	es
01ed:8ea9	and	al, 0xf
01ed:8eab	xor	ah, ah
01ed:8ead	push	ax
01ed:8eae	lodsb	al, byte ptr [si]
01ed:8eaf	push	ax
01ed:8eb0	lodsb	al, byte ptr [si]
01ed:8eb1	push	ax
01ed:8eb2	and	ax, ax
01ed:8eb4	je	loc_ad89
01ed:8eb6	mov	ax, 0x20
        	loc_ad89:
01ed:8eb9	push	ax
01ed:8eba	call	0x905d
01ed:8ebd	add	sp, 8
01ed:8ec0	pop	es
01ed:8ec1	pop	di
01ed:8ec2	pop	dx
01ed:8ec3	pop	cx
01ed:8ec4	pop	bx
01ed:8ec5	pop	ax
01ed:8ec6	ret	
sub_ad73 ENDP
*/
void sub_ad73()
{
    // coverage: 0xa0a3-0xa0c7 method sub_ad73
    push(0x7777);
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    push(di);
    push(es);
    al &= 0x0f;
    ah = 0;
    push(ax);
    lodsb<MemAuto, DirAuto>();
    push(ax);
    lodsb<MemAuto, DirAuto>();
    push(ax);
    if (ax == 0)
        goto loc_ad89;
    ax = 0x0020;
loc_ad89:
    push(ax);
    sub_af2d();
    sp += 0x0008;
    es = pop();
    di = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:8eeb sub_adbb()
sub_adbb PROC
01ed:8eeb	push	ax
01ed:8eec	push	ax
01ed:8eed	mov	ah, 0x40
01ed:8eef	mov	al, 0xff
01ed:8ef1	call	0x9007
01ed:8ef4	pop	ax
01ed:8ef5	push	ax
01ed:8ef6	mov	ah, 0x41
01ed:8ef8	mov	al, 0xff
01ed:8efa	call	0x9007
01ed:8efd	pop	ax
01ed:8efe	push	ax
01ed:8eff	mov	ah, 0x42
01ed:8f01	mov	al, 0xff
01ed:8f03	call	0x9007
01ed:8f06	pop	ax
01ed:8f07	push	ax
01ed:8f08	mov	ah, 0x48
01ed:8f0a	mov	al, 0xff
01ed:8f0c	call	0x9007
01ed:8f0f	pop	ax
01ed:8f10	push	ax
01ed:8f11	mov	ah, 0x49
01ed:8f13	mov	al, 0xff
01ed:8f15	call	0x9007
01ed:8f18	pop	ax
01ed:8f19	push	ax
01ed:8f1a	mov	ah, 0x4a
01ed:8f1c	mov	al, 0xff
01ed:8f1e	call	0x9007
01ed:8f21	pop	ax
01ed:8f22	push	ax
01ed:8f23	mov	ah, 0x50
01ed:8f25	mov	al, 0xff
01ed:8f27	call	0x9007
01ed:8f2a	pop	ax
01ed:8f2b	push	ax
01ed:8f2c	mov	ah, 0x51
01ed:8f2e	mov	al, 0xff
01ed:8f30	call	0x9007
01ed:8f33	pop	ax
01ed:8f34	push	ax
01ed:8f35	mov	ah, 0x52
01ed:8f37	mov	al, 0xff
01ed:8f39	call	0x9007
01ed:8f3c	pop	ax
01ed:8f3d	push	ax
01ed:8f3e	mov	ah, 0x43
01ed:8f40	mov	al, 0xff
01ed:8f42	call	0x9007
01ed:8f45	pop	ax
01ed:8f46	push	ax
01ed:8f47	mov	ah, 0x44
01ed:8f49	mov	al, 0xff
01ed:8f4b	call	0x9007
01ed:8f4e	pop	ax
01ed:8f4f	push	ax
01ed:8f50	mov	ah, 0x45
01ed:8f52	mov	al, 0xff
01ed:8f54	call	0x9007
01ed:8f57	pop	ax
01ed:8f58	push	ax
01ed:8f59	mov	ah, 0x4b
01ed:8f5b	mov	al, 0xff
01ed:8f5d	call	0x9007
01ed:8f60	pop	ax
01ed:8f61	push	ax
01ed:8f62	mov	ah, 0x4c
01ed:8f64	mov	al, 0xff
01ed:8f66	call	0x9007
01ed:8f69	pop	ax
01ed:8f6a	push	ax
01ed:8f6b	mov	ah, 0x4d
01ed:8f6d	mov	al, 0xff
01ed:8f6f	call	0x9007
01ed:8f72	pop	ax
01ed:8f73	push	ax
01ed:8f74	mov	ah, 0x53
01ed:8f76	mov	al, 0xff
01ed:8f78	call	0x9007
01ed:8f7b	pop	ax
01ed:8f7c	push	ax
01ed:8f7d	mov	ah, 0x54
01ed:8f7f	mov	al, 0xff
01ed:8f81	call	0x9007
01ed:8f84	pop	ax
01ed:8f85	push	ax
01ed:8f86	mov	ah, 0x55
01ed:8f88	mov	al, 0xff
01ed:8f8a	call	0x9007
01ed:8f8d	pop	ax
01ed:8f8e	mov	ax, 0x100
        	loc_ae61:
01ed:8f91	call	0x9007
01ed:8f94	inc	ah
01ed:8f96	cmp	ah, 0x40
01ed:8f99	jne	loc_ae61
01ed:8f9b	mov	ax, 0x6000
        	loc_ae6e:
01ed:8f9e	call	0x9007
01ed:8fa1	inc	ah
01ed:8fa3	cmp	ah, 0xf6
01ed:8fa6	jne	loc_ae6e
01ed:8fa8	mov	ax, 0x406
01ed:8fab	call	0x9007
01ed:8fae	mov	ax, 0xbd00
01ed:8fb1	call	0x9007
01ed:8fb4	pop	ax
01ed:8fb5	ret	
sub_adbb ENDP
*/
void sub_adbb()
{
    // coverage: 0xa0eb-0xa1b6 method sub_adbb
    push(ax);
    push(ax);
    ah = 0x40;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x41;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x42;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x48;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x49;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x4a;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x50;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x51;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x52;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x43;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x44;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x45;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x4b;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x4c;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x4d;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x53;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x54;
    al = 0xff;
    sub_aed7();
    ax = pop();
    push(ax);
    ah = 0x55;
    al = 0xff;
    sub_aed7();
    ax = pop();
    ax = 0x0100;
loc_ae61:
    sub_aed7();
    ah++;
    if (ah != 0x40)
        goto loc_ae61;
    ax = 0x6000;
loc_ae6e:
    sub_aed7();
    ah++;
    if (ah != 0xf6)
        goto loc_ae6e;
    ax = 0x0406;
    sub_aed7();
    ax = 0xbd00;
    sub_aed7();
    ax = pop();
}
/* Assembly listing of 01ed:8fb6 sub_ae86()
sub_ae86 PROC
01ed:8fb6	push	ax
01ed:8fb7	push	cx
01ed:8fb8	push	dx
01ed:8fb9	mov	ax, 0x460
01ed:8fbc	call	0x9007
01ed:8fbf	mov	ax, 0x480
01ed:8fc2	call	0x9007
01ed:8fc5	call	0x9056
01ed:8fc8	push	ax
01ed:8fc9	mov	ax, 0x2ff
01ed:8fcc	call	0x9007
01ed:8fcf	mov	ax, 0x421
01ed:8fd2	call	0x9007
01ed:8fd5	mov	cx, 0xc7
        	loc_aea8:
01ed:8fd8	call	0x9056
01ed:8fdb	loop	loc_aea8
01ed:8fdd	call	0x9056
01ed:8fe0	push	ax
01ed:8fe1	mov	ax, 0x460
01ed:8fe4	call	0x9007
01ed:8fe7	mov	ax, 0x480
01ed:8fea	call	0x9007
01ed:8fed	pop	ax
01ed:8fee	pop	dx
01ed:8fef	mov	ah, 0
01ed:8ff1	and	al, 0xe0
01ed:8ff3	and	dl, 0xe0
01ed:8ff6	cmp	al, 0xc0
01ed:8ff8	jne	loc_aed1
01ed:8ffa	cmp	dl, 0
01ed:8ffd	jne	loc_aed1
01ed:8fff	mov	ah, 1
        	loc_aed1:
01ed:9001	and	ah, ah
01ed:9003	pop	dx
01ed:9004	pop	cx
01ed:9005	pop	ax
01ed:9006	ret	
sub_ae86 ENDP
*/
void sub_ae86()
{
    // coverage: 0xa1b6-0xa207 method sub_ae86
    push(ax);
    push(cx);
    push(dx);
    ax = 0x0460;
    sub_aed7();
    ax = 0x0480;
    sub_aed7();
    sub_af26();
    push(ax);
    ax = 0x02ff;
    sub_aed7();
    ax = 0x0421;
    sub_aed7();
    cx = 0x00c7;
loc_aea8:
    sub_af26();
    if (--cx)
        goto loc_aea8;
    sub_af26();
    push(ax);
    ax = 0x0460;
    sub_aed7();
    ax = 0x0480;
    sub_aed7();
    ax = pop();
    dx = pop();
    ah = 0x00;
    al &= 0xe0;
    dl &= 0xe0;
    if (al != 0xc0)
        goto loc_aed1;
    if (dl != 0x00)
        goto loc_aed1;
    ah = 0x01;
loc_aed1:
    flags.zero = ah == 0;
    dx = pop();
    cx = pop();
    ax = pop();
}
/* Assembly listing of 01ed:9007 sub_aed7()
sub_aed7 PROC
01ed:9007	pushf	
01ed:9008	cli	
01ed:9009	push	ax
01ed:900a	push	dx
01ed:900b	push	ds
01ed:900c	push	bx
01ed:900d	mov	bx, 0x1ed
01ed:9010	mov	ds, bx
01ed:9012	mov	bx, 0x80cc
01ed:9015	add	bl, ah
01ed:9017	adc	bh, 0
01ed:901a	mov	byte ptr [bx], al
01ed:901c	pop	bx
01ed:901d	pop	ds
01ed:901e	mov	dx, 0x388
01ed:9021	xchg	ah, al
01ed:9023	out	dx, al
01ed:9024	in	al, dx
01ed:9025	in	al, dx
01ed:9026	in	al, dx
01ed:9027	in	al, dx
01ed:9028	in	al, dx
01ed:9029	in	al, dx
01ed:902a	inc	dx
01ed:902b	xchg	ah, al
01ed:902d	out	dx, al
01ed:902e	dec	dx
01ed:902f	in	al, dx
01ed:9030	in	al, dx
01ed:9031	in	al, dx
01ed:9032	in	al, dx
01ed:9033	in	al, dx
01ed:9034	in	al, dx
01ed:9035	in	al, dx
01ed:9036	in	al, dx
01ed:9037	in	al, dx
01ed:9038	in	al, dx
01ed:9039	in	al, dx
01ed:903a	in	al, dx
01ed:903b	in	al, dx
01ed:903c	in	al, dx
01ed:903d	in	al, dx
01ed:903e	in	al, dx
01ed:903f	in	al, dx
01ed:9040	in	al, dx
01ed:9041	in	al, dx
01ed:9042	in	al, dx
01ed:9043	in	al, dx
01ed:9044	in	al, dx
01ed:9045	in	al, dx
01ed:9046	in	al, dx
01ed:9047	in	al, dx
01ed:9048	in	al, dx
01ed:9049	in	al, dx
01ed:904a	in	al, dx
01ed:904b	in	al, dx
01ed:904c	in	al, dx
01ed:904d	in	al, dx
01ed:904e	in	al, dx
01ed:904f	in	al, dx
01ed:9050	in	al, dx
01ed:9051	in	al, dx
01ed:9052	pop	dx
01ed:9053	pop	ax
01ed:9054	popf	
01ed:9055	ret	
sub_aed7 ENDP
*/
void sub_aed7()
{
    // coverage: 0xa207-0xa256 method sub_aed7
    tx = flags.carry | (flags.zero << 1);
    push(tx);
    flags.interrupts = false;
    push(ax);
    push(dx);
    push(ds);
    push(bx);
    bx = 0x01ed;
    ds = bx;
    bx = 0x80cc;
    flags.carry = (bl + ah) >= 0x100;
    bl += ah;
    bh += flags.carry;
    memoryASet(ds, bx, al);
    bx = pop();
    ds = pop();
    dx = 0x0388;
    tl = ah;
    ah = al;
    al = tl;
    out(dx, al);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    dx++;
    tl = ah;
    ah = al;
    al = tl;
    out(dx, al);
    dx--;
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    in(al, dx);
    dx = pop();
    ax = pop();
    tx = pop();
    flags.carry = tx & 1;
    flags.zero = (tx << 1) & 1;
}
/* Assembly listing of 01ed:9056 sub_af26()
sub_af26 PROC
01ed:9056	push	dx
01ed:9057	mov	dx, 0x388
01ed:905a	in	al, dx
01ed:905b	pop	dx
01ed:905c	ret	
sub_af26 ENDP
*/
void sub_af26()
{
    // coverage: 0xa256-0xa25d method sub_af26
    push(dx);
    dx = 0x0388;
    in(al, dx);
    dx = pop();
}
/* Assembly listing of 01ed:905d sub_af2d()
sub_af2d PROC
01ed:905d	push	bp
01ed:905e	mov	bp, sp
01ed:9060	push	bx
01ed:9061	push	cx
01ed:9062	push	dx
01ed:9063	push	ds
01ed:9064	push	ax
01ed:9065	mov	ah, 8
01ed:9067	mov	al, 0
01ed:9069	call	0x9007
01ed:906c	pop	ax
01ed:906d	push	bx
01ed:906e	push	ds
01ed:906f	push	ax
01ed:9070	mov	bx, 0x1228
01ed:9073	mov	ds, bx
01ed:9075	mov	bx, word ptr [bp + 0xa]
01ed:9078	xor	bh, bh
01ed:907a	mov	dl, byte ptr [bx + 0x5593]
01ed:907e	add	dl, 0x43
01ed:9081	mov	ah, dl
01ed:9083	push	ds
01ed:9084	push	bx
01ed:9085	mov	bx, 0x1ed
01ed:9088	mov	ds, bx
01ed:908a	mov	bx, 0x80cc
01ed:908d	add	bl, ah
01ed:908f	adc	bh, 0
01ed:9092	mov	al, byte ptr [bx]
01ed:9094	pop	bx
01ed:9095	pop	ds
01ed:9096	mov	ah, 0x20
01ed:9098	sub	dh, byte ptr [bp + 6]
01ed:909b	shr	dh, 1
01ed:909d	shr	dh, 1
01ed:909f	shr	dh, 1
01ed:90a1	shr	dh, 1
01ed:90a3	and	dh, 0x3f
01ed:90a6	sub	ah, dh
01ed:90a8	mov	dh, ah
01ed:90aa	and	dh, 0x3f
01ed:90ad	and	al, 0xc0
01ed:90af	or	dh, al
01ed:90b1	push	dx
01ed:90b2	push	ax
01ed:90b3	mov	ah, dl
01ed:90b5	mov	al, dh
01ed:90b7	call	0x9007
01ed:90ba	pop	ax
01ed:90bb	pop	dx
01ed:90bc	pop	ax
01ed:90bd	pop	ds
01ed:90be	pop	bx
01ed:90bf	mov	ax, 0x1228
01ed:90c2	mov	ds, ax
01ed:90c4	mov	bx, word ptr [bp + 8]
01ed:90c7	mov	di, 0x55b4
01ed:90ca	mov	cl, byte ptr [bx + di]
01ed:90cc	dec	cl
01ed:90ce	mov	di, 0x5614
01ed:90d1	mov	al, byte ptr [bx + di]
01ed:90d3	xor	ah, ah
01ed:90d5	mov	bx, ax
01ed:90d7	add	bx, bx
01ed:90d9	mov	di, 0x559c
01ed:90dc	mov	ax, word ptr [bx + di]
01ed:90de	and	ax, 0x3ff
01ed:90e1	push	ax
01ed:90e2	mov	ah, al
01ed:90e4	mov	al, 0xa0
01ed:90e6	add	al, byte ptr [bp + 0xa]
01ed:90e9	xchg	al, ah
01ed:90eb	call	0x9007
01ed:90ee	pop	ax
01ed:90ef	pop	ds
01ed:90f0	mov	al, ah
01ed:90f2	and	al, 3
01ed:90f4	and	cl, 7
01ed:90f7	shl	cl, 1
01ed:90f9	shl	cl, 1
01ed:90fb	add	al, cl
01ed:90fd	add	al, byte ptr [bp + 4]
01ed:9100	xor	ah, ah
01ed:9102	push	ax
01ed:9103	mov	ah, al
01ed:9105	mov	al, 0xb0
01ed:9107	add	al, byte ptr [bp + 0xa]
01ed:910a	xchg	ah, al
01ed:910c	call	0x9007
01ed:910f	pop	ax
01ed:9110	pop	dx
01ed:9111	pop	cx
01ed:9112	pop	bx
01ed:9113	pop	bp
01ed:9114	ret	
sub_af2d ENDP
*/
void sub_af2d()
{
    // coverage: 0xa25d-0xa315 method sub_af2d
    push(0x7777);
    push(bp);
    bp = sp;
    push(bx);
    push(cx);
    push(dx);
    push(ds);
    push(ax);
    ah = 0x08;
    al = 0x00;
    sub_aed7();
    ax = pop();
    push(bx);
    push(ds);
    push(ax);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ss, bp + 10);
    bh = 0;
    dl = memoryAGet(ds, bx + 21907);
    dl += 0x43;
    ah = dl;
    push(ds);
    push(bx);
    bx = 0x01ed;
    ds = bx;
    bx = 0x80cc;
    flags.carry = (bl + ah) >= 0x100;
    bl += ah;
    bh += flags.carry;
    al = memoryAGet(ds, bx);
    bx = pop();
    ds = pop();
    ah = 0x20;
    dh -= memoryAGet(ss, bp + 6);
    dh >>= 1;
    dh >>= 1;
    dh >>= 1;
    dh >>= 1;
    dh &= 0x3f;
    ah -= dh;
    dh = ah;
    dh &= 0x3f;
    al &= 0xc0;
    dh |= al;
    push(dx);
    push(ax);
    ah = dl;
    al = dh;
    sub_aed7();
    ax = pop();
    dx = pop();
    ax = pop();
    ds = pop();
    bx = pop();
    ax = 0x1228;
    ds = ax;
    bx = memoryAGet16(ss, bp + 8);
    di = 0x55b4;
    cl = memoryAGet(ds, bx + di);
    cl--;
    di = 0x5614;
    al = memoryAGet(ds, bx + di);
    ah = 0;
    bx = ax;
    bx += bx;
    di = 0x559c;
    ax = memoryAGet16(ds, bx + di);
    ax &= 0x03ff;
    push(ax);
    ah = al;
    al = 0xa0;
    al += memoryAGet(ss, bp + 10);
    tl = al;
    al = ah;
    ah = tl;
    sub_aed7();
    ax = pop();
    ds = pop();
    al = ah;
    al &= 0x03;
    cl &= 0x07;
    cl <<= 1;
    cl <<= 1;
    al += cl;
    al += memoryAGet(ss, bp + 4);
    ah = 0;
    push(ax);
    ah = al;
    al = 0xb0;
    al += memoryAGet(ss, bp + 10);
    tl = ah;
    ah = al;
    al = tl;
    sub_aed7();
    ax = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9115 sub_afe5()
sub_afe5 PROC
01ed:9115	push	ax
01ed:9116	push	bx
01ed:9117	push	cx
01ed:9118	mov	bx, 0x83cc
01ed:911b	mov	cx, 0xf
01ed:911e	xor	al, al
        	loc_aff0:
01ed:9120	mov	byte ptr cs:[bx], al
01ed:9123	inc	bx
01ed:9124	loop	loc_aff0
01ed:9126	pop	cx
01ed:9127	pop	bx
01ed:9128	pop	ax
01ed:9129	xor	al, al
01ed:912b	mov	byte ptr cs:[0x83ee], al
01ed:912f	in	al, 0x61
01ed:9131	and	al, 0xfc
01ed:9133	out	0x61, al
01ed:9135	ret	
sub_afe5 ENDP
*/
void sub_afe5()
{
    // coverage: 0xa315-0xa336 method sub_afe5
    push(ax);
    push(bx);
    push(cx);
    bx = 0x83cc;
    cx = 0x000f;
    al = 0;
loc_aff0:
    memoryASet(cs, bx, al);
    bx++;
    if (--cx)
        goto loc_aff0;
    cx = pop();
    bx = pop();
    ax = pop();
    al = 0;
    memoryASet(cs, 0x83ee, al);
    in(al, 0x61);
    al &= 0xfc;
    out(0x61, al);
}
/* Assembly listing of 01ed:91cf sub_b09f()
sub_b09f PROC
01ed:91cf	push	ax
01ed:91d0	lodsb	al, byte ptr [si]
01ed:91d1	mov	ah, 0
01ed:91d3	add	si, ax
01ed:91d5	pop	ax
01ed:91d6	ret	
sub_b09f ENDP
*/
void sub_b09f()
{
    // coverage: 0xa3cf-0xa3d7 method sub_b09f
    push(ax);
    lodsb<MemAuto, DirAuto>();
    ah = 0x00;
    si += ax;
    ax = pop();
}
/* Assembly listing of 01ed:91d7 sub_b0a7()
sub_b0a7 PROC
01ed:91d7	push	ax
01ed:91d8	lodsb	al, byte ptr [si]
01ed:91d9	mov	ah, 0
01ed:91db	add	si, ax
01ed:91dd	pop	ax
01ed:91de	ret	
sub_b0a7 ENDP
*/
void sub_b0a7()
{
    // coverage: 0xa3d7-0xa3df method sub_b0a7
    push(ax);
    lodsb<MemAuto, DirAuto>();
    ah = 0x00;
    si += ax;
    ax = pop();
}
/* Assembly listing of 01ed:91df sub_b0af()
sub_b0af PROC
01ed:91df	push	ax
01ed:91e0	push	bx
01ed:91e1	mov	ah, al
01ed:91e3	and	ah, 0xf0
01ed:91e6	cmp	ah, 0xc0
01ed:91e9	je	loc_b0f7
01ed:91eb	test	al, 0xf
01ed:91ed	jne	loc_b0c4
01ed:91ef	or	al, byte ptr cs:[bx + 0x80]
        	loc_b0c4:
01ed:91f4	mov	bx, 0x83cc
01ed:91f7	mov	ah, al
01ed:91f9	and	ah, 0xf
01ed:91fc	add	bl, ah
01ed:91fe	adc	bh, 0
01ed:9201	and	al, 0xf0
01ed:9203	cmp	al, 0x90
01ed:9205	je	loc_b0e9
01ed:9207	cmp	al, 0x80
01ed:9209	je	loc_b0e0
01ed:920b	lodsb	al, byte ptr [si]
01ed:920c	lodsb	al, byte ptr [si]
        	loc_b0dd:
01ed:920d	pop	bx
01ed:920e	pop	ax
01ed:920f	ret	
        	loc_b0e0:
01ed:9210	lodsb	al, byte ptr [si]
01ed:9211	lodsb	al, byte ptr [si]
01ed:9212	xor	al, al
        	loc_b0e4:
01ed:9214	mov	byte ptr cs:[bx], al
01ed:9217	jmp	loc_b0dd
        	loc_b0e9:
01ed:9219	lodsb	al, byte ptr [si]
01ed:921a	mov	ah, al
01ed:921c	lodsb	al, byte ptr [si]
01ed:921d	cmp	al, 0
01ed:921f	je	loc_b0f5
01ed:9221	mov	al, ah
01ed:9223	jmp	loc_b0e4
        	loc_b0f5:
01ed:9225	jmp	loc_b0e4
        	loc_b0f7:
01ed:9227	call	0x922c
01ed:922a	jmp	loc_b0dd
sub_b0af ENDP
*/
void sub_b0af()
{
    // coverage: 0xa3df-0xa42c method sub_b0af
    push(ax);
    push(bx);
    ah = al;
    ah &= 0xf0;
    if (ah == 0xc0)
        goto loc_b0f7;
    if (al & 0x0f)
        goto loc_b0c4;
    al |= memoryAGet(cs, bx + 128);
loc_b0c4:
    bx = 0x83cc;
    ah = al;
    ah &= 0x0f;
    flags.carry = (bl + ah) >= 0x100;
    bl += ah;
    bh += flags.carry;
    al &= 0xf0;
    if (al == 0x90)
        goto loc_b0e9;
    if (al == 0x80)
        goto loc_b0e0;
    lodsb<MemAuto, DirAuto>();
    lodsb<MemAuto, DirAuto>();
loc_b0dd:
    bx = pop();
    ax = pop();
    return;
loc_b0e0:
    lodsb<MemAuto, DirAuto>();
    lodsb<MemAuto, DirAuto>();
    al = 0;
loc_b0e4:
    memoryASet(cs, bx, al);
    goto loc_b0dd;
loc_b0e9:
    lodsb<MemAuto, DirAuto>();
    ah = al;
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_b0f5;
    al = ah;
    goto loc_b0e4;
loc_b0f5:
    goto loc_b0e4;
loc_b0f7:
    sub_b0fc();
    goto loc_b0dd;
}
/* Assembly listing of 01ed:922c sub_b0fc()
sub_b0fc PROC
01ed:922c	and	al, 0xf
01ed:922e	mov	ah, al
01ed:9230	mov	al, byte ptr [si]
01ed:9232	push	bx
01ed:9233	mov	bx, 0x8473
01ed:9236	add	bl, ah
01ed:9238	adc	bh, 0
01ed:923b	mov	byte ptr cs:[bx], al
01ed:923e	pop	bx
01ed:923f	inc	si
01ed:9240	ret	
sub_b0fc ENDP
*/
void sub_b0fc()
{
    // coverage: 0xa42c-0xa441 method sub_b0fc
    al &= 0x0f;
    ah = al;
    al = memoryAGet(ds, si);
    push(bx);
    bx = 0x8473;
    flags.carry = (bl + ah) >= 0x100;
    bl += ah;
    bh += flags.carry;
    memoryASet(cs, bx, al);
    bx = pop();
    si++;
}
/* Assembly listing of 01ed:927c sub_b14c()
sub_b14c PROC
01ed:927c	push	di
01ed:927d	push	si
01ed:927e	push	bp
01ed:927f	push	ds
01ed:9280	push	es
01ed:9281	mov	ax, 0
01ed:9284	int	0x33
01ed:9286	mov	byte ptr [0x5674], al
01ed:9289	xor	ax, 0xffff
01ed:928c	push	ax
01ed:928d	mov	ax, 4
01ed:9290	mov	cx, 0
01ed:9293	mov	dx, cx
01ed:9295	int	0x33
01ed:9297	mov	ax, 7
01ed:929a	mov	cx, 0
01ed:929d	mov	dx, 0x280
01ed:92a0	int	0x33
01ed:92a2	mov	ax, 8
01ed:92a5	mov	cx, 0
01ed:92a8	mov	dx, 0xc8
01ed:92ab	int	0x33
01ed:92ad	pop	ax
01ed:92ae	pop	es
01ed:92af	pop	ds
01ed:92b0	pop	bp
01ed:92b1	pop	si
01ed:92b2	pop	di
01ed:92b3	ret	
sub_b14c ENDP
*/
void sub_b14c()
{
    // coverage: 0xa47c-0xa4b4 method sub_b14c
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x0000;
    interrupt(0x33);
    memoryASet(ds, 0x5674, al);
    ax ^= 0xffff;
    push(ax);
    ax = 0x0004;
    cx = 0x0000;
    dx = cx;
    interrupt(0x33);
    ax = 0x0007;
    cx = 0x0000;
    dx = 0x0280;
    interrupt(0x33);
    ax = 0x0008;
    cx = 0x0000;
    dx = 0x00c8;
    interrupt(0x33);
    ax = pop();
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
}
/* Assembly listing of 01ed:93a4 sub_b274()
sub_b274 PROC
01ed:93a4	push	bp
01ed:93a5	mov	bp, sp
01ed:93a7	mov	ax, word ptr [bp + 4]
01ed:93aa	pop	bp
01ed:93ab	lcall	0xed2, 0
01ed:93b0	ret	
sub_b274 ENDP
*/
void sub_b274()
{
    // coverage: 0xa5a4-0xa5b1 method sub_b274
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ed2;
    sub_ed20();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:93b1 sub_b281()
sub_b281 PROC
01ed:93b1	lcall	0xed2, 0x1f
01ed:93b6	ret	
sub_b281 ENDP
*/
void sub_b281()
{
    // coverage: 0xa5b1-0xa5b7 method sub_b281
    push(cs);
    cs = 0x0ed2;
    sub_ed3f();
    assert(cs == 0x01ed);
}
/* Assembly listing of 01ed:93b8 sub_b288()
sub_b288 PROC
01ed:93b8	push	bp
01ed:93b9	mov	bp, sp
01ed:93bb	mov	dx, word ptr [bp + 6]
01ed:93be	mov	ax, word ptr [bp + 4]
01ed:93c1	pop	bp
01ed:93c2	lcall	0xca6, 0x1028
01ed:93c7	ret	
sub_b288 ENDP
*/
void sub_b288()
{
    // coverage: 0xa5b8-0xa5c8 method sub_b288
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_da88();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:93c8 sub_b298()
sub_b298 PROC
01ed:93c8	push	bp
01ed:93c9	mov	bp, sp
01ed:93cb	mov	dx, word ptr [bp + 6]
01ed:93ce	mov	ax, word ptr [bp + 4]
01ed:93d1	pop	bp
01ed:93d2	lcall	0xca6, 0x126e
01ed:93d7	ret	
sub_b298 ENDP
*/
void sub_b298()
{
    // coverage: 0xa5c8-0xa5d8 method sub_b298
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_dcce();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:93d8 sub_b2a8()
sub_b2a8 PROC
01ed:93d8	push	bp
01ed:93d9	mov	bp, sp
01ed:93db	lcall	0xed9, 0x2ced
01ed:93e0	pop	bp
01ed:93e1	ret	
sub_b2a8 ENDP
*/
void sub_b2a8()
{
    // coverage: 0xa5d8-0xa5e2 method sub_b2a8
    push(0x7777);
    push(bp);
    bp = sp;
    push(cs);
    cs = 0x0ed9;
    sub_11a7d();
    assert(cs == 0x01ed);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9406 sub_b2d6()
sub_b2d6 PROC
01ed:9406	push	bp
01ed:9407	mov	bp, sp
01ed:9409	lcall	0xed9, 0x2da8
01ed:940e	pop	bp
01ed:940f	ret	
sub_b2d6 ENDP
*/
void sub_b2d6()
{
    // coverage: 0xa606-0xa610 method sub_b2d6
    push(0x7777);
    push(bp);
    bp = sp;
    push(cs);
    cs = 0x0ed9;
    sub_11b38();
    assert(cs == 0x01ed);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9410 sub_b2e0()
sub_b2e0 PROC
01ed:9410	push	bp
01ed:9411	mov	bp, sp
01ed:9413	lcall	0xed9, 0x2dd2
01ed:9418	pop	bp
01ed:9419	ret	
sub_b2e0 ENDP
*/
void sub_b2e0()
{
    // coverage: 0xa610-0xa61a method sub_b2e0
    push(0x7777);
    push(bp);
    bp = sp;
    push(cs);
    cs = 0x0ed9;
    sub_11b62();
    assert(cs == 0x01ed);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9424 sub_b2f4()
sub_b2f4 PROC
01ed:9424	lcall	0xed9, 0x3137
01ed:9429	ret	
sub_b2f4 ENDP
*/
void sub_b2f4()
{
    // coverage: 0xa624-0xa62a method sub_b2f4
    push(cs);
    cs = 0x0ed9;
    sub_11ec7();
    assert(cs == 0x01ed);
}
/* Assembly listing of 01ed:942a sub_b2fa()
sub_b2fa PROC
01ed:942a	push	bp
01ed:942b	mov	bp, sp
01ed:942d	lcall	0xed9, 0x31b7
01ed:9432	pop	bp
01ed:9433	ret	
sub_b2fa ENDP
*/
void sub_b2fa()
{
    // coverage: 0xa62a-0xa634 method sub_b2fa
    push(0x7777);
    push(bp);
    bp = sp;
    push(cs);
    cs = 0x0ed9;
    sub_11f47();
    assert(cs == 0x01ed);
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9434 sub_b304()
sub_b304 PROC
01ed:9434	jmp	loc_b306
01ed:9436	jmp	loc_b308
01ed:9438	ret	
sub_b304 ENDP
*/
void sub_b304()
{
    // coverage: 0xa634-0xa639 method sub_b304
}
/* Assembly listing of 01ed:9440 sub_b310()
sub_b310 PROC
01ed:9440	cmp	word ptr [0x683e], 0
01ed:9445	jne	loc_b321
01ed:9447	in	al, 0x61
01ed:9449	or	al, 3
01ed:944b	call	0x9434
01ed:944e	out	0x61, al
01ed:9450	ret	
        	loc_b321:
01ed:9451	in	al, 0x61
01ed:9453	and	al, 0xfc
01ed:9455	call	0x9434
01ed:9458	out	0x61, al
01ed:945a	ret	
sub_b310 ENDP
*/
void sub_b310()
{
    // coverage: 0xa640-0xa65b method sub_b310
    if (memoryAGet16(ds, 0x683e) != 0x0000)
        goto loc_b321;
    in(al, 0x61);
    al |= 0x03;
    sub_b304();
    out(0x61, al);
    return;
loc_b321:
    in(al, 0x61);
    al &= 0xfc;
    sub_b304();
    out(0x61, al);
}
/* Assembly listing of 01ed:9451 sub_b321()
sub_b321 PROC
01ed:9451	in	al, 0x61
01ed:9453	and	al, 0xfc
01ed:9455	call	0x9434
01ed:9458	out	0x61, al
01ed:945a	ret	
sub_b321 ENDP
*/
void sub_b321()
{
    // coverage: 0xa651-0xa65b method sub_b321
    in(al, 0x61);
    al &= 0xfc;
    sub_b304();
    out(0x61, al);
}
// INJECT: Error: cannot inject flag in sub_b32b() because of being label!
/* Assembly listing of 01ed:945b sub_b32b()
sub_b32b PROC
01ed:945b	cmp	ax, 0xff
01ed:945e	je	loc_b337
01ed:9460	cmp	word ptr cs:[0x946c], ax
01ed:9465	jb	loc_b33b
        	loc_b337:
01ed:9467	mov	word ptr cs:[0x946c], ax
        	loc_b33b:
01ed:946b	ret	
sub_b32b ENDP
*/
void sub_b32b()
{
    // coverage: 0xa65b-0xa66c method sub_b32b
    if (ax == 0x00ff)
        goto loc_b337;
    if (memoryAGet16(cs, 0x946c) < ax)
        goto loc_b33b;
loc_b337:
    memoryASet16(cs, 0x946c, ax);
loc_b33b:
    stop(/*inject ret*/);
}
/* Assembly listing of 01ed:946e sub_b33e()
sub_b33e PROC
01ed:946e	mov	ax, word ptr [0x683e]
01ed:9471	cmp	ax, 0
01ed:9474	mov	ax, 0xff
01ed:9477	je	loc_b351
01ed:9479	mov	ax, 0
01ed:947c	call	0x945b
01ed:947f	jmp	loc_b357
        	loc_b351:
01ed:9481	call	0x945b
01ed:9484	call	0x9451
        	loc_b357:
01ed:9487	ret	
sub_b33e ENDP
*/
void sub_b33e()
{
    // coverage: 0xa66e-0xa688 method sub_b33e
    ax = memoryAGet16(ds, 0x683e);
    tx = ax;
    ax = 0x00ff;
    if (stop("check inject: cmp ax, 0") && tx == 0x0000)
        goto loc_b351;
    ax = 0x0000;
    sub_b32b();
    return;
loc_b351:
    sub_b32b();
    sub_b321();
}
/* Assembly listing of 01ed:9488 sub_b358()
sub_b358 PROC
01ed:9488	push	bp
01ed:9489	mov	bp, sp
01ed:948b	push	di
01ed:948c	push	si
01ed:948d	push	bp
01ed:948e	push	ds
01ed:948f	push	es
01ed:9490	pushf	
01ed:9491	cli	
01ed:9492	mov	ax, word ptr [bp + 4]
01ed:9495	call	0x945b
01ed:9498	mov	ax, 0xffff
01ed:949b	jb	loc_b3ca
01ed:949d	mov	ax, word ptr [bp + 6]
01ed:94a0	mov	word ptr cs:[0x9788], ax
01ed:94a4	mov	ax, word ptr [bp + 8]
01ed:94a7	mov	word ptr cs:[0x978a], ax
01ed:94ab	mov	ax, word ptr [bp + 0xa]
01ed:94ae	mov	word ptr cs:[0x9796], ax
01ed:94b2	mov	word ptr cs:[0x978c], ax
01ed:94b6	mov	ax, word ptr [bp + 0xc]
01ed:94b9	mov	word ptr cs:[0x978e], ax
01ed:94bd	mov	ax, word ptr [bp + 0xe]
01ed:94c0	mov	word ptr cs:[0x9790], ax
01ed:94c4	mov	ax, word ptr [bp + 0x10]
01ed:94c7	mov	word ptr cs:[0x9792], ax
01ed:94cb	mov	word ptr cs:[0x9798], ax
01ed:94cf	mov	ax, word ptr [bp + 0x12]
01ed:94d2	mov	word ptr cs:[0x9794], ax
01ed:94d6	mov	byte ptr cs:[0x979a], 0xf
01ed:94dc	mov	cx, 0x9631
01ed:94df	mov	word ptr cs:[0x97a1], cx
01ed:94e4	mov	dx, 0x1ed
01ed:94e7	mov	word ptr cs:[0x979f], dx
01ed:94ec	mov	ax, word ptr [bp + 0xe]
01ed:94ef	mov	bx, 2
01ed:94f2	call	0x7df9
01ed:94f5	call	0x9440
01ed:94f8	xor	ax, ax
        	loc_b3ca:
01ed:94fa	popf	
01ed:94fb	pop	es
01ed:94fc	pop	ds
01ed:94fd	pop	bp
01ed:94fe	pop	si
01ed:94ff	pop	di
01ed:9500	pop	bp
01ed:9501	ret	
sub_b358 ENDP
*/
void sub_b358()
{
    // coverage: 0xa688-0xa702 method sub_b358
    push(0x7777);
    push(bp);
    bp = sp;
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    tx = flags.carry | (flags.zero << 1);
    push(tx);
    flags.interrupts = false;
    ax = memoryAGet16(ss, bp + 4);
    sub_b32b();
    ax = 0xffff;
    if (flags.carry)
        goto loc_b3ca;
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(cs, 0x9788, ax);
    ax = memoryAGet16(ss, bp + 8);
    memoryASet16(cs, 0x978a, ax);
    ax = memoryAGet16(ss, bp + 10);
    memoryASet16(cs, 0x9796, ax);
    memoryASet16(cs, 0x978c, ax);
    ax = memoryAGet16(ss, bp + 12);
    memoryASet16(cs, 0x978e, ax);
    ax = memoryAGet16(ss, bp + 14);
    memoryASet16(cs, 0x9790, ax);
    ax = memoryAGet16(ss, bp + 16);
    memoryASet16(cs, 0x9792, ax);
    memoryASet16(cs, 0x9798, ax);
    ax = memoryAGet16(ss, bp + 18);
    memoryASet16(cs, 0x9794, ax);
    memoryASet(cs, 0x979a, 0x0f);
    cx = 0x9631;
    memoryASet16(cs, 0x97a1, cx);
    dx = 0x01ed;
    memoryASet16(cs, 0x979f, dx);
    ax = memoryAGet16(ss, bp + 14);
    bx = 0x0002;
    sub_9cc9();
    sub_b310();
    ax = 0;
loc_b3ca:
    tx = pop();
    flags.carry = tx & 1;
    flags.zero = (tx << 1) & 1;
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9502 sub_b3d2()
sub_b3d2 PROC
01ed:9502	push	bp
01ed:9503	mov	bp, sp
01ed:9505	push	di
01ed:9506	push	si
01ed:9507	push	bp
01ed:9508	push	ds
01ed:9509	push	es
01ed:950a	pushf	
01ed:950b	cli	
01ed:950c	mov	ax, word ptr [bp + 4]
01ed:950f	call	0x945b
01ed:9512	mov	ax, 0xffff
01ed:9515	jb	loc_b435
01ed:9517	mov	ax, word ptr [bp + 6]
01ed:951a	mov	word ptr cs:[0x9788], ax
01ed:951e	mov	ax, word ptr [bp + 8]
01ed:9521	mov	word ptr cs:[0x978a], ax
01ed:9525	mov	ax, word ptr [bp + 0xa]
01ed:9528	mov	ax, word ptr [bp + 0xa]
01ed:952b	mov	word ptr cs:[0x9790], ax
01ed:952f	mov	ax, word ptr [bp + 0xc]
01ed:9532	mov	word ptr cs:[0x9792], ax
01ed:9536	mov	word ptr cs:[0x9798], ax
01ed:953a	mov	ax, word ptr [bp + 0xe]
01ed:953d	mov	word ptr cs:[0x9794], ax
01ed:9541	mov	byte ptr cs:[0x979a], 0xf
01ed:9547	mov	cx, 0x96c4
01ed:954a	mov	word ptr cs:[0x97a1], cx
01ed:954f	mov	dx, 0x1ed
01ed:9552	mov	word ptr cs:[0x979f], dx
01ed:9557	mov	ax, word ptr [bp + 0xa]
01ed:955a	mov	bx, 2
01ed:955d	call	0x7df9
01ed:9560	call	0x9440
01ed:9563	xor	ax, ax
        	loc_b435:
01ed:9565	popf	
01ed:9566	pop	es
01ed:9567	pop	ds
01ed:9568	pop	bp
01ed:9569	pop	si
01ed:956a	pop	di
01ed:956b	pop	bp
01ed:956c	ret	
sub_b3d2 ENDP
*/
void sub_b3d2()
{
    // coverage: 0xa702-0xa76d method sub_b3d2
    push(0x7777);
    push(bp);
    bp = sp;
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    tx = flags.carry | (flags.zero << 1);
    push(tx);
    flags.interrupts = false;
    ax = memoryAGet16(ss, bp + 4);
    sub_b32b();
    ax = 0xffff;
    if (flags.carry)
        goto loc_b435;
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(cs, 0x9788, ax);
    ax = memoryAGet16(ss, bp + 8);
    memoryASet16(cs, 0x978a, ax);
    ax = memoryAGet16(ss, bp + 10);
    ax = memoryAGet16(ss, bp + 10);
    memoryASet16(cs, 0x9790, ax);
    ax = memoryAGet16(ss, bp + 12);
    memoryASet16(cs, 0x9792, ax);
    memoryASet16(cs, 0x9798, ax);
    ax = memoryAGet16(ss, bp + 14);
    memoryASet16(cs, 0x9794, ax);
    memoryASet(cs, 0x979a, 0x0f);
    cx = 0x96c4;
    memoryASet16(cs, 0x97a1, cx);
    dx = 0x01ed;
    memoryASet16(cs, 0x979f, dx);
    ax = memoryAGet16(ss, bp + 10);
    bx = 0x0002;
    sub_9cc9();
    sub_b310();
    ax = 0;
loc_b435:
    tx = pop();
    flags.carry = tx & 1;
    flags.zero = (tx << 1) & 1;
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:97a4 sub_b674()
sub_b674 PROC
01ed:97a4	lcall	0x1219, 0
01ed:97a9	ret	
sub_b674 ENDP
*/
void sub_b674()
{
    // coverage: 0xa9a4-0xa9aa method sub_b674
    push(cs);
    cs = 0x1219;
    sub_12190();
    assert(cs == 0x01ed);
}
// INJECT: Error: cannot inject zero flag in sub_b67a() because no traceback!
/* Assembly listing of 01ed:97aa sub_b67a()
sub_b67a PROC
01ed:97aa	call	0x7abb
01ed:97ad	retf	
sub_b67a ENDP
*/
void sub_b67a()
{
    // coverage: 0xa9aa-0xa9ae method sub_b67a
    sub_998b();
    stop(/*inject ret*/);
    cs = pop();
}
/* Assembly listing of 01ed:97c5 sub_b695()
sub_b695 PROC
01ed:97c5	push	bp
01ed:97c6	mov	bp, sp
01ed:97c8	mov	ax, word ptr [bp + 4]
01ed:97cb	mov	dx, word ptr [bp + 6]
01ed:97ce	pop	bp
01ed:97cf	lcall	0xca6, 0x1311
01ed:97d4	ret	
sub_b695 ENDP
*/
void sub_b695()
{
    // coverage: 0xa9c5-0xa9d5 method sub_b695
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    dx = memoryAGet16(ss, bp + 6);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_dd71();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:97d5 sub_b6a5()
sub_b6a5 PROC
01ed:97d5	push	bp
01ed:97d6	mov	bp, sp
01ed:97d8	mov	dx, word ptr [bp + 6]
01ed:97db	mov	ax, word ptr [bp + 4]
01ed:97de	pop	bp
01ed:97df	lcall	0xca6, 0x132b
01ed:97e4	ret	
sub_b6a5 ENDP
*/
void sub_b6a5()
{
    // coverage: 0xa9d5-0xa9e5 method sub_b6a5
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_dd8b();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:97f1 sub_b6c1()
sub_b6c1 PROC
01ed:97f1	lcall	0xca6, 0x137b
01ed:97f6	ret	
sub_b6c1 ENDP
*/
void sub_b6c1()
{
    // coverage: 0xa9f1-0xa9f7 method sub_b6c1
    push(cs);
    cs = 0x0ca6;
    sub_dddb();
    assert(cs == 0x01ed);
}
/* Assembly listing of 01ed:9804 sub_b6d4()
sub_b6d4 PROC
01ed:9804	push	bp
01ed:9805	mov	bp, sp
01ed:9807	mov	dx, word ptr [bp + 6]
01ed:980a	mov	ax, word ptr [bp + 4]
01ed:980d	pop	bp
01ed:980e	lcall	0xca6, 0x13ec
01ed:9813	ret	
sub_b6d4 ENDP
*/
void sub_b6d4()
{
    // coverage: 0xaa04-0xaa14 method sub_b6d4
    push(0x7777);
    push(bp);
    bp = sp;
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_de4c();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9814 sub_b6e4()
sub_b6e4 PROC
01ed:9814	push	bp
01ed:9815	mov	bp, sp
01ed:9817	mov	bx, word ptr [bp + 4]
01ed:981a	pop	bp
01ed:981b	lcall	0xca6, 0x1409
01ed:9820	ret	
sub_b6e4 ENDP
*/
void sub_b6e4()
{
    // coverage: 0xaa14-0xaa21 method sub_b6e4
    push(0x7777);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_de69();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9821 sub_b6f1()
sub_b6f1 PROC
01ed:9821	push	bp
01ed:9822	mov	bp, sp
01ed:9824	mov	ax, word ptr [bp + 4]
01ed:9827	mov	bx, word ptr [bp + 6]
01ed:982a	mov	cx, word ptr [bp + 8]
01ed:982d	mov	dx, word ptr [bp + 0xa]
01ed:9830	pop	bp
01ed:9831	lcall	0xca6, 0x1422
01ed:9836	ret	
sub_b6f1 ENDP
*/
void sub_b6f1()
{
    // coverage: 0xaa21-0xaa37 method sub_b6f1
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    bx = memoryAGet16(ss, bp + 6);
    cx = memoryAGet16(ss, bp + 8);
    dx = memoryAGet16(ss, bp + 10);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_de82();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9837 sub_b707()
sub_b707 PROC
01ed:9837	push	bp
01ed:9838	mov	bp, sp
01ed:983a	mov	ax, word ptr [bp + 4]
01ed:983d	mov	dx, word ptr [bp + 6]
01ed:9840	pop	bp
01ed:9841	lcall	0xca6, 0x1441
01ed:9846	ret	
sub_b707 ENDP
*/
void sub_b707()
{
    // coverage: 0xaa37-0xaa47 method sub_b707
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    dx = memoryAGet16(ss, bp + 6);
    bp = pop();
    push(cs);
    cs = 0x0ca6;
    sub_dea1();
    assert(cs == 0x01ed);
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9864 sub_b734()
sub_b734 PROC
01ed:9864	lcall	0x1223, 0
01ed:9869	ret	
sub_b734 ENDP
*/
void sub_b734()
{
    // coverage: 0xaa64-0xaa6a method sub_b734
    push(cs);
    cs = 0x1223;
    sub_12230();
    assert(cs == 0x01ed);
}
/* Assembly listing of 01ed:988e sub_b75e()
sub_b75e PROC
01ed:988e	push	bp
01ed:988f	mov	bp, sp
01ed:9891	push	si
01ed:9892	mov	si, word ptr [bp + 4]
01ed:9895	or	si, si
01ed:9897	jl	loc_b76e
01ed:9899	cmp	si, 0x14
01ed:989c	jl	loc_b777
        	loc_b76e:
01ed:989e	mov	ax, 6
01ed:98a1	push	ax
01ed:98a2	call	0xa178
01ed:98a5	jmp	loc_b786
        	loc_b777:
01ed:98a7	mov	bx, si
01ed:98a9	shl	bx, 1
01ed:98ab	mov	word ptr [bx + 0x6b1c], 0xffff
01ed:98b1	push	si
01ed:98b2	call	0x9fb5
01ed:98b5	pop	cx
        	loc_b786:
01ed:98b6	pop	si
01ed:98b7	pop	bp
01ed:98b8	ret	
sub_b75e ENDP
*/
void sub_b75e()
{
    // coverage: 0xaa8e-0xaab9 method sub_b75e
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    si = memoryAGet16(ss, bp + 4);
    if ((short)si < 0)
        goto loc_b76e;
    if ((short)si < (short)0x0014)
        goto loc_b777;
loc_b76e:
    ax = 0x0006;
    push(ax);
    sub_c048();
    goto loc_b786;
loc_b777:
    bx = si;
    bx <<= 1;
    memoryASet16(ds, bx + 27420, 0xffff);
    push(si);
    sub_be85();
    cx = pop();
loc_b786:
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:98ba sub_b78a()
sub_b78a PROC
01ed:98ba	push	bp
01ed:98bb	mov	bp, sp
01ed:98bd	jmp	loc_b799
        	loc_b78f:
01ed:98bf	mov	bx, word ptr [0x6982]
01ed:98c3	shl	bx, 1
01ed:98c5	call	word ptr [bx - 0x5e42]
        	loc_b799:
01ed:98c9	mov	ax, word ptr [0x6982]
01ed:98cc	dec	word ptr [0x6982]
01ed:98d0	or	ax, ax
01ed:98d2	jne	loc_b78f
01ed:98d4	push	word ptr [bp + 4]
01ed:98d7	call	0x100f6
01ed:98da	pop	cx
01ed:98db	pop	bp
01ed:98dc	ret	
sub_b78a ENDP
*/
void sub_b78a()
{
    // coverage: 0xaaba-0xaadd method sub_b78a
    push(0x7777);
    push(bp);
    bp = sp;
    goto loc_b799;
loc_b78f:
    bx = memoryAGet16(ds, 0x6982);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 41406));
loc_b799:
    ax = memoryAGet16(ds, 0x6982);
    memoryASet16(ds, 0x6982, memoryAGet16(ds, 0x6982) - 1);
    if (ax)
        goto loc_b78f;
    push(memoryAGet16(ss, bp + 4));
    sub_1fc6();
    cx = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:98dd sub_b7ad()
sub_b7ad PROC
01ed:98dd	push	bp
01ed:98de	mov	bp, sp
01ed:98e0	push	si
01ed:98e1	push	di
01ed:98e2	mov	ax, word ptr [bp + 6]
01ed:98e5	inc	ax
01ed:98e6	mov	si, ax
01ed:98e8	sub	si, word ptr [0x79]
01ed:98ec	mov	ax, si
01ed:98ee	add	ax, 0x3f
01ed:98f1	mov	cl, 6
01ed:98f3	shr	ax, cl
01ed:98f5	mov	si, ax
01ed:98f7	cmp	si, word ptr [0x698a]
01ed:98fb	jne	loc_b7df
        	loc_b7cd:
01ed:98fd	mov	ax, word ptr [bp + 6]
01ed:9900	mov	dx, word ptr [bp + 4]
01ed:9903	mov	word ptr [0x87], dx
01ed:9907	mov	word ptr [0x89], ax
01ed:990a	mov	ax, 1
01ed:990d	jmp	loc_b825
        	loc_b7df:
01ed:990f	mov	cl, 6
01ed:9911	shl	si, cl
01ed:9913	mov	di, word ptr [0x8d]
01ed:9917	mov	ax, si
01ed:9919	add	ax, word ptr [0x79]
01ed:991d	cmp	ax, di
01ed:991f	jbe	loc_b7f9
01ed:9921	mov	ax, di
01ed:9923	sub	ax, word ptr [0x79]
01ed:9927	mov	si, ax
        	loc_b7f9:
01ed:9929	push	si
01ed:992a	push	word ptr [0x79]
01ed:992e	call	0xa482
01ed:9931	pop	cx
01ed:9932	pop	cx
01ed:9933	mov	di, ax
01ed:9935	cmp	di, -1
01ed:9938	jne	loc_b815
01ed:993a	mov	ax, si
01ed:993c	mov	cl, 6
01ed:993e	shr	ax, cl
01ed:9940	mov	word ptr [0x698a], ax
01ed:9943	jmp	loc_b7cd
        	loc_b815:
01ed:9945	mov	ax, word ptr [0x79]
01ed:9948	add	ax, di
01ed:994a	mov	word ptr [0x8b], 0
01ed:9950	mov	word ptr [0x8d], ax
01ed:9953	xor	ax, ax
        	loc_b825:
01ed:9955	pop	di
01ed:9956	pop	si
01ed:9957	pop	bp
01ed:9958	ret	4
sub_b7ad ENDP
*/
void sub_b7ad()
{
    // coverage: 0xaadd-0xab5b method sub_b7ad
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    ax = memoryAGet16(ss, bp + 6);
    ax++;
    si = ax;
    si -= memoryAGet16(ds, 0x0079);
    ax = si;
    ax += 0x003f;
    cl = 0x06;
    ax >>= cl;
    si = ax;
    if (si != memoryAGet16(ds, 0x698a))
        goto loc_b7df;
loc_b7cd:
    ax = memoryAGet16(ss, bp + 6);
    dx = memoryAGet16(ss, bp + 4);
    memoryASet16(ds, 0x0087, dx);
    memoryASet16(ds, 0x0089, ax);
    ax = 0x0001;
    goto loc_b825;
loc_b7df:
    cl = 0x06;
    si <<= cl;
    di = memoryAGet16(ds, 0x008d);
    ax = si;
    ax += memoryAGet16(ds, 0x0079);
    if (ax <= di)
        goto loc_b7f9;
    ax = di;
    ax -= memoryAGet16(ds, 0x0079);
    si = ax;
loc_b7f9:
    push(si);
    push(memoryAGet16(ds, 0x0079));
    sub_c352();
    cx = pop();
    cx = pop();
    di = ax;
    if (di != 0xffff)
        goto loc_b815;
    ax = si;
    cl = 0x06;
    ax >>= cl;
    memoryASet16(ds, 0x698a, ax);
    goto loc_b7cd;
loc_b815:
    ax = memoryAGet16(ds, 0x0079);
    ax += di;
    memoryASet16(ds, 0x008b, 0x0000);
    memoryASet16(ds, 0x008d, ax);
    ax = 0;
loc_b825:
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
    sp += 4;
}
/* Assembly listing of 01ed:995b sub_b82b()
sub_b82b PROC
01ed:995b	push	bp
01ed:995c	mov	bp, sp
01ed:995e	mov	cx, word ptr [0x85]
01ed:9962	mov	bx, word ptr [0x83]
01ed:9966	mov	dx, word ptr [bp + 6]
01ed:9969	mov	ax, word ptr [bp + 4]
01ed:996c	call	0xaa2b
01ed:996f	jb	loc_b861
01ed:9971	mov	cx, word ptr [0x8d]
01ed:9975	mov	bx, word ptr [0x8b]
01ed:9979	mov	dx, word ptr [bp + 6]
01ed:997c	mov	ax, word ptr [bp + 4]
01ed:997f	call	0xaa2b
01ed:9982	ja	loc_b861
01ed:9984	push	word ptr [bp + 6]
01ed:9987	push	word ptr [bp + 4]
01ed:998a	call	0x98dd
01ed:998d	or	ax, ax
01ed:998f	jne	loc_b866
        	loc_b861:
01ed:9991	mov	ax, 0xffff
01ed:9994	jmp	loc_b868
        	loc_b866:
01ed:9996	xor	ax, ax
        	loc_b868:
01ed:9998	pop	bp
01ed:9999	ret	
sub_b82b ENDP
*/
void sub_b82b()
{
    // coverage: 0xab5b-0xab9a method sub_b82b
    push(0x7777);
    push(bp);
    bp = sp;
    cx = memoryAGet16(ds, 0x0085);
    bx = memoryAGet16(ds, 0x0083);
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    sub_c8fb();
    if (flags.carry)
        goto loc_b861;
    cx = memoryAGet16(ds, 0x008d);
    bx = memoryAGet16(ds, 0x008b);
    dx = memoryAGet16(ss, bp + 6);
    ax = memoryAGet16(ss, bp + 4);
    sub_c8fb();
    if (!flags.zero && !flags.carry)
        goto loc_b861;
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_b7ad();
    if (ax)
        goto loc_b866;
loc_b861:
    ax = 0xffff;
    goto loc_b868;
loc_b866:
    ax = 0;
loc_b868:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:999a sub_b86a()
sub_b86a PROC
01ed:999a	push	bp
01ed:999b	mov	bp, sp
01ed:999d	sub	sp, 8
01ed:99a0	mov	dx, word ptr [0x89]
01ed:99a4	mov	ax, word ptr [0x87]
01ed:99a7	mov	cx, word ptr [bp + 6]
01ed:99aa	mov	bx, word ptr [bp + 4]
01ed:99ad	call	0xa995
01ed:99b0	mov	word ptr [bp - 4], ax
01ed:99b3	mov	word ptr [bp - 2], dx
01ed:99b6	mov	cx, word ptr [0x85]
01ed:99ba	mov	bx, word ptr [0x83]
01ed:99be	mov	ax, word ptr [bp - 4]
01ed:99c1	call	0xaa2b
01ed:99c4	jb	loc_b8a9
01ed:99c6	mov	cx, word ptr [0x8d]
01ed:99ca	mov	bx, word ptr [0x8b]
01ed:99ce	mov	dx, word ptr [bp - 2]
01ed:99d1	mov	ax, word ptr [bp - 4]
01ed:99d4	call	0xaa2b
01ed:99d7	jbe	loc_b8b1
        	loc_b8a9:
01ed:99d9	mov	dx, 0xffff
01ed:99dc	mov	ax, 0xffff
01ed:99df	jmp	loc_b8d3
        	loc_b8b1:
01ed:99e1	mov	ax, word ptr [0x89]
01ed:99e4	mov	dx, word ptr [0x87]
01ed:99e8	mov	word ptr [bp - 8], dx
01ed:99eb	mov	word ptr [bp - 6], ax
01ed:99ee	push	word ptr [bp - 2]
01ed:99f1	push	word ptr [bp - 4]
01ed:99f4	call	0x98dd
01ed:99f7	or	ax, ax
01ed:99f9	jne	loc_b8cd
01ed:99fb	jmp	loc_b8a9
        	loc_b8cd:
01ed:99fd	mov	dx, word ptr [bp - 6]
01ed:9a00	mov	ax, word ptr [bp - 8]
        	loc_b8d3:
01ed:9a03	mov	sp, bp
01ed:9a05	pop	bp
01ed:9a06	ret	
sub_b86a ENDP
*/
void sub_b86a()
{
    // coverage: 0xab9a-0xac07 method sub_b86a
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    dx = memoryAGet16(ds, 0x0089);
    ax = memoryAGet16(ds, 0x0087);
    cx = memoryAGet16(ss, bp + 6);
    bx = memoryAGet16(ss, bp + 4);
    sub_c865();
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, dx);
    cx = memoryAGet16(ds, 0x0085);
    bx = memoryAGet16(ds, 0x0083);
    ax = memoryAGet16(ss, bp - 4);
    sub_c8fb();
    if (flags.carry)
        goto loc_b8a9;
    cx = memoryAGet16(ds, 0x008d);
    bx = memoryAGet16(ds, 0x008b);
    dx = memoryAGet16(ss, bp - 2);
    ax = memoryAGet16(ss, bp - 4);
    sub_c8fb();
    if (flags.zero || flags.carry)
        goto loc_b8b1;
loc_b8a9:
    dx = 0xffff;
    ax = 0xffff;
    goto loc_b8d3;
loc_b8b1:
    ax = memoryAGet16(ds, 0x0089);
    dx = memoryAGet16(ds, 0x0087);
    memoryASet16(ss, bp - 8, dx);
    memoryASet16(ss, bp - 6, ax);
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    sub_b7ad();
    if (ax)
        goto loc_b8cd;
    goto loc_b8a9;
loc_b8cd:
    dx = memoryAGet16(ss, bp - 6);
    ax = memoryAGet16(ss, bp - 8);
loc_b8d3:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9a07 sub_b8d7()
sub_b8d7 PROC
01ed:9a07	push	bp
01ed:9a08	mov	bp, sp
01ed:9a0a	push	si
01ed:9a0b	mov	ax, word ptr [bp + 4]
01ed:9a0e	or	ax, word ptr [bp + 6]
01ed:9a11	jne	loc_b8e9
01ed:9a13	call	0x9ad3
01ed:9a16	jmp	loc_b99e
        	loc_b8e9:
01ed:9a19	les	bx, ptr [bp + 4]
01ed:9a1c	mov	ax, word ptr es:[bx + 0x12]
01ed:9a20	cmp	ax, word ptr [bp + 4]
01ed:9a23	je	loc_b8fb
        	loc_b8f5:
01ed:9a25	mov	ax, 0xffff
01ed:9a28	jmp	loc_b9a0
        	loc_b8fb:
01ed:9a2b	les	bx, ptr [bp + 4]
01ed:9a2e	cmp	word ptr es:[bx], 0
01ed:9a32	jl	loc_b952
01ed:9a34	test	word ptr es:[bx + 2], 8
01ed:9a3a	jne	loc_b921
01ed:9a3c	mov	ax, word ptr es:[bx + 0xe]
01ed:9a40	mov	dx, word ptr [bp + 4]
01ed:9a43	add	dx, 5
01ed:9a46	cmp	ax, word ptr [bp + 6]
01ed:9a49	jne	loc_b950
01ed:9a4b	cmp	word ptr es:[bx + 0xc], dx
01ed:9a4f	jne	loc_b950
        	loc_b921:
01ed:9a51	les	bx, ptr [bp + 4]
01ed:9a54	mov	word ptr es:[bx], 0
01ed:9a59	mov	ax, word ptr es:[bx + 0xe]
01ed:9a5d	mov	dx, word ptr [bp + 4]
01ed:9a60	add	dx, 5
01ed:9a63	cmp	ax, word ptr [bp + 6]
01ed:9a66	jne	loc_b950
01ed:9a68	cmp	word ptr es:[bx + 0xc], dx
01ed:9a6c	jne	loc_b950
01ed:9a6e	mov	ax, word ptr es:[bx + 0xa]
01ed:9a72	mov	dx, word ptr es:[bx + 8]
01ed:9a76	mov	word ptr es:[bx + 0xc], dx
01ed:9a7a	mov	word ptr es:[bx + 0xe], ax
01ed:9a7e	jmp	loc_b99e
        	loc_b950:
01ed:9a80	jmp	loc_b99e
        	loc_b952:
01ed:9a82	les	bx, ptr [bp + 4]
01ed:9a85	mov	ax, word ptr es:[bx + 6]
01ed:9a89	add	ax, word ptr es:[bx]
01ed:9a8c	inc	ax
01ed:9a8d	mov	si, ax
01ed:9a8f	mov	ax, word ptr es:[bx]
01ed:9a92	sub	ax, si
01ed:9a94	mov	word ptr es:[bx], ax
01ed:9a97	push	si
01ed:9a98	mov	ax, word ptr es:[bx + 0xa]
01ed:9a9c	mov	dx, word ptr es:[bx + 8]
01ed:9aa0	mov	word ptr es:[bx + 0xc], dx
01ed:9aa4	mov	word ptr es:[bx + 0xe], ax
01ed:9aa8	push	ax
01ed:9aa9	push	dx
01ed:9aaa	mov	al, byte ptr es:[bx + 4]
01ed:9aae	cwde	
01ed:9aaf	push	ax
01ed:9ab0	call	0x9dfe
01ed:9ab3	add	sp, 8
01ed:9ab6	cmp	ax, si
01ed:9ab8	je	loc_b99e
01ed:9aba	les	bx, ptr [bp + 4]
01ed:9abd	test	word ptr es:[bx + 2], 0x200
01ed:9ac3	jne	loc_b99e
01ed:9ac5	or	word ptr es:[bx + 2], 0x10
01ed:9acb	jmp	loc_b8f5
        	loc_b99e:
01ed:9ace	xor	ax, ax
        	loc_b9a0:
01ed:9ad0	pop	si
01ed:9ad1	pop	bp
01ed:9ad2	ret	
sub_b8d7 ENDP
*/
void sub_b8d7()
{
    // coverage: 0xac07-0xacd3 method sub_b8d7
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    ax = memoryAGet16(ss, bp + 4);
    ax |= memoryAGet16(ss, bp + 6);
    if (ax)
        goto loc_b8e9;
    sub_b9a3();
    goto loc_b99e;
loc_b8e9:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    ax = memoryAGet16(es, bx + 18);
    if (ax == memoryAGet16(ss, bp + 4))
        goto loc_b8fb;
loc_b8f5:
    ax = 0xffff;
    goto loc_b9a0;
loc_b8fb:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if ((short)memoryAGet16(es, bx) < (short)0x0000)
        goto loc_b952;
    if (memoryAGet16(es, bx + 2) & 0x0008)
        goto loc_b921;
    ax = memoryAGet16(es, bx + 14);
    dx = memoryAGet16(ss, bp + 4);
    dx += 0x0005;
    if (ax != memoryAGet16(ss, bp + 6))
        goto loc_b950;
    if (memoryAGet16(es, bx + 12) != dx)
        goto loc_b950;
loc_b921:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    memoryASet16(es, bx, 0x0000);
    ax = memoryAGet16(es, bx + 14);
    dx = memoryAGet16(ss, bp + 4);
    dx += 0x0005;
    if (ax != memoryAGet16(ss, bp + 6))
        goto loc_b950;
    if (memoryAGet16(es, bx + 12) != dx)
        goto loc_b950;
    ax = memoryAGet16(es, bx + 10);
    dx = memoryAGet16(es, bx + 8);
    memoryASet16(es, bx + 12, dx);
    memoryASet16(es, bx + 14, ax);
    goto loc_b99e;
loc_b950:
    goto loc_b99e;
loc_b952:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    ax = memoryAGet16(es, bx + 6);
    ax += memoryAGet16(es, bx);
    ax++;
    si = ax;
    ax = memoryAGet16(es, bx);
    ax -= si;
    memoryASet16(es, bx, ax);
    push(si);
    ax = memoryAGet16(es, bx + 10);
    dx = memoryAGet16(es, bx + 8);
    memoryASet16(es, bx + 12, dx);
    memoryASet16(es, bx + 14, ax);
    push(ax);
    push(dx);
    al = memoryAGet(es, bx + 4);
    cbw();
    push(ax);
    sub_bcce();
    sp += 0x0008;
    if (ax == si)
        goto loc_b99e;
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if (memoryAGet16(es, bx + 2) & 0x0200)
        goto loc_b99e;
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) | 0x0010);
    goto loc_b8f5;
loc_b99e:
    ax = 0;
loc_b9a0:
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9ad3 sub_b9a3()
sub_b9a3 PROC
01ed:9ad3	push	bp
01ed:9ad4	mov	bp, sp
01ed:9ad6	sub	sp, 4
01ed:9ad9	push	si
01ed:9ada	push	di
01ed:9adb	xor	di, di
01ed:9add	mov	si, 0x14
01ed:9ae0	mov	word ptr [bp - 4], 0x698c
01ed:9ae5	mov	word ptr [bp - 2], ds
01ed:9ae8	jmp	loc_b9d5
        	loc_b9ba:
01ed:9aea	les	bx, ptr [bp - 4]
01ed:9aed	test	word ptr es:[bx + 2], 3
01ed:9af3	je	loc_b9d1
01ed:9af5	push	word ptr [bp - 2]
01ed:9af8	push	word ptr [bp - 4]
01ed:9afb	call	0x9a07
01ed:9afe	pop	cx
01ed:9aff	pop	cx
01ed:9b00	inc	di
        	loc_b9d1:
01ed:9b01	add	word ptr [bp - 4], 0x14
        	loc_b9d5:
01ed:9b05	mov	ax, si
01ed:9b07	dec	si
01ed:9b08	or	ax, ax
01ed:9b0a	jne	loc_b9ba
01ed:9b0c	mov	ax, di
01ed:9b0e	pop	di
01ed:9b0f	pop	si
01ed:9b10	mov	sp, bp
01ed:9b12	pop	bp
01ed:9b13	ret	
sub_b9a3 ENDP
*/
void sub_b9a3()
{
    // coverage: 0xacd3-0xad14 method sub_b9a3
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(si);
    push(di);
    di = 0;
    si = 0x0014;
    memoryASet16(ss, bp - 4, 0x698c);
    memoryASet16(ss, bp - 2, ds);
    goto loc_b9d5;
loc_b9ba:
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    if (!(memoryAGet16(es, bx + 2) & 0x0003))
        goto loc_b9d1;
    push(memoryAGet16(ss, bp - 2));
    push(memoryAGet16(ss, bp - 4));
    sub_b8d7();
    cx = pop();
    cx = pop();
    di++;
loc_b9d1:
    memoryASet16(ss, bp - 4, memoryAGet16(ss, bp - 4) + 0x0014);
loc_b9d5:
    ax = si;
    si--;
    if (ax)
        goto loc_b9ba;
    ax = di;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9b14 sub_b9e4()
sub_b9e4 PROC
01ed:9b14	push	bp
01ed:9b15	mov	bp, sp
01ed:9b17	sub	sp, 4
01ed:9b1a	push	si
01ed:9b1b	push	di
01ed:9b1c	les	bx, ptr [bp + 4]
01ed:9b1f	cmp	word ptr es:[bx], 0
01ed:9b23	jge	loc_b9ff
01ed:9b25	mov	ax, word ptr es:[bx + 6]
01ed:9b29	add	ax, word ptr es:[bx]
01ed:9b2c	inc	ax
01ed:9b2d	jmp	loc_ba0a
        	loc_b9ff:
01ed:9b2f	les	bx, ptr [bp + 4]
01ed:9b32	mov	ax, word ptr es:[bx]
01ed:9b35	cdq	
01ed:9b36	xor	ax, dx
01ed:9b38	sub	ax, dx
        	loc_ba0a:
01ed:9b3a	mov	si, ax
01ed:9b3c	mov	di, ax
01ed:9b3e	les	bx, ptr [bp + 4]
01ed:9b41	test	word ptr es:[bx + 2], 0x40
01ed:9b47	je	loc_ba1b
01ed:9b49	jmp	loc_ba5e
        	loc_ba1b:
01ed:9b4b	les	bx, ptr [bp + 4]
01ed:9b4e	mov	ax, word ptr es:[bx + 0xe]
01ed:9b52	mov	dx, word ptr es:[bx + 0xc]
01ed:9b56	mov	word ptr [bp - 4], dx
01ed:9b59	mov	word ptr [bp - 2], ax
01ed:9b5c	cmp	word ptr es:[bx], 0
01ed:9b60	jge	loc_ba57
01ed:9b62	jmp	loc_ba41
        	loc_ba34:
01ed:9b64	dec	word ptr [bp - 4]
01ed:9b67	les	bx, ptr [bp - 4]
01ed:9b6a	cmp	byte ptr es:[bx], 0xa
01ed:9b6e	jne	loc_ba41
01ed:9b70	inc	di
        	loc_ba41:
01ed:9b71	mov	ax, si
01ed:9b73	dec	si
01ed:9b74	or	ax, ax
01ed:9b76	jne	loc_ba34
01ed:9b78	jmp	loc_ba5e
        	loc_ba4a:
01ed:9b7a	les	bx, ptr [bp - 4]
01ed:9b7d	inc	word ptr [bp - 4]
01ed:9b80	cmp	byte ptr es:[bx], 0xa
01ed:9b84	jne	loc_ba57
01ed:9b86	inc	di
        	loc_ba57:
01ed:9b87	mov	ax, si
01ed:9b89	dec	si
01ed:9b8a	or	ax, ax
01ed:9b8c	jne	loc_ba4a
        	loc_ba5e:
01ed:9b8e	mov	ax, di
01ed:9b90	pop	di
01ed:9b91	pop	si
01ed:9b92	mov	sp, bp
01ed:9b94	pop	bp
01ed:9b95	ret	4
sub_b9e4 ENDP
*/
void sub_b9e4()
{
    // coverage: 0xad14-0xad98 method sub_b9e4
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(si);
    push(di);
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if ((short)memoryAGet16(es, bx) >= (short)0x0000)
        goto loc_b9ff;
    ax = memoryAGet16(es, bx + 6);
    ax += memoryAGet16(es, bx);
    ax++;
    goto loc_ba0a;
loc_b9ff:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    ax = memoryAGet16(es, bx);
    dx = ax & 0x8000 ? 0xffff : 0x0000;
    ax ^= dx;
    ax -= dx;
loc_ba0a:
    si = ax;
    di = ax;
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if (!(memoryAGet16(es, bx + 2) & 0x0040))
        goto loc_ba1b;
    goto loc_ba5e;
loc_ba1b:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    ax = memoryAGet16(es, bx + 14);
    dx = memoryAGet16(es, bx + 12);
    memoryASet16(ss, bp - 4, dx);
    memoryASet16(ss, bp - 2, ax);
    if ((short)memoryAGet16(es, bx) >= (short)0x0000)
        goto loc_ba57;
    goto loc_ba41;
loc_ba34:
    memoryASet16(ss, bp - 4, memoryAGet16(ss, bp - 4) - 1);
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    if (memoryAGet(es, bx) != 0x0a)
        goto loc_ba41;
    di++;
loc_ba41:
    ax = si;
    si--;
    if (ax)
        goto loc_ba34;
    goto loc_ba5e;
loc_ba4a:
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    memoryASet16(ss, bp - 4, memoryAGet16(ss, bp - 4) + 1);
    if (memoryAGet(es, bx) != 0x0a)
        goto loc_ba57;
    di++;
loc_ba57:
    ax = si;
    si--;
    if (ax)
        goto loc_ba4a;
loc_ba5e:
    ax = di;
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    sp += 4;
}
/* Assembly listing of 01ed:9b98 sub_ba68()
sub_ba68 PROC
01ed:9b98	push	bp
01ed:9b99	mov	bp, sp
01ed:9b9b	push	word ptr [bp + 6]
01ed:9b9e	push	word ptr [bp + 4]
01ed:9ba1	call	0x9a07
01ed:9ba4	pop	cx
01ed:9ba5	pop	cx
01ed:9ba6	or	ax, ax
01ed:9ba8	je	loc_ba7f
01ed:9baa	mov	ax, 0xffff
01ed:9bad	jmp	loc_bae2
        	loc_ba7f:
01ed:9baf	cmp	word ptr [bp + 0xc], 1
01ed:9bb3	jne	loc_ba9e
01ed:9bb5	les	bx, ptr [bp + 4]
01ed:9bb8	cmp	word ptr es:[bx], 0
01ed:9bbc	jle	loc_ba9e
01ed:9bbe	push	word ptr [bp + 6]
01ed:9bc1	push	word ptr [bp + 4]
01ed:9bc4	call	0x9b14
01ed:9bc7	cdq	
01ed:9bc8	sub	word ptr [bp + 8], ax
01ed:9bcb	sbb	word ptr [bp + 0xa], dx
        	loc_ba9e:
01ed:9bce	les	bx, ptr [bp + 4]
01ed:9bd1	and	word ptr es:[bx + 2], 0xfe5f
01ed:9bd7	mov	word ptr es:[bx], 0
01ed:9bdc	mov	ax, word ptr es:[bx + 0xa]
01ed:9be0	mov	dx, word ptr es:[bx + 8]
01ed:9be4	mov	word ptr es:[bx + 0xc], dx
01ed:9be8	mov	word ptr es:[bx + 0xe], ax
01ed:9bec	push	word ptr [bp + 0xc]
01ed:9bef	push	word ptr [bp + 0xa]
01ed:9bf2	push	word ptr [bp + 8]
01ed:9bf5	mov	al, byte ptr es:[bx + 4]
01ed:9bf9	cwde	
01ed:9bfa	push	ax
01ed:9bfb	call	0xa1c6
01ed:9bfe	add	sp, 8
01ed:9c01	cmp	dx, -1
01ed:9c04	jne	loc_bae0
01ed:9c06	cmp	ax, 0xffff
01ed:9c09	jne	loc_bae0
01ed:9c0b	mov	ax, 0xffff
01ed:9c0e	jmp	loc_bae2
        	loc_bae0:
01ed:9c10	xor	ax, ax
        	loc_bae2:
01ed:9c12	pop	bp
01ed:9c13	ret	
sub_ba68 ENDP
*/
void sub_ba68()
{
    // coverage: 0xad98-0xae14 method sub_ba68
    push(0x7777);
    push(bp);
    bp = sp;
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_b8d7();
    cx = pop();
    cx = pop();
    if (!ax)
        goto loc_ba7f;
    ax = 0xffff;
    goto loc_bae2;
loc_ba7f:
    if (memoryAGet16(ss, bp + 12) != 0x0001)
        goto loc_ba9e;
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if ((short)memoryAGet16(es, bx) <= (short)0x0000)
        goto loc_ba9e;
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_b9e4();
    dx = ax & 0x8000 ? 0xffff : 0x0000;
    flags.carry = memoryAGet16(ss, bp + 8) < ax;
    memoryASet16(ss, bp + 8, memoryAGet16(ss, bp + 8) - ax);
    memoryASet16(ss, bp + 10, memoryAGet16(ss, bp + 10) - (dx + flags.carry));
loc_ba9e:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) & 0xfe5f);
    memoryASet16(es, bx, 0x0000);
    ax = memoryAGet16(es, bx + 10);
    dx = memoryAGet16(es, bx + 8);
    memoryASet16(es, bx + 12, dx);
    memoryASet16(es, bx + 14, ax);
    push(memoryAGet16(ss, bp + 12));
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    al = memoryAGet(es, bx + 4);
    cbw();
    push(ax);
    sub_c096();
    sp += 0x0008;
    if (dx != 0xffff)
        goto loc_bae0;
    if (ax != 0xffff)
        goto loc_bae0;
    ax = 0xffff;
    goto loc_bae2;
loc_bae0:
    ax = 0;
loc_bae2:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9c62 sub_bb32()
sub_bb32 PROC
01ed:9c62	mov	al, byte ptr [0x6990]
01ed:9c65	cwde	
01ed:9c66	push	ax
01ed:9c67	call	0xa1b5
01ed:9c6a	pop	cx
01ed:9c6b	or	ax, ax
01ed:9c6d	jne	loc_bb45
01ed:9c6f	and	word ptr [0x698e], 0xfdff
        	loc_bb45:
01ed:9c75	mov	ax, 0x200
01ed:9c78	push	ax
01ed:9c79	test	word ptr [0x698e], 0x200
01ed:9c7f	je	loc_bb56
01ed:9c81	mov	ax, 1
01ed:9c84	jmp	loc_bb58
        	loc_bb56:
01ed:9c86	xor	ax, ax
        	loc_bb58:
01ed:9c88	push	ax
01ed:9c89	xor	ax, ax
01ed:9c8b	xor	dx, dx
01ed:9c8d	push	ax
01ed:9c8e	push	dx
01ed:9c8f	push	ds
01ed:9c90	mov	ax, 0x698c
01ed:9c93	push	ax
01ed:9c94	call	0x9cd3
01ed:9c97	add	sp, 0xc
01ed:9c9a	mov	al, byte ptr [0x69a4]
01ed:9c9d	cwde	
01ed:9c9e	push	ax
01ed:9c9f	call	0xa1b5
01ed:9ca2	pop	cx
01ed:9ca3	or	ax, ax
01ed:9ca5	jne	loc_bb7d
01ed:9ca7	and	word ptr [0x69a2], 0xfdff
        	loc_bb7d:
01ed:9cad	mov	ax, 0x200
01ed:9cb0	push	ax
01ed:9cb1	test	word ptr [0x69a2], 0x200
01ed:9cb7	je	loc_bb8e
01ed:9cb9	mov	ax, 2
01ed:9cbc	jmp	loc_bb90
        	loc_bb8e:
01ed:9cbe	xor	ax, ax
        	loc_bb90:
01ed:9cc0	push	ax
01ed:9cc1	xor	ax, ax
01ed:9cc3	xor	dx, dx
01ed:9cc5	push	ax
01ed:9cc6	push	dx
01ed:9cc7	push	ds
01ed:9cc8	mov	ax, 0x69a0
01ed:9ccb	push	ax
01ed:9ccc	call	0x9cd3
01ed:9ccf	add	sp, 0xc
01ed:9cd2	ret	
sub_bb32 ENDP
*/
void sub_bb32()
{
    // coverage: 0xae62-0xaed3 method sub_bb32
    push(0x7777);
    al = memoryAGet(ds, 0x6990);
    cbw();
    push(ax);
    sub_c085();
    cx = pop();
    if (ax)
        goto loc_bb45;
    memoryASet16(ds, 0x698e, memoryAGet16(ds, 0x698e) & 0xfdff);
loc_bb45:
    ax = 0x0200;
    push(ax);
    if (!(memoryAGet16(ds, 0x698e) & 0x0200))
        goto loc_bb56;
    ax = 0x0001;
    goto loc_bb58;
loc_bb56:
    ax = 0;
loc_bb58:
    push(ax);
    ax = 0;
    dx = 0;
    push(ax);
    push(dx);
    push(ds);
    ax = 0x698c;
    push(ax);
    sub_bba3();
    sp += 0x000c;
    al = memoryAGet(ds, 0x69a4);
    cbw();
    push(ax);
    sub_c085();
    cx = pop();
    if (ax)
        goto loc_bb7d;
    memoryASet16(ds, 0x69a2, memoryAGet16(ds, 0x69a2) & 0xfdff);
loc_bb7d:
    ax = 0x0200;
    push(ax);
    if (!(memoryAGet16(ds, 0x69a2) & 0x0200))
        goto loc_bb8e;
    ax = 0x0002;
    goto loc_bb90;
loc_bb8e:
    ax = 0;
loc_bb90:
    push(ax);
    ax = 0;
    dx = 0;
    push(ax);
    push(dx);
    push(ds);
    ax = 0x69a0;
    push(ax);
    sub_bba3();
    sp += 0x000c;
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9cd3 sub_bba3()
sub_bba3 PROC
01ed:9cd3	push	bp
01ed:9cd4	mov	bp, sp
01ed:9cd6	push	si
01ed:9cd7	push	di
01ed:9cd8	mov	di, word ptr [bp + 0xc]
01ed:9cdb	mov	si, word ptr [bp + 0xe]
01ed:9cde	les	bx, ptr [bp + 4]
01ed:9ce1	mov	ax, word ptr es:[bx + 0x12]
01ed:9ce5	cmp	ax, word ptr [bp + 4]
01ed:9ce8	jne	loc_bbc5
01ed:9cea	cmp	di, 2
01ed:9ced	jg	loc_bbc5
01ed:9cef	cmp	si, 0x7fff
01ed:9cf3	jbe	loc_bbcb
        	loc_bbc5:
01ed:9cf5	mov	ax, 0xffff
01ed:9cf8	jmp	loc_bcb2
        	loc_bbcb:
01ed:9cfb	cmp	word ptr [0x6b4a], 0
01ed:9d00	jne	loc_bbe1
01ed:9d02	cmp	word ptr [bp + 4], 0x69a0
01ed:9d07	jne	loc_bbe1
01ed:9d09	mov	word ptr [0x6b4a], 1
01ed:9d0f	jmp	loc_bbf5
        	loc_bbe1:
01ed:9d11	cmp	word ptr [0x6b48], 0
01ed:9d16	jne	loc_bbf5
01ed:9d18	cmp	word ptr [bp + 4], 0x698c
01ed:9d1d	jne	loc_bbf5
01ed:9d1f	mov	word ptr [0x6b48], 1
        	loc_bbf5:
01ed:9d25	les	bx, ptr [bp + 4]
01ed:9d28	cmp	word ptr es:[bx], 0
01ed:9d2c	je	loc_bc14
01ed:9d2e	mov	ax, 1
01ed:9d31	push	ax
01ed:9d32	xor	ax, ax
01ed:9d34	xor	dx, dx
01ed:9d36	push	ax
01ed:9d37	push	dx
01ed:9d38	push	word ptr [bp + 6]
01ed:9d3b	push	word ptr [bp + 4]
01ed:9d3e	call	0x9b98
01ed:9d41	add	sp, 0xa
        	loc_bc14:
01ed:9d44	les	bx, ptr [bp + 4]
01ed:9d47	test	word ptr es:[bx + 2], 4
01ed:9d4d	je	loc_bc2c
01ed:9d4f	push	word ptr es:[bx + 0xa]
01ed:9d53	push	word ptr es:[bx + 8]
01ed:9d57	call	0xa62e
01ed:9d5a	pop	cx
01ed:9d5b	pop	cx
        	loc_bc2c:
01ed:9d5c	les	bx, ptr [bp + 4]
01ed:9d5f	and	word ptr es:[bx + 2], 0xfff3
01ed:9d65	mov	word ptr es:[bx + 6], 0
01ed:9d6b	mov	ax, word ptr [bp + 6]
01ed:9d6e	mov	dx, word ptr [bp + 4]
01ed:9d71	add	dx, 5
01ed:9d74	mov	word ptr es:[bx + 8], dx
01ed:9d78	mov	word ptr es:[bx + 0xa], ax
01ed:9d7c	mov	word ptr es:[bx + 0xc], dx
01ed:9d80	mov	word ptr es:[bx + 0xe], ax
01ed:9d84	cmp	di, 2
01ed:9d87	je	loc_bcb0
01ed:9d89	or	si, si
01ed:9d8b	jbe	loc_bcb0
01ed:9d8d	mov	word ptr [0x6984], 0x9f25
01ed:9d93	mov	ax, word ptr [bp + 8]
01ed:9d96	or	ax, word ptr [bp + 0xa]
01ed:9d99	jne	loc_bc88
01ed:9d9b	push	si
01ed:9d9c	call	0xa714
01ed:9d9f	pop	cx
01ed:9da0	mov	word ptr [bp + 8], ax
01ed:9da3	mov	word ptr [bp + 0xa], dx
01ed:9da6	or	ax, dx
01ed:9da8	je	loc_bc85
01ed:9daa	les	bx, ptr [bp + 4]
01ed:9dad	or	word ptr es:[bx + 2], 4
01ed:9db3	jmp	loc_bc88
        	loc_bc85:
01ed:9db5	jmp	loc_bbc5
        	loc_bc88:
01ed:9db8	les	bx, ptr [bp + 4]
01ed:9dbb	mov	ax, word ptr [bp + 0xa]
01ed:9dbe	mov	dx, word ptr [bp + 8]
01ed:9dc1	mov	word ptr es:[bx + 0xc], dx
01ed:9dc5	mov	word ptr es:[bx + 0xe], ax
01ed:9dc9	mov	word ptr es:[bx + 8], dx
01ed:9dcd	mov	word ptr es:[bx + 0xa], ax
01ed:9dd1	mov	word ptr es:[bx + 6], si
01ed:9dd5	cmp	di, 1
01ed:9dd8	jne	loc_bcb0
01ed:9dda	or	word ptr es:[bx + 2], 8
        	loc_bcb0:
01ed:9de0	xor	ax, ax
        	loc_bcb2:
01ed:9de2	pop	di
01ed:9de3	pop	si
01ed:9de4	pop	bp
01ed:9de5	ret	
sub_bba3 ENDP
*/
void sub_bba3()
{
    // coverage: 0xaed3-0xafe6 method sub_bba3
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    di = memoryAGet16(ss, bp + 12);
    si = memoryAGet16(ss, bp + 14);
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    ax = memoryAGet16(es, bx + 18);
    if (ax != memoryAGet16(ss, bp + 4))
        goto loc_bbc5;
    if ((short)di > (short)0x0002)
        goto loc_bbc5;
    if (si <= 0x7fff)
        goto loc_bbcb;
loc_bbc5:
    ax = 0xffff;
    goto loc_bcb2;
loc_bbcb:
    if (memoryAGet16(ds, 0x6b4a) != 0x0000)
        goto loc_bbe1;
    if (memoryAGet16(ss, bp + 4) != 0x69a0)
        goto loc_bbe1;
    memoryASet16(ds, 0x6b4a, 0x0001);
    goto loc_bbf5;
loc_bbe1:
    if (memoryAGet16(ds, 0x6b48) != 0x0000)
        goto loc_bbf5;
    if (memoryAGet16(ss, bp + 4) != 0x698c)
        goto loc_bbf5;
    memoryASet16(ds, 0x6b48, 0x0001);
loc_bbf5:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if (memoryAGet16(es, bx) == 0x0000)
        goto loc_bc14;
    ax = 0x0001;
    push(ax);
    ax = 0;
    dx = 0;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_ba68();
    sp += 0x000a;
loc_bc14:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if (!(memoryAGet16(es, bx + 2) & 0x0004))
        goto loc_bc2c;
    push(memoryAGet16(es, bx + 10));
    push(memoryAGet16(es, bx + 8));
    sub_c4fe();
    cx = pop();
    cx = pop();
loc_bc2c:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) & 0xfff3);
    memoryASet16(es, bx + 6, 0x0000);
    ax = memoryAGet16(ss, bp + 6);
    dx = memoryAGet16(ss, bp + 4);
    dx += 0x0005;
    memoryASet16(es, bx + 8, dx);
    memoryASet16(es, bx + 10, ax);
    memoryASet16(es, bx + 12, dx);
    memoryASet16(es, bx + 14, ax);
    if (di == 0x0002)
        goto loc_bcb0;
    if (stop(/*condition!*/))
        goto loc_bcb0;
    memoryASet16(ds, 0x6984, 0x9f25);
    ax = memoryAGet16(ss, bp + 8);
    ax |= memoryAGet16(ss, bp + 10);
    if (ax)
        goto loc_bc88;
    push(si);
    sub_c5e4();
    cx = pop();
    memoryASet16(ss, bp + 8, ax);
    memoryASet16(ss, bp + 10, dx);
    ax |= dx;
    if (!ax)
        goto loc_bc85;
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) | 0x0004);
    goto loc_bc88;
loc_bc85:
    goto loc_bbc5;
loc_bc88:
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    ax = memoryAGet16(ss, bp + 10);
    dx = memoryAGet16(ss, bp + 8);
    memoryASet16(es, bx + 12, dx);
    memoryASet16(es, bx + 14, ax);
    memoryASet16(es, bx + 8, dx);
    memoryASet16(es, bx + 10, ax);
    memoryASet16(es, bx + 6, si);
    if (di != 0x0001)
        goto loc_bcb0;
    memoryASet16(es, bx + 2, memoryAGet16(es, bx + 2) | 0x0008);
loc_bcb0:
    ax = 0;
loc_bcb2:
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9dfe sub_bcce()
sub_bcce PROC
01ed:9dfe	push	bp
01ed:9dff	mov	bp, sp
01ed:9e01	sub	sp, 0x8e
01ed:9e05	push	si
01ed:9e06	push	di
01ed:9e07	mov	ax, word ptr [bp + 0xa]
01ed:9e0a	inc	ax
01ed:9e0b	cmp	ax, 2
01ed:9e0e	jae	loc_bce5
01ed:9e10	xor	ax, ax
01ed:9e12	jmp	loc_bdef
        	loc_bce5:
01ed:9e15	mov	bx, word ptr [bp + 4]
01ed:9e18	shl	bx, 1
01ed:9e1a	test	word ptr [bx + 0x6b1c], 0x8000
01ed:9e20	je	loc_bd07
01ed:9e22	push	word ptr [bp + 0xa]
01ed:9e25	push	word ptr [bp + 8]
01ed:9e28	push	word ptr [bp + 6]
01ed:9e2b	push	word ptr [bp + 4]
01ed:9e2e	call	0xa49e
01ed:9e31	add	sp, 8
01ed:9e34	jmp	loc_bdef
        	loc_bd07:
01ed:9e37	mov	bx, word ptr [bp + 4]
01ed:9e3a	shl	bx, 1
01ed:9e3c	and	word ptr [bx + 0x6b1c], 0xfdff
01ed:9e42	mov	ax, word ptr [bp + 8]
01ed:9e45	mov	dx, word ptr [bp + 6]
01ed:9e48	mov	word ptr [bp - 0xc], dx
01ed:9e4b	mov	word ptr [bp - 0xa], ax
01ed:9e4e	mov	ax, word ptr [bp + 0xa]
01ed:9e51	mov	word ptr [bp - 6], ax
01ed:9e54	jmp	loc_bd9e
        	loc_bd26:
01ed:9e56	dec	word ptr [bp - 6]
01ed:9e59	les	bx, ptr [bp - 0xc]
01ed:9e5c	inc	word ptr [bp - 0xc]
01ed:9e5f	mov	al, byte ptr es:[bx]
01ed:9e62	mov	byte ptr [bp - 7], al
01ed:9e65	cmp	al, 0xa
01ed:9e67	jne	loc_bd43
01ed:9e69	les	bx, ptr [bp - 4]
01ed:9e6c	mov	byte ptr es:[bx], 0xd
01ed:9e70	inc	word ptr [bp - 4]
        	loc_bd43:
01ed:9e73	les	bx, ptr [bp - 4]
01ed:9e76	mov	al, byte ptr [bp - 7]
01ed:9e79	mov	byte ptr es:[bx], al
01ed:9e7c	inc	word ptr [bp - 4]
01ed:9e7f	lea	ax, [bp - 0x8e]
01ed:9e83	mov	dx, word ptr [bp - 4]
01ed:9e86	xor	bx, bx
01ed:9e88	sub	dx, ax
01ed:9e8a	sbb	bx, 0
01ed:9e8d	or	bx, bx
01ed:9e8f	jl	loc_bda8
01ed:9e91	jne	loc_bd69
01ed:9e93	cmp	dx, 0x80
01ed:9e97	jb	loc_bda8
        	loc_bd69:
01ed:9e99	lea	ax, [bp - 0x8e]
01ed:9e9d	mov	dx, word ptr [bp - 4]
01ed:9ea0	xor	bx, bx
01ed:9ea2	sub	dx, ax
01ed:9ea4	sbb	bx, 0
01ed:9ea7	mov	si, dx
01ed:9ea9	push	si
01ed:9eaa	push	ss
01ed:9eab	push	ax
01ed:9eac	push	word ptr [bp + 4]
01ed:9eaf	call	0xa49e
01ed:9eb2	add	sp, 8
01ed:9eb5	mov	di, ax
01ed:9eb7	cmp	ax, si
01ed:9eb9	je	loc_bd9e
01ed:9ebb	or	di, di
01ed:9ebd	jae	loc_bd94
        	loc_bd8f:
01ed:9ebf	mov	ax, 0xffff
01ed:9ec2	jmp	loc_bdea
        	loc_bd94:
01ed:9ec4	mov	ax, word ptr [bp + 0xa]
01ed:9ec7	sub	ax, word ptr [bp - 6]
01ed:9eca	jmp	loc_bde6
01ed:9ecc		
        	loc_bd9e:
01ed:9ece	lea	ax, [bp - 0x8e]
01ed:9ed2	mov	word ptr [bp - 4], ax
01ed:9ed5	mov	word ptr [bp - 2], ss
        	loc_bda8:
01ed:9ed8	cmp	word ptr [bp - 6], 0
01ed:9edc	je	loc_bdb1
01ed:9ede	jmp	loc_bd26
        	loc_bdb1:
01ed:9ee1	lea	ax, [bp - 0x8e]
01ed:9ee5	mov	dx, word ptr [bp - 4]
01ed:9ee8	xor	bx, bx
01ed:9eea	sub	dx, ax
01ed:9eec	sbb	bx, 0
01ed:9eef	mov	si, dx
01ed:9ef1	mov	ax, dx
01ed:9ef3	or	ax, ax
01ed:9ef5	jbe	loc_bdec
01ed:9ef7	push	si
01ed:9ef8	push	ss
01ed:9ef9	lea	ax, [bp - 0x8e]
01ed:9efd	push	ax
01ed:9efe	push	word ptr [bp + 4]
01ed:9f01	call	0xa49e
01ed:9f04	add	sp, 8
01ed:9f07	mov	di, ax
01ed:9f09	cmp	ax, si
01ed:9f0b	je	loc_bdec
01ed:9f0d	or	di, di
01ed:9f0f	jae	loc_bde3
01ed:9f11	jmp	loc_bd8f
        	loc_bde3:
01ed:9f13	mov	ax, word ptr [bp + 0xa]
        	loc_bde6:
01ed:9f16	add	ax, di
01ed:9f18	sub	ax, si
        	loc_bdea:
01ed:9f1a	jmp	loc_bdef
        	loc_bdec:
01ed:9f1c	mov	ax, word ptr [bp + 0xa]
        	loc_bdef:
01ed:9f1f	pop	di
01ed:9f20	pop	si
01ed:9f21	mov	sp, bp
01ed:9f23	pop	bp
01ed:9f24	ret	
sub_bcce ENDP
*/
void sub_bcce()
{
    // coverage: 0xaffe-0xb0cc method sub_bcce
    // coverage: 0xb0ce-0xb125 method sub_bcce
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x008e;
    push(si);
    push(di);
    ax = memoryAGet16(ss, bp + 10);
    ax++;
    if (ax >= 0x0002)
        goto loc_bce5;
    ax = 0;
    goto loc_bdef;
loc_bce5:
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    if (!(memoryAGet16(ds, bx + 27420) & 0x8000))
        goto loc_bd07;
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_c36e();
    sp += 0x0008;
    goto loc_bdef;
loc_bd07:
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    memoryASet16(ds, bx + 27420, memoryAGet16(ds, bx + 27420) & 0xfdff);
    ax = memoryAGet16(ss, bp + 8);
    dx = memoryAGet16(ss, bp + 6);
    memoryASet16(ss, bp - 12, dx);
    memoryASet16(ss, bp - 10, ax);
    ax = memoryAGet16(ss, bp + 10);
    memoryASet16(ss, bp - 6, ax);
    goto loc_bd9e;
loc_bd26:
    memoryASet16(ss, bp - 6, memoryAGet16(ss, bp - 6) - 1);
    bx = memoryAGet16(ss, bp - 12);
    es = memoryAGet16(ss, bp - 12 + 2);
    memoryASet16(ss, bp - 12, memoryAGet16(ss, bp - 12) + 1);
    al = memoryAGet(es, bx);
    memoryASet(ss, bp - 7, al);
    if (al != 0x0a)
        goto loc_bd43;
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    memoryASet(es, bx, 0x0d);
    memoryASet16(ss, bp - 4, memoryAGet16(ss, bp - 4) + 1);
loc_bd43:
    bx = memoryAGet16(ss, bp - 4);
    es = memoryAGet16(ss, bp - 4 + 2);
    al = memoryAGet(ss, bp - 7);
    memoryASet(es, bx, al);
    memoryASet16(ss, bp - 4, memoryAGet16(ss, bp - 4) + 1);
    ax = bp - 0x8e;
    dx = memoryAGet16(ss, bp - 4);
    bx = 0;
    flags.carry = dx < ax;
    dx -= ax;
    bx -= flags.carry;
    if ((short)bx < 0)
        goto loc_bda8;
    if (bx)
        goto loc_bd69;
    if (dx < 0x0080)
        goto loc_bda8;
loc_bd69:
    ax = bp - 0x8e;
    dx = memoryAGet16(ss, bp - 4);
    bx = 0;
    flags.carry = dx < ax;
    dx -= ax;
    bx -= flags.carry;
    si = dx;
    push(si);
    push(ss);
    push(ax);
    push(memoryAGet16(ss, bp + 4));
    sub_c36e();
    sp += 0x0008;
    di = ax;
    if (ax == si)
        goto loc_bd9e;
    if (stop(/*condition!*/))
        goto loc_bd94;
loc_bd8f:
    ax = 0xffff;
    goto loc_bdea;
loc_bd94:
    ax = memoryAGet16(ss, bp + 10);
    ax -= memoryAGet16(ss, bp - 6);
    goto loc_bde6;
    //   gap of 2 bytes
loc_bd9e:
    ax = bp - 0x8e;
    memoryASet16(ss, bp - 4, ax);
    memoryASet16(ss, bp - 2, ss);
loc_bda8:
    if (memoryAGet16(ss, bp - 6) == 0x0000)
        goto loc_bdb1;
    goto loc_bd26;
loc_bdb1:
    ax = bp - 0x8e;
    dx = memoryAGet16(ss, bp - 4);
    bx = 0;
    flags.carry = dx < ax;
    dx -= ax;
    bx -= flags.carry;
    si = dx;
    ax = dx;
    if (stop(/*condition!*/))
        goto loc_bdec;
    push(si);
    push(ss);
    ax = bp - 0x8e;
    push(ax);
    push(memoryAGet16(ss, bp + 4));
    sub_c36e();
    sp += 0x0008;
    di = ax;
    if (ax == si)
        goto loc_bdec;
    if (stop(/*condition!*/))
        goto loc_bde3;
    goto loc_bd8f;
loc_bde3:
    ax = memoryAGet16(ss, bp + 10);
loc_bde6:
    ax += di;
    ax -= si;
loc_bdea:
    goto loc_bdef;
loc_bdec:
    ax = memoryAGet16(ss, bp + 10);
loc_bdef:
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9f98 sub_be68()
sub_be68 PROC
01ed:9f98	push	bp
01ed:9f99	mov	bp, sp
01ed:9f9b	push	ds
01ed:9f9c	mov	cx, word ptr [bp + 0xa]
01ed:9f9f	mov	ah, 0x43
01ed:9fa1	mov	al, byte ptr [bp + 8]
01ed:9fa4	lds	dx, ptr [bp + 4]
01ed:9fa7	int	0x21
01ed:9fa9	pop	ds
01ed:9faa	jb	loc_be7f
01ed:9fac	xchg	cx, ax
01ed:9fad	jmp	loc_be83
        	loc_be7f:
01ed:9faf	push	ax
01ed:9fb0	call	0xa178
        	loc_be83:
01ed:9fb3	pop	bp
01ed:9fb4	ret	
sub_be68 ENDP
*/
void sub_be68()
{
    // coverage: 0xb198-0xb1b5 method sub_be68
    push(0x7777);
    push(bp);
    bp = sp;
    push(ds);
    cx = memoryAGet16(ss, bp + 10);
    ah = 0x43;
    al = memoryAGet(ss, bp + 8);
    dx = memoryAGet16(ss, bp + 4);
    ds = memoryAGet16(ss, bp + 4 + 2);
    interrupt(0x21);
    ds = pop();
    if (flags.carry)
        goto loc_be7f;
    tx = cx;
    cx = ax;
    ax = tx;
    goto loc_be83;
loc_be7f:
    push(ax);
    sub_c048();
loc_be83:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:9fb5 sub_be85()
sub_be85 PROC
01ed:9fb5	push	bp
01ed:9fb6	mov	bp, sp
01ed:9fb8	mov	ah, 0x3e
01ed:9fba	mov	bx, word ptr [bp + 4]
01ed:9fbd	int	0x21
01ed:9fbf	jb	loc_be9d
01ed:9fc1	shl	bx, 1
01ed:9fc3	mov	word ptr [bx + 0x6b1c], 0xffff
01ed:9fc9	xor	ax, ax
01ed:9fcb	jmp	loc_bea1
        	loc_be9d:
01ed:9fcd	push	ax
01ed:9fce	call	0xa178
        	loc_bea1:
01ed:9fd1	pop	bp
01ed:9fd2	ret	
sub_be85 ENDP
*/
void sub_be85()
{
    // coverage: 0xb1b5-0xb1d3 method sub_be85
    push(0x7777);
    push(bp);
    bp = sp;
    ah = 0x3e;
    bx = memoryAGet16(ss, bp + 4);
    interrupt(0x21);
    if (flags.carry)
        goto loc_be9d;
    bx <<= 1;
    memoryASet16(ds, bx + 27420, 0xffff);
    ax = 0;
    goto loc_bea1;
loc_be9d:
    push(ax);
    sub_c048();
loc_bea1:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a0a0 sub_bf70()
sub_bf70 PROC
01ed:a0a0	push	bp
01ed:a0a1	mov	bp, sp
01ed:a0a3	mov	ah, 0x25
01ed:a0a5	mov	al, byte ptr [bp + 4]
01ed:a0a8	push	ds
01ed:a0a9	lds	dx, ptr [bp + 6]
01ed:a0ac	int	0x21
01ed:a0ae	pop	ds
01ed:a0af	pop	bp
01ed:a0b0	ret	
sub_bf70 ENDP
*/
void sub_bf70()
{
    // coverage: 0xb2a0-0xb2b1 method sub_bf70
    push(0x7777);
    push(bp);
    bp = sp;
    ah = 0x25;
    al = memoryAGet(ss, bp + 4);
    push(ds);
    dx = memoryAGet16(ss, bp + 6);
    ds = memoryAGet16(ss, bp + 6 + 2);
    interrupt(0x21);
    ds = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a0e9 sub_bfb9()
sub_bfb9 PROC
01ed:a0e9	push	bp
01ed:a0ea	mov	bp, sp
01ed:a0ec	mov	ax, word ptr [bp + 4]
01ed:a0ef	mov	word ptr [0xa1fe], ax
01ed:a0f2	push	cs
01ed:a0f3	mov	ax, 0xa0b1
01ed:a0f6	push	ax
01ed:a0f7	mov	ax, 0x24
01ed:a0fa	push	ax
01ed:a0fb	call	0xa0a0
01ed:a0fe	add	sp, 6
01ed:a101	pop	bp
01ed:a102	ret	
sub_bfb9 ENDP
*/
void sub_bfb9()
{
    // coverage: 0xb2e9-0xb303 method sub_bfb9
    push(0x7777);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4);
    memoryASet16(ds, 0xa1fe, ax);
    push(cs);
    ax = 0xa0b1;
    push(ax);
    ax = 0x0024;
    push(ax);
    sub_bf70();
    sp += 0x0006;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a14f sub_c01f()
sub_c01f PROC
01ed:a14f	push	bp
01ed:a150	mov	bp, sp
01ed:a152	push	ds
01ed:a153	mov	ah, 0x44
01ed:a155	mov	al, byte ptr [bp + 6]
01ed:a158	mov	bx, word ptr [bp + 4]
01ed:a15b	mov	cx, word ptr [bp + 0xc]
01ed:a15e	lds	dx, ptr [bp + 8]
01ed:a161	int	0x21
01ed:a163	pop	ds
01ed:a164	jb	loc_c042
01ed:a166	cmp	word ptr [bp + 6], 0
01ed:a16a	jne	loc_c040
01ed:a16c	mov	ax, dx
01ed:a16e	jmp	loc_c046
        	loc_c040:
01ed:a170	jmp	loc_c046
        	loc_c042:
01ed:a172	push	ax
01ed:a173	call	0xa178
        	loc_c046:
01ed:a176	pop	bp
01ed:a177	ret	
sub_c01f ENDP
*/
void sub_c01f()
{
    // coverage: 0xb34f-0xb378 method sub_c01f
    push(0x7777);
    push(bp);
    bp = sp;
    push(ds);
    ah = 0x44;
    al = memoryAGet(ss, bp + 6);
    bx = memoryAGet16(ss, bp + 4);
    cx = memoryAGet16(ss, bp + 12);
    dx = memoryAGet16(ss, bp + 8);
    ds = memoryAGet16(ss, bp + 8 + 2);
    interrupt(0x21);
    ds = pop();
    if (flags.carry)
        goto loc_c042;
    if (memoryAGet16(ss, bp + 6) != 0x0000)
        goto loc_c040;
    ax = dx;
    goto loc_c046;
loc_c040:
    goto loc_c046;
loc_c042:
    push(ax);
    sub_c048();
loc_c046:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a178 sub_c048()
sub_c048 PROC
01ed:a178	push	bp
01ed:a179	mov	bp, sp
01ed:a17b	push	si
01ed:a17c	mov	si, word ptr [bp + 4]
01ed:a17f	or	si, si
01ed:a181	jl	loc_c068
01ed:a183	cmp	si, 0x58
01ed:a186	jle	loc_c05b
        	loc_c058:
01ed:a188	mov	si, 0x57
        	loc_c05b:
01ed:a18b	mov	word ptr [0x6b4e], si
01ed:a18f	mov	al, byte ptr [si + 0x6b50]
01ed:a193	cwde	
01ed:a194	mov	si, ax
01ed:a196	jmp	loc_c079
        	loc_c068:
01ed:a198	mov	ax, si
01ed:a19a	neg	ax
01ed:a19c	mov	si, ax
01ed:a19e	cmp	si, 0x23
01ed:a1a1	jg	loc_c058
01ed:a1a3	mov	word ptr [0x6b4e], 0xffff
        	loc_c079:
01ed:a1a9	mov	word ptr [0x7d], si
01ed:a1ad	mov	ax, 0xffff
01ed:a1b0	pop	si
01ed:a1b1	pop	bp
01ed:a1b2	ret	2
sub_c048 ENDP
*/
void sub_c048()
{
    // coverage: 0xb378-0xb3b5 method sub_c048
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    si = memoryAGet16(ss, bp + 4);
    if ((short)si < 0)
        goto loc_c068;
    if ((short)si <= (short)0x0058)
        goto loc_c05b;
loc_c058:
    si = 0x0057;
loc_c05b:
    memoryASet16(ds, 0x6b4e, si);
    al = memoryAGet(ds, si + 27472);
    cbw();
    si = ax;
    goto loc_c079;
loc_c068:
    ax = si;
    ax = -ax;
    si = ax;
    if ((short)si > (short)0x0023)
        goto loc_c058;
    memoryASet16(ds, 0x6b4e, 0xffff);
loc_c079:
    memoryASet16(ds, 0x007d, si);
    ax = 0xffff;
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
    sp += 2;
}
/* Assembly listing of 01ed:a1b5 sub_c085()
sub_c085 PROC
01ed:a1b5	push	bp
01ed:a1b6	mov	bp, sp
01ed:a1b8	mov	ax, 0x4400
01ed:a1bb	mov	bx, word ptr [bp + 4]
01ed:a1be	int	0x21
01ed:a1c0	xchg	dx, ax
01ed:a1c1	and	ax, 0x80
01ed:a1c4	pop	bp
01ed:a1c5	ret	
sub_c085 ENDP
*/
void sub_c085()
{
    // coverage: 0xb3b5-0xb3c6 method sub_c085
    push(0x7777);
    push(bp);
    bp = sp;
    ax = 0x4400;
    bx = memoryAGet16(ss, bp + 4);
    interrupt(0x21);
    tx = dx;
    dx = ax;
    ax = tx;
    ax &= 0x0080;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a1c6 sub_c096()
sub_c096 PROC
01ed:a1c6	push	bp
01ed:a1c7	mov	bp, sp
01ed:a1c9	mov	bx, word ptr [bp + 4]
01ed:a1cc	shl	bx, 1
01ed:a1ce	and	word ptr [bx + 0x6b1c], 0xfdff
01ed:a1d4	mov	ah, 0x42
01ed:a1d6	mov	al, byte ptr [bp + 0xa]
01ed:a1d9	mov	bx, word ptr [bp + 4]
01ed:a1dc	mov	cx, word ptr [bp + 8]
01ed:a1df	mov	dx, word ptr [bp + 6]
01ed:a1e2	int	0x21
01ed:a1e4	jb	loc_c0b8
01ed:a1e6	jmp	loc_c0bd
        	loc_c0b8:
01ed:a1e8	push	ax
01ed:a1e9	call	0xa178
01ed:a1ec	cdq	
        	loc_c0bd:
01ed:a1ed	pop	bp
01ed:a1ee	ret	
sub_c096 ENDP
*/
void sub_c096()
{
    // coverage: 0xb3c6-0xb3ef method sub_c096
    push(0x7777);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    memoryASet16(ds, bx + 27420, memoryAGet16(ds, bx + 27420) & 0xfdff);
    ah = 0x42;
    al = memoryAGet(ss, bp + 10);
    bx = memoryAGet16(ss, bp + 4);
    cx = memoryAGet16(ss, bp + 8);
    dx = memoryAGet16(ss, bp + 6);
    interrupt(0x21);
    if (flags.carry)
        goto loc_c0b8;
    goto loc_c0bd;
loc_c0b8:
    push(ax);
    sub_c048();
    dx = ax & 0x8000 ? 0xffff : 0x0000;
loc_c0bd:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a1ef sub_c0bf()
sub_c0bf PROC
01ed:a1ef	push	bp
01ed:a1f0	mov	bp, sp
01ed:a1f2	push	ds
01ed:a1f3	mov	cx, word ptr [bp + 4]
01ed:a1f6	mov	ah, 0x3c
01ed:a1f8	lds	dx, ptr [bp + 6]
01ed:a1fb	int	0x21
01ed:a1fd	pop	ds
01ed:a1fe	jb	loc_c0d2
01ed:a200	jmp	loc_c0d6
        	loc_c0d2:
01ed:a202	push	ax
01ed:a203	call	0xa178
        	loc_c0d6:
01ed:a206	pop	bp
01ed:a207	ret	6
sub_c0bf ENDP
*/
void sub_c0bf()
{
    // coverage: 0xb3ef-0xb40a method sub_c0bf
    push(0x7777);
    push(bp);
    bp = sp;
    push(ds);
    cx = memoryAGet16(ss, bp + 4);
    ah = 0x3c;
    dx = memoryAGet16(ss, bp + 6);
    ds = memoryAGet16(ss, bp + 6 + 2);
    interrupt(0x21);
    ds = pop();
    if (flags.carry)
        goto loc_c0d2;
    goto loc_c0d6;
loc_c0d2:
    push(ax);
    sub_c048();
loc_c0d6:
    bp = pop();
    assert(pop() == 0x7777);
    sp += 6;
}
/* Assembly listing of 01ed:a20a sub_c0da()
sub_c0da PROC
01ed:a20a	push	bp
01ed:a20b	mov	bp, sp
01ed:a20d	mov	bx, word ptr [bp + 4]
01ed:a210	sub	cx, cx
01ed:a212	sub	dx, dx
01ed:a214	mov	ah, 0x40
01ed:a216	int	0x21
01ed:a218	pop	bp
01ed:a219	ret	2
sub_c0da ENDP
*/
void sub_c0da()
{
    // coverage: 0xb40a-0xb41c method sub_c0da
    push(0x7777);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4);
    cx = 0;
    dx = 0;
    ah = 0x40;
    interrupt(0x21);
    bp = pop();
    assert(pop() == 0x7777);
    sp += 2;
}
/* Assembly listing of 01ed:a21c sub_c0ec()
sub_c0ec PROC
01ed:a21c	push	bp
01ed:a21d	mov	bp, sp
01ed:a21f	sub	sp, 4
01ed:a222	push	si
01ed:a223	push	di
01ed:a224	mov	si, word ptr [bp + 8]
01ed:a227	test	si, 0xc000
01ed:a22b	jne	loc_c109
01ed:a22d	mov	ax, word ptr [0x6b44]
01ed:a230	and	ax, 0xc000
01ed:a233	mov	dx, si
01ed:a235	or	dx, ax
01ed:a237	mov	si, dx
        	loc_c109:
01ed:a239	test	si, 0x100
01ed:a23d	jne	loc_c112
01ed:a23f	jmp	loc_c196
        	loc_c112:
01ed:a242	mov	ax, word ptr [0x6b46]
01ed:a245	and	word ptr [bp + 0xa], ax
01ed:a248	mov	ax, word ptr [bp + 0xa]
01ed:a24b	test	ax, 0x180
01ed:a24e	jne	loc_c127
01ed:a250	mov	ax, 1
01ed:a253	push	ax
01ed:a254	call	0xa178
        	loc_c127:
01ed:a257	xor	ax, ax
01ed:a259	push	ax
01ed:a25a	push	word ptr [bp + 6]
01ed:a25d	push	word ptr [bp + 4]
01ed:a260	call	0x9f98
01ed:a263	add	sp, 6
01ed:a266	mov	word ptr [bp - 2], ax
01ed:a269	cmp	ax, 0xffff
01ed:a26c	jne	loc_c16a
01ed:a26e	test	word ptr [bp + 0xa], 0x80
01ed:a273	je	loc_c149
01ed:a275	xor	ax, ax
01ed:a277	jmp	loc_c14c
        	loc_c149:
01ed:a279	mov	ax, 1
        	loc_c14c:
01ed:a27c	mov	word ptr [bp - 2], ax
01ed:a27f	test	si, 0xf0
01ed:a283	je	loc_c181
01ed:a285	push	word ptr [bp + 6]
01ed:a288	push	word ptr [bp + 4]
01ed:a28b	xor	ax, ax
01ed:a28d	push	ax
01ed:a28e	call	0xa1ef
01ed:a291	mov	di, ax
01ed:a293	or	ax, ax
01ed:a295	jge	loc_c17a
01ed:a297	jmp	loc_c228
        	loc_c16a:
01ed:a29a	test	si, 0x400
01ed:a29e	je	loc_c196
01ed:a2a0	mov	ax, 0x50
01ed:a2a3	push	ax
01ed:a2a4	call	0xa178
01ed:a2a7	jmp	loc_c22a
        	loc_c17a:
01ed:a2aa	push	di
01ed:a2ab	call	0x9fb5
01ed:a2ae	pop	cx
01ed:a2af	jmp	loc_c19b
        	loc_c181:
01ed:a2b1	push	word ptr [bp + 6]
01ed:a2b4	push	word ptr [bp + 4]
01ed:a2b7	push	word ptr [bp - 2]
01ed:a2ba	call	0xa1ef
01ed:a2bd	mov	di, ax
01ed:a2bf	or	ax, ax
01ed:a2c1	jge	loc_c207
01ed:a2c3	jmp	loc_c228
        	loc_c196:
01ed:a2c6	mov	word ptr [bp - 2], 0
        	loc_c19b:
01ed:a2cb	push	si
01ed:a2cc	push	word ptr [bp + 6]
01ed:a2cf	push	word ptr [bp + 4]
01ed:a2d2	call	0xa360
01ed:a2d5	add	sp, 6
01ed:a2d8	mov	di, ax
01ed:a2da	or	ax, ax
01ed:a2dc	jl	loc_c207
01ed:a2de	xor	ax, ax
01ed:a2e0	push	ax
01ed:a2e1	push	di
01ed:a2e2	call	0xa14f
01ed:a2e5	pop	cx
01ed:a2e6	pop	cx
01ed:a2e7	mov	word ptr [bp - 4], ax
01ed:a2ea	test	ax, 0x80
01ed:a2ed	je	loc_c1e0
01ed:a2ef	or	si, 0x2000
01ed:a2f3	test	si, 0x8000
01ed:a2f7	je	loc_c1ea
01ed:a2f9	and	ax, 0xff
01ed:a2fc	or	ax, 0x20
01ed:a2ff	xor	dx, dx
01ed:a301	push	dx
01ed:a302	push	ax
01ed:a303	mov	ax, 1
01ed:a306	push	ax
01ed:a307	push	di
01ed:a308	call	0xa14f
01ed:a30b	add	sp, 8
01ed:a30e	jmp	loc_c1ea
        	loc_c1e0:
01ed:a310	test	si, 0x200
01ed:a314	je	loc_c1ea
01ed:a316	push	di
01ed:a317	call	0xa20a
        	loc_c1ea:
01ed:a31a	cmp	word ptr [bp - 2], 0
01ed:a31e	je	loc_c207
01ed:a320	test	si, 0xf0
01ed:a324	je	loc_c207
01ed:a326	mov	ax, 1
01ed:a329	push	ax
01ed:a32a	push	ax
01ed:a32b	push	word ptr [bp + 6]
01ed:a32e	push	word ptr [bp + 4]
01ed:a331	call	0x9f98
01ed:a334	add	sp, 8
        	loc_c207:
01ed:a337	or	di, di
01ed:a339	jl	loc_c228
01ed:a33b	test	si, 0x300
01ed:a33f	je	loc_c216
01ed:a341	mov	ax, 0x1000
01ed:a344	jmp	loc_c218
        	loc_c216:
01ed:a346	xor	ax, ax
        	loc_c218:
01ed:a348	mov	dx, si
01ed:a34a	and	dx, 0xf8ff
01ed:a34e	or	dx, ax
01ed:a350	mov	bx, di
01ed:a352	shl	bx, 1
01ed:a354	mov	word ptr [bx + 0x6b1c], dx
        	loc_c228:
01ed:a358	mov	ax, di
        	loc_c22a:
01ed:a35a	pop	di
01ed:a35b	pop	si
01ed:a35c	mov	sp, bp
01ed:a35e	pop	bp
01ed:a35f	ret	
sub_c0ec ENDP
*/
void sub_c0ec()
{
    // coverage: 0xb41c-0xb560 method sub_c0ec
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(si);
    push(di);
    si = memoryAGet16(ss, bp + 8);
    if (si & 0xc000)
        goto loc_c109;
    ax = memoryAGet16(ds, 0x6b44);
    ax &= 0xc000;
    dx = si;
    dx |= ax;
    si = dx;
loc_c109:
    if (si & 0x0100)
        goto loc_c112;
    goto loc_c196;
loc_c112:
    ax = memoryAGet16(ds, 0x6b46);
    memoryASet16(ss, bp + 10, memoryAGet16(ss, bp + 10) & ax);
    ax = memoryAGet16(ss, bp + 10);
    if (ax & 0x0180)
        goto loc_c127;
    ax = 0x0001;
    push(ax);
    sub_c048();
loc_c127:
    ax = 0;
    push(ax);
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_be68();
    sp += 0x0006;
    memoryASet16(ss, bp - 2, ax);
    if (ax != 0xffff)
        goto loc_c16a;
    if (!(memoryAGet16(ss, bp + 10) & 0x0080))
        goto loc_c149;
    ax = 0;
    goto loc_c14c;
loc_c149:
    ax = 0x0001;
loc_c14c:
    memoryASet16(ss, bp - 2, ax);
    if (!(si & 0x00f0))
        goto loc_c181;
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    ax = 0;
    push(ax);
    sub_c0bf();
    di = ax;
    if ((short)ax >= 0)
        goto loc_c17a;
    goto loc_c228;
loc_c16a:
    if (!(si & 0x0400))
        goto loc_c196;
    ax = 0x0050;
    push(ax);
    sub_c048();
    goto loc_c22a;
loc_c17a:
    push(di);
    sub_be85();
    cx = pop();
    goto loc_c19b;
loc_c181:
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    push(memoryAGet16(ss, bp - 2));
    sub_c0bf();
    di = ax;
    if ((short)ax >= 0)
        goto loc_c207;
    goto loc_c228;
loc_c196:
    memoryASet16(ss, bp - 2, 0x0000);
loc_c19b:
    push(si);
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_c230();
    sp += 0x0006;
    di = ax;
    if ((short)ax < 0)
        goto loc_c207;
    ax = 0;
    push(ax);
    push(di);
    sub_c01f();
    cx = pop();
    cx = pop();
    memoryASet16(ss, bp - 4, ax);
    if (!(ax & 0x0080))
        goto loc_c1e0;
    si |= 0x2000;
    if (!(si & 0x8000))
        goto loc_c1ea;
    ax &= 0x00ff;
    ax |= 0x0020;
    dx = 0;
    push(dx);
    push(ax);
    ax = 0x0001;
    push(ax);
    push(di);
    sub_c01f();
    sp += 0x0008;
    goto loc_c1ea;
loc_c1e0:
    if (!(si & 0x0200))
        goto loc_c1ea;
    push(di);
    sub_c0da();
loc_c1ea:
    if (memoryAGet16(ss, bp - 2) == 0x0000)
        goto loc_c207;
    if (!(si & 0x00f0))
        goto loc_c207;
    ax = 0x0001;
    push(ax);
    push(ax);
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_be68();
    sp += 0x0008;
loc_c207:
    if ((short)di < 0)
        goto loc_c228;
    if (!(si & 0x0300))
        goto loc_c216;
    ax = 0x1000;
    goto loc_c218;
loc_c216:
    ax = 0;
loc_c218:
    dx = si;
    dx &= 0xf8ff;
    dx |= ax;
    bx = di;
    bx <<= 1;
    memoryASet16(ds, bx + 27420, dx);
loc_c228:
    ax = di;
loc_c22a:
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a360 sub_c230()
sub_c230 PROC
01ed:a360	push	bp
01ed:a361	mov	bp, sp
01ed:a363	dec	sp
01ed:a364	dec	sp
01ed:a365	mov	al, 1
01ed:a367	mov	cx, word ptr [bp + 8]
01ed:a36a	test	cx, 2
01ed:a36e	jne	loc_c24a
01ed:a370	mov	al, 2
01ed:a372	test	cx, 4
01ed:a376	jne	loc_c24a
01ed:a378	mov	al, 0
        	loc_c24a:
01ed:a37a	push	ds
01ed:a37b	lds	dx, ptr [bp + 4]
01ed:a37e	mov	cl, 0xf0
01ed:a380	and	cl, byte ptr [bp + 8]
01ed:a383	or	al, cl
01ed:a385	mov	ah, 0x3d
01ed:a387	int	0x21
01ed:a389	pop	ds
01ed:a38a	jb	loc_c276
01ed:a38c	mov	word ptr [bp - 2], ax
01ed:a38f	mov	bx, word ptr [bp - 2]
01ed:a392	shl	bx, 1
01ed:a394	mov	ax, word ptr [bp + 8]
01ed:a397	and	ax, 0xf8ff
01ed:a39a	or	ax, 0x8000
01ed:a39d	mov	word ptr [bx + 0x6b1c], ax
01ed:a3a1	mov	ax, word ptr [bp - 2]
01ed:a3a4	jmp	loc_c27a
        	loc_c276:
01ed:a3a6	push	ax
01ed:a3a7	call	0xa178
        	loc_c27a:
01ed:a3aa	mov	sp, bp
01ed:a3ac	pop	bp
01ed:a3ad	ret	
sub_c230 ENDP
*/
void sub_c230()
{
    // coverage: 0xb560-0xb5ae method sub_c230
    push(0x7777);
    push(bp);
    bp = sp;
    sp--;
    sp--;
    al = 0x01;
    cx = memoryAGet16(ss, bp + 8);
    if (cx & 0x0002)
        goto loc_c24a;
    al = 0x02;
    if (cx & 0x0004)
        goto loc_c24a;
    al = 0x00;
loc_c24a:
    push(ds);
    dx = memoryAGet16(ss, bp + 4);
    ds = memoryAGet16(ss, bp + 4 + 2);
    cl = 0xf0;
    cl &= memoryAGet(ss, bp + 8);
    al |= cl;
    ah = 0x3d;
    interrupt(0x21);
    ds = pop();
    if (flags.carry)
        goto loc_c276;
    memoryASet16(ss, bp - 2, ax);
    bx = memoryAGet16(ss, bp - 2);
    bx <<= 1;
    ax = memoryAGet16(ss, bp + 8);
    ax &= 0xf8ff;
    ax |= 0x8000;
    memoryASet16(ds, bx + 27420, ax);
    ax = memoryAGet16(ss, bp - 2);
    goto loc_c27a;
loc_c276:
    push(ax);
    sub_c048();
loc_c27a:
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a3ae sub_c27e()
sub_c27e PROC
01ed:a3ae	push	bp
01ed:a3af	mov	bp, sp
01ed:a3b1	sub	sp, 4
01ed:a3b4	push	si
01ed:a3b5	push	di
01ed:a3b6	mov	ax, word ptr [bp + 0xa]
01ed:a3b9	inc	ax
01ed:a3ba	cmp	ax, 2
01ed:a3bd	jb	loc_c29c
01ed:a3bf	mov	bx, word ptr [bp + 4]
01ed:a3c2	shl	bx, 1
01ed:a3c4	test	word ptr [bx + 0x6b1c], 0x200
01ed:a3ca	je	loc_c2a1
        	loc_c29c:
01ed:a3cc	xor	ax, ax
01ed:a3ce	jmp	loc_c330
        	loc_c2a1:
01ed:a3d1	push	word ptr [bp + 0xa]
01ed:a3d4	push	word ptr [bp + 8]
01ed:a3d7	push	word ptr [bp + 6]
01ed:a3da	push	word ptr [bp + 4]
01ed:a3dd	call	0xa466
01ed:a3e0	add	sp, 8
01ed:a3e3	mov	word ptr [bp - 2], ax
01ed:a3e6	inc	ax
01ed:a3e7	cmp	ax, 2
01ed:a3ea	jb	loc_c2c9
01ed:a3ec	mov	bx, word ptr [bp + 4]
01ed:a3ef	shl	bx, 1
01ed:a3f1	test	word ptr [bx + 0x6b1c], 0x8000
01ed:a3f7	je	loc_c2ce
        	loc_c2c9:
01ed:a3f9	mov	ax, word ptr [bp - 2]
01ed:a3fc	jmp	loc_c330
        	loc_c2ce:
01ed:a3fe	mov	cx, word ptr [bp - 2]
01ed:a401	les	si, ptr [bp + 6]
01ed:a404	mov	di, si
01ed:a406	mov	bx, si
01ed:a408	cld	
        	loc_c2d9:
01ed:a409	lodsb	al, byte ptr es:[si]
01ed:a40b	cmp	al, 0x1a
01ed:a40d	je	loc_c30d
01ed:a40f	cmp	al, 0xd
01ed:a411	je	loc_c2e8
01ed:a413	stosb	byte ptr es:[di], al
01ed:a414	loop	loc_c2d9
01ed:a416	jmp	loc_c305
        	loc_c2e8:
01ed:a418	loop	loc_c2d9
01ed:a41a	push	es
01ed:a41b	push	bx
01ed:a41c	mov	ax, 1
01ed:a41f	push	ax
01ed:a420	lea	ax, [bp - 3]
01ed:a423	push	ss
01ed:a424	push	ax
01ed:a425	push	word ptr [bp + 4]
01ed:a428	call	0xa466
01ed:a42b	add	sp, 8
01ed:a42e	pop	bx
01ed:a42f	pop	es
01ed:a430	cld	
01ed:a431	mov	al, byte ptr [bp - 3]
01ed:a434	stosb	byte ptr es:[di], al
        	loc_c305:
01ed:a435	cmp	di, bx
01ed:a437	jne	loc_c30b
01ed:a439	jmp	loc_c2a1
        	loc_c30b:
01ed:a43b	jmp	loc_c32d
        	loc_c30d:
01ed:a43d	push	bx
01ed:a43e	mov	ax, 1
01ed:a441	push	ax
01ed:a442	neg	cx
01ed:a444	sbb	ax, ax
01ed:a446	push	ax
01ed:a447	push	cx
01ed:a448	push	word ptr [bp + 4]
01ed:a44b	call	0xa1c6
01ed:a44e	add	sp, 8
01ed:a451	mov	bx, word ptr [bp + 4]
01ed:a454	shl	bx, 1
01ed:a456	or	word ptr [bx + 0x6b1c], 0x200
01ed:a45c	pop	bx
        	loc_c32d:
01ed:a45d	sub	di, bx
01ed:a45f	xchg	di, ax
        	loc_c330:
01ed:a460	pop	di
01ed:a461	pop	si
01ed:a462	mov	sp, bp
01ed:a464	pop	bp
01ed:a465	ret	
sub_c27e ENDP
*/
void sub_c27e()
{
    // coverage: 0xb5ae-0xb666 method sub_c27e
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(si);
    push(di);
    ax = memoryAGet16(ss, bp + 10);
    ax++;
    if (ax < 0x0002)
        goto loc_c29c;
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    if (!(memoryAGet16(ds, bx + 27420) & 0x0200))
        goto loc_c2a1;
loc_c29c:
    ax = 0;
    goto loc_c330;
loc_c2a1:
    push(memoryAGet16(ss, bp + 10));
    push(memoryAGet16(ss, bp + 8));
    push(memoryAGet16(ss, bp + 6));
    push(memoryAGet16(ss, bp + 4));
    sub_c336();
    sp += 0x0008;
    memoryASet16(ss, bp - 2, ax);
    ax++;
    if (ax < 0x0002)
        goto loc_c2c9;
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    if (!(memoryAGet16(ds, bx + 27420) & 0x8000))
        goto loc_c2ce;
loc_c2c9:
    ax = memoryAGet16(ss, bp - 2);
    goto loc_c330;
loc_c2ce:
    cx = memoryAGet16(ss, bp - 2);
    si = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    di = si;
    bx = si;
    flags.direction = false;
loc_c2d9:
    lodsb_es<MemAuto, DirAuto>();
    if (al == 0x1a)
        goto loc_c30d;
    if (al == 0x0d)
        goto loc_c2e8;
    stosb<MemAuto, DirAuto>();
    if (--cx)
        goto loc_c2d9;
    goto loc_c305;
loc_c2e8:
    if (--cx)
        goto loc_c2d9;
    push(es);
    push(bx);
    ax = 0x0001;
    push(ax);
    ax = bp - 0x3;
    push(ss);
    push(ax);
    push(memoryAGet16(ss, bp + 4));
    sub_c336();
    sp += 0x0008;
    bx = pop();
    es = pop();
    flags.direction = false;
    al = memoryAGet(ss, bp - 3);
    stosb<MemAuto, DirAuto>();
loc_c305:
    if (di != bx)
        goto loc_c30b;
    goto loc_c2a1;
loc_c30b:
    goto loc_c32d;
loc_c30d:
    push(bx);
    ax = 0x0001;
    push(ax);
    stop(/*74*/);
    cx = -cx;
    ax -= ax + flags.carry;
    push(ax);
    push(cx);
    push(memoryAGet16(ss, bp + 4));
    sub_c096();
    sp += 0x0008;
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    memoryASet16(ds, bx + 27420, memoryAGet16(ds, bx + 27420) | 0x0200);
    bx = pop();
loc_c32d:
    di -= bx;
    tx = di;
    di = ax;
    ax = tx;
loc_c330:
    di = pop();
    si = pop();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a466 sub_c336()
sub_c336 PROC
01ed:a466	push	bp
01ed:a467	mov	bp, sp
01ed:a469	push	ds
01ed:a46a	mov	ah, 0x3f
01ed:a46c	mov	bx, word ptr [bp + 4]
01ed:a46f	mov	cx, word ptr [bp + 0xa]
01ed:a472	lds	dx, ptr [bp + 6]
01ed:a475	int	0x21
01ed:a477	pop	ds
01ed:a478	jb	loc_c34c
01ed:a47a	jmp	loc_c350
        	loc_c34c:
01ed:a47c	push	ax
01ed:a47d	call	0xa178
        	loc_c350:
01ed:a480	pop	bp
01ed:a481	ret	
sub_c336 ENDP
*/
void sub_c336()
{
    // coverage: 0xb666-0xb682 method sub_c336
    push(0x7777);
    push(bp);
    bp = sp;
    push(ds);
    ah = 0x3f;
    bx = memoryAGet16(ss, bp + 4);
    cx = memoryAGet16(ss, bp + 10);
    dx = memoryAGet16(ss, bp + 6);
    ds = memoryAGet16(ss, bp + 6 + 2);
    interrupt(0x21);
    ds = pop();
    if (flags.carry)
        goto loc_c34c;
    goto loc_c350;
loc_c34c:
    push(ax);
    sub_c048();
loc_c350:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a482 sub_c352()
sub_c352 PROC
01ed:a482	push	bp
01ed:a483	mov	bp, sp
01ed:a485	mov	ah, 0x4a
01ed:a487	mov	bx, word ptr [bp + 6]
01ed:a48a	mov	es, word ptr [bp + 4]
01ed:a48d	int	0x21
01ed:a48f	jb	loc_c366
01ed:a491	mov	ax, 0xffff
01ed:a494	jmp	loc_c36c
        	loc_c366:
01ed:a496	push	bx
01ed:a497	push	ax
01ed:a498	call	0xa178
01ed:a49b	pop	ax
        	loc_c36c:
01ed:a49c	pop	bp
01ed:a49d	ret	
sub_c352 ENDP
*/
void sub_c352()
{
    // coverage: 0xb682-0xb69e method sub_c352
    push(0x7777);
    push(bp);
    bp = sp;
    ah = 0x4a;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 4);
    interrupt(0x21);
    if (flags.carry)
        goto loc_c366;
    ax = 0xffff;
    goto loc_c36c;
loc_c366:
    push(bx);
    push(ax);
    sub_c048();
    ax = pop();
loc_c36c:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a49e sub_c36e()
sub_c36e PROC
01ed:a49e	push	bp
01ed:a49f	mov	bp, sp
01ed:a4a1	mov	bx, word ptr [bp + 4]
01ed:a4a4	shl	bx, 1
01ed:a4a6	test	word ptr [bx + 0x6b1c], 0x800
01ed:a4ac	je	loc_c391
01ed:a4ae	mov	ax, 2
01ed:a4b1	push	ax
01ed:a4b2	xor	ax, ax
01ed:a4b4	xor	dx, dx
01ed:a4b6	push	ax
01ed:a4b7	push	dx
01ed:a4b8	push	word ptr [bp + 4]
01ed:a4bb	call	0xa1c6
01ed:a4be	add	sp, 8
        	loc_c391:
01ed:a4c1	push	ds
01ed:a4c2	mov	ah, 0x40
01ed:a4c4	mov	bx, word ptr [bp + 4]
01ed:a4c7	mov	cx, word ptr [bp + 0xa]
01ed:a4ca	lds	dx, ptr [bp + 6]
01ed:a4cd	int	0x21
01ed:a4cf	pop	ds
01ed:a4d0	jb	loc_c3b1
01ed:a4d2	push	ax
01ed:a4d3	mov	bx, word ptr [bp + 4]
01ed:a4d6	shl	bx, 1
01ed:a4d8	or	word ptr [bx + 0x6b1c], 0x1000
01ed:a4de	pop	ax
01ed:a4df	jmp	loc_c3b5
        	loc_c3b1:
01ed:a4e1	push	ax
01ed:a4e2	call	0xa178
        	loc_c3b5:
01ed:a4e5	pop	bp
01ed:a4e6	ret	
sub_c36e ENDP
*/
void sub_c36e()
{
    // coverage: 0xb69e-0xb6e7 method sub_c36e
    push(0x7777);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    if (!(memoryAGet16(ds, bx + 27420) & 0x0800))
        goto loc_c391;
    ax = 0x0002;
    push(ax);
    ax = 0;
    dx = 0;
    push(ax);
    push(dx);
    push(memoryAGet16(ss, bp + 4));
    sub_c096();
    sp += 0x0008;
loc_c391:
    push(ds);
    ah = 0x40;
    bx = memoryAGet16(ss, bp + 4);
    cx = memoryAGet16(ss, bp + 10);
    dx = memoryAGet16(ss, bp + 6);
    ds = memoryAGet16(ss, bp + 6 + 2);
    interrupt(0x21);
    ds = pop();
    if (flags.carry)
        goto loc_c3b1;
    push(ax);
    bx = memoryAGet16(ss, bp + 4);
    bx <<= 1;
    memoryASet16(ds, bx + 27420, memoryAGet16(ds, bx + 27420) | 0x1000);
    ax = pop();
    goto loc_c3b5;
loc_c3b1:
    push(ax);
    sub_c048();
loc_c3b5:
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a4fc sub_c3cc()
sub_c3cc PROC
01ed:a4fc	cmp	dx, word ptr cs:[0xa4f0]
01ed:a501	je	loc_c40a
01ed:a503	mov	ds, dx
01ed:a505	mov	ds, word ptr [2]
01ed:a509	cmp	word ptr [2], 0
01ed:a50e	je	loc_c3e7
01ed:a510	mov	word ptr cs:[0xa4f2], ds
01ed:a515	jmp	loc_c41f
        	loc_c3e7:
01ed:a517	mov	ax, ds
01ed:a519	cmp	ax, word ptr cs:[0xa4f0]
01ed:a51e	je	loc_c405
01ed:a520	mov	ax, word ptr [8]
01ed:a523	mov	word ptr cs:[0xa4f2], ax
01ed:a527	push	ds
01ed:a528	xor	ax, ax
01ed:a52a	push	ax
01ed:a52b	call	0xa5cf
01ed:a52e	mov	ds, word ptr cs:[0xa4f6]
01ed:a533	jmp	loc_c428
        	loc_c405:
01ed:a535	mov	dx, word ptr cs:[0xa4f0]
        	loc_c40a:
01ed:a53a	mov	word ptr cs:[0xa4f0], 0
01ed:a541	mov	word ptr cs:[0xa4f2], 0
01ed:a548	mov	word ptr cs:[0xa4f4], 0
        	loc_c41f:
01ed:a54f	mov	ds, word ptr cs:[0xa4f6]
01ed:a554	push	dx
01ed:a555	xor	ax, ax
01ed:a557	push	ax
        	loc_c428:
01ed:a558	call	0x995b
01ed:a55b	pop	ax
01ed:a55c	pop	ax
01ed:a55d	ret	
sub_c3cc ENDP
*/
void sub_c3cc()
{
    // coverage: 0xb6fc-0xb75e method sub_c3cc
    if (dx == memoryAGet16(cs, 0xa4f0))
        goto loc_c40a;
    ds = dx;
    ds = memoryAGet16(ds, 0x0002);
    if (memoryAGet16(ds, 0x0002) == 0x0000)
        goto loc_c3e7;
    memoryASet16(cs, 0xa4f2, ds);
    goto loc_c41f;
loc_c3e7:
    ax = ds;
    if (ax == memoryAGet16(cs, 0xa4f0))
        goto loc_c405;
    ax = memoryAGet16(ds, 0x0008);
    memoryASet16(cs, 0xa4f2, ax);
    push(ds);
    ax = 0;
    push(ax);
    sub_c49f();
    ds = memoryAGet16(cs, 0xa4f6);
    goto loc_c428;
loc_c405:
    dx = memoryAGet16(cs, 0xa4f0);
loc_c40a:
    memoryASet16(cs, 0xa4f0, 0x0000);
    memoryASet16(cs, 0xa4f2, 0x0000);
    memoryASet16(cs, 0xa4f4, 0x0000);
loc_c41f:
    ds = memoryAGet16(cs, 0xa4f6);
    push(dx);
    ax = 0;
    push(ax);
loc_c428:
    sub_b82b();
    ax = pop();
    ax = pop();
}
/* Assembly listing of 01ed:a55e sub_c42e()
sub_c42e PROC
01ed:a55e	mov	ds, dx
01ed:a560	push	ds
01ed:a561	mov	es, word ptr [2]
01ed:a565	mov	word ptr [2], 0
01ed:a56b	mov	word ptr [8], es
01ed:a56f	cmp	dx, word ptr cs:[0xa4f0]
01ed:a574	je	loc_c474
01ed:a576	cmp	word ptr es:[2], 0
01ed:a57c	jne	loc_c474
01ed:a57e	mov	ax, word ptr [0]
01ed:a581	pop	bx
01ed:a582	push	es
01ed:a583	add	word ptr es:[0], ax
01ed:a588	mov	cx, es
01ed:a58a	add	dx, ax
01ed:a58c	mov	es, dx
01ed:a58e	cmp	word ptr es:[2], 0
01ed:a594	jne	loc_c46d
01ed:a596	mov	word ptr es:[8], cx
01ed:a59b	jmp	loc_c477
        	loc_c46d:
01ed:a59d	mov	word ptr es:[2], cx
01ed:a5a2	jmp	loc_c477
        	loc_c474:
01ed:a5a4	call	0xa5f8
        	loc_c477:
01ed:a5a7	pop	es
01ed:a5a8	mov	ax, es
01ed:a5aa	add	ax, word ptr es:[0]
01ed:a5af	mov	ds, ax
01ed:a5b1	cmp	word ptr [2], 0
01ed:a5b6	je	loc_c489
01ed:a5b8	ret	
        	loc_c489:
01ed:a5b9	mov	ax, word ptr [0]
01ed:a5bc	add	word ptr es:[0], ax
01ed:a5c1	mov	ax, es
01ed:a5c3	mov	bx, ds
01ed:a5c5	add	bx, word ptr [0]
01ed:a5c9	mov	es, bx
01ed:a5cb	mov	word ptr es:[2], ax
01ed:a5cf	mov	bx, ds
01ed:a5d1	cmp	bx, word ptr [6]
01ed:a5d5	je	loc_c4c0
01ed:a5d7	mov	es, word ptr [6]
01ed:a5db	mov	ds, word ptr [4]
01ed:a5df	mov	word ptr [6], es
01ed:a5e3	mov	word ptr es:[4], ds
01ed:a5e8	mov	word ptr cs:[0xa4f4], ds
01ed:a5ed	mov	ds, bx
01ed:a5ef	ret	
        	loc_c4c0:
01ed:a5f0	mov	word ptr cs:[0xa4f4], 0
01ed:a5f7	ret	
sub_c42e ENDP
*/
void sub_c42e()
{
    // coverage: 0xb75e-0xb7f8 method sub_c42e
    ds = dx;
    push(ds);
    es = memoryAGet16(ds, 0x0002);
    memoryASet16(ds, 0x0002, 0x0000);
    memoryASet16(ds, 0x0008, es);
    if (dx == memoryAGet16(cs, 0xa4f0))
        goto loc_c474;
    if (memoryAGet16(es, 0x0002) != 0x0000)
        goto loc_c474;
    ax = memoryAGet16(ds, 0x0000);
    bx = pop();
    push(es);
    memoryASet16(es, 0x0000, memoryAGet16(es, 0x0000) + ax);
    cx = es;
    dx += ax;
    es = dx;
    if (memoryAGet16(es, 0x0002) != 0x0000)
        goto loc_c46d;
    memoryASet16(es, 0x0008, cx);
    goto loc_c477;
loc_c46d:
    memoryASet16(es, 0x0002, cx);
    goto loc_c477;
loc_c474:
    sub_c4c8();
loc_c477:
    es = pop();
    ax = es;
    ax += memoryAGet16(es, 0x0000);
    ds = ax;
    if (memoryAGet16(ds, 0x0002) == 0x0000)
        goto loc_c489;
    return;
loc_c489:
    ax = memoryAGet16(ds, 0x0000);
    memoryASet16(es, 0x0000, memoryAGet16(es, 0x0000) + ax);
    ax = es;
    bx = ds;
    bx += memoryAGet16(ds, 0x0000);
    es = bx;
    memoryASet16(es, 0x0002, ax);
    bx = ds;
    if (bx == memoryAGet16(ds, 0x0006))
        goto loc_c4c0;
    es = memoryAGet16(ds, 0x0006);
    ds = memoryAGet16(ds, 0x0004);
    memoryASet16(ds, 0x0006, es);
    memoryASet16(es, 0x0004, ds);
    memoryASet16(cs, 0xa4f4, ds);
    ds = bx;
    return;
loc_c4c0:
    memoryASet16(cs, 0xa4f4, 0x0000);
}
/* Assembly listing of 01ed:a5cf sub_c49f()
sub_c49f PROC
01ed:a5cf	mov	bx, ds
01ed:a5d1	cmp	bx, word ptr [6]
01ed:a5d5	je	loc_c4c0
01ed:a5d7	mov	es, word ptr [6]
01ed:a5db	mov	ds, word ptr [4]
01ed:a5df	mov	word ptr [6], es
01ed:a5e3	mov	word ptr es:[4], ds
01ed:a5e8	mov	word ptr cs:[0xa4f4], ds
01ed:a5ed	mov	ds, bx
01ed:a5ef	ret	
        	loc_c4c0:
01ed:a5f0	mov	word ptr cs:[0xa4f4], 0
01ed:a5f7	ret	
sub_c49f ENDP
*/
void sub_c49f()
{
    // coverage: 0xb7cf-0xb7f8 method sub_c49f
    bx = ds;
    if (bx == memoryAGet16(ds, 0x0006))
        goto loc_c4c0;
    es = memoryAGet16(ds, 0x0006);
    ds = memoryAGet16(ds, 0x0004);
    memoryASet16(ds, 0x0006, es);
    memoryASet16(es, 0x0004, ds);
    memoryASet16(cs, 0xa4f4, ds);
    ds = bx;
    return;
loc_c4c0:
    memoryASet16(cs, 0xa4f4, 0x0000);
}
/* Assembly listing of 01ed:a5f8 sub_c4c8()
sub_c4c8 PROC
01ed:a5f8	mov	ax, word ptr cs:[0xa4f4]
01ed:a5fc	or	ax, ax
01ed:a5fe	je	loc_c4f0
01ed:a600	mov	bx, ss
01ed:a602	cli	
01ed:a603	mov	ss, ax
01ed:a605	mov	es, word ptr ss:[6]
01ed:a60a	mov	word ptr ss:[6], ds
01ed:a60f	mov	word ptr [4], ss
01ed:a613	mov	ss, bx
01ed:a615	sti	
01ed:a616	mov	word ptr es:[4], ds
01ed:a61b	mov	word ptr [6], es
01ed:a61f	ret	
        	loc_c4f0:
01ed:a620	mov	word ptr cs:[0xa4f4], ds
01ed:a625	mov	word ptr [4], ds
01ed:a629	mov	word ptr [6], ds
01ed:a62d	ret	
sub_c4c8 ENDP
*/
void sub_c4c8()
{
    // coverage: 0xb7f8-0xb82e method sub_c4c8
    ax = memoryAGet16(cs, 0xa4f4);
    if (!ax)
        goto loc_c4f0;
    bx = ss;
    flags.interrupts = false;
    ss = ax;
    es = memoryAGet16(ss, 0x0006);
    memoryASet16(ss, 0x0006, ds);
    memoryASet16(ds, 0x0004, ss);
    ss = bx;
    flags.interrupts = true;
    memoryASet16(es, 0x0004, ds);
    memoryASet16(ds, 0x0006, es);
    return;
loc_c4f0:
    memoryASet16(cs, 0xa4f4, ds);
    memoryASet16(ds, 0x0004, ds);
    memoryASet16(ds, 0x0006, ds);
}
/* Assembly listing of 01ed:a62e sub_c4fe()
sub_c4fe PROC
01ed:a62e	push	bp
01ed:a62f	mov	bp, sp
01ed:a631	push	si
01ed:a632	push	di
01ed:a633	mov	word ptr cs:[0xa4f6], ds
01ed:a638	mov	dx, word ptr [bp + 6]
01ed:a63b	or	dx, dx
01ed:a63d	je	loc_c51e
01ed:a63f	cmp	dx, word ptr cs:[0xa4f2]
01ed:a644	jne	loc_c51b
01ed:a646	call	0xa4fc
01ed:a649	jmp	loc_c51e
        	loc_c51b:
01ed:a64b	call	0xa55e
        	loc_c51e:
01ed:a64e	mov	ds, word ptr cs:[0xa4f6]
01ed:a653	pop	di
01ed:a654	pop	si
01ed:a655	pop	bp
01ed:a656	ret	
sub_c4fe ENDP
*/
void sub_c4fe()
{
    // coverage: 0xb82e-0xb857 method sub_c4fe
    push(0x7777);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    memoryASet16(cs, 0xa4f6, ds);
    dx = memoryAGet16(ss, bp + 6);
    if (!dx)
        goto loc_c51e;
    if (dx != memoryAGet16(cs, 0xa4f2))
        goto loc_c51b;
    sub_c3cc();
    goto loc_c51e;
loc_c51b:
    sub_c42e();
loc_c51e:
    ds = memoryAGet16(cs, 0xa4f6);
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a657 sub_c527()
sub_c527 PROC
01ed:a657	push	ax
01ed:a658	mov	ds, word ptr cs:[0xa4f6]
01ed:a65d	xor	ax, ax
01ed:a65f	push	ax
01ed:a660	push	ax
01ed:a661	call	0x999a
01ed:a664	pop	bx
01ed:a665	pop	bx
01ed:a666	and	ax, 0xf
01ed:a669	je	loc_c54e
01ed:a66b	mov	dx, 0x10
01ed:a66e	sub	dx, ax
01ed:a670	xor	ax, ax
01ed:a672	mov	ds, word ptr cs:[0xa4f6]
01ed:a677	push	ax
01ed:a678	push	dx
01ed:a679	call	0x999a
01ed:a67c	pop	bx
01ed:a67d	pop	bx
        	loc_c54e:
01ed:a67e	pop	ax
01ed:a67f	push	ax
01ed:a680	xor	bx, bx
01ed:a682	mov	bl, ah
01ed:a684	mov	cl, 4
01ed:a686	shr	bx, cl
01ed:a688	shl	ax, cl
01ed:a68a	mov	ds, word ptr cs:[0xa4f6]
01ed:a68f	push	bx
01ed:a690	push	ax
01ed:a691	call	0x999a
01ed:a694	pop	bx
01ed:a695	pop	bx
01ed:a696	pop	bx
01ed:a697	cmp	ax, 0xffff
01ed:a69a	je	loc_c584
01ed:a69c	mov	word ptr cs:[0xa4f0], dx
01ed:a6a1	mov	word ptr cs:[0xa4f2], dx
01ed:a6a6	mov	ds, dx
01ed:a6a8	mov	word ptr [0], bx
01ed:a6ac	mov	word ptr [2], dx
01ed:a6b0	mov	ax, 4
01ed:a6b3	ret	
        	loc_c584:
01ed:a6b4	xor	ax, ax
01ed:a6b6	cdq	
01ed:a6b7	ret	
sub_c527 ENDP
*/
void sub_c527()
{
    // coverage: 0xb857-0xb8b8 method sub_c527
    push(ax);
    ds = memoryAGet16(cs, 0xa4f6);
    ax = 0;
    push(ax);
    push(ax);
    sub_b86a();
    bx = pop();
    bx = pop();
    ax &= 0x000f;
    if (ax == 0)
        goto loc_c54e;
    dx = 0x0010;
    dx -= ax;
    ax = 0;
    ds = memoryAGet16(cs, 0xa4f6);
    push(ax);
    push(dx);
    sub_b86a();
    bx = pop();
    bx = pop();
loc_c54e:
    ax = pop();
    push(ax);
    bx = 0;
    bl = ah;
    cl = 0x04;
    bx >>= cl;
    ax <<= cl;
    ds = memoryAGet16(cs, 0xa4f6);
    push(bx);
    push(ax);
    sub_b86a();
    bx = pop();
    bx = pop();
    bx = pop();
    if (ax == 0xffff)
        goto loc_c584;
    memoryASet16(cs, 0xa4f0, dx);
    memoryASet16(cs, 0xa4f2, dx);
    ds = dx;
    memoryASet16(ds, 0x0000, bx);
    memoryASet16(ds, 0x0002, dx);
    ax = 0x0004;
    return;
loc_c584:
    ax = 0;
    dx = ax & 0x8000 ? 0xffff : 0x0000;
}
/* Assembly listing of 01ed:a6b8 sub_c588()
sub_c588 PROC
01ed:a6b8	push	ax
01ed:a6b9	xor	bx, bx
01ed:a6bb	mov	bl, ah
01ed:a6bd	mov	cl, 4
01ed:a6bf	shr	bx, cl
01ed:a6c1	shl	ax, cl
01ed:a6c3	mov	ds, word ptr cs:[0xa4f6]
01ed:a6c8	push	bx
01ed:a6c9	push	ax
01ed:a6ca	call	0x999a
01ed:a6cd	pop	bx
01ed:a6ce	pop	bx
01ed:a6cf	pop	bx
01ed:a6d0	cmp	ax, 0xffff
01ed:a6d3	je	loc_c5bd
01ed:a6d5	mov	cx, word ptr cs:[0xa4f2]
01ed:a6da	mov	word ptr cs:[0xa4f2], dx
01ed:a6df	mov	ds, dx
01ed:a6e1	mov	word ptr [0], bx
01ed:a6e5	mov	word ptr [2], cx
01ed:a6e9	mov	ax, 4
01ed:a6ec	ret	
        	loc_c5bd:
01ed:a6ed	xor	ax, ax
01ed:a6ef	cdq	
01ed:a6f0	ret	
sub_c588 ENDP
*/
void sub_c588()
{
    // coverage: 0xb8b8-0xb8f1 method sub_c588
    push(ax);
    bx = 0;
    bl = ah;
    cl = 0x04;
    bx >>= cl;
    ax <<= cl;
    ds = memoryAGet16(cs, 0xa4f6);
    push(bx);
    push(ax);
    sub_b86a();
    bx = pop();
    bx = pop();
    bx = pop();
    if (ax == 0xffff)
        goto loc_c5bd;
    cx = memoryAGet16(cs, 0xa4f2);
    memoryASet16(cs, 0xa4f2, dx);
    ds = dx;
    memoryASet16(ds, 0x0000, bx);
    memoryASet16(ds, 0x0002, cx);
    ax = 0x0004;
    return;
loc_c5bd:
    ax = 0;
    dx = ax & 0x8000 ? 0xffff : 0x0000;
}
/* Assembly listing of 01ed:a6f1 sub_c5c1()
sub_c5c1 PROC
01ed:a6f1	mov	bx, dx
01ed:a6f3	sub	word ptr [0], ax
01ed:a6f7	add	dx, word ptr [0]
01ed:a6fb	mov	ds, dx
01ed:a6fd	mov	word ptr [0], ax
01ed:a700	mov	word ptr [2], bx
01ed:a704	mov	bx, dx
01ed:a706	add	bx, word ptr [0]
01ed:a70a	mov	ds, bx
01ed:a70c	mov	word ptr [2], dx
01ed:a710	mov	ax, 4
01ed:a713	ret	
sub_c5c1 ENDP
*/
void sub_c5c1()
{
    // coverage: 0xb8f1-0xb914 method sub_c5c1
    bx = dx;
    memoryASet16(ds, 0x0000, memoryAGet16(ds, 0x0000) - ax);
    dx += memoryAGet16(ds, 0x0000);
    ds = dx;
    memoryASet16(ds, 0x0000, ax);
    memoryASet16(ds, 0x0002, bx);
    bx = dx;
    bx += memoryAGet16(ds, 0x0000);
    ds = bx;
    memoryASet16(ds, 0x0002, dx);
    ax = 0x0004;
}
/* Assembly listing of 01ed:a714 sub_c5e4()
sub_c5e4 PROC
01ed:a714	push	bp
01ed:a715	mov	bp, sp
01ed:a717	xor	dx, dx
01ed:a719	mov	ax, word ptr [bp + 4]
01ed:a71c	jmp	loc_c5f7
01ed:a71e		
        	loc_c5f7:
01ed:a727	push	si
01ed:a728	push	di
01ed:a729	mov	word ptr cs:[0xa4f6], ds
01ed:a72e	mov	cx, ax
01ed:a730	or	cx, dx
01ed:a732	je	loc_c662
01ed:a734	add	ax, 0x13
01ed:a737	adc	dx, 0
01ed:a73a	jb	loc_c64d
01ed:a73c	test	dx, 0xfff0
01ed:a740	jne	loc_c64d
01ed:a742	mov	cl, 4
01ed:a744	shr	ax, cl
01ed:a746	shl	dx, cl
01ed:a748	or	ah, dl
01ed:a74a	mov	dx, word ptr cs:[0xa4f0]
01ed:a74f	or	dx, dx
01ed:a751	je	loc_c643
01ed:a753	mov	dx, word ptr cs:[0xa4f4]
01ed:a758	or	dx, dx
01ed:a75a	je	loc_c63e
01ed:a75c	mov	bx, dx
        	loc_c62e:
01ed:a75e	mov	ds, dx
01ed:a760	cmp	word ptr [0], ax
01ed:a764	jae	loc_c652
01ed:a766	mov	dx, word ptr [6]
01ed:a76a	cmp	dx, bx
01ed:a76c	jne	loc_c62e
        	loc_c63e:
01ed:a76e	call	0xa6b8
01ed:a771	jmp	loc_c662
        	loc_c643:
01ed:a773	call	0xa657
01ed:a776	jmp	loc_c662
        	loc_c648:
01ed:a778	call	0xa6f1
01ed:a77b	jmp	loc_c662
        	loc_c64d:
01ed:a77d	xor	ax, ax
01ed:a77f	cdq	
01ed:a780	jmp	loc_c662
        	loc_c652:
01ed:a782	ja	loc_c648
01ed:a784	call	0xa5cf
01ed:a787	mov	bx, word ptr [8]
01ed:a78b	mov	word ptr [2], bx
01ed:a78f	mov	ax, 4
        	loc_c662:
01ed:a792	mov	ds, word ptr cs:[0xa4f6]
01ed:a797	pop	di
01ed:a798	pop	si
01ed:a799	pop	bp
01ed:a79a	ret	
sub_c5e4 ENDP
*/
void sub_c5e4()
{
    // coverage: 0xb914-0xb91e method sub_c5e4
    // coverage: 0xb927-0xb99b method sub_c5e4
    push(0x7777);
    push(bp);
    bp = sp;
    dx = 0;
    ax = memoryAGet16(ss, bp + 4);
    goto loc_c5f7;
    //   gap of 9 bytes
loc_c5f7:
    push(si);
    push(di);
    memoryASet16(cs, 0xa4f6, ds);
    cx = ax;
    cx |= dx;
    if (!cx)
        goto loc_c662;
    flags.carry = (ax + 0x0013) >= 0x10000;
    ax += 0x0013;
    tl = flags.carry;
    flags.carry = (dx + 0x0000 + tl) >= 0x10000;
    dx += tl;
    if (flags.carry)
        goto loc_c64d;
    if (dx & 0xfff0)
        goto loc_c64d;
    cl = 0x04;
    ax >>= cl;
    dx <<= cl;
    ah |= dl;
    dx = memoryAGet16(cs, 0xa4f0);
    if (!dx)
        goto loc_c643;
    dx = memoryAGet16(cs, 0xa4f4);
    if (!dx)
        goto loc_c63e;
    bx = dx;
loc_c62e:
    ds = dx;
    if (memoryAGet16(ds, 0x0000) >= ax)
        goto loc_c652;
    dx = memoryAGet16(ds, 0x0006);
    if (dx != bx)
        goto loc_c62e;
loc_c63e:
    sub_c588();
    goto loc_c662;
loc_c643:
    sub_c527();
    goto loc_c662;
loc_c648:
    sub_c5c1();
    goto loc_c662;
loc_c64d:
    ax = 0;
    dx = ax & 0x8000 ? 0xffff : 0x0000;
    goto loc_c662;
loc_c652:
    if (memoryAGet16(ds, 0x0000) > ax)
        goto loc_c648;
    sub_c49f();
    bx = memoryAGet16(ds, 0x0008);
    memoryASet16(ds, 0x0002, bx);
    ax = 0x0004;
loc_c662:
    ds = memoryAGet16(cs, 0xa4f6);
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
}
/* Assembly listing of 01ed:a8ee sub_c7be()
sub_c7be PROC
01ed:a8ee	pop	cx
01ed:a8ef	push	cs
01ed:a8f0	push	cx
01ed:a8f1	mov	cx, 1
01ed:a8f4	jmp	loc_c7d4
01ed:a8f6		
        	loc_c7d4:
01ed:a904	push	bp
01ed:a905	push	si
01ed:a906	push	di
01ed:a907	mov	bp, sp
01ed:a909	mov	di, cx
01ed:a90b	mov	ax, word ptr [bp + 0xa]
01ed:a90e	mov	dx, word ptr [bp + 0xc]
01ed:a911	mov	bx, word ptr [bp + 0xe]
01ed:a914	mov	cx, word ptr [bp + 0x10]
01ed:a917	or	cx, cx
01ed:a919	jne	loc_c7f3
01ed:a91b	or	dx, dx
01ed:a91d	je	loc_c858
01ed:a91f	or	bx, bx
01ed:a921	je	loc_c858
        	loc_c7f3:
01ed:a923	test	di, 1
01ed:a927	jne	loc_c815
01ed:a929	or	dx, dx
01ed:a92b	jns	loc_c807
01ed:a92d	neg	dx
01ed:a92f	neg	ax
01ed:a931	sbb	dx, 0
01ed:a934	or	di, 0xc
        	loc_c807:
01ed:a937	or	cx, cx
01ed:a939	jns	loc_c815
01ed:a93b	neg	cx
01ed:a93d	neg	bx
01ed:a93f	sbb	cx, 0
01ed:a942	xor	di, 4
        	loc_c815:
01ed:a945	mov	bp, cx
01ed:a947	mov	cx, 0x20
01ed:a94a	push	di
01ed:a94b	xor	di, di
01ed:a94d	xor	si, si
        	loc_c81f:
01ed:a94f	shl	ax, 1
01ed:a951	rcl	dx, 1
01ed:a953	rcl	si, 1
01ed:a955	rcl	di, 1
01ed:a957	cmp	di, bp
01ed:a959	jb	loc_c836
01ed:a95b	ja	loc_c831
01ed:a95d	cmp	si, bx
01ed:a95f	jb	loc_c836
        	loc_c831:
01ed:a961	sub	si, bx
01ed:a963	sbb	di, bp
01ed:a965	inc	ax
        	loc_c836:
01ed:a966	loop	loc_c81f
01ed:a968	pop	bx
01ed:a969	test	bx, 2
01ed:a96d	je	loc_c845
01ed:a96f	mov	ax, si
01ed:a971	mov	dx, di
01ed:a973	shr	bx, 1
        	loc_c845:
01ed:a975	test	bx, 4
01ed:a979	je	loc_c852
01ed:a97b	neg	dx
01ed:a97d	neg	ax
01ed:a97f	sbb	dx, 0
        	loc_c852:
01ed:a982	pop	di
01ed:a983	pop	si
01ed:a984	pop	bp
01ed:a985	retf	8
        	loc_c858:
01ed:a988	div	bx
01ed:a98a	test	di, 2
01ed:a98e	je	loc_c861
01ed:a990	xchg	dx, ax
        	loc_c861:
01ed:a991	xor	dx, dx
01ed:a993	jmp	loc_c852
sub_c7be ENDP
*/
void sub_c7be()
{
    // coverage: 0xbaee-0xbaf6 method sub_c7be
    // coverage: 0xbb04-0xbb95 method sub_c7be
    push(0x7777);
    stop(/*override stack*/);
    cx = pop();
    push(cs);
    push(cx);
    cx = 0x0001;
    goto loc_c7d4;
    //   gap of 14 bytes
loc_c7d4:
    push(bp);
    push(si);
    push(di);
    bp = sp;
    di = cx;
    ax = memoryAGet16(ss, bp + 10);
    dx = memoryAGet16(ss, bp + 12);
    bx = memoryAGet16(ss, bp + 14);
    cx = memoryAGet16(ss, bp + 16);
    if (cx)
        goto loc_c7f3;
    if (!dx)
        goto loc_c858;
    if (!bx)
        goto loc_c858;
loc_c7f3:
    if (di & 0x0001)
        goto loc_c815;
    if (!(dx & 0x8000))
        goto loc_c807;
    dx = -dx;
    stop(/*74*/);
    ax = -ax;
    dx -= flags.carry;
    di |= 0x000c;
loc_c807:
    if (!(cx & 0x8000))
        goto loc_c815;
    cx = -cx;
    stop(/*74*/);
    bx = -bx;
    cx -= flags.carry;
    di ^= 0x0004;
loc_c815:
    bp = cx;
    cx = 0x0020;
    push(di);
    di = 0;
    si = 0;
loc_c81f:
    flags.carry = !!(ax & 0x8000);
    ax <<= 1;
    dx = rcl(dx, 0x0001);
    si = rcl(si, 0x0001);
    di = rcl(di, 0x0001);
    if (di < bp)
        goto loc_c836;
    if (di > bp)
        goto loc_c831;
    if (si < bx)
        goto loc_c836;
loc_c831:
    flags.carry = si < bx;
    si -= bx;
    di -= bp + flags.carry;
    ax++;
loc_c836:
    if (--cx)
        goto loc_c81f;
    bx = pop();
    if (!(bx & 0x0002))
        goto loc_c845;
    ax = si;
    dx = di;
    bx >>= 1;
loc_c845:
    if (!(bx & 0x0004))
        goto loc_c852;
    dx = -dx;
    stop(/*74*/);
    ax = -ax;
    dx -= flags.carry;
loc_c852:
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
    sp += 8;
    return;
loc_c858:
    div(bx);
    if (!(di & 0x0002))
        goto loc_c861;
    tx = dx;
    dx = ax;
    ax = tx;
loc_c861:
    dx = 0;
    goto loc_c852;
}
/* Assembly listing of 01ed:a995 sub_c865()
sub_c865 PROC
01ed:a995	pop	es
01ed:a996	push	cs
01ed:a997	push	es
01ed:a998	or	cx, cx
01ed:a99a	jge	loc_c878
01ed:a99c	not	bx
01ed:a99e	not	cx
01ed:a9a0	add	bx, 1
01ed:a9a3	adc	cx, 0
01ed:a9a6	jmp	loc_c8a7
        	loc_c878:
01ed:a9a8	add	ax, bx
01ed:a9aa	jae	loc_c880
01ed:a9ac	add	dx, 0x1000
        	loc_c880:
01ed:a9b0	mov	ch, cl
01ed:a9b2	mov	cl, 4
01ed:a9b4	shl	ch, cl
01ed:a9b6	add	dh, ch
01ed:a9b8	mov	ch, al
01ed:a9ba	shr	ax, cl
01ed:a9bc	add	dx, ax
01ed:a9be	mov	al, ch
01ed:a9c0	and	ax, 0xf
01ed:a9c3	retf	
01ed:a9c4		
        	loc_c8a7:
01ed:a9d7	sub	ax, bx
01ed:a9d9	jae	loc_c8af
01ed:a9db	sub	dx, 0x1000
        	loc_c8af:
01ed:a9df	mov	bh, cl
01ed:a9e1	mov	cl, 4
01ed:a9e3	shl	bh, cl
01ed:a9e5	xor	bl, bl
01ed:a9e7	sub	dx, bx
01ed:a9e9	mov	ch, al
01ed:a9eb	shr	ax, cl
01ed:a9ed	add	dx, ax
01ed:a9ef	mov	al, ch
01ed:a9f1	and	ax, 0xf
01ed:a9f4	retf	
sub_c865 ENDP
*/
void sub_c865()
{
    // coverage: 0xbb95-0xbbc4 method sub_c865
    // coverage: 0xbbd7-0xbbf5 method sub_c865
    stop(/*override stack*/);
    es = pop();
    push(cs);
    push(es);
    if ((short)cx >= 0)
        goto loc_c878;
    bx = ~bx;
    cx = ~cx;
    flags.carry = (bx + 0x0001) >= 0x10000;
    bx += 0x0001;
    cx += flags.carry;
    goto loc_c8a7;
loc_c878:
    flags.carry = (ax + bx) >= 0x10000;
    ax += bx;
    if (!flags.carry)
        goto loc_c880;
    dx += 0x1000;
loc_c880:
    ch = cl;
    cl = 0x04;
    ch <<= cl;
    dh += ch;
    ch = al;
    ax >>= cl;
    dx += ax;
    al = ch;
    ax &= 0x000f;
    cs = pop();
    return;
    //   gap of 19 bytes
loc_c8a7:
    flags.carry = ax < bx;
    ax -= bx;
    if (!flags.carry)
        goto loc_c8af;
    dx -= 0x1000;
loc_c8af:
    bh = cl;
    cl = 0x04;
    bh <<= cl;
    bl = 0;
    dx -= bx;
    ch = al;
    ax >>= cl;
    dx += ax;
    al = ch;
    ax &= 0x000f;
    cs = pop();
}
/* Assembly listing of 01ed:a9f5 sub_c8c5()
sub_c8c5 PROC
01ed:a9f5	pop	es
01ed:a9f6	push	cs
01ed:a9f7	push	es
01ed:a9f8	push	bp
01ed:a9f9	mov	bp, sp
01ed:a9fb	push	si
01ed:a9fc	push	di
01ed:a9fd	push	ds
01ed:a9fe	lds	si, ptr [bp + 6]
01ed:aa01	les	di, ptr [bp + 0xa]
01ed:aa04	cld	
01ed:aa05	shr	cx, 1
01ed:aa07	rep movsw	word ptr es:[di], word ptr [si]
01ed:aa09	adc	cx, cx
01ed:aa0b	rep movsb	byte ptr es:[di], byte ptr [si]
01ed:aa0d	pop	ds
01ed:aa0e	pop	di
01ed:aa0f	pop	si
01ed:aa10	pop	bp
01ed:aa11	retf	8
sub_c8c5 ENDP
*/
void sub_c8c5()
{
    // coverage: 0xbbf5-0xbc14 method sub_c8c5
    push(0x7777);
    stop(/*override stack*/);
    es = pop();
    push(cs);
    push(es);
    push(bp);
    bp = sp;
    push(si);
    push(di);
    push(ds);
    si = memoryAGet16(ss, bp + 6);
    ds = memoryAGet16(ss, bp + 6 + 2);
    di = memoryAGet16(ss, bp + 10);
    es = memoryAGet16(ss, bp + 10 + 2);
    flags.direction = false;
    flags.carry = cx & 1;
    cx >>= 1;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
    cx += cx + flags.carry;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    ds = pop();
    di = pop();
    si = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
    sp += 8;
}
/* Assembly listing of 01ed:aa14 sub_c8e4()
sub_c8e4 PROC
01ed:aa14	push	si
01ed:aa15	xchg	si, ax
01ed:aa16	xchg	dx, ax
01ed:aa17	test	ax, ax
01ed:aa19	je	loc_c8ed
01ed:aa1b	mul	bx
        	loc_c8ed:
01ed:aa1d	jcxz	loc_c8f4
01ed:aa1f	xchg	cx, ax
01ed:aa20	mul	si
01ed:aa22	add	ax, cx
        	loc_c8f4:
01ed:aa24	xchg	si, ax
01ed:aa25	mul	bx
01ed:aa27	add	dx, si
01ed:aa29	pop	si
01ed:aa2a	ret	
sub_c8e4 ENDP
*/
void sub_c8e4()
{
    // coverage: 0xbc14-0xbc2b method sub_c8e4
    push(si);
    tx = si;
    si = ax;
    ax = tx;
    tx = dx;
    dx = ax;
    ax = tx;
    if (!(ax & ax))
        goto loc_c8ed;
    mul(bx);
loc_c8ed:
    if (cx == 0)
        goto loc_c8f4;
    tx = cx;
    cx = ax;
    ax = tx;
    mul(si);
    ax += cx;
loc_c8f4:
    tx = si;
    si = ax;
    ax = tx;
    mul(bx);
    dx += si;
    si = pop();
}
/* Assembly listing of 01ed:aa2b sub_c8fb()
sub_c8fb PROC
01ed:aa2b	push	cx
01ed:aa2c	mov	ch, al
01ed:aa2e	mov	cl, 4
01ed:aa30	shr	ax, cl
01ed:aa32	add	dx, ax
01ed:aa34	mov	al, ch
01ed:aa36	mov	ah, bl
01ed:aa38	shr	bx, cl
01ed:aa3a	pop	cx
01ed:aa3b	add	cx, bx
01ed:aa3d	mov	bl, ah
01ed:aa3f	and	ax, 0xf
01ed:aa42	and	bx, 0xf
01ed:aa45	cmp	dx, cx
01ed:aa47	jne	loc_c91b
01ed:aa49	cmp	ax, bx
        	loc_c91b:
01ed:aa4b	ret	
sub_c8fb ENDP
*/
void sub_c8fb()
{
    // coverage: 0xbc2b-0xbc4c method sub_c8fb
    push(cx);
    ch = al;
    cl = 0x04;
    ax >>= cl;
    dx += ax;
    al = ch;
    ah = bl;
    bx >>= cl;
    cx = pop();
    cx += bx;
    bl = ah;
    ax &= 0x000f;
    bx &= 0x000f;
    flags.carry = dx < cx;
    flags.zero = dx == cx;
    if (dx != cx)
        return;
    flags.carry = ax < bx;
    flags.zero = ax == bx;
}
/* Assembly listing of 01ed:aa4e sub_c91e()
sub_c91e PROC
01ed:aa4e		
        	loc_20ba:
01ed:01ea	mov	cx, 0x1e
01ed:01ed	mov	dx, 0x3b
01ed:01f0	mov	ds, word ptr cs:[0x1ff]
01ed:01f5	call	0x1e2
01ed:01f8	mov	ax, 3
01ed:01fb	push	ax
01ed:01fc	call	0x115
01ed:01ff	add	byte ptr [bx + si], al
01ed:0201	add	ax, word ptr [bx + si + 0x55]
01ed:0204	mov	bp, sp
01ed:0206	cmp	word ptr [0x6b4c], sp
01ed:020a	ja	loc_20df
01ed:020c	call	0xffffab83
        	loc_20df:
01ed:020f	cmp	byte ptr [bp + 4], 1
01ed:0213	jne	loc_2126
01ed:0215	call	0x416
01ed:0218	mov	ah, 0
01ed:021a	or	ax, ax
01ed:021c	jne	loc_2126
01ed:021e	les	bx, ptr [bp + 6]
01ed:0221	mov	ax, word ptr es:[bx + 6]
01ed:0225	mov	dx, word ptr es:[bx + 4]
01ed:0229	mov	word ptr [0x6be4], dx
01ed:022d	mov	word ptr [0x6be6], ax
01ed:0230	call	0x282
01ed:0233	call	0x7ba7
01ed:0236	call	0xa07
01ed:0239	call	0x258
01ed:023c	call	0x569
01ed:023f	call	0x7a77
01ed:0242	call	0x7db9
01ed:0245	mov	ax, 3
01ed:0248	push	ax
01ed:0249	call	0x7120
01ed:024c	inc	sp
01ed:024d	inc	sp
01ed:024e	xor	ax, ax
01ed:0250	push	ax
01ed:0251	call	0xffff98ba
01ed:0254	inc	sp
01ed:0255	inc	sp
        	loc_2126:
01ed:0256	pop	bp
01ed:0257	ret	
01ed:0258		
        	loc_c91e:
01ed:aa4e	pop	word ptr [0x6bb0]
01ed:aa52	pop	word ptr [0x6bb2]
01ed:aa56	pop	word ptr [0x6bb4]
01ed:aa5a	mov	word ptr cs:[0xaa4c], ds
01ed:aa5f	mov	word ptr [0x6bb6], si
01ed:aa63	mov	word ptr [0x6bb8], di
01ed:aa67	cld	
01ed:aa68	mov	es, word ptr [0x79]
01ed:aa6c	mov	si, 0x80
01ed:aa6f	xor	ah, ah
01ed:aa71	lodsb	al, byte ptr es:[si]
01ed:aa73	inc	ax
01ed:aa74	mov	bp, es
01ed:aa76	xchg	si, dx
01ed:aa78	xchg	bx, ax
01ed:aa79	mov	si, word ptr [0x73]
01ed:aa7d	inc	si
01ed:aa7e	inc	si
01ed:aa7f	mov	cx, 1
01ed:aa82	cmp	byte ptr [0x7b], 3
01ed:aa87	jb	loc_c96a
01ed:aa89	mov	es, word ptr [0x75]
01ed:aa8d	mov	di, si
01ed:aa8f	mov	cl, 0x7f
01ed:aa91	xor	al, al
01ed:aa93	repne scasb	al, byte ptr es:[di]
01ed:aa95	jcxz	loc_c9d5
01ed:aa97	xor	cl, 0x7f
        	loc_c96a:
01ed:aa9a	push	ax
01ed:aa9b	mov	ax, cx
01ed:aa9d	add	ax, bx
01ed:aa9f	inc	ax
01ed:aaa0	and	ax, 0xfffe
01ed:aaa3	mov	di, sp
01ed:aaa5	sub	di, ax
01ed:aaa7	jb	loc_c9d5
01ed:aaa9	mov	sp, di
01ed:aaab	push	es
01ed:aaac	pop	ds
01ed:aaad	push	ss
01ed:aaae	pop	es
01ed:aaaf	push	cx
01ed:aab0	dec	cx
01ed:aab1	rep movsb	byte ptr es:[di], byte ptr [si]
01ed:aab3	xor	al, al
01ed:aab5	stosb	byte ptr es:[di], al
01ed:aab6	mov	ds, bp
01ed:aab8	xchg	dx, si
01ed:aaba	xchg	cx, bx
01ed:aabc	mov	ax, bx
01ed:aabe	mov	dx, ax
01ed:aac0	inc	bx
        	loc_c991:
01ed:aac1	call	0xaadd
01ed:aac4	ja	loc_c99d
        	loc_c996:
01ed:aac6	jb	loc_c9d8
01ed:aac8	call	0xaadd
01ed:aacb	ja	loc_c996
        	loc_c99d:
01ed:aacd	cmp	al, 0x20
01ed:aacf	je	loc_c9a9
01ed:aad1	cmp	al, 0xd
01ed:aad3	je	loc_c9a9
01ed:aad5	cmp	al, 9
01ed:aad7	jne	loc_c991
        	loc_c9a9:
01ed:aad9	xor	al, al
01ed:aadb	jmp	loc_c991
01ed:aadd		
        	loc_c9d5:
01ed:ab05	jmp	loc_20ba
        	loc_c9d8:
01ed:ab08	pop	cx
01ed:ab09	add	cx, dx
01ed:ab0b	mov	ds, word ptr cs:[0xaa4c]
01ed:ab10	mov	word ptr [0x6baa], bx
01ed:ab14	inc	bx
01ed:ab15	add	bx, bx
01ed:ab17	add	bx, bx
01ed:ab19	mov	si, sp
01ed:ab1b	mov	bp, sp
01ed:ab1d	sub	bp, bx
01ed:ab1f	jb	loc_c9d5
01ed:ab21	mov	sp, bp
01ed:ab23	mov	word ptr [0x6bac], bp
01ed:ab27	mov	word ptr [0x6bae], ss
        	loc_c9fb:
01ed:ab2b	jcxz	loc_ca0e
01ed:ab2d	mov	word ptr [bp], si
01ed:ab30	mov	word ptr [bp + 2], ss
01ed:ab33	add	bp, 4
        	loc_ca06:
01ed:ab36	lodsb	al, byte ptr ss:[si]
01ed:ab38	or	al, al
01ed:ab3a	loopne	loc_ca06
01ed:ab3c	je	loc_c9fb
        	loc_ca0e:
01ed:ab3e	xor	ax, ax
01ed:ab40	mov	word ptr [bp], ax
01ed:ab43	mov	word ptr [bp + 2], ax
01ed:ab46	mov	ds, word ptr cs:[0xaa4c]
01ed:ab4b	mov	si, word ptr [0x6bb6]
01ed:ab4f	mov	di, word ptr [0x6bb8]
01ed:ab53	push	word ptr [0x6bb4]
01ed:ab57	push	word ptr [0x6bb2]
01ed:ab5b	mov	ax, word ptr [0x6baa]
01ed:ab5e	mov	word ptr [0x69], ax
01ed:ab61	mov	ax, word ptr [0x6bae]
01ed:ab64	mov	word ptr [0x6d], ax
01ed:ab67	mov	ax, word ptr [0x6bac]
01ed:ab6a	mov	word ptr [0x6b], ax
01ed:ab6d	jmp	word ptr [0x6bb0]
sub_c91e ENDP
*/
void sub_c91e()
{
    // coverage: 0x13ea-0x1458 method sub_c91e
    // coverage: 0xbc4e-0xbcdd method sub_c91e
    // coverage: 0xbd05-0xbd71 method sub_c91e
    push(0x7777);
    goto loc_c91e;
loc_20ba:
    cx = 0x001e;
    dx = 0x003b;
    ds = memoryAGet16(cs, 0x01ff);
    sub_20b2();
    ax = 0x0003;
    push(ax);
    sub_1fe5();
    memoryASet(ds, bx + si, memoryAGet(ds, bx + si) + al);
    ax += memoryAGet16(ds, bx + si + 85);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_20df;
    sub_ca53();
loc_20df:
    if (memoryAGet(ss, bp + 4) != 0x01)
        goto loc_2126;
    sub_22e6();
    ah = 0x00;
    if (ax)
        goto loc_2126;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x6be4, dx);
    memoryASet16(ds, 0x6be6, ax);
    sub_2152();
    sub_9a77();
    sub_28d7();
    sub_2128();
    sub_2439();
    sub_9947();
    sub_9c89();
    ax = 0x0003;
    push(ax);
    sub_8ff0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b78a();
    sp++;
    sp++;
loc_2126:
    bp = pop();
    assert(pop() == 0x7777);
    return;
    //   gap of 42998 bytes
loc_c91e:
    memoryASet16(ds, 0x6bb0, pop());
    memoryASet16(ds, 0x6bb2, pop());
    memoryASet16(ds, 0x6bb4, pop());
    memoryASet16(cs, 0xaa4c, ds);
    memoryASet16(ds, 0x6bb6, si);
    memoryASet16(ds, 0x6bb8, di);
    flags.direction = false;
    es = memoryAGet16(ds, 0x0079);
    si = 0x0080;
    ah = 0;
    lodsb_es<MemAuto, DirAuto>();
    ax++;
    bp = es;
    tx = si;
    si = dx;
    dx = tx;
    tx = bx;
    bx = ax;
    ax = tx;
    si = memoryAGet16(ds, 0x0073);
    si++;
    si++;
    cx = 0x0001;
    if (memoryAGet(ds, 0x007b) < 0x03)
        goto loc_c96a;
    es = memoryAGet16(ds, 0x0075);
    di = si;
    cl = 0x7f;
    al = 0;
    repne_scasb<MemAuto, DirAuto>(al);
    if (cx == 0)
        goto loc_c9d5;
    cl ^= 0x7f;
loc_c96a:
    push(ax);
    ax = cx;
    ax += bx;
    ax++;
    ax &= 0xfffe;
    di = sp;
    tx = di;
    di -= ax;
    if (tx < ax)
        goto loc_c9d5;
    sp = di;
    push(es);
    ds = pop();
    push(ss);
    es = pop();
    push(cx);
    cx--;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    al = 0;
    stosb<MemAuto, DirAuto>();
    ds = bp;
    tx = dx;
    dx = si;
    si = tx;
    tx = cx;
    cx = bx;
    bx = tx;
    ax = bx;
    dx = ax;
    bx++;
loc_c991:
    sub_c9ad();
    if (!flags.zero && !flags.carry)
        goto loc_c99d;
loc_c996:
    if (stop(/*1 - jb loc_c9d8*/))
        goto loc_c9d8;
    sub_c9ad();
    if (!flags.zero && !flags.carry)
        goto loc_c996;
loc_c99d:
    if (al == 0x20)
        goto loc_c9a9;
    if (al == 0x0d)
        goto loc_c9a9;
    if (al != 0x09)
        goto loc_c991;
loc_c9a9:
    al = 0;
    goto loc_c991;
    //   gap of 40 bytes
loc_c9d5:
    goto loc_20ba;
loc_c9d8:
    cx = pop();
    cx += dx;
    ds = memoryAGet16(cs, 0xaa4c);
    memoryASet16(ds, 0x6baa, bx);
    bx++;
    bx += bx;
    bx += bx;
    si = sp;
    bp = sp;
    tx = bp;
    bp -= bx;
    if (tx < bx)
        goto loc_c9d5;
    sp = bp;
    memoryASet16(ds, 0x6bac, bp);
    memoryASet16(ds, 0x6bae, ss);
loc_c9fb:
    if (cx == 0)
        goto loc_ca0e;
    memoryASet16(ss, bp, si);
    memoryASet16(ss, bp + 2, ss);
    bp += 0x0004;
loc_ca06:
    lodsb_ss<MemAuto, DirAuto>();
    if (--cx && al)
        goto loc_ca06;
    if (!al)
        goto loc_c9fb;
loc_ca0e:
    ax = 0;
    memoryASet16(ss, bp, ax);
    memoryASet16(ss, bp + 2, ax);
    ds = memoryAGet16(cs, 0xaa4c);
    si = memoryAGet16(ds, 0x6bb6);
    di = memoryAGet16(ds, 0x6bb8);
    push(memoryAGet16(ds, 0x6bb4));
    push(memoryAGet16(ds, 0x6bb2));
    ax = memoryAGet16(ds, 0x6baa);
    memoryASet16(ds, 0x0069, ax);
    ax = memoryAGet16(ds, 0x6bae);
    memoryASet16(ds, 0x006d, ax);
    ax = memoryAGet16(ds, 0x6bac);
    memoryASet16(ds, 0x006b, ax);
    stop(/*2*/); // 01ed:ab6d jmp word ptr [0x6bb0] - jump Indirect memoryAGet16(ds, 0x6bb0)
}
// INJECT: Error: cannot inject flag in sub_c9ad() because of being label!
/* Assembly listing of 01ed:aadd sub_c9ad()
sub_c9ad PROC
01ed:aadd	or	ax, ax
01ed:aadf	je	loc_c9b8
01ed:aae1	inc	dx
01ed:aae2	stosb	byte ptr es:[di], al
01ed:aae3	or	al, al
01ed:aae5	jne	loc_c9b8
01ed:aae7	inc	bx
        	loc_c9b8:
01ed:aae8	xchg	al, ah
01ed:aaea	xor	al, al
01ed:aaec	stc	
01ed:aaed	jcxz	loc_c9d4
01ed:aaef	lodsb	al, byte ptr [si]
01ed:aaf0	dec	cx
01ed:aaf1	sub	al, 0x22
01ed:aaf3	je	loc_c9d4
01ed:aaf5	add	al, 0x22
01ed:aaf7	cmp	al, 0x5c
01ed:aaf9	jne	loc_c9d2
01ed:aafb	cmp	byte ptr [si], 0x22
01ed:aafe	jne	loc_c9d2
01ed:ab00	lodsb	al, byte ptr [si]
01ed:ab01	dec	cx
        	loc_c9d2:
01ed:ab02	or	si, si
        	loc_c9d4:
01ed:ab04	ret	
sub_c9ad ENDP
*/
void sub_c9ad()
{
    // coverage: 0xbcdd-0xbd05 method sub_c9ad
    if (!ax)
        goto loc_c9b8;
    dx++;
    stosb<MemAuto, DirAuto>();
    if (al)
        goto loc_c9b8;
    bx++;
loc_c9b8:
    tl = al;
    al = ah;
    ah = tl;
    al = 0;
    flags.carry = true;
    if (cx == 0)
        goto loc_c9d4;
    lodsb<MemAuto, DirAuto>();
    cx--;
    al -= 0x22;
    if (al == 0)
        goto loc_c9d4;
    al += 0x22;
    if (al != 0x5c)
        goto loc_c9d2;
    if (memoryAGet(ds, si) != 0x22)
        goto loc_c9d2;
    lodsb<MemAuto, DirAuto>();
    cx--;
loc_c9d2:
loc_c9d4:
    stop(/*inject ret*/);
}
/* Assembly listing of 01ed:ab83 sub_ca53()
sub_ca53 PROC
01ed:ab83		
        	loc_1fe5:
01ed:0115	mov	ds, word ptr cs:[0x1ff]
01ed:011a	call	0x172
01ed:011d	mov	bp, sp
01ed:011f	mov	ah, 0x4c
01ed:0121	mov	al, byte ptr [bp + 2]
01ed:0124	int	0x21
01ed:0126	mov	cx, 0xe
01ed:0129	mov	dx, 0x2d
01ed:012c	jmp	loc_20c0
01ed:012f		
        	loc_20c0:
01ed:01f0	mov	ds, word ptr cs:[0x1ff]
01ed:01f5	call	0x1e2
01ed:01f8	mov	ax, 3
01ed:01fb	push	ax
01ed:01fc	call	0x115
01ed:01ff	add	byte ptr [bx + si], al
01ed:0201	add	ax, word ptr [bx + si + 0x55]
01ed:0204	mov	bp, sp
01ed:0206	cmp	word ptr [0x6b4c], sp
01ed:020a	ja	loc_20df
01ed:020c	call	0xffffab83
        	loc_20df:
01ed:020f	cmp	byte ptr [bp + 4], 1
01ed:0213	jne	loc_2126
01ed:0215	call	0x416
01ed:0218	mov	ah, 0
01ed:021a	or	ax, ax
01ed:021c	jne	loc_2126
01ed:021e	les	bx, ptr [bp + 6]
01ed:0221	mov	ax, word ptr es:[bx + 6]
01ed:0225	mov	dx, word ptr es:[bx + 4]
01ed:0229	mov	word ptr [0x6be4], dx
01ed:022d	mov	word ptr [0x6be6], ax
01ed:0230	call	0x282
01ed:0233	call	0x7ba7
01ed:0236	call	0xa07
01ed:0239	call	0x258
01ed:023c	call	0x569
01ed:023f	call	0x7a77
01ed:0242	call	0x7db9
01ed:0245	mov	ax, 3
01ed:0248	push	ax
01ed:0249	call	0x7120
01ed:024c	inc	sp
01ed:024d	inc	sp
01ed:024e	xor	ax, ax
01ed:0250	push	ax
01ed:0251	call	0xffff98ba
01ed:0254	inc	sp
01ed:0255	inc	sp
        	loc_2126:
01ed:0256	pop	bp
01ed:0257	ret	
01ed:0258		
        	loc_ca53:
01ed:ab83	push	cs
01ed:ab84	pop	ds
01ed:ab85	mov	dx, 0xab71
01ed:ab88	mov	ah, 9
01ed:ab8a	int	0x21
01ed:ab8c	jmp	loc_1fe5
sub_ca53 ENDP
*/
void sub_ca53()
{
    // coverage: 0x1315-0x132f method sub_ca53
    // coverage: 0x13f0-0x1458 method sub_ca53
    // coverage: 0xbd83-0xbd8f method sub_ca53
    push(0x7777);
    goto loc_ca53;
loc_1fe5:
    ds = memoryAGet16(cs, 0x01ff);
    sub_2042();
    bp = sp;
    ah = 0x4c;
    al = memoryAGet(ss, bp + 2);
    interrupt(0x21);
    cx = 0x000e;
    dx = 0x002d;
    goto loc_20c0;
    //   gap of 193 bytes
loc_20c0:
    ds = memoryAGet16(cs, 0x01ff);
    sub_20b2();
    ax = 0x0003;
    push(ax);
    sub_1fe5();
    memoryASet(ds, bx + si, memoryAGet(ds, bx + si) + al);
    ax += memoryAGet16(ds, bx + si + 85);
    bp = sp;
    if (memoryAGet16(ds, 0x6b4c) > sp)
        goto loc_20df;
    sub_ca53();
loc_20df:
    if (memoryAGet(ss, bp + 4) != 0x01)
        goto loc_2126;
    sub_22e6();
    ah = 0x00;
    if (ax)
        goto loc_2126;
    bx = memoryAGet16(ss, bp + 6);
    es = memoryAGet16(ss, bp + 6 + 2);
    ax = memoryAGet16(es, bx + 6);
    dx = memoryAGet16(es, bx + 4);
    memoryASet16(ds, 0x6be4, dx);
    memoryASet16(ds, 0x6be6, ax);
    sub_2152();
    sub_9a77();
    sub_28d7();
    sub_2128();
    sub_2439();
    sub_9947();
    sub_9c89();
    ax = 0x0003;
    push(ax);
    sub_8ff0();
    sp++;
    sp++;
    ax = 0;
    push(ax);
    sub_b78a();
    sp++;
    sp++;
loc_2126:
    bp = pop();
    assert(pop() == 0x7777);
    return;
    //   gap of 43307 bytes
loc_ca53:
    push(cs);
    ds = pop();
    dx = 0xab71;
    ah = 0x09;
    interrupt(0x21);
    goto loc_1fe5;
}
/* Assembly listing of 0ca6:0000 sub_ca60()
sub_ca60 PROC
0ca6:0000	mov	si, 0x4de6
0ca6:0003	call	0x64d
0ca6:0006	mov	cx, 2
0ca6:0009	call	0x427
0ca6:000c	mov	bx, word ptr es:[di + 0x1c]
0ca6:0010	push	bx
0ca6:0011	mov	bx, di
0ca6:0013	push	es
0ca6:0014	call	0x52d
0ca6:0017	pop	ds
0ca6:0018	mov	si, bx
0ca6:001a	pop	bx
0ca6:001b	push	ds
0ca6:001c	mov	ax, 0x1228
0ca6:001f	mov	ds, ax
0ca6:0021	shl	bx, 1
0ca6:0023	mov	ax, word ptr [bx + 0x4dcc]
0ca6:0027	pop	ds
0ca6:0028	call	ax
0ca6:002a	ret	
sub_ca60 ENDP
*/
void sub_ca60()
{
    // coverage: 0xbd90-0xbdbb method sub_ca60
    si = 0x4de6;
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    push(es);
    sub_cf8d();
    ds = pop();
    si = bx;
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 19916);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:0001 sub_ca61()
sub_ca61 PROC
0ca6:0001	out	0x4d, al
0ca6:0003	call	0x64d
0ca6:0006	mov	cx, 2
0ca6:0009	call	0x427
0ca6:000c	mov	bx, word ptr es:[di + 0x1c]
0ca6:0010	push	bx
0ca6:0011	mov	bx, di
0ca6:0013	push	es
0ca6:0014	call	0x52d
0ca6:0017	pop	ds
0ca6:0018	mov	si, bx
0ca6:001a	pop	bx
0ca6:001b	push	ds
0ca6:001c	mov	ax, 0x1228
0ca6:001f	mov	ds, ax
0ca6:0021	shl	bx, 1
0ca6:0023	mov	ax, word ptr [bx + 0x4dcc]
0ca6:0027	pop	ds
0ca6:0028	call	ax
0ca6:002a	ret	
sub_ca61 ENDP
*/
void sub_ca61()
{
    // coverage: 0xbd91-0xbdbb method sub_ca61
    out(0x4d, al);
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    push(es);
    sub_cf8d();
    ds = pop();
    si = bx;
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 19916);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:0002 sub_ca62()
sub_ca62 PROC
0ca6:0002	dec	bp
0ca6:0003	call	0x64d
0ca6:0006	mov	cx, 2
0ca6:0009	call	0x427
0ca6:000c	mov	bx, word ptr es:[di + 0x1c]
0ca6:0010	push	bx
0ca6:0011	mov	bx, di
0ca6:0013	push	es
0ca6:0014	call	0x52d
0ca6:0017	pop	ds
0ca6:0018	mov	si, bx
0ca6:001a	pop	bx
0ca6:001b	push	ds
0ca6:001c	mov	ax, 0x1228
0ca6:001f	mov	ds, ax
0ca6:0021	shl	bx, 1
0ca6:0023	mov	ax, word ptr [bx + 0x4dcc]
0ca6:0027	pop	ds
0ca6:0028	call	ax
0ca6:002a	ret	
sub_ca62 ENDP
*/
void sub_ca62()
{
    // coverage: 0xbd92-0xbdbb method sub_ca62
    bp--;
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    push(es);
    sub_cf8d();
    ds = pop();
    si = bx;
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 19916);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:0003 sub_ca63()
sub_ca63 PROC
0ca6:0003	call	0x64d
0ca6:0006	mov	cx, 2
0ca6:0009	call	0x427
0ca6:000c	mov	bx, word ptr es:[di + 0x1c]
0ca6:0010	push	bx
0ca6:0011	mov	bx, di
0ca6:0013	push	es
0ca6:0014	call	0x52d
0ca6:0017	pop	ds
0ca6:0018	mov	si, bx
0ca6:001a	pop	bx
0ca6:001b	push	ds
0ca6:001c	mov	ax, 0x1228
0ca6:001f	mov	ds, ax
0ca6:0021	shl	bx, 1
0ca6:0023	mov	ax, word ptr [bx + 0x4dcc]
0ca6:0027	pop	ds
0ca6:0028	call	ax
0ca6:002a	ret	
sub_ca63 ENDP
*/
void sub_ca63()
{
    // coverage: 0xbd93-0xbdbb method sub_ca63
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    push(es);
    sub_cf8d();
    ds = pop();
    si = bx;
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 19916);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:002b sub_ca8b()
sub_ca8b PROC
0ca6:002b	mov	bx, 0x101
        	loc_ca8e:
0ca6:002e	mov	dx, 0x3c4
0ca6:0031	mov	ah, bh
0ca6:0033	mov	al, 2
0ca6:0035	out	dx, ax
0ca6:0036	call	0x5cf
0ca6:0039	call	0x47
0ca6:003c	inc	bl
0ca6:003e	shl	bh, 1
0ca6:0040	cmp	bh, 8
0ca6:0043	jg	loc_cad1
0ca6:0045	jmp	loc_ca8e
0ca6:0047		
        	loc_cad1:
0ca6:0071	ret	
sub_ca8b ENDP
*/
void sub_ca8b()
{
    // coverage: 0xbdbb-0xbdd7 method sub_ca8b
    // coverage: 0xbe01-0xbe02 method sub_ca8b
    bx = 0x0101;
loc_ca8e:
    dx = 0x03c4;
    ah = bh;
    al = 0x02;
    out(dx, ax);
    sub_d02f();
    sub_caa7();
    bl++;
    bh <<= 1;
    if ((char)bh > (char)0x08)
        return;
    goto loc_ca8e;
    //   gap of 42 bytes
}
/* Assembly listing of 0ca6:0047 sub_caa7()
sub_caa7 PROC
0ca6:0047	push	di
0ca6:0048	push	ds
0ca6:0049	mov	bp, 0x1228
0ca6:004c	mov	ds, bp
0ca6:004e	mov	bp, word ptr [0x5429]
0ca6:0052	mov	dx, word ptr [0x5433]
0ca6:0056	mov	cx, word ptr [0x5431]
0ca6:005a	mov	dh, cl
0ca6:005c	pop	ds
        	loc_cabd:
0ca6:005d	cmp	dl, ch
0ca6:005f	je	loc_cacf
0ca6:0061	dec	dl
0ca6:0063	shr	cx, 1
0ca6:0065	rep stosw	word ptr es:[di], ax
0ca6:0067	mov	cl, dh
0ca6:0069	sub	di, cx
0ca6:006b	add	di, bp
0ca6:006d	jmp	loc_cabd
        	loc_cacf:
0ca6:006f	pop	di
0ca6:0070	ret	
sub_caa7 ENDP
*/
void sub_caa7()
{
    // coverage: 0xbdd7-0xbe01 method sub_caa7
    push(di);
    push(ds);
    bp = 0x1228;
    ds = bp;
    bp = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_cabd:
    if (dl == ch)
        goto loc_cacf;
    dl--;
    cx >>= 1;
    rep_stosw<MemAuto, DirAuto>();
    cl = dh;
    di -= cx;
    di += bp;
    goto loc_cabd;
loc_cacf:
    di = pop();
}
/* Assembly listing of 0ca6:0072 sub_cad2()
sub_cad2 PROC
0ca6:0072	mov	bx, 0x101
        	loc_cad5:
0ca6:0075	mov	dx, 0x3c4
0ca6:0078	mov	ah, bh
0ca6:007a	mov	al, 2
0ca6:007c	out	dx, ax
0ca6:007d	call	0x5cf
0ca6:0080	jmp	loc_caed
        	loc_cae2:
0ca6:0082	inc	bl
0ca6:0084	shl	bh, 1
0ca6:0086	cmp	bh, 8
0ca6:0089	jg	loc_cb25
0ca6:008b	jmp	loc_cad5
        	loc_caed:
0ca6:008d	push	di
0ca6:008e	push	ds
0ca6:008f	mov	bp, 0x1228
0ca6:0092	mov	ds, bp
0ca6:0094	mov	bp, word ptr [0x5429]
0ca6:0098	mov	dx, word ptr [0x5433]
0ca6:009c	mov	cx, word ptr [0x5431]
0ca6:00a0	mov	dh, cl
0ca6:00a2	pop	ds
0ca6:00a3	mov	si, ax
0ca6:00a5	not	si
        	loc_cb07:
0ca6:00a7	cmp	dl, ch
0ca6:00a9	je	loc_cb22
0ca6:00ab	dec	dl
0ca6:00ad	shr	cx, 1
        	loc_cb0f:
0ca6:00af	and	word ptr es:[di], si
0ca6:00b2	or	word ptr es:[di], ax
0ca6:00b5	add	di, 2
0ca6:00b8	loop	loc_cb0f
0ca6:00ba	mov	cl, dh
0ca6:00bc	sub	di, cx
0ca6:00be	add	di, bp
0ca6:00c0	jmp	loc_cb07
        	loc_cb22:
0ca6:00c2	pop	di
0ca6:00c3	jmp	loc_cae2
        	loc_cb25:
0ca6:00c5	ret	
sub_cad2 ENDP
*/
void sub_cad2()
{
    // coverage: 0xbe02-0xbe56 method sub_cad2
    bx = 0x0101;
loc_cad5:
    dx = 0x03c4;
    ah = bh;
    al = 0x02;
    out(dx, ax);
    sub_d02f();
    goto loc_caed;
loc_cae2:
    bl++;
    bh <<= 1;
    if ((char)bh > (char)0x08)
        return;
    goto loc_cad5;
loc_caed:
    push(di);
    push(ds);
    bp = 0x1228;
    ds = bp;
    bp = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
    si = ax;
    si = ~si;
loc_cb07:
    if (dl == ch)
        goto loc_cb22;
    dl--;
    cx >>= 1;
loc_cb0f:
    memoryASet16(es, di, memoryAGet16(es, di) & si);
    memoryASet16(es, di, memoryAGet16(es, di) | ax);
    di += 0x0002;
    if (--cx)
        goto loc_cb0f;
    cl = dh;
    di -= cx;
    di += bp;
    goto loc_cb07;
loc_cb22:
    di = pop();
    goto loc_cae2;
}
/* Assembly listing of 0ca6:00c6 sub_cb26()
sub_cb26 PROC
0ca6:00c6	mov	bx, 0x101
        	loc_cb29:
0ca6:00c9	mov	dx, 0x3c4
0ca6:00cc	mov	ah, bh
0ca6:00ce	mov	al, 2
0ca6:00d0	out	dx, ax
0ca6:00d1	call	0x5cf
0ca6:00d4	not	ax
0ca6:00d6	call	0xe4
0ca6:00d9	inc	bl
0ca6:00db	shl	bh, 1
0ca6:00dd	cmp	bh, 8
0ca6:00e0	jg	loc_cb74
0ca6:00e2	jmp	loc_cb29
0ca6:00e4		
        	loc_cb74:
0ca6:0114	ret	
sub_cb26 ENDP
*/
void sub_cb26()
{
    // coverage: 0xbe56-0xbe74 method sub_cb26
    // coverage: 0xbea4-0xbea5 method sub_cb26
    bx = 0x0101;
loc_cb29:
    dx = 0x03c4;
    ah = bh;
    al = 0x02;
    out(dx, ax);
    sub_d02f();
    ax = ~ax;
    sub_cb44();
    bl++;
    bh <<= 1;
    if ((char)bh > (char)0x08)
        return;
    goto loc_cb29;
    //   gap of 48 bytes
}
/* Assembly listing of 0ca6:00e4 sub_cb44()
sub_cb44 PROC
0ca6:00e4	push	di
0ca6:00e5	push	ds
0ca6:00e6	mov	bp, 0x1228
0ca6:00e9	mov	ds, bp
0ca6:00eb	mov	bp, word ptr [0x5429]
0ca6:00ef	mov	dx, word ptr [0x5433]
0ca6:00f3	mov	cx, word ptr [0x5431]
0ca6:00f7	mov	dh, cl
0ca6:00f9	pop	ds
        	loc_cb5a:
0ca6:00fa	cmp	dl, ch
0ca6:00fc	je	loc_cb72
0ca6:00fe	dec	dl
0ca6:0100	shr	cx, 1
        	loc_cb62:
0ca6:0102	and	word ptr es:[di], ax
0ca6:0105	add	di, 2
0ca6:0108	loop	loc_cb62
0ca6:010a	mov	cl, dh
0ca6:010c	sub	di, cx
0ca6:010e	add	di, bp
0ca6:0110	jmp	loc_cb5a
        	loc_cb72:
0ca6:0112	pop	di
0ca6:0113	ret	
sub_cb44 ENDP
*/
void sub_cb44()
{
    // coverage: 0xbe74-0xbea4 method sub_cb44
    push(di);
    push(ds);
    bp = 0x1228;
    ds = bp;
    bp = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_cb5a:
    if (dl == ch)
        goto loc_cb72;
    dl--;
    cx >>= 1;
loc_cb62:
    memoryASet16(es, di, memoryAGet16(es, di) & ax);
    di += 0x0002;
    if (--cx)
        goto loc_cb62;
    cl = dh;
    di -= cx;
    di += bp;
    goto loc_cb5a;
loc_cb72:
    di = pop();
}
/* Assembly listing of 0ca6:0115 sub_cb75()
sub_cb75 PROC
0ca6:0115	mov	byte ptr cs:[0x166], 0x21
0ca6:011b	jmp	loc_cb8b
0ca6:011d		
        	loc_cb8b:
0ca6:012b	mov	bx, 0x101
        	loc_cb8e:
0ca6:012e	mov	dx, 0x3c4
0ca6:0131	mov	ah, bh
0ca6:0133	mov	al, 2
0ca6:0135	out	dx, ax
0ca6:0136	call	0x5cf
0ca6:0139	call	0x147
0ca6:013c	inc	bl
0ca6:013e	shl	bh, 1
0ca6:0140	cmp	bh, 8
0ca6:0143	jg	loc_cbd7
0ca6:0145	jmp	loc_cb8e
0ca6:0147		
        	loc_cbd7:
0ca6:0177	ret	
sub_cb75 ENDP
*/
void sub_cb75()
{
    // coverage: 0xbea5-0xbead method sub_cb75
    // coverage: 0xbebb-0xbed7 method sub_cb75
    // coverage: 0xbf07-0xbf08 method sub_cb75
    memoryASet(cs, 0x0166, 0x21);
    goto loc_cb8b;
    //   gap of 14 bytes
loc_cb8b:
    bx = 0x0101;
loc_cb8e:
    dx = 0x03c4;
    ah = bh;
    al = 0x02;
    out(dx, ax);
    sub_d02f();
    sub_cba7();
    bl++;
    bh <<= 1;
    if ((char)bh > (char)0x08)
        return;
    goto loc_cb8e;
    //   gap of 48 bytes
}
/* Assembly listing of 0ca6:011d sub_cb7d()
sub_cb7d PROC
0ca6:011d	mov	byte ptr cs:[0x166], 9
0ca6:0123	jmp	loc_cb8b
0ca6:0125		
        	loc_cb8b:
0ca6:012b	mov	bx, 0x101
        	loc_cb8e:
0ca6:012e	mov	dx, 0x3c4
0ca6:0131	mov	ah, bh
0ca6:0133	mov	al, 2
0ca6:0135	out	dx, ax
0ca6:0136	call	0x5cf
0ca6:0139	call	0x147
0ca6:013c	inc	bl
0ca6:013e	shl	bh, 1
0ca6:0140	cmp	bh, 8
0ca6:0143	jg	loc_cbd7
0ca6:0145	jmp	loc_cb8e
0ca6:0147		
        	loc_cbd7:
0ca6:0177	ret	
sub_cb7d ENDP
*/
void sub_cb7d()
{
    // coverage: 0xbead-0xbeb5 method sub_cb7d
    // coverage: 0xbebb-0xbed7 method sub_cb7d
    // coverage: 0xbf07-0xbf08 method sub_cb7d
    memoryASet(cs, 0x0166, 0x09);
    goto loc_cb8b;
    //   gap of 6 bytes
loc_cb8b:
    bx = 0x0101;
loc_cb8e:
    dx = 0x03c4;
    ah = bh;
    al = 0x02;
    out(dx, ax);
    sub_d02f();
    sub_cba7();
    bl++;
    bh <<= 1;
    if ((char)bh > (char)0x08)
        return;
    goto loc_cb8e;
    //   gap of 48 bytes
}
/* Assembly listing of 0ca6:0125 sub_cb85()
sub_cb85 PROC
0ca6:0125	mov	byte ptr cs:[0x166], 0x31
0ca6:012b	mov	bx, 0x101
        	loc_cb8e:
0ca6:012e	mov	dx, 0x3c4
0ca6:0131	mov	ah, bh
0ca6:0133	mov	al, 2
0ca6:0135	out	dx, ax
0ca6:0136	call	0x5cf
0ca6:0139	call	0x147
0ca6:013c	inc	bl
0ca6:013e	shl	bh, 1
0ca6:0140	cmp	bh, 8
0ca6:0143	jg	loc_cbd7
0ca6:0145	jmp	loc_cb8e
0ca6:0147		
        	loc_cbd7:
0ca6:0177	ret	
sub_cb85 ENDP
*/
void sub_cb85()
{
    // coverage: 0xbeb5-0xbed7 method sub_cb85
    // coverage: 0xbf07-0xbf08 method sub_cb85
    memoryASet(cs, 0x0166, 0x31);
    bx = 0x0101;
loc_cb8e:
    dx = 0x03c4;
    ah = bh;
    al = 0x02;
    out(dx, ax);
    sub_d02f();
    sub_cba7();
    bl++;
    bh <<= 1;
    if ((char)bh > (char)0x08)
        return;
    goto loc_cb8e;
    //   gap of 48 bytes
}
/* Assembly listing of 0ca6:0147 sub_cba7()
sub_cba7 PROC
0ca6:0147	push	di
0ca6:0148	push	ds
0ca6:0149	mov	bp, 0x1228
0ca6:014c	mov	ds, bp
0ca6:014e	mov	bp, word ptr [0x5429]
0ca6:0152	mov	dx, word ptr [0x5433]
0ca6:0156	mov	cx, word ptr [0x5431]
0ca6:015a	mov	dh, cl
0ca6:015c	pop	ds
        	loc_cbbd:
0ca6:015d	cmp	dl, ch
0ca6:015f	je	loc_cbd5
0ca6:0161	dec	dl
0ca6:0163	shr	cx, 1
        	loc_cbc5:
0ca6:0165	and	word ptr es:[di], ax
0ca6:0168	add	di, 2
0ca6:016b	loop	loc_cbc5
0ca6:016d	mov	cl, dh
0ca6:016f	sub	di, cx
0ca6:0171	add	di, bp
0ca6:0173	jmp	loc_cbbd
        	loc_cbd5:
0ca6:0175	pop	di
0ca6:0176	ret	
sub_cba7 ENDP
*/
void sub_cba7()
{
    // coverage: 0xbed7-0xbf07 method sub_cba7
    push(di);
    push(ds);
    bp = 0x1228;
    ds = bp;
    bp = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_cbbd:
    if (dl == ch)
        goto loc_cbd5;
    dl--;
    cx >>= 1;
loc_cbc5:
    memoryASet16(es, di, memoryAGet16(es, di) & ax);
    di += 0x0002;
    if (--cx)
        goto loc_cbc5;
    cl = dh;
    di -= cx;
    di += bp;
    goto loc_cbbd;
loc_cbd5:
    di = pop();
}
/* Assembly listing of 0ca6:0178 sub_cbd8()
sub_cbd8 PROC
0ca6:0178	ret	
sub_cbd8 ENDP
*/
void sub_cbd8()
{
    // coverage: 0xbf08-0xbf09 method sub_cbd8
}
/* Assembly listing of 0ca6:0179 sub_cbd9()
sub_cbd9 PROC
0ca6:0179	push	di
0ca6:017a	push	si
0ca6:017b	push	bp
0ca6:017c	push	ds
0ca6:017d	push	es
0ca6:017e	cld	
0ca6:017f	mov	bx, 0x1228
0ca6:0182	mov	ds, bx
0ca6:0184	mov	es, dx
0ca6:0186	mov	di, ax
0ca6:0188	mov	word ptr es:[di + 0x18], 0x14
0ca6:018e	mov	word ptr es:[di + 0x1a], 0x19
0ca6:0194	mov	byte ptr [0x541f], 2
0ca6:0199	mov	byte ptr [0x5420], 1
0ca6:019e	mov	bx, word ptr [0x541d]
0ca6:01a2	shl	bx, 1
0ca6:01a4	call	word ptr [bx + 0x4dda]
0ca6:01a8	pop	es
0ca6:01a9	pop	ds
0ca6:01aa	pop	bp
0ca6:01ab	pop	si
0ca6:01ac	pop	di
0ca6:01ad	retf	
sub_cbd9 ENDP
*/
void sub_cbd9()
{
    // coverage: 0xbf09-0xbf3e method sub_cbd9
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    flags.direction = false;
    bx = 0x1228;
    ds = bx;
    es = dx;
    di = ax;
    memoryASet16(es, di + 24, 0x0014);
    memoryASet16(es, di + 26, 0x0019);
    memoryASet(ds, 0x541f, 0x02);
    memoryASet(ds, 0x5420, 0x01);
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 19930));
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:01ae sub_cc0e()
sub_cc0e PROC
0ca6:01ae	ret	
sub_cc0e ENDP
*/
void sub_cc0e()
{
    // coverage: 0xbf3e-0xbf3f method sub_cc0e
}
/* Assembly listing of 0ca6:01af sub_cc0f()
sub_cc0f PROC
0ca6:01af	ret	
sub_cc0f ENDP
*/
void sub_cc0f()
{
    // coverage: 0xbf3f-0xbf40 method sub_cc0f
}
/* Assembly listing of 0ca6:01b0 sub_cc10()
sub_cc10 PROC
0ca6:01b0	ret	
sub_cc10 ENDP
*/
void sub_cc10()
{
    // coverage: 0xbf40-0xbf41 method sub_cc10
}
/* Assembly listing of 0ca6:01e1 sub_cc41()
sub_cc41 PROC
0ca6:01e1	push	di
0ca6:01e2	push	si
0ca6:01e3	push	bp
0ca6:01e4	push	ds
0ca6:01e5	push	es
0ca6:01e6	mov	bp, 0x1228
0ca6:01e9	mov	ds, bp
0ca6:01eb	mov	es, bp
0ca6:01ed	mov	bp, word ptr [0x541d]
0ca6:01f1	shl	bp, 1
0ca6:01f3	notrack call	word ptr ds:[bp + 0x5435]
0ca6:01f8	pop	es
0ca6:01f9	pop	ds
0ca6:01fa	pop	bp
0ca6:01fb	pop	si
0ca6:01fc	pop	di
0ca6:01fd	retf	
sub_cc41 ENDP
*/
void sub_cc41()
{
    // coverage: 0xbf71-0xbf8e method sub_cc41
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bp = 0x1228;
    ds = bp;
    es = bp;
    bp = memoryAGet16(ds, 0x541d);
    bp <<= 1;
    callIndirect(cs, memoryAGet16(ds, bp + 21557));
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:01ff sub_cc5f()
sub_cc5f PROC
0ca6:01ff	push	di
0ca6:0200	push	si
0ca6:0201	push	bp
0ca6:0202	push	ds
0ca6:0203	push	es
0ca6:0204	mov	bx, word ptr [0x541d]
0ca6:0208	shl	bx, 1
0ca6:020a	jmp	word ptr [bx + 0x545d]
        	loc_cc6e:
0ca6:020e	mov	ax, 0xd
0ca6:0211	int	0x10
0ca6:0213	jmp	loc_cc75
        	loc_cc75:
0ca6:0215	pop	es
0ca6:0216	pop	ds
0ca6:0217	pop	bp
0ca6:0218	pop	si
0ca6:0219	pop	di
0ca6:021a	retf	
sub_cc5f ENDP
*/
void sub_cc5f()
{
    // coverage: 0xbf8f-0xbfab method sub_cc5f
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    switch (bx)
    {
        // coverage: 0x16a0d-0x16a17 switch
        case 0: goto loc_cc6e;
        case 2: goto loc_cc6e;
        case 4: goto loc_cc6e;
        case 6: goto loc_cc75;
        case 8: goto loc_cc75;
        case 10: goto loc_cc75;
        default:
        assert(0);
    }
loc_cc6e:
    ax = 0x000d;
    interrupt(0x10);
loc_cc75:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:021b sub_cc7b()
sub_cc7b PROC
0ca6:021b	push	di
0ca6:021c	push	si
0ca6:021d	push	bp
0ca6:021e	push	ds
0ca6:021f	push	es
0ca6:0220	mov	bx, 0x1228
0ca6:0223	mov	ds, bx
0ca6:0225	mov	word ptr [0x5313], dx
0ca6:0229	mov	word ptr [0x5311], ax
0ca6:022c	pop	es
0ca6:022d	pop	ds
0ca6:022e	pop	bp
0ca6:022f	pop	si
0ca6:0230	pop	di
0ca6:0231	retf	
sub_cc7b ENDP
*/
void sub_cc7b()
{
    // coverage: 0xbfab-0xbfc2 method sub_cc7b
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    memoryASet16(ds, 0x5313, dx);
    memoryASet16(ds, 0x5311, ax);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:0232 sub_cc92()
sub_cc92 PROC
0ca6:0232	push	di
0ca6:0233	push	si
0ca6:0234	push	bp
0ca6:0235	push	ds
0ca6:0236	push	es
0ca6:0237	cmp	cl, 0
0ca6:023a	jne	loc_cc9e
0ca6:023c	jmp	loc_cd0b
        	loc_cc9e:
0ca6:023e	cmp	cl, 2
0ca6:0241	jg	loc_cd0b
0ca6:0243	mov	ax, 0x1228
0ca6:0246	mov	ds, ax
0ca6:0248	mov	es, ax
0ca6:024a	push	cx
0ca6:024b	mov	di, 0x5310
0ca6:024e	mov	cx, 1
0ca6:0251	cld	
0ca6:0252	xor	al, al
0ca6:0254	rep stosb	byte ptr es:[di], al
0ca6:0256	pop	cx
0ca6:0257	mov	si, 0x5415
0ca6:025a	xor	ch, ch
0ca6:025c	dec	cl
0ca6:025e	mov	bx, word ptr [0x541d]
0ca6:0262	shl	bx, 1
0ca6:0264	jmp	word ptr [bx + 0x5469]
        	loc_ccc8:
0ca6:0268	mov	word ptr [si + 2], 0xa000
0ca6:026d	mov	word ptr [si], 0
0ca6:0271	cmp	word ptr [0x541d], 5
0ca6:0276	jne	loc_cce7
0ca6:0278	mov	word ptr [si + 6], 0xa400
0ca6:027d	mov	word ptr [si + 4], 0
0ca6:0282	call	0x5ce
0ca6:0285	jmp	loc_cd0b
        	loc_cce7:
0ca6:0287	mov	word ptr [si + 6], 0xa200
0ca6:028c	mov	word ptr [si + 4], 0
0ca6:0291	jmp	loc_cd0b
0ca6:0293		
        	loc_cd0b:
0ca6:02ab	pop	es
0ca6:02ac	pop	ds
0ca6:02ad	pop	bp
0ca6:02ae	pop	si
0ca6:02af	pop	di
0ca6:02b0	retf	
sub_cc92 ENDP
*/
void sub_cc92()
{
    // coverage: 0xbfc2-0xc023 method sub_cc92
    // coverage: 0xc03b-0xc041 method sub_cc92
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    if (cl != 0x00)
        goto loc_cc9e;
    goto loc_cd0b;
loc_cc9e:
    if ((char)cl > (char)0x02)
        goto loc_cd0b;
    ax = 0x1228;
    ds = ax;
    es = ax;
    push(cx);
    di = 0x5310;
    cx = 0x0001;
    flags.direction = false;
    al = 0;
    rep_stosb<MemAuto, DirAuto>();
    cx = pop();
    si = 0x5415;
    ch = 0;
    cl--;
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    switch (bx)
    {
        // coverage: 0x16a19-0x16a1d switch
        case 0: goto loc_ccc8;
        case 2: goto loc_ccc8;
        case 4: goto loc_ccc8;
        default:
        assert(0);
    }
loc_ccc8:
    memoryASet16(ds, si + 2, 0xa000);
    memoryASet16(ds, si, 0x0000);
    if (memoryAGet16(ds, 0x541d) != 0x0005)
        goto loc_cce7;
    memoryASet16(ds, si + 6, 0xa400);
    memoryASet16(ds, si + 4, 0x0000);
    sub_d02e();
    goto loc_cd0b;
loc_cce7:
    memoryASet16(ds, si + 6, 0xa200);
    memoryASet16(ds, si + 4, 0x0000);
    goto loc_cd0b;
    //   gap of 24 bytes
loc_cd0b:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:02b1 sub_cd11()
sub_cd11 PROC
0ca6:02b1	push	di
0ca6:02b2	push	si
0ca6:02b3	push	bp
0ca6:02b4	push	ds
0ca6:02b5	push	es
0ca6:02b6	mov	ax, 0x1228
0ca6:02b9	mov	ds, ax
0ca6:02bb	mov	es, ax
0ca6:02bd	mov	bp, word ptr [0x541d]
0ca6:02c1	shl	bp, 1
0ca6:02c3	notrack call	word ptr ds:[bp + 0x5441]
0ca6:02c8	pop	es
0ca6:02c9	pop	ds
0ca6:02ca	pop	bp
0ca6:02cb	pop	si
0ca6:02cc	pop	di
0ca6:02cd	retf	
sub_cd11 ENDP
*/
void sub_cd11()
{
    // coverage: 0xc041-0xc05e method sub_cd11
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    es = ax;
    bp = memoryAGet16(ds, 0x541d);
    bp <<= 1;
    callIndirect(cs, memoryAGet16(ds, bp + 21569));
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:02ce sub_cd2e()
sub_cd2e PROC
0ca6:02ce	push	di
0ca6:02cf	push	si
0ca6:02d0	push	bp
0ca6:02d1	push	ds
0ca6:02d2	push	es
0ca6:02d3	mov	ax, 0x1228
0ca6:02d6	mov	ds, ax
0ca6:02d8	mov	ax, 2
0ca6:02db	int	0x10
0ca6:02dd	mov	si, 0x529c
0ca6:02e0	xor	bh, bh
0ca6:02e2	mov	dx, 0x101
0ca6:02e5	mov	ah, 2
0ca6:02e7	int	0x10
0ca6:02e9	mov	ah, 9
0ca6:02eb	mov	dx, si
0ca6:02ed	int	0x21
0ca6:02ef	mov	si, 0x52b4
0ca6:02f2	mov	di, 0x548b
0ca6:02f5	mov	bh, 0
0ca6:02f7	mov	cx, 6
0ca6:02fa	mov	dx, 0xa21
        	loc_cd5d:
0ca6:02fd	cmp	byte ptr [di], 1
0ca6:0300	jne	loc_cd70
0ca6:0302	mov	ah, 2
0ca6:0304	int	0x10
0ca6:0306	push	dx
0ca6:0307	mov	ah, 9
0ca6:0309	mov	dx, si
0ca6:030b	int	0x21
0ca6:030d	pop	dx
0ca6:030e	inc	dh
        	loc_cd70:
0ca6:0310	add	si, 0xf
0ca6:0313	inc	di
0ca6:0314	loop	loc_cd5d
        	loc_cd76:
0ca6:0316	mov	al, 0x3c
0ca6:0318	lcall	0x1ed, 0x7bfa
0ca6:031d	jne	loc_cd8a
0ca6:031f	mov	al, 0x3d
0ca6:0321	lcall	0x1ed, 0x7bfa
0ca6:0326	jne	loc_cd98
0ca6:0328	jmp	loc_cd76
        	loc_cd8a:
0ca6:032a	mov	word ptr [0x541d], 1
0ca6:0330	mov	word ptr [0x530e], 0x40
0ca6:0336	jmp	loc_cdab
        	loc_cd98:
0ca6:0338	mov	word ptr [0x541d], 2
0ca6:033e	mov	word ptr [0x530e], 0x40
0ca6:0344	jmp	loc_cdab
0ca6:0346		
        	loc_cdab:
0ca6:034b	pop	es
0ca6:034c	pop	ds
0ca6:034d	pop	bp
0ca6:034e	pop	si
0ca6:034f	pop	di
0ca6:0350	retf	
sub_cd2e ENDP
*/
void sub_cd2e()
{
    // coverage: 0xc05e-0xc0d6 method sub_cd2e
    // coverage: 0xc0db-0xc0e1 method sub_cd2e
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    ax = 0x0002;
    interrupt(0x10);
    si = 0x529c;
    bh = 0;
    dx = 0x0101;
    ah = 0x02;
    interrupt(0x10);
    ah = 0x09;
    dx = si;
    interrupt(0x21);
    si = 0x52b4;
    di = 0x548b;
    bh = 0x00;
    cx = 0x0006;
    dx = 0x0a21;
loc_cd5d:
    if (memoryAGet(ds, di) != 0x01)
        goto loc_cd70;
    ah = 0x02;
    interrupt(0x10);
    push(dx);
    ah = 0x09;
    dx = si;
    interrupt(0x21);
    dx = pop();
    dh++;
loc_cd70:
    si += 0x000f;
    di++;
    if (--cx)
        goto loc_cd5d;
loc_cd76:
    al = 0x3c;
    push(cs);
    cs = 0x01ed;
    sub_9aca();
    assert(cs == 0x0ca6);
    if (!flags.zero)
        goto loc_cd8a;
    al = 0x3d;
    push(cs);
    cs = 0x01ed;
    sub_9aca();
    assert(cs == 0x0ca6);
    if (!flags.zero)
        goto loc_cd98;
    goto loc_cd76;
loc_cd8a:
    memoryASet16(ds, 0x541d, 0x0001);
    memoryASet16(ds, 0x530e, 0x0040);
    goto loc_cdab;
loc_cd98:
    memoryASet16(ds, 0x541d, 0x0002);
    memoryASet16(ds, 0x530e, 0x0040);
    goto loc_cdab;
    //   gap of 5 bytes
loc_cdab:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:0351 sub_cdb1()
sub_cdb1 PROC
0ca6:0351	push	di
0ca6:0352	push	si
0ca6:0353	push	bp
0ca6:0354	push	ds
0ca6:0355	push	es
0ca6:0356	cmp	bx, 0
0ca6:0359	je	loc_cdde
0ca6:035b	cmp	bx, 1
0ca6:035e	jg	loc_cdde
0ca6:0360	mov	ax, 0x1228
0ca6:0363	mov	ds, ax
0ca6:0365	xor	cx, cx
0ca6:0367	xchg	byte ptr [bx + 0x530f], cl
0ca6:036b	mov	si, 0x5415
0ca6:036e	mov	bp, word ptr [0x541d]
0ca6:0372	shl	bp, 1
0ca6:0374	notrack jmp	word ptr ds:[bp + 0x5475]
        	loc_cdd9:
0ca6:0379	call	0x6c1
0ca6:037c	jmp	loc_cdde
        	loc_cdde:
0ca6:037e	pop	es
0ca6:037f	pop	ds
0ca6:0380	pop	bp
0ca6:0381	pop	si
0ca6:0382	pop	di
0ca6:0383	retf	
sub_cdb1 ENDP
*/
void sub_cdb1()
{
    // coverage: 0xc0e1-0xc114 method sub_cdb1
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    if (bx == 0x0000)
        goto loc_cdde;
    if ((short)bx > (short)0x0001)
        goto loc_cdde;
    ax = 0x1228;
    ds = ax;
    cx = 0;
    tl = memoryAGet(ds, bx + 21263);
    memoryASet(ds, bx + 21263, cl);
    cl = tl;
    si = 0x5415;
    bp = memoryAGet16(ds, 0x541d);
    bp <<= 1;
    switch (bp)
    {
        // coverage: 0x16a25-0x16a29 switch
        case 0: goto loc_cdd9;
        case 2: goto loc_cdd9;
        case 4: goto loc_cdd9;
        default:
        assert(0);
    }
loc_cdd9:
    sub_d121();
loc_cdde:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:0427 sub_ce87()
sub_ce87 PROC
0ca6:0427	mov	ax, word ptr es:[di + 6]
0ca6:042b	push	cx
        	loc_ce8c:
0ca6:042c	shr	cx, 1
0ca6:042e	je	loc_ce94
0ca6:0430	shl	ax, 1
0ca6:0432	jmp	loc_ce8c
        	loc_ce94:
0ca6:0434	pop	cx
0ca6:0435	test	word ptr es:[di + 0x1c], 0x200
0ca6:043b	je	loc_cea4
0ca6:043d	inc	ax
0ca6:043e	and	word ptr es:[di + 0x1c], 0xfdff
        	loc_cea4:
0ca6:0444	mov	word ptr [0x5423], ax
0ca6:0447	mov	ax, 0x14
0ca6:044a	cmp	byte ptr [0x541f], 1
0ca6:044f	je	loc_ceb5
0ca6:0451	mov	ax, word ptr es:[di + 0xa]
        	loc_ceb5:
0ca6:0455	push	cx
        	loc_ceb6:
0ca6:0456	shr	cx, 1
0ca6:0458	je	loc_cebe
0ca6:045a	shl	ax, 1
0ca6:045c	jmp	loc_ceb6
        	loc_cebe:
0ca6:045e	pop	cx
0ca6:045f	mov	word ptr [0x542b], ax
0ca6:0462	mov	ax, word ptr es:[di + 0x14]
0ca6:0466	push	cx
        	loc_cec7:
0ca6:0467	shr	cx, 1
0ca6:0469	je	loc_cecf
0ca6:046b	shl	ax, 1
0ca6:046d	jmp	loc_cec7
        	loc_cecf:
0ca6:046f	pop	cx
0ca6:0470	test	word ptr es:[di + 0x1c], 0x400
0ca6:0476	je	loc_cedf
0ca6:0478	inc	ax
0ca6:0479	and	word ptr es:[di + 0x1c], 0xfbff
        	loc_cedf:
0ca6:047f	mov	word ptr [0x5421], ax
0ca6:0482	mov	ax, 0x14
0ca6:0485	cmp	byte ptr [0x5420], 1
0ca6:048a	je	loc_cef0
0ca6:048c	mov	ax, word ptr es:[di + 0x18]
        	loc_cef0:
0ca6:0490	push	cx
        	loc_cef1:
0ca6:0491	shr	cx, 1
0ca6:0493	je	loc_cef9
0ca6:0495	shl	ax, 1
0ca6:0497	jmp	loc_cef1
        	loc_cef9:
0ca6:0499	pop	cx
0ca6:049a	mov	word ptr [0x5429], ax
0ca6:049d	mov	ax, word ptr es:[di + 0x1e]
0ca6:04a1	push	cx
        	loc_cf02:
0ca6:04a2	shr	cx, 1
0ca6:04a4	je	loc_cf0a
0ca6:04a6	shl	ax, 1
0ca6:04a8	jmp	loc_cf02
        	loc_cf0a:
0ca6:04aa	pop	cx
0ca6:04ab	mov	word ptr [0x5431], ax
0ca6:04ae	mov	cx, 8
0ca6:04b1	mov	ax, word ptr es:[di + 8]
0ca6:04b5	push	cx
        	loc_cf16:
0ca6:04b6	shr	cx, 1
0ca6:04b8	je	loc_cf1e
0ca6:04ba	shl	ax, 1
0ca6:04bc	jmp	loc_cf16
        	loc_cf1e:
0ca6:04be	pop	cx
0ca6:04bf	test	word ptr es:[di + 0x1c], 0x100
0ca6:04c5	je	loc_cf31
0ca6:04c7	add	ax, word ptr es:[di + 0x26]
0ca6:04cb	and	word ptr es:[di + 0x1c], 0xfe
        	loc_cf31:
0ca6:04d1	mov	word ptr [0x542f], ax
0ca6:04d4	mov	ax, 0x19
0ca6:04d7	cmp	byte ptr [0x541f], 1
0ca6:04dc	je	loc_cf42
0ca6:04de	mov	ax, word ptr es:[di + 0xc]
        	loc_cf42:
0ca6:04e2	push	cx
        	loc_cf43:
0ca6:04e3	shr	cx, 1
0ca6:04e5	je	loc_cf4b
0ca6:04e7	shl	ax, 1
0ca6:04e9	jmp	loc_cf43
        	loc_cf4b:
0ca6:04eb	pop	cx
0ca6:04ec	mov	word ptr [0x5427], ax
0ca6:04ef	mov	ax, word ptr es:[di + 0x16]
0ca6:04f3	push	cx
        	loc_cf54:
0ca6:04f4	shr	cx, 1
0ca6:04f6	je	loc_cf5c
0ca6:04f8	shl	ax, 1
0ca6:04fa	jmp	loc_cf54
        	loc_cf5c:
0ca6:04fc	pop	cx
0ca6:04fd	mov	word ptr [0x542d], ax
0ca6:0500	mov	ax, 0x19
0ca6:0503	cmp	byte ptr [0x5420], 1
0ca6:0508	je	loc_cf6e
0ca6:050a	mov	ax, word ptr es:[di + 0x1a]
        	loc_cf6e:
0ca6:050e	push	cx
        	loc_cf6f:
0ca6:050f	shr	cx, 1
0ca6:0511	je	loc_cf77
0ca6:0513	shl	ax, 1
0ca6:0515	jmp	loc_cf6f
        	loc_cf77:
0ca6:0517	pop	cx
0ca6:0518	mov	word ptr [0x5425], ax
0ca6:051b	mov	ax, word ptr es:[di + 0x20]
0ca6:051f	push	cx
        	loc_cf80:
0ca6:0520	shr	cx, 1
0ca6:0522	je	loc_cf88
0ca6:0524	shl	ax, 1
0ca6:0526	jmp	loc_cf80
        	loc_cf88:
0ca6:0528	pop	cx
0ca6:0529	mov	word ptr [0x5433], ax
0ca6:052c	ret	
sub_ce87 ENDP
*/
void sub_ce87()
{
    // coverage: 0xc1b7-0xc2bd method sub_ce87
    ax = memoryAGet16(es, di + 6);
    push(cx);
loc_ce8c:
    cx >>= 1;
    if (cx == 0)
        goto loc_ce94;
    ax <<= 1;
    goto loc_ce8c;
loc_ce94:
    cx = pop();
    if (!(memoryAGet16(es, di + 28) & 0x0200))
        goto loc_cea4;
    ax++;
    memoryASet16(es, di + 28, memoryAGet16(es, di + 28) & 0xfdff);
loc_cea4:
    memoryASet16(ds, 0x5423, ax);
    ax = 0x0014;
    if (memoryAGet(ds, 0x541f) == 0x01)
        goto loc_ceb5;
    ax = memoryAGet16(es, di + 10);
loc_ceb5:
    push(cx);
loc_ceb6:
    cx >>= 1;
    if (cx == 0)
        goto loc_cebe;
    ax <<= 1;
    goto loc_ceb6;
loc_cebe:
    cx = pop();
    memoryASet16(ds, 0x542b, ax);
    ax = memoryAGet16(es, di + 20);
    push(cx);
loc_cec7:
    cx >>= 1;
    if (cx == 0)
        goto loc_cecf;
    ax <<= 1;
    goto loc_cec7;
loc_cecf:
    cx = pop();
    if (!(memoryAGet16(es, di + 28) & 0x0400))
        goto loc_cedf;
    ax++;
    memoryASet16(es, di + 28, memoryAGet16(es, di + 28) & 0xfbff);
loc_cedf:
    memoryASet16(ds, 0x5421, ax);
    ax = 0x0014;
    if (memoryAGet(ds, 0x5420) == 0x01)
        goto loc_cef0;
    ax = memoryAGet16(es, di + 24);
loc_cef0:
    push(cx);
loc_cef1:
    cx >>= 1;
    if (cx == 0)
        goto loc_cef9;
    ax <<= 1;
    goto loc_cef1;
loc_cef9:
    cx = pop();
    memoryASet16(ds, 0x5429, ax);
    ax = memoryAGet16(es, di + 30);
    push(cx);
loc_cf02:
    cx >>= 1;
    if (cx == 0)
        goto loc_cf0a;
    ax <<= 1;
    goto loc_cf02;
loc_cf0a:
    cx = pop();
    memoryASet16(ds, 0x5431, ax);
    cx = 0x0008;
    ax = memoryAGet16(es, di + 8);
    push(cx);
loc_cf16:
    cx >>= 1;
    if (cx == 0)
        goto loc_cf1e;
    ax <<= 1;
    goto loc_cf16;
loc_cf1e:
    cx = pop();
    if (!(memoryAGet16(es, di + 28) & 0x0100))
        goto loc_cf31;
    ax += memoryAGet16(es, di + 38);
    memoryASet16(es, di + 28, memoryAGet16(es, di + 28) & 0x00fe);
loc_cf31:
    memoryASet16(ds, 0x542f, ax);
    ax = 0x0019;
    if (memoryAGet(ds, 0x541f) == 0x01)
        goto loc_cf42;
    ax = memoryAGet16(es, di + 12);
loc_cf42:
    push(cx);
loc_cf43:
    cx >>= 1;
    if (cx == 0)
        goto loc_cf4b;
    ax <<= 1;
    goto loc_cf43;
loc_cf4b:
    cx = pop();
    memoryASet16(ds, 0x5427, ax);
    ax = memoryAGet16(es, di + 22);
    push(cx);
loc_cf54:
    cx >>= 1;
    if (cx == 0)
        goto loc_cf5c;
    ax <<= 1;
    goto loc_cf54;
loc_cf5c:
    cx = pop();
    memoryASet16(ds, 0x542d, ax);
    ax = 0x0019;
    if (memoryAGet(ds, 0x5420) == 0x01)
        goto loc_cf6e;
    ax = memoryAGet16(es, di + 26);
loc_cf6e:
    push(cx);
loc_cf6f:
    cx >>= 1;
    if (cx == 0)
        goto loc_cf77;
    ax <<= 1;
    goto loc_cf6f;
loc_cf77:
    cx = pop();
    memoryASet16(ds, 0x5425, ax);
    ax = memoryAGet16(es, di + 32);
    push(cx);
loc_cf80:
    cx >>= 1;
    if (cx == 0)
        goto loc_cf88;
    ax <<= 1;
    goto loc_cf80;
loc_cf88:
    cx = pop();
    memoryASet16(ds, 0x5433, ax);
}
/* Assembly listing of 0ca6:052d sub_cf8d()
sub_cf8d PROC
0ca6:052d	push	ax
0ca6:052e	push	bx
0ca6:052f	push	cx
0ca6:0530	push	dx
0ca6:0531	push	bp
0ca6:0532	mov	bx, di
0ca6:0534	cmp	byte ptr [0x541f], 2
0ca6:0539	je	loc_cfd6
0ca6:053b	mov	ax, word ptr [0x542f]
0ca6:053e	mul	word ptr [0x542b]
0ca6:0542	add	ax, word ptr [0x5423]
0ca6:0546	mov	si, ax
0ca6:0548	cmp	byte ptr [0x541f], 1
0ca6:054d	jne	loc_cfbd
0ca6:054f	mov	bp, word ptr es:[bx]
0ca6:0552	shl	bp, 1
0ca6:0554	shl	bp, 1
0ca6:0556	lds	ax, ptr ds:[bp + 0x5415]
0ca6:055b	jmp	loc_cfc1
        	loc_cfbd:
0ca6:055d	lds	ax, ptr es:[bx + 2]
        	loc_cfc1:
0ca6:0561	add	si, ax
0ca6:0563	push	es
0ca6:0564	mov	ax, ds
0ca6:0566	mov	es, ax
0ca6:0568	mov	di, si
0ca6:056a	push	bx
0ca6:056b	lcall	0xec7, 0x89
0ca6:0570	pop	bx
0ca6:0571	mov	ds, dx
0ca6:0573	mov	si, ax
0ca6:0575	pop	es
        	loc_cfd6:
0ca6:0576	push	ds
0ca6:0577	mov	ax, 0x1228
0ca6:057a	mov	ds, ax
0ca6:057c	mov	ax, word ptr [0x542d]
0ca6:057f	mul	word ptr [0x5429]
0ca6:0583	add	ax, word ptr [0x5421]
0ca6:0587	mov	di, ax
0ca6:0589	cmp	byte ptr [0x5420], 1
0ca6:058e	jne	loc_d000
0ca6:0590	mov	bp, word ptr es:[bx + 0xe]
0ca6:0594	shl	bp, 1
0ca6:0596	shl	bp, 1
0ca6:0598	les	ax, ptr ds:[bp + 0x5415]
0ca6:059d	pop	ds
0ca6:059e	jmp	loc_d010
        	loc_d000:
0ca6:05a0	les	ax, ptr es:[bx + 0x10]
0ca6:05a4	pop	ds
0ca6:05a5	add	di, ax
0ca6:05a7	lcall	0xec7, 0x89
0ca6:05ac	mov	es, dx
0ca6:05ae	mov	di, ax
        	loc_d010:
0ca6:05b0	pop	bp
0ca6:05b1	pop	dx
0ca6:05b2	pop	cx
0ca6:05b3	pop	bx
0ca6:05b4	pop	ax
0ca6:05b5	ret	
sub_cf8d ENDP
*/
void sub_cf8d()
{
    // coverage: 0xc2bd-0xc346 method sub_cf8d
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    push(bp);
    bx = di;
    if (memoryAGet(ds, 0x541f) == 0x02)
        goto loc_cfd6;
    ax = memoryAGet16(ds, 0x542f);
    mul(memoryAGet16(ds, 0x542b));
    ax += memoryAGet16(ds, 0x5423);
    si = ax;
    if (memoryAGet(ds, 0x541f) != 0x01)
        goto loc_cfbd;
    bp = memoryAGet16(es, bx);
    bp <<= 1;
    bp <<= 1;
    ax = memoryAGet16(ds, bp + 21525);
    ds = memoryAGet16(ds, bp + 21525 + 2);
    goto loc_cfc1;
loc_cfbd:
    ax = memoryAGet16(es, bx + 2);
    ds = memoryAGet16(es, bx + 2 + 2);
loc_cfc1:
    si += ax;
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(bx);
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0ca6);
    bx = pop();
    ds = dx;
    si = ax;
    es = pop();
loc_cfd6:
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x542d);
    mul(memoryAGet16(ds, 0x5429));
    ax += memoryAGet16(ds, 0x5421);
    di = ax;
    if (memoryAGet(ds, 0x5420) != 0x01)
        goto loc_d000;
    bp = memoryAGet16(es, bx + 14);
    bp <<= 1;
    bp <<= 1;
    ax = memoryAGet16(ds, bp + 21525);
    es = memoryAGet16(ds, bp + 21525 + 2);
    ds = pop();
    goto loc_d010;
loc_d000:
    ax = memoryAGet16(es, bx + 16);
    es = memoryAGet16(es, bx + 16 + 2);
    ds = pop();
    di += ax;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0ca6);
    es = dx;
    di = ax;
loc_d010:
    bp = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
}
/* Assembly listing of 0ca6:05b6 sub_d016()
sub_d016 PROC
0ca6:05b6	mov	dx, bx
0ca6:05b8	shl	dx, 1
0ca6:05ba	shl	dx, 1
0ca6:05bc	mov	ax, dx
0ca6:05be	shl	ax, 1
0ca6:05c0	shl	ax, 1
0ca6:05c2	shl	ax, 1
0ca6:05c4	add	dx, ax
0ca6:05c6	shl	ax, 1
0ca6:05c8	add	ax, dx
0ca6:05ca	sub	ax, bx
0ca6:05cc	ret	
sub_d016 ENDP
*/
void sub_d016()
{
    // coverage: 0xc346-0xc35d method sub_d016
    dx = bx;
    dx <<= 1;
    dx <<= 1;
    ax = dx;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    dx += ax;
    ax <<= 1;
    ax += dx;
    ax -= bx;
}
/* Assembly listing of 0ca6:05ce sub_d02e()
sub_d02e PROC
0ca6:05ce	ret	
sub_d02e ENDP
*/
void sub_d02e()
{
    // coverage: 0xc35e-0xc35f method sub_d02e
}
/* Assembly listing of 0ca6:05cf sub_d02f()
sub_d02f PROC
0ca6:05cf	xor	ax, ax
0ca6:05d1	mov	dl, byte ptr [si + 0x22]
0ca6:05d4	test	bh, dl
0ca6:05d6	je	loc_d03a
0ca6:05d8	mov	al, 1
        	loc_d03a:
0ca6:05da	mov	dl, byte ptr [si + 0x23]
0ca6:05dd	test	bh, dl
0ca6:05df	je	loc_d043
0ca6:05e1	or	al, 2
        	loc_d043:
0ca6:05e3	mov	dl, byte ptr [si + 0x24]
0ca6:05e6	test	bh, dl
0ca6:05e8	je	loc_d04c
0ca6:05ea	or	al, 4
        	loc_d04c:
0ca6:05ec	mov	dl, byte ptr [si + 0x25]
0ca6:05ef	test	bh, dl
0ca6:05f1	je	loc_d055
0ca6:05f3	or	al, 8
        	loc_d055:
0ca6:05f5	mov	dl, al
0ca6:05f7	shl	dl, 1
0ca6:05f9	shl	dl, 1
0ca6:05fb	shl	dl, 1
0ca6:05fd	shl	dl, 1
0ca6:05ff	or	al, dl
0ca6:0601	mov	ah, al
0ca6:0603	ret	
sub_d02f ENDP
*/
void sub_d02f()
{
    // coverage: 0xc35f-0xc394 method sub_d02f
    ax = 0;
    dl = memoryAGet(ds, si + 34);
    if (!(bh & dl))
        goto loc_d03a;
    al = 0x01;
loc_d03a:
    dl = memoryAGet(ds, si + 35);
    if (!(bh & dl))
        goto loc_d043;
    al |= 0x02;
loc_d043:
    dl = memoryAGet(ds, si + 36);
    if (!(bh & dl))
        goto loc_d04c;
    al |= 0x04;
loc_d04c:
    dl = memoryAGet(ds, si + 37);
    if (!(bh & dl))
        goto loc_d055;
    al |= 0x08;
loc_d055:
    dl = al;
    dl <<= 1;
    dl <<= 1;
    dl <<= 1;
    dl <<= 1;
    al |= dl;
    ah = al;
}
/* Assembly listing of 0ca6:0605 sub_d065()
sub_d065 PROC
0ca6:0605	ret	
sub_d065 ENDP
*/
void sub_d065()
{
    // coverage: 0xc395-0xc396 method sub_d065
}
/* Assembly listing of 0ca6:0606 sub_d066()
sub_d066 PROC
0ca6:0606	mov	di, 0x5311
0ca6:0609	les	di, ptr [di]
0ca6:060b	mov	si, ax
0ca6:060d	mov	ds, dx
0ca6:060f	call	0x5b6
0ca6:0612	add	di, ax
0ca6:0614	add	di, 0x23
0ca6:0617	add	si, 0x23
0ca6:061a	mov	cx, 8
0ca6:061d	rep movsw	word ptr es:[di], word ptr [si]
0ca6:061f	ret	
sub_d066 ENDP
*/
void sub_d066()
{
    // coverage: 0xc396-0xc3b0 method sub_d066
    di = 0x5311;
    tx = di;
    di = memoryAGet16(ds, tx);
    es = memoryAGet16(ds, tx + 2);
    si = ax;
    ds = dx;
    sub_d016();
    di += ax;
    di += 0x0023;
    si += 0x0023;
    cx = 0x0008;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
}
/* Assembly listing of 0ca6:0620 sub_d080()
sub_d080 PROC
0ca6:0620	mov	di, 0x5311
0ca6:0623	les	di, ptr [di]
0ca6:0625	mov	si, ax
0ca6:0627	mov	ds, dx
0ca6:0629	call	0x5b6
0ca6:062c	add	di, ax
0ca6:062e	add	di, 0x33
0ca6:0631	add	si, 0x33
0ca6:0634	push	ds
0ca6:0635	mov	ax, 0x1228
0ca6:0638	mov	ds, ax
0ca6:063a	cmp	word ptr [0x541d], 5
0ca6:063f	jne	loc_d0a4
0ca6:0641	add	di, 0x30
        	loc_d0a4:
0ca6:0644	pop	ds
0ca6:0645	mov	cx, 0x18
0ca6:0648	rep movsw	word ptr es:[di], word ptr [si]
0ca6:064a	ret	
sub_d080 ENDP
*/
void sub_d080()
{
    // coverage: 0xc3b0-0xc3db method sub_d080
    di = 0x5311;
    tx = di;
    di = memoryAGet16(ds, tx);
    es = memoryAGet16(ds, tx + 2);
    si = ax;
    ds = dx;
    sub_d016();
    di += ax;
    di += 0x0033;
    si += 0x0033;
    push(ds);
    ax = 0x1228;
    ds = ax;
    if (memoryAGet16(ds, 0x541d) != 0x0005)
        goto loc_d0a4;
    di += 0x0030;
loc_d0a4:
    ds = pop();
    cx = 0x0018;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
}
/* Assembly listing of 0ca6:064b sub_d0ab()
sub_d0ab PROC
0ca6:064b	ret	
sub_d0ab ENDP
*/
void sub_d0ab()
{
    // coverage: 0xc3db-0xc3dc method sub_d0ab
}
/* Assembly listing of 0ca6:064c sub_d0ac()
sub_d0ac PROC
0ca6:064c	ret	
sub_d0ac ENDP
*/
void sub_d0ac()
{
    // coverage: 0xc3dc-0xc3dd method sub_d0ac
}
/* Assembly listing of 0ca6:064d sub_d0ad()
sub_d0ad PROC
0ca6:064d	mov	dx, 0x3ce
0ca6:0650	mov	cx, 7
        	loc_d0b3:
0ca6:0653	lodsw	ax, word ptr [si]
0ca6:0654	out	dx, ax
0ca6:0655	loop	loc_d0b3
0ca6:0657	mov	dx, 0x3c4
0ca6:065a	mov	ax, word ptr [si]
0ca6:065c	out	dx, ax
0ca6:065d	ret	
sub_d0ad ENDP
*/
void sub_d0ad()
{
    // coverage: 0xc3dd-0xc3ee method sub_d0ad
    dx = 0x03ce;
    cx = 0x0007;
loc_d0b3:
    lodsw<MemAuto, DirAuto>();
    out(dx, ax);
    if (--cx)
        goto loc_d0b3;
    dx = 0x03c4;
    ax = memoryAGet16(ds, si);
    out(dx, ax);
}
/* Assembly listing of 0ca6:065f sub_d0bf()
sub_d0bf PROC
0ca6:065f	ret	
sub_d0bf ENDP
*/
void sub_d0bf()
{
    // coverage: 0xc3ef-0xc3f0 method sub_d0bf
}
/* Assembly listing of 0ca6:0661 sub_d0c1()
sub_d0c1 PROC
0ca6:0661	ret	
sub_d0c1 ENDP
*/
void sub_d0c1()
{
    // coverage: 0xc3f1-0xc3f2 method sub_d0c1
}
/* Assembly listing of 0ca6:0662 sub_d0c2()
sub_d0c2 PROC
0ca6:0662	mov	si, 0x5311
0ca6:0665	les	si, ptr [si]
0ca6:0667	call	0x5b6
0ca6:066a	add	si, ax
0ca6:066c	add	si, 0x23
0ca6:066f	mov	dx, si
0ca6:0671	mov	ax, 0x1002
0ca6:0674	int	0x10
0ca6:0676	ret	
sub_d0c2 ENDP
*/
void sub_d0c2()
{
    // coverage: 0xc3f2-0xc407 method sub_d0c2
    si = 0x5311;
    tx = si;
    si = memoryAGet16(ds, tx);
    es = memoryAGet16(ds, tx + 2);
    sub_d016();
    si += ax;
    si += 0x0023;
    dx = si;
    ax = 0x1002;
    interrupt(0x10);
}
/* Assembly listing of 0ca6:0677 sub_d0d7()
sub_d0d7 PROC
0ca6:0677	mov	si, 0x5311
0ca6:067a	les	si, ptr [si]
0ca6:067c	call	0x5b6
0ca6:067f	add	si, ax
0ca6:0681	add	si, 0x33
0ca6:0684	mov	dx, 0x3c8
0ca6:0687	mov	al, 0
0ca6:0689	out	dx, al
0ca6:068a	inc	dx
0ca6:068b	mov	cx, 8
        	loc_d0ee:
0ca6:068e	mov	al, byte ptr es:[si]
0ca6:0691	out	dx, al
0ca6:0692	mov	al, byte ptr es:[si + 1]
0ca6:0696	out	dx, al
0ca6:0697	mov	al, byte ptr es:[si + 2]
0ca6:069b	out	dx, al
0ca6:069c	add	si, 3
0ca6:069f	loop	loc_d0ee
0ca6:06a1	dec	dx
0ca6:06a2	mov	al, 0x10
0ca6:06a4	out	dx, al
0ca6:06a5	inc	dx
0ca6:06a6	mov	cx, 8
        	loc_d109:
0ca6:06a9	mov	al, byte ptr es:[si]
0ca6:06ac	out	dx, al
0ca6:06ad	mov	al, byte ptr es:[si + 1]
0ca6:06b1	out	dx, al
0ca6:06b2	mov	al, byte ptr es:[si + 2]
0ca6:06b6	out	dx, al
0ca6:06b7	add	si, 3
0ca6:06ba	loop	loc_d109
0ca6:06bc	ret	
sub_d0d7 ENDP
*/
void sub_d0d7()
{
    // coverage: 0xc407-0xc44d method sub_d0d7
    si = 0x5311;
    tx = si;
    si = memoryAGet16(ds, tx);
    es = memoryAGet16(ds, tx + 2);
    sub_d016();
    si += ax;
    si += 0x0033;
    dx = 0x03c8;
    al = 0x00;
    out(dx, al);
    dx++;
    cx = 0x0008;
loc_d0ee:
    al = memoryAGet(es, si);
    out(dx, al);
    al = memoryAGet(es, si + 1);
    out(dx, al);
    al = memoryAGet(es, si + 2);
    out(dx, al);
    si += 0x0003;
    if (--cx)
        goto loc_d0ee;
    dx--;
    al = 0x10;
    out(dx, al);
    dx++;
    cx = 0x0008;
loc_d109:
    al = memoryAGet(es, si);
    out(dx, al);
    al = memoryAGet(es, si + 1);
    out(dx, al);
    al = memoryAGet(es, si + 2);
    out(dx, al);
    si += 0x0003;
    if (--cx)
        goto loc_d109;
}
/* Assembly listing of 0ca6:06bd sub_d11d()
sub_d11d PROC
0ca6:06bd	ret	
sub_d11d ENDP
*/
void sub_d11d()
{
    // coverage: 0xc44d-0xc44e method sub_d11d
}
/* Assembly listing of 0ca6:06be sub_d11e()
sub_d11e PROC
0ca6:06be	ret	
sub_d11e ENDP
*/
void sub_d11e()
{
    // coverage: 0xc44e-0xc44f method sub_d11e
}
/* Assembly listing of 0ca6:06bf sub_d11f()
sub_d11f PROC
0ca6:06bf	ret	
sub_d11f ENDP
*/
void sub_d11f()
{
    // coverage: 0xc44f-0xc450 method sub_d11f
}
/* Assembly listing of 0ca6:06c1 sub_d121()
sub_d121 PROC
0ca6:06c1	cli	
0ca6:06c2	mov	dx, 0x3d4
0ca6:06c5	mov	al, 0xc
0ca6:06c7	out	dx, al
0ca6:06c8	inc	dx
0ca6:06c9	in	al, dx
0ca6:06ca	mov	ah, 0x20
0ca6:06cc	xor	al, ah
0ca6:06ce	out	dx, al
0ca6:06cf	sti	
0ca6:06d0	shl	bx, 1
0ca6:06d2	shl	bx, 1
0ca6:06d4	mov	ax, word ptr [si + 2]
0ca6:06d7	xchg	word ptr [bx + si + 2], ax
0ca6:06da	mov	word ptr [si + 2], ax
0ca6:06dd	ret	
sub_d121 ENDP
*/
void sub_d121()
{
    // coverage: 0xc451-0xc46e method sub_d121
    flags.interrupts = false;
    dx = 0x03d4;
    al = 0x0c;
    out(dx, al);
    dx++;
    in(al, dx);
    ah = 0x20;
    al ^= ah;
    out(dx, al);
    flags.interrupts = true;
    bx <<= 1;
    bx <<= 1;
    ax = memoryAGet16(ds, si + 2);
    tx = memoryAGet16(ds, bx + si + 2);
    memoryASet16(ds, bx + si + 2, ax);
    ax = tx;
    memoryASet16(ds, si + 2, ax);
}
/* Assembly listing of 0ca6:07f0 sub_d250()
sub_d250 PROC
0ca6:07f0	mov	cx, 2
0ca6:07f3	call	0x427
0ca6:07f6	mov	ax, word ptr [0x542b]
0ca6:07f9	mul	word ptr [0x5427]
0ca6:07fd	mov	bp, ax
0ca6:07ff	mov	ax, word ptr [0x5429]
0ca6:0802	mul	word ptr [0x5425]
0ca6:0806	mov	bx, ax
0ca6:0808	mov	ax, word ptr es:[di + 0x1c]
0ca6:080c	call	0x52d
0ca6:080f	push	bx
0ca6:0810	push	ds
0ca6:0811	mov	bx, ax
0ca6:0813	mov	ax, 0x1228
0ca6:0816	mov	ds, ax
0ca6:0818	shl	bx, 1
0ca6:081a	mov	ax, word ptr [bx + 0x5536]
0ca6:081e	pop	ds
0ca6:081f	pop	bx
0ca6:0820	call	ax
0ca6:0822	ret	
sub_d250 ENDP
*/
void sub_d250()
{
    // coverage: 0xc580-0xc5b3 method sub_d250
    cx = 0x0002;
    sub_ce87();
    ax = memoryAGet16(ds, 0x542b);
    mul(memoryAGet16(ds, 0x5427));
    bp = ax;
    ax = memoryAGet16(ds, 0x5429);
    mul(memoryAGet16(ds, 0x5425));
    bx = ax;
    ax = memoryAGet16(es, di + 28);
    sub_cf8d();
    push(bx);
    push(ds);
    bx = ax;
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 21814);
    ds = pop();
    bx = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:0823 sub_d283()
sub_d283 PROC
0ca6:0823	cld	
0ca6:0824	xor	ax, ax
        	loc_d286:
0ca6:0826	call	0x858
0ca6:0829	inc	ah
0ca6:082b	cmp	ah, 3
0ca6:082e	jg	loc_d2f1
0ca6:0830	add	si, bp
0ca6:0832	add	di, bx
0ca6:0834	push	ax
0ca6:0835	push	bx
0ca6:0836	push	dx
0ca6:0837	push	di
0ca6:0838	push	es
0ca6:0839	mov	ax, ds
0ca6:083b	mov	es, ax
0ca6:083d	mov	di, si
0ca6:083f	lcall	0xec7, 0x89
0ca6:0844	mov	ds, dx
0ca6:0846	mov	si, ax
0ca6:0848	pop	es
0ca6:0849	pop	di
0ca6:084a	lcall	0xec7, 0x89
0ca6:084f	mov	es, dx
0ca6:0851	mov	di, ax
0ca6:0853	pop	dx
0ca6:0854	pop	bx
0ca6:0855	pop	ax
0ca6:0856	jmp	loc_d286
0ca6:0858		
        	loc_d2f1:
0ca6:0891	ret	
sub_d283 ENDP
*/
void sub_d283()
{
    // coverage: 0xc5b3-0xc5e8 method sub_d283
    // coverage: 0xc621-0xc622 method sub_d283
    flags.direction = false;
    ax = 0;
loc_d286:
    sub_d2b8();
    ah++;
    if ((char)ah > (char)0x03)
        return;
    si += bp;
    di += bx;
    push(ax);
    push(bx);
    push(dx);
    push(di);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0ca6);
    ds = dx;
    si = ax;
    es = pop();
    di = pop();
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0ca6);
    es = dx;
    di = ax;
    dx = pop();
    bx = pop();
    ax = pop();
    goto loc_d286;
    //   gap of 57 bytes
}
/* Assembly listing of 0ca6:0858 sub_d2b8()
sub_d2b8 PROC
0ca6:0858	push	bx
0ca6:0859	push	bp
0ca6:085a	push	si
0ca6:085b	push	di
0ca6:085c	push	ds
0ca6:085d	mov	bx, 0x1228
0ca6:0860	mov	ds, bx
0ca6:0862	mov	bx, word ptr [0x542b]
0ca6:0866	mov	bp, word ptr [0x5429]
0ca6:086a	mov	dx, word ptr [0x5433]
0ca6:086e	mov	cx, word ptr [0x5431]
0ca6:0872	mov	dh, cl
0ca6:0874	pop	ds
        	loc_d2d5:
0ca6:0875	cmp	dl, 0
0ca6:0878	je	loc_d2ec
0ca6:087a	dec	dl
0ca6:087c	shr	cx, 1
0ca6:087e	rep movsw	word ptr es:[di], word ptr [si]
0ca6:0880	mov	cl, dh
0ca6:0882	sub	si, cx
0ca6:0884	sub	di, cx
0ca6:0886	add	si, bx
0ca6:0888	add	di, bp
0ca6:088a	jmp	loc_d2d5
        	loc_d2ec:
0ca6:088c	pop	di
0ca6:088d	pop	si
0ca6:088e	pop	bp
0ca6:088f	pop	bx
0ca6:0890	ret	
sub_d2b8 ENDP
*/
void sub_d2b8()
{
    // coverage: 0xc5e8-0xc621 method sub_d2b8
    push(bx);
    push(bp);
    push(si);
    push(di);
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x542b);
    bp = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_d2d5:
    if (dl == 0x00)
        goto loc_d2ec;
    dl--;
    cx >>= 1;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
    cl = dh;
    si -= cx;
    di -= cx;
    si += bx;
    di += bp;
    goto loc_d2d5;
loc_d2ec:
    di = pop();
    si = pop();
    bp = pop();
    bx = pop();
}
/* Assembly listing of 0ca6:0892 sub_d2f2()
sub_d2f2 PROC
0ca6:0892	push	ds
0ca6:0893	mov	ax, 0x1228
0ca6:0896	mov	ds, ax
0ca6:0898	mov	ax, word ptr [0x5429]
0ca6:089b	mov	word ptr cs:[0xa9c], ax
0ca6:089f	mov	ax, word ptr [0x542b]
0ca6:08a2	mov	dx, word ptr [0x5433]
0ca6:08a6	mov	cx, word ptr [0x5431]
0ca6:08aa	mov	dh, cl
0ca6:08ac	pop	ds
0ca6:08ad	jcxz	loc_d37d
        	loc_d30f:
0ca6:08af	cmp	dl, 0
0ca6:08b2	je	loc_d37d
0ca6:08b4	dec	dl
0ca6:08b6	shr	cx, 1
0ca6:08b8	push	ax
0ca6:08b9	push	dx
        	loc_d31a:
0ca6:08ba	mov	dx, word ptr [si]
0ca6:08bc	add	si, bp
0ca6:08be	add	di, bx
0ca6:08c0	or	dx, word ptr [si]
0ca6:08c2	add	si, bp
0ca6:08c4	add	di, bx
0ca6:08c6	or	dx, word ptr [si]
0ca6:08c8	add	si, bp
0ca6:08ca	add	di, bx
0ca6:08cc	or	dx, word ptr [si]
0ca6:08ce	not	dx
0ca6:08d0	mov	ax, word ptr es:[di]
0ca6:08d3	and	ax, dx
0ca6:08d5	or	ax, word ptr [si]
0ca6:08d7	mov	word ptr es:[di], ax
0ca6:08da	sub	si, bp
0ca6:08dc	sub	di, bx
0ca6:08de	mov	ax, word ptr es:[di]
0ca6:08e1	and	ax, dx
0ca6:08e3	or	ax, word ptr [si]
0ca6:08e5	mov	word ptr es:[di], ax
0ca6:08e8	sub	si, bp
0ca6:08ea	sub	di, bx
0ca6:08ec	mov	ax, word ptr es:[di]
0ca6:08ef	and	ax, dx
0ca6:08f1	or	ax, word ptr [si]
0ca6:08f3	mov	word ptr es:[di], ax
0ca6:08f6	sub	si, bp
0ca6:08f8	sub	di, bx
0ca6:08fa	mov	ax, word ptr es:[di]
0ca6:08fd	and	ax, dx
0ca6:08ff	or	ax, word ptr [si]
0ca6:0901	mov	word ptr es:[di], ax
0ca6:0904	add	si, 2
0ca6:0907	add	di, 2
0ca6:090a	loop	loc_d31a
0ca6:090c	pop	dx
0ca6:090d	pop	ax
0ca6:090e	mov	cl, dh
0ca6:0910	sub	si, cx
0ca6:0912	sub	di, cx
0ca6:0914	add	si, ax
0ca6:0916	add	di, word ptr cs:[0xa9c]
0ca6:091b	jmp	loc_d30f
        	loc_d37d:
0ca6:091d	ret	
sub_d2f2 ENDP
*/
void sub_d2f2()
{
    // coverage: 0xc622-0xc6ae method sub_d2f2
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x5429);
    memoryASet16(cs, 0x0a9c, ax);
    ax = memoryAGet16(ds, 0x542b);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
    if (cx == 0)
        return;
loc_d30f:
    if (dl == 0x00)
        return;
    dl--;
    cx >>= 1;
    push(ax);
    push(dx);
loc_d31a:
    dx = memoryAGet16(ds, si);
    si += bp;
    di += bx;
    dx |= memoryAGet16(ds, si);
    si += bp;
    di += bx;
    dx |= memoryAGet16(ds, si);
    si += bp;
    di += bx;
    dx |= memoryAGet16(ds, si);
    dx = ~dx;
    ax = memoryAGet16(es, di);
    ax &= dx;
    ax |= memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    si -= bp;
    di -= bx;
    ax = memoryAGet16(es, di);
    ax &= dx;
    ax |= memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    si -= bp;
    di -= bx;
    ax = memoryAGet16(es, di);
    ax &= dx;
    ax |= memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    si -= bp;
    di -= bx;
    ax = memoryAGet16(es, di);
    ax &= dx;
    ax |= memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    si += 0x0002;
    di += 0x0002;
    if (--cx)
        goto loc_d31a;
    dx = pop();
    ax = pop();
    cl = dh;
    si -= cx;
    di -= cx;
    si += ax;
    di += memoryAGet16(cs, 0x0a9c);
    goto loc_d30f;
}
/* Assembly listing of 0ca6:091e sub_d37e()
sub_d37e PROC
0ca6:091e	ret	
sub_d37e ENDP
*/
void sub_d37e()
{
    // coverage: 0xc6ae-0xc6af method sub_d37e
}
/* Assembly listing of 0ca6:091f sub_d37f()
sub_d37f PROC
0ca6:091f	mov	byte ptr cs:[0x973], 0x21
0ca6:0925	jmp	loc_d395
0ca6:0927		
        	loc_d395:
0ca6:0935	xor	ax, ax
        	loc_d397:
0ca6:0937	call	0x947
0ca6:093a	inc	ah
0ca6:093c	cmp	ah, 3
0ca6:093f	jg	loc_d3ef
0ca6:0941	add	si, bp
0ca6:0943	add	di, bx
0ca6:0945	jmp	loc_d397
0ca6:0947		
        	loc_d3ef:
0ca6:098f	ret	
sub_d37f ENDP
*/
void sub_d37f()
{
    // coverage: 0xc6af-0xc6b7 method sub_d37f
    // coverage: 0xc6c5-0xc6d7 method sub_d37f
    // coverage: 0xc71f-0xc720 method sub_d37f
    memoryASet(cs, 0x0973, 0x21);
    goto loc_d395;
    //   gap of 14 bytes
loc_d395:
    ax = 0;
loc_d397:
    sub_d3a7();
    ah++;
    if ((char)ah > (char)0x03)
        return;
    si += bp;
    di += bx;
    goto loc_d397;
    //   gap of 72 bytes
}
/* Assembly listing of 0ca6:0927 sub_d387()
sub_d387 PROC
0ca6:0927	mov	byte ptr cs:[0x973], 9
0ca6:092d	jmp	loc_d395
0ca6:092f		
        	loc_d395:
0ca6:0935	xor	ax, ax
        	loc_d397:
0ca6:0937	call	0x947
0ca6:093a	inc	ah
0ca6:093c	cmp	ah, 3
0ca6:093f	jg	loc_d3ef
0ca6:0941	add	si, bp
0ca6:0943	add	di, bx
0ca6:0945	jmp	loc_d397
0ca6:0947		
        	loc_d3ef:
0ca6:098f	ret	
sub_d387 ENDP
*/
void sub_d387()
{
    // coverage: 0xc6b7-0xc6bf method sub_d387
    // coverage: 0xc6c5-0xc6d7 method sub_d387
    // coverage: 0xc71f-0xc720 method sub_d387
    memoryASet(cs, 0x0973, 0x09);
    goto loc_d395;
    //   gap of 6 bytes
loc_d395:
    ax = 0;
loc_d397:
    sub_d3a7();
    ah++;
    if ((char)ah > (char)0x03)
        return;
    si += bp;
    di += bx;
    goto loc_d397;
    //   gap of 72 bytes
}
/* Assembly listing of 0ca6:092f sub_d38f()
sub_d38f PROC
0ca6:092f	mov	byte ptr cs:[0x973], 0x31
0ca6:0935	xor	ax, ax
        	loc_d397:
0ca6:0937	call	0x947
0ca6:093a	inc	ah
0ca6:093c	cmp	ah, 3
0ca6:093f	jg	loc_d3ef
0ca6:0941	add	si, bp
0ca6:0943	add	di, bx
0ca6:0945	jmp	loc_d397
0ca6:0947		
        	loc_d3ef:
0ca6:098f	ret	
sub_d38f ENDP
*/
void sub_d38f()
{
    // coverage: 0xc6bf-0xc6d7 method sub_d38f
    // coverage: 0xc71f-0xc720 method sub_d38f
    memoryASet(cs, 0x0973, 0x31);
    ax = 0;
loc_d397:
    sub_d3a7();
    ah++;
    if ((char)ah > (char)0x03)
        return;
    si += bp;
    di += bx;
    goto loc_d397;
    //   gap of 72 bytes
}
/* Assembly listing of 0ca6:0947 sub_d3a7()
sub_d3a7 PROC
0ca6:0947	push	ax
0ca6:0948	push	bx
0ca6:0949	push	bp
0ca6:094a	push	si
0ca6:094b	push	di
0ca6:094c	push	ds
0ca6:094d	mov	bx, 0x1228
0ca6:0950	mov	ds, bx
0ca6:0952	mov	bx, word ptr [0x542b]
0ca6:0956	mov	bp, word ptr [0x5429]
0ca6:095a	mov	dx, word ptr [0x5433]
0ca6:095e	mov	cx, word ptr [0x5431]
0ca6:0962	mov	dh, cl
0ca6:0964	pop	ds
0ca6:0965	jcxz	loc_d3e9
        	loc_d3c7:
0ca6:0967	cmp	dl, 0
0ca6:096a	je	loc_d3e9
0ca6:096c	dec	dl
0ca6:096e	shr	cx, 1
        	loc_d3d0:
0ca6:0970	mov	ax, word ptr [si]
0ca6:0972	and	word ptr es:[di], ax
0ca6:0975	add	si, 2
0ca6:0978	add	di, 2
0ca6:097b	loop	loc_d3d0
0ca6:097d	mov	cl, dh
0ca6:097f	sub	si, cx
0ca6:0981	sub	di, cx
0ca6:0983	add	si, bx
0ca6:0985	add	di, bp
0ca6:0987	jmp	loc_d3c7
        	loc_d3e9:
0ca6:0989	pop	di
0ca6:098a	pop	si
0ca6:098b	pop	bp
0ca6:098c	pop	bx
0ca6:098d	pop	ax
0ca6:098e	ret	
sub_d3a7 ENDP
*/
void sub_d3a7()
{
    // coverage: 0xc6d7-0xc71f method sub_d3a7
    push(ax);
    push(bx);
    push(bp);
    push(si);
    push(di);
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x542b);
    bp = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
    if (cx == 0)
        goto loc_d3e9;
loc_d3c7:
    if (dl == 0x00)
        goto loc_d3e9;
    dl--;
    cx >>= 1;
loc_d3d0:
    ax = memoryAGet16(ds, si);
    memoryASet16(es, di, memoryAGet16(es, di) & ax);
    si += 0x0002;
    di += 0x0002;
    if (--cx)
        goto loc_d3d0;
    cl = dh;
    si -= cx;
    di -= cx;
    si += bx;
    di += bp;
    goto loc_d3c7;
loc_d3e9:
    di = pop();
    si = pop();
    bp = pop();
    bx = pop();
    ax = pop();
}
/* Assembly listing of 0ca6:0990 sub_d3f0()
sub_d3f0 PROC
0ca6:0990	ret	
sub_d3f0 ENDP
*/
void sub_d3f0()
{
    // coverage: 0xc720-0xc721 method sub_d3f0
}
/* Assembly listing of 0ca6:0991 sub_d3f1()
sub_d3f1 PROC
0ca6:0991	ret	
sub_d3f1 ENDP
*/
void sub_d3f1()
{
    // coverage: 0xc721-0xc722 method sub_d3f1
}
/* Assembly listing of 0ca6:0997 sub_d3f7()
sub_d3f7 PROC
0ca6:0997	ret	
sub_d3f7 ENDP
*/
void sub_d3f7()
{
    // coverage: 0xc727-0xc728 method sub_d3f7
}
/* Assembly listing of 0ca6:0998 sub_d3f8()
sub_d3f8 PROC
0ca6:0998	ret	
sub_d3f8 ENDP
*/
void sub_d3f8()
{
    // coverage: 0xc728-0xc729 method sub_d3f8
}
/* Assembly listing of 0ca6:0999 sub_d3f9()
sub_d3f9 PROC
0ca6:0999	ret	
sub_d3f9 ENDP
*/
void sub_d3f9()
{
    // coverage: 0xc729-0xc72a method sub_d3f9
}
/* Assembly listing of 0ca6:0a73 sub_d4d3()
sub_d4d3 PROC
0ca6:0a73	push	di
0ca6:0a74	push	si
0ca6:0a75	push	bp
0ca6:0a76	push	ds
0ca6:0a77	push	es
0ca6:0a78	cld	
0ca6:0a79	mov	bx, 0x1228
0ca6:0a7c	mov	ds, bx
0ca6:0a7e	mov	es, dx
0ca6:0a80	mov	di, ax
0ca6:0a82	mov	byte ptr [0x541f], 0
0ca6:0a87	mov	byte ptr [0x5420], 0
0ca6:0a8c	mov	bx, word ptr [0x541d]
0ca6:0a90	shl	bx, 1
0ca6:0a92	call	word ptr [bx + 0x5544]
0ca6:0a96	pop	es
0ca6:0a97	pop	ds
0ca6:0a98	pop	bp
0ca6:0a99	pop	si
0ca6:0a9a	pop	di
0ca6:0a9b	retf	
sub_d4d3 ENDP
*/
void sub_d4d3()
{
    // coverage: 0xc803-0xc82c method sub_d4d3
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    flags.direction = false;
    bx = 0x1228;
    ds = bx;
    es = dx;
    di = ax;
    memoryASet(ds, 0x541f, 0x00);
    memoryASet(ds, 0x5420, 0x00);
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 21828));
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:0aa0 sub_d500()
sub_d500 PROC
0ca6:0aa0	mov	si, 0x556a
0ca6:0aa3	call	0x64d
0ca6:0aa6	mov	cx, 2
0ca6:0aa9	call	0x427
0ca6:0aac	mov	ax, word ptr [0x542b]
0ca6:0aaf	mul	word ptr [0x5427]
0ca6:0ab3	mov	bp, ax
0ca6:0ab5	mov	bx, word ptr es:[di + 0x1c]
0ca6:0ab9	push	bx
0ca6:0aba	mov	bx, di
0ca6:0abc	call	0x52d
0ca6:0abf	pop	bx
0ca6:0ac0	push	ds
0ca6:0ac1	mov	ax, 0x1228
0ca6:0ac4	mov	ds, ax
0ca6:0ac6	shl	bx, 1
0ca6:0ac8	mov	ax, word ptr [bx + 0x5550]
0ca6:0acc	pop	ds
0ca6:0acd	call	ax
0ca6:0acf	ret	
sub_d500 ENDP
*/
void sub_d500()
{
    // coverage: 0xc830-0xc860 method sub_d500
    si = 0x556a;
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    ax = memoryAGet16(ds, 0x542b);
    mul(memoryAGet16(ds, 0x5427));
    bp = ax;
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    sub_cf8d();
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 21840);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:0ad0 sub_d530()
sub_d530 PROC
0ca6:0ad0	cld	
0ca6:0ad1	mov	dx, 0x3c4
0ca6:0ad4	mov	al, 2
0ca6:0ad6	out	dx, al
0ca6:0ad7	mov	al, 1
        	loc_d539:
0ca6:0ad9	mov	dx, 0x3c5
0ca6:0adc	out	dx, al
0ca6:0add	jmp	loc_d560
        	loc_d53f:
0ca6:0adf	shl	al, 1
0ca6:0ae1	cmp	al, 8
0ca6:0ae3	jg	loc_d592
0ca6:0ae5	add	si, bp
0ca6:0ae7	push	ax
0ca6:0ae8	push	bx
0ca6:0ae9	push	di
0ca6:0aea	push	es
0ca6:0aeb	mov	ax, ds
0ca6:0aed	mov	es, ax
0ca6:0aef	mov	di, si
0ca6:0af1	lcall	0xec7, 0x89
0ca6:0af6	mov	ds, dx
0ca6:0af8	mov	si, ax
0ca6:0afa	pop	es
0ca6:0afb	pop	di
0ca6:0afc	pop	bx
0ca6:0afd	pop	ax
0ca6:0afe	jmp	loc_d539
        	loc_d560:
0ca6:0b00	push	si
0ca6:0b01	push	di
0ca6:0b02	push	ds
0ca6:0b03	mov	bx, 0x1228
0ca6:0b06	mov	ds, bx
0ca6:0b08	mov	bx, word ptr [0x542b]
0ca6:0b0c	mov	dx, word ptr [0x5433]
0ca6:0b10	mov	cx, word ptr [0x5431]
0ca6:0b14	mov	dh, cl
0ca6:0b16	pop	ds
        	loc_d577:
0ca6:0b17	cmp	dl, ch
0ca6:0b19	je	loc_d58e
0ca6:0b1b	dec	dl
0ca6:0b1d	shr	cx, 1
0ca6:0b1f	rep movsw	word ptr es:[di], word ptr [si]
0ca6:0b21	mov	cl, dh
0ca6:0b23	sub	si, cx
0ca6:0b25	sub	di, cx
0ca6:0b27	add	si, bx
0ca6:0b29	add	di, 0x28
0ca6:0b2c	jmp	loc_d577
        	loc_d58e:
0ca6:0b2e	pop	di
0ca6:0b2f	pop	si
0ca6:0b30	jmp	loc_d53f
        	loc_d592:
0ca6:0b32	ret	
sub_d530 ENDP
*/
void sub_d530()
{
    // coverage: 0xc860-0xc8c3 method sub_d530
    flags.direction = false;
    dx = 0x03c4;
    al = 0x02;
    out(dx, al);
    al = 0x01;
loc_d539:
    dx = 0x03c5;
    out(dx, al);
    goto loc_d560;
loc_d53f:
    al <<= 1;
    if ((char)al > (char)0x08)
        return;
    si += bp;
    push(ax);
    push(bx);
    push(di);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0ca6);
    ds = dx;
    si = ax;
    es = pop();
    di = pop();
    bx = pop();
    ax = pop();
    goto loc_d539;
loc_d560:
    push(si);
    push(di);
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x542b);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_d577:
    if (dl == ch)
        goto loc_d58e;
    dl--;
    cx >>= 1;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
    cl = dh;
    si -= cx;
    di -= cx;
    si += bx;
    di += 0x0028;
    goto loc_d577;
loc_d58e:
    di = pop();
    si = pop();
    goto loc_d53f;
}
/* Assembly listing of 0ca6:0b33 sub_d593()
sub_d593 PROC
0ca6:0b33	mov	word ptr cs:[0xb81], 0x9090
0ca6:0b3a	jmp	loc_d5a3
0ca6:0b3c		
        	loc_d5a3:
0ca6:0b43	mov	dx, 0x3c4
0ca6:0b46	mov	ax, 2
0ca6:0b49	out	dx, ax
0ca6:0b4a	push	ds
0ca6:0b4b	mov	bx, 0x1228
0ca6:0b4e	mov	ds, bx
0ca6:0b50	mov	bx, word ptr [0x542b]
0ca6:0b54	mov	dx, word ptr [0x5433]
0ca6:0b58	mov	cx, word ptr [0x5431]
0ca6:0b5c	mov	dh, cl
0ca6:0b5e	pop	ds
0ca6:0b5f	jcxz	loc_d5c3
0ca6:0b61	jmp	loc_d5c6
        	loc_d5c3:
0ca6:0b63	jmp	loc_d65c
        	loc_d5c6:
0ca6:0b66	cmp	dl, ch
0ca6:0b68	jne	loc_d5cd
0ca6:0b6a	jmp	loc_d65c
        	loc_d5cd:
0ca6:0b6d	dec	dl
0ca6:0b6f	shr	cx, 1
0ca6:0b71	push	dx
        	loc_d5d2:
0ca6:0b72	mov	ax, word ptr [si]
0ca6:0b74	add	si, bp
0ca6:0b76	or	ax, word ptr [si]
0ca6:0b78	add	si, bp
0ca6:0b7a	or	ax, word ptr [si]
0ca6:0b7c	add	si, bp
0ca6:0b7e	or	ax, word ptr [si]
0ca6:0b80	push	si
0ca6:0b81	nop	
0ca6:0b82	nop	
0ca6:0b83	mov	ch, ah
0ca6:0b85	mov	ah, al
0ca6:0b87	mov	dx, 0x3ce
0ca6:0b8a	mov	al, 8
0ca6:0b8c	out	dx, ax
0ca6:0b8d	mov	al, byte ptr es:[di]
0ca6:0b90	mov	dx, 0x3c5
0ca6:0b93	mov	al, 8
0ca6:0b95	out	dx, al
0ca6:0b96	mov	ah, byte ptr [si]
0ca6:0b98	mov	byte ptr es:[di], ah
0ca6:0b9b	shr	al, 1
0ca6:0b9d	out	dx, al
0ca6:0b9e	sub	si, bp
0ca6:0ba0	mov	ah, byte ptr [si]
0ca6:0ba2	mov	byte ptr es:[di], ah
0ca6:0ba5	shr	al, 1
0ca6:0ba7	out	dx, al
0ca6:0ba8	sub	si, bp
0ca6:0baa	mov	ah, byte ptr [si]
0ca6:0bac	mov	byte ptr es:[di], ah
0ca6:0baf	shr	al, 1
0ca6:0bb1	out	dx, al
0ca6:0bb2	sub	si, bp
0ca6:0bb4	movsb	byte ptr es:[di], byte ptr [si]
0ca6:0bb5	mov	ah, ch
0ca6:0bb7	pop	si
0ca6:0bb8	inc	si
0ca6:0bb9	mov	dx, 0x3ce
0ca6:0bbc	mov	al, 8
0ca6:0bbe	out	dx, ax
0ca6:0bbf	mov	al, byte ptr es:[di]
0ca6:0bc2	mov	dx, 0x3c5
0ca6:0bc5	mov	al, 8
0ca6:0bc7	out	dx, al
0ca6:0bc8	mov	ah, byte ptr [si]
0ca6:0bca	mov	byte ptr es:[di], ah
0ca6:0bcd	shr	al, 1
0ca6:0bcf	out	dx, al
0ca6:0bd0	sub	si, bp
0ca6:0bd2	mov	ah, byte ptr [si]
0ca6:0bd4	mov	byte ptr es:[di], ah
0ca6:0bd7	shr	al, 1
0ca6:0bd9	out	dx, al
0ca6:0bda	sub	si, bp
0ca6:0bdc	mov	ah, byte ptr [si]
0ca6:0bde	mov	byte ptr es:[di], ah
0ca6:0be1	shr	al, 1
0ca6:0be3	out	dx, al
0ca6:0be4	sub	si, bp
0ca6:0be6	movsb	byte ptr es:[di], byte ptr [si]
0ca6:0be7	dec	cl
0ca6:0be9	jne	loc_d5d2
0ca6:0beb	pop	dx
0ca6:0bec	xor	ch, ch
0ca6:0bee	mov	cl, dh
0ca6:0bf0	sub	si, cx
0ca6:0bf2	sub	di, cx
0ca6:0bf4	add	si, bx
0ca6:0bf6	add	di, 0x28
0ca6:0bf9	jmp	loc_d5c6
        	loc_d65c:
0ca6:0bfc	ret	
sub_d593 ENDP
*/
void sub_d593()
{
    // coverage: 0xc8c3-0xc8cc method sub_d593
    // coverage: 0xc8d3-0xc98d method sub_d593
    memoryASet16(cs, 0x0b81, 0x9090);
    goto loc_d5a3;
    //   gap of 7 bytes
loc_d5a3:
    dx = 0x03c4;
    ax = 0x0002;
    out(dx, ax);
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x542b);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
    if (cx == 0)
        goto loc_d5c3;
    goto loc_d5c6;
loc_d5c3:
    return;
loc_d5c6:
    if (dl != ch)
        goto loc_d5cd;
    return;
loc_d5cd:
    dl--;
    cx >>= 1;
    push(dx);
loc_d5d2:
    ax = memoryAGet16(ds, si);
    si += bp;
    ax |= memoryAGet16(ds, si);
    si += bp;
    ax |= memoryAGet16(ds, si);
    si += bp;
    ax |= memoryAGet16(ds, si);
    push(si);
    ch = ah;
    ah = al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    al = memoryAGet(es, di);
    dx = 0x03c5;
    al = 0x08;
    out(dx, al);
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    movsb<MemAuto, MemAuto, DirAuto>();
    ah = ch;
    si = pop();
    si++;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    al = memoryAGet(es, di);
    dx = 0x03c5;
    al = 0x08;
    out(dx, al);
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    movsb<MemAuto, MemAuto, DirAuto>();
    tl = cl;
    cl--;
    if (tl != 1)
        goto loc_d5d2;
    dx = pop();
    ch = 0;
    cl = dh;
    si -= cx;
    di -= cx;
    si += bx;
    di += 0x0028;
    goto loc_d5c6;
}
/* Assembly listing of 0ca6:0b3c sub_d59c()
sub_d59c PROC
0ca6:0b3c	mov	word ptr cs:[0xb81], 0xd0f7
0ca6:0b43	mov	dx, 0x3c4
0ca6:0b46	mov	ax, 2
0ca6:0b49	out	dx, ax
0ca6:0b4a	push	ds
0ca6:0b4b	mov	bx, 0x1228
0ca6:0b4e	mov	ds, bx
0ca6:0b50	mov	bx, word ptr [0x542b]
0ca6:0b54	mov	dx, word ptr [0x5433]
0ca6:0b58	mov	cx, word ptr [0x5431]
0ca6:0b5c	mov	dh, cl
0ca6:0b5e	pop	ds
0ca6:0b5f	jcxz	loc_d5c3
0ca6:0b61	jmp	loc_d5c6
        	loc_d5c3:
0ca6:0b63	jmp	loc_d65c
        	loc_d5c6:
0ca6:0b66	cmp	dl, ch
0ca6:0b68	jne	loc_d5cd
0ca6:0b6a	jmp	loc_d65c
        	loc_d5cd:
0ca6:0b6d	dec	dl
0ca6:0b6f	shr	cx, 1
0ca6:0b71	push	dx
        	loc_d5d2:
0ca6:0b72	mov	ax, word ptr [si]
0ca6:0b74	add	si, bp
0ca6:0b76	or	ax, word ptr [si]
0ca6:0b78	add	si, bp
0ca6:0b7a	or	ax, word ptr [si]
0ca6:0b7c	add	si, bp
0ca6:0b7e	or	ax, word ptr [si]
0ca6:0b80	push	si
0ca6:0b81	nop	
0ca6:0b82	nop	
0ca6:0b83	mov	ch, ah
0ca6:0b85	mov	ah, al
0ca6:0b87	mov	dx, 0x3ce
0ca6:0b8a	mov	al, 8
0ca6:0b8c	out	dx, ax
0ca6:0b8d	mov	al, byte ptr es:[di]
0ca6:0b90	mov	dx, 0x3c5
0ca6:0b93	mov	al, 8
0ca6:0b95	out	dx, al
0ca6:0b96	mov	ah, byte ptr [si]
0ca6:0b98	mov	byte ptr es:[di], ah
0ca6:0b9b	shr	al, 1
0ca6:0b9d	out	dx, al
0ca6:0b9e	sub	si, bp
0ca6:0ba0	mov	ah, byte ptr [si]
0ca6:0ba2	mov	byte ptr es:[di], ah
0ca6:0ba5	shr	al, 1
0ca6:0ba7	out	dx, al
0ca6:0ba8	sub	si, bp
0ca6:0baa	mov	ah, byte ptr [si]
0ca6:0bac	mov	byte ptr es:[di], ah
0ca6:0baf	shr	al, 1
0ca6:0bb1	out	dx, al
0ca6:0bb2	sub	si, bp
0ca6:0bb4	movsb	byte ptr es:[di], byte ptr [si]
0ca6:0bb5	mov	ah, ch
0ca6:0bb7	pop	si
0ca6:0bb8	inc	si
0ca6:0bb9	mov	dx, 0x3ce
0ca6:0bbc	mov	al, 8
0ca6:0bbe	out	dx, ax
0ca6:0bbf	mov	al, byte ptr es:[di]
0ca6:0bc2	mov	dx, 0x3c5
0ca6:0bc5	mov	al, 8
0ca6:0bc7	out	dx, al
0ca6:0bc8	mov	ah, byte ptr [si]
0ca6:0bca	mov	byte ptr es:[di], ah
0ca6:0bcd	shr	al, 1
0ca6:0bcf	out	dx, al
0ca6:0bd0	sub	si, bp
0ca6:0bd2	mov	ah, byte ptr [si]
0ca6:0bd4	mov	byte ptr es:[di], ah
0ca6:0bd7	shr	al, 1
0ca6:0bd9	out	dx, al
0ca6:0bda	sub	si, bp
0ca6:0bdc	mov	ah, byte ptr [si]
0ca6:0bde	mov	byte ptr es:[di], ah
0ca6:0be1	shr	al, 1
0ca6:0be3	out	dx, al
0ca6:0be4	sub	si, bp
0ca6:0be6	movsb	byte ptr es:[di], byte ptr [si]
0ca6:0be7	dec	cl
0ca6:0be9	jne	loc_d5d2
0ca6:0beb	pop	dx
0ca6:0bec	xor	ch, ch
0ca6:0bee	mov	cl, dh
0ca6:0bf0	sub	si, cx
0ca6:0bf2	sub	di, cx
0ca6:0bf4	add	si, bx
0ca6:0bf6	add	di, 0x28
0ca6:0bf9	jmp	loc_d5c6
        	loc_d65c:
0ca6:0bfc	ret	
sub_d59c ENDP
*/
void sub_d59c()
{
    // coverage: 0xc8cc-0xc98d method sub_d59c
    memoryASet16(cs, 0x0b81, 0xd0f7);
    dx = 0x03c4;
    ax = 0x0002;
    out(dx, ax);
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x542b);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
    if (cx == 0)
        goto loc_d5c3;
    goto loc_d5c6;
loc_d5c3:
    return;
loc_d5c6:
    if (dl != ch)
        goto loc_d5cd;
    return;
loc_d5cd:
    dl--;
    cx >>= 1;
    push(dx);
loc_d5d2:
    ax = memoryAGet16(ds, si);
    si += bp;
    ax |= memoryAGet16(ds, si);
    si += bp;
    ax |= memoryAGet16(ds, si);
    si += bp;
    ax |= memoryAGet16(ds, si);
    push(si);
    ch = ah;
    ah = al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    al = memoryAGet(es, di);
    dx = 0x03c5;
    al = 0x08;
    out(dx, al);
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    movsb<MemAuto, MemAuto, DirAuto>();
    ah = ch;
    si = pop();
    si++;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    al = memoryAGet(es, di);
    dx = 0x03c5;
    al = 0x08;
    out(dx, al);
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    ah = memoryAGet(ds, si);
    memoryASet(es, di, ah);
    al >>= 1;
    out(dx, al);
    si -= bp;
    movsb<MemAuto, MemAuto, DirAuto>();
    tl = cl;
    cl--;
    if (tl != 1)
        goto loc_d5d2;
    dx = pop();
    ch = 0;
    cl = dh;
    si -= cx;
    di -= cx;
    si += bx;
    di += 0x0028;
    goto loc_d5c6;
}
/* Assembly listing of 0ca6:0bfd sub_d65d()
sub_d65d PROC
0ca6:0bfd	mov	byte ptr cs:[0xc63], 0x21
0ca6:0c03	jmp	loc_d673
0ca6:0c05		
        	loc_d673:
0ca6:0c13	mov	dx, 0x3ce
0ca6:0c16	mov	al, 4
0ca6:0c18	out	dx, al
0ca6:0c19	mov	dx, 0x3c4
0ca6:0c1c	mov	al, 2
0ca6:0c1e	out	dx, al
0ca6:0c1f	mov	al, 0
0ca6:0c21	mov	ah, 1
        	loc_d683:
0ca6:0c23	mov	dx, 0x3cf
0ca6:0c26	out	dx, al
0ca6:0c27	xchg	ah, al
0ca6:0c29	mov	dx, 0x3c5
0ca6:0c2c	out	dx, al
0ca6:0c2d	xchg	al, ah
0ca6:0c2f	call	0xc3e
0ca6:0c32	inc	al
0ca6:0c34	shl	ah, 1
0ca6:0c36	cmp	al, 3
0ca6:0c38	jg	loc_d6de
0ca6:0c3a	add	si, bp
0ca6:0c3c	jmp	loc_d683
0ca6:0c3e		
        	loc_d6de:
0ca6:0c7e	ret	
sub_d65d ENDP
*/
void sub_d65d()
{
    // coverage: 0xc98d-0xc995 method sub_d65d
    // coverage: 0xc9a3-0xc9ce method sub_d65d
    // coverage: 0xca0e-0xca0f method sub_d65d
    memoryASet(cs, 0x0c63, 0x21);
    goto loc_d673;
    //   gap of 14 bytes
loc_d673:
    dx = 0x03ce;
    al = 0x04;
    out(dx, al);
    dx = 0x03c4;
    al = 0x02;
    out(dx, al);
    al = 0x00;
    ah = 0x01;
loc_d683:
    dx = 0x03cf;
    out(dx, al);
    tl = ah;
    ah = al;
    al = tl;
    dx = 0x03c5;
    out(dx, al);
    tl = al;
    al = ah;
    ah = tl;
    sub_d69e();
    al++;
    ah <<= 1;
    if ((char)al > (char)0x03)
        return;
    si += bp;
    goto loc_d683;
    //   gap of 64 bytes
}
/* Assembly listing of 0ca6:0c05 sub_d665()
sub_d665 PROC
0ca6:0c05	mov	byte ptr cs:[0xc63], 9
0ca6:0c0b	jmp	loc_d673
0ca6:0c0d		
        	loc_d673:
0ca6:0c13	mov	dx, 0x3ce
0ca6:0c16	mov	al, 4
0ca6:0c18	out	dx, al
0ca6:0c19	mov	dx, 0x3c4
0ca6:0c1c	mov	al, 2
0ca6:0c1e	out	dx, al
0ca6:0c1f	mov	al, 0
0ca6:0c21	mov	ah, 1
        	loc_d683:
0ca6:0c23	mov	dx, 0x3cf
0ca6:0c26	out	dx, al
0ca6:0c27	xchg	ah, al
0ca6:0c29	mov	dx, 0x3c5
0ca6:0c2c	out	dx, al
0ca6:0c2d	xchg	al, ah
0ca6:0c2f	call	0xc3e
0ca6:0c32	inc	al
0ca6:0c34	shl	ah, 1
0ca6:0c36	cmp	al, 3
0ca6:0c38	jg	loc_d6de
0ca6:0c3a	add	si, bp
0ca6:0c3c	jmp	loc_d683
0ca6:0c3e		
        	loc_d6de:
0ca6:0c7e	ret	
sub_d665 ENDP
*/
void sub_d665()
{
    // coverage: 0xc995-0xc99d method sub_d665
    // coverage: 0xc9a3-0xc9ce method sub_d665
    // coverage: 0xca0e-0xca0f method sub_d665
    memoryASet(cs, 0x0c63, 0x09);
    goto loc_d673;
    //   gap of 6 bytes
loc_d673:
    dx = 0x03ce;
    al = 0x04;
    out(dx, al);
    dx = 0x03c4;
    al = 0x02;
    out(dx, al);
    al = 0x00;
    ah = 0x01;
loc_d683:
    dx = 0x03cf;
    out(dx, al);
    tl = ah;
    ah = al;
    al = tl;
    dx = 0x03c5;
    out(dx, al);
    tl = al;
    al = ah;
    ah = tl;
    sub_d69e();
    al++;
    ah <<= 1;
    if ((char)al > (char)0x03)
        return;
    si += bp;
    goto loc_d683;
    //   gap of 64 bytes
}
/* Assembly listing of 0ca6:0c0d sub_d66d()
sub_d66d PROC
0ca6:0c0d	mov	byte ptr cs:[0xc63], 0x31
0ca6:0c13	mov	dx, 0x3ce
0ca6:0c16	mov	al, 4
0ca6:0c18	out	dx, al
0ca6:0c19	mov	dx, 0x3c4
0ca6:0c1c	mov	al, 2
0ca6:0c1e	out	dx, al
0ca6:0c1f	mov	al, 0
0ca6:0c21	mov	ah, 1
        	loc_d683:
0ca6:0c23	mov	dx, 0x3cf
0ca6:0c26	out	dx, al
0ca6:0c27	xchg	ah, al
0ca6:0c29	mov	dx, 0x3c5
0ca6:0c2c	out	dx, al
0ca6:0c2d	xchg	al, ah
0ca6:0c2f	call	0xc3e
0ca6:0c32	inc	al
0ca6:0c34	shl	ah, 1
0ca6:0c36	cmp	al, 3
0ca6:0c38	jg	loc_d6de
0ca6:0c3a	add	si, bp
0ca6:0c3c	jmp	loc_d683
0ca6:0c3e		
        	loc_d6de:
0ca6:0c7e	ret	
sub_d66d ENDP
*/
void sub_d66d()
{
    // coverage: 0xc99d-0xc9ce method sub_d66d
    // coverage: 0xca0e-0xca0f method sub_d66d
    memoryASet(cs, 0x0c63, 0x31);
    dx = 0x03ce;
    al = 0x04;
    out(dx, al);
    dx = 0x03c4;
    al = 0x02;
    out(dx, al);
    al = 0x00;
    ah = 0x01;
loc_d683:
    dx = 0x03cf;
    out(dx, al);
    tl = ah;
    ah = al;
    al = tl;
    dx = 0x03c5;
    out(dx, al);
    tl = al;
    al = ah;
    ah = tl;
    sub_d69e();
    al++;
    ah <<= 1;
    if ((char)al > (char)0x03)
        return;
    si += bp;
    goto loc_d683;
    //   gap of 64 bytes
}
/* Assembly listing of 0ca6:0c3e sub_d69e()
sub_d69e PROC
0ca6:0c3e	push	ax
0ca6:0c3f	push	si
0ca6:0c40	push	di
0ca6:0c41	push	ds
0ca6:0c42	mov	ax, 0x1228
0ca6:0c45	mov	ds, ax
0ca6:0c47	mov	bx, word ptr [0x542b]
0ca6:0c4b	mov	dx, word ptr [0x5433]
0ca6:0c4f	mov	cx, word ptr [0x5431]
0ca6:0c53	mov	dh, cl
0ca6:0c55	pop	ds
0ca6:0c56	jcxz	loc_d6da
        	loc_d6b8:
0ca6:0c58	cmp	dl, ch
0ca6:0c5a	je	loc_d6da
0ca6:0c5c	dec	dl
0ca6:0c5e	shr	cx, 1
        	loc_d6c0:
0ca6:0c60	mov	ax, word ptr [si]
0ca6:0c62	and	word ptr es:[di], ax
0ca6:0c65	add	si, 2
0ca6:0c68	add	di, 2
0ca6:0c6b	loop	loc_d6c0
0ca6:0c6d	mov	cl, dh
0ca6:0c6f	sub	si, cx
0ca6:0c71	sub	di, cx
0ca6:0c73	add	si, bx
0ca6:0c75	add	di, 0x28
0ca6:0c78	jmp	loc_d6b8
        	loc_d6da:
0ca6:0c7a	pop	di
0ca6:0c7b	pop	si
0ca6:0c7c	pop	ax
0ca6:0c7d	ret	
sub_d69e ENDP
*/
void sub_d69e()
{
    // coverage: 0xc9ce-0xca0e method sub_d69e
    push(ax);
    push(si);
    push(di);
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx = memoryAGet16(ds, 0x542b);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
    if (cx == 0)
        goto loc_d6da;
loc_d6b8:
    if (dl == ch)
        goto loc_d6da;
    dl--;
    cx >>= 1;
loc_d6c0:
    ax = memoryAGet16(ds, si);
    memoryASet16(es, di, memoryAGet16(es, di) & ax);
    si += 0x0002;
    di += 0x0002;
    if (--cx)
        goto loc_d6c0;
    cl = dh;
    si -= cx;
    di -= cx;
    si += bx;
    di += 0x0028;
    goto loc_d6b8;
loc_d6da:
    di = pop();
    si = pop();
    ax = pop();
}
/* Assembly listing of 0ca6:0c7f sub_d6df()
sub_d6df PROC
0ca6:0c7f	ret	
sub_d6df ENDP
*/
void sub_d6df()
{
    // coverage: 0xca0f-0xca10 method sub_d6df
}
/* Assembly listing of 0ca6:0c80 sub_d6e0()
sub_d6e0 PROC
0ca6:0c80	ret	
sub_d6e0 ENDP
*/
void sub_d6e0()
{
    // coverage: 0xca10-0xca11 method sub_d6e0
}
/* Assembly listing of 0ca6:0c86 sub_d6e6()
sub_d6e6 PROC
0ca6:0c86	ret	
sub_d6e6 ENDP
*/
void sub_d6e6()
{
    // coverage: 0xca16-0xca17 method sub_d6e6
}
/* Assembly listing of 0ca6:0c87 sub_d6e7()
sub_d6e7 PROC
0ca6:0c87	ret	
sub_d6e7 ENDP
*/
void sub_d6e7()
{
    // coverage: 0xca17-0xca18 method sub_d6e7
}
/* Assembly listing of 0ca6:0c88 sub_d6e8()
sub_d6e8 PROC
0ca6:0c88	ret	
sub_d6e8 ENDP
*/
void sub_d6e8()
{
    // coverage: 0xca18-0xca19 method sub_d6e8
}
/* Assembly listing of 0ca6:0d77 sub_d7d7()
sub_d7d7 PROC
0ca6:0d77	push	di
0ca6:0d78	push	si
0ca6:0d79	push	bp
0ca6:0d7a	push	ds
0ca6:0d7b	push	es
0ca6:0d7c	mov	bx, 0x1228
0ca6:0d7f	mov	ds, bx
0ca6:0d81	mov	es, dx
0ca6:0d83	mov	di, ax
0ca6:0d85	mov	bp, word ptr es:[di + 0xe]
0ca6:0d89	cmp	bp, 1
0ca6:0d8c	jg	loc_d802
0ca6:0d8e	mov	byte ptr [0x541f], 0
0ca6:0d93	mov	byte ptr [0x5420], 1
0ca6:0d98	mov	bx, word ptr [0x541d]
0ca6:0d9c	shl	bx, 1
0ca6:0d9e	call	word ptr [bx + 0x555e]
        	loc_d802:
0ca6:0da2	pop	es
0ca6:0da3	pop	ds
0ca6:0da4	pop	bp
0ca6:0da5	pop	si
0ca6:0da6	pop	di
0ca6:0da7	retf	
sub_d7d7 ENDP
*/
void sub_d7d7()
{
    // coverage: 0xcb07-0xcb38 method sub_d7d7
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    es = dx;
    di = ax;
    bp = memoryAGet16(es, di + 14);
    if ((short)bp > (short)0x0001)
        goto loc_d802;
    memoryASet(ds, 0x541f, 0x00);
    memoryASet(ds, 0x5420, 0x01);
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 21854));
loc_d802:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:0db0 sub_d810()
sub_d810 PROC
0ca6:0db0	mov	si, 0x56a4
0ca6:0db3	call	0x64d
0ca6:0db6	mov	cx, 2
0ca6:0db9	call	0x427
0ca6:0dbc	mov	ax, word ptr [0x5429]
0ca6:0dbf	mul	word ptr [0x5425]
0ca6:0dc3	mov	bp, ax
0ca6:0dc5	mov	bx, word ptr es:[di + 0x1c]
0ca6:0dc9	push	bx
0ca6:0dca	mov	bx, di
0ca6:0dcc	call	0x52d
0ca6:0dcf	pop	bx
0ca6:0dd0	push	ds
0ca6:0dd1	mov	ax, 0x1228
0ca6:0dd4	mov	ds, ax
0ca6:0dd6	shl	bx, 1
0ca6:0dd8	mov	ax, word ptr [bx + 0x568a]
0ca6:0ddc	pop	ds
0ca6:0ddd	call	ax
0ca6:0ddf	ret	
sub_d810 ENDP
*/
void sub_d810()
{
    // coverage: 0xcb40-0xcb70 method sub_d810
    si = 0x56a4;
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    ax = memoryAGet16(ds, 0x5429);
    mul(memoryAGet16(ds, 0x5425));
    bp = ax;
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    sub_cf8d();
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 22154);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:0de0 sub_d840()
sub_d840 PROC
0ca6:0de0	cld	
0ca6:0de1	mov	dx, 0x3ce
0ca6:0de4	mov	al, 4
0ca6:0de6	out	dx, al
0ca6:0de7	mov	al, 0
        	loc_d849:
0ca6:0de9	mov	dx, 0x3cf
0ca6:0dec	out	dx, al
0ca6:0ded	call	0xe09
0ca6:0df0	inc	al
0ca6:0df2	cmp	al, 3
0ca6:0df4	jg	loc_d89b
0ca6:0df6	add	di, bp
0ca6:0df8	push	ax
0ca6:0df9	push	bx
0ca6:0dfa	push	dx
0ca6:0dfb	lcall	0xec7, 0x89
0ca6:0e00	mov	es, dx
0ca6:0e02	mov	di, ax
0ca6:0e04	pop	dx
0ca6:0e05	pop	bx
0ca6:0e06	pop	ax
0ca6:0e07	jmp	loc_d849
0ca6:0e09		
        	loc_d89b:
0ca6:0e3b	ret	
sub_d840 ENDP
*/
void sub_d840()
{
    // coverage: 0xcb70-0xcb99 method sub_d840
    // coverage: 0xcbcb-0xcbcc method sub_d840
    flags.direction = false;
    dx = 0x03ce;
    al = 0x04;
    out(dx, al);
    al = 0x00;
loc_d849:
    dx = 0x03cf;
    out(dx, al);
    sub_d869();
    al++;
    if ((char)al > (char)0x03)
        return;
    di += bp;
    push(ax);
    push(bx);
    push(dx);
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0ca6);
    es = dx;
    di = ax;
    dx = pop();
    bx = pop();
    ax = pop();
    goto loc_d849;
    //   gap of 50 bytes
}
/* Assembly listing of 0ca6:0e09 sub_d869()
sub_d869 PROC
0ca6:0e09	push	si
0ca6:0e0a	push	di
0ca6:0e0b	push	ds
0ca6:0e0c	mov	bx, 0x1228
0ca6:0e0f	mov	ds, bx
0ca6:0e11	mov	bx, word ptr [0x5429]
0ca6:0e15	mov	dx, word ptr [0x5433]
0ca6:0e19	mov	cx, word ptr [0x5431]
0ca6:0e1d	mov	dh, cl
0ca6:0e1f	pop	ds
        	loc_d880:
0ca6:0e20	cmp	dl, 0
0ca6:0e23	je	loc_d898
0ca6:0e25	dec	dl
0ca6:0e27	shr	cx, 1
0ca6:0e29	rep movsw	word ptr es:[di], word ptr [si]
0ca6:0e2b	mov	cl, dh
0ca6:0e2d	sub	si, cx
0ca6:0e2f	sub	di, cx
0ca6:0e31	add	si, 0x28
0ca6:0e34	add	di, bx
0ca6:0e36	jmp	loc_d880
        	loc_d898:
0ca6:0e38	pop	di
0ca6:0e39	pop	si
0ca6:0e3a	ret	
sub_d869 ENDP
*/
void sub_d869()
{
    // coverage: 0xcb99-0xcbcb method sub_d869
    push(si);
    push(di);
    push(ds);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x5429);
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_d880:
    if (dl == 0x00)
        goto loc_d898;
    dl--;
    cx >>= 1;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
    cl = dh;
    si -= cx;
    di -= cx;
    si += 0x0028;
    di += bx;
    goto loc_d880;
loc_d898:
    di = pop();
    si = pop();
}
/* Assembly listing of 0ca6:0ec3 sub_d923()
sub_d923 PROC
0ca6:0ec3	ret	
sub_d923 ENDP
*/
void sub_d923()
{
    // coverage: 0xcc53-0xcc54 method sub_d923
}
/* Assembly listing of 0ca6:0f35 sub_d995()
sub_d995 PROC
0ca6:0f35	ret	
sub_d995 ENDP
*/
void sub_d995()
{
    // coverage: 0xccc5-0xccc6 method sub_d995
}
/* Assembly listing of 0ca6:1028 sub_da88()
sub_da88 PROC
0ca6:1028	push	di
0ca6:1029	push	si
0ca6:102a	push	bp
0ca6:102b	push	ds
0ca6:102c	push	es
0ca6:102d	mov	bx, 0x1228
0ca6:1030	mov	ds, bx
0ca6:1032	mov	es, dx
0ca6:1034	mov	di, ax
0ca6:1036	mov	bp, word ptr es:[di]
0ca6:1039	cmp	bp, 1
0ca6:103c	jg	loc_dab2
0ca6:103e	mov	byte ptr [0x541f], 1
0ca6:1043	mov	byte ptr [0x5420], 0
0ca6:1048	mov	bx, word ptr [0x541d]
0ca6:104c	shl	bx, 1
0ca6:104e	call	word ptr [bx + 0x5698]
        	loc_dab2:
0ca6:1052	pop	es
0ca6:1053	pop	ds
0ca6:1054	pop	bp
0ca6:1055	pop	si
0ca6:1056	pop	di
0ca6:1057	retf	
sub_da88 ENDP
*/
void sub_da88()
{
    // coverage: 0xcdb8-0xcde8 method sub_da88
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    es = dx;
    di = ax;
    bp = memoryAGet16(es, di);
    if ((short)bp > (short)0x0001)
        goto loc_dab2;
    memoryASet(ds, 0x541f, 0x01);
    memoryASet(ds, 0x5420, 0x00);
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 22168));
loc_dab2:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:1060 sub_dac0()
sub_dac0 PROC
0ca6:1060	mov	si, 0x56ce
0ca6:1063	call	0x64d
0ca6:1066	mov	cx, 2
0ca6:1069	call	0x427
0ca6:106c	mov	bx, word ptr es:[di + 0x1c]
0ca6:1070	push	bx
0ca6:1071	mov	bx, di
0ca6:1073	call	0x52d
0ca6:1076	pop	bx
0ca6:1077	push	ds
0ca6:1078	mov	ax, 0x1228
0ca6:107b	mov	ds, ax
0ca6:107d	shl	bx, 1
0ca6:107f	mov	ax, word ptr [bx + 0x56b4]
0ca6:1083	pop	ds
0ca6:1084	call	ax
0ca6:1086	ret	
sub_dac0 ENDP
*/
void sub_dac0()
{
    // coverage: 0xcdf0-0xce17 method sub_dac0
    si = 0x56ce;
    sub_d0ad();
    cx = 0x0002;
    sub_ce87();
    bx = memoryAGet16(es, di + 28);
    push(bx);
    bx = di;
    sub_cf8d();
    bx = pop();
    push(ds);
    ax = 0x1228;
    ds = ax;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 22196);
    ds = pop();
    callIndirect(cs, ax);
}
/* Assembly listing of 0ca6:1087 sub_dae7()
sub_dae7 PROC
0ca6:1087	cld	
0ca6:1088	mov	dx, 0x3c4
0ca6:108b	mov	ax, 0xf02
0ca6:108e	out	dx, ax
0ca6:108f	push	ds
0ca6:1090	mov	ax, 0x1228
0ca6:1093	mov	ds, ax
0ca6:1095	mov	dx, word ptr [0x5433]
0ca6:1099	mov	cx, word ptr [0x5431]
0ca6:109d	mov	dh, cl
0ca6:109f	pop	ds
        	loc_db00:
0ca6:10a0	cmp	dl, 0
0ca6:10a3	je	loc_db17
0ca6:10a5	dec	dl
0ca6:10a7	rep movsb	byte ptr es:[di], byte ptr [si]
0ca6:10a9	mov	cl, dh
0ca6:10ab	sub	si, cx
0ca6:10ad	sub	di, cx
0ca6:10af	add	si, 0x28
0ca6:10b2	add	di, 0x28
0ca6:10b5	jmp	loc_db00
        	loc_db17:
0ca6:10b7	ret	
sub_dae7 ENDP
*/
void sub_dae7()
{
    // coverage: 0xce17-0xce48 method sub_dae7
    flags.direction = false;
    dx = 0x03c4;
    ax = 0x0f02;
    out(dx, ax);
    push(ds);
    ax = 0x1228;
    ds = ax;
    dx = memoryAGet16(ds, 0x5433);
    cx = memoryAGet16(ds, 0x5431);
    dh = cl;
    ds = pop();
loc_db00:
    if (dl == 0x00)
        return;
    dl--;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    cl = dh;
    si -= cx;
    di -= cx;
    si += 0x0028;
    di += 0x0028;
    goto loc_db00;
}
/* Assembly listing of 0ca6:11d6 sub_dc36()
sub_dc36 PROC
0ca6:11d6	ret	
sub_dc36 ENDP
*/
void sub_dc36()
{
    // coverage: 0xcf66-0xcf67 method sub_dc36
}
/* Assembly listing of 0ca6:11dc sub_dc3c()
sub_dc3c PROC
0ca6:11dc	ret	
sub_dc3c ENDP
*/
void sub_dc3c()
{
    // coverage: 0xcf6c-0xcf6d method sub_dc3c
}
/* Assembly listing of 0ca6:11dd sub_dc3d()
sub_dc3d PROC
0ca6:11dd	ret	
sub_dc3d ENDP
*/
void sub_dc3d()
{
    // coverage: 0xcf6d-0xcf6e method sub_dc3d
}
/* Assembly listing of 0ca6:11de sub_dc3e()
sub_dc3e PROC
0ca6:11de	ret	
sub_dc3e ENDP
*/
void sub_dc3e()
{
    // coverage: 0xcf6e-0xcf6f method sub_dc3e
}
/* Assembly listing of 0ca6:126e sub_dcce()
sub_dcce PROC
0ca6:126e	push	di
0ca6:126f	push	si
0ca6:1270	push	bp
0ca6:1271	push	ds
0ca6:1272	push	es
0ca6:1273	mov	bx, 0x1228
0ca6:1276	mov	ds, bx
0ca6:1278	mov	es, dx
0ca6:127a	mov	di, ax
0ca6:127c	mov	bx, word ptr es:[di]
0ca6:127f	cmp	bx, 1
0ca6:1282	jg	loc_dd01
0ca6:1284	mov	bp, word ptr es:[di + 0xe]
0ca6:1288	cmp	bp, 1
0ca6:128b	jg	loc_dd01
0ca6:128d	mov	byte ptr [0x541f], 1
0ca6:1292	mov	byte ptr [0x5420], 1
0ca6:1297	mov	si, word ptr [0x541d]
0ca6:129b	shl	si, 1
0ca6:129d	call	word ptr [si + 0x56c2]
        	loc_dd01:
0ca6:12a1	pop	es
0ca6:12a2	pop	ds
0ca6:12a3	pop	bp
0ca6:12a4	pop	si
0ca6:12a5	pop	di
0ca6:12a6	retf	
sub_dcce ENDP
*/
void sub_dcce()
{
    // coverage: 0xcffe-0xd037 method sub_dcce
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    es = dx;
    di = ax;
    bx = memoryAGet16(es, di);
    if ((short)bx > (short)0x0001)
        goto loc_dd01;
    bp = memoryAGet16(es, di + 14);
    if ((short)bp > (short)0x0001)
        goto loc_dd01;
    memoryASet(ds, 0x541f, 0x01);
    memoryASet(ds, 0x5420, 0x01);
    si = memoryAGet16(ds, 0x541d);
    si <<= 1;
    callIndirect(cs, memoryAGet16(ds, si + 22210));
loc_dd01:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:1311 sub_dd71()
sub_dd71 PROC
0ca6:1311	push	di
0ca6:1312	push	si
0ca6:1313	push	bp
0ca6:1314	push	ds
0ca6:1315	push	es
0ca6:1316	mov	bx, 0x1228
0ca6:1319	mov	ds, bx
0ca6:131b	mov	bx, word ptr [0x541d]
0ca6:131f	shl	bx, 1
0ca6:1321	call	word ptr [bx + 0x6946]
0ca6:1325	pop	es
0ca6:1326	pop	ds
0ca6:1327	pop	bp
0ca6:1328	pop	si
0ca6:1329	pop	di
0ca6:132a	retf	
sub_dd71 ENDP
*/
void sub_dd71()
{
    // coverage: 0xd0a1-0xd0bb method sub_dd71
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 26950));
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:132b sub_dd8b()
sub_dd8b PROC
0ca6:132b	push	di
0ca6:132c	push	si
0ca6:132d	push	bp
0ca6:132e	push	ds
0ca6:132f	push	es
0ca6:1330	mov	bx, 0x1228
0ca6:1333	mov	ds, bx
0ca6:1335	mov	word ptr [0x68a4], dx
0ca6:1339	mov	word ptr [0x68a2], ax
0ca6:133c	mov	di, 0x68a2
0ca6:133f	mov	bx, word ptr [di + 2]
0ca6:1342	mov	es, bx
0ca6:1344	mov	di, word ptr [di]
0ca6:1346	mov	al, byte ptr es:[di + 3]
0ca6:134a	add	al, 2
0ca6:134c	mov	byte ptr [0x693e], al
0ca6:134f	pop	es
0ca6:1350	pop	ds
0ca6:1351	pop	bp
0ca6:1352	pop	si
0ca6:1353	pop	di
0ca6:1354	retf	
sub_dd8b ENDP
*/
void sub_dd8b()
{
    // coverage: 0xd0bb-0xd0e5 method sub_dd8b
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    memoryASet16(ds, 0x68a4, dx);
    memoryASet16(ds, 0x68a2, ax);
    di = 0x68a2;
    bx = memoryAGet16(ds, di + 2);
    es = bx;
    di = memoryAGet16(ds, di);
    al = memoryAGet(es, di + 3);
    al += 0x02;
    memoryASet(ds, 0x693e, al);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:137b sub_dddb()
sub_dddb PROC
0ca6:137b	push	di
0ca6:137c	push	si
0ca6:137d	push	bp
0ca6:137e	push	ds
0ca6:137f	push	es
0ca6:1380	mov	ax, 0x1228
0ca6:1383	mov	ds, ax
0ca6:1385	mov	ax, 0xa
0ca6:1388	mov	dx, 0xa
0ca6:138b	push	cs
0ca6:138c	call	0x1441
0ca6:138f	mov	ax, 0
0ca6:1392	mov	bx, 0
0ca6:1395	mov	cx, 0x13f
0ca6:1398	mov	dx, 0xc7
0ca6:139b	push	cs
0ca6:139c	call	0x1422
0ca6:139f	mov	bx, 0
0ca6:13a2	push	cs
0ca6:13a3	call	0x1409
0ca6:13a6	mov	al, 8
0ca6:13a8	push	cs
0ca6:13a9	call	0x1458
0ca6:13ac	mov	ax, 0xf
0ca6:13af	mov	dx, 0
0ca6:13b2	push	cs
0ca6:13b3	call	0x1311
0ca6:13b6	pop	es
0ca6:13b7	pop	ds
0ca6:13b8	pop	bp
0ca6:13b9	pop	si
0ca6:13ba	pop	di
0ca6:13bb	retf	
sub_dddb ENDP
*/
void sub_dddb()
{
    // coverage: 0xd10b-0xd14c method sub_dddb
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    ax = 0x000a;
    dx = 0x000a;
    push(cs);
    sub_dea1();
    ax = 0x0000;
    bx = 0x0000;
    cx = 0x013f;
    dx = 0x00c7;
    push(cs);
    sub_de82();
    bx = 0x0000;
    push(cs);
    sub_de69();
    al = 0x08;
    push(cs);
    sub_deb8();
    ax = 0x000f;
    dx = 0x0000;
    push(cs);
    sub_dd71();
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:13bc sub_de1c()
sub_de1c PROC
0ca6:13bc	push	di
0ca6:13bd	push	si
0ca6:13be	push	bp
0ca6:13bf	push	ds
0ca6:13c0	push	es
0ca6:13c1	cld	
0ca6:13c2	mov	bx, 0x1228
0ca6:13c5	mov	ds, bx
0ca6:13c7	mov	di, 0x68a2
0ca6:13ca	mov	bx, word ptr [di + 2]
0ca6:13cd	mov	es, bx
0ca6:13cf	mov	di, word ptr [di]
0ca6:13d1	cmp	al, byte ptr es:[di]
0ca6:13d4	jb	loc_de46
0ca6:13d6	cmp	al, byte ptr es:[di + 1]
0ca6:13da	jae	loc_de46
0ca6:13dc	mov	bx, word ptr [0x541d]
0ca6:13e0	shl	bx, 1
0ca6:13e2	call	word ptr [bx + 0x6952]
        	loc_de46:
0ca6:13e6	pop	es
0ca6:13e7	pop	ds
0ca6:13e8	pop	bp
0ca6:13e9	pop	si
0ca6:13ea	pop	di
0ca6:13eb	retf	
sub_de1c ENDP
*/
void sub_de1c()
{
    // coverage: 0xd14c-0xd17c method sub_de1c
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    flags.direction = false;
    bx = 0x1228;
    ds = bx;
    di = 0x68a2;
    bx = memoryAGet16(ds, di + 2);
    es = bx;
    di = memoryAGet16(ds, di);
    if (al < memoryAGet(es, di))
        goto loc_de46;
    if (al >= memoryAGet(es, di + 1))
        goto loc_de46;
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 26962));
loc_de46:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:13ec sub_de4c()
sub_de4c PROC
0ca6:13ec	push	di
0ca6:13ed	push	si
0ca6:13ee	push	bp
0ca6:13ef	push	ds
0ca6:13f0	push	es
0ca6:13f1	cld	
0ca6:13f2	mov	ds, dx
0ca6:13f4	mov	si, ax
        	loc_de56:
0ca6:13f6	mov	al, byte ptr [si]
0ca6:13f8	cmp	al, 0
0ca6:13fa	je	loc_de63
0ca6:13fc	push	cs
0ca6:13fd	call	0x13bc
0ca6:1400	inc	si
0ca6:1401	jmp	loc_de56
        	loc_de63:
0ca6:1403	pop	es
0ca6:1404	pop	ds
0ca6:1405	pop	bp
0ca6:1406	pop	si
0ca6:1407	pop	di
0ca6:1408	retf	
sub_de4c ENDP
*/
void sub_de4c()
{
    // coverage: 0xd17c-0xd199 method sub_de4c
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    flags.direction = false;
    ds = dx;
    si = ax;
loc_de56:
    al = memoryAGet(ds, si);
    if (al == 0x00)
        goto loc_de63;
    push(cs);
    sub_de1c();
    si++;
    goto loc_de56;
loc_de63:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:1409 sub_de69()
sub_de69 PROC
0ca6:1409	push	di
0ca6:140a	push	si
0ca6:140b	push	bp
0ca6:140c	push	ds
0ca6:140d	push	es
0ca6:140e	cmp	bx, 1
0ca6:1411	jg	loc_de7c
0ca6:1413	mov	ax, 0x1228
0ca6:1416	mov	ds, ax
0ca6:1418	mov	word ptr [0x6940], bx
        	loc_de7c:
0ca6:141c	pop	es
0ca6:141d	pop	ds
0ca6:141e	pop	bp
0ca6:141f	pop	si
0ca6:1420	pop	di
0ca6:1421	retf	
sub_de69 ENDP
*/
void sub_de69()
{
    // coverage: 0xd199-0xd1b2 method sub_de69
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    if ((short)bx > (short)0x0001)
        goto loc_de7c;
    ax = 0x1228;
    ds = ax;
    memoryASet16(ds, 0x6940, bx);
loc_de7c:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:1422 sub_de82()
sub_de82 PROC
0ca6:1422	push	di
0ca6:1423	push	si
0ca6:1424	push	bp
0ca6:1425	push	ds
0ca6:1426	push	es
0ca6:1427	mov	bp, 0x1228
0ca6:142a	mov	ds, bp
0ca6:142c	mov	word ptr [0x6936], ax
0ca6:142f	mov	word ptr [0x6938], bx
0ca6:1433	mov	word ptr [0x693a], cx
0ca6:1437	mov	word ptr [0x693c], dx
0ca6:143b	pop	es
0ca6:143c	pop	ds
0ca6:143d	pop	bp
0ca6:143e	pop	si
0ca6:143f	pop	di
0ca6:1440	retf	
sub_de82 ENDP
*/
void sub_de82()
{
    // coverage: 0xd1b2-0xd1d1 method sub_de82
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bp = 0x1228;
    ds = bp;
    memoryASet16(ds, 0x6936, ax);
    memoryASet16(ds, 0x6938, bx);
    memoryASet16(ds, 0x693a, cx);
    memoryASet16(ds, 0x693c, dx);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:1441 sub_dea1()
sub_dea1 PROC
0ca6:1441	push	di
0ca6:1442	push	si
0ca6:1443	push	bp
0ca6:1444	push	ds
0ca6:1445	push	es
0ca6:1446	mov	bx, 0x1228
0ca6:1449	mov	ds, bx
0ca6:144b	mov	word ptr [0x6944], dx
0ca6:144f	mov	word ptr [0x6942], ax
0ca6:1452	pop	es
0ca6:1453	pop	ds
0ca6:1454	pop	bp
0ca6:1455	pop	si
0ca6:1456	pop	di
0ca6:1457	retf	
sub_dea1 ENDP
*/
void sub_dea1()
{
    // coverage: 0xd1d1-0xd1e8 method sub_dea1
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    memoryASet16(ds, 0x6944, dx);
    memoryASet16(ds, 0x6942, ax);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:1458 sub_deb8()
sub_deb8 PROC
0ca6:1458	push	di
0ca6:1459	push	si
0ca6:145a	push	bp
0ca6:145b	push	ds
0ca6:145c	push	es
0ca6:145d	mov	bx, 0x1228
0ca6:1460	mov	ds, bx
0ca6:1462	mov	byte ptr [0x693e], al
0ca6:1465	pop	es
0ca6:1466	pop	ds
0ca6:1467	pop	bp
0ca6:1468	pop	si
0ca6:1469	pop	di
0ca6:146a	retf	
sub_deb8 ENDP
*/
void sub_deb8()
{
    // coverage: 0xd1e8-0xd1fb method sub_deb8
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    memoryASet(ds, 0x693e, al);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ca6:148e sub_deee()
sub_deee PROC
0ca6:148e	mov	si, 0x695e
0ca6:1491	mov	word ptr [si], 0x68b6
0ca6:1495	mov	word ptr [si + 2], ds
0ca6:1498	mov	bp, word ptr [0x6940]
0ca6:149c	shl	bp, 1
0ca6:149e	shl	bp, 1
0ca6:14a0	add	ax, word ptr ds:[bp + 0x5415]
0ca6:14a5	mov	word ptr [si + 8], ax
0ca6:14a8	mov	ax, word ptr ds:[bp + 0x5417]
0ca6:14ad	mov	word ptr [si + 0xa], ax
0ca6:14b0	xor	ax, ax
0ca6:14b2	mov	al, bl
0ca6:14b4	mov	word ptr [si + 0xc], ax
0ca6:14b7	mov	al, bh
0ca6:14b9	mov	word ptr [si + 0xe], ax
0ca6:14bc	mov	al, cl
0ca6:14be	mov	word ptr [si + 0x10], ax
0ca6:14c1	mov	al, ch
0ca6:14c3	mov	word ptr [si + 0x12], ax
0ca6:14c6	mov	byte ptr [si + 0x16], dl
0ca6:14c9	mov	dx, ds
0ca6:14cb	mov	ax, si
0ca6:14cd	lcall	0xed9, 0x2d15
0ca6:14d2	ret	
sub_deee ENDP
*/
void sub_deee()
{
    // coverage: 0xd21e-0xd263 method sub_deee
    si = 0x695e;
    memoryASet16(ds, si, 0x68b6);
    memoryASet16(ds, si + 2, ds);
    bp = memoryAGet16(ds, 0x6940);
    bp <<= 1;
    bp <<= 1;
    ax += memoryAGet16(ds, bp + 21525);
    memoryASet16(ds, si + 8, ax);
    ax = memoryAGet16(ds, bp + 21527);
    memoryASet16(ds, si + 10, ax);
    ax = 0;
    al = bl;
    memoryASet16(ds, si + 12, ax);
    al = bh;
    memoryASet16(ds, si + 14, ax);
    al = cl;
    memoryASet16(ds, si + 16, ax);
    al = ch;
    memoryASet16(ds, si + 18, ax);
    memoryASet(ds, si + 22, dl);
    dx = ds;
    ax = si;
    push(cs);
    cs = 0x0ed9;
    sub_11aa5();
    assert(cs == 0x0ca6);
}
/* Assembly listing of 0ca6:14d3 sub_df33()
sub_df33 PROC
0ca6:14d3	sub	al, byte ptr es:[di]
0ca6:14d6	xor	ah, ah
0ca6:14d8	shl	ax, 1
0ca6:14da	mov	bx, es
0ca6:14dc	mov	ds, bx
0ca6:14de	mov	si, di
0ca6:14e0	add	si, 6
0ca6:14e3	add	si, ax
0ca6:14e5	mov	ax, word ptr [si]
0ca6:14e7	xchg	al, ah
0ca6:14e9	add	ax, di
0ca6:14eb	mov	si, ax
0ca6:14ed	ret	
sub_df33 ENDP
*/
void sub_df33()
{
    // coverage: 0xd263-0xd27e method sub_df33
    al -= memoryAGet(es, di);
    ah = 0;
    ax <<= 1;
    bx = es;
    ds = bx;
    si = di;
    si += 0x0006;
    si += ax;
    ax = memoryAGet16(ds, si);
    tl = al;
    al = ah;
    ah = tl;
    ax += di;
    si = ax;
}
/* Assembly listing of 0ca6:14ef sub_df4f()
sub_df4f PROC
0ca6:14ef	mov	si, 0x68a6
0ca6:14f2	call	0x14ff
0ca6:14f5	mov	si, 0x68ae
0ca6:14f8	mov	ax, dx
0ca6:14fa	call	0x14ff
0ca6:14fd	jmp	loc_df8d
0ca6:14ff		
        	loc_df8d:
0ca6:152d	ret	
sub_df4f ENDP
*/
void sub_df4f()
{
    // coverage: 0xd27f-0xd28f method sub_df4f
    // coverage: 0xd2bd-0xd2be method sub_df4f
    si = 0x68a6;
    sub_df5f();
    si = 0x68ae;
    ax = dx;
    sub_df5f();
    return;
    //   gap of 46 bytes
}
/* Assembly listing of 0ca6:14ff sub_df5f()
sub_df5f PROC
0ca6:14ff	mov	word ptr [si], 0
0ca6:1503	mov	word ptr [si + 2], 0
0ca6:1508	test	ax, 1
0ca6:150b	je	loc_df70
0ca6:150d	mov	byte ptr [si], 0xff
        	loc_df70:
0ca6:1510	test	ax, 2
0ca6:1513	je	loc_df79
0ca6:1515	mov	byte ptr [si + 1], 0xff
        	loc_df79:
0ca6:1519	test	ax, 4
0ca6:151c	je	loc_df84
0ca6:151e	mov	byte ptr [si + 2], 0xff
0ca6:1522	je	loc_df84
        	loc_df84:
0ca6:1524	test	ax, 8
0ca6:1527	je	loc_df8d
0ca6:1529	mov	byte ptr [si + 3], 0xff
        	loc_df8d:
0ca6:152d	ret	
sub_df5f ENDP
*/
void sub_df5f()
{
    // coverage: 0xd28f-0xd2be method sub_df5f
    memoryASet16(ds, si, 0x0000);
    memoryASet16(ds, si + 2, 0x0000);
    if (!(ax & 0x0001))
        goto loc_df70;
    memoryASet(ds, si, 0xff);
loc_df70:
    if (!(ax & 0x0002))
        goto loc_df79;
    memoryASet(ds, si + 1, 0xff);
loc_df79:
    if (!(ax & 0x0004))
        goto loc_df84;
    memoryASet(ds, si + 2, 0xff);
    if (!(ax & 0x0004))
        goto loc_df84;
loc_df84:
    if (!(ax & 0x0008))
        return;
    memoryASet(ds, si + 3, 0xff);
}
/* Assembly listing of 0ca6:1530 sub_df90()
sub_df90 PROC
0ca6:1530	push	ax
0ca6:1531	push	dx
0ca6:1532	cmp	ax, word ptr [0x6936]
0ca6:1536	jl	loc_dfbb
0ca6:1538	add	al, bh
0ca6:153a	jae	loc_df9e
0ca6:153c	inc	ah
        	loc_df9e:
0ca6:153e	dec	ax
0ca6:153f	cmp	ax, word ptr [0x693a]
0ca6:1543	jg	loc_dfbb
0ca6:1545	cmp	dx, word ptr [0x6938]
0ca6:1549	jl	loc_dfbb
0ca6:154b	add	dl, bl
0ca6:154d	jae	loc_dfb1
0ca6:154f	inc	dh
        	loc_dfb1:
0ca6:1551	dec	dx
0ca6:1552	cmp	dx, word ptr [0x693c]
0ca6:1556	jg	loc_dfbb
0ca6:1558	clc	
0ca6:1559	jmp	loc_dfbc
        	loc_dfbb:
0ca6:155b	stc	
        	loc_dfbc:
0ca6:155c	pop	dx
0ca6:155d	pop	ax
0ca6:155e	ret	
sub_df90 ENDP
*/
void sub_df90()
{
    // coverage: 0xd2c0-0xd2ef method sub_df90
    push(ax);
    push(dx);
    if ((short)ax < (short)memoryAGet16(ds, 0x6936))
        goto loc_dfbb;
    flags.carry = (al + bh) >= 0x100;
    al += bh;
    if (!flags.carry)
        goto loc_df9e;
    ah++;
loc_df9e:
    ax--;
    if ((short)ax > (short)memoryAGet16(ds, 0x693a))
        goto loc_dfbb;
    if ((short)dx < (short)memoryAGet16(ds, 0x6938))
        goto loc_dfbb;
    flags.carry = (dl + bl) >= 0x100;
    dl += bl;
    if (!flags.carry)
        goto loc_dfb1;
    dh++;
loc_dfb1:
    dx--;
    if ((short)dx > (short)memoryAGet16(ds, 0x693c))
        goto loc_dfbb;
    flags.carry = false;
    goto loc_dfbc;
loc_dfbb:
    flags.carry = true;
loc_dfbc:
    dx = pop();
    ax = pop();
}
/* Assembly listing of 0ca6:155f sub_dfbf()
sub_dfbf PROC
0ca6:155f	push	ax
0ca6:1560	push	bx
0ca6:1561	push	cx
0ca6:1562	push	dx
0ca6:1563	push	bp
0ca6:1564	push	di
0ca6:1565	push	si
0ca6:1566	push	ds
0ca6:1567	push	es
0ca6:1568	mov	si, 0x68ae
0ca6:156b	mov	di, 0x68b6
0ca6:156e	mov	cx, 0x80
0ca6:1571	shr	cx, 1
0ca6:1573	shr	cx, 1
        	loc_dfd5:
0ca6:1575	mov	ax, word ptr [si]
0ca6:1577	mov	word ptr [di], ax
0ca6:1579	mov	ax, word ptr [si + 2]
0ca6:157c	mov	word ptr [di + 2], ax
0ca6:157f	add	di, 4
0ca6:1582	loop	loc_dfd5
0ca6:1584	pop	es
0ca6:1585	pop	ds
0ca6:1586	pop	si
0ca6:1587	pop	di
0ca6:1588	pop	bp
0ca6:1589	pop	dx
0ca6:158a	pop	cx
0ca6:158b	pop	bx
0ca6:158c	pop	ax
0ca6:158d	ret	
sub_dfbf ENDP
*/
void sub_dfbf()
{
    // coverage: 0xd2ef-0xd31e method sub_dfbf
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    push(bp);
    push(di);
    push(si);
    push(ds);
    push(es);
    si = 0x68ae;
    di = 0x68b6;
    cx = 0x0080;
    cx >>= 1;
    cx >>= 1;
loc_dfd5:
    ax = memoryAGet16(ds, si);
    memoryASet16(ds, di, ax);
    ax = memoryAGet16(ds, si + 2);
    memoryASet16(ds, di + 2, ax);
    di += 0x0004;
    if (--cx)
        goto loc_dfd5;
    es = pop();
    ds = pop();
    si = pop();
    di = pop();
    bp = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
}
/* Assembly listing of 0ca6:158e sub_dfee()
sub_dfee PROC
0ca6:158e	call	0x155f
0ca6:1591	call	0x14d3
0ca6:1594	mov	al, byte ptr es:[di + 2]
0ca6:1598	mov	bl, byte ptr es:[di + 3]
0ca6:159c	mov	bh, byte ptr [si]
0ca6:159e	mov	cl, bh
0ca6:15a0	add	bh, byte ptr es:[di + 4]
0ca6:15a4	mov	dl, byte ptr [si + 1]
0ca6:15a7	mov	dh, byte ptr [si + 2]
0ca6:15aa	add	si, 3
0ca6:15ad	push	ds
0ca6:15ae	mov	bp, 0x1228
0ca6:15b1	mov	ds, bp
0ca6:15b3	mov	es, bp
0ca6:15b5	mov	bp, 0x68a6
0ca6:15b8	mov	di, 0x68b6
0ca6:15bb	pop	ds
0ca6:15bc	ret	
sub_dfee ENDP
*/
void sub_dfee()
{
    // coverage: 0xd31e-0xd34d method sub_dfee
    sub_dfbf();
    sub_df33();
    al = memoryAGet(es, di + 2);
    bl = memoryAGet(es, di + 3);
    bh = memoryAGet(ds, si);
    cl = bh;
    bh += memoryAGet(es, di + 4);
    dl = memoryAGet(ds, si + 1);
    dh = memoryAGet(ds, si + 2);
    si += 0x0003;
    push(ds);
    bp = 0x1228;
    ds = bp;
    es = bp;
    bp = 0x68a6;
    di = 0x68b6;
    ds = pop();
}
/* Assembly listing of 0ca6:15bd sub_e01d()
sub_e01d PROC
0ca6:15bd	push	ax
0ca6:15be	push	bx
0ca6:15bf	push	cx
0ca6:15c0	push	dx
0ca6:15c1	push	bp
0ca6:15c2	push	di
0ca6:15c3	push	si
0ca6:15c4	push	ds
0ca6:15c5	push	es
0ca6:15c6	xor	ch, ch
0ca6:15c8	shr	cx, 1
0ca6:15ca	shr	cx, 1
0ca6:15cc	shr	cx, 1
0ca6:15ce	shl	cx, 1
0ca6:15d0	shl	cx, 1
0ca6:15d2	add	di, cx
0ca6:15d4	mov	cl, bh
0ca6:15d6	and	cl, 7
0ca6:15d9	xor	al, al
0ca6:15db	jcxz	loc_e05c
        	loc_e03d:
0ca6:15dd	stc	
0ca6:15de	rcr	al, 1
0ca6:15e0	loop	loc_e03d
0ca6:15e2	mov	cx, 4
        	loc_e045:
0ca6:15e5	cmp	bl, 0
0ca6:15e8	je	loc_e05c
0ca6:15ea	dec	bl
        	loc_e04c:
0ca6:15ec	and	byte ptr es:[di], al
0ca6:15ef	inc	di
0ca6:15f0	loop	loc_e04c
0ca6:15f2	mov	cx, 4
0ca6:15f5	sub	di, cx
0ca6:15f7	add	di, 8
0ca6:15fa	jmp	loc_e045
        	loc_e05c:
0ca6:15fc	pop	es
0ca6:15fd	pop	ds
0ca6:15fe	pop	si
0ca6:15ff	pop	di
0ca6:1600	pop	bp
0ca6:1601	pop	dx
0ca6:1602	pop	cx
0ca6:1603	pop	bx
0ca6:1604	pop	ax
0ca6:1605	ret	
sub_e01d ENDP
*/
void sub_e01d()
{
    // coverage: 0xd34d-0xd396 method sub_e01d
    push(ax);
    push(bx);
    push(cx);
    push(dx);
    push(bp);
    push(di);
    push(si);
    push(ds);
    push(es);
    ch = 0;
    cx >>= 1;
    cx >>= 1;
    cx >>= 1;
    cx <<= 1;
    cx <<= 1;
    di += cx;
    cl = bh;
    cl &= 0x07;
    al = 0;
    if (cx == 0)
        goto loc_e05c;
loc_e03d:
    flags.carry = true;
    al = rcr(al, 0x01);
    if (--cx)
        goto loc_e03d;
    cx = 0x0004;
loc_e045:
    if (bl == 0x00)
        goto loc_e05c;
    bl--;
loc_e04c:
    memoryASet(es, di, memoryAGet(es, di) & al);
    di++;
    if (--cx)
        goto loc_e04c;
    cx = 0x0004;
    di -= cx;
    di += 0x0008;
    goto loc_e045;
loc_e05c:
    es = pop();
    ds = pop();
    si = pop();
    di = pop();
    bp = pop();
    dx = pop();
    cx = pop();
    bx = pop();
    ax = pop();
}
/* Assembly listing of 0ca6:1606 sub_e066()
sub_e066 PROC
0ca6:1606	ret	
sub_e066 ENDP
*/
void sub_e066()
{
    // coverage: 0xd396-0xd397 method sub_e066
}
/* Assembly listing of 0ca6:1607 sub_e067()
sub_e067 PROC
0ca6:1607	call	0x158e
0ca6:160a	cmp	cl, 0
0ca6:160d	jne	loc_e072
0ca6:160f	jmp	loc_e13d
        	loc_e072:
0ca6:1612	push	ax
0ca6:1613	call	0x15bd
0ca6:1616	mov	al, 8
0ca6:1618	mul	dh
0ca6:161a	xor	ah, ah
0ca6:161c	add	di, ax
0ca6:161e	xor	ch, ch
0ca6:1620	dec	cl
0ca6:1622	shr	cx, 1
0ca6:1624	shr	cx, 1
0ca6:1626	shr	cx, 1
0ca6:1628	inc	cx
0ca6:1629	mov	dh, cl
0ca6:162b	push	bx
        	loc_e08c:
0ca6:162c	cmp	dl, 0
0ca6:162f	je	loc_e0ea
0ca6:1631	dec	dl
0ca6:1633	push	di
0ca6:1634	push	dx
        	loc_e095:
0ca6:1635	mov	al, byte ptr [si]
0ca6:1637	mov	bl, al
0ca6:1639	mov	bh, al
0ca6:163b	mov	ax, word ptr es:[bp]
0ca6:163f	and	ax, bx
0ca6:1641	mov	dx, ax
0ca6:1643	mov	ax, word ptr es:[bp + 2]
0ca6:1647	and	ax, bx
0ca6:1649	or	dx, ax
0ca6:164b	or	dh, dl
0ca6:164d	mov	dl, dh
0ca6:164f	not	dx
0ca6:1651	cmp	dx, -1
0ca6:1654	je	loc_e0d2
0ca6:1656	mov	ax, word ptr es:[bp]
0ca6:165a	and	ax, bx
0ca6:165c	and	word ptr es:[di], dx
0ca6:165f	or	word ptr es:[di], ax
0ca6:1662	mov	ax, word ptr es:[bp + 2]
0ca6:1666	and	ax, bx
0ca6:1668	and	word ptr es:[di + 2], dx
0ca6:166c	or	word ptr es:[di + 2], ax
0ca6:1670	jmp	loc_e0db
        	loc_e0d2:
0ca6:1672	not	bx
0ca6:1674	and	word ptr es:[di], bx
0ca6:1677	and	word ptr es:[di + 2], bx
        	loc_e0db:
0ca6:167b	inc	si
0ca6:167c	add	di, 4
0ca6:167f	loop	loc_e095
0ca6:1681	pop	dx
0ca6:1682	mov	cl, dh
0ca6:1684	pop	di
0ca6:1685	add	di, 8
0ca6:1688	jmp	loc_e08c
        	loc_e0ea:
0ca6:168a	pop	bx
0ca6:168b	mov	ax, 0x1228
0ca6:168e	mov	ds, ax
0ca6:1690	pop	dx
0ca6:1691	xor	dh, dh
0ca6:1693	neg	dx
0ca6:1695	add	dx, word ptr [0x6944]
0ca6:1699	mov	ax, word ptr [0x6942]
0ca6:169c	add	byte ptr [0x6942], bh
0ca6:16a0	jae	loc_e108
0ca6:16a2	add	word ptr [0x6942], 0x100
        	loc_e108:
0ca6:16a8	call	0x1530
0ca6:16ab	jb	loc_e13d
0ca6:16ad	shl	dx, 1
0ca6:16af	shl	dx, 1
0ca6:16b1	shl	dx, 1
0ca6:16b3	mov	cx, dx
0ca6:16b5	shl	cx, 1
0ca6:16b7	shl	cx, 1
0ca6:16b9	add	cx, dx
0ca6:16bb	mov	dx, ax
0ca6:16bd	and	dx, 7
0ca6:16c0	shr	ax, 1
0ca6:16c2	shr	ax, 1
0ca6:16c4	shr	ax, 1
0ca6:16c6	add	ax, cx
0ca6:16c8	dec	bh
0ca6:16ca	shr	bh, 1
0ca6:16cc	shr	bh, 1
0ca6:16ce	shr	bh, 1
0ca6:16d0	inc	bh
0ca6:16d2	mov	cl, bh
0ca6:16d4	mov	ch, bl
0ca6:16d6	mov	bl, 2
0ca6:16d8	mov	bh, 0x28
0ca6:16da	call	0x148e
        	loc_e13d:
0ca6:16dd	call	0x65f
0ca6:16e0	ret	
sub_e067 ENDP
*/
void sub_e067()
{
    // coverage: 0xd397-0xd471 method sub_e067
    sub_dfee();
    if (cl != 0x00)
        goto loc_e072;
    goto loc_e13d;
loc_e072:
    push(ax);
    sub_e01d();
    al = 0x08;
    mul(dh);
    ah = 0;
    di += ax;
    ch = 0;
    cl--;
    cx >>= 1;
    cx >>= 1;
    cx >>= 1;
    cx++;
    dh = cl;
    push(bx);
loc_e08c:
    if (dl == 0x00)
        goto loc_e0ea;
    dl--;
    push(di);
    push(dx);
loc_e095:
    al = memoryAGet(ds, si);
    bl = al;
    bh = al;
    ax = memoryAGet16(es, bp);
    ax &= bx;
    dx = ax;
    ax = memoryAGet16(es, bp + 2);
    ax &= bx;
    dx |= ax;
    dh |= dl;
    dl = dh;
    dx = ~dx;
    if (dx == 0xffff)
        goto loc_e0d2;
    ax = memoryAGet16(es, bp);
    ax &= bx;
    memoryASet16(es, di, memoryAGet16(es, di) & dx);
    memoryASet16(es, di, memoryAGet16(es, di) | ax);
    ax = memoryAGet16(es, bp + 2);
    ax &= bx;
    memoryASet16(es, di + 2, memoryAGet16(es, di + 2) & dx);
    memoryASet16(es, di + 2, memoryAGet16(es, di + 2) | ax);
    goto loc_e0db;
loc_e0d2:
    bx = ~bx;
    memoryASet16(es, di, memoryAGet16(es, di) & bx);
    memoryASet16(es, di + 2, memoryAGet16(es, di + 2) & bx);
loc_e0db:
    si++;
    di += 0x0004;
    if (--cx)
        goto loc_e095;
    dx = pop();
    cl = dh;
    di = pop();
    di += 0x0008;
    goto loc_e08c;
loc_e0ea:
    bx = pop();
    ax = 0x1228;
    ds = ax;
    dx = pop();
    dh = 0;
    dx = -dx;
    dx += memoryAGet16(ds, 0x6944);
    ax = memoryAGet16(ds, 0x6942);
    flags.carry = (memoryAGet(ds, 0x6942) + bh) >= 0x100;
    memoryASet(ds, 0x6942, memoryAGet(ds, 0x6942) + bh);
    if (!flags.carry)
        goto loc_e108;
    memoryASet16(ds, 0x6942, memoryAGet16(ds, 0x6942) + 0x0100);
loc_e108:
    sub_df90();
    if (flags.carry)
        goto loc_e13d;
    dx <<= 1;
    dx <<= 1;
    dx <<= 1;
    cx = dx;
    cx <<= 1;
    cx <<= 1;
    cx += dx;
    dx = ax;
    dx &= 0x0007;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax += cx;
    bh--;
    bh >>= 1;
    bh >>= 1;
    bh >>= 1;
    bh++;
    cl = bh;
    ch = bl;
    bl = 0x02;
    bh = 0x28;
    sub_deee();
loc_e13d:
    sub_d0bf();
}
/* Assembly listing of 0ca6:16e1 sub_e141()
sub_e141 PROC
0ca6:16e1	ret	
sub_e141 ENDP
*/
void sub_e141()
{
    // coverage: 0xd471-0xd472 method sub_e141
}
/* Assembly listing of 0ca6:16e2 sub_e142()
sub_e142 PROC
0ca6:16e2	ret	
sub_e142 ENDP
*/
void sub_e142()
{
    // coverage: 0xd472-0xd473 method sub_e142
}
/* Assembly listing of 0e15:0000 sub_e150()
sub_e150 PROC
0e15:0000	push	di
0e15:0001	push	si
0e15:0002	push	bp
0e15:0003	push	ds
0e15:0004	push	es
0e15:0005	mov	bp, 0x1228
0e15:0008	mov	ds, bp
0e15:000a	mov	word ptr [0x4e10], di
0e15:000e	mov	word ptr [0x4e0c], di
0e15:0012	mov	word ptr [0x4e0e], si
0e15:0016	mov	word ptr [0x4e0a], si
0e15:001a	mov	es, di
0e15:001c	mov	di, si
0e15:001e	mov	word ptr [0x4e14], bx
0e15:0022	mov	word ptr [0x4e2a], bx
0e15:0026	mov	word ptr [0x4e12], ax
0e15:0029	mov	word ptr [0x4e28], ax
0e15:002c	mov	bx, dx
0e15:002e	mov	ax, cx
0e15:0030	lcall	0xec7, 0
0e15:0035	mov	word ptr [0x4e0c], dx
0e15:0039	mov	word ptr [0x4e0a], ax
        	loc_e18c:
0e15:003c	call	0xa09
0e15:003f	jae	loc_e196
0e15:0041	mov	ax, 3
0e15:0044	jmp	loc_e1c8
        	loc_e196:
0e15:0046	push	si
0e15:0047	push	ds
0e15:0048	mov	bp, 0x1228
0e15:004b	mov	ds, bp
0e15:004d	mov	si, word ptr [0x4e31]
0e15:0051	and	si, 0x7fff
0e15:0055	dec	si
0e15:0056	shl	si, 1
0e15:0058	mov	bp, word ptr [si + 0x4e37]
0e15:005c	pop	ds
0e15:005d	pop	si
0e15:005e	call	bp
0e15:0060	mov	ax, 0x1228
0e15:0063	mov	ds, ax
0e15:0065	mov	ax, word ptr [0x4e35]
0e15:0068	mov	word ptr [0x4e2a], ax
0e15:006b	mov	ax, word ptr [0x4e33]
0e15:006e	mov	word ptr [0x4e28], ax
0e15:0071	cmp	word ptr [0x4e31], 0
0e15:0076	jg	loc_e18c
        	loc_e1c8:
0e15:0078	pop	es
0e15:0079	pop	ds
0e15:007a	pop	bp
0e15:007b	pop	si
0e15:007c	pop	di
0e15:007d	retf	
sub_e150 ENDP
*/
void sub_e150()
{
    // coverage: 0xd480-0xd4fe method sub_e150
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bp = 0x1228;
    ds = bp;
    memoryASet16(ds, 0x4e10, di);
    memoryASet16(ds, 0x4e0c, di);
    memoryASet16(ds, 0x4e0e, si);
    memoryASet16(ds, 0x4e0a, si);
    es = di;
    di = si;
    memoryASet16(ds, 0x4e14, bx);
    memoryASet16(ds, 0x4e2a, bx);
    memoryASet16(ds, 0x4e12, ax);
    memoryASet16(ds, 0x4e28, ax);
    bx = dx;
    ax = cx;
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e0c, dx);
    memoryASet16(ds, 0x4e0a, ax);
loc_e18c:
    sub_eb59();
    if (!flags.carry)
        goto loc_e196;
    ax = 0x0003;
    goto loc_e1c8;
loc_e196:
    push(si);
    push(ds);
    bp = 0x1228;
    ds = bp;
    si = memoryAGet16(ds, 0x4e31);
    si &= 0x7fff;
    si--;
    si <<= 1;
    bp = memoryAGet16(ds, si + 20023);
    ds = pop();
    si = pop();
    callIndirect(cs, bp);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4e35);
    memoryASet16(ds, 0x4e2a, ax);
    ax = memoryAGet16(ds, 0x4e33);
    memoryASet16(ds, 0x4e28, ax);
    if ((short)memoryAGet16(ds, 0x4e31) > (short)0x0000)
        goto loc_e18c;
loc_e1c8:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0e15:007e sub_e1ce()
sub_e1ce PROC
0e15:007e	mov	dx, word ptr [0x4e26]
0e15:0082	mov	word ptr [0x4e14], dx
0e15:0086	mov	ax, word ptr [0x4e24]
0e15:0089	mov	word ptr [0x4e12], ax
0e15:008c	and	byte ptr [0x4e12], 0xf0
0e15:0091	cmp	dx, word ptr [0x4e14]
0e15:0095	jne	loc_e1ed
0e15:0097	cmp	ax, word ptr [0x4e12]
0e15:009b	je	loc_e1f8
        	loc_e1ed:
0e15:009d	add	word ptr [0x4e12], 0x10
0e15:00a2	jae	loc_e1f8
0e15:00a4	inc	word ptr [0x4e14]
        	loc_e1f8:
0e15:00a8	mov	ax, word ptr [0x4e0c]
0e15:00ab	mov	word ptr [0x4e18], ax
0e15:00ae	mov	ax, word ptr [0x4e0a]
0e15:00b1	mov	word ptr [0x4e16], ax
0e15:00b4	mov	ax, word ptr [0x4e18]
0e15:00b7	mov	es, ax
0e15:00b9	mov	di, word ptr [0x4e16]
0e15:00bd	mov	bx, word ptr [0x4e14]
0e15:00c1	mov	ax, word ptr [0x4e12]
0e15:00c4	lcall	0xec7, 0x45
0e15:00c9	and	al, 0xfe
0e15:00cb	mov	word ptr [0x4e08], dx
0e15:00cf	mov	word ptr [0x4e06], ax
0e15:00d2	mov	es, dx
0e15:00d4	mov	di, ax
0e15:00d6	mov	bx, word ptr [0x4e14]
0e15:00da	mov	ax, word ptr [0x4e12]
0e15:00dd	lcall	0xec7, 0
0e15:00e2	mov	word ptr [0x4dfc], dx
0e15:00e6	mov	word ptr [0x4dfa], ax
0e15:00e9	mov	ax, word ptr [0x4e10]
0e15:00ec	mov	es, ax
0e15:00ee	mov	di, word ptr [0x4e0e]
0e15:00f2	mov	bx, word ptr [0x4e14]
0e15:00f6	mov	ax, word ptr [0x4e12]
0e15:00f9	lcall	0xec7, 0
0e15:00fe	mov	word ptr [0x4df8], dx
0e15:0102	mov	word ptr [0x4df6], ax
0e15:0105	mov	es, dx
0e15:0107	mov	di, ax
0e15:0109	xor	bx, bx
0e15:010b	mov	ax, 0x10
0e15:010e	lcall	0xec7, 0
0e15:0113	mov	word ptr [0x4e00], dx
0e15:0117	mov	word ptr [0x4dfe], ax
0e15:011a	cmp	dx, word ptr [0x4dfc]
0e15:011e	jb	loc_e285
0e15:0120	jne	loc_e278
0e15:0122	cmp	ax, word ptr [0x4dfa]
0e15:0126	jbe	loc_e285
        	loc_e278:
0e15:0128	mov	word ptr [0x4e14], 0
0e15:012e	mov	word ptr [0x4e12], 2
0e15:0134	ret	
        	loc_e285:
0e15:0135	mov	cx, word ptr [0x4e14]
0e15:0139	mov	bx, word ptr [0x4e12]
0e15:013d	mov	ax, word ptr [0x4dfc]
0e15:0140	mov	es, ax
0e15:0142	mov	di, word ptr [0x4dfa]
0e15:0146	mov	si, word ptr [0x4df6]
0e15:014a	mov	ax, word ptr [0x4df8]
0e15:014d	mov	ds, ax
        	loc_e29f:
0e15:014f	sub	si, 2
0e15:0152	jae	loc_e2ac
0e15:0154	add	si, 0x10
0e15:0157	mov	ax, ds
0e15:0159	dec	ax
0e15:015a	mov	ds, ax
        	loc_e2ac:
0e15:015c	sub	di, 2
0e15:015f	jae	loc_e2b9
0e15:0161	add	di, 0x10
0e15:0164	mov	ax, es
0e15:0166	dec	ax
0e15:0167	mov	es, ax
        	loc_e2b9:
0e15:0169	mov	ax, word ptr [si]
0e15:016b	mov	word ptr es:[di], ax
0e15:016e	sub	bx, 2
0e15:0171	jae	loc_e2c7
0e15:0173	add	bx, 0x10
0e15:0176	dec	cx
        	loc_e2c7:
0e15:0177	cmp	cx, 0
0e15:017a	jne	loc_e29f
0e15:017c	cmp	bx, 0
0e15:017f	jne	loc_e29f
0e15:0181	mov	ax, 0x1228
0e15:0184	mov	ds, ax
0e15:0186	mov	word ptr [0x4e14], 0
0e15:018c	mov	word ptr [0x4e12], 1
0e15:0192	ret	
sub_e1ce ENDP
*/
void sub_e1ce()
{
    // coverage: 0xd4fe-0xd613 method sub_e1ce
    dx = memoryAGet16(ds, 0x4e26);
    memoryASet16(ds, 0x4e14, dx);
    ax = memoryAGet16(ds, 0x4e24);
    memoryASet16(ds, 0x4e12, ax);
    memoryASet(ds, 0x4e12, memoryAGet(ds, 0x4e12) & 0xf0);
    if (dx != memoryAGet16(ds, 0x4e14))
        goto loc_e1ed;
    if (ax == memoryAGet16(ds, 0x4e12))
        goto loc_e1f8;
loc_e1ed:
    flags.carry = (memoryAGet16(ds, 0x4e12) + 0x0010) >= 0x10000;
    memoryASet16(ds, 0x4e12, memoryAGet16(ds, 0x4e12) + 0x0010);
    if (!flags.carry)
        goto loc_e1f8;
    memoryASet16(ds, 0x4e14, memoryAGet16(ds, 0x4e14) + 1);
loc_e1f8:
    ax = memoryAGet16(ds, 0x4e0c);
    memoryASet16(ds, 0x4e18, ax);
    ax = memoryAGet16(ds, 0x4e0a);
    memoryASet16(ds, 0x4e16, ax);
    ax = memoryAGet16(ds, 0x4e18);
    es = ax;
    di = memoryAGet16(ds, 0x4e16);
    bx = memoryAGet16(ds, 0x4e14);
    ax = memoryAGet16(ds, 0x4e12);
    push(cs);
    cs = 0x0ec7;
    sub_ecb5();
    assert(cs == 0x0e15);
    al &= 0xfe;
    memoryASet16(ds, 0x4e08, dx);
    memoryASet16(ds, 0x4e06, ax);
    es = dx;
    di = ax;
    bx = memoryAGet16(ds, 0x4e14);
    ax = memoryAGet16(ds, 0x4e12);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4dfc, dx);
    memoryASet16(ds, 0x4dfa, ax);
    ax = memoryAGet16(ds, 0x4e10);
    es = ax;
    di = memoryAGet16(ds, 0x4e0e);
    bx = memoryAGet16(ds, 0x4e14);
    ax = memoryAGet16(ds, 0x4e12);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4df8, dx);
    memoryASet16(ds, 0x4df6, ax);
    es = dx;
    di = ax;
    bx = 0;
    ax = 0x0010;
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e00, dx);
    memoryASet16(ds, 0x4dfe, ax);
    if (dx < memoryAGet16(ds, 0x4dfc))
        goto loc_e285;
    if (dx != memoryAGet16(ds, 0x4dfc))
        goto loc_e278;
    if (ax <= memoryAGet16(ds, 0x4dfa))
        goto loc_e285;
loc_e278:
    memoryASet16(ds, 0x4e14, 0x0000);
    memoryASet16(ds, 0x4e12, 0x0002);
    return;
loc_e285:
    cx = memoryAGet16(ds, 0x4e14);
    bx = memoryAGet16(ds, 0x4e12);
    ax = memoryAGet16(ds, 0x4dfc);
    es = ax;
    di = memoryAGet16(ds, 0x4dfa);
    si = memoryAGet16(ds, 0x4df6);
    ax = memoryAGet16(ds, 0x4df8);
    ds = ax;
loc_e29f:
    flags.carry = si < 0x0002;
    si -= 0x0002;
    if (!flags.carry)
        goto loc_e2ac;
    si += 0x0010;
    ax = ds;
    ax--;
    ds = ax;
loc_e2ac:
    flags.carry = di < 0x0002;
    di -= 0x0002;
    if (!flags.carry)
        goto loc_e2b9;
    di += 0x0010;
    ax = es;
    ax--;
    es = ax;
loc_e2b9:
    ax = memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    flags.carry = bx < 0x0002;
    bx -= 0x0002;
    if (!flags.carry)
        goto loc_e2c7;
    bx += 0x0010;
    cx--;
loc_e2c7:
    if (cx != 0x0000)
        goto loc_e29f;
    if (bx != 0x0000)
        goto loc_e29f;
    ax = 0x1228;
    ds = ax;
    memoryASet16(ds, 0x4e14, 0x0000);
    memoryASet16(ds, 0x4e12, 0x0001);
}
/* Assembly listing of 0e15:0193 sub_e2e3()
sub_e2e3 PROC
0e15:0193	ret	
sub_e2e3 ENDP
*/
void sub_e2e3()
{
    // coverage: 0xd613-0xd614 method sub_e2e3
}
/* Assembly listing of 0e15:0194 sub_e2e4()
sub_e2e4 PROC
0e15:0194	mov	ax, 0x1228
0e15:0197	mov	ds, ax
0e15:0199	mov	ax, word ptr [0x4e10]
0e15:019c	mov	es, ax
0e15:019e	mov	di, word ptr [0x4e0e]
0e15:01a2	xor	bx, bx
0e15:01a4	mov	ax, 0xc
0e15:01a7	lcall	0xec7, 0
0e15:01ac	mov	word ptr [0x4e08], dx
0e15:01b0	mov	word ptr [0x4e06], ax
0e15:01b3	mov	es, dx
0e15:01b5	mov	di, ax
0e15:01b7	mov	al, byte ptr es:[di]
0e15:01ba	mov	byte ptr [0x4e22], al
0e15:01bd	inc	word ptr [0x4e06]
0e15:01c1	mov	ax, word ptr [0x4e10]
0e15:01c4	mov	es, ax
0e15:01c6	mov	di, word ptr [0x4e0e]
0e15:01ca	mov	bx, word ptr [0x4e26]
0e15:01ce	mov	ax, word ptr [0x4e24]
0e15:01d1	lcall	0xec7, 0
0e15:01d6	mov	word ptr [0x4df8], dx
0e15:01da	mov	word ptr [0x4df6], ax
0e15:01dd	mov	bx, word ptr [0x4e2a]
0e15:01e1	mov	ax, word ptr [0x4e28]
0e15:01e4	lcall	0xec7, 0
0e15:01e9	mov	word ptr [0x4dfc], dx
0e15:01ed	mov	word ptr [0x4dfa], ax
0e15:01f0	mov	ax, 0x1228
0e15:01f3	mov	es, ax
0e15:01f5	mov	di, 0x4e97
0e15:01f8	xor	bx, bx
0e15:01fa	mov	ax, 0x400
0e15:01fd	lcall	0xec7, 0
0e15:0202	mov	word ptr [0x4e04], dx
0e15:0206	mov	word ptr [0x4e02], ax
0e15:0209	mov	es, dx
0e15:020b	mov	di, ax
0e15:020d	mov	word ptr [0x4e2f], dx
0e15:0211	mov	word ptr [0x4e2d], ax
0e15:0214	mov	si, word ptr [0x4dfa]
0e15:0218	mov	ax, word ptr [0x4dfc]
0e15:021b	mov	ds, ax
0e15:021d	mov	cx, 0x400
        	loc_e370:
0e15:0220	sub	si, 1
0e15:0223	jae	loc_e37d
0e15:0225	add	si, 0x10
0e15:0228	mov	ax, ds
0e15:022a	dec	ax
0e15:022b	mov	ds, ax
        	loc_e37d:
0e15:022d	sub	di, 1
0e15:0230	jae	loc_e38a
0e15:0232	add	di, 0x10
0e15:0235	mov	ax, es
0e15:0237	dec	ax
0e15:0238	mov	es, ax
        	loc_e38a:
0e15:023a	mov	al, byte ptr [si]
0e15:023c	mov	byte ptr es:[di], al
0e15:023f	mov	ax, ds
0e15:0241	mov	bp, cx
0e15:0243	mov	bx, 0x1228
0e15:0246	mov	ds, bx
0e15:0248	mov	dx, word ptr [0x4e08]
0e15:024c	mov	cx, word ptr [0x4e06]
0e15:0250	mov	ds, ax
0e15:0252	cmp	ax, dx
0e15:0254	jne	loc_e3aa
0e15:0256	cmp	si, cx
0e15:0258	je	loc_e3ff
        	loc_e3aa:
0e15:025a	mov	cx, bp
0e15:025c	loop	loc_e370
0e15:025e	mov	bp, ds
0e15:0260	mov	ax, 0x1228
0e15:0263	mov	ds, ax
0e15:0265	mov	ax, word ptr [0x4df8]
0e15:0268	mov	word ptr [0x4e04], ax
0e15:026b	mov	di, word ptr [0x4df6]
0e15:026f	mov	word ptr [0x4e02], di
0e15:0273	mov	es, ax
0e15:0275	mov	ds, bp
        	loc_e3c7:
0e15:0277	sub	si, 1
0e15:027a	jae	loc_e3d4
0e15:027c	add	si, 0x10
0e15:027f	mov	ax, ds
0e15:0281	dec	ax
0e15:0282	mov	ds, ax
        	loc_e3d4:
0e15:0284	sub	di, 1
0e15:0287	jae	loc_e3e1
0e15:0289	add	di, 0x10
0e15:028c	mov	ax, es
0e15:028e	dec	ax
0e15:028f	mov	es, ax
        	loc_e3e1:
0e15:0291	mov	al, byte ptr [si]
0e15:0293	mov	byte ptr es:[di], al
0e15:0296	mov	ax, ds
0e15:0298	mov	bx, 0x1228
0e15:029b	mov	ds, bx
0e15:029d	mov	dx, word ptr [0x4e08]
0e15:02a1	mov	cx, word ptr [0x4e06]
0e15:02a5	mov	ds, ax
0e15:02a7	cmp	ax, dx
0e15:02a9	jne	loc_e3c7
0e15:02ab	cmp	si, cx
0e15:02ad	jne	loc_e3c7
        	loc_e3ff:
0e15:02af	mov	ax, 0x1228
0e15:02b2	mov	ds, ax
0e15:02b4	mov	ax, word ptr [0x4e10]
0e15:02b7	mov	word ptr [0x4e00], ax
0e15:02ba	mov	ax, word ptr [0x4e0e]
0e15:02bd	mov	word ptr [0x4dfe], ax
0e15:02c0	mov	ax, es
0e15:02c2	mov	ds, ax
0e15:02c4	mov	si, di
        	loc_e416:
0e15:02c6	mov	al, byte ptr [si]
0e15:02c8	mov	bp, ds
0e15:02ca	mov	bx, 0x1228
0e15:02cd	mov	ds, bx
0e15:02cf	mov	byte ptr [0x4e2c], al
0e15:02d2	mov	ds, bp
0e15:02d4	mov	bp, bx
0e15:02d6	add	si, 1
0e15:02d9	push	di
0e15:02da	push	bp
0e15:02db	push	es
0e15:02dc	mov	ax, ds
0e15:02de	mov	es, ax
0e15:02e0	mov	di, si
0e15:02e2	lcall	0xec7, 0x89
0e15:02e7	mov	ds, dx
0e15:02e9	mov	si, ax
0e15:02eb	pop	es
0e15:02ec	pop	bp
0e15:02ed	pop	di
0e15:02ee	mov	bx, ds
0e15:02f0	mov	ds, bp
0e15:02f2	mov	dx, word ptr [0x4df8]
0e15:02f6	mov	cx, word ptr [0x4df6]
0e15:02fa	mov	ds, bx
0e15:02fc	cmp	bx, dx
0e15:02fe	jne	loc_e465
0e15:0300	cmp	si, cx
0e15:0302	jne	loc_e465
0e15:0304	mov	ds, bp
0e15:0306	mov	ax, 0x1228
0e15:0309	mov	word ptr [0x4e04], ax
0e15:030c	mov	si, 0x4e97
0e15:030f	mov	word ptr [0x4e02], si
0e15:0313	mov	ds, ax
        	loc_e465:
0e15:0315	mov	bp, ds
0e15:0317	mov	bx, 0x1228
0e15:031a	mov	ds, bx
0e15:031c	mov	al, byte ptr [0x4e22]
0e15:031f	mov	ah, byte ptr [0x4e2c]
0e15:0323	mov	ds, bp
0e15:0325	cmp	al, ah
0e15:0327	je	loc_e47c
0e15:0329	jmp	loc_e565
        	loc_e47c:
0e15:032c	mov	al, byte ptr [si]
0e15:032e	mov	ds, bx
0e15:0330	mov	byte ptr [0x4e1e], al
0e15:0333	mov	ds, bp
0e15:0335	mov	bp, bx
0e15:0337	add	si, 1
0e15:033a	push	di
0e15:033b	push	bp
0e15:033c	push	es
0e15:033d	mov	ax, ds
0e15:033f	mov	es, ax
0e15:0341	mov	di, si
0e15:0343	lcall	0xec7, 0x89
0e15:0348	mov	ds, dx
0e15:034a	mov	si, ax
0e15:034c	pop	es
0e15:034d	pop	bp
0e15:034e	pop	di
0e15:034f	mov	bx, ds
0e15:0351	mov	ds, bp
0e15:0353	mov	dx, word ptr [0x4df8]
0e15:0357	mov	cx, word ptr [0x4df6]
0e15:035b	mov	ds, bx
0e15:035d	cmp	bx, dx
0e15:035f	jne	loc_e4c6
0e15:0361	cmp	si, cx
0e15:0363	jne	loc_e4c6
0e15:0365	mov	ds, bp
0e15:0367	mov	ax, 0x1228
0e15:036a	mov	word ptr [0x4e04], ax
0e15:036d	mov	si, 0x4e97
0e15:0370	mov	word ptr [0x4e02], si
0e15:0374	mov	ds, ax
        	loc_e4c6:
0e15:0376	mov	bp, ds
0e15:0378	mov	bx, 0x1228
0e15:037b	mov	ds, bx
0e15:037d	mov	al, byte ptr [0x4e22]
0e15:0380	mov	ah, byte ptr [0x4e1e]
0e15:0384	mov	ds, bp
0e15:0386	cmp	al, ah
0e15:0388	jne	loc_e4dd
0e15:038a	jmp	loc_e565
        	loc_e4dd:
0e15:038d	mov	al, byte ptr [si]
0e15:038f	mov	ds, bx
0e15:0391	mov	byte ptr [0x4e16], al
0e15:0394	mov	ds, bp
0e15:0396	mov	bp, bx
0e15:0398	add	si, 1
0e15:039b	push	di
0e15:039c	push	bp
0e15:039d	push	es
0e15:039e	mov	ax, ds
0e15:03a0	mov	es, ax
0e15:03a2	mov	di, si
0e15:03a4	lcall	0xec7, 0x89
0e15:03a9	mov	ds, dx
0e15:03ab	mov	si, ax
0e15:03ad	pop	es
0e15:03ae	pop	bp
0e15:03af	pop	di
0e15:03b0	mov	bx, ds
0e15:03b2	mov	ds, bp
0e15:03b4	mov	dx, word ptr [0x4df8]
0e15:03b8	mov	cx, word ptr [0x4df6]
0e15:03bc	mov	ds, bx
0e15:03be	cmp	bx, dx
0e15:03c0	jne	loc_e527
0e15:03c2	cmp	si, cx
0e15:03c4	jne	loc_e527
0e15:03c6	mov	ds, bp
0e15:03c8	mov	ax, 0x1228
0e15:03cb	mov	word ptr [0x4e04], ax
0e15:03ce	mov	si, 0x4e97
0e15:03d1	mov	word ptr [0x4e02], si
0e15:03d5	mov	ds, ax
        	loc_e527:
0e15:03d7	mov	bp, ds
0e15:03d9	mov	bx, 0x1228
0e15:03dc	mov	ds, bx
0e15:03de	mov	ax, word ptr [0x4e00]
0e15:03e1	mov	es, ax
0e15:03e3	mov	di, word ptr [0x4dfe]
0e15:03e7	mov	al, byte ptr [0x4e1e]
0e15:03ea	mov	byte ptr es:[di], al
0e15:03ed	add	di, 1
0e15:03f0	lcall	0xec7, 0x89
0e15:03f5	mov	es, dx
0e15:03f7	mov	di, ax
0e15:03f9	mov	word ptr [0x4e00], dx
0e15:03fd	mov	word ptr [0x4dfe], ax
0e15:0400	cmp	bp, dx
0e15:0402	jne	loc_e55b
0e15:0404	cmp	si, di
0e15:0406	jne	loc_e55b
0e15:0408	jmp	loc_e5fe
        	loc_e55b:
0e15:040b	dec	byte ptr [0x4e16]
0e15:040f	mov	ds, bp
0e15:0411	jne	loc_e527
0e15:0413	jmp	loc_e590
        	loc_e565:
0e15:0415	mov	bp, ds
0e15:0417	mov	ax, 0x1228
0e15:041a	mov	ds, ax
0e15:041c	mov	ax, word ptr [0x4e00]
0e15:041f	mov	es, ax
0e15:0421	mov	di, word ptr [0x4dfe]
0e15:0425	mov	al, byte ptr [0x4e2c]
0e15:0428	mov	byte ptr es:[di], al
0e15:042b	add	di, 1
0e15:042e	lcall	0xec7, 0x89
0e15:0433	mov	es, dx
0e15:0435	mov	di, ax
0e15:0437	mov	word ptr [0x4e00], dx
0e15:043b	mov	word ptr [0x4dfe], ax
0e15:043e	mov	ds, bp
        	loc_e590:
0e15:0440	mov	bp, ds
0e15:0442	mov	dx, es
0e15:0444	cmp	bp, dx
0e15:0446	jne	loc_e59c
0e15:0448	cmp	si, di
0e15:044a	je	loc_e5fe
        	loc_e59c:
0e15:044c	mov	bx, 0x1228
0e15:044f	mov	ds, bx
0e15:0451	mov	dx, word ptr [0x4e2f]
0e15:0455	mov	cx, word ptr [0x4e2d]
0e15:0459	mov	ds, bp
0e15:045b	cmp	bp, dx
0e15:045d	je	loc_e5b2
0e15:045f	jmp	loc_e416
        	loc_e5b2:
0e15:0462	cmp	si, cx
0e15:0464	je	loc_e5b9
0e15:0466	jmp	loc_e416
        	loc_e5b9:
0e15:0469	mov	ax, 0x1228
0e15:046c	mov	ds, ax
0e15:046e	push	di
0e15:046f	push	es
0e15:0470	mov	ax, word ptr [0x4e26]
0e15:0473	mov	es, ax
0e15:0475	mov	di, word ptr [0x4e24]
0e15:0479	lcall	0xec7, 0x89
0e15:047e	mov	word ptr [0x4e26], dx
0e15:0482	mov	word ptr [0x4e24], ax
0e15:0485	pop	es
0e15:0486	pop	di
0e15:0487	mov	ax, word ptr [0x4e0e]
0e15:048a	sub	di, ax
0e15:048c	jae	loc_e5e6
0e15:048e	add	di, 0x10
0e15:0491	mov	ax, es
0e15:0493	dec	ax
0e15:0494	mov	es, ax
        	loc_e5e6:
0e15:0496	mov	bx, word ptr [0x4e10]
0e15:049a	mov	ax, es
0e15:049c	sub	ax, bx
0e15:049e	cmp	ax, word ptr [0x4e26]
0e15:04a2	jne	loc_e5ff
0e15:04a4	cmp	di, word ptr [0x4e24]
0e15:04a8	jne	loc_e5ff
0e15:04aa	mov	ax, 1
0e15:04ad	ret	
        	loc_e5fe:
0e15:04ae	ret	
        	loc_e5ff:
0e15:04af	ret	
sub_e2e4 ENDP
*/
void sub_e2e4()
{
    // coverage: 0xd614-0xd930 method sub_e2e4
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4e10);
    es = ax;
    di = memoryAGet16(ds, 0x4e0e);
    bx = 0;
    ax = 0x000c;
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e08, dx);
    memoryASet16(ds, 0x4e06, ax);
    es = dx;
    di = ax;
    al = memoryAGet(es, di);
    memoryASet(ds, 0x4e22, al);
    memoryASet16(ds, 0x4e06, memoryAGet16(ds, 0x4e06) + 1);
    ax = memoryAGet16(ds, 0x4e10);
    es = ax;
    di = memoryAGet16(ds, 0x4e0e);
    bx = memoryAGet16(ds, 0x4e26);
    ax = memoryAGet16(ds, 0x4e24);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4df8, dx);
    memoryASet16(ds, 0x4df6, ax);
    bx = memoryAGet16(ds, 0x4e2a);
    ax = memoryAGet16(ds, 0x4e28);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4dfc, dx);
    memoryASet16(ds, 0x4dfa, ax);
    ax = 0x1228;
    es = ax;
    di = 0x4e97;
    bx = 0;
    ax = 0x0400;
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e04, dx);
    memoryASet16(ds, 0x4e02, ax);
    es = dx;
    di = ax;
    memoryASet16(ds, 0x4e2f, dx);
    memoryASet16(ds, 0x4e2d, ax);
    si = memoryAGet16(ds, 0x4dfa);
    ax = memoryAGet16(ds, 0x4dfc);
    ds = ax;
    cx = 0x0400;
loc_e370:
    flags.carry = si < 0x0001;
    si -= 0x0001;
    if (!flags.carry)
        goto loc_e37d;
    si += 0x0010;
    ax = ds;
    ax--;
    ds = ax;
loc_e37d:
    flags.carry = di < 0x0001;
    di -= 0x0001;
    if (!flags.carry)
        goto loc_e38a;
    di += 0x0010;
    ax = es;
    ax--;
    es = ax;
loc_e38a:
    al = memoryAGet(ds, si);
    memoryASet(es, di, al);
    ax = ds;
    bp = cx;
    bx = 0x1228;
    ds = bx;
    dx = memoryAGet16(ds, 0x4e08);
    cx = memoryAGet16(ds, 0x4e06);
    ds = ax;
    if (ax != dx)
        goto loc_e3aa;
    if (si == cx)
        goto loc_e3ff;
loc_e3aa:
    cx = bp;
    if (--cx)
        goto loc_e370;
    bp = ds;
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4df8);
    memoryASet16(ds, 0x4e04, ax);
    di = memoryAGet16(ds, 0x4df6);
    memoryASet16(ds, 0x4e02, di);
    es = ax;
    ds = bp;
loc_e3c7:
    flags.carry = si < 0x0001;
    si -= 0x0001;
    if (!flags.carry)
        goto loc_e3d4;
    si += 0x0010;
    ax = ds;
    ax--;
    ds = ax;
loc_e3d4:
    flags.carry = di < 0x0001;
    di -= 0x0001;
    if (!flags.carry)
        goto loc_e3e1;
    di += 0x0010;
    ax = es;
    ax--;
    es = ax;
loc_e3e1:
    al = memoryAGet(ds, si);
    memoryASet(es, di, al);
    ax = ds;
    bx = 0x1228;
    ds = bx;
    dx = memoryAGet16(ds, 0x4e08);
    cx = memoryAGet16(ds, 0x4e06);
    ds = ax;
    if (ax != dx)
        goto loc_e3c7;
    if (si != cx)
        goto loc_e3c7;
loc_e3ff:
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4e10);
    memoryASet16(ds, 0x4e00, ax);
    ax = memoryAGet16(ds, 0x4e0e);
    memoryASet16(ds, 0x4dfe, ax);
    ax = es;
    ds = ax;
    si = di;
loc_e416:
    al = memoryAGet(ds, si);
    bp = ds;
    bx = 0x1228;
    ds = bx;
    memoryASet(ds, 0x4e2c, al);
    ds = bp;
    bp = bx;
    si += 0x0001;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    bx = ds;
    ds = bp;
    dx = memoryAGet16(ds, 0x4df8);
    cx = memoryAGet16(ds, 0x4df6);
    ds = bx;
    if (bx != dx)
        goto loc_e465;
    if (si != cx)
        goto loc_e465;
    ds = bp;
    ax = 0x1228;
    memoryASet16(ds, 0x4e04, ax);
    si = 0x4e97;
    memoryASet16(ds, 0x4e02, si);
    ds = ax;
loc_e465:
    bp = ds;
    bx = 0x1228;
    ds = bx;
    al = memoryAGet(ds, 0x4e22);
    ah = memoryAGet(ds, 0x4e2c);
    ds = bp;
    if (al == ah)
        goto loc_e47c;
    goto loc_e565;
loc_e47c:
    al = memoryAGet(ds, si);
    ds = bx;
    memoryASet(ds, 0x4e1e, al);
    ds = bp;
    bp = bx;
    si += 0x0001;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    bx = ds;
    ds = bp;
    dx = memoryAGet16(ds, 0x4df8);
    cx = memoryAGet16(ds, 0x4df6);
    ds = bx;
    if (bx != dx)
        goto loc_e4c6;
    if (si != cx)
        goto loc_e4c6;
    ds = bp;
    ax = 0x1228;
    memoryASet16(ds, 0x4e04, ax);
    si = 0x4e97;
    memoryASet16(ds, 0x4e02, si);
    ds = ax;
loc_e4c6:
    bp = ds;
    bx = 0x1228;
    ds = bx;
    al = memoryAGet(ds, 0x4e22);
    ah = memoryAGet(ds, 0x4e1e);
    ds = bp;
    if (al != ah)
        goto loc_e4dd;
    goto loc_e565;
loc_e4dd:
    al = memoryAGet(ds, si);
    ds = bx;
    memoryASet(ds, 0x4e16, al);
    ds = bp;
    bp = bx;
    si += 0x0001;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    bx = ds;
    ds = bp;
    dx = memoryAGet16(ds, 0x4df8);
    cx = memoryAGet16(ds, 0x4df6);
    ds = bx;
    if (bx != dx)
        goto loc_e527;
    if (si != cx)
        goto loc_e527;
    ds = bp;
    ax = 0x1228;
    memoryASet16(ds, 0x4e04, ax);
    si = 0x4e97;
    memoryASet16(ds, 0x4e02, si);
    ds = ax;
loc_e527:
    bp = ds;
    bx = 0x1228;
    ds = bx;
    ax = memoryAGet16(ds, 0x4e00);
    es = ax;
    di = memoryAGet16(ds, 0x4dfe);
    al = memoryAGet(ds, 0x4e1e);
    memoryASet(es, di, al);
    di += 0x0001;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    memoryASet16(ds, 0x4e00, dx);
    memoryASet16(ds, 0x4dfe, ax);
    if (bp != dx)
        goto loc_e55b;
    if (si != di)
        goto loc_e55b;
    goto loc_e5fe;
loc_e55b:
    tl = memoryAGet(ds, 0x4e16);
    memoryASet(ds, 0x4e16, memoryAGet(ds, 0x4e16) - 1);
    ds = bp;
    if (stop("check inject: dec byte ptr [0x4e16]") && tl != 1)
        goto loc_e527;
    goto loc_e590;
loc_e565:
    bp = ds;
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4e00);
    es = ax;
    di = memoryAGet16(ds, 0x4dfe);
    al = memoryAGet(ds, 0x4e2c);
    memoryASet(es, di, al);
    di += 0x0001;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    memoryASet16(ds, 0x4e00, dx);
    memoryASet16(ds, 0x4dfe, ax);
    ds = bp;
loc_e590:
    bp = ds;
    dx = es;
    if (bp != dx)
        goto loc_e59c;
    if (si == di)
        goto loc_e5fe;
loc_e59c:
    bx = 0x1228;
    ds = bx;
    dx = memoryAGet16(ds, 0x4e2f);
    cx = memoryAGet16(ds, 0x4e2d);
    ds = bp;
    if (bp == dx)
        goto loc_e5b2;
    goto loc_e416;
loc_e5b2:
    if (si == cx)
        goto loc_e5b9;
    goto loc_e416;
loc_e5b9:
    ax = 0x1228;
    ds = ax;
    push(di);
    push(es);
    ax = memoryAGet16(ds, 0x4e26);
    es = ax;
    di = memoryAGet16(ds, 0x4e24);
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e26, dx);
    memoryASet16(ds, 0x4e24, ax);
    es = pop();
    di = pop();
    ax = memoryAGet16(ds, 0x4e0e);
    flags.carry = di < ax;
    di -= ax;
    if (!flags.carry)
        goto loc_e5e6;
    di += 0x0010;
    ax = es;
    ax--;
    es = ax;
loc_e5e6:
    bx = memoryAGet16(ds, 0x4e10);
    ax = es;
    ax -= bx;
    if (ax != memoryAGet16(ds, 0x4e26))
        return;
    if (di != memoryAGet16(ds, 0x4e24))
        return;
    ax = 0x0001;
    return;
loc_e5fe:
    return;
}
/* Assembly listing of 0e15:04b0 sub_e600()
sub_e600 PROC
0e15:04b0		
        	loc_e5fe:
0e15:04ae	ret	
0e15:04af		
        	loc_e600:
0e15:04b0	mov	ax, 0x1228
0e15:04b3	mov	ds, ax
0e15:04b5	mov	ax, word ptr [0x4e10]
0e15:04b8	mov	es, ax
0e15:04ba	mov	di, word ptr [0x4e0e]
0e15:04be	mov	bx, word ptr [0x4e26]
0e15:04c2	mov	ax, word ptr [0x4e24]
0e15:04c5	lcall	0xec7, 0
0e15:04ca	cmp	dx, word ptr [0x4e0c]
0e15:04ce	ja	loc_e5fe
0e15:04d0	jne	loc_e628
0e15:04d2	cmp	ax, word ptr [0x4e0a]
0e15:04d6	ja	loc_e5fe
        	loc_e628:
0e15:04d8	mov	ax, word ptr [0x4e10]
0e15:04db	mov	es, ax
0e15:04dd	mov	di, word ptr [0x4e0e]
0e15:04e1	xor	bx, bx
0e15:04e3	mov	ax, 0xc
0e15:04e6	lcall	0xec7, 0
0e15:04eb	mov	word ptr [0x4df8], dx
0e15:04ef	mov	word ptr [0x4df6], ax
0e15:04f2	mov	es, dx
0e15:04f4	mov	di, ax
0e15:04f6	mov	ax, word ptr es:[di]
0e15:04f9	xchg	al, ah
0e15:04fb	mov	word ptr [0x4e22], ax
0e15:04fe	add	word ptr [0x4df6], 2
0e15:0503	mov	dx, word ptr [0x4e26]
0e15:0507	mov	word ptr [0x4e20], dx
0e15:050b	mov	ax, word ptr [0x4e24]
0e15:050e	mov	word ptr [0x4e1e], ax
0e15:0511	and	byte ptr [0x4e1e], 0xe0
0e15:0516	cmp	dx, word ptr [0x4e20]
0e15:051a	jne	loc_e679
0e15:051c	cmp	ax, word ptr [0x4e1e]
0e15:0520	je	loc_e67f
0e15:0522	mov	dx, word ptr [0x4e20]
0e15:0526	mov	ax, word ptr [0x4e1e]
        	loc_e679:
0e15:0529	add	ax, 0x20
0e15:052c	jae	loc_e67f
0e15:052e	inc	dx
        	loc_e67f:
0e15:052f	shr	dx, 1
0e15:0531	rcr	ax, 1
0e15:0533	shr	dx, 1
0e15:0535	rcr	ax, 1
0e15:0537	shr	dx, 1
0e15:0539	rcr	ax, 1
0e15:053b	mov	word ptr [0x4e20], dx
0e15:053f	mov	word ptr [0x4e1e], ax
0e15:0542	mov	ax, word ptr [0x4e0c]
0e15:0545	mov	word ptr [0x4e18], ax
0e15:0548	mov	di, word ptr [0x4e0a]
0e15:054c	mov	word ptr [0x4e16], di
0e15:0550	mov	es, ax
0e15:0552	mov	bx, word ptr [0x4e20]
0e15:0556	mov	ax, word ptr [0x4e1e]
0e15:0559	lcall	0xec7, 0x45
0e15:055e	mov	word ptr [0x4e18], dx
0e15:0562	mov	word ptr [0x4e16], ax
0e15:0565	and	byte ptr [0x4e16], 0xfe
0e15:056a	mov	dx, word ptr [0x4e18]
0e15:056e	mov	word ptr [0x4dfc], dx
0e15:0572	mov	ax, word ptr [0x4e16]
0e15:0575	mov	word ptr [0x4dfa], ax
0e15:0578	mov	word ptr [0x4e00], dx
0e15:057c	mov	word ptr [0x4dfe], ax
0e15:057f	mov	es, dx
0e15:0581	mov	di, ax
0e15:0583	mov	ax, word ptr [0x4e20]
0e15:0586	mov	word ptr [0x4e18], ax
0e15:0589	mov	ax, word ptr [0x4e1e]
0e15:058c	mov	word ptr [0x4e16], ax
0e15:058f	mov	si, word ptr [0x4df6]
0e15:0593	mov	ax, word ptr [0x4df8]
0e15:0596	mov	ds, ax
        	loc_e6e8:
0e15:0598	mov	ax, word ptr [si + 2]
0e15:059b	mov	word ptr es:[di + 2], ax
0e15:059f	mov	ax, word ptr [si]
0e15:05a1	mov	word ptr es:[di], ax
0e15:05a4	add	si, 4
0e15:05a7	push	di
0e15:05a8	push	bp
0e15:05a9	push	es
0e15:05aa	mov	ax, ds
0e15:05ac	mov	es, ax
0e15:05ae	mov	di, si
0e15:05b0	lcall	0xec7, 0x89
0e15:05b5	mov	ds, dx
0e15:05b7	mov	si, ax
0e15:05b9	pop	es
0e15:05ba	pop	bp
0e15:05bb	pop	di
0e15:05bc	mov	bp, ds
0e15:05be	add	di, 4
0e15:05c1	lcall	0xec7, 0x89
0e15:05c6	mov	es, dx
0e15:05c8	mov	di, ax
0e15:05ca	mov	ax, 0x1228
0e15:05cd	mov	ds, ax
0e15:05cf	push	di
0e15:05d0	push	es
0e15:05d1	mov	ax, word ptr [0x4e18]
0e15:05d4	mov	es, ax
0e15:05d6	mov	di, word ptr [0x4e16]
0e15:05da	xor	bx, bx
0e15:05dc	mov	ax, 4
0e15:05df	lcall	0xec7, 0x45
0e15:05e4	pop	es
0e15:05e5	pop	di
0e15:05e6	mov	word ptr [0x4e18], dx
0e15:05ea	mov	word ptr [0x4e16], ax
0e15:05ed	mov	ds, bp
0e15:05ef	cmp	dx, 0
0e15:05f2	jne	loc_e6e8
0e15:05f4	cmp	ax, 0
0e15:05f7	jne	loc_e6e8
0e15:05f9	mov	ax, 0x1228
0e15:05fc	mov	ds, ax
0e15:05fe	mov	word ptr [0x4df8], bp
0e15:0602	mov	word ptr [0x4df6], si
0e15:0606	mov	ax, es
0e15:0608	mov	word ptr [0x4e00], ax
0e15:060b	mov	word ptr [0x4dfe], di
0e15:060f	mov	ax, word ptr [0x4e26]
0e15:0612	push	ax
0e15:0613	mov	ax, word ptr [0x4e24]
0e15:0616	push	ax
0e15:0617	mov	ax, word ptr [0x4dfc]
0e15:061a	push	ax
0e15:061b	mov	ax, word ptr [0x4dfa]
0e15:061e	push	ax
0e15:061f	mov	ax, word ptr [0x4e0c]
0e15:0622	push	ax
0e15:0623	mov	ax, word ptr [0x4e0a]
0e15:0626	push	ax
0e15:0627	mov	ax, word ptr [0x4dfc]
0e15:062a	mov	word ptr [0x4e0c], ax
0e15:062d	mov	ax, word ptr [0x4dfa]
0e15:0630	mov	word ptr [0x4e0a], ax
0e15:0633	mov	ax, word ptr [0x4e2a]
0e15:0636	mov	word ptr [0x4e26], ax
0e15:0639	mov	ax, word ptr [0x4e28]
0e15:063c	mov	word ptr [0x4e24], ax
0e15:063f	call	0x7e
0e15:0642	pop	ax
0e15:0643	mov	word ptr [0x4e0a], ax
0e15:0646	pop	ax
0e15:0647	mov	word ptr [0x4e0c], ax
0e15:064a	pop	ax
0e15:064b	mov	word ptr [0x4dfa], ax
0e15:064e	pop	ax
0e15:064f	mov	word ptr [0x4dfc], ax
0e15:0652	pop	ax
0e15:0653	mov	word ptr [0x4e24], ax
0e15:0656	pop	ax
0e15:0657	mov	word ptr [0x4e26], ax
0e15:065a	cmp	word ptr [0x4e14], 0
0e15:065f	jne	loc_e7bb
0e15:0661	cmp	word ptr [0x4e12], 2
0e15:0666	jne	loc_e7bb
0e15:0668	jmp	loc_e5fe
        	loc_e7bb:
0e15:066b	mov	ax, word ptr [0x4e26]
0e15:066e	push	ax
0e15:066f	mov	ax, word ptr [0x4e24]
0e15:0672	push	ax
0e15:0673	mov	ax, word ptr [0x4e2a]
0e15:0676	push	ax
0e15:0677	mov	ax, word ptr [0x4e28]
0e15:067a	push	ax
0e15:067b	mov	ax, word ptr [0x4e0c]
0e15:067e	push	ax
0e15:067f	mov	ax, word ptr [0x4e0a]
0e15:0682	push	ax
0e15:0683	mov	ax, word ptr [0x4e08]
0e15:0686	mov	es, ax
0e15:0688	mov	di, word ptr [0x4e06]
0e15:068c	mov	bx, word ptr [0x4e2a]
0e15:0690	mov	ax, word ptr [0x4e28]
0e15:0693	lcall	0xec7, 0
0e15:0698	mov	word ptr [0x4e04], dx
0e15:069c	mov	word ptr [0x4e02], ax
0e15:069f	mov	bx, word ptr [0x4e20]
0e15:06a3	mov	ax, word ptr [0x4e1e]
0e15:06a6	lcall	0xec7, 0
0e15:06ab	mov	es, dx
0e15:06ad	mov	di, ax
0e15:06af	xor	bx, bx
0e15:06b1	mov	ax, 0xe
0e15:06b4	lcall	0xec7, 0
0e15:06b9	mov	word ptr [0x4e08], dx
0e15:06bd	mov	word ptr [0x4e06], ax
0e15:06c0	mov	ax, word ptr [0x4e0c]
0e15:06c3	mov	word ptr [0x4e00], ax
0e15:06c6	mov	di, word ptr [0x4e0a]
0e15:06ca	mov	word ptr [0x4dfe], di
0e15:06ce	mov	es, ax
0e15:06d0	xor	bx, bx
0e15:06d2	mov	ax, 0x400
0e15:06d5	lcall	0xec7, 0x45
0e15:06da	mov	word ptr [0x4e00], dx
0e15:06de	mov	word ptr [0x4dfe], ax
0e15:06e1	mov	ax, word ptr [0x4dfc]
0e15:06e4	mov	word ptr [0x4e0c], ax
0e15:06e7	mov	ax, word ptr [0x4dfa]
0e15:06ea	mov	word ptr [0x4e0a], ax
0e15:06ed	mov	ax, word ptr [0x4e10]
0e15:06f0	mov	word ptr [0x4df8], ax
0e15:06f3	mov	ax, word ptr [0x4e0e]
0e15:06f6	mov	word ptr [0x4df6], ax
0e15:06f9	mov	word ptr [0x4e1c], 0
0e15:06ff	mov	word ptr [0x4e1a], 0
0e15:0705	mov	word ptr [0x4e14], 0
0e15:070b	mov	word ptr [0x4e12], 0
0e15:0711	mov	word ptr [0x4e18], 0
0e15:0717	mov	word ptr [0x4e16], 0
        	loc_e86d:
0e15:071d	sub	word ptr [0x4e16], 1
0e15:0722	cmp	word ptr [0x4e16], 0
0e15:0727	jns	loc_e8c2
0e15:0729	mov	bp, ds
0e15:072b	mov	si, word ptr [0x4e0a]
0e15:072f	mov	ax, word ptr [0x4e0c]
0e15:0732	mov	ds, ax
0e15:0734	mov	dx, word ptr [si + 2]
0e15:0737	xchg	dl, dh
0e15:0739	mov	ax, word ptr [si]
0e15:073b	xchg	al, ah
0e15:073d	push	ax
0e15:073e	push	dx
0e15:073f	add	si, 4
0e15:0742	push	di
0e15:0743	push	bp
0e15:0744	push	es
0e15:0745	mov	ax, ds
0e15:0747	mov	es, ax
0e15:0749	mov	di, si
0e15:074b	lcall	0xec7, 0x89
0e15:0750	mov	ds, dx
0e15:0752	mov	si, ax
0e15:0754	pop	es
0e15:0755	pop	bp
0e15:0756	pop	di
0e15:0757	pop	dx
0e15:0758	pop	ax
0e15:0759	mov	cx, ds
0e15:075b	mov	ds, bp
0e15:075d	mov	word ptr [0x4e0c], cx
0e15:0761	mov	word ptr [0x4e0a], si
0e15:0765	mov	word ptr [0x4e16], 0x1f
0e15:076b	mov	word ptr [0x4e26], ax
0e15:076e	mov	word ptr [0x4e24], dx
        	loc_e8c2:
0e15:0772	mov	dx, word ptr [0x4e26]
0e15:0776	mov	ax, word ptr [0x4e24]
0e15:0779	shl	ax, 1
0e15:077b	rcl	dx, 1
0e15:077d	mov	word ptr [0x4e26], dx
0e15:0781	mov	word ptr [0x4e24], ax
0e15:0784	jae	loc_e8d9
0e15:0786	jmp	loc_ea27
        	loc_e8d9:
0e15:0789	mov	ax, word ptr [0x4df8]
0e15:078c	mov	es, ax
0e15:078e	mov	di, word ptr [0x4df6]
0e15:0792	mov	si, word ptr [0x4e06]
0e15:0796	mov	ax, word ptr [0x4e08]
0e15:0799	mov	ds, ax
0e15:079b	mov	al, byte ptr [si]
0e15:079d	mov	byte ptr es:[di], al
0e15:07a0	add	si, 1
0e15:07a3	push	di
0e15:07a4	push	bp
0e15:07a5	push	es
0e15:07a6	mov	ax, ds
0e15:07a8	mov	es, ax
0e15:07aa	mov	di, si
0e15:07ac	lcall	0xec7, 0x89
0e15:07b1	mov	ds, dx
0e15:07b3	mov	si, ax
0e15:07b5	pop	es
0e15:07b6	pop	bp
0e15:07b7	pop	di
0e15:07b8	mov	bp, ds
0e15:07ba	add	di, 1
0e15:07bd	lcall	0xec7, 0x89
0e15:07c2	mov	es, dx
0e15:07c4	mov	di, ax
0e15:07c6	mov	ax, 0x1228
0e15:07c9	mov	ds, ax
0e15:07cb	mov	word ptr [0x4e08], bp
0e15:07cf	mov	word ptr [0x4e06], si
0e15:07d3	mov	ax, es
0e15:07d5	mov	word ptr [0x4df8], ax
0e15:07d8	mov	word ptr [0x4df6], di
0e15:07dc	add	word ptr [0x4e12], 1
0e15:07e1	jae	loc_e937
0e15:07e3	inc	word ptr [0x4e14]
        	loc_e937:
0e15:07e7	mov	dx, word ptr [0x4e00]
0e15:07eb	mov	ax, word ptr [0x4dfe]
0e15:07ee	cmp	dx, word ptr [0x4df8]
0e15:07f2	jne	loc_e962
0e15:07f4	cmp	ax, word ptr [0x4df6]
0e15:07f8	jne	loc_e962
0e15:07fa	mov	ax, 0x1228
0e15:07fd	mov	word ptr [0x4df8], ax
0e15:0800	mov	ax, 0x4e97
0e15:0803	mov	word ptr [0x4df6], ax
0e15:0806	mov	word ptr [0x4e1c], 0
0e15:080c	mov	word ptr [0x4e1a], 1
        	loc_e962:
0e15:0812	mov	dx, word ptr [0x4e08]
0e15:0816	mov	ax, word ptr [0x4e06]
0e15:0819	cmp	dx, word ptr [0x4e04]
0e15:081d	jne	loc_e978
0e15:081f	cmp	ax, word ptr [0x4e02]
0e15:0823	jne	loc_e978
0e15:0825	jmp	loc_ea84
        	loc_e978:
0e15:0828	mov	dx, word ptr [0x4e08]
0e15:082c	mov	ax, word ptr [0x4e06]
0e15:082f	cmp	dx, word ptr [0x4df8]
0e15:0833	jbe	loc_e988
0e15:0835	jmp	loc_e86d
        	loc_e988:
0e15:0838	jne	loc_e993
0e15:083a	cmp	ax, word ptr [0x4df6]
0e15:083e	jbe	loc_e993
0e15:0840	jmp	loc_e86d
        	loc_e993:
0e15:0843	cmp	word ptr [0x4e1c], 0
0e15:0848	je	loc_e99d
0e15:084a	jmp	loc_e86d
        	loc_e99d:
0e15:084d	cmp	word ptr [0x4e1a], 0
0e15:0852	je	loc_e9a7
0e15:0854	jmp	loc_e86d
        	loc_e9a7:
0e15:0857	mov	ax, word ptr [0x4e0c]
0e15:085a	mov	word ptr [0x4dfc], ax
0e15:085d	mov	ax, word ptr [0x4e0a]
0e15:0860	mov	word ptr [0x4dfa], ax
0e15:0863	mov	dx, word ptr [0x4e08]
0e15:0867	mov	cx, word ptr [0x4e06]
0e15:086b	mov	ax, word ptr [0x4dfc]
0e15:086e	mov	es, ax
0e15:0870	mov	di, word ptr [0x4dfa]
0e15:0874	mov	si, word ptr [0x4e02]
0e15:0878	mov	ax, word ptr [0x4e04]
0e15:087b	mov	ds, ax
        	loc_e9cd:
0e15:087d	sub	si, 1
0e15:0880	jae	loc_e9da
0e15:0882	add	si, 0x10
0e15:0885	mov	ax, ds
0e15:0887	dec	ax
0e15:0888	mov	ds, ax
        	loc_e9da:
0e15:088a	sub	di, 1
0e15:088d	jae	loc_e9e7
0e15:088f	add	di, 0x10
0e15:0892	mov	ax, es
0e15:0894	dec	ax
0e15:0895	mov	es, ax
        	loc_e9e7:
0e15:0897	mov	al, byte ptr [si]
0e15:0899	mov	byte ptr es:[di], al
0e15:089c	mov	ax, ds
0e15:089e	cmp	dx, ax
0e15:08a0	jne	loc_e9cd
0e15:08a2	cmp	cx, si
0e15:08a4	jne	loc_e9cd
0e15:08a6	mov	ax, 0x1228
0e15:08a9	mov	ds, ax
0e15:08ab	mov	word ptr [0x4e04], bp
0e15:08af	mov	word ptr [0x4e02], si
0e15:08b3	mov	ax, es
0e15:08b5	mov	word ptr [0x4dfc], ax
0e15:08b8	mov	word ptr [0x4dfa], di
0e15:08bc	mov	ax, word ptr [0x4dfc]
0e15:08bf	mov	word ptr [0x4e08], ax
0e15:08c2	mov	ax, word ptr [0x4dfa]
0e15:08c5	mov	word ptr [0x4e06], ax
0e15:08c8	mov	ax, word ptr [0x4e0c]
0e15:08cb	mov	word ptr [0x4e04], ax
0e15:08ce	mov	ax, word ptr [0x4e0a]
0e15:08d1	mov	word ptr [0x4e02], ax
0e15:08d4	jmp	loc_e86d
        	loc_ea27:
0e15:08d7	mov	ax, word ptr [0x4df8]
0e15:08da	mov	es, ax
0e15:08dc	mov	di, word ptr [0x4df6]
0e15:08e0	mov	al, byte ptr [0x4e22]
0e15:08e3	mov	byte ptr es:[di], al
0e15:08e6	add	di, 1
0e15:08e9	lcall	0xec7, 0x89
0e15:08ee	mov	es, dx
0e15:08f0	mov	di, ax
0e15:08f2	mov	ax, es
0e15:08f4	mov	word ptr [0x4df8], ax
0e15:08f7	mov	word ptr [0x4df6], di
0e15:08fb	add	word ptr [0x4e12], 1
0e15:0900	jae	loc_ea56
0e15:0902	inc	word ptr [0x4e14]
        	loc_ea56:
0e15:0906	mov	dx, word ptr [0x4e00]
0e15:090a	mov	ax, word ptr [0x4dfe]
0e15:090d	cmp	dx, word ptr [0x4df8]
0e15:0911	jne	loc_ea81
0e15:0913	cmp	ax, word ptr [0x4df6]
0e15:0917	jne	loc_ea81
0e15:0919	mov	ax, 0x1228
0e15:091c	mov	word ptr [0x4df8], ax
0e15:091f	mov	ax, 0x4e97
0e15:0922	mov	word ptr [0x4df6], ax
0e15:0925	mov	word ptr [0x4e1c], 0
0e15:092b	mov	word ptr [0x4e1a], 1
        	loc_ea81:
0e15:0931	jmp	loc_e978
        	loc_ea84:
0e15:0934	pop	ax
0e15:0935	mov	word ptr [0x4e0a], ax
0e15:0938	pop	ax
0e15:0939	mov	word ptr [0x4e0c], ax
0e15:093c	pop	ax
0e15:093d	mov	word ptr [0x4e28], ax
0e15:0940	pop	ax
0e15:0941	mov	word ptr [0x4e2a], ax
0e15:0944	pop	ax
0e15:0945	mov	word ptr [0x4e24], ax
0e15:0948	pop	ax
0e15:0949	mov	word ptr [0x4e26], ax
        	loc_ea9c:
0e15:094c	mov	al, byte ptr [0x4e22]
0e15:094f	mov	byte ptr es:[di], al
0e15:0952	add	di, 1
0e15:0955	lcall	0xec7, 0x89
0e15:095a	mov	es, dx
0e15:095c	mov	di, ax
0e15:095e	add	word ptr [0x4e12], 1
0e15:0963	jae	loc_eab9
0e15:0965	inc	word ptr [0x4e14]
        	loc_eab9:
0e15:0969	mov	dx, word ptr [0x4e00]
0e15:096d	mov	ax, word ptr [0x4dfe]
0e15:0970	cmp	dx, word ptr [0x4df8]
0e15:0974	jne	loc_eae4
0e15:0976	cmp	ax, word ptr [0x4df6]
0e15:097a	jne	loc_eae4
0e15:097c	mov	ax, 0x1228
0e15:097f	mov	word ptr [0x4df8], ax
0e15:0982	mov	ax, 0x4e97
0e15:0985	mov	word ptr [0x4df6], ax
0e15:0988	mov	word ptr [0x4e1c], 0
0e15:098e	mov	word ptr [0x4e1a], 1
        	loc_eae4:
0e15:0994	mov	dx, word ptr [0x4e26]
0e15:0998	mov	ax, word ptr [0x4e24]
0e15:099b	cmp	dx, word ptr [0x4e14]
0e15:099f	ja	loc_ea9c
0e15:09a1	jne	loc_eaf9
0e15:09a3	cmp	ax, word ptr [0x4e12]
0e15:09a7	ja	loc_ea9c
        	loc_eaf9:
0e15:09a9	mov	ax, 0x1228
0e15:09ac	mov	word ptr [0x4df8], ax
0e15:09af	mov	ax, 0x4e97
0e15:09b2	mov	word ptr [0x4df6], ax
0e15:09b5	mov	cx, 0x400
0e15:09b8	shr	cx, 1
0e15:09ba	shr	cx, 1
0e15:09bc	mov	ax, word ptr [0x4e00]
0e15:09bf	mov	es, ax
0e15:09c1	mov	di, word ptr [0x4dfe]
0e15:09c5	mov	si, word ptr [0x4df6]
0e15:09c9	mov	ax, word ptr [0x4df8]
0e15:09cc	mov	ds, ax
        	loc_eb1e:
0e15:09ce	mov	ax, word ptr [si + 2]
0e15:09d1	mov	word ptr es:[di + 2], ax
0e15:09d5	mov	ax, word ptr [si]
0e15:09d7	mov	word ptr es:[di], ax
0e15:09da	add	si, 4
0e15:09dd	push	di
0e15:09de	push	bp
0e15:09df	push	es
0e15:09e0	mov	ax, ds
0e15:09e2	mov	es, ax
0e15:09e4	mov	di, si
0e15:09e6	lcall	0xec7, 0x89
0e15:09eb	mov	ds, dx
0e15:09ed	mov	si, ax
0e15:09ef	pop	es
0e15:09f0	pop	bp
0e15:09f1	pop	di
0e15:09f2	add	di, 4
0e15:09f5	lcall	0xec7, 0x89
0e15:09fa	mov	es, dx
0e15:09fc	mov	di, ax
0e15:09fe	loop	loc_eb1e
0e15:0a00	mov	ax, 0x1228
0e15:0a03	mov	ds, ax
0e15:0a05	mov	ax, 1
0e15:0a08	ret	
sub_e600 ENDP
*/
void sub_e600()
{
    // coverage: 0xd92e-0xd92f method sub_e600
    // coverage: 0xd930-0xde89 method sub_e600
    goto loc_e600;
loc_e5fe:
    return;
    //   gap of 1 bytes
loc_e600:
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ds, 0x4e10);
    es = ax;
    di = memoryAGet16(ds, 0x4e0e);
    bx = memoryAGet16(ds, 0x4e26);
    ax = memoryAGet16(ds, 0x4e24);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    if (dx > memoryAGet16(ds, 0x4e0c))
        goto loc_e5fe;
    if (dx != memoryAGet16(ds, 0x4e0c))
        goto loc_e628;
    if (ax > memoryAGet16(ds, 0x4e0a))
        goto loc_e5fe;
loc_e628:
    ax = memoryAGet16(ds, 0x4e10);
    es = ax;
    di = memoryAGet16(ds, 0x4e0e);
    bx = 0;
    ax = 0x000c;
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4df8, dx);
    memoryASet16(ds, 0x4df6, ax);
    es = dx;
    di = ax;
    ax = memoryAGet16(es, di);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(ds, 0x4e22, ax);
    memoryASet16(ds, 0x4df6, memoryAGet16(ds, 0x4df6) + 0x0002);
    dx = memoryAGet16(ds, 0x4e26);
    memoryASet16(ds, 0x4e20, dx);
    ax = memoryAGet16(ds, 0x4e24);
    memoryASet16(ds, 0x4e1e, ax);
    memoryASet(ds, 0x4e1e, memoryAGet(ds, 0x4e1e) & 0xe0);
    if (dx != memoryAGet16(ds, 0x4e20))
        goto loc_e679;
    if (ax == memoryAGet16(ds, 0x4e1e))
        goto loc_e67f;
    dx = memoryAGet16(ds, 0x4e20);
    ax = memoryAGet16(ds, 0x4e1e);
loc_e679:
    flags.carry = (ax + 0x0020) >= 0x10000;
    ax += 0x0020;
    if (!flags.carry)
        goto loc_e67f;
    dx++;
loc_e67f:
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    memoryASet16(ds, 0x4e20, dx);
    memoryASet16(ds, 0x4e1e, ax);
    ax = memoryAGet16(ds, 0x4e0c);
    memoryASet16(ds, 0x4e18, ax);
    di = memoryAGet16(ds, 0x4e0a);
    memoryASet16(ds, 0x4e16, di);
    es = ax;
    bx = memoryAGet16(ds, 0x4e20);
    ax = memoryAGet16(ds, 0x4e1e);
    push(cs);
    cs = 0x0ec7;
    sub_ecb5();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e18, dx);
    memoryASet16(ds, 0x4e16, ax);
    memoryASet(ds, 0x4e16, memoryAGet(ds, 0x4e16) & 0xfe);
    dx = memoryAGet16(ds, 0x4e18);
    memoryASet16(ds, 0x4dfc, dx);
    ax = memoryAGet16(ds, 0x4e16);
    memoryASet16(ds, 0x4dfa, ax);
    memoryASet16(ds, 0x4e00, dx);
    memoryASet16(ds, 0x4dfe, ax);
    es = dx;
    di = ax;
    ax = memoryAGet16(ds, 0x4e20);
    memoryASet16(ds, 0x4e18, ax);
    ax = memoryAGet16(ds, 0x4e1e);
    memoryASet16(ds, 0x4e16, ax);
    si = memoryAGet16(ds, 0x4df6);
    ax = memoryAGet16(ds, 0x4df8);
    ds = ax;
loc_e6e8:
    ax = memoryAGet16(ds, si + 2);
    memoryASet16(es, di + 2, ax);
    ax = memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    si += 0x0004;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    bp = ds;
    di += 0x0004;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    ax = 0x1228;
    ds = ax;
    push(di);
    push(es);
    ax = memoryAGet16(ds, 0x4e18);
    es = ax;
    di = memoryAGet16(ds, 0x4e16);
    bx = 0;
    ax = 0x0004;
    push(cs);
    cs = 0x0ec7;
    sub_ecb5();
    assert(cs == 0x0e15);
    es = pop();
    di = pop();
    memoryASet16(ds, 0x4e18, dx);
    memoryASet16(ds, 0x4e16, ax);
    ds = bp;
    if (dx != 0x0000)
        goto loc_e6e8;
    if (ax != 0x0000)
        goto loc_e6e8;
    ax = 0x1228;
    ds = ax;
    memoryASet16(ds, 0x4df8, bp);
    memoryASet16(ds, 0x4df6, si);
    ax = es;
    memoryASet16(ds, 0x4e00, ax);
    memoryASet16(ds, 0x4dfe, di);
    ax = memoryAGet16(ds, 0x4e26);
    push(ax);
    ax = memoryAGet16(ds, 0x4e24);
    push(ax);
    ax = memoryAGet16(ds, 0x4dfc);
    push(ax);
    ax = memoryAGet16(ds, 0x4dfa);
    push(ax);
    ax = memoryAGet16(ds, 0x4e0c);
    push(ax);
    ax = memoryAGet16(ds, 0x4e0a);
    push(ax);
    ax = memoryAGet16(ds, 0x4dfc);
    memoryASet16(ds, 0x4e0c, ax);
    ax = memoryAGet16(ds, 0x4dfa);
    memoryASet16(ds, 0x4e0a, ax);
    ax = memoryAGet16(ds, 0x4e2a);
    memoryASet16(ds, 0x4e26, ax);
    ax = memoryAGet16(ds, 0x4e28);
    memoryASet16(ds, 0x4e24, ax);
    sub_e1ce();
    ax = pop();
    memoryASet16(ds, 0x4e0a, ax);
    ax = pop();
    memoryASet16(ds, 0x4e0c, ax);
    ax = pop();
    memoryASet16(ds, 0x4dfa, ax);
    ax = pop();
    memoryASet16(ds, 0x4dfc, ax);
    ax = pop();
    memoryASet16(ds, 0x4e24, ax);
    ax = pop();
    memoryASet16(ds, 0x4e26, ax);
    if (memoryAGet16(ds, 0x4e14) != 0x0000)
        goto loc_e7bb;
    if (memoryAGet16(ds, 0x4e12) != 0x0002)
        goto loc_e7bb;
    goto loc_e5fe;
loc_e7bb:
    ax = memoryAGet16(ds, 0x4e26);
    push(ax);
    ax = memoryAGet16(ds, 0x4e24);
    push(ax);
    ax = memoryAGet16(ds, 0x4e2a);
    push(ax);
    ax = memoryAGet16(ds, 0x4e28);
    push(ax);
    ax = memoryAGet16(ds, 0x4e0c);
    push(ax);
    ax = memoryAGet16(ds, 0x4e0a);
    push(ax);
    ax = memoryAGet16(ds, 0x4e08);
    es = ax;
    di = memoryAGet16(ds, 0x4e06);
    bx = memoryAGet16(ds, 0x4e2a);
    ax = memoryAGet16(ds, 0x4e28);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e04, dx);
    memoryASet16(ds, 0x4e02, ax);
    bx = memoryAGet16(ds, 0x4e20);
    ax = memoryAGet16(ds, 0x4e1e);
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    bx = 0;
    ax = 0x000e;
    push(cs);
    cs = 0x0ec7;
    sub_ec70();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e08, dx);
    memoryASet16(ds, 0x4e06, ax);
    ax = memoryAGet16(ds, 0x4e0c);
    memoryASet16(ds, 0x4e00, ax);
    di = memoryAGet16(ds, 0x4e0a);
    memoryASet16(ds, 0x4dfe, di);
    es = ax;
    bx = 0;
    ax = 0x0400;
    push(cs);
    cs = 0x0ec7;
    sub_ecb5();
    assert(cs == 0x0e15);
    memoryASet16(ds, 0x4e00, dx);
    memoryASet16(ds, 0x4dfe, ax);
    ax = memoryAGet16(ds, 0x4dfc);
    memoryASet16(ds, 0x4e0c, ax);
    ax = memoryAGet16(ds, 0x4dfa);
    memoryASet16(ds, 0x4e0a, ax);
    ax = memoryAGet16(ds, 0x4e10);
    memoryASet16(ds, 0x4df8, ax);
    ax = memoryAGet16(ds, 0x4e0e);
    memoryASet16(ds, 0x4df6, ax);
    memoryASet16(ds, 0x4e1c, 0x0000);
    memoryASet16(ds, 0x4e1a, 0x0000);
    memoryASet16(ds, 0x4e14, 0x0000);
    memoryASet16(ds, 0x4e12, 0x0000);
    memoryASet16(ds, 0x4e18, 0x0000);
    memoryASet16(ds, 0x4e16, 0x0000);
loc_e86d:
    memoryASet16(ds, 0x4e16, memoryAGet16(ds, 0x4e16) - 0x0001);
    if ((short)memoryAGet16(ds, 0x4e16) >= 0)
        goto loc_e8c2;
    bp = ds;
    si = memoryAGet16(ds, 0x4e0a);
    ax = memoryAGet16(ds, 0x4e0c);
    ds = ax;
    dx = memoryAGet16(ds, si + 2);
    tl = dl;
    dl = dh;
    dh = tl;
    ax = memoryAGet16(ds, si);
    tl = al;
    al = ah;
    ah = tl;
    push(ax);
    push(dx);
    si += 0x0004;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    dx = pop();
    ax = pop();
    cx = ds;
    ds = bp;
    memoryASet16(ds, 0x4e0c, cx);
    memoryASet16(ds, 0x4e0a, si);
    memoryASet16(ds, 0x4e16, 0x001f);
    memoryASet16(ds, 0x4e26, ax);
    memoryASet16(ds, 0x4e24, dx);
loc_e8c2:
    dx = memoryAGet16(ds, 0x4e26);
    ax = memoryAGet16(ds, 0x4e24);
    flags.carry = !!(ax & 0x8000);
    ax <<= 1;
    dx = rcl(dx, 0x0001);
    memoryASet16(ds, 0x4e26, dx);
    memoryASet16(ds, 0x4e24, ax);
    if (!flags.carry)
        goto loc_e8d9;
    goto loc_ea27;
loc_e8d9:
    ax = memoryAGet16(ds, 0x4df8);
    es = ax;
    di = memoryAGet16(ds, 0x4df6);
    si = memoryAGet16(ds, 0x4e06);
    ax = memoryAGet16(ds, 0x4e08);
    ds = ax;
    al = memoryAGet(ds, si);
    memoryASet(es, di, al);
    si += 0x0001;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    bp = ds;
    di += 0x0001;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    ax = 0x1228;
    ds = ax;
    memoryASet16(ds, 0x4e08, bp);
    memoryASet16(ds, 0x4e06, si);
    ax = es;
    memoryASet16(ds, 0x4df8, ax);
    memoryASet16(ds, 0x4df6, di);
    flags.carry = (memoryAGet16(ds, 0x4e12) + 0x0001) >= 0x10000;
    memoryASet16(ds, 0x4e12, memoryAGet16(ds, 0x4e12) + 0x0001);
    if (!flags.carry)
        goto loc_e937;
    memoryASet16(ds, 0x4e14, memoryAGet16(ds, 0x4e14) + 1);
loc_e937:
    dx = memoryAGet16(ds, 0x4e00);
    ax = memoryAGet16(ds, 0x4dfe);
    if (dx != memoryAGet16(ds, 0x4df8))
        goto loc_e962;
    if (ax != memoryAGet16(ds, 0x4df6))
        goto loc_e962;
    ax = 0x1228;
    memoryASet16(ds, 0x4df8, ax);
    ax = 0x4e97;
    memoryASet16(ds, 0x4df6, ax);
    memoryASet16(ds, 0x4e1c, 0x0000);
    memoryASet16(ds, 0x4e1a, 0x0001);
loc_e962:
    dx = memoryAGet16(ds, 0x4e08);
    ax = memoryAGet16(ds, 0x4e06);
    if (dx != memoryAGet16(ds, 0x4e04))
        goto loc_e978;
    if (ax != memoryAGet16(ds, 0x4e02))
        goto loc_e978;
    goto loc_ea84;
loc_e978:
    dx = memoryAGet16(ds, 0x4e08);
    ax = memoryAGet16(ds, 0x4e06);
    if (dx <= memoryAGet16(ds, 0x4df8))
        goto loc_e988;
    goto loc_e86d;
loc_e988:
    if (dx != memoryAGet16(ds, 0x4df8))
        goto loc_e993;
    if (ax <= memoryAGet16(ds, 0x4df6))
        goto loc_e993;
    goto loc_e86d;
loc_e993:
    if (memoryAGet16(ds, 0x4e1c) == 0x0000)
        goto loc_e99d;
    goto loc_e86d;
loc_e99d:
    if (memoryAGet16(ds, 0x4e1a) == 0x0000)
        goto loc_e9a7;
    goto loc_e86d;
loc_e9a7:
    ax = memoryAGet16(ds, 0x4e0c);
    memoryASet16(ds, 0x4dfc, ax);
    ax = memoryAGet16(ds, 0x4e0a);
    memoryASet16(ds, 0x4dfa, ax);
    dx = memoryAGet16(ds, 0x4e08);
    cx = memoryAGet16(ds, 0x4e06);
    ax = memoryAGet16(ds, 0x4dfc);
    es = ax;
    di = memoryAGet16(ds, 0x4dfa);
    si = memoryAGet16(ds, 0x4e02);
    ax = memoryAGet16(ds, 0x4e04);
    ds = ax;
loc_e9cd:
    flags.carry = si < 0x0001;
    si -= 0x0001;
    if (!flags.carry)
        goto loc_e9da;
    si += 0x0010;
    ax = ds;
    ax--;
    ds = ax;
loc_e9da:
    flags.carry = di < 0x0001;
    di -= 0x0001;
    if (!flags.carry)
        goto loc_e9e7;
    di += 0x0010;
    ax = es;
    ax--;
    es = ax;
loc_e9e7:
    al = memoryAGet(ds, si);
    memoryASet(es, di, al);
    ax = ds;
    if (dx != ax)
        goto loc_e9cd;
    if (cx != si)
        goto loc_e9cd;
    ax = 0x1228;
    ds = ax;
    memoryASet16(ds, 0x4e04, bp);
    memoryASet16(ds, 0x4e02, si);
    ax = es;
    memoryASet16(ds, 0x4dfc, ax);
    memoryASet16(ds, 0x4dfa, di);
    ax = memoryAGet16(ds, 0x4dfc);
    memoryASet16(ds, 0x4e08, ax);
    ax = memoryAGet16(ds, 0x4dfa);
    memoryASet16(ds, 0x4e06, ax);
    ax = memoryAGet16(ds, 0x4e0c);
    memoryASet16(ds, 0x4e04, ax);
    ax = memoryAGet16(ds, 0x4e0a);
    memoryASet16(ds, 0x4e02, ax);
    goto loc_e86d;
loc_ea27:
    ax = memoryAGet16(ds, 0x4df8);
    es = ax;
    di = memoryAGet16(ds, 0x4df6);
    al = memoryAGet(ds, 0x4e22);
    memoryASet(es, di, al);
    di += 0x0001;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    ax = es;
    memoryASet16(ds, 0x4df8, ax);
    memoryASet16(ds, 0x4df6, di);
    flags.carry = (memoryAGet16(ds, 0x4e12) + 0x0001) >= 0x10000;
    memoryASet16(ds, 0x4e12, memoryAGet16(ds, 0x4e12) + 0x0001);
    if (!flags.carry)
        goto loc_ea56;
    memoryASet16(ds, 0x4e14, memoryAGet16(ds, 0x4e14) + 1);
loc_ea56:
    dx = memoryAGet16(ds, 0x4e00);
    ax = memoryAGet16(ds, 0x4dfe);
    if (dx != memoryAGet16(ds, 0x4df8))
        goto loc_ea81;
    if (ax != memoryAGet16(ds, 0x4df6))
        goto loc_ea81;
    ax = 0x1228;
    memoryASet16(ds, 0x4df8, ax);
    ax = 0x4e97;
    memoryASet16(ds, 0x4df6, ax);
    memoryASet16(ds, 0x4e1c, 0x0000);
    memoryASet16(ds, 0x4e1a, 0x0001);
loc_ea81:
    goto loc_e978;
loc_ea84:
    ax = pop();
    memoryASet16(ds, 0x4e0a, ax);
    ax = pop();
    memoryASet16(ds, 0x4e0c, ax);
    ax = pop();
    memoryASet16(ds, 0x4e28, ax);
    ax = pop();
    memoryASet16(ds, 0x4e2a, ax);
    ax = pop();
    memoryASet16(ds, 0x4e24, ax);
    ax = pop();
    memoryASet16(ds, 0x4e26, ax);
loc_ea9c:
    al = memoryAGet(ds, 0x4e22);
    memoryASet(es, di, al);
    di += 0x0001;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    flags.carry = (memoryAGet16(ds, 0x4e12) + 0x0001) >= 0x10000;
    memoryASet16(ds, 0x4e12, memoryAGet16(ds, 0x4e12) + 0x0001);
    if (!flags.carry)
        goto loc_eab9;
    memoryASet16(ds, 0x4e14, memoryAGet16(ds, 0x4e14) + 1);
loc_eab9:
    dx = memoryAGet16(ds, 0x4e00);
    ax = memoryAGet16(ds, 0x4dfe);
    if (dx != memoryAGet16(ds, 0x4df8))
        goto loc_eae4;
    if (ax != memoryAGet16(ds, 0x4df6))
        goto loc_eae4;
    ax = 0x1228;
    memoryASet16(ds, 0x4df8, ax);
    ax = 0x4e97;
    memoryASet16(ds, 0x4df6, ax);
    memoryASet16(ds, 0x4e1c, 0x0000);
    memoryASet16(ds, 0x4e1a, 0x0001);
loc_eae4:
    dx = memoryAGet16(ds, 0x4e26);
    ax = memoryAGet16(ds, 0x4e24);
    if (dx > memoryAGet16(ds, 0x4e14))
        goto loc_ea9c;
    if (dx != memoryAGet16(ds, 0x4e14))
        goto loc_eaf9;
    if (ax > memoryAGet16(ds, 0x4e12))
        goto loc_ea9c;
loc_eaf9:
    ax = 0x1228;
    memoryASet16(ds, 0x4df8, ax);
    ax = 0x4e97;
    memoryASet16(ds, 0x4df6, ax);
    cx = 0x0400;
    cx >>= 1;
    cx >>= 1;
    ax = memoryAGet16(ds, 0x4e00);
    es = ax;
    di = memoryAGet16(ds, 0x4dfe);
    si = memoryAGet16(ds, 0x4df6);
    ax = memoryAGet16(ds, 0x4df8);
    ds = ax;
loc_eb1e:
    ax = memoryAGet16(ds, si + 2);
    memoryASet16(es, di + 2, ax);
    ax = memoryAGet16(ds, si);
    memoryASet16(es, di, ax);
    si += 0x0004;
    push(di);
    push(bp);
    push(es);
    ax = ds;
    es = ax;
    di = si;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    ds = dx;
    si = ax;
    es = pop();
    bp = pop();
    di = pop();
    di += 0x0004;
    push(cs);
    cs = 0x0ec7;
    sub_ecf9();
    assert(cs == 0x0e15);
    es = dx;
    di = ax;
    if (--cx)
        goto loc_eb1e;
    ax = 0x1228;
    ds = ax;
    ax = 0x0001;
}
/* Assembly listing of 0e15:0a09 sub_eb59()
sub_eb59 PROC
0e15:0a09	mov	ax, word ptr [0x4e2a]
0e15:0a0c	push	ax
0e15:0a0d	mov	ax, word ptr [0x4e28]
0e15:0a10	push	ax
0e15:0a11	mov	ax, word ptr [0x4e0c]
0e15:0a14	push	ax
0e15:0a15	mov	ax, word ptr [0x4e0a]
0e15:0a18	push	ax
0e15:0a19	mov	ax, word ptr [0x4e10]
0e15:0a1c	mov	es, ax
0e15:0a1e	push	ax
0e15:0a1f	mov	ax, word ptr [0x4e0e]
0e15:0a22	mov	di, ax
0e15:0a24	push	ax
0e15:0a25	mov	ax, word ptr es:[di]
0e15:0a28	xchg	al, ah
0e15:0a2a	mov	bx, word ptr es:[di + 2]
0e15:0a2e	xchg	bl, bh
0e15:0a30	mov	word ptr [0x4e26], ax
0e15:0a33	mov	word ptr [0x4e24], bx
0e15:0a37	mov	word ptr [0x4e35], ax
0e15:0a3a	mov	word ptr [0x4e33], bx
0e15:0a3e	cmp	ax, 0xf
0e15:0a41	ja	loc_ec06
0e15:0a43	nop	
0e15:0a44	nop	
0e15:0a45	nop	
0e15:0a46	cmp	ax, 0xf
0e15:0a49	jne	loc_eba0
0e15:0a4b	cmp	bx, -1
0e15:0a4e	ja	loc_ec06
        	loc_eba0:
0e15:0a50	mov	ax, word ptr es:[di + 6]
0e15:0a54	xchg	al, ah
0e15:0a56	mov	bx, word ptr es:[di + 4]
0e15:0a5a	xchg	bl, bh
0e15:0a5c	mov	word ptr [0x4e20], ax
0e15:0a5f	mov	word ptr [0x4e1e], bx
0e15:0a63	mov	ax, word ptr es:[di + 8]
0e15:0a67	xchg	al, ah
0e15:0a69	mov	word ptr [0x4e31], ax
0e15:0a6c	mov	si, ax
0e15:0a6e	and	si, 0x3f
0e15:0a71	cmp	si, 0x1e
0e15:0a74	ja	loc_ec06
0e15:0a76	add	si, si
0e15:0a78	mov	bx, word ptr [si + 0x4e5b]
0e15:0a7c	xchg	bl, bh
0e15:0a7e	cmp	bx, 0
0e15:0a81	jl	loc_ec06
0e15:0a83	mov	si, ax
0e15:0a85	and	si, 0x7f00
0e15:0a89	jne	loc_ec06
0e15:0a8b	mov	bx, word ptr [0x4e26]
0e15:0a8f	mov	ax, word ptr [0x4e24]
0e15:0a92	mov	si, word ptr [0x4e31]
0e15:0a96	xor	si, bx
0e15:0a98	xor	si, ax
0e15:0a9a	mov	word ptr [0x4e26], bx
0e15:0a9e	mov	word ptr [0x4e24], ax
0e15:0aa1	mov	ax, word ptr [0x4e20]
0e15:0aa4	mov	bx, word ptr [0x4e1e]
0e15:0aa8	xor	si, bx
0e15:0aaa	xor	si, ax
0e15:0aac	mov	ax, word ptr es:[di + 0xa]
0e15:0ab0	xchg	al, ah
0e15:0ab2	cmp	si, ax
0e15:0ab4	je	loc_ec07
        	loc_ec06:
0e15:0ab6	stc	
        	loc_ec07:
0e15:0ab7	pop	ax
0e15:0ab8	mov	word ptr [0x4e0e], ax
0e15:0abb	pop	ax
0e15:0abc	mov	word ptr [0x4e10], ax
0e15:0abf	pop	ax
0e15:0ac0	mov	word ptr [0x4e0a], ax
0e15:0ac3	pop	ax
0e15:0ac4	mov	word ptr [0x4e0c], ax
0e15:0ac7	pop	ax
0e15:0ac8	mov	word ptr [0x4e28], ax
0e15:0acb	pop	ax
0e15:0acc	mov	word ptr [0x4e2a], ax
0e15:0acf	ret	
sub_eb59 ENDP
*/
void sub_eb59()
{
    // coverage: 0xde89-0xdf50 method sub_eb59
    ax = memoryAGet16(ds, 0x4e2a);
    push(ax);
    ax = memoryAGet16(ds, 0x4e28);
    push(ax);
    ax = memoryAGet16(ds, 0x4e0c);
    push(ax);
    ax = memoryAGet16(ds, 0x4e0a);
    push(ax);
    ax = memoryAGet16(ds, 0x4e10);
    es = ax;
    push(ax);
    ax = memoryAGet16(ds, 0x4e0e);
    di = ax;
    push(ax);
    ax = memoryAGet16(es, di);
    tl = al;
    al = ah;
    ah = tl;
    bx = memoryAGet16(es, di + 2);
    tl = bl;
    bl = bh;
    bh = tl;
    memoryASet16(ds, 0x4e26, ax);
    memoryASet16(ds, 0x4e24, bx);
    memoryASet16(ds, 0x4e35, ax);
    memoryASet16(ds, 0x4e33, bx);
    if (ax > 0x000f)
        goto loc_ec06;
    if (ax != 0x000f)
        goto loc_eba0;
    if (bx > 0xffff)
        goto loc_ec06;
loc_eba0:
    ax = memoryAGet16(es, di + 6);
    tl = al;
    al = ah;
    ah = tl;
    bx = memoryAGet16(es, di + 4);
    tl = bl;
    bl = bh;
    bh = tl;
    memoryASet16(ds, 0x4e20, ax);
    memoryASet16(ds, 0x4e1e, bx);
    ax = memoryAGet16(es, di + 8);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(ds, 0x4e31, ax);
    si = ax;
    si &= 0x003f;
    if (si > 0x001e)
        goto loc_ec06;
    si += si;
    bx = memoryAGet16(ds, si + 20059);
    tl = bl;
    bl = bh;
    bh = tl;
    if ((short)bx < (short)0x0000)
        goto loc_ec06;
    si = ax;
    si &= 0x7f00;
    if (si != 0)
        goto loc_ec06;
    bx = memoryAGet16(ds, 0x4e26);
    ax = memoryAGet16(ds, 0x4e24);
    si = memoryAGet16(ds, 0x4e31);
    si ^= bx;
    si ^= ax;
    memoryASet16(ds, 0x4e26, bx);
    memoryASet16(ds, 0x4e24, ax);
    ax = memoryAGet16(ds, 0x4e20);
    bx = memoryAGet16(ds, 0x4e1e);
    si ^= bx;
    si ^= ax;
    ax = memoryAGet16(es, di + 10);
    tl = al;
    al = ah;
    ah = tl;
    if (si == ax)
        goto loc_ec07;
loc_ec06:
    flags.carry = true;
loc_ec07:
    ax = pop();
    memoryASet16(ds, 0x4e0e, ax);
    ax = pop();
    memoryASet16(ds, 0x4e10, ax);
    ax = pop();
    memoryASet16(ds, 0x4e0a, ax);
    ax = pop();
    memoryASet16(ds, 0x4e0c, ax);
    ax = pop();
    memoryASet16(ds, 0x4e28, ax);
    ax = pop();
    memoryASet16(ds, 0x4e2a, ax);
}
/* Assembly listing of 0ec2:0000 sub_ec20()
sub_ec20 PROC
0ec2:0000	push	di
0ec2:0001	push	si
0ec2:0002	push	bp
0ec2:0003	push	ds
0ec2:0004	push	es
0ec2:0005	add	ax, 0xf
0ec2:0008	jae	loc_ec2b
0ec2:000a	inc	dx
        	loc_ec2b:
0ec2:000b	shr	dx, 1
0ec2:000d	rcr	ax, 1
0ec2:000f	shr	dx, 1
0ec2:0011	rcr	ax, 1
0ec2:0013	shr	dx, 1
0ec2:0015	rcr	ax, 1
0ec2:0017	shr	dx, 1
0ec2:0019	rcr	ax, 1
0ec2:001b	mov	bx, ax
0ec2:001d	mov	ah, 0x48
0ec2:001f	int	0x21
0ec2:0021	jb	loc_ec48
0ec2:0023	xor	dx, dx
0ec2:0025	xchg	dx, ax
0ec2:0026	jmp	loc_ec4c
        	loc_ec48:
0ec2:0028	xor	dx, dx
0ec2:002a	xor	ax, ax
        	loc_ec4c:
0ec2:002c	pop	es
0ec2:002d	pop	ds
0ec2:002e	pop	bp
0ec2:002f	pop	si
0ec2:0030	pop	di
0ec2:0031	retf	
sub_ec20 ENDP
*/
void sub_ec20()
{
    // coverage: 0xdf50-0xdf82 method sub_ec20
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    flags.carry = (ax + 0x000f) >= 0x10000;
    ax += 0x000f;
    if (!flags.carry)
        goto loc_ec2b;
    dx++;
loc_ec2b:
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = dx & 1;
    dx >>= 1;
    ax = rcr(ax, 0x0001);
    bx = ax;
    ah = 0x48;
    interrupt(0x21);
    if (flags.carry)
        goto loc_ec48;
    dx = 0;
    tx = dx;
    dx = ax;
    ax = tx;
    goto loc_ec4c;
loc_ec48:
    dx = 0;
    ax = 0;
loc_ec4c:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ec2:0032 sub_ec52()
sub_ec52 PROC
0ec2:0032	push	di
0ec2:0033	push	si
0ec2:0034	push	bp
0ec2:0035	push	ds
0ec2:0036	push	es
0ec2:0037	mov	es, ax
0ec2:0039	mov	ah, 0x49
0ec2:003b	int	0x21
0ec2:003d	pop	es
0ec2:003e	pop	ds
0ec2:003f	pop	bp
0ec2:0040	pop	si
0ec2:0041	pop	di
0ec2:0042	retf	
sub_ec52 ENDP
*/
void sub_ec52()
{
    // coverage: 0xdf82-0xdf93 method sub_ec52
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    es = ax;
    ah = 0x49;
    interrupt(0x21);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ec7:0000 sub_ec70()
sub_ec70 PROC
0ec7:0000	push	di
0ec7:0001	push	si
0ec7:0002	push	bp
0ec7:0003	push	ds
0ec7:0004	push	es
0ec7:0005	mov	bp, 0x1228
0ec7:0008	mov	ds, bp
0ec7:000a	push	ax
0ec7:000b	push	bx
0ec7:000c	push	cs
0ec7:000d	call	0x89
0ec7:0010	mov	es, dx
0ec7:0012	mov	di, ax
0ec7:0014	pop	bx
0ec7:0015	pop	ax
0ec7:0016	mov	cx, ax
0ec7:0018	shr	bx, 1
0ec7:001a	rcr	ax, 1
0ec7:001c	shr	bx, 1
0ec7:001e	rcr	ax, 1
0ec7:0020	shr	bx, 1
0ec7:0022	rcr	ax, 1
0ec7:0024	shr	bx, 1
0ec7:0026	rcr	ax, 1
0ec7:0028	mov	bx, cx
0ec7:002a	and	bx, 0xf
0ec7:002d	add	bx, di
0ec7:002f	mov	dx, bx
0ec7:0031	mov	bx, es
0ec7:0033	add	ax, bx
0ec7:0035	xchg	dx, ax
0ec7:0036	cmp	ax, 0xf
0ec7:0039	jle	loc_ecaf
0ec7:003b	and	ax, 0xf
0ec7:003e	inc	dx
        	loc_ecaf:
0ec7:003f	pop	es
0ec7:0040	pop	ds
0ec7:0041	pop	bp
0ec7:0042	pop	si
0ec7:0043	pop	di
0ec7:0044	retf	
sub_ec70 ENDP
*/
void sub_ec70()
{
    // coverage: 0xdfa0-0xdfe5 method sub_ec70
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bp = 0x1228;
    ds = bp;
    push(ax);
    push(bx);
    push(cs);
    sub_ecf9();
    es = dx;
    di = ax;
    bx = pop();
    ax = pop();
    cx = ax;
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    bx = cx;
    bx &= 0x000f;
    bx += di;
    dx = bx;
    bx = es;
    ax += bx;
    tx = dx;
    dx = ax;
    ax = tx;
    if ((short)ax <= (short)0x000f)
        goto loc_ecaf;
    ax &= 0x000f;
    dx++;
loc_ecaf:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ec7:0045 sub_ecb5()
sub_ecb5 PROC
0ec7:0045	push	di
0ec7:0046	push	si
0ec7:0047	push	bp
0ec7:0048	push	ds
0ec7:0049	push	es
0ec7:004a	mov	bp, 0x1228
0ec7:004d	mov	ds, bp
0ec7:004f	push	ax
0ec7:0050	push	bx
0ec7:0051	push	cs
0ec7:0052	call	0x89
0ec7:0055	mov	es, dx
0ec7:0057	mov	di, ax
0ec7:0059	pop	bx
0ec7:005a	pop	ax
0ec7:005b	mov	cx, ax
0ec7:005d	shr	bx, 1
0ec7:005f	rcr	ax, 1
0ec7:0061	shr	bx, 1
0ec7:0063	rcr	ax, 1
0ec7:0065	shr	bx, 1
0ec7:0067	rcr	ax, 1
0ec7:0069	shr	bx, 1
0ec7:006b	rcr	ax, 1
0ec7:006d	mov	bx, cx
0ec7:006f	and	bx, 0xf
0ec7:0072	sub	di, bx
0ec7:0074	jae	loc_ecea
0ec7:0076	add	di, 0x10
0ec7:0079	inc	ax
        	loc_ecea:
0ec7:007a	mov	dx, di
0ec7:007c	mov	bx, es
0ec7:007e	sub	bx, ax
0ec7:0080	mov	ax, bx
0ec7:0082	xchg	dx, ax
0ec7:0083	pop	es
0ec7:0084	pop	ds
0ec7:0085	pop	bp
0ec7:0086	pop	si
0ec7:0087	pop	di
0ec7:0088	retf	
sub_ecb5 ENDP
*/
void sub_ecb5()
{
    // coverage: 0xdfe5-0xe029 method sub_ecb5
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bp = 0x1228;
    ds = bp;
    push(ax);
    push(bx);
    push(cs);
    sub_ecf9();
    es = dx;
    di = ax;
    bx = pop();
    ax = pop();
    cx = ax;
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    flags.carry = bx & 1;
    bx >>= 1;
    ax = rcr(ax, 0x0001);
    bx = cx;
    bx &= 0x000f;
    flags.carry = di < bx;
    di -= bx;
    if (!flags.carry)
        goto loc_ecea;
    di += 0x0010;
    ax++;
loc_ecea:
    dx = di;
    bx = es;
    bx -= ax;
    ax = bx;
    tx = dx;
    dx = ax;
    ax = tx;
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ec7:0089 sub_ecf9()
sub_ecf9 PROC
0ec7:0089	push	di
0ec7:008a	push	si
0ec7:008b	push	bp
0ec7:008c	push	ds
0ec7:008d	push	es
0ec7:008e	mov	ax, di
0ec7:0090	and	di, 0xf
0ec7:0093	shr	ax, 1
0ec7:0095	shr	ax, 1
0ec7:0097	shr	ax, 1
0ec7:0099	shr	ax, 1
0ec7:009b	mov	bx, es
0ec7:009d	add	ax, bx
0ec7:009f	mov	dx, ax
0ec7:00a1	mov	ax, di
0ec7:00a3	pop	es
0ec7:00a4	pop	ds
0ec7:00a5	pop	bp
0ec7:00a6	pop	si
0ec7:00a7	pop	di
0ec7:00a8	retf	
sub_ecf9 ENDP
*/
void sub_ecf9()
{
    // coverage: 0xe029-0xe049 method sub_ecf9
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = di;
    di &= 0x000f;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    bx = es;
    ax += bx;
    dx = ax;
    ax = di;
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed2:0000 sub_ed20()
sub_ed20 PROC
0ed2:0000	push	di
0ed2:0001	push	si
0ed2:0002	push	bp
0ed2:0003	push	ds
0ed2:0004	push	es
0ed2:0005	mov	bx, 0x1228
0ed2:0008	mov	ds, bx
0ed2:000a	mov	word ptr [0x5676], ax
0ed2:000d	mov	word ptr [0x5678], 0
0ed2:0013	mov	word ptr [0x567a], 0
0ed2:0019	pop	es
0ed2:001a	pop	ds
0ed2:001b	pop	bp
0ed2:001c	pop	si
0ed2:001d	pop	di
0ed2:001e	retf	
sub_ed20 ENDP
*/
void sub_ed20()
{
    // coverage: 0xe050-0xe06f method sub_ed20
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    memoryASet16(ds, 0x5676, ax);
    memoryASet16(ds, 0x5678, 0x0000);
    memoryASet16(ds, 0x567a, 0x0000);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed2:001f sub_ed3f()
sub_ed3f PROC
0ed2:001f	push	di
0ed2:0020	push	si
0ed2:0021	push	bp
0ed2:0022	push	ds
0ed2:0023	push	es
0ed2:0024	mov	ax, 0x1228
0ed2:0027	mov	ds, ax
0ed2:0029	mov	bx, word ptr [0x5678]
0ed2:002d	mov	bp, word ptr [0x567a]
0ed2:0031	mov	ax, bp
0ed2:0033	add	ax, 0x2432
0ed2:0036	xor	ax, bx
0ed2:0038	xor	ax, word ptr [0x5676]
0ed2:003c	mov	bp, ax
0ed2:003e	ror	ax, 1
0ed2:0040	sub	ax, word ptr [0x5676]
0ed2:0044	xor	ax, bx
0ed2:0046	add	ax, 0x1c12
0ed2:0049	xor	ax, bp
0ed2:004b	ror	ax, 1
0ed2:004d	add	ax, bp
0ed2:004f	rcr	ax, 1
0ed2:0051	mov	bx, ax
0ed2:0053	mov	ax, word ptr [0x5676]
0ed2:0056	add	ax, bp
0ed2:0058	xor	ax, 0x3812
0ed2:005b	xor	ax, bx
0ed2:005d	mov	word ptr [0x5676], ax
0ed2:0060	mov	word ptr [0x5678], bx
0ed2:0064	mov	word ptr [0x567a], bp
0ed2:0068	pop	es
0ed2:0069	pop	ds
0ed2:006a	pop	bp
0ed2:006b	pop	si
0ed2:006c	pop	di
0ed2:006d	retf	
sub_ed3f ENDP
*/
void sub_ed3f()
{
    // coverage: 0xe06f-0xe0be method sub_ed3f
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    bx = memoryAGet16(ds, 0x5678);
    bp = memoryAGet16(ds, 0x567a);
    ax = bp;
    ax += 0x2432;
    ax ^= bx;
    ax ^= memoryAGet16(ds, 0x5676);
    bp = ax;
    ax = ror(ax, 0x0001);
    ax -= memoryAGet16(ds, 0x5676);
    ax ^= bx;
    ax += 0x1c12;
    ax ^= bp;
    ax = ror(ax, 0x0001);
    flags.carry = (ax + bp) >= 0x10000;
    ax += bp;
    ax = rcr(ax, 0x0001);
    bx = ax;
    ax = memoryAGet16(ds, 0x5676);
    ax += bp;
    ax ^= 0x3812;
    ax ^= bx;
    memoryASet16(ds, 0x5676, ax);
    memoryASet16(ds, 0x5678, bx);
    memoryASet16(ds, 0x567a, bp);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:0c34 sub_f9c4()
sub_f9c4 PROC
        	loc_f9c4:
0ed9:0c34	mov	ax, es
0ed9:0c36	mov	bx, word ptr es:[di]
0ed9:0c39	xchg	bl, bh
0ed9:0c3b	ror	bx, 1
0ed9:0c3d	ror	bx, 1
0ed9:0c3f	ror	bx, 1
0ed9:0c41	ror	bx, 1
0ed9:0c43	add	ax, bx
0ed9:0c45	mov	cx, bx
0ed9:0c47	mov	bx, word ptr es:[di + 2]
0ed9:0c4b	or	cx, bx
0ed9:0c4d	je	loc_fa06
0ed9:0c4f	xchg	bl, bh
0ed9:0c51	mov	cx, bx
0ed9:0c53	and	cx, 0xf
0ed9:0c56	add	cx, 0x800
0ed9:0c5a	and	bx, 0xfff0
0ed9:0c5d	shr	bx, 1
0ed9:0c5f	shr	bx, 1
0ed9:0c61	shr	bx, 1
0ed9:0c63	shr	bx, 1
0ed9:0c65	add	ax, bx
0ed9:0c67	mov	word ptr es:[di + 2], ax
0ed9:0c6b	mov	word ptr es:[di], cx
0ed9:0c6e	call	0xc77
0ed9:0c71	add	di, 4
0ed9:0c74	jmp	loc_f9c4
        	loc_fa06:
0ed9:0c76	ret	
sub_f9c4 ENDP
*/
void sub_f9c4()
{
    // coverage: 0xecf4-0xed37 method sub_f9c4
loc_f9c4:
    ax = es;
    bx = memoryAGet16(es, di);
    tl = bl;
    bl = bh;
    bh = tl;
    bx = ror(bx, 0x0001);
    bx = ror(bx, 0x0001);
    bx = ror(bx, 0x0001);
    bx = ror(bx, 0x0001);
    ax += bx;
    cx = bx;
    bx = memoryAGet16(es, di + 2);
    cx |= bx;
    if (!cx)
        return;
    tl = bl;
    bl = bh;
    bh = tl;
    cx = bx;
    cx &= 0x000f;
    cx += 0x0800;
    bx &= 0xfff0;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    ax += bx;
    memoryASet16(es, di + 2, ax);
    memoryASet16(es, di, cx);
    sub_fa07();
    di += 0x0004;
    goto loc_f9c4;
}
/* Assembly listing of 0ed9:0c77 sub_fa07()
sub_fa07 PROC
0ed9:0c77	push	ds
0ed9:0c78	push	di
0ed9:0c79	push	si
0ed9:0c7a	push	ax
0ed9:0c7b	push	cx
0ed9:0c7c	mov	ax, word ptr [0x541d]
0ed9:0c7f	mov	word ptr cs:[0xded], ax
0ed9:0c83	lds	di, ptr es:[di]
0ed9:0c86	mov	cx, word ptr [di - 2]
0ed9:0c89	xchg	cl, ch
0ed9:0c8b	mov	word ptr [di - 2], cx
0ed9:0c8e	and	cx, cx
0ed9:0c90	js	loc_fa26
0ed9:0c92	je	loc_fa26
0ed9:0c94	jmp	loc_fa29
        	loc_fa26:
0ed9:0c96	jmp	loc_fb77
        	loc_fa29:
0ed9:0c99	mov	ax, word ptr [di - 4]
0ed9:0c9c	xchg	al, ah
0ed9:0c9e	mov	word ptr [di - 4], ax
0ed9:0ca1	mov	ax, word ptr [di - 6]
0ed9:0ca4	xchg	al, ah
0ed9:0ca6	mov	word ptr [di - 6], ax
0ed9:0ca9	mov	ax, word ptr [di - 8]
0ed9:0cac	xchg	al, ah
0ed9:0cae	mov	word ptr [di - 8], ax
0ed9:0cb1	mov	ax, word ptr [di - 0xc]
0ed9:0cb4	xchg	al, ah
0ed9:0cb6	mov	word ptr [di - 0xc], ax
0ed9:0cb9	mov	ax, word ptr [di - 0xa]
0ed9:0cbc	xchg	ah, al
0ed9:0cbe	mov	word ptr [di - 0xa], ax
0ed9:0cc1	and	al, 0xc0
0ed9:0cc3	jne	loc_fa26
0ed9:0cc5	mov	si, di
0ed9:0cc7	mov	ax, word ptr cs:[0xded]
0ed9:0ccb	cmp	ax, 0
0ed9:0cce	je	loc_fa63
0ed9:0cd0	jmp	loc_fb3c
        	loc_fa63:
0ed9:0cd3	mov	ax, word ptr [di - 4]
0ed9:0cd6	shr	ax, 1
0ed9:0cd8	shr	ax, 1
0ed9:0cda	mov	dx, ax
0ed9:0cdc	and	dx, dx
0ed9:0cde	js	loc_fa26
0ed9:0ce0	je	loc_fa26
        	loc_fa72:
0ed9:0ce2	mov	al, byte ptr [si + 2]
0ed9:0ce5	mov	ah, byte ptr [si + 1]
0ed9:0ce8	mov	byte ptr [si + 1], al
0ed9:0ceb	mov	al, byte ptr [si + 4]
0ed9:0cee	mov	byte ptr [si + 4], ah
0ed9:0cf1	mov	byte ptr [si + 2], al
0ed9:0cf4	mov	al, byte ptr [si + 6]
0ed9:0cf7	mov	ah, byte ptr [si + 3]
0ed9:0cfa	mov	byte ptr [si + 3], al
0ed9:0cfd	mov	al, byte ptr [si + 5]
0ed9:0d00	mov	byte ptr [si + 5], ah
0ed9:0d03	mov	byte ptr [si + 6], al
0ed9:0d06	mov	ax, word ptr [si]
0ed9:0d08	shl	al, 1
0ed9:0d0a	rcl	bx, 1
0ed9:0d0c	shl	ah, 1
0ed9:0d0e	rcl	bx, 1
0ed9:0d10	shl	al, 1
0ed9:0d12	rcl	bx, 1
0ed9:0d14	shl	ah, 1
0ed9:0d16	rcl	bx, 1
0ed9:0d18	shl	al, 1
0ed9:0d1a	rcl	bx, 1
0ed9:0d1c	shl	ah, 1
0ed9:0d1e	rcl	bx, 1
0ed9:0d20	shl	al, 1
0ed9:0d22	rcl	bx, 1
0ed9:0d24	shl	ah, 1
0ed9:0d26	rcl	bx, 1
0ed9:0d28	shl	al, 1
0ed9:0d2a	rcl	bx, 1
0ed9:0d2c	shl	ah, 1
0ed9:0d2e	rcl	bx, 1
0ed9:0d30	shl	al, 1
0ed9:0d32	rcl	bx, 1
0ed9:0d34	shl	ah, 1
0ed9:0d36	rcl	bx, 1
0ed9:0d38	shl	al, 1
0ed9:0d3a	rcl	bx, 1
0ed9:0d3c	shl	ah, 1
0ed9:0d3e	rcl	bx, 1
0ed9:0d40	shl	al, 1
0ed9:0d42	rcl	bx, 1
0ed9:0d44	shl	ah, 1
0ed9:0d46	rcl	bx, 1
0ed9:0d48	xchg	bl, bh
0ed9:0d4a	mov	word ptr [si], bx
0ed9:0d4c	mov	ax, word ptr [si + 4]
0ed9:0d4f	shl	al, 1
0ed9:0d51	rcl	bx, 1
0ed9:0d53	shl	ah, 1
0ed9:0d55	rcl	bx, 1
0ed9:0d57	shl	al, 1
0ed9:0d59	rcl	bx, 1
0ed9:0d5b	shl	ah, 1
0ed9:0d5d	rcl	bx, 1
0ed9:0d5f	shl	al, 1
0ed9:0d61	rcl	bx, 1
0ed9:0d63	shl	ah, 1
0ed9:0d65	rcl	bx, 1
0ed9:0d67	shl	al, 1
0ed9:0d69	rcl	bx, 1
0ed9:0d6b	shl	ah, 1
0ed9:0d6d	rcl	bx, 1
0ed9:0d6f	shl	al, 1
0ed9:0d71	rcl	bx, 1
0ed9:0d73	shl	ah, 1
0ed9:0d75	rcl	bx, 1
0ed9:0d77	shl	al, 1
0ed9:0d79	rcl	bx, 1
0ed9:0d7b	shl	ah, 1
0ed9:0d7d	rcl	bx, 1
0ed9:0d7f	shl	al, 1
0ed9:0d81	rcl	bx, 1
0ed9:0d83	shl	ah, 1
0ed9:0d85	rcl	bx, 1
0ed9:0d87	shl	al, 1
0ed9:0d89	rcl	bx, 1
0ed9:0d8b	shl	ah, 1
0ed9:0d8d	rcl	bx, 1
0ed9:0d8f	xchg	bl, bh
0ed9:0d91	mov	word ptr [si + 4], bx
0ed9:0d94	xor	ax, ax
0ed9:0d96	mov	word ptr [si + 2], ax
0ed9:0d99	mov	word ptr [si + 6], ax
0ed9:0d9c	add	si, 8
0ed9:0d9f	dec	dx
0ed9:0da0	jne	loc_fb36
0ed9:0da2	loop	loc_fb39
0ed9:0da4	jmp	loc_fb77
        	loc_fb36:
0ed9:0da6	jmp	loc_fa72
        	loc_fb39:
0ed9:0da9	jmp	loc_fa63
        	loc_fb3c:
0ed9:0dac	mov	ax, word ptr [di - 4]
0ed9:0daf	shr	ax, 1
0ed9:0db1	shr	ax, 1
0ed9:0db3	mov	dx, ax
0ed9:0db5	and	dx, dx
0ed9:0db7	js	loc_fb77
0ed9:0db9	je	loc_fb77
        	loc_fb4b:
0ed9:0dbb	mov	al, byte ptr [si + 2]
0ed9:0dbe	mov	ah, byte ptr [si + 1]
0ed9:0dc1	mov	byte ptr [si + 1], al
0ed9:0dc4	mov	al, byte ptr [si + 4]
0ed9:0dc7	mov	byte ptr [si + 4], ah
0ed9:0dca	mov	byte ptr [si + 2], al
0ed9:0dcd	mov	al, byte ptr [si + 6]
0ed9:0dd0	mov	ah, byte ptr [si + 3]
0ed9:0dd3	mov	byte ptr [si + 3], al
0ed9:0dd6	mov	al, byte ptr [si + 5]
0ed9:0dd9	mov	byte ptr [si + 5], ah
0ed9:0ddc	mov	byte ptr [si + 6], al
0ed9:0ddf	add	si, 8
0ed9:0de2	dec	dx
0ed9:0de3	jne	loc_fb4b
0ed9:0de5	loop	loc_fb3c
        	loc_fb77:
0ed9:0de7	pop	cx
0ed9:0de8	pop	ax
0ed9:0de9	pop	si
0ed9:0dea	pop	di
0ed9:0deb	pop	ds
0ed9:0dec	ret	
sub_fa07 ENDP
*/
void sub_fa07()
{
    // coverage: 0xed37-0xeead method sub_fa07
    push(ds);
    push(di);
    push(si);
    push(ax);
    push(cx);
    ax = memoryAGet16(ds, 0x541d);
    memoryASet16(cs, 0x0ded, ax);
    tx = di;
    di = memoryAGet16(es, tx);
    ds = memoryAGet16(es, tx + 2);
    cx = memoryAGet16(ds, di + 65534);
    tl = cl;
    cl = ch;
    ch = tl;
    memoryASet16(ds, di + 65534, cx);
    if ((short)cx < 0)
        goto loc_fa26;
    if (cx == 0)
        goto loc_fa26;
    goto loc_fa29;
loc_fa26:
    goto loc_fb77;
loc_fa29:
    ax = memoryAGet16(ds, di + 65532);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(ds, di + 65532, ax);
    ax = memoryAGet16(ds, di + 65530);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(ds, di + 65530, ax);
    ax = memoryAGet16(ds, di + 65528);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(ds, di + 65528, ax);
    ax = memoryAGet16(ds, di + 65524);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(ds, di + 65524, ax);
    ax = memoryAGet16(ds, di + 65526);
    tl = ah;
    ah = al;
    al = tl;
    memoryASet16(ds, di + 65526, ax);
    al &= 0xc0;
    if (al != 0)
        goto loc_fa26;
    si = di;
    ax = memoryAGet16(cs, 0x0ded);
    if (ax == 0x0000)
        goto loc_fa63;
    goto loc_fb3c;
loc_fa63:
    ax = memoryAGet16(ds, di + 65532);
    ax >>= 1;
    ax >>= 1;
    dx = ax;
    if ((short)dx < 0)
        goto loc_fa26;
    if (dx == 0)
        goto loc_fa26;
loc_fa72:
    al = memoryAGet(ds, si + 2);
    ah = memoryAGet(ds, si + 1);
    memoryASet(ds, si + 1, al);
    al = memoryAGet(ds, si + 4);
    memoryASet(ds, si + 4, ah);
    memoryASet(ds, si + 2, al);
    al = memoryAGet(ds, si + 6);
    ah = memoryAGet(ds, si + 3);
    memoryASet(ds, si + 3, al);
    al = memoryAGet(ds, si + 5);
    memoryASet(ds, si + 5, ah);
    memoryASet(ds, si + 6, al);
    ax = memoryAGet16(ds, si);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    tl = bl;
    bl = bh;
    bh = tl;
    memoryASet16(ds, si, bx);
    ax = memoryAGet16(ds, si + 4);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(al & 0x80);
    al <<= 1;
    bx = rcl(bx, 0x0001);
    flags.carry = !!(ah & 0x80);
    ah <<= 1;
    bx = rcl(bx, 0x0001);
    tl = bl;
    bl = bh;
    bh = tl;
    memoryASet16(ds, si + 4, bx);
    ax = 0;
    memoryASet16(ds, si + 2, ax);
    memoryASet16(ds, si + 6, ax);
    si += 0x0008;
    tx = dx;
    dx--;
    if (tx != 1)
        goto loc_fb36;
    if (--cx)
        goto loc_fb39;
    goto loc_fb77;
loc_fb36:
    goto loc_fa72;
loc_fb39:
    goto loc_fa63;
loc_fb3c:
    ax = memoryAGet16(ds, di + 65532);
    ax >>= 1;
    ax >>= 1;
    dx = ax;
    if ((short)dx < 0)
        goto loc_fb77;
    if (dx == 0)
        goto loc_fb77;
loc_fb4b:
    al = memoryAGet(ds, si + 2);
    ah = memoryAGet(ds, si + 1);
    memoryASet(ds, si + 1, al);
    al = memoryAGet(ds, si + 4);
    memoryASet(ds, si + 4, ah);
    memoryASet(ds, si + 2, al);
    al = memoryAGet(ds, si + 6);
    ah = memoryAGet(ds, si + 3);
    memoryASet(ds, si + 3, al);
    al = memoryAGet(ds, si + 5);
    memoryASet(ds, si + 5, ah);
    memoryASet(ds, si + 6, al);
    si += 0x0008;
    tx = dx;
    dx--;
    if (tx != 1)
        goto loc_fb4b;
    if (--cx)
        goto loc_fb3c;
loc_fb77:
    cx = pop();
    ax = pop();
    si = pop();
    di = pop();
    ds = pop();
}
/* Assembly listing of 0ed9:0def sub_fb7f()
sub_fb7f PROC
0ed9:0def	mov	ax, word ptr [bp + 4]
0ed9:0df2	shr	ax, 1
0ed9:0df4	shr	ax, 1
0ed9:0df6	shr	ax, 1
0ed9:0df8	and	ax, 0xfffe
0ed9:0dfb	mov	word ptr [0x680d], ax
0ed9:0dfe	mov	dx, word ptr [bp + 8]
0ed9:0e01	inc	dx
0ed9:0e02	shr	dx, 1
0ed9:0e04	shr	dx, 1
0ed9:0e06	shr	dx, 1
0ed9:0e08	and	dx, 0xfffe
0ed9:0e0b	mov	word ptr [0x680f], dx
0ed9:0e0f	sub	dx, ax
0ed9:0e11	mov	word ptr [0x6815], dx
0ed9:0e15	mov	ax, word ptr [bp + 6]
0ed9:0e18	mov	word ptr [0x6811], ax
0ed9:0e1b	mov	dx, word ptr [bp + 0xa]
0ed9:0e1e	mov	word ptr [0x6813], dx
0ed9:0e22	sub	dx, ax
0ed9:0e24	mov	word ptr [0x6817], dx
0ed9:0e28	ret	
sub_fb7f ENDP
*/
void sub_fb7f()
{
    // coverage: 0xeeaf-0xeee9 method sub_fb7f
    ax = memoryAGet16(ss, bp + 4);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax &= 0xfffe;
    memoryASet16(ds, 0x680d, ax);
    dx = memoryAGet16(ss, bp + 8);
    dx++;
    dx >>= 1;
    dx >>= 1;
    dx >>= 1;
    dx &= 0xfffe;
    memoryASet16(ds, 0x680f, dx);
    dx -= ax;
    memoryASet16(ds, 0x6815, dx);
    ax = memoryAGet16(ss, bp + 6);
    memoryASet16(ds, 0x6811, ax);
    dx = memoryAGet16(ss, bp + 10);
    memoryASet16(ds, 0x6813, dx);
    dx -= ax;
    memoryASet16(ds, 0x6817, dx);
}
/* Assembly listing of 0ed9:0e29 sub_fbb9()
sub_fbb9 PROC
0ed9:0e29	les	bx, ptr [bp + 4]
0ed9:0e2c	or	bx, bx
0ed9:0e2e	je	loc_fbc3
0ed9:0e30	call	0xe34
        	loc_fbc3:
0ed9:0e33	ret	
sub_fbb9 ENDP
*/
void sub_fbb9()
{
    // coverage: 0xeee9-0xeef4 method sub_fbb9
    bx = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    if (!bx)
        return;
    sub_fbc4();
}
/* Assembly listing of 0ed9:0e34 sub_fbc4()
sub_fbc4 PROC
0ed9:0e34	mov	word ptr [0x6809], bx
0ed9:0e38	mov	si, es
0ed9:0e3a	mov	word ptr [0x680b], si
0ed9:0e3e	mov	ax, bx
0ed9:0e40	or	ax, si
0ed9:0e42	je	loc_fbd7
0ed9:0e44	call	0xe48
        	loc_fbd7:
0ed9:0e47	ret	
sub_fbc4 ENDP
*/
void sub_fbc4()
{
    // coverage: 0xeef4-0xef08 method sub_fbc4
    memoryASet16(ds, 0x6809, bx);
    si = es;
    memoryASet16(ds, 0x680b, si);
    ax = bx;
    ax |= si;
    if (!ax)
        return;
    sub_fbd8();
}
/* Assembly listing of 0ed9:0e48 sub_fbd8()
sub_fbd8 PROC
0ed9:0e48	les	bx, ptr [0x6809]
        	loc_fbdc:
0ed9:0e4c	push	es
0ed9:0e4d	les	di, ptr es:[bx]
0ed9:0e50	mov	ax, es
0ed9:0e52	or	ax, di
0ed9:0e54	je	loc_fbe9
0ed9:0e56	push	bx
0ed9:0e57	jmp	loc_fbef
        	loc_fbe9:
0ed9:0e59	jmp	loc_fc8f
        	loc_fbec:
0ed9:0e5c	jmp	loc_fc87
        	loc_fbef:
0ed9:0e5f	mov	al, byte ptr es:[di + 0xa]
0ed9:0e63	test	al, 0x80
0ed9:0e65	je	loc_fbec
0ed9:0e67	mov	ax, word ptr es:[di]
0ed9:0e6a	test	byte ptr es:[di + 0xa], 0x20
0ed9:0e6f	je	loc_fc11
0ed9:0e71	mov	bx, word ptr es:[di + 0x10]
0ed9:0e75	shl	bx, 1
0ed9:0e77	shl	bx, 1
0ed9:0e79	sub	ax, bx
0ed9:0e7b	add	ax, word ptr es:[di + 0x14]
0ed9:0e7f	jmp	loc_fc15
        	loc_fc11:
0ed9:0e81	sub	ax, word ptr es:[di + 0x14]
        	loc_fc15:
0ed9:0e85	test	byte ptr es:[di + 0xa], 1
0ed9:0e8a	je	loc_fc22
0ed9:0e8c	add	ax, 4
0ed9:0e8f	and	ax, 0xfff8
        	loc_fc22:
0ed9:0e92	mov	bx, ax
0ed9:0e94	and	bx, 7
0ed9:0e97	mov	byte ptr cs:[0x3216], bl
0ed9:0e9c	sar	ax, 1
0ed9:0e9e	sar	ax, 1
0ed9:0ea0	sar	ax, 1
0ed9:0ea2	mov	word ptr [0x6821], ax
0ed9:0ea5	mov	ax, word ptr es:[di + 2]
0ed9:0ea9	sub	ax, word ptr es:[di + 0x16]
0ed9:0ead	mov	word ptr [0x6823], ax
0ed9:0eb0	mov	dx, word ptr [0x6813]
0ed9:0eb4	mov	ax, word ptr [0x6823]
0ed9:0eb7	cmp	dx, ax
0ed9:0eb9	jle	loc_fbec
0ed9:0ebb	mov	dx, word ptr [0x680f]
0ed9:0ebf	mov	ax, word ptr [0x6821]
0ed9:0ec2	cmp	dx, ax
0ed9:0ec4	jle	loc_fbec
0ed9:0ec6	mov	dx, ax
0ed9:0ec8	mov	ax, word ptr es:[di + 0x10]
0ed9:0ecc	shr	ax, 1
0ed9:0ece	add	dx, ax
0ed9:0ed0	js	loc_fbec
0ed9:0ed2	mov	ax, word ptr [0x680d]
0ed9:0ed5	cmp	dx, ax
0ed9:0ed7	jl	loc_fbec
0ed9:0ed9	mov	ax, word ptr [0x6823]
0ed9:0edc	mov	dx, ax
0ed9:0ede	mov	ax, word ptr es:[di + 0x12]
0ed9:0ee2	add	dx, ax
0ed9:0ee4	js	loc_fc87
0ed9:0ee6	mov	ax, word ptr [0x6811]
0ed9:0ee9	cmp	dx, ax
0ed9:0eeb	jl	loc_fc87
0ed9:0eed	push	bx
0ed9:0eee	push	di
0ed9:0eef	call	0x103d
0ed9:0ef2	pop	di
0ed9:0ef3	pop	bx
0ed9:0ef4	jmp	loc_fbec
        	loc_fc87:
0ed9:0ef7	pop	bx
0ed9:0ef8	pop	es
0ed9:0ef9	add	bx, 4
0ed9:0efc	jmp	loc_fbdc
        	loc_fc8f:
0ed9:0eff	pop	es
0ed9:0f00	ret	
sub_fbd8 ENDP
*/
void sub_fbd8()
{
    // coverage: 0xef08-0xefc1 method sub_fbd8
    bx = memoryAGet16(ds, 0x6809);
    es = memoryAGet16(ds, 0x6809 + 2);
loc_fbdc:
    push(es);
    di = memoryAGet16(es, bx);
    es = memoryAGet16(es, bx + 2);
    ax = es;
    ax |= di;
    if (!ax)
        goto loc_fbe9;
    push(bx);
    goto loc_fbef;
loc_fbe9:
    goto loc_fc8f;
loc_fbec:
    goto loc_fc87;
loc_fbef:
    al = memoryAGet(es, di + 10);
    if (!(al & 0x80))
        goto loc_fbec;
    ax = memoryAGet16(es, di);
    if (!(memoryAGet(es, di + 10) & 0x20))
        goto loc_fc11;
    bx = memoryAGet16(es, di + 16);
    bx <<= 1;
    bx <<= 1;
    ax -= bx;
    ax += memoryAGet16(es, di + 20);
    goto loc_fc15;
loc_fc11:
    ax -= memoryAGet16(es, di + 20);
loc_fc15:
    if (!(memoryAGet(es, di + 10) & 0x01))
        goto loc_fc22;
    ax += 0x0004;
    ax &= 0xfff8;
loc_fc22:
    bx = ax;
    bx &= 0x0007;
    memoryASet(cs, 0x3216, bl);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet16(ds, 0x6821, ax);
    ax = memoryAGet16(es, di + 2);
    ax -= memoryAGet16(es, di + 22);
    memoryASet16(ds, 0x6823, ax);
    dx = memoryAGet16(ds, 0x6813);
    ax = memoryAGet16(ds, 0x6823);
    if ((short)dx <= (short)ax)
        goto loc_fbec;
    dx = memoryAGet16(ds, 0x680f);
    ax = memoryAGet16(ds, 0x6821);
    if ((short)dx <= (short)ax)
        goto loc_fbec;
    dx = ax;
    ax = memoryAGet16(es, di + 16);
    ax >>= 1;
    dx += ax;
    if ((short)dx < 0)
        goto loc_fbec;
    ax = memoryAGet16(ds, 0x680d);
    if ((short)dx < (short)ax)
        goto loc_fbec;
    ax = memoryAGet16(ds, 0x6823);
    dx = ax;
    ax = memoryAGet16(es, di + 18);
    dx += ax;
    if ((short)dx < 0)
        goto loc_fc87;
    ax = memoryAGet16(ds, 0x6811);
    if ((short)dx < (short)ax)
        goto loc_fc87;
    push(bx);
    push(di);
    sub_fdcd();
    di = pop();
    bx = pop();
    goto loc_fbec;
loc_fc87:
    bx = pop();
    es = pop();
    bx += 0x0004;
    goto loc_fbdc;
loc_fc8f:
    es = pop();
}
/* Assembly listing of 0ed9:0f50 sub_fce0()
sub_fce0 PROC
0ed9:0f50	mov	byte ptr [0x683c], 0
0ed9:0f55	mov	word ptr [0x6819], 0
0ed9:0f5b	mov	ax, word ptr [0x680d]
0ed9:0f5e	sub	ax, word ptr [0x6821]
0ed9:0f62	jns	loc_fcfb
0ed9:0f64	neg	ax
0ed9:0f66	mov	word ptr [0x6819], ax
0ed9:0f69	xor	ax, ax
        	loc_fcfb:
0ed9:0f6b	mov	word ptr [0x681f], ax
0ed9:0f6e	and	ax, ax
0ed9:0f70	je	loc_fd07
0ed9:0f72	or	byte ptr [0x683c], 2
        	loc_fd07:
0ed9:0f77	mov	ax, word ptr [0x680f]
0ed9:0f7a	sub	ax, word ptr [0x6821]
0ed9:0f7e	js	loc_fd31
0ed9:0f80	mov	bx, word ptr es:[di + 0x10]
0ed9:0f84	shr	bx, 1
0ed9:0f86	inc	bx
0ed9:0f87	sub	ax, bx
0ed9:0f89	js	loc_fd31
0ed9:0f8b	mov	ax, word ptr es:[di + 0x10]
0ed9:0f8f	shr	ax, 1
0ed9:0f91	sub	ax, word ptr [0x681f]
0ed9:0f95	jns	loc_fd29
0ed9:0f97	xor	ax, ax
        	loc_fd29:
0ed9:0f99	mov	word ptr [0x6835], ax
0ed9:0f9c	jmp	loc_fd43
        	loc_fd2e:
0ed9:0f9e	xor	ax, ax
0ed9:0fa0	ret	
        	loc_fd31:
0ed9:0fa1	mov	ax, word ptr [0x681f]
0ed9:0fa4	neg	ax
0ed9:0fa6	add	ax, word ptr [0x680f]
0ed9:0faa	sub	ax, word ptr [0x6821]
0ed9:0fae	or	byte ptr [0x683c], 1
        	loc_fd43:
0ed9:0fb3	mov	word ptr [0x6835], ax
0ed9:0fb6	mov	word ptr [0x681b], 0
0ed9:0fbc	mov	ax, word ptr [0x6811]
0ed9:0fbf	sub	ax, word ptr [0x6823]
0ed9:0fc3	jns	loc_fd5c
0ed9:0fc5	neg	ax
0ed9:0fc7	mov	word ptr [0x681b], ax
0ed9:0fca	xor	ax, ax
        	loc_fd5c:
0ed9:0fcc	mov	word ptr [0x681d], ax
0ed9:0fcf	mov	ax, word ptr [0x6811]
0ed9:0fd2	add	ax, word ptr [0x6817]
0ed9:0fd6	sub	ax, word ptr [0x6823]
0ed9:0fda	js	loc_fd7d
0ed9:0fdc	sub	ax, word ptr es:[di + 0x12]
0ed9:0fe0	js	loc_fd7d
0ed9:0fe2	mov	ax, word ptr [0x681d]
0ed9:0fe5	neg	ax
0ed9:0fe7	add	ax, word ptr es:[di + 0x12]
0ed9:0feb	jmp	loc_fd8e
        	loc_fd7d:
0ed9:0fed	mov	ax, word ptr [0x681d]
0ed9:0ff0	neg	ax
0ed9:0ff2	add	ax, word ptr [0x6811]
0ed9:0ff6	add	ax, word ptr [0x6817]
0ed9:0ffa	sub	ax, word ptr [0x6823]
        	loc_fd8e:
0ed9:0ffe	mov	word ptr [0x6837], ax
0ed9:1001	mov	ax, word ptr [0x681b]
0ed9:1004	add	ax, word ptr [0x6811]
0ed9:1008	test	ax, ax
0ed9:100a	je	loc_fda0
0ed9:100c	mov	bl, 0x28
0ed9:100e	mul	bl
        	loc_fda0:
0ed9:1010	add	ax, word ptr [0x56e2]
0ed9:1014	add	ax, word ptr [0x6819]
0ed9:1018	add	ax, word ptr [0x680d]
0ed9:101c	mov	word ptr [0x56e8], ax
0ed9:101f	mov	ax, word ptr [0x6835]
0ed9:1022	and	ax, ax
0ed9:1024	je	loc_fdca
0ed9:1026	js	loc_fdca
0ed9:1028	mov	ax, word ptr [0x6837]
0ed9:102b	and	ax, ax
0ed9:102d	je	loc_fdca
0ed9:102f	js	loc_fdca
0ed9:1031	cmp	ax, 0x64
0ed9:1034	jge	loc_fdca
0ed9:1036	or	ax, 1
0ed9:1039	ret	
        	loc_fdca:
0ed9:103a	jmp	loc_fd2e
sub_fce0 ENDP
*/
void sub_fce0()
{
    // coverage: 0xf010-0xf0fd method sub_fce0
    memoryASet(ds, 0x683c, 0x00);
    memoryASet16(ds, 0x6819, 0x0000);
    ax = memoryAGet16(ds, 0x680d);
    ax -= memoryAGet16(ds, 0x6821);
    if ((short)ax >= 0)
        goto loc_fcfb;
    ax = -ax;
    memoryASet16(ds, 0x6819, ax);
    ax = 0;
loc_fcfb:
    memoryASet16(ds, 0x681f, ax);
    if (ax == 0)
        goto loc_fd07;
    memoryASet(ds, 0x683c, memoryAGet(ds, 0x683c) | 0x02);
loc_fd07:
    ax = memoryAGet16(ds, 0x680f);
    ax -= memoryAGet16(ds, 0x6821);
    if ((short)ax < 0)
        goto loc_fd31;
    bx = memoryAGet16(es, di + 16);
    bx >>= 1;
    bx++;
    ax -= bx;
    if ((short)ax < 0)
        goto loc_fd31;
    ax = memoryAGet16(es, di + 16);
    ax >>= 1;
    ax -= memoryAGet16(ds, 0x681f);
    if ((short)ax >= 0)
        goto loc_fd29;
    ax = 0;
loc_fd29:
    memoryASet16(ds, 0x6835, ax);
    goto loc_fd43;
loc_fd2e:
    ax = 0;
    return;
loc_fd31:
    ax = memoryAGet16(ds, 0x681f);
    ax = -ax;
    ax += memoryAGet16(ds, 0x680f);
    ax -= memoryAGet16(ds, 0x6821);
    memoryASet(ds, 0x683c, memoryAGet(ds, 0x683c) | 0x01);
loc_fd43:
    memoryASet16(ds, 0x6835, ax);
    memoryASet16(ds, 0x681b, 0x0000);
    ax = memoryAGet16(ds, 0x6811);
    ax -= memoryAGet16(ds, 0x6823);
    if ((short)ax >= 0)
        goto loc_fd5c;
    ax = -ax;
    memoryASet16(ds, 0x681b, ax);
    ax = 0;
loc_fd5c:
    memoryASet16(ds, 0x681d, ax);
    ax = memoryAGet16(ds, 0x6811);
    ax += memoryAGet16(ds, 0x6817);
    ax -= memoryAGet16(ds, 0x6823);
    if ((short)ax < 0)
        goto loc_fd7d;
    ax -= memoryAGet16(es, di + 18);
    if ((short)ax < 0)
        goto loc_fd7d;
    ax = memoryAGet16(ds, 0x681d);
    ax = -ax;
    ax += memoryAGet16(es, di + 18);
    goto loc_fd8e;
loc_fd7d:
    ax = memoryAGet16(ds, 0x681d);
    ax = -ax;
    ax += memoryAGet16(ds, 0x6811);
    ax += memoryAGet16(ds, 0x6817);
    ax -= memoryAGet16(ds, 0x6823);
loc_fd8e:
    memoryASet16(ds, 0x6837, ax);
    ax = memoryAGet16(ds, 0x681b);
    ax += memoryAGet16(ds, 0x6811);
    if (!(ax & ax))
        goto loc_fda0;
    bl = 0x28;
    mul(bl);
loc_fda0:
    ax += memoryAGet16(ds, 0x56e2);
    ax += memoryAGet16(ds, 0x6819);
    ax += memoryAGet16(ds, 0x680d);
    memoryASet16(ds, 0x56e8, ax);
    ax = memoryAGet16(ds, 0x6835);
    if (ax == 0)
        goto loc_fdca;
    if ((short)ax < 0)
        goto loc_fdca;
    ax = memoryAGet16(ds, 0x6837);
    if (ax == 0)
        goto loc_fdca;
    if ((short)ax < 0)
        goto loc_fdca;
    if ((short)ax >= (short)0x0064)
        goto loc_fdca;
    ax |= 0x0001;
    return;
loc_fdca:
    goto loc_fd2e;
}
/* Assembly listing of 0ed9:103d sub_fdcd()
sub_fdcd PROC
0ed9:103d	call	0xf50
0ed9:1040	mov	ax, word ptr [0x681d]
0ed9:1043	test	ax, ax
0ed9:1045	je	loc_fddf
0ed9:1047	mov	bl, byte ptr es:[di + 0x10]
0ed9:104b	add	bl, bl
0ed9:104d	mul	bl
        	loc_fddf:
0ed9:104f	add	ax, word ptr [0x681f]
0ed9:1053	add	ax, word ptr [0x681f]
0ed9:1057	add	ax, word ptr [0x681f]
0ed9:105b	add	ax, word ptr [0x681f]
0ed9:105f	mov	word ptr [0x56e6], ax
0ed9:1062	mov	ax, word ptr [0x6835]
0ed9:1065	mov	dx, word ptr es:[di + 0x10]
0ed9:1069	shr	dx, 1
0ed9:106b	mov	cl, 0x28
0ed9:106d	sub	cl, al
0ed9:106f	xor	ch, ch
0ed9:1071	mov	dh, ch
0ed9:1073	mov	byte ptr [0x683a], 0
0ed9:1078	jmp	loc_fe36
0ed9:107a		
        	loc_fe36:
0ed9:10a6	push	es
0ed9:10a7	push	di
0ed9:10a8	mov	al, byte ptr cs:[0x3216]
0ed9:10ac	mov	byte ptr [0x683b], al
0ed9:10af	les	bp, ptr es:[di + 0xc]
0ed9:10b3	add	bp, word ptr [0x56e6]
0ed9:10b7	mov	word ptr [0x6825], bp
0ed9:10bb	mov	ax, es
0ed9:10bd	mov	word ptr [0x6827], ax
0ed9:10c0	mov	si, word ptr [0x56e8]
0ed9:10c4	mov	word ptr [0x682d], si
0ed9:10c8	mov	ax, word ptr [0x56e4]
0ed9:10cb	mov	word ptr [0x682f], ax
0ed9:10ce	mov	word ptr [0x6833], 0x28
0ed9:10d4	mov	word ptr [0x6831], dx
0ed9:10d8	mov	si, 0x6825
0ed9:10db	call	0x10e1
0ed9:10de	pop	di
0ed9:10df	pop	es
0ed9:10e0	ret	
sub_fdcd ENDP
*/
void sub_fdcd()
{
    // coverage: 0xf0fd-0xf13a method sub_fdcd
    // coverage: 0xf166-0xf1a1 method sub_fdcd
    sub_fce0();
    ax = memoryAGet16(ds, 0x681d);
    if (!(ax & ax))
        goto loc_fddf;
    bl = memoryAGet(es, di + 16);
    bl += bl;
    mul(bl);
loc_fddf:
    ax += memoryAGet16(ds, 0x681f);
    ax += memoryAGet16(ds, 0x681f);
    ax += memoryAGet16(ds, 0x681f);
    ax += memoryAGet16(ds, 0x681f);
    memoryASet16(ds, 0x56e6, ax);
    ax = memoryAGet16(ds, 0x6835);
    dx = memoryAGet16(es, di + 16);
    dx >>= 1;
    cl = 0x28;
    cl -= al;
    ch = 0;
    dh = ch;
    memoryASet(ds, 0x683a, 0x00);
    goto loc_fe36;
    //   gap of 44 bytes
loc_fe36:
    push(es);
    push(di);
    al = memoryAGet(cs, 0x3216);
    memoryASet(ds, 0x683b, al);
    bp = memoryAGet16(es, di + 12);
    es = memoryAGet16(es, di + 12 + 2);
    bp += memoryAGet16(ds, 0x56e6);
    memoryASet16(ds, 0x6825, bp);
    ax = es;
    memoryASet16(ds, 0x6827, ax);
    si = memoryAGet16(ds, 0x56e8);
    memoryASet16(ds, 0x682d, si);
    ax = memoryAGet16(ds, 0x56e4);
    memoryASet16(ds, 0x682f, ax);
    memoryASet16(ds, 0x6833, 0x0028);
    memoryASet16(ds, 0x6831, dx);
    si = 0x6825;
    sub_fe71();
    di = pop();
    es = pop();
}
/* Assembly listing of 0ed9:10e1 sub_fe71()
sub_fe71 PROC
0ed9:10e1		
        	loc_f9b4:
0ed9:0c24	push	ax
0ed9:0c25	mov	ax, 3
0ed9:0c28	int	0x10
0ed9:0c2a	pop	ax
0ed9:0c2b	mov	dl, al
0ed9:0c2d	mov	ah, 2
0ed9:0c2f	int	0x21
0ed9:0c31	int	0x20
0ed9:0c33	ret	
0ed9:0c34		
        	loc_fe71:
0ed9:10e1	push	ds
0ed9:10e2	mov	al, byte ptr [si + 0x17]
0ed9:10e5	mov	byte ptr cs:[0x3215], al
0ed9:10e9	mov	al, byte ptr [si + 0x16]
0ed9:10ec	mov	byte ptr cs:[0x3216], al
0ed9:10f0	mov	ax, word ptr [si + 0x12]
0ed9:10f3	dec	ax
0ed9:10f4	mov	word ptr cs:[0x3213], ax
0ed9:10f8	jns	loc_fe8d
0ed9:10fa	jmp	loc_10ec9
        	loc_fe8d:
0ed9:10fd	mov	bx, word ptr [si + 0x10]
0ed9:1100	mov	ax, word ptr [si + 0xe]
0ed9:1103	sub	ax, bx
0ed9:1105	mov	word ptr cs:[0x320f], ax
0ed9:1109	mov	cx, word ptr [si + 0xc]
0ed9:110c	sub	cx, bx
0ed9:110e	mov	al, byte ptr [si + 0x15]
0ed9:1111	push	dx
0ed9:1112	push	ax
0ed9:1113	mov	dx, 0x3ce
0ed9:1116	mov	al, 5
0ed9:1118	out	dx, al
0ed9:1119	jmp	loc_feab
0ed9:111b	jmp	loc_fead
0ed9:111d	inc	dx
0ed9:111e	mov	al, 0
0ed9:1120	out	dx, al
0ed9:1121	pop	ax
0ed9:1122	pop	dx
0ed9:1123	push	dx
0ed9:1124	push	ax
0ed9:1125	mov	dx, 0x3ce
0ed9:1128	mov	al, 3
0ed9:112a	out	dx, al
0ed9:112b	jmp	loc_febd
0ed9:112d	jmp	loc_febf
0ed9:112f	inc	dx
0ed9:1130	mov	al, 0
0ed9:1132	out	dx, al
0ed9:1133	pop	ax
0ed9:1134	pop	dx
0ed9:1135	push	dx
0ed9:1136	push	ax
0ed9:1137	mov	dx, 0x3c4
0ed9:113a	mov	al, 2
0ed9:113c	out	dx, al
0ed9:113d	jmp	loc_fecf
0ed9:113f	jmp	loc_fed1
0ed9:1141	inc	dx
0ed9:1142	mov	al, 0xf
0ed9:1144	out	dx, al
0ed9:1145	pop	ax
0ed9:1146	pop	dx
0ed9:1147	add	bx, bx
0ed9:1149	xor	ah, ah
0ed9:114b	add	ax, ax
0ed9:114d	mov	dx, ax
0ed9:114f	add	ax, ax
0ed9:1151	add	ax, dx
0ed9:1153	mov	bp, 0x328f
0ed9:1156	add	bp, ax
0ed9:1158	mov	dx, word ptr cs:[bp + 4]
0ed9:115c	mov	di, word ptr cs:[bp]
0ed9:1160	mov	ax, word ptr cs:[bx + di]
0ed9:1163	mov	word ptr cs:[0x25e2], ax
0ed9:1167	mov	ax, word ptr cs:[bp + 2]
0ed9:116b	push	ax
0ed9:116c	push	bx
0ed9:116d	mov	al, byte ptr cs:[0x320e]
0ed9:1171	mov	bx, 0x11da
0ed9:1174	and	al, 0x40
0ed9:1176	je	loc_ff0b
0ed9:1178	mov	bx, 0x11e2
        	loc_ff0b:
0ed9:117b	mov	ax, word ptr cs:[bx]
0ed9:117e	mov	word ptr cs:[0x11d5], ax
0ed9:1182	mov	al, byte ptr cs:[bx + 2]
0ed9:1186	mov	byte ptr cs:[0x11d7], al
0ed9:118a	mov	al, byte ptr cs:[bx + 4]
0ed9:118e	mov	byte ptr cs:[0x11d8], al
0ed9:1192	mov	al, byte ptr cs:[bx + 6]
0ed9:1196	mov	byte ptr cs:[0x11d9], al
0ed9:119a	pop	bx
0ed9:119b	pop	ax
0ed9:119c	les	bp, ptr [si]
0ed9:119e	lds	si, ptr [si + 8]
0ed9:11a1	mov	bl, byte ptr cs:[0x3216]
0ed9:11a6	xor	bh, bh
0ed9:11a8	add	bx, bx
0ed9:11aa	mov	di, word ptr cs:[bx + 0x3325]
0ed9:11af	cmp	dx, 4
0ed9:11b2	je	loc_ff5a
0ed9:11b4	cmp	dx, 2
0ed9:11b7	je	loc_ff5c
0ed9:11b9	cmp	dx, 1
0ed9:11bc	je	loc_ff58
0ed9:11be	cmp	dx, 3
0ed9:11c1	je	loc_ff58
        	loc_ff53:
0ed9:11c3	mov	ah, 1
0ed9:11c5	jmp	loc_f9b4
        	loc_ff58:
0ed9:11c8	jmp	loc_ff53
        	loc_ff5a:
0ed9:11ca	add	cx, cx
        	loc_ff5c:
0ed9:11cc	add	cx, cx
0ed9:11ce	mov	word ptr cs:[0x3211], cx
0ed9:11d3	jmp	ax
0ed9:11d5		
        	loc_10cd6:
0ed9:1f46	mov	ax, word ptr es:[bp]
0ed9:1f4a	mov	dx, word ptr es:[bp + 2]
0ed9:1f4e	add	bp, 4
0ed9:1f51	push	cx
0ed9:1f52	mov	cl, byte ptr cs:[0x3216]
0ed9:1f57	ror	ax, cl
0ed9:1f59	ror	dx, cl
0ed9:1f5b	pop	cx
0ed9:1f5c	push	ax
0ed9:1f5d	push	dx
0ed9:1f5e	and	ax, di
0ed9:1f60	and	dx, di
0ed9:1f62	or	bx, ax
0ed9:1f64	or	cx, dx
0ed9:1f66	mov	ax, bx
0ed9:1f68	or	ax, cx
0ed9:1f6a	or	ah, al
0ed9:1f6c	mov	dx, 0x3ce
0ed9:1f6f	mov	al, 8
0ed9:1f71	out	dx, ax
0ed9:1f72	mov	dx, 0x3c4
0ed9:1f75	mov	ax, word ptr cs:[0x11d5]
0ed9:1f79	out	dx, ax
0ed9:1f7a	mov	al, ah
0ed9:1f7c	inc	dx
0ed9:1f7d	mov	ah, byte ptr [si]
0ed9:1f7f	mov	byte ptr [si], bl
0ed9:1f81	mov	al, byte ptr cs:[0x11d7]
0ed9:1f85	out	dx, al
0ed9:1f86	mov	byte ptr [si], bh
0ed9:1f88	mov	al, byte ptr cs:[0x11d8]
0ed9:1f8c	out	dx, al
0ed9:1f8d	mov	byte ptr [si], cl
0ed9:1f8f	mov	al, byte ptr cs:[0x11d9]
0ed9:1f93	out	dx, al
0ed9:1f94	mov	byte ptr [si], ch
0ed9:1f96	inc	si
0ed9:1f97	pop	cx
0ed9:1f98	pop	bx
0ed9:1f99	not	di
0ed9:1f9b	xchg	bl, bh
0ed9:1f9d	xchg	cl, ch
0ed9:1f9f	and	bx, di
0ed9:1fa1	and	cx, di
0ed9:1fa3	not	di
0ed9:1fa5	mov	ax, word ptr es:[bp]
0ed9:1fa9	mov	dx, word ptr es:[bp + 2]
0ed9:1fad	add	bp, 4
0ed9:1fb0	push	cx
0ed9:1fb1	mov	cl, byte ptr cs:[0x3216]
0ed9:1fb6	ror	ax, cl
0ed9:1fb8	ror	dx, cl
0ed9:1fba	pop	cx
0ed9:1fbb	push	ax
0ed9:1fbc	push	dx
0ed9:1fbd	and	ax, di
0ed9:1fbf	and	dx, di
0ed9:1fc1	or	bx, ax
0ed9:1fc3	or	cx, dx
0ed9:1fc5	mov	ax, bx
0ed9:1fc7	or	ax, cx
0ed9:1fc9	or	ah, al
0ed9:1fcb	mov	dx, 0x3ce
0ed9:1fce	mov	al, 8
0ed9:1fd0	out	dx, ax
0ed9:1fd1	mov	dx, 0x3c4
0ed9:1fd4	mov	ax, word ptr cs:[0x11d5]
0ed9:1fd8	out	dx, ax
0ed9:1fd9	mov	al, ah
0ed9:1fdb	inc	dx
0ed9:1fdc	mov	ah, byte ptr [si]
0ed9:1fde	mov	byte ptr [si], bl
0ed9:1fe0	mov	al, byte ptr cs:[0x11d7]
0ed9:1fe4	out	dx, al
0ed9:1fe5	mov	byte ptr [si], bh
0ed9:1fe7	mov	al, byte ptr cs:[0x11d8]
0ed9:1feb	out	dx, al
0ed9:1fec	mov	byte ptr [si], cl
0ed9:1fee	mov	al, byte ptr cs:[0x11d9]
0ed9:1ff2	out	dx, al
0ed9:1ff3	mov	byte ptr [si], ch
0ed9:1ff5	inc	si
0ed9:1ff6	pop	cx
0ed9:1ff7	pop	bx
0ed9:1ff8	not	di
0ed9:1ffa	xchg	bl, bh
0ed9:1ffc	xchg	cl, ch
0ed9:1ffe	and	bx, di
0ed9:2000	and	cx, di
0ed9:2002	not	di
        	loc_10d94:
0ed9:2004	mov	ax, word ptr es:[bp]
0ed9:2008	mov	dx, word ptr es:[bp + 2]
0ed9:200c	add	bp, 4
0ed9:200f	push	cx
0ed9:2010	mov	cl, byte ptr cs:[0x3216]
0ed9:2015	ror	ax, cl
0ed9:2017	ror	dx, cl
0ed9:2019	pop	cx
0ed9:201a	push	ax
0ed9:201b	push	dx
0ed9:201c	and	ax, di
0ed9:201e	and	dx, di
0ed9:2020	or	bx, ax
0ed9:2022	or	cx, dx
0ed9:2024	mov	ax, bx
0ed9:2026	or	ax, cx
0ed9:2028	or	ah, al
0ed9:202a	mov	dx, 0x3ce
0ed9:202d	mov	al, 8
0ed9:202f	out	dx, ax
0ed9:2030	mov	dx, 0x3c4
0ed9:2033	mov	ax, word ptr cs:[0x11d5]
0ed9:2037	out	dx, ax
0ed9:2038	mov	al, ah
0ed9:203a	inc	dx
0ed9:203b	mov	ah, byte ptr [si]
0ed9:203d	mov	byte ptr [si], bl
0ed9:203f	mov	al, byte ptr cs:[0x11d7]
0ed9:2043	out	dx, al
0ed9:2044	mov	byte ptr [si], bh
0ed9:2046	mov	al, byte ptr cs:[0x11d8]
0ed9:204a	out	dx, al
0ed9:204b	mov	byte ptr [si], cl
0ed9:204d	mov	al, byte ptr cs:[0x11d9]
0ed9:2051	out	dx, al
0ed9:2052	mov	byte ptr [si], ch
0ed9:2054	inc	si
0ed9:2055	pop	cx
0ed9:2056	pop	bx
0ed9:2057	not	di
0ed9:2059	xchg	bl, bh
0ed9:205b	xchg	cl, ch
0ed9:205d	and	bx, di
0ed9:205f	and	cx, di
0ed9:2061	not	di
        	loc_10df3:
0ed9:2063	mov	ax, word ptr es:[bp]
0ed9:2067	mov	dx, word ptr es:[bp + 2]
0ed9:206b	add	bp, 4
0ed9:206e	push	cx
0ed9:206f	mov	cl, byte ptr cs:[0x3216]
0ed9:2074	ror	ax, cl
0ed9:2076	ror	dx, cl
0ed9:2078	pop	cx
0ed9:2079	push	ax
0ed9:207a	push	dx
0ed9:207b	and	ax, di
0ed9:207d	and	dx, di
0ed9:207f	or	bx, ax
0ed9:2081	or	cx, dx
0ed9:2083	mov	ax, bx
0ed9:2085	or	ax, cx
0ed9:2087	or	ah, al
0ed9:2089	mov	dx, 0x3ce
0ed9:208c	mov	al, 8
0ed9:208e	out	dx, ax
0ed9:208f	mov	dx, 0x3c4
0ed9:2092	mov	ax, word ptr cs:[0x11d5]
0ed9:2096	out	dx, ax
0ed9:2097	mov	al, ah
0ed9:2099	inc	dx
0ed9:209a	mov	ah, byte ptr [si]
0ed9:209c	mov	byte ptr [si], bl
0ed9:209e	mov	al, byte ptr cs:[0x11d7]
0ed9:20a2	out	dx, al
0ed9:20a3	mov	byte ptr [si], bh
0ed9:20a5	mov	al, byte ptr cs:[0x11d8]
0ed9:20a9	out	dx, al
0ed9:20aa	mov	byte ptr [si], cl
0ed9:20ac	mov	al, byte ptr cs:[0x11d9]
0ed9:20b0	out	dx, al
0ed9:20b1	mov	byte ptr [si], ch
0ed9:20b3	inc	si
0ed9:20b4	pop	cx
0ed9:20b5	pop	bx
0ed9:20b6	not	di
0ed9:20b8	xchg	bl, bh
0ed9:20ba	xchg	cl, ch
0ed9:20bc	and	bx, di
0ed9:20be	and	cx, di
0ed9:20c0	not	di
0ed9:20c2	mov	al, byte ptr cs:[0x3215]
0ed9:20c6	and	al, 1
0ed9:20c8	jne	loc_10e8a
0ed9:20ca	mov	ax, bx
0ed9:20cc	or	ax, cx
0ed9:20ce	or	ah, al
0ed9:20d0	mov	dx, 0x3ce
0ed9:20d3	mov	al, 8
0ed9:20d5	out	dx, ax
0ed9:20d6	mov	dx, 0x3c4
0ed9:20d9	mov	ax, word ptr cs:[0x11d5]
0ed9:20dd	out	dx, ax
0ed9:20de	mov	al, ah
0ed9:20e0	inc	dx
0ed9:20e1	mov	ah, byte ptr [si]
0ed9:20e3	mov	byte ptr [si], bl
0ed9:20e5	mov	al, byte ptr cs:[0x11d7]
0ed9:20e9	out	dx, al
0ed9:20ea	mov	byte ptr [si], bh
0ed9:20ec	mov	al, byte ptr cs:[0x11d8]
0ed9:20f0	out	dx, al
0ed9:20f1	mov	byte ptr [si], cl
0ed9:20f3	mov	al, byte ptr cs:[0x11d9]
0ed9:20f7	out	dx, al
0ed9:20f8	mov	byte ptr [si], ch
        	loc_10e8a:
0ed9:20fa	dec	word ptr cs:[0x3213]
0ed9:20ff	js	loc_10ec9
0ed9:2101	add	bp, word ptr cs:[0x3211]
0ed9:2106	add	si, word ptr cs:[0x320f]
        	loc_10e9b:
0ed9:210b	xor	bx, bx
0ed9:210d	xor	cx, cx
0ed9:210f	mov	al, byte ptr cs:[0x3215]
0ed9:2113	and	al, 2
0ed9:2115	je	loc_10ec6
0ed9:2117	mov	bx, word ptr es:[bp - 4]
0ed9:211b	mov	ax, word ptr es:[bp - 2]
0ed9:211f	mov	cl, byte ptr cs:[0x3216]
0ed9:2124	ror	bx, cl
0ed9:2126	ror	ax, cl
0ed9:2128	mov	cx, ax
0ed9:212a	not	di
0ed9:212c	xchg	bl, bh
0ed9:212e	xchg	cl, ch
0ed9:2130	and	bx, di
0ed9:2132	and	cx, di
0ed9:2134	not	di
        	loc_10ec6:
0ed9:2136	jmp	loc_11371
        	loc_10ec9:
0ed9:2139	mov	dx, 0x3ce
0ed9:213c	mov	ax, 0xff08
0ed9:213f	out	dx, ax
0ed9:2140	pop	ds
0ed9:2141	ret	
0ed9:2142		
        	loc_11371:
0ed9:25e1	mov	ax, 0
0ed9:25e4	jmp	ax
sub_fe71 ENDP
*/
void sub_fe71()
{
    // coverage: 0xece4-0xecf4 method sub_fe71
    // coverage: 0xf1a1-0xf295 method sub_fe71
    // coverage: 0x10006-0x10202 method sub_fe71
    // coverage: 0x106a1-0x106a6 method sub_fe71
    goto loc_fe71;
loc_f9b4:
    push(ax);
    ax = 0x0003;
    interrupt(0x10);
    ax = pop();
    dl = al;
    ah = 0x02;
    interrupt(0x21);
    interrupt(0x20);
    return;
    //   gap of 1197 bytes
loc_fe71:
    push(ds);
    al = memoryAGet(ds, si + 23);
    memoryASet(cs, 0x3215, al);
    al = memoryAGet(ds, si + 22);
    memoryASet(cs, 0x3216, al);
    ax = memoryAGet16(ds, si + 18);
    ax--;
    memoryASet16(cs, 0x3213, ax);
    if ((short)ax >= 0)
        goto loc_fe8d;
    goto loc_10ec9;
loc_fe8d:
    bx = memoryAGet16(ds, si + 16);
    ax = memoryAGet16(ds, si + 14);
    ax -= bx;
    memoryASet16(cs, 0x320f, ax);
    cx = memoryAGet16(ds, si + 12);
    cx -= bx;
    al = memoryAGet(ds, si + 21);
    push(dx);
    push(ax);
    dx = 0x03ce;
    al = 0x05;
    out(dx, al);
    dx++;
    al = 0x00;
    out(dx, al);
    ax = pop();
    dx = pop();
    push(dx);
    push(ax);
    dx = 0x03ce;
    al = 0x03;
    out(dx, al);
    dx++;
    al = 0x00;
    out(dx, al);
    ax = pop();
    dx = pop();
    push(dx);
    push(ax);
    dx = 0x03c4;
    al = 0x02;
    out(dx, al);
    dx++;
    al = 0x0f;
    out(dx, al);
    ax = pop();
    dx = pop();
    bx += bx;
    ah = 0;
    ax += ax;
    dx = ax;
    ax += ax;
    ax += dx;
    bp = 0x328f;
    bp += ax;
    dx = memoryAGet16(cs, bp + 4);
    di = memoryAGet16(cs, bp);
    ax = memoryAGet16(cs, bx + di);
    memoryASet16(cs, 0x25e2, ax);
    ax = memoryAGet16(cs, bp + 2);
    push(ax);
    push(bx);
    al = memoryAGet(cs, 0x320e);
    bx = 0x11da;
    al &= 0x40;
    if (al == 0)
        goto loc_ff0b;
    bx = 0x11e2;
loc_ff0b:
    ax = memoryAGet16(cs, bx);
    memoryASet16(cs, 0x11d5, ax);
    al = memoryAGet(cs, bx + 2);
    memoryASet(cs, 0x11d7, al);
    al = memoryAGet(cs, bx + 4);
    memoryASet(cs, 0x11d8, al);
    al = memoryAGet(cs, bx + 6);
    memoryASet(cs, 0x11d9, al);
    bx = pop();
    ax = pop();
    bp = memoryAGet16(ds, si);
    es = memoryAGet16(ds, si + 2);
    tx = si;
    si = memoryAGet16(ds, tx + 8);
    ds = memoryAGet16(ds, tx + 8 + 2);
    bl = memoryAGet(cs, 0x3216);
    bh = 0;
    bx += bx;
    di = memoryAGet16(cs, bx + 13093);
    if (dx == 0x0004)
        goto loc_ff5a;
    if (dx == 0x0002)
        goto loc_ff5c;
    if (dx == 0x0001)
        goto loc_ff58;
    if (dx == 0x0003)
        goto loc_ff58;
loc_ff53:
    ah = 0x01;
    goto loc_f9b4;
loc_ff58:
    goto loc_ff53;
loc_ff5a:
    cx += cx;
loc_ff5c:
    cx += cx;
    memoryASet16(cs, 0x3211, cx);
    switch (ax)
    {
        // coverage: 0x101cb-0x101cb switch
        case 0x210b: goto loc_10e9b;
        default:
        assert(0);
    }
    //   gap of 3441 bytes
loc_10cd6:
    ax = memoryAGet16(es, bp);
    dx = memoryAGet16(es, bp + 2);
    bp += 0x0004;
    push(cx);
    cl = memoryAGet(cs, 0x3216);
    ax = ror(ax, cl);
    dx = ror(dx, cl);
    cx = pop();
    push(ax);
    push(dx);
    ax &= di;
    dx &= di;
    bx |= ax;
    cx |= dx;
    ax = bx;
    ax |= cx;
    ah |= al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    dx = 0x03c4;
    ax = memoryAGet16(cs, 0x11d5);
    out(dx, ax);
    al = ah;
    dx++;
    ah = memoryAGet(ds, si);
    memoryASet(ds, si, bl);
    al = memoryAGet(cs, 0x11d7);
    out(dx, al);
    memoryASet(ds, si, bh);
    al = memoryAGet(cs, 0x11d8);
    out(dx, al);
    memoryASet(ds, si, cl);
    al = memoryAGet(cs, 0x11d9);
    out(dx, al);
    memoryASet(ds, si, ch);
    si++;
    cx = pop();
    bx = pop();
    di = ~di;
    tl = bl;
    bl = bh;
    bh = tl;
    tl = cl;
    cl = ch;
    ch = tl;
    bx &= di;
    cx &= di;
    di = ~di;
    ax = memoryAGet16(es, bp);
    dx = memoryAGet16(es, bp + 2);
    bp += 0x0004;
    push(cx);
    cl = memoryAGet(cs, 0x3216);
    ax = ror(ax, cl);
    dx = ror(dx, cl);
    cx = pop();
    push(ax);
    push(dx);
    ax &= di;
    dx &= di;
    bx |= ax;
    cx |= dx;
    ax = bx;
    ax |= cx;
    ah |= al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    dx = 0x03c4;
    ax = memoryAGet16(cs, 0x11d5);
    out(dx, ax);
    al = ah;
    dx++;
    ah = memoryAGet(ds, si);
    memoryASet(ds, si, bl);
    al = memoryAGet(cs, 0x11d7);
    out(dx, al);
    memoryASet(ds, si, bh);
    al = memoryAGet(cs, 0x11d8);
    out(dx, al);
    memoryASet(ds, si, cl);
    al = memoryAGet(cs, 0x11d9);
    out(dx, al);
    memoryASet(ds, si, ch);
    si++;
    cx = pop();
    bx = pop();
    di = ~di;
    tl = bl;
    bl = bh;
    bh = tl;
    tl = cl;
    cl = ch;
    ch = tl;
    bx &= di;
    cx &= di;
    di = ~di;
loc_10d94:
    ax = memoryAGet16(es, bp);
    dx = memoryAGet16(es, bp + 2);
    bp += 0x0004;
    push(cx);
    cl = memoryAGet(cs, 0x3216);
    ax = ror(ax, cl);
    dx = ror(dx, cl);
    cx = pop();
    push(ax);
    push(dx);
    ax &= di;
    dx &= di;
    bx |= ax;
    cx |= dx;
    ax = bx;
    ax |= cx;
    ah |= al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    dx = 0x03c4;
    ax = memoryAGet16(cs, 0x11d5);
    out(dx, ax);
    al = ah;
    dx++;
    ah = memoryAGet(ds, si);
    memoryASet(ds, si, bl);
    al = memoryAGet(cs, 0x11d7);
    out(dx, al);
    memoryASet(ds, si, bh);
    al = memoryAGet(cs, 0x11d8);
    out(dx, al);
    memoryASet(ds, si, cl);
    al = memoryAGet(cs, 0x11d9);
    out(dx, al);
    memoryASet(ds, si, ch);
    si++;
    cx = pop();
    bx = pop();
    di = ~di;
    tl = bl;
    bl = bh;
    bh = tl;
    tl = cl;
    cl = ch;
    ch = tl;
    bx &= di;
    cx &= di;
    di = ~di;
loc_10df3:
    ax = memoryAGet16(es, bp);
    dx = memoryAGet16(es, bp + 2);
    bp += 0x0004;
    push(cx);
    cl = memoryAGet(cs, 0x3216);
    ax = ror(ax, cl);
    dx = ror(dx, cl);
    cx = pop();
    push(ax);
    push(dx);
    ax &= di;
    dx &= di;
    bx |= ax;
    cx |= dx;
    ax = bx;
    ax |= cx;
    ah |= al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    dx = 0x03c4;
    ax = memoryAGet16(cs, 0x11d5);
    out(dx, ax);
    al = ah;
    dx++;
    ah = memoryAGet(ds, si);
    memoryASet(ds, si, bl);
    al = memoryAGet(cs, 0x11d7);
    out(dx, al);
    memoryASet(ds, si, bh);
    al = memoryAGet(cs, 0x11d8);
    out(dx, al);
    memoryASet(ds, si, cl);
    al = memoryAGet(cs, 0x11d9);
    out(dx, al);
    memoryASet(ds, si, ch);
    si++;
    cx = pop();
    bx = pop();
    di = ~di;
    tl = bl;
    bl = bh;
    bh = tl;
    tl = cl;
    cl = ch;
    ch = tl;
    bx &= di;
    cx &= di;
    di = ~di;
    al = memoryAGet(cs, 0x3215);
    al &= 0x01;
    if (al != 0)
        goto loc_10e8a;
    ax = bx;
    ax |= cx;
    ah |= al;
    dx = 0x03ce;
    al = 0x08;
    out(dx, ax);
    dx = 0x03c4;
    ax = memoryAGet16(cs, 0x11d5);
    out(dx, ax);
    al = ah;
    dx++;
    ah = memoryAGet(ds, si);
    memoryASet(ds, si, bl);
    al = memoryAGet(cs, 0x11d7);
    out(dx, al);
    memoryASet(ds, si, bh);
    al = memoryAGet(cs, 0x11d8);
    out(dx, al);
    memoryASet(ds, si, cl);
    al = memoryAGet(cs, 0x11d9);
    out(dx, al);
    memoryASet(ds, si, ch);
loc_10e8a:
    memoryASet16(cs, 0x3213, memoryAGet16(cs, 0x3213) - 1);
    if ((short)memoryAGet16(cs, 0x3213) < 0)
        goto loc_10ec9;
    bp += memoryAGet16(cs, 0x3211);
    si += memoryAGet16(cs, 0x320f);
loc_10e9b:
    bx = 0;
    cx = 0;
    al = memoryAGet(cs, 0x3215);
    al &= 0x02;
    if (al == 0)
        goto loc_10ec6;
    bx = memoryAGet16(es, bp - 4);
    ax = memoryAGet16(es, bp - 2);
    cl = memoryAGet(cs, 0x3216);
    bx = ror(bx, cl);
    ax = ror(ax, cl);
    cx = ax;
    di = ~di;
    tl = bl;
    bl = bh;
    bh = tl;
    tl = cl;
    cl = ch;
    ch = tl;
    bx &= di;
    cx &= di;
    di = ~di;
loc_10ec6:
    goto loc_11371;
loc_10ec9:
    dx = 0x03ce;
    ax = 0xff08;
    out(dx, ax);
    ds = pop();
    return;
    //   gap of 1183 bytes
loc_11371:
    ax = 0x0000;
    switch (ax)
    {
        // coverage: 0x100c4-0x100c4 switch
        case 0x2004: goto loc_10d94;
        // coverage: 0x10123-0x10123 switch
        case 0x2063: goto loc_10df3;
        // coverage: 0x10006-0x10006 switch
        case 0x1f46: goto loc_10cd6;
        default:
        assert(0);
    }
}
/* Assembly listing of 0ed9:2ced sub_11a7d()
sub_11a7d PROC
0ed9:2ced	push	di
0ed9:2cee	push	si
0ed9:2cef	push	bp
0ed9:2cf0	push	ds
0ed9:2cf1	push	es
0ed9:2cf2	mov	bx, 0x2d09
0ed9:2cf5	mov	di, word ptr [0x541d]
0ed9:2cf9	add	di, di
0ed9:2cfb	mov	ax, word ptr cs:[bx + di]
0ed9:2cfe	les	di, ptr [bp + 4]
0ed9:2d01	call	ax
0ed9:2d03	pop	es
0ed9:2d04	pop	ds
0ed9:2d05	pop	bp
0ed9:2d06	pop	si
0ed9:2d07	pop	di
0ed9:2d08	retf	
sub_11a7d ENDP
*/
void sub_11a7d()
{
    // coverage: 0x10dad-0x10dc9 method sub_11a7d
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x2d09;
    di = memoryAGet16(ds, 0x541d);
    di += di;
    ax = memoryAGet16(cs, bx + di);
    di = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    callIndirect(cs, ax);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:2d15 sub_11aa5()
sub_11aa5 PROC
0ed9:2d15	push	di
0ed9:2d16	push	si
0ed9:2d17	push	bp
0ed9:2d18	push	ds
0ed9:2d19	push	es
0ed9:2d1a	mov	bx, 0x1228
0ed9:2d1d	mov	ds, bx
0ed9:2d1f	mov	ds, dx
0ed9:2d21	mov	si, ax
0ed9:2d23	mov	bx, 0x2d37
0ed9:2d26	mov	di, word ptr [0x541d]
0ed9:2d2a	add	di, di
0ed9:2d2c	mov	ax, word ptr cs:[bx + di]
0ed9:2d2f	call	ax
0ed9:2d31	pop	es
0ed9:2d32	pop	ds
0ed9:2d33	pop	bp
0ed9:2d34	pop	si
0ed9:2d35	pop	di
0ed9:2d36	retf	
sub_11aa5 ENDP
*/
void sub_11aa5()
{
    // coverage: 0x10dd5-0x10df7 method sub_11aa5
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = 0x1228;
    ds = bx;
    ds = dx;
    si = ax;
    bx = 0x2d37;
    di = memoryAGet16(ds, 0x541d);
    di += di;
    ax = memoryAGet16(cs, bx + di);
    callIndirect(cs, ax);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:2d6d sub_11afd()
sub_11afd PROC
0ed9:2d6d	push	di
0ed9:2d6e	push	si
0ed9:2d6f	push	bp
0ed9:2d70	push	ds
0ed9:2d71	push	es
0ed9:2d72	mov	ax, 0x1228
0ed9:2d75	mov	ds, ax
0ed9:2d77	push	ds
0ed9:2d78	lds	si, ptr [0x56de]
0ed9:2d7c	lds	si, ptr [si]
0ed9:2d7e	mov	ax, ds
0ed9:2d80	pop	ds
0ed9:2d81	mov	word ptr [0x56e2], si
0ed9:2d85	mov	word ptr [0x56e4], ax
0ed9:2d88	mov	bx, 0x2d9c
0ed9:2d8b	mov	di, word ptr [0x541d]
0ed9:2d8f	add	di, di
0ed9:2d91	mov	ax, word ptr cs:[bx + di]
0ed9:2d94	call	ax
0ed9:2d96	pop	es
0ed9:2d97	pop	ds
0ed9:2d98	pop	bp
0ed9:2d99	pop	si
0ed9:2d9a	pop	di
0ed9:2d9b	retf	
sub_11afd ENDP
*/
void sub_11afd()
{
    // coverage: 0x10e2d-0x10e5c method sub_11afd
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    push(ds);
    si = memoryAGet16(ds, 0x56de);
    ds = memoryAGet16(ds, 0x56de + 2);
    tx = si;
    si = memoryAGet16(ds, tx);
    ds = memoryAGet16(ds, tx + 2);
    ax = ds;
    ds = pop();
    memoryASet16(ds, 0x56e2, si);
    memoryASet16(ds, 0x56e4, ax);
    bx = 0x2d9c;
    di = memoryAGet16(ds, 0x541d);
    di += di;
    ax = memoryAGet16(cs, bx + di);
    callIndirect(cs, ax);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:2da8 sub_11b38()
sub_11b38 PROC
0ed9:2da8	push	di
0ed9:2da9	push	si
0ed9:2daa	push	bp
0ed9:2dab	push	ds
0ed9:2dac	push	es
0ed9:2dad	mov	ax, 0x1228
0ed9:2db0	mov	ds, ax
0ed9:2db2	mov	bx, 0x2dc6
0ed9:2db5	mov	di, word ptr [0x541d]
0ed9:2db9	add	di, di
0ed9:2dbb	mov	ax, word ptr cs:[bx + di]
0ed9:2dbe	call	ax
0ed9:2dc0	pop	es
0ed9:2dc1	pop	ds
0ed9:2dc2	pop	bp
0ed9:2dc3	pop	si
0ed9:2dc4	pop	di
0ed9:2dc5	retf	
sub_11b38 ENDP
*/
void sub_11b38()
{
    // coverage: 0x10e68-0x10e86 method sub_11b38
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    bx = 0x2dc6;
    di = memoryAGet16(ds, 0x541d);
    di += di;
    ax = memoryAGet16(cs, bx + di);
    callIndirect(cs, ax);
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:2dd2 sub_11b62()
sub_11b62 PROC
0ed9:2dd2	push	ds
0ed9:2dd3	mov	ax, 0x1228
0ed9:2dd6	mov	ds, ax
0ed9:2dd8	mov	ax, word ptr [bp + 4]
0ed9:2ddb	shl	ax, 1
0ed9:2ddd	shl	ax, 1
0ed9:2ddf	add	ax, 0x5415
0ed9:2de2	mov	word ptr [0x56de], ax
0ed9:2de5	mov	ax, 0x1228
0ed9:2de8	mov	word ptr [0x56e0], ax
0ed9:2deb	pop	ds
0ed9:2dec	retf	
sub_11b62 ENDP
*/
void sub_11b62()
{
    // coverage: 0x10e92-0x10ead method sub_11b62
    push(ds);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ss, bp + 4);
    ax <<= 1;
    ax <<= 1;
    ax += 0x5415;
    memoryASet16(ds, 0x56de, ax);
    ax = 0x1228;
    memoryASet16(ds, 0x56e0, ax);
    ds = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:2ded sub_11b7d()
sub_11b7d PROC
0ed9:2ded	push	di
0ed9:2dee	push	si
0ed9:2def	push	bp
0ed9:2df0	push	ds
0ed9:2df1	push	es
0ed9:2df2	mov	ax, 0x1228
0ed9:2df5	mov	ds, ax
0ed9:2df7	les	si, ptr [bp + 4]
0ed9:2dfa	mov	word ptr [0x56ee], 0x56f0
        	loc_11b90:
0ed9:2e00	push	es
0ed9:2e01	les	bx, ptr es:[si]
0ed9:2e04	mov	ax, es
0ed9:2e06	or	ax, bx
0ed9:2e08	jne	loc_11ba1
0ed9:2e0a	pop	es
0ed9:2e0b	pop	es
0ed9:2e0c	pop	ds
0ed9:2e0d	pop	bp
0ed9:2e0e	pop	si
0ed9:2e0f	pop	di
0ed9:2e10	retf	
        	loc_11ba1:
0ed9:2e11	mov	ax, word ptr es:[bx + 4]
0ed9:2e15	shl	ax, 1
0ed9:2e17	shl	ax, 1
0ed9:2e19	mov	di, 0x1228
0ed9:2e1c	mov	ds, di
0ed9:2e1e	lds	di, ptr es:[bx + 6]
0ed9:2e22	add	di, ax
0ed9:2e24	lds	di, ptr [di]
0ed9:2e26	mov	word ptr es:[bx + 0xc], di
0ed9:2e2a	mov	ax, ds
0ed9:2e2c	mov	word ptr es:[bx + 0xe], ax
0ed9:2e30	or	ax, di
0ed9:2e32	jne	loc_11bca
0ed9:2e34	mov	word ptr es:[bx + 0xa], 0
        	loc_11bca:
0ed9:2e3a	mov	ax, word ptr [di - 2]
0ed9:2e3d	mov	word ptr es:[bx + 0x12], ax
0ed9:2e41	mov	ax, word ptr [di - 4]
0ed9:2e44	mov	word ptr es:[bx + 0x10], ax
0ed9:2e48	mov	ax, word ptr [di - 6]
0ed9:2e4b	mov	word ptr es:[bx + 0x14], ax
0ed9:2e4f	mov	ax, word ptr [di - 8]
0ed9:2e52	mov	word ptr es:[bx + 0x16], ax
0ed9:2e56	mov	ax, word ptr [di - 0xc]
0ed9:2e59	mov	word ptr es:[bx + 0x18], ax
0ed9:2e5d	cmp	ax, 3
0ed9:2e60	jb	loc_11bf5
0ed9:2e62	mov	ax, 3
        	loc_11bf5:
0ed9:2e65	mov	word ptr es:[bx + 0x18], ax
0ed9:2e69	or	ax, ax
0ed9:2e6b	je	loc_11c20
0ed9:2e6d	push	ds
0ed9:2e6e	push	di
0ed9:2e6f	push	es
0ed9:2e70	push	si
0ed9:2e71	push	cx
0ed9:2e72	mov	cx, ax
0ed9:2e74	lea	si, [di - 0xc]
0ed9:2e77	lea	di, [bx + 0x1a]
        	loc_11c0a:
0ed9:2e7a	dec	si
0ed9:2e7b	dec	si
0ed9:2e7c	movsw	word ptr es:[di], word ptr [si]
0ed9:2e7d	dec	si
0ed9:2e7e	dec	si
0ed9:2e7f	dec	si
0ed9:2e80	dec	si
0ed9:2e81	movsw	word ptr es:[di], word ptr [si]
0ed9:2e82	dec	si
0ed9:2e83	dec	si
0ed9:2e84	dec	si
0ed9:2e85	dec	si
0ed9:2e86	movsw	word ptr es:[di], word ptr [si]
0ed9:2e87	dec	si
0ed9:2e88	dec	si
0ed9:2e89	loop	loc_11c0a
0ed9:2e8b	pop	cx
0ed9:2e8c	pop	si
0ed9:2e8d	pop	es
0ed9:2e8e	pop	di
0ed9:2e8f	pop	ds
        	loc_11c20:
0ed9:2e90	mov	al, byte ptr [di - 0xa]
0ed9:2e93	mov	byte ptr es:[bx + 0xb], al
0ed9:2e97	and	al, 0xc0
0ed9:2e99	jne	loc_11c32
        	loc_11c2b:
0ed9:2e9b	add	si, 4
0ed9:2e9e	pop	es
0ed9:2e9f	jmp	loc_11b90
        	loc_11c32:
0ed9:2ea2	test	al, 0x40
0ed9:2ea4	jne	loc_11c39
0ed9:2ea6	jmp	loc_11df8
        	loc_11c39:
0ed9:2ea9	push	si
0ed9:2eaa	push	di
0ed9:2eab	mov	dh, byte ptr es:[bx + 0xa]
0ed9:2eaf	mov	ax, word ptr es:[0x56ee]
0ed9:2eb3	mov	si, di
0ed9:2eb5	sub	si, 0xc
0ed9:2eb8	mov	di, ax
0ed9:2eba	add	ax, 0xc
0ed9:2ebd	mov	word ptr es:[bx + 0xc], ax
0ed9:2ec1	mov	ax, 0x1228
0ed9:2ec4	mov	word ptr es:[bx + 0xe], ax
0ed9:2ec8	mov	es, ax
0ed9:2eca	mov	cx, 6
0ed9:2ecd	rep movsw	word ptr es:[di], word ptr [si]
0ed9:2ecf	mov	bx, si
0ed9:2ed1	mov	al, byte ptr [si - 4]
0ed9:2ed4	shr	al, 1
0ed9:2ed6	shr	al, 1
0ed9:2ed8	mov	ah, byte ptr [si - 2]
0ed9:2edb	mul	ah
0ed9:2edd	add	si, ax
0ed9:2edf	mov	cx, ax
0ed9:2ee1	test	dh, 0x20
0ed9:2ee4	jne	loc_11c79
0ed9:2ee6	jmp	loc_11d93
        	loc_11c79:
0ed9:2ee9	mov	cx, word ptr [bx - 4]
0ed9:2eec	mov	bp, cx
0ed9:2eee	shl	cx, 1
0ed9:2ef0	sub	di, cx
0ed9:2ef2	sub	di, 8
0ed9:2ef5	mov	cx, word ptr [bx - 2]
        	loc_11c88:
0ed9:2ef8	push	cx
0ed9:2ef9	mov	cx, bp
0ed9:2efb	shl	cx, 1
0ed9:2efd	shl	cx, 1
0ed9:2eff	add	di, cx
0ed9:2f01	mov	cx, bp
0ed9:2f03	shr	cx, 1
0ed9:2f05	shr	cx, 1
        	loc_11c97:
0ed9:2f07	push	cx
0ed9:2f08	mov	cl, byte ptr [bx]
0ed9:2f0a	inc	bx
0ed9:2f0b	push	bx
0ed9:2f0c	xor	ah, ah
0ed9:2f0e	xor	al, al
0ed9:2f10	test	cl, 0x80
0ed9:2f13	je	loc_11cb0
0ed9:2f15	mov	al, byte ptr [si]
0ed9:2f17	mov	bx, 0x66f0
0ed9:2f1a	add	bx, ax
0ed9:2f1c	mov	al, byte ptr es:[bx]
0ed9:2f1f	inc	si
        	loc_11cb0:
0ed9:2f20	mov	ch, al
0ed9:2f22	xor	al, al
0ed9:2f24	test	cl, 0x40
0ed9:2f27	je	loc_11cc4
0ed9:2f29	mov	al, byte ptr [si]
0ed9:2f2b	mov	bx, 0x66f0
0ed9:2f2e	add	bx, ax
0ed9:2f30	mov	al, byte ptr es:[bx]
0ed9:2f33	inc	si
        	loc_11cc4:
0ed9:2f34	stosb	byte ptr es:[di], al
0ed9:2f35	xor	al, al
0ed9:2f37	test	cl, 0x20
0ed9:2f3a	je	loc_11cd7
0ed9:2f3c	mov	al, byte ptr [si]
0ed9:2f3e	mov	bx, 0x66f0
0ed9:2f41	add	bx, ax
0ed9:2f43	mov	al, byte ptr es:[bx]
0ed9:2f46	inc	si
        	loc_11cd7:
0ed9:2f47	mov	dl, al
0ed9:2f49	xor	al, al
0ed9:2f4b	test	cl, 0x10
0ed9:2f4e	je	loc_11ceb
0ed9:2f50	mov	al, byte ptr [si]
0ed9:2f52	mov	bx, 0x66f0
0ed9:2f55	add	bx, ax
0ed9:2f57	mov	al, byte ptr es:[bx]
0ed9:2f5a	inc	si
        	loc_11ceb:
0ed9:2f5b	stosb	byte ptr es:[di], al
0ed9:2f5c	xor	al, al
0ed9:2f5e	test	cl, 8
0ed9:2f61	je	loc_11cfe
0ed9:2f63	mov	al, byte ptr [si]
0ed9:2f65	mov	bx, 0x66f0
0ed9:2f68	add	bx, ax
0ed9:2f6a	mov	al, byte ptr es:[bx]
0ed9:2f6d	inc	si
        	loc_11cfe:
0ed9:2f6e	mov	dh, al
0ed9:2f70	xor	al, al
0ed9:2f72	test	cl, 4
0ed9:2f75	je	loc_11d12
0ed9:2f77	mov	al, byte ptr [si]
0ed9:2f79	mov	bx, 0x66f0
0ed9:2f7c	add	bx, ax
0ed9:2f7e	mov	al, byte ptr es:[bx]
0ed9:2f81	inc	si
        	loc_11d12:
0ed9:2f82	stosb	byte ptr es:[di], al
0ed9:2f83	xor	al, al
0ed9:2f85	test	cl, 2
0ed9:2f88	je	loc_11d25
0ed9:2f8a	mov	al, byte ptr [si]
0ed9:2f8c	mov	bx, 0x66f0
0ed9:2f8f	add	bx, ax
0ed9:2f91	mov	al, byte ptr es:[bx]
0ed9:2f94	inc	si
        	loc_11d25:
0ed9:2f95	mov	ah, al
0ed9:2f97	xor	al, al
0ed9:2f99	test	cl, 1
0ed9:2f9c	je	loc_11d3c
0ed9:2f9e	mov	al, byte ptr [si]
0ed9:2fa0	mov	bx, 0x66f0
0ed9:2fa3	add	bl, al
0ed9:2fa5	adc	bh, 0
0ed9:2fa8	mov	al, byte ptr es:[bx]
0ed9:2fab	inc	si
        	loc_11d3c:
0ed9:2fac	stosb	byte ptr es:[di], al
0ed9:2fad	mov	cl, ah
0ed9:2faf	mov	ax, word ptr cs:[0xded]
0ed9:2fb3	cmp	ax, 0
0ed9:2fb6	jne	loc_11d60
0ed9:2fb8	mov	ax, word ptr es:[di - 2]
0ed9:2fbc	xchg	al, ah
0ed9:2fbe	mov	word ptr es:[di - 2], ax
0ed9:2fc2	mov	ax, word ptr es:[di - 4]
0ed9:2fc6	xchg	al, ah
0ed9:2fc8	mov	word ptr es:[di - 4], ax
0ed9:2fcc	xchg	dl, ch
0ed9:2fce	xchg	cl, dh
        	loc_11d60:
0ed9:2fd0	mov	al, ch
0ed9:2fd2	stosb	byte ptr es:[di], al
0ed9:2fd3	mov	al, dl
0ed9:2fd5	stosb	byte ptr es:[di], al
0ed9:2fd6	mov	al, dh
0ed9:2fd8	stosb	byte ptr es:[di], al
0ed9:2fd9	mov	al, cl
0ed9:2fdb	stosb	byte ptr es:[di], al
0ed9:2fdc	sub	di, 0x10
0ed9:2fdf	pop	bx
0ed9:2fe0	pop	cx
0ed9:2fe1	dec	cx
0ed9:2fe2	or	cx, cx
0ed9:2fe4	je	loc_11d79
0ed9:2fe6	jmp	loc_11c97
        	loc_11d79:
0ed9:2fe9	pop	cx
0ed9:2fea	dec	cx
0ed9:2feb	or	cx, cx
0ed9:2fed	je	loc_11d82
0ed9:2fef	jmp	loc_11c88
        	loc_11d82:
0ed9:2ff2	shl	bp, 1
0ed9:2ff4	add	di, bp
0ed9:2ff6	add	di, 8
0ed9:2ff9	mov	word ptr es:[0x56ee], di
0ed9:2ffe	pop	di
0ed9:2fff	pop	si
0ed9:3000	jmp	loc_11c2b
        	loc_11d93:
0ed9:3003	push	cx
0ed9:3004	mov	cl, byte ptr [bx]
0ed9:3006	inc	bx
0ed9:3007	xor	ax, ax
0ed9:3009	shl	cx, 1
0ed9:300b	jae	loc_11da0
0ed9:300d	mov	al, byte ptr [si]
0ed9:300f	inc	si
        	loc_11da0:
0ed9:3010	stosb	byte ptr es:[di], al
0ed9:3011	shl	cx, 1
0ed9:3013	jae	loc_11da8
0ed9:3015	mov	ah, byte ptr [si]
0ed9:3017	inc	si
        	loc_11da8:
0ed9:3018	xor	al, al
0ed9:301a	shl	cx, 1
0ed9:301c	jae	loc_11db1
0ed9:301e	mov	al, byte ptr [si]
0ed9:3020	inc	si
        	loc_11db1:
0ed9:3021	stosb	byte ptr es:[di], al
0ed9:3022	xor	ch, ch
0ed9:3024	shl	cx, 1
0ed9:3026	jae	loc_11dbb
0ed9:3028	mov	ch, byte ptr [si]
0ed9:302a	inc	si
        	loc_11dbb:
0ed9:302b	xor	al, al
0ed9:302d	shl	cx, 1
0ed9:302f	jae	loc_11dc4
0ed9:3031	mov	al, byte ptr [si]
0ed9:3033	inc	si
        	loc_11dc4:
0ed9:3034	stosb	byte ptr es:[di], al
0ed9:3035	xor	dl, dl
0ed9:3037	shl	cx, 1
0ed9:3039	jae	loc_11dce
0ed9:303b	mov	dl, byte ptr [si]
0ed9:303d	inc	si
        	loc_11dce:
0ed9:303e	xor	al, al
0ed9:3040	shl	cx, 1
0ed9:3042	jae	loc_11dd7
0ed9:3044	mov	al, byte ptr [si]
0ed9:3046	inc	si
        	loc_11dd7:
0ed9:3047	stosb	byte ptr es:[di], al
0ed9:3048	mov	al, ah
0ed9:304a	stosb	byte ptr es:[di], al
0ed9:304b	mov	al, ch
0ed9:304d	stosb	byte ptr es:[di], al
0ed9:304e	mov	al, dl
0ed9:3050	stosb	byte ptr es:[di], al
0ed9:3051	xor	al, al
0ed9:3053	shl	cx, 1
0ed9:3055	jae	loc_11dea
0ed9:3057	mov	al, byte ptr [si]
0ed9:3059	inc	si
        	loc_11dea:
0ed9:305a	stosb	byte ptr es:[di], al
0ed9:305b	pop	cx
0ed9:305c	loop	loc_11d93
0ed9:305e	mov	word ptr es:[0x56ee], di
0ed9:3063	pop	di
0ed9:3064	pop	si
0ed9:3065	jmp	loc_11c2b
        	loc_11df8:
0ed9:3068	jmp	loc_11c2b
sub_11b7d ENDP
*/
void sub_11b7d()
{
    // coverage: 0x10ead-0x1112b method sub_11b7d
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    si = memoryAGet16(ss, bp + 4);
    es = memoryAGet16(ss, bp + 4 + 2);
    memoryASet16(ds, 0x56ee, 0x56f0);
loc_11b90:
    push(es);
    bx = memoryAGet16(es, si);
    es = memoryAGet16(es, si + 2);
    ax = es;
    ax |= bx;
    if (ax)
        goto loc_11ba1;
    es = pop();
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
    return;
loc_11ba1:
    ax = memoryAGet16(es, bx + 4);
    ax <<= 1;
    ax <<= 1;
    di = 0x1228;
    ds = di;
    di = memoryAGet16(es, bx + 6);
    ds = memoryAGet16(es, bx + 6 + 2);
    di += ax;
    tx = di;
    di = memoryAGet16(ds, tx);
    ds = memoryAGet16(ds, tx + 2);
    memoryASet16(es, bx + 12, di);
    ax = ds;
    memoryASet16(es, bx + 14, ax);
    ax |= di;
    if (ax)
        goto loc_11bca;
    memoryASet16(es, bx + 10, 0x0000);
loc_11bca:
    ax = memoryAGet16(ds, di + 65534);
    memoryASet16(es, bx + 18, ax);
    ax = memoryAGet16(ds, di + 65532);
    memoryASet16(es, bx + 16, ax);
    ax = memoryAGet16(ds, di + 65530);
    memoryASet16(es, bx + 20, ax);
    ax = memoryAGet16(ds, di + 65528);
    memoryASet16(es, bx + 22, ax);
    ax = memoryAGet16(ds, di + 65524);
    memoryASet16(es, bx + 24, ax);
    if (ax < 0x0003)
        goto loc_11bf5;
    ax = 0x0003;
loc_11bf5:
    memoryASet16(es, bx + 24, ax);
    if (!ax)
        goto loc_11c20;
    push(ds);
    push(di);
    push(es);
    push(si);
    push(cx);
    cx = ax;
    si = di + 0xfffffff4;
    di = bx + 0x1a;
loc_11c0a:
    si--;
    si--;
    movsw<MemAuto, MemAuto, DirAuto>();
    si--;
    si--;
    si--;
    si--;
    movsw<MemAuto, MemAuto, DirAuto>();
    si--;
    si--;
    si--;
    si--;
    movsw<MemAuto, MemAuto, DirAuto>();
    si--;
    si--;
    if (--cx)
        goto loc_11c0a;
    cx = pop();
    si = pop();
    es = pop();
    di = pop();
    ds = pop();
loc_11c20:
    al = memoryAGet(ds, di + 65526);
    memoryASet(es, bx + 11, al);
    al &= 0xc0;
    if (al != 0)
        goto loc_11c32;
loc_11c2b:
    si += 0x0004;
    es = pop();
    goto loc_11b90;
loc_11c32:
    if (al & 0x40)
        goto loc_11c39;
    goto loc_11df8;
loc_11c39:
    push(si);
    push(di);
    dh = memoryAGet(es, bx + 10);
    ax = memoryAGet16(es, 0x56ee);
    si = di;
    si -= 0x000c;
    di = ax;
    ax += 0x000c;
    memoryASet16(es, bx + 12, ax);
    ax = 0x1228;
    memoryASet16(es, bx + 14, ax);
    es = ax;
    cx = 0x0006;
    rep_movsw<MemAuto, MemAuto, DirAuto>();
    bx = si;
    al = memoryAGet(ds, si + 65532);
    al >>= 1;
    al >>= 1;
    ah = memoryAGet(ds, si + 65534);
    mul(ah);
    si += ax;
    cx = ax;
    if (dh & 0x20)
        goto loc_11c79;
    goto loc_11d93;
loc_11c79:
    cx = memoryAGet16(ds, bx + 65532);
    bp = cx;
    cx <<= 1;
    di -= cx;
    di -= 0x0008;
    cx = memoryAGet16(ds, bx + 65534);
loc_11c88:
    push(cx);
    cx = bp;
    cx <<= 1;
    cx <<= 1;
    di += cx;
    cx = bp;
    cx >>= 1;
    cx >>= 1;
loc_11c97:
    push(cx);
    cl = memoryAGet(ds, bx);
    bx++;
    push(bx);
    ah = 0;
    al = 0;
    if (!(cl & 0x80))
        goto loc_11cb0;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11cb0:
    ch = al;
    al = 0;
    if (!(cl & 0x40))
        goto loc_11cc4;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11cc4:
    stosb<MemAuto, DirAuto>();
    al = 0;
    if (!(cl & 0x20))
        goto loc_11cd7;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11cd7:
    dl = al;
    al = 0;
    if (!(cl & 0x10))
        goto loc_11ceb;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11ceb:
    stosb<MemAuto, DirAuto>();
    al = 0;
    if (!(cl & 0x08))
        goto loc_11cfe;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11cfe:
    dh = al;
    al = 0;
    if (!(cl & 0x04))
        goto loc_11d12;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11d12:
    stosb<MemAuto, DirAuto>();
    al = 0;
    if (!(cl & 0x02))
        goto loc_11d25;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    bx += ax;
    al = memoryAGet(es, bx);
    si++;
loc_11d25:
    ah = al;
    al = 0;
    if (!(cl & 0x01))
        goto loc_11d3c;
    al = memoryAGet(ds, si);
    bx = 0x66f0;
    flags.carry = (bl + al) >= 0x100;
    bl += al;
    bh += flags.carry;
    al = memoryAGet(es, bx);
    si++;
loc_11d3c:
    stosb<MemAuto, DirAuto>();
    cl = ah;
    ax = memoryAGet16(cs, 0x0ded);
    if (ax != 0x0000)
        goto loc_11d60;
    ax = memoryAGet16(es, di + 65534);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(es, di + 65534, ax);
    ax = memoryAGet16(es, di + 65532);
    tl = al;
    al = ah;
    ah = tl;
    memoryASet16(es, di + 65532, ax);
    tl = dl;
    dl = ch;
    ch = tl;
    tl = cl;
    cl = dh;
    dh = tl;
loc_11d60:
    al = ch;
    stosb<MemAuto, DirAuto>();
    al = dl;
    stosb<MemAuto, DirAuto>();
    al = dh;
    stosb<MemAuto, DirAuto>();
    al = cl;
    stosb<MemAuto, DirAuto>();
    di -= 0x0010;
    bx = pop();
    cx = pop();
    cx--;
    if (!cx)
        goto loc_11d79;
    goto loc_11c97;
loc_11d79:
    cx = pop();
    cx--;
    if (!cx)
        goto loc_11d82;
    goto loc_11c88;
loc_11d82:
    bp <<= 1;
    di += bp;
    di += 0x0008;
    memoryASet16(es, 0x56ee, di);
    di = pop();
    si = pop();
    goto loc_11c2b;
loc_11d93:
    push(cx);
    cl = memoryAGet(ds, bx);
    bx++;
    ax = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11da0;
    al = memoryAGet(ds, si);
    si++;
loc_11da0:
    stosb<MemAuto, DirAuto>();
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11da8;
    ah = memoryAGet(ds, si);
    si++;
loc_11da8:
    al = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11db1;
    al = memoryAGet(ds, si);
    si++;
loc_11db1:
    stosb<MemAuto, DirAuto>();
    ch = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11dbb;
    ch = memoryAGet(ds, si);
    si++;
loc_11dbb:
    al = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11dc4;
    al = memoryAGet(ds, si);
    si++;
loc_11dc4:
    stosb<MemAuto, DirAuto>();
    dl = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11dce;
    dl = memoryAGet(ds, si);
    si++;
loc_11dce:
    al = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11dd7;
    al = memoryAGet(ds, si);
    si++;
loc_11dd7:
    stosb<MemAuto, DirAuto>();
    al = ah;
    stosb<MemAuto, DirAuto>();
    al = ch;
    stosb<MemAuto, DirAuto>();
    al = dl;
    stosb<MemAuto, DirAuto>();
    al = 0;
    flags.carry = !!(cx & 0x8000);
    cx <<= 1;
    if (!flags.carry)
        goto loc_11dea;
    al = memoryAGet(ds, si);
    si++;
loc_11dea:
    stosb<MemAuto, DirAuto>();
    cx = pop();
    if (--cx)
        goto loc_11d93;
    memoryASet16(es, 0x56ee, di);
    di = pop();
    si = pop();
    goto loc_11c2b;
loc_11df8:
    goto loc_11c2b;
}
/* Assembly listing of 0ed9:3137 sub_11ec7()
sub_11ec7 PROC
0ed9:3137	push	di
0ed9:3138	push	si
0ed9:3139	push	bp
0ed9:313a	push	ds
0ed9:313b	push	es
0ed9:313c	mov	ax, 0x1228
0ed9:313f	mov	ds, ax
0ed9:3141	mov	bx, 0x66f0
0ed9:3144	mov	cx, 0
0ed9:3147	mov	ax, word ptr [0x541d]
0ed9:314a	cmp	ax, 0
0ed9:314d	jne	loc_11f15
        	loc_11edf:
0ed9:314f	mov	dl, cl
0ed9:3151	shr	dl, 1
0ed9:3153	rcr	al, 1
0ed9:3155	shr	dl, 1
0ed9:3157	rcl	ah, 1
0ed9:3159	shl	ax, 1
0ed9:315b	shr	dl, 1
0ed9:315d	rcr	al, 1
0ed9:315f	shr	dl, 1
0ed9:3161	rcl	ah, 1
0ed9:3163	shl	ax, 1
0ed9:3165	shr	dl, 1
0ed9:3167	rcr	al, 1
0ed9:3169	shr	dl, 1
0ed9:316b	rcl	ah, 1
0ed9:316d	shl	ax, 1
0ed9:316f	shr	dl, 1
0ed9:3171	rcr	al, 1
0ed9:3173	shr	dl, 1
0ed9:3175	rcl	ah, 1
0ed9:3177	shl	ax, 1
0ed9:3179	mov	byte ptr [bx], ah
0ed9:317b	inc	bx
0ed9:317c	inc	cx
0ed9:317d	cmp	cx, 0xff
0ed9:3181	jle	loc_11edf
0ed9:3183	jmp	loc_11f41
        	loc_11f15:
0ed9:3185	mov	ah, cl
0ed9:3187	shr	ah, 1
0ed9:3189	rcl	al, 1
0ed9:318b	shr	ah, 1
0ed9:318d	rcl	al, 1
0ed9:318f	shr	ah, 1
0ed9:3191	rcl	al, 1
0ed9:3193	shr	ah, 1
0ed9:3195	rcl	al, 1
0ed9:3197	shr	ah, 1
0ed9:3199	rcl	al, 1
0ed9:319b	shr	ah, 1
0ed9:319d	rcl	al, 1
0ed9:319f	shr	ah, 1
0ed9:31a1	rcl	al, 1
0ed9:31a3	shr	ah, 1
0ed9:31a5	rcl	al, 1
0ed9:31a7	mov	byte ptr [bx], al
0ed9:31a9	inc	bx
0ed9:31aa	inc	cx
0ed9:31ab	cmp	cx, 0xff
0ed9:31af	jle	loc_11f15
        	loc_11f41:
0ed9:31b1	pop	es
0ed9:31b2	pop	ds
0ed9:31b3	pop	bp
0ed9:31b4	pop	si
0ed9:31b5	pop	di
0ed9:31b6	retf	
sub_11ec7 ENDP
*/
void sub_11ec7()
{
    // coverage: 0x111f7-0x11277 method sub_11ec7
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    bx = 0x66f0;
    cx = 0x0000;
    ax = memoryAGet16(ds, 0x541d);
    if (ax != 0x0000)
        goto loc_11f15;
loc_11edf:
    dl = cl;
    flags.carry = dl & 1;
    dl >>= 1;
    al = rcr(al, 0x01);
    flags.carry = dl & 1;
    dl >>= 1;
    ah = rcl(ah, 0x01);
    ax <<= 1;
    flags.carry = dl & 1;
    dl >>= 1;
    al = rcr(al, 0x01);
    flags.carry = dl & 1;
    dl >>= 1;
    ah = rcl(ah, 0x01);
    ax <<= 1;
    flags.carry = dl & 1;
    dl >>= 1;
    al = rcr(al, 0x01);
    flags.carry = dl & 1;
    dl >>= 1;
    ah = rcl(ah, 0x01);
    ax <<= 1;
    flags.carry = dl & 1;
    dl >>= 1;
    al = rcr(al, 0x01);
    flags.carry = dl & 1;
    dl >>= 1;
    ah = rcl(ah, 0x01);
    ax <<= 1;
    memoryASet(ds, bx, ah);
    bx++;
    cx++;
    if ((short)cx <= (short)0x00ff)
        goto loc_11edf;
    goto loc_11f41;
loc_11f15:
    ah = cl;
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    flags.carry = ah & 1;
    ah >>= 1;
    al = rcl(al, 0x01);
    memoryASet(ds, bx, al);
    bx++;
    cx++;
    if ((short)cx <= (short)0x00ff)
        goto loc_11f15;
loc_11f41:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 0ed9:31b7 sub_11f47()
sub_11f47 PROC
0ed9:31b7	push	di
0ed9:31b8	push	si
0ed9:31b9	push	bp
0ed9:31ba	push	ds
0ed9:31bb	push	es
0ed9:31bc	mov	ax, 0x1228
0ed9:31bf	mov	ds, ax
0ed9:31c1	mov	ax, word ptr [bp + 4]
0ed9:31c4	mov	word ptr [0x67f0], ax
0ed9:31c7	mov	dx, word ptr [bp + 6]
0ed9:31ca	mov	word ptr [0x67f2], dx
0ed9:31ce	mov	es, dx
0ed9:31d0	mov	di, ax
0ed9:31d2	mov	al, byte ptr es:[di + 0xa]
0ed9:31d6	mov	byte ptr cs:[0x320e], al
0ed9:31da	mov	bp, sp
0ed9:31dc	mov	ax, 0x1228
0ed9:31df	push	ax
0ed9:31e0	mov	ax, 0x67f0
0ed9:31e3	push	ax
0ed9:31e4	push	bp
0ed9:31e5	mov	bp, sp
0ed9:31e7	sub	bp, 2
0ed9:31ea	push	cs
0ed9:31eb	call	0x2ded
0ed9:31ee	pop	bp
0ed9:31ef	mov	sp, bp
0ed9:31f1	mov	bp, sp
0ed9:31f3	mov	ax, 0x1228
0ed9:31f6	push	ax
0ed9:31f7	mov	ax, 0x67f0
0ed9:31fa	push	ax
0ed9:31fb	push	bp
0ed9:31fc	mov	bp, sp
0ed9:31fe	sub	bp, 2
0ed9:3201	push	cs
0ed9:3202	call	0x2d6d
0ed9:3205	pop	bp
0ed9:3206	mov	sp, bp
0ed9:3208	pop	es
0ed9:3209	pop	ds
0ed9:320a	pop	bp
0ed9:320b	pop	si
0ed9:320c	pop	di
0ed9:320d	retf	
sub_11f47 ENDP
*/
void sub_11f47()
{
    // coverage: 0x11277-0x112ce method sub_11f47
    push(0x7777);
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    ax = memoryAGet16(ss, bp + 4);
    memoryASet16(ds, 0x67f0, ax);
    dx = memoryAGet16(ss, bp + 6);
    memoryASet16(ds, 0x67f2, dx);
    es = dx;
    di = ax;
    al = memoryAGet(es, di + 10);
    memoryASet(cs, 0x320e, al);
    bp = sp;
    ax = 0x1228;
    push(ax);
    ax = 0x67f0;
    push(ax);
    push(bp);
    bp = sp;
    bp -= 0x0002;
    push(cs);
    sub_11b7d();
    bp = pop();
    sp = bp;
    bp = sp;
    ax = 0x1228;
    push(ax);
    ax = 0x67f0;
    push(ax);
    push(bp);
    bp = sp;
    bp -= 0x0002;
    push(cs);
    sub_11afd();
    bp = pop();
    sp = bp;
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
/* Assembly listing of 1219:0000 sub_12190()
sub_12190 PROC
1219:0000	push	di
1219:0001	push	si
1219:0002	push	bp
1219:0003	push	ds
1219:0004	push	es
1219:0005	mov	ax, 0x1228
1219:0008	mov	ds, ax
1219:000a	mov	ax, 2
1219:000d	int	0x10
1219:000f	mov	si, 0x6840
1219:0012	xor	bh, bh
1219:0014	mov	dx, 0x101
1219:0017	mov	ah, 2
1219:0019	int	0x10
1219:001b	mov	ah, 9
1219:001d	mov	dx, si
1219:001f	int	0x21
1219:0021	mov	si, 0x6858
1219:0024	mov	di, 0x689e
1219:0027	mov	bh, 0
1219:0029	mov	cx, 4
1219:002c	mov	dx, 0xa21
        	loc_121bf:
1219:002f	cmp	byte ptr [di], 1
1219:0032	jne	loc_121d2
1219:0034	mov	ah, 2
1219:0036	int	0x10
1219:0038	push	dx
1219:0039	mov	ah, 9
1219:003b	mov	dx, si
1219:003d	int	0x21
1219:003f	pop	dx
1219:0040	inc	dh
        	loc_121d2:
1219:0042	add	si, 0x11
1219:0045	inc	di
1219:0046	loop	loc_121bf
        	loc_121d8:
1219:0048	mov	al, 0x3f
1219:004a	lcall	0x1ed, 0x97aa
1219:004f	jne	loc_121fe
1219:0051	mov	al, 0x40
1219:0053	lcall	0x1ed, 0x97aa
1219:0058	jne	loc_12206
1219:005a	mov	al, 0x41
1219:005c	lcall	0x1ed, 0x97aa
1219:0061	jne	loc_1220e
1219:0063	mov	al, 0x42
1219:0065	lcall	0x1ed, 0x97aa
1219:006a	jne	loc_12216
1219:006c	jmp	loc_121d8
        	loc_121fe:
1219:006e	mov	word ptr [0x689c], 0x8000
1219:0074	jmp	loc_12223
        	loc_12206:
1219:0076	mov	word ptr [0x689c], 0
1219:007c	jmp	loc_12223
        	loc_1220e:
1219:007e	mov	word ptr [0x689c], 1
1219:0084	jmp	loc_12223
        	loc_12216:
1219:0086	mov	word ptr [0x689c], 4
1219:008c	jmp	loc_12223
1219:008e		
        	loc_12223:
1219:0093	pop	es
1219:0094	pop	ds
1219:0095	pop	bp
1219:0096	pop	si
1219:0097	pop	di
1219:0098	retf	
sub_12190 ENDP
*/
void sub_12190()
{
    // coverage: 0x114c0-0x1154e method sub_12190
    // coverage: 0x11553-0x11559 method sub_12190
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    ax = 0x1228;
    ds = ax;
    ax = 0x0002;
    interrupt(0x10);
    si = 0x6840;
    bh = 0;
    dx = 0x0101;
    ah = 0x02;
    interrupt(0x10);
    ah = 0x09;
    dx = si;
    interrupt(0x21);
    si = 0x6858;
    di = 0x689e;
    bh = 0x00;
    cx = 0x0004;
    dx = 0x0a21;
loc_121bf:
    if (memoryAGet(ds, di) != 0x01)
        goto loc_121d2;
    ah = 0x02;
    interrupt(0x10);
    push(dx);
    ah = 0x09;
    dx = si;
    interrupt(0x21);
    dx = pop();
    dh++;
loc_121d2:
    si += 0x0011;
    di++;
    if (--cx)
        goto loc_121bf;
loc_121d8:
    al = 0x3f;
    push(cs);
    cs = 0x01ed;
    sub_b67a();
    assert(cs == 0x1219);
    if (!flags.zero)
        goto loc_121fe;
    al = 0x40;
    push(cs);
    cs = 0x01ed;
    sub_b67a();
    assert(cs == 0x1219);
    if (!flags.zero)
        goto loc_12206;
    al = 0x41;
    push(cs);
    cs = 0x01ed;
    sub_b67a();
    assert(cs == 0x1219);
    if (!flags.zero)
        goto loc_1220e;
    al = 0x42;
    push(cs);
    cs = 0x01ed;
    sub_b67a();
    assert(cs == 0x1219);
    if (!flags.zero)
        goto loc_12216;
    goto loc_121d8;
loc_121fe:
    memoryASet16(ds, 0x689c, 0x8000);
    goto loc_12223;
loc_12206:
    memoryASet16(ds, 0x689c, 0x0000);
    goto loc_12223;
loc_1220e:
    memoryASet16(ds, 0x689c, 0x0001);
    goto loc_12223;
loc_12216:
    memoryASet16(ds, 0x689c, 0x0004);
    goto loc_12223;
    //   gap of 5 bytes
loc_12223:
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 1223:0000 sub_12230()
sub_12230 PROC
1223:0000	push	di
1223:0001	push	si
1223:0002	push	bp
1223:0003	push	ds
1223:0004	push	es
1223:0005	mov	bx, word ptr [0x541d]
1223:0009	shl	bx, 1
1223:000b	call	word ptr [bx + 0x6976]
1223:000f	pop	es
1223:0010	pop	ds
1223:0011	pop	bp
1223:0012	pop	si
1223:0013	pop	di
1223:0014	retf	
sub_12230 ENDP
*/
void sub_12230()
{
    // coverage: 0x11560-0x11575 method sub_12230
    push(di);
    push(si);
    push(bp);
    push(ds);
    push(es);
    bx = memoryAGet16(ds, 0x541d);
    bx <<= 1;
    callIndirect(cs, memoryAGet16(ds, bx + 26998));
    es = pop();
    ds = pop();
    bp = pop();
    si = pop();
    di = pop();
    cs = pop();
}
/* Assembly listing of 1223:0015 sub_12245()
sub_12245 PROC
1223:0015	mov	dx, 0x3da
        	loc_12248:
1223:0018	in	al, dx
1223:0019	test	al, 8
1223:001b	je	loc_12248
        	loc_1224d:
1223:001d	in	al, dx
1223:001e	test	al, 8
1223:0020	jne	loc_1224d
1223:0022	ret	
sub_12245 ENDP
*/
void sub_12245()
{
    // coverage: 0x11575-0x11583 method sub_12245
    dx = 0x03da;
loc_12248:
    in(al, dx);
    if (!(al & 0x08))
        goto loc_12248;
loc_1224d:
    in(al, dx);
    if (al & 0x08)
        goto loc_1224d;
}
`