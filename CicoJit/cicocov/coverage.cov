cicoData = (() => { var code="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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAABgZGRoaGhsbHBwcHR0dHh4fHx8gICEhISIiIiMjJCQkJSUmJiYnJycoKCkpKSoqKisrLCwsLS0uLi4vLy8wMDExNjk+QURIS1BTVlhbMTY5PkFDSUtQU1ZaXv/8/Pzz8PDw8/Dw8PPw8PDPzMzMw8DAwMPAwMDDwMDAz8zMzMPAwMDDwMDAw8DAwM/MzMzDwMDAw8DAwMPAwMA/PDw8MzAwMDMwMDAzMDAwDwwMDAMAAAADAAAAAwAAAA8MDAwDAAAAAwAAAAMAAAAPDAwMAwAAAAMAAAADAAAAPzw8PDMwMDAzMDAwMzAwMA8MDAwDAAAAAwAAAAMAAAAPDAwMAwAAAAMAAAADAAAADwwMDAMAAAADAAAAAwAAAD88PDwzMDAwMzAwMDMwMDAPDAwMAwAAAAMAAAADAAAADwwMDAMAAAADAAAAAwAAAA8MDAwDAAAAAwAAAAMAAAAAAwAADA8MDAADAAAAAwAAMDMwMDw/PDwwMzAwMDMwMAADAAAMDwwMAAMAAAADAAAAAwAADA8MDAADAAAAAwAAwMPAwMzPzMzAw8DAwMPAwPDz8PD8//z88PPw8PDz8PDAw8DAzM/MzMDDwMDAw8DAwMPAwMzPzMzAw8DAwMPAwAADAAAMDwwMAAMAAAADAAAwMzAwPD88PDAzMDAwMzAwAAMAAAwPDAwAAwAAAAMAAAADAAAMDwwMAAMAAAADAAAAAwAADA8MDAADAAAAAwAAMDMwMDw/PDwwMzAwMDMwMAADAAAMDwwMAAMAAAADAAAAAwAADA8MDAADAAAAAwAAAAADAAAAAwAMDA8MAAADAAAAAwAAAAMADAwPDAAAAwAwMDMwMDAzMDw8PzwwMDMwAAADAAAAAwAMDA8MAAADAAAAAwAAAAMADAwPDAAAAwAAAAMAAAADAAwMDwwAAAMAMDAzMDAwMzA8PD88MDAzMAAAAwAAAAMADAwPDAAAAwDAwMPAwMDDwMzMz8zAwMPAwMDDwMDAw8DMzM/MwMDDwPDw8/Dw8PPw/Pz//PDw8/DAwMPAwMDDwMzMz8zAwMPAAAADAAAAAwAMDA8MAAADAAAAAwAAAAMADAwPDAAAAwAwMDMwMDAzMDw8PzwwMDMwAAADAAAAAwAMDA8MAAADAAAAAAMAAAADAAAAAwwMDA8AAAADAAAAAwAAAAMMDAwPAAAAAwAAAAMAAAADDAwMDzAwMDMwMDAzMDAwMzw8PD8AAAADAAAAAwAAAAMMDAwPAAAAAwAAAAMAAAADDAwMDwAAAAMAAAADAAAAAwwMDA8wMDAzMDAwMzAwMDM8PDw/AAAAAwAAAAMAAAADDAwMDwAAAAMAAAADAAAAAwwMDA8AAAADAAAAAwAAAAMMDAwPMDAwMzAwMDMwMDAzPDw8P8DAwMPAwMDDwMDAw8zMzM/AwMDDwMDAw8DAwMPMzMzPwMDAw8DAwMPAwMDDzMzMz/Dw8PPw8PDz8PDw8/z8/P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxVMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxVMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="; return Uint8Array.from(atob(code), c => c.charCodeAt(0));})();
cicoArgs = `/Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos/GOOSE.EXE -asm -coverage -jumptable 1000:104e 1000:105a 35 callwords indirect -simplestack -ctx -recursive start `
cicoText = `
#include "cicoemu.h"
using namespace CicoContext;

void sub_10010();

// info: executable /Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos/GOOSE.EXE
// info: arguments /Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos/GOOSE.EXE -asm -coverage -jumptable 1000:104e 1000:105a 35 callwords indirect -simplestack -ctx -recursive start
// info: linearToFile 0xfe00
void start()
{
    headerSize = 0x0200;
    loadAddress = 0x1000;
    cs = 0x1000;
    ds = 0x0ff0;
    es = 0x0ff0;
    ss = 0x1cfc;
    sp = 0x0100;
    load("/Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos", "GOOSE.EXE", 53684);
    sub_10010();
}
// coverage: 0x0-0x1c header
// coverage: 0x1e-0x2e reloc
void sub_10010();
void sub_100a9();
void sub_100cf();
void sub_100fd();
void sub_10103();
void sub_1019d();
void sub_101ad();
void sub_101c0();
void sub_1033b();
void sub_10442();
void sub_104a5();
void sub_104f3();
void sub_10529();
void sub_10541();
void sub_10588();
void sub_10591();
void sub_105bc();
void sub_105ec();
void sub_10600();
void sub_10637();
void sub_10644();
void sub_1064d();
void sub_10674();
void sub_1069a();
void sub_107af();
void sub_107fd();
void sub_108ba();
void sub_1094a();
void sub_109a4();
void sub_109b5();
void sub_109e9();
void sub_10a1b();
void sub_10a51();
void sub_10ad5();
void sub_10b58();
void sub_10b7c();
void sub_10b8e();
void sub_10bc5();
void sub_10bdc();
void sub_10c24();
void sub_10d98();
void sub_10da7();
void sub_10dc0();
void sub_10e07();
void sub_10e3d();
void sub_10e84();
void sub_10f3c();
void sub_10f9d();
void sub_10fda();
void sub_110a0();
void sub_110c6();
void sub_110f3();
void sub_11108();
void sub_112a7();
void sub_112cb();
void sub_112eb();
void sub_11384();
void sub_113a8();
void sub_11429();
void sub_114f0();
void sub_115fc();
void sub_116d6();
void sub_116df();
void sub_116fe();
void sub_1171f();
void sub_11740();
void sub_1176c();
void sub_11783();
void sub_117ac();
void sub_117d6();
void sub_117f4();
void sub_118a9();
void sub_118c7();
void sub_1196f();
void sub_11993();
void sub_119c2();
void sub_11a04();
void sub_11a9e();
void sub_11b09();
void sub_11b4a();
void sub_11b57();
void sub_11b80();
void sub_11bb9();
void sub_11c0a();
void sub_11c33();
void sub_11c56();
void sub_11c78();
void sub_11cd9();
void sub_11d1e();
void sub_11def();
void sub_11e7d();
void sub_11f0b();
void sub_11fba();
void sub_12005();
void sub_12047();
void sub_12092();
void sub_12099();
void sub_120a0();
void sub_120db();
void sub_120f0();
void sub_12121();
void sub_1215b();
void sub_121dc();
void sub_12200();
void sub_1220d();
void sub_122b1();
void sub_122c1();
void sub_122e1();
void sub_122f9();
void sub_12311();
void sub_12329();
void sub_1237c();
void sub_1239b();
void sub_123d4();
void sub_123ec();
void sub_12404();
void sub_1241c();
void sub_12434();
void sub_1244c();
void sub_12464();
void sub_1250b();
void sub_1252f();
void sub_12536();
void sub_12542();
void sub_12553();
void sub_12577();
void sub_1257e();
void sub_1258a();
void sub_1259b();
void sub_125bf();
void sub_125c6();
void sub_125d2();
void sub_125e3();
void sub_1264a();
void sub_12662();
void sub_12676();
void sub_1268a();
void sub_1269e();
void sub_12714();
void sub_12762();
void sub_1279f();
void sub_12809();
void sub_12872();
void sub_128da();
void sub_12907();
void sub_12959();
void sub_1296f();
void sub_129ae();
void sub_129db();
void sub_12a64();
void sub_12a7f();
void sub_12b28();
void sub_12c07();
void sub_12c45();
void sub_12c9a();
void sub_12cc7();
void sub_12cea();
void sub_12d9a();
void sub_12ddc();
void sub_12df6();
void sub_12e02();
void sub_12f50();
void sub_12fe8();
void sub_1300a();
void sub_13059();
void sub_13084();
void sub_1309d();
void sub_13130();
void sub_1315e();
void sub_13170();
void sub_13181();
void sub_13191();
void sub_131a4();
void sub_131e7();
void sub_13209();
void sub_13291();
void sub_132fe();
void sub_1333c();
void sub_13383();
void sub_133b3();
void sub_133d7();
void sub_133e5();
void sub_13423();
void sub_13439();
void sub_13472();
void sub_13498();
void sub_134a8();
void sub_135bc();
void sub_136d4();
void sub_13801();
void sub_1382a();
void sub_13840();
void sub_13914();
void sub_139a3();
void sub_139b8();
/* Assembly listing of 1000:0010 sub_10010()
                sub_10010 PROC
1000:0010	mov	ax, 0x13a5
1000:0013	mov	ds, ax
1000:0015	mov	bx, 0x9670
1000:0018	add	bx, 0xf
1000:001b	shr	bx, 1
1000:001d	shr	bx, 1
1000:001f	shr	bx, 1
1000:0021	shr	bx, 1
1000:0023	add	ax, bx
1000:0025	mov	word ptr [0x94e8], ax
1000:0028	add	ax, 0x800
1000:002b	mov	word ptr [0x94ea], ax
1000:002e	add	ax, 0x800
1000:0031	mov	word ptr [0x94ec], ax
1000:0034	add	ax, 0x800
1000:0037	mov	word ptr [0x94ee], ax
1000:003a	add	ax, 0x800
1000:003d	mov	word ptr [0x94f0], ax
1000:0040	add	ax, 0x800
1000:0043	mov	word ptr [0x94f2], ax
1000:0046	add	ax, 0x800
1000:0049	mov	word ptr [0x94f4], ax
1000:004c	add	ax, 0x800
1000:004f	mov	word ptr [0x94f6], ax
1000:0052	int	0x12
1000:0054	cmp	ax, 0x200
1000:0057	jae	loc_10067
1000:0059	mov	dx, 7
1000:005c	mov	ah, 9
1000:005e	int	0x21
1000:0060	mov	ax, 0x4c00
1000:0063	int	0x21
1000:0065	jmp	loc_1006e
        	loc_10067:
1000:0067	mov	dx, 0x2a
1000:006a	mov	ah, 9
1000:006c	int	0x21
        	loc_1006e:
1000:006e	call	0x600
1000:0071	call	0x333c
1000:0074	call	0x2762
1000:0077	call	0x5ec
1000:007a	call	0x442
1000:007d	call	0x588
1000:0080	call	0x591
1000:0083	call	0x382a
1000:0086	mov	byte ptr [0x9501], 0
        	loc_1008b:
1000:008b	call	0xa9
1000:008e	call	0xcf
1000:0091	call	0xfd
1000:0094	jmp	loc_1008b
                sub_10010 ENDP
*/
void sub_10010()
{
    // coverage: 0x210-0x296 method sub_10010
    ax = 0x13a5;
    ds = ax;
    bx = 0x9670;
    bx += 0x000f;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    ax += bx;
    memoryASet16(ds, 0x94e8, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94ea, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94ec, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94ee, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f0, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f2, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f4, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f6, ax);
    interrupt(0x12);
    if (ax >= 0x0200)
        goto loc_10067;
    dx = 0x0007;
    ah = 0x09;
    interrupt(0x21);
    ax = 0x4c00;
    interrupt(0x21);
    goto loc_1006e;
loc_10067:
    dx = 0x002a;
    ah = 0x09;
    interrupt(0x21);
loc_1006e:
    sub_10600();
    sub_1333c();
    sub_12762();
    sub_105ec();
    sub_10442();
    sub_10588();
    sub_10591();
    sub_1382a();
    memoryASet(ds, 0x9501, 0x00);
loc_1008b:
    sub_100a9();
    sub_100cf();
    sub_100fd();
    goto loc_1008b;
}
/* Assembly listing of 1000:00a9 sub_100a9()
                sub_100a9 PROC
1000:00a9	call	0x103
1000:00ac	mov	byte ptr [0x9500], 0
1000:00b1	mov	byte ptr [0x94fe], 1
1000:00b6	mov	byte ptr [0x94fc], 0x10
1000:00bb	mov	byte ptr [0x94ff], 0
1000:00c0	mov	byte ptr [0x9502], 0
1000:00c5	call	0xda7
1000:00c8	call	0x3423
1000:00cb	call	0x21dc
1000:00ce	ret	
                sub_100a9 ENDP
*/
void sub_100a9()
{
    // coverage: 0x2a9-0x2cf method sub_100a9
    sub_10103();
    memoryASet(ds, 0x9500, 0x00);
    memoryASet(ds, 0x94fe, 0x01);
    memoryASet(ds, 0x94fc, 0x10);
    memoryASet(ds, 0x94ff, 0x00);
    memoryASet(ds, 0x9502, 0x00);
    sub_10da7();
    sub_13423();
    sub_121dc();
}
/* Assembly listing of 1000:00cf sub_100cf()
                sub_100cf PROC
        	loc_100cf:
1000:00cf	call	0x1c0
1000:00d2	call	0xfda
1000:00d5	mov	al, byte ptr [0x94ff]
1000:00d8	cmp	al, 0
1000:00da	jne	loc_100e4
1000:00dc	call	0x32fe
1000:00df	call	0xb8e
1000:00e2	jmp	loc_100ed
        	loc_100e4:
1000:00e4	call	0x34a8
1000:00e7	call	0x31a4
1000:00ea	call	0xb8e
        	loc_100ed:
1000:00ed	call	0x220d
1000:00f0	call	0x3383
1000:00f3	mov	al, byte ptr [0x9500]
1000:00f6	cmp	al, 0
1000:00f8	jne	loc_100fc
1000:00fa	jmp	loc_100cf
        	loc_100fc:
1000:00fc	ret	
                sub_100cf ENDP
*/
void sub_100cf()
{
    // coverage: 0x2cf-0x2fd method sub_100cf
loc_100cf:
    sub_101c0();
    sub_10fda();
    al = memoryAGet(ds, 0x94ff);
    if (al != 0x00)
        goto loc_100e4;
    sub_132fe();
    sub_10b8e();
    goto loc_100ed;
loc_100e4:
    sub_134a8();
    sub_131a4();
    sub_10b8e();
loc_100ed:
    sub_1220d();
    sub_13383();
    al = memoryAGet(ds, 0x9500);
    if (al != 0x00)
        return;
    goto loc_100cf;
}
/* Assembly listing of 1000:00fd sub_100fd()
                sub_100fd PROC
1000:00fd	mov	byte ptr [6], 1
1000:0102	ret	
                sub_100fd ENDP
*/
void sub_100fd()
{
    // coverage: 0x2fd-0x303 method sub_100fd
    memoryASet(ds, 0x0006, 0x01);
}
/* Assembly listing of 1000:0103 sub_10103()
                sub_10103 PROC
1000:0103	mov	al, byte ptr [6]
1000:0106	cmp	al, 0
1000:0108	je	loc_10115
1000:010a	mov	word ptr [0x8e7e], 0xda
1000:0110	call	0x279f
1000:0113	jmp	loc_1011e
        	loc_10115:
1000:0115	mov	word ptr [0x8e7e], 0xe9
1000:011b	call	0x28da
        	loc_1011e:
1000:011e	call	0x39b8
1000:0121	call	0x3472
1000:0124	mov	byte ptr [0x9503], 1
1000:0129	mov	word ptr [0x8e80], 0
1000:012f	call	0xd98
        	loc_10132:
1000:0132	call	0x1c0
1000:0135	call	0xfda
1000:0138	call	0x3498
1000:013b	call	0xb8e
1000:013e	call	0x3383
1000:0141	mov	ax, word ptr [0x954c]
1000:0144	test	ax, 0x80
1000:0147	jne	loc_10197
1000:0149	inc	word ptr [0x8e80]
1000:014d	mov	bx, word ptr [0x8e80]
1000:0151	test	bx, 7
1000:0155	jne	loc_10195
1000:0157	shr	bx, 1
1000:0159	shr	bx, 1
1000:015b	shr	bx, 1
1000:015d	add	bx, word ptr [0x8e7e]
1000:0161	mov	al, byte ptr [bx]
1000:0163	cmp	al, 0
1000:0165	je	loc_10195
1000:0167	cmp	al, 0xff
1000:0169	je	loc_10197
1000:016b	cmp	al, 0xfe
1000:016d	jne	loc_10180
1000:016f	mov	al, byte ptr [0x9546]
1000:0172	cmp	al, 0
1000:0174	je	loc_1017b
1000:0176	call	0x29db
1000:0179	jmp	loc_1017e
        	loc_1017b:
1000:017b	call	0x1ad
        	loc_1017e:
1000:017e	jmp	loc_10195
        	loc_10180:
1000:0180	test	al, 0x80
1000:0182	jne	loc_10189
1000:0184	call	0x19d
1000:0187	jmp	loc_10195
        	loc_10189:
1000:0189	and	al, 0x3f
1000:018b	push	ax
1000:018c	call	0x19d
1000:018f	pop	ax
1000:0190	inc	al
1000:0192	call	0x19d
        	loc_10195:
1000:0195	jmp	loc_10132
        	loc_10197:
1000:0197	mov	byte ptr [0x9503], 0
1000:019c	ret	
                sub_10103 ENDP
*/
void sub_10103()
{
    // coverage: 0x303-0x39d method sub_10103
    al = memoryAGet(ds, 0x0006);
    if (al == 0x00)
        goto loc_10115;
    memoryASet16(ds, 0x8e7e, 0x00da);
    sub_1279f();
    goto loc_1011e;
loc_10115:
    memoryASet16(ds, 0x8e7e, 0x00e9);
    sub_128da();
loc_1011e:
    sub_139b8();
    sub_13472();
    memoryASet(ds, 0x9503, 0x01);
    memoryASet16(ds, 0x8e80, 0x0000);
    sub_10d98();
loc_10132:
    sub_101c0();
    sub_10fda();
    sub_13498();
    sub_10b8e();
    sub_13383();
    ax = memoryAGet16(ds, 0x954c);
    if (ax & 0x0080)
        goto loc_10197;
    memoryASet16(ds, 0x8e80, memoryAGet16(ds, 0x8e80) + 1);
    bx = memoryAGet16(ds, 0x8e80);
    if (bx & 0x0007)
        goto loc_10195;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx += memoryAGet16(ds, 0x8e7e);
    al = memoryAGet(ds, bx);
    if (al == 0x00)
        goto loc_10195;
    if (al == 0xff)
        goto loc_10197;
    if (al != 0xfe)
        goto loc_10180;
    al = memoryAGet(ds, 0x9546);
    if (al == 0x00)
        goto loc_1017b;
    sub_129db();
    goto loc_1017e;
loc_1017b:
    sub_101ad();
loc_1017e:
    goto loc_10195;
loc_10180:
    if (al & 0x80)
        goto loc_10189;
    sub_1019d();
    goto loc_10195;
loc_10189:
    al &= 0x3f;
    push(ax);
    sub_1019d();
    ax = pop();
    al++;
    sub_1019d();
loc_10195:
    goto loc_10132;
loc_10197:
    memoryASet(ds, 0x9503, 0x00);
}
/* Assembly listing of 1000:019d sub_1019d()
                sub_1019d PROC
1000:019d	mov	si, 0x109
1000:01a0	mov	byte ptr [si + 4], al
1000:01a3	mov	bx, 0x120
1000:01a6	call	0x2121
1000:01a9	call	0xb58
1000:01ac	ret	
                sub_1019d ENDP
*/
void sub_1019d()
{
    // coverage: 0x39d-0x3ad method sub_1019d
    si = 0x0109;
    memoryASet(ds, si + 4, al);
    bx = 0x0120;
    sub_12121();
    sub_10b58();
}
/* Assembly listing of 1000:01ad sub_101ad()
                sub_101ad PROC
1000:01ad	mov	cx, 0x1f40
        	loc_101b0:
1000:01b0	push	cx
1000:01b1	call	0x1c0
1000:01b4	pop	cx
1000:01b5	mov	ax, word ptr [0x954c]
1000:01b8	test	al, 0x80
1000:01ba	je	loc_101bd
1000:01bc	ret	
        	loc_101bd:
1000:01bd	loop	loc_101b0
1000:01bf	ret	
                sub_101ad ENDP
*/
void sub_101ad()
{
    // coverage: 0x3ad-0x3c0 method sub_101ad
    cx = 0x1f40;
loc_101b0:
    push(cx);
    sub_101c0();
    cx = pop();
    ax = memoryAGet16(ds, 0x954c);
    if (!(al & 0x80))
        goto loc_101bd;
    return;
loc_101bd:
    if (--cx)
        goto loc_101b0;
}
/* Assembly listing of 1000:01c0 sub_101c0()
                sub_101c0 PROC
1000:01c0		
        	loc_10096:
1000:0096	call	0x39a3
1000:0099	call	0x5bc
1000:009c	call	0x4a5
1000:009f	mov	ax, 3
1000:00a2	int	0x10
1000:00a4	mov	ax, 0x4c00
1000:00a7	int	0x21
1000:00a9	call	0x103
1000:00ac	mov	byte ptr [0x9500], 0
1000:00b1	mov	byte ptr [0x94fe], 1
1000:00b6	mov	byte ptr [0x94fc], 0x10
1000:00bb	mov	byte ptr [0x94ff], 0
1000:00c0	mov	byte ptr [0x9502], 0
1000:00c5	call	0xda7
1000:00c8	call	0x3423
1000:00cb	call	0x21dc
1000:00ce	ret	
1000:00cf		
        	loc_101c0:
1000:01c0	mov	bx, 0x8e8a
1000:01c3	mov	si, 0x3d
1000:01c6	mov	al, byte ptr [bx + si]
1000:01c8	cmp	al, 0
1000:01ca	je	loc_101d5
1000:01cc	mov	si, 0x3e
        	loc_101cf:
1000:01cf	mov	al, byte ptr [bx + si]
1000:01d1	cmp	al, 0
1000:01d3	je	loc_101cf
        	loc_101d5:
1000:01d5	mov	si, 0x3b
1000:01d8	mov	al, byte ptr [bx + si]
1000:01da	cmp	al, 0
1000:01dc	je	loc_101e1
1000:01de	call	0x33b
        	loc_101e1:
1000:01e1	mov	bx, 0x8e8a
1000:01e4	mov	si, word ptr [0x8f0d]
1000:01e8	mov	al, byte ptr [bx + si]
1000:01ea	cmp	al, 0
1000:01ec	je	loc_101f6
1000:01ee	mov	word ptr [0x954c], 1
1000:01f4	jmp	loc_1020e
        	loc_101f6:
1000:01f6	mov	si, word ptr [0x8f0f]
1000:01fa	mov	al, byte ptr [bx + si]
1000:01fc	cmp	al, 0
1000:01fe	je	loc_10208
1000:0200	mov	word ptr [0x954c], 2
1000:0206	jmp	loc_1020e
        	loc_10208:
1000:0208	mov	word ptr [0x954c], 0
        	loc_1020e:
1000:020e	mov	si, word ptr [0x8f11]
1000:0212	mov	al, byte ptr [bx + si]
1000:0214	cmp	al, 0
1000:0216	je	loc_1021f
1000:0218	or	word ptr [0x954c], 4
1000:021d	jmp	loc_1022e
        	loc_1021f:
1000:021f	mov	si, word ptr [0x8f13]
1000:0223	mov	al, byte ptr [bx + si]
1000:0225	cmp	al, 0
1000:0227	je	loc_1022e
1000:0229	or	word ptr [0x954c], 8
        	loc_1022e:
1000:022e	mov	si, word ptr [0x8f15]
1000:0232	mov	al, byte ptr [bx + si]
1000:0234	cmp	al, 0
1000:0236	je	loc_1023e
1000:0238	or	word ptr [0x954c], 0x80
        	loc_1023e:
1000:023e	mov	si, word ptr [0x8f17]
1000:0242	mov	al, byte ptr [bx + si]
1000:0244	cmp	al, 0
1000:0246	je	loc_1024d
1000:0248	or	word ptr [0x954c], 0x40
        	loc_1024d:
1000:024d	mov	si, word ptr [0x8f19]
1000:0251	mov	al, byte ptr [bx + si]
1000:0253	cmp	al, 0
1000:0255	je	loc_1025c
1000:0257	or	word ptr [0x954c], 0x20
        	loc_1025c:
1000:025c	mov	si, word ptr [0x8f1b]
1000:0260	mov	al, byte ptr [bx + si]
1000:0262	cmp	al, 0
1000:0264	je	loc_1028c
1000:0266	call	0x2c45
1000:0269	mov	bx, 0x8e8a
        	loc_1026c:
1000:026c	mov	al, byte ptr [bx + 0x15]
1000:026f	cmp	al, 0
1000:0271	jne	loc_1027c
1000:0273	mov	al, byte ptr [bx + 0x31]
1000:0276	cmp	al, 0
1000:0278	jne	loc_1027c
1000:027a	jmp	loc_1026c
        	loc_1027c:
1000:027c	mov	bx, 0x8e8a
1000:027f	mov	al, byte ptr [bx + 0x15]
1000:0282	cmp	al, 0
1000:0284	je	loc_10289
1000:0286	jmp	loc_10096
        	loc_10289:
1000:0289	call	0x529
        	loc_1028c:
1000:028c	mov	bx, 0x8e8a
1000:028f	mov	si, 0x3c
1000:0292	mov	al, byte ptr [bx + si]
1000:0294	cmp	al, 0
1000:0296	je	loc_102c5
1000:0298	mov	al, byte ptr [0x9505]
1000:029b	cmp	al, 0
1000:029d	jne	loc_102b0
1000:029f	mov	al, 0xe
1000:02a1	call	0x3840
1000:02a4	mov	byte ptr [0x9505], 1
1000:02a9	mov	byte ptr [0x9506], 0
1000:02ae	jmp	loc_102c3
        	loc_102b0:
1000:02b0	cmp	al, 2
1000:02b2	jne	loc_102c3
1000:02b4	mov	byte ptr [0x9505], 3
1000:02b9	mov	byte ptr [0x9506], 1
1000:02be	mov	al, 0xd
1000:02c0	call	0x3840
        	loc_102c3:
1000:02c3	jmp	loc_102dc
        	loc_102c5:
1000:02c5	mov	al, byte ptr [0x9505]
1000:02c8	cmp	al, 1
1000:02ca	jne	loc_102d3
1000:02cc	mov	byte ptr [0x9505], 2
1000:02d1	jmp	loc_102dc
        	loc_102d3:
1000:02d3	cmp	al, 3
1000:02d5	jne	loc_102dc
1000:02d7	mov	byte ptr [0x9505], 0
        	loc_102dc:
1000:02dc	mov	al, byte ptr [0x8f0a]
1000:02df	cmp	al, 0
1000:02e1	jne	loc_102e4
1000:02e3	ret	
        	loc_102e4:
1000:02e4	mov	ax, 3
1000:02e7	int	0x33
1000:02e9	test	bx, 1
1000:02ed	je	loc_102f5
1000:02ef	or	word ptr [0x954c], 0x80
        	loc_102f5:
1000:02f5	test	bx, 2
1000:02f9	je	loc_10300
1000:02fb	or	word ptr [0x954c], 0x20
        	loc_10300:
1000:0300	mov	ax, word ptr [0x954c]
1000:0303	and	ax, 0xf
1000:0306	je	loc_10309
1000:0308	ret	
        	loc_10309:
1000:0309	mov	ax, 0xb
1000:030c	int	0x33
1000:030e	cmp	cx, -5
1000:0311	jge	loc_1031a
1000:0313	or	word ptr [0x954c], 1
1000:0318	jmp	loc_10324
        	loc_1031a:
1000:031a	cmp	cx, 5
1000:031d	jle	loc_10324
1000:031f	or	word ptr [0x954c], 2
        	loc_10324:
1000:0324	cmp	dx, -0xa
1000:0327	jge	loc_10330
1000:0329	or	word ptr [0x954c], 4
1000:032e	jmp	loc_1033a
        	loc_10330:
1000:0330	cmp	dx, 0xa
1000:0333	jle	loc_1033a
1000:0335	or	word ptr [0x954c], 8
        	loc_1033a:
1000:033a	ret	
                sub_101c0 ENDP
*/
void sub_101c0()
{
    // coverage: 0x296-0x2cf method sub_101c0
    // coverage: 0x3c0-0x53b method sub_101c0
    goto loc_101c0;
loc_10096:
    sub_139a3();
    sub_105bc();
    sub_104a5();
    ax = 0x0003;
    interrupt(0x10);
    ax = 0x4c00;
    interrupt(0x21);
    sub_10103();
    memoryASet(ds, 0x9500, 0x00);
    memoryASet(ds, 0x94fe, 0x01);
    memoryASet(ds, 0x94fc, 0x10);
    memoryASet(ds, 0x94ff, 0x00);
    memoryASet(ds, 0x9502, 0x00);
    sub_10da7();
    sub_13423();
    sub_121dc();
    return;
    //   gap of 241 bytes
loc_101c0:
    bx = 0x8e8a;
    si = 0x003d;
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101d5;
    si = 0x003e;
loc_101cf:
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101cf;
loc_101d5:
    si = 0x003b;
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101e1;
    sub_1033b();
loc_101e1:
    bx = 0x8e8a;
    si = memoryAGet16(ds, 0x8f0d);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101f6;
    memoryASet16(ds, 0x954c, 0x0001);
    goto loc_1020e;
loc_101f6:
    si = memoryAGet16(ds, 0x8f0f);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_10208;
    memoryASet16(ds, 0x954c, 0x0002);
    goto loc_1020e;
loc_10208:
    memoryASet16(ds, 0x954c, 0x0000);
loc_1020e:
    si = memoryAGet16(ds, 0x8f11);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1021f;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0004);
    goto loc_1022e;
loc_1021f:
    si = memoryAGet16(ds, 0x8f13);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1022e;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0008);
loc_1022e:
    si = memoryAGet16(ds, 0x8f15);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1023e;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0080);
loc_1023e:
    si = memoryAGet16(ds, 0x8f17);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1024d;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0040);
loc_1024d:
    si = memoryAGet16(ds, 0x8f19);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1025c;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0020);
loc_1025c:
    si = memoryAGet16(ds, 0x8f1b);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1028c;
    sub_12c45();
    bx = 0x8e8a;
loc_1026c:
    al = memoryAGet(ds, bx + 21);
    if (al != 0x00)
        goto loc_1027c;
    al = memoryAGet(ds, bx + 49);
    if (al != 0x00)
        goto loc_1027c;
    goto loc_1026c;
loc_1027c:
    bx = 0x8e8a;
    al = memoryAGet(ds, bx + 21);
    if (al == 0x00)
        goto loc_10289;
    goto loc_10096;
loc_10289:
    sub_10529();
loc_1028c:
    bx = 0x8e8a;
    si = 0x003c;
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_102c5;
    al = memoryAGet(ds, 0x9505);
    if (al != 0x00)
        goto loc_102b0;
    al = 0x0e;
    sub_13840();
    memoryASet(ds, 0x9505, 0x01);
    memoryASet(ds, 0x9506, 0x00);
    goto loc_102c3;
loc_102b0:
    if (al != 0x02)
        goto loc_102c3;
    memoryASet(ds, 0x9505, 0x03);
    memoryASet(ds, 0x9506, 0x01);
    al = 0x0d;
    sub_13840();
loc_102c3:
    goto loc_102dc;
loc_102c5:
    al = memoryAGet(ds, 0x9505);
    if (al != 0x01)
        goto loc_102d3;
    memoryASet(ds, 0x9505, 0x02);
    goto loc_102dc;
loc_102d3:
    if (al != 0x03)
        goto loc_102dc;
    memoryASet(ds, 0x9505, 0x00);
loc_102dc:
    al = memoryAGet(ds, 0x8f0a);
    if (al != 0x00)
        goto loc_102e4;
    return;
loc_102e4:
    ax = 0x0003;
    interrupt(0x33);
    if (!(bx & 0x0001))
        goto loc_102f5;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0080);
loc_102f5:
    if (!(bx & 0x0002))
        goto loc_10300;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0020);
loc_10300:
    ax = memoryAGet16(ds, 0x954c);
    ax &= 0x000f;
    if (ax == 0)
        goto loc_10309;
    return;
loc_10309:
    ax = 0x000b;
    interrupt(0x33);
    if ((short)cx >= (short)0xfffb)
        goto loc_1031a;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0001);
    goto loc_10324;
loc_1031a:
    if ((short)cx <= (short)0x0005)
        goto loc_10324;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0002);
loc_10324:
    if ((short)dx >= (short)0xfff6)
        goto loc_10330;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0004);
    return;
loc_10330:
    if ((short)dx <= (short)0x000a)
        return;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0008);
}
/* Assembly listing of 1000:033b sub_1033b()
                sub_1033b PROC
1000:033b	call	0x2c07
1000:033e	mov	al, 4
1000:0340	call	0x2c9a
1000:0343	call	0x4f3
1000:0346	mov	word ptr [0x8f15], ax
1000:0349	mov	al, 0
1000:034b	call	0x2c9a
        	loc_1034e:
1000:034e	call	0x4f3
1000:0351	cmp	ax, word ptr [0x8f15]
1000:0355	je	loc_1034e
1000:0357	mov	word ptr [0x8f0d], ax
1000:035a	mov	al, 1
1000:035c	call	0x2c9a
        	loc_1035f:
1000:035f	call	0x4f3
1000:0362	cmp	ax, word ptr [0x8f15]
1000:0366	je	loc_1035f
1000:0368	cmp	ax, word ptr [0x8f0d]
1000:036c	je	loc_1035f
1000:036e	mov	word ptr [0x8f0f], ax
1000:0371	mov	al, 2
1000:0373	call	0x2c9a
        	loc_10376:
1000:0376	call	0x4f3
1000:0379	cmp	ax, word ptr [0x8f15]
1000:037d	je	loc_10376
1000:037f	cmp	ax, word ptr [0x8f0d]
1000:0383	je	loc_10376
1000:0385	cmp	ax, word ptr [0x8f0f]
1000:0389	je	loc_10376
1000:038b	mov	word ptr [0x8f11], ax
1000:038e	mov	al, 3
1000:0390	call	0x2c9a
        	loc_10393:
1000:0393	call	0x4f3
1000:0396	cmp	ax, word ptr [0x8f15]
1000:039a	je	loc_10393
1000:039c	cmp	ax, word ptr [0x8f0d]
1000:03a0	je	loc_10393
1000:03a2	cmp	ax, word ptr [0x8f0f]
1000:03a6	je	loc_10393
1000:03a8	cmp	ax, word ptr [0x8f11]
1000:03ac	je	loc_10393
1000:03ae	mov	word ptr [0x8f13], ax
1000:03b1	mov	al, 6
1000:03b3	call	0x2c9a
        	loc_103b6:
1000:03b6	call	0x4f3
1000:03b9	cmp	ax, word ptr [0x8f15]
1000:03bd	je	loc_103b6
1000:03bf	cmp	ax, word ptr [0x8f0d]
1000:03c3	je	loc_103b6
1000:03c5	cmp	ax, word ptr [0x8f0f]
1000:03c9	je	loc_103b6
1000:03cb	cmp	ax, word ptr [0x8f11]
1000:03cf	je	loc_103b6
1000:03d1	cmp	ax, word ptr [0x8f13]
1000:03d5	je	loc_103b6
1000:03d7	mov	word ptr [0x8f17], ax
1000:03da	mov	al, 7
1000:03dc	call	0x2c9a
        	loc_103df:
1000:03df	call	0x4f3
1000:03e2	cmp	ax, word ptr [0x8f15]
1000:03e6	je	loc_103df
1000:03e8	cmp	ax, word ptr [0x8f0d]
1000:03ec	je	loc_103df
1000:03ee	cmp	ax, word ptr [0x8f0f]
1000:03f2	je	loc_103df
1000:03f4	cmp	ax, word ptr [0x8f11]
1000:03f8	je	loc_103df
1000:03fa	cmp	ax, word ptr [0x8f13]
1000:03fe	je	loc_103df
1000:0400	cmp	ax, word ptr [0x8f17]
1000:0404	je	loc_103df
1000:0406	mov	word ptr [0x8f19], ax
1000:0409	mov	al, 5
1000:040b	call	0x2c9a
        	loc_1040e:
1000:040e	call	0x4f3
1000:0411	cmp	ax, word ptr [0x8f15]
1000:0415	je	loc_1040e
1000:0417	cmp	ax, word ptr [0x8f0d]
1000:041b	je	loc_1040e
1000:041d	cmp	ax, word ptr [0x8f0f]
1000:0421	je	loc_1040e
1000:0423	cmp	ax, word ptr [0x8f11]
1000:0427	je	loc_1040e
1000:0429	cmp	ax, word ptr [0x8f13]
1000:042d	je	loc_1040e
1000:042f	cmp	ax, word ptr [0x8f17]
1000:0433	je	loc_1040e
1000:0435	cmp	ax, word ptr [0x8f19]
1000:0439	je	loc_1040e
1000:043b	mov	word ptr [0x8f1b], ax
1000:043e	call	0x529
1000:0441	ret	
                sub_1033b ENDP
*/
void sub_1033b()
{
    // coverage: 0x53b-0x642 method sub_1033b
    sub_12c07();
    al = 0x04;
    sub_12c9a();
    sub_104f3();
    memoryASet16(ds, 0x8f15, ax);
    al = 0x00;
    sub_12c9a();
loc_1034e:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_1034e;
    memoryASet16(ds, 0x8f0d, ax);
    al = 0x01;
    sub_12c9a();
loc_1035f:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_1035f;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_1035f;
    memoryASet16(ds, 0x8f0f, ax);
    al = 0x02;
    sub_12c9a();
loc_10376:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_10376;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_10376;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_10376;
    memoryASet16(ds, 0x8f11, ax);
    al = 0x03;
    sub_12c9a();
loc_10393:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_10393;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_10393;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_10393;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_10393;
    memoryASet16(ds, 0x8f13, ax);
    al = 0x06;
    sub_12c9a();
loc_103b6:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f13))
        goto loc_103b6;
    memoryASet16(ds, 0x8f17, ax);
    al = 0x07;
    sub_12c9a();
loc_103df:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f13))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f17))
        goto loc_103df;
    memoryASet16(ds, 0x8f19, ax);
    al = 0x05;
    sub_12c9a();
loc_1040e:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f13))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f17))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f19))
        goto loc_1040e;
    memoryASet16(ds, 0x8f1b, ax);
    sub_10529();
}
/* Assembly listing of 1000:0442 sub_10442()
                sub_10442 PROC
1000:0442	mov	word ptr [0x8f0b], 0
1000:0448	mov	word ptr [0x8f0d], 0x4b
1000:044e	mov	word ptr [0x8f0f], 0x4d
1000:0454	mov	word ptr [0x8f11], 0x48
1000:045a	mov	word ptr [0x8f13], 0x50
1000:0460	mov	word ptr [0x8f15], 0x39
1000:0466	mov	word ptr [0x8f17], 0x31
1000:046c	mov	word ptr [0x8f19], 0x32
1000:0472	mov	word ptr [0x8f1b], 0x10
1000:0478	mov	ax, ds
1000:047a	mov	es, ax
1000:047c	mov	ax, 0
1000:047f	mov	cx, 0x40
1000:0482	mov	di, 0x8e8a
1000:0485	rep stosw	word ptr es:[di], ax
1000:0487	mov	al, 9
1000:0489	mov	ah, 0x35
1000:048b	int	0x21
1000:048d	mov	word ptr [0x8e84], bx
1000:0491	mov	word ptr [0x8e82], es
1000:0495	push	ds
1000:0496	mov	dx, 0x4b7
1000:0499	mov	ax, cs
1000:049b	mov	ds, ax
1000:049d	mov	al, 9
1000:049f	mov	ah, 0x25
1000:04a1	int	0x21
1000:04a3	pop	ds
1000:04a4	ret	
                sub_10442 ENDP
*/
void sub_10442()
{
    // coverage: 0x642-0x6a5 method sub_10442
    memoryASet16(ds, 0x8f0b, 0x0000);
    memoryASet16(ds, 0x8f0d, 0x004b);
    memoryASet16(ds, 0x8f0f, 0x004d);
    memoryASet16(ds, 0x8f11, 0x0048);
    memoryASet16(ds, 0x8f13, 0x0050);
    memoryASet16(ds, 0x8f15, 0x0039);
    memoryASet16(ds, 0x8f17, 0x0031);
    memoryASet16(ds, 0x8f19, 0x0032);
    memoryASet16(ds, 0x8f1b, 0x0010);
    ax = ds;
    es = ax;
    ax = 0x0000;
    cx = 0x0040;
    di = 0x8e8a;
    rep_stosw<MemAuto, DirAuto>();
    al = 0x09;
    ah = 0x35;
    interrupt(0x21);
    memoryASet16(ds, 0x8e84, bx);
    memoryASet16(ds, 0x8e82, es);
    push(ds);
    dx = 0x04b7;
    ax = cs;
    ds = ax;
    al = 0x09;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:04a5 sub_104a5()
                sub_104a5 PROC
1000:04a5	mov	dx, word ptr [0x8e84]
1000:04a9	mov	ax, word ptr [0x8e82]
1000:04ac	push	ds
1000:04ad	mov	ds, ax
1000:04af	mov	al, 9
1000:04b1	mov	ah, 0x25
1000:04b3	int	0x21
1000:04b5	pop	ds
1000:04b6	ret	
                sub_104a5 ENDP
*/
void sub_104a5()
{
    // coverage: 0x6a5-0x6b7 method sub_104a5
    dx = memoryAGet16(ds, 0x8e84);
    ax = memoryAGet16(ds, 0x8e82);
    push(ds);
    ds = ax;
    al = 0x09;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:04f3 sub_104f3()
                sub_104f3 PROC
1000:04f3	cld	
        	loc_104f4:
1000:04f4	mov	si, 0x8e8a
        	loc_104f7:
1000:04f7	lodsb	al, byte ptr [si]
1000:04f8	cmp	al, 0
1000:04fa	je	loc_10520
1000:04fc	mov	ax, si
1000:04fe	sub	ax, 0x8e8b
1000:0501	cmp	ax, 0x3b
1000:0504	je	loc_10520
1000:0506	cmp	ax, 0x3c
1000:0509	je	loc_10520
1000:050b	cmp	ax, 0x3d
1000:050e	je	loc_10520
1000:0510	cmp	ax, 0x3e
1000:0513	je	loc_10520
1000:0515	cmp	ax, 0x2a
1000:0518	je	loc_10520
1000:051a	cmp	ax, 0x36
1000:051d	je	loc_10520
1000:051f	ret	
        	loc_10520:
1000:0520	cmp	si, 0x8f0a
1000:0524	jne	loc_104f7
1000:0526	jmp	loc_104f4
                sub_104f3 ENDP
*/
void sub_104f3()
{
    // coverage: 0x6f3-0x728 method sub_104f3
    flags.direction = false;
loc_104f4:
    si = 0x8e8a;
loc_104f7:
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_10520;
    ax = si;
    ax -= 0x8e8b;
    if (ax == 0x003b)
        goto loc_10520;
    if (ax == 0x003c)
        goto loc_10520;
    if (ax == 0x003d)
        goto loc_10520;
    if (ax == 0x003e)
        goto loc_10520;
    if (ax == 0x002a)
        goto loc_10520;
    if (ax == 0x0036)
        goto loc_10520;
    return;
loc_10520:
    if (si != 0x8f0a)
        goto loc_104f7;
    goto loc_104f4;
}
/* Assembly listing of 1000:0529 sub_10529()
                sub_10529 PROC
        	loc_10529:
1000:0529	mov	si, 0x8e8a
1000:052c	mov	ah, 0
        	loc_1052e:
1000:052e	lodsb	al, byte ptr [si]
1000:052f	cmp	al, 0
1000:0531	je	loc_10535
1000:0533	inc	ah
        	loc_10535:
1000:0535	cmp	si, 0x8f0a
1000:0539	jne	loc_1052e
1000:053b	cmp	ah, 0
1000:053e	jne	loc_10529
1000:0540	ret	
                sub_10529 ENDP
*/
void sub_10529()
{
    // coverage: 0x729-0x741 method sub_10529
loc_10529:
    si = 0x8e8a;
    ah = 0x00;
loc_1052e:
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_10535;
    ah++;
loc_10535:
    if (si != 0x8f0a)
        goto loc_1052e;
    if (ah != 0x00)
        goto loc_10529;
}
/* Assembly listing of 1000:0541 sub_10541()
                sub_10541 PROC
1000:0541	mov	cx, 0x4e20
        	loc_10544:
1000:0544	mov	si, 0x8e8a
1000:0547	mov	ah, 0
1000:0549	cld	
        	loc_1054a:
1000:054a	lodsb	al, byte ptr [si]
1000:054b	cmp	al, 0
1000:054d	je	loc_10557
1000:054f	mov	ah, 1
1000:0551	cmp	si, word ptr [0x8f0b]
1000:0555	jne	loc_1055f
        	loc_10557:
1000:0557	cmp	si, 0x8f0a
1000:055b	je	loc_1055f
1000:055d	jmp	loc_1054a
        	loc_1055f:
1000:055f	je	loc_10578
1000:0561	mov	word ptr [0x8f0b], si
1000:0565	sub	si, 0x8e8b
1000:0569	mov	al, byte ptr [si + 0x5a]
1000:056d	cmp	al, 0
1000:056f	je	loc_10576
1000:0571	jns	loc_10575
1000:0573	mov	al, 0
        	loc_10575:
1000:0575	ret	
        	loc_10576:
1000:0576	jmp	loc_10583
        	loc_10578:
1000:0578	cmp	ah, 0
1000:057b	jne	loc_10583
1000:057d	mov	word ptr [0x8f0b], 0
        	loc_10583:
1000:0583	loop	loc_10544
1000:0585	mov	al, 0
1000:0587	ret	
                sub_10541 ENDP
*/
void sub_10541()
{
    // coverage: 0x741-0x788 method sub_10541
    cx = 0x4e20;
loc_10544:
    si = 0x8e8a;
    ah = 0x00;
    flags.direction = false;
loc_1054a:
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_10557;
    ah = 0x01;
    flags.zero = si == memoryAGet16(ds, 0x8f0b);
    if (si != memoryAGet16(ds, 0x8f0b))
        goto loc_1055f;
loc_10557:
    flags.zero = si == 0x8f0a;
    if (si == 0x8f0a)
        goto loc_1055f;
    goto loc_1054a;
loc_1055f:
    if (flags.zero)
        goto loc_10578;
    memoryASet16(ds, 0x8f0b, si);
    si -= 0x8e8b;
    al = memoryAGet(ds, si + 90);
    if (al == 0x00)
        goto loc_10576;
    if ((char)al >= 0)
        goto loc_10575;
    al = 0x00;
loc_10575:
    return;
loc_10576:
    goto loc_10583;
loc_10578:
    if (ah != 0x00)
        goto loc_10583;
    memoryASet16(ds, 0x8f0b, 0x0000);
loc_10583:
    if (--cx)
        goto loc_10544;
    al = 0x00;
}
/* Assembly listing of 1000:0588 sub_10588()
                sub_10588 PROC
1000:0588	mov	ax, 0
1000:058b	int	0x33
1000:058d	mov	byte ptr [0x8f0a], al
1000:0590	ret	
                sub_10588 ENDP
*/
void sub_10588()
{
    // coverage: 0x788-0x791 method sub_10588
    ax = 0x0000;
    interrupt(0x33);
    memoryASet(ds, 0x8f0a, al);
}
/* Assembly listing of 1000:0591 sub_10591()
                sub_10591 PROC
1000:0591	mov	al, 0x1c
1000:0593	mov	ah, 0x35
1000:0595	int	0x21
1000:0597	mov	word ptr [0x8e88], bx
1000:059b	mov	word ptr [0x8e86], es
1000:059f	push	ds
1000:05a0	mov	dx, 0x5ce
1000:05a3	mov	ax, cs
1000:05a5	mov	ds, ax
1000:05a7	mov	al, 0x1c
1000:05a9	mov	ah, 0x25
1000:05ab	int	0x21
1000:05ad	pop	ds
1000:05ae	mov	al, 0x36
1000:05b0	out	0x43, al
1000:05b2	mov	ax, 0x4d0e
1000:05b5	out	0x40, al
1000:05b7	mov	al, ah
1000:05b9	out	0x40, al
1000:05bb	ret	
                sub_10591 ENDP
*/
void sub_10591()
{
    // coverage: 0x791-0x7bc method sub_10591
    al = 0x1c;
    ah = 0x35;
    interrupt(0x21);
    memoryASet16(ds, 0x8e88, bx);
    memoryASet16(ds, 0x8e86, es);
    push(ds);
    dx = 0x05ce;
    ax = cs;
    ds = ax;
    al = 0x1c;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
    al = 0x36;
    out(0x43, al);
    ax = 0x4d0e;
    out(0x40, al);
    al = ah;
    out(0x40, al);
}
/* Assembly listing of 1000:05bc sub_105bc()
                sub_105bc PROC
1000:05bc	mov	dx, word ptr [0x8e88]
1000:05c0	mov	ax, word ptr [0x8e86]
1000:05c3	push	ds
1000:05c4	mov	ds, ax
1000:05c6	mov	al, 0x1c
1000:05c8	mov	ah, 0x25
1000:05ca	int	0x21
1000:05cc	pop	ds
1000:05cd	ret	
                sub_105bc ENDP
*/
void sub_105bc()
{
    // coverage: 0x7bc-0x7ce method sub_105bc
    dx = memoryAGet16(ds, 0x8e88);
    ax = memoryAGet16(ds, 0x8e86);
    push(ds);
    ds = ax;
    al = 0x1c;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:05ec sub_105ec()
                sub_105ec PROC
1000:05ec	push	ds
1000:05ed	mov	dx, 0x5fc
1000:05f0	mov	ax, cs
1000:05f2	mov	ds, ax
1000:05f4	mov	al, 0x24
1000:05f6	mov	ah, 0x25
1000:05f8	int	0x21
1000:05fa	pop	ds
1000:05fb	ret	
                sub_105ec ENDP
*/
void sub_105ec()
{
    // coverage: 0x7ec-0x7fc method sub_105ec
    push(ds);
    dx = 0x05fc;
    ax = cs;
    ds = ax;
    al = 0x24;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:0600 sub_10600()
                sub_10600 PROC
1000:0600	mov	dx, 0x1e2
1000:0603	mov	ax, word ptr [0x94e8]
1000:0606	call	0x637
1000:0609	mov	dx, 0x1ea
1000:060c	mov	ax, word ptr [0x94ea]
1000:060f	call	0x637
1000:0612	mov	dx, 0x1f2
1000:0615	mov	ax, word ptr [0x94ec]
1000:0618	call	0x637
1000:061b	mov	dx, 0x1f9
1000:061e	mov	ax, word ptr [0x94ee]
1000:0621	call	0x637
1000:0624	mov	dx, 0x203
1000:0627	mov	ax, word ptr [0x94f0]
1000:062a	call	0x637
1000:062d	mov	dx, 0x20b
1000:0630	mov	ax, word ptr [0x94f2]
1000:0633	call	0x637
1000:0636	ret	
                sub_10600 ENDP
*/
void sub_10600()
{
    // coverage: 0x800-0x837 method sub_10600
    dx = 0x01e2;
    ax = memoryAGet16(ds, 0x94e8);
    sub_10637();
    dx = 0x01ea;
    ax = memoryAGet16(ds, 0x94ea);
    sub_10637();
    dx = 0x01f2;
    ax = memoryAGet16(ds, 0x94ec);
    sub_10637();
    dx = 0x01f9;
    ax = memoryAGet16(ds, 0x94ee);
    sub_10637();
    dx = 0x0203;
    ax = memoryAGet16(ds, 0x94f0);
    sub_10637();
    dx = 0x020b;
    ax = memoryAGet16(ds, 0x94f2);
    sub_10637();
}
/* Assembly listing of 1000:0637 sub_10637()
                sub_10637 PROC
1000:0637	mov	word ptr [0x8f20], ax
1000:063a	mov	di, 0
1000:063d	mov	cx, 0x7d00
1000:0640	call	0x64d
1000:0643	ret	
                sub_10637 ENDP
*/
void sub_10637()
{
    // coverage: 0x837-0x844 method sub_10637
    memoryASet16(ds, 0x8f20, ax);
    di = 0x0000;
    cx = 0x7d00;
    sub_1064d();
}
/* Assembly listing of 1000:0644 sub_10644()
                sub_10644 PROC
1000:0644	mov	ax, ds
1000:0646	mov	word ptr [0x8f20], ax
1000:0649	call	0x64d
1000:064c	ret	
                sub_10644 ENDP
*/
void sub_10644()
{
    // coverage: 0x844-0x84d method sub_10644
    ax = ds;
    memoryASet16(ds, 0x8f20, ax);
    sub_1064d();
}
/* Assembly listing of 1000:064d sub_1064d()
                sub_1064d PROC
1000:064d	push	di
1000:064e	push	cx
1000:064f	mov	ax, 0x3d00
1000:0652	int	0x21
1000:0654	pop	cx
1000:0655	pop	dx
1000:0656	jae	loc_10659
1000:0658	ret	
        	loc_10659:
1000:0659	mov	word ptr [0x8f1e], ax
1000:065c	mov	bx, ax
1000:065e	mov	ax, word ptr [0x8f20]
1000:0661	push	ds
1000:0662	mov	ds, ax
1000:0664	mov	ax, 0x3f00
1000:0667	int	0x21
1000:0669	pop	ds
1000:066a	mov	ax, 0x3e00
1000:066d	mov	bx, word ptr [0x8f1e]
1000:0671	int	0x21
1000:0673	ret	
                sub_1064d ENDP
*/
void sub_1064d()
{
    // coverage: 0x84d-0x874 method sub_1064d
    push(di);
    push(cx);
    ax = 0x3d00;
    interrupt(0x21);
    cx = pop();
    dx = pop();
    if (!flags.carry)
        goto loc_10659;
    return;
loc_10659:
    memoryASet16(ds, 0x8f1e, ax);
    bx = ax;
    ax = memoryAGet16(ds, 0x8f20);
    push(ds);
    ds = ax;
    ax = 0x3f00;
    interrupt(0x21);
    ds = pop();
    ax = 0x3e00;
    bx = memoryAGet16(ds, 0x8f1e);
    interrupt(0x21);
}
/* Assembly listing of 1000:0674 sub_10674()
                sub_10674 PROC
1000:0674	push	di
1000:0675	push	cx
1000:0676	mov	cx, 0
1000:0679	mov	ax, 0x3c00
1000:067c	int	0x21
1000:067e	pop	cx
1000:067f	pop	dx
1000:0680	jae	loc_10683
1000:0682	ret	
        	loc_10683:
1000:0683	mov	word ptr [0x8f1e], ax
1000:0686	mov	bx, ax
1000:0688	mov	ax, 0x4000
1000:068b	int	0x21
1000:068d	jae	loc_10690
1000:068f	ret	
        	loc_10690:
1000:0690	mov	ax, 0x3e00
1000:0693	mov	bx, word ptr [0x8f1e]
1000:0697	int	0x21
1000:0699	ret	
                sub_10674 ENDP
*/
void sub_10674()
{
    // coverage: 0x874-0x89a method sub_10674
    push(di);
    push(cx);
    cx = 0x0000;
    ax = 0x3c00;
    interrupt(0x21);
    cx = pop();
    dx = pop();
    if (!flags.carry)
        goto loc_10683;
    return;
loc_10683:
    memoryASet16(ds, 0x8f1e, ax);
    bx = ax;
    ax = 0x4000;
    interrupt(0x21);
    if (!flags.carry)
        goto loc_10690;
    return;
loc_10690:
    ax = 0x3e00;
    bx = memoryAGet16(ds, 0x8f1e);
    interrupt(0x21);
}
/* Assembly listing of 1000:069a sub_1069a()
                sub_1069a PROC
1000:069a	mov	al, byte ptr [0x9501]
1000:069d	mov	bl, al
1000:069f	shl	bl, 1
1000:06a1	add	bl, al
1000:06a3	add	bl, byte ptr [0x9502]
1000:06a7	mov	bh, 0
1000:06a9	shl	bx, 1
1000:06ab	mov	si, word ptr [bx + 0x244]
1000:06af	mov	di, 0x9229
1000:06b2	mov	cx, 0x40
1000:06b5	mov	ax, ds
1000:06b7	mov	es, ax
1000:06b9	mov	ax, 0
1000:06bc	cld	
1000:06bd	rep stosw	word ptr es:[di], ax
1000:06bf	mov	di, 0x9229
        	loc_106c2:
1000:06c2	lodsb	al, byte ptr [si]
1000:06c3	cmp	al, 0xff
1000:06c5	je	loc_106eb
1000:06c7	shl	al, 1
1000:06c9	shl	al, 1
1000:06cb	mov	ah, al
1000:06cd	lodsb	al, byte ptr [si]
1000:06ce	shl	al, 1
1000:06d0	mov	bl, al
1000:06d2	mov	bh, 0
1000:06d4	mov	al, 0
1000:06d6	or	ax, word ptr [bx + 0xcd7]
1000:06da	mov	cx, ax
1000:06dc	lodsb	al, byte ptr [si]
1000:06dd	neg	al
1000:06df	add	al, 0x3f
1000:06e1	shl	al, 1
1000:06e3	mov	bl, al
1000:06e5	or	word ptr [bx - 0x6dd7], cx
1000:06e9	jmp	loc_106c2
        	loc_106eb:
1000:06eb	mov	al, byte ptr [0x9501]
1000:06ee	mov	bl, al
1000:06f0	shl	bl, 1
1000:06f2	add	bl, al
1000:06f4	add	bl, byte ptr [0x9502]
1000:06f8	mov	bh, 0
1000:06fa	shl	bx, 1
1000:06fc	mov	si, word ptr [bx + 0x214]
1000:0700	mov	di, 0x8f29
1000:0703	mov	cx, 0x300
1000:0706	mov	bl, 0
        	loc_10708:
1000:0708	dec	bl
1000:070a	jns	loc_1072c
1000:070c	lodsb	al, byte ptr [si]
1000:070d	mov	dl, al
1000:070f	and	dl, 0x3f
1000:0712	and	al, 0xc0
1000:0714	jne	loc_1071a
1000:0716	mov	bl, 0
1000:0718	jmp	loc_1072c
        	loc_1071a:
1000:071a	cmp	al, 0x40
1000:071c	jne	loc_10722
1000:071e	mov	bl, 1
1000:0720	jmp	loc_1072c
        	loc_10722:
1000:0722	cmp	al, 0x80
1000:0724	jne	loc_1072a
1000:0726	mov	bl, 2
1000:0728	jmp	loc_1072c
        	loc_1072a:
1000:072a	mov	bl, 3
        	loc_1072c:
1000:072c	mov	byte ptr [di], dl
1000:072e	inc	di
1000:072f	loop	loc_10708
1000:0731	mov	di, 0
1000:0734	mov	ax, 0xa800
1000:0737	mov	es, ax
1000:0739	mov	dx, 0x3ce
1000:073c	mov	ah, 0
1000:073e	mov	al, 0
1000:0740	out	dx, ax
1000:0741	mov	ax, 0xf01
1000:0744	out	dx, ax
1000:0745	mov	cx, 0x4000
1000:0748	rep stosw	word ptr es:[di], ax
1000:074a	mov	ax, 0x8f29
1000:074d	mov	word ptr [0x8f25], ax
1000:0750	mov	word ptr [0x8f23], 0x3f0
1000:0756	mov	cx, 0x40
        	loc_10759:
1000:0759	push	cx
1000:075a	mov	byte ptr [0x8f22], 0
1000:075f	call	0x7af
1000:0762	mov	word ptr [0x279], 0
1000:0768	mov	byte ptr [0x27d], 8
1000:076d	add	word ptr [0x283], 8
1000:0772	mov	si, 0x274
1000:0775	call	0xbc5
1000:0778	mov	word ptr [0x279], 8
1000:077e	mov	byte ptr [0x27d], 0x18
1000:0783	mov	cx, 0xa
        	loc_10786:
1000:0786	push	cx
1000:0787	call	0x7af
1000:078a	mov	si, 0x274
1000:078d	call	0xbc5
1000:0790	add	word ptr [0x279], 0x18
1000:0795	pop	cx
1000:0796	loop	loc_10786
1000:0798	mov	byte ptr [0x27d], 8
1000:079d	call	0x7af
1000:07a0	mov	si, 0x274
1000:07a3	call	0xbc5
1000:07a6	sub	word ptr [0x8f23], 0x10
1000:07ab	pop	cx
1000:07ac	loop	loc_10759
1000:07ae	ret	
                sub_1069a ENDP
*/
void sub_1069a()
{
    // coverage: 0x89a-0x9af method sub_1069a
    al = memoryAGet(ds, 0x9501);
    bl = al;
    bl <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    si = memoryAGet16(ds, bx + 580);
    di = 0x9229;
    cx = 0x0040;
    ax = ds;
    es = ax;
    ax = 0x0000;
    flags.direction = false;
    rep_stosw<MemAuto, DirAuto>();
    di = 0x9229;
loc_106c2:
    lodsb<MemAuto, DirAuto>();
    if (al == 0xff)
        goto loc_106eb;
    al <<= 1;
    al <<= 1;
    ah = al;
    lodsb<MemAuto, DirAuto>();
    al <<= 1;
    bl = al;
    bh = 0x00;
    al = 0x00;
    ax |= memoryAGet16(ds, bx + 3287);
    cx = ax;
    lodsb<MemAuto, DirAuto>();
    al = -al;
    al += 0x3f;
    al <<= 1;
    bl = al;
    memoryASet16(ds, bx + 37417, memoryAGet16(ds, bx + 37417) | cx);
    goto loc_106c2;
loc_106eb:
    al = memoryAGet(ds, 0x9501);
    bl = al;
    bl <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    si = memoryAGet16(ds, bx + 532);
    di = 0x8f29;
    cx = 0x0300;
    bl = 0x00;
loc_10708:
    bl--;
    if ((char)bl >= 0)
        goto loc_1072c;
    lodsb<MemAuto, DirAuto>();
    dl = al;
    dl &= 0x3f;
    al &= 0xc0;
    if (al != 0)
        goto loc_1071a;
    bl = 0x00;
    goto loc_1072c;
loc_1071a:
    if (al != 0x40)
        goto loc_10722;
    bl = 0x01;
    goto loc_1072c;
loc_10722:
    if (al != 0x80)
        goto loc_1072a;
    bl = 0x02;
    goto loc_1072c;
loc_1072a:
    bl = 0x03;
loc_1072c:
    memoryASet(ds, di, dl);
    di++;
    if (--cx)
        goto loc_10708;
    di = 0x0000;
    ax = 0xa800;
    es = ax;
    dx = 0x03ce;
    ah = 0x00;
    al = 0x00;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    cx = 0x4000;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x8f29;
    memoryASet16(ds, 0x8f25, ax);
    memoryASet16(ds, 0x8f23, 0x03f0);
    cx = 0x0040;
loc_10759:
    push(cx);
    memoryASet(ds, 0x8f22, 0x00);
    sub_107af();
    memoryASet16(ds, 0x0279, 0x0000);
    memoryASet(ds, 0x027d, 0x08);
    memoryASet16(ds, 0x0283, memoryAGet16(ds, 0x0283) + 0x0008);
    si = 0x0274;
    sub_10bc5();
    memoryASet16(ds, 0x0279, 0x0008);
    memoryASet(ds, 0x027d, 0x18);
    cx = 0x000a;
loc_10786:
    push(cx);
    sub_107af();
    si = 0x0274;
    sub_10bc5();
    memoryASet16(ds, 0x0279, memoryAGet16(ds, 0x0279) + 0x0018);
    cx = pop();
    if (--cx)
        goto loc_10786;
    memoryASet(ds, 0x027d, 0x08);
    sub_107af();
    si = 0x0274;
    sub_10bc5();
    memoryASet16(ds, 0x8f23, memoryAGet16(ds, 0x8f23) - 0x0010);
    cx = pop();
    if (--cx)
        goto loc_10759;
}
/* Assembly listing of 1000:07af sub_107af()
                sub_107af PROC
1000:07af	mov	al, byte ptr [0x8f22]
1000:07b2	mov	byte ptr [0x277], al
1000:07b5	mov	bx, word ptr [0x8f25]
1000:07b9	mov	al, byte ptr [bx]
1000:07bb	inc	bx
1000:07bc	mov	word ptr [0x8f25], bx
1000:07c0	mov	bh, 0
1000:07c2	mov	bl, al
1000:07c4	mov	al, byte ptr [bx + 0x51d]
1000:07c8	mov	byte ptr [0x27e], al
1000:07cb	mov	al, byte ptr [bx + 0x571]
1000:07cf	add	byte ptr [0x8f22], al
1000:07d3	mov	al, byte ptr [bx + 0x547]
1000:07d7	cwde	
1000:07d8	add	ax, word ptr [0x8f23]
1000:07dc	mov	word ptr [0x27b], ax
1000:07df	cmp	bx, 0x26
1000:07e2	jb	loc_107ec
1000:07e4	mov	word ptr [0x281], 2
1000:07ea	jmp	loc_107f2
        	loc_107ec:
1000:07ec	mov	word ptr [0x281], 4
        	loc_107f2:
1000:07f2	shl	bx, 1
1000:07f4	mov	bx, word ptr [bx + 0x5ef]
1000:07f8	mov	word ptr [0x283], bx
1000:07fc	ret	
                sub_107af ENDP
*/
void sub_107af()
{
    // coverage: 0x9af-0x9fd method sub_107af
    al = memoryAGet(ds, 0x8f22);
    memoryASet(ds, 0x0277, al);
    bx = memoryAGet16(ds, 0x8f25);
    al = memoryAGet(ds, bx);
    bx++;
    memoryASet16(ds, 0x8f25, bx);
    bh = 0x00;
    bl = al;
    al = memoryAGet(ds, bx + 1309);
    memoryASet(ds, 0x027e, al);
    al = memoryAGet(ds, bx + 1393);
    memoryASet(ds, 0x8f22, memoryAGet(ds, 0x8f22) + al);
    al = memoryAGet(ds, bx + 1351);
    cbw();
    ax += memoryAGet16(ds, 0x8f23);
    memoryASet16(ds, 0x027b, ax);
    if (bx < 0x0026)
        goto loc_107ec;
    memoryASet16(ds, 0x0281, 0x0002);
    goto loc_107f2;
loc_107ec:
    memoryASet16(ds, 0x0281, 0x0004);
loc_107f2:
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 1519);
    memoryASet16(ds, 0x0283, bx);
}
/* Assembly listing of 1000:07fd sub_107fd()
                sub_107fd PROC
1000:07fd	push	bp
1000:07fe	mov	bp, sp
1000:0800	sub	sp, 8
1000:0803	mov	ax, word ptr [bp + 6]
1000:0806	add	ax, 0x10
1000:0809	mov	cl, 0x18
1000:080b	div	cl
1000:080d	push	ax
1000:080e	mov	ah, 0
1000:0810	mov	word ptr [bp - 2], ax
1000:0813	pop	ax
1000:0814	mov	al, ah
1000:0816	mov	ah, 0
1000:0818	mov	cl, 3
1000:081a	div	cl
1000:081c	mov	ah, 0
1000:081e	mov	word ptr [bp - 4], ax
1000:0821	mov	ax, word ptr [bp + 4]
1000:0824	and	ax, 0x3ff
1000:0827	shr	ax, 1
1000:0829	shr	ax, 1
1000:082b	shr	ax, 1
1000:082d	shr	ax, 1
1000:082f	neg	ax
1000:0831	add	ax, 0x3f
1000:0834	mov	word ptr [bp - 6], ax
1000:0837	mov	ax, word ptr [bp + 4]
1000:083a	and	ax, 0xf
1000:083d	shr	ax, 1
1000:083f	mov	word ptr [bp - 8], ax
1000:0842	mov	ax, word ptr [bp - 6]
1000:0845	shl	ax, 1
1000:0847	shl	ax, 1
1000:0849	mov	bx, ax
1000:084b	shl	ax, 1
1000:084d	add	bx, ax
1000:084f	add	bx, 0x8f29
1000:0853	mov	si, bx
1000:0855	add	bx, word ptr [bp - 2]
1000:0858	mov	al, byte ptr [bx]
1000:085a	mov	ah, 0
1000:085c	push	ax
1000:085d	shl	ax, 1
1000:085f	mov	bx, ax
1000:0861	mov	bx, word ptr [bx + 0x643]
1000:0865	mov	ax, word ptr [bp - 8]
1000:0868	shl	ax, 1
1000:086a	shl	ax, 1
1000:086c	shl	ax, 1
1000:086e	add	bx, ax
1000:0870	add	bx, word ptr [bp - 4]
1000:0873	mov	cl, byte ptr [bx]
1000:0875	push	cx
1000:0876	and	cl, 0x1f
1000:0879	test	cl, 0x10
1000:087c	je	loc_10881
1000:087e	or	cl, 0xe0
        	loc_10881:
1000:0881	mov	dx, word ptr [bp - 2]
1000:0884	cld	
        	loc_10885:
1000:0885	cmp	dx, 0
1000:0888	je	loc_10896
1000:088a	lodsb	al, byte ptr [si]
1000:088b	mov	bh, 0
1000:088d	mov	bl, al
1000:088f	add	cl, byte ptr [bx + 0x571]
1000:0893	dec	dx
1000:0894	jmp	loc_10885
        	loc_10896:
1000:0896	mov	al, cl
1000:0898	cwde	
1000:0899	pop	cx
1000:089a	pop	bx
1000:089b	test	cl, 0x80
1000:089e	jne	loc_108a6
1000:08a0	mov	bl, byte ptr [bx + 0x59b]
1000:08a4	jmp	loc_108aa
        	loc_108a6:
1000:08a6	mov	bl, byte ptr [bx + 0x5c5]
        	loc_108aa:
1000:08aa	mov	bh, 0
1000:08ac	mov	cx, word ptr [bp - 6]
1000:08af	neg	cx
1000:08b1	add	cx, 0x3f
1000:08b4	mov	sp, bp
1000:08b6	pop	bp
1000:08b7	ret	4
                sub_107fd ENDP
*/
void sub_107fd()
{
    // coverage: 0x9fd-0xaba method sub_107fd
    push(bp);
    bp = sp;
    sp -= 0x0008;
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax += 0x0010;
    cl = 0x18;
    div(cl);
    push(ax);
    ah = 0x00;
    memoryASet16(ss, bp - 2 - 2, ax);
    ax = pop();
    al = ah;
    ah = 0x00;
    cl = 0x03;
    div(cl);
    ah = 0x00;
    memoryASet16(ss, bp - 4 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax &= 0x03ff;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax = -ax;
    ax += 0x003f;
    memoryASet16(ss, bp - 6 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax &= 0x000f;
    ax >>= 1;
    memoryASet16(ss, bp - 8 - 2, ax);
    ax = memoryAGet16(ss, bp - 6 - 2);
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax <<= 1;
    bx += ax;
    bx += 0x8f29;
    si = bx;
    bx += memoryAGet16(ss, bp - 2 - 2);
    al = memoryAGet(ds, bx);
    ah = 0x00;
    push(ax);
    ax <<= 1;
    bx = ax;
    bx = memoryAGet16(ds, bx + 1603);
    ax = memoryAGet16(ss, bp - 8 - 2);
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    bx += ax;
    bx += memoryAGet16(ss, bp - 4 - 2);
    cl = memoryAGet(ds, bx);
    push(cx);
    cl &= 0x1f;
    if (!(cl & 0x10))
        goto loc_10881;
    cl |= 0xe0;
loc_10881:
    dx = memoryAGet16(ss, bp - 2 - 2);
    flags.direction = false;
loc_10885:
    if (dx == 0x0000)
        goto loc_10896;
    lodsb<MemAuto, DirAuto>();
    bh = 0x00;
    bl = al;
    cl += memoryAGet(ds, bx + 1393);
    dx--;
    goto loc_10885;
loc_10896:
    al = cl;
    cbw();
    cx = pop();
    bx = pop();
    if (cl & 0x80)
        goto loc_108a6;
    bl = memoryAGet(ds, bx + 1435);
    goto loc_108aa;
loc_108a6:
    bl = memoryAGet(ds, bx + 1477);
loc_108aa:
    bh = 0x00;
    cx = memoryAGet16(ss, bp - 6 - 2);
    cx = -cx;
    cx += 0x003f;
    sp = bp;
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:08ba sub_108ba()
                sub_108ba PROC
1000:08ba	push	bp
1000:08bb	mov	bp, sp
1000:08bd	mov	bx, word ptr [bp + 4]
1000:08c0	shl	bx, 1
1000:08c2	mov	ax, word ptr [bx - 0x6dd7]
1000:08c6	cmp	ax, 0
1000:08c9	je	loc_10946
1000:08cb	push	ax
1000:08cc	shr	ah, 1
1000:08ce	shr	ah, 1
1000:08d0	mov	bl, ah
1000:08d2	mov	bh, 0
1000:08d4	shl	bx, 1
1000:08d6	mov	si, word ptr [bx + 0x28b]
1000:08da	cmp	ah, 0xf
1000:08dd	jb	loc_10902
1000:08df	cmp	ah, 0x14
1000:08e2	ja	loc_10902
1000:08e4	sub	ah, 0xf
1000:08e7	mov	byte ptr [si + 1], ah
1000:08ea	mov	bl, ah
1000:08ec	mov	bh, 0
1000:08ee	mov	al, byte ptr [bx - 0x6ad2]
1000:08f2	cmp	al, 0
1000:08f4	je	loc_108f9
1000:08f6	pop	ax
1000:08f7	jmp	loc_10946
        	loc_108f9:
1000:08f9	shl	bx, 1
1000:08fb	mov	ax, word ptr [bx + 0x32e]
1000:08ff	mov	word ptr [si + 0xf], ax
        	loc_10902:
1000:0902	mov	byte ptr [si + 0x13], 0xa
1000:0906	mov	ax, word ptr [bp + 4]
1000:0909	mov	byte ptr [si + 0x14], al
1000:090c	pop	ax
1000:090d	mov	cx, 0xa
        	loc_10910:
1000:0910	shr	ax, 1
1000:0912	jae	loc_10941
1000:0914	push	ax
1000:0915	push	cx
1000:0916	call	0x94a
1000:0919	mov	al, byte ptr [si + 0x13]
1000:091c	mov	ah, 0
1000:091e	push	ax
1000:091f	mov	ax, word ptr [bp + 4]
1000:0922	push	ax
1000:0923	call	0x9e9
1000:0926	cmp	ax, 0
1000:0929	je	loc_10932
1000:092b	push	si
1000:092c	call	0xb58
1000:092f	pop	si
1000:0930	jmp	loc_1093f
        	loc_10932:
1000:0932	push	si
1000:0933	call	0xb58
1000:0936	cmp	si, 0
1000:0939	je	loc_1093e
1000:093b	call	0xa1b
        	loc_1093e:
1000:093e	pop	si
        	loc_1093f:
1000:093f	pop	cx
1000:0940	pop	ax
        	loc_10941:
1000:0941	dec	byte ptr [si + 0x13]
1000:0944	loop	loc_10910
        	loc_10946:
1000:0946	pop	bp
1000:0947	ret	2
                sub_108ba ENDP
*/
void sub_108ba()
{
    // coverage: 0xaba-0xb4a method sub_108ba
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 37417);
    if (ax == 0x0000)
        goto loc_10946;
    push(ax);
    ah >>= 1;
    ah >>= 1;
    bl = ah;
    bh = 0x00;
    bx <<= 1;
    si = memoryAGet16(ds, bx + 651);
    if (ah < 0x0f)
        goto loc_10902;
    if (ah > 0x14)
        goto loc_10902;
    ah -= 0x0f;
    memoryASet(ds, si + 1, ah);
    bl = ah;
    bh = 0x00;
    al = memoryAGet(ds, bx + 38190);
    if (al == 0x00)
        goto loc_108f9;
    ax = pop();
    goto loc_10946;
loc_108f9:
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 814);
    memoryASet16(ds, si + 15, ax);
loc_10902:
    memoryASet(ds, si + 19, 0x0a);
    ax = memoryAGet16(ss, bp + 4 - 2);
    memoryASet(ds, si + 20, al);
    ax = pop();
    cx = 0x000a;
loc_10910:
    flags.carry = ax & 1;
    ax >>= 1;
    if (!flags.carry)
        goto loc_10941;
    push(ax);
    push(cx);
    sub_1094a();
    al = memoryAGet(ds, si + 19);
    ah = 0x00;
    push(ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_109e9();
    if (ax == 0x0000)
        goto loc_10932;
    push(si);
    sub_10b58();
    si = pop();
    goto loc_1093f;
loc_10932:
    push(si);
    sub_10b58();
    if (si == 0x0000)
        goto loc_1093e;
    sub_10a1b();
loc_1093e:
    si = pop();
loc_1093f:
    cx = pop();
    ax = pop();
loc_10941:
    memoryASet(ds, si + 19, memoryAGet(ds, si + 19) - 1);
    if (--cx)
        goto loc_10910;
loc_10946:
    bp = pop();
    sp += 2;
}
/* Assembly listing of 1000:094a sub_1094a()
                sub_1094a PROC
1000:094a	mov	dl, byte ptr [si + 0x13]
1000:094d	push	si
1000:094e	mov	al, 0x3f
1000:0950	sub	al, byte ptr [si + 0x14]
1000:0953	shl	al, 1
1000:0955	shl	al, 1
1000:0957	mov	ah, 0
1000:0959	mov	si, ax
1000:095b	shl	ax, 1
1000:095d	add	si, ax
1000:095f	add	si, 0x8f29
1000:0963	mov	cl, 0
1000:0965	cld	
        	loc_10966:
1000:0966	cmp	dl, 0
1000:0969	je	loc_10978
1000:096b	lodsb	al, byte ptr [si]
1000:096c	mov	bh, 0
1000:096e	mov	bl, al
1000:0970	add	cl, byte ptr [bx + 0x571]
1000:0974	dec	dl
1000:0976	jmp	loc_10966
        	loc_10978:
1000:0978	pop	si
1000:0979	mov	byte ptr [si + 3], cl
1000:097c	mov	al, byte ptr [si + 0x14]
1000:097f	mov	ah, 0
1000:0981	shl	ax, 1
1000:0983	shl	ax, 1
1000:0985	shl	ax, 1
1000:0987	shl	ax, 1
1000:0989	mov	word ptr [si + 7], ax
1000:098c	mov	al, byte ptr [si + 0x13]
1000:098f	mov	ah, 0
1000:0991	shl	ax, 1
1000:0993	mov	cx, ax
1000:0995	shl	ax, 1
1000:0997	add	ax, cx
1000:0999	shl	ax, 1
1000:099b	shl	ax, 1
1000:099d	sub	ax, 4
1000:09a0	mov	word ptr [si + 5], ax
1000:09a3	ret	
                sub_1094a ENDP
*/
void sub_1094a()
{
    // coverage: 0xb4a-0xba4 method sub_1094a
    dl = memoryAGet(ds, si + 19);
    push(si);
    al = 0x3f;
    al -= memoryAGet(ds, si + 20);
    al <<= 1;
    al <<= 1;
    ah = 0x00;
    si = ax;
    ax <<= 1;
    si += ax;
    si += 0x8f29;
    cl = 0x00;
    flags.direction = false;
loc_10966:
    if (dl == 0x00)
        goto loc_10978;
    lodsb<MemAuto, DirAuto>();
    bh = 0x00;
    bl = al;
    cl += memoryAGet(ds, bx + 1393);
    dl--;
    goto loc_10966;
loc_10978:
    si = pop();
    memoryASet(ds, si + 3, cl);
    al = memoryAGet(ds, si + 20);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, si + 19);
    ah = 0x00;
    ax <<= 1;
    cx = ax;
    ax <<= 1;
    ax += cx;
    ax <<= 1;
    ax <<= 1;
    ax -= 0x0004;
    memoryASet16(ds, si + 5, ax);
}
/* Assembly listing of 1000:09a4 sub_109a4()
                sub_109a4 PROC
1000:09a4	mov	di, 0x92a9
1000:09a7	mov	cx, 0xc0
1000:09aa	mov	ax, ds
1000:09ac	mov	es, ax
1000:09ae	mov	ax, 0xffff
1000:09b1	cld	
1000:09b2	rep stosw	word ptr es:[di], ax
1000:09b4	ret	
                sub_109a4 ENDP
*/
void sub_109a4()
{
    // coverage: 0xba4-0xbb5 method sub_109a4
    di = 0x92a9;
    cx = 0x00c0;
    ax = ds;
    es = ax;
    ax = 0xffff;
    flags.direction = false;
    rep_stosw<MemAuto, DirAuto>();
}
/* Assembly listing of 1000:09b5 sub_109b5()
                sub_109b5 PROC
1000:09b5	push	bp
1000:09b6	mov	bp, sp
1000:09b8	mov	si, word ptr [bp + 8]
1000:09bb	call	0xa1b
1000:09be	mov	bx, word ptr [bp + 6]
1000:09c1	shl	bx, 1
1000:09c3	mov	cx, word ptr [bx + 0xceb]
1000:09c7	mov	bx, word ptr [bp + 4]
1000:09ca	shl	bx, 1
1000:09cc	mov	al, byte ptr [0x9502]
1000:09cf	cmp	al, 1
1000:09d1	jne	loc_109d9
1000:09d3	add	bx, 0x80
1000:09d7	jmp	loc_109e1
        	loc_109d9:
1000:09d9	cmp	al, 2
1000:09db	jne	loc_109e1
1000:09dd	add	bx, 0x100
        	loc_109e1:
1000:09e1	and	word ptr [bx - 0x6d57], cx
1000:09e5	pop	bp
1000:09e6	ret	6
                sub_109b5 ENDP
*/
void sub_109b5()
{
    // coverage: 0xbb5-0xbe9 method sub_109b5
    push(bp);
    bp = sp;
    si = memoryAGet16(ss, bp + 8 - 2);
    sub_10a1b();
    bx = memoryAGet16(ss, bp + 6 - 2);
    bx <<= 1;
    cx = memoryAGet16(ds, bx + 3307);
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_109d9;
    bx += 0x0080;
    goto loc_109e1;
loc_109d9:
    if (al != 0x02)
        goto loc_109e1;
    bx += 0x0100;
loc_109e1:
    memoryASet16(ds, bx + 37545, memoryAGet16(ds, bx + 37545) & cx);
    bp = pop();
    sp += 6;
}
/* Assembly listing of 1000:09e9 sub_109e9()
                sub_109e9 PROC
1000:09e9	push	bp
1000:09ea	mov	bp, sp
1000:09ec	mov	bx, word ptr [bp + 6]
1000:09ef	shl	bx, 1
1000:09f1	mov	cx, word ptr [bx + 0xceb]
1000:09f5	mov	bx, word ptr [bp + 4]
1000:09f8	shl	bx, 1
1000:09fa	mov	al, byte ptr [0x9502]
1000:09fd	cmp	al, 1
1000:09ff	jne	loc_10a07
1000:0a01	add	bx, 0x80
1000:0a05	jmp	loc_10a0f
        	loc_10a07:
1000:0a07	cmp	al, 2
1000:0a09	jne	loc_10a0f
1000:0a0b	add	bx, 0x100
        	loc_10a0f:
1000:0a0f	not	cx
1000:0a11	mov	ax, word ptr [bx - 0x6d57]
1000:0a15	and	ax, cx
1000:0a17	pop	bp
1000:0a18	ret	4
                sub_109e9 ENDP
*/
void sub_109e9()
{
    // coverage: 0xbe9-0xc1b method sub_109e9
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 6 - 2);
    bx <<= 1;
    cx = memoryAGet16(ds, bx + 3307);
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_10a07;
    bx += 0x0080;
    goto loc_10a0f;
loc_10a07:
    if (al != 0x02)
        goto loc_10a0f;
    bx += 0x0100;
loc_10a0f:
    cx = ~cx;
    ax = memoryAGet16(ds, bx + 37545);
    ax &= cx;
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:0a1b sub_10a1b()
                sub_10a1b PROC
1000:0a1b	mov	al, byte ptr [si + 0x12]
1000:0a1e	shl	al, 1
1000:0a20	mov	bl, al
1000:0a22	mov	bh, 0
1000:0a24	mov	di, word ptr [bx + 0x31e]
1000:0a28	mov	al, byte ptr [di]
1000:0a2a	mov	byte ptr [si], al
1000:0a2c	mov	al, byte ptr [di + 9]
1000:0a2f	mov	byte ptr [si + 9], al
1000:0a32	mov	al, byte ptr [di + 0xa]
1000:0a35	mov	byte ptr [si + 0xa], al
1000:0a38	mov	al, byte ptr [di + 0xb]
1000:0a3b	mov	byte ptr [si + 0xb], al
1000:0a3e	mov	al, byte ptr [di + 0xc]
1000:0a41	mov	byte ptr [si + 0xc], al
1000:0a44	mov	ax, word ptr [di + 0xf]
1000:0a47	mov	word ptr [si + 0xf], ax
1000:0a4a	mov	al, byte ptr [di + 0x12]
1000:0a4d	mov	byte ptr [si + 0x12], al
1000:0a50	ret	
                sub_10a1b ENDP
*/
void sub_10a1b()
{
    // coverage: 0xc1b-0xc51 method sub_10a1b
    al = memoryAGet(ds, si + 18);
    al <<= 1;
    bl = al;
    bh = 0x00;
    di = memoryAGet16(ds, bx + 798);
    al = memoryAGet(ds, di);
    memoryASet(ds, si, al);
    al = memoryAGet(ds, di + 9);
    memoryASet(ds, si + 9, al);
    al = memoryAGet(ds, di + 10);
    memoryASet(ds, si + 10, al);
    al = memoryAGet(ds, di + 11);
    memoryASet(ds, si + 11, al);
    al = memoryAGet(ds, di + 12);
    memoryASet(ds, si + 12, al);
    ax = memoryAGet16(ds, di + 15);
    memoryASet16(ds, si + 15, ax);
    al = memoryAGet(ds, di + 18);
    memoryASet(ds, si + 18, al);
}
/* Assembly listing of 1000:0a51 sub_10a51()
                sub_10a51 PROC
1000:0a51	mov	bl, byte ptr [0x1b9e]
1000:0a55	mov	bh, 0
1000:0a57	shl	bx, 1
1000:0a59	mov	si, bx
1000:0a5b	mov	al, byte ptr [0x9502]
1000:0a5e	cmp	al, 1
1000:0a60	jne	loc_10a68
1000:0a62	add	si, 0x80
1000:0a66	jmp	loc_10a70
        	loc_10a68:
1000:0a68	cmp	al, 2
1000:0a6a	jne	loc_10a70
1000:0a6c	add	si, 0x100
        	loc_10a70:
1000:0a70	mov	ax, word ptr [si - 0x6d57]
1000:0a74	and	ax, word ptr [bx - 0x6dd7]
1000:0a78	cmp	ax, 0
1000:0a7b	je	loc_10ad1
1000:0a7d	mov	bl, ah
1000:0a7f	shr	bl, 1
1000:0a81	shr	bl, 1
1000:0a83	mov	bh, 0
1000:0a85	mov	cl, byte ptr [bx + 0x2b5]
1000:0a89	cmp	cl, 0
1000:0a8c	je	loc_10ad1
1000:0a8e	mov	byte ptr [0x9429], cl
1000:0a92	mov	word ptr [0x942c], 0xa
1000:0a98	shl	bx, 1
1000:0a9a	mov	dx, word ptr [bx + 0x2ca]
1000:0a9e	mov	bx, word ptr [bx + 0x2f4]
1000:0aa2	mov	cx, 0xa
        	loc_10aa5:
1000:0aa5	shr	ax, 1
1000:0aa7	jae	loc_10ac8
1000:0aa9	push	bx
1000:0aaa	sub	bx, dx
1000:0aac	cmp	bx, word ptr [0x1b8f]
1000:0ab0	jg	loc_10ac7
1000:0ab2	add	bx, dx
1000:0ab4	add	bx, dx
1000:0ab6	cmp	bx, word ptr [0x1b8f]
1000:0aba	jl	loc_10ac7
1000:0abc	pop	ax
1000:0abd	mov	al, byte ptr [0x9429]
1000:0ac0	mov	ah, 0
1000:0ac2	mov	bx, word ptr [0x942c]
1000:0ac6	ret	
        	loc_10ac7:
1000:0ac7	pop	bx
        	loc_10ac8:
1000:0ac8	sub	bx, 0x18
1000:0acb	dec	word ptr [0x942c]
1000:0acf	loop	loc_10aa5
        	loc_10ad1:
1000:0ad1	mov	ax, 0
1000:0ad4	ret	
                sub_10a51 ENDP
*/
void sub_10a51()
{
    // coverage: 0xc51-0xcd5 method sub_10a51
    bl = memoryAGet(ds, 0x1b9e);
    bh = 0x00;
    bx <<= 1;
    si = bx;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_10a68;
    si += 0x0080;
    goto loc_10a70;
loc_10a68:
    if (al != 0x02)
        goto loc_10a70;
    si += 0x0100;
loc_10a70:
    ax = memoryAGet16(ds, si + 37545);
    ax &= memoryAGet16(ds, bx + 37417);
    if (ax == 0x0000)
        goto loc_10ad1;
    bl = ah;
    bl >>= 1;
    bl >>= 1;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 693);
    if (cl == 0x00)
        goto loc_10ad1;
    memoryASet(ds, 0x9429, cl);
    memoryASet16(ds, 0x942c, 0x000a);
    bx <<= 1;
    dx = memoryAGet16(ds, bx + 714);
    bx = memoryAGet16(ds, bx + 756);
    cx = 0x000a;
loc_10aa5:
    flags.carry = ax & 1;
    ax >>= 1;
    if (!flags.carry)
        goto loc_10ac8;
    push(bx);
    bx -= dx;
    if ((short)bx > (short)memoryAGet16(ds, 0x1b8f))
        goto loc_10ac7;
    bx += dx;
    bx += dx;
    if ((short)bx < (short)memoryAGet16(ds, 0x1b8f))
        goto loc_10ac7;
    ax = pop();
    al = memoryAGet(ds, 0x9429);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x942c);
    return;
loc_10ac7:
    bx = pop();
loc_10ac8:
    bx -= 0x0018;
    memoryASet16(ds, 0x942c, memoryAGet16(ds, 0x942c) - 1);
    if (--cx)
        goto loc_10aa5;
loc_10ad1:
    ax = 0x0000;
}
/* Assembly listing of 1000:0ad5 sub_10ad5()
                sub_10ad5 PROC
1000:0ad5	push	bp
1000:0ad6	mov	bp, sp
1000:0ad8	mov	bx, word ptr [bp + 4]
1000:0adb	shl	bx, 1
1000:0add	mov	si, bx
1000:0adf	mov	al, byte ptr [0x9502]
1000:0ae2	cmp	al, 1
1000:0ae4	jne	loc_10aec
1000:0ae6	add	si, 0x80
1000:0aea	jmp	loc_10af4
        	loc_10aec:
1000:0aec	cmp	al, 2
1000:0aee	jne	loc_10af4
1000:0af0	add	si, 0x100
        	loc_10af4:
1000:0af4	mov	ax, word ptr [si - 0x6d57]
1000:0af8	and	ax, word ptr [bx - 0x6dd7]
1000:0afc	cmp	ax, 0
1000:0aff	je	loc_10b51
1000:0b01	mov	bl, ah
1000:0b03	shr	bl, 1
1000:0b05	shr	bl, 1
1000:0b07	mov	bh, 0
1000:0b09	mov	cl, byte ptr [bx + 0x2b5]
1000:0b0d	cmp	cl, 0
1000:0b10	je	loc_10b51
1000:0b12	mov	word ptr [0x942c], 0xa
1000:0b18	shl	bx, 1
1000:0b1a	mov	dx, word ptr [bx + 0x2ca]
1000:0b1e	sub	dx, 0xe
1000:0b21	mov	bx, word ptr [bx + 0x2f4]
1000:0b25	mov	cx, 0xa
        	loc_10b28:
1000:0b28	shr	ax, 1
1000:0b2a	jae	loc_10b48
1000:0b2c	push	bx
1000:0b2d	sub	bx, dx
1000:0b2f	cmp	bx, word ptr [bp + 6]
1000:0b32	jg	loc_10b47
1000:0b34	add	bx, dx
1000:0b36	add	bx, dx
1000:0b38	cmp	bx, word ptr [bp + 6]
1000:0b3b	jl	loc_10b47
1000:0b3d	pop	ax
1000:0b3e	mov	ax, 1
1000:0b41	mov	bx, word ptr [0x942c]
1000:0b45	jmp	loc_10b54
        	loc_10b47:
1000:0b47	pop	bx
        	loc_10b48:
1000:0b48	sub	bx, 0x18
1000:0b4b	dec	word ptr [0x942c]
1000:0b4f	loop	loc_10b28
        	loc_10b51:
1000:0b51	mov	ax, 0
        	loc_10b54:
1000:0b54	pop	bp
1000:0b55	ret	4
                sub_10ad5 ENDP
*/
void sub_10ad5()
{
    // coverage: 0xcd5-0xd58 method sub_10ad5
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    si = bx;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_10aec;
    si += 0x0080;
    goto loc_10af4;
loc_10aec:
    if (al != 0x02)
        goto loc_10af4;
    si += 0x0100;
loc_10af4:
    ax = memoryAGet16(ds, si + 37545);
    ax &= memoryAGet16(ds, bx + 37417);
    if (ax == 0x0000)
        goto loc_10b51;
    bl = ah;
    bl >>= 1;
    bl >>= 1;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 693);
    if (cl == 0x00)
        goto loc_10b51;
    memoryASet16(ds, 0x942c, 0x000a);
    bx <<= 1;
    dx = memoryAGet16(ds, bx + 714);
    dx -= 0x000e;
    bx = memoryAGet16(ds, bx + 756);
    cx = 0x000a;
loc_10b28:
    flags.carry = ax & 1;
    ax >>= 1;
    if (!flags.carry)
        goto loc_10b48;
    push(bx);
    bx -= dx;
    if ((short)bx > (short)memoryAGet16(ss, bp + 6 - 2))
        goto loc_10b47;
    bx += dx;
    bx += dx;
    if ((short)bx < (short)memoryAGet16(ss, bp + 6 - 2))
        goto loc_10b47;
    ax = pop();
    ax = 0x0001;
    bx = memoryAGet16(ds, 0x942c);
    goto loc_10b54;
loc_10b47:
    bx = pop();
loc_10b48:
    bx -= 0x0018;
    memoryASet16(ds, 0x942c, memoryAGet16(ds, 0x942c) - 1);
    if (--cx)
        goto loc_10b28;
loc_10b51:
    ax = 0x0000;
loc_10b54:
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:0b58 sub_10b58()
                sub_10b58 PROC
1000:0b58	mov	ax, 0x13a5
1000:0b5b	mov	es, ax
1000:0b5d	mov	di, 0x1b8a
        	loc_10b60:
1000:0b60	mov	al, byte ptr [di]
1000:0b62	test	al, 0x80
1000:0b64	jne	loc_10b78
1000:0b66	test	al, 1
1000:0b68	jne	loc_10b73
1000:0b6a	push	di
1000:0b6b	mov	cx, 0x17
1000:0b6e	cld	
1000:0b6f	rep movsb	byte ptr es:[di], byte ptr [si]
1000:0b71	pop	si
1000:0b72	ret	
        	loc_10b73:
1000:0b73	add	di, 0x17
1000:0b76	jmp	loc_10b60
        	loc_10b78:
1000:0b78	mov	si, 0
1000:0b7b	ret	
                sub_10b58 ENDP
*/
void sub_10b58()
{
    // coverage: 0xd58-0xd7c method sub_10b58
    ax = 0x13a5;
    es = ax;
    di = 0x1b8a;
loc_10b60:
    al = memoryAGet(ds, di);
    if (al & 0x80)
        goto loc_10b78;
    if (al & 0x01)
        goto loc_10b73;
    push(di);
    cx = 0x0017;
    flags.direction = false;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    si = pop();
    return;
loc_10b73:
    di += 0x0017;
    goto loc_10b60;
loc_10b78:
    si = 0x0000;
}
/* Assembly listing of 1000:0b7c sub_10b7c()
                sub_10b7c PROC
1000:0b7c	mov	si, 0x1b8a
        	loc_10b7f:
1000:0b7f	mov	al, byte ptr [si]
1000:0b81	test	al, 0x80
1000:0b83	jne	loc_10b8d
1000:0b85	mov	byte ptr [si], 0
1000:0b88	add	si, 0x17
1000:0b8b	jmp	loc_10b7f
        	loc_10b8d:
1000:0b8d	ret	
                sub_10b7c ENDP
*/
void sub_10b7c()
{
    // coverage: 0xd7c-0xd8e method sub_10b7c
    si = 0x1b8a;
loc_10b7f:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        return;
    memoryASet(ds, si, 0x00);
    si += 0x0017;
    goto loc_10b7f;
}
/* Assembly listing of 1000:0b8e sub_10b8e()
                sub_10b8e PROC
1000:0b8e	mov	ax, word ptr [0x94f8]
1000:0b91	mov	word ptr [0x942e], ax
1000:0b94	mov	word ptr cs:[0xd93], 0x28
1000:0b9b	mov	word ptr [0x9430], 1
1000:0ba1	mov	cx, 7
        	loc_10ba4:
1000:0ba4	mov	si, 0x1b8a
        	loc_10ba7:
1000:0ba7	mov	al, byte ptr [si]
1000:0ba9	test	al, 0x80
1000:0bab	jne	loc_10bc2
1000:0bad	test	al, 1
1000:0baf	je	loc_10bbd
1000:0bb1	cmp	cl, byte ptr [si + 2]
1000:0bb4	jne	loc_10bbd
1000:0bb6	push	cx
1000:0bb7	push	si
1000:0bb8	call	0xbdc
1000:0bbb	pop	si
1000:0bbc	pop	cx
        	loc_10bbd:
1000:0bbd	add	si, 0x17
1000:0bc0	jmp	loc_10ba7
        	loc_10bc2:
1000:0bc2	loop	loc_10ba4
1000:0bc4	ret	
                sub_10b8e ENDP
*/
void sub_10b8e()
{
    // coverage: 0xd8e-0xdc5 method sub_10b8e
    ax = memoryAGet16(ds, 0x94f8);
    memoryASet16(ds, 0x942e, ax);
    memoryASet16(cs, 0x0d93, 0x0028);
    memoryASet16(ds, 0x9430, 0x0001);
    cx = 0x0007;
loc_10ba4:
    si = 0x1b8a;
loc_10ba7:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_10bc2;
    if (!(al & 0x01))
        goto loc_10bbd;
    if (cl != memoryAGet(ds, si + 2))
        goto loc_10bbd;
    push(cx);
    push(si);
    sub_10bdc();
    si = pop();
    cx = pop();
loc_10bbd:
    si += 0x0017;
    goto loc_10ba7;
loc_10bc2:
    if (--cx)
        goto loc_10ba4;
}
/* Assembly listing of 1000:0bc5 sub_10bc5()
                sub_10bc5 PROC
1000:0bc5	mov	ax, 0xa800
1000:0bc8	mov	word ptr [0x942e], ax
1000:0bcb	mov	word ptr cs:[0xd93], 0x20
1000:0bd2	mov	word ptr [0x9430], 0
1000:0bd8	call	0xbdc
1000:0bdb	ret	
                sub_10bc5 ENDP
*/
void sub_10bc5()
{
    // coverage: 0xdc5-0xddc method sub_10bc5
    ax = 0xa800;
    memoryASet16(ds, 0x942e, ax);
    memoryASet16(cs, 0x0d93, 0x0020);
    memoryASet16(ds, 0x9430, 0x0000);
    sub_10bdc();
}
/* Assembly listing of 1000:0bdc sub_10bdc()
                sub_10bdc PROC
1000:0bdc	mov	al, byte ptr [si + 0xb]
1000:0bdf	cwde	
1000:0be0	mov	bx, word ptr [si + 5]
1000:0be3	sub	bx, ax
1000:0be5	push	bx
1000:0be6	mov	al, byte ptr [si + 3]
1000:0be9	add	al, byte ptr [si + 0xc]
1000:0bec	cwde	
1000:0bed	neg	ax
1000:0bef	add	ax, word ptr [si + 7]
1000:0bf2	push	ax
1000:0bf3	mov	al, byte ptr [si + 9]
1000:0bf6	mov	ah, 0
1000:0bf8	push	ax
1000:0bf9	mov	al, byte ptr [si + 0xa]
1000:0bfc	mov	ah, 0
1000:0bfe	push	ax
1000:0bff	mov	bx, word ptr [si + 0xd]
1000:0c02	mov	bx, word ptr [bx - 0x6b18]
1000:0c06	mov	al, byte ptr [si + 0x11]
1000:0c09	mov	byte ptr cs:[0xd95], al
1000:0c0d	mov	cl, al
1000:0c0f	shl	cl, 1
1000:0c11	shl	cl, 1
1000:0c13	shl	cl, 1
1000:0c15	shl	cl, 1
1000:0c17	or	al, cl
1000:0c19	mov	byte ptr cs:[0xd96], al
1000:0c1d	mov	si, word ptr [si + 0xf]
1000:0c20	call	0xc24
1000:0c23	ret	
                sub_10bdc ENDP
*/
void sub_10bdc()
{
    // coverage: 0xddc-0xe24 method sub_10bdc
    al = memoryAGet(ds, si + 11);
    cbw();
    bx = memoryAGet16(ds, si + 5);
    bx -= ax;
    push(bx);
    al = memoryAGet(ds, si + 3);
    al += memoryAGet(ds, si + 12);
    cbw();
    ax = -ax;
    ax += memoryAGet16(ds, si + 7);
    push(ax);
    al = memoryAGet(ds, si + 9);
    ah = 0x00;
    push(ax);
    al = memoryAGet(ds, si + 10);
    ah = 0x00;
    push(ax);
    bx = memoryAGet16(ds, si + 13);
    bx = memoryAGet16(ds, bx + 38120);
    al = memoryAGet(ds, si + 17);
    memoryASet(cs, 0x0d95, al);
    cl = al;
    cl <<= 1;
    cl <<= 1;
    cl <<= 1;
    cl <<= 1;
    al |= cl;
    memoryASet(cs, 0x0d96, al);
    si = memoryAGet16(ds, si + 15);
    sub_10c24();
}
/* Assembly listing of 1000:0c24 sub_10c24()
                sub_10c24 PROC
1000:0c24	push	bp
1000:0c25	mov	bp, sp
1000:0c27	mov	ax, word ptr [0x9430]
1000:0c2a	cmp	ax, 0
1000:0c2d	jne	loc_10c32
1000:0c2f	jmp	loc_10cbc
        	loc_10c32:
1000:0c32	mov	ax, word ptr [bp + 8]
1000:0c35	sub	ax, word ptr [0x9528]
1000:0c39	and	ax, 0x3ff
1000:0c3c	test	ax, 0x200
1000:0c3f	je	loc_10c44
1000:0c41	or	ax, 0xfc00
        	loc_10c44:
1000:0c44	mov	word ptr [bp + 8], ax
1000:0c47	cmp	ax, 0
1000:0c4a	jge	loc_10c77
1000:0c4c	add	word ptr [bp + 4], ax
1000:0c4f	jns	loc_10c54
1000:0c51	jmp	loc_10d8f
        	loc_10c54:
1000:0c54	jne	loc_10c59
1000:0c56	jmp	loc_10d8f
        	loc_10c59:
1000:0c59	neg	ax
1000:0c5b	shl	ax, 1
1000:0c5d	shl	ax, 1
1000:0c5f	shl	ax, 1
1000:0c61	mov	cx, ax
1000:0c63	shl	ax, 1
1000:0c65	shl	ax, 1
1000:0c67	add	cx, ax
1000:0c69	shl	cx, 1
1000:0c6b	shl	cx, 1
1000:0c6d	add	si, cx
1000:0c6f	mov	ax, 0
1000:0c72	mov	word ptr [bp + 8], ax
1000:0c75	jmp	loc_10c8f
        	loc_10c77:
1000:0c77	add	ax, word ptr [bp + 4]
1000:0c7a	sub	ax, 0xa0
1000:0c7d	js	loc_10c8f
1000:0c7f	neg	ax
1000:0c81	add	ax, word ptr [bp + 4]
1000:0c84	cmp	ax, 0
1000:0c87	jg	loc_10c8c
1000:0c89	jmp	loc_10d8f
        	loc_10c8c:
1000:0c8c	mov	word ptr [bp + 4], ax
        	loc_10c8f:
1000:0c8f	mov	ax, 0x20
1000:0c92	add	word ptr [bp + 0xa], ax
1000:0c95	mov	ax, 8
1000:0c98	add	word ptr [bp + 8], ax
1000:0c9b	mov	ax, word ptr [bp + 0xa]
1000:0c9e	cmp	ax, 0x20
1000:0ca1	jge	loc_10cab
1000:0ca3	mov	ax, 0x20
1000:0ca6	mov	word ptr [bp + 0xa], ax
1000:0ca9	jmp	loc_10cbc
        	loc_10cab:
1000:0cab	add	ax, word ptr [bp + 6]
1000:0cae	cmp	ax, 0x120
1000:0cb1	jle	loc_10cbc
1000:0cb3	mov	ax, 0x120
1000:0cb6	sub	ax, word ptr [bp + 6]
1000:0cb9	mov	word ptr [bp + 0xa], ax
        	loc_10cbc:
1000:0cbc	push	ds
1000:0cbd	push	bx
1000:0cbe	mov	dx, 0x3ce
1000:0cc1	mov	ax, 0xa05
1000:0cc4	out	dx, ax
1000:0cc5	mov	ax, 7
1000:0cc8	out	dx, ax
1000:0cc9	mov	ax, word ptr [bp + 0xa]
1000:0ccc	mov	bx, word ptr [bp + 8]
1000:0ccf	push	cx
1000:0cd0	shl	bx, 1
1000:0cd2	shl	bx, 1
1000:0cd4	shl	bx, 1
1000:0cd6	mov	cx, word ptr cs:[0xd93]
1000:0cdb	cmp	cx, 0x28
1000:0cde	jne	loc_10ce4
1000:0ce0	mov	di, bx
1000:0ce2	jmp	loc_10ce7
        	loc_10ce4:
1000:0ce4	mov	di, 0
        	loc_10ce7:
1000:0ce7	shl	bx, 1
1000:0ce9	shl	bx, 1
1000:0ceb	add	di, bx
1000:0ced	mov	cl, al
1000:0cef	shr	ax, 1
1000:0cf1	shr	ax, 1
1000:0cf3	shr	ax, 1
1000:0cf5	add	di, ax
1000:0cf7	and	cl, 7
1000:0cfa	mov	ax, 0x80
1000:0cfd	shr	ax, cl
1000:0cff	mov	ah, al
1000:0d01	mov	bx, word ptr [0x942e]
1000:0d05	mov	es, bx
1000:0d07	pop	cx
1000:0d08	mov	cx, word ptr [bp + 6]
1000:0d0b	shr	cx, 1
1000:0d0d	mov	al, 8
1000:0d0f	pop	ds
1000:0d10	mov	bx, word ptr [bp + 4]
        	loc_10d13:
1000:0d13	push	ax
1000:0d14	push	bx
1000:0d15	push	cx
1000:0d16	push	di
1000:0d17	push	si
        	loc_10d18:
1000:0d18	mov	bh, byte ptr cs:[0xd96]
        	loc_10d1d:
1000:0d1d	mov	bl, byte ptr [si]
1000:0d1f	inc	si
1000:0d20	cmp	bh, bl
1000:0d22	jne	loc_10d3a
1000:0d24	shr	ah, 1
1000:0d26	jne	loc_10d2f
1000:0d28	mov	ah, 0x40
1000:0d2a	inc	di
1000:0d2b	loop	loc_10d1d
1000:0d2d	jmp	loc_10d6d
        	loc_10d2f:
1000:0d2f	shr	ah, 1
1000:0d31	jne	loc_10d36
1000:0d33	mov	ah, 0x80
1000:0d35	inc	di
        	loc_10d36:
1000:0d36	loop	loc_10d1d
1000:0d38	jmp	loc_10d6d
        	loc_10d3a:
1000:0d3a	mov	bh, bl
1000:0d3c	shr	bl, 1
1000:0d3e	shr	bl, 1
1000:0d40	shr	bl, 1
1000:0d42	shr	bl, 1
1000:0d44	cmp	bl, byte ptr cs:[0xd95]
1000:0d49	je	loc_10d4f
1000:0d4b	out	dx, ax
1000:0d4c	and	byte ptr es:[di], bl
        	loc_10d4f:
1000:0d4f	shr	ah, 1
1000:0d51	jne	loc_10d56
1000:0d53	mov	ah, 0x80
1000:0d55	inc	di
        	loc_10d56:
1000:0d56	and	bh, 0xf
1000:0d59	cmp	bh, byte ptr cs:[0xd95]
1000:0d5e	je	loc_10d64
1000:0d60	out	dx, ax
1000:0d61	and	byte ptr es:[di], bh
        	loc_10d64:
1000:0d64	shr	ah, 1
1000:0d66	jne	loc_10d6b
1000:0d68	mov	ah, 0x80
1000:0d6a	inc	di
        	loc_10d6b:
1000:0d6b	loop	loc_10d18
        	loc_10d6d:
1000:0d6d	pop	si
1000:0d6e	add	si, 0xa0
1000:0d72	pop	di
1000:0d73	add	di, word ptr cs:[0xd93]
1000:0d78	and	di, 0x7fff
1000:0d7c	pop	cx
1000:0d7d	pop	bx
1000:0d7e	pop	ax
1000:0d7f	dec	bx
1000:0d80	jne	loc_10d13
1000:0d82	pop	ds
1000:0d83	mov	ax, 0xff08
1000:0d86	out	dx, ax
1000:0d87	mov	ax, 5
1000:0d8a	out	dx, ax
1000:0d8b	mov	ax, 0xf07
1000:0d8e	out	dx, ax
        	loc_10d8f:
1000:0d8f	pop	bp
1000:0d90	ret	8
                sub_10c24 ENDP
*/
void sub_10c24()
{
    // coverage: 0xe24-0xf93 method sub_10c24
    push(bp);
    bp = sp;
    ax = memoryAGet16(ds, 0x9430);
    if (ax != 0x0000)
        goto loc_10c32;
    goto loc_10cbc;
loc_10c32:
    ax = memoryAGet16(ss, bp + 8 - 2);
    ax -= memoryAGet16(ds, 0x9528);
    ax &= 0x03ff;
    if (!(ax & 0x0200))
        goto loc_10c44;
    ax |= 0xfc00;
loc_10c44:
    memoryASet16(ss, bp + 8 - 2, ax);
    if ((short)ax >= (short)0x0000)
        goto loc_10c77;
    memoryASet16(ss, bp + 4 - 2, memoryAGet16(ss, bp + 4 - 2) + ax);
    if ((short)memoryAGet16(ss, bp + 4 - 2) >= 0)
        goto loc_10c54;
    goto loc_10d8f;
loc_10c54:
    if (memoryAGet16(ss, bp + 4 - 2) != 0)
        goto loc_10c59;
    goto loc_10d8f;
loc_10c59:
    ax = -ax;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    cx = ax;
    ax <<= 1;
    ax <<= 1;
    cx += ax;
    cx <<= 1;
    cx <<= 1;
    si += cx;
    ax = 0x0000;
    memoryASet16(ss, bp + 8 - 2, ax);
    goto loc_10c8f;
loc_10c77:
    ax += memoryAGet16(ss, bp + 4 - 2);
    ax -= 0x00a0;
    if ((short)ax < 0)
        goto loc_10c8f;
    ax = -ax;
    ax += memoryAGet16(ss, bp + 4 - 2);
    if ((short)ax > (short)0x0000)
        goto loc_10c8c;
    goto loc_10d8f;
loc_10c8c:
    memoryASet16(ss, bp + 4 - 2, ax);
loc_10c8f:
    ax = 0x0020;
    memoryASet16(ss, bp + 10 - 2, memoryAGet16(ss, bp + 10 - 2) + ax);
    ax = 0x0008;
    memoryASet16(ss, bp + 8 - 2, memoryAGet16(ss, bp + 8 - 2) + ax);
    ax = memoryAGet16(ss, bp + 10 - 2);
    if ((short)ax >= (short)0x0020)
        goto loc_10cab;
    ax = 0x0020;
    memoryASet16(ss, bp + 10 - 2, ax);
    goto loc_10cbc;
loc_10cab:
    ax += memoryAGet16(ss, bp + 6 - 2);
    if ((short)ax <= (short)0x0120)
        goto loc_10cbc;
    ax = 0x0120;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    memoryASet16(ss, bp + 10 - 2, ax);
loc_10cbc:
    push(ds);
    push(bx);
    dx = 0x03ce;
    ax = 0x0a05;
    out(dx, ax);
    ax = 0x0007;
    out(dx, ax);
    ax = memoryAGet16(ss, bp + 10 - 2);
    bx = memoryAGet16(ss, bp + 8 - 2);
    push(cx);
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    cx = memoryAGet16(cs, 0x0d93);
    if (cx != 0x0028)
        goto loc_10ce4;
    di = bx;
    goto loc_10ce7;
loc_10ce4:
    di = 0x0000;
loc_10ce7:
    bx <<= 1;
    bx <<= 1;
    di += bx;
    cl = al;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    di += ax;
    cl &= 0x07;
    ax = 0x0080;
    ax >>= cl;
    ah = al;
    bx = memoryAGet16(ds, 0x942e);
    es = bx;
    cx = pop();
    cx = memoryAGet16(ss, bp + 6 - 2);
    cx >>= 1;
    al = 0x08;
    ds = pop();
    bx = memoryAGet16(ss, bp + 4 - 2);
loc_10d13:
    push(ax);
    push(bx);
    push(cx);
    push(di);
    push(si);
loc_10d18:
    bh = memoryAGet(cs, 0x0d96);
loc_10d1d:
    bl = memoryAGet(ds, si);
    si++;
    if (bh != bl)
        goto loc_10d3a;
    ah >>= 1;
    if (ah != 0)
        goto loc_10d2f;
    ah = 0x40;
    di++;
    if (--cx)
        goto loc_10d1d;
    goto loc_10d6d;
loc_10d2f:
    ah >>= 1;
    if (ah != 0)
        goto loc_10d36;
    ah = 0x80;
    di++;
loc_10d36:
    if (--cx)
        goto loc_10d1d;
    goto loc_10d6d;
loc_10d3a:
    bh = bl;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    if (bl == memoryAGet(cs, 0x0d95))
        goto loc_10d4f;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bl);
loc_10d4f:
    ah >>= 1;
    if (ah != 0)
        goto loc_10d56;
    ah = 0x80;
    di++;
loc_10d56:
    bh &= 0x0f;
    if (bh == memoryAGet(cs, 0x0d95))
        goto loc_10d64;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bh);
loc_10d64:
    ah >>= 1;
    if (ah != 0)
        goto loc_10d6b;
    ah = 0x80;
    di++;
loc_10d6b:
    if (--cx)
        goto loc_10d18;
loc_10d6d:
    si = pop();
    si += 0x00a0;
    di = pop();
    di += memoryAGet16(cs, 0x0d93);
    di &= 0x7fff;
    cx = pop();
    bx = pop();
    ax = pop();
    tx = bx;
    bx--;
    if (tx != 1)
        goto loc_10d13;
    ds = pop();
    ax = 0xff08;
    out(dx, ax);
    ax = 0x0005;
    out(dx, ax);
    ax = 0x0f07;
    out(dx, ax);
loc_10d8f:
    bp = pop();
    sp += 8;
}
/* Assembly listing of 1000:0d98 sub_10d98()
                sub_10d98 PROC
1000:0d98	mov	word ptr [0x9528], 0x1a
1000:0d9e	mov	byte ptr [0x9513], 0
1000:0da3	call	0xb7c
1000:0da6	ret	
                sub_10d98 ENDP
*/
void sub_10d98()
{
    // coverage: 0xf98-0xfa7 method sub_10d98
    memoryASet16(ds, 0x9528, 0x001a);
    memoryASet(ds, 0x9513, 0x00);
    sub_10b7c();
}
/* Assembly listing of 1000:0da7 sub_10da7()
                sub_10da7 PROC
1000:0da7	call	0x9a4
1000:0daa	call	0x69a
1000:0dad	mov	byte ptr [0x9519], 0
1000:0db2	mov	byte ptr [0x951a], 0
1000:0db7	mov	byte ptr [0x951b], 0
1000:0dbc	call	0xe3d
1000:0dbf	ret	
                sub_10da7 ENDP
*/
void sub_10da7()
{
    // coverage: 0xfa7-0xfc0 method sub_10da7
    sub_109a4();
    sub_1069a();
    memoryASet(ds, 0x9519, 0x00);
    memoryASet(ds, 0x951a, 0x00);
    memoryASet(ds, 0x951b, 0x00);
    sub_10e3d();
}
/* Assembly listing of 1000:0dc0 sub_10dc0()
                sub_10dc0 PROC
1000:0dc0	inc	byte ptr [0x94fe]
1000:0dc4	mov	al, byte ptr [0x94fe]
1000:0dc7	cmp	al, 6
1000:0dc9	jb	loc_10dd3
1000:0dcb	mov	word ptr [0x94fc], 0x30
1000:0dd1	jmp	loc_10de5
        	loc_10dd3:
1000:0dd3	cmp	al, 3
1000:0dd5	jb	loc_10ddf
1000:0dd7	mov	word ptr [0x94fc], 0x20
1000:0ddd	jmp	loc_10de5
        	loc_10ddf:
1000:0ddf	mov	word ptr [0x94fc], 0x10
        	loc_10de5:
1000:0de5	inc	byte ptr [0x9501]
1000:0de9	mov	al, byte ptr [0x9501]
1000:0dec	cmp	al, 7
1000:0dee	jbe	loc_10df5
1000:0df0	mov	byte ptr [0x9501], 1
        	loc_10df5:
1000:0df5	call	0x9a4
1000:0df8	call	0x69a
1000:0dfb	mov	byte ptr [0x9519], 0
1000:0e00	call	0xe3d
1000:0e03	call	0x2a7f
1000:0e06	ret	
                sub_10dc0 ENDP
*/
void sub_10dc0()
{
    // coverage: 0xfc0-0x1007 method sub_10dc0
    memoryASet(ds, 0x94fe, memoryAGet(ds, 0x94fe) + 1);
    al = memoryAGet(ds, 0x94fe);
    if (al < 0x06)
        goto loc_10dd3;
    memoryASet16(ds, 0x94fc, 0x0030);
    goto loc_10de5;
loc_10dd3:
    if (al < 0x03)
        goto loc_10ddf;
    memoryASet16(ds, 0x94fc, 0x0020);
    goto loc_10de5;
loc_10ddf:
    memoryASet16(ds, 0x94fc, 0x0010);
loc_10de5:
    memoryASet(ds, 0x9501, memoryAGet(ds, 0x9501) + 1);
    al = memoryAGet(ds, 0x9501);
    if (al <= 0x07)
        goto loc_10df5;
    memoryASet(ds, 0x9501, 0x01);
loc_10df5:
    sub_109a4();
    sub_1069a();
    memoryASet(ds, 0x9519, 0x00);
    sub_10e3d();
    sub_12a7f();
}
/* Assembly listing of 1000:0e07 sub_10e07()
                sub_10e07 PROC
1000:0e07	mov	ax, word ptr [0x9534]
1000:0e0a	cmp	ax, 0
1000:0e0d	jne	loc_10e15
1000:0e0f	mov	byte ptr [0x9500], 1
1000:0e14	ret	
        	loc_10e15:
1000:0e15	call	0x2329
1000:0e18	mov	al, byte ptr [0x9502]
1000:0e1b	cmp	al, 0
1000:0e1d	je	loc_10e27
1000:0e1f	mov	byte ptr [0x9502], 0
1000:0e24	call	0x69a
        	loc_10e27:
1000:0e27	call	0x2200
1000:0e2a	mov	byte ptr [0x9519], 1
1000:0e2f	mov	byte ptr [0x951a], 0
1000:0e34	mov	byte ptr [0x951b], 0
1000:0e39	call	0xe3d
1000:0e3c	ret	
                sub_10e07 ENDP
*/
void sub_10e07()
{
    // coverage: 0x1007-0x103d method sub_10e07
    ax = memoryAGet16(ds, 0x9534);
    if (ax != 0x0000)
        goto loc_10e15;
    memoryASet(ds, 0x9500, 0x01);
    return;
loc_10e15:
    sub_12329();
    al = memoryAGet(ds, 0x9502);
    if (al == 0x00)
        goto loc_10e27;
    memoryASet(ds, 0x9502, 0x00);
    sub_1069a();
loc_10e27:
    sub_12200();
    memoryASet(ds, 0x9519, 0x01);
    memoryASet(ds, 0x951a, 0x00);
    memoryASet(ds, 0x951b, 0x00);
    sub_10e3d();
}
/* Assembly listing of 1000:0e3d sub_10e3d()
                sub_10e3d PROC
1000:0e3d	mov	bl, byte ptr [0x9501]
1000:0e41	mov	bh, 0
1000:0e43	shl	bx, 1
1000:0e45	mov	ax, word ptr [bx + 0x14f5]
1000:0e49	and	ax, 0x3ff
1000:0e4c	mov	word ptr [0x9528], ax
1000:0e4f	mov	ax, word ptr [0x94fc]
1000:0e52	mov	word ptr [0x952a], ax
1000:0e55	mov	word ptr [0x950a], 0x80
1000:0e5b	mov	byte ptr [0x950e], 0
1000:0e60	mov	word ptr [0x950f], 0
1000:0e66	mov	word ptr [0x9511], 0
1000:0e6c	mov	byte ptr [0x9513], 0
1000:0e71	mov	byte ptr [0x9515], 0
1000:0e76	mov	byte ptr [0x9517], 0
1000:0e7b	mov	byte ptr [0x9432], 0
1000:0e80	call	0xe84
1000:0e83	ret	
                sub_10e3d ENDP
*/
void sub_10e3d()
{
    // coverage: 0x103d-0x1084 method sub_10e3d
    bl = memoryAGet(ds, 0x9501);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5365);
    ax &= 0x03ff;
    memoryASet16(ds, 0x9528, ax);
    ax = memoryAGet16(ds, 0x94fc);
    memoryASet16(ds, 0x952a, ax);
    memoryASet16(ds, 0x950a, 0x0080);
    memoryASet(ds, 0x950e, 0x00);
    memoryASet16(ds, 0x950f, 0x0000);
    memoryASet16(ds, 0x9511, 0x0000);
    memoryASet(ds, 0x9513, 0x00);
    memoryASet(ds, 0x9515, 0x00);
    memoryASet(ds, 0x9517, 0x00);
    memoryASet(ds, 0x9432, 0x00);
    sub_10e84();
}
/* Assembly listing of 1000:0e84 sub_10e84()
                sub_10e84 PROC
1000:0e84	mov	al, byte ptr [0x950e]
1000:0e87	cmp	al, 0
1000:0e89	je	loc_10e93
1000:0e8b	mov	byte ptr [0x950e], 0
1000:0e90	call	0x69a
        	loc_10e93:
1000:0e93	mov	word ptr [0x952c], 0
1000:0e99	call	0xb7c
1000:0e9c	mov	si, 0xd32
1000:0e9f	call	0xb58
1000:0ea2	mov	ax, word ptr [0x950a]
1000:0ea5	mov	word ptr [0x1b8f], ax
1000:0ea8	call	0x1b57
1000:0eab	mov	ax, word ptr [0x9528]
1000:0eae	shr	ax, 1
1000:0eb0	shr	ax, 1
1000:0eb2	shr	ax, 1
1000:0eb4	shr	ax, 1
1000:0eb6	sub	ax, 3
1000:0eb9	and	ax, 0x3f
1000:0ebc	mov	word ptr [0x9507], ax
1000:0ebf	mov	cx, 0xf
        	loc_10ec2:
1000:0ec2	push	cx
1000:0ec3	push	ax
1000:0ec4	push	ax
1000:0ec5	call	0x8ba
1000:0ec8	pop	ax
1000:0ec9	pop	cx
1000:0eca	inc	ax
1000:0ecb	and	ax, 0x3f
1000:0ece	loop	loc_10ec2
1000:0ed0	mov	al, byte ptr [0x9432]
1000:0ed3	cmp	al, 0
1000:0ed5	je	loc_10eea
1000:0ed7	mov	si, 0x1b8a
1000:0eda	mov	bx, 0xd49
1000:0edd	mov	byte ptr [si + 4], 0xa
1000:0ee1	call	0x2121
1000:0ee4	mov	byte ptr [0x1b9c], 0x23
1000:0ee9	ret	
        	loc_10eea:
1000:0eea	mov	al, byte ptr [0x9519]
1000:0eed	cmp	al, 0
1000:0eef	je	loc_10f08
1000:0ef1	mov	byte ptr [0x9519], 0
1000:0ef6	mov	si, 0xda2
1000:0ef9	mov	ax, word ptr [0x1b91]
1000:0efc	mov	word ptr [si + 7], ax
1000:0eff	mov	al, byte ptr [0x1b8d]
1000:0f02	mov	byte ptr [si + 3], al
1000:0f05	call	0xb58
        	loc_10f08:
1000:0f08	call	0xf9d
1000:0f0b	mov	al, byte ptr [0x951a]
1000:0f0e	cmp	al, 0
1000:0f10	je	loc_10f23
1000:0f12	mov	byte ptr [0x951a], 1
1000:0f17	mov	si, 0xdc3
1000:0f1a	and	byte ptr [si], 0xdf
1000:0f1d	call	0x1cd9
1000:0f20	call	0xb58
        	loc_10f23:
1000:0f23	mov	al, byte ptr [0x951b]
1000:0f26	cmp	al, 0
1000:0f28	je	loc_10f3b
1000:0f2a	mov	byte ptr [0x951b], 1
1000:0f2f	mov	si, 0xdc3
1000:0f32	or	byte ptr [si], 0x20
1000:0f35	call	0x1cd9
1000:0f38	call	0xb58
        	loc_10f3b:
1000:0f3b	ret	
                sub_10e84 ENDP
*/
void sub_10e84()
{
    // coverage: 0x1084-0x113c method sub_10e84
    al = memoryAGet(ds, 0x950e);
    if (al == 0x00)
        goto loc_10e93;
    memoryASet(ds, 0x950e, 0x00);
    sub_1069a();
loc_10e93:
    memoryASet16(ds, 0x952c, 0x0000);
    sub_10b7c();
    si = 0x0d32;
    sub_10b58();
    ax = memoryAGet16(ds, 0x950a);
    memoryASet16(ds, 0x1b8f, ax);
    sub_11b57();
    ax = memoryAGet16(ds, 0x9528);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax -= 0x0003;
    ax &= 0x003f;
    memoryASet16(ds, 0x9507, ax);
    cx = 0x000f;
loc_10ec2:
    push(cx);
    push(ax);
    push(ax);
    sub_108ba();
    ax = pop();
    cx = pop();
    ax++;
    ax &= 0x003f;
    if (--cx)
        goto loc_10ec2;
    al = memoryAGet(ds, 0x9432);
    if (al == 0x00)
        goto loc_10eea;
    si = 0x1b8a;
    bx = 0x0d49;
    memoryASet(ds, si + 4, 0x0a);
    sub_12121();
    memoryASet(ds, 0x1b9c, 0x23);
    return;
loc_10eea:
    al = memoryAGet(ds, 0x9519);
    if (al == 0x00)
        goto loc_10f08;
    memoryASet(ds, 0x9519, 0x00);
    si = 0x0da2;
    ax = memoryAGet16(ds, 0x1b91);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1b8d);
    memoryASet(ds, si + 3, al);
    sub_10b58();
loc_10f08:
    sub_10f9d();
    al = memoryAGet(ds, 0x951a);
    if (al == 0x00)
        goto loc_10f23;
    memoryASet(ds, 0x951a, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    sub_11cd9();
    sub_10b58();
loc_10f23:
    al = memoryAGet(ds, 0x951b);
    if (al == 0x00)
        return;
    memoryASet(ds, 0x951b, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    sub_11cd9();
    sub_10b58();
}
/* Assembly listing of 1000:0f3c sub_10f3c()
                sub_10f3c PROC
1000:0f3c	mov	byte ptr [0x951c], 0
1000:0f41	call	0x2ddc
1000:0f44	mov	word ptr [0x9528], 0x1a
1000:0f4a	mov	word ptr [0x9547], 0
1000:0f50	mov	word ptr [0x951e], 0
1000:0f56	mov	byte ptr [0x9524], 0
1000:0f5b	mov	byte ptr [0x9549], 3
1000:0f60	call	0xb7c
1000:0f63	mov	si, 0xd04
1000:0f66	call	0xb58
1000:0f69	call	0x2df6
1000:0f6c	mov	al, byte ptr [0x951a]
1000:0f6f	cmp	al, 0
1000:0f71	je	loc_10f84
1000:0f73	mov	byte ptr [0x951a], 1
1000:0f78	mov	si, 0xd1b
1000:0f7b	and	byte ptr [si], 0xdf
1000:0f7e	call	0x2f50
1000:0f81	call	0xb58
        	loc_10f84:
1000:0f84	mov	al, byte ptr [0x951b]
1000:0f87	cmp	al, 0
1000:0f89	je	loc_10f9c
1000:0f8b	mov	byte ptr [0x951b], 1
1000:0f90	mov	si, 0xd1b
1000:0f93	or	byte ptr [si], 0x20
1000:0f96	call	0x2f50
1000:0f99	call	0xb58
        	loc_10f9c:
1000:0f9c	ret	
                sub_10f3c ENDP
*/
void sub_10f3c()
{
    // coverage: 0x113c-0x119d method sub_10f3c
    memoryASet(ds, 0x951c, 0x00);
    sub_12ddc();
    memoryASet16(ds, 0x9528, 0x001a);
    memoryASet16(ds, 0x9547, 0x0000);
    memoryASet16(ds, 0x951e, 0x0000);
    memoryASet(ds, 0x9524, 0x00);
    memoryASet(ds, 0x9549, 0x03);
    sub_10b7c();
    si = 0x0d04;
    sub_10b58();
    sub_12df6();
    al = memoryAGet(ds, 0x951a);
    if (al == 0x00)
        goto loc_10f84;
    memoryASet(ds, 0x951a, 0x01);
    si = 0x0d1b;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    sub_12f50();
    sub_10b58();
loc_10f84:
    al = memoryAGet(ds, 0x951b);
    if (al == 0x00)
        return;
    memoryASet(ds, 0x951b, 0x01);
    si = 0x0d1b;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    sub_12f50();
    sub_10b58();
}
/* Assembly listing of 1000:0f9d sub_10f9d()
                sub_10f9d PROC
1000:0f9d	mov	ax, word ptr [0x1b8f]
1000:0fa0	mov	word ptr [0x9433], ax
1000:0fa3	mov	word ptr [0x9435], ax
1000:0fa6	mov	word ptr [0x9437], ax
1000:0fa9	mov	word ptr [0x9439], ax
1000:0fac	mov	ax, word ptr [0x1b91]
1000:0faf	mov	word ptr [0x943b], ax
1000:0fb2	mov	word ptr [0x943d], ax
1000:0fb5	mov	word ptr [0x943f], ax
1000:0fb8	mov	word ptr [0x9441], ax
1000:0fbb	mov	al, byte ptr [0x1b8e]
1000:0fbe	mov	byte ptr [0x9443], al
1000:0fc1	mov	byte ptr [0x9444], al
1000:0fc4	mov	byte ptr [0x9445], al
1000:0fc7	mov	byte ptr [0x9446], al
1000:0fca	mov	al, byte ptr [0x1b8d]
1000:0fcd	mov	byte ptr [0x9447], al
1000:0fd0	mov	byte ptr [0x9448], al
1000:0fd3	mov	byte ptr [0x9449], al
1000:0fd6	mov	byte ptr [0x944a], al
1000:0fd9	ret	
                sub_10f9d ENDP
*/
void sub_10f9d()
{
    // coverage: 0x119d-0x11da method sub_10f9d
    ax = memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, 0x9433, ax);
    memoryASet16(ds, 0x9435, ax);
    memoryASet16(ds, 0x9437, ax);
    memoryASet16(ds, 0x9439, ax);
    ax = memoryAGet16(ds, 0x1b91);
    memoryASet16(ds, 0x943b, ax);
    memoryASet16(ds, 0x943d, ax);
    memoryASet16(ds, 0x943f, ax);
    memoryASet16(ds, 0x9441, ax);
    al = memoryAGet(ds, 0x1b8e);
    memoryASet(ds, 0x9443, al);
    memoryASet(ds, 0x9444, al);
    memoryASet(ds, 0x9445, al);
    memoryASet(ds, 0x9446, al);
    al = memoryAGet(ds, 0x1b8d);
    memoryASet(ds, 0x9447, al);
    memoryASet(ds, 0x9448, al);
    memoryASet(ds, 0x9449, al);
    memoryASet(ds, 0x944a, al);
}
/* Assembly listing of 1000:0fda sub_10fda()
                sub_10fda PROC
        	loc_10fda:
1000:0fda	mov	al, byte ptr [0x94ff]
1000:0fdd	mov	byte ptr [0x9509], al
1000:0fe0	mov	si, 0x1b8a
        	loc_10fe3:
1000:0fe3	mov	al, byte ptr [0x9513]
1000:0fe6	cmp	al, 0
1000:0fe8	je	loc_10ff5
1000:0fea	call	0xe07
1000:0fed	mov	al, byte ptr [0x9500]
1000:0ff0	cmp	al, 0
1000:0ff2	je	loc_10fda
1000:0ff4	ret	
        	loc_10ff5:
1000:0ff5	mov	al, byte ptr [0x94ff]
1000:0ff8	cmp	al, byte ptr [0x9509]
1000:0ffc	je	loc_11036
1000:0ffe	cmp	al, 1
1000:1000	jne	loc_1100e
1000:1002	mov	al, 0xb
1000:1004	call	0x3840
1000:1007	call	0xf3c
1000:100a	jmp	loc_10fda
1000:100c		
        	loc_1100e:
1000:100e	mov	al, 0xb
1000:1010	call	0x3840
1000:1013	mov	al, byte ptr [0x951d]
1000:1016	cmp	al, 0xf0
1000:1018	jne	loc_1101f
1000:101a	call	0xdc0
1000:101d	jmp	loc_11034
        	loc_1101f:
1000:101f	mov	al, byte ptr [0x1ba0]
1000:1022	and	al, 0x7f
1000:1024	cmp	al, 0x28
1000:1026	jbe	loc_11031
1000:1028	cmp	al, 0x58
1000:102a	jae	loc_11031
1000:102c	mov	byte ptr [0x9432], 1
        	loc_11031:
1000:1031	call	0xe84
        	loc_11034:
1000:1034	jmp	loc_10fda
        	loc_11036:
1000:1036	mov	al, byte ptr [si]
1000:1038	test	al, 0x80
1000:103a	jne	loc_11059
1000:103c	test	al, 2
1000:103e	je	loc_11054
1000:1040	push	si
1000:1041	mov	bl, byte ptr [si + 0x12]
1000:1044	cmp	bl, 0
1000:1047	je	loc_11053
1000:1049	mov	bh, 0
1000:104b	dec	bx
1000:104c	shl	bx, 1
1000:104e	call	word ptr cs:[bx + 0x105a]
        	loc_11053:
1000:1053	pop	si
        	loc_11054:
1000:1054	add	si, 0x17
1000:1057	jmp	loc_10fe3
        	loc_11059:
1000:1059	ret	
                sub_10fda ENDP
*/
void sub_10fda()
{
    // coverage: 0x11da-0x120c method sub_10fda
    // coverage: 0x120e-0x125a method sub_10fda
loc_10fda:
    al = memoryAGet(ds, 0x94ff);
    memoryASet(ds, 0x9509, al);
    si = 0x1b8a;
loc_10fe3:
    al = memoryAGet(ds, 0x9513);
    if (al == 0x00)
        goto loc_10ff5;
    sub_10e07();
    al = memoryAGet(ds, 0x9500);
    if (al == 0x00)
        goto loc_10fda;
    return;
loc_10ff5:
    al = memoryAGet(ds, 0x94ff);
    if (al == memoryAGet(ds, 0x9509))
        goto loc_11036;
    if (al != 0x01)
        goto loc_1100e;
    al = 0x0b;
    sub_13840();
    sub_10f3c();
    goto loc_10fda;
    //   gap of 2 bytes
loc_1100e:
    al = 0x0b;
    sub_13840();
    al = memoryAGet(ds, 0x951d);
    if (al != 0xf0)
        goto loc_1101f;
    sub_10dc0();
    goto loc_11034;
loc_1101f:
    al = memoryAGet(ds, 0x1ba0);
    al &= 0x7f;
    if (al <= 0x28)
        goto loc_11031;
    if (al >= 0x58)
        goto loc_11031;
    memoryASet(ds, 0x9432, 0x01);
loc_11031:
    sub_10e84();
loc_11034:
    goto loc_10fda;
loc_11036:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        return;
    if (!(al & 0x02))
        goto loc_11054;
    push(si);
    bl = memoryAGet(ds, si + 18);
    if (bl == 0x00)
        goto loc_11053;
    bh = 0x00;
    bx--;
    bx <<= 1;
    assert(cs == 0x1000);
    switch (bx)
    {
        case 0: sub_11108(); break;
        case 2: sub_1176c(); break;
        case 4: sub_11783(); break;
        case 6: sub_110c6(); break;
        case 8: sub_117ac(); break;
        case 10: sub_117d6(); break;
        case 12: sub_118a9(); break;
        case 14: sub_11a9e(); break;
        case 16: sub_110c6(); break;
        case 18: sub_11993(); break;
        case 20: sub_119c2(); break;
        case 22: sub_12e02(); break;
        case 24: sub_110c6(); break;
        case 26: sub_12fe8(); break;
        case 28: sub_1300a(); break;
        case 30: sub_116fe(); break;
        case 32: sub_112cb(); break;
        case 34: sub_110c6(); break;
        case 36: sub_112eb(); break;
        case 38: sub_115fc(); break;
        case 40: sub_116df(); break;
        case 42: sub_116d6(); break;
        case 44: sub_11740(); break;
        case 46: sub_11384(); break;
        case 48: sub_113a8(); break;
        case 50: sub_114f0(); break;
        case 52: sub_110f3(); break;
        case 54: sub_118c7(); break;
        case 56: sub_11429(); break;
        case 58: sub_117f4(); break;
        case 60: sub_1171f(); break;
        case 62: sub_11b09(); break;
        case 64: sub_11b4a(); break;
        case 66: sub_12f50(); break;
        case 68: sub_112a7(); break;
        default:
        assert(0);
    }
loc_11053:
    si = pop();
loc_11054:
    si += 0x0017;
    goto loc_10fe3;
}
/* Assembly listing of 1000:10a0 sub_110a0()
                sub_110a0 PROC
1000:10a0	mov	al, byte ptr [si + 0xa]
1000:10a3	sub	al, byte ptr [si + 3]
1000:10a6	sub	al, byte ptr [si + 0xc]
1000:10a9	cwde	
1000:10aa	add	ax, word ptr [si + 7]
1000:10ad	and	ax, 0x3ff
1000:10b0	mov	bx, word ptr [0x9528]
1000:10b4	cmp	ax, bx
1000:10b6	jae	loc_110bb
1000:10b8	add	ax, 0x400
        	loc_110bb:
1000:10bb	sub	ax, bx
1000:10bd	cmp	ax, 0x200
1000:10c0	jbe	loc_110c5
1000:10c2	mov	byte ptr [si], 0
        	loc_110c5:
1000:10c5	ret	
                sub_110a0 ENDP
*/
void sub_110a0()
{
    // coverage: 0x12a0-0x12c6 method sub_110a0
    al = memoryAGet(ds, si + 10);
    al -= memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, si + 12);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    bx = memoryAGet16(ds, 0x9528);
    if (ax >= bx)
        goto loc_110bb;
    ax += 0x0400;
loc_110bb:
    ax -= bx;
    if (ax <= 0x0200)
        return;
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:10c6 sub_110c6()
                sub_110c6 PROC
1000:10c6	mov	al, byte ptr [si + 3]
1000:10c9	add	al, byte ptr [si + 0xc]
1000:10cc	cwde	
1000:10cd	neg	ax
1000:10cf	add	ax, word ptr [si + 7]
1000:10d2	and	ax, 0x3ff
1000:10d5	mov	bx, word ptr [0x9528]
1000:10d9	add	bx, 0xa0
1000:10dd	and	bx, 0x3ff
1000:10e1	cmp	ax, bx
1000:10e3	jae	loc_110e8
1000:10e5	add	ax, 0x400
        	loc_110e8:
1000:10e8	sub	ax, bx
1000:10ea	cmp	ax, 0x200
1000:10ed	jae	loc_110f2
1000:10ef	mov	byte ptr [si], 0
        	loc_110f2:
1000:10f2	ret	
                sub_110c6 ENDP
*/
void sub_110c6()
{
    // coverage: 0x12c6-0x12f3 method sub_110c6
    al = memoryAGet(ds, si + 3);
    al += memoryAGet(ds, si + 12);
    cbw();
    ax = -ax;
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    bx = memoryAGet16(ds, 0x9528);
    bx += 0x00a0;
    bx &= 0x03ff;
    if (ax >= bx)
        goto loc_110e8;
    ax += 0x0400;
loc_110e8:
    ax -= bx;
    if (ax >= 0x0200)
        return;
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:10f3 sub_110f3()
                sub_110f3 PROC
1000:10f3	inc	byte ptr [si + 0x16]
1000:10f6	mov	al, byte ptr [si + 0x16]
1000:10f9	cmp	al, 8
1000:10fb	jbe	loc_110ff
1000:10fd	mov	al, 8
        	loc_110ff:
1000:10ff	mov	ah, 0
1000:1101	sub	word ptr [si + 7], ax
1000:1104	call	0x10a0
1000:1107	ret	
                sub_110f3 ENDP
*/
void sub_110f3()
{
    // coverage: 0x12f3-0x1308 method sub_110f3
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    if (al <= 0x08)
        goto loc_110ff;
    al = 0x08;
loc_110ff:
    ah = 0x00;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - ax);
    sub_110a0();
}
/* Assembly listing of 1000:1108 sub_11108()
                sub_11108 PROC
1000:1108	call	0x1b80
1000:110b	call	0x1bb9
1000:110e	mov	bx, word ptr [0x954c]
1000:1112	mov	ax, word ptr [0x952c]
1000:1115	test	bl, 1
1000:1118	je	loc_11131
1000:111a	sub	ax, 1
1000:111d	js	loc_11127
1000:111f	cmp	ax, 4
1000:1122	jle	loc_11127
1000:1124	mov	ax, 4
        	loc_11127:
1000:1127	cmp	ax, 0xffe8
1000:112a	jge	loc_1112f
1000:112c	mov	ax, 0xffe8
        	loc_1112f:
1000:112f	jmp	loc_11158
        	loc_11131:
1000:1131	test	bl, 2
1000:1134	je	loc_1114d
1000:1136	add	ax, 1
1000:1139	jns	loc_11143
1000:113b	cmp	ax, 0xfffc
1000:113e	jge	loc_11143
1000:1140	mov	ax, 0xfffc
        	loc_11143:
1000:1143	cmp	ax, 0x18
1000:1146	jle	loc_1114b
1000:1148	mov	ax, 0x18
        	loc_1114b:
1000:114b	jmp	loc_11158
        	loc_1114d:
1000:114d	cmp	ax, 0
1000:1150	je	loc_11158
1000:1152	jle	loc_11157
1000:1154	dec	ax
1000:1155	jmp	loc_11158
        	loc_11157:
1000:1157	inc	ax
        	loc_11158:
1000:1158	mov	word ptr [0x952c], ax
1000:115b	add	ax, 3
1000:115e	sar	ax, 1
1000:1160	sar	ax, 1
1000:1162	add	ax, word ptr [0x1b8f]
1000:1166	cmp	ax, 0x14
1000:1169	jge	loc_11174
1000:116b	mov	ax, 0x14
1000:116e	mov	word ptr [0x952c], 0
        	loc_11174:
1000:1174	cmp	ax, 0xec
1000:1177	jle	loc_11182
1000:1179	mov	ax, 0xec
1000:117c	mov	word ptr [0x952c], 0
        	loc_11182:
1000:1182	mov	word ptr [0x1b8f], ax
1000:1185	mov	al, byte ptr [0x1b8e]
1000:1188	cmp	al, 0
1000:118a	je	loc_1118f
1000:118c	call	0x1b57
        	loc_1118f:
1000:118f	call	0x1c78
1000:1192	call	0xa51
1000:1195	cmp	ax, 0
1000:1198	je	loc_1119f
1000:119a	call	0x1c56
1000:119d	jmp	loc_111bc
        	loc_1119f:
1000:119f	inc	byte ptr [0x1b9e]
1000:11a3	and	byte ptr [0x1b9e], 0x3f
1000:11a8	call	0xa51
1000:11ab	cmp	ax, 0
1000:11ae	je	loc_111b3
1000:11b0	call	0x1c56
        	loc_111b3:
1000:11b3	dec	byte ptr [0x1b9e]
1000:11b7	and	byte ptr [0x1b9e], 0x3f
        	loc_111bc:
1000:11bc	mov	ax, word ptr [0x9542]
1000:11bf	cmp	ax, 0
1000:11c2	jg	loc_111c8
1000:11c4	call	0x1c33
1000:11c7	ret	
        	loc_111c8:
1000:11c8	mov	al, byte ptr [0x1b8e]
1000:11cb	cmp	al, 0
1000:11cd	jne	loc_111de
1000:11cf	inc	byte ptr [0x9515]
1000:11d3	mov	al, byte ptr [0x9515]
1000:11d6	cmp	al, 4
1000:11d8	jb	loc_111dd
1000:11da	call	0x1c33
        	loc_111dd:
1000:11dd	ret	
        	loc_111de:
1000:11de	mov	ax, word ptr [0x953e]
1000:11e1	cmp	ax, 0
1000:11e4	jle	loc_111f0
1000:11e6	mov	ax, word ptr [0x954c]
1000:11e9	test	al, 0x80
1000:11eb	je	loc_111f0
1000:11ed	call	0x1d1e
        	loc_111f0:
1000:11f0	mov	ax, word ptr [0x954c]
1000:11f3	mov	bl, byte ptr [0x951a]
1000:11f7	test	al, 0x40
1000:11f9	je	loc_11235
1000:11fb	cmp	bl, 0
1000:11fe	jne	loc_11224
1000:1200	mov	ax, word ptr [0x9536]
1000:1203	cmp	ax, 0
1000:1206	jbe	loc_11222
1000:1208	mov	byte ptr [0x951a], 1
1000:120d	mov	si, 0xdc3
1000:1210	and	byte ptr [si], 0xdf
1000:1213	call	0x1cd9
1000:1216	call	0xb58
1000:1219	dec	word ptr [0x9538]
1000:121d	mov	al, 1
1000:121f	call	0x3840
        	loc_11222:
1000:1222	jmp	loc_11233
        	loc_11224:
1000:1224	cmp	bl, 2
1000:1227	jne	loc_11233
1000:1229	mov	byte ptr [0x951a], 3
1000:122e	mov	al, 2
1000:1230	call	0x3840
        	loc_11233:
1000:1233	jmp	loc_1124b
        	loc_11235:
1000:1235	cmp	bl, 1
1000:1238	jne	loc_11241
1000:123a	mov	byte ptr [0x951a], 2
1000:123f	jmp	loc_1124b
        	loc_11241:
1000:1241	cmp	bl, 3
1000:1244	jne	loc_1124b
1000:1246	mov	byte ptr [0x951a], 0
        	loc_1124b:
1000:124b	mov	ax, word ptr [0x954c]
1000:124e	mov	bl, byte ptr [0x951b]
1000:1252	test	al, 0x20
1000:1254	je	loc_11290
1000:1256	cmp	bl, 0
1000:1259	jne	loc_1127f
1000:125b	mov	ax, word ptr [0x9536]
1000:125e	cmp	ax, 0
1000:1261	jbe	loc_1127d
1000:1263	mov	byte ptr [0x951b], 1
1000:1268	mov	si, 0xdc3
1000:126b	or	byte ptr [si], 0x20
1000:126e	call	0x1cd9
1000:1271	call	0xb58
1000:1274	dec	word ptr [0x9538]
1000:1278	mov	al, 1
1000:127a	call	0x3840
        	loc_1127d:
1000:127d	jmp	loc_1128e
        	loc_1127f:
1000:127f	cmp	bl, 2
1000:1282	jne	loc_1128e
1000:1284	mov	byte ptr [0x951b], 3
1000:1289	mov	al, 2
1000:128b	call	0x3840
        	loc_1128e:
1000:128e	jmp	loc_112a6
        	loc_11290:
1000:1290	cmp	bl, 1
1000:1293	jne	loc_1129c
1000:1295	mov	byte ptr [0x951b], 2
1000:129a	jmp	loc_112a6
        	loc_1129c:
1000:129c	cmp	bl, 3
1000:129f	jne	loc_112a6
1000:12a1	mov	byte ptr [0x951b], 0
        	loc_112a6:
1000:12a6	ret	
                sub_11108 ENDP
*/
void sub_11108()
{
    // coverage: 0x1308-0x14a7 method sub_11108
    sub_11b80();
    sub_11bb9();
    bx = memoryAGet16(ds, 0x954c);
    ax = memoryAGet16(ds, 0x952c);
    if (!(bl & 0x01))
        goto loc_11131;
    ax -= 0x0001;
    if ((short)ax < 0)
        goto loc_11127;
    if ((short)ax <= (short)0x0004)
        goto loc_11127;
    ax = 0x0004;
loc_11127:
    if ((short)ax >= (short)0xffe8)
        goto loc_1112f;
    ax = 0xffe8;
loc_1112f:
    goto loc_11158;
loc_11131:
    if (!(bl & 0x02))
        goto loc_1114d;
    ax += 0x0001;
    if ((short)ax >= 0)
        goto loc_11143;
    if ((short)ax >= (short)0xfffc)
        goto loc_11143;
    ax = 0xfffc;
loc_11143:
    if ((short)ax <= (short)0x0018)
        goto loc_1114b;
    ax = 0x0018;
loc_1114b:
    goto loc_11158;
loc_1114d:
    if (ax == 0x0000)
        goto loc_11158;
    if ((short)ax <= (short)0x0000)
        goto loc_11157;
    ax--;
    goto loc_11158;
loc_11157:
    ax++;
loc_11158:
    memoryASet16(ds, 0x952c, ax);
    ax += 0x0003;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax += memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= (short)0x0014)
        goto loc_11174;
    ax = 0x0014;
    memoryASet16(ds, 0x952c, 0x0000);
loc_11174:
    if ((short)ax <= (short)0x00ec)
        goto loc_11182;
    ax = 0x00ec;
    memoryASet16(ds, 0x952c, 0x0000);
loc_11182:
    memoryASet16(ds, 0x1b8f, ax);
    al = memoryAGet(ds, 0x1b8e);
    if (al == 0x00)
        goto loc_1118f;
    sub_11b57();
loc_1118f:
    sub_11c78();
    sub_10a51();
    if (ax == 0x0000)
        goto loc_1119f;
    sub_11c56();
    goto loc_111bc;
loc_1119f:
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) + 1);
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) & 0x3f);
    sub_10a51();
    if (ax == 0x0000)
        goto loc_111b3;
    sub_11c56();
loc_111b3:
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) - 1);
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) & 0x3f);
loc_111bc:
    ax = memoryAGet16(ds, 0x9542);
    if ((short)ax > (short)0x0000)
        goto loc_111c8;
    sub_11c33();
    return;
loc_111c8:
    al = memoryAGet(ds, 0x1b8e);
    if (al != 0x00)
        goto loc_111de;
    memoryASet(ds, 0x9515, memoryAGet(ds, 0x9515) + 1);
    al = memoryAGet(ds, 0x9515);
    if (al < 0x04)
        goto loc_111dd;
    sub_11c33();
loc_111dd:
    return;
loc_111de:
    ax = memoryAGet16(ds, 0x953e);
    if ((short)ax <= (short)0x0000)
        goto loc_111f0;
    ax = memoryAGet16(ds, 0x954c);
    if (!(al & 0x80))
        goto loc_111f0;
    sub_11d1e();
loc_111f0:
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951a);
    if (!(al & 0x40))
        goto loc_11235;
    if (bl != 0x00)
        goto loc_11224;
    ax = memoryAGet16(ds, 0x9536);
    if (ax <= 0x0000)
        goto loc_11222;
    memoryASet(ds, 0x951a, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    sub_11cd9();
    sub_10b58();
    memoryASet16(ds, 0x9538, memoryAGet16(ds, 0x9538) - 1);
    al = 0x01;
    sub_13840();
loc_11222:
    goto loc_11233;
loc_11224:
    if (bl != 0x02)
        goto loc_11233;
    memoryASet(ds, 0x951a, 0x03);
    al = 0x02;
    sub_13840();
loc_11233:
    goto loc_1124b;
loc_11235:
    if (bl != 0x01)
        goto loc_11241;
    memoryASet(ds, 0x951a, 0x02);
    goto loc_1124b;
loc_11241:
    if (bl != 0x03)
        goto loc_1124b;
    memoryASet(ds, 0x951a, 0x00);
loc_1124b:
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951b);
    if (!(al & 0x20))
        goto loc_11290;
    if (bl != 0x00)
        goto loc_1127f;
    ax = memoryAGet16(ds, 0x9536);
    if (ax <= 0x0000)
        goto loc_1127d;
    memoryASet(ds, 0x951b, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    sub_11cd9();
    sub_10b58();
    memoryASet16(ds, 0x9538, memoryAGet16(ds, 0x9538) - 1);
    al = 0x01;
    sub_13840();
loc_1127d:
    goto loc_1128e;
loc_1127f:
    if (bl != 0x02)
        goto loc_1128e;
    memoryASet(ds, 0x951b, 0x03);
    al = 0x02;
    sub_13840();
loc_1128e:
    return;
loc_11290:
    if (bl != 0x01)
        goto loc_1129c;
    memoryASet(ds, 0x951b, 0x02);
    return;
loc_1129c:
    if (bl != 0x03)
        return;
    memoryASet(ds, 0x951b, 0x00);
}
/* Assembly listing of 1000:12a7 sub_112a7()
                sub_112a7 PROC
1000:12a7	mov	ax, word ptr [0x952a]
1000:12aa	sub	ax, 3
1000:12ad	js	loc_112b4
1000:12af	mov	word ptr [0x952a], ax
1000:12b2	jmp	loc_112b7
        	loc_112b4:
1000:12b4	call	0x1c33
        	loc_112b7:
1000:12b7	call	0x1bb9
1000:12ba	call	0x1b57
1000:12bd	mov	si, 0x1b8a
1000:12c0	mov	bx, 0xd49
1000:12c3	mov	byte ptr [si + 4], 0xa
1000:12c7	call	0x2121
1000:12ca	ret	
                sub_112a7 ENDP
*/
void sub_112a7()
{
    // coverage: 0x14a7-0x14cb method sub_112a7
    ax = memoryAGet16(ds, 0x952a);
    ax -= 0x0003;
    if ((short)ax < 0)
        goto loc_112b4;
    memoryASet16(ds, 0x952a, ax);
    goto loc_112b7;
loc_112b4:
    sub_11c33();
loc_112b7:
    sub_11bb9();
    sub_11b57();
    si = 0x1b8a;
    bx = 0x0d49;
    memoryASet(ds, si + 4, 0x0a);
    sub_12121();
}
/* Assembly listing of 1000:12cb sub_112cb()
                sub_112cb PROC
1000:12cb	mov	ax, word ptr [0x952a]
1000:12ce	dec	ax
1000:12cf	js	loc_112d4
1000:12d1	mov	word ptr [0x952a], ax
        	loc_112d4:
1000:12d4	call	0x1bb9
1000:12d7	call	0x1b57
1000:12da	inc	byte ptr [0x9514]
1000:12de	mov	al, byte ptr [0x9514]
1000:12e1	cmp	al, 0x28
1000:12e3	jb	loc_112ea
1000:12e5	mov	byte ptr [0x9513], 1
        	loc_112ea:
1000:12ea	ret	
                sub_112cb ENDP
*/
void sub_112cb()
{
    // coverage: 0x14cb-0x14eb method sub_112cb
    ax = memoryAGet16(ds, 0x952a);
    ax--;
    if ((short)ax < 0)
        goto loc_112d4;
    memoryASet16(ds, 0x952a, ax);
loc_112d4:
    sub_11bb9();
    sub_11b57();
    memoryASet(ds, 0x9514, memoryAGet(ds, 0x9514) + 1);
    al = memoryAGet(ds, 0x9514);
    if (al < 0x28)
        return;
    memoryASet(ds, 0x9513, 0x01);
}
/* Assembly listing of 1000:12eb sub_112eb()
                sub_112eb PROC
1000:12eb	call	0x10a0
1000:12ee	mov	al, byte ptr [si]
1000:12f0	cmp	al, 0
1000:12f2	jne	loc_112f5
1000:12f4	ret	
        	loc_112f5:
1000:12f5	sub	word ptr [si + 7], 0x10
1000:12f9	and	word ptr [si + 7], 0x3ff
1000:12fe	mov	al, byte ptr [si + 4]
1000:1301	cmp	al, 1
1000:1303	jne	loc_11312
1000:1305	mov	al, byte ptr [si + 3]
1000:1308	cmp	al, 0x9c
1000:130a	jle	loc_11310
1000:130c	sub	byte ptr [si + 3], 8
        	loc_11310:
1000:1310	jmp	loc_11321
        	loc_11312:
1000:1312	cmp	al, 2
1000:1314	jne	loc_11321
1000:1316	mov	al, byte ptr [si + 3]
1000:1319	cmp	al, 0x64
1000:131b	jge	loc_11321
1000:131d	add	byte ptr [si + 3], 8
        	loc_11321:
1000:1321	push	si
1000:1322	mov	ax, word ptr [si + 5]
1000:1325	push	ax
1000:1326	mov	ax, word ptr [si + 7]
1000:1329	push	ax
1000:132a	call	0x7fd
1000:132d	pop	si
1000:132e	cmp	al, byte ptr [si + 3]
1000:1331	jl	loc_11338
1000:1333	call	0x2092
1000:1336	jmp	loc_11383
        	loc_11338:
1000:1338	push	si
1000:1339	mov	ax, word ptr [si + 5]
1000:133c	push	ax
1000:133d	mov	byte ptr [si + 0x14], cl
1000:1340	push	cx
1000:1341	call	0xad5
1000:1344	pop	si
1000:1345	cmp	ax, 0
1000:1348	je	loc_11383
1000:134a	push	si
1000:134b	mov	al, byte ptr [si + 0x14]
1000:134e	mov	ah, 0
1000:1350	push	bx
1000:1351	push	ax
1000:1352	call	0x1c0a
1000:1355	mov	al, byte ptr [si]
1000:1357	test	al, 0x80
1000:1359	jne	loc_11382
1000:135b	pop	bx
1000:135c	push	bx
1000:135d	mov	al, byte ptr [si + 3]
1000:1360	sub	al, byte ptr [bx + 3]
1000:1363	jns	loc_11367
1000:1365	neg	al
        	loc_11367:
1000:1367	cmp	al, 0x10
1000:1369	jae	loc_11382
1000:136b	dec	byte ptr [si + 0x15]
1000:136e	jns	loc_1137a
1000:1370	call	0x20db
1000:1373	mov	al, 6
1000:1375	call	0x3840
1000:1378	jmp	loc_1137d
        	loc_1137a:
1000:137a	call	0x2662
        	loc_1137d:
1000:137d	pop	si
1000:137e	push	si
1000:137f	call	0x2047
        	loc_11382:
1000:1382	pop	si
        	loc_11383:
1000:1383	ret	
                sub_112eb ENDP
*/
void sub_112eb()
{
    // coverage: 0x14eb-0x1584 method sub_112eb
    sub_110a0();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_112f5;
    return;
loc_112f5:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - 0x0010);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    al = memoryAGet(ds, si + 4);
    if (al != 0x01)
        goto loc_11312;
    al = memoryAGet(ds, si + 3);
    if ((char)al <= (char)0x9c)
        goto loc_11310;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) - 0x08);
loc_11310:
    goto loc_11321;
loc_11312:
    if (al != 0x02)
        goto loc_11321;
    al = memoryAGet(ds, si + 3);
    if ((char)al >= (char)0x64)
        goto loc_11321;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + 0x08);
loc_11321:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    if ((char)al < (char)memoryAGet(ds, si + 3))
        goto loc_11338;
    sub_12092();
    return;
loc_11338:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    memoryASet(ds, si + 20, cl);
    push(cx);
    sub_10ad5();
    si = pop();
    if (ax == 0x0000)
        return;
    push(si);
    al = memoryAGet(ds, si + 20);
    ah = 0x00;
    push(bx);
    push(ax);
    sub_11c0a();
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_11382;
    bx = pop();
    push(bx);
    al = memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, bx + 3);
    if ((char)al >= 0)
        goto loc_11367;
    al = -al;
loc_11367:
    if (al >= 0x10)
        goto loc_11382;
    memoryASet(ds, si + 21, memoryAGet(ds, si + 21) - 1);
    if ((char)memoryAGet(ds, si + 21) >= 0)
        goto loc_1137a;
    sub_120db();
    al = 0x06;
    sub_13840();
    goto loc_1137d;
loc_1137a:
    sub_12662();
loc_1137d:
    si = pop();
    push(si);
    sub_12047();
loc_11382:
    si = pop();
}
/* Assembly listing of 1000:1384 sub_11384()
                sub_11384 PROC
1000:1384	mov	al, byte ptr [0x1b9c]
1000:1387	cmp	al, 0x11
1000:1389	jne	loc_1138e
1000:138b	mov	byte ptr [si], 0
        	loc_1138e:
1000:138e	call	0x1cd9
1000:1391	mov	al, byte ptr [si]
1000:1393	test	al, 0x20
1000:1395	jne	loc_1139c
1000:1397	mov	al, byte ptr [0x951a]
1000:139a	jmp	loc_1139f
        	loc_1139c:
1000:139c	mov	al, byte ptr [0x951b]
        	loc_1139f:
1000:139f	cmp	al, 3
1000:13a1	jne	loc_113a7
1000:13a3	mov	byte ptr [si + 0x12], 0x19
        	loc_113a7:
1000:13a7	ret	
                sub_11384 ENDP
*/
void sub_11384()
{
    // coverage: 0x1584-0x15a8 method sub_11384
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_1138e;
    memoryASet(ds, si, 0x00);
loc_1138e:
    sub_11cd9();
    al = memoryAGet(ds, si);
    if (al & 0x20)
        goto loc_1139c;
    al = memoryAGet(ds, 0x951a);
    goto loc_1139f;
loc_1139c:
    al = memoryAGet(ds, 0x951b);
loc_1139f:
    if (al != 0x03)
        return;
    memoryASet(ds, si + 18, 0x19);
}
/* Assembly listing of 1000:13a8 sub_113a8()
                sub_113a8 PROC
1000:13a8	call	0x10a0
1000:13ab	mov	al, byte ptr [si]
1000:13ad	cmp	al, 0
1000:13af	jne	loc_113b2
1000:13b1	ret	
        	loc_113b2:
1000:13b2	sub	word ptr [si + 7], 6
1000:13b6	and	word ptr [si + 7], 0x3ff
1000:13bb	push	si
1000:13bc	mov	ax, word ptr [si + 5]
1000:13bf	push	ax
1000:13c0	mov	ax, word ptr [si + 7]
1000:13c3	push	ax
1000:13c4	call	0x7fd
1000:13c7	pop	si
1000:13c8	add	al, 4
1000:13ca	mov	byte ptr [si + 3], al
1000:13cd	mov	byte ptr [si + 0x14], cl
1000:13d0	mov	byte ptr [si + 4], bl
1000:13d3	mov	bx, 0xdda
1000:13d6	call	0x2121
1000:13d9	mov	al, byte ptr [si + 4]
1000:13dc	cmp	al, 0
1000:13de	jne	loc_113f5
1000:13e0	add	word ptr [si + 7], 4
1000:13e4	and	word ptr [si + 7], 0x3ff
1000:13e9	dec	byte ptr [si + 0x15]
1000:13ec	jns	loc_113f5
1000:13ee	call	0x20f0
1000:13f1	mov	byte ptr [si], 0
1000:13f4	ret	
        	loc_113f5:
1000:13f5	push	si
1000:13f6	mov	ax, word ptr [si + 5]
1000:13f9	push	ax
1000:13fa	mov	cl, byte ptr [si + 0x14]
1000:13fd	mov	ch, 0
1000:13ff	push	cx
1000:1400	call	0xad5
1000:1403	pop	si
1000:1404	cmp	ax, 0
1000:1407	je	loc_11428
1000:1409	push	si
1000:140a	mov	al, byte ptr [si + 0x14]
1000:140d	mov	ah, 0
1000:140f	push	bx
1000:1410	push	ax
1000:1411	call	0x1c0a
1000:1414	mov	al, byte ptr [si]
1000:1416	test	al, 0x80
1000:1418	jne	loc_11427
1000:141a	call	0x20db
1000:141d	mov	al, 6
1000:141f	call	0x3840
1000:1422	pop	si
1000:1423	push	si
1000:1424	mov	byte ptr [si], 0
        	loc_11427:
1000:1427	pop	si
        	loc_11428:
1000:1428	ret	
                sub_113a8 ENDP
*/
void sub_113a8()
{
    // coverage: 0x15a8-0x1629 method sub_113a8
    sub_110a0();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_113b2;
    return;
loc_113b2:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - 0x0006);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    al += 0x04;
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 20, cl);
    memoryASet(ds, si + 4, bl);
    bx = 0x0dda;
    sub_12121();
    al = memoryAGet(ds, si + 4);
    if (al != 0x00)
        goto loc_113f5;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0004);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    memoryASet(ds, si + 21, memoryAGet(ds, si + 21) - 1);
    if ((char)memoryAGet(ds, si + 21) >= 0)
        goto loc_113f5;
    sub_120f0();
    memoryASet(ds, si, 0x00);
    return;
loc_113f5:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    cl = memoryAGet(ds, si + 20);
    ch = 0x00;
    push(cx);
    sub_10ad5();
    si = pop();
    if (ax == 0x0000)
        return;
    push(si);
    al = memoryAGet(ds, si + 20);
    ah = 0x00;
    push(bx);
    push(ax);
    sub_11c0a();
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_11427;
    sub_120db();
    al = 0x06;
    sub_13840();
    si = pop();
    push(si);
    memoryASet(ds, si, 0x00);
loc_11427:
    si = pop();
}
/* Assembly listing of 1000:1429 sub_11429()
                sub_11429 PROC
1000:1429	call	0x10c6
1000:142c	mov	al, byte ptr [si]
1000:142e	cmp	al, 0
1000:1430	jne	loc_11433
1000:1432	ret	
        	loc_11433:
1000:1433	mov	al, byte ptr [si + 1]
1000:1436	cmp	al, 2
1000:1438	jne	loc_11440
1000:143a	add	word ptr [si + 7], 5
1000:143e	jmp	loc_1146a
        	loc_11440:
1000:1440	cmp	al, 0
1000:1442	jne	loc_1144a
1000:1444	sub	word ptr [si + 5], 5
1000:1448	jmp	loc_1146a
        	loc_1144a:
1000:144a	cmp	al, 1
1000:144c	jne	loc_11458
1000:144e	sub	word ptr [si + 5], 3
1000:1452	add	word ptr [si + 7], 2
1000:1456	jmp	loc_1146a
        	loc_11458:
1000:1458	cmp	al, 3
1000:145a	jne	loc_11466
1000:145c	add	word ptr [si + 5], 3
1000:1460	add	word ptr [si + 7], 2
1000:1464	jmp	loc_1146a
        	loc_11466:
1000:1466	add	word ptr [si + 5], 5
        	loc_1146a:
1000:146a	and	word ptr [si + 7], 0x3ff
1000:146f	mov	ax, word ptr [si + 5]
1000:1472	cmp	ax, 0xc
1000:1475	jge	loc_1147b
1000:1477	mov	byte ptr [si], 0
1000:147a	ret	
        	loc_1147b:
1000:147b	cmp	ax, 0xf4
1000:147e	jle	loc_11484
1000:1480	mov	byte ptr [si], 0
1000:1483	ret	
        	loc_11484:
1000:1484	push	si
1000:1485	mov	ax, word ptr [si + 5]
1000:1488	push	ax
1000:1489	mov	ax, word ptr [si + 7]
1000:148c	push	ax
1000:148d	call	0x7fd
1000:1490	pop	si
1000:1491	add	al, 8
1000:1493	mov	byte ptr [si + 3], al
1000:1496	mov	byte ptr [si + 0x14], cl
1000:1499	mov	byte ptr [si + 4], bl
1000:149c	mov	bl, byte ptr [si + 1]
1000:149f	mov	bh, 0
1000:14a1	shl	bx, 1
1000:14a3	mov	bx, word ptr [bx + 0x10ff]
1000:14a7	call	0x2121
1000:14aa	mov	al, byte ptr [0x1b9c]
1000:14ad	cmp	al, 0x11
1000:14af	jne	loc_114b2
1000:14b1	ret	
        	loc_114b2:
1000:14b2	mov	ax, word ptr [si + 5]
1000:14b5	sub	ax, word ptr [0x1b8f]
1000:14b9	jns	loc_114bd
1000:14bb	neg	ax
        	loc_114bd:
1000:14bd	cmp	ax, 0x10
1000:14c0	jae	loc_114ef
1000:14c2	mov	ax, word ptr [si + 7]
1000:14c5	sub	ax, word ptr [0x1b91]
1000:14c9	sub	ax, 8
1000:14cc	jns	loc_114d0
1000:14ce	neg	ax
        	loc_114d0:
1000:14d0	cmp	ax, 0x10
1000:14d3	jae	loc_114ef
1000:14d5	mov	al, 5
1000:14d7	call	0x3840
1000:14da	sub	word ptr [0x9544], 0x64
1000:14df	mov	byte ptr [0x12a0], 1
1000:14e4	call	0x20f0
1000:14e7	mov	byte ptr [0x12a0], 5
1000:14ec	mov	byte ptr [si], 0
        	loc_114ef:
1000:14ef	ret	
                sub_11429 ENDP
*/
void sub_11429()
{
    // coverage: 0x1629-0x16f0 method sub_11429
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11433;
    return;
loc_11433:
    al = memoryAGet(ds, si + 1);
    if (al != 0x02)
        goto loc_11440;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0005);
    goto loc_1146a;
loc_11440:
    if (al != 0x00)
        goto loc_1144a;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0005);
    goto loc_1146a;
loc_1144a:
    if (al != 0x01)
        goto loc_11458;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0003);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0002);
    goto loc_1146a;
loc_11458:
    if (al != 0x03)
        goto loc_11466;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0003);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0002);
    goto loc_1146a;
loc_11466:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0005);
loc_1146a:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    ax = memoryAGet16(ds, si + 5);
    if ((short)ax >= (short)0x000c)
        goto loc_1147b;
    memoryASet(ds, si, 0x00);
    return;
loc_1147b:
    if ((short)ax <= (short)0x00f4)
        goto loc_11484;
    memoryASet(ds, si, 0x00);
    return;
loc_11484:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    al += 0x08;
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 20, cl);
    memoryASet(ds, si + 4, bl);
    bl = memoryAGet(ds, si + 1);
    bh = 0x00;
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4351);
    sub_12121();
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_114b2;
    return;
loc_114b2:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_114bd;
    ax = -ax;
loc_114bd:
    if (ax >= 0x0010)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    ax -= 0x0008;
    if ((short)ax >= 0)
        goto loc_114d0;
    ax = -ax;
loc_114d0:
    if (ax >= 0x0010)
        return;
    al = 0x05;
    sub_13840();
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x0064);
    memoryASet(ds, 0x12a0, 0x01);
    sub_120f0();
    memoryASet(ds, 0x12a0, 0x05);
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:14f0 sub_114f0()
                sub_114f0 PROC
1000:14f0	add	word ptr [si + 7], 1
1000:14f4	push	si
1000:14f5	mov	ax, word ptr [si + 5]
1000:14f8	push	ax
1000:14f9	mov	ax, word ptr [si + 7]
1000:14fc	push	ax
1000:14fd	call	0x7fd
1000:1500	pop	si
1000:1501	mov	byte ptr [si + 3], al
1000:1504	mov	byte ptr [si + 0x14], cl
1000:1507	mov	byte ptr [si + 4], bl
1000:150a	mov	bl, byte ptr [si + 1]
1000:150d	mov	bh, 0
1000:150f	shl	bx, 1
1000:1511	mov	bx, word ptr [bx + 0xfe1]
1000:1515	call	0x2121
1000:1518	mov	al, byte ptr [0x1b9c]
1000:151b	cmp	al, 0x11
1000:151d	je	loc_11548
1000:151f	mov	ax, word ptr [si + 5]
1000:1522	sub	ax, word ptr [0x1b8f]
1000:1526	jns	loc_1152a
1000:1528	neg	ax
        	loc_1152a:
1000:152a	cmp	ax, 0x1a
1000:152d	jae	loc_11548
1000:152f	mov	ax, word ptr [si + 7]
1000:1532	sub	ax, word ptr [0x1b91]
1000:1536	jns	loc_1153a
1000:1538	neg	ax
        	loc_1153a:
1000:153a	cmp	ax, 0x12
1000:153d	jae	loc_11548
1000:153f	sub	word ptr [0x9544], 0xc
1000:1544	mov	byte ptr [si + 0x15], 0xff
        	loc_11548:
1000:1548	mov	di, 0x1ba1
        	loc_1154b:
1000:154b	mov	al, byte ptr [si + 0x15]
1000:154e	cmp	al, 0
1000:1550	jge	loc_11561
1000:1552	mov	al, 7
1000:1554	call	0x3840
1000:1557	call	0x20f0
1000:155a	mov	byte ptr [si], 0
1000:155d	call	0x2676
1000:1560	ret	
        	loc_11561:
1000:1561	mov	al, byte ptr [di]
1000:1563	test	al, 0x80
1000:1565	jne	loc_115c0
1000:1567	test	al, 0x40
1000:1569	je	loc_115bb
1000:156b	push	di
1000:156c	mov	ax, word ptr [di + 5]
1000:156f	sub	ax, word ptr [si + 5]
1000:1572	jns	loc_11576
1000:1574	neg	ax
        	loc_11576:
1000:1576	cmp	ax, 0x14
1000:1579	jae	loc_115ba
1000:157b	mov	ax, word ptr [di + 7]
1000:157e	sub	ax, word ptr [si + 7]
1000:1581	jns	loc_11585
1000:1583	neg	ax
        	loc_11585:
1000:1585	cmp	ax, 0x10
1000:1588	jae	loc_115ba
1000:158a	mov	al, byte ptr [di + 0x12]
1000:158d	cmp	al, 0x19
1000:158f	jne	loc_1159a
1000:1591	mov	byte ptr [si + 0x15], 0xff
1000:1595	mov	byte ptr [di], 0
1000:1598	jmp	loc_115ba
        	loc_1159a:
1000:159a	mov	al, byte ptr [di + 3]
1000:159d	sub	al, byte ptr [si + 3]
1000:15a0	jns	loc_115a4
1000:15a2	neg	al
        	loc_115a4:
1000:15a4	cmp	al, 0x10
1000:15a6	jae	loc_115ba
1000:15a8	dec	byte ptr [si + 0x15]
1000:15ab	push	si
1000:15ac	mov	si, di
1000:15ae	call	0x2092
1000:15b1	mov	al, 3
1000:15b3	call	0x3840
1000:15b6	call	0x2662
1000:15b9	pop	si
        	loc_115ba:
1000:15ba	pop	di
        	loc_115bb:
1000:15bb	add	di, 0x17
1000:15be	jmp	loc_1154b
        	loc_115c0:
1000:15c0	mov	al, byte ptr [0x1b9c]
1000:15c3	cmp	al, 0x11
1000:15c5	je	loc_115f8
1000:15c7	mov	ax, word ptr [0x1b91]
1000:15ca	cmp	ax, word ptr [si + 7]
1000:15cd	jbe	loc_115f8
1000:15cf	mov	ax, word ptr [0x1b8f]
1000:15d2	sub	ax, word ptr [si + 5]
1000:15d5	jns	loc_115d9
1000:15d7	neg	ax
        	loc_115d9:
1000:15d9	cmp	ax, 0x20
1000:15dc	jae	loc_115f8
1000:15de	dec	byte ptr [si + 0x16]
1000:15e1	jns	loc_115ee
1000:15e3	mov	byte ptr [si + 0x16], 7
1000:15e7	mov	byte ptr [0x9518], 1
1000:15ec	jmp	loc_115f3
        	loc_115ee:
1000:15ee	mov	byte ptr [0x9518], 0
        	loc_115f3:
1000:15f3	push	si
1000:15f4	call	0x1def
1000:15f7	pop	si
        	loc_115f8:
1000:15f8	call	0x10c6
1000:15fb	ret	
                sub_114f0 ENDP
*/
void sub_114f0()
{
    // coverage: 0x16f0-0x17fc method sub_114f0
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0001);
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 20, cl);
    memoryASet(ds, si + 4, bl);
    bl = memoryAGet(ds, si + 1);
    bh = 0x00;
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4065);
    sub_12121();
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_11548;
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_1152a;
    ax = -ax;
loc_1152a:
    if (ax >= 0x001a)
        goto loc_11548;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_1153a;
    ax = -ax;
loc_1153a:
    if (ax >= 0x0012)
        goto loc_11548;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x000c);
    memoryASet(ds, si + 21, 0xff);
loc_11548:
    di = 0x1ba1;
loc_1154b:
    al = memoryAGet(ds, si + 21);
    if ((char)al >= (char)0x00)
        goto loc_11561;
    al = 0x07;
    sub_13840();
    sub_120f0();
    memoryASet(ds, si, 0x00);
    sub_12676();
    return;
loc_11561:
    al = memoryAGet(ds, di);
    if (al & 0x80)
        goto loc_115c0;
    if (!(al & 0x40))
        goto loc_115bb;
    push(di);
    ax = memoryAGet16(ds, di + 5);
    ax -= memoryAGet16(ds, si + 5);
    if ((short)ax >= 0)
        goto loc_11576;
    ax = -ax;
loc_11576:
    if (ax >= 0x0014)
        goto loc_115ba;
    ax = memoryAGet16(ds, di + 7);
    ax -= memoryAGet16(ds, si + 7);
    if ((short)ax >= 0)
        goto loc_11585;
    ax = -ax;
loc_11585:
    if (ax >= 0x0010)
        goto loc_115ba;
    al = memoryAGet(ds, di + 18);
    if (al != 0x19)
        goto loc_1159a;
    memoryASet(ds, si + 21, 0xff);
    memoryASet(ds, di, 0x00);
    goto loc_115ba;
loc_1159a:
    al = memoryAGet(ds, di + 3);
    al -= memoryAGet(ds, si + 3);
    if ((char)al >= 0)
        goto loc_115a4;
    al = -al;
loc_115a4:
    if (al >= 0x10)
        goto loc_115ba;
    memoryASet(ds, si + 21, memoryAGet(ds, si + 21) - 1);
    push(si);
    si = di;
    sub_12092();
    al = 0x03;
    sub_13840();
    sub_12662();
    si = pop();
loc_115ba:
    di = pop();
loc_115bb:
    di += 0x0017;
    goto loc_1154b;
loc_115c0:
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_115f8;
    ax = memoryAGet16(ds, 0x1b91);
    if (ax <= memoryAGet16(ds, si + 7))
        goto loc_115f8;
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    if ((short)ax >= 0)
        goto loc_115d9;
    ax = -ax;
loc_115d9:
    if (ax >= 0x0020)
        goto loc_115f8;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_115ee;
    memoryASet(ds, si + 22, 0x07);
    memoryASet(ds, 0x9518, 0x01);
    goto loc_115f3;
loc_115ee:
    memoryASet(ds, 0x9518, 0x00);
loc_115f3:
    push(si);
    sub_11def();
    si = pop();
loc_115f8:
    sub_110c6();
}
/* Assembly listing of 1000:15fc sub_115fc()
                sub_115fc PROC
1000:15fc	call	0x10c6
1000:15ff	mov	al, byte ptr [si]
1000:1601	cmp	al, 0
1000:1603	jne	loc_11606
1000:1605	ret	
        	loc_11606:
1000:1606	mov	al, byte ptr [si + 1]
1000:1609	cmp	al, 2
1000:160b	jne	loc_11613
1000:160d	add	word ptr [si + 7], 8
1000:1611	jmp	loc_1163d
        	loc_11613:
1000:1613	cmp	al, 0
1000:1615	jne	loc_1161d
1000:1617	sub	word ptr [si + 5], 8
1000:161b	jmp	loc_1163d
        	loc_1161d:
1000:161d	cmp	al, 1
1000:161f	jne	loc_1162b
1000:1621	sub	word ptr [si + 5], 6
1000:1625	add	word ptr [si + 7], 4
1000:1629	jmp	loc_1163d
        	loc_1162b:
1000:162b	cmp	al, 3
1000:162d	jne	loc_11639
1000:162f	add	word ptr [si + 5], 6
1000:1633	add	word ptr [si + 7], 4
1000:1637	jmp	loc_1163d
        	loc_11639:
1000:1639	add	word ptr [si + 5], 8
        	loc_1163d:
1000:163d	and	word ptr [si + 7], 0x3ff
1000:1642	mov	ax, word ptr [si + 5]
1000:1645	cmp	ax, 4
1000:1648	jge	loc_1164e
1000:164a	mov	byte ptr [si], 0
1000:164d	ret	
        	loc_1164e:
1000:164e	cmp	ax, 0xfc
1000:1651	jle	loc_11657
1000:1653	mov	byte ptr [si], 0
1000:1656	ret	
        	loc_11657:
1000:1657	mov	al, byte ptr [si + 4]
1000:165a	cmp	al, 1
1000:165c	jne	loc_1166b
1000:165e	mov	al, byte ptr [si + 3]
1000:1661	cmp	al, 0x64
1000:1663	jge	loc_11669
1000:1665	add	byte ptr [si + 3], 4
        	loc_11669:
1000:1669	jmp	loc_1167a
        	loc_1166b:
1000:166b	cmp	al, 2
1000:166d	jne	loc_1167a
1000:166f	mov	al, byte ptr [si + 3]
1000:1672	cmp	al, 0x9c
1000:1674	jle	loc_1167a
1000:1676	sub	byte ptr [si + 3], 4
        	loc_1167a:
1000:167a	push	si
1000:167b	mov	ax, word ptr [si + 5]
1000:167e	push	ax
1000:167f	mov	ax, word ptr [si + 7]
1000:1682	push	ax
1000:1683	call	0x7fd
1000:1686	pop	si
1000:1687	cmp	al, byte ptr [si + 3]
1000:168a	jl	loc_11691
1000:168c	call	0x2092
1000:168f	jmp	loc_116d5
        	loc_11691:
1000:1691	mov	al, byte ptr [0x1b9c]
1000:1694	cmp	al, 0x11
1000:1696	jne	loc_11699
1000:1698	ret	
        	loc_11699:
1000:1699	mov	ax, word ptr [si + 5]
1000:169c	sub	ax, word ptr [0x1b8f]
1000:16a0	jns	loc_116a4
1000:16a2	neg	ax
        	loc_116a4:
1000:16a4	cmp	ax, 0xc
1000:16a7	jae	loc_116d5
1000:16a9	mov	ax, word ptr [si + 7]
1000:16ac	sub	ax, word ptr [0x1b91]
1000:16b0	jns	loc_116b4
1000:16b2	neg	ax
        	loc_116b4:
1000:16b4	cmp	ax, 8
1000:16b7	jae	loc_116d5
1000:16b9	mov	al, byte ptr [si + 3]
1000:16bc	sub	al, byte ptr [0x1b8d]
1000:16c0	jns	loc_116c4
1000:16c2	neg	al
        	loc_116c4:
1000:16c4	cmp	al, 0x10
1000:16c6	jae	loc_116d5
1000:16c8	sub	word ptr [0x9544], 1
1000:16cd	call	0x2092
1000:16d0	mov	al, 4
1000:16d2	call	0x3840
        	loc_116d5:
1000:16d5	ret	
                sub_115fc ENDP
*/
void sub_115fc()
{
    // coverage: 0x17fc-0x18d6 method sub_115fc
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11606;
    return;
loc_11606:
    al = memoryAGet(ds, si + 1);
    if (al != 0x02)
        goto loc_11613;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0008);
    goto loc_1163d;
loc_11613:
    if (al != 0x00)
        goto loc_1161d;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0008);
    goto loc_1163d;
loc_1161d:
    if (al != 0x01)
        goto loc_1162b;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0006);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0004);
    goto loc_1163d;
loc_1162b:
    if (al != 0x03)
        goto loc_11639;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0006);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0004);
    goto loc_1163d;
loc_11639:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0008);
loc_1163d:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    ax = memoryAGet16(ds, si + 5);
    if ((short)ax >= (short)0x0004)
        goto loc_1164e;
    memoryASet(ds, si, 0x00);
    return;
loc_1164e:
    if ((short)ax <= (short)0x00fc)
        goto loc_11657;
    memoryASet(ds, si, 0x00);
    return;
loc_11657:
    al = memoryAGet(ds, si + 4);
    if (al != 0x01)
        goto loc_1166b;
    al = memoryAGet(ds, si + 3);
    if ((char)al >= (char)0x64)
        goto loc_11669;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + 0x04);
loc_11669:
    goto loc_1167a;
loc_1166b:
    if (al != 0x02)
        goto loc_1167a;
    al = memoryAGet(ds, si + 3);
    if ((char)al <= (char)0x9c)
        goto loc_1167a;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) - 0x04);
loc_1167a:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    if ((char)al < (char)memoryAGet(ds, si + 3))
        goto loc_11691;
    sub_12092();
    return;
loc_11691:
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_11699;
    return;
loc_11699:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_116a4;
    ax = -ax;
loc_116a4:
    if (ax >= 0x000c)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_116b4;
    ax = -ax;
loc_116b4:
    if (ax >= 0x0008)
        return;
    al = memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, 0x1b8d);
    if ((char)al >= 0)
        goto loc_116c4;
    al = -al;
loc_116c4:
    if (al >= 0x10)
        return;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x0001);
    sub_12092();
    al = 0x04;
    sub_13840();
}
/* Assembly listing of 1000:16d6 sub_116d6()
                sub_116d6 PROC
1000:16d6	dec	byte ptr [si + 4]
1000:16d9	jns	loc_116de
1000:16db	mov	byte ptr [si], 0
        	loc_116de:
1000:16de	ret	
                sub_116d6 ENDP
*/
void sub_116d6()
{
    // coverage: 0x18d6-0x18df method sub_116d6
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) - 1);
    if ((char)memoryAGet(ds, si + 4) >= 0)
        return;
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:16df sub_116df()
                sub_116df PROC
1000:16df	mov	al, byte ptr [si + 4]
1000:16e2	inc	byte ptr [si + 4]
1000:16e5	cmp	al, 4
1000:16e7	jb	loc_116ed
1000:16e9	mov	byte ptr [si], 0
1000:16ec	ret	
        	loc_116ed:
1000:16ed	shl	al, 1
1000:16ef	mov	bl, al
1000:16f1	mov	bh, 0
1000:16f3	mov	ax, word ptr [bx + 0x143e]
1000:16f7	mov	word ptr [si + 0xf], ax
1000:16fa	call	0x10c6
1000:16fd	ret	
                sub_116df ENDP
*/
void sub_116df()
{
    // coverage: 0x18df-0x18fe method sub_116df
    al = memoryAGet(ds, si + 4);
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) + 1);
    if (al < 0x04)
        goto loc_116ed;
    memoryASet(ds, si, 0x00);
    return;
loc_116ed:
    al <<= 1;
    bl = al;
    bh = 0x00;
    ax = memoryAGet16(ds, bx + 5182);
    memoryASet16(ds, si + 15, ax);
    sub_110c6();
}
/* Assembly listing of 1000:16fe sub_116fe()
                sub_116fe PROC
1000:16fe	inc	byte ptr [si + 0x16]
1000:1701	mov	al, byte ptr [si + 0x16]
1000:1704	shr	al, 1
1000:1706	shr	al, 1
1000:1708	and	al, 7
1000:170a	cmp	al, 5
1000:170c	jl	loc_11712
1000:170e	mov	byte ptr [si], 0
1000:1711	ret	
        	loc_11712:
1000:1712	mov	byte ptr [si + 4], al
1000:1715	mov	bx, 0x12b5
1000:1718	call	0x2121
1000:171b	call	0x10c6
1000:171e	ret	
                sub_116fe ENDP
*/
void sub_116fe()
{
    // coverage: 0x18fe-0x191f method sub_116fe
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al >>= 1;
    al &= 0x07;
    if ((char)al < (char)0x05)
        goto loc_11712;
    memoryASet(ds, si, 0x00);
    return;
loc_11712:
    memoryASet(ds, si + 4, al);
    bx = 0x12b5;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:171f sub_1171f()
                sub_1171f PROC
1000:171f	inc	byte ptr [si + 0x16]
1000:1722	mov	al, byte ptr [si + 0x16]
1000:1725	shr	al, 1
1000:1727	shr	al, 1
1000:1729	and	al, 7
1000:172b	cmp	al, 6
1000:172d	jl	loc_11733
1000:172f	mov	byte ptr [si], 0
1000:1732	ret	
        	loc_11733:
1000:1733	mov	byte ptr [si + 4], al
1000:1736	mov	bx, 0x12f5
1000:1739	call	0x2121
1000:173c	call	0x10c6
1000:173f	ret	
                sub_1171f ENDP
*/
void sub_1171f()
{
    // coverage: 0x191f-0x1940 method sub_1171f
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al >>= 1;
    al &= 0x07;
    if ((char)al < (char)0x06)
        goto loc_11733;
    memoryASet(ds, si, 0x00);
    return;
loc_11733:
    memoryASet(ds, si + 4, al);
    bx = 0x12f5;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:1740 sub_11740()
                sub_11740 PROC
1000:1740	inc	byte ptr [si + 0x16]
1000:1743	mov	al, byte ptr [si + 0x16]
1000:1746	and	al, 7
1000:1748	cmp	al, 4
1000:174a	jl	loc_11762
1000:174c	mov	al, byte ptr [si]
1000:174e	test	al, 0x20
1000:1750	je	loc_11759
1000:1752	and	byte ptr [0x9517], 0x7f
1000:1757	jmp	loc_1175e
        	loc_11759:
1000:1759	and	byte ptr [0x9517], 0xfe
        	loc_1175e:
1000:175e	mov	byte ptr [si], 0
1000:1761	ret	
        	loc_11762:
1000:1762	mov	byte ptr [si + 4], al
1000:1765	mov	bx, 0x133d
1000:1768	call	0x2121
1000:176b	ret	
                sub_11740 ENDP
*/
void sub_11740()
{
    // coverage: 0x1940-0x196c method sub_11740
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al &= 0x07;
    if ((char)al < (char)0x04)
        goto loc_11762;
    al = memoryAGet(ds, si);
    if (!(al & 0x20))
        goto loc_11759;
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) & 0x7f);
    goto loc_1175e;
loc_11759:
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) & 0xfe);
loc_1175e:
    memoryASet(ds, si, 0x00);
    return;
loc_11762:
    memoryASet(ds, si + 4, al);
    bx = 0x133d;
    sub_12121();
}
/* Assembly listing of 1000:176c sub_1176c()
                sub_1176c PROC
1000:176c	inc	byte ptr [si + 0x16]
1000:176f	mov	al, byte ptr [si + 0x16]
1000:1772	shr	al, 1
1000:1774	and	al, 3
1000:1776	mov	byte ptr [si + 4], al
1000:1779	mov	bx, 0xe2b
1000:177c	call	0x2121
1000:177f	call	0x10c6
1000:1782	ret	
                sub_1176c ENDP
*/
void sub_1176c()
{
    // coverage: 0x196c-0x1983 method sub_1176c
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al &= 0x03;
    memoryASet(ds, si + 4, al);
    bx = 0x0e2b;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:1783 sub_11783()
                sub_11783 PROC
1000:1783	inc	byte ptr [si + 0x16]
1000:1786	mov	al, byte ptr [si + 0x16]
1000:1789	shr	al, 1
1000:178b	and	al, 7
1000:178d	cmp	al, 6
1000:178f	jb	loc_11797
1000:1791	mov	al, 0
1000:1793	mov	byte ptr [si + 0x16], 0
        	loc_11797:
1000:1797	mov	bl, al
1000:1799	mov	bh, 0
1000:179b	mov	al, byte ptr [bx + 0xe4c]
1000:179f	mov	byte ptr [si + 4], al
1000:17a2	mov	bx, 0xe52
1000:17a5	call	0x2121
1000:17a8	call	0x10c6
1000:17ab	ret	
                sub_11783 ENDP
*/
void sub_11783()
{
    // coverage: 0x1983-0x19ac method sub_11783
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al &= 0x07;
    if (al < 0x06)
        goto loc_11797;
    al = 0x00;
    memoryASet(ds, si + 22, 0x00);
loc_11797:
    bl = al;
    bh = 0x00;
    al = memoryAGet(ds, bx + 3660);
    memoryASet(ds, si + 4, al);
    bx = 0x0e52;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:17ac sub_117ac()
                sub_117ac PROC
1000:17ac	call	0x215b
1000:17af	cmp	cx, 0
1000:17b2	je	loc_117cc
1000:17b4	dec	byte ptr [si + 0x16]
1000:17b7	jns	loc_117c4
1000:17b9	mov	byte ptr [si + 0x16], 8
1000:17bd	mov	byte ptr [0x9518], 1
1000:17c2	jmp	loc_117c9
        	loc_117c4:
1000:17c4	mov	byte ptr [0x9518], 0
        	loc_117c9:
1000:17c9	call	0x1f0b
        	loc_117cc:
1000:17cc	mov	bx, 0xe73
1000:17cf	call	0x2121
1000:17d2	call	0x10c6
1000:17d5	ret	
                sub_117ac ENDP
*/
void sub_117ac()
{
    // coverage: 0x19ac-0x19d6 method sub_117ac
    sub_1215b();
    if (cx == 0x0000)
        goto loc_117cc;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_117c4;
    memoryASet(ds, si + 22, 0x08);
    memoryASet(ds, 0x9518, 0x01);
    goto loc_117c9;
loc_117c4:
    memoryASet(ds, 0x9518, 0x00);
loc_117c9:
    sub_11f0b();
loc_117cc:
    bx = 0x0e73;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:17d6 sub_117d6()
                sub_117d6 PROC
1000:17d6	call	0x215b
1000:17d9	cmp	cx, 0
1000:17dc	je	loc_117ea
1000:17de	dec	byte ptr [si + 0x16]
1000:17e1	jns	loc_117ea
1000:17e3	mov	byte ptr [si + 0x16], 0x12
1000:17e7	call	0x2005
        	loc_117ea:
1000:17ea	mov	bx, 0xe9c
1000:17ed	call	0x2121
1000:17f0	call	0x10c6
1000:17f3	ret	
                sub_117d6 ENDP
*/
void sub_117d6()
{
    // coverage: 0x19d6-0x19f4 method sub_117d6
    sub_1215b();
    if (cx == 0x0000)
        goto loc_117ea;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_117ea;
    memoryASet(ds, si + 22, 0x12);
    sub_12005();
loc_117ea:
    bx = 0x0e9c;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:17f4 sub_117f4()
                sub_117f4 PROC
1000:17f4	call	0x10c6
1000:17f7	mov	al, byte ptr [si]
1000:17f9	cmp	al, 0
1000:17fb	jne	loc_117fe
1000:17fd	ret	
        	loc_117fe:
1000:17fe	mov	al, byte ptr [si + 1]
1000:1801	cmp	al, 2
1000:1803	jne	loc_1180b
1000:1805	add	word ptr [si + 7], 3
1000:1809	jmp	loc_11835
        	loc_1180b:
1000:180b	cmp	al, 0
1000:180d	jne	loc_11815
1000:180f	sub	word ptr [si + 5], 4
1000:1813	jmp	loc_11835
        	loc_11815:
1000:1815	cmp	al, 1
1000:1817	jne	loc_11823
1000:1819	sub	word ptr [si + 5], 4
1000:181d	add	word ptr [si + 7], 3
1000:1821	jmp	loc_11835
        	loc_11823:
1000:1823	cmp	al, 3
1000:1825	jne	loc_11831
1000:1827	add	word ptr [si + 5], 4
1000:182b	add	word ptr [si + 7], 3
1000:182f	jmp	loc_11835
        	loc_11831:
1000:1831	add	word ptr [si + 5], 4
        	loc_11835:
1000:1835	and	word ptr [si + 7], 0x3ff
1000:183a	mov	ax, word ptr [si + 5]
1000:183d	cmp	ax, 8
1000:1840	jge	loc_11846
1000:1842	mov	byte ptr [si], 0
1000:1845	ret	
        	loc_11846:
1000:1846	cmp	ax, 0xf8
1000:1849	jle	loc_1184f
1000:184b	mov	byte ptr [si], 0
1000:184e	ret	
        	loc_1184f:
1000:184f	inc	byte ptr [si + 0x16]
1000:1852	mov	bl, byte ptr [si + 0x16]
1000:1855	cmp	bl, 0x10
1000:1858	jb	loc_1185e
1000:185a	call	0x2099
1000:185d	ret	
        	loc_1185e:
1000:185e	mov	bh, 0
1000:1860	mov	al, byte ptr [bx + 0x1467]
1000:1864	add	byte ptr [si + 3], al
1000:1867	mov	al, byte ptr [0x1b9c]
1000:186a	cmp	al, 0x11
1000:186c	jne	loc_1186f
1000:186e	ret	
        	loc_1186f:
1000:186f	mov	ax, word ptr [si + 5]
1000:1872	sub	ax, word ptr [0x1b8f]
1000:1876	jns	loc_1187a
1000:1878	neg	ax
        	loc_1187a:
1000:187a	cmp	ax, 0xe
1000:187d	jae	loc_118a8
1000:187f	mov	ax, word ptr [si + 7]
1000:1882	sub	ax, word ptr [0x1b91]
1000:1886	jns	loc_1188a
1000:1888	neg	ax
        	loc_1188a:
1000:188a	cmp	ax, 0xa
1000:188d	jae	loc_118a8
1000:188f	mov	al, byte ptr [si + 3]
1000:1892	sub	al, byte ptr [0x1b8d]
1000:1896	jns	loc_1189a
1000:1898	neg	al
        	loc_1189a:
1000:189a	cmp	al, 0x10
1000:189c	jae	loc_118a8
1000:189e	sub	word ptr [0x9544], 0xa
1000:18a3	mov	al, 5
1000:18a5	call	0x3840
        	loc_118a8:
1000:18a8	ret	
                sub_117f4 ENDP
*/
void sub_117f4()
{
    // coverage: 0x19f4-0x1aa9 method sub_117f4
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_117fe;
    return;
loc_117fe:
    al = memoryAGet(ds, si + 1);
    if (al != 0x02)
        goto loc_1180b;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0003);
    goto loc_11835;
loc_1180b:
    if (al != 0x00)
        goto loc_11815;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0004);
    goto loc_11835;
loc_11815:
    if (al != 0x01)
        goto loc_11823;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0004);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0003);
    goto loc_11835;
loc_11823:
    if (al != 0x03)
        goto loc_11831;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0004);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0003);
    goto loc_11835;
loc_11831:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0004);
loc_11835:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    ax = memoryAGet16(ds, si + 5);
    if ((short)ax >= (short)0x0008)
        goto loc_11846;
    memoryASet(ds, si, 0x00);
    return;
loc_11846:
    if ((short)ax <= (short)0x00f8)
        goto loc_1184f;
    memoryASet(ds, si, 0x00);
    return;
loc_1184f:
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    bl = memoryAGet(ds, si + 22);
    if (bl < 0x10)
        goto loc_1185e;
    sub_12099();
    return;
loc_1185e:
    bh = 0x00;
    al = memoryAGet(ds, bx + 5223);
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + al);
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_1186f;
    return;
loc_1186f:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_1187a;
    ax = -ax;
loc_1187a:
    if (ax >= 0x000e)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_1188a;
    ax = -ax;
loc_1188a:
    if (ax >= 0x000a)
        return;
    al = memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, 0x1b8d);
    if ((char)al >= 0)
        goto loc_1189a;
    al = -al;
loc_1189a:
    if (al >= 0x10)
        return;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x000a);
    al = 0x05;
    sub_13840();
}
/* Assembly listing of 1000:18a9 sub_118a9()
                sub_118a9 PROC
1000:18a9	call	0x215b
1000:18ac	cmp	cx, 0
1000:18af	je	loc_118bd
1000:18b1	dec	byte ptr [si + 0x16]
1000:18b4	jns	loc_118bd
1000:18b6	mov	byte ptr [si + 0x16], 0x28
1000:18ba	call	0x1fba
        	loc_118bd:
1000:18bd	mov	bx, 0xec5
1000:18c0	call	0x2121
1000:18c3	call	0x10c6
1000:18c6	ret	
                sub_118a9 ENDP
*/
void sub_118a9()
{
    // coverage: 0x1aa9-0x1ac7 method sub_118a9
    sub_1215b();
    if (cx == 0x0000)
        goto loc_118bd;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_118bd;
    memoryASet(ds, si + 22, 0x28);
    sub_11fba();
loc_118bd:
    bx = 0x0ec5;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:18c7 sub_118c7()
                sub_118c7 PROC
1000:18c7	mov	al, byte ptr [0x952e]
1000:18ca	and	al, byte ptr [0x952f]
1000:18ce	and	al, byte ptr [0x9530]
1000:18d2	and	al, byte ptr [0x9531]
1000:18d6	and	al, byte ptr [0x9532]
1000:18da	and	al, byte ptr [0x9533]
1000:18de	jne	loc_118e4
1000:18e0	call	0x10c6
1000:18e3	ret	
        	loc_118e4:
1000:18e4	mov	ax, word ptr [0x1b8f]
1000:18e7	sub	ax, word ptr [si + 5]
1000:18ea	sub	ax, 0xc
1000:18ed	jns	loc_118f1
1000:18ef	neg	ax
        	loc_118f1:
1000:18f1	mov	cx, word ptr [0x1b91]
1000:18f5	sub	cx, 8
1000:18f8	sub	cx, word ptr [si + 7]
1000:18fb	jns	loc_118ff
1000:18fd	neg	cx
        	loc_118ff:
1000:18ff	mov	bl, byte ptr [si + 4]
1000:1902	shr	bl, 1
1000:1904	add	ax, cx
1000:1906	cmp	ax, 0x40
1000:1909	ja	loc_11915
1000:190b	cmp	bl, 8
1000:190e	je	loc_11913
1000:1910	inc	byte ptr [si + 4]
        	loc_11913:
1000:1913	jmp	loc_1191d
        	loc_11915:
1000:1915	cmp	bl, 0
1000:1918	je	loc_1191d
1000:191a	dec	byte ptr [si + 4]
        	loc_1191d:
1000:191d	push	bx
1000:191e	mov	bh, 0
1000:1920	shl	bx, 1
1000:1922	mov	ax, word ptr [bx + 0x1483]
1000:1926	mov	word ptr [si + 0xf], ax
1000:1929	pop	bx
1000:192a	cmp	bl, 2
1000:192d	jb	loc_1196b
1000:192f	mov	ax, word ptr [0x1b8f]
1000:1932	sub	ax, word ptr [si + 5]
1000:1935	sub	ax, 0xc
1000:1938	jns	loc_11947
1000:193a	neg	ax
1000:193c	cmp	ax, 0x18
1000:193f	ja	loc_11945
1000:1941	inc	word ptr [0x1b8f]
        	loc_11945:
1000:1945	jmp	loc_11952
        	loc_11947:
1000:1947	je	loc_11952
1000:1949	cmp	ax, 0x18
1000:194c	ja	loc_11952
1000:194e	dec	word ptr [0x1b8f]
        	loc_11952:
1000:1952	cmp	bl, 8
1000:1955	jne	loc_1196b
1000:1957	cmp	cx, 8
1000:195a	ja	loc_1196b
1000:195c	cmp	ax, 8
1000:195f	ja	loc_1196b
1000:1961	mov	al, byte ptr [0x1b9c]
1000:1964	cmp	al, 0x11
1000:1966	je	loc_1196b
1000:1968	call	0x196f
        	loc_1196b:
1000:196b	call	0x10c6
1000:196e	ret	
                sub_118c7 ENDP
*/
void sub_118c7()
{
    // coverage: 0x1ac7-0x1b6f method sub_118c7
    al = memoryAGet(ds, 0x952e);
    al &= memoryAGet(ds, 0x952f);
    al &= memoryAGet(ds, 0x9530);
    al &= memoryAGet(ds, 0x9531);
    al &= memoryAGet(ds, 0x9532);
    al &= memoryAGet(ds, 0x9533);
    if (al != 0)
        goto loc_118e4;
    sub_110c6();
    return;
loc_118e4:
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_118f1;
    ax = -ax;
loc_118f1:
    cx = memoryAGet16(ds, 0x1b91);
    cx -= 0x0008;
    cx -= memoryAGet16(ds, si + 7);
    if ((short)cx >= 0)
        goto loc_118ff;
    cx = -cx;
loc_118ff:
    bl = memoryAGet(ds, si + 4);
    bl >>= 1;
    ax += cx;
    if (ax > 0x0040)
        goto loc_11915;
    if (bl == 0x08)
        goto loc_11913;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) + 1);
loc_11913:
    goto loc_1191d;
loc_11915:
    if (bl == 0x00)
        goto loc_1191d;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) - 1);
loc_1191d:
    push(bx);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5251);
    memoryASet16(ds, si + 15, ax);
    bx = pop();
    if (bl < 0x02)
        goto loc_1196b;
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11947;
    ax = -ax;
    if (ax > 0x0018)
        goto loc_11945;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) + 1);
loc_11945:
    goto loc_11952;
loc_11947:
    if (ax == 0)
        goto loc_11952;
    if (ax > 0x0018)
        goto loc_11952;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) - 1);
loc_11952:
    if (bl != 0x08)
        goto loc_1196b;
    if (cx > 0x0008)
        goto loc_1196b;
    if (ax > 0x0008)
        goto loc_1196b;
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_1196b;
    sub_1196f();
loc_1196b:
    sub_110c6();
}
/* Assembly listing of 1000:196f sub_1196f()
                sub_1196f PROC
1000:196f	mov	al, byte ptr [0x1b8e]
1000:1972	cmp	al, 0
1000:1974	jne	loc_11982
1000:1976	mov	byte ptr [0x951d], 0xf0
1000:197b	mov	byte ptr [0x94ff], 1
1000:1980	jmp	loc_11992
        	loc_11982:
1000:1982	push	si
1000:1983	mov	byte ptr [0x1b8e], 0
1000:1988	mov	si, 0x1b8a
1000:198b	mov	bx, 0xd49
1000:198e	call	0x2121
1000:1991	pop	si
        	loc_11992:
1000:1992	ret	
                sub_1196f ENDP
*/
void sub_1196f()
{
    // coverage: 0x1b6f-0x1b93 method sub_1196f
    al = memoryAGet(ds, 0x1b8e);
    if (al != 0x00)
        goto loc_11982;
    memoryASet(ds, 0x951d, 0xf0);
    memoryASet(ds, 0x94ff, 0x01);
    return;
loc_11982:
    push(si);
    memoryASet(ds, 0x1b8e, 0x00);
    si = 0x1b8a;
    bx = 0x0d49;
    sub_12121();
    si = pop();
}
/* Assembly listing of 1000:1993 sub_11993()
                sub_11993 PROC
1000:1993	call	0x1a04
1000:1996	mov	al, byte ptr [0x94ff]
1000:1999	cmp	al, 1
1000:199b	jne	loc_119c1
1000:199d	mov	al, byte ptr [0x9501]
1000:19a0	mov	bl, al
1000:19a2	shl	al, 1
1000:19a4	add	bl, al
1000:19a6	add	bl, byte ptr [0x9502]
1000:19aa	mov	bh, 0
1000:19ac	shl	bx, 1
1000:19ae	mov	ax, word ptr [bx + 0x1495]
1000:19b2	mov	bh, ah
1000:19b4	and	ax, 0x3ff
1000:19b7	mov	word ptr [0x950c], ax
1000:19ba	and	bh, 0xc0
1000:19bd	mov	byte ptr [0x951d], bh
        	loc_119c1:
1000:19c1	ret	
                sub_11993 ENDP
*/
void sub_11993()
{
    // coverage: 0x1b93-0x1bc2 method sub_11993
    sub_11a04();
    al = memoryAGet(ds, 0x94ff);
    if (al != 0x01)
        return;
    al = memoryAGet(ds, 0x9501);
    bl = al;
    al <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5269);
    bh = ah;
    ax &= 0x03ff;
    memoryASet16(ds, 0x950c, ax);
    bh &= 0xc0;
    memoryASet(ds, 0x951d, bh);
}
/* Assembly listing of 1000:19c2 sub_119c2()
                sub_119c2 PROC
1000:19c2	call	0x1a04
1000:19c5	mov	al, byte ptr [0x94ff]
1000:19c8	cmp	al, 1
1000:19ca	jne	loc_11a03
1000:19cc	mov	al, byte ptr [0x9501]
1000:19cf	mov	bl, al
1000:19d1	shl	al, 1
1000:19d3	add	bl, al
1000:19d5	add	bl, byte ptr [0x9502]
1000:19d9	mov	bh, 0
1000:19db	shl	bx, 1
1000:19dd	mov	ax, word ptr [bx + 0x14c5]
1000:19e1	mov	bh, ah
1000:19e3	and	ax, 0x3ff
1000:19e6	mov	word ptr [0x950c], ax
1000:19e9	and	bh, 0xc0
1000:19ec	mov	byte ptr [0x951d], bh
1000:19f0	mov	byte ptr [0x950e], 1
1000:19f5	mov	al, byte ptr [0x9502]
1000:19f8	inc	al
1000:19fa	cmp	al, 2
1000:19fc	jbe	loc_11a00
1000:19fe	mov	al, 0
        	loc_11a00:
1000:1a00	mov	byte ptr [0x9502], al
        	loc_11a03:
1000:1a03	ret	
                sub_119c2 ENDP
*/
void sub_119c2()
{
    // coverage: 0x1bc2-0x1c04 method sub_119c2
    sub_11a04();
    al = memoryAGet(ds, 0x94ff);
    if (al != 0x01)
        return;
    al = memoryAGet(ds, 0x9501);
    bl = al;
    al <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5317);
    bh = ah;
    ax &= 0x03ff;
    memoryASet16(ds, 0x950c, ax);
    bh &= 0xc0;
    memoryASet(ds, 0x951d, bh);
    memoryASet(ds, 0x950e, 0x01);
    al = memoryAGet(ds, 0x9502);
    al++;
    if (al <= 0x02)
        goto loc_11a00;
    al = 0x00;
loc_11a00:
    memoryASet(ds, 0x9502, al);
}
/* Assembly listing of 1000:1a04 sub_11a04()
                sub_11a04 PROC
1000:1a04	mov	ax, word ptr [0x1b8f]
1000:1a07	sub	ax, word ptr [si + 5]
1000:1a0a	sub	ax, 0xc
1000:1a0d	jns	loc_11a11
1000:1a0f	neg	ax
        	loc_11a11:
1000:1a11	mov	cx, word ptr [0x1b91]
1000:1a15	sub	cx, word ptr [si + 7]
1000:1a18	jns	loc_11a1c
1000:1a1a	neg	cx
        	loc_11a1c:
1000:1a1c	mov	bl, byte ptr [si + 4]
1000:1a1f	shr	bl, 1
1000:1a21	add	ax, cx
1000:1a23	cmp	ax, 0x40
1000:1a26	ja	loc_11a32
1000:1a28	cmp	bl, 6
1000:1a2b	je	loc_11a30
1000:1a2d	inc	byte ptr [si + 4]
        	loc_11a30:
1000:1a30	jmp	loc_11a3a
        	loc_11a32:
1000:1a32	cmp	bl, 0
1000:1a35	je	loc_11a3a
1000:1a37	dec	byte ptr [si + 4]
        	loc_11a3a:
1000:1a3a	cmp	bl, 6
1000:1a3d	jne	loc_11a45
1000:1a3f	mov	byte ptr [si + 2], 0
1000:1a43	jmp	loc_11a56
        	loc_11a45:
1000:1a45	push	bx
1000:1a46	mov	byte ptr [si + 2], 7
1000:1a4a	mov	bh, 0
1000:1a4c	shl	bx, 1
1000:1a4e	mov	ax, word ptr [bx + 0x1477]
1000:1a52	mov	word ptr [si + 0xf], ax
1000:1a55	pop	bx
        	loc_11a56:
1000:1a56	cmp	bl, 1
1000:1a59	jb	loc_11a9a
1000:1a5b	mov	ax, word ptr [0x1b8f]
1000:1a5e	sub	ax, word ptr [si + 5]
1000:1a61	sub	ax, 0xc
1000:1a64	jns	loc_11a73
1000:1a66	neg	ax
1000:1a68	cmp	ax, 0x18
1000:1a6b	ja	loc_11a71
1000:1a6d	inc	word ptr [0x1b8f]
        	loc_11a71:
1000:1a71	jmp	loc_11a7e
        	loc_11a73:
1000:1a73	je	loc_11a7e
1000:1a75	cmp	ax, 0x18
1000:1a78	ja	loc_11a7e
1000:1a7a	dec	word ptr [0x1b8f]
        	loc_11a7e:
1000:1a7e	cmp	cx, 8
1000:1a81	ja	loc_11a9a
1000:1a83	cmp	ax, 8
1000:1a86	ja	loc_11a9a
1000:1a88	mov	al, byte ptr [0x1b9c]
1000:1a8b	cmp	al, 0x11
1000:1a8d	je	loc_11a9a
1000:1a8f	mov	ax, word ptr [0x1b8f]
1000:1a92	mov	word ptr [0x950a], ax
1000:1a95	mov	byte ptr [0x94ff], 1
        	loc_11a9a:
1000:1a9a	call	0x10c6
1000:1a9d	ret	
                sub_11a04 ENDP
*/
void sub_11a04()
{
    // coverage: 0x1c04-0x1c9e method sub_11a04
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11a11;
    ax = -ax;
loc_11a11:
    cx = memoryAGet16(ds, 0x1b91);
    cx -= memoryAGet16(ds, si + 7);
    if ((short)cx >= 0)
        goto loc_11a1c;
    cx = -cx;
loc_11a1c:
    bl = memoryAGet(ds, si + 4);
    bl >>= 1;
    ax += cx;
    if (ax > 0x0040)
        goto loc_11a32;
    if (bl == 0x06)
        goto loc_11a30;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) + 1);
loc_11a30:
    goto loc_11a3a;
loc_11a32:
    if (bl == 0x00)
        goto loc_11a3a;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) - 1);
loc_11a3a:
    if (bl != 0x06)
        goto loc_11a45;
    memoryASet(ds, si + 2, 0x00);
    goto loc_11a56;
loc_11a45:
    push(bx);
    memoryASet(ds, si + 2, 0x07);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5239);
    memoryASet16(ds, si + 15, ax);
    bx = pop();
loc_11a56:
    if (bl < 0x01)
        goto loc_11a9a;
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11a73;
    ax = -ax;
    if (ax > 0x0018)
        goto loc_11a71;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) + 1);
loc_11a71:
    goto loc_11a7e;
loc_11a73:
    if (ax == 0)
        goto loc_11a7e;
    if (ax > 0x0018)
        goto loc_11a7e;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) - 1);
loc_11a7e:
    if (cx > 0x0008)
        goto loc_11a9a;
    if (ax > 0x0008)
        goto loc_11a9a;
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_11a9a;
    ax = memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, 0x950a, ax);
    memoryASet(ds, 0x94ff, 0x01);
loc_11a9a:
    sub_110c6();
}
/* Assembly listing of 1000:1a9e sub_11a9e()
                sub_11a9e PROC
1000:1a9e	call	0x10c6
1000:1aa1	mov	al, byte ptr [si]
1000:1aa3	cmp	al, 0
1000:1aa5	jne	loc_11aa8
1000:1aa7	ret	
        	loc_11aa8:
1000:1aa8	mov	bx, word ptr [0x1b91]
1000:1aac	sub	bx, word ptr [si + 7]
1000:1aaf	jns	loc_11abb
1000:1ab1	cmp	bx, -0x10
1000:1ab4	jge	loc_11aba
1000:1ab6	mov	byte ptr [si + 2], 1
        	loc_11aba:
1000:1aba	ret	
        	loc_11abb:
1000:1abb	cmp	bx, 0x20
1000:1abe	jle	loc_11ac1
1000:1ac0	ret	
        	loc_11ac1:
1000:1ac1	mov	ax, word ptr [0x1b8f]
1000:1ac4	sub	ax, word ptr [si + 5]
1000:1ac7	sub	ax, 0xc
1000:1aca	jns	loc_11ad9
1000:1acc	neg	ax
1000:1ace	cmp	ax, 0x18
1000:1ad1	jae	loc_11ad7
1000:1ad3	inc	word ptr [0x1b8f]
        	loc_11ad7:
1000:1ad7	jmp	loc_11ae7
        	loc_11ad9:
1000:1ad9	cmp	ax, 0x18
1000:1adc	jae	loc_11ae7
1000:1ade	cmp	ax, 0
1000:1ae1	je	loc_11ae7
1000:1ae3	dec	word ptr [0x1b8f]
        	loc_11ae7:
1000:1ae7	cmp	bx, 8
1000:1aea	jbe	loc_11aed
1000:1aec	ret	
        	loc_11aed:
1000:1aed	cmp	ax, 2
1000:1af0	ja	loc_11af8
1000:1af2	inc	word ptr [0x9538]
1000:1af6	jmp	loc_11b08
        	loc_11af8:
1000:1af8	cmp	ax, 0x24
1000:1afb	jae	loc_11b08
1000:1afd	mov	word ptr [0x9542], 0
1000:1b03	mov	al, 6
1000:1b05	call	0x3840
        	loc_11b08:
1000:1b08	ret	
                sub_11a9e ENDP
*/
void sub_11a9e()
{
    // coverage: 0x1c9e-0x1d09 method sub_11a9e
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11aa8;
    return;
loc_11aa8:
    bx = memoryAGet16(ds, 0x1b91);
    bx -= memoryAGet16(ds, si + 7);
    if ((short)bx >= 0)
        goto loc_11abb;
    if ((short)bx >= (short)0xfff0)
        goto loc_11aba;
    memoryASet(ds, si + 2, 0x01);
loc_11aba:
    return;
loc_11abb:
    if ((short)bx <= (short)0x0020)
        goto loc_11ac1;
    return;
loc_11ac1:
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11ad9;
    ax = -ax;
    if (ax >= 0x0018)
        goto loc_11ad7;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) + 1);
loc_11ad7:
    goto loc_11ae7;
loc_11ad9:
    if (ax >= 0x0018)
        goto loc_11ae7;
    if (ax == 0x0000)
        goto loc_11ae7;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) - 1);
loc_11ae7:
    if (bx <= 0x0008)
        goto loc_11aed;
    return;
loc_11aed:
    if (ax > 0x0002)
        goto loc_11af8;
    memoryASet16(ds, 0x9538, memoryAGet16(ds, 0x9538) + 1);
    return;
loc_11af8:
    if (ax >= 0x0024)
        return;
    memoryASet16(ds, 0x9542, 0x0000);
    al = 0x06;
    sub_13840();
}
/* Assembly listing of 1000:1b09 sub_11b09()
                sub_11b09 PROC
1000:1b09	call	0x10c6
1000:1b0c	mov	al, byte ptr [si]
1000:1b0e	cmp	al, 0
1000:1b10	jne	loc_11b13
1000:1b12	ret	
        	loc_11b13:
1000:1b13	mov	al, byte ptr [0x1b9c]
1000:1b16	cmp	al, 0x11
1000:1b18	jne	loc_11b1b
1000:1b1a	ret	
        	loc_11b1b:
1000:1b1b	mov	ax, word ptr [si + 5]
1000:1b1e	sub	ax, word ptr [0x1b8f]
1000:1b22	jns	loc_11b26
1000:1b24	neg	ax
        	loc_11b26:
1000:1b26	cmp	ax, 0x12
1000:1b29	jae	loc_11b49
1000:1b2b	mov	ax, word ptr [si + 7]
1000:1b2e	sub	ax, word ptr [0x1b91]
1000:1b32	jns	loc_11b36
1000:1b34	neg	ax
        	loc_11b36:
1000:1b36	cmp	ax, 0x10
1000:1b39	jae	loc_11b49
1000:1b3b	mov	byte ptr [si], 0
1000:1b3e	mov	al, byte ptr [si + 1]
1000:1b41	call	0x2b28
1000:1b44	mov	al, 0xa
1000:1b46	call	0x3840
        	loc_11b49:
1000:1b49	ret	
                sub_11b09 ENDP
*/
void sub_11b09()
{
    // coverage: 0x1d09-0x1d4a method sub_11b09
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11b13;
    return;
loc_11b13:
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_11b1b;
    return;
loc_11b1b:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_11b26;
    ax = -ax;
loc_11b26:
    if (ax >= 0x0012)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_11b36;
    ax = -ax;
loc_11b36:
    if (ax >= 0x0010)
        return;
    memoryASet(ds, si, 0x00);
    al = memoryAGet(ds, si + 1);
    sub_12b28();
    al = 0x0a;
    sub_13840();
}
/* Assembly listing of 1000:1b4a sub_11b4a()
                sub_11b4a PROC
1000:1b4a	sub	word ptr [si + 7], 2
1000:1b4e	and	word ptr [si + 7], 0x3ff
1000:1b53	call	0x10a0
1000:1b56	ret	
                sub_11b4a ENDP
*/
void sub_11b4a()
{
    // coverage: 0x1d4a-0x1d57 method sub_11b4a
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - 0x0002);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    sub_110a0();
}
/* Assembly listing of 1000:1b57 sub_11b57()
                sub_11b57 PROC
1000:1b57	mov	ax, word ptr [0x1b8f]
1000:1b5a	push	ax
1000:1b5b	mov	ax, word ptr [0x9528]
1000:1b5e	add	ax, 0x70
1000:1b61	and	ax, 0x3ff
1000:1b64	mov	word ptr [0x1b91], ax
1000:1b67	push	ax
1000:1b68	call	0x7fd
1000:1b6b	mov	byte ptr [0x1b8d], al
1000:1b6e	mov	byte ptr [0x1b9e], cl
1000:1b72	mov	byte ptr [0x1b8e], bl
1000:1b76	mov	si, 0x1b8a
1000:1b79	mov	bx, 0xd49
1000:1b7c	call	0x2121
1000:1b7f	ret	
                sub_11b57 ENDP
*/
void sub_11b57()
{
    // coverage: 0x1d57-0x1d80 method sub_11b57
    ax = memoryAGet16(ds, 0x1b8f);
    push(ax);
    ax = memoryAGet16(ds, 0x9528);
    ax += 0x0070;
    ax &= 0x03ff;
    memoryASet16(ds, 0x1b91, ax);
    push(ax);
    sub_107fd();
    memoryASet(ds, 0x1b8d, al);
    memoryASet(ds, 0x1b9e, cl);
    memoryASet(ds, 0x1b8e, bl);
    si = 0x1b8a;
    bx = 0x0d49;
    sub_12121();
}
/* Assembly listing of 1000:1b80 sub_11b80()
                sub_11b80 PROC
1000:1b80	mov	bx, word ptr [0x952a]
1000:1b84	mov	ax, word ptr [0x953a]
1000:1b87	cmp	ax, 0
1000:1b8a	jg	loc_11b91
1000:1b8c	mov	ax, 8
1000:1b8f	jmp	loc_11b94
        	loc_11b91:
1000:1b91	mov	ax, word ptr [0x954c]
        	loc_11b94:
1000:1b94	test	al, 4
1000:1b96	je	loc_11ba3
1000:1b98	inc	bx
1000:1b99	cmp	bx, 0x40
1000:1b9c	jle	loc_11ba1
1000:1b9e	mov	bx, 0x40
        	loc_11ba1:
1000:1ba1	jmp	loc_11bb4
        	loc_11ba3:
1000:1ba3	test	al, 8
1000:1ba5	je	loc_11bb4
1000:1ba7	sub	bx, 2
1000:1baa	cmp	bx, word ptr [0x94fc]
1000:1bae	jge	loc_11bb4
1000:1bb0	mov	bx, word ptr [0x94fc]
        	loc_11bb4:
1000:1bb4	mov	word ptr [0x952a], bx
1000:1bb8	ret	
                sub_11b80 ENDP
*/
void sub_11b80()
{
    // coverage: 0x1d80-0x1db9 method sub_11b80
    bx = memoryAGet16(ds, 0x952a);
    ax = memoryAGet16(ds, 0x953a);
    if ((short)ax > (short)0x0000)
        goto loc_11b91;
    ax = 0x0008;
    goto loc_11b94;
loc_11b91:
    ax = memoryAGet16(ds, 0x954c);
loc_11b94:
    if (!(al & 0x04))
        goto loc_11ba3;
    bx++;
    if ((short)bx <= (short)0x0040)
        goto loc_11ba1;
    bx = 0x0040;
loc_11ba1:
    goto loc_11bb4;
loc_11ba3:
    if (!(al & 0x08))
        goto loc_11bb4;
    bx -= 0x0002;
    if ((short)bx >= (short)memoryAGet16(ds, 0x94fc))
        goto loc_11bb4;
    bx = memoryAGet16(ds, 0x94fc);
loc_11bb4:
    memoryASet16(ds, 0x952a, bx);
}
/* Assembly listing of 1000:1bb9 sub_11bb9()
                sub_11bb9 PROC
1000:1bb9	mov	bx, word ptr [0x952a]
1000:1bbd	add	bx, 0xf
1000:1bc0	shr	bx, 1
1000:1bc2	shr	bx, 1
1000:1bc4	shr	bx, 1
1000:1bc6	mov	ax, bx
1000:1bc8	dec	ax
1000:1bc9	shr	bx, 1
1000:1bcb	add	ax, word ptr [0x950f]
1000:1bcf	cmp	ax, 0x8b
1000:1bd2	jbe	loc_11bdd
1000:1bd4	mov	ax, 0
1000:1bd7	mov	word ptr [0x953c], 0xffff
        	loc_11bdd:
1000:1bdd	mov	word ptr [0x950f], ax
1000:1be0	mov	ax, word ptr [0x9528]
1000:1be3	sub	ax, bx
1000:1be5	and	ax, 0x3ff
1000:1be8	mov	word ptr [0x9528], ax
1000:1beb	mov	ax, word ptr [0x9528]
1000:1bee	shr	ax, 1
1000:1bf0	shr	ax, 1
1000:1bf2	shr	ax, 1
1000:1bf4	shr	ax, 1
1000:1bf6	sub	ax, 3
1000:1bf9	and	ax, 0x3f
1000:1bfc	cmp	ax, word ptr [0x9507]
1000:1c00	je	loc_11c09
1000:1c02	mov	word ptr [0x9507], ax
1000:1c05	push	ax
1000:1c06	call	0x8ba
        	loc_11c09:
1000:1c09	ret	
                sub_11bb9 ENDP
*/
void sub_11bb9()
{
    // coverage: 0x1db9-0x1e0a method sub_11bb9
    bx = memoryAGet16(ds, 0x952a);
    bx += 0x000f;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    ax = bx;
    ax--;
    bx >>= 1;
    ax += memoryAGet16(ds, 0x950f);
    if (ax <= 0x008b)
        goto loc_11bdd;
    ax = 0x0000;
    memoryASet16(ds, 0x953c, 0xffff);
loc_11bdd:
    memoryASet16(ds, 0x950f, ax);
    ax = memoryAGet16(ds, 0x9528);
    ax -= bx;
    ax &= 0x03ff;
    memoryASet16(ds, 0x9528, ax);
    ax = memoryAGet16(ds, 0x9528);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax -= 0x0003;
    ax &= 0x003f;
    if (ax == memoryAGet16(ds, 0x9507))
        return;
    memoryASet16(ds, 0x9507, ax);
    push(ax);
    sub_108ba();
}
/* Assembly listing of 1000:1c0a sub_11c0a()
                sub_11c0a PROC
1000:1c0a	push	bp
1000:1c0b	mov	bp, sp
1000:1c0d	mov	bx, word ptr [bp + 6]
1000:1c10	mov	cx, word ptr [bp + 4]
1000:1c13	mov	si, 0x1b8a
        	loc_11c16:
1000:1c16	mov	al, byte ptr [si]
1000:1c18	test	al, 0x80
1000:1c1a	jne	loc_11c2f
1000:1c1c	test	al, 8
1000:1c1e	je	loc_11c2a
1000:1c20	cmp	cl, byte ptr [si + 0x14]
1000:1c23	jne	loc_11c2a
1000:1c25	cmp	bl, byte ptr [si + 0x13]
1000:1c28	je	loc_11c2f
        	loc_11c2a:
1000:1c2a	add	si, 0x17
1000:1c2d	jmp	loc_11c16
        	loc_11c2f:
1000:1c2f	pop	bp
1000:1c30	ret	4
                sub_11c0a ENDP
*/
void sub_11c0a()
{
    // coverage: 0x1e0a-0x1e33 method sub_11c0a
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 6 - 2);
    cx = memoryAGet16(ss, bp + 4 - 2);
    si = 0x1b8a;
loc_11c16:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_11c2f;
    if (!(al & 0x08))
        goto loc_11c2a;
    if (cl != memoryAGet(ds, si + 20))
        goto loc_11c2a;
    if (bl == memoryAGet(ds, si + 19))
        goto loc_11c2f;
loc_11c2a:
    si += 0x0017;
    goto loc_11c16;
loc_11c2f:
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:1c33 sub_11c33()
                sub_11c33 PROC
1000:1c33	mov	al, byte ptr [0x1b9c]
1000:1c36	cmp	al, 0x11
1000:1c38	jne	loc_11c3b
1000:1c3a	ret	
        	loc_11c3b:
1000:1c3b	mov	al, 0xc
1000:1c3d	call	0x3840
1000:1c40	mov	si, 0x1b8a
1000:1c43	call	0x20f0
1000:1c46	mov	byte ptr [0x1b9c], 0x11
1000:1c4b	mov	byte ptr [0x1b8c], 0
1000:1c50	mov	byte ptr [0x9514], 0
1000:1c55	ret	
                sub_11c33 ENDP
*/
void sub_11c33()
{
    // coverage: 0x1e33-0x1e56 method sub_11c33
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_11c3b;
    return;
loc_11c3b:
    al = 0x0c;
    sub_13840();
    si = 0x1b8a;
    sub_120f0();
    memoryASet(ds, 0x1b9c, 0x11);
    memoryASet(ds, 0x1b8c, 0x00);
    memoryASet(ds, 0x9514, 0x00);
}
/* Assembly listing of 1000:1c56 sub_11c56()
                sub_11c56 PROC
1000:1c56	neg	ax
1000:1c58	mov	word ptr [0x9544], ax
1000:1c5b	push	ax
1000:1c5c	mov	al, 6
1000:1c5e	call	0x3840
1000:1c61	pop	ax
1000:1c62	mov	ax, bx
1000:1c64	push	ax
1000:1c65	mov	al, byte ptr [0x1b9e]
1000:1c68	mov	ah, 0
1000:1c6a	push	ax
1000:1c6b	call	0x1c0a
1000:1c6e	mov	al, byte ptr [si]
1000:1c70	test	al, 0x80
1000:1c72	jne	loc_11c77
1000:1c74	call	0x20db
        	loc_11c77:
1000:1c77	ret	
                sub_11c56 ENDP
*/
void sub_11c56()
{
    // coverage: 0x1e56-0x1e78 method sub_11c56
    ax = -ax;
    memoryASet16(ds, 0x9544, ax);
    push(ax);
    al = 0x06;
    sub_13840();
    ax = pop();
    ax = bx;
    push(ax);
    al = memoryAGet(ds, 0x1b9e);
    ah = 0x00;
    push(ax);
    sub_11c0a();
    al = memoryAGet(ds, si);
    if (al & 0x80)
        return;
    sub_120db();
}
/* Assembly listing of 1000:1c78 sub_11c78()
                sub_11c78 PROC
1000:1c78	mov	ax, word ptr [0x9437]
1000:1c7b	mov	word ptr [0x9439], ax
1000:1c7e	mov	ax, word ptr [0x9435]
1000:1c81	mov	word ptr [0x9437], ax
1000:1c84	mov	ax, word ptr [0x9433]
1000:1c87	mov	word ptr [0x9435], ax
1000:1c8a	mov	ax, word ptr [0x1b8f]
1000:1c8d	mov	word ptr [0x9433], ax
1000:1c90	mov	ax, word ptr [0x943f]
1000:1c93	mov	word ptr [0x9441], ax
1000:1c96	mov	ax, word ptr [0x943d]
1000:1c99	mov	word ptr [0x943f], ax
1000:1c9c	mov	ax, word ptr [0x943b]
1000:1c9f	mov	word ptr [0x943d], ax
1000:1ca2	mov	ax, word ptr [0x1b91]
1000:1ca5	mov	word ptr [0x943b], ax
1000:1ca8	mov	al, byte ptr [0x9445]
1000:1cab	mov	byte ptr [0x9446], al
1000:1cae	mov	al, byte ptr [0x9444]
1000:1cb1	mov	byte ptr [0x9445], al
1000:1cb4	mov	al, byte ptr [0x9443]
1000:1cb7	mov	byte ptr [0x9444], al
1000:1cba	mov	al, byte ptr [0x1b8e]
1000:1cbd	mov	byte ptr [0x9443], al
1000:1cc0	mov	al, byte ptr [0x9449]
1000:1cc3	mov	byte ptr [0x944a], al
1000:1cc6	mov	al, byte ptr [0x9448]
1000:1cc9	mov	byte ptr [0x9449], al
1000:1ccc	mov	al, byte ptr [0x9447]
1000:1ccf	mov	byte ptr [0x9448], al
1000:1cd2	mov	al, byte ptr [0x1b8d]
1000:1cd5	mov	byte ptr [0x9447], al
1000:1cd8	ret	
                sub_11c78 ENDP
*/
void sub_11c78()
{
    // coverage: 0x1e78-0x1ed9 method sub_11c78
    ax = memoryAGet16(ds, 0x9437);
    memoryASet16(ds, 0x9439, ax);
    ax = memoryAGet16(ds, 0x9435);
    memoryASet16(ds, 0x9437, ax);
    ax = memoryAGet16(ds, 0x9433);
    memoryASet16(ds, 0x9435, ax);
    ax = memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, 0x9433, ax);
    ax = memoryAGet16(ds, 0x943f);
    memoryASet16(ds, 0x9441, ax);
    ax = memoryAGet16(ds, 0x943d);
    memoryASet16(ds, 0x943f, ax);
    ax = memoryAGet16(ds, 0x943b);
    memoryASet16(ds, 0x943d, ax);
    ax = memoryAGet16(ds, 0x1b91);
    memoryASet16(ds, 0x943b, ax);
    al = memoryAGet(ds, 0x9445);
    memoryASet(ds, 0x9446, al);
    al = memoryAGet(ds, 0x9444);
    memoryASet(ds, 0x9445, al);
    al = memoryAGet(ds, 0x9443);
    memoryASet(ds, 0x9444, al);
    al = memoryAGet(ds, 0x1b8e);
    memoryASet(ds, 0x9443, al);
    al = memoryAGet(ds, 0x9449);
    memoryASet(ds, 0x944a, al);
    al = memoryAGet(ds, 0x9448);
    memoryASet(ds, 0x9449, al);
    al = memoryAGet(ds, 0x9447);
    memoryASet(ds, 0x9448, al);
    al = memoryAGet(ds, 0x1b8d);
    memoryASet(ds, 0x9447, al);
}
/* Assembly listing of 1000:1cd9 sub_11cd9()
                sub_11cd9 PROC
1000:1cd9	mov	ax, word ptr [0x9439]
1000:1cdc	mov	word ptr [si + 5], ax
1000:1cdf	mov	ax, word ptr [0x9441]
1000:1ce2	add	ax, 6
1000:1ce5	and	ax, 0x3ff
1000:1ce8	mov	word ptr [si + 7], ax
1000:1ceb	mov	al, byte ptr [0x9446]
1000:1cee	mov	byte ptr [si + 4], al
1000:1cf1	mov	bl, al
1000:1cf3	mov	bh, 0
1000:1cf5	mov	cl, byte ptr [bx + 0xdb9]
1000:1cf9	mov	al, byte ptr [0x944a]
1000:1cfc	add	al, 6
1000:1cfe	mov	byte ptr [si + 3], al
1000:1d01	mov	al, byte ptr [si]
1000:1d03	test	al, 0x20
1000:1d05	jne	loc_11d10
1000:1d07	sub	word ptr [si + 5], 8
1000:1d0b	add	byte ptr [si + 3], cl
1000:1d0e	jmp	loc_11d17
        	loc_11d10:
1000:1d10	add	word ptr [si + 5], 8
1000:1d14	sub	byte ptr [si + 3], cl
        	loc_11d17:
1000:1d17	mov	bx, 0xdda
1000:1d1a	call	0x2121
1000:1d1d	ret	
                sub_11cd9 ENDP
*/
void sub_11cd9()
{
    // coverage: 0x1ed9-0x1f1e method sub_11cd9
    ax = memoryAGet16(ds, 0x9439);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x9441);
    ax += 0x0006;
    ax &= 0x03ff;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x9446);
    memoryASet(ds, si + 4, al);
    bl = al;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 3513);
    al = memoryAGet(ds, 0x944a);
    al += 0x06;
    memoryASet(ds, si + 3, al);
    al = memoryAGet(ds, si);
    if (al & 0x20)
        goto loc_11d10;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0008);
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + cl);
    goto loc_11d17;
loc_11d10:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0008);
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) - cl);
loc_11d17:
    bx = 0x0dda;
    sub_12121();
}
/* Assembly listing of 1000:1d1e sub_11d1e()
                sub_11d1e PROC
1000:1d1e	mov	si, 0x135e
1000:1d21	and	byte ptr [si], 0xdf
1000:1d24	mov	bl, byte ptr [0x1b8e]
1000:1d28	mov	bh, 0
1000:1d2a	mov	al, byte ptr [bx + 0x139d]
1000:1d2e	mov	byte ptr [si + 4], al
1000:1d31	mov	al, byte ptr [bx + 0x1375]
1000:1d35	cwde	
1000:1d36	add	ax, word ptr [0x1b8f]
1000:1d3a	mov	word ptr [si + 5], ax
1000:1d3d	mov	ax, word ptr [0x1b91]
1000:1d40	sub	ax, 4
1000:1d43	and	ax, 0x3ff
1000:1d46	mov	word ptr [si + 7], ax
1000:1d49	mov	al, byte ptr [0x1b8d]
1000:1d4c	add	al, byte ptr [bx + 0x1389]
1000:1d50	mov	byte ptr [si + 3], al
1000:1d53	mov	bl, byte ptr [si + 4]
1000:1d56	mov	bh, 0
1000:1d58	mov	al, byte ptr [bx + 0x13a7]
1000:1d5c	mov	byte ptr [si + 0xa], al
1000:1d5f	shl	bx, 1
1000:1d61	mov	ax, word ptr [bx + 0x13aa]
1000:1d65	mov	word ptr [si + 0xf], ax
1000:1d68	call	0xb58
1000:1d6b	mov	si, 0xff7
1000:1d6e	mov	ax, word ptr [0x1363]
1000:1d71	mov	word ptr [si + 5], ax
1000:1d74	mov	ax, word ptr [0x1365]
1000:1d77	mov	word ptr [si + 7], ax
1000:1d7a	mov	al, byte ptr [0x1361]
1000:1d7d	mov	byte ptr [si + 3], al
1000:1d80	inc	byte ptr [0x9516]
1000:1d84	mov	bl, byte ptr [0x9516]
1000:1d88	and	bx, 0xf
1000:1d8b	mov	al, byte ptr [bx + 0xfe7]
1000:1d8f	mov	byte ptr [si + 4], al
1000:1d92	mov	bx, 0x100e
1000:1d95	call	0x2121
1000:1d98	call	0xb58
1000:1d9b	mov	si, 0x135e
1000:1d9e	or	byte ptr [si], 0x20
1000:1da1	mov	bl, byte ptr [0x1b8e]
1000:1da5	mov	bh, 0
1000:1da7	mov	al, byte ptr [bx + 0x137f]
1000:1dab	cwde	
1000:1dac	add	ax, word ptr [0x1b8f]
1000:1db0	mov	word ptr [si + 5], ax
1000:1db3	mov	al, byte ptr [0x1b8d]
1000:1db6	add	al, byte ptr [bx + 0x1393]
1000:1dba	mov	byte ptr [si + 3], al
1000:1dbd	call	0xb58
1000:1dc0	mov	si, 0xff7
1000:1dc3	mov	ax, word ptr [0x1363]
1000:1dc6	mov	word ptr [si + 5], ax
1000:1dc9	mov	ax, word ptr [0x1365]
1000:1dcc	mov	word ptr [si + 7], ax
1000:1dcf	mov	al, byte ptr [0x1361]
1000:1dd2	mov	byte ptr [si + 3], al
1000:1dd5	call	0xb58
1000:1dd8	mov	ax, word ptr [0x9511]
1000:1ddb	add	ax, bx
1000:1ddd	cmp	ax, 0x10
1000:1de0	jbe	loc_11deb
1000:1de2	mov	ax, 0
1000:1de5	mov	word ptr [0x9540], 0xffff
        	loc_11deb:
1000:1deb	mov	word ptr [0x9511], ax
1000:1dee	ret	
                sub_11d1e ENDP
*/
void sub_11d1e()
{
    // coverage: 0x1f1e-0x1fef method sub_11d1e
    si = 0x135e;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    bl = memoryAGet(ds, 0x1b8e);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5021);
    memoryASet(ds, si + 4, al);
    al = memoryAGet(ds, bx + 4981);
    cbw();
    ax += memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x1b91);
    ax -= 0x0004;
    ax &= 0x03ff;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1b8d);
    al += memoryAGet(ds, bx + 5001);
    memoryASet(ds, si + 3, al);
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5031);
    memoryASet(ds, si + 10, al);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5034);
    memoryASet16(ds, si + 15, ax);
    sub_10b58();
    si = 0x0ff7;
    ax = memoryAGet16(ds, 0x1363);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x1365);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1361);
    memoryASet(ds, si + 3, al);
    memoryASet(ds, 0x9516, memoryAGet(ds, 0x9516) + 1);
    bl = memoryAGet(ds, 0x9516);
    bx &= 0x000f;
    al = memoryAGet(ds, bx + 4071);
    memoryASet(ds, si + 4, al);
    bx = 0x100e;
    sub_12121();
    sub_10b58();
    si = 0x135e;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    bl = memoryAGet(ds, 0x1b8e);
    bh = 0x00;
    al = memoryAGet(ds, bx + 4991);
    cbw();
    ax += memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, si + 5, ax);
    al = memoryAGet(ds, 0x1b8d);
    al += memoryAGet(ds, bx + 5011);
    memoryASet(ds, si + 3, al);
    sub_10b58();
    si = 0x0ff7;
    ax = memoryAGet16(ds, 0x1363);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x1365);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1361);
    memoryASet(ds, si + 3, al);
    sub_10b58();
    ax = memoryAGet16(ds, 0x9511);
    ax += bx;
    if (ax <= 0x0010)
        goto loc_11deb;
    ax = 0x0000;
    memoryASet16(ds, 0x9540, 0xffff);
loc_11deb:
    memoryASet16(ds, 0x9511, ax);
}
/* Assembly listing of 1000:1def sub_11def()
                sub_11def PROC
1000:1def	inc	byte ptr [0x9516]
1000:1df3	mov	bl, byte ptr [0x9516]
1000:1df7	and	bx, 0xf
1000:1dfa	mov	al, byte ptr [bx + 0xfe7]
1000:1dfe	mov	byte ptr [0xffb], al
1000:1e01	mov	al, byte ptr [si + 1]
1000:1e04	cmp	al, 0
1000:1e06	jne	loc_11e2e
1000:1e08	mov	bl, byte ptr [si + 4]
1000:1e0b	mov	bh, 0
1000:1e0d	mov	cl, byte ptr [bx + 0x13cd]
1000:1e11	mov	ax, 0xfffd
1000:1e14	mov	bx, 8
1000:1e17	call	0x1e7d
1000:1e1a	mov	bl, byte ptr [si + 4]
1000:1e1d	mov	bh, 0
1000:1e1f	mov	cl, byte ptr [bx + 0x13d7]
1000:1e23	mov	ax, 3
1000:1e26	mov	bx, 8
1000:1e29	call	0x1e7d
1000:1e2c	jmp	loc_11e7c
        	loc_11e2e:
1000:1e2e	cmp	al, 1
1000:1e30	jne	loc_11e46
1000:1e32	mov	bl, byte ptr [si + 4]
1000:1e35	mov	bh, 0
1000:1e37	mov	cl, byte ptr [bx + 0x13e1]
1000:1e3b	mov	ax, 0
1000:1e3e	mov	bx, 8
1000:1e41	call	0x1e7d
1000:1e44	jmp	loc_11e7c
        	loc_11e46:
1000:1e46	mov	bl, byte ptr [si + 4]
1000:1e49	mov	bh, 0
1000:1e4b	mov	cl, byte ptr [bx + 0x13eb]
1000:1e4f	mov	ax, 0xfff9
1000:1e52	mov	bx, 8
1000:1e55	call	0x1e7d
1000:1e58	mov	bl, byte ptr [si + 4]
1000:1e5b	mov	bh, 0
1000:1e5d	mov	cl, byte ptr [bx + 0x13f5]
1000:1e61	mov	ax, 0
1000:1e64	mov	bx, 0xb
1000:1e67	call	0x1e7d
1000:1e6a	mov	bl, byte ptr [si + 4]
1000:1e6d	mov	bh, 0
1000:1e6f	mov	cl, byte ptr [bx + 0x13ff]
1000:1e73	mov	ax, 7
1000:1e76	mov	bx, 8
1000:1e79	call	0x1e7d
        	loc_11e7c:
1000:1e7c	ret	
                sub_11def ENDP
*/
void sub_11def()
{
    // coverage: 0x1fef-0x207d method sub_11def
    memoryASet(ds, 0x9516, memoryAGet(ds, 0x9516) + 1);
    bl = memoryAGet(ds, 0x9516);
    bx &= 0x000f;
    al = memoryAGet(ds, bx + 4071);
    memoryASet(ds, 0x0ffb, al);
    al = memoryAGet(ds, si + 1);
    if (al != 0x00)
        goto loc_11e2e;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5069);
    ax = 0xfffd;
    bx = 0x0008;
    sub_11e7d();
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5079);
    ax = 0x0003;
    bx = 0x0008;
    sub_11e7d();
    return;
loc_11e2e:
    if (al != 0x01)
        goto loc_11e46;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5089);
    ax = 0x0000;
    bx = 0x0008;
    sub_11e7d();
    return;
loc_11e46:
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5099);
    ax = 0xfff9;
    bx = 0x0008;
    sub_11e7d();
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5109);
    ax = 0x0000;
    bx = 0x000b;
    sub_11e7d();
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5119);
    ax = 0x0007;
    bx = 0x0008;
    sub_11e7d();
}
/* Assembly listing of 1000:1e7d sub_11e7d()
                sub_11e7d PROC
1000:1e7d	push	si
1000:1e7e	mov	di, 0xff7
1000:1e81	add	ax, word ptr [si + 5]
1000:1e84	mov	word ptr [di + 5], ax
1000:1e87	add	bx, word ptr [si + 7]
1000:1e8a	and	bx, 0x3ff
1000:1e8e	mov	word ptr [di + 7], bx
1000:1e91	add	cl, byte ptr [si + 3]
1000:1e94	mov	byte ptr [di + 3], cl
1000:1e97	mov	si, di
1000:1e99	mov	bx, 0x1039
1000:1e9c	call	0x2121
1000:1e9f	call	0xb58
1000:1ea2	cmp	si, 0
1000:1ea5	je	loc_11eb0
1000:1ea7	pop	ax
1000:1ea8	push	ax
1000:1ea9	cmp	ax, si
1000:1eab	jbe	loc_11eb0
1000:1ead	call	0x16d6
        	loc_11eb0:
1000:1eb0	pop	si
1000:1eb1	mov	al, byte ptr [0x9518]
1000:1eb4	cmp	al, 0
1000:1eb6	jne	loc_11eb9
1000:1eb8	ret	
        	loc_11eb9:
1000:1eb9	push	si
1000:1eba	mov	bl, byte ptr [si + 4]
1000:1ebd	mov	bh, 0
1000:1ebf	mov	si, 0x13b0
1000:1ec2	mov	al, byte ptr [bx + 0x139d]
1000:1ec6	mov	byte ptr [si + 4], al
1000:1ec9	mov	ax, word ptr [0xffc]
1000:1ecc	mov	word ptr [si + 5], ax
1000:1ecf	mov	ax, word ptr [0xffe]
1000:1ed2	mov	word ptr [si + 7], ax
1000:1ed5	mov	al, byte ptr [0xffa]
1000:1ed8	mov	byte ptr [si + 3], al
1000:1edb	mov	byte ptr [si + 1], 2
1000:1edf	mov	bl, byte ptr [si + 4]
1000:1ee2	mov	bh, 0
1000:1ee4	mov	al, byte ptr [bx + 0x13a7]
1000:1ee8	mov	byte ptr [si + 0xa], al
1000:1eeb	mov	byte ptr [si + 9], 4
1000:1eef	shl	bx, 1
1000:1ef1	mov	ax, word ptr [bx + 0x13c7]
1000:1ef5	mov	word ptr [si + 0xf], ax
1000:1ef8	call	0xb58
1000:1efb	cmp	si, 0
1000:1efe	je	loc_11f09
1000:1f00	pop	ax
1000:1f01	push	ax
1000:1f02	cmp	ax, si
1000:1f04	jbe	loc_11f09
1000:1f06	call	0x15fc
        	loc_11f09:
1000:1f09	pop	si
1000:1f0a	ret	
                sub_11e7d ENDP
*/
void sub_11e7d()
{
    // coverage: 0x207d-0x210b method sub_11e7d
    push(si);
    di = 0x0ff7;
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    bx += memoryAGet16(ds, si + 7);
    bx &= 0x03ff;
    memoryASet16(ds, di + 7, bx);
    cl += memoryAGet(ds, si + 3);
    memoryASet(ds, di + 3, cl);
    si = di;
    bx = 0x1039;
    sub_12121();
    sub_10b58();
    if (si == 0x0000)
        goto loc_11eb0;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11eb0;
    sub_116d6();
loc_11eb0:
    si = pop();
    al = memoryAGet(ds, 0x9518);
    if (al != 0x00)
        goto loc_11eb9;
    return;
loc_11eb9:
    push(si);
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    si = 0x13b0;
    al = memoryAGet(ds, bx + 5021);
    memoryASet(ds, si + 4, al);
    ax = memoryAGet16(ds, 0x0ffc);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x0ffe);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x0ffa);
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 1, 0x02);
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5031);
    memoryASet(ds, si + 10, al);
    memoryASet(ds, si + 9, 0x04);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5063);
    memoryASet16(ds, si + 15, ax);
    sub_10b58();
    if (si == 0x0000)
        goto loc_11f09;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11f09;
    sub_115fc();
loc_11f09:
    si = pop();
}
/* Assembly listing of 1000:1f0b sub_11f0b()
                sub_11f0b PROC
1000:1f0b	push	si
1000:1f0c	inc	byte ptr [0x9516]
1000:1f10	mov	bl, byte ptr [0x9516]
1000:1f14	and	bx, 0xf
1000:1f17	mov	al, byte ptr [bx + 0xfe7]
1000:1f1b	mov	byte ptr [0xffb], al
1000:1f1e	mov	di, 0xff7
1000:1f21	mov	bl, byte ptr [si + 4]
1000:1f24	mov	bh, 0
1000:1f26	mov	al, byte ptr [bx + 0x1409]
1000:1f2a	cwde	
1000:1f2b	add	ax, word ptr [si + 5]
1000:1f2e	mov	word ptr [di + 5], ax
1000:1f31	mov	al, byte ptr [bx + 0x140e]
1000:1f35	cwde	
1000:1f36	add	ax, word ptr [si + 7]
1000:1f39	and	ax, 0x3ff
1000:1f3c	mov	word ptr [di + 7], ax
1000:1f3f	mov	al, byte ptr [si + 3]
1000:1f42	add	al, 4
1000:1f44	mov	byte ptr [di + 3], al
1000:1f47	shl	bx, 1
1000:1f49	mov	bx, word ptr [bx + 0x102f]
1000:1f4d	mov	si, di
1000:1f4f	call	0x2121
1000:1f52	call	0xb58
1000:1f55	cmp	si, 0
1000:1f58	je	loc_11f63
1000:1f5a	pop	ax
1000:1f5b	push	ax
1000:1f5c	cmp	ax, si
1000:1f5e	jbe	loc_11f63
1000:1f60	call	0x16d6
        	loc_11f63:
1000:1f63	pop	si
1000:1f64	mov	al, byte ptr [0x9518]
1000:1f67	cmp	al, 0
1000:1f69	jne	loc_11f6c
1000:1f6b	ret	
        	loc_11f6c:
1000:1f6c	push	si
1000:1f6d	mov	di, 0x13b0
1000:1f70	mov	bl, byte ptr [si + 4]
1000:1f73	mov	bh, 0
1000:1f75	mov	byte ptr [di + 1], bl
1000:1f78	mov	ax, word ptr [0xffc]
1000:1f7b	mov	word ptr [di + 5], ax
1000:1f7e	mov	ax, word ptr [0xffe]
1000:1f81	mov	word ptr [di + 7], ax
1000:1f84	mov	al, byte ptr [0xffa]
1000:1f87	mov	byte ptr [di + 3], al
1000:1f8a	mov	al, byte ptr [bx + 0x1413]
1000:1f8e	mov	byte ptr [di + 9], al
1000:1f91	mov	al, byte ptr [bx + 0x1418]
1000:1f95	mov	byte ptr [di + 0xa], al
1000:1f98	mov	byte ptr [di + 4], 0
1000:1f9c	shl	bx, 1
1000:1f9e	mov	ax, word ptr [bx + 0x141d]
1000:1fa2	mov	word ptr [di + 0xf], ax
1000:1fa5	mov	si, di
1000:1fa7	call	0xb58
1000:1faa	cmp	si, 0
1000:1fad	je	loc_11fb8
1000:1faf	pop	ax
1000:1fb0	push	ax
1000:1fb1	cmp	ax, si
1000:1fb3	jbe	loc_11fb8
1000:1fb5	call	0x15fc
        	loc_11fb8:
1000:1fb8	pop	si
1000:1fb9	ret	
                sub_11f0b ENDP
*/
void sub_11f0b()
{
    // coverage: 0x210b-0x21ba method sub_11f0b
    push(si);
    memoryASet(ds, 0x9516, memoryAGet(ds, 0x9516) + 1);
    bl = memoryAGet(ds, 0x9516);
    bx &= 0x000f;
    al = memoryAGet(ds, bx + 4071);
    memoryASet(ds, 0x0ffb, al);
    di = 0x0ff7;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5129);
    cbw();
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    al = memoryAGet(ds, bx + 5134);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, si + 3);
    al += 0x04;
    memoryASet(ds, di + 3, al);
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4143);
    si = di;
    sub_12121();
    sub_10b58();
    if (si == 0x0000)
        goto loc_11f63;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11f63;
    sub_116d6();
loc_11f63:
    si = pop();
    al = memoryAGet(ds, 0x9518);
    if (al != 0x00)
        goto loc_11f6c;
    return;
loc_11f6c:
    push(si);
    di = 0x13b0;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    memoryASet(ds, di + 1, bl);
    ax = memoryAGet16(ds, 0x0ffc);
    memoryASet16(ds, di + 5, ax);
    ax = memoryAGet16(ds, 0x0ffe);
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, 0x0ffa);
    memoryASet(ds, di + 3, al);
    al = memoryAGet(ds, bx + 5139);
    memoryASet(ds, di + 9, al);
    al = memoryAGet(ds, bx + 5144);
    memoryASet(ds, di + 10, al);
    memoryASet(ds, di + 4, 0x00);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5149);
    memoryASet16(ds, di + 15, ax);
    si = di;
    sub_10b58();
    if (si == 0x0000)
        goto loc_11fb8;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11fb8;
    sub_115fc();
loc_11fb8:
    si = pop();
}
/* Assembly listing of 1000:1fba sub_11fba()
                sub_11fba PROC
1000:1fba	push	si
1000:1fbb	mov	di, 0x10e8
1000:1fbe	mov	bl, byte ptr [si + 4]
1000:1fc1	mov	byte ptr [di + 1], bl
1000:1fc4	mov	bh, 0
1000:1fc6	mov	al, byte ptr [bx + 0x10de]
1000:1fca	cwde	
1000:1fcb	add	ax, word ptr [si + 5]
1000:1fce	mov	word ptr [di + 5], ax
1000:1fd1	mov	al, byte ptr [bx + 0x10e3]
1000:1fd5	cwde	
1000:1fd6	add	ax, word ptr [si + 7]
1000:1fd9	and	ax, 0x3ff
1000:1fdc	mov	word ptr [di + 7], ax
1000:1fdf	mov	al, byte ptr [si + 3]
1000:1fe2	add	al, 8
1000:1fe4	mov	byte ptr [di + 3], al
1000:1fe7	shl	bx, 1
1000:1fe9	mov	bx, word ptr [bx + 0x10ff]
1000:1fed	mov	si, di
1000:1fef	call	0x2121
1000:1ff2	call	0xb58
1000:1ff5	cmp	si, 0
1000:1ff8	je	loc_12003
1000:1ffa	pop	ax
1000:1ffb	push	ax
1000:1ffc	cmp	ax, si
1000:1ffe	jbe	loc_12003
1000:2000	call	0x1429
        	loc_12003:
1000:2003	pop	si
1000:2004	ret	
                sub_11fba ENDP
*/
void sub_11fba()
{
    // coverage: 0x21ba-0x2205 method sub_11fba
    push(si);
    di = 0x10e8;
    bl = memoryAGet(ds, si + 4);
    memoryASet(ds, di + 1, bl);
    bh = 0x00;
    al = memoryAGet(ds, bx + 4318);
    cbw();
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    al = memoryAGet(ds, bx + 4323);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, si + 3);
    al += 0x08;
    memoryASet(ds, di + 3, al);
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4351);
    si = di;
    sub_12121();
    sub_10b58();
    if (si == 0x0000)
        goto loc_12003;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_12003;
    sub_11429();
loc_12003:
    si = pop();
}
/* Assembly listing of 1000:2005 sub_12005()
                sub_12005 PROC
1000:2005	push	si
1000:2006	mov	di, 0x1446
1000:2009	mov	bl, byte ptr [si + 4]
1000:200c	mov	byte ptr [di + 1], bl
1000:200f	mov	bh, 0
1000:2011	mov	al, byte ptr [bx + 0x145d]
1000:2015	cwde	
1000:2016	add	ax, word ptr [si + 5]
1000:2019	mov	word ptr [di + 5], ax
1000:201c	mov	al, byte ptr [bx + 0x1462]
1000:2020	cwde	
1000:2021	add	ax, word ptr [si + 7]
1000:2024	and	ax, 0x3ff
1000:2027	mov	word ptr [di + 7], ax
1000:202a	mov	al, byte ptr [si + 3]
1000:202d	add	al, 8
1000:202f	mov	byte ptr [di + 3], al
1000:2032	mov	si, di
1000:2034	call	0xb58
1000:2037	cmp	si, 0
1000:203a	je	loc_12045
1000:203c	pop	ax
1000:203d	push	ax
1000:203e	cmp	ax, si
1000:2040	jbe	loc_12045
1000:2042	call	0x17f4
        	loc_12045:
1000:2045	pop	si
1000:2046	ret	
                sub_12005 ENDP
*/
void sub_12005()
{
    // coverage: 0x2205-0x2247 method sub_12005
    push(si);
    di = 0x1446;
    bl = memoryAGet(ds, si + 4);
    memoryASet(ds, di + 1, bl);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5213);
    cbw();
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    al = memoryAGet(ds, bx + 5218);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, si + 3);
    al += 0x08;
    memoryASet(ds, di + 3, al);
    si = di;
    sub_10b58();
    if (si == 0x0000)
        goto loc_12045;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_12045;
    sub_117f4();
loc_12045:
    si = pop();
}
/* Assembly listing of 1000:2047 sub_12047()
                sub_12047 PROC
1000:2047	mov	al, byte ptr [si]
1000:2049	mov	bl, byte ptr [0x9517]
1000:204d	test	al, 0x20
1000:204f	je	loc_12072
1000:2051	test	bl, 0x80
1000:2054	jne	loc_1206d
1000:2056	or	byte ptr [0x9517], 0x80
1000:205b	or	byte ptr [0x1326], 0x20
1000:2060	mov	di, 0x1326
1000:2063	call	0x20a0
1000:2066	mov	al, 3
1000:2068	call	0x3840
1000:206b	jmp	loc_12070
        	loc_1206d:
1000:206d	mov	byte ptr [si], 0
        	loc_12070:
1000:2070	jmp	loc_12091
        	loc_12072:
1000:2072	test	bl, 1
1000:2075	jne	loc_1208e
1000:2077	or	byte ptr [0x9517], 1
1000:207c	and	byte ptr [0x1326], 0xdf
1000:2081	mov	di, 0x1326
1000:2084	call	0x20a0
1000:2087	mov	al, 3
1000:2089	call	0x3840
1000:208c	jmp	loc_12091
        	loc_1208e:
1000:208e	mov	byte ptr [si], 0
        	loc_12091:
1000:2091	ret	
                sub_12047 ENDP
*/
void sub_12047()
{
    // coverage: 0x2247-0x2292 method sub_12047
    al = memoryAGet(ds, si);
    bl = memoryAGet(ds, 0x9517);
    if (!(al & 0x20))
        goto loc_12072;
    if (bl & 0x80)
        goto loc_1206d;
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) | 0x80);
    memoryASet(ds, 0x1326, memoryAGet(ds, 0x1326) | 0x20);
    di = 0x1326;
    sub_120a0();
    al = 0x03;
    sub_13840();
    goto loc_12070;
loc_1206d:
    memoryASet(ds, si, 0x00);
loc_12070:
    return;
loc_12072:
    if (bl & 0x01)
        goto loc_1208e;
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) | 0x01);
    memoryASet(ds, 0x1326, memoryAGet(ds, 0x1326) & 0xdf);
    di = 0x1326;
    sub_120a0();
    al = 0x03;
    sub_13840();
    return;
loc_1208e:
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:2092 sub_12092()
                sub_12092 PROC
1000:2092	mov	di, 0x1427
1000:2095	call	0x20a0
1000:2098	ret	
                sub_12092 ENDP
*/
void sub_12092()
{
    // coverage: 0x2292-0x2299 method sub_12092
    di = 0x1427;
    sub_120a0();
}
/* Assembly listing of 1000:2099 sub_12099()
                sub_12099 PROC
1000:2099	mov	di, 0x12de
1000:209c	call	0x20a0
1000:209f	ret	
                sub_12099 ENDP
*/
void sub_12099()
{
    // coverage: 0x2299-0x22a0 method sub_12099
    di = 0x12de;
    sub_120a0();
}
/* Assembly listing of 1000:20a0 sub_120a0()
                sub_120a0 PROC
1000:20a0	mov	al, byte ptr [di]
1000:20a2	mov	byte ptr [si], al
1000:20a4	mov	al, byte ptr [di + 2]
1000:20a7	mov	byte ptr [si + 2], al
1000:20aa	mov	al, byte ptr [di + 0x16]
1000:20ad	mov	byte ptr [si + 0x16], al
1000:20b0	mov	al, byte ptr [di + 4]
1000:20b3	mov	byte ptr [si + 4], al
1000:20b6	mov	al, byte ptr [di + 9]
1000:20b9	mov	byte ptr [si + 9], al
1000:20bc	mov	al, byte ptr [di + 0xa]
1000:20bf	mov	byte ptr [si + 0xa], al
1000:20c2	mov	al, byte ptr [di + 0xb]
1000:20c5	mov	byte ptr [si + 0xb], al
1000:20c8	mov	al, byte ptr [di + 0xc]
1000:20cb	mov	byte ptr [si + 0xc], al
1000:20ce	mov	ax, word ptr [di + 0xf]
1000:20d1	mov	word ptr [si + 0xf], ax
1000:20d4	mov	al, byte ptr [di + 0x12]
1000:20d7	mov	byte ptr [si + 0x12], al
1000:20da	ret	
                sub_120a0 ENDP
*/
void sub_120a0()
{
    // coverage: 0x22a0-0x22db method sub_120a0
    al = memoryAGet(ds, di);
    memoryASet(ds, si, al);
    al = memoryAGet(ds, di + 2);
    memoryASet(ds, si + 2, al);
    al = memoryAGet(ds, di + 22);
    memoryASet(ds, si + 22, al);
    al = memoryAGet(ds, di + 4);
    memoryASet(ds, si + 4, al);
    al = memoryAGet(ds, di + 9);
    memoryASet(ds, si + 9, al);
    al = memoryAGet(ds, di + 10);
    memoryASet(ds, si + 10, al);
    al = memoryAGet(ds, di + 11);
    memoryASet(ds, si + 11, al);
    al = memoryAGet(ds, di + 12);
    memoryASet(ds, si + 12, al);
    ax = memoryAGet16(ds, di + 15);
    memoryASet16(ds, si + 15, ax);
    al = memoryAGet(ds, di + 18);
    memoryASet(ds, si + 18, al);
}
/* Assembly listing of 1000:20db sub_120db()
                sub_120db PROC
1000:20db	call	0x2676
1000:20de	call	0x20f0
1000:20e1	push	si
1000:20e2	mov	al, byte ptr [si + 0x13]
1000:20e5	mov	ah, 0
1000:20e7	push	ax
1000:20e8	mov	al, byte ptr [si + 0x14]
1000:20eb	push	ax
1000:20ec	call	0x9b5
1000:20ef	ret	
                sub_120db ENDP
*/
void sub_120db()
{
    // coverage: 0x22db-0x22f0 method sub_120db
    sub_12676();
    sub_120f0();
    push(si);
    al = memoryAGet(ds, si + 19);
    ah = 0x00;
    push(ax);
    al = memoryAGet(ds, si + 20);
    push(ax);
    sub_109b5();
}
/* Assembly listing of 1000:20f0 sub_120f0()
                sub_120f0 PROC
1000:20f0	push	si
1000:20f1	mov	ax, word ptr [si + 5]
1000:20f4	mov	word ptr [0x12a3], ax
1000:20f7	mov	ax, word ptr [si + 7]
1000:20fa	mov	word ptr [0x12a5], ax
1000:20fd	mov	al, byte ptr [si + 3]
1000:2100	mov	byte ptr [0x12a1], al
1000:2103	mov	al, byte ptr [si]
1000:2105	test	al, 0x10
1000:2107	je	loc_12119
1000:2109	sub	word ptr [0x12a3], 0xc
1000:210e	sub	word ptr [0x12a5], 8
1000:2113	and	word ptr [0x12a5], 0x3ff
        	loc_12119:
1000:2119	mov	si, 0x129e
1000:211c	call	0xb58
1000:211f	pop	si
1000:2120	ret	
                sub_120f0 ENDP
*/
void sub_120f0()
{
    // coverage: 0x22f0-0x2321 method sub_120f0
    push(si);
    ax = memoryAGet16(ds, si + 5);
    memoryASet16(ds, 0x12a3, ax);
    ax = memoryAGet16(ds, si + 7);
    memoryASet16(ds, 0x12a5, ax);
    al = memoryAGet(ds, si + 3);
    memoryASet(ds, 0x12a1, al);
    al = memoryAGet(ds, si);
    if (!(al & 0x10))
        goto loc_12119;
    memoryASet16(ds, 0x12a3, memoryAGet16(ds, 0x12a3) - 0x000c);
    memoryASet16(ds, 0x12a5, memoryAGet16(ds, 0x12a5) - 0x0008);
    memoryASet16(ds, 0x12a5, memoryAGet16(ds, 0x12a5) & 0x03ff);
loc_12119:
    si = 0x129e;
    sub_10b58();
    si = pop();
}
/* Assembly listing of 1000:2121 sub_12121()
                sub_12121 PROC
1000:2121	mov	cl, byte ptr [bx]
1000:2123	mov	ch, 0
1000:2125	inc	bx
1000:2126	mov	al, byte ptr [si + 4]
1000:2129	mov	ah, 0
1000:212b	mov	di, ax
1000:212d	mov	al, byte ptr [bx + di]
1000:212f	mov	byte ptr [si + 9], al
1000:2132	add	bx, cx
1000:2134	mov	al, byte ptr [bx + di]
1000:2136	mov	byte ptr [si + 0xa], al
1000:2139	add	bx, cx
1000:213b	mov	al, byte ptr [bx + di]
1000:213d	mov	byte ptr [si + 0xb], al
1000:2140	add	bx, cx
1000:2142	mov	al, byte ptr [bx + di]
1000:2144	mov	byte ptr [si + 0xc], al
1000:2147	add	bx, cx
1000:2149	shl	di, 1
1000:214b	shl	di, 1
1000:214d	mov	ax, word ptr [bx + di]
1000:214f	mov	word ptr [si + 0xd], ax
1000:2152	add	bx, 2
1000:2155	mov	ax, word ptr [bx + di]
1000:2157	mov	word ptr [si + 0xf], ax
1000:215a	ret	
                sub_12121 ENDP
*/
void sub_12121()
{
    // coverage: 0x2321-0x235b method sub_12121
    cl = memoryAGet(ds, bx);
    ch = 0x00;
    bx++;
    al = memoryAGet(ds, si + 4);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 9, al);
    bx += cx;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 10, al);
    bx += cx;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 11, al);
    bx += cx;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 12, al);
    bx += cx;
    di <<= 1;
    di <<= 1;
    ax = memoryAGet16(ds, bx + di);
    memoryASet16(ds, si + 13, ax);
    bx += 0x0002;
    ax = memoryAGet16(ds, bx + di);
    memoryASet16(ds, si + 15, ax);
}
/* Assembly listing of 1000:215b sub_1215b()
                sub_1215b PROC
1000:215b	mov	cx, 1
1000:215e	mov	ax, word ptr [0x1b91]
1000:2161	sub	ax, word ptr [si + 7]
1000:2164	cmp	ax, 0x8c
1000:2167	jle	loc_12171
1000:2169	mov	byte ptr [si + 4], 2
1000:216d	mov	cx, 0
1000:2170	ret	
        	loc_12171:
1000:2171	cmp	ax, 0xfff0
1000:2174	jge	loc_121a0
1000:2176	mov	ah, byte ptr [si + 4]
1000:2179	mov	al, byte ptr [si]
1000:217b	test	al, 0x20
1000:217d	je	loc_1218d
1000:217f	inc	ah
1000:2181	cmp	ah, 4
1000:2184	jle	loc_1218b
1000:2186	and	byte ptr [si], 0xdf
1000:2189	mov	ah, 4
        	loc_1218b:
1000:218b	jmp	loc_12199
        	loc_1218d:
1000:218d	dec	ah
1000:218f	cmp	ah, 0
1000:2192	jge	loc_12199
1000:2194	or	byte ptr [si], 0x20
1000:2197	mov	ah, 0
        	loc_12199:
1000:2199	mov	byte ptr [si + 4], ah
1000:219c	mov	cx, 0
1000:219f	ret	
        	loc_121a0:
1000:21a0	mov	bx, word ptr [0x1b8f]
1000:21a4	sub	bx, word ptr [si + 5]
1000:21a7	jns	loc_121c2
1000:21a9	cmp	bx, -0x20
1000:21ac	jle	loc_121b3
1000:21ae	mov	byte ptr [si + 4], 2
1000:21b2	ret	
        	loc_121b3:
1000:21b3	cmp	ax, 0x20
1000:21b6	jle	loc_121bd
1000:21b8	mov	byte ptr [si + 4], 1
1000:21bc	ret	
        	loc_121bd:
1000:21bd	mov	byte ptr [si + 4], 0
1000:21c1	ret	
        	loc_121c2:
1000:21c2	cmp	bx, 0x20
1000:21c5	jge	loc_121cc
1000:21c7	mov	byte ptr [si + 4], 2
1000:21cb	ret	
        	loc_121cc:
1000:21cc	cmp	ax, 0x20
1000:21cf	jle	loc_121d6
1000:21d1	mov	byte ptr [si + 4], 3
1000:21d5	ret	
        	loc_121d6:
1000:21d6	mov	byte ptr [si + 4], 4
1000:21da	ret	
                sub_1215b ENDP
*/
void sub_1215b()
{
    // coverage: 0x235b-0x23db method sub_1215b
    cx = 0x0001;
    ax = memoryAGet16(ds, 0x1b91);
    ax -= memoryAGet16(ds, si + 7);
    if ((short)ax <= (short)0x008c)
        goto loc_12171;
    memoryASet(ds, si + 4, 0x02);
    cx = 0x0000;
    return;
loc_12171:
    if ((short)ax >= (short)0xfff0)
        goto loc_121a0;
    ah = memoryAGet(ds, si + 4);
    al = memoryAGet(ds, si);
    if (!(al & 0x20))
        goto loc_1218d;
    ah++;
    if ((char)ah <= (char)0x04)
        goto loc_1218b;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    ah = 0x04;
loc_1218b:
    goto loc_12199;
loc_1218d:
    ah--;
    if ((char)ah >= (char)0x00)
        goto loc_12199;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    ah = 0x00;
loc_12199:
    memoryASet(ds, si + 4, ah);
    cx = 0x0000;
    return;
loc_121a0:
    bx = memoryAGet16(ds, 0x1b8f);
    bx -= memoryAGet16(ds, si + 5);
    if ((short)bx >= 0)
        goto loc_121c2;
    if ((short)bx <= (short)0xffe0)
        goto loc_121b3;
    memoryASet(ds, si + 4, 0x02);
    return;
loc_121b3:
    if ((short)ax <= (short)0x0020)
        goto loc_121bd;
    memoryASet(ds, si + 4, 0x01);
    return;
loc_121bd:
    memoryASet(ds, si + 4, 0x00);
    return;
loc_121c2:
    if ((short)bx >= (short)0x0020)
        goto loc_121cc;
    memoryASet(ds, si + 4, 0x02);
    return;
loc_121cc:
    if ((short)ax <= (short)0x0020)
        goto loc_121d6;
    memoryASet(ds, si + 4, 0x03);
    return;
loc_121d6:
    memoryASet(ds, si + 4, 0x04);
}
/* Assembly listing of 1000:21dc sub_121dc()
                sub_121dc PROC
1000:21dc	mov	ax, 0x403c
1000:21df	push	ax
1000:21e0	mov	ax, 0x1e11
1000:21e3	push	ax
1000:21e4	mov	ax, 0x38
1000:21e7	push	ax
1000:21e8	mov	ax, 7
1000:21eb	push	ax
1000:21ec	mov	ax, 2
1000:21ef	push	ax
1000:21f0	call	0x2cea
1000:21f3	call	0x2200
1000:21f6	call	0x264a
1000:21f9	call	0x2a7f
1000:21fc	call	0x22b1
1000:21ff	ret	
                sub_121dc ENDP
*/
void sub_121dc()
{
    // coverage: 0x23dc-0x2400 method sub_121dc
    ax = 0x403c;
    push(ax);
    ax = 0x1e11;
    push(ax);
    ax = 0x0038;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    sub_12200();
    sub_1264a();
    sub_12a7f();
    sub_122b1();
}
/* Assembly listing of 1000:2200 sub_12200()
                sub_12200 PROC
1000:2200	call	0x250b
1000:2203	call	0x2553
1000:2206	call	0x259b
1000:2209	call	0x237c
1000:220c	ret	
                sub_12200 ENDP
*/
void sub_12200()
{
    // coverage: 0x2400-0x240d method sub_12200
    sub_1250b();
    sub_12553();
    sub_1259b();
    sub_1237c();
}
/* Assembly listing of 1000:220d sub_1220d()
                sub_1220d PROC
1000:220d	inc	byte ptr [0x944c]
1000:2211	mov	al, byte ptr [0x944c]
1000:2214	and	al, 3
1000:2216	jne	loc_12228
1000:2218	mov	ax, 0
1000:221b	push	ax
1000:221c	push	ax
1000:221d	push	ax
1000:221e	mov	al, byte ptr [0x94fe]
1000:2221	push	ax
1000:2222	call	0x269e
1000:2225	call	0x2714
        	loc_12228:
1000:2228	mov	ax, word ptr [0x953c]
1000:222b	cmp	ax, 0
1000:222e	je	loc_12246
1000:2230	jns	loc_12237
1000:2232	call	0x252f
1000:2235	jmp	loc_12240
        	loc_12237:
1000:2237	mov	cx, ax
        	loc_12239:
1000:2239	push	cx
1000:223a	call	0x2542
1000:223d	pop	cx
1000:223e	loop	loc_12239
        	loc_12240:
1000:2240	mov	word ptr [0x953c], 0
        	loc_12246:
1000:2246	mov	ax, word ptr [0x9540]
1000:2249	cmp	ax, 0
1000:224c	je	loc_12264
1000:224e	jns	loc_12255
1000:2250	call	0x2577
1000:2253	jmp	loc_1225e
        	loc_12255:
1000:2255	mov	cx, ax
        	loc_12257:
1000:2257	push	cx
1000:2258	call	0x258a
1000:225b	pop	cx
1000:225c	loop	loc_12257
        	loc_1225e:
1000:225e	mov	word ptr [0x9540], 0
        	loc_12264:
1000:2264	mov	ax, word ptr [0x9544]
1000:2267	cmp	ax, 0
1000:226a	je	loc_1228a
1000:226c	jns	loc_1227b
1000:226e	neg	ax
1000:2270	mov	cx, ax
        	loc_12272:
1000:2272	push	cx
1000:2273	call	0x25bf
1000:2276	pop	cx
1000:2277	loop	loc_12272
1000:2279	jmp	loc_12284
        	loc_1227b:
1000:227b	mov	cx, ax
        	loc_1227d:
1000:227d	push	cx
1000:227e	call	0x25d2
1000:2281	pop	cx
1000:2282	loop	loc_1227d
        	loc_12284:
1000:2284	mov	word ptr [0x9544], 0
        	loc_1228a:
1000:228a	mov	ax, word ptr [0x9538]
1000:228d	cmp	ax, 0
1000:2290	je	loc_122b0
1000:2292	jns	loc_122a1
1000:2294	neg	ax
1000:2296	mov	cx, ax
        	loc_12298:
1000:2298	push	cx
1000:2299	call	0x2464
1000:229c	pop	cx
1000:229d	loop	loc_12298
1000:229f	jmp	loc_122aa
        	loc_122a1:
1000:22a1	mov	cx, ax
        	loc_122a3:
1000:22a3	push	cx
1000:22a4	call	0x239b
1000:22a7	pop	cx
1000:22a8	loop	loc_122a3
        	loc_122aa:
1000:22aa	mov	word ptr [0x9538], 0
        	loc_122b0:
1000:22b0	ret	
                sub_1220d ENDP
*/
void sub_1220d()
{
    // coverage: 0x240d-0x24b1 method sub_1220d
    memoryASet(ds, 0x944c, memoryAGet(ds, 0x944c) + 1);
    al = memoryAGet(ds, 0x944c);
    al &= 0x03;
    if (al != 0)
        goto loc_12228;
    ax = 0x0000;
    push(ax);
    push(ax);
    push(ax);
    al = memoryAGet(ds, 0x94fe);
    push(ax);
    sub_1269e();
    sub_12714();
loc_12228:
    ax = memoryAGet16(ds, 0x953c);
    if (ax == 0x0000)
        goto loc_12246;
    if ((short)ax >= 0)
        goto loc_12237;
    sub_1252f();
    goto loc_12240;
loc_12237:
    cx = ax;
loc_12239:
    push(cx);
    sub_12542();
    cx = pop();
    if (--cx)
        goto loc_12239;
loc_12240:
    memoryASet16(ds, 0x953c, 0x0000);
loc_12246:
    ax = memoryAGet16(ds, 0x9540);
    if (ax == 0x0000)
        goto loc_12264;
    if ((short)ax >= 0)
        goto loc_12255;
    sub_12577();
    goto loc_1225e;
loc_12255:
    cx = ax;
loc_12257:
    push(cx);
    sub_1258a();
    cx = pop();
    if (--cx)
        goto loc_12257;
loc_1225e:
    memoryASet16(ds, 0x9540, 0x0000);
loc_12264:
    ax = memoryAGet16(ds, 0x9544);
    if (ax == 0x0000)
        goto loc_1228a;
    if ((short)ax >= 0)
        goto loc_1227b;
    ax = -ax;
    cx = ax;
loc_12272:
    push(cx);
    sub_125bf();
    cx = pop();
    if (--cx)
        goto loc_12272;
    goto loc_12284;
loc_1227b:
    cx = ax;
loc_1227d:
    push(cx);
    sub_125d2();
    cx = pop();
    if (--cx)
        goto loc_1227d;
loc_12284:
    memoryASet16(ds, 0x9544, 0x0000);
loc_1228a:
    ax = memoryAGet16(ds, 0x9538);
    if (ax == 0x0000)
        return;
    if ((short)ax >= 0)
        goto loc_122a1;
    ax = -ax;
    cx = ax;
loc_12298:
    push(cx);
    sub_12464();
    cx = pop();
    if (--cx)
        goto loc_12298;
    goto loc_122aa;
loc_122a1:
    cx = ax;
loc_122a3:
    push(cx);
    sub_1239b();
    cx = pop();
    if (--cx)
        goto loc_122a3;
loc_122aa:
    memoryASet16(ds, 0x9538, 0x0000);
}
/* Assembly listing of 1000:22b1 sub_122b1()
                sub_122b1 PROC
1000:22b1	mov	word ptr [0x9534], 3
1000:22b7	call	0x22e1
1000:22ba	call	0x22f9
1000:22bd	call	0x2311
1000:22c0	ret	
                sub_122b1 ENDP
*/
void sub_122b1()
{
    // coverage: 0x24b1-0x24c1 method sub_122b1
    memoryASet16(ds, 0x9534, 0x0003);
    sub_122e1();
    sub_122f9();
    sub_12311();
}
/* Assembly listing of 1000:22c1 sub_122c1()
                sub_122c1 PROC
1000:22c1	inc	word ptr [0x9534]
1000:22c5	mov	ax, word ptr [0x9534]
1000:22c8	cmp	ax, 3
1000:22cb	jbe	loc_122d4
1000:22cd	mov	word ptr [0x9534], 3
1000:22d3	ret	
        	loc_122d4:
1000:22d4	je	loc_12311
1000:22d6	cmp	ax, 2
1000:22d9	je	loc_122f9
1000:22db	cmp	ax, 1
1000:22de	je	loc_122e1
1000:22e0	ret	
        	loc_122e1:
1000:22e1	mov	ax, 0x43e6
1000:22e4	push	ax
1000:22e5	mov	ax, 0x1b90
1000:22e8	push	ax
1000:22e9	mov	ax, 0x10
1000:22ec	push	ax
1000:22ed	mov	ax, 0xf
1000:22f0	push	ax
1000:22f1	mov	ax, 2
1000:22f4	push	ax
1000:22f5	call	0x2cea
1000:22f8	ret	
        	loc_122f9:
1000:22f9	mov	ax, 0x43e6
1000:22fc	push	ax
1000:22fd	mov	ax, 0x1b93
1000:2300	push	ax
1000:2301	mov	ax, 0x10
1000:2304	push	ax
1000:2305	mov	ax, 0xf
1000:2308	push	ax
1000:2309	mov	ax, 2
1000:230c	push	ax
1000:230d	call	0x2cea
1000:2310	ret	
        	loc_12311:
1000:2311	mov	ax, 0x43e6
1000:2314	push	ax
1000:2315	mov	ax, 0x1b96
1000:2318	push	ax
1000:2319	mov	ax, 0x10
1000:231c	push	ax
1000:231d	mov	ax, 0xf
1000:2320	push	ax
1000:2321	mov	ax, 2
1000:2324	push	ax
1000:2325	call	0x2cea
1000:2328	ret	
                sub_122c1 ENDP
*/
void sub_122c1()
{
    // coverage: 0x24c1-0x2529 method sub_122c1
    memoryASet16(ds, 0x9534, memoryAGet16(ds, 0x9534) + 1);
    ax = memoryAGet16(ds, 0x9534);
    if (ax <= 0x0003)
        goto loc_122d4;
    memoryASet16(ds, 0x9534, 0x0003);
    return;
loc_122d4:
    if (ax == 0x0003)
        goto loc_12311;
    if (ax == 0x0002)
        goto loc_122f9;
    if (ax == 0x0001)
        goto loc_122e1;
    return;
loc_122e1:
    ax = 0x43e6;
    push(ax);
    ax = 0x1b90;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_122f9:
    ax = 0x43e6;
    push(ax);
    ax = 0x1b93;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_12311:
    ax = 0x43e6;
    push(ax);
    ax = 0x1b96;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:22e1 sub_122e1()
                sub_122e1 PROC
1000:22e1	mov	ax, 0x43e6
1000:22e4	push	ax
1000:22e5	mov	ax, 0x1b90
1000:22e8	push	ax
1000:22e9	mov	ax, 0x10
1000:22ec	push	ax
1000:22ed	mov	ax, 0xf
1000:22f0	push	ax
1000:22f1	mov	ax, 2
1000:22f4	push	ax
1000:22f5	call	0x2cea
1000:22f8	ret	
                sub_122e1 ENDP
*/
void sub_122e1()
{
    // coverage: 0x24e1-0x24f9 method sub_122e1
    ax = 0x43e6;
    push(ax);
    ax = 0x1b90;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:22f9 sub_122f9()
                sub_122f9 PROC
1000:22f9	mov	ax, 0x43e6
1000:22fc	push	ax
1000:22fd	mov	ax, 0x1b93
1000:2300	push	ax
1000:2301	mov	ax, 0x10
1000:2304	push	ax
1000:2305	mov	ax, 0xf
1000:2308	push	ax
1000:2309	mov	ax, 2
1000:230c	push	ax
1000:230d	call	0x2cea
1000:2310	ret	
                sub_122f9 ENDP
*/
void sub_122f9()
{
    // coverage: 0x24f9-0x2511 method sub_122f9
    ax = 0x43e6;
    push(ax);
    ax = 0x1b93;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2311 sub_12311()
                sub_12311 PROC
1000:2311	mov	ax, 0x43e6
1000:2314	push	ax
1000:2315	mov	ax, 0x1b96
1000:2318	push	ax
1000:2319	mov	ax, 0x10
1000:231c	push	ax
1000:231d	mov	ax, 0xf
1000:2320	push	ax
1000:2321	mov	ax, 2
1000:2324	push	ax
1000:2325	call	0x2cea
1000:2328	ret	
                sub_12311 ENDP
*/
void sub_12311()
{
    // coverage: 0x2511-0x2529 method sub_12311
    ax = 0x43e6;
    push(ax);
    ax = 0x1b96;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2329 sub_12329()
                sub_12329 PROC
1000:2329	dec	word ptr [0x9534]
1000:232d	mov	ax, word ptr [0x9534]
1000:2330	cmp	ax, 2
1000:2333	je	loc_12368
1000:2335	cmp	ax, 1
1000:2338	je	loc_12354
1000:233a	cmp	ax, 0
1000:233d	je	loc_12340
1000:233f	ret	
        	loc_12340:
1000:2340	mov	ax, 0x1b90
1000:2343	push	ax
1000:2344	mov	ax, 2
1000:2347	push	ax
1000:2348	mov	ax, 0xf
1000:234b	push	ax
1000:234c	mov	ax, 0
1000:234f	push	ax
1000:2350	call	0x2d9a
1000:2353	ret	
        	loc_12354:
1000:2354	mov	ax, 0x1b93
1000:2357	push	ax
1000:2358	mov	ax, 2
1000:235b	push	ax
1000:235c	mov	ax, 0xf
1000:235f	push	ax
1000:2360	mov	ax, 0
1000:2363	push	ax
1000:2364	call	0x2d9a
1000:2367	ret	
        	loc_12368:
1000:2368	mov	ax, 0x1b96
1000:236b	push	ax
1000:236c	mov	ax, 2
1000:236f	push	ax
1000:2370	mov	ax, 0xf
1000:2373	push	ax
1000:2374	mov	ax, 0
1000:2377	push	ax
1000:2378	call	0x2d9a
1000:237b	ret	
                sub_12329 ENDP
*/
void sub_12329()
{
    // coverage: 0x2529-0x257c method sub_12329
    memoryASet16(ds, 0x9534, memoryAGet16(ds, 0x9534) - 1);
    ax = memoryAGet16(ds, 0x9534);
    if (ax == 0x0002)
        goto loc_12368;
    if (ax == 0x0001)
        goto loc_12354;
    if (ax == 0x0000)
        goto loc_12340;
    return;
loc_12340:
    ax = 0x1b90;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_12354:
    ax = 0x1b93;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_12368:
    ax = 0x1b96;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
}
/* Assembly listing of 1000:237c sub_1237c()
                sub_1237c PROC
1000:237c	mov	word ptr [0x9536], 6
1000:2382	mov	word ptr [0x9538], 0
1000:2388	call	0x23d4
1000:238b	call	0x23ec
1000:238e	call	0x2404
1000:2391	call	0x241c
1000:2394	call	0x2434
1000:2397	call	0x244c
1000:239a	ret	
                sub_1237c ENDP
*/
void sub_1237c()
{
    // coverage: 0x257c-0x259b method sub_1237c
    memoryASet16(ds, 0x9536, 0x0006);
    memoryASet16(ds, 0x9538, 0x0000);
    sub_123d4();
    sub_123ec();
    sub_12404();
    sub_1241c();
    sub_12434();
    sub_1244c();
}
/* Assembly listing of 1000:239b sub_1239b()
                sub_1239b PROC
1000:239b	inc	word ptr [0x9536]
1000:239f	mov	ax, word ptr [0x9536]
1000:23a2	cmp	ax, 6
1000:23a5	jbe	loc_123ae
1000:23a7	mov	word ptr [0x9536], 6
1000:23ad	ret	
        	loc_123ae:
1000:23ae	push	ax
1000:23af	mov	al, 8
1000:23b1	call	0x3840
1000:23b4	pop	ax
1000:23b5	cmp	ax, 1
1000:23b8	je	loc_123d4
1000:23ba	cmp	ax, 2
1000:23bd	je	loc_123ec
1000:23bf	cmp	ax, 3
1000:23c2	je	loc_12404
1000:23c4	cmp	ax, 4
1000:23c7	je	loc_1241c
1000:23c9	cmp	ax, 5
1000:23cc	je	loc_12434
1000:23ce	cmp	ax, 6
1000:23d1	je	loc_1244c
1000:23d3	ret	
        	loc_123d4:
1000:23d4	mov	ax, 0x43ee
1000:23d7	push	ax
1000:23d8	mov	ax, 0x1b99
1000:23db	push	ax
1000:23dc	mov	ax, 0x10
1000:23df	push	ax
1000:23e0	mov	ax, 0xf
1000:23e3	push	ax
1000:23e4	mov	ax, 2
1000:23e7	push	ax
1000:23e8	call	0x2cea
1000:23eb	ret	
        	loc_123ec:
1000:23ec	mov	ax, 0x43ee
1000:23ef	push	ax
1000:23f0	mov	ax, 0x1b9b
1000:23f3	push	ax
1000:23f4	mov	ax, 0x10
1000:23f7	push	ax
1000:23f8	mov	ax, 0xf
1000:23fb	push	ax
1000:23fc	mov	ax, 2
1000:23ff	push	ax
1000:2400	call	0x2cea
1000:2403	ret	
        	loc_12404:
1000:2404	mov	ax, 0x43ee
1000:2407	push	ax
1000:2408	mov	ax, 0x1b9d
1000:240b	push	ax
1000:240c	mov	ax, 0x10
1000:240f	push	ax
1000:2410	mov	ax, 0xf
1000:2413	push	ax
1000:2414	mov	ax, 2
1000:2417	push	ax
1000:2418	call	0x2cea
1000:241b	ret	
        	loc_1241c:
1000:241c	mov	ax, 0x43ee
1000:241f	push	ax
1000:2420	mov	ax, 0x1b9f
1000:2423	push	ax
1000:2424	mov	ax, 0x10
1000:2427	push	ax
1000:2428	mov	ax, 0xf
1000:242b	push	ax
1000:242c	mov	ax, 2
1000:242f	push	ax
1000:2430	call	0x2cea
1000:2433	ret	
        	loc_12434:
1000:2434	mov	ax, 0x43ee
1000:2437	push	ax
1000:2438	mov	ax, 0x1ba1
1000:243b	push	ax
1000:243c	mov	ax, 0x10
1000:243f	push	ax
1000:2440	mov	ax, 0xf
1000:2443	push	ax
1000:2444	mov	ax, 2
1000:2447	push	ax
1000:2448	call	0x2cea
1000:244b	ret	
        	loc_1244c:
1000:244c	mov	ax, 0x43ee
1000:244f	push	ax
1000:2450	mov	ax, 0x1ba3
1000:2453	push	ax
1000:2454	mov	ax, 0x10
1000:2457	push	ax
1000:2458	mov	ax, 0xf
1000:245b	push	ax
1000:245c	mov	ax, 2
1000:245f	push	ax
1000:2460	call	0x2cea
1000:2463	ret	
                sub_1239b ENDP
*/
void sub_1239b()
{
    // coverage: 0x259b-0x2664 method sub_1239b
    memoryASet16(ds, 0x9536, memoryAGet16(ds, 0x9536) + 1);
    ax = memoryAGet16(ds, 0x9536);
    if (ax <= 0x0006)
        goto loc_123ae;
    memoryASet16(ds, 0x9536, 0x0006);
    return;
loc_123ae:
    push(ax);
    al = 0x08;
    sub_13840();
    ax = pop();
    if (ax == 0x0001)
        goto loc_123d4;
    if (ax == 0x0002)
        goto loc_123ec;
    if (ax == 0x0003)
        goto loc_12404;
    if (ax == 0x0004)
        goto loc_1241c;
    if (ax == 0x0005)
        goto loc_12434;
    if (ax == 0x0006)
        goto loc_1244c;
    return;
loc_123d4:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b99;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_123ec:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9b;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_12404:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9d;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_1241c:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9f;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_12434:
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba1;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_1244c:
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba3;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:23d4 sub_123d4()
                sub_123d4 PROC
1000:23d4	mov	ax, 0x43ee
1000:23d7	push	ax
1000:23d8	mov	ax, 0x1b99
1000:23db	push	ax
1000:23dc	mov	ax, 0x10
1000:23df	push	ax
1000:23e0	mov	ax, 0xf
1000:23e3	push	ax
1000:23e4	mov	ax, 2
1000:23e7	push	ax
1000:23e8	call	0x2cea
1000:23eb	ret	
                sub_123d4 ENDP
*/
void sub_123d4()
{
    // coverage: 0x25d4-0x25ec method sub_123d4
    ax = 0x43ee;
    push(ax);
    ax = 0x1b99;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:23ec sub_123ec()
                sub_123ec PROC
1000:23ec	mov	ax, 0x43ee
1000:23ef	push	ax
1000:23f0	mov	ax, 0x1b9b
1000:23f3	push	ax
1000:23f4	mov	ax, 0x10
1000:23f7	push	ax
1000:23f8	mov	ax, 0xf
1000:23fb	push	ax
1000:23fc	mov	ax, 2
1000:23ff	push	ax
1000:2400	call	0x2cea
1000:2403	ret	
                sub_123ec ENDP
*/
void sub_123ec()
{
    // coverage: 0x25ec-0x2604 method sub_123ec
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9b;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2404 sub_12404()
                sub_12404 PROC
1000:2404	mov	ax, 0x43ee
1000:2407	push	ax
1000:2408	mov	ax, 0x1b9d
1000:240b	push	ax
1000:240c	mov	ax, 0x10
1000:240f	push	ax
1000:2410	mov	ax, 0xf
1000:2413	push	ax
1000:2414	mov	ax, 2
1000:2417	push	ax
1000:2418	call	0x2cea
1000:241b	ret	
                sub_12404 ENDP
*/
void sub_12404()
{
    // coverage: 0x2604-0x261c method sub_12404
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9d;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:241c sub_1241c()
                sub_1241c PROC
1000:241c	mov	ax, 0x43ee
1000:241f	push	ax
1000:2420	mov	ax, 0x1b9f
1000:2423	push	ax
1000:2424	mov	ax, 0x10
1000:2427	push	ax
1000:2428	mov	ax, 0xf
1000:242b	push	ax
1000:242c	mov	ax, 2
1000:242f	push	ax
1000:2430	call	0x2cea
1000:2433	ret	
                sub_1241c ENDP
*/
void sub_1241c()
{
    // coverage: 0x261c-0x2634 method sub_1241c
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9f;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2434 sub_12434()
                sub_12434 PROC
1000:2434	mov	ax, 0x43ee
1000:2437	push	ax
1000:2438	mov	ax, 0x1ba1
1000:243b	push	ax
1000:243c	mov	ax, 0x10
1000:243f	push	ax
1000:2440	mov	ax, 0xf
1000:2443	push	ax
1000:2444	mov	ax, 2
1000:2447	push	ax
1000:2448	call	0x2cea
1000:244b	ret	
                sub_12434 ENDP
*/
void sub_12434()
{
    // coverage: 0x2634-0x264c method sub_12434
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba1;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:244c sub_1244c()
                sub_1244c PROC
1000:244c	mov	ax, 0x43ee
1000:244f	push	ax
1000:2450	mov	ax, 0x1ba3
1000:2453	push	ax
1000:2454	mov	ax, 0x10
1000:2457	push	ax
1000:2458	mov	ax, 0xf
1000:245b	push	ax
1000:245c	mov	ax, 2
1000:245f	push	ax
1000:2460	call	0x2cea
1000:2463	ret	
                sub_1244c ENDP
*/
void sub_1244c()
{
    // coverage: 0x264c-0x2664 method sub_1244c
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba3;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2464 sub_12464()
                sub_12464 PROC
1000:2464	mov	ax, word ptr [0x9536]
1000:2467	dec	word ptr [0x9536]
1000:246b	jns	loc_12474
1000:246d	mov	word ptr [0x9536], 0
1000:2473	ret	
        	loc_12474:
1000:2474	cmp	ax, 1
1000:2477	je	loc_12493
1000:2479	cmp	ax, 2
1000:247c	je	loc_124a7
1000:247e	cmp	ax, 3
1000:2481	je	loc_124bb
1000:2483	cmp	ax, 4
1000:2486	je	loc_124cf
1000:2488	cmp	ax, 5
1000:248b	je	loc_124e3
1000:248d	cmp	ax, 6
1000:2490	je	loc_124f7
1000:2492	ret	
        	loc_12493:
1000:2493	mov	ax, 0x1b99
1000:2496	push	ax
1000:2497	mov	ax, 2
1000:249a	push	ax
1000:249b	mov	ax, 0xf
1000:249e	push	ax
1000:249f	mov	ax, 0
1000:24a2	push	ax
1000:24a3	call	0x2d9a
1000:24a6	ret	
        	loc_124a7:
1000:24a7	mov	ax, 0x1b9b
1000:24aa	push	ax
1000:24ab	mov	ax, 2
1000:24ae	push	ax
1000:24af	mov	ax, 0xf
1000:24b2	push	ax
1000:24b3	mov	ax, 0
1000:24b6	push	ax
1000:24b7	call	0x2d9a
1000:24ba	ret	
        	loc_124bb:
1000:24bb	mov	ax, 0x1b9d
1000:24be	push	ax
1000:24bf	mov	ax, 2
1000:24c2	push	ax
1000:24c3	mov	ax, 0xf
1000:24c6	push	ax
1000:24c7	mov	ax, 0
1000:24ca	push	ax
1000:24cb	call	0x2d9a
1000:24ce	ret	
        	loc_124cf:
1000:24cf	mov	ax, 0x1b9f
1000:24d2	push	ax
1000:24d3	mov	ax, 2
1000:24d6	push	ax
1000:24d7	mov	ax, 0xf
1000:24da	push	ax
1000:24db	mov	ax, 0
1000:24de	push	ax
1000:24df	call	0x2d9a
1000:24e2	ret	
        	loc_124e3:
1000:24e3	mov	ax, 0x1ba1
1000:24e6	push	ax
1000:24e7	mov	ax, 2
1000:24ea	push	ax
1000:24eb	mov	ax, 0xf
1000:24ee	push	ax
1000:24ef	mov	ax, 0
1000:24f2	push	ax
1000:24f3	call	0x2d9a
1000:24f6	ret	
        	loc_124f7:
1000:24f7	mov	ax, 0x1ba3
1000:24fa	push	ax
1000:24fb	mov	ax, 2
1000:24fe	push	ax
1000:24ff	mov	ax, 0xf
1000:2502	push	ax
1000:2503	mov	ax, 0
1000:2506	push	ax
1000:2507	call	0x2d9a
1000:250a	ret	
                sub_12464 ENDP
*/
void sub_12464()
{
    // coverage: 0x2664-0x270b method sub_12464
    ax = memoryAGet16(ds, 0x9536);
    memoryASet16(ds, 0x9536, memoryAGet16(ds, 0x9536) - 1);
    if ((short)memoryAGet16(ds, 0x9536) >= 0)
        goto loc_12474;
    memoryASet16(ds, 0x9536, 0x0000);
    return;
loc_12474:
    if (ax == 0x0001)
        goto loc_12493;
    if (ax == 0x0002)
        goto loc_124a7;
    if (ax == 0x0003)
        goto loc_124bb;
    if (ax == 0x0004)
        goto loc_124cf;
    if (ax == 0x0005)
        goto loc_124e3;
    if (ax == 0x0006)
        goto loc_124f7;
    return;
loc_12493:
    ax = 0x1b99;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124a7:
    ax = 0x1b9b;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124bb:
    ax = 0x1b9d;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124cf:
    ax = 0x1b9f;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124e3:
    ax = 0x1ba1;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124f7:
    ax = 0x1ba3;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
}
/* Assembly listing of 1000:250b sub_1250b()
                sub_1250b PROC
1000:250b	mov	word ptr [0x953a], 0x2c
1000:2511	mov	word ptr [0x953c], 0
1000:2517	mov	ax, 0x48f6
1000:251a	push	ax
1000:251b	mov	ax, 0x1b88
1000:251e	push	ax
1000:251f	mov	ax, 0x2c
1000:2522	push	ax
1000:2523	mov	ax, 7
1000:2526	push	ax
1000:2527	mov	ax, 2
1000:252a	push	ax
1000:252b	call	0x2cea
1000:252e	ret	
                sub_1250b ENDP
*/
void sub_1250b()
{
    // coverage: 0x270b-0x272f method sub_1250b
    memoryASet16(ds, 0x953a, 0x002c);
    memoryASet16(ds, 0x953c, 0x0000);
    ax = 0x48f6;
    push(ax);
    ax = 0x1b88;
    push(ax);
    ax = 0x002c;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:252f sub_1252f()
                sub_1252f PROC
1000:252f	mov	ax, word ptr [0x953a]
1000:2532	dec	ax
1000:2533	jns	loc_12536
1000:2535	ret	
        	loc_12536:
1000:2536	mov	word ptr [0x953a], ax
1000:2539	push	ax
1000:253a	mov	ax, 0x1b88
1000:253d	push	ax
1000:253e	call	0x25e3
1000:2541	ret	
                sub_1252f ENDP
*/
void sub_1252f()
{
    // coverage: 0x272f-0x2742 method sub_1252f
    ax = memoryAGet16(ds, 0x953a);
    ax--;
    if ((short)ax >= 0)
        goto loc_12536;
    return;
loc_12536:
    memoryASet16(ds, 0x953a, ax);
    push(ax);
    ax = 0x1b88;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:2536 sub_12536()
                sub_12536 PROC
1000:2536	mov	word ptr [0x953a], ax
1000:2539	push	ax
1000:253a	mov	ax, 0x1b88
1000:253d	push	ax
1000:253e	call	0x25e3
1000:2541	ret	
                sub_12536 ENDP
*/
void sub_12536()
{
    // coverage: 0x2736-0x2742 method sub_12536
    memoryASet16(ds, 0x953a, ax);
    push(ax);
    ax = 0x1b88;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:2542 sub_12542()
                sub_12542 PROC
1000:2542	mov	ax, word ptr [0x953a]
1000:2545	cmp	ax, 0x2c
1000:2548	jb	loc_1254b
1000:254a	ret	
        	loc_1254b:
1000:254b	call	0x2536
1000:254e	inc	word ptr [0x953a]
1000:2552	ret	
                sub_12542 ENDP
*/
void sub_12542()
{
    // coverage: 0x2742-0x2753 method sub_12542
    ax = memoryAGet16(ds, 0x953a);
    if (ax < 0x002c)
        goto loc_1254b;
    return;
loc_1254b:
    sub_12536();
    memoryASet16(ds, 0x953a, memoryAGet16(ds, 0x953a) + 1);
}
/* Assembly listing of 1000:2553 sub_12553()
                sub_12553 PROC
1000:2553	mov	word ptr [0x953e], 0x30
1000:2559	mov	word ptr [0x9540], 0
1000:255f	mov	ax, 0x2ce6
1000:2562	push	ax
1000:2563	mov	ax, 0x1cc8
1000:2566	push	ax
1000:2567	mov	ax, 0x30
1000:256a	push	ax
1000:256b	mov	ax, 7
1000:256e	push	ax
1000:256f	mov	ax, 2
1000:2572	push	ax
1000:2573	call	0x2cea
1000:2576	ret	
                sub_12553 ENDP
*/
void sub_12553()
{
    // coverage: 0x2753-0x2777 method sub_12553
    memoryASet16(ds, 0x953e, 0x0030);
    memoryASet16(ds, 0x9540, 0x0000);
    ax = 0x2ce6;
    push(ax);
    ax = 0x1cc8;
    push(ax);
    ax = 0x0030;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2577 sub_12577()
                sub_12577 PROC
1000:2577	mov	ax, word ptr [0x953e]
1000:257a	dec	ax
1000:257b	jns	loc_1257e
1000:257d	ret	
        	loc_1257e:
1000:257e	mov	word ptr [0x953e], ax
1000:2581	push	ax
1000:2582	mov	ax, 0x1cc8
1000:2585	push	ax
1000:2586	call	0x25e3
1000:2589	ret	
                sub_12577 ENDP
*/
void sub_12577()
{
    // coverage: 0x2777-0x278a method sub_12577
    ax = memoryAGet16(ds, 0x953e);
    ax--;
    if ((short)ax >= 0)
        goto loc_1257e;
    return;
loc_1257e:
    memoryASet16(ds, 0x953e, ax);
    push(ax);
    ax = 0x1cc8;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:257e sub_1257e()
                sub_1257e PROC
1000:257e	mov	word ptr [0x953e], ax
1000:2581	push	ax
1000:2582	mov	ax, 0x1cc8
1000:2585	push	ax
1000:2586	call	0x25e3
1000:2589	ret	
                sub_1257e ENDP
*/
void sub_1257e()
{
    // coverage: 0x277e-0x278a method sub_1257e
    memoryASet16(ds, 0x953e, ax);
    push(ax);
    ax = 0x1cc8;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:258a sub_1258a()
                sub_1258a PROC
1000:258a	mov	ax, word ptr [0x953e]
1000:258d	cmp	ax, 0x30
1000:2590	jb	loc_12593
1000:2592	ret	
        	loc_12593:
1000:2593	call	0x257e
1000:2596	inc	word ptr [0x953e]
1000:259a	ret	
                sub_1258a ENDP
*/
void sub_1258a()
{
    // coverage: 0x278a-0x279b method sub_1258a
    ax = memoryAGet16(ds, 0x953e);
    if (ax < 0x0030)
        goto loc_12593;
    return;
loc_12593:
    sub_1257e();
    memoryASet16(ds, 0x953e, memoryAGet16(ds, 0x953e) + 1);
}
/* Assembly listing of 1000:259b sub_1259b()
                sub_1259b PROC
1000:259b	mov	word ptr [0x9542], 0x38
1000:25a1	mov	word ptr [0x9544], 0
1000:25a7	mov	ax, 0x4496
1000:25aa	push	ax
1000:25ab	mov	ax, 0x1e08
1000:25ae	push	ax
1000:25af	mov	ax, 0x38
1000:25b2	push	ax
1000:25b3	mov	ax, 7
1000:25b6	push	ax
1000:25b7	mov	ax, 2
1000:25ba	push	ax
1000:25bb	call	0x2cea
1000:25be	ret	
                sub_1259b ENDP
*/
void sub_1259b()
{
    // coverage: 0x279b-0x27bf method sub_1259b
    memoryASet16(ds, 0x9542, 0x0038);
    memoryASet16(ds, 0x9544, 0x0000);
    ax = 0x4496;
    push(ax);
    ax = 0x1e08;
    push(ax);
    ax = 0x0038;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:25bf sub_125bf()
                sub_125bf PROC
1000:25bf	mov	ax, word ptr [0x9542]
1000:25c2	dec	ax
1000:25c3	jns	loc_125c6
1000:25c5	ret	
        	loc_125c6:
1000:25c6	mov	word ptr [0x9542], ax
1000:25c9	push	ax
1000:25ca	mov	ax, 0x1e08
1000:25cd	push	ax
1000:25ce	call	0x25e3
1000:25d1	ret	
                sub_125bf ENDP
*/
void sub_125bf()
{
    // coverage: 0x27bf-0x27d2 method sub_125bf
    ax = memoryAGet16(ds, 0x9542);
    ax--;
    if ((short)ax >= 0)
        goto loc_125c6;
    return;
loc_125c6:
    memoryASet16(ds, 0x9542, ax);
    push(ax);
    ax = 0x1e08;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:25c6 sub_125c6()
                sub_125c6 PROC
1000:25c6	mov	word ptr [0x9542], ax
1000:25c9	push	ax
1000:25ca	mov	ax, 0x1e08
1000:25cd	push	ax
1000:25ce	call	0x25e3
1000:25d1	ret	
                sub_125c6 ENDP
*/
void sub_125c6()
{
    // coverage: 0x27c6-0x27d2 method sub_125c6
    memoryASet16(ds, 0x9542, ax);
    push(ax);
    ax = 0x1e08;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:25d2 sub_125d2()
                sub_125d2 PROC
1000:25d2	mov	ax, word ptr [0x9542]
1000:25d5	cmp	ax, 0x38
1000:25d8	jb	loc_125db
1000:25da	ret	
        	loc_125db:
1000:25db	call	0x25c6
1000:25de	inc	word ptr [0x9542]
1000:25e2	ret	
                sub_125d2 ENDP
*/
void sub_125d2()
{
    // coverage: 0x27d2-0x27e3 method sub_125d2
    ax = memoryAGet16(ds, 0x9542);
    if (ax < 0x0038)
        goto loc_125db;
    return;
loc_125db:
    sub_125c6();
    memoryASet16(ds, 0x9542, memoryAGet16(ds, 0x9542) + 1);
}
/* Assembly listing of 1000:25e3 sub_125e3()
                sub_125e3 PROC
1000:25e3	push	bp
1000:25e4	mov	bp, sp
1000:25e6	mov	ax, 0xa000
1000:25e9	mov	es, ax
1000:25eb	mov	ax, word ptr [bp + 6]
1000:25ee	shr	ax, 1
1000:25f0	shr	ax, 1
1000:25f2	shr	ax, 1
1000:25f4	add	ax, word ptr [bp + 4]
1000:25f7	mov	di, ax
1000:25f9	mov	dx, 0x3ce
1000:25fc	mov	ax, 0x805
1000:25ff	out	dx, ax
1000:2600	mov	cx, word ptr [bp + 6]
1000:2603	and	cx, 7
1000:2606	mov	ah, 0x80
1000:2608	shr	ah, cl
1000:260a	mov	al, 8
1000:260c	out	dx, ax
1000:260d	mov	bl, ah
1000:260f	mov	ax, 0x1803
1000:2612	out	dx, ax
1000:2613	mov	ax, 0xf01
1000:2616	out	dx, ax
1000:2617	mov	ax, 0x700
1000:261a	out	dx, ax
1000:261b	mov	cx, 7
        	loc_1261e:
1000:261e	mov	al, byte ptr es:[di]
1000:2621	test	bl, al
1000:2623	jne	loc_1262d
1000:2625	mov	byte ptr es:[di], bl
1000:2628	mov	byte ptr es:[di + 0x2000], bl
        	loc_1262d:
1000:262d	add	di, 0x28
1000:2630	loop	loc_1261e
1000:2632	mov	ax, 5
1000:2635	out	dx, ax
1000:2636	mov	ax, 0xff08
1000:2639	out	dx, ax
1000:263a	mov	ax, 3
1000:263d	out	dx, ax
1000:263e	mov	ax, 1
1000:2641	out	dx, ax
1000:2642	mov	ax, 0
1000:2645	out	dx, ax
1000:2646	pop	bp
1000:2647	ret	4
                sub_125e3 ENDP
*/
void sub_125e3()
{
    // coverage: 0x27e3-0x284a method sub_125e3
    push(bp);
    bp = sp;
    ax = 0xa000;
    es = ax;
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax += memoryAGet16(ss, bp + 4 - 2);
    di = ax;
    dx = 0x03ce;
    ax = 0x0805;
    out(dx, ax);
    cx = memoryAGet16(ss, bp + 6 - 2);
    cx &= 0x0007;
    ah = 0x80;
    ah >>= cl;
    al = 0x08;
    out(dx, ax);
    bl = ah;
    ax = 0x1803;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    ax = 0x0700;
    out(dx, ax);
    cx = 0x0007;
loc_1261e:
    al = memoryAGet(es, di);
    if (bl & al)
        goto loc_1262d;
    memoryASet(es, di, bl);
    memoryASet(es, di + 8192, bl);
loc_1262d:
    di += 0x0028;
    if (--cx)
        goto loc_1261e;
    ax = 0x0005;
    out(dx, ax);
    ax = 0xff08;
    out(dx, ax);
    ax = 0x0003;
    out(dx, ax);
    ax = 0x0001;
    out(dx, ax);
    ax = 0x0000;
    out(dx, ax);
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:264a sub_1264a()
                sub_1264a PROC
1000:264a	mov	al, 0
1000:264c	mov	byte ptr [0x94a9], al
1000:264f	mov	byte ptr [0x94aa], al
1000:2652	mov	byte ptr [0x94ab], al
1000:2655	mov	byte ptr [0x94ac], al
1000:2658	mov	byte ptr [0x94ad], al
1000:265b	mov	byte ptr [0x94ae], al
1000:265e	call	0x2714
1000:2661	ret	
                sub_1264a ENDP
*/
void sub_1264a()
{
    // coverage: 0x284a-0x2862 method sub_1264a
    al = 0x00;
    memoryASet(ds, 0x94a9, al);
    memoryASet(ds, 0x94aa, al);
    memoryASet(ds, 0x94ab, al);
    memoryASet(ds, 0x94ac, al);
    memoryASet(ds, 0x94ad, al);
    memoryASet(ds, 0x94ae, al);
    sub_12714();
}
/* Assembly listing of 1000:2662 sub_12662()
                sub_12662 PROC
1000:2662	mov	ax, 0
1000:2665	push	ax
1000:2666	mov	ax, 0
1000:2669	push	ax
1000:266a	mov	ax, 1
1000:266d	push	ax
1000:266e	mov	ax, 0
1000:2671	push	ax
1000:2672	call	0x269e
1000:2675	ret	
                sub_12662 ENDP
*/
void sub_12662()
{
    // coverage: 0x2862-0x2876 method sub_12662
    ax = 0x0000;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
}
/* Assembly listing of 1000:2676 sub_12676()
                sub_12676 PROC
1000:2676	mov	ax, 0
1000:2679	push	ax
1000:267a	mov	ax, 1
1000:267d	push	ax
1000:267e	mov	ax, 5
1000:2681	push	ax
1000:2682	mov	ax, 0
1000:2685	push	ax
1000:2686	call	0x269e
1000:2689	ret	
                sub_12676 ENDP
*/
void sub_12676()
{
    // coverage: 0x2876-0x288a method sub_12676
    ax = 0x0000;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0005;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
}
/* Assembly listing of 1000:268a sub_1268a()
                sub_1268a PROC
1000:268a	mov	ax, 2
1000:268d	push	ax
1000:268e	mov	ax, 5
1000:2691	push	ax
1000:2692	mov	ax, 0
1000:2695	push	ax
1000:2696	mov	ax, 0
1000:2699	push	ax
1000:269a	call	0x269e
1000:269d	ret	
                sub_1268a ENDP
*/
void sub_1268a()
{
    // coverage: 0x288a-0x289e method sub_1268a
    ax = 0x0002;
    push(ax);
    ax = 0x0005;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
}
/* Assembly listing of 1000:269e sub_1269e()
                sub_1269e PROC
1000:269e	push	bp
1000:269f	mov	bp, sp
1000:26a1	mov	al, byte ptr [0x94ae]
1000:26a4	add	al, byte ptr [bp + 4]
1000:26a7	cmp	al, 9
1000:26a9	jbe	loc_126b1
1000:26ab	sub	al, 0xa
1000:26ad	inc	byte ptr [0x94ad]
        	loc_126b1:
1000:26b1	mov	byte ptr [0x94ae], al
1000:26b4	mov	al, byte ptr [0x94ad]
1000:26b7	add	al, byte ptr [bp + 6]
1000:26ba	cmp	al, 9
1000:26bc	jbe	loc_126c4
1000:26be	sub	al, 0xa
1000:26c0	inc	byte ptr [0x94ac]
        	loc_126c4:
1000:26c4	mov	byte ptr [0x94ad], al
1000:26c7	mov	al, byte ptr [0x94ac]
1000:26ca	add	al, byte ptr [bp + 8]
1000:26cd	cmp	al, 9
1000:26cf	jbe	loc_126d7
1000:26d1	sub	al, 0xa
1000:26d3	inc	byte ptr [0x94ab]
        	loc_126d7:
1000:26d7	mov	byte ptr [0x94ac], al
1000:26da	mov	al, byte ptr [0x94ab]
1000:26dd	add	al, byte ptr [bp + 0xa]
1000:26e0	cmp	al, 9
1000:26e2	jbe	loc_126ea
1000:26e4	sub	al, 0xa
1000:26e6	inc	byte ptr [0x94aa]
        	loc_126ea:
1000:26ea	mov	byte ptr [0x94ab], al
1000:26ed	mov	al, byte ptr [0x94aa]
1000:26f0	cmp	al, 9
1000:26f2	jbe	loc_12701
1000:26f4	sub	al, 0xa
1000:26f6	inc	byte ptr [0x94a9]
1000:26fa	push	ax
1000:26fb	push	si
1000:26fc	call	0x22c1
1000:26ff	pop	si
1000:2700	pop	ax
        	loc_12701:
1000:2701	mov	byte ptr [0x94aa], al
1000:2704	mov	al, byte ptr [0x94a9]
1000:2707	cmp	al, 9
1000:2709	jbe	loc_1270d
1000:270b	sub	al, 0xa
        	loc_1270d:
1000:270d	mov	byte ptr [0x94a9], al
1000:2710	pop	bp
1000:2711	ret	8
                sub_1269e ENDP
*/
void sub_1269e()
{
    // coverage: 0x289e-0x2914 method sub_1269e
    push(bp);
    bp = sp;
    al = memoryAGet(ds, 0x94ae);
    al += memoryAGet(ss, bp + 4 - 2);
    if (al <= 0x09)
        goto loc_126b1;
    al -= 0x0a;
    memoryASet(ds, 0x94ad, memoryAGet(ds, 0x94ad) + 1);
loc_126b1:
    memoryASet(ds, 0x94ae, al);
    al = memoryAGet(ds, 0x94ad);
    al += memoryAGet(ss, bp + 6 - 2);
    if (al <= 0x09)
        goto loc_126c4;
    al -= 0x0a;
    memoryASet(ds, 0x94ac, memoryAGet(ds, 0x94ac) + 1);
loc_126c4:
    memoryASet(ds, 0x94ad, al);
    al = memoryAGet(ds, 0x94ac);
    al += memoryAGet(ss, bp + 8 - 2);
    if (al <= 0x09)
        goto loc_126d7;
    al -= 0x0a;
    memoryASet(ds, 0x94ab, memoryAGet(ds, 0x94ab) + 1);
loc_126d7:
    memoryASet(ds, 0x94ac, al);
    al = memoryAGet(ds, 0x94ab);
    al += memoryAGet(ss, bp + 10 - 2);
    if (al <= 0x09)
        goto loc_126ea;
    al -= 0x0a;
    memoryASet(ds, 0x94aa, memoryAGet(ds, 0x94aa) + 1);
loc_126ea:
    memoryASet(ds, 0x94ab, al);
    al = memoryAGet(ds, 0x94aa);
    if (al <= 0x09)
        goto loc_12701;
    al -= 0x0a;
    memoryASet(ds, 0x94a9, memoryAGet(ds, 0x94a9) + 1);
    push(ax);
    push(si);
    sub_122c1();
    si = pop();
    ax = pop();
loc_12701:
    memoryASet(ds, 0x94aa, al);
    al = memoryAGet(ds, 0x94a9);
    if (al <= 0x09)
        goto loc_1270d;
    al -= 0x0a;
loc_1270d:
    memoryASet(ds, 0x94a9, al);
    bp = pop();
    sp += 8;
}
/* Assembly listing of 1000:2714 sub_12714()
                sub_12714 PROC
1000:2714	mov	byte ptr [0x944d], 1
1000:2719	mov	si, 0x94a9
1000:271c	mov	cx, 6
1000:271f	mov	dx, 0
        	loc_12722:
1000:2722	push	cx
1000:2723	lodsb	al, byte ptr [si]
1000:2724	cmp	al, 0
1000:2726	je	loc_1272d
1000:2728	mov	byte ptr [0x944d], 0
        	loc_1272d:
1000:272d	mov	cl, byte ptr [0x944d]
1000:2731	cmp	cl, 0
1000:2734	jne	loc_1275e
1000:2736	push	dx
1000:2737	push	si
1000:2738	mov	bh, 0
1000:273a	mov	bl, al
1000:273c	shl	bx, 1
1000:273e	mov	ax, word ptr [bx + 0x155f]
1000:2742	push	ax
1000:2743	mov	bx, dx
1000:2745	mov	ax, word ptr [bx + 0x1573]
1000:2749	push	ax
1000:274a	mov	ax, 0x10
1000:274d	push	ax
1000:274e	mov	ax, 9
1000:2751	push	ax
1000:2752	mov	ax, 2
1000:2755	push	ax
1000:2756	call	0x2cea
1000:2759	pop	si
1000:275a	pop	dx
1000:275b	add	dx, 2
        	loc_1275e:
1000:275e	pop	cx
1000:275f	loop	loc_12722
1000:2761	ret	
                sub_12714 ENDP
*/
void sub_12714()
{
    // coverage: 0x2914-0x2962 method sub_12714
    memoryASet(ds, 0x944d, 0x01);
    si = 0x94a9;
    cx = 0x0006;
    dx = 0x0000;
loc_12722:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_1272d;
    memoryASet(ds, 0x944d, 0x00);
loc_1272d:
    cl = memoryAGet(ds, 0x944d);
    if (cl != 0x00)
        goto loc_1275e;
    push(dx);
    push(si);
    bh = 0x00;
    bl = al;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5471);
    push(ax);
    bx = dx;
    ax = memoryAGet16(ds, bx + 5491);
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0009;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    si = pop();
    dx = pop();
    dx += 0x0002;
loc_1275e:
    cx = pop();
    if (--cx)
        goto loc_12722;
}
/* Assembly listing of 1000:2762 sub_12762()
                sub_12762 PROC
1000:2762	mov	cx, 0x12
1000:2765	mov	ax, ds
1000:2767	mov	es, ax
1000:2769	mov	di, 0x94af
1000:276c	cld	
1000:276d	mov	ax, 0
1000:2770	rep stosw	word ptr es:[di], ax
1000:2772	mov	cx, 0x2a
1000:2775	mov	di, 0x9455
1000:2778	mov	al, 0x2e
1000:277a	mov	ah, 0x2e
1000:277c	rep stosw	word ptr es:[di], ax
1000:277e	mov	byte ptr [0x9455], 0x5f
1000:2783	mov	al, 0
1000:2785	mov	cx, 7
1000:2788	mov	si, 0x94da
        	loc_1278b:
1000:278b	mov	byte ptr [si], al
1000:278d	inc	al
1000:278f	inc	si
1000:2790	loop	loc_1278b
1000:2792	mov	di, 0x9455
1000:2795	mov	dx, 0x1506
1000:2798	mov	cx, 0x8c
1000:279b	call	0x644
1000:279e	ret	
                sub_12762 ENDP
*/
void sub_12762()
{
    // coverage: 0x2962-0x299f method sub_12762
    cx = 0x0012;
    ax = ds;
    es = ax;
    di = 0x94af;
    flags.direction = false;
    ax = 0x0000;
    rep_stosw<MemAuto, DirAuto>();
    cx = 0x002a;
    di = 0x9455;
    al = 0x2e;
    ah = 0x2e;
    rep_stosw<MemAuto, DirAuto>();
    memoryASet(ds, 0x9455, 0x5f);
    al = 0x00;
    cx = 0x0007;
    si = 0x94da;
loc_1278b:
    memoryASet(ds, si, al);
    al++;
    si++;
    if (--cx)
        goto loc_1278b;
    di = 0x9455;
    dx = 0x1506;
    cx = 0x008c;
    sub_10644();
}
/* Assembly listing of 1000:279f sub_1279f()
                sub_1279f PROC
1000:279f	call	0x2809
1000:27a2	mov	al, byte ptr [0x94e0]
1000:27a5	cmp	al, 0
1000:27a7	jne	loc_127af
1000:27a9	mov	byte ptr [0x9546], 0
1000:27ae	ret	
        	loc_127af:
1000:27af	mov	byte ptr [0x9546], 1
1000:27b4	mov	bl, al
1000:27b6	shl	bl, 1
1000:27b8	add	bl, al
1000:27ba	mov	bh, 0
1000:27bc	shl	bx, 1
1000:27be	push	bx
1000:27bf	add	bx, 0x94a9
1000:27c3	mov	si, 0x94a9
1000:27c6	mov	cx, 6
        	loc_127c9:
1000:27c9	lodsb	al, byte ptr [si]
1000:27ca	mov	byte ptr [bx], al
1000:27cc	inc	bx
1000:27cd	loop	loc_127c9
1000:27cf	pop	bx
1000:27d0	shl	bx, 1
1000:27d2	add	bx, 0x9455
1000:27d6	mov	word ptr [0x9451], bx
1000:27da	mov	si, 0x9455
1000:27dd	mov	cx, 0xc
        	loc_127e0:
1000:27e0	lodsb	al, byte ptr [si]
1000:27e1	mov	byte ptr [bx], al
1000:27e3	inc	bx
1000:27e4	loop	loc_127e0
1000:27e6	mov	si, 0x94da
        	loc_127e9:
1000:27e9	mov	al, byte ptr [si]
1000:27eb	cmp	al, 0
1000:27ed	je	loc_127f2
1000:27ef	inc	si
1000:27f0	jmp	loc_127e9
        	loc_127f2:
1000:27f2	mov	al, byte ptr [0x94e0]
1000:27f5	mov	byte ptr [si], al
1000:27f7	mov	byte ptr [0x94e0], 0
1000:27fc	sub	si, 0x94da
1000:2800	mov	ax, si
1000:2802	mov	byte ptr [0x9450], al
1000:2805	call	0x28da
1000:2808	ret	
                sub_1279f ENDP
*/
void sub_1279f()
{
    // coverage: 0x299f-0x2a09 method sub_1279f
    sub_12809();
    al = memoryAGet(ds, 0x94e0);
    if (al != 0x00)
        goto loc_127af;
    memoryASet(ds, 0x9546, 0x00);
    return;
loc_127af:
    memoryASet(ds, 0x9546, 0x01);
    bl = al;
    bl <<= 1;
    bl += al;
    bh = 0x00;
    bx <<= 1;
    push(bx);
    bx += 0x94a9;
    si = 0x94a9;
    cx = 0x0006;
loc_127c9:
    lodsb<MemAuto, DirAuto>();
    memoryASet(ds, bx, al);
    bx++;
    if (--cx)
        goto loc_127c9;
    bx = pop();
    bx <<= 1;
    bx += 0x9455;
    memoryASet16(ds, 0x9451, bx);
    si = 0x9455;
    cx = 0x000c;
loc_127e0:
    lodsb<MemAuto, DirAuto>();
    memoryASet(ds, bx, al);
    bx++;
    if (--cx)
        goto loc_127e0;
    si = 0x94da;
loc_127e9:
    al = memoryAGet(ds, si);
    if (al == 0x00)
        goto loc_127f2;
    si++;
    goto loc_127e9;
loc_127f2:
    al = memoryAGet(ds, 0x94e0);
    memoryASet(ds, si, al);
    memoryASet(ds, 0x94e0, 0x00);
    si -= 0x94da;
    ax = si;
    memoryASet(ds, 0x9450, al);
    sub_128da();
}
/* Assembly listing of 1000:2809 sub_12809()
                sub_12809 PROC
1000:2809	mov	al, byte ptr [0x94da]
1000:280c	mov	byte ptr [0x94d3], al
1000:280f	mov	al, byte ptr [0x94db]
1000:2812	mov	byte ptr [0x94d4], al
1000:2815	mov	al, byte ptr [0x94dc]
1000:2818	mov	byte ptr [0x94d5], al
1000:281b	mov	al, byte ptr [0x94dd]
1000:281e	mov	byte ptr [0x94d6], al
1000:2821	mov	al, byte ptr [0x94de]
1000:2824	mov	byte ptr [0x94d7], al
1000:2827	mov	al, byte ptr [0x94df]
1000:282a	mov	byte ptr [0x94d8], al
1000:282d	mov	al, byte ptr [0x94e0]
1000:2830	mov	byte ptr [0x94d9], al
1000:2833	mov	si, 0x94d3
1000:2836	mov	di, 0x94da
1000:2839	mov	cx, 7
        	loc_1283c:
1000:283c	push	cx
1000:283d	push	si
        	loc_1283e:
1000:283e	mov	al, byte ptr [si]
1000:2840	cmp	al, 0xff
1000:2842	jne	loc_12847
1000:2844	inc	si
1000:2845	jmp	loc_1283e
        	loc_12847:
1000:2847	cmp	si, 0x94d9
1000:284b	je	loc_12865
1000:284d	mov	bx, si
        	loc_1284f:
1000:284f	inc	bx
1000:2850	mov	al, byte ptr [bx]
1000:2852	cmp	al, 0xff
1000:2854	je	loc_1285f
1000:2856	call	0x2872
1000:2859	cmp	al, 0
1000:285b	je	loc_1285f
1000:285d	mov	si, bx
        	loc_1285f:
1000:285f	cmp	bx, 0x94d9
1000:2863	jne	loc_1284f
        	loc_12865:
1000:2865	mov	al, byte ptr [si]
1000:2867	mov	byte ptr [si], 0xff
1000:286a	mov	byte ptr [di], al
1000:286c	inc	di
1000:286d	pop	si
1000:286e	pop	cx
1000:286f	loop	loc_1283c
1000:2871	ret	
                sub_12809 ENDP
*/
void sub_12809()
{
    // coverage: 0x2a09-0x2a72 method sub_12809
    al = memoryAGet(ds, 0x94da);
    memoryASet(ds, 0x94d3, al);
    al = memoryAGet(ds, 0x94db);
    memoryASet(ds, 0x94d4, al);
    al = memoryAGet(ds, 0x94dc);
    memoryASet(ds, 0x94d5, al);
    al = memoryAGet(ds, 0x94dd);
    memoryASet(ds, 0x94d6, al);
    al = memoryAGet(ds, 0x94de);
    memoryASet(ds, 0x94d7, al);
    al = memoryAGet(ds, 0x94df);
    memoryASet(ds, 0x94d8, al);
    al = memoryAGet(ds, 0x94e0);
    memoryASet(ds, 0x94d9, al);
    si = 0x94d3;
    di = 0x94da;
    cx = 0x0007;
loc_1283c:
    push(cx);
    push(si);
loc_1283e:
    al = memoryAGet(ds, si);
    if (al != 0xff)
        goto loc_12847;
    si++;
    goto loc_1283e;
loc_12847:
    if (si == 0x94d9)
        goto loc_12865;
    bx = si;
loc_1284f:
    bx++;
    al = memoryAGet(ds, bx);
    if (al == 0xff)
        goto loc_1285f;
    sub_12872();
    if (al == 0x00)
        goto loc_1285f;
    si = bx;
loc_1285f:
    if (bx != 0x94d9)
        goto loc_1284f;
loc_12865:
    al = memoryAGet(ds, si);
    memoryASet(ds, si, 0xff);
    memoryASet(ds, di, al);
    di++;
    si = pop();
    cx = pop();
    if (--cx)
        goto loc_1283c;
}
/* Assembly listing of 1000:2872 sub_12872()
                sub_12872 PROC
1000:2872	push	si
1000:2873	push	di
1000:2874	mov	al, byte ptr [si]
1000:2876	mov	ah, al
1000:2878	shl	al, 1
1000:287a	add	al, ah
1000:287c	shl	al, 1
1000:287e	mov	ah, 0
1000:2880	add	ax, 0x94a9
1000:2883	mov	si, ax
1000:2885	mov	al, byte ptr [bx]
1000:2887	mov	ah, al
1000:2889	shl	al, 1
1000:288b	add	al, ah
1000:288d	shl	al, 1
1000:288f	mov	ah, 0
1000:2891	add	ax, 0x94a9
1000:2894	mov	di, ax
1000:2896	mov	al, byte ptr [di]
1000:2898	cmp	al, byte ptr [si]
1000:289a	ja	loc_128d5
1000:289c	jb	loc_128d0
1000:289e	mov	al, byte ptr [di + 1]
1000:28a1	cmp	al, byte ptr [si + 1]
1000:28a4	ja	loc_128d5
1000:28a6	jb	loc_128d0
1000:28a8	mov	al, byte ptr [di + 2]
1000:28ab	cmp	al, byte ptr [si + 2]
1000:28ae	ja	loc_128d5
1000:28b0	jb	loc_128d0
1000:28b2	mov	al, byte ptr [di + 3]
1000:28b5	cmp	al, byte ptr [si + 3]
1000:28b8	ja	loc_128d5
1000:28ba	jb	loc_128d0
1000:28bc	mov	al, byte ptr [di + 4]
1000:28bf	cmp	al, byte ptr [si + 4]
1000:28c2	ja	loc_128d5
1000:28c4	jb	loc_128d0
1000:28c6	mov	al, byte ptr [di + 5]
1000:28c9	cmp	al, byte ptr [si + 5]
1000:28cc	ja	loc_128d5
1000:28ce	jb	loc_128d0
        	loc_128d0:
1000:28d0	mov	al, 0
1000:28d2	pop	di
1000:28d3	pop	si
1000:28d4	ret	
        	loc_128d5:
1000:28d5	mov	al, 1
1000:28d7	pop	di
1000:28d8	pop	si
1000:28d9	ret	
                sub_12872 ENDP
*/
void sub_12872()
{
    // coverage: 0x2a72-0x2ada method sub_12872
    push(si);
    push(di);
    al = memoryAGet(ds, si);
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
    ax += 0x94a9;
    si = ax;
    al = memoryAGet(ds, bx);
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
    ax += 0x94a9;
    di = ax;
    al = memoryAGet(ds, di);
    if (al > memoryAGet(ds, si))
        goto loc_128d5;
    if (al < memoryAGet(ds, si))
        goto loc_128d0;
    al = memoryAGet(ds, di + 1);
    if (al > memoryAGet(ds, si + 1))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 1))
        goto loc_128d0;
    al = memoryAGet(ds, di + 2);
    if (al > memoryAGet(ds, si + 2))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 2))
        goto loc_128d0;
    al = memoryAGet(ds, di + 3);
    if (al > memoryAGet(ds, si + 3))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 3))
        goto loc_128d0;
    al = memoryAGet(ds, di + 4);
    if (al > memoryAGet(ds, si + 4))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 4))
        goto loc_128d0;
    al = memoryAGet(ds, di + 5);
    if (al > memoryAGet(ds, si + 5))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 5))
        goto loc_128d0;
loc_128d0:
    al = 0x00;
    di = pop();
    si = pop();
    return;
loc_128d5:
    al = 0x01;
    di = pop();
    si = pop();
}
/* Assembly listing of 1000:28da sub_128da()
                sub_128da PROC
1000:28da	mov	si, 0x94da
1000:28dd	mov	di, 0x1b1
1000:28e0	mov	cx, 6
        	loc_128e3:
1000:28e3	push	cx
1000:28e4	add	di, 2
1000:28e7	mov	ax, word ptr [di]
1000:28e9	add	di, 2
1000:28ec	push	si
1000:28ed	push	di
1000:28ee	call	0x2959
1000:28f1	pop	di
1000:28f2	pop	si
1000:28f3	add	di, 2
1000:28f6	mov	ax, word ptr [di]
1000:28f8	add	di, 2
1000:28fb	push	si
1000:28fc	push	di
1000:28fd	call	0x2907
1000:2900	pop	di
1000:2901	pop	si
1000:2902	inc	si
1000:2903	pop	cx
1000:2904	loop	loc_128e3
1000:2906	ret	
                sub_128da ENDP
*/
void sub_128da()
{
    // coverage: 0x2ada-0x2b07 method sub_128da
    si = 0x94da;
    di = 0x01b1;
    cx = 0x0006;
loc_128e3:
    push(cx);
    di += 0x0002;
    ax = memoryAGet16(ds, di);
    di += 0x0002;
    push(si);
    push(di);
    sub_12959();
    di = pop();
    si = pop();
    di += 0x0002;
    ax = memoryAGet16(ds, di);
    di += 0x0002;
    push(si);
    push(di);
    sub_12907();
    di = pop();
    si = pop();
    si++;
    cx = pop();
    if (--cx)
        goto loc_128e3;
}
/* Assembly listing of 1000:2907 sub_12907()
                sub_12907 PROC
1000:2907	mov	word ptr [0x944e], ax
1000:290a	mov	al, byte ptr [si]
1000:290c	mov	ah, al
1000:290e	shl	al, 1
1000:2910	add	al, ah
1000:2912	mov	ah, 0
1000:2914	shl	ax, 1
1000:2916	add	ax, 0x94a9
1000:2919	mov	si, ax
1000:291b	mov	byte ptr [0x944d], 1
1000:2920	mov	cx, 6
1000:2923	mov	dx, 0
        	loc_12926:
1000:2926	push	cx
1000:2927	lodsb	al, byte ptr [si]
1000:2928	cmp	al, 0
1000:292a	je	loc_12931
1000:292c	mov	byte ptr [0x944d], 0
        	loc_12931:
1000:2931	mov	cl, byte ptr [0x944d]
1000:2935	cmp	cl, 0
1000:2938	je	loc_1293f
1000:293a	mov	ax, 0x6f6c
1000:293d	jmp	loc_12949
        	loc_1293f:
1000:293f	mov	bh, 0
1000:2941	mov	bl, al
1000:2943	shl	bx, 1
1000:2945	mov	ax, word ptr [bx + 0x157f]
        	loc_12949:
1000:2949	push	dx
1000:294a	push	si
1000:294b	push	ax
1000:294c	push	dx
1000:294d	call	0x29ae
1000:2950	pop	si
1000:2951	pop	dx
1000:2952	add	dx, 6
1000:2955	pop	cx
1000:2956	loop	loc_12926
1000:2958	ret	
                sub_12907 ENDP
*/
void sub_12907()
{
    // coverage: 0x2b07-0x2b59 method sub_12907
    memoryASet16(ds, 0x944e, ax);
    al = memoryAGet(ds, si);
    ah = al;
    al <<= 1;
    al += ah;
    ah = 0x00;
    ax <<= 1;
    ax += 0x94a9;
    si = ax;
    memoryASet(ds, 0x944d, 0x01);
    cx = 0x0006;
    dx = 0x0000;
loc_12926:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_12931;
    memoryASet(ds, 0x944d, 0x00);
loc_12931:
    cl = memoryAGet(ds, 0x944d);
    if (cl == 0x00)
        goto loc_1293f;
    ax = 0x6f6c;
    goto loc_12949;
loc_1293f:
    bh = 0x00;
    bl = al;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5503);
loc_12949:
    push(dx);
    push(si);
    push(ax);
    push(dx);
    sub_129ae();
    si = pop();
    dx = pop();
    dx += 0x0006;
    cx = pop();
    if (--cx)
        goto loc_12926;
}
/* Assembly listing of 1000:2959 sub_12959()
                sub_12959 PROC
1000:2959	mov	word ptr [0x944e], ax
1000:295c	mov	al, byte ptr [si]
1000:295e	mov	ah, al
1000:2960	shl	al, 1
1000:2962	add	al, ah
1000:2964	mov	ah, 0
1000:2966	shl	ax, 1
1000:2968	shl	ax, 1
1000:296a	add	ax, 0x9455
1000:296d	mov	si, ax
1000:296f	mov	cx, 0xc
1000:2972	mov	dx, 0
        	loc_12975:
1000:2975	push	cx
1000:2976	lodsb	al, byte ptr [si]
1000:2977	push	si
1000:2978	push	dx
1000:2979	cmp	al, 0x20
1000:297b	jne	loc_12982
1000:297d	mov	ax, 0x6546
1000:2980	jmp	loc_129a0
        	loc_12982:
1000:2982	cmp	al, 0x2e
1000:2984	jne	loc_1298b
1000:2986	mov	ax, 0x6f6c
1000:2989	jmp	loc_129a0
        	loc_1298b:
1000:298b	cmp	al, 0x5f
1000:298d	jne	loc_12994
1000:298f	mov	ax, 0x764c
1000:2992	jmp	loc_129a0
        	loc_12994:
1000:2994	sub	al, 0x41
1000:2996	mov	ah, al
1000:2998	shl	al, 1
1000:299a	add	al, ah
1000:299c	shl	al, 1
1000:299e	mov	ah, 0
        	loc_129a0:
1000:29a0	push	ax
1000:29a1	push	dx
1000:29a2	call	0x29ae
1000:29a5	pop	dx
1000:29a6	add	dx, 6
1000:29a9	pop	si
1000:29aa	pop	cx
1000:29ab	loop	loc_12975
1000:29ad	ret	
                sub_12959 ENDP
*/
void sub_12959()
{
    // coverage: 0x2b59-0x2bae method sub_12959
    memoryASet16(ds, 0x944e, ax);
    al = memoryAGet(ds, si);
    ah = al;
    al <<= 1;
    al += ah;
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax += 0x9455;
    si = ax;
    cx = 0x000c;
    dx = 0x0000;
loc_12975:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    push(si);
    push(dx);
    if (al != 0x20)
        goto loc_12982;
    ax = 0x6546;
    goto loc_129a0;
loc_12982:
    if (al != 0x2e)
        goto loc_1298b;
    ax = 0x6f6c;
    goto loc_129a0;
loc_1298b:
    if (al != 0x5f)
        goto loc_12994;
    ax = 0x764c;
    goto loc_129a0;
loc_12994:
    al -= 0x41;
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
loc_129a0:
    push(ax);
    push(dx);
    sub_129ae();
    dx = pop();
    dx += 0x0006;
    si = pop();
    cx = pop();
    if (--cx)
        goto loc_12975;
}
/* Assembly listing of 1000:296f sub_1296f()
                sub_1296f PROC
1000:296f	mov	cx, 0xc
1000:2972	mov	dx, 0
        	loc_12975:
1000:2975	push	cx
1000:2976	lodsb	al, byte ptr [si]
1000:2977	push	si
1000:2978	push	dx
1000:2979	cmp	al, 0x20
1000:297b	jne	loc_12982
1000:297d	mov	ax, 0x6546
1000:2980	jmp	loc_129a0
        	loc_12982:
1000:2982	cmp	al, 0x2e
1000:2984	jne	loc_1298b
1000:2986	mov	ax, 0x6f6c
1000:2989	jmp	loc_129a0
        	loc_1298b:
1000:298b	cmp	al, 0x5f
1000:298d	jne	loc_12994
1000:298f	mov	ax, 0x764c
1000:2992	jmp	loc_129a0
        	loc_12994:
1000:2994	sub	al, 0x41
1000:2996	mov	ah, al
1000:2998	shl	al, 1
1000:299a	add	al, ah
1000:299c	shl	al, 1
1000:299e	mov	ah, 0
        	loc_129a0:
1000:29a0	push	ax
1000:29a1	push	dx
1000:29a2	call	0x29ae
1000:29a5	pop	dx
1000:29a6	add	dx, 6
1000:29a9	pop	si
1000:29aa	pop	cx
1000:29ab	loop	loc_12975
1000:29ad	ret	
                sub_1296f ENDP
*/
void sub_1296f()
{
    // coverage: 0x2b6f-0x2bae method sub_1296f
    cx = 0x000c;
    dx = 0x0000;
loc_12975:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    push(si);
    push(dx);
    if (al != 0x20)
        goto loc_12982;
    ax = 0x6546;
    goto loc_129a0;
loc_12982:
    if (al != 0x2e)
        goto loc_1298b;
    ax = 0x6f6c;
    goto loc_129a0;
loc_1298b:
    if (al != 0x5f)
        goto loc_12994;
    ax = 0x764c;
    goto loc_129a0;
loc_12994:
    al -= 0x41;
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
loc_129a0:
    push(ax);
    push(dx);
    sub_129ae();
    dx = pop();
    dx += 0x0006;
    si = pop();
    cx = pop();
    if (--cx)
        goto loc_12975;
}
/* Assembly listing of 1000:29ae sub_129ae()
                sub_129ae PROC
1000:29ae	push	bp
1000:29af	mov	bp, sp
1000:29b1	mov	ax, word ptr [0x94f0]
1000:29b4	mov	es, ax
1000:29b6	mov	di, word ptr [0x944e]
1000:29ba	add	di, word ptr [bp + 4]
1000:29bd	mov	ax, word ptr [0x94ea]
1000:29c0	push	ds
1000:29c1	mov	ds, ax
1000:29c3	mov	si, word ptr [bp + 6]
1000:29c6	mov	cx, 0xb
        	loc_129c9:
1000:29c9	movsw	word ptr es:[di], word ptr [si]
1000:29ca	movsw	word ptr es:[di], word ptr [si]
1000:29cb	movsw	word ptr es:[di], word ptr [si]
1000:29cc	add	di, 0x9a
1000:29d0	add	si, 0x9a
1000:29d4	loop	loc_129c9
1000:29d6	pop	ds
1000:29d7	pop	bp
1000:29d8	ret	4
                sub_129ae ENDP
*/
void sub_129ae()
{
    // coverage: 0x2bae-0x2bdb method sub_129ae
    push(bp);
    bp = sp;
    ax = memoryAGet16(ds, 0x94f0);
    es = ax;
    di = memoryAGet16(ds, 0x944e);
    di += memoryAGet16(ss, bp + 4 - 2);
    ax = memoryAGet16(ds, 0x94ea);
    push(ds);
    ds = ax;
    si = memoryAGet16(ss, bp + 6 - 2);
    cx = 0x000b;
loc_129c9:
    movsw<MemAuto, MemAuto, DirAuto>();
    movsw<MemAuto, MemAuto, DirAuto>();
    movsw<MemAuto, MemAuto, DirAuto>();
    di += 0x009a;
    si += 0x009a;
    if (--cx)
        goto loc_129c9;
    ds = pop();
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:29db sub_129db()
                sub_129db PROC
1000:29db	mov	word ptr [0x9453], 0
        	loc_129e1:
1000:29e1	mov	ax, word ptr [0x9453]
1000:29e4	cmp	ax, 0xc
1000:29e7	jae	loc_12a39
1000:29e9	call	0x541
1000:29ec	cmp	al, 0
1000:29ee	je	loc_12a39
1000:29f0	cmp	al, 8
1000:29f2	jne	loc_12a0d
1000:29f4	mov	bx, word ptr [0x9451]
1000:29f8	add	bx, word ptr [0x9453]
1000:29fc	mov	byte ptr [bx], 0x2e
1000:29ff	dec	word ptr [0x9453]
1000:2a03	jns	loc_12a0b
1000:2a05	mov	word ptr [0x9453], 0
        	loc_12a0b:
1000:2a0b	jmp	loc_12a1b
        	loc_12a0d:
1000:2a0d	mov	bx, word ptr [0x9451]
1000:2a11	add	bx, word ptr [0x9453]
1000:2a15	mov	byte ptr [bx], al
1000:2a17	inc	word ptr [0x9453]
        	loc_12a1b:
1000:2a1b	mov	bx, word ptr [0x9453]
1000:2a1f	cmp	bx, 0xc
1000:2a22	jae	loc_12a2b
1000:2a24	add	bx, word ptr [0x9451]
1000:2a28	mov	byte ptr [bx], 0x5f
        	loc_12a2b:
1000:2a2b	call	0x2a64
1000:2a2e	call	0x3498
1000:2a31	call	0xb8e
1000:2a34	call	0x3383
1000:2a37	jmp	loc_129e1
        	loc_12a39:
1000:2a39	mov	bx, word ptr [0x9453]
1000:2a3d	cmp	bx, 0xc
1000:2a40	jae	loc_12a52
1000:2a42	add	bx, word ptr [0x9451]
1000:2a46	mov	al, byte ptr [bx]
1000:2a48	cmp	al, 0x5f
1000:2a4a	jne	loc_12a52
1000:2a4c	mov	byte ptr [bx], 0x2e
1000:2a4f	call	0x2a64
        	loc_12a52:
1000:2a52	mov	di, 0x9455
1000:2a55	mov	dx, 0x1506
1000:2a58	mov	cx, 0x8c
1000:2a5b	call	0x674
1000:2a5e	mov	byte ptr [0x9546], 0
1000:2a63	ret	
                sub_129db ENDP
*/
void sub_129db()
{
    // coverage: 0x2bdb-0x2c64 method sub_129db
    memoryASet16(ds, 0x9453, 0x0000);
loc_129e1:
    ax = memoryAGet16(ds, 0x9453);
    if (ax >= 0x000c)
        goto loc_12a39;
    sub_10541();
    if (al == 0x00)
        goto loc_12a39;
    if (al != 0x08)
        goto loc_12a0d;
    bx = memoryAGet16(ds, 0x9451);
    bx += memoryAGet16(ds, 0x9453);
    memoryASet(ds, bx, 0x2e);
    memoryASet16(ds, 0x9453, memoryAGet16(ds, 0x9453) - 1);
    if ((short)memoryAGet16(ds, 0x9453) >= 0)
        goto loc_12a0b;
    memoryASet16(ds, 0x9453, 0x0000);
loc_12a0b:
    goto loc_12a1b;
loc_12a0d:
    bx = memoryAGet16(ds, 0x9451);
    bx += memoryAGet16(ds, 0x9453);
    memoryASet(ds, bx, al);
    memoryASet16(ds, 0x9453, memoryAGet16(ds, 0x9453) + 1);
loc_12a1b:
    bx = memoryAGet16(ds, 0x9453);
    if (bx >= 0x000c)
        goto loc_12a2b;
    bx += memoryAGet16(ds, 0x9451);
    memoryASet(ds, bx, 0x5f);
loc_12a2b:
    sub_12a64();
    sub_13498();
    sub_10b8e();
    sub_13383();
    goto loc_129e1;
loc_12a39:
    bx = memoryAGet16(ds, 0x9453);
    if (bx >= 0x000c)
        goto loc_12a52;
    bx += memoryAGet16(ds, 0x9451);
    al = memoryAGet(ds, bx);
    if (al != 0x5f)
        goto loc_12a52;
    memoryASet(ds, bx, 0x2e);
    sub_12a64();
loc_12a52:
    di = 0x9455;
    dx = 0x1506;
    cx = 0x008c;
    sub_10674();
    memoryASet(ds, 0x9546, 0x00);
}
/* Assembly listing of 1000:2a64 sub_12a64()
                sub_12a64 PROC
1000:2a64	mov	si, word ptr [0x9451]
1000:2a68	mov	bl, byte ptr [0x9450]
1000:2a6c	mov	bh, 0
1000:2a6e	shl	bx, 1
1000:2a70	shl	bx, 1
1000:2a72	shl	bx, 1
1000:2a74	mov	ax, word ptr [bx + 0x1b3]
1000:2a78	mov	word ptr [0x944e], ax
1000:2a7b	call	0x296f
1000:2a7e	ret	
                sub_12a64 ENDP
*/
void sub_12a64()
{
    // coverage: 0x2c64-0x2c7f method sub_12a64
    si = memoryAGet16(ds, 0x9451);
    bl = memoryAGet(ds, 0x9450);
    bh = 0x00;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 435);
    memoryASet16(ds, 0x944e, ax);
    sub_1296f();
}
/* Assembly listing of 1000:2a7f sub_12a7f()
                sub_12a7f PROC
1000:2a7f	mov	byte ptr [0x952e], 0
1000:2a84	mov	byte ptr [0x952f], 0
1000:2a89	mov	byte ptr [0x9530], 0
1000:2a8e	mov	byte ptr [0x9531], 0
1000:2a93	mov	byte ptr [0x9532], 0
1000:2a98	mov	byte ptr [0x9533], 0
1000:2a9d	mov	ax, 0x1178
1000:2aa0	push	ax
1000:2aa1	mov	ax, 0x1b82
1000:2aa4	push	ax
1000:2aa5	mov	ax, 0x10
1000:2aa8	push	ax
1000:2aa9	mov	ax, 8
1000:2aac	push	ax
1000:2aad	mov	ax, 4
1000:2ab0	push	ax
1000:2ab1	call	0x2cea
1000:2ab4	mov	ax, 0x1678
1000:2ab7	push	ax
1000:2ab8	mov	ax, 0x1cc2
1000:2abb	push	ax
1000:2abc	mov	ax, 0x10
1000:2abf	push	ax
1000:2ac0	mov	ax, 8
1000:2ac3	push	ax
1000:2ac4	mov	ax, 4
1000:2ac7	push	ax
1000:2ac8	call	0x2cea
1000:2acb	mov	ax, 0x1b78
1000:2ace	push	ax
1000:2acf	mov	ax, 0x1e02
1000:2ad2	push	ax
1000:2ad3	mov	ax, 0x10
1000:2ad6	push	ax
1000:2ad7	mov	ax, 8
1000:2ada	push	ax
1000:2adb	mov	ax, 4
1000:2ade	push	ax
1000:2adf	call	0x2cea
1000:2ae2	mov	ax, 0x2078
1000:2ae5	push	ax
1000:2ae6	mov	ax, 0x1b85
1000:2ae9	push	ax
1000:2aea	mov	ax, 0x10
1000:2aed	push	ax
1000:2aee	mov	ax, 8
1000:2af1	push	ax
1000:2af2	mov	ax, 4
1000:2af5	push	ax
1000:2af6	call	0x2cea
1000:2af9	mov	ax, 0x2578
1000:2afc	push	ax
1000:2afd	mov	ax, 0x1cc5
1000:2b00	push	ax
1000:2b01	mov	ax, 0x10
1000:2b04	push	ax
1000:2b05	mov	ax, 8
1000:2b08	push	ax
1000:2b09	mov	ax, 4
1000:2b0c	push	ax
1000:2b0d	call	0x2cea
1000:2b10	mov	ax, 0x2a78
1000:2b13	push	ax
1000:2b14	mov	ax, 0x1e05
1000:2b17	push	ax
1000:2b18	mov	ax, 0x10
1000:2b1b	push	ax
1000:2b1c	mov	ax, 8
1000:2b1f	push	ax
1000:2b20	mov	ax, 4
1000:2b23	push	ax
1000:2b24	call	0x2cea
1000:2b27	ret	
                sub_12a7f ENDP
*/
void sub_12a7f()
{
    // coverage: 0x2c7f-0x2d28 method sub_12a7f
    memoryASet(ds, 0x952e, 0x00);
    memoryASet(ds, 0x952f, 0x00);
    memoryASet(ds, 0x9530, 0x00);
    memoryASet(ds, 0x9531, 0x00);
    memoryASet(ds, 0x9532, 0x00);
    memoryASet(ds, 0x9533, 0x00);
    ax = 0x1178;
    push(ax);
    ax = 0x1b82;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x1678;
    push(ax);
    ax = 0x1cc2;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x1b78;
    push(ax);
    ax = 0x1e02;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x2078;
    push(ax);
    ax = 0x1b85;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x2578;
    push(ax);
    ax = 0x1cc5;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x2a78;
    push(ax);
    ax = 0x1e05;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2b28 sub_12b28()
                sub_12b28 PROC
1000:2b28	push	ax
1000:2b29	mov	ax, 0
1000:2b2c	push	ax
1000:2b2d	mov	ax, 1
1000:2b30	push	ax
1000:2b31	mov	ax, 5
1000:2b34	push	ax
1000:2b35	mov	ax, 0
1000:2b38	push	ax
1000:2b39	call	0x269e
1000:2b3c	pop	ax
1000:2b3d	cmp	al, 0
1000:2b3f	je	loc_12b59
1000:2b41	cmp	al, 1
1000:2b43	je	loc_12b76
1000:2b45	cmp	al, 2
1000:2b47	je	loc_12b93
1000:2b49	cmp	al, 3
1000:2b4b	je	loc_12bb0
1000:2b4d	cmp	al, 4
1000:2b4f	je	loc_12bcd
1000:2b51	cmp	al, 5
1000:2b53	jne	loc_12b58
1000:2b55	jmp	loc_12bea
        	loc_12b58:
1000:2b58	ret	
        	loc_12b59:
1000:2b59	mov	byte ptr [0x952e], 1
1000:2b5e	mov	ax, 0x2f78
1000:2b61	push	ax
1000:2b62	mov	ax, 0x1b82
1000:2b65	push	ax
1000:2b66	mov	ax, 0x10
1000:2b69	push	ax
1000:2b6a	mov	ax, 8
1000:2b6d	push	ax
1000:2b6e	mov	ax, 4
1000:2b71	push	ax
1000:2b72	call	0x2cea
1000:2b75	ret	
        	loc_12b76:
1000:2b76	mov	byte ptr [0x952f], 1
1000:2b7b	mov	ax, 0x2f78
1000:2b7e	push	ax
1000:2b7f	mov	ax, 0x1cc2
1000:2b82	push	ax
1000:2b83	mov	ax, 0x10
1000:2b86	push	ax
1000:2b87	mov	ax, 8
1000:2b8a	push	ax
1000:2b8b	mov	ax, 4
1000:2b8e	push	ax
1000:2b8f	call	0x2cea
1000:2b92	ret	
        	loc_12b93:
1000:2b93	mov	byte ptr [0x9530], 1
1000:2b98	mov	ax, 0x2f78
1000:2b9b	push	ax
1000:2b9c	mov	ax, 0x1e02
1000:2b9f	push	ax
1000:2ba0	mov	ax, 0x10
1000:2ba3	push	ax
1000:2ba4	mov	ax, 8
1000:2ba7	push	ax
1000:2ba8	mov	ax, 4
1000:2bab	push	ax
1000:2bac	call	0x2cea
1000:2baf	ret	
        	loc_12bb0:
1000:2bb0	mov	byte ptr [0x9531], 1
1000:2bb5	mov	ax, 0x2f78
1000:2bb8	push	ax
1000:2bb9	mov	ax, 0x1b85
1000:2bbc	push	ax
1000:2bbd	mov	ax, 0x10
1000:2bc0	push	ax
1000:2bc1	mov	ax, 8
1000:2bc4	push	ax
1000:2bc5	mov	ax, 4
1000:2bc8	push	ax
1000:2bc9	call	0x2cea
1000:2bcc	ret	
        	loc_12bcd:
1000:2bcd	mov	byte ptr [0x9532], 1
1000:2bd2	mov	ax, 0x2f78
1000:2bd5	push	ax
1000:2bd6	mov	ax, 0x1cc5
1000:2bd9	push	ax
1000:2bda	mov	ax, 0x10
1000:2bdd	push	ax
1000:2bde	mov	ax, 8
1000:2be1	push	ax
1000:2be2	mov	ax, 4
1000:2be5	push	ax
1000:2be6	call	0x2cea
1000:2be9	ret	
        	loc_12bea:
1000:2bea	mov	byte ptr [0x9533], 1
1000:2bef	mov	ax, 0x2f78
1000:2bf2	push	ax
1000:2bf3	mov	ax, 0x1e05
1000:2bf6	push	ax
1000:2bf7	mov	ax, 0x10
1000:2bfa	push	ax
1000:2bfb	mov	ax, 8
1000:2bfe	push	ax
1000:2bff	mov	ax, 4
1000:2c02	push	ax
1000:2c03	call	0x2cea
1000:2c06	ret	
                sub_12b28 ENDP
*/
void sub_12b28()
{
    // coverage: 0x2d28-0x2e07 method sub_12b28
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0005;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
    ax = pop();
    if (al == 0x00)
        goto loc_12b59;
    if (al == 0x01)
        goto loc_12b76;
    if (al == 0x02)
        goto loc_12b93;
    if (al == 0x03)
        goto loc_12bb0;
    if (al == 0x04)
        goto loc_12bcd;
    if (al != 0x05)
        goto loc_12b58;
    goto loc_12bea;
loc_12b58:
    return;
loc_12b59:
    memoryASet(ds, 0x952e, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1b82;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12b76:
    memoryASet(ds, 0x952f, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1cc2;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12b93:
    memoryASet(ds, 0x9530, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1e02;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12bb0:
    memoryASet(ds, 0x9531, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1b85;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12bcd:
    memoryASet(ds, 0x9532, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1cc5;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12bea:
    memoryASet(ds, 0x9533, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1e05;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2c07 sub_12c07()
                sub_12c07 PROC
1000:2c07	mov	ax, 0xa0b
1000:2c0a	push	ax
1000:2c0b	mov	ax, 0x13
1000:2c0e	push	ax
1000:2c0f	mov	ax, 0x30
1000:2c12	push	ax
1000:2c13	mov	ax, 5
1000:2c16	push	ax
1000:2c17	call	0x2d9a
1000:2c1a	mov	ax, 0xaac
1000:2c1d	push	ax
1000:2c1e	mov	ax, 0x11
1000:2c21	push	ax
1000:2c22	mov	ax, 0x28
1000:2c25	push	ax
1000:2c26	mov	ax, 2
1000:2c29	push	ax
1000:2c2a	call	0x2d9a
1000:2c2d	mov	ax, 0x5a5c
1000:2c30	push	ax
1000:2c31	mov	ax, 0xb4d
1000:2c34	push	ax
1000:2c35	mov	ax, 0x78
1000:2c38	push	ax
1000:2c39	mov	ax, 0xf
1000:2c3c	push	ax
1000:2c3d	mov	ax, 4
1000:2c40	push	ax
1000:2c41	call	0x2cea
1000:2c44	ret	
                sub_12c07 ENDP
*/
void sub_12c07()
{
    // coverage: 0x2e07-0x2e45 method sub_12c07
    ax = 0x0a0b;
    push(ax);
    ax = 0x0013;
    push(ax);
    ax = 0x0030;
    push(ax);
    ax = 0x0005;
    push(ax);
    sub_12d9a();
    ax = 0x0aac;
    push(ax);
    ax = 0x0011;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12d9a();
    ax = 0x5a5c;
    push(ax);
    ax = 0x0b4d;
    push(ax);
    ax = 0x0078;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2c45 sub_12c45()
                sub_12c45 PROC
1000:2c45	mov	ax, 0xaac
1000:2c48	push	ax
1000:2c49	mov	ax, 0x10
1000:2c4c	push	ax
1000:2c4d	mov	ax, 0x28
1000:2c50	push	ax
1000:2c51	mov	ax, 5
1000:2c54	push	ax
1000:2c55	call	0x2d9a
1000:2c58	mov	ax, 0xb4d
1000:2c5b	push	ax
1000:2c5c	mov	ax, 0xe
1000:2c5f	push	ax
1000:2c60	mov	ax, 0x20
1000:2c63	push	ax
1000:2c64	mov	ax, 2
1000:2c67	push	ax
1000:2c68	call	0x2d9a
1000:2c6b	mov	ax, 0x7592
1000:2c6e	push	ax
1000:2c6f	mov	ax, 0xc8f
1000:2c72	push	ax
1000:2c73	mov	ax, 0x28
1000:2c76	push	ax
1000:2c77	mov	ax, 0xc
1000:2c7a	push	ax
1000:2c7b	mov	ax, 2
1000:2c7e	push	ax
1000:2c7f	call	0x2cea
1000:2c82	mov	ax, 0x1ab8
1000:2c85	push	ax
1000:2c86	mov	ax, 0xce4
1000:2c89	push	ax
1000:2c8a	mov	ax, 0x20
1000:2c8d	push	ax
1000:2c8e	mov	ax, 0xd
1000:2c91	push	ax
1000:2c92	mov	ax, 4
1000:2c95	push	ax
1000:2c96	call	0x2cea
1000:2c99	ret	
                sub_12c45 ENDP
*/
void sub_12c45()
{
    // coverage: 0x2e45-0x2e9a method sub_12c45
    ax = 0x0aac;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x0005;
    push(ax);
    sub_12d9a();
    ax = 0x0b4d;
    push(ax);
    ax = 0x000e;
    push(ax);
    ax = 0x0020;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12d9a();
    ax = 0x7592;
    push(ax);
    ax = 0x0c8f;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x000c;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    ax = 0x1ab8;
    push(ax);
    ax = 0x0ce4;
    push(ax);
    ax = 0x0020;
    push(ax);
    ax = 0x000d;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2c9a sub_12c9a()
                sub_12c9a PROC
1000:2c9a	push	ax
1000:2c9b	mov	ax, 0xdcc
1000:2c9e	push	ax
1000:2c9f	mov	ax, 0x11
1000:2ca2	push	ax
1000:2ca3	mov	ax, 0xf
1000:2ca6	push	ax
1000:2ca7	mov	ax, 2
1000:2caa	push	ax
1000:2cab	call	0x2d9a
1000:2cae	pop	ax
1000:2caf	cmp	al, 6
1000:2cb1	jne	loc_12cbc
1000:2cb3	mov	al, 0
1000:2cb5	call	0x2cc7
1000:2cb8	mov	al, 6
1000:2cba	jmp	loc_12cc7
        	loc_12cbc:
1000:2cbc	cmp	al, 7
1000:2cbe	jne	loc_12cc7
1000:2cc0	mov	al, 1
1000:2cc2	call	0x2cc7
1000:2cc5	mov	al, 7
        	loc_12cc7:
1000:2cc7	mov	bl, al
1000:2cc9	mov	bh, 0
1000:2ccb	shl	bx, 1
1000:2ccd	mov	ax, word ptr [bx + 0x151f]
1000:2cd1	push	ax
1000:2cd2	mov	ax, word ptr [bx + 0x152f]
1000:2cd6	push	ax
1000:2cd7	mov	ax, word ptr [bx + 0x153f]
1000:2cdb	push	ax
1000:2cdc	mov	ax, word ptr [bx + 0x154f]
1000:2ce0	push	ax
1000:2ce1	mov	ax, word ptr [bx + 0x150f]
1000:2ce5	push	ax
1000:2ce6	call	0x2cea
1000:2ce9	ret	
                sub_12c9a ENDP
*/
void sub_12c9a()
{
    // coverage: 0x2e9a-0x2eea method sub_12c9a
    push(ax);
    ax = 0x0dcc;
    push(ax);
    ax = 0x0011;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12d9a();
    ax = pop();
    if (al != 0x06)
        goto loc_12cbc;
    al = 0x00;
    sub_12cc7();
    al = 0x06;
    goto loc_12cc7;
loc_12cbc:
    if (al != 0x07)
        goto loc_12cc7;
    al = 0x01;
    sub_12cc7();
    al = 0x07;
loc_12cc7:
    bl = al;
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5407);
    push(ax);
    ax = memoryAGet16(ds, bx + 5423);
    push(ax);
    ax = memoryAGet16(ds, bx + 5439);
    push(ax);
    ax = memoryAGet16(ds, bx + 5455);
    push(ax);
    ax = memoryAGet16(ds, bx + 5391);
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2cc7 sub_12cc7()
                sub_12cc7 PROC
1000:2cc7	mov	bl, al
1000:2cc9	mov	bh, 0
1000:2ccb	shl	bx, 1
1000:2ccd	mov	ax, word ptr [bx + 0x151f]
1000:2cd1	push	ax
1000:2cd2	mov	ax, word ptr [bx + 0x152f]
1000:2cd6	push	ax
1000:2cd7	mov	ax, word ptr [bx + 0x153f]
1000:2cdb	push	ax
1000:2cdc	mov	ax, word ptr [bx + 0x154f]
1000:2ce0	push	ax
1000:2ce1	mov	ax, word ptr [bx + 0x150f]
1000:2ce5	push	ax
1000:2ce6	call	0x2cea
1000:2ce9	ret	
                sub_12cc7 ENDP
*/
void sub_12cc7()
{
    // coverage: 0x2ec7-0x2eea method sub_12cc7
    bl = al;
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5407);
    push(ax);
    ax = memoryAGet16(ds, bx + 5423);
    push(ax);
    ax = memoryAGet16(ds, bx + 5439);
    push(ax);
    ax = memoryAGet16(ds, bx + 5455);
    push(ax);
    ax = memoryAGet16(ds, bx + 5391);
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2cea sub_12cea()
                sub_12cea PROC
1000:2cea	push	bp
1000:2ceb	mov	bp, sp
1000:2ced	mov	ax, 0xa000
1000:2cf0	mov	es, ax
1000:2cf2	mov	di, word ptr [bp + 0xa]
1000:2cf5	mov	bx, word ptr [bp + 4]
1000:2cf8	mov	bx, word ptr [bx - 0x6b18]
1000:2cfc	mov	si, word ptr [bp + 0xc]
1000:2cff	push	ds
1000:2d00	push	bx
1000:2d01	mov	dx, 0x3ce
1000:2d04	mov	ax, 0xa05
1000:2d07	out	dx, ax
1000:2d08	mov	ax, 7
1000:2d0b	out	dx, ax
1000:2d0c	mov	cx, word ptr [bp + 8]
1000:2d0f	shr	cx, 1
1000:2d11	mov	ah, 0x80
1000:2d13	mov	al, 8
1000:2d15	pop	ds
1000:2d16	mov	bx, word ptr [bp + 6]
        	loc_12d19:
1000:2d19	push	ax
1000:2d1a	push	bx
1000:2d1b	push	cx
1000:2d1c	push	di
1000:2d1d	push	si
        	loc_12d1e:
1000:2d1e	mov	bh, 0x22
        	loc_12d20:
1000:2d20	mov	bl, byte ptr [si]
1000:2d22	inc	si
1000:2d23	cmp	bh, bl
1000:2d25	jne	loc_12d3d
1000:2d27	shr	ah, 1
1000:2d29	jne	loc_12d32
1000:2d2b	mov	ah, 0x40
1000:2d2d	inc	di
1000:2d2e	loop	loc_12d20
1000:2d30	jmp	loc_12d76
        	loc_12d32:
1000:2d32	shr	ah, 1
1000:2d34	jne	loc_12d39
1000:2d36	mov	ah, 0x80
1000:2d38	inc	di
        	loc_12d39:
1000:2d39	loop	loc_12d20
1000:2d3b	jmp	loc_12d76
        	loc_12d3d:
1000:2d3d	mov	bh, bl
1000:2d3f	shr	bl, 1
1000:2d41	shr	bl, 1
1000:2d43	shr	bl, 1
1000:2d45	shr	bl, 1
1000:2d47	cmp	bl, 2
1000:2d4a	je	loc_12d55
1000:2d4c	out	dx, ax
1000:2d4d	and	byte ptr es:[di], bl
1000:2d50	and	byte ptr es:[di + 0x2000], bl
        	loc_12d55:
1000:2d55	shr	ah, 1
1000:2d57	jne	loc_12d5c
1000:2d59	mov	ah, 0x80
1000:2d5b	inc	di
        	loc_12d5c:
1000:2d5c	and	bh, 0xf
1000:2d5f	cmp	bh, 2
1000:2d62	je	loc_12d6d
1000:2d64	out	dx, ax
1000:2d65	and	byte ptr es:[di], bh
1000:2d68	and	byte ptr es:[di + 0x2000], bh
        	loc_12d6d:
1000:2d6d	shr	ah, 1
1000:2d6f	jne	loc_12d74
1000:2d71	mov	ah, 0x80
1000:2d73	inc	di
        	loc_12d74:
1000:2d74	loop	loc_12d1e
        	loc_12d76:
1000:2d76	pop	si
1000:2d77	add	si, 0xa0
1000:2d7b	pop	di
1000:2d7c	add	di, 0x28
1000:2d7f	and	di, 0x7fff
1000:2d83	pop	cx
1000:2d84	pop	bx
1000:2d85	pop	ax
1000:2d86	dec	bx
1000:2d87	jne	loc_12d19
1000:2d89	pop	ds
1000:2d8a	mov	ax, 0xff08
1000:2d8d	out	dx, ax
1000:2d8e	mov	ax, 5
1000:2d91	out	dx, ax
1000:2d92	mov	ax, 0xf07
1000:2d95	out	dx, ax
1000:2d96	pop	bp
1000:2d97	ret	0xa
                sub_12cea ENDP
*/
void sub_12cea()
{
    // coverage: 0x2eea-0x2f9a method sub_12cea
    push(bp);
    bp = sp;
    ax = 0xa000;
    es = ax;
    di = memoryAGet16(ss, bp + 10 - 2);
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx = memoryAGet16(ds, bx + 38120);
    si = memoryAGet16(ss, bp + 12 - 2);
    push(ds);
    push(bx);
    dx = 0x03ce;
    ax = 0x0a05;
    out(dx, ax);
    ax = 0x0007;
    out(dx, ax);
    cx = memoryAGet16(ss, bp + 8 - 2);
    cx >>= 1;
    ah = 0x80;
    al = 0x08;
    ds = pop();
    bx = memoryAGet16(ss, bp + 6 - 2);
loc_12d19:
    push(ax);
    push(bx);
    push(cx);
    push(di);
    push(si);
loc_12d1e:
    bh = 0x22;
loc_12d20:
    bl = memoryAGet(ds, si);
    si++;
    if (bh != bl)
        goto loc_12d3d;
    ah >>= 1;
    if (ah != 0)
        goto loc_12d32;
    ah = 0x40;
    di++;
    if (--cx)
        goto loc_12d20;
    goto loc_12d76;
loc_12d32:
    ah >>= 1;
    if (ah != 0)
        goto loc_12d39;
    ah = 0x80;
    di++;
loc_12d39:
    if (--cx)
        goto loc_12d20;
    goto loc_12d76;
loc_12d3d:
    bh = bl;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    if (bl == 0x02)
        goto loc_12d55;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bl);
    memoryASet(es, di + 8192, memoryAGet(es, di + 8192) & bl);
loc_12d55:
    ah >>= 1;
    if (ah != 0)
        goto loc_12d5c;
    ah = 0x80;
    di++;
loc_12d5c:
    bh &= 0x0f;
    if (bh == 0x02)
        goto loc_12d6d;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bh);
    memoryASet(es, di + 8192, memoryAGet(es, di + 8192) & bh);
loc_12d6d:
    ah >>= 1;
    if (ah != 0)
        goto loc_12d74;
    ah = 0x80;
    di++;
loc_12d74:
    if (--cx)
        goto loc_12d1e;
loc_12d76:
    si = pop();
    si += 0x00a0;
    di = pop();
    di += 0x0028;
    di &= 0x7fff;
    cx = pop();
    bx = pop();
    ax = pop();
    tx = bx;
    bx--;
    if (tx != 1)
        goto loc_12d19;
    ds = pop();
    ax = 0xff08;
    out(dx, ax);
    ax = 0x0005;
    out(dx, ax);
    ax = 0x0f07;
    out(dx, ax);
    bp = pop();
    sp += 10;
}
/* Assembly listing of 1000:2d9a sub_12d9a()
                sub_12d9a PROC
1000:2d9a	push	bp
1000:2d9b	mov	bp, sp
1000:2d9d	mov	ax, 0xa000
1000:2da0	mov	es, ax
1000:2da2	mov	di, word ptr [bp + 0xa]
1000:2da5	mov	dx, 0x3ce
1000:2da8	mov	ax, word ptr [bp + 4]
1000:2dab	mov	ah, al
1000:2dad	mov	al, 0
1000:2daf	out	dx, ax
1000:2db0	mov	ax, 0xf01
1000:2db3	out	dx, ax
1000:2db4	cld	
1000:2db5	mov	bx, word ptr [bp + 6]
        	loc_12db8:
1000:2db8	push	di
1000:2db9	mov	cx, word ptr [bp + 8]
1000:2dbc	rep stosb	byte ptr es:[di], al
1000:2dbe	pop	di
1000:2dbf	push	di
1000:2dc0	add	di, 0x2000
1000:2dc4	mov	cx, word ptr [bp + 8]
1000:2dc7	rep stosb	byte ptr es:[di], al
1000:2dc9	pop	di
1000:2dca	add	di, 0x28
1000:2dcd	dec	bx
1000:2dce	jne	loc_12db8
1000:2dd0	mov	ax, 0
1000:2dd3	out	dx, ax
1000:2dd4	inc	al
1000:2dd6	out	dx, ax
1000:2dd7	pop	bp
1000:2dd8	ret	8
                sub_12d9a ENDP
*/
void sub_12d9a()
{
    // coverage: 0x2f9a-0x2fdb method sub_12d9a
    push(bp);
    bp = sp;
    ax = 0xa000;
    es = ax;
    di = memoryAGet16(ss, bp + 10 - 2);
    dx = 0x03ce;
    ax = memoryAGet16(ss, bp + 4 - 2);
    ah = al;
    al = 0x00;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    flags.direction = false;
    bx = memoryAGet16(ss, bp + 6 - 2);
loc_12db8:
    push(di);
    cx = memoryAGet16(ss, bp + 8 - 2);
    rep_stosb<MemAuto, DirAuto>();
    di = pop();
    push(di);
    di += 0x2000;
    cx = memoryAGet16(ss, bp + 8 - 2);
    rep_stosb<MemAuto, DirAuto>();
    di = pop();
    di += 0x0028;
    tx = bx;
    bx--;
    if (tx != 1)
        goto loc_12db8;
    ax = 0x0000;
    out(dx, ax);
    al++;
    out(dx, ax);
    bp = pop();
    sp += 8;
}
/* Assembly listing of 1000:2ddc sub_12ddc()
                sub_12ddc PROC
1000:2ddc	mov	bl, byte ptr [0x94e4]
1000:2de0	and	bx, 3
1000:2de3	shl	bx, 1
1000:2de5	mov	ax, word ptr [bx + 0x1a2a]
1000:2de9	mov	word ptr [0x94e2], ax
1000:2dec	inc	byte ptr [0x94e4]
1000:2df0	mov	byte ptr [0x9527], 0xff
1000:2df5	ret	
                sub_12ddc ENDP
*/
void sub_12ddc()
{
    // coverage: 0x2fdc-0x2ff6 method sub_12ddc
    bl = memoryAGet(ds, 0x94e4);
    bx &= 0x0003;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 6698);
    memoryASet16(ds, 0x94e2, ax);
    memoryASet(ds, 0x94e4, memoryAGet(ds, 0x94e4) + 1);
    memoryASet(ds, 0x9527, 0xff);
}
/* Assembly listing of 1000:2df6 sub_12df6()
                sub_12df6 PROC
1000:2df6	mov	al, 0
1000:2df8	mov	byte ptr [0x94e5], al
1000:2dfb	mov	byte ptr [0x94e6], al
1000:2dfe	mov	byte ptr [0x94e7], al
1000:2e01	ret	
                sub_12df6 ENDP
*/
void sub_12df6()
{
    // coverage: 0x2ff6-0x3002 method sub_12df6
    al = 0x00;
    memoryASet(ds, 0x94e5, al);
    memoryASet(ds, 0x94e6, al);
    memoryASet(ds, 0x94e7, al);
}
/* Assembly listing of 1000:2e02 sub_12e02()
                sub_12e02 PROC
1000:2e02	push	si
1000:2e03	call	0x1b80
1000:2e06	call	0x309d
1000:2e09	pop	si
1000:2e0a	mov	ax, word ptr [0x952a]
1000:2e0d	shr	ax, 1
1000:2e0f	shr	ax, 1
1000:2e11	shr	ax, 1
1000:2e13	mov	bx, word ptr [0x954c]
1000:2e17	test	bl, 1
1000:2e1a	je	loc_12e23
1000:2e1c	neg	ax
1000:2e1e	sub	ax, 3
1000:2e21	jmp	loc_12e30
        	loc_12e23:
1000:2e23	test	bl, 2
1000:2e26	je	loc_12e2d
1000:2e28	add	ax, 3
1000:2e2b	jmp	loc_12e30
        	loc_12e2d:
1000:2e2d	mov	ax, 0
        	loc_12e30:
1000:2e30	mov	word ptr [0x9522], ax
1000:2e33	mov	al, byte ptr [si + 0x16]
1000:2e36	and	ax, 0x7f
1000:2e39	cmp	al, 0x3f
1000:2e3b	jbe	loc_12e48
1000:2e3d	neg	al
1000:2e3f	add	al, 0x7f
1000:2e41	call	0x3084
1000:2e44	neg	ax
1000:2e46	jmp	loc_12e4b
        	loc_12e48:
1000:2e48	call	0x3084
        	loc_12e4b:
1000:2e4b	mov	word ptr [0x9520], ax
1000:2e4e	mov	ax, word ptr [0x951e]
1000:2e51	add	ax, word ptr [0x9522]
1000:2e55	add	ax, word ptr [0x9520]
1000:2e59	je	loc_12e6a
1000:2e5b	jns	loc_12e63
1000:2e5d	inc	ax
1000:2e5e	jns	loc_12e61
1000:2e60	inc	ax
        	loc_12e61:
1000:2e61	jmp	loc_12e6a
        	loc_12e63:
1000:2e63	dec	ax
1000:2e64	cmp	ax, 0
1000:2e67	jle	loc_12e6a
1000:2e69	dec	ax
        	loc_12e6a:
1000:2e6a	cmp	ax, 0x40
1000:2e6d	jle	loc_12e74
1000:2e6f	mov	ax, 0x40
1000:2e72	jmp	loc_12e7c
        	loc_12e74:
1000:2e74	cmp	ax, 0xffc0
1000:2e77	jge	loc_12e7c
1000:2e79	mov	ax, 0xffc0
        	loc_12e7c:
1000:2e7c	mov	word ptr [0x951e], ax
1000:2e7f	sar	ax, 1
1000:2e81	sar	ax, 1
1000:2e83	add	byte ptr [si + 0x16], al
1000:2e86	mov	al, byte ptr [si + 0x16]
1000:2e89	and	ax, 0x7f
1000:2e8c	mov	bx, ax
1000:2e8e	mov	al, byte ptr [bx + 0x1675]
1000:2e92	cwde	
1000:2e93	shl	ax, 1
1000:2e95	add	ax, 0x80
1000:2e98	mov	word ptr [si + 5], ax
1000:2e9b	mov	al, byte ptr [bx + 0x16f5]
1000:2e9f	cwde	
1000:2ea0	shl	ax, 1
1000:2ea2	add	ax, 0x80
1000:2ea5	push	bx
1000:2ea6	cmp	ax, 0
1000:2ea9	je	loc_12ebe
1000:2eab	mov	bx, ax
1000:2ead	shl	ax, 1
1000:2eaf	shl	ax, 1
1000:2eb1	add	ax, bx
1000:2eb3	shl	ax, 1
1000:2eb5	add	ax, 5
1000:2eb8	mov	bl, 0xc
1000:2eba	div	bl
1000:2ebc	mov	ah, 0
        	loc_12ebe:
1000:2ebe	pop	bx
1000:2ebf	mov	word ptr [si + 7], ax
1000:2ec2	mov	al, byte ptr [bx + 0x1775]
1000:2ec6	mov	byte ptr [si + 4], al
1000:2ec9	mov	bx, 0x1594
1000:2ecc	call	0x2121
1000:2ecf	mov	al, byte ptr [0x94e6]
1000:2ed2	mov	byte ptr [0x94e7], al
1000:2ed5	mov	al, byte ptr [0x94e5]
1000:2ed8	mov	byte ptr [0x94e6], al
1000:2edb	mov	al, byte ptr [0x1ba0]
1000:2ede	mov	byte ptr [0x94e5], al
1000:2ee1	mov	ax, word ptr [0x954c]
1000:2ee4	mov	bl, byte ptr [0x951a]
1000:2ee8	test	al, 0x40
1000:2eea	je	loc_12f02
1000:2eec	cmp	bl, 2
1000:2eef	jne	loc_12f00
1000:2ef1	mov	byte ptr [0x951a], 3
1000:2ef6	mov	al, 2
1000:2ef8	call	0x3840
1000:2efb	mov	byte ptr [0x951c], 2
        	loc_12f00:
1000:2f00	jmp	loc_12f18
        	loc_12f02:
1000:2f02	cmp	bl, 1
1000:2f05	jne	loc_12f0e
1000:2f07	mov	byte ptr [0x951a], 2
1000:2f0c	jmp	loc_12f18
        	loc_12f0e:
1000:2f0e	cmp	bl, 3
1000:2f11	jne	loc_12f18
1000:2f13	mov	byte ptr [0x951a], 0
        	loc_12f18:
1000:2f18	mov	ax, word ptr [0x954c]
1000:2f1b	mov	bl, byte ptr [0x951b]
1000:2f1f	test	al, 0x20
1000:2f21	je	loc_12f39
1000:2f23	cmp	bl, 2
1000:2f26	jne	loc_12f37
1000:2f28	mov	byte ptr [0x951b], 3
1000:2f2d	mov	al, 2
1000:2f2f	call	0x3840
1000:2f32	mov	byte ptr [0x951c], 2
        	loc_12f37:
1000:2f37	jmp	loc_12f4f
        	loc_12f39:
1000:2f39	cmp	bl, 1
1000:2f3c	jne	loc_12f45
1000:2f3e	mov	byte ptr [0x951b], 2
1000:2f43	jmp	loc_12f4f
        	loc_12f45:
1000:2f45	cmp	bl, 3
1000:2f48	jne	loc_12f4f
1000:2f4a	mov	byte ptr [0x951b], 0
        	loc_12f4f:
1000:2f4f	ret	
                sub_12e02 ENDP
*/
void sub_12e02()
{
    // coverage: 0x3002-0x3150 method sub_12e02
    push(si);
    sub_11b80();
    sub_1309d();
    si = pop();
    ax = memoryAGet16(ds, 0x952a);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    bx = memoryAGet16(ds, 0x954c);
    if (!(bl & 0x01))
        goto loc_12e23;
    ax = -ax;
    ax -= 0x0003;
    goto loc_12e30;
loc_12e23:
    if (!(bl & 0x02))
        goto loc_12e2d;
    ax += 0x0003;
    goto loc_12e30;
loc_12e2d:
    ax = 0x0000;
loc_12e30:
    memoryASet16(ds, 0x9522, ax);
    al = memoryAGet(ds, si + 22);
    ax &= 0x007f;
    if (al <= 0x3f)
        goto loc_12e48;
    al = -al;
    al += 0x7f;
    sub_13084();
    ax = -ax;
    goto loc_12e4b;
loc_12e48:
    sub_13084();
loc_12e4b:
    memoryASet16(ds, 0x9520, ax);
    ax = memoryAGet16(ds, 0x951e);
    ax += memoryAGet16(ds, 0x9522);
    ax += memoryAGet16(ds, 0x9520);
    if (ax == 0)
        goto loc_12e6a;
    if ((short)ax >= 0)
        goto loc_12e63;
    ax++;
    if ((short)ax >= 0)
        goto loc_12e61;
    ax++;
loc_12e61:
    goto loc_12e6a;
loc_12e63:
    ax--;
    if ((short)ax <= (short)0x0000)
        goto loc_12e6a;
    ax--;
loc_12e6a:
    if ((short)ax <= (short)0x0040)
        goto loc_12e74;
    ax = 0x0040;
    goto loc_12e7c;
loc_12e74:
    if ((short)ax >= (short)0xffc0)
        goto loc_12e7c;
    ax = 0xffc0;
loc_12e7c:
    memoryASet16(ds, 0x951e, ax);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + al);
    al = memoryAGet(ds, si + 22);
    ax &= 0x007f;
    bx = ax;
    al = memoryAGet(ds, bx + 5749);
    cbw();
    ax <<= 1;
    ax += 0x0080;
    memoryASet16(ds, si + 5, ax);
    al = memoryAGet(ds, bx + 5877);
    cbw();
    ax <<= 1;
    ax += 0x0080;
    push(bx);
    if (ax == 0x0000)
        goto loc_12ebe;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_12ebe:
    bx = pop();
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, bx + 6005);
    memoryASet(ds, si + 4, al);
    bx = 0x1594;
    sub_12121();
    al = memoryAGet(ds, 0x94e6);
    memoryASet(ds, 0x94e7, al);
    al = memoryAGet(ds, 0x94e5);
    memoryASet(ds, 0x94e6, al);
    al = memoryAGet(ds, 0x1ba0);
    memoryASet(ds, 0x94e5, al);
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951a);
    if (!(al & 0x40))
        goto loc_12f02;
    if (bl != 0x02)
        goto loc_12f00;
    memoryASet(ds, 0x951a, 0x03);
    al = 0x02;
    sub_13840();
    memoryASet(ds, 0x951c, 0x02);
loc_12f00:
    goto loc_12f18;
loc_12f02:
    if (bl != 0x01)
        goto loc_12f0e;
    memoryASet(ds, 0x951a, 0x02);
    goto loc_12f18;
loc_12f0e:
    if (bl != 0x03)
        goto loc_12f18;
    memoryASet(ds, 0x951a, 0x00);
loc_12f18:
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951b);
    if (!(al & 0x20))
        goto loc_12f39;
    if (bl != 0x02)
        goto loc_12f37;
    memoryASet(ds, 0x951b, 0x03);
    al = 0x02;
    sub_13840();
    memoryASet(ds, 0x951c, 0x02);
loc_12f37:
    return;
loc_12f39:
    if (bl != 0x01)
        goto loc_12f45;
    memoryASet(ds, 0x951b, 0x02);
    return;
loc_12f45:
    if (bl != 0x03)
        return;
    memoryASet(ds, 0x951b, 0x00);
}
/* Assembly listing of 1000:2f50 sub_12f50()
                sub_12f50 PROC
1000:2f50	mov	al, byte ptr [si]
1000:2f52	test	al, 0x20
1000:2f54	jne	loc_12f5e
1000:2f56	mov	ah, byte ptr [0x951a]
1000:2f5a	mov	al, 0xf8
1000:2f5c	jmp	loc_12f64
        	loc_12f5e:
1000:2f5e	mov	ah, byte ptr [0x951b]
1000:2f62	mov	al, 8
        	loc_12f64:
1000:2f64	cmp	ah, 3
1000:2f67	je	loc_12f6e
1000:2f69	cmp	ah, 0
1000:2f6c	jne	loc_12f90
        	loc_12f6e:
1000:2f6e	mov	byte ptr [si], 0
1000:2f71	mov	si, 0x1ba1
        	loc_12f74:
1000:2f74	mov	al, byte ptr [si]
1000:2f76	test	al, 0x80
1000:2f78	jne	loc_12f8f
1000:2f7a	test	al, 1
1000:2f7c	je	loc_12f8a
1000:2f7e	mov	al, byte ptr [si + 0x12]
1000:2f81	cmp	al, 0xf
1000:2f83	jne	loc_12f8a
1000:2f85	push	si
1000:2f86	call	0x3059
1000:2f89	pop	si
        	loc_12f8a:
1000:2f8a	add	si, 0x17
1000:2f8d	jmp	loc_12f74
        	loc_12f8f:
1000:2f8f	ret	
        	loc_12f90:
1000:2f90	add	al, byte ptr [0x94e7]
1000:2f94	and	ax, 0x7f
1000:2f97	mov	bx, ax
1000:2f99	mov	al, byte ptr [bx + 0x1675]
1000:2f9d	cwde	
1000:2f9e	mov	cx, ax
1000:2fa0	sar	cx, 1
1000:2fa2	add	ax, cx
1000:2fa4	add	ax, 0x80
1000:2fa7	mov	word ptr [si + 5], ax
1000:2faa	mov	al, byte ptr [bx + 0x16f5]
1000:2fae	cwde	
1000:2faf	mov	cx, ax
1000:2fb1	sar	cx, 1
1000:2fb3	add	ax, cx
1000:2fb5	add	ax, 0x80
1000:2fb8	cmp	ax, 0
1000:2fbb	je	loc_12fd0
1000:2fbd	mov	bx, ax
1000:2fbf	shl	ax, 1
1000:2fc1	shl	ax, 1
1000:2fc3	add	ax, bx
1000:2fc5	shl	ax, 1
1000:2fc7	add	ax, 5
1000:2fca	mov	bl, 0xc
1000:2fcc	div	bl
1000:2fce	mov	ah, 0
        	loc_12fd0:
1000:2fd0	mov	bl, byte ptr [0x1ba0]
1000:2fd4	and	bx, 0x7f
1000:2fd7	mov	word ptr [si + 7], ax
1000:2fda	mov	al, byte ptr [bx + 0x1892]
1000:2fde	mov	byte ptr [si + 4], al
1000:2fe1	mov	bx, 0x1811
1000:2fe4	call	0x2121
1000:2fe7	ret	
                sub_12f50 ENDP
*/
void sub_12f50()
{
    // coverage: 0x3150-0x31e8 method sub_12f50
    al = memoryAGet(ds, si);
    if (al & 0x20)
        goto loc_12f5e;
    ah = memoryAGet(ds, 0x951a);
    al = 0xf8;
    goto loc_12f64;
loc_12f5e:
    ah = memoryAGet(ds, 0x951b);
    al = 0x08;
loc_12f64:
    if (ah == 0x03)
        goto loc_12f6e;
    if (ah != 0x00)
        goto loc_12f90;
loc_12f6e:
    memoryASet(ds, si, 0x00);
    si = 0x1ba1;
loc_12f74:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_12f8f;
    if (!(al & 0x01))
        goto loc_12f8a;
    al = memoryAGet(ds, si + 18);
    if (al != 0x0f)
        goto loc_12f8a;
    push(si);
    sub_13059();
    si = pop();
loc_12f8a:
    si += 0x0017;
    goto loc_12f74;
loc_12f8f:
    return;
loc_12f90:
    al += memoryAGet(ds, 0x94e7);
    ax &= 0x007f;
    bx = ax;
    al = memoryAGet(ds, bx + 5749);
    cbw();
    cx = ax;
    cx = sar(cx, 1);
    ax += cx;
    ax += 0x0080;
    memoryASet16(ds, si + 5, ax);
    al = memoryAGet(ds, bx + 5877);
    cbw();
    cx = ax;
    cx = sar(cx, 1);
    ax += cx;
    ax += 0x0080;
    if (ax == 0x0000)
        goto loc_12fd0;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_12fd0:
    bl = memoryAGet(ds, 0x1ba0);
    bx &= 0x007f;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, bx + 6290);
    memoryASet(ds, si + 4, al);
    bx = 0x1811;
    sub_12121();
}
/* Assembly listing of 1000:2fe8 sub_12fe8()
                sub_12fe8 PROC
1000:2fe8	mov	bx, word ptr [0x9525]
1000:2fec	shr	bx, 1
1000:2fee	shr	bx, 1
1000:2ff0	shr	bx, 1
1000:2ff2	and	bx, 0x1f
1000:2ff5	mov	al, byte ptr [bx + 0x1a0a]
1000:2ff9	mov	byte ptr [0x9549], al
1000:2ffc	mov	al, byte ptr [bx + 0x19ea]
1000:3000	mov	byte ptr [si + 4], al
1000:3003	mov	bx, 0x1929
1000:3006	call	0x2121
1000:3009	ret	
                sub_12fe8 ENDP
*/
void sub_12fe8()
{
    // coverage: 0x31e8-0x320a method sub_12fe8
    bx = memoryAGet16(ds, 0x9525);
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx &= 0x001f;
    al = memoryAGet(ds, bx + 6666);
    memoryASet(ds, 0x9549, al);
    al = memoryAGet(ds, bx + 6634);
    memoryASet(ds, si + 4, al);
    bx = 0x1929;
    sub_12121();
}
/* Assembly listing of 1000:300a sub_1300a()
                sub_1300a PROC
1000:300a	mov	ax, word ptr [0x9547]
1000:300d	sub	ax, word ptr [si + 0x13]
1000:3010	shr	ax, 1
1000:3012	shr	ax, 1
1000:3014	shr	ax, 1
1000:3016	cmp	ax, 0x2d
1000:3019	jbe	loc_1301f
1000:301b	mov	byte ptr [si], 0
1000:301e	ret	
        	loc_1301f:
1000:301f	push	ax
1000:3020	call	0x3130
1000:3023	pop	ax
1000:3024	shr	ax, 1
1000:3026	mov	byte ptr [si + 4], al
1000:3029	mov	bx, ax
1000:302b	mov	al, byte ptr [bx + 0x1a9a]
1000:302f	mov	byte ptr [si + 2], al
1000:3032	mov	bx, 0x1ac9
1000:3035	call	0x2121
1000:3038	mov	al, byte ptr [si + 2]
1000:303b	cmp	al, 2
1000:303d	je	loc_13040
1000:303f	ret	
        	loc_13040:
1000:3040	mov	bl, byte ptr [0x1b8e]
1000:3044	mov	bh, 0
1000:3046	mov	al, byte ptr [bx + 0x17f5]
1000:304a	cmp	al, byte ptr [si + 1]
1000:304d	je	loc_13050
1000:304f	ret	
        	loc_13050:
1000:3050	mov	al, 9
1000:3052	call	0x3840
1000:3055	call	0x3059
1000:3058	ret	
                sub_1300a ENDP
*/
void sub_1300a()
{
    // coverage: 0x320a-0x3259 method sub_1300a
    ax = memoryAGet16(ds, 0x9547);
    ax -= memoryAGet16(ds, si + 19);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    if (ax <= 0x002d)
        goto loc_1301f;
    memoryASet(ds, si, 0x00);
    return;
loc_1301f:
    push(ax);
    sub_13130();
    ax = pop();
    ax >>= 1;
    memoryASet(ds, si + 4, al);
    bx = ax;
    al = memoryAGet(ds, bx + 6810);
    memoryASet(ds, si + 2, al);
    bx = 0x1ac9;
    sub_12121();
    al = memoryAGet(ds, si + 2);
    if (al == 0x02)
        goto loc_13040;
    return;
loc_13040:
    bl = memoryAGet(ds, 0x1b8e);
    bh = 0x00;
    al = memoryAGet(ds, bx + 6133);
    if (al == memoryAGet(ds, si + 1))
        goto loc_13050;
    return;
loc_13050:
    al = 0x09;
    sub_13840();
    sub_13059();
}
/* Assembly listing of 1000:3059 sub_13059()
                sub_13059 PROC
1000:3059	mov	byte ptr [si], 0
1000:305c	mov	al, byte ptr [0x951d]
1000:305f	cmp	al, 0x40
1000:3061	jne	loc_1306a
1000:3063	add	word ptr [0x9540], 6
1000:3068	jmp	loc_13083
        	loc_1306a:
1000:306a	cmp	al, 0x80
1000:306c	jne	loc_13075
1000:306e	add	word ptr [0x953c], 4
1000:3073	jmp	loc_13083
        	loc_13075:
1000:3075	cmp	al, 0xc0
1000:3077	jne	loc_13080
1000:3079	add	word ptr [0x9544], 8
1000:307e	jmp	loc_13083
        	loc_13080:
1000:3080	call	0x268a
        	loc_13083:
1000:3083	ret	
                sub_13059 ENDP
*/
void sub_13059()
{
    // coverage: 0x3259-0x3284 method sub_13059
    memoryASet(ds, si, 0x00);
    al = memoryAGet(ds, 0x951d);
    if (al != 0x40)
        goto loc_1306a;
    memoryASet16(ds, 0x9540, memoryAGet16(ds, 0x9540) + 0x0006);
    return;
loc_1306a:
    if (al != 0x80)
        goto loc_13075;
    memoryASet16(ds, 0x953c, memoryAGet16(ds, 0x953c) + 0x0004);
    return;
loc_13075:
    if (al != 0xc0)
        goto loc_13080;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) + 0x0008);
    return;
loc_13080:
    sub_1268a();
}
/* Assembly listing of 1000:3084 sub_13084()
                sub_13084 PROC
1000:3084	sub	al, 5
1000:3086	jns	loc_1308d
1000:3088	mov	ax, 0
1000:308b	jmp	loc_1309c
        	loc_1308d:
1000:308d	cmp	al, 0x38
1000:308f	jbe	loc_13093
1000:3091	mov	al, 0x38
        	loc_13093:
1000:3093	shr	al, 1
1000:3095	mov	ah, 0
1000:3097	neg	ax
1000:3099	sub	ax, 3
        	loc_1309c:
1000:309c	ret	
                sub_13084 ENDP
*/
void sub_13084()
{
    // coverage: 0x3284-0x329d method sub_13084
    al -= 0x05;
    if ((char)al >= 0)
        goto loc_1308d;
    ax = 0x0000;
    return;
loc_1308d:
    if (al <= 0x38)
        goto loc_13093;
    al = 0x38;
loc_13093:
    al >>= 1;
    ah = 0x00;
    ax = -ax;
    ax -= 0x0003;
}
/* Assembly listing of 1000:309d sub_1309d()
                sub_1309d PROC
1000:309d	mov	bx, word ptr [0x952a]
1000:30a1	add	bx, 7
1000:30a4	shr	bx, 1
1000:30a6	shr	bx, 1
1000:30a8	shr	bx, 1
1000:30aa	add	bx, 2
1000:30ad	add	word ptr [0x9547], bx
1000:30b1	mov	ax, word ptr [0x950f]
1000:30b4	add	ax, bx
1000:30b6	cmp	ax, 0x2e8
1000:30b9	jbe	loc_130c4
1000:30bb	mov	ax, 0
1000:30be	mov	word ptr [0x953c], 0xffff
        	loc_130c4:
1000:30c4	mov	word ptr [0x950f], ax
1000:30c7	mov	ax, word ptr [0x9547]
1000:30ca	sub	ax, 0x380
1000:30cd	jns	loc_13124
1000:30cf	neg	ax
1000:30d1	cmp	ax, 0x100
1000:30d4	jae	loc_130ed
1000:30d6	mov	word ptr [0x9525], ax
1000:30d9	mov	al, byte ptr [0x9524]
1000:30dc	cmp	al, 0
1000:30de	jne	loc_130eb
1000:30e0	mov	si, 0x1912
1000:30e3	call	0xb58
1000:30e6	mov	byte ptr [0x9524], 1
        	loc_130eb:
1000:30eb	jmp	loc_13122
        	loc_130ed:
1000:30ed	mov	ax, word ptr [0x9547]
1000:30f0	shr	ax, 1
1000:30f2	shr	ax, 1
1000:30f4	shr	ax, 1
1000:30f6	shr	ax, 1
1000:30f8	shr	ax, 1
1000:30fa	shr	ax, 1
1000:30fc	cmp	al, byte ptr [0x9527]
1000:3100	je	loc_13122
1000:3102	mov	byte ptr [0x9527], al
1000:3105	mov	bl, al
1000:3107	mov	bh, 0
1000:3109	add	bx, word ptr [0x94e2]
1000:310d	mov	al, byte ptr [bx]
1000:310f	cmp	al, 0
1000:3111	je	loc_13122
1000:3113	mov	si, 0x1ab2
1000:3116	mov	byte ptr [si + 1], al
1000:3119	mov	ax, word ptr [0x9547]
1000:311c	mov	word ptr [si + 0x13], ax
1000:311f	call	0xb58
        	loc_13122:
1000:3122	jmp	loc_1312f
        	loc_13124:
1000:3124	mov	byte ptr [0x94ff], 0
1000:3129	mov	ax, word ptr [0x950c]
1000:312c	mov	word ptr [0x9528], ax
        	loc_1312f:
1000:312f	ret	
                sub_1309d ENDP
*/
void sub_1309d()
{
    // coverage: 0x329d-0x3330 method sub_1309d
    bx = memoryAGet16(ds, 0x952a);
    bx += 0x0007;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx += 0x0002;
    memoryASet16(ds, 0x9547, memoryAGet16(ds, 0x9547) + bx);
    ax = memoryAGet16(ds, 0x950f);
    ax += bx;
    if (ax <= 0x02e8)
        goto loc_130c4;
    ax = 0x0000;
    memoryASet16(ds, 0x953c, 0xffff);
loc_130c4:
    memoryASet16(ds, 0x950f, ax);
    ax = memoryAGet16(ds, 0x9547);
    ax -= 0x0380;
    if ((short)ax >= 0)
        goto loc_13124;
    ax = -ax;
    if (ax >= 0x0100)
        goto loc_130ed;
    memoryASet16(ds, 0x9525, ax);
    al = memoryAGet(ds, 0x9524);
    if (al != 0x00)
        goto loc_130eb;
    si = 0x1912;
    sub_10b58();
    memoryASet(ds, 0x9524, 0x01);
loc_130eb:
    goto loc_13122;
loc_130ed:
    ax = memoryAGet16(ds, 0x9547);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    if (al == memoryAGet(ds, 0x9527))
        goto loc_13122;
    memoryASet(ds, 0x9527, al);
    bl = al;
    bh = 0x00;
    bx += memoryAGet16(ds, 0x94e2);
    al = memoryAGet(ds, bx);
    if (al == 0x00)
        goto loc_13122;
    si = 0x1ab2;
    memoryASet(ds, si + 1, al);
    ax = memoryAGet16(ds, 0x9547);
    memoryASet16(ds, si + 19, ax);
    sub_10b58();
loc_13122:
    return;
loc_13124:
    memoryASet(ds, 0x94ff, 0x00);
    ax = memoryAGet16(ds, 0x950c);
    memoryASet16(ds, 0x9528, ax);
}
/* Assembly listing of 1000:3130 sub_13130()
                sub_13130 PROC
1000:3130	mov	bl, al
1000:3132	mov	bh, 0
1000:3134	mov	cl, byte ptr [bx + 0x1a6a]
1000:3138	mov	ch, 0
1000:313a	mov	al, byte ptr [si + 1]
1000:313d	cmp	al, 1
1000:313f	je	loc_1315e
1000:3141	cmp	al, 2
1000:3143	je	loc_13167
1000:3145	cmp	al, 3
1000:3147	je	loc_13170
1000:3149	cmp	al, 4
1000:314b	je	loc_13178
1000:314d	cmp	al, 5
1000:314f	je	loc_13181
1000:3151	cmp	al, 6
1000:3153	je	loc_13188
1000:3155	cmp	al, 7
1000:3157	je	loc_13191
1000:3159	cmp	al, 8
1000:315b	je	loc_1319b
1000:315d	ret	
        	loc_1315e:
1000:315e	neg	cx
1000:3160	add	cx, 0x6a
1000:3163	mov	word ptr [si + 7], cx
1000:3166	ret	
        	loc_13167:
1000:3167	push	cx
1000:3168	call	0x315e
1000:316b	pop	cx
1000:316c	call	0x3170
1000:316f	ret	
        	loc_13170:
1000:3170	add	cx, 0x80
1000:3174	mov	word ptr [si + 5], cx
1000:3177	ret	
        	loc_13178:
1000:3178	push	cx
1000:3179	call	0x3170
1000:317c	pop	cx
1000:317d	call	0x3181
1000:3180	ret	
        	loc_13181:
1000:3181	add	cx, 0x6a
1000:3184	mov	word ptr [si + 7], cx
1000:3187	ret	
        	loc_13188:
1000:3188	push	cx
1000:3189	call	0x3181
1000:318c	pop	cx
1000:318d	call	0x3191
1000:3190	ret	
        	loc_13191:
1000:3191	neg	cx
1000:3193	add	cx, 0x80
1000:3197	mov	word ptr [si + 5], cx
1000:319a	ret	
        	loc_1319b:
1000:319b	push	cx
1000:319c	call	0x3191
1000:319f	pop	cx
1000:31a0	call	0x315e
1000:31a3	ret	
                sub_13130 ENDP
*/
void sub_13130()
{
    // coverage: 0x3330-0x33a4 method sub_13130
    bl = al;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 6762);
    ch = 0x00;
    al = memoryAGet(ds, si + 1);
    if (al == 0x01)
        goto loc_1315e;
    if (al == 0x02)
        goto loc_13167;
    if (al == 0x03)
        goto loc_13170;
    if (al == 0x04)
        goto loc_13178;
    if (al == 0x05)
        goto loc_13181;
    if (al == 0x06)
        goto loc_13188;
    if (al == 0x07)
        goto loc_13191;
    if (al == 0x08)
        goto loc_1319b;
    return;
loc_1315e:
    cx = -cx;
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
    return;
loc_13167:
    push(cx);
    sub_1315e();
    cx = pop();
    sub_13170();
    return;
loc_13170:
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
    return;
loc_13178:
    push(cx);
    sub_13170();
    cx = pop();
    sub_13181();
    return;
loc_13181:
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
    return;
loc_13188:
    push(cx);
    sub_13181();
    cx = pop();
    sub_13191();
    return;
loc_13191:
    cx = -cx;
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
    return;
loc_1319b:
    push(cx);
    sub_13191();
    cx = pop();
    sub_1315e();
}
/* Assembly listing of 1000:315e sub_1315e()
                sub_1315e PROC
1000:315e	neg	cx
1000:3160	add	cx, 0x6a
1000:3163	mov	word ptr [si + 7], cx
1000:3166	ret	
                sub_1315e ENDP
*/
void sub_1315e()
{
    // coverage: 0x335e-0x3367 method sub_1315e
    cx = -cx;
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
}
/* Assembly listing of 1000:3170 sub_13170()
                sub_13170 PROC
1000:3170	add	cx, 0x80
1000:3174	mov	word ptr [si + 5], cx
1000:3177	ret	
                sub_13170 ENDP
*/
void sub_13170()
{
    // coverage: 0x3370-0x3378 method sub_13170
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
}
/* Assembly listing of 1000:3181 sub_13181()
                sub_13181 PROC
1000:3181	add	cx, 0x6a
1000:3184	mov	word ptr [si + 7], cx
1000:3187	ret	
                sub_13181 ENDP
*/
void sub_13181()
{
    // coverage: 0x3381-0x3388 method sub_13181
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
}
/* Assembly listing of 1000:3191 sub_13191()
                sub_13191 PROC
1000:3191	neg	cx
1000:3193	add	cx, 0x80
1000:3197	mov	word ptr [si + 5], cx
1000:319a	ret	
                sub_13191 ENDP
*/
void sub_13191()
{
    // coverage: 0x3391-0x339b method sub_13191
    cx = -cx;
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
}
/* Assembly listing of 1000:31a4 sub_131a4()
                sub_131a4 PROC
1000:31a4	mov	ax, word ptr [0x94f8]
1000:31a7	mov	es, ax
1000:31a9	mov	di, 0x144
1000:31ac	mov	bx, word ptr [0x94f4]
1000:31b0	mov	si, 0x340
1000:31b3	call	0x31e7
1000:31b6	not	ax
1000:31b8	and	ax, 0xf
1000:31bb	mov	ah, al
1000:31bd	mov	al, 1
1000:31bf	mov	dx, 0x3ce
1000:31c2	out	dx, ax
1000:31c3	call	0x3209
1000:31c6	mov	ah, al
1000:31c8	mov	al, 0
1000:31ca	out	dx, ax
1000:31cb	push	ds
1000:31cc	mov	ds, bx
1000:31ce	cld	
1000:31cf	mov	cx, 0xa0
        	loc_131d2:
1000:31d2	push	cx
1000:31d3	mov	cx, 0x20
1000:31d6	rep movsb	byte ptr es:[di], byte ptr [si]
1000:31d8	add	di, 8
1000:31db	pop	cx
1000:31dc	loop	loc_131d2
1000:31de	pop	ds
1000:31df	mov	ax, 0
1000:31e2	out	dx, ax
1000:31e3	inc	al
1000:31e5	out	dx, ax
1000:31e6	ret	
                sub_131a4 ENDP
*/
void sub_131a4()
{
    // coverage: 0x33a4-0x33e7 method sub_131a4
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0144;
    bx = memoryAGet16(ds, 0x94f4);
    si = 0x0340;
    sub_131e7();
    ax = ~ax;
    ax &= 0x000f;
    ah = al;
    al = 0x01;
    dx = 0x03ce;
    out(dx, ax);
    sub_13209();
    ah = al;
    al = 0x00;
    out(dx, ax);
    push(ds);
    ds = bx;
    flags.direction = false;
    cx = 0x00a0;
loc_131d2:
    push(cx);
    cx = 0x0020;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    di += 0x0008;
    cx = pop();
    if (--cx)
        goto loc_131d2;
    ds = pop();
    ax = 0x0000;
    out(dx, ax);
    al++;
    out(dx, ax);
}
/* Assembly listing of 1000:31e7 sub_131e7()
                sub_131e7 PROC
1000:31e7	mov	al, byte ptr [0x951d]
1000:31ea	cmp	al, 0x40
1000:31ec	jne	loc_131f3
1000:31ee	mov	ax, 2
1000:31f1	jmp	loc_13208
        	loc_131f3:
1000:31f3	cmp	al, 0x80
1000:31f5	jne	loc_131fc
1000:31f7	mov	ax, 4
1000:31fa	jmp	loc_13208
        	loc_131fc:
1000:31fc	cmp	al, 0xc0
1000:31fe	jne	loc_13205
1000:3200	mov	ax, 1
1000:3203	jmp	loc_13208
        	loc_13205:
1000:3205	mov	ax, 3
        	loc_13208:
1000:3208	ret	
                sub_131e7 ENDP
*/
void sub_131e7()
{
    // coverage: 0x33e7-0x3409 method sub_131e7
    al = memoryAGet(ds, 0x951d);
    if (al != 0x40)
        goto loc_131f3;
    ax = 0x0002;
    return;
loc_131f3:
    if (al != 0x80)
        goto loc_131fc;
    ax = 0x0004;
    return;
loc_131fc:
    if (al != 0xc0)
        goto loc_13205;
    ax = 0x0001;
    return;
loc_13205:
    ax = 0x0003;
}
/* Assembly listing of 1000:3209 sub_13209()
                sub_13209 PROC
1000:3209	mov	al, byte ptr [0x951c]
1000:320c	cmp	al, 0
1000:320e	jne	loc_13215
1000:3210	mov	ax, 0
1000:3213	jmp	loc_1322b
        	loc_13215:
1000:3215	cmp	al, 1
1000:3217	jne	loc_13223
1000:3219	mov	ax, 7
1000:321c	mov	byte ptr [0x951c], 0
1000:3221	jmp	loc_1322b
        	loc_13223:
1000:3223	mov	ax, 0xf
1000:3226	mov	byte ptr [0x951c], 1
        	loc_1322b:
1000:322b	ret	
                sub_13209 ENDP
*/
void sub_13209()
{
    // coverage: 0x3409-0x342c method sub_13209
    al = memoryAGet(ds, 0x951c);
    if (al != 0x00)
        goto loc_13215;
    ax = 0x0000;
    return;
loc_13215:
    if (al != 0x01)
        goto loc_13223;
    ax = 0x0007;
    memoryASet(ds, 0x951c, 0x00);
    return;
loc_13223:
    ax = 0x000f;
    memoryASet(ds, 0x951c, 0x01);
}
/* Assembly listing of 1000:3291 sub_13291()
                sub_13291 PROC
1000:3291	push	bp
1000:3292	mov	bp, sp
1000:3294	mov	ax, word ptr [bp + 4]
1000:3297	mov	es, ax
1000:3299	mov	di, 0x144
1000:329c	mov	bx, word ptr [bp + 6]
1000:329f	mov	si, 0x144
1000:32a2	mov	dx, 0x3ce
1000:32a5	mov	ax, 0x105
1000:32a8	out	dx, ax
1000:32a9	push	ds
1000:32aa	mov	ds, bx
1000:32ac	cld	
1000:32ad	mov	cx, 0xa0
        	loc_132b0:
1000:32b0	push	cx
1000:32b1	mov	cx, 0x20
1000:32b4	rep movsb	byte ptr es:[di], byte ptr [si]
1000:32b6	add	si, 8
1000:32b9	add	di, 8
1000:32bc	pop	cx
1000:32bd	loop	loc_132b0
1000:32bf	pop	ds
1000:32c0	mov	ax, 5
1000:32c3	out	dx, ax
1000:32c4	pop	bp
1000:32c5	ret	4
                sub_13291 ENDP
*/
void sub_13291()
{
    // coverage: 0x3491-0x34c8 method sub_13291
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4 - 2);
    es = ax;
    di = 0x0144;
    bx = memoryAGet16(ss, bp + 6 - 2);
    si = 0x0144;
    dx = 0x03ce;
    ax = 0x0105;
    out(dx, ax);
    push(ds);
    ds = bx;
    flags.direction = false;
    cx = 0x00a0;
loc_132b0:
    push(cx);
    cx = 0x0020;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    si += 0x0008;
    di += 0x0008;
    cx = pop();
    if (--cx)
        goto loc_132b0;
    ds = pop();
    ax = 0x0005;
    out(dx, ax);
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:32fe sub_132fe()
                sub_132fe PROC
1000:32fe	mov	dx, 0x3ce
1000:3301	mov	ax, 0x105
1000:3304	out	dx, ax
1000:3305	mov	ax, word ptr [0x94f8]
1000:3308	mov	es, ax
1000:330a	mov	di, 0x144
1000:330d	mov	ax, word ptr [0x9528]
1000:3310	shl	ax, 1
1000:3312	shl	ax, 1
1000:3314	shl	ax, 1
1000:3316	shl	ax, 1
1000:3318	shl	ax, 1
1000:331a	mov	si, ax
1000:331c	push	ds
1000:331d	mov	ax, 0xa800
1000:3320	mov	ds, ax
1000:3322	cld	
1000:3323	mov	cx, 0xa0
        	loc_13326:
1000:3326	push	cx
1000:3327	mov	cx, 0x20
1000:332a	rep movsb	byte ptr es:[di], byte ptr [si]
1000:332c	and	si, 0x7fff
1000:3330	add	di, 8
1000:3333	pop	cx
1000:3334	loop	loc_13326
1000:3336	pop	ds
1000:3337	mov	ax, 5
1000:333a	out	dx, ax
1000:333b	ret	
                sub_132fe ENDP
*/
void sub_132fe()
{
    // coverage: 0x34fe-0x353c method sub_132fe
    dx = 0x03ce;
    ax = 0x0105;
    out(dx, ax);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0144;
    ax = memoryAGet16(ds, 0x9528);
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    si = ax;
    push(ds);
    ax = 0xa800;
    ds = ax;
    flags.direction = false;
    cx = 0x00a0;
loc_13326:
    push(cx);
    cx = 0x0020;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    si &= 0x7fff;
    di += 0x0008;
    cx = pop();
    if (--cx)
        goto loc_13326;
    ds = pop();
    ax = 0x0005;
    out(dx, ax);
}
/* Assembly listing of 1000:333c sub_1333c()
                sub_1333c PROC
1000:333c	mov	ax, 0xd
1000:333f	int	0x10
1000:3341	mov	ax, 0xa000
1000:3344	mov	word ptr [0x94fa], ax
1000:3347	add	ax, 0x200
1000:334a	mov	word ptr [0x94f8], ax
1000:334d	mov	ax, 0
1000:3350	call	0x33b3
1000:3353	mov	ax, word ptr [0x94f8]
1000:3356	mov	bx, word ptr [0x94fa]
1000:335a	mov	word ptr [0x94f8], bx
1000:335e	mov	word ptr [0x94fa], ax
1000:3361	call	0x33d7
1000:3364	mov	bx, word ptr [0x94fa]
1000:3368	shl	bx, 1
1000:336a	shl	bx, 1
1000:336c	shl	bx, 1
1000:336e	shl	bx, 1
1000:3370	cli	
1000:3371	mov	dx, 0x3d4
1000:3374	mov	ah, bh
1000:3376	mov	al, 0xc
1000:3378	out	dx, ax
1000:3379	mov	ah, bl
1000:337b	inc	al
1000:337d	out	dx, ax
1000:337e	sti	
1000:337f	call	0x33d7
1000:3382	ret	
                sub_1333c ENDP
*/
void sub_1333c()
{
    // coverage: 0x353c-0x3583 method sub_1333c
    ax = 0x000d;
    interrupt(0x10);
    ax = 0xa000;
    memoryASet16(ds, 0x94fa, ax);
    ax += 0x0200;
    memoryASet16(ds, 0x94f8, ax);
    ax = 0x0000;
    sub_133b3();
    ax = memoryAGet16(ds, 0x94f8);
    bx = memoryAGet16(ds, 0x94fa);
    memoryASet16(ds, 0x94f8, bx);
    memoryASet16(ds, 0x94fa, ax);
    sub_133d7();
    bx = memoryAGet16(ds, 0x94fa);
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    flags.interrupts = false;
    dx = 0x03d4;
    ah = bh;
    al = 0x0c;
    out(dx, ax);
    ah = bl;
    al++;
    out(dx, ax);
    flags.interrupts = true;
    sub_133d7();
}
/* Assembly listing of 1000:3383 sub_13383()
                sub_13383 PROC
1000:3383	mov	ax, word ptr [0x94f8]
1000:3386	mov	bx, word ptr [0x94fa]
1000:338a	mov	word ptr [0x94f8], bx
1000:338e	mov	word ptr [0x94fa], ax
1000:3391	mov	bx, word ptr [0x94fa]
1000:3395	shl	bx, 1
1000:3397	shl	bx, 1
1000:3399	shl	bx, 1
1000:339b	shl	bx, 1
1000:339d	cli	
1000:339e	mov	dx, 0x3d4
1000:33a1	mov	ah, bh
1000:33a3	mov	al, 0xc
1000:33a5	out	dx, ax
1000:33a6	sti	
1000:33a7	mov	dx, 0x3da
        	loc_133aa:
1000:33aa	in	al, dx
1000:33ab	and	al, 8
1000:33ad	jne	loc_133aa
1000:33af	call	0x33d7
1000:33b2	ret	
                sub_13383 ENDP
*/
void sub_13383()
{
    // coverage: 0x3583-0x35b3 method sub_13383
    ax = memoryAGet16(ds, 0x94f8);
    bx = memoryAGet16(ds, 0x94fa);
    memoryASet16(ds, 0x94f8, bx);
    memoryASet16(ds, 0x94fa, ax);
    bx = memoryAGet16(ds, 0x94fa);
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    flags.interrupts = false;
    dx = 0x03d4;
    ah = bh;
    al = 0x0c;
    out(dx, ax);
    flags.interrupts = true;
    dx = 0x03da;
loc_133aa:
    in(al, dx);
    al &= 0x08;
    if (al != 0)
        goto loc_133aa;
    sub_133d7();
}
/* Assembly listing of 1000:33b3 sub_133b3()
                sub_133b3 PROC
1000:33b3	push	ax
1000:33b4	mov	ax, word ptr [0x94f8]
1000:33b7	mov	es, ax
1000:33b9	mov	di, 0
1000:33bc	mov	dx, 0x3ce
1000:33bf	pop	ax
1000:33c0	mov	ah, al
1000:33c2	mov	al, 0
1000:33c4	out	dx, ax
1000:33c5	mov	ax, 0xf01
1000:33c8	out	dx, ax
1000:33c9	cld	
1000:33ca	mov	cx, 0xfa0
1000:33cd	rep stosw	word ptr es:[di], ax
1000:33cf	mov	ax, 0
1000:33d2	out	dx, ax
1000:33d3	inc	al
1000:33d5	out	dx, ax
1000:33d6	ret	
                sub_133b3 ENDP
*/
void sub_133b3()
{
    // coverage: 0x35b3-0x35d7 method sub_133b3
    push(ax);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0000;
    dx = 0x03ce;
    ax = pop();
    ah = al;
    al = 0x00;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    flags.direction = false;
    cx = 0x0fa0;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x0000;
    out(dx, ax);
    al++;
    out(dx, ax);
}
/* Assembly listing of 1000:33d7 sub_133d7()
                sub_133d7 PROC
1000:33d7	mov	dx, 0x3da
        	loc_133da:
1000:33da	in	al, dx
1000:33db	and	al, 8
1000:33dd	je	loc_133da
        	loc_133df:
1000:33df	in	al, dx
1000:33e0	and	al, 8
1000:33e2	jne	loc_133df
1000:33e4	ret	
                sub_133d7 ENDP
*/
void sub_133d7()
{
    // coverage: 0x35d7-0x35e5 method sub_133d7
    dx = 0x03da;
loc_133da:
    in(al, dx);
    al &= 0x08;
    if (al == 0)
        goto loc_133da;
loc_133df:
    in(al, dx);
    al &= 0x08;
    if (al != 0)
        goto loc_133df;
}
/* Assembly listing of 1000:33e5 sub_133e5()
                sub_133e5 PROC
1000:33e5	mov	ax, word ptr [0x94f8]
1000:33e8	mov	es, ax
1000:33ea	mov	di, 0
1000:33ed	mov	dx, 0x3ce
1000:33f0	mov	ax, 0x805
1000:33f3	out	dx, ax
1000:33f4	mov	ax, 7
1000:33f7	out	dx, ax
1000:33f8	mov	dl, 0xc4
1000:33fa	mov	ax, 0x802
1000:33fd	push	ds
1000:33fe	mov	ds, bx
        	loc_13400:
1000:3400	out	dx, ax
1000:3401	push	ax
1000:3402	push	di
1000:3403	mov	cx, 0x1f40
        	loc_13406:
1000:3406	lodsb	al, byte ptr [si]
1000:3407	and	byte ptr es:[di], al
1000:340a	inc	di
1000:340b	loop	loc_13406
1000:340d	pop	di
1000:340e	pop	ax
1000:340f	shr	ah, 1
1000:3411	jne	loc_13400
1000:3413	pop	ds
1000:3414	mov	ax, 0xf02
1000:3417	out	dx, ax
1000:3418	mov	dl, 0xce
1000:341a	mov	ax, 5
1000:341d	out	dx, ax
1000:341e	mov	ax, 0xf07
1000:3421	out	dx, ax
1000:3422	ret	
                sub_133e5 ENDP
*/
void sub_133e5()
{
    // coverage: 0x35e5-0x3623 method sub_133e5
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0000;
    dx = 0x03ce;
    ax = 0x0805;
    out(dx, ax);
    ax = 0x0007;
    out(dx, ax);
    dl = 0xc4;
    ax = 0x0802;
    push(ds);
    ds = bx;
loc_13400:
    out(dx, ax);
    push(ax);
    push(di);
    cx = 0x1f40;
loc_13406:
    lodsb<MemAuto, DirAuto>();
    memoryASet(es, di, memoryAGet(es, di) & al);
    di++;
    if (--cx)
        goto loc_13406;
    di = pop();
    ax = pop();
    ah >>= 1;
    if (ah != 0)
        goto loc_13400;
    ds = pop();
    ax = 0x0f02;
    out(dx, ax);
    dl = 0xce;
    ax = 0x0005;
    out(dx, ax);
    ax = 0x0f07;
    out(dx, ax);
}
/* Assembly listing of 1000:3423 sub_13423()
                sub_13423 PROC
1000:3423	mov	ax, 0
1000:3426	call	0x33b3
1000:3429	call	0x3439
1000:342c	call	0x3383
1000:342f	mov	ax, 0
1000:3432	call	0x33b3
1000:3435	call	0x3439
1000:3438	ret	
                sub_13423 ENDP
*/
void sub_13423()
{
    // coverage: 0x3623-0x3639 method sub_13423
    ax = 0x0000;
    sub_133b3();
    sub_13439();
    sub_13383();
    ax = 0x0000;
    sub_133b3();
    sub_13439();
}
/* Assembly listing of 1000:3439 sub_13439()
                sub_13439 PROC
1000:3439	mov	ax, word ptr [0x94f8]
1000:343c	mov	es, ax
1000:343e	mov	di, 0x11c
1000:3441	mov	ax, 0xffff
1000:3444	mov	cx, 0x10
1000:3447	rep stosw	word ptr es:[di], ax
1000:3449	mov	di, 0x1a44
1000:344c	mov	cx, 0x10
1000:344f	rep stosw	word ptr es:[di], ax
1000:3451	mov	di, 0x11b
1000:3454	mov	al, 1
1000:3456	mov	cx, 0xa2
        	loc_13459:
1000:3459	mov	byte ptr es:[di], al
1000:345c	add	di, 0x28
1000:345f	loop	loc_13459
1000:3461	mov	di, 0x13c
1000:3464	mov	al, 0x80
1000:3466	mov	cx, 0xa2
        	loc_13469:
1000:3469	mov	byte ptr es:[di], al
1000:346c	add	di, 0x28
1000:346f	loop	loc_13469
1000:3471	ret	
                sub_13439 ENDP
*/
void sub_13439()
{
    // coverage: 0x3639-0x3672 method sub_13439
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x011c;
    ax = 0xffff;
    cx = 0x0010;
    rep_stosw<MemAuto, DirAuto>();
    di = 0x1a44;
    cx = 0x0010;
    rep_stosw<MemAuto, DirAuto>();
    di = 0x011b;
    al = 0x01;
    cx = 0x00a2;
loc_13459:
    memoryASet(es, di, al);
    di += 0x0028;
    if (--cx)
        goto loc_13459;
    di = 0x013c;
    al = 0x80;
    cx = 0x00a2;
loc_13469:
    memoryASet(es, di, al);
    di += 0x0028;
    if (--cx)
        goto loc_13469;
}
/* Assembly listing of 1000:3472 sub_13472()
                sub_13472 PROC
1000:3472	mov	si, 0
1000:3475	mov	bx, word ptr [0x94f2]
1000:3479	call	0x33e5
1000:347c	call	0x3383
1000:347f	mov	si, 0
1000:3482	mov	bx, word ptr [0x94f2]
1000:3486	call	0x33e5
1000:3489	mov	ax, word ptr [0x94f8]
1000:348c	push	ax
1000:348d	mov	ax, 0xa000
1000:3490	add	ax, 0x400
1000:3493	push	ax
1000:3494	call	0x3291
1000:3497	ret	
                sub_13472 ENDP
*/
void sub_13472()
{
    // coverage: 0x3672-0x3698 method sub_13472
    si = 0x0000;
    bx = memoryAGet16(ds, 0x94f2);
    sub_133e5();
    sub_13383();
    si = 0x0000;
    bx = memoryAGet16(ds, 0x94f2);
    sub_133e5();
    ax = memoryAGet16(ds, 0x94f8);
    push(ax);
    ax = 0xa000;
    ax += 0x0400;
    push(ax);
    sub_13291();
}
/* Assembly listing of 1000:3498 sub_13498()
                sub_13498 PROC
1000:3498	mov	ax, 0xa000
1000:349b	add	ax, 0x400
1000:349e	push	ax
1000:349f	mov	ax, word ptr [0x94f8]
1000:34a2	push	ax
1000:34a3	call	0x3291
1000:34a6	ret	
                sub_13498 ENDP
*/
void sub_13498()
{
    // coverage: 0x3698-0x36a7 method sub_13498
    ax = 0xa000;
    ax += 0x0400;
    push(ax);
    ax = memoryAGet16(ds, 0x94f8);
    push(ax);
    sub_13291();
}
/* Assembly listing of 1000:34a8 sub_134a8()
                sub_134a8 PROC
1000:34a8	mov	di, 0
1000:34ab	mov	ax, word ptr [0x94f4]
1000:34ae	mov	es, ax
1000:34b0	mov	ax, 0
1000:34b3	mov	cx, 0x1000
1000:34b6	cld	
1000:34b7	rep stosw	word ptr es:[di], ax
1000:34b9	mov	ax, 0x4f
1000:34bc	push	ax
1000:34bd	mov	ax, 0xff
1000:34c0	push	ax
1000:34c1	mov	ax, 0xb0
1000:34c4	push	ax
1000:34c5	mov	ax, 0
1000:34c8	push	ax
1000:34c9	call	0x36d4
1000:34cc	mov	ax, 0x4f
1000:34cf	push	ax
1000:34d0	mov	ax, 0
1000:34d3	push	ax
1000:34d4	mov	ax, 0xb0
1000:34d7	push	ax
1000:34d8	mov	ax, 0xff
1000:34db	push	ax
1000:34dc	call	0x36d4
1000:34df	mov	ax, 0
1000:34e2	push	ax
1000:34e3	mov	ax, 0x4f
1000:34e6	push	ax
1000:34e7	mov	ax, 0xff
1000:34ea	push	ax
1000:34eb	mov	ax, 0xb0
1000:34ee	push	ax
1000:34ef	call	0x36d4
1000:34f2	mov	ax, 0
1000:34f5	push	ax
1000:34f6	mov	ax, 0xb0
1000:34f9	push	ax
1000:34fa	mov	ax, 0xff
1000:34fd	push	ax
1000:34fe	mov	ax, 0x4f
1000:3501	push	ax
1000:3502	call	0x36d4
1000:3505	mov	ax, word ptr [0x9547]
1000:3508	and	ax, 0x3f
1000:350b	mov	word ptr [0x954e], ax
1000:350e	mov	bx, ax
1000:3510	add	ax, 0x40
1000:3513	push	ax
1000:3514	mov	al, byte ptr [bx + 0x1fdc]
1000:3518	mov	ah, 0
1000:351a	push	ax
1000:351b	call	0x35bc
1000:351e	mov	ax, word ptr [0x954e]
1000:3521	cmp	ax, 0xc
1000:3524	jbe	loc_13527
1000:3526	ret	
        	loc_13527:
1000:3527	mov	bx, word ptr [0x954e]
1000:352b	mov	al, byte ptr [bx + 0x201c]
1000:352f	mov	ah, 0
1000:3531	add	ax, 0x80
1000:3534	push	ax
1000:3535	mov	ax, 0
1000:3538	push	ax
1000:3539	mov	ax, 0xff
1000:353c	push	ax
1000:353d	mov	al, byte ptr [bx + 0x2029]
1000:3541	mov	ah, 0
1000:3543	neg	ax
1000:3545	add	ax, 0x7f
1000:3548	push	ax
1000:3549	call	0x36d4
1000:354c	mov	bx, word ptr [0x954e]
1000:3550	mov	al, byte ptr [bx + 0x201c]
1000:3554	mov	ah, 0
1000:3556	neg	ax
1000:3558	add	ax, 0x7f
1000:355b	push	ax
1000:355c	mov	ax, 0
1000:355f	push	ax
1000:3560	mov	ax, 0
1000:3563	push	ax
1000:3564	mov	al, byte ptr [bx + 0x2029]
1000:3568	mov	ah, 0
1000:356a	neg	ax
1000:356c	add	ax, 0x7f
1000:356f	push	ax
1000:3570	call	0x36d4
1000:3573	mov	bx, word ptr [0x954e]
1000:3577	mov	al, byte ptr [bx + 0x201c]
1000:357b	mov	ah, 0
1000:357d	add	ax, 0x80
1000:3580	push	ax
1000:3581	mov	ax, 0xff
1000:3584	push	ax
1000:3585	mov	ax, 0xff
1000:3588	push	ax
1000:3589	mov	al, byte ptr [bx + 0x2029]
1000:358d	mov	ah, 0
1000:358f	add	ax, 0x80
1000:3592	push	ax
1000:3593	call	0x36d4
1000:3596	mov	bx, word ptr [0x954e]
1000:359a	mov	al, byte ptr [bx + 0x201c]
1000:359e	mov	ah, 0
1000:35a0	neg	ax
1000:35a2	add	ax, 0x7f
1000:35a5	push	ax
1000:35a6	mov	ax, 0xff
1000:35a9	push	ax
1000:35aa	mov	ax, 0
1000:35ad	push	ax
1000:35ae	mov	al, byte ptr [bx + 0x2029]
1000:35b2	mov	ah, 0
1000:35b4	add	ax, 0x80
1000:35b7	push	ax
1000:35b8	call	0x36d4
1000:35bb	ret	
                sub_134a8 ENDP
*/
void sub_134a8()
{
    // coverage: 0x36a8-0x37bc method sub_134a8
    di = 0x0000;
    ax = memoryAGet16(ds, 0x94f4);
    es = ax;
    ax = 0x0000;
    cx = 0x1000;
    flags.direction = false;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x004f;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x00b0;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_136d4();
    ax = 0x004f;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x00b0;
    push(ax);
    ax = 0x00ff;
    push(ax);
    sub_136d4();
    ax = 0x0000;
    push(ax);
    ax = 0x004f;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x00b0;
    push(ax);
    sub_136d4();
    ax = 0x0000;
    push(ax);
    ax = 0x00b0;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x004f;
    push(ax);
    sub_136d4();
    ax = memoryAGet16(ds, 0x9547);
    ax &= 0x003f;
    memoryASet16(ds, 0x954e, ax);
    bx = ax;
    ax += 0x0040;
    push(ax);
    al = memoryAGet(ds, bx + 8156);
    ah = 0x00;
    push(ax);
    sub_135bc();
    ax = memoryAGet16(ds, 0x954e);
    if (ax <= 0x000c)
        goto loc_13527;
    return;
loc_13527:
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x00ff;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    sub_136d4();
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0000;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    sub_136d4();
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x00ff;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    sub_136d4();
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x0000;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    sub_136d4();
}
/* Assembly listing of 1000:35bc sub_135bc()
                sub_135bc PROC
1000:35bc	push	bp
1000:35bd	mov	bp, sp
        	loc_135bf:
1000:35bf	mov	ax, 0x7f
1000:35c2	sub	ax, word ptr [bp + 4]
1000:35c5	push	ax
1000:35c6	mov	ax, 0x7f
1000:35c9	sub	ax, word ptr [bp + 6]
1000:35cc	push	ax
1000:35cd	mov	ax, 0x80
1000:35d0	add	ax, word ptr [bp + 4]
1000:35d3	push	ax
1000:35d4	mov	ax, 0x7f
1000:35d7	sub	ax, word ptr [bp + 6]
1000:35da	push	ax
1000:35db	call	0x36d4
1000:35de	mov	ax, 0x80
1000:35e1	add	ax, word ptr [bp + 4]
1000:35e4	push	ax
1000:35e5	mov	ax, 0x7f
1000:35e8	sub	ax, word ptr [bp + 6]
1000:35eb	push	ax
1000:35ec	mov	ax, 0x80
1000:35ef	add	ax, word ptr [bp + 6]
1000:35f2	push	ax
1000:35f3	mov	ax, 0x7f
1000:35f6	sub	ax, word ptr [bp + 4]
1000:35f9	push	ax
1000:35fa	call	0x36d4
1000:35fd	mov	ax, 0x80
1000:3600	add	ax, word ptr [bp + 6]
1000:3603	push	ax
1000:3604	mov	ax, 0x7f
1000:3607	sub	ax, word ptr [bp + 4]
1000:360a	push	ax
1000:360b	mov	ax, 0x80
1000:360e	add	ax, word ptr [bp + 6]
1000:3611	push	ax
1000:3612	mov	ax, 0x80
1000:3615	add	ax, word ptr [bp + 4]
1000:3618	push	ax
1000:3619	call	0x36d4
1000:361c	mov	ax, 0x80
1000:361f	add	ax, word ptr [bp + 4]
1000:3622	push	ax
1000:3623	mov	ax, 0x80
1000:3626	add	ax, word ptr [bp + 6]
1000:3629	push	ax
1000:362a	mov	ax, 0x80
1000:362d	add	ax, word ptr [bp + 6]
1000:3630	push	ax
1000:3631	mov	ax, 0x80
1000:3634	add	ax, word ptr [bp + 4]
1000:3637	push	ax
1000:3638	call	0x36d4
1000:363b	mov	ax, 0x7f
1000:363e	sub	ax, word ptr [bp + 4]
1000:3641	push	ax
1000:3642	mov	ax, 0x80
1000:3645	add	ax, word ptr [bp + 6]
1000:3648	push	ax
1000:3649	mov	ax, 0x80
1000:364c	add	ax, word ptr [bp + 4]
1000:364f	push	ax
1000:3650	mov	ax, 0x80
1000:3653	add	ax, word ptr [bp + 6]
1000:3656	push	ax
1000:3657	call	0x36d4
1000:365a	mov	ax, 0x7f
1000:365d	sub	ax, word ptr [bp + 6]
1000:3660	push	ax
1000:3661	mov	ax, 0x80
1000:3664	add	ax, word ptr [bp + 4]
1000:3667	push	ax
1000:3668	mov	ax, 0x7f
1000:366b	sub	ax, word ptr [bp + 4]
1000:366e	push	ax
1000:366f	mov	ax, 0x80
1000:3672	add	ax, word ptr [bp + 6]
1000:3675	push	ax
1000:3676	call	0x36d4
1000:3679	mov	ax, 0x7f
1000:367c	sub	ax, word ptr [bp + 6]
1000:367f	push	ax
1000:3680	mov	ax, 0x7f
1000:3683	sub	ax, word ptr [bp + 4]
1000:3686	push	ax
1000:3687	mov	ax, 0x7f
1000:368a	sub	ax, word ptr [bp + 6]
1000:368d	push	ax
1000:368e	mov	ax, 0x80
1000:3691	add	ax, word ptr [bp + 4]
1000:3694	push	ax
1000:3695	call	0x36d4
1000:3698	mov	ax, 0x7f
1000:369b	sub	ax, word ptr [bp + 6]
1000:369e	push	ax
1000:369f	mov	ax, 0x7f
1000:36a2	sub	ax, word ptr [bp + 4]
1000:36a5	push	ax
1000:36a6	mov	ax, 0x7f
1000:36a9	sub	ax, word ptr [bp + 4]
1000:36ac	push	ax
1000:36ad	mov	ax, 0x7f
1000:36b0	sub	ax, word ptr [bp + 6]
1000:36b3	push	ax
1000:36b4	call	0x36d4
1000:36b7	mov	ax, word ptr [bp + 6]
1000:36ba	shr	ax, 1
1000:36bc	cmp	al, byte ptr [0x9549]
1000:36c0	jbe	loc_136d0
1000:36c2	mov	word ptr [bp + 6], ax
1000:36c5	mov	ax, word ptr [bp + 4]
1000:36c8	shr	ax, 1
1000:36ca	mov	word ptr [bp + 4], ax
1000:36cd	jmp	loc_135bf
        	loc_136d0:
1000:36d0	pop	bp
1000:36d1	ret	4
                sub_135bc ENDP
*/
void sub_135bc()
{
    // coverage: 0x37bc-0x38d4 method sub_135bc
    push(bp);
    bp = sp;
loc_135bf:
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax >>= 1;
    if (al <= memoryAGet(ds, 0x9549))
        goto loc_136d0;
    memoryASet16(ss, bp + 6 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax >>= 1;
    memoryASet16(ss, bp + 4 - 2, ax);
    goto loc_135bf;
loc_136d0:
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:36d4 sub_136d4()
                sub_136d4 PROC
1000:36d4	push	bp
1000:36d5	mov	bp, sp
1000:36d7	sub	sp, 0xa
1000:36da	mov	ax, word ptr [0x94f4]
1000:36dd	mov	es, ax
1000:36df	mov	ax, word ptr [bp + 8]
1000:36e2	cmp	ax, 0
1000:36e5	je	loc_136fa
1000:36e7	mov	bx, ax
1000:36e9	shl	ax, 1
1000:36eb	shl	ax, 1
1000:36ed	add	ax, bx
1000:36ef	shl	ax, 1
1000:36f1	add	ax, 5
1000:36f4	mov	bl, 0xc
1000:36f6	div	bl
1000:36f8	mov	ah, 0
        	loc_136fa:
1000:36fa	mov	word ptr [bp + 8], ax
1000:36fd	mov	ax, word ptr [bp + 4]
1000:3700	cmp	ax, 0
1000:3703	je	loc_13718
1000:3705	mov	bx, ax
1000:3707	shl	ax, 1
1000:3709	shl	ax, 1
1000:370b	add	ax, bx
1000:370d	shl	ax, 1
1000:370f	add	ax, 5
1000:3712	mov	bl, 0xc
1000:3714	div	bl
1000:3716	mov	ah, 0
        	loc_13718:
1000:3718	mov	word ptr [bp + 4], ax
1000:371b	mov	ax, word ptr [bp + 0xa]
1000:371e	mov	bx, word ptr [bp + 6]
1000:3721	cmp	bx, ax
1000:3723	jae	loc_13737
1000:3725	mov	word ptr [bp + 0xa], bx
1000:3728	mov	word ptr [bp + 6], ax
1000:372b	mov	ax, word ptr [bp + 8]
1000:372e	mov	bx, word ptr [bp + 4]
1000:3731	mov	word ptr [bp + 8], bx
1000:3734	mov	word ptr [bp + 4], ax
        	loc_13737:
1000:3737	mov	ax, word ptr [bp + 6]
1000:373a	sub	ax, word ptr [bp + 0xa]
1000:373d	mov	word ptr [bp - 2], ax
1000:3740	mov	ax, word ptr [bp + 4]
1000:3743	sub	ax, word ptr [bp + 8]
1000:3746	jns	loc_13751
1000:3748	neg	ax
1000:374a	mov	word ptr [bp - 0xa], 0xffe0
1000:374f	jmp	loc_13756
        	loc_13751:
1000:3751	mov	word ptr [bp - 0xa], 0x20
        	loc_13756:
1000:3756	mov	word ptr [bp - 4], ax
1000:3759	mov	cx, word ptr [bp - 2]
1000:375c	cmp	cx, 0
1000:375f	je	loc_137db
1000:3761	cmp	ax, 0
1000:3764	jne	loc_13769
1000:3766	jmp	loc_137ed
        	loc_13769:
1000:3769	cmp	ax, word ptr [bp - 2]
1000:376c	jae	loc_137a4
1000:376e	mov	ax, word ptr [bp - 2]
1000:3771	shr	ax, 1
1000:3773	mov	word ptr [bp - 6], ax
1000:3776	call	0x3801
1000:3779	mov	cx, word ptr [bp - 2]
        	loc_1377c:
1000:377c	shr	al, 1
1000:377e	jne	loc_13783
1000:3780	mov	al, 0x80
1000:3782	inc	di
        	loc_13783:
1000:3783	mov	bx, word ptr [bp - 6]
1000:3786	add	bx, word ptr [bp - 4]
1000:3789	mov	word ptr [bp - 6], bx
1000:378c	cmp	bx, word ptr [bp - 2]
1000:378f	jbe	loc_1379d
1000:3791	sub	bx, word ptr [bp - 2]
1000:3794	mov	word ptr [bp - 6], bx
1000:3797	mov	bx, word ptr [bp - 0xa]
1000:379a	add	di, word ptr [bp - 0xa]
        	loc_1379d:
1000:379d	or	byte ptr es:[di], al
1000:37a0	loop	loc_1377c
1000:37a2	jmp	loc_137d5
        	loc_137a4:
1000:37a4	mov	ax, word ptr [bp - 4]
1000:37a7	shr	ax, 1
1000:37a9	mov	word ptr [bp - 6], ax
1000:37ac	call	0x3801
1000:37af	mov	cx, word ptr [bp - 4]
        	loc_137b2:
1000:37b2	add	di, word ptr [bp - 0xa]
1000:37b5	mov	bx, word ptr [bp - 6]
1000:37b8	add	bx, word ptr [bp - 2]
1000:37bb	mov	word ptr [bp - 6], bx
1000:37be	cmp	bx, word ptr [bp - 4]
1000:37c1	jbe	loc_137d0
1000:37c3	sub	bx, word ptr [bp - 4]
1000:37c6	mov	word ptr [bp - 6], bx
1000:37c9	shr	al, 1
1000:37cb	jne	loc_137d0
1000:37cd	mov	al, 0x80
1000:37cf	inc	di
        	loc_137d0:
1000:37d0	or	byte ptr es:[di], al
1000:37d3	loop	loc_137b2
        	loc_137d5:
1000:37d5	mov	sp, bp
1000:37d7	pop	bp
1000:37d8	ret	8
        	loc_137db:
1000:37db	call	0x3801
1000:37de	mov	cx, word ptr [bp - 4]
1000:37e1	jcxz	loc_137d5
        	loc_137e3:
1000:37e3	add	di, word ptr [bp - 0xa]
1000:37e6	or	byte ptr es:[di], al
1000:37e9	loop	loc_137e3
1000:37eb	jmp	loc_137d5
        	loc_137ed:
1000:37ed	call	0x3801
1000:37f0	mov	cx, word ptr [bp - 2]
        	loc_137f3:
1000:37f3	shr	al, 1
1000:37f5	jne	loc_137fa
1000:37f7	mov	al, 0x80
1000:37f9	inc	di
        	loc_137fa:
1000:37fa	or	byte ptr es:[di], al
1000:37fd	loop	loc_137f3
1000:37ff	jmp	loc_137d5
                sub_136d4 ENDP
*/
void sub_136d4()
{
    // coverage: 0x38d4-0x3a01 method sub_136d4
    push(bp);
    bp = sp;
    sp -= 0x000a;
    ax = memoryAGet16(ds, 0x94f4);
    es = ax;
    ax = memoryAGet16(ss, bp + 8 - 2);
    if (ax == 0x0000)
        goto loc_136fa;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_136fa:
    memoryASet16(ss, bp + 8 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    if (ax == 0x0000)
        goto loc_13718;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_13718:
    memoryASet16(ss, bp + 4 - 2, ax);
    ax = memoryAGet16(ss, bp + 10 - 2);
    bx = memoryAGet16(ss, bp + 6 - 2);
    if (bx >= ax)
        goto loc_13737;
    memoryASet16(ss, bp + 10 - 2, bx);
    memoryASet16(ss, bp + 6 - 2, ax);
    ax = memoryAGet16(ss, bp + 8 - 2);
    bx = memoryAGet16(ss, bp + 4 - 2);
    memoryASet16(ss, bp + 8 - 2, bx);
    memoryASet16(ss, bp + 4 - 2, ax);
loc_13737:
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax -= memoryAGet16(ss, bp + 10 - 2);
    memoryASet16(ss, bp - 2 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax -= memoryAGet16(ss, bp + 8 - 2);
    if ((short)ax >= 0)
        goto loc_13751;
    ax = -ax;
    memoryASet16(ss, bp - 10 - 2, 0xffe0);
    goto loc_13756;
loc_13751:
    memoryASet16(ss, bp - 10 - 2, 0x0020);
loc_13756:
    memoryASet16(ss, bp - 4 - 2, ax);
    cx = memoryAGet16(ss, bp - 2 - 2);
    if (cx == 0x0000)
        goto loc_137db;
    if (ax != 0x0000)
        goto loc_13769;
    goto loc_137ed;
loc_13769:
    if (ax >= memoryAGet16(ss, bp - 2 - 2))
        goto loc_137a4;
    ax = memoryAGet16(ss, bp - 2 - 2);
    ax >>= 1;
    memoryASet16(ss, bp - 6 - 2, ax);
    sub_13801();
    cx = memoryAGet16(ss, bp - 2 - 2);
loc_1377c:
    al >>= 1;
    if (al != 0)
        goto loc_13783;
    al = 0x80;
    di++;
loc_13783:
    bx = memoryAGet16(ss, bp - 6 - 2);
    bx += memoryAGet16(ss, bp - 4 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    if (bx <= memoryAGet16(ss, bp - 2 - 2))
        goto loc_1379d;
    bx -= memoryAGet16(ss, bp - 2 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    bx = memoryAGet16(ss, bp - 10 - 2);
    di += memoryAGet16(ss, bp - 10 - 2);
loc_1379d:
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_1377c;
    goto loc_137d5;
loc_137a4:
    ax = memoryAGet16(ss, bp - 4 - 2);
    ax >>= 1;
    memoryASet16(ss, bp - 6 - 2, ax);
    sub_13801();
    cx = memoryAGet16(ss, bp - 4 - 2);
loc_137b2:
    di += memoryAGet16(ss, bp - 10 - 2);
    bx = memoryAGet16(ss, bp - 6 - 2);
    bx += memoryAGet16(ss, bp - 2 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    if (bx <= memoryAGet16(ss, bp - 4 - 2))
        goto loc_137d0;
    bx -= memoryAGet16(ss, bp - 4 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    al >>= 1;
    if (al != 0)
        goto loc_137d0;
    al = 0x80;
    di++;
loc_137d0:
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_137b2;
loc_137d5:
    sp = bp;
    bp = pop();
    sp += 8;
    return;
loc_137db:
    sub_13801();
    cx = memoryAGet16(ss, bp - 4 - 2);
    if (cx == 0)
        goto loc_137d5;
loc_137e3:
    di += memoryAGet16(ss, bp - 10 - 2);
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_137e3;
    goto loc_137d5;
loc_137ed:
    sub_13801();
    cx = memoryAGet16(ss, bp - 2 - 2);
loc_137f3:
    al >>= 1;
    if (al != 0)
        goto loc_137fa;
    al = 0x80;
    di++;
loc_137fa:
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_137f3;
    goto loc_137d5;
}
/* Assembly listing of 1000:3801 sub_13801()
                sub_13801 PROC
1000:3801	mov	ax, word ptr [bp + 8]
1000:3804	shl	ax, 1
1000:3806	shl	ax, 1
1000:3808	shl	ax, 1
1000:380a	shl	ax, 1
1000:380c	shl	ax, 1
1000:380e	mov	di, ax
1000:3810	mov	ax, word ptr [bp + 0xa]
1000:3813	shr	ax, 1
1000:3815	shr	ax, 1
1000:3817	shr	ax, 1
1000:3819	add	di, ax
1000:381b	mov	cx, word ptr [bp + 0xa]
1000:381e	and	cx, 7
1000:3821	mov	al, 0x80
1000:3823	shr	al, cl
1000:3825	or	byte ptr es:[di], al
1000:3828	ret	
                sub_13801 ENDP
*/
void sub_13801()
{
    // coverage: 0x3a01-0x3a29 method sub_13801
    ax = memoryAGet16(ss, bp + 8 - 2);
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    di = ax;
    ax = memoryAGet16(ss, bp + 10 - 2);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    di += ax;
    cx = memoryAGet16(ss, bp + 10 - 2);
    cx &= 0x0007;
    al = 0x80;
    al >>= cl;
    memoryASet(es, di, memoryAGet(es, di) | al);
}
/* Assembly listing of 1000:382a sub_1382a()
                sub_1382a PROC
1000:382a	mov	al, 0
1000:382c	mov	byte ptr [0x9550], al
1000:382f	mov	byte ptr [0x9551], al
1000:3832	mov	byte ptr [0x9552], al
1000:3835	mov	byte ptr [0x9506], 1
1000:383a	mov	byte ptr [0x9505], 0
1000:383f	ret	
                sub_1382a ENDP
*/
void sub_1382a()
{
    // coverage: 0x3a2a-0x3a40 method sub_1382a
    al = 0x00;
    memoryASet(ds, 0x9550, al);
    memoryASet(ds, 0x9551, al);
    memoryASet(ds, 0x9552, al);
    memoryASet(ds, 0x9506, 0x01);
    memoryASet(ds, 0x9505, 0x00);
}
/* Assembly listing of 1000:3840 sub_13840()
                sub_13840 PROC
1000:3840	mov	ah, byte ptr [0x955e]
1000:3844	cmp	ah, 0
1000:3847	je	loc_1384a
1000:3849	ret	
        	loc_1384a:
1000:384a	mov	ah, byte ptr [0x9506]
1000:384e	cmp	ah, 0
1000:3851	jne	loc_13854
1000:3853	ret	
        	loc_13854:
1000:3854	mov	ah, byte ptr [0x9550]
1000:3858	cmp	ah, 0
1000:385b	jne	loc_13866
1000:385d	push	bx
1000:385e	mov	byte ptr [0x9550], al
1000:3861	call	0x3914
1000:3864	pop	bx
1000:3865	ret	
        	loc_13866:
1000:3866	mov	ah, byte ptr [0x9551]
1000:386a	cmp	ah, 0
1000:386d	jne	loc_13873
1000:386f	mov	byte ptr [0x9551], al
1000:3872	ret	
        	loc_13873:
1000:3873	cmp	al, byte ptr [0x9552]
1000:3877	jbe	loc_1387c
1000:3879	mov	byte ptr [0x9552], al
        	loc_1387c:
1000:387c	ret	
                sub_13840 ENDP
*/
void sub_13840()
{
    // coverage: 0x3a40-0x3a7d method sub_13840
    ah = memoryAGet(ds, 0x955e);
    if (ah == 0x00)
        goto loc_1384a;
    return;
loc_1384a:
    ah = memoryAGet(ds, 0x9506);
    if (ah != 0x00)
        goto loc_13854;
    return;
loc_13854:
    ah = memoryAGet(ds, 0x9550);
    if (ah != 0x00)
        goto loc_13866;
    push(bx);
    memoryASet(ds, 0x9550, al);
    sub_13914();
    bx = pop();
    return;
loc_13866:
    ah = memoryAGet(ds, 0x9551);
    if (ah != 0x00)
        goto loc_13873;
    memoryASet(ds, 0x9551, al);
    return;
loc_13873:
    if (al <= memoryAGet(ds, 0x9552))
        return;
    memoryASet(ds, 0x9552, al);
}
/* Assembly listing of 1000:3914 sub_13914()
                sub_13914 PROC
1000:3914	dec	al
1000:3916	mov	bl, al
1000:3918	mov	bh, 0
1000:391a	shl	bx, 1
1000:391c	mov	bx, word ptr [bx - 0x741c]
1000:3920	mov	al, byte ptr [bx + 1]
1000:3923	mov	byte ptr [0x9557], al
1000:3926	cmp	bx, 0x8c2c
1000:392a	jne	loc_13941
1000:392c	mov	ax, word ptr [0x9536]
1000:392f	mov	ah, al
1000:3931	mov	al, 0
1000:3933	shl	ax, 1
1000:3935	shl	ax, 1
1000:3937	neg	ax
1000:3939	add	ax, 0x1f40
1000:393c	mov	word ptr [0x8c2e], ax
1000:393f	jmp	loc_13966
        	loc_13941:
1000:3941	cmp	bx, 0x8c32
1000:3945	jne	loc_13966
1000:3947	mov	al, byte ptr [0x1ba0]
1000:394a	and	ax, 0x7f
1000:394d	cmp	ax, 0x3f
1000:3950	jbe	loc_13957
1000:3952	sub	ax, 0x40
1000:3955	jmp	loc_1395c
        	loc_13957:
1000:3957	neg	ax
1000:3959	add	ax, 0x3f
        	loc_1395c:
1000:395c	shl	ax, 1
1000:395e	shl	ax, 1
1000:3960	add	ax, 0x190
1000:3963	mov	word ptr [0x8c34], ax
        	loc_13966:
1000:3966	mov	ax, word ptr [bx + 2]
1000:3969	mov	word ptr [0x9558], ax
1000:396c	mov	ax, word ptr [bx + 4]
1000:396f	mov	word ptr [0x955a], ax
1000:3972	mov	bl, byte ptr [bx]
1000:3974	mov	byte ptr [0x9553], bl
1000:3978	cmp	bl, 0
1000:397b	jle	loc_1398f
1000:397d	dec	bl
1000:397f	mov	bh, 0
1000:3981	shl	bx, 1
1000:3983	mov	ax, word ptr [bx - 0x73a4]
1000:3987	mov	word ptr [0x9555], ax
1000:398a	mov	byte ptr [0x9554], 0
        	loc_1398f:
1000:398f	mov	al, 0xb6
1000:3991	out	0x43, al
1000:3993	mov	ax, word ptr [0x9558]
1000:3996	out	0x42, al
1000:3998	mov	al, ah
1000:399a	out	0x42, al
1000:399c	in	al, 0x61
1000:399e	or	al, 3
1000:39a0	out	0x61, al
1000:39a2	ret	
                sub_13914 ENDP
*/
void sub_13914()
{
    // coverage: 0x3b14-0x3ba3 method sub_13914
    al--;
    bl = al;
    bh = 0x00;
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 35812);
    al = memoryAGet(ds, bx + 1);
    memoryASet(ds, 0x9557, al);
    if (bx != 0x8c2c)
        goto loc_13941;
    ax = memoryAGet16(ds, 0x9536);
    ah = al;
    al = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax = -ax;
    ax += 0x1f40;
    memoryASet16(ds, 0x8c2e, ax);
    goto loc_13966;
loc_13941:
    if (bx != 0x8c32)
        goto loc_13966;
    al = memoryAGet(ds, 0x1ba0);
    ax &= 0x007f;
    if (ax <= 0x003f)
        goto loc_13957;
    ax -= 0x0040;
    goto loc_1395c;
loc_13957:
    ax = -ax;
    ax += 0x003f;
loc_1395c:
    ax <<= 1;
    ax <<= 1;
    ax += 0x0190;
    memoryASet16(ds, 0x8c34, ax);
loc_13966:
    ax = memoryAGet16(ds, bx + 2);
    memoryASet16(ds, 0x9558, ax);
    ax = memoryAGet16(ds, bx + 4);
    memoryASet16(ds, 0x955a, ax);
    bl = memoryAGet(ds, bx);
    memoryASet(ds, 0x9553, bl);
    if ((char)bl <= (char)0x00)
        goto loc_1398f;
    bl--;
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 35932);
    memoryASet16(ds, 0x9555, ax);
    memoryASet(ds, 0x9554, 0x00);
loc_1398f:
    al = 0xb6;
    out(0x43, al);
    ax = memoryAGet16(ds, 0x9558);
    out(0x42, al);
    al = ah;
    out(0x42, al);
    in(al, 0x61);
    al |= 0x03;
    out(0x61, al);
}
/* Assembly listing of 1000:39a3 sub_139a3()
                sub_139a3 PROC
1000:39a3	mov	al, 0
1000:39a5	mov	byte ptr [0x9550], al
1000:39a8	mov	byte ptr [0x9551], al
1000:39ab	mov	byte ptr [0x9552], al
1000:39ae	mov	byte ptr [0x9557], al
1000:39b1	in	al, 0x61
1000:39b3	and	al, 0xfc
1000:39b5	out	0x61, al
1000:39b7	ret	
                sub_139a3 ENDP
*/
void sub_139a3()
{
    // coverage: 0x3ba3-0x3bb8 method sub_139a3
    al = 0x00;
    memoryASet(ds, 0x9550, al);
    memoryASet(ds, 0x9551, al);
    memoryASet(ds, 0x9552, al);
    memoryASet(ds, 0x9557, al);
    in(al, 0x61);
    al &= 0xfc;
    out(0x61, al);
}
/* Assembly listing of 1000:39b8 sub_139b8()
                sub_139b8 PROC
1000:39b8	mov	byte ptr [0x9561], 0
1000:39bd	mov	word ptr [0x955f], 0
1000:39c3	mov	byte ptr [0x955e], 1
1000:39c8	mov	al, byte ptr [0x9546]
1000:39cb	cmp	al, 0
1000:39cd	jne	loc_139d4
1000:39cf	mov	ax, 0x8dec
1000:39d2	jmp	loc_139d7
        	loc_139d4:
1000:39d4	mov	ax, 0x8d4c
        	loc_139d7:
1000:39d7	mov	word ptr [0x9562], ax
1000:39da	ret	
                sub_139b8 ENDP
*/
void sub_139b8()
{
    // coverage: 0x3bb8-0x3bdb method sub_139b8
    memoryASet(ds, 0x9561, 0x00);
    memoryASet16(ds, 0x955f, 0x0000);
    memoryASet(ds, 0x955e, 0x01);
    al = memoryAGet(ds, 0x9546);
    if (al != 0x00)
        goto loc_139d4;
    ax = 0x8dec;
    goto loc_139d7;
loc_139d4:
    ax = 0x8d4c;
loc_139d7:
    memoryASet16(ds, 0x9562, ax);
}
`
