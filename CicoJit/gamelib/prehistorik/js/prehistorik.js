var prehistorikLevel = 0;
var prehistorikScreen = 0;
var prehistorikFade = true;
var prehistorikInifniteEnergy = false;
var prehistorikInifniteLives = false;

function* start() {
    headerSize = 0x2000;
    loadAddress = 0x01ed;
    cs = 0x01ed;
    ds = 0x01dd;
    es = 0x01dd;
    ss = 0x2956;
    sp = 0x0080;
    load("/Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/prehistorik/dos", "HISTORIK.EXE", 164166);
    fixReloc(cs);
    yield* sub_1ed0();
}
function fixReloc(seg) {
    memory16set(0x0000 + seg, 0x0002, memory16get(0x0000 + seg, 0x0002) + seg);
    memory16set(0x000c + seg, 0x0005, memory16get(0x000c + seg, 0x0005) + seg);
    memory16set(0x000c + seg, 0x000a, memory16get(0x000c + seg, 0x000a) + seg);
    memory16set(0x000f + seg, 0x0009, memory16get(0x000f + seg, 0x0009) + seg);
    memory16set(0x000f + seg, 0x000f, memory16get(0x000f + seg, 0x000f) + seg);
    memory16set(0x0010 + seg, 0x0009, memory16get(0x0010 + seg, 0x0009) + seg);
    memory16set(0x0017 + seg, 0x0000, memory16get(0x0017 + seg, 0x0000) + seg);
    memory16set(0x003e + seg, 0x0001, memory16get(0x003e + seg, 0x0001) + seg);
    memory16set(0x0043 + seg, 0x0004, memory16get(0x0043 + seg, 0x0004) + seg);
    memory16set(0x0044 + seg, 0x000d, memory16get(0x0044 + seg, 0x000d) + seg);
    memory16set(0x0049 + seg, 0x0009, memory16get(0x0049 + seg, 0x0009) + seg);
    memory16set(0x004b + seg, 0x0001, memory16get(0x004b + seg, 0x0001) + seg);
    memory16set(0x0050 + seg, 0x0008, memory16get(0x0050 + seg, 0x0008) + seg);
    memory16set(0x0054 + seg, 0x0008, memory16get(0x0054 + seg, 0x0008) + seg);
    memory16set(0x0056 + seg, 0x0005, memory16get(0x0056 + seg, 0x0005) + seg);
    memory16set(0x005c + seg, 0x0007, memory16get(0x005c + seg, 0x0007) + seg);
    memory16set(0x0060 + seg, 0x000c, memory16get(0x0060 + seg, 0x000c) + seg);
    memory16set(0x0065 + seg, 0x0005, memory16get(0x0065 + seg, 0x0005) + seg);
    memory16set(0x007f + seg, 0x000d, memory16get(0x007f + seg, 0x000d) + seg);
    memory16set(0x0081 + seg, 0x0008, memory16get(0x0081 + seg, 0x0008) + seg);
    memory16set(0x00a1 + seg, 0x0003, memory16get(0x00a1 + seg, 0x0003) + seg);
    memory16set(0x00a2 + seg, 0x000c, memory16get(0x00a2 + seg, 0x000c) + seg);
    memory16set(0x00b1 + seg, 0x0007, memory16get(0x00b1 + seg, 0x0007) + seg);
    memory16set(0x00b3 + seg, 0x0007, memory16get(0x00b3 + seg, 0x0007) + seg);
    memory16set(0x00c1 + seg, 0x000e, memory16get(0x00c1 + seg, 0x000e) + seg);
    memory16set(0x00c3 + seg, 0x000f, memory16get(0x00c3 + seg, 0x000f) + seg);
    memory16set(0x00cc + seg, 0x000b, memory16get(0x00cc + seg, 0x000b) + seg);
    memory16set(0x00d3 + seg, 0x0003, memory16get(0x00d3 + seg, 0x0003) + seg);
    memory16set(0x00d5 + seg, 0x0006, memory16get(0x00d5 + seg, 0x0006) + seg);
    memory16set(0x00d9 + seg, 0x0003, memory16get(0x00d9 + seg, 0x0003) + seg);
    memory16set(0x00dd + seg, 0x0009, memory16get(0x00dd + seg, 0x0009) + seg);
    memory16set(0x00de + seg, 0x000a, memory16get(0x00de + seg, 0x000a) + seg);
    memory16set(0x00e4 + seg, 0x000f, memory16get(0x00e4 + seg, 0x000f) + seg);
    memory16set(0x00e8 + seg, 0x000d, memory16get(0x00e8 + seg, 0x000d) + seg);
    memory16set(0x00ec + seg, 0x000f, memory16get(0x00ec + seg, 0x000f) + seg);
    memory16set(0x00ee + seg, 0x0006, memory16get(0x00ee + seg, 0x0006) + seg);
    memory16set(0x00f4 + seg, 0x0000, memory16get(0x00f4 + seg, 0x0000) + seg);
    memory16set(0x00f8 + seg, 0x0008, memory16get(0x00f8 + seg, 0x0008) + seg);
    memory16set(0x00fa + seg, 0x0003, memory16get(0x00fa + seg, 0x0003) + seg);
    memory16set(0x00ff + seg, 0x000b, memory16get(0x00ff + seg, 0x000b) + seg);
    memory16set(0x0106 + seg, 0x000b, memory16get(0x0106 + seg, 0x000b) + seg);
    memory16set(0x0119 + seg, 0x0001, memory16get(0x0119 + seg, 0x0001) + seg);
    memory16set(0x011d + seg, 0x000b, memory16get(0x011d + seg, 0x000b) + seg);
    memory16set(0x011f + seg, 0x000d, memory16get(0x011f + seg, 0x000d) + seg);
    memory16set(0x0138 + seg, 0x000d, memory16get(0x0138 + seg, 0x000d) + seg);
    memory16set(0x0145 + seg, 0x0008, memory16get(0x0145 + seg, 0x0008) + seg);
    memory16set(0x0155 + seg, 0x000d, memory16get(0x0155 + seg, 0x000d) + seg);
    memory16set(0x0172 + seg, 0x0003, memory16get(0x0172 + seg, 0x0003) + seg);
    memory16set(0x0175 + seg, 0x0001, memory16get(0x0175 + seg, 0x0001) + seg);
    memory16set(0x0181 + seg, 0x0008, memory16get(0x0181 + seg, 0x0008) + seg);
    memory16set(0x0185 + seg, 0x0006, memory16get(0x0185 + seg, 0x0006) + seg);
    memory16set(0x018d + seg, 0x0007, memory16get(0x018d + seg, 0x0007) + seg);
    memory16set(0x018f + seg, 0x0004, memory16get(0x018f + seg, 0x0004) + seg);
    memory16set(0x0199 + seg, 0x0004, memory16get(0x0199 + seg, 0x0004) + seg);
    memory16set(0x01a3 + seg, 0x000a, memory16get(0x01a3 + seg, 0x000a) + seg);
    memory16set(0x01b4 + seg, 0x0005, memory16get(0x01b4 + seg, 0x0005) + seg);
    memory16set(0x01c1 + seg, 0x0006, memory16get(0x01c1 + seg, 0x0006) + seg);
    memory16set(0x01d2 + seg, 0x000c, memory16get(0x01d2 + seg, 0x000c) + seg);
    memory16set(0x01e2 + seg, 0x000e, memory16get(0x01e2 + seg, 0x000e) + seg);
    memory16set(0x01e9 + seg, 0x0009, memory16get(0x01e9 + seg, 0x0009) + seg);
    memory16set(0x01f0 + seg, 0x000d, memory16get(0x01f0 + seg, 0x000d) + seg);
    memory16set(0x01f2 + seg, 0x0001, memory16get(0x01f2 + seg, 0x0001) + seg);
    memory16set(0x01f8 + seg, 0x0003, memory16get(0x01f8 + seg, 0x0003) + seg);
    memory16set(0x0203 + seg, 0x0007, memory16get(0x0203 + seg, 0x0007) + seg);
    memory16set(0x020a + seg, 0x0006, memory16get(0x020a + seg, 0x0006) + seg);
    memory16set(0x020c + seg, 0x0008, memory16get(0x020c + seg, 0x0008) + seg);
    memory16set(0x020e + seg, 0x0001, memory16get(0x020e + seg, 0x0001) + seg);
    memory16set(0x020f + seg, 0x000a, memory16get(0x020f + seg, 0x000a) + seg);
    memory16set(0x0211 + seg, 0x000d, memory16get(0x0211 + seg, 0x000d) + seg);
    memory16set(0x0215 + seg, 0x0004, memory16get(0x0215 + seg, 0x0004) + seg);
    memory16set(0x0218 + seg, 0x0001, memory16get(0x0218 + seg, 0x0001) + seg);
    memory16set(0x021c + seg, 0x0009, memory16get(0x021c + seg, 0x0009) + seg);
    memory16set(0x0220 + seg, 0x0005, memory16get(0x0220 + seg, 0x0005) + seg);
    memory16set(0x0222 + seg, 0x000c, memory16get(0x0222 + seg, 0x000c) + seg);
    memory16set(0x0224 + seg, 0x000f, memory16get(0x0224 + seg, 0x000f) + seg);
    memory16set(0x0242 + seg, 0x0004, memory16get(0x0242 + seg, 0x0004) + seg);
    memory16set(0x0247 + seg, 0x000b, memory16get(0x0247 + seg, 0x000b) + seg);
    memory16set(0x0260 + seg, 0x0000, memory16get(0x0260 + seg, 0x0000) + seg);
    memory16set(0x026b + seg, 0x000b, memory16get(0x026b + seg, 0x000b) + seg);
    memory16set(0x026d + seg, 0x0003, memory16get(0x026d + seg, 0x0003) + seg);
    memory16set(0x0277 + seg, 0x0004, memory16get(0x0277 + seg, 0x0004) + seg);
    memory16set(0x0278 + seg, 0x000c, memory16get(0x0278 + seg, 0x000c) + seg);
    memory16set(0x02b3 + seg, 0x0003, memory16get(0x02b3 + seg, 0x0003) + seg);
    memory16set(0x02b5 + seg, 0x000a, memory16get(0x02b5 + seg, 0x000a) + seg);
    memory16set(0x02d0 + seg, 0x0001, memory16get(0x02d0 + seg, 0x0001) + seg);
    memory16set(0x02d2 + seg, 0x0008, memory16get(0x02d2 + seg, 0x0008) + seg);
    memory16set(0x02ea + seg, 0x000d, memory16get(0x02ea + seg, 0x000d) + seg);
    memory16set(0x02ed + seg, 0x0006, memory16get(0x02ed + seg, 0x0006) + seg);
    memory16set(0x02f4 + seg, 0x0005, memory16get(0x02f4 + seg, 0x0005) + seg);
    memory16set(0x02fd + seg, 0x000c, memory16get(0x02fd + seg, 0x000c) + seg);
    memory16set(0x0306 + seg, 0x0008, memory16get(0x0306 + seg, 0x0008) + seg);
    memory16set(0x0332 + seg, 0x000a, memory16get(0x0332 + seg, 0x000a) + seg);
    memory16set(0x034c + seg, 0x0007, memory16get(0x034c + seg, 0x0007) + seg);
    memory16set(0x0361 + seg, 0x0008, memory16get(0x0361 + seg, 0x0008) + seg);
    memory16set(0x03b0 + seg, 0x000c, memory16get(0x03b0 + seg, 0x000c) + seg);
    memory16set(0x03b4 + seg, 0x0004, memory16get(0x03b4 + seg, 0x0004) + seg);
    memory16set(0x03bb + seg, 0x0005, memory16get(0x03bb + seg, 0x0005) + seg);
    memory16set(0x03bf + seg, 0x000f, memory16get(0x03bf + seg, 0x000f) + seg);
    memory16set(0x03c2 + seg, 0x0000, memory16get(0x03c2 + seg, 0x0000) + seg);
    memory16set(0x03c7 + seg, 0x000f, memory16get(0x03c7 + seg, 0x000f) + seg);
    memory16set(0x03e9 + seg, 0x0007, memory16get(0x03e9 + seg, 0x0007) + seg);
    memory16set(0x0412 + seg, 0x000c, memory16get(0x0412 + seg, 0x000c) + seg);
    memory16set(0x0414 + seg, 0x0009, memory16get(0x0414 + seg, 0x0009) + seg);
    memory16set(0x0419 + seg, 0x0002, memory16get(0x0419 + seg, 0x0002) + seg);
    memory16set(0x041a + seg, 0x000f, memory16get(0x041a + seg, 0x000f) + seg);
    memory16set(0x042f + seg, 0x000d, memory16get(0x042f + seg, 0x000d) + seg);
    memory16set(0x0434 + seg, 0x000c, memory16get(0x0434 + seg, 0x000c) + seg);
    memory16set(0x0437 + seg, 0x000c, memory16get(0x0437 + seg, 0x000c) + seg);
    memory16set(0x043a + seg, 0x0003, memory16get(0x043a + seg, 0x0003) + seg);
    memory16set(0x0447 + seg, 0x000f, memory16get(0x0447 + seg, 0x000f) + seg);
    memory16set(0x0449 + seg, 0x0007, memory16get(0x0449 + seg, 0x0007) + seg);
    memory16set(0x044b + seg, 0x0002, memory16get(0x044b + seg, 0x0002) + seg);
    memory16set(0x044c + seg, 0x000b, memory16get(0x044c + seg, 0x000b) + seg);
    memory16set(0x0458 + seg, 0x0009, memory16get(0x0458 + seg, 0x0009) + seg);
    memory16set(0x0459 + seg, 0x000b, memory16get(0x0459 + seg, 0x000b) + seg);
    memory16set(0x045d + seg, 0x0007, memory16get(0x045d + seg, 0x0007) + seg);
    memory16set(0x046c + seg, 0x0004, memory16get(0x046c + seg, 0x0004) + seg);
    memory16set(0x046d + seg, 0x0008, memory16get(0x046d + seg, 0x0008) + seg);
    memory16set(0x046e + seg, 0x0009, memory16get(0x046e + seg, 0x0009) + seg);
    memory16set(0x0472 + seg, 0x0005, memory16get(0x0472 + seg, 0x0005) + seg);
    memory16set(0x0479 + seg, 0x000d, memory16get(0x0479 + seg, 0x000d) + seg);
    memory16set(0x047b + seg, 0x0001, memory16get(0x047b + seg, 0x0001) + seg);
    memory16set(0x047c + seg, 0x0002, memory16get(0x047c + seg, 0x0002) + seg);
    memory16set(0x047f + seg, 0x000e, memory16get(0x047f + seg, 0x000e) + seg);
    memory16set(0x04b8 + seg, 0x0005, memory16get(0x04b8 + seg, 0x0005) + seg);
    memory16set(0x04bc + seg, 0x000d, memory16get(0x04bc + seg, 0x000d) + seg);
    memory16set(0x04be + seg, 0x000b, memory16get(0x04be + seg, 0x000b) + seg);
    memory16set(0x04c8 + seg, 0x000f, memory16get(0x04c8 + seg, 0x000f) + seg);
    memory16set(0x04f1 + seg, 0x0001, memory16get(0x04f1 + seg, 0x0001) + seg);
    memory16set(0x04f1 + seg, 0x0008, memory16get(0x04f1 + seg, 0x0008) + seg);
    memory16set(0x04f3 + seg, 0x0000, memory16get(0x04f3 + seg, 0x0000) + seg);
    memory16set(0x04f3 + seg, 0x0007, memory16get(0x04f3 + seg, 0x0007) + seg);
    memory16set(0x04f6 + seg, 0x000a, memory16get(0x04f6 + seg, 0x000a) + seg);
    memory16set(0x0507 + seg, 0x0009, memory16get(0x0507 + seg, 0x0009) + seg);
    memory16set(0x0508 + seg, 0x000f, memory16get(0x0508 + seg, 0x000f) + seg);
    memory16set(0x050a + seg, 0x0001, memory16get(0x050a + seg, 0x0001) + seg);
    memory16set(0x050a + seg, 0x0008, memory16get(0x050a + seg, 0x0008) + seg);
    memory16set(0x050c + seg, 0x0004, memory16get(0x050c + seg, 0x0004) + seg);
    memory16set(0x050e + seg, 0x000e, memory16get(0x050e + seg, 0x000e) + seg);
    memory16set(0x0510 + seg, 0x0004, memory16get(0x0510 + seg, 0x0004) + seg);
    memory16set(0x0518 + seg, 0x0000, memory16get(0x0518 + seg, 0x0000) + seg);
    memory16set(0x0519 + seg, 0x0005, memory16get(0x0519 + seg, 0x0005) + seg);
    memory16set(0x051a + seg, 0x0005, memory16get(0x051a + seg, 0x0005) + seg);
    memory16set(0x051b + seg, 0x000a, memory16get(0x051b + seg, 0x000a) + seg);
    memory16set(0x051d + seg, 0x0009, memory16get(0x051d + seg, 0x0009) + seg);
    memory16set(0x051e + seg, 0x000e, memory16get(0x051e + seg, 0x000e) + seg);
    memory16set(0x051f + seg, 0x000e, memory16get(0x051f + seg, 0x000e) + seg);
    memory16set(0x0521 + seg, 0x0003, memory16get(0x0521 + seg, 0x0003) + seg);
    memory16set(0x0524 + seg, 0x0001, memory16get(0x0524 + seg, 0x0001) + seg);
    memory16set(0x0525 + seg, 0x000f, memory16get(0x0525 + seg, 0x000f) + seg);
    memory16set(0x0529 + seg, 0x0007, memory16get(0x0529 + seg, 0x0007) + seg);
    memory16set(0x052a + seg, 0x0006, memory16get(0x052a + seg, 0x0006) + seg);
    memory16set(0x052a + seg, 0x000e, memory16get(0x052a + seg, 0x000e) + seg);
    memory16set(0x052b + seg, 0x0003, memory16get(0x052b + seg, 0x0003) + seg);
    memory16set(0x052b + seg, 0x0008, memory16get(0x052b + seg, 0x0008) + seg);
    memory16set(0x052d + seg, 0x0009, memory16get(0x052d + seg, 0x0009) + seg);
    memory16set(0x0530 + seg, 0x0000, memory16get(0x0530 + seg, 0x0000) + seg);
    memory16set(0x0531 + seg, 0x0003, memory16get(0x0531 + seg, 0x0003) + seg);
    memory16set(0x0534 + seg, 0x0003, memory16get(0x0534 + seg, 0x0003) + seg);
    memory16set(0x0537 + seg, 0x0000, memory16get(0x0537 + seg, 0x0000) + seg);
    memory16set(0x0538 + seg, 0x0003, memory16get(0x0538 + seg, 0x0003) + seg);
    memory16set(0x053b + seg, 0x0004, memory16get(0x053b + seg, 0x0004) + seg);
    memory16set(0x053d + seg, 0x000a, memory16get(0x053d + seg, 0x000a) + seg);
    memory16set(0x053f + seg, 0x0007, memory16get(0x053f + seg, 0x0007) + seg);
    memory16set(0x0540 + seg, 0x0009, memory16get(0x0540 + seg, 0x0009) + seg);
    memory16set(0x0543 + seg, 0x0005, memory16get(0x0543 + seg, 0x0005) + seg);
    memory16set(0x0545 + seg, 0x0007, memory16get(0x0545 + seg, 0x0007) + seg);
    memory16set(0x0547 + seg, 0x000a, memory16get(0x0547 + seg, 0x000a) + seg);
    memory16set(0x054d + seg, 0x0004, memory16get(0x054d + seg, 0x0004) + seg);
    memory16set(0x0552 + seg, 0x0009, memory16get(0x0552 + seg, 0x0009) + seg);
    memory16set(0x0555 + seg, 0x0009, memory16get(0x0555 + seg, 0x0009) + seg);
    memory16set(0x0559 + seg, 0x0008, memory16get(0x0559 + seg, 0x0008) + seg);
    memory16set(0x055e + seg, 0x000d, memory16get(0x055e + seg, 0x000d) + seg);
    memory16set(0x0561 + seg, 0x000d, memory16get(0x0561 + seg, 0x000d) + seg);
    memory16set(0x0563 + seg, 0x0000, memory16get(0x0563 + seg, 0x0000) + seg);
    memory16set(0x0564 + seg, 0x0008, memory16get(0x0564 + seg, 0x0008) + seg);
    memory16set(0x056a + seg, 0x0008, memory16get(0x056a + seg, 0x0008) + seg);
    memory16set(0x0579 + seg, 0x0007, memory16get(0x0579 + seg, 0x0007) + seg);
    memory16set(0x057b + seg, 0x0009, memory16get(0x057b + seg, 0x0009) + seg);
    memory16set(0x057e + seg, 0x0003, memory16get(0x057e + seg, 0x0003) + seg);
    memory16set(0x057f + seg, 0x0009, memory16get(0x057f + seg, 0x0009) + seg);
    memory16set(0x0583 + seg, 0x0000, memory16get(0x0583 + seg, 0x0000) + seg);
    memory16set(0x0584 + seg, 0x0006, memory16get(0x0584 + seg, 0x0006) + seg);
    memory16set(0x0587 + seg, 0x000d, memory16get(0x0587 + seg, 0x000d) + seg);
    memory16set(0x0589 + seg, 0x0003, memory16get(0x0589 + seg, 0x0003) + seg);
    memory16set(0x0590 + seg, 0x000b, memory16get(0x0590 + seg, 0x000b) + seg);
    memory16set(0x0592 + seg, 0x0001, memory16get(0x0592 + seg, 0x0001) + seg);
    memory16set(0x0599 + seg, 0x0002, memory16get(0x0599 + seg, 0x0002) + seg);
    memory16set(0x059a + seg, 0x0008, memory16get(0x059a + seg, 0x0008) + seg);
    memory16set(0x059f + seg, 0x000b, memory16get(0x059f + seg, 0x000b) + seg);
    memory16set(0x05a0 + seg, 0x000d, memory16get(0x05a0 + seg, 0x000d) + seg);
    memory16set(0x05a2 + seg, 0x0001, memory16get(0x05a2 + seg, 0x0001) + seg);
    memory16set(0x05a2 + seg, 0x0009, memory16get(0x05a2 + seg, 0x0009) + seg);
    memory16set(0x05a2 + seg, 0x000e, memory16get(0x05a2 + seg, 0x000e) + seg);
    memory16set(0x05a3 + seg, 0x000b, memory16get(0x05a3 + seg, 0x000b) + seg);
    memory16set(0x05a4 + seg, 0x0007, memory16get(0x05a4 + seg, 0x0007) + seg);
    memory16set(0x05a5 + seg, 0x0005, memory16get(0x05a5 + seg, 0x0005) + seg);
    memory16set(0x05aa + seg, 0x0002, memory16get(0x05aa + seg, 0x0002) + seg);
    memory16set(0x05ab + seg, 0x0005, memory16get(0x05ab + seg, 0x0005) + seg);
    memory16set(0x05ae + seg, 0x000b, memory16get(0x05ae + seg, 0x000b) + seg);
    memory16set(0x05af + seg, 0x000e, memory16get(0x05af + seg, 0x000e) + seg);
    memory16set(0x05b8 + seg, 0x0002, memory16get(0x05b8 + seg, 0x0002) + seg);
    memory16set(0x05ba + seg, 0x0000, memory16get(0x05ba + seg, 0x0000) + seg);
    memory16set(0x05be + seg, 0x0006, memory16get(0x05be + seg, 0x0006) + seg);
    memory16set(0x05bf + seg, 0x0009, memory16get(0x05bf + seg, 0x0009) + seg);
    memory16set(0x05c4 + seg, 0x0002, memory16get(0x05c4 + seg, 0x0002) + seg);
    memory16set(0x05c5 + seg, 0x0005, memory16get(0x05c5 + seg, 0x0005) + seg);
    memory16set(0x05cd + seg, 0x0009, memory16get(0x05cd + seg, 0x0009) + seg);
    memory16set(0x05cf + seg, 0x0007, memory16get(0x05cf + seg, 0x0007) + seg);
    memory16set(0x05f2 + seg, 0x0000, memory16get(0x05f2 + seg, 0x0000) + seg);
    memory16set(0x0604 + seg, 0x0003, memory16get(0x0604 + seg, 0x0003) + seg);
    memory16set(0x0605 + seg, 0x0008, memory16get(0x0605 + seg, 0x0008) + seg);
    memory16set(0x0608 + seg, 0x0004, memory16get(0x0608 + seg, 0x0004) + seg);
    memory16set(0x061e + seg, 0x0009, memory16get(0x061e + seg, 0x0009) + seg);
    memory16set(0x063d + seg, 0x000f, memory16get(0x063d + seg, 0x000f) + seg);
    memory16set(0x0650 + seg, 0x0005, memory16get(0x0650 + seg, 0x0005) + seg);
    memory16set(0x0651 + seg, 0x0009, memory16get(0x0651 + seg, 0x0009) + seg);
    memory16set(0x0653 + seg, 0x000f, memory16get(0x0653 + seg, 0x000f) + seg);
    memory16set(0x0663 + seg, 0x000a, memory16get(0x0663 + seg, 0x000a) + seg);
    memory16set(0x0687 + seg, 0x0002, memory16get(0x0687 + seg, 0x0002) + seg);
    memory16set(0x0689 + seg, 0x0000, memory16get(0x0689 + seg, 0x0000) + seg);
    memory16set(0x0690 + seg, 0x0003, memory16get(0x0690 + seg, 0x0003) + seg);
    memory16set(0x0691 + seg, 0x0007, memory16get(0x0691 + seg, 0x0007) + seg);
    memory16set(0x0694 + seg, 0x0000, memory16get(0x0694 + seg, 0x0000) + seg);
    memory16set(0x069f + seg, 0x0004, memory16get(0x069f + seg, 0x0004) + seg);
    memory16set(0x06a4 + seg, 0x0003, memory16get(0x06a4 + seg, 0x0003) + seg);
    memory16set(0x06a9 + seg, 0x0001, memory16get(0x06a9 + seg, 0x0001) + seg);
    memory16set(0x06b1 + seg, 0x000b, memory16get(0x06b1 + seg, 0x000b) + seg);
    memory16set(0x06b6 + seg, 0x0005, memory16get(0x06b6 + seg, 0x0005) + seg);
    memory16set(0x06ba + seg, 0x000f, memory16get(0x06ba + seg, 0x000f) + seg);
    memory16set(0x06c3 + seg, 0x000f, memory16get(0x06c3 + seg, 0x000f) + seg);
    memory16set(0x06cf + seg, 0x0008, memory16get(0x06cf + seg, 0x0008) + seg);
    memory16set(0x06d2 + seg, 0x0009, memory16get(0x06d2 + seg, 0x0009) + seg);
    memory16set(0x06d5 + seg, 0x0005, memory16get(0x06d5 + seg, 0x0005) + seg);
    memory16set(0x06dd + seg, 0x0000, memory16get(0x06dd + seg, 0x0000) + seg);
    memory16set(0x06e2 + seg, 0x000d, memory16get(0x06e2 + seg, 0x000d) + seg);
    memory16set(0x06e3 + seg, 0x000e, memory16get(0x06e3 + seg, 0x000e) + seg);
    memory16set(0x06e7 + seg, 0x000e, memory16get(0x06e7 + seg, 0x000e) + seg);
    memory16set(0x06f5 + seg, 0x000e, memory16get(0x06f5 + seg, 0x000e) + seg);
    memory16set(0x070b + seg, 0x0007, memory16get(0x070b + seg, 0x0007) + seg);
    memory16set(0x0711 + seg, 0x0008, memory16get(0x0711 + seg, 0x0008) + seg);
    memory16set(0x0713 + seg, 0x0006, memory16get(0x0713 + seg, 0x0006) + seg);
    memory16set(0x071c + seg, 0x000f, memory16get(0x071c + seg, 0x000f) + seg);
    memory16set(0x073a + seg, 0x000f, memory16get(0x073a + seg, 0x000f) + seg);
    memory16set(0x074d + seg, 0x0006, memory16get(0x074d + seg, 0x0006) + seg);
    memory16set(0x074e + seg, 0x000a, memory16get(0x074e + seg, 0x000a) + seg);
    memory16set(0x0751 + seg, 0x0000, memory16get(0x0751 + seg, 0x0000) + seg);
    memory16set(0x0753 + seg, 0x0002, memory16get(0x0753 + seg, 0x0002) + seg);
    memory16set(0x0757 + seg, 0x0005, memory16get(0x0757 + seg, 0x0005) + seg);
    memory16set(0x0759 + seg, 0x0000, memory16get(0x0759 + seg, 0x0000) + seg);
    memory16set(0x075c + seg, 0x0008, memory16get(0x075c + seg, 0x0008) + seg);
    memory16set(0x0760 + seg, 0x0008, memory16get(0x0760 + seg, 0x0008) + seg);
    memory16set(0x0763 + seg, 0x0007, memory16get(0x0763 + seg, 0x0007) + seg);
    memory16set(0x0785 + seg, 0x0007, memory16get(0x0785 + seg, 0x0007) + seg);
    memory16set(0x0795 + seg, 0x0007, memory16get(0x0795 + seg, 0x0007) + seg);
    memory16set(0x0796 + seg, 0x000b, memory16get(0x0796 + seg, 0x000b) + seg);
    memory16set(0x0799 + seg, 0x0001, memory16get(0x0799 + seg, 0x0001) + seg);
    memory16set(0x079e + seg, 0x000a, memory16get(0x079e + seg, 0x000a) + seg);
    memory16set(0x07a0 + seg, 0x0005, memory16get(0x07a0 + seg, 0x0005) + seg);
    memory16set(0x07a3 + seg, 0x000d, memory16get(0x07a3 + seg, 0x000d) + seg);
    memory16set(0x07a5 + seg, 0x0004, memory16get(0x07a5 + seg, 0x0004) + seg);
    memory16set(0x07b2 + seg, 0x000f, memory16get(0x07b2 + seg, 0x000f) + seg);
    memory16set(0x07b4 + seg, 0x000d, memory16get(0x07b4 + seg, 0x000d) + seg);
    memory16set(0x07d9 + seg, 0x0003, memory16get(0x07d9 + seg, 0x0003) + seg);
    memory16set(0x07db + seg, 0x0001, memory16get(0x07db + seg, 0x0001) + seg);
    memory16set(0x07e1 + seg, 0x000d, memory16get(0x07e1 + seg, 0x000d) + seg);
    memory16set(0x07e3 + seg, 0x0001, memory16get(0x07e3 + seg, 0x0001) + seg);
    memory16set(0x07e5 + seg, 0x000c, memory16get(0x07e5 + seg, 0x000c) + seg);
    memory16set(0x07f3 + seg, 0x000f, memory16get(0x07f3 + seg, 0x000f) + seg);
    memory16set(0x07f5 + seg, 0x0006, memory16get(0x07f5 + seg, 0x0006) + seg);
    memory16set(0x0804 + seg, 0x000f, memory16get(0x0804 + seg, 0x000f) + seg);
    memory16set(0x0810 + seg, 0x0008, memory16get(0x0810 + seg, 0x0008) + seg);
    memory16set(0x0813 + seg, 0x0009, memory16get(0x0813 + seg, 0x0009) + seg);
    memory16set(0x081b + seg, 0x0001, memory16get(0x081b + seg, 0x0001) + seg);
    memory16set(0x081b + seg, 0x000e, memory16get(0x081b + seg, 0x000e) + seg);
    memory16set(0x081c + seg, 0x000e, memory16get(0x081c + seg, 0x000e) + seg);
    memory16set(0x081f + seg, 0x0001, memory16get(0x081f + seg, 0x0001) + seg);
    memory16set(0x0822 + seg, 0x000e, memory16get(0x0822 + seg, 0x000e) + seg);
    memory16set(0x0827 + seg, 0x0006, memory16get(0x0827 + seg, 0x0006) + seg);
    memory16set(0x082e + seg, 0x0002, memory16get(0x082e + seg, 0x0002) + seg);
    memory16set(0x082e + seg, 0x000a, memory16get(0x082e + seg, 0x000a) + seg);
    memory16set(0x0835 + seg, 0x000b, memory16get(0x0835 + seg, 0x000b) + seg);
    memory16set(0x083a + seg, 0x000b, memory16get(0x083a + seg, 0x000b) + seg);
    memory16set(0x083b + seg, 0x000e, memory16get(0x083b + seg, 0x000e) + seg);
    memory16set(0x083d + seg, 0x0001, memory16get(0x083d + seg, 0x0001) + seg);
    memory16set(0x083e + seg, 0x0002, memory16get(0x083e + seg, 0x0002) + seg);
    memory16set(0x0842 + seg, 0x0005, memory16get(0x0842 + seg, 0x0005) + seg);
    memory16set(0x0843 + seg, 0x0000, memory16get(0x0843 + seg, 0x0000) + seg);
    memory16set(0x0846 + seg, 0x000d, memory16get(0x0846 + seg, 0x000d) + seg);
    memory16set(0x0848 + seg, 0x0009, memory16get(0x0848 + seg, 0x0009) + seg);
    memory16set(0x0849 + seg, 0x000c, memory16get(0x0849 + seg, 0x000c) + seg);
    memory16set(0x084a + seg, 0x000e, memory16get(0x084a + seg, 0x000e) + seg);
    memory16set(0x084d + seg, 0x0004, memory16get(0x084d + seg, 0x0004) + seg);
    memory16set(0x084d + seg, 0x000b, memory16get(0x084d + seg, 0x000b) + seg);
    memory16set(0x084e + seg, 0x0003, memory16get(0x084e + seg, 0x0003) + seg);
    memory16set(0x0862 + seg, 0x0004, memory16get(0x0862 + seg, 0x0004) + seg);
    memory16set(0x086e + seg, 0x0002, memory16get(0x086e + seg, 0x0002) + seg);
    memory16set(0x0870 + seg, 0x000b, memory16get(0x0870 + seg, 0x000b) + seg);
    memory16set(0x0879 + seg, 0x0003, memory16get(0x0879 + seg, 0x0003) + seg);
    memory16set(0x087c + seg, 0x0005, memory16get(0x087c + seg, 0x0005) + seg);
    memory16set(0x087e + seg, 0x000d, memory16get(0x087e + seg, 0x000d) + seg);
    memory16set(0x0880 + seg, 0x0008, memory16get(0x0880 + seg, 0x0008) + seg);
    memory16set(0x0882 + seg, 0x0001, memory16get(0x0882 + seg, 0x0001) + seg);
    memory16set(0x0883 + seg, 0x0001, memory16get(0x0883 + seg, 0x0001) + seg);
    memory16set(0x0885 + seg, 0x0001, memory16get(0x0885 + seg, 0x0001) + seg);
    memory16set(0x0886 + seg, 0x0001, memory16get(0x0886 + seg, 0x0001) + seg);
    memory16set(0x0889 + seg, 0x0000, memory16get(0x0889 + seg, 0x0000) + seg);
    memory16set(0x088a + seg, 0x0009, memory16get(0x088a + seg, 0x0009) + seg);
    memory16set(0x088b + seg, 0x0009, memory16get(0x088b + seg, 0x0009) + seg);
    memory16set(0x088d + seg, 0x000e, memory16get(0x088d + seg, 0x000e) + seg);
    memory16set(0x0896 + seg, 0x0001, memory16get(0x0896 + seg, 0x0001) + seg);
    memory16set(0x089b + seg, 0x0005, memory16get(0x089b + seg, 0x0005) + seg);
    memory16set(0x08a3 + seg, 0x0008, memory16get(0x08a3 + seg, 0x0008) + seg);
    memory16set(0x08af + seg, 0x000c, memory16get(0x08af + seg, 0x000c) + seg);
    memory16set(0x08b2 + seg, 0x0000, memory16get(0x08b2 + seg, 0x0000) + seg);
    memory16set(0x08b4 + seg, 0x000c, memory16get(0x08b4 + seg, 0x000c) + seg);
    memory16set(0x08b5 + seg, 0x0003, memory16get(0x08b5 + seg, 0x0003) + seg);
    memory16set(0x08b5 + seg, 0x000a, memory16get(0x08b5 + seg, 0x000a) + seg);
    memory16set(0x08bd + seg, 0x0004, memory16get(0x08bd + seg, 0x0004) + seg);
    memory16set(0x08c3 + seg, 0x0006, memory16get(0x08c3 + seg, 0x0006) + seg);
    memory16set(0x08e6 + seg, 0x0005, memory16get(0x08e6 + seg, 0x0005) + seg);
    memory16set(0x08e7 + seg, 0x0004, memory16get(0x08e7 + seg, 0x0004) + seg);
    memory16set(0x08e9 + seg, 0x0001, memory16get(0x08e9 + seg, 0x0001) + seg);
    memory16set(0x08ea + seg, 0x0003, memory16get(0x08ea + seg, 0x0003) + seg);
    memory16set(0x08eb + seg, 0x0005, memory16get(0x08eb + seg, 0x0005) + seg);
    memory16set(0x08ef + seg, 0x0005, memory16get(0x08ef + seg, 0x0005) + seg);
    memory16set(0x08f0 + seg, 0x0008, memory16get(0x08f0 + seg, 0x0008) + seg);
    memory16set(0x08f1 + seg, 0x0001, memory16get(0x08f1 + seg, 0x0001) + seg);
    memory16set(0x08f1 + seg, 0x000c, memory16get(0x08f1 + seg, 0x000c) + seg);
    memory16set(0x08f3 + seg, 0x0001, memory16get(0x08f3 + seg, 0x0001) + seg);
    memory16set(0x08f4 + seg, 0x0005, memory16get(0x08f4 + seg, 0x0005) + seg);
    memory16set(0x08f5 + seg, 0x0009, memory16get(0x08f5 + seg, 0x0009) + seg);
    memory16set(0x0908 + seg, 0x0006, memory16get(0x0908 + seg, 0x0006) + seg);
    memory16set(0x0914 + seg, 0x0009, memory16get(0x0914 + seg, 0x0009) + seg);
    memory16set(0x0920 + seg, 0x000c, memory16get(0x0920 + seg, 0x000c) + seg);
    memory16set(0x0932 + seg, 0x0004, memory16get(0x0932 + seg, 0x0004) + seg);
    memory16set(0x093f + seg, 0x000a, memory16get(0x093f + seg, 0x000a) + seg);
    memory16set(0x094a + seg, 0x0009, memory16get(0x094a + seg, 0x0009) + seg);
    memory16set(0x0960 + seg, 0x0001, memory16get(0x0960 + seg, 0x0001) + seg);
    memory16set(0x0962 + seg, 0x0004, memory16get(0x0962 + seg, 0x0004) + seg);
    memory16set(0x0973 + seg, 0x0003, memory16get(0x0973 + seg, 0x0003) + seg);
    memory16set(0x0975 + seg, 0x0006, memory16get(0x0975 + seg, 0x0006) + seg);
    memory16set(0x0981 + seg, 0x0009, memory16get(0x0981 + seg, 0x0009) + seg);
    memory16set(0x0993 + seg, 0x0009, memory16get(0x0993 + seg, 0x0009) + seg);
    memory16set(0x09a1 + seg, 0x0003, memory16get(0x09a1 + seg, 0x0003) + seg);
    memory16set(0x09ac + seg, 0x0004, memory16get(0x09ac + seg, 0x0004) + seg);
    memory16set(0x09b3 + seg, 0x0005, memory16get(0x09b3 + seg, 0x0005) + seg);
    memory16set(0x09b6 + seg, 0x0001, memory16get(0x09b6 + seg, 0x0001) + seg);
    memory16set(0x0a8f + seg, 0x000d, memory16get(0x0a8f + seg, 0x000d) + seg);
    memory16set(0x0b25 + seg, 0x0007, memory16get(0x0b25 + seg, 0x0007) + seg);
    memory16set(0x0b25 + seg, 0x000d, memory16get(0x0b25 + seg, 0x000d) + seg);
    memory16set(0x0b2d + seg, 0x0005, memory16get(0x0b2d + seg, 0x0005) + seg);
    memory16set(0x0b2d + seg, 0x000b, memory16get(0x0b2d + seg, 0x000b) + seg);
    memory16set(0x0b33 + seg, 0x000b, memory16get(0x0b33 + seg, 0x000b) + seg);
    memory16set(0x0b34 + seg, 0x0001, memory16get(0x0b34 + seg, 0x0001) + seg);
    memory16set(0x0c5c + seg, 0x0006, memory16get(0x0c5c + seg, 0x0006) + seg);
    memory16set(0x0c61 + seg, 0x0007, memory16get(0x0c61 + seg, 0x0007) + seg);
    memory16set(0x0c68 + seg, 0x0008, memory16get(0x0c68 + seg, 0x0008) + seg);
    memory16set(0x0c6c + seg, 0x0005, memory16get(0x0c6c + seg, 0x0005) + seg);
    memory16set(0x0d0b + seg, 0x0005, memory16get(0x0d0b + seg, 0x0005) + seg);
    memory16set(0x0d0f + seg, 0x000f, memory16get(0x0d0f + seg, 0x000f) + seg);
    memory16set(0x0d11 + seg, 0x0008, memory16get(0x0d11 + seg, 0x0008) + seg);
    memory16set(0x0d12 + seg, 0x0004, memory16get(0x0d12 + seg, 0x0004) + seg);
    memory16set(0x0d13 + seg, 0x0003, memory16get(0x0d13 + seg, 0x0003) + seg);
    memory16set(0x0d13 + seg, 0x000e, memory16get(0x0d13 + seg, 0x000e) + seg);
    memory16set(0x0d15 + seg, 0x0003, memory16get(0x0d15 + seg, 0x0003) + seg);
    memory16set(0x0d16 + seg, 0x0007, memory16get(0x0d16 + seg, 0x0007) + seg);
    memory16set(0x0d1f + seg, 0x0001, memory16get(0x0d1f + seg, 0x0001) + seg);
    memory16set(0x0d20 + seg, 0x000c, memory16get(0x0d20 + seg, 0x000c) + seg);
    memory16set(0x0d24 + seg, 0x0007, memory16get(0x0d24 + seg, 0x0007) + seg);
    memory16set(0x0d25 + seg, 0x0005, memory16get(0x0d25 + seg, 0x0005) + seg);
    memory16set(0x0d27 + seg, 0x0002, memory16get(0x0d27 + seg, 0x0002) + seg);
    memory16set(0x0d29 + seg, 0x0007, memory16get(0x0d29 + seg, 0x0007) + seg);
    memory16set(0x0d2d + seg, 0x0003, memory16get(0x0d2d + seg, 0x0003) + seg);
    memory16set(0x0d33 + seg, 0x0008, memory16get(0x0d33 + seg, 0x0008) + seg);
    memory16set(0x0d35 + seg, 0x000a, memory16get(0x0d35 + seg, 0x000a) + seg);
    memory16set(0x0d36 + seg, 0x0005, memory16get(0x0d36 + seg, 0x0005) + seg);
    memory16set(0x0d36 + seg, 0x000c, memory16get(0x0d36 + seg, 0x000c) + seg);
    memory16set(0x0d37 + seg, 0x0006, memory16get(0x0d37 + seg, 0x0006) + seg);
    memory16set(0x0d38 + seg, 0x0003, memory16get(0x0d38 + seg, 0x0003) + seg);
    memory16set(0x0d38 + seg, 0x000a, memory16get(0x0d38 + seg, 0x000a) + seg);
    memory16set(0x0d3b + seg, 0x0000, memory16get(0x0d3b + seg, 0x0000) + seg);
    memory16set(0x0d3d + seg, 0x000b, memory16get(0x0d3d + seg, 0x000b) + seg);
    memory16set(0x0d41 + seg, 0x0000, memory16get(0x0d41 + seg, 0x0000) + seg);
    memory16set(0x0d43 + seg, 0x0006, memory16get(0x0d43 + seg, 0x0006) + seg);
    memory16set(0x0d46 + seg, 0x000b, memory16get(0x0d46 + seg, 0x000b) + seg);
    memory16set(0x0d48 + seg, 0x000f, memory16get(0x0d48 + seg, 0x000f) + seg);
    memory16set(0x0d56 + seg, 0x0006, memory16get(0x0d56 + seg, 0x0006) + seg);
    memory16set(0x0d6f + seg, 0x0000, memory16get(0x0d6f + seg, 0x0000) + seg);
    memory16set(0x0dc9 + seg, 0x0005, memory16get(0x0dc9 + seg, 0x0005) + seg);
    memory16set(0x0df2 + seg, 0x0004, memory16get(0x0df2 + seg, 0x0004) + seg);
    memory16set(0x0df5 + seg, 0x000d, memory16get(0x0df5 + seg, 0x000d) + seg);
    memory16set(0x0e17 + seg, 0x0002, memory16get(0x0e17 + seg, 0x0002) + seg);
    memory16set(0x0e75 + seg, 0x0003, memory16get(0x0e75 + seg, 0x0003) + seg);
    memory16set(0x0e7a + seg, 0x0005, memory16get(0x0e7a + seg, 0x0005) + seg);
    memory16set(0x0e7b + seg, 0x0003, memory16get(0x0e7b + seg, 0x0003) + seg);
    memory16set(0x0e7c + seg, 0x0009, memory16get(0x0e7c + seg, 0x0009) + seg);
    memory16set(0x0e7d + seg, 0x0000, memory16get(0x0e7d + seg, 0x0000) + seg);
    memory16set(0x0e7d + seg, 0x000b, memory16get(0x0e7d + seg, 0x000b) + seg);
    memory16set(0x0e7f + seg, 0x000f, memory16get(0x0e7f + seg, 0x000f) + seg);
    memory16set(0x0e82 + seg, 0x000a, memory16get(0x0e82 + seg, 0x000a) + seg);
    memory16set(0x0e96 + seg, 0x0001, memory16get(0x0e96 + seg, 0x0001) + seg);
    memory16set(0x0e96 + seg, 0x0007, memory16get(0x0e96 + seg, 0x0007) + seg);
    memory16set(0x0e98 + seg, 0x0006, memory16get(0x0e98 + seg, 0x0006) + seg);
    memory16set(0x0e99 + seg, 0x000f, memory16get(0x0e99 + seg, 0x000f) + seg);
    memory16set(0x0e9b + seg, 0x0001, memory16get(0x0e9b + seg, 0x0001) + seg);
    memory16set(0x0e9c + seg, 0x0003, memory16get(0x0e9c + seg, 0x0003) + seg);
    memory16set(0x0e9d + seg, 0x0005, memory16get(0x0e9d + seg, 0x0005) + seg);
    memory16set(0x0e9e + seg, 0x0007, memory16get(0x0e9e + seg, 0x0007) + seg);
    memory16set(0x0e9f + seg, 0x0009, memory16get(0x0e9f + seg, 0x0009) + seg);
    memory16set(0x0ea0 + seg, 0x0002, memory16get(0x0ea0 + seg, 0x0002) + seg);
    memory16set(0x0ea1 + seg, 0x0006, memory16get(0x0ea1 + seg, 0x0006) + seg);
    memory16set(0x0ea6 + seg, 0x000d, memory16get(0x0ea6 + seg, 0x000d) + seg);
    memory16set(0x0ea9 + seg, 0x0004, memory16get(0x0ea9 + seg, 0x0004) + seg);
    memory16set(0x0eae + seg, 0x0007, memory16get(0x0eae + seg, 0x0007) + seg);
    memory16set(0x0eaf + seg, 0x000a, memory16get(0x0eaf + seg, 0x000a) + seg);
    memory16set(0x0eb2 + seg, 0x0001, memory16get(0x0eb2 + seg, 0x0001) + seg);
    memory16set(0x0eb4 + seg, 0x000c, memory16get(0x0eb4 + seg, 0x000c) + seg);
    memory16set(0x0eb7 + seg, 0x0005, memory16get(0x0eb7 + seg, 0x0005) + seg);
    memory16set(0x0ebd + seg, 0x0005, memory16get(0x0ebd + seg, 0x0005) + seg);
    memory16set(0x0ebd + seg, 0x000c, memory16get(0x0ebd + seg, 0x000c) + seg);
    memory16set(0x0ebe + seg, 0x0004, memory16get(0x0ebe + seg, 0x0004) + seg);
    memory16set(0x0ec2 + seg, 0x0001, memory16get(0x0ec2 + seg, 0x0001) + seg);
    memory16set(0x0ec5 + seg, 0x000b, memory16get(0x0ec5 + seg, 0x000b) + seg);
    memory16set(0x0ece + seg, 0x0004, memory16get(0x0ece + seg, 0x0004) + seg);
    memory16set(0x0ed1 + seg, 0x000b, memory16get(0x0ed1 + seg, 0x000b) + seg);
    memory16set(0x0ed2 + seg, 0x0002, memory16get(0x0ed2 + seg, 0x0002) + seg);
    memory16set(0x0ed3 + seg, 0x0005, memory16get(0x0ed3 + seg, 0x0005) + seg);
    memory16set(0x0ed8 + seg, 0x000a, memory16get(0x0ed8 + seg, 0x000a) + seg);
    memory16set(0x0ee6 + seg, 0x000a, memory16get(0x0ee6 + seg, 0x000a) + seg);
    memory16set(0x0ef9 + seg, 0x0007, memory16get(0x0ef9 + seg, 0x0007) + seg);
    memory16set(0x0efa + seg, 0x0003, memory16get(0x0efa + seg, 0x0003) + seg);
    memory16set(0x0efb + seg, 0x0000, memory16get(0x0efb + seg, 0x0000) + seg);
    memory16set(0x0efb + seg, 0x0009, memory16get(0x0efb + seg, 0x0009) + seg);
    memory16set(0x0efe + seg, 0x0006, memory16get(0x0efe + seg, 0x0006) + seg);
    memory16set(0x0f00 + seg, 0x0003, memory16get(0x0f00 + seg, 0x0003) + seg);
    memory16set(0x0f00 + seg, 0x000a, memory16get(0x0f00 + seg, 0x000a) + seg);
    memory16set(0x0f01 + seg, 0x0008, memory16get(0x0f01 + seg, 0x0008) + seg);
    memory16set(0x0f15 + seg, 0x000a, memory16get(0x0f15 + seg, 0x000a) + seg);
    memory16set(0x0f17 + seg, 0x0009, memory16get(0x0f17 + seg, 0x0009) + seg);
    memory16set(0x0f18 + seg, 0x000c, memory16get(0x0f18 + seg, 0x000c) + seg);
    memory16set(0x0f1b + seg, 0x0000, memory16get(0x0f1b + seg, 0x0000) + seg);
    memory16set(0x0f1c + seg, 0x0002, memory16get(0x0f1c + seg, 0x0002) + seg);
    memory16set(0x0f1d + seg, 0x0000, memory16get(0x0f1d + seg, 0x0000) + seg);
    memory16set(0x0f24 + seg, 0x0002, memory16get(0x0f24 + seg, 0x0002) + seg);
    memory16set(0x0f25 + seg, 0x0000, memory16get(0x0f25 + seg, 0x0000) + seg);
    memory16set(0x0f26 + seg, 0x0001, memory16get(0x0f26 + seg, 0x0001) + seg);
    memory16set(0x0f2a + seg, 0x0007, memory16get(0x0f2a + seg, 0x0007) + seg);
    memory16set(0x0f2b + seg, 0x0004, memory16get(0x0f2b + seg, 0x0004) + seg);
    memory16set(0x0f31 + seg, 0x000c, memory16get(0x0f31 + seg, 0x000c) + seg);
    memory16set(0x0f32 + seg, 0x000f, memory16get(0x0f32 + seg, 0x000f) + seg);
    memory16set(0x0f38 + seg, 0x000a, memory16get(0x0f38 + seg, 0x000a) + seg);
    memory16set(0x0f3d + seg, 0x000a, memory16get(0x0f3d + seg, 0x000a) + seg);
    memory16set(0x0f41 + seg, 0x000d, memory16get(0x0f41 + seg, 0x000d) + seg);
    memory16set(0x0f46 + seg, 0x000b, memory16get(0x0f46 + seg, 0x000b) + seg);
    memory16set(0x0f4e + seg, 0x0009, memory16get(0x0f4e + seg, 0x0009) + seg);
    memory16set(0x0f50 + seg, 0x0006, memory16get(0x0f50 + seg, 0x0006) + seg);
    memory16set(0x0f56 + seg, 0x0003, memory16get(0x0f56 + seg, 0x0003) + seg);
    memory16set(0x0f58 + seg, 0x000d, memory16get(0x0f58 + seg, 0x000d) + seg);
    memory16set(0x0f76 + seg, 0x000d, memory16get(0x0f76 + seg, 0x000d) + seg);
    memory16set(0x0f77 + seg, 0x0005, memory16get(0x0f77 + seg, 0x0005) + seg);
    memory16set(0x0f79 + seg, 0x0001, memory16get(0x0f79 + seg, 0x0001) + seg);
    memory16set(0x0f7b + seg, 0x0005, memory16get(0x0f7b + seg, 0x0005) + seg);
    memory16set(0x0f7c + seg, 0x0005, memory16get(0x0f7c + seg, 0x0005) + seg);
    memory16set(0x0f7d + seg, 0x0004, memory16get(0x0f7d + seg, 0x0004) + seg);
    memory16set(0x0f80 + seg, 0x0002, memory16get(0x0f80 + seg, 0x0002) + seg);
    memory16set(0x0f83 + seg, 0x0001, memory16get(0x0f83 + seg, 0x0001) + seg);
    memory16set(0x0f85 + seg, 0x000e, memory16get(0x0f85 + seg, 0x000e) + seg);
    memory16set(0x0f88 + seg, 0x0006, memory16get(0x0f88 + seg, 0x0006) + seg);
    memory16set(0x0f89 + seg, 0x0004, memory16get(0x0f89 + seg, 0x0004) + seg);
    memory16set(0x0f8a + seg, 0x0006, memory16get(0x0f8a + seg, 0x0006) + seg);
    memory16set(0x0f8b + seg, 0x0005, memory16get(0x0f8b + seg, 0x0005) + seg);
    memory16set(0x0f8c + seg, 0x0004, memory16get(0x0f8c + seg, 0x0004) + seg);
    memory16set(0x0f8f + seg, 0x0002, memory16get(0x0f8f + seg, 0x0002) + seg);
    memory16set(0x0f95 + seg, 0x0007, memory16get(0x0f95 + seg, 0x0007) + seg);
    memory16set(0x0f98 + seg, 0x0004, memory16get(0x0f98 + seg, 0x0004) + seg);
    memory16set(0x0fde + seg, 0x000d, memory16get(0x0fde + seg, 0x000d) + seg);
    memory16set(0x0fdf + seg, 0x0008, memory16get(0x0fdf + seg, 0x0008) + seg);
    memory16set(0x0fe0 + seg, 0x000d, memory16get(0x0fe0 + seg, 0x000d) + seg);
    memory16set(0x0fe1 + seg, 0x0006, memory16get(0x0fe1 + seg, 0x0006) + seg);
    memory16set(0x0fe2 + seg, 0x000c, memory16get(0x0fe2 + seg, 0x000c) + seg);
    memory16set(0x0fe4 + seg, 0x0003, memory16get(0x0fe4 + seg, 0x0003) + seg);
    memory16set(0x0fe7 + seg, 0x000b, memory16get(0x0fe7 + seg, 0x000b) + seg);
    memory16set(0x0fe8 + seg, 0x0007, memory16get(0x0fe8 + seg, 0x0007) + seg);
    memory16set(0x0fe9 + seg, 0x0003, memory16get(0x0fe9 + seg, 0x0003) + seg);
    memory16set(0x0fe9 + seg, 0x000e, memory16get(0x0fe9 + seg, 0x000e) + seg);
    memory16set(0x0fec + seg, 0x0001, memory16get(0x0fec + seg, 0x0001) + seg);
    memory16set(0x0fed + seg, 0x0007, memory16get(0x0fed + seg, 0x0007) + seg);
    memory16set(0x0fef + seg, 0x0007, memory16get(0x0fef + seg, 0x0007) + seg);
    memory16set(0x0fef + seg, 0x000e, memory16get(0x0fef + seg, 0x000e) + seg);
    memory16set(0x0ff2 + seg, 0x000c, memory16get(0x0ff2 + seg, 0x000c) + seg);
    memory16set(0x0ff4 + seg, 0x0001, memory16get(0x0ff4 + seg, 0x0001) + seg);
    memory16set(0x0ff7 + seg, 0x000e, memory16get(0x0ff7 + seg, 0x000e) + seg);
    memory16set(0x0ff8 + seg, 0x0005, memory16get(0x0ff8 + seg, 0x0005) + seg);
    memory16set(0x1000 + seg, 0x0007, memory16get(0x1000 + seg, 0x0007) + seg);
    memory16set(0x1002 + seg, 0x0009, memory16get(0x1002 + seg, 0x0009) + seg);
    memory16set(0x1008 + seg, 0x000f, memory16get(0x1008 + seg, 0x000f) + seg);
    memory16set(0x100a + seg, 0x0007, memory16get(0x100a + seg, 0x0007) + seg);
    memory16set(0x100e + seg, 0x0002, memory16get(0x100e + seg, 0x0002) + seg);
    memory16set(0x1011 + seg, 0x000e, memory16get(0x1011 + seg, 0x000e) + seg);
    memory16set(0x1013 + seg, 0x000e, memory16get(0x1013 + seg, 0x000e) + seg);
    memory16set(0x1016 + seg, 0x0005, memory16get(0x1016 + seg, 0x0005) + seg);
    memory16set(0x1017 + seg, 0x0000, memory16get(0x1017 + seg, 0x0000) + seg);
    memory16set(0x1018 + seg, 0x0004, memory16get(0x1018 + seg, 0x0004) + seg);
    memory16set(0x101b + seg, 0x000d, memory16get(0x101b + seg, 0x000d) + seg);
    memory16set(0x101e + seg, 0x0001, memory16get(0x101e + seg, 0x0001) + seg);
    memory16set(0x1020 + seg, 0x0000, memory16get(0x1020 + seg, 0x0000) + seg);
    memory16set(0x1021 + seg, 0x0003, memory16get(0x1021 + seg, 0x0003) + seg);
    memory16set(0x1023 + seg, 0x0004, memory16get(0x1023 + seg, 0x0004) + seg);
    memory16set(0x1024 + seg, 0x0008, memory16get(0x1024 + seg, 0x0008) + seg);
    memory16set(0x1025 + seg, 0x000c, memory16get(0x1025 + seg, 0x000c) + seg);
    memory16set(0x1027 + seg, 0x0000, memory16get(0x1027 + seg, 0x0000) + seg);
    memory16set(0x1028 + seg, 0x0004, memory16get(0x1028 + seg, 0x0004) + seg);
    memory16set(0x1029 + seg, 0x0008, memory16get(0x1029 + seg, 0x0008) + seg);
    memory16set(0x102c + seg, 0x0001, memory16get(0x102c + seg, 0x0001) + seg);
    memory16set(0x1031 + seg, 0x0007, memory16get(0x1031 + seg, 0x0007) + seg);
    memory16set(0x103a + seg, 0x0001, memory16get(0x103a + seg, 0x0001) + seg);
    memory16set(0x103a + seg, 0x000a, memory16get(0x103a + seg, 0x000a) + seg);
    memory16set(0x103b + seg, 0x0004, memory16get(0x103b + seg, 0x0004) + seg);
    memory16set(0x103b + seg, 0x000e, memory16get(0x103b + seg, 0x000e) + seg);
    memory16set(0x103c + seg, 0x0008, memory16get(0x103c + seg, 0x0008) + seg);
    memory16set(0x103d + seg, 0x0002, memory16get(0x103d + seg, 0x0002) + seg);
    memory16set(0x103d + seg, 0x000c, memory16get(0x103d + seg, 0x000c) + seg);
    memory16set(0x103e + seg, 0x0006, memory16get(0x103e + seg, 0x0006) + seg);
    memory16set(0x103f + seg, 0x0007, memory16get(0x103f + seg, 0x0007) + seg);
    memory16set(0x103f + seg, 0x000e, memory16get(0x103f + seg, 0x000e) + seg);
    memory16set(0x1040 + seg, 0x0006, memory16get(0x1040 + seg, 0x0006) + seg);
    memory16set(0x1040 + seg, 0x000e, memory16get(0x1040 + seg, 0x000e) + seg);
    memory16set(0x1041 + seg, 0x0006, memory16get(0x1041 + seg, 0x0006) + seg);
    memory16set(0x1041 + seg, 0x000e, memory16get(0x1041 + seg, 0x000e) + seg);
    memory16set(0x1042 + seg, 0x0006, memory16get(0x1042 + seg, 0x0006) + seg);
    memory16set(0x1042 + seg, 0x000e, memory16get(0x1042 + seg, 0x000e) + seg);
    memory16set(0x104d + seg, 0x000f, memory16get(0x104d + seg, 0x000f) + seg);
    memory16set(0x1050 + seg, 0x0000, memory16get(0x1050 + seg, 0x0000) + seg);
    memory16set(0x1054 + seg, 0x000d, memory16get(0x1054 + seg, 0x000d) + seg);
    memory16set(0x1059 + seg, 0x0002, memory16get(0x1059 + seg, 0x0002) + seg);
    memory16set(0x105d + seg, 0x0007, memory16get(0x105d + seg, 0x0007) + seg);
    memory16set(0x1066 + seg, 0x0009, memory16get(0x1066 + seg, 0x0009) + seg);
    memory16set(0x106a + seg, 0x000e, memory16get(0x106a + seg, 0x000e) + seg);
    memory16set(0x106e + seg, 0x0009, memory16get(0x106e + seg, 0x0009) + seg);
    memory16set(0x1070 + seg, 0x000f, memory16get(0x1070 + seg, 0x000f) + seg);
    memory16set(0x1072 + seg, 0x000c, memory16get(0x1072 + seg, 0x000c) + seg);
    memory16set(0x1073 + seg, 0x000c, memory16get(0x1073 + seg, 0x000c) + seg);
    memory16set(0x1074 + seg, 0x0008, memory16get(0x1074 + seg, 0x0008) + seg);
    memory16set(0x1075 + seg, 0x0009, memory16get(0x1075 + seg, 0x0009) + seg);
    memory16set(0x1076 + seg, 0x0009, memory16get(0x1076 + seg, 0x0009) + seg);
    memory16set(0x1077 + seg, 0x0009, memory16get(0x1077 + seg, 0x0009) + seg);
    memory16set(0x1078 + seg, 0x000b, memory16get(0x1078 + seg, 0x000b) + seg);
    memory16set(0x1079 + seg, 0x000d, memory16get(0x1079 + seg, 0x000d) + seg);
    memory16set(0x107a + seg, 0x000d, memory16get(0x107a + seg, 0x000d) + seg);
    memory16set(0x107e + seg, 0x000e, memory16get(0x107e + seg, 0x000e) + seg);
    memory16set(0x1080 + seg, 0x000f, memory16get(0x1080 + seg, 0x000f) + seg);
    memory16set(0x1083 + seg, 0x0006, memory16get(0x1083 + seg, 0x0006) + seg);
    memory16set(0x1085 + seg, 0x000d, memory16get(0x1085 + seg, 0x000d) + seg);
    memory16set(0x1088 + seg, 0x0006, memory16get(0x1088 + seg, 0x0006) + seg);
    memory16set(0x108a + seg, 0x000f, memory16get(0x108a + seg, 0x000f) + seg);
    memory16set(0x108d + seg, 0x0000, memory16get(0x108d + seg, 0x0000) + seg);
    memory16set(0x108f + seg, 0x0001, memory16get(0x108f + seg, 0x0001) + seg);
    memory16set(0x1093 + seg, 0x0003, memory16get(0x1093 + seg, 0x0003) + seg);
    memory16set(0x1094 + seg, 0x000f, memory16get(0x1094 + seg, 0x000f) + seg);
    memory16set(0x1096 + seg, 0x0009, memory16get(0x1096 + seg, 0x0009) + seg);
    memory16set(0x1099 + seg, 0x0000, memory16get(0x1099 + seg, 0x0000) + seg);
    memory16set(0x109b + seg, 0x0000, memory16get(0x109b + seg, 0x0000) + seg);
    memory16set(0x109c + seg, 0x0004, memory16get(0x109c + seg, 0x0004) + seg);
    memory16set(0x109d + seg, 0x000d, memory16get(0x109d + seg, 0x000d) + seg);
    memory16set(0x10a1 + seg, 0x000f, memory16get(0x10a1 + seg, 0x000f) + seg);
    memory16set(0x10a3 + seg, 0x0004, memory16get(0x10a3 + seg, 0x0004) + seg);
    memory16set(0x10a7 + seg, 0x0003, memory16get(0x10a7 + seg, 0x0003) + seg);
    memory16set(0x10ab + seg, 0x000a, memory16get(0x10ab + seg, 0x000a) + seg);
    memory16set(0x10ac + seg, 0x0003, memory16get(0x10ac + seg, 0x0003) + seg);
    memory16set(0x10ad + seg, 0x0001, memory16get(0x10ad + seg, 0x0001) + seg);
    memory16set(0x10f6 + seg, 0x0003, memory16get(0x10f6 + seg, 0x0003) + seg);
    memory16set(0x10fa + seg, 0x000f, memory16get(0x10fa + seg, 0x000f) + seg);
    memory16set(0x10fd + seg, 0x0009, memory16get(0x10fd + seg, 0x0009) + seg);
    memory16set(0x1114 + seg, 0x0000, memory16get(0x1114 + seg, 0x0000) + seg);
    memory16set(0x1117 + seg, 0x0005, memory16get(0x1117 + seg, 0x0005) + seg);
    memory16set(0x1118 + seg, 0x0007, memory16get(0x1118 + seg, 0x0007) + seg);
    memory16set(0x1119 + seg, 0x0001, memory16get(0x1119 + seg, 0x0001) + seg);
    memory16set(0x1119 + seg, 0x0009, memory16get(0x1119 + seg, 0x0009) + seg);
    memory16set(0x1119 + seg, 0x000e, memory16get(0x1119 + seg, 0x000e) + seg);
    memory16set(0x111b + seg, 0x0001, memory16get(0x111b + seg, 0x0001) + seg);
    memory16set(0x111d + seg, 0x0001, memory16get(0x111d + seg, 0x0001) + seg);
    memory16set(0x111e + seg, 0x0003, memory16get(0x111e + seg, 0x0003) + seg);
    memory16set(0x111f + seg, 0x0005, memory16get(0x111f + seg, 0x0005) + seg);
    memory16set(0x1120 + seg, 0x0007, memory16get(0x1120 + seg, 0x0007) + seg);
    memory16set(0x1121 + seg, 0x0009, memory16get(0x1121 + seg, 0x0009) + seg);
    memory16set(0x1122 + seg, 0x000b, memory16get(0x1122 + seg, 0x000b) + seg);
    memory16set(0x1123 + seg, 0x0004, memory16get(0x1123 + seg, 0x0004) + seg);
    memory16set(0x1129 + seg, 0x000a, memory16get(0x1129 + seg, 0x000a) + seg);
    memory16set(0x1131 + seg, 0x000d, memory16get(0x1131 + seg, 0x000d) + seg);
    memory16set(0x1132 + seg, 0x000e, memory16get(0x1132 + seg, 0x000e) + seg);
    memory16set(0x1133 + seg, 0x000f, memory16get(0x1133 + seg, 0x000f) + seg);
    memory16set(0x1134 + seg, 0x000b, memory16get(0x1134 + seg, 0x000b) + seg);
    memory16set(0x113a + seg, 0x0000, memory16get(0x113a + seg, 0x0000) + seg);
    memory16set(0x113b + seg, 0x0001, memory16get(0x113b + seg, 0x0001) + seg);
    memory16set(0x113c + seg, 0x0008, memory16get(0x113c + seg, 0x0008) + seg);
    memory16set(0x113d + seg, 0x0001, memory16get(0x113d + seg, 0x0001) + seg);
    memory16set(0x113d + seg, 0x000b, memory16get(0x113d + seg, 0x000b) + seg);
    memory16set(0x113e + seg, 0x000e, memory16get(0x113e + seg, 0x000e) + seg);
    memory16set(0x1140 + seg, 0x000a, memory16get(0x1140 + seg, 0x000a) + seg);
    memory16set(0x1141 + seg, 0x0001, memory16get(0x1141 + seg, 0x0001) + seg);
    memory16set(0x1142 + seg, 0x0002, memory16get(0x1142 + seg, 0x0002) + seg);
    memory16set(0x1143 + seg, 0x0003, memory16get(0x1143 + seg, 0x0003) + seg);
    memory16set(0x1144 + seg, 0x000b, memory16get(0x1144 + seg, 0x000b) + seg);
    memory16set(0x1145 + seg, 0x000c, memory16get(0x1145 + seg, 0x000c) + seg);
    memory16set(0x1146 + seg, 0x0005, memory16get(0x1146 + seg, 0x0005) + seg);
    memory16set(0x1146 + seg, 0x000f, memory16get(0x1146 + seg, 0x000f) + seg);
    memory16set(0x1148 + seg, 0x0006, memory16get(0x1148 + seg, 0x0006) + seg);
    memory16set(0x1149 + seg, 0x0008, memory16get(0x1149 + seg, 0x0008) + seg);
    memory16set(0x114a + seg, 0x000a, memory16get(0x114a + seg, 0x000a) + seg);
    memory16set(0x114b + seg, 0x0008, memory16get(0x114b + seg, 0x0008) + seg);
    memory16set(0x114c + seg, 0x0008, memory16get(0x114c + seg, 0x0008) + seg);
    memory16set(0x114d + seg, 0x000d, memory16get(0x114d + seg, 0x000d) + seg);
    memory16set(0x1151 + seg, 0x0004, memory16get(0x1151 + seg, 0x0004) + seg);
    memory16set(0x1155 + seg, 0x0004, memory16get(0x1155 + seg, 0x0004) + seg);
    memory16set(0x1158 + seg, 0x0008, memory16get(0x1158 + seg, 0x0008) + seg);
    memory16set(0x115c + seg, 0x0003, memory16get(0x115c + seg, 0x0003) + seg);
    memory16set(0x115d + seg, 0x0005, memory16get(0x115d + seg, 0x0005) + seg);
    memory16set(0x115e + seg, 0x0007, memory16get(0x115e + seg, 0x0007) + seg);
    memory16set(0x1183 + seg, 0x0006, memory16get(0x1183 + seg, 0x0006) + seg);
    memory16set(0x1184 + seg, 0x0008, memory16get(0x1184 + seg, 0x0008) + seg);
    memory16set(0x1185 + seg, 0x000a, memory16get(0x1185 + seg, 0x000a) + seg);
    memory16set(0x118e + seg, 0x0009, memory16get(0x118e + seg, 0x0009) + seg);
    memory16set(0x1190 + seg, 0x0006, memory16get(0x1190 + seg, 0x0006) + seg);
    memory16set(0x1191 + seg, 0x0002, memory16get(0x1191 + seg, 0x0002) + seg);
    memory16set(0x1193 + seg, 0x0000, memory16get(0x1193 + seg, 0x0000) + seg);
    memory16set(0x1194 + seg, 0x000e, memory16get(0x1194 + seg, 0x000e) + seg);
    memory16set(0x11ab + seg, 0x0003, memory16get(0x11ab + seg, 0x0003) + seg);
    memory16set(0x11ac + seg, 0x000c, memory16get(0x11ac + seg, 0x000c) + seg);
    memory16set(0x11ae + seg, 0x0005, memory16get(0x11ae + seg, 0x0005) + seg);
    memory16set(0x11b3 + seg, 0x000c, memory16get(0x11b3 + seg, 0x000c) + seg);
    memory16set(0x11b5 + seg, 0x0005, memory16get(0x11b5 + seg, 0x0005) + seg);
    memory16set(0x11b6 + seg, 0x000e, memory16get(0x11b6 + seg, 0x000e) + seg);
    memory16set(0x11bc + seg, 0x0002, memory16get(0x11bc + seg, 0x0002) + seg);
    memory16set(0x11bd + seg, 0x000b, memory16get(0x11bd + seg, 0x000b) + seg);
    memory16set(0x11c2 + seg, 0x0005, memory16get(0x11c2 + seg, 0x0005) + seg);
    memory16set(0x11c3 + seg, 0x0004, memory16get(0x11c3 + seg, 0x0004) + seg);
    memory16set(0x11c4 + seg, 0x0003, memory16get(0x11c4 + seg, 0x0003) + seg);
    memory16set(0x11c5 + seg, 0x0002, memory16get(0x11c5 + seg, 0x0002) + seg);
    memory16set(0x11ca + seg, 0x000c, memory16get(0x11ca + seg, 0x000c) + seg);
    memory16set(0x11cc + seg, 0x0000, memory16get(0x11cc + seg, 0x0000) + seg);
    memory16set(0x11d0 + seg, 0x000c, memory16get(0x11d0 + seg, 0x000c) + seg);
    memory16set(0x11d1 + seg, 0x000f, memory16get(0x11d1 + seg, 0x000f) + seg);
    memory16set(0x11d2 + seg, 0x000f, memory16get(0x11d2 + seg, 0x000f) + seg);
    memory16set(0x11d3 + seg, 0x000f, memory16get(0x11d3 + seg, 0x000f) + seg);
    memory16set(0x11d4 + seg, 0x000f, memory16get(0x11d4 + seg, 0x000f) + seg);
    memory16set(0x11d7 + seg, 0x000b, memory16get(0x11d7 + seg, 0x000b) + seg);
    memory16set(0x11d8 + seg, 0x000b, memory16get(0x11d8 + seg, 0x000b) + seg);
    memory16set(0x11d9 + seg, 0x000b, memory16get(0x11d9 + seg, 0x000b) + seg);
    memory16set(0x11da + seg, 0x000b, memory16get(0x11da + seg, 0x000b) + seg);
    memory16set(0x11db + seg, 0x000b, memory16get(0x11db + seg, 0x000b) + seg);
    memory16set(0x11dc + seg, 0x000b, memory16get(0x11dc + seg, 0x000b) + seg);
    memory16set(0x11dd + seg, 0x000b, memory16get(0x11dd + seg, 0x000b) + seg);
    memory16set(0x11df + seg, 0x0004, memory16get(0x11df + seg, 0x0004) + seg);
    memory16set(0x11e0 + seg, 0x0004, memory16get(0x11e0 + seg, 0x0004) + seg);
    memory16set(0x11e1 + seg, 0x0004, memory16get(0x11e1 + seg, 0x0004) + seg);
    memory16set(0x11e2 + seg, 0x0003, memory16get(0x11e2 + seg, 0x0003) + seg);
    memory16set(0x11e2 + seg, 0x0008, memory16get(0x11e2 + seg, 0x0008) + seg);
    memory16set(0x11e2 + seg, 0x000d, memory16get(0x11e2 + seg, 0x000d) + seg);
    memory16set(0x11e4 + seg, 0x0001, memory16get(0x11e4 + seg, 0x0001) + seg);
    memory16set(0x11e5 + seg, 0x0000, memory16get(0x11e5 + seg, 0x0000) + seg);
    memory16set(0x11e5 + seg, 0x0005, memory16get(0x11e5 + seg, 0x0005) + seg);
    memory16set(0x11e6 + seg, 0x0001, memory16get(0x11e6 + seg, 0x0001) + seg);
    memory16set(0x11ea + seg, 0x0009, memory16get(0x11ea + seg, 0x0009) + seg);
    memory16set(0x11ed + seg, 0x0009, memory16get(0x11ed + seg, 0x0009) + seg);
    memory16set(0x11f0 + seg, 0x0009, memory16get(0x11f0 + seg, 0x0009) + seg);
    memory16set(0x11f1 + seg, 0x0007, memory16get(0x11f1 + seg, 0x0007) + seg);
    memory16set(0x11f2 + seg, 0x0000, memory16get(0x11f2 + seg, 0x0000) + seg);
    memory16set(0x11f2 + seg, 0x000a, memory16get(0x11f2 + seg, 0x000a) + seg);
    memory16set(0x11fb + seg, 0x000c, memory16get(0x11fb + seg, 0x000c) + seg);
    memory16set(0x11fc + seg, 0x0007, memory16get(0x11fc + seg, 0x0007) + seg);
    memory16set(0x11fe + seg, 0x0002, memory16get(0x11fe + seg, 0x0002) + seg);
    memory16set(0x11ff + seg, 0x000c, memory16get(0x11ff + seg, 0x000c) + seg);
    memory16set(0x1200 + seg, 0x000b, memory16get(0x1200 + seg, 0x000b) + seg);
    memory16set(0x1201 + seg, 0x000c, memory16get(0x1201 + seg, 0x000c) + seg);
    memory16set(0x1203 + seg, 0x000a, memory16get(0x1203 + seg, 0x000a) + seg);
    memory16set(0x1204 + seg, 0x000d, memory16get(0x1204 + seg, 0x000d) + seg);
    memory16set(0x1205 + seg, 0x0008, memory16get(0x1205 + seg, 0x0008) + seg);
    memory16set(0x1206 + seg, 0x0003, memory16get(0x1206 + seg, 0x0003) + seg);
    memory16set(0x1206 + seg, 0x000e, memory16get(0x1206 + seg, 0x000e) + seg);
    memory16set(0x1207 + seg, 0x000c, memory16get(0x1207 + seg, 0x000c) + seg);
    memory16set(0x1208 + seg, 0x0008, memory16get(0x1208 + seg, 0x0008) + seg);
    memory16set(0x1209 + seg, 0x0009, memory16get(0x1209 + seg, 0x0009) + seg);
    memory16set(0x120a + seg, 0x0006, memory16get(0x120a + seg, 0x0006) + seg);
    memory16set(0x120b + seg, 0x0003, memory16get(0x120b + seg, 0x0003) + seg);
    memory16set(0x120c + seg, 0x0002, memory16get(0x120c + seg, 0x0002) + seg);
    memory16set(0x120e + seg, 0x0002, memory16get(0x120e + seg, 0x0002) + seg);
    memory16set(0x1210 + seg, 0x0005, memory16get(0x1210 + seg, 0x0005) + seg);
    memory16set(0x1211 + seg, 0x000d, memory16get(0x1211 + seg, 0x000d) + seg);
    memory16set(0x1212 + seg, 0x000e, memory16get(0x1212 + seg, 0x000e) + seg);
    memory16set(0x1214 + seg, 0x0005, memory16get(0x1214 + seg, 0x0005) + seg);
    memory16set(0x1215 + seg, 0x000b, memory16get(0x1215 + seg, 0x000b) + seg);
    memory16set(0x1217 + seg, 0x0004, memory16get(0x1217 + seg, 0x0004) + seg);
    memory16set(0x1218 + seg, 0x0001, memory16get(0x1218 + seg, 0x0001) + seg);
    memory16set(0x1218 + seg, 0x0008, memory16get(0x1218 + seg, 0x0008) + seg);
    memory16set(0x1219 + seg, 0x0007, memory16get(0x1219 + seg, 0x0007) + seg);
    memory16set(0x1219 + seg, 0x000c, memory16get(0x1219 + seg, 0x000c) + seg);
    memory16set(0x121a + seg, 0x0001, memory16get(0x121a + seg, 0x0001) + seg);
    memory16set(0x121a + seg, 0x0006, memory16get(0x121a + seg, 0x0006) + seg);
    memory16set(0x121a + seg, 0x000b, memory16get(0x121a + seg, 0x000b) + seg);
    memory16set(0x121e + seg, 0x0000, memory16get(0x121e + seg, 0x0000) + seg);
    memory16set(0x1222 + seg, 0x000b, memory16get(0x1222 + seg, 0x000b) + seg);
    memory16set(0x1223 + seg, 0x0006, memory16get(0x1223 + seg, 0x0006) + seg);
    memory16set(0x1223 + seg, 0x000b, memory16get(0x1223 + seg, 0x000b) + seg);
    memory16set(0x1224 + seg, 0x0006, memory16get(0x1224 + seg, 0x0006) + seg);
    memory16set(0x1224 + seg, 0x000b, memory16get(0x1224 + seg, 0x000b) + seg);
    memory16set(0x1229 + seg, 0x000f, memory16get(0x1229 + seg, 0x000f) + seg);
    memory16set(0x122b + seg, 0x000b, memory16get(0x122b + seg, 0x000b) + seg);
    memory16set(0x1232 + seg, 0x0003, memory16get(0x1232 + seg, 0x0003) + seg);
    memory16set(0x1234 + seg, 0x0008, memory16get(0x1234 + seg, 0x0008) + seg);
    memory16set(0x1236 + seg, 0x0002, memory16get(0x1236 + seg, 0x0002) + seg);
    memory16set(0x1236 + seg, 0x000d, memory16get(0x1236 + seg, 0x000d) + seg);
    memory16set(0x1237 + seg, 0x0009, memory16get(0x1237 + seg, 0x0009) + seg);
    memory16set(0x1239 + seg, 0x0002, memory16get(0x1239 + seg, 0x0002) + seg);
    memory16set(0x123b + seg, 0x0007, memory16get(0x123b + seg, 0x0007) + seg);
    memory16set(0x123d + seg, 0x0001, memory16get(0x123d + seg, 0x0001) + seg);
    memory16set(0x1240 + seg, 0x0009, memory16get(0x1240 + seg, 0x0009) + seg);
    memory16set(0x1241 + seg, 0x0007, memory16get(0x1241 + seg, 0x0007) + seg);
    memory16set(0x1243 + seg, 0x0003, memory16get(0x1243 + seg, 0x0003) + seg);
    memory16set(0x1245 + seg, 0x0009, memory16get(0x1245 + seg, 0x0009) + seg);
    memory16set(0x1246 + seg, 0x0000, memory16get(0x1246 + seg, 0x0000) + seg);
    memory16set(0x1246 + seg, 0x000d, memory16get(0x1246 + seg, 0x000d) + seg);
    memory16set(0x1247 + seg, 0x000d, memory16get(0x1247 + seg, 0x000d) + seg);
    memory16set(0x1248 + seg, 0x0004, memory16get(0x1248 + seg, 0x0004) + seg);
    memory16set(0x1250 + seg, 0x0005, memory16get(0x1250 + seg, 0x0005) + seg);
    memory16set(0x1254 + seg, 0x0003, memory16get(0x1254 + seg, 0x0003) + seg);
    memory16set(0x1257 + seg, 0x000f, memory16get(0x1257 + seg, 0x000f) + seg);
    memory16set(0x125f + seg, 0x000e, memory16get(0x125f + seg, 0x000e) + seg);
    memory16set(0x1268 + seg, 0x000b, memory16get(0x1268 + seg, 0x000b) + seg);
    memory16set(0x126e + seg, 0x0001, memory16get(0x126e + seg, 0x0001) + seg);
    memory16set(0x1270 + seg, 0x0007, memory16get(0x1270 + seg, 0x0007) + seg);
    memory16set(0x1272 + seg, 0x0009, memory16get(0x1272 + seg, 0x0009) + seg);
    memory16set(0x1274 + seg, 0x0000, memory16get(0x1274 + seg, 0x0000) + seg);
    memory16set(0x1274 + seg, 0x000c, memory16get(0x1274 + seg, 0x000c) + seg);
    memory16set(0x1276 + seg, 0x0002, memory16get(0x1276 + seg, 0x0002) + seg);
    memory16set(0x1279 + seg, 0x0003, memory16get(0x1279 + seg, 0x0003) + seg);
    memory16set(0x127a + seg, 0x000f, memory16get(0x127a + seg, 0x000f) + seg);
    memory16set(0x127c + seg, 0x000b, memory16get(0x127c + seg, 0x000b) + seg);
    memory16set(0x127e + seg, 0x0007, memory16get(0x127e + seg, 0x0007) + seg);
    memory16set(0x1280 + seg, 0x0003, memory16get(0x1280 + seg, 0x0003) + seg);
    memory16set(0x1282 + seg, 0x0000, memory16get(0x1282 + seg, 0x0000) + seg);
    memory16set(0x1284 + seg, 0x000b, memory16get(0x1284 + seg, 0x000b) + seg);
    memory16set(0x1286 + seg, 0x0009, memory16get(0x1286 + seg, 0x0009) + seg);
    memory16set(0x1288 + seg, 0x0008, memory16get(0x1288 + seg, 0x0008) + seg);
    memory16set(0x128b + seg, 0x0003, memory16get(0x128b + seg, 0x0003) + seg);
    memory16set(0x1296 + seg, 0x0000, memory16get(0x1296 + seg, 0x0000) + seg);
    memory16set(0x1297 + seg, 0x000d, memory16get(0x1297 + seg, 0x000d) + seg);
    memory16set(0x129b + seg, 0x0001, memory16get(0x129b + seg, 0x0001) + seg);
    memory16set(0x129d + seg, 0x0007, memory16get(0x129d + seg, 0x0007) + seg);
    memory16set(0x12a0 + seg, 0x0009, memory16get(0x12a0 + seg, 0x0009) + seg);
    memory16set(0x12a2 + seg, 0x0006, memory16get(0x12a2 + seg, 0x0006) + seg);
    memory16set(0x12ad + seg, 0x0000, memory16get(0x12ad + seg, 0x0000) + seg);
    memory16set(0x12af + seg, 0x000e, memory16get(0x12af + seg, 0x000e) + seg);
    memory16set(0x12b1 + seg, 0x0003, memory16get(0x12b1 + seg, 0x0003) + seg);
    memory16set(0x12b1 + seg, 0x000f, memory16get(0x12b1 + seg, 0x000f) + seg);
    memory16set(0x12b5 + seg, 0x000f, memory16get(0x12b5 + seg, 0x000f) + seg);
    memory16set(0x12b6 + seg, 0x0004, memory16get(0x12b6 + seg, 0x0004) + seg);
    memory16set(0x12b6 + seg, 0x0009, memory16get(0x12b6 + seg, 0x0009) + seg);
    memory16set(0x12b6 + seg, 0x000e, memory16get(0x12b6 + seg, 0x000e) + seg);
    memory16set(0x12b7 + seg, 0x0003, memory16get(0x12b7 + seg, 0x0003) + seg);
    memory16set(0x12b9 + seg, 0x0002, memory16get(0x12b9 + seg, 0x0002) + seg);
    memory16set(0x12c3 + seg, 0x000c, memory16get(0x12c3 + seg, 0x000c) + seg);
    memory16set(0x12c6 + seg, 0x0002, memory16get(0x12c6 + seg, 0x0002) + seg);
    memory16set(0x12c9 + seg, 0x0009, memory16get(0x12c9 + seg, 0x0009) + seg);
    memory16set(0x12cb + seg, 0x0007, memory16get(0x12cb + seg, 0x0007) + seg);
    memory16set(0x12cc + seg, 0x000b, memory16get(0x12cc + seg, 0x000b) + seg);
    memory16set(0x12ce + seg, 0x0009, memory16get(0x12ce + seg, 0x0009) + seg);
    memory16set(0x12cf + seg, 0x000d, memory16get(0x12cf + seg, 0x000d) + seg);
    memory16set(0x12d2 + seg, 0x0003, memory16get(0x12d2 + seg, 0x0003) + seg);
    memory16set(0x12d3 + seg, 0x000f, memory16get(0x12d3 + seg, 0x000f) + seg);
    memory16set(0x12d5 + seg, 0x000c, memory16get(0x12d5 + seg, 0x000c) + seg);
    memory16set(0x12d7 + seg, 0x0009, memory16get(0x12d7 + seg, 0x0009) + seg);
    memory16set(0x12d9 + seg, 0x0006, memory16get(0x12d9 + seg, 0x0006) + seg);
    memory16set(0x12db + seg, 0x0001, memory16get(0x12db + seg, 0x0001) + seg);
    memory16set(0x12db + seg, 0x000d, memory16get(0x12db + seg, 0x000d) + seg);
    memory16set(0x12de + seg, 0x0001, memory16get(0x12de + seg, 0x0001) + seg);
    memory16set(0x12e6 + seg, 0x0009, memory16get(0x12e6 + seg, 0x0009) + seg);
    memory16set(0x12e7 + seg, 0x0004, memory16get(0x12e7 + seg, 0x0004) + seg);
    memory16set(0x12e9 + seg, 0x000a, memory16get(0x12e9 + seg, 0x000a) + seg);
    memory16set(0x12ea + seg, 0x0009, memory16get(0x12ea + seg, 0x0009) + seg);
    memory16set(0x12eb + seg, 0x000a, memory16get(0x12eb + seg, 0x000a) + seg);
    memory16set(0x12ed + seg, 0x0002, memory16get(0x12ed + seg, 0x0002) + seg);
    memory16set(0x12ef + seg, 0x0001, memory16get(0x12ef + seg, 0x0001) + seg);
    memory16set(0x12f0 + seg, 0x0004, memory16get(0x12f0 + seg, 0x0004) + seg);
    memory16set(0x12f0 + seg, 0x000f, memory16get(0x12f0 + seg, 0x000f) + seg);
    memory16set(0x12f1 + seg, 0x000a, memory16get(0x12f1 + seg, 0x000a) + seg);
    memory16set(0x12f2 + seg, 0x0005, memory16get(0x12f2 + seg, 0x0005) + seg);
    memory16set(0x12f3 + seg, 0x0003, memory16get(0x12f3 + seg, 0x0003) + seg);
    memory16set(0x12f3 + seg, 0x000f, memory16get(0x12f3 + seg, 0x000f) + seg);
    memory16set(0x12f5 + seg, 0x0000, memory16get(0x12f5 + seg, 0x0000) + seg);
    memory16set(0x12f5 + seg, 0x000d, memory16get(0x12f5 + seg, 0x000d) + seg);
    memory16set(0x12f6 + seg, 0x000a, memory16get(0x12f6 + seg, 0x000a) + seg);
    memory16set(0x12f7 + seg, 0x0009, memory16get(0x12f7 + seg, 0x0009) + seg);
    memory16set(0x12f9 + seg, 0x0001, memory16get(0x12f9 + seg, 0x0001) + seg);
    memory16set(0x12fa + seg, 0x0000, memory16get(0x12fa + seg, 0x0000) + seg);
    memory16set(0x12fc + seg, 0x0000, memory16get(0x12fc + seg, 0x0000) + seg);
    memory16set(0x1300 + seg, 0x000f, memory16get(0x1300 + seg, 0x000f) + seg);
    memory16set(0x1302 + seg, 0x0006, memory16get(0x1302 + seg, 0x0006) + seg);
    memory16set(0x1303 + seg, 0x000c, memory16get(0x1303 + seg, 0x000c) + seg);
    memory16set(0x1305 + seg, 0x0005, memory16get(0x1305 + seg, 0x0005) + seg);
    memory16set(0x1306 + seg, 0x0002, memory16get(0x1306 + seg, 0x0002) + seg);
    memory16set(0x1306 + seg, 0x0009, memory16get(0x1306 + seg, 0x0009) + seg);
    memory16set(0x1307 + seg, 0x0008, memory16get(0x1307 + seg, 0x0008) + seg);
    memory16set(0x1307 + seg, 0x000d, memory16get(0x1307 + seg, 0x000d) + seg);
    memory16set(0x1308 + seg, 0x0002, memory16get(0x1308 + seg, 0x0002) + seg);
    memory16set(0x1308 + seg, 0x0007, memory16get(0x1308 + seg, 0x0007) + seg);
    memory16set(0x1308 + seg, 0x000c, memory16get(0x1308 + seg, 0x000c) + seg);
    memory16set(0x130c + seg, 0x0001, memory16get(0x130c + seg, 0x0001) + seg);
    memory16set(0x1310 + seg, 0x000c, memory16get(0x1310 + seg, 0x000c) + seg);
    memory16set(0x1311 + seg, 0x0007, memory16get(0x1311 + seg, 0x0007) + seg);
    memory16set(0x1311 + seg, 0x000c, memory16get(0x1311 + seg, 0x000c) + seg);
    memory16set(0x1312 + seg, 0x0007, memory16get(0x1312 + seg, 0x0007) + seg);
    memory16set(0x1312 + seg, 0x000c, memory16get(0x1312 + seg, 0x000c) + seg);
    memory16set(0x1313 + seg, 0x000f, memory16get(0x1313 + seg, 0x000f) + seg);
    memory16set(0x1316 + seg, 0x0004, memory16get(0x1316 + seg, 0x0004) + seg);
    memory16set(0x1316 + seg, 0x000f, memory16get(0x1316 + seg, 0x000f) + seg);
    memory16set(0x1318 + seg, 0x0004, memory16get(0x1318 + seg, 0x0004) + seg);
    memory16set(0x1319 + seg, 0x000d, memory16get(0x1319 + seg, 0x000d) + seg);
    memory16set(0x131c + seg, 0x0002, memory16get(0x131c + seg, 0x0002) + seg);
    memory16set(0x131d + seg, 0x000c, memory16get(0x131d + seg, 0x000c) + seg);
    memory16set(0x1320 + seg, 0x0004, memory16get(0x1320 + seg, 0x0004) + seg);
    memory16set(0x1324 + seg, 0x0001, memory16get(0x1324 + seg, 0x0001) + seg);
    memory16set(0x1324 + seg, 0x000f, memory16get(0x1324 + seg, 0x000f) + seg);
    memory16set(0x1326 + seg, 0x000b, memory16get(0x1326 + seg, 0x000b) + seg);
    memory16set(0x1329 + seg, 0x0001, memory16get(0x1329 + seg, 0x0001) + seg);
    memory16set(0x1329 + seg, 0x000c, memory16get(0x1329 + seg, 0x000c) + seg);
    memory16set(0x132a + seg, 0x0007, memory16get(0x132a + seg, 0x0007) + seg);
    memory16set(0x132b + seg, 0x0002, memory16get(0x132b + seg, 0x0002) + seg);
    memory16set(0x132b + seg, 0x000f, memory16get(0x132b + seg, 0x000f) + seg);
    memory16set(0x132c + seg, 0x000f, memory16get(0x132c + seg, 0x000f) + seg);
    memory16set(0x132d + seg, 0x0006, memory16get(0x132d + seg, 0x0006) + seg);
    memory16set(0x1340 + seg, 0x0002, memory16get(0x1340 + seg, 0x0002) + seg);
    memory16set(0x1341 + seg, 0x000a, memory16get(0x1341 + seg, 0x000a) + seg);
    memory16set(0x1354 + seg, 0x0009, memory16get(0x1354 + seg, 0x0009) + seg);
    memory16set(0x1358 + seg, 0x0002, memory16get(0x1358 + seg, 0x0002) + seg);
    memory16set(0x135a + seg, 0x000c, memory16get(0x135a + seg, 0x000c) + seg);
    memory16set(0x135d + seg, 0x0005, memory16get(0x135d + seg, 0x0005) + seg);
    memory16set(0x135e + seg, 0x0009, memory16get(0x135e + seg, 0x0009) + seg);
    memory16set(0x135f + seg, 0x0005, memory16get(0x135f + seg, 0x0005) + seg);
    memory16set(0x1360 + seg, 0x000b, memory16get(0x1360 + seg, 0x000b) + seg);
    memory16set(0x1369 + seg, 0x0002, memory16get(0x1369 + seg, 0x0002) + seg);
    memory16set(0x1369 + seg, 0x000d, memory16get(0x1369 + seg, 0x000d) + seg);
    memory16set(0x136b + seg, 0x000e, memory16get(0x136b + seg, 0x000e) + seg);
    memory16set(0x136d + seg, 0x0008, memory16get(0x136d + seg, 0x0008) + seg);
    memory16set(0x136e + seg, 0x0007, memory16get(0x136e + seg, 0x0007) + seg);
    memory16set(0x136f + seg, 0x0008, memory16get(0x136f + seg, 0x0008) + seg);
    memory16set(0x1371 + seg, 0x0003, memory16get(0x1371 + seg, 0x0003) + seg);
    memory16set(0x1372 + seg, 0x0006, memory16get(0x1372 + seg, 0x0006) + seg);
    memory16set(0x1373 + seg, 0x0001, memory16get(0x1373 + seg, 0x0001) + seg);
    memory16set(0x1373 + seg, 0x000c, memory16get(0x1373 + seg, 0x000c) + seg);
    memory16set(0x1374 + seg, 0x0007, memory16get(0x1374 + seg, 0x0007) + seg);
    memory16set(0x1375 + seg, 0x0005, memory16get(0x1375 + seg, 0x0005) + seg);
    memory16set(0x1376 + seg, 0x0001, memory16get(0x1376 + seg, 0x0001) + seg);
    memory16set(0x1377 + seg, 0x0002, memory16get(0x1377 + seg, 0x0002) + seg);
    memory16set(0x1377 + seg, 0x000f, memory16get(0x1377 + seg, 0x000f) + seg);
    memory16set(0x1378 + seg, 0x000c, memory16get(0x1378 + seg, 0x000c) + seg);
    memory16set(0x1379 + seg, 0x000b, memory16get(0x1379 + seg, 0x000b) + seg);
    memory16set(0x137b + seg, 0x000b, memory16get(0x137b + seg, 0x000b) + seg);
    memory16set(0x137d + seg, 0x0007, memory16get(0x137d + seg, 0x0007) + seg);
    memory16set(0x137e + seg, 0x0008, memory16get(0x137e + seg, 0x0008) + seg);
    memory16set(0x137f + seg, 0x000f, memory16get(0x137f + seg, 0x000f) + seg);
    memory16set(0x1381 + seg, 0x0005, memory16get(0x1381 + seg, 0x0005) + seg);
    memory16set(0x1382 + seg, 0x000e, memory16get(0x1382 + seg, 0x000e) + seg);
    memory16set(0x1383 + seg, 0x000b, memory16get(0x1383 + seg, 0x000b) + seg);
    memory16set(0x1384 + seg, 0x0002, memory16get(0x1384 + seg, 0x0002) + seg);
    memory16set(0x1385 + seg, 0x0001, memory16get(0x1385 + seg, 0x0001) + seg);
    memory16set(0x1385 + seg, 0x0006, memory16get(0x1385 + seg, 0x0006) + seg);
    memory16set(0x1385 + seg, 0x000b, memory16get(0x1385 + seg, 0x000b) + seg);
    memory16set(0x1386 + seg, 0x0000, memory16get(0x1386 + seg, 0x0000) + seg);
    memory16set(0x1386 + seg, 0x0005, memory16get(0x1386 + seg, 0x0005) + seg);
    memory16set(0x1389 + seg, 0x000a, memory16get(0x1389 + seg, 0x000a) + seg);
    memory16set(0x138e + seg, 0x0005, memory16get(0x138e + seg, 0x0005) + seg);
    memory16set(0x138f + seg, 0x0000, memory16get(0x138f + seg, 0x0000) + seg);
    memory16set(0x138f + seg, 0x0005, memory16get(0x138f + seg, 0x0005) + seg);
    memory16set(0x1390 + seg, 0x0000, memory16get(0x1390 + seg, 0x0000) + seg);
    memory16set(0x1390 + seg, 0x0005, memory16get(0x1390 + seg, 0x0005) + seg);
    memory16set(0x1398 + seg, 0x000f, memory16get(0x1398 + seg, 0x000f) + seg);
    memory16set(0x139a + seg, 0x000c, memory16get(0x139a + seg, 0x000c) + seg);
    memory16set(0x139c + seg, 0x000f, memory16get(0x139c + seg, 0x000f) + seg);
    memory16set(0x139e + seg, 0x0002, memory16get(0x139e + seg, 0x0002) + seg);
    memory16set(0x13a0 + seg, 0x0007, memory16get(0x13a0 + seg, 0x0007) + seg);
    memory16set(0x13a1 + seg, 0x0002, memory16get(0x13a1 + seg, 0x0002) + seg);
    memory16set(0x13a2 + seg, 0x0007, memory16get(0x13a2 + seg, 0x0007) + seg);
    memory16set(0x13a4 + seg, 0x0000, memory16get(0x13a4 + seg, 0x0000) + seg);
    memory16set(0x13ab + seg, 0x000e, memory16get(0x13ab + seg, 0x000e) + seg);
    memory16set(0x13ad + seg, 0x0008, memory16get(0x13ad + seg, 0x0008) + seg);
    memory16set(0x13b1 + seg, 0x0000, memory16get(0x13b1 + seg, 0x0000) + seg);
    memory16set(0x13b1 + seg, 0x000e, memory16get(0x13b1 + seg, 0x000e) + seg);
    memory16set(0x13b3 + seg, 0x000a, memory16get(0x13b3 + seg, 0x000a) + seg);
    memory16set(0x13b6 + seg, 0x0000, memory16get(0x13b6 + seg, 0x0000) + seg);
    memory16set(0x13b6 + seg, 0x0007, memory16get(0x13b6 + seg, 0x0007) + seg);
    memory16set(0x13b7 + seg, 0x0004, memory16get(0x13b7 + seg, 0x0004) + seg);
    memory16set(0x13b8 + seg, 0x0004, memory16get(0x13b8 + seg, 0x0004) + seg);
    memory16set(0x13b8 + seg, 0x000b, memory16get(0x13b8 + seg, 0x000b) + seg);
    memory16set(0x13c1 + seg, 0x0001, memory16get(0x13c1 + seg, 0x0001) + seg);
    memory16set(0x13c5 + seg, 0x0009, memory16get(0x13c5 + seg, 0x0009) + seg);
    memory16set(0x13c8 + seg, 0x0001, memory16get(0x13c8 + seg, 0x0001) + seg);
    memory16set(0x13ca + seg, 0x000e, memory16get(0x13ca + seg, 0x000e) + seg);
    memory16set(0x13cc + seg, 0x000b, memory16get(0x13cc + seg, 0x000b) + seg);
    memory16set(0x13cd + seg, 0x0007, memory16get(0x13cd + seg, 0x0007) + seg);
    memory16set(0x13ce + seg, 0x000d, memory16get(0x13ce + seg, 0x000d) + seg);
    memory16set(0x13d0 + seg, 0x000d, memory16get(0x13d0 + seg, 0x000d) + seg);
    memory16set(0x13d4 + seg, 0x0009, memory16get(0x13d4 + seg, 0x0009) + seg);
    memory16set(0x13d7 + seg, 0x0006, memory16get(0x13d7 + seg, 0x0006) + seg);
    memory16set(0x13d7 + seg, 0x000e, memory16get(0x13d7 + seg, 0x000e) + seg);
    memory16set(0x13dc + seg, 0x0002, memory16get(0x13dc + seg, 0x0002) + seg);
    memory16set(0x13df + seg, 0x000c, memory16get(0x13df + seg, 0x000c) + seg);
    memory16set(0x13eb + seg, 0x0000, memory16get(0x13eb + seg, 0x0000) + seg);
    memory16set(0x1404 + seg, 0x0002, memory16get(0x1404 + seg, 0x0002) + seg);
    memory16set(0x1414 + seg, 0x0004, memory16get(0x1414 + seg, 0x0004) + seg);
    memory16set(0x1416 + seg, 0x0007, memory16get(0x1416 + seg, 0x0007) + seg);
    memory16set(0x1417 + seg, 0x0006, memory16get(0x1417 + seg, 0x0006) + seg);
    memory16set(0x1420 + seg, 0x0000, memory16get(0x1420 + seg, 0x0000) + seg);
    memory16set(0x1425 + seg, 0x0005, memory16get(0x1425 + seg, 0x0005) + seg);
    memory16set(0x1428 + seg, 0x0001, memory16get(0x1428 + seg, 0x0001) + seg);
    memory16set(0x1429 + seg, 0x000d, memory16get(0x1429 + seg, 0x000d) + seg);
    memory16set(0x142d + seg, 0x000c, memory16get(0x142d + seg, 0x000c) + seg);
    memory16set(0x142f + seg, 0x0008, memory16get(0x142f + seg, 0x0008) + seg);
    memory16set(0x1430 + seg, 0x0000, memory16get(0x1430 + seg, 0x0000) + seg);
    memory16set(0x1432 + seg, 0x0001, memory16get(0x1432 + seg, 0x0001) + seg);
    memory16set(0x1433 + seg, 0x000d, memory16get(0x1433 + seg, 0x000d) + seg);
    memory16set(0x1437 + seg, 0x000b, memory16get(0x1437 + seg, 0x000b) + seg);
    memory16set(0x143a + seg, 0x0008, memory16get(0x143a + seg, 0x0008) + seg);
    memory16set(0x143d + seg, 0x0005, memory16get(0x143d + seg, 0x0005) + seg);
    memory16set(0x1441 + seg, 0x000f, memory16get(0x1441 + seg, 0x000f) + seg);
    memory16set(0x1446 + seg, 0x000b, memory16get(0x1446 + seg, 0x000b) + seg);
    memory16set(0x1448 + seg, 0x0001, memory16get(0x1448 + seg, 0x0001) + seg);
    memory16set(0x1451 + seg, 0x0009, memory16get(0x1451 + seg, 0x0009) + seg);
    memory16set(0x1455 + seg, 0x0009, memory16get(0x1455 + seg, 0x0009) + seg);
    memory16set(0x145a + seg, 0x0009, memory16get(0x145a + seg, 0x0009) + seg);
    memory16set(0x1467 + seg, 0x000a, memory16get(0x1467 + seg, 0x000a) + seg);
    memory16set(0x1471 + seg, 0x000f, memory16get(0x1471 + seg, 0x000f) + seg);
    memory16set(0x1473 + seg, 0x0003, memory16get(0x1473 + seg, 0x0003) + seg);
    memory16set(0x1476 + seg, 0x0003, memory16get(0x1476 + seg, 0x0003) + seg);
    memory16set(0x1477 + seg, 0x0002, memory16get(0x1477 + seg, 0x0002) + seg);
    memory16set(0x1478 + seg, 0x0003, memory16get(0x1478 + seg, 0x0003) + seg);
    memory16set(0x1479 + seg, 0x0004, memory16get(0x1479 + seg, 0x0004) + seg);
    memory16set(0x147a + seg, 0x0008, memory16get(0x147a + seg, 0x0008) + seg);
    memory16set(0x147c + seg, 0x0004, memory16get(0x147c + seg, 0x0004) + seg);
    memory16set(0x147e + seg, 0x0003, memory16get(0x147e + seg, 0x0003) + seg);
    memory16set(0x1480 + seg, 0x0002, memory16get(0x1480 + seg, 0x0002) + seg);
    memory16set(0x1482 + seg, 0x0001, memory16get(0x1482 + seg, 0x0001) + seg);
    memory16set(0x1483 + seg, 0x0007, memory16get(0x1483 + seg, 0x0007) + seg);
    memory16set(0x1484 + seg, 0x0006, memory16get(0x1484 + seg, 0x0006) + seg);
    memory16set(0x1485 + seg, 0x000b, memory16get(0x1485 + seg, 0x000b) + seg);
    memory16set(0x1487 + seg, 0x0007, memory16get(0x1487 + seg, 0x0007) + seg);
    memory16set(0x1489 + seg, 0x0006, memory16get(0x1489 + seg, 0x0006) + seg);
    memory16set(0x148a + seg, 0x000b, memory16get(0x148a + seg, 0x000b) + seg);
    memory16set(0x148c + seg, 0x0001, memory16get(0x148c + seg, 0x0001) + seg);
    memory16set(0x1491 + seg, 0x0003, memory16get(0x1491 + seg, 0x0003) + seg);
    memory16set(0x1494 + seg, 0x0002, memory16get(0x1494 + seg, 0x0002) + seg);
    memory16set(0x1495 + seg, 0x0004, memory16get(0x1495 + seg, 0x0004) + seg);
    memory16set(0x149a + seg, 0x0004, memory16get(0x149a + seg, 0x0004) + seg);
    memory16set(0x149e + seg, 0x0005, memory16get(0x149e + seg, 0x0005) + seg);
    memory16set(0x14a0 + seg, 0x000a, memory16get(0x14a0 + seg, 0x000a) + seg);
    memory16set(0x14a6 + seg, 0x0004, memory16get(0x14a6 + seg, 0x0004) + seg);
    memory16set(0x14a7 + seg, 0x0002, memory16get(0x14a7 + seg, 0x0002) + seg);
    memory16set(0x14a8 + seg, 0x0000, memory16get(0x14a8 + seg, 0x0000) + seg);
    memory16set(0x14a9 + seg, 0x0009, memory16get(0x14a9 + seg, 0x0009) + seg);
    memory16set(0x14aa + seg, 0x0000, memory16get(0x14aa + seg, 0x0000) + seg);
    memory16set(0x14ab + seg, 0x000f, memory16get(0x14ab + seg, 0x000f) + seg);
    memory16set(0x14ae + seg, 0x0001, memory16get(0x14ae + seg, 0x0001) + seg);
    memory16set(0x14af + seg, 0x000d, memory16get(0x14af + seg, 0x000d) + seg);
    memory16set(0x14b0 + seg, 0x0009, memory16get(0x14b0 + seg, 0x0009) + seg);
    memory16set(0x14b2 + seg, 0x000e, memory16get(0x14b2 + seg, 0x000e) + seg);
    memory16set(0x14b4 + seg, 0x0008, memory16get(0x14b4 + seg, 0x0008) + seg);
    memory16set(0x14b6 + seg, 0x0002, memory16get(0x14b6 + seg, 0x0002) + seg);
    memory16set(0x14b7 + seg, 0x000c, memory16get(0x14b7 + seg, 0x000c) + seg);
    memory16set(0x14b9 + seg, 0x0007, memory16get(0x14b9 + seg, 0x0007) + seg);
    memory16set(0x14bb + seg, 0x0004, memory16get(0x14bb + seg, 0x0004) + seg);
    memory16set(0x14bc + seg, 0x000e, memory16get(0x14bc + seg, 0x000e) + seg);
    memory16set(0x14be + seg, 0x0008, memory16get(0x14be + seg, 0x0008) + seg);
    memory16set(0x14c0 + seg, 0x0002, memory16get(0x14c0 + seg, 0x0002) + seg);
    memory16set(0x14c1 + seg, 0x000d, memory16get(0x14c1 + seg, 0x000d) + seg);
    memory16set(0x14c3 + seg, 0x0007, memory16get(0x14c3 + seg, 0x0007) + seg);
    memory16set(0x14c6 + seg, 0x000f, memory16get(0x14c6 + seg, 0x000f) + seg);
    memory16set(0x14c7 + seg, 0x000d, memory16get(0x14c7 + seg, 0x000d) + seg);
    memory16set(0x14c8 + seg, 0x000b, memory16get(0x14c8 + seg, 0x000b) + seg);
    memory16set(0x14c9 + seg, 0x0007, memory16get(0x14c9 + seg, 0x0007) + seg);
    memory16set(0x14ca + seg, 0x000d, memory16get(0x14ca + seg, 0x000d) + seg);
    memory16set(0x14cb + seg, 0x000c, memory16get(0x14cb + seg, 0x000c) + seg);
    memory16set(0x14d5 + seg, 0x0007, memory16get(0x14d5 + seg, 0x0007) + seg);
    memory16set(0x14de + seg, 0x000d, memory16get(0x14de + seg, 0x000d) + seg);
    memory16set(0x14e1 + seg, 0x0005, memory16get(0x14e1 + seg, 0x0005) + seg);
    memory16set(0x14e4 + seg, 0x000b, memory16get(0x14e4 + seg, 0x000b) + seg);
    memory16set(0x14e7 + seg, 0x0004, memory16get(0x14e7 + seg, 0x0004) + seg);
    memory16set(0x14e9 + seg, 0x0007, memory16get(0x14e9 + seg, 0x0007) + seg);
    memory16set(0x14ec + seg, 0x0001, memory16get(0x14ec + seg, 0x0001) + seg);
    memory16set(0x14f2 + seg, 0x0006, memory16get(0x14f2 + seg, 0x0006) + seg);
    memory16set(0x14fb + seg, 0x000f, memory16get(0x14fb + seg, 0x000f) + seg);
    memory16set(0x14fd + seg, 0x0003, memory16get(0x14fd + seg, 0x0003) + seg);
    memory16set(0x1500 + seg, 0x0003, memory16get(0x1500 + seg, 0x0003) + seg);
    memory16set(0x1501 + seg, 0x0002, memory16get(0x1501 + seg, 0x0002) + seg);
    memory16set(0x1501 + seg, 0x000b, memory16get(0x1501 + seg, 0x000b) + seg);
    memory16set(0x1502 + seg, 0x0006, memory16get(0x1502 + seg, 0x0006) + seg);
    memory16set(0x1503 + seg, 0x0001, memory16get(0x1503 + seg, 0x0001) + seg);
    memory16set(0x1503 + seg, 0x000c, memory16get(0x1503 + seg, 0x000c) + seg);
    memory16set(0x1504 + seg, 0x0007, memory16get(0x1504 + seg, 0x0007) + seg);
    memory16set(0x1505 + seg, 0x0002, memory16get(0x1505 + seg, 0x0002) + seg);
    memory16set(0x1505 + seg, 0x000d, memory16get(0x1505 + seg, 0x000d) + seg);
    memory16set(0x1506 + seg, 0x0008, memory16get(0x1506 + seg, 0x0008) + seg);
    memory16set(0x1507 + seg, 0x0003, memory16get(0x1507 + seg, 0x0003) + seg);
    memory16set(0x1507 + seg, 0x000e, memory16get(0x1507 + seg, 0x000e) + seg);
    memory16set(0x1508 + seg, 0x0009, memory16get(0x1508 + seg, 0x0009) + seg);
    memory16set(0x1509 + seg, 0x0004, memory16get(0x1509 + seg, 0x0004) + seg);
    memory16set(0x1509 + seg, 0x000f, memory16get(0x1509 + seg, 0x000f) + seg);
    memory16set(0x150a + seg, 0x000a, memory16get(0x150a + seg, 0x000a) + seg);
    memory16set(0x150b + seg, 0x0008, memory16get(0x150b + seg, 0x0008) + seg);
    memory16set(0x150c + seg, 0x000c, memory16get(0x150c + seg, 0x000c) + seg);
    memory16set(0x150e + seg, 0x0001, memory16get(0x150e + seg, 0x0001) + seg);
    memory16set(0x150f + seg, 0x0007, memory16get(0x150f + seg, 0x0007) + seg);
    memory16set(0x1510 + seg, 0x0006, memory16get(0x1510 + seg, 0x0006) + seg);
    memory16set(0x1511 + seg, 0x000c, memory16get(0x1511 + seg, 0x000c) + seg);
    memory16set(0x1512 + seg, 0x0001, memory16get(0x1512 + seg, 0x0001) + seg);
    memory16set(0x151c + seg, 0x0007, memory16get(0x151c + seg, 0x0007) + seg);
    memory16set(0x1520 + seg, 0x0004, memory16get(0x1520 + seg, 0x0004) + seg);
    memory16set(0x1520 + seg, 0x000c, memory16get(0x1520 + seg, 0x000c) + seg);
    memory16set(0x1528 + seg, 0x000b, memory16get(0x1528 + seg, 0x000b) + seg);
    memory16set(0x152b + seg, 0x0000, memory16get(0x152b + seg, 0x0000) + seg);
    memory16set(0x152b + seg, 0x0005, memory16get(0x152b + seg, 0x0005) + seg);
    memory16set(0x152b + seg, 0x000a, memory16get(0x152b + seg, 0x000a) + seg);
    memory16set(0x152c + seg, 0x000d, memory16get(0x152c + seg, 0x000d) + seg);
    memory16set(0x1530 + seg, 0x0002, memory16get(0x1530 + seg, 0x0002) + seg);
    memory16set(0x1531 + seg, 0x0000, memory16get(0x1531 + seg, 0x0000) + seg);
    memory16set(0x1531 + seg, 0x000e, memory16get(0x1531 + seg, 0x000e) + seg);
    memory16set(0x1534 + seg, 0x0005, memory16get(0x1534 + seg, 0x0005) + seg);
    memory16set(0x1534 + seg, 0x000c, memory16get(0x1534 + seg, 0x000c) + seg);
    memory16set(0x153e + seg, 0x0009, memory16get(0x153e + seg, 0x0009) + seg);
    memory16set(0x1541 + seg, 0x000c, memory16get(0x1541 + seg, 0x000c) + seg);
    memory16set(0x1544 + seg, 0x000e, memory16get(0x1544 + seg, 0x000e) + seg);
    memory16set(0x1549 + seg, 0x0004, memory16get(0x1549 + seg, 0x0004) + seg);
    memory16set(0x154a + seg, 0x0002, memory16get(0x154a + seg, 0x0002) + seg);
    memory16set(0x154b + seg, 0x0000, memory16get(0x154b + seg, 0x0000) + seg);
    memory16set(0x154b + seg, 0x000c, memory16get(0x154b + seg, 0x000c) + seg);
    memory16set(0x154c + seg, 0x000c, memory16get(0x154c + seg, 0x000c) + seg);
    memory16set(0x154d + seg, 0x000b, memory16get(0x154d + seg, 0x000b) + seg);
    memory16set(0x154e + seg, 0x000b, memory16get(0x154e + seg, 0x000b) + seg);
    memory16set(0x1554 + seg, 0x000b, memory16get(0x1554 + seg, 0x000b) + seg);
    memory16set(0x155b + seg, 0x0008, memory16get(0x155b + seg, 0x0008) + seg);
    memory16set(0x155e + seg, 0x0005, memory16get(0x155e + seg, 0x0005) + seg);
    memory16set(0x155e + seg, 0x000d, memory16get(0x155e + seg, 0x000d) + seg);
    memory16set(0x156b + seg, 0x0001, memory16get(0x156b + seg, 0x0001) + seg);
    memory16set(0x156d + seg, 0x0000, memory16get(0x156d + seg, 0x0000) + seg);
    memory16set(0x156e + seg, 0x000f, memory16get(0x156e + seg, 0x000f) + seg);
    memory16set(0x156f + seg, 0x0007, memory16get(0x156f + seg, 0x0007) + seg);
    memory16set(0x1572 + seg, 0x000e, memory16get(0x1572 + seg, 0x000e) + seg);
    memory16set(0x1573 + seg, 0x0006, memory16get(0x1573 + seg, 0x0006) + seg);
    memory16set(0x157b + seg, 0x0003, memory16get(0x157b + seg, 0x0003) + seg);
    memory16set(0x157c + seg, 0x0007, memory16get(0x157c + seg, 0x0007) + seg);
    memory16set(0x157e + seg, 0x0001, memory16get(0x157e + seg, 0x0001) + seg);
    memory16set(0x157f + seg, 0x000d, memory16get(0x157f + seg, 0x000d) + seg);
    memory16set(0x1581 + seg, 0x0003, memory16get(0x1581 + seg, 0x0003) + seg);
    memory16set(0x1582 + seg, 0x000b, memory16get(0x1582 + seg, 0x000b) + seg);
    memory16set(0x1584 + seg, 0x0003, memory16get(0x1584 + seg, 0x0003) + seg);
    memory16set(0x1585 + seg, 0x0006, memory16get(0x1585 + seg, 0x0006) + seg);
    memory16set(0x1585 + seg, 0x000d, memory16get(0x1585 + seg, 0x000d) + seg);
    memory16set(0x1586 + seg, 0x000f, memory16get(0x1586 + seg, 0x000f) + seg);
    memory16set(0x1588 + seg, 0x000e, memory16get(0x1588 + seg, 0x000e) + seg);
    memory16set(0x158a + seg, 0x0004, memory16get(0x158a + seg, 0x0004) + seg);
    memory16set(0x158b + seg, 0x0003, memory16get(0x158b + seg, 0x0003) + seg);
    memory16set(0x158c + seg, 0x0009, memory16get(0x158c + seg, 0x0009) + seg);
    memory16set(0x158c + seg, 0x000e, memory16get(0x158c + seg, 0x000e) + seg);
    memory16set(0x158f + seg, 0x000d, memory16get(0x158f + seg, 0x000d) + seg);
    memory16set(0x1592 + seg, 0x0002, memory16get(0x1592 + seg, 0x0002) + seg);
    memory16set(0x1592 + seg, 0x0007, memory16get(0x1592 + seg, 0x0007) + seg);
    memory16set(0x1592 + seg, 0x000c, memory16get(0x1592 + seg, 0x000c) + seg);
    memory16set(0x1593 + seg, 0x000f, memory16get(0x1593 + seg, 0x000f) + seg);
    memory16set(0x1597 + seg, 0x0004, memory16get(0x1597 + seg, 0x0004) + seg);
    memory16set(0x1598 + seg, 0x0002, memory16get(0x1598 + seg, 0x0002) + seg);
    memory16set(0x1599 + seg, 0x0000, memory16get(0x1599 + seg, 0x0000) + seg);
    memory16set(0x159b + seg, 0x0007, memory16get(0x159b + seg, 0x0007) + seg);
    memory16set(0x159b + seg, 0x000e, memory16get(0x159b + seg, 0x000e) + seg);
    memory16set(0x159f + seg, 0x000a, memory16get(0x159f + seg, 0x000a) + seg);
    memory16set(0x15a0 + seg, 0x0002, memory16get(0x15a0 + seg, 0x0002) + seg);
    memory16set(0x15a1 + seg, 0x000e, memory16get(0x15a1 + seg, 0x000e) + seg);
    memory16set(0x15a5 + seg, 0x0000, memory16get(0x15a5 + seg, 0x0000) + seg);
    memory16set(0x15a7 + seg, 0x0000, memory16get(0x15a7 + seg, 0x0000) + seg);
    memory16set(0x15a8 + seg, 0x000c, memory16get(0x15a8 + seg, 0x000c) + seg);
    memory16set(0x15ac + seg, 0x000c, memory16get(0x15ac + seg, 0x000c) + seg);
    memory16set(0x15ad + seg, 0x000a, memory16get(0x15ad + seg, 0x000a) + seg);
    memory16set(0x15ae + seg, 0x0008, memory16get(0x15ae + seg, 0x0008) + seg);
    memory16set(0x15af + seg, 0x0004, memory16get(0x15af + seg, 0x0004) + seg);
    memory16set(0x15b0 + seg, 0x0004, memory16get(0x15b0 + seg, 0x0004) + seg);
    memory16set(0x15b1 + seg, 0x0003, memory16get(0x15b1 + seg, 0x0003) + seg);
    memory16set(0x15b2 + seg, 0x0003, memory16get(0x15b2 + seg, 0x0003) + seg);
    memory16set(0x15b4 + seg, 0x0003, memory16get(0x15b4 + seg, 0x0003) + seg);
    memory16set(0x15b8 + seg, 0x0002, memory16get(0x15b8 + seg, 0x0002) + seg);
    memory16set(0x15b9 + seg, 0x000e, memory16get(0x15b9 + seg, 0x000e) + seg);
    memory16set(0x15ba + seg, 0x000f, memory16get(0x15ba + seg, 0x000f) + seg);
    memory16set(0x15bc + seg, 0x0000, memory16get(0x15bc + seg, 0x0000) + seg);
    memory16set(0x15be + seg, 0x000d, memory16get(0x15be + seg, 0x000d) + seg);
    memory16set(0x15c7 + seg, 0x0009, memory16get(0x15c7 + seg, 0x0009) + seg);
    memory16set(0x15ca + seg, 0x0002, memory16get(0x15ca + seg, 0x0002) + seg);
    memory16set(0x15d4 + seg, 0x0001, memory16get(0x15d4 + seg, 0x0001) + seg);
    memory16set(0x15d4 + seg, 0x000c, memory16get(0x15d4 + seg, 0x000c) + seg);
    memory16set(0x15d6 + seg, 0x000d, memory16get(0x15d6 + seg, 0x000d) + seg);
    memory16set(0x15d8 + seg, 0x0007, memory16get(0x15d8 + seg, 0x0007) + seg);
    memory16set(0x15d9 + seg, 0x0006, memory16get(0x15d9 + seg, 0x0006) + seg);
    memory16set(0x15da + seg, 0x0007, memory16get(0x15da + seg, 0x0007) + seg);
    memory16set(0x15db + seg, 0x000d, memory16get(0x15db + seg, 0x000d) + seg);
    memory16set(0x15dc + seg, 0x0008, memory16get(0x15dc + seg, 0x0008) + seg);
    memory16set(0x15dd + seg, 0x0003, memory16get(0x15dd + seg, 0x0003) + seg);
    memory16set(0x15dd + seg, 0x000e, memory16get(0x15dd + seg, 0x000e) + seg);
    memory16set(0x15de + seg, 0x000c, memory16get(0x15de + seg, 0x000c) + seg);
    memory16set(0x15df + seg, 0x0008, memory16get(0x15df + seg, 0x0008) + seg);
    memory16set(0x15e0 + seg, 0x0009, memory16get(0x15e0 + seg, 0x0009) + seg);
    memory16set(0x15e1 + seg, 0x0006, memory16get(0x15e1 + seg, 0x0006) + seg);
    memory16set(0x15e2 + seg, 0x0003, memory16get(0x15e2 + seg, 0x0003) + seg);
    memory16set(0x15e3 + seg, 0x0002, memory16get(0x15e3 + seg, 0x0002) + seg);
    memory16set(0x15e5 + seg, 0x0002, memory16get(0x15e5 + seg, 0x0002) + seg);
    memory16set(0x15e7 + seg, 0x000e, memory16get(0x15e7 + seg, 0x000e) + seg);
    memory16set(0x15e9 + seg, 0x0005, memory16get(0x15e9 + seg, 0x0005) + seg);
    memory16set(0x15ea + seg, 0x000b, memory16get(0x15ea + seg, 0x000b) + seg);
    memory16set(0x15ec + seg, 0x0004, memory16get(0x15ec + seg, 0x0004) + seg);
    memory16set(0x15ed + seg, 0x0001, memory16get(0x15ed + seg, 0x0001) + seg);
    memory16set(0x15ed + seg, 0x0008, memory16get(0x15ed + seg, 0x0008) + seg);
    memory16set(0x15ee + seg, 0x0007, memory16get(0x15ee + seg, 0x0007) + seg);
    memory16set(0x15ee + seg, 0x000c, memory16get(0x15ee + seg, 0x000c) + seg);
    memory16set(0x15ef + seg, 0x0001, memory16get(0x15ef + seg, 0x0001) + seg);
    memory16set(0x15ef + seg, 0x0006, memory16get(0x15ef + seg, 0x0006) + seg);
    memory16set(0x15ef + seg, 0x000b, memory16get(0x15ef + seg, 0x000b) + seg);
    memory16set(0x15f3 + seg, 0x0000, memory16get(0x15f3 + seg, 0x0000) + seg);
    memory16set(0x15f7 + seg, 0x000b, memory16get(0x15f7 + seg, 0x000b) + seg);
    memory16set(0x15f8 + seg, 0x0006, memory16get(0x15f8 + seg, 0x0006) + seg);
    memory16set(0x15f8 + seg, 0x000b, memory16get(0x15f8 + seg, 0x000b) + seg);
    memory16set(0x15f9 + seg, 0x0006, memory16get(0x15f9 + seg, 0x0006) + seg);
    memory16set(0x15f9 + seg, 0x000b, memory16get(0x15f9 + seg, 0x000b) + seg);
    memory16set(0x15fa + seg, 0x000e, memory16get(0x15fa + seg, 0x000e) + seg);
    memory16set(0x15fd + seg, 0x0003, memory16get(0x15fd + seg, 0x0003) + seg);
    memory16set(0x15fd + seg, 0x000e, memory16get(0x15fd + seg, 0x000e) + seg);
    memory16set(0x15ff + seg, 0x0000, memory16get(0x15ff + seg, 0x0000) + seg);
    memory16set(0x1600 + seg, 0x0009, memory16get(0x1600 + seg, 0x0009) + seg);
    memory16set(0x1602 + seg, 0x000e, memory16get(0x1602 + seg, 0x000e) + seg);
    memory16set(0x1604 + seg, 0x0008, memory16get(0x1604 + seg, 0x0008) + seg);
    memory16set(0x1608 + seg, 0x0000, memory16get(0x1608 + seg, 0x0000) + seg);
    memory16set(0x1608 + seg, 0x000e, memory16get(0x1608 + seg, 0x000e) + seg);
    memory16set(0x160a + seg, 0x000a, memory16get(0x160a + seg, 0x000a) + seg);
    memory16set(0x160d + seg, 0x0000, memory16get(0x160d + seg, 0x0000) + seg);
    memory16set(0x160d + seg, 0x000b, memory16get(0x160d + seg, 0x000b) + seg);
    memory16set(0x160e + seg, 0x0006, memory16get(0x160e + seg, 0x0006) + seg);
    memory16set(0x160f + seg, 0x0001, memory16get(0x160f + seg, 0x0001) + seg);
    memory16set(0x160f + seg, 0x000e, memory16get(0x160f + seg, 0x000e) + seg);
    memory16set(0x1610 + seg, 0x000e, memory16get(0x1610 + seg, 0x000e) + seg);
    memory16set(0x1611 + seg, 0x0005, memory16get(0x1611 + seg, 0x0005) + seg);
    memory16set(0x1632 + seg, 0x0005, memory16get(0x1632 + seg, 0x0005) + seg);
    memory16set(0x1635 + seg, 0x0002, memory16get(0x1635 + seg, 0x0002) + seg);
    memory16set(0x1639 + seg, 0x0007, memory16get(0x1639 + seg, 0x0007) + seg);
    memory16set(0x163a + seg, 0x0003, memory16get(0x163a + seg, 0x0003) + seg);
    memory16set(0x163b + seg, 0x0009, memory16get(0x163b + seg, 0x0009) + seg);
    memory16set(0x163c + seg, 0x0008, memory16get(0x163c + seg, 0x0008) + seg);
    memory16set(0x1678 + seg, 0x0001, memory16get(0x1678 + seg, 0x0001) + seg);
    memory16set(0x167e + seg, 0x0006, memory16get(0x167e + seg, 0x0006) + seg);
    memory16set(0x1684 + seg, 0x000b, memory16get(0x1684 + seg, 0x000b) + seg);
    memory16set(0x168f + seg, 0x0000, memory16get(0x168f + seg, 0x0000) + seg);
    memory16set(0x1698 + seg, 0x000c, memory16get(0x1698 + seg, 0x000c) + seg);
    memory16set(0x16a1 + seg, 0x000b, memory16get(0x16a1 + seg, 0x000b) + seg);
    memory16set(0x16a5 + seg, 0x0005, memory16get(0x16a5 + seg, 0x0005) + seg);
    memory16set(0x16b3 + seg, 0x0003, memory16get(0x16b3 + seg, 0x0003) + seg);
    memory16set(0x16b6 + seg, 0x000d, memory16get(0x16b6 + seg, 0x000d) + seg);
    memory16set(0x16bf + seg, 0x000c, memory16get(0x16bf + seg, 0x000c) + seg);
    memory16set(0x16d2 + seg, 0x000a, memory16get(0x16d2 + seg, 0x000a) + seg);
    memory16set(0x16d4 + seg, 0x0005, memory16get(0x16d4 + seg, 0x0005) + seg);
    memory16set(0x16e9 + seg, 0x0006, memory16get(0x16e9 + seg, 0x0006) + seg);
    memory16set(0x16f6 + seg, 0x0003, memory16get(0x16f6 + seg, 0x0003) + seg);
    memory16set(0x16f7 + seg, 0x0008, memory16get(0x16f7 + seg, 0x0008) + seg);
    memory16set(0x16f8 + seg, 0x0002, memory16get(0x16f8 + seg, 0x0002) + seg);
    memory16set(0x16fa + seg, 0x0000, memory16get(0x16fa + seg, 0x0000) + seg);
    memory16set(0x1703 + seg, 0x000a, memory16get(0x1703 + seg, 0x000a) + seg);
    memory16set(0x171e + seg, 0x0009, memory16get(0x171e + seg, 0x0009) + seg);
    memory16set(0x1726 + seg, 0x000d, memory16get(0x1726 + seg, 0x000d) + seg);
    memory16set(0x1727 + seg, 0x0005, memory16get(0x1727 + seg, 0x0005) + seg);
    memory16set(0x1728 + seg, 0x000b, memory16get(0x1728 + seg, 0x000b) + seg);
    memory16set(0x1729 + seg, 0x000d, memory16get(0x1729 + seg, 0x000d) + seg);
    memory16set(0x172a + seg, 0x000c, memory16get(0x172a + seg, 0x000c) + seg);
    memory16set(0x172d + seg, 0x0007, memory16get(0x172d + seg, 0x0007) + seg);
    memory16set(0x172d + seg, 0x000e, memory16get(0x172d + seg, 0x000e) + seg);
    memory16set(0x172e + seg, 0x0009, memory16get(0x172e + seg, 0x0009) + seg);
    memory16set(0x1739 + seg, 0x000f, memory16get(0x1739 + seg, 0x000f) + seg);
    memory16set(0x173f + seg, 0x000e, memory16get(0x173f + seg, 0x000e) + seg);
    memory16set(0x1745 + seg, 0x000b, memory16get(0x1745 + seg, 0x000b) + seg);
    memory16set(0x1746 + seg, 0x0006, memory16get(0x1746 + seg, 0x0006) + seg);
    memory16set(0x1747 + seg, 0x0008, memory16get(0x1747 + seg, 0x0008) + seg);
    memory16set(0x1748 + seg, 0x000a, memory16get(0x1748 + seg, 0x000a) + seg);
    memory16set(0x1749 + seg, 0x0008, memory16get(0x1749 + seg, 0x0008) + seg);
    memory16set(0x174a + seg, 0x0008, memory16get(0x174a + seg, 0x0008) + seg);
    memory16set(0x174d + seg, 0x0003, memory16get(0x174d + seg, 0x0003) + seg);
    memory16set(0x1752 + seg, 0x0006, memory16get(0x1752 + seg, 0x0006) + seg);
    memory16set(0x1757 + seg, 0x0009, memory16get(0x1757 + seg, 0x0009) + seg);
    memory16set(0x1758 + seg, 0x000f, memory16get(0x1758 + seg, 0x000f) + seg);
    memory16set(0x177e + seg, 0x0006, memory16get(0x177e + seg, 0x0006) + seg);
    memory16set(0x177e + seg, 0x000b, memory16get(0x177e + seg, 0x000b) + seg);
    memory16set(0x1780 + seg, 0x0002, memory16get(0x1780 + seg, 0x0002) + seg);
    memory16set(0x1781 + seg, 0x000f, memory16get(0x1781 + seg, 0x000f) + seg);
    memory16set(0x1783 + seg, 0x000d, memory16get(0x1783 + seg, 0x000d) + seg);
    memory16set(0x1786 + seg, 0x000e, memory16get(0x1786 + seg, 0x000e) + seg);
    memory16set(0x1789 + seg, 0x0006, memory16get(0x1789 + seg, 0x0006) + seg);
    memory16set(0x178a + seg, 0x0006, memory16get(0x178a + seg, 0x0006) + seg);
    memory16set(0x178d + seg, 0x000f, memory16get(0x178d + seg, 0x000f) + seg);
    memory16set(0x178f + seg, 0x000d, memory16get(0x178f + seg, 0x000d) + seg);
    memory16set(0x1793 + seg, 0x0000, memory16get(0x1793 + seg, 0x0000) + seg);
    memory16set(0x1795 + seg, 0x0000, memory16get(0x1795 + seg, 0x0000) + seg);
    memory16set(0x1798 + seg, 0x0001, memory16get(0x1798 + seg, 0x0001) + seg);
    memory16set(0x1799 + seg, 0x0001, memory16get(0x1799 + seg, 0x0001) + seg);
    memory16set(0x179c + seg, 0x000d, memory16get(0x179c + seg, 0x000d) + seg);
    memory16set(0x179e + seg, 0x000b, memory16get(0x179e + seg, 0x000b) + seg);
    memory16set(0x17a1 + seg, 0x000c, memory16get(0x17a1 + seg, 0x000c) + seg);
    memory16set(0x17a4 + seg, 0x0007, memory16get(0x17a4 + seg, 0x0007) + seg);
    memory16set(0x17a5 + seg, 0x0007, memory16get(0x17a5 + seg, 0x0007) + seg);
    memory16set(0x17a9 + seg, 0x0001, memory16get(0x17a9 + seg, 0x0001) + seg);
    memory16set(0x17b3 + seg, 0x0005, memory16get(0x17b3 + seg, 0x0005) + seg);
    memory16set(0x17b4 + seg, 0x000d, memory16get(0x17b4 + seg, 0x000d) + seg);
    memory16set(0x17b7 + seg, 0x0004, memory16get(0x17b7 + seg, 0x0004) + seg);
    memory16set(0x17ba + seg, 0x0003, memory16get(0x17ba + seg, 0x0003) + seg);
    memory16set(0x17bb + seg, 0x000e, memory16get(0x17bb + seg, 0x000e) + seg);
    memory16set(0x17c8 + seg, 0x0005, memory16get(0x17c8 + seg, 0x0005) + seg);
    memory16set(0x17cc + seg, 0x0005, memory16get(0x17cc + seg, 0x0005) + seg);
    memory16set(0x17d0 + seg, 0x000c, memory16get(0x17d0 + seg, 0x000c) + seg);
    memory16set(0x17d1 + seg, 0x0004, memory16get(0x17d1 + seg, 0x0004) + seg);
    memory16set(0x17d2 + seg, 0x0003, memory16get(0x17d2 + seg, 0x0003) + seg);
    memory16set(0x17d2 + seg, 0x0008, memory16get(0x17d2 + seg, 0x0008) + seg);
    memory16set(0x17d2 + seg, 0x000d, memory16get(0x17d2 + seg, 0x000d) + seg);
    memory16set(0x17d3 + seg, 0x0002, memory16get(0x17d3 + seg, 0x0002) + seg);
    memory16set(0x17d3 + seg, 0x0007, memory16get(0x17d3 + seg, 0x0007) + seg);
    memory16set(0x17d6 + seg, 0x0006, memory16get(0x17d6 + seg, 0x0006) + seg);
    memory16set(0x17db + seg, 0x0001, memory16get(0x17db + seg, 0x0001) + seg);
    memory16set(0x17db + seg, 0x000c, memory16get(0x17db + seg, 0x000c) + seg);
    memory16set(0x17dc + seg, 0x0001, memory16get(0x17dc + seg, 0x0001) + seg);
    memory16set(0x17dc + seg, 0x000c, memory16get(0x17dc + seg, 0x000c) + seg);
    memory16set(0x17dd + seg, 0x0001, memory16get(0x17dd + seg, 0x0001) + seg);
    memory16set(0x17de + seg, 0x0004, memory16get(0x17de + seg, 0x0004) + seg);
    memory16set(0x17e0 + seg, 0x0009, memory16get(0x17e0 + seg, 0x0009) + seg);
    memory16set(0x17e0 + seg, 0x000e, memory16get(0x17e0 + seg, 0x000e) + seg);
    memory16set(0x17e1 + seg, 0x000a, memory16get(0x17e1 + seg, 0x000a) + seg);
    memory16set(0x17e2 + seg, 0x000d, memory16get(0x17e2 + seg, 0x000d) + seg);
    memory16set(0x17e6 + seg, 0x0002, memory16get(0x17e6 + seg, 0x0002) + seg);
    memory16set(0x17e7 + seg, 0x0000, memory16get(0x17e7 + seg, 0x0000) + seg);
    memory16set(0x17e8 + seg, 0x000c, memory16get(0x17e8 + seg, 0x000c) + seg);
    memory16set(0x17e9 + seg, 0x000e, memory16get(0x17e9 + seg, 0x000e) + seg);
    memory16set(0x17ea + seg, 0x000a, memory16get(0x17ea + seg, 0x000a) + seg);
    memory16set(0x17eb + seg, 0x0001, memory16get(0x17eb + seg, 0x0001) + seg);
    memory16set(0x17f2 + seg, 0x000a, memory16get(0x17f2 + seg, 0x000a) + seg);
    memory16set(0x17f6 + seg, 0x000e, memory16get(0x17f6 + seg, 0x000e) + seg);
    memory16set(0x17f8 + seg, 0x0009, memory16get(0x17f8 + seg, 0x0009) + seg);
    memory16set(0x17f9 + seg, 0x000c, memory16get(0x17f9 + seg, 0x000c) + seg);
    memory16set(0x17fa + seg, 0x0004, memory16get(0x17fa + seg, 0x0004) + seg);
    memory16set(0x1809 + seg, 0x0007, memory16get(0x1809 + seg, 0x0007) + seg);
    memory16set(0x1812 + seg, 0x0004, memory16get(0x1812 + seg, 0x0004) + seg);
    memory16set(0x1817 + seg, 0x000d, memory16get(0x1817 + seg, 0x000d) + seg);
    memory16set(0x181c + seg, 0x0002, memory16get(0x181c + seg, 0x0002) + seg);
    memory16set(0x181d + seg, 0x000f, memory16get(0x181d + seg, 0x000f) + seg);
    memory16set(0x181f + seg, 0x000d, memory16get(0x181f + seg, 0x000d) + seg);
    memory16set(0x1821 + seg, 0x0000, memory16get(0x1821 + seg, 0x0000) + seg);
    memory16set(0x1821 + seg, 0x000f, memory16get(0x1821 + seg, 0x000f) + seg);
    memory16set(0x1822 + seg, 0x000b, memory16get(0x1822 + seg, 0x000b) + seg);
    memory16set(0x182f + seg, 0x000e, memory16get(0x182f + seg, 0x000e) + seg);
    memory16set(0x1835 + seg, 0x0008, memory16get(0x1835 + seg, 0x0008) + seg);
    memory16set(0x183b + seg, 0x0008, memory16get(0x183b + seg, 0x0008) + seg);
    memory16set(0x183e + seg, 0x0009, memory16get(0x183e + seg, 0x0009) + seg);
    memory16set(0x1840 + seg, 0x0005, memory16get(0x1840 + seg, 0x0005) + seg);
    memory16set(0x1843 + seg, 0x0001, memory16get(0x1843 + seg, 0x0001) + seg);
    memory16set(0x1845 + seg, 0x000d, memory16get(0x1845 + seg, 0x000d) + seg);
    memory16set(0x1849 + seg, 0x000d, memory16get(0x1849 + seg, 0x000d) + seg);
    memory16set(0x184b + seg, 0x0000, memory16get(0x184b + seg, 0x0000) + seg);
    memory16set(0x184d + seg, 0x0005, memory16get(0x184d + seg, 0x0005) + seg);
    memory16set(0x186a + seg, 0x0003, memory16get(0x186a + seg, 0x0003) + seg);
    memory16set(0x186c + seg, 0x000e, memory16get(0x186c + seg, 0x000e) + seg);
    memory16set(0x1875 + seg, 0x0003, memory16get(0x1875 + seg, 0x0003) + seg);
    memory16set(0x1878 + seg, 0x0009, memory16get(0x1878 + seg, 0x0009) + seg);
    memory16set(0x187b + seg, 0x0000, memory16get(0x187b + seg, 0x0000) + seg);
    memory16set(0x1885 + seg, 0x000f, memory16get(0x1885 + seg, 0x000f) + seg);
    memory16set(0x188a + seg, 0x0008, memory16get(0x188a + seg, 0x0008) + seg);
    memory16set(0x18af + seg, 0x000c, memory16get(0x18af + seg, 0x000c) + seg);
    memory16set(0x18b2 + seg, 0x0004, memory16get(0x18b2 + seg, 0x0004) + seg);
    memory16set(0x18b8 + seg, 0x000a, memory16get(0x18b8 + seg, 0x000a) + seg);
    memory16set(0x18ba + seg, 0x0004, memory16get(0x18ba + seg, 0x0004) + seg);
    memory16set(0x18bf + seg, 0x0005, memory16get(0x18bf + seg, 0x0005) + seg);
    memory16set(0x18c0 + seg, 0x000f, memory16get(0x18c0 + seg, 0x000f) + seg);
    memory16set(0x18c4 + seg, 0x0001, memory16get(0x18c4 + seg, 0x0001) + seg);
    memory16set(0x18c5 + seg, 0x000b, memory16get(0x18c5 + seg, 0x000b) + seg);
    memory16set(0x18c7 + seg, 0x000d, memory16get(0x18c7 + seg, 0x000d) + seg);
    memory16set(0x18d8 + seg, 0x0007, memory16get(0x18d8 + seg, 0x0007) + seg);
    memory16set(0x18dc + seg, 0x0001, memory16get(0x18dc + seg, 0x0001) + seg);
    memory16set(0x18e6 + seg, 0x000b, memory16get(0x18e6 + seg, 0x000b) + seg);
    memory16set(0x18ec + seg, 0x0007, memory16get(0x18ec + seg, 0x0007) + seg);
    memory16set(0x18f1 + seg, 0x0001, memory16get(0x18f1 + seg, 0x0001) + seg);
    memory16set(0x18f2 + seg, 0x000b, memory16get(0x18f2 + seg, 0x000b) + seg);
    memory16set(0x18f7 + seg, 0x0006, memory16get(0x18f7 + seg, 0x0006) + seg);
    memory16set(0x18f9 + seg, 0x0000, memory16get(0x18f9 + seg, 0x0000) + seg);
    memory16set(0x18fb + seg, 0x0006, memory16get(0x18fb + seg, 0x0006) + seg);
    memory16set(0x18fd + seg, 0x0000, memory16get(0x18fd + seg, 0x0000) + seg);
    memory16set(0x18ff + seg, 0x000a, memory16get(0x18ff + seg, 0x000a) + seg);
    memory16set(0x1909 + seg, 0x0006, memory16get(0x1909 + seg, 0x0006) + seg);
    memory16set(0x190e + seg, 0x0009, memory16get(0x190e + seg, 0x0009) + seg);
    memory16set(0x1916 + seg, 0x000a, memory16get(0x1916 + seg, 0x000a) + seg);
    memory16set(0x191a + seg, 0x0003, memory16get(0x191a + seg, 0x0003) + seg);
    memory16set(0x191d + seg, 0x0001, memory16get(0x191d + seg, 0x0001) + seg);
    memory16set(0x1920 + seg, 0x000b, memory16get(0x1920 + seg, 0x000b) + seg);
    memory16set(0x1922 + seg, 0x0006, memory16get(0x1922 + seg, 0x0006) + seg);
    memory16set(0x192a + seg, 0x0005, memory16get(0x192a + seg, 0x0005) + seg);
    memory16set(0x192c + seg, 0x0007, memory16get(0x192c + seg, 0x0007) + seg);
    memory16set(0x1938 + seg, 0x0003, memory16get(0x1938 + seg, 0x0003) + seg);
    memory16set(0x193b + seg, 0x000f, memory16get(0x193b + seg, 0x000f) + seg);
    memory16set(0x1942 + seg, 0x0002, memory16get(0x1942 + seg, 0x0002) + seg);
    memory16set(0x1942 + seg, 0x000a, memory16get(0x1942 + seg, 0x000a) + seg);
    memory16set(0x1943 + seg, 0x000b, memory16get(0x1943 + seg, 0x000b) + seg);
    memory16set(0x1946 + seg, 0x0009, memory16get(0x1946 + seg, 0x0009) + seg);
    memory16set(0x1949 + seg, 0x0005, memory16get(0x1949 + seg, 0x0005) + seg);
    memory16set(0x194b + seg, 0x000b, memory16get(0x194b + seg, 0x000b) + seg);
    memory16set(0x1950 + seg, 0x0002, memory16get(0x1950 + seg, 0x0002) + seg);
    memory16set(0x1951 + seg, 0x0000, memory16get(0x1951 + seg, 0x0000) + seg);
    memory16set(0x1952 + seg, 0x000e, memory16get(0x1952 + seg, 0x000e) + seg);
    memory16set(0x1956 + seg, 0x000a, memory16get(0x1956 + seg, 0x000a) + seg);
    memory16set(0x195c + seg, 0x000d, memory16get(0x195c + seg, 0x000d) + seg);
    memory16set(0x195d + seg, 0x0005, memory16get(0x195d + seg, 0x0005) + seg);
    memory16set(0x195f + seg, 0x0004, memory16get(0x195f + seg, 0x0004) + seg);
    memory16set(0x1963 + seg, 0x0000, memory16get(0x1963 + seg, 0x0000) + seg);
    memory16set(0x196b + seg, 0x0006, memory16get(0x196b + seg, 0x0006) + seg);
    memory16set(0x196b + seg, 0x000e, memory16get(0x196b + seg, 0x000e) + seg);
    memory16set(0x1972 + seg, 0x0003, memory16get(0x1972 + seg, 0x0003) + seg);
    memory16set(0x1976 + seg, 0x0009, memory16get(0x1976 + seg, 0x0009) + seg);
    memory16set(0x1978 + seg, 0x000b, memory16get(0x1978 + seg, 0x000b) + seg);
    memory16set(0x197a + seg, 0x000b, memory16get(0x197a + seg, 0x000b) + seg);
    memory16set(0x197c + seg, 0x0008, memory16get(0x197c + seg, 0x0008) + seg);
    memory16set(0x197e + seg, 0x000c, memory16get(0x197e + seg, 0x000c) + seg);
    memory16set(0x197f + seg, 0x000d, memory16get(0x197f + seg, 0x000d) + seg);
    memory16set(0x1981 + seg, 0x000f, memory16get(0x1981 + seg, 0x000f) + seg);
    memory16set(0x1982 + seg, 0x000b, memory16get(0x1982 + seg, 0x000b) + seg);
    memory16set(0x198f + seg, 0x0001, memory16get(0x198f + seg, 0x0001) + seg);
    memory16set(0x1990 + seg, 0x000d, memory16get(0x1990 + seg, 0x000d) + seg);
    memory16set(0x1992 + seg, 0x000a, memory16get(0x1992 + seg, 0x000a) + seg);
    memory16set(0x1995 + seg, 0x0007, memory16get(0x1995 + seg, 0x0007) + seg);
    memory16set(0x1999 + seg, 0x0001, memory16get(0x1999 + seg, 0x0001) + seg);
    memory16set(0x19af + seg, 0x0009, memory16get(0x19af + seg, 0x0009) + seg);
    memory16set(0x19b7 + seg, 0x0000, memory16get(0x19b7 + seg, 0x0000) + seg);
    memory16set(0x19b9 + seg, 0x0007, memory16get(0x19b9 + seg, 0x0007) + seg);
    memory16set(0x19bb + seg, 0x000b, memory16get(0x19bb + seg, 0x000b) + seg);
    memory16set(0x19bd + seg, 0x0008, memory16get(0x19bd + seg, 0x0008) + seg);
    memory16set(0x19dd + seg, 0x000c, memory16get(0x19dd + seg, 0x000c) + seg);
    memory16set(0x19ed + seg, 0x0007, memory16get(0x19ed + seg, 0x0007) + seg);
    memory16set(0x19ef + seg, 0x000a, memory16get(0x19ef + seg, 0x000a) + seg);
    memory16set(0x19f0 + seg, 0x000c, memory16get(0x19f0 + seg, 0x000c) + seg);
    memory16set(0x19f1 + seg, 0x0001, memory16get(0x19f1 + seg, 0x0001) + seg);
    memory16set(0x19fd + seg, 0x000f, memory16get(0x19fd + seg, 0x000f) + seg);
    memory16set(0x19ff + seg, 0x0001, memory16get(0x19ff + seg, 0x0001) + seg);
    memory16set(0x1a11 + seg, 0x000a, memory16get(0x1a11 + seg, 0x000a) + seg);
    memory16set(0x1a21 + seg, 0x0001, memory16get(0x1a21 + seg, 0x0001) + seg);
    memory16set(0x1a23 + seg, 0x0005, memory16get(0x1a23 + seg, 0x0005) + seg);
    memory16set(0x1a28 + seg, 0x0007, memory16get(0x1a28 + seg, 0x0007) + seg);
    memory16set(0x1a2a + seg, 0x0003, memory16get(0x1a2a + seg, 0x0003) + seg);
    memory16set(0x1a2f + seg, 0x000a, memory16get(0x1a2f + seg, 0x000a) + seg);
    memory16set(0x1a36 + seg, 0x0005, memory16get(0x1a36 + seg, 0x0005) + seg);
    memory16set(0x1a39 + seg, 0x0005, memory16get(0x1a39 + seg, 0x0005) + seg);
    memory16set(0x1a3c + seg, 0x0003, memory16get(0x1a3c + seg, 0x0003) + seg);
    memory16set(0x1a46 + seg, 0x000f, memory16get(0x1a46 + seg, 0x000f) + seg);
    memory16set(0x1a48 + seg, 0x0007, memory16get(0x1a48 + seg, 0x0007) + seg);
    memory16set(0x1a4b + seg, 0x0005, memory16get(0x1a4b + seg, 0x0005) + seg);
    memory16set(0x1a52 + seg, 0x000b, memory16get(0x1a52 + seg, 0x000b) + seg);
    memory16set(0x1a57 + seg, 0x000d, memory16get(0x1a57 + seg, 0x000d) + seg);
    memory16set(0x1a5b + seg, 0x0008, memory16get(0x1a5b + seg, 0x0008) + seg);
    memory16set(0x1a62 + seg, 0x0003, memory16get(0x1a62 + seg, 0x0003) + seg);
    memory16set(0x1a62 + seg, 0x000f, memory16get(0x1a62 + seg, 0x000f) + seg);
    memory16set(0x1a6a + seg, 0x0002, memory16get(0x1a6a + seg, 0x0002) + seg);
    memory16set(0x1a6a + seg, 0x000a, memory16get(0x1a6a + seg, 0x000a) + seg);
    memory16set(0x1a6f + seg, 0x0006, memory16get(0x1a6f + seg, 0x0006) + seg);
    memory16set(0x1a74 + seg, 0x0007, memory16get(0x1a74 + seg, 0x0007) + seg);
    memory16set(0x1a77 + seg, 0x0009, memory16get(0x1a77 + seg, 0x0009) + seg);
    memory16set(0x1a79 + seg, 0x0004, memory16get(0x1a79 + seg, 0x0004) + seg);
    memory16set(0x1a7b + seg, 0x000b, memory16get(0x1a7b + seg, 0x000b) + seg);
    memory16set(0x1a7f + seg, 0x0006, memory16get(0x1a7f + seg, 0x0006) + seg);
    memory16set(0x1a86 + seg, 0x0007, memory16get(0x1a86 + seg, 0x0007) + seg);
    memory16set(0x1a88 + seg, 0x0004, memory16get(0x1a88 + seg, 0x0004) + seg);
    memory16set(0x1a8a + seg, 0x0003, memory16get(0x1a8a + seg, 0x0003) + seg);
    memory16set(0x1a8c + seg, 0x0001, memory16get(0x1a8c + seg, 0x0001) + seg);
    memory16set(0x1a8d + seg, 0x000f, memory16get(0x1a8d + seg, 0x000f) + seg);
    memory16set(0x1a91 + seg, 0x0000, memory16get(0x1a91 + seg, 0x0000) + seg);
    memory16set(0x1a95 + seg, 0x0008, memory16get(0x1a95 + seg, 0x0008) + seg);
    memory16set(0x1a9a + seg, 0x000b, memory16get(0x1a9a + seg, 0x000b) + seg);
    memory16set(0x1aa2 + seg, 0x0000, memory16get(0x1aa2 + seg, 0x0000) + seg);
    memory16set(0x1aa4 + seg, 0x0007, memory16get(0x1aa4 + seg, 0x0007) + seg);
    memory16set(0x1aa9 + seg, 0x0006, memory16get(0x1aa9 + seg, 0x0006) + seg);
    memory16set(0x1ab3 + seg, 0x0003, memory16get(0x1ab3 + seg, 0x0003) + seg);
    memory16set(0x1ab9 + seg, 0x0002, memory16get(0x1ab9 + seg, 0x0002) + seg);
    memory16set(0x1abd + seg, 0x000e, memory16get(0x1abd + seg, 0x000e) + seg);
    memory16set(0x1ac2 + seg, 0x0002, memory16get(0x1ac2 + seg, 0x0002) + seg);
    memory16set(0x1acc + seg, 0x0008, memory16get(0x1acc + seg, 0x0008) + seg);
    memory16set(0x1acf + seg, 0x000d, memory16get(0x1acf + seg, 0x000d) + seg);
    memory16set(0x1ad9 + seg, 0x0005, memory16get(0x1ad9 + seg, 0x0005) + seg);
    memory16set(0x1add + seg, 0x0000, memory16get(0x1add + seg, 0x0000) + seg);
    memory16set(0x1ae5 + seg, 0x0007, memory16get(0x1ae5 + seg, 0x0007) + seg);
    memory16set(0x1ae9 + seg, 0x000f, memory16get(0x1ae9 + seg, 0x000f) + seg);
    memory16set(0x1aec + seg, 0x000e, memory16get(0x1aec + seg, 0x000e) + seg);
    memory16set(0x1af3 + seg, 0x0002, memory16get(0x1af3 + seg, 0x0002) + seg);
    memory16set(0x1af4 + seg, 0x000e, memory16get(0x1af4 + seg, 0x000e) + seg);
    memory16set(0x1afd + seg, 0x0009, memory16get(0x1afd + seg, 0x0009) + seg);
    memory16set(0x1b00 + seg, 0x0001, memory16get(0x1b00 + seg, 0x0001) + seg);
    memory16set(0x1b04 + seg, 0x0007, memory16get(0x1b04 + seg, 0x0007) + seg);
    memory16set(0x1b08 + seg, 0x0000, memory16get(0x1b08 + seg, 0x0000) + seg);
    memory16set(0x1b0d + seg, 0x0003, memory16get(0x1b0d + seg, 0x0003) + seg);
    memory16set(0x1b11 + seg, 0x000c, memory16get(0x1b11 + seg, 0x000c) + seg);
    memory16set(0x1b14 + seg, 0x0001, memory16get(0x1b14 + seg, 0x0001) + seg);
    memory16set(0x1b17 + seg, 0x000a, memory16get(0x1b17 + seg, 0x000a) + seg);
    memory16set(0x1b30 + seg, 0x000e, memory16get(0x1b30 + seg, 0x000e) + seg);
    memory16set(0x1b32 + seg, 0x000c, memory16get(0x1b32 + seg, 0x000c) + seg);
    memory16set(0x1b34 + seg, 0x000a, memory16get(0x1b34 + seg, 0x000a) + seg);
    memory16set(0x1b39 + seg, 0x0009, memory16get(0x1b39 + seg, 0x0009) + seg);
    memory16set(0x1b3f + seg, 0x0009, memory16get(0x1b3f + seg, 0x0009) + seg);
    memory16set(0x1b40 + seg, 0x000e, memory16get(0x1b40 + seg, 0x000e) + seg);
    memory16set(0x1b44 + seg, 0x0007, memory16get(0x1b44 + seg, 0x0007) + seg);
    memory16set(0x1b4a + seg, 0x0002, memory16get(0x1b4a + seg, 0x0002) + seg);
    memory16set(0x1b4d + seg, 0x0001, memory16get(0x1b4d + seg, 0x0001) + seg);
    memory16set(0x1b4e + seg, 0x0001, memory16get(0x1b4e + seg, 0x0001) + seg);
    memory16set(0x1b50 + seg, 0x0003, memory16get(0x1b50 + seg, 0x0003) + seg);
    memory16set(0x1b58 + seg, 0x0005, memory16get(0x1b58 + seg, 0x0005) + seg);
    memory16set(0x1b5c + seg, 0x0008, memory16get(0x1b5c + seg, 0x0008) + seg);
    memory16set(0x1b60 + seg, 0x0006, memory16get(0x1b60 + seg, 0x0006) + seg);
    memory16set(0x1b6c + seg, 0x000a, memory16get(0x1b6c + seg, 0x000a) + seg);
    memory16set(0x1b75 + seg, 0x0004, memory16get(0x1b75 + seg, 0x0004) + seg);
    memory16set(0x1b76 + seg, 0x000e, memory16get(0x1b76 + seg, 0x000e) + seg);
    memory16set(0x1b7a + seg, 0x000d, memory16get(0x1b7a + seg, 0x000d) + seg);
    memory16set(0x1b7f + seg, 0x000c, memory16get(0x1b7f + seg, 0x000c) + seg);
    memory16set(0x1b82 + seg, 0x000a, memory16get(0x1b82 + seg, 0x000a) + seg);
    memory16set(0x1b87 + seg, 0x0003, memory16get(0x1b87 + seg, 0x0003) + seg);
    memory16set(0x1b8a + seg, 0x0007, memory16get(0x1b8a + seg, 0x0007) + seg);
    memory16set(0x1b8e + seg, 0x000f, memory16get(0x1b8e + seg, 0x000f) + seg);
    memory16set(0x1b94 + seg, 0x000c, memory16get(0x1b94 + seg, 0x000c) + seg);
    memory16set(0x1b9c + seg, 0x0001, memory16get(0x1b9c + seg, 0x0001) + seg);
    memory16set(0x1b9e + seg, 0x0008, memory16get(0x1b9e + seg, 0x0008) + seg);
    memory16set(0x1ba3 + seg, 0x0007, memory16get(0x1ba3 + seg, 0x0007) + seg);
    memory16set(0x1ba6 + seg, 0x0006, memory16get(0x1ba6 + seg, 0x0006) + seg);
    memory16set(0x1ba8 + seg, 0x0004, memory16get(0x1ba8 + seg, 0x0004) + seg);
    memory16set(0x1baa + seg, 0x0004, memory16get(0x1baa + seg, 0x0004) + seg);
    memory16set(0x1bad + seg, 0x000b, memory16get(0x1bad + seg, 0x000b) + seg);
    memory16set(0x1bb1 + seg, 0x0008, memory16get(0x1bb1 + seg, 0x0008) + seg);
    memory16set(0x1bb4 + seg, 0x000f, memory16get(0x1bb4 + seg, 0x000f) + seg);
    memory16set(0x1bb9 + seg, 0x000a, memory16get(0x1bb9 + seg, 0x000a) + seg);
    memory16set(0x1bbd + seg, 0x0005, memory16get(0x1bbd + seg, 0x0005) + seg);
    memory16set(0x1bbf + seg, 0x000f, memory16get(0x1bbf + seg, 0x000f) + seg);
    memory16set(0x1bc6 + seg, 0x0002, memory16get(0x1bc6 + seg, 0x0002) + seg);
    memory16set(0x1bcd + seg, 0x0009, memory16get(0x1bcd + seg, 0x0009) + seg);
    memory16set(0x1bd2 + seg, 0x0000, memory16get(0x1bd2 + seg, 0x0000) + seg);
    memory16set(0x1bd4 + seg, 0x0007, memory16get(0x1bd4 + seg, 0x0007) + seg);
    memory16set(0x1bd6 + seg, 0x0004, memory16get(0x1bd6 + seg, 0x0004) + seg);
    memory16set(0x1bd9 + seg, 0x0004, memory16get(0x1bd9 + seg, 0x0004) + seg);
    memory16set(0x1bda + seg, 0x000b, memory16get(0x1bda + seg, 0x000b) + seg);
    memory16set(0x1bdc + seg, 0x0005, memory16get(0x1bdc + seg, 0x0005) + seg);
    memory16set(0x1bdd + seg, 0x0007, memory16get(0x1bdd + seg, 0x0007) + seg);
    memory16set(0x1bde + seg, 0x0007, memory16get(0x1bde + seg, 0x0007) + seg);
    memory16set(0x1bdf + seg, 0x000b, memory16get(0x1bdf + seg, 0x000b) + seg);
    memory16set(0x1be2 + seg, 0x0004, memory16get(0x1be2 + seg, 0x0004) + seg);
    memory16set(0x1be3 + seg, 0x000e, memory16get(0x1be3 + seg, 0x000e) + seg);
    memory16set(0x1be5 + seg, 0x0000, memory16get(0x1be5 + seg, 0x0000) + seg);
    memory16set(0x1be6 + seg, 0x0000, memory16get(0x1be6 + seg, 0x0000) + seg);
    memory16set(0x1be7 + seg, 0x0004, memory16get(0x1be7 + seg, 0x0004) + seg);
    memory16set(0x1be9 + seg, 0x000d, memory16get(0x1be9 + seg, 0x000d) + seg);
    memory16set(0x1beb + seg, 0x0006, memory16get(0x1beb + seg, 0x0006) + seg);
    memory16set(0x1bec + seg, 0x0008, memory16get(0x1bec + seg, 0x0008) + seg);
    memory16set(0x1bed + seg, 0x0008, memory16get(0x1bed + seg, 0x0008) + seg);
    memory16set(0x1bee + seg, 0x000c, memory16get(0x1bee + seg, 0x000c) + seg);
    memory16set(0x1bf0 + seg, 0x000f, memory16get(0x1bf0 + seg, 0x000f) + seg);
    memory16set(0x1bf2 + seg, 0x0001, memory16get(0x1bf2 + seg, 0x0001) + seg);
    memory16set(0x1bf3 + seg, 0x0005, memory16get(0x1bf3 + seg, 0x0005) + seg);
    memory16set(0x1bf4 + seg, 0x000a, memory16get(0x1bf4 + seg, 0x000a) + seg);
    memory16set(0x1bf6 + seg, 0x0000, memory16get(0x1bf6 + seg, 0x0000) + seg);
    memory16set(0x1bf6 + seg, 0x000f, memory16get(0x1bf6 + seg, 0x000f) + seg);
    memory16set(0x1bfb + seg, 0x0009, memory16get(0x1bfb + seg, 0x0009) + seg);
    memory16set(0x1bfd + seg, 0x0003, memory16get(0x1bfd + seg, 0x0003) + seg);
    memory16set(0x1bfe + seg, 0x0001, memory16get(0x1bfe + seg, 0x0001) + seg);
    memory16set(0x1c00 + seg, 0x0005, memory16get(0x1c00 + seg, 0x0005) + seg);
    memory16set(0x1c01 + seg, 0x0002, memory16get(0x1c01 + seg, 0x0002) + seg);
    memory16set(0x1c01 + seg, 0x000a, memory16get(0x1c01 + seg, 0x000a) + seg);
    memory16set(0x1c02 + seg, 0x0007, memory16get(0x1c02 + seg, 0x0007) + seg);
    memory16set(0x1c03 + seg, 0x000d, memory16get(0x1c03 + seg, 0x000d) + seg);
    memory16set(0x1c04 + seg, 0x0005, memory16get(0x1c04 + seg, 0x0005) + seg);
    memory16set(0x1c04 + seg, 0x000d, memory16get(0x1c04 + seg, 0x000d) + seg);
    memory16set(0x1c06 + seg, 0x0009, memory16get(0x1c06 + seg, 0x0009) + seg);
    memory16set(0x1c07 + seg, 0x000b, memory16get(0x1c07 + seg, 0x000b) + seg);
    memory16set(0x1c09 + seg, 0x0000, memory16get(0x1c09 + seg, 0x0000) + seg);
    memory16set(0x1c09 + seg, 0x000c, memory16get(0x1c09 + seg, 0x000c) + seg);
    memory16set(0x1c0b + seg, 0x0002, memory16get(0x1c0b + seg, 0x0002) + seg);
    memory16set(0x1c0b + seg, 0x000e, memory16get(0x1c0b + seg, 0x000e) + seg);
    memory16set(0x1c0c + seg, 0x0005, memory16get(0x1c0c + seg, 0x0005) + seg);
    memory16set(0x1c0c + seg, 0x000d, memory16get(0x1c0c + seg, 0x000d) + seg);
    memory16set(0x1c0e + seg, 0x0004, memory16get(0x1c0e + seg, 0x0004) + seg);
    memory16set(0x1c0f + seg, 0x0006, memory16get(0x1c0f + seg, 0x0006) + seg);
    memory16set(0x1c11 + seg, 0x0002, memory16get(0x1c11 + seg, 0x0002) + seg);
    memory16set(0x1c12 + seg, 0x0008, memory16get(0x1c12 + seg, 0x0008) + seg);
    memory16set(0x1c13 + seg, 0x0007, memory16get(0x1c13 + seg, 0x0007) + seg);
    memory16set(0x1c15 + seg, 0x0003, memory16get(0x1c15 + seg, 0x0003) + seg);
    memory16set(0x1c16 + seg, 0x0009, memory16get(0x1c16 + seg, 0x0009) + seg);
    memory16set(0x1c17 + seg, 0x0005, memory16get(0x1c17 + seg, 0x0005) + seg);
    memory16set(0x1c18 + seg, 0x0009, memory16get(0x1c18 + seg, 0x0009) + seg);
    memory16set(0x1c19 + seg, 0x000f, memory16get(0x1c19 + seg, 0x000f) + seg);
    memory16set(0x1c1a + seg, 0x000b, memory16get(0x1c1a + seg, 0x000b) + seg);
    memory16set(0x1c1b + seg, 0x000f, memory16get(0x1c1b + seg, 0x000f) + seg);
    memory16set(0x1c1d + seg, 0x0005, memory16get(0x1c1d + seg, 0x0005) + seg);
    memory16set(0x1c1d + seg, 0x000d, memory16get(0x1c1d + seg, 0x000d) + seg);
    memory16set(0x1c1e + seg, 0x0002, memory16get(0x1c1e + seg, 0x0002) + seg);
    memory16set(0x1c1e + seg, 0x000a, memory16get(0x1c1e + seg, 0x000a) + seg);
    memory16set(0x1c20 + seg, 0x0006, memory16get(0x1c20 + seg, 0x0006) + seg);
    memory16set(0x1c21 + seg, 0x0007, memory16get(0x1c21 + seg, 0x0007) + seg);
    memory16set(0x1c22 + seg, 0x0008, memory16get(0x1c22 + seg, 0x0008) + seg);
    memory16set(0x1c25 + seg, 0x000a, memory16get(0x1c25 + seg, 0x000a) + seg);
    memory16set(0x1c26 + seg, 0x000c, memory16get(0x1c26 + seg, 0x000c) + seg);
    memory16set(0x1c27 + seg, 0x0004, memory16get(0x1c27 + seg, 0x0004) + seg);
    memory16set(0x1c27 + seg, 0x0009, memory16get(0x1c27 + seg, 0x0009) + seg);
    memory16set(0x1c28 + seg, 0x0001, memory16get(0x1c28 + seg, 0x0001) + seg);
    memory16set(0x1c29 + seg, 0x000e, memory16get(0x1c29 + seg, 0x000e) + seg);
    memory16set(0x1c2b + seg, 0x0000, memory16get(0x1c2b + seg, 0x0000) + seg);
    memory16set(0x1c2b + seg, 0x0008, memory16get(0x1c2b + seg, 0x0008) + seg);
    memory16set(0x1c2b + seg, 0x000d, memory16get(0x1c2b + seg, 0x000d) + seg);
    memory16set(0x1c2c + seg, 0x0005, memory16get(0x1c2c + seg, 0x0005) + seg);
    memory16set(0x1c2e + seg, 0x0002, memory16get(0x1c2e + seg, 0x0002) + seg);
    memory16set(0x1c2f + seg, 0x0004, memory16get(0x1c2f + seg, 0x0004) + seg);
    memory16set(0x1c2f + seg, 0x000c, memory16get(0x1c2f + seg, 0x000c) + seg);
    memory16set(0x1c30 + seg, 0x0001, memory16get(0x1c30 + seg, 0x0001) + seg);
    memory16set(0x1c30 + seg, 0x0009, memory16get(0x1c30 + seg, 0x0009) + seg);
    memory16set(0x1c32 + seg, 0x0006, memory16get(0x1c32 + seg, 0x0006) + seg);
    memory16set(0x1c33 + seg, 0x0008, memory16get(0x1c33 + seg, 0x0008) + seg);
    memory16set(0x1c34 + seg, 0x0000, memory16get(0x1c34 + seg, 0x0000) + seg);
    memory16set(0x1c34 + seg, 0x0005, memory16get(0x1c34 + seg, 0x0005) + seg);
    memory16set(0x1c34 + seg, 0x000d, memory16get(0x1c34 + seg, 0x000d) + seg);
    memory16set(0x1c36 + seg, 0x000a, memory16get(0x1c36 + seg, 0x000a) + seg);
    memory16set(0x1c37 + seg, 0x000c, memory16get(0x1c37 + seg, 0x000c) + seg);
    memory16set(0x1c38 + seg, 0x0004, memory16get(0x1c38 + seg, 0x0004) + seg);
    memory16set(0x1c38 + seg, 0x0009, memory16get(0x1c38 + seg, 0x0009) + seg);
    memory16set(0x1c39 + seg, 0x0001, memory16get(0x1c39 + seg, 0x0001) + seg);
    memory16set(0x1c3a + seg, 0x000e, memory16get(0x1c3a + seg, 0x000e) + seg);
    memory16set(0x1c3c + seg, 0x0000, memory16get(0x1c3c + seg, 0x0000) + seg);
    memory16set(0x1c3c + seg, 0x0008, memory16get(0x1c3c + seg, 0x0008) + seg);
    memory16set(0x1c3c + seg, 0x000d, memory16get(0x1c3c + seg, 0x000d) + seg);
    memory16set(0x1c3d + seg, 0x0005, memory16get(0x1c3d + seg, 0x0005) + seg);
    memory16set(0x1c3f + seg, 0x0002, memory16get(0x1c3f + seg, 0x0002) + seg);
    memory16set(0x1c40 + seg, 0x0004, memory16get(0x1c40 + seg, 0x0004) + seg);
    memory16set(0x1c40 + seg, 0x000c, memory16get(0x1c40 + seg, 0x000c) + seg);
    memory16set(0x1c41 + seg, 0x0001, memory16get(0x1c41 + seg, 0x0001) + seg);
    memory16set(0x1c41 + seg, 0x0009, memory16get(0x1c41 + seg, 0x0009) + seg);
    memory16set(0x1c45 + seg, 0x0003, memory16get(0x1c45 + seg, 0x0003) + seg);
    memory16set(0x1c47 + seg, 0x0001, memory16get(0x1c47 + seg, 0x0001) + seg);
    memory16set(0x1c4b + seg, 0x0008, memory16get(0x1c4b + seg, 0x0008) + seg);
    memory16set(0x1c4d + seg, 0x0008, memory16get(0x1c4d + seg, 0x0008) + seg);
    memory16set(0x1c4e + seg, 0x000d, memory16get(0x1c4e + seg, 0x000d) + seg);
    memory16set(0x1c50 + seg, 0x0002, memory16get(0x1c50 + seg, 0x0002) + seg);
    memory16set(0x1c50 + seg, 0x000f, memory16get(0x1c50 + seg, 0x000f) + seg);
    memory16set(0x1c53 + seg, 0x0000, memory16get(0x1c53 + seg, 0x0000) + seg);
    memory16set(0x1c57 + seg, 0x0006, memory16get(0x1c57 + seg, 0x0006) + seg);
    memory16set(0x1c59 + seg, 0x0003, memory16get(0x1c59 + seg, 0x0003) + seg);
    memory16set(0x1c5a + seg, 0x0008, memory16get(0x1c5a + seg, 0x0008) + seg);
    memory16set(0x1c5b + seg, 0x000d, memory16get(0x1c5b + seg, 0x000d) + seg);
    memory16set(0x1c5c + seg, 0x000a, memory16get(0x1c5c + seg, 0x000a) + seg);
    memory16set(0x1c5e + seg, 0x000b, memory16get(0x1c5e + seg, 0x000b) + seg);
    memory16set(0x1c60 + seg, 0x0000, memory16get(0x1c60 + seg, 0x0000) + seg);
    memory16set(0x1c60 + seg, 0x000d, memory16get(0x1c60 + seg, 0x000d) + seg);
    memory16set(0x1c62 + seg, 0x0002, memory16get(0x1c62 + seg, 0x0002) + seg);
    memory16set(0x1c66 + seg, 0x000f, memory16get(0x1c66 + seg, 0x000f) + seg);
    memory16set(0x1c68 + seg, 0x000d, memory16get(0x1c68 + seg, 0x000d) + seg);
    memory16set(0x1c6a + seg, 0x0002, memory16get(0x1c6a + seg, 0x0002) + seg);
    memory16set(0x1c6b + seg, 0x0007, memory16get(0x1c6b + seg, 0x0007) + seg);
    memory16set(0x1c6c + seg, 0x0004, memory16get(0x1c6c + seg, 0x0004) + seg);
    memory16set(0x1c6e + seg, 0x0005, memory16get(0x1c6e + seg, 0x0005) + seg);
    memory16set(0x1c6f + seg, 0x000a, memory16get(0x1c6f + seg, 0x000a) + seg);
    memory16set(0x1c70 + seg, 0x0007, memory16get(0x1c70 + seg, 0x0007) + seg);
    memory16set(0x1c71 + seg, 0x000c, memory16get(0x1c71 + seg, 0x000c) + seg);
    memory16set(0x1c76 + seg, 0x000c, memory16get(0x1c76 + seg, 0x000c) + seg);
    memory16set(0x1c78 + seg, 0x0008, memory16get(0x1c78 + seg, 0x0008) + seg);
    memory16set(0x1c79 + seg, 0x000d, memory16get(0x1c79 + seg, 0x000d) + seg);
    memory16set(0x1c7b + seg, 0x0002, memory16get(0x1c7b + seg, 0x0002) + seg);
    memory16set(0x1c7b + seg, 0x000f, memory16get(0x1c7b + seg, 0x000f) + seg);
    memory16set(0x1c8a + seg, 0x000c, memory16get(0x1c8a + seg, 0x000c) + seg);
    memory16set(0x1c8c + seg, 0x000e, memory16get(0x1c8c + seg, 0x000e) + seg);
    memory16set(0x1c92 + seg, 0x0007, memory16get(0x1c92 + seg, 0x0007) + seg);
    memory16set(0x1c93 + seg, 0x0003, memory16get(0x1c93 + seg, 0x0003) + seg);
    memory16set(0x1c97 + seg, 0x0009, memory16get(0x1c97 + seg, 0x0009) + seg);
    memory16set(0x1c9e + seg, 0x000f, memory16get(0x1c9e + seg, 0x000f) + seg);
    memory16set(0x1ca8 + seg, 0x0004, memory16get(0x1ca8 + seg, 0x0004) + seg);
    memory16set(0x1cab + seg, 0x0008, memory16get(0x1cab + seg, 0x0008) + seg);
    memory16set(0x1cad + seg, 0x0003, memory16get(0x1cad + seg, 0x0003) + seg);
    memory16set(0x1cae + seg, 0x0005, memory16get(0x1cae + seg, 0x0005) + seg);
    memory16set(0x1cb0 + seg, 0x000a, memory16get(0x1cb0 + seg, 0x000a) + seg);
    memory16set(0x1cbb + seg, 0x0002, memory16get(0x1cbb + seg, 0x0002) + seg);
    memory16set(0x1cbf + seg, 0x0007, memory16get(0x1cbf + seg, 0x0007) + seg);
    memory16set(0x1cc4 + seg, 0x000c, memory16get(0x1cc4 + seg, 0x000c) + seg);
    memory16set(0x1cca + seg, 0x0003, memory16get(0x1cca + seg, 0x0003) + seg);
    memory16set(0x1ccb + seg, 0x0008, memory16get(0x1ccb + seg, 0x0008) + seg);
    memory16set(0x1cce + seg, 0x000c, memory16get(0x1cce + seg, 0x000c) + seg);
    memory16set(0x1cd0 + seg, 0x0005, memory16get(0x1cd0 + seg, 0x0005) + seg);
    memory16set(0x1cd1 + seg, 0x000a, memory16get(0x1cd1 + seg, 0x000a) + seg);
    memory16set(0x1cd6 + seg, 0x0001, memory16get(0x1cd6 + seg, 0x0001) + seg);
    memory16set(0x1cd8 + seg, 0x0004, memory16get(0x1cd8 + seg, 0x0004) + seg);
    memory16set(0x1cdb + seg, 0x0000, memory16get(0x1cdb + seg, 0x0000) + seg);
    memory16set(0x1cdc + seg, 0x0003, memory16get(0x1cdc + seg, 0x0003) + seg);
    memory16set(0x1cdd + seg, 0x000f, memory16get(0x1cdd + seg, 0x000f) + seg);
    memory16set(0x1cdf + seg, 0x000f, memory16get(0x1cdf + seg, 0x000f) + seg);
    memory16set(0x1ce1 + seg, 0x000b, memory16get(0x1ce1 + seg, 0x000b) + seg);
    memory16set(0x1ce3 + seg, 0x0005, memory16get(0x1ce3 + seg, 0x0005) + seg);
    memory16set(0x1ce4 + seg, 0x0005, memory16get(0x1ce4 + seg, 0x0005) + seg);
    memory16set(0x1ceb + seg, 0x0000, memory16get(0x1ceb + seg, 0x0000) + seg);
    memory16set(0x1ceb + seg, 0x000b, memory16get(0x1ceb + seg, 0x000b) + seg);
    memory16set(0x1cf1 + seg, 0x000f, memory16get(0x1cf1 + seg, 0x000f) + seg);
    memory16set(0x1cf2 + seg, 0x000e, memory16get(0x1cf2 + seg, 0x000e) + seg);
    memory16set(0x1cf3 + seg, 0x0007, memory16get(0x1cf3 + seg, 0x0007) + seg);
    memory16set(0x1cf6 + seg, 0x0007, memory16get(0x1cf6 + seg, 0x0007) + seg);
    memory16set(0x1cf8 + seg, 0x000a, memory16get(0x1cf8 + seg, 0x000a) + seg);
    memory16set(0x1cfd + seg, 0x0009, memory16get(0x1cfd + seg, 0x0009) + seg);
    memory16set(0x1d0a + seg, 0x0006, memory16get(0x1d0a + seg, 0x0006) + seg);
    memory16set(0x1d10 + seg, 0x000b, memory16get(0x1d10 + seg, 0x000b) + seg);
    memory16set(0x1d15 + seg, 0x0009, memory16get(0x1d15 + seg, 0x0009) + seg);
    memory16set(0x1d21 + seg, 0x0002, memory16get(0x1d21 + seg, 0x0002) + seg);
    memory16set(0x1d22 + seg, 0x000d, memory16get(0x1d22 + seg, 0x000d) + seg);
    memory16set(0x1d2c + seg, 0x0009, memory16get(0x1d2c + seg, 0x0009) + seg);
    memory16set(0x1d2f + seg, 0x0009, memory16get(0x1d2f + seg, 0x0009) + seg);
    memory16set(0x1d35 + seg, 0x000c, memory16get(0x1d35 + seg, 0x000c) + seg);
    memory16set(0x1d36 + seg, 0x000e, memory16get(0x1d36 + seg, 0x000e) + seg);
    memory16set(0x1d38 + seg, 0x0009, memory16get(0x1d38 + seg, 0x0009) + seg);
    memory16set(0x1d3f + seg, 0x000f, memory16get(0x1d3f + seg, 0x000f) + seg);
    memory16set(0x1d44 + seg, 0x000d, memory16get(0x1d44 + seg, 0x000d) + seg);
    memory16set(0x1d45 + seg, 0x000b, memory16get(0x1d45 + seg, 0x000b) + seg);
    memory16set(0x1d48 + seg, 0x0008, memory16get(0x1d48 + seg, 0x0008) + seg);
    memory16set(0x1d4b + seg, 0x0004, memory16get(0x1d4b + seg, 0x0004) + seg);
    memory16set(0x1d4e + seg, 0x0005, memory16get(0x1d4e + seg, 0x0005) + seg);
    memory16set(0x1d4f + seg, 0x0009, memory16get(0x1d4f + seg, 0x0009) + seg);
    memory16set(0x1d52 + seg, 0x000f, memory16get(0x1d52 + seg, 0x000f) + seg);
    memory16set(0x1d5a + seg, 0x0003, memory16get(0x1d5a + seg, 0x0003) + seg);
    memory16set(0x1d5c + seg, 0x0009, memory16get(0x1d5c + seg, 0x0009) + seg);
    memory16set(0x1d61 + seg, 0x0001, memory16get(0x1d61 + seg, 0x0001) + seg);
    memory16set(0x1d66 + seg, 0x0002, memory16get(0x1d66 + seg, 0x0002) + seg);
    memory16set(0x1d68 + seg, 0x0007, memory16get(0x1d68 + seg, 0x0007) + seg);
    memory16set(0x1d6b + seg, 0x000c, memory16get(0x1d6b + seg, 0x000c) + seg);
    memory16set(0x1d6f + seg, 0x0004, memory16get(0x1d6f + seg, 0x0004) + seg);
    memory16set(0x1d73 + seg, 0x0008, memory16get(0x1d73 + seg, 0x0008) + seg);
    memory16set(0x1d74 + seg, 0x0007, memory16get(0x1d74 + seg, 0x0007) + seg);
    memory16set(0x1d75 + seg, 0x000e, memory16get(0x1d75 + seg, 0x000e) + seg);
    memory16set(0x1d81 + seg, 0x000a, memory16get(0x1d81 + seg, 0x000a) + seg);
    memory16set(0x1d8a + seg, 0x000e, memory16get(0x1d8a + seg, 0x000e) + seg);
    memory16set(0x1d90 + seg, 0x000a, memory16get(0x1d90 + seg, 0x000a) + seg);
    memory16set(0x1d95 + seg, 0x0007, memory16get(0x1d95 + seg, 0x0007) + seg);
    memory16set(0x1d97 + seg, 0x000f, memory16get(0x1d97 + seg, 0x000f) + seg);
    memory16set(0x1da1 + seg, 0x000c, memory16get(0x1da1 + seg, 0x000c) + seg);
    memory16set(0x1da2 + seg, 0x0000, memory16get(0x1da2 + seg, 0x0000) + seg);
    memory16set(0x1da2 + seg, 0x0004, memory16get(0x1da2 + seg, 0x0004) + seg);
    memory16set(0x1da2 + seg, 0x0008, memory16get(0x1da2 + seg, 0x0008) + seg);
    memory16set(0x1da2 + seg, 0x000c, memory16get(0x1da2 + seg, 0x000c) + seg);
    memory16set(0x1da3 + seg, 0x0000, memory16get(0x1da3 + seg, 0x0000) + seg);
    memory16set(0x1da3 + seg, 0x0004, memory16get(0x1da3 + seg, 0x0004) + seg);
    memory16set(0x1da3 + seg, 0x0008, memory16get(0x1da3 + seg, 0x0008) + seg);
    memory16set(0x1da3 + seg, 0x000c, memory16get(0x1da3 + seg, 0x000c) + seg);
    memory16set(0x1da4 + seg, 0x0000, memory16get(0x1da4 + seg, 0x0000) + seg);
    memory16set(0x1da4 + seg, 0x0004, memory16get(0x1da4 + seg, 0x0004) + seg);
    memory16set(0x1da4 + seg, 0x0008, memory16get(0x1da4 + seg, 0x0008) + seg);
    memory16set(0x1da4 + seg, 0x000c, memory16get(0x1da4 + seg, 0x000c) + seg);
    memory16set(0x1da5 + seg, 0x0000, memory16get(0x1da5 + seg, 0x0000) + seg);
    memory16set(0x1da5 + seg, 0x0004, memory16get(0x1da5 + seg, 0x0004) + seg);
    memory16set(0x1da5 + seg, 0x0008, memory16get(0x1da5 + seg, 0x0008) + seg);
    memory16set(0x1da5 + seg, 0x000c, memory16get(0x1da5 + seg, 0x000c) + seg);
    memory16set(0x1da6 + seg, 0x0000, memory16get(0x1da6 + seg, 0x0000) + seg);
    memory16set(0x1da6 + seg, 0x0004, memory16get(0x1da6 + seg, 0x0004) + seg);
    memory16set(0x1da6 + seg, 0x0008, memory16get(0x1da6 + seg, 0x0008) + seg);
    memory16set(0x1da6 + seg, 0x000c, memory16get(0x1da6 + seg, 0x000c) + seg);
    memory16set(0x1dbc + seg, 0x0000, memory16get(0x1dbc + seg, 0x0000) + seg);
    memory16set(0x1dbc + seg, 0x0004, memory16get(0x1dbc + seg, 0x0004) + seg);
    memory16set(0x1dbc + seg, 0x0008, memory16get(0x1dbc + seg, 0x0008) + seg);
    memory16set(0x1dbc + seg, 0x000c, memory16get(0x1dbc + seg, 0x000c) + seg);
    memory16set(0x1dbd + seg, 0x0000, memory16get(0x1dbd + seg, 0x0000) + seg);
    memory16set(0x1dbd + seg, 0x0004, memory16get(0x1dbd + seg, 0x0004) + seg);
    memory16set(0x1dbd + seg, 0x0008, memory16get(0x1dbd + seg, 0x0008) + seg);
    memory16set(0x1dbd + seg, 0x000c, memory16get(0x1dbd + seg, 0x000c) + seg);
    memory16set(0x1dbe + seg, 0x0000, memory16get(0x1dbe + seg, 0x0000) + seg);
    memory16set(0x1dbe + seg, 0x0004, memory16get(0x1dbe + seg, 0x0004) + seg);
    memory16set(0x1dbe + seg, 0x0008, memory16get(0x1dbe + seg, 0x0008) + seg);
    memory16set(0x1dbe + seg, 0x000c, memory16get(0x1dbe + seg, 0x000c) + seg);
    memory16set(0x1df5 + seg, 0x0002, memory16get(0x1df5 + seg, 0x0002) + seg);
    memory16set(0x1df5 + seg, 0x0006, memory16get(0x1df5 + seg, 0x0006) + seg);
    memory16set(0x1df5 + seg, 0x000a, memory16get(0x1df5 + seg, 0x000a) + seg);
    memory16set(0x1df5 + seg, 0x000e, memory16get(0x1df5 + seg, 0x000e) + seg);
    memory16set(0x1df6 + seg, 0x0002, memory16get(0x1df6 + seg, 0x0002) + seg);
    memory16set(0x1df6 + seg, 0x0006, memory16get(0x1df6 + seg, 0x0006) + seg);
    memory16set(0x1df6 + seg, 0x000a, memory16get(0x1df6 + seg, 0x000a) + seg);
    memory16set(0x1df6 + seg, 0x000e, memory16get(0x1df6 + seg, 0x000e) + seg);
    memory16set(0x1df7 + seg, 0x0002, memory16get(0x1df7 + seg, 0x0002) + seg);
    memory16set(0x1df7 + seg, 0x0006, memory16get(0x1df7 + seg, 0x0006) + seg);
    memory16set(0x1df7 + seg, 0x000a, memory16get(0x1df7 + seg, 0x000a) + seg);
    memory16set(0x1df7 + seg, 0x000e, memory16get(0x1df7 + seg, 0x000e) + seg);
    memory16set(0x1df8 + seg, 0x0002, memory16get(0x1df8 + seg, 0x0002) + seg);
    memory16set(0x1df8 + seg, 0x0006, memory16get(0x1df8 + seg, 0x0006) + seg);
    memory16set(0x1df8 + seg, 0x000a, memory16get(0x1df8 + seg, 0x000a) + seg);
    memory16set(0x1df8 + seg, 0x000e, memory16get(0x1df8 + seg, 0x000e) + seg);
    memory16set(0x1df9 + seg, 0x0002, memory16get(0x1df9 + seg, 0x0002) + seg);
    memory16set(0x1df9 + seg, 0x0006, memory16get(0x1df9 + seg, 0x0006) + seg);
    memory16set(0x1df9 + seg, 0x000a, memory16get(0x1df9 + seg, 0x000a) + seg);
    memory16set(0x1df9 + seg, 0x000e, memory16get(0x1df9 + seg, 0x000e) + seg);
    memory16set(0x1dfa + seg, 0x0002, memory16get(0x1dfa + seg, 0x0002) + seg);
    memory16set(0x1dfa + seg, 0x0006, memory16get(0x1dfa + seg, 0x0006) + seg);
    memory16set(0x1dfa + seg, 0x000a, memory16get(0x1dfa + seg, 0x000a) + seg);
    memory16set(0x1dfa + seg, 0x000e, memory16get(0x1dfa + seg, 0x000e) + seg);
    memory16set(0x1dfb + seg, 0x0002, memory16get(0x1dfb + seg, 0x0002) + seg);
    memory16set(0x1dfb + seg, 0x0006, memory16get(0x1dfb + seg, 0x0006) + seg);
    memory16set(0x1dfb + seg, 0x000a, memory16get(0x1dfb + seg, 0x000a) + seg);
    memory16set(0x1dfb + seg, 0x000e, memory16get(0x1dfb + seg, 0x000e) + seg);
    memory16set(0x1dfc + seg, 0x0002, memory16get(0x1dfc + seg, 0x0002) + seg);
    memory16set(0x1dfc + seg, 0x0006, memory16get(0x1dfc + seg, 0x0006) + seg);
    memory16set(0x1dfc + seg, 0x000a, memory16get(0x1dfc + seg, 0x000a) + seg);
    memory16set(0x1dfc + seg, 0x000e, memory16get(0x1dfc + seg, 0x000e) + seg);
    memory16set(0x1dfd + seg, 0x0002, memory16get(0x1dfd + seg, 0x0002) + seg);
    memory16set(0x1dfd + seg, 0x0006, memory16get(0x1dfd + seg, 0x0006) + seg);
    memory16set(0x1dfd + seg, 0x000a, memory16get(0x1dfd + seg, 0x000a) + seg);
    memory16set(0x1dfd + seg, 0x000e, memory16get(0x1dfd + seg, 0x000e) + seg);
    memory16set(0x1dfe + seg, 0x0002, memory16get(0x1dfe + seg, 0x0002) + seg);
    memory16set(0x1dfe + seg, 0x0006, memory16get(0x1dfe + seg, 0x0006) + seg);
    memory16set(0x1dfe + seg, 0x000a, memory16get(0x1dfe + seg, 0x000a) + seg);
    memory16set(0x1dfe + seg, 0x000e, memory16get(0x1dfe + seg, 0x000e) + seg);
    memory16set(0x1dff + seg, 0x0002, memory16get(0x1dff + seg, 0x0002) + seg);
    memory16set(0x1dff + seg, 0x0006, memory16get(0x1dff + seg, 0x0006) + seg);
    memory16set(0x1dff + seg, 0x000a, memory16get(0x1dff + seg, 0x000a) + seg);
    memory16set(0x1dff + seg, 0x000e, memory16get(0x1dff + seg, 0x000e) + seg);
    memory16set(0x1e00 + seg, 0x0002, memory16get(0x1e00 + seg, 0x0002) + seg);
    memory16set(0x1e00 + seg, 0x0006, memory16get(0x1e00 + seg, 0x0006) + seg);
    memory16set(0x1e00 + seg, 0x000a, memory16get(0x1e00 + seg, 0x000a) + seg);
    memory16set(0x1e00 + seg, 0x000e, memory16get(0x1e00 + seg, 0x000e) + seg);
    memory16set(0x1e01 + seg, 0x0002, memory16get(0x1e01 + seg, 0x0002) + seg);
    memory16set(0x1e01 + seg, 0x0006, memory16get(0x1e01 + seg, 0x0006) + seg);
    memory16set(0x1e01 + seg, 0x000a, memory16get(0x1e01 + seg, 0x000a) + seg);
    memory16set(0x1e01 + seg, 0x000e, memory16get(0x1e01 + seg, 0x000e) + seg);
    memory16set(0x1e02 + seg, 0x0002, memory16get(0x1e02 + seg, 0x0002) + seg);
    memory16set(0x1e02 + seg, 0x0006, memory16get(0x1e02 + seg, 0x0006) + seg);
    memory16set(0x1e02 + seg, 0x000a, memory16get(0x1e02 + seg, 0x000a) + seg);
    memory16set(0x1e02 + seg, 0x000e, memory16get(0x1e02 + seg, 0x000e) + seg);
    memory16set(0x1e03 + seg, 0x0002, memory16get(0x1e03 + seg, 0x0002) + seg);
    memory16set(0x1e03 + seg, 0x0006, memory16get(0x1e03 + seg, 0x0006) + seg);
    memory16set(0x1e03 + seg, 0x000a, memory16get(0x1e03 + seg, 0x000a) + seg);
    memory16set(0x1e03 + seg, 0x000e, memory16get(0x1e03 + seg, 0x000e) + seg);
    memory16set(0x1e04 + seg, 0x0002, memory16get(0x1e04 + seg, 0x0002) + seg);
    memory16set(0x1e04 + seg, 0x0006, memory16get(0x1e04 + seg, 0x0006) + seg);
    memory16set(0x1e04 + seg, 0x000a, memory16get(0x1e04 + seg, 0x000a) + seg);
    memory16set(0x1e04 + seg, 0x000e, memory16get(0x1e04 + seg, 0x000e) + seg);
    memory16set(0x1e05 + seg, 0x0002, memory16get(0x1e05 + seg, 0x0002) + seg);
    memory16set(0x1e05 + seg, 0x0006, memory16get(0x1e05 + seg, 0x0006) + seg);
    memory16set(0x1e05 + seg, 0x000a, memory16get(0x1e05 + seg, 0x000a) + seg);
    memory16set(0x1e05 + seg, 0x000e, memory16get(0x1e05 + seg, 0x000e) + seg);
    memory16set(0x1e06 + seg, 0x0002, memory16get(0x1e06 + seg, 0x0002) + seg);
    memory16set(0x1e06 + seg, 0x0006, memory16get(0x1e06 + seg, 0x0006) + seg);
    memory16set(0x1e06 + seg, 0x000a, memory16get(0x1e06 + seg, 0x000a) + seg);
    memory16set(0x1e06 + seg, 0x000e, memory16get(0x1e06 + seg, 0x000e) + seg);
    memory16set(0x1e07 + seg, 0x0002, memory16get(0x1e07 + seg, 0x0002) + seg);
    memory16set(0x1e07 + seg, 0x0006, memory16get(0x1e07 + seg, 0x0006) + seg);
    memory16set(0x1e07 + seg, 0x000a, memory16get(0x1e07 + seg, 0x000a) + seg);
    memory16set(0x1e07 + seg, 0x000e, memory16get(0x1e07 + seg, 0x000e) + seg);
    memory16set(0x1e08 + seg, 0x0002, memory16get(0x1e08 + seg, 0x0002) + seg);
    memory16set(0x1e08 + seg, 0x0006, memory16get(0x1e08 + seg, 0x0006) + seg);
    memory16set(0x1e08 + seg, 0x000a, memory16get(0x1e08 + seg, 0x000a) + seg);
    memory16set(0x1e08 + seg, 0x000e, memory16get(0x1e08 + seg, 0x000e) + seg);
    memory16set(0x1e09 + seg, 0x0002, memory16get(0x1e09 + seg, 0x0002) + seg);
    memory16set(0x1e09 + seg, 0x0006, memory16get(0x1e09 + seg, 0x0006) + seg);
    memory16set(0x1e09 + seg, 0x000a, memory16get(0x1e09 + seg, 0x000a) + seg);
    memory16set(0x1e09 + seg, 0x000e, memory16get(0x1e09 + seg, 0x000e) + seg);
    memory16set(0x1e0a + seg, 0x0002, memory16get(0x1e0a + seg, 0x0002) + seg);
    memory16set(0x1e0a + seg, 0x0006, memory16get(0x1e0a + seg, 0x0006) + seg);
    memory16set(0x1e0a + seg, 0x000a, memory16get(0x1e0a + seg, 0x000a) + seg);
    memory16set(0x1e0a + seg, 0x000e, memory16get(0x1e0a + seg, 0x000e) + seg);
    memory16set(0x1e0b + seg, 0x0002, memory16get(0x1e0b + seg, 0x0002) + seg);
    memory16set(0x1e0b + seg, 0x0006, memory16get(0x1e0b + seg, 0x0006) + seg);
    memory16set(0x1e0b + seg, 0x000a, memory16get(0x1e0b + seg, 0x000a) + seg);
    memory16set(0x1e0b + seg, 0x000e, memory16get(0x1e0b + seg, 0x000e) + seg);
    memory16set(0x1e0c + seg, 0x0002, memory16get(0x1e0c + seg, 0x0002) + seg);
    memory16set(0x1e0c + seg, 0x0006, memory16get(0x1e0c + seg, 0x0006) + seg);
    memory16set(0x1e0c + seg, 0x000a, memory16get(0x1e0c + seg, 0x000a) + seg);
    memory16set(0x1e0c + seg, 0x000e, memory16get(0x1e0c + seg, 0x000e) + seg);
    memory16set(0x1e0d + seg, 0x0002, memory16get(0x1e0d + seg, 0x0002) + seg);
    memory16set(0x1e0d + seg, 0x0006, memory16get(0x1e0d + seg, 0x0006) + seg);
    memory16set(0x1e0d + seg, 0x000a, memory16get(0x1e0d + seg, 0x000a) + seg);
    memory16set(0x1e0d + seg, 0x000e, memory16get(0x1e0d + seg, 0x000e) + seg);
    memory16set(0x1e0e + seg, 0x0002, memory16get(0x1e0e + seg, 0x0002) + seg);
    memory16set(0x1e0e + seg, 0x0006, memory16get(0x1e0e + seg, 0x0006) + seg);
    memory16set(0x1e0e + seg, 0x000a, memory16get(0x1e0e + seg, 0x000a) + seg);
    memory16set(0x1e0e + seg, 0x000e, memory16get(0x1e0e + seg, 0x000e) + seg);
    memory16set(0x1e0f + seg, 0x0002, memory16get(0x1e0f + seg, 0x0002) + seg);
    memory16set(0x1e0f + seg, 0x0006, memory16get(0x1e0f + seg, 0x0006) + seg);
    memory16set(0x1e0f + seg, 0x000a, memory16get(0x1e0f + seg, 0x000a) + seg);
    memory16set(0x1e0f + seg, 0x000e, memory16get(0x1e0f + seg, 0x000e) + seg);
    memory16set(0x1e10 + seg, 0x0002, memory16get(0x1e10 + seg, 0x0002) + seg);
    memory16set(0x1e10 + seg, 0x0006, memory16get(0x1e10 + seg, 0x0006) + seg);
    memory16set(0x1e10 + seg, 0x000a, memory16get(0x1e10 + seg, 0x000a) + seg);
    memory16set(0x1e10 + seg, 0x000e, memory16get(0x1e10 + seg, 0x000e) + seg);
    memory16set(0x1e11 + seg, 0x0002, memory16get(0x1e11 + seg, 0x0002) + seg);
    memory16set(0x1e11 + seg, 0x0006, memory16get(0x1e11 + seg, 0x0006) + seg);
    memory16set(0x1e11 + seg, 0x000a, memory16get(0x1e11 + seg, 0x000a) + seg);
    memory16set(0x1e11 + seg, 0x000e, memory16get(0x1e11 + seg, 0x000e) + seg);
    memory16set(0x1e12 + seg, 0x0002, memory16get(0x1e12 + seg, 0x0002) + seg);
    memory16set(0x1e12 + seg, 0x0006, memory16get(0x1e12 + seg, 0x0006) + seg);
    memory16set(0x1e12 + seg, 0x000a, memory16get(0x1e12 + seg, 0x000a) + seg);
    memory16set(0x1e12 + seg, 0x000e, memory16get(0x1e12 + seg, 0x000e) + seg);
    memory16set(0x1e13 + seg, 0x0002, memory16get(0x1e13 + seg, 0x0002) + seg);
    memory16set(0x1e13 + seg, 0x0006, memory16get(0x1e13 + seg, 0x0006) + seg);
    memory16set(0x1e13 + seg, 0x000a, memory16get(0x1e13 + seg, 0x000a) + seg);
    memory16set(0x1e13 + seg, 0x000e, memory16get(0x1e13 + seg, 0x000e) + seg);
    memory16set(0x1e14 + seg, 0x0002, memory16get(0x1e14 + seg, 0x0002) + seg);
    memory16set(0x1e14 + seg, 0x0006, memory16get(0x1e14 + seg, 0x0006) + seg);
    memory16set(0x1e14 + seg, 0x000a, memory16get(0x1e14 + seg, 0x000a) + seg);
    memory16set(0x1e14 + seg, 0x000e, memory16get(0x1e14 + seg, 0x000e) + seg);
    memory16set(0x1e15 + seg, 0x0002, memory16get(0x1e15 + seg, 0x0002) + seg);
    memory16set(0x1e15 + seg, 0x0006, memory16get(0x1e15 + seg, 0x0006) + seg);
    memory16set(0x1e15 + seg, 0x000a, memory16get(0x1e15 + seg, 0x000a) + seg);
    memory16set(0x1e15 + seg, 0x000e, memory16get(0x1e15 + seg, 0x000e) + seg);
    memory16set(0x1e16 + seg, 0x0002, memory16get(0x1e16 + seg, 0x0002) + seg);
    memory16set(0x1e16 + seg, 0x0006, memory16get(0x1e16 + seg, 0x0006) + seg);
    memory16set(0x1e16 + seg, 0x000a, memory16get(0x1e16 + seg, 0x000a) + seg);
    memory16set(0x1e16 + seg, 0x000e, memory16get(0x1e16 + seg, 0x000e) + seg);
    memory16set(0x1e17 + seg, 0x0002, memory16get(0x1e17 + seg, 0x0002) + seg);
    memory16set(0x1e17 + seg, 0x0006, memory16get(0x1e17 + seg, 0x0006) + seg);
    memory16set(0x1e17 + seg, 0x000a, memory16get(0x1e17 + seg, 0x000a) + seg);
    memory16set(0x1e17 + seg, 0x000e, memory16get(0x1e17 + seg, 0x000e) + seg);
    memory16set(0x1e18 + seg, 0x0002, memory16get(0x1e18 + seg, 0x0002) + seg);
    memory16set(0x1e18 + seg, 0x0006, memory16get(0x1e18 + seg, 0x0006) + seg);
    memory16set(0x1e18 + seg, 0x000a, memory16get(0x1e18 + seg, 0x000a) + seg);
    memory16set(0x1e18 + seg, 0x000e, memory16get(0x1e18 + seg, 0x000e) + seg);
    memory16set(0x1e19 + seg, 0x0002, memory16get(0x1e19 + seg, 0x0002) + seg);
    memory16set(0x1e19 + seg, 0x0006, memory16get(0x1e19 + seg, 0x0006) + seg);
    memory16set(0x1e19 + seg, 0x000a, memory16get(0x1e19 + seg, 0x000a) + seg);
    memory16set(0x1e19 + seg, 0x000e, memory16get(0x1e19 + seg, 0x000e) + seg);
    memory16set(0x1e1a + seg, 0x0002, memory16get(0x1e1a + seg, 0x0002) + seg);
    memory16set(0x1e1a + seg, 0x0006, memory16get(0x1e1a + seg, 0x0006) + seg);
    memory16set(0x1e1a + seg, 0x000a, memory16get(0x1e1a + seg, 0x000a) + seg);
    memory16set(0x1e1a + seg, 0x000e, memory16get(0x1e1a + seg, 0x000e) + seg);
    memory16set(0x1e1b + seg, 0x0002, memory16get(0x1e1b + seg, 0x0002) + seg);
    memory16set(0x1e1b + seg, 0x0006, memory16get(0x1e1b + seg, 0x0006) + seg);
    memory16set(0x1e1b + seg, 0x000a, memory16get(0x1e1b + seg, 0x000a) + seg);
    memory16set(0x1e1b + seg, 0x000e, memory16get(0x1e1b + seg, 0x000e) + seg);
    memory16set(0x1e1c + seg, 0x0002, memory16get(0x1e1c + seg, 0x0002) + seg);
    memory16set(0x1e1c + seg, 0x0006, memory16get(0x1e1c + seg, 0x0006) + seg);
    memory16set(0x1e1c + seg, 0x000a, memory16get(0x1e1c + seg, 0x000a) + seg);
    memory16set(0x1e1c + seg, 0x000e, memory16get(0x1e1c + seg, 0x000e) + seg);
    memory16set(0x1e1d + seg, 0x0002, memory16get(0x1e1d + seg, 0x0002) + seg);
    memory16set(0x1e1d + seg, 0x0006, memory16get(0x1e1d + seg, 0x0006) + seg);
    memory16set(0x1e1d + seg, 0x000a, memory16get(0x1e1d + seg, 0x000a) + seg);
    memory16set(0x1e1d + seg, 0x000e, memory16get(0x1e1d + seg, 0x000e) + seg);
    memory16set(0x1e1e + seg, 0x0002, memory16get(0x1e1e + seg, 0x0002) + seg);
    memory16set(0x1e1e + seg, 0x0006, memory16get(0x1e1e + seg, 0x0006) + seg);
    memory16set(0x1e1e + seg, 0x000a, memory16get(0x1e1e + seg, 0x000a) + seg);
    memory16set(0x1e1e + seg, 0x000e, memory16get(0x1e1e + seg, 0x000e) + seg);
    memory16set(0x1e1f + seg, 0x0002, memory16get(0x1e1f + seg, 0x0002) + seg);
    memory16set(0x1e1f + seg, 0x0006, memory16get(0x1e1f + seg, 0x0006) + seg);
    memory16set(0x1e1f + seg, 0x000a, memory16get(0x1e1f + seg, 0x000a) + seg);
    memory16set(0x1e1f + seg, 0x000e, memory16get(0x1e1f + seg, 0x000e) + seg);
    memory16set(0x1e20 + seg, 0x0002, memory16get(0x1e20 + seg, 0x0002) + seg);
    memory16set(0x1e20 + seg, 0x0006, memory16get(0x1e20 + seg, 0x0006) + seg);
    memory16set(0x1e20 + seg, 0x000a, memory16get(0x1e20 + seg, 0x000a) + seg);
    memory16set(0x1e20 + seg, 0x000e, memory16get(0x1e20 + seg, 0x000e) + seg);
    memory16set(0x1e21 + seg, 0x0002, memory16get(0x1e21 + seg, 0x0002) + seg);
    memory16set(0x1e21 + seg, 0x0006, memory16get(0x1e21 + seg, 0x0006) + seg);
    memory16set(0x1e21 + seg, 0x000a, memory16get(0x1e21 + seg, 0x000a) + seg);
    memory16set(0x1e21 + seg, 0x000e, memory16get(0x1e21 + seg, 0x000e) + seg);
    memory16set(0x1e22 + seg, 0x0002, memory16get(0x1e22 + seg, 0x0002) + seg);
    memory16set(0x1e22 + seg, 0x0006, memory16get(0x1e22 + seg, 0x0006) + seg);
    memory16set(0x1e22 + seg, 0x000a, memory16get(0x1e22 + seg, 0x000a) + seg);
    memory16set(0x1e22 + seg, 0x000e, memory16get(0x1e22 + seg, 0x000e) + seg);
    memory16set(0x1e23 + seg, 0x0002, memory16get(0x1e23 + seg, 0x0002) + seg);
    memory16set(0x1e23 + seg, 0x0006, memory16get(0x1e23 + seg, 0x0006) + seg);
    memory16set(0x1e23 + seg, 0x000a, memory16get(0x1e23 + seg, 0x000a) + seg);
    memory16set(0x1e23 + seg, 0x000e, memory16get(0x1e23 + seg, 0x000e) + seg);
    memory16set(0x1e24 + seg, 0x0002, memory16get(0x1e24 + seg, 0x0002) + seg);
    memory16set(0x1e24 + seg, 0x0006, memory16get(0x1e24 + seg, 0x0006) + seg);
    memory16set(0x1e24 + seg, 0x000a, memory16get(0x1e24 + seg, 0x000a) + seg);
    memory16set(0x1e24 + seg, 0x000e, memory16get(0x1e24 + seg, 0x000e) + seg);
    memory16set(0x1e25 + seg, 0x0002, memory16get(0x1e25 + seg, 0x0002) + seg);
    memory16set(0x1e25 + seg, 0x0006, memory16get(0x1e25 + seg, 0x0006) + seg);
    memory16set(0x1e25 + seg, 0x000a, memory16get(0x1e25 + seg, 0x000a) + seg);
    memory16set(0x1e25 + seg, 0x000e, memory16get(0x1e25 + seg, 0x000e) + seg);
    memory16set(0x1e26 + seg, 0x0002, memory16get(0x1e26 + seg, 0x0002) + seg);
    memory16set(0x1e26 + seg, 0x0006, memory16get(0x1e26 + seg, 0x0006) + seg);
    memory16set(0x1e26 + seg, 0x000a, memory16get(0x1e26 + seg, 0x000a) + seg);
    memory16set(0x1e26 + seg, 0x000e, memory16get(0x1e26 + seg, 0x000e) + seg);
    memory16set(0x1e27 + seg, 0x0002, memory16get(0x1e27 + seg, 0x0002) + seg);
    memory16set(0x1e27 + seg, 0x0006, memory16get(0x1e27 + seg, 0x0006) + seg);
    memory16set(0x1e27 + seg, 0x000a, memory16get(0x1e27 + seg, 0x000a) + seg);
    memory16set(0x1e27 + seg, 0x000e, memory16get(0x1e27 + seg, 0x000e) + seg);
    memory16set(0x1e28 + seg, 0x0002, memory16get(0x1e28 + seg, 0x0002) + seg);
    memory16set(0x1e28 + seg, 0x0006, memory16get(0x1e28 + seg, 0x0006) + seg);
    memory16set(0x1e28 + seg, 0x000a, memory16get(0x1e28 + seg, 0x000a) + seg);
    memory16set(0x1e28 + seg, 0x000e, memory16get(0x1e28 + seg, 0x000e) + seg);
    memory16set(0x1e29 + seg, 0x0002, memory16get(0x1e29 + seg, 0x0002) + seg);
    memory16set(0x1e29 + seg, 0x0006, memory16get(0x1e29 + seg, 0x0006) + seg);
    memory16set(0x1e29 + seg, 0x000a, memory16get(0x1e29 + seg, 0x000a) + seg);
    memory16set(0x1e29 + seg, 0x000e, memory16get(0x1e29 + seg, 0x000e) + seg);
    memory16set(0x1e2a + seg, 0x0002, memory16get(0x1e2a + seg, 0x0002) + seg);
    memory16set(0x1e2a + seg, 0x0006, memory16get(0x1e2a + seg, 0x0006) + seg);
    memory16set(0x1e2a + seg, 0x000a, memory16get(0x1e2a + seg, 0x000a) + seg);
    memory16set(0x1e2a + seg, 0x000e, memory16get(0x1e2a + seg, 0x000e) + seg);
    memory16set(0x1e2b + seg, 0x0002, memory16get(0x1e2b + seg, 0x0002) + seg);
    memory16set(0x1e2b + seg, 0x0006, memory16get(0x1e2b + seg, 0x0006) + seg);
    memory16set(0x1e2b + seg, 0x000a, memory16get(0x1e2b + seg, 0x000a) + seg);
    memory16set(0x1e2b + seg, 0x000e, memory16get(0x1e2b + seg, 0x000e) + seg);
    memory16set(0x1e2c + seg, 0x0002, memory16get(0x1e2c + seg, 0x0002) + seg);
    memory16set(0x1e2c + seg, 0x0006, memory16get(0x1e2c + seg, 0x0006) + seg);
    memory16set(0x1e2c + seg, 0x000a, memory16get(0x1e2c + seg, 0x000a) + seg);
    memory16set(0x1e2c + seg, 0x000e, memory16get(0x1e2c + seg, 0x000e) + seg);
    memory16set(0x1e2d + seg, 0x0002, memory16get(0x1e2d + seg, 0x0002) + seg);
    memory16set(0x1e2d + seg, 0x0006, memory16get(0x1e2d + seg, 0x0006) + seg);
    memory16set(0x1e2d + seg, 0x000a, memory16get(0x1e2d + seg, 0x000a) + seg);
    memory16set(0x1e2d + seg, 0x000e, memory16get(0x1e2d + seg, 0x000e) + seg);
    memory16set(0x1e2e + seg, 0x0002, memory16get(0x1e2e + seg, 0x0002) + seg);
    memory16set(0x1e2e + seg, 0x0006, memory16get(0x1e2e + seg, 0x0006) + seg);
    memory16set(0x1e2e + seg, 0x000a, memory16get(0x1e2e + seg, 0x000a) + seg);
    memory16set(0x1e2e + seg, 0x000e, memory16get(0x1e2e + seg, 0x000e) + seg);
    memory16set(0x1e2f + seg, 0x0002, memory16get(0x1e2f + seg, 0x0002) + seg);
    memory16set(0x1e2f + seg, 0x0006, memory16get(0x1e2f + seg, 0x0006) + seg);
    memory16set(0x1e2f + seg, 0x000a, memory16get(0x1e2f + seg, 0x000a) + seg);
    memory16set(0x255c + seg, 0x0002, memory16get(0x255c + seg, 0x0002) + seg);
    memory16set(0x255c + seg, 0x0006, memory16get(0x255c + seg, 0x0006) + seg);
    memory16set(0x255c + seg, 0x000a, memory16get(0x255c + seg, 0x000a) + seg);
    memory16set(0x255c + seg, 0x000e, memory16get(0x255c + seg, 0x000e) + seg);
    memory16set(0x255d + seg, 0x0002, memory16get(0x255d + seg, 0x0002) + seg);
    memory16set(0x255d + seg, 0x0006, memory16get(0x255d + seg, 0x0006) + seg);
    memory16set(0x255d + seg, 0x000a, memory16get(0x255d + seg, 0x000a) + seg);
    memory16set(0x255d + seg, 0x000e, memory16get(0x255d + seg, 0x000e) + seg);
    memory16set(0x2609 + seg, 0x000c, memory16get(0x2609 + seg, 0x000c) + seg);
    memory16set(0x260a + seg, 0x0000, memory16get(0x260a + seg, 0x0000) + seg);
    memory16set(0x260a + seg, 0x0004, memory16get(0x260a + seg, 0x0004) + seg);
    memory16set(0x260d + seg, 0x0006, memory16get(0x260d + seg, 0x0006) + seg);
    memory16set(0x260d + seg, 0x000a, memory16get(0x260d + seg, 0x000a) + seg);
}
function* sub_1ed0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        flags.interrupts = true;
        r16[dx] = 0x1f86;
        memory16set(cs, 0x0172, r16[dx]);
        r8[ah] = 0x30;
        interrupt(0x21);
        bp = memoryPsp16(ds, 0x0002);
        r16[bx] = memoryPsp16(ds, 0x002c);
        ds = r16[dx];
        memory16set(ds, 0x0071, r16[ax]);
        memory16set(ds, 0x006f, es);
        memory16set(ds, 0x006b, r16[bx]);
        memory16set(ds, 0x0081, bp);
        memory16set(ds, 0x0075, 0xffff);
        yield* sub_1ff2();
        r16[di] = memory16get(ds, 0x0069);
        es = memory16get(ds, 0x0069 + 2);
        r16[ax] = r16[di];
        r16[bx] = r16[ax];
        r16[cx] = 0x7fff;
    case 0x1f0a:
        if (memoryPsp16(es, r16[di]) != 0x3738) {
            pc = 0x1f2a;
            break;
        }
        r16[dx] = memory16get(es, r16[di] + 2);
        if (r8[dl] != 0x3d) {
            pc = 0x1f2a;
            break;
        }
        r8[dh] &= 0xdf;
        memory16set(ds, 0x0075, memory16get(ds, 0x0075) + 1);
        if (r8[dh] != 0x59) {
            pc = 0x1f2a;
            break;
        }
        memory16set(ds, 0x0075, memory16get(ds, 0x0075) + 1);
    case 0x1f2a:
        repne_scasb_psp_forward(r8[al]);
        if (r16[cx] == 0) {
            pc = 0x1f70;
            break;
        }
        r16[bx]++;
        if (memoryPsp(es, r16[di]) != r8[al]) {
            pc = 0x1f0a;
            break;
        }
        r8[ch] |= 0x80;
        r16[cx] = -r16[cx];
        memory16set(ds, 0x0069, r16[cx]);
        r16[cx] = 0x0002;
        r16[bx] <<= r8[cl];
        r16[bx] += 0x0010;
        r16[bx] &= 0xfff0;
        memory16set(ds, 0x006d, r16[bx]);
        push(cs);
        yield* callIndirect(cs, memory16get(ds, 0x87b0));
        r16[dx] = ss;
        bp -= r16[dx];
        r16[di] = memory16get(ds, 0x1bf2);
        if (r16[di] >= 0x0100) {
            pc = 0x1f67;
            break;
        }
        r16[di] = 0x0100;
        memory16set(ds, 0x1bf2, r16[di]);
    case 0x1f67:
        r8[cl] = 0x04;
        r16[di] >>= r8[cl];
        r16[di]++;
        if (bp >= r16[di]) {
            pc = 0x1f73;
            break;
        }
    case 0x1f70:
        pc = 0x202a;
        break;
    case 0x1f73:
        r16[bx] = r16[di];
        r16[bx] += r16[dx];
        memory16set(ds, 0x0079, r16[bx]);
        memory16set(ds, 0x007d, r16[bx]);
        r16[ax] = memory16get(ds, 0x006f);
        r16[bx] -= r16[ax];
        es = r16[ax];
        r8[ah] = 0x4a;
        push(r16[di]);
        interrupt(0x21);
        r16[di] = pop();
        r16[di] <<= r8[cl];
        ss = r16[dx];
        sp = r16[di];
        push(cs);
        cs = 0x01ed;
        yield* sub_21f8();
        assert(cs == 0x01ed);
        push(cs);
        cs = 0x01ed;
        yield* sub_22f6();
        assert(cs == 0x01ed);
        r16[ax] = 0;
        es = memory16get(cs, 0x0172);
        r16[di] = 0x87b6;
        r16[cx] = 0x9cf8;
        r16[cx] -= r16[di];
        rep_stosb_data_forward();
        push(cs);
        yield* callIndirect(cs, memory16get(ds, 0x87b4));
        push(memory16get(ds, 0x0067));
        push(memory16get(ds, 0x0065));
        push(memory16get(ds, 0x0063));
        push(memory16get(ds, 0x0061));
        push(memory16get(ds, 0x005f));
        push(cs);
        cs = 0x12f9;
        yield* sub_1302c();
        assert(cs == 0x01ed);
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x01ed);
        ds = memory16get(cs, 0x0172);
        push(cs);
        cs = 0x01ed;
        yield* sub_200e();
        assert(cs == 0x01ed);
        push(cs);
        yield* callIndirect(cs, memory16get(ds, 0x87b2));
        bp = sp;
        r8[ah] = 0x4c;
        r8[al] = memory[ss*16 + bp + 4];
        interrupt(0x21);
        r16[cx] = 0x000e;
        r16[dx] = 0x002f;
        pc = 0x2031;
        break;
    case 0x202a:
        r16[cx] = 0x001e;
        r16[dx] = 0x003d;
    case 0x2031:
        ds = memory16get(cs, 0x0172);
        yield* sub_2022();
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x01ed;
        yield* sub_1fd1();
        assert(cs == 0x01ed);
        memory[ds*16 + r16[bx] + r16[si]] += r8[al];
        r8[cl] = 0x03;
        pc = 0x2052;
        break;
    case 0x2052:
        push(bp);
        push(r16[si]);
        push(r16[di]);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        bp = memory16get(ss, bp + 16);
        r16[si] = 0;
        if (r8[cl] & 0x01) {
            pc = 0x2089;
            break;
        }
        if (!(r16[dx] & 0x8000)) {
            pc = 0x2077;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= r16[si] + flags.carry;
        r8[cl] |= 0x04;
    case 0x2077:
        if (!(bp & 0x8000)) {
            pc = 0x2089;
            break;
        }
        bp = -bp;
        flags.carry = r16[bx] != 0;
        r16[bx] = -r16[bx];
        bp -= r16[si] + flags.carry;
        if (r8[cl] & 0x02) {
            pc = 0x2089;
            break;
        }
        r8[cl] ^= 0x04;
    case 0x2089:
        r16[di] = bp;
        r16[di] |= r16[dx];
        if (r16[di]) {
            pc = 0x2095;
            break;
        }
        div16(r16[bx]);
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        pc = 0x20b5;
        break;
    case 0x2095:
        push(r16[cx]);
        r16[cx] = 0x0020;
        r16[di] = r16[si];
    case 0x209b:
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        r16[si] = rcl16(r16[si], 0x0001);
        r16[di] = rcl16(r16[di], 0x0001);
        if (r16[di] < bp) {
            pc = 0x20b2;
            break;
        }
        if (r16[di] > bp) {
            pc = 0x20ad;
            break;
        }
        if (r16[si] < r16[bx]) {
            pc = 0x20b2;
            break;
        }
    case 0x20ad:
        flags.carry = r16[si] < r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= bp + flags.carry;
        r16[ax]++;
    case 0x20b2:
        if (--r16[cx]) {
            pc = 0x209b;
            break;
        }
        r16[cx] = pop();
    case 0x20b5:
        if (!(r8[cl] & 0x02)) {
            pc = 0x20bd;
            break;
        }
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = r16[di];
    case 0x20bd:
        if (!(r8[cl] & 0x04)) {
            pc = 0x20c9;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= flags.carry;
    case 0x20c9:
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    } while (1);
}
function* sub_1fd1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(8, true);
        push(0x7777);
        ds = memory16get(cs, 0x0172);
        push(cs);
        cs = 0x01ed;
        yield* sub_200e();
        assert(cs == 0x01ed);
        push(cs);
        yield* callIndirect(cs, memory16get(ds, 0x87b2));
        bp = sp;
        r8[ah] = 0x4c;
        r8[al] = memory[ss*16 + bp + 4];
        interrupt(0x21);
        r16[cx] = 0x000e;
        r16[dx] = 0x002f;
        pc = 0x2031;
        break;
    case 0x2031:
        ds = memory16get(cs, 0x0172);
        yield* sub_2022();
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x01ed;
        yield* sub_1fd1();
        assert(cs == 0x01ed);
        memory[ds*16 + r16[bx] + r16[si]] += r8[al];
        r8[cl] = 0x03;
        pc = 0x2052;
        break;
    case 0x2052:
        push(bp);
        push(r16[si]);
        push(r16[di]);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        bp = memory16get(ss, bp + 16);
        r16[si] = 0;
        if (r8[cl] & 0x01) {
            pc = 0x2089;
            break;
        }
        if (!(r16[dx] & 0x8000)) {
            pc = 0x2077;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= r16[si] + flags.carry;
        r8[cl] |= 0x04;
    case 0x2077:
        if (!(bp & 0x8000)) {
            pc = 0x2089;
            break;
        }
        bp = -bp;
        flags.carry = r16[bx] != 0;
        r16[bx] = -r16[bx];
        bp -= r16[si] + flags.carry;
        if (r8[cl] & 0x02) {
            pc = 0x2089;
            break;
        }
        r8[cl] ^= 0x04;
    case 0x2089:
        r16[di] = bp;
        r16[di] |= r16[dx];
        if (r16[di]) {
            pc = 0x2095;
            break;
        }
        div16(r16[bx]);
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        pc = 0x20b5;
        break;
    case 0x2095:
        push(r16[cx]);
        r16[cx] = 0x0020;
        r16[di] = r16[si];
    case 0x209b:
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        r16[si] = rcl16(r16[si], 0x0001);
        r16[di] = rcl16(r16[di], 0x0001);
        if (r16[di] < bp) {
            pc = 0x20b2;
            break;
        }
        if (r16[di] > bp) {
            pc = 0x20ad;
            break;
        }
        if (r16[si] < r16[bx]) {
            pc = 0x20b2;
            break;
        }
    case 0x20ad:
        flags.carry = r16[si] < r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= bp + flags.carry;
        r16[ax]++;
    case 0x20b2:
        if (--r16[cx]) {
            pc = 0x209b;
            break;
        }
        r16[cx] = pop();
    case 0x20b5:
        if (!(r8[cl] & 0x02)) {
            pc = 0x20bd;
            break;
        }
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = r16[di];
    case 0x20bd:
        if (!(r8[cl] & 0x04)) {
            pc = 0x20c9;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= flags.carry;
    case 0x20c9:
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    } while (1);
}
function* sub_1fe9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(8, true);
        push(0x7777);
        r16[cx] = 0x000e;
        r16[dx] = 0x002f;
        pc = 0x2031;
        break;
    case 0x2031:
        ds = memory16get(cs, 0x0172);
        yield* sub_2022();
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x01ed;
        yield* sub_1fd1();
        assert(cs == 0x01ed);
        memory[ds*16 + r16[bx] + r16[si]] += r8[al];
        r8[cl] = 0x03;
        pc = 0x2052;
        break;
    case 0x2052:
        push(bp);
        push(r16[si]);
        push(r16[di]);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        bp = memory16get(ss, bp + 16);
        r16[si] = 0;
        if (r8[cl] & 0x01) {
            pc = 0x2089;
            break;
        }
        if (!(r16[dx] & 0x8000)) {
            pc = 0x2077;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= r16[si] + flags.carry;
        r8[cl] |= 0x04;
    case 0x2077:
        if (!(bp & 0x8000)) {
            pc = 0x2089;
            break;
        }
        bp = -bp;
        flags.carry = r16[bx] != 0;
        r16[bx] = -r16[bx];
        bp -= r16[si] + flags.carry;
        if (r8[cl] & 0x02) {
            pc = 0x2089;
            break;
        }
        r8[cl] ^= 0x04;
    case 0x2089:
        r16[di] = bp;
        r16[di] |= r16[dx];
        if (r16[di]) {
            pc = 0x2095;
            break;
        }
        div16(r16[bx]);
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        pc = 0x20b5;
        break;
    case 0x2095:
        push(r16[cx]);
        r16[cx] = 0x0020;
        r16[di] = r16[si];
    case 0x209b:
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        r16[si] = rcl16(r16[si], 0x0001);
        r16[di] = rcl16(r16[di], 0x0001);
        if (r16[di] < bp) {
            pc = 0x20b2;
            break;
        }
        if (r16[di] > bp) {
            pc = 0x20ad;
            break;
        }
        if (r16[si] < r16[bx]) {
            pc = 0x20b2;
            break;
        }
    case 0x20ad:
        flags.carry = r16[si] < r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= bp + flags.carry;
        r16[ax]++;
    case 0x20b2:
        if (--r16[cx]) {
            pc = 0x209b;
            break;
        }
        r16[cx] = pop();
    case 0x20b5:
        if (!(r8[cl] & 0x02)) {
            pc = 0x20bd;
            break;
        }
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = r16[di];
    case 0x20bd:
        if (!(r8[cl] & 0x04)) {
            pc = 0x20c9;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= flags.carry;
    case 0x20c9:
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    } while (1);
}
function* sub_1ff2() {
    //CStackGuard sg(0, false);
    push(ds);
    r16[ax] = 0x3500;
    interrupt(0x21);
    memory16set(ds, 0x005b, r16[bx]);
    memory16set(ds, 0x005d, es);
    r16[ax] = 0x2500;
    r16[dx] = cs;
    ds = r16[dx];
    r16[dx] = 0x0119;
    interrupt(0x21);
    ds = pop();
}
function* sub_200e() {
    //CStackGuardFar sg(0, false);
    push(ds);
    r16[ax] = 0x2500;
    r16[dx] = memory16get(ds, 0x005b);
    ds = memory16get(ds, 0x005b + 2);
    interrupt(0x21);
    ds = pop();
    cs = pop();
}
function* sub_201a() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x0075, 0x0000);
    cs = pop();
}
function* sub_2021() {
    //CStackGuardFar sg(0, false);
    cs = pop();
}
function* sub_2022() {
    //CStackGuard sg(0, false);
    r8[ah] = 0x40;
    r16[bx] = 0x0002;
    interrupt(0x21);
}
function* sub_2044() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(8, true);
        push(0x7777);
        r8[cl] = 0x03;
        pc = 0x2052;
        break;
    case 0x2052:
        push(bp);
        push(r16[si]);
        push(r16[di]);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        bp = memory16get(ss, bp + 16);
        r16[si] = 0;
        if (r8[cl] & 0x01) {
            pc = 0x2089;
            break;
        }
        if (!(r16[dx] & 0x8000)) {
            pc = 0x2077;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= r16[si] + flags.carry;
        r8[cl] |= 0x04;
    case 0x2077:
        if (!(bp & 0x8000)) {
            pc = 0x2089;
            break;
        }
        bp = -bp;
        flags.carry = r16[bx] != 0;
        r16[bx] = -r16[bx];
        bp -= r16[si] + flags.carry;
        if (r8[cl] & 0x02) {
            pc = 0x2089;
            break;
        }
        r8[cl] ^= 0x04;
    case 0x2089:
        r16[di] = bp;
        r16[di] |= r16[dx];
        if (r16[di]) {
            pc = 0x2095;
            break;
        }
        div16(r16[bx]);
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        pc = 0x20b5;
        break;
    case 0x2095:
        push(r16[cx]);
        r16[cx] = 0x0020;
        r16[di] = r16[si];
    case 0x209b:
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        r16[si] = rcl16(r16[si], 0x0001);
        r16[di] = rcl16(r16[di], 0x0001);
        if (r16[di] < bp) {
            pc = 0x20b2;
            break;
        }
        if (r16[di] > bp) {
            pc = 0x20ad;
            break;
        }
        if (r16[si] < r16[bx]) {
            pc = 0x20b2;
            break;
        }
    case 0x20ad:
        flags.carry = r16[si] < r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= bp + flags.carry;
        r16[ax]++;
    case 0x20b2:
        if (--r16[cx]) {
            pc = 0x209b;
            break;
        }
        r16[cx] = pop();
    case 0x20b5:
        if (!(r8[cl] & 0x02)) {
            pc = 0x20bd;
            break;
        }
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = r16[di];
    case 0x20bd:
        if (!(r8[cl] & 0x04)) {
            pc = 0x20c9;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= flags.carry;
    case 0x20c9:
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    } while (1);
}
function* sub_204c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(8, true);
        push(0x7777);
        r8[cl] = 0x01;
        pc = 0x2052;
        break;
    case 0x2052:
        push(bp);
        push(r16[si]);
        push(r16[di]);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        bp = memory16get(ss, bp + 16);
        r16[si] = 0;
        if (r8[cl] & 0x01) {
            pc = 0x2089;
            break;
        }
        if (!(r16[dx] & 0x8000)) {
            pc = 0x2077;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= r16[si] + flags.carry;
        r8[cl] |= 0x04;
    case 0x2077:
        if (!(bp & 0x8000)) {
            pc = 0x2089;
            break;
        }
        bp = -bp;
        flags.carry = r16[bx] != 0;
        r16[bx] = -r16[bx];
        bp -= r16[si] + flags.carry;
        if (r8[cl] & 0x02) {
            pc = 0x2089;
            break;
        }
        r8[cl] ^= 0x04;
    case 0x2089:
        r16[di] = bp;
        r16[di] |= r16[dx];
        if (r16[di]) {
            pc = 0x2095;
            break;
        }
        div16(r16[bx]);
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        pc = 0x20b5;
        break;
    case 0x2095:
        push(r16[cx]);
        r16[cx] = 0x0020;
        r16[di] = r16[si];
    case 0x209b:
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        r16[si] = rcl16(r16[si], 0x0001);
        r16[di] = rcl16(r16[di], 0x0001);
        if (r16[di] < bp) {
            pc = 0x20b2;
            break;
        }
        if (r16[di] > bp) {
            pc = 0x20ad;
            break;
        }
        if (r16[si] < r16[bx]) {
            pc = 0x20b2;
            break;
        }
    case 0x20ad:
        flags.carry = r16[si] < r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= bp + flags.carry;
        r16[ax]++;
    case 0x20b2:
        if (--r16[cx]) {
            pc = 0x209b;
            break;
        }
        r16[cx] = pop();
    case 0x20b5:
        if (!(r8[cl] & 0x02)) {
            pc = 0x20bd;
            break;
        }
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = r16[di];
    case 0x20bd:
        if (!(r8[cl] & 0x04)) {
            pc = 0x20c9;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= flags.carry;
    case 0x20c9:
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    } while (1);
}
function* sub_2050() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(8, true);
        push(0x7777);
        r16[cx] = 0;
        push(bp);
        push(r16[si]);
        push(r16[di]);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        bp = memory16get(ss, bp + 16);
        r16[si] = 0;
        if (r8[cl] & 0x01) {
            pc = 0x2089;
            break;
        }
        if (!(r16[dx] & 0x8000)) {
            pc = 0x2077;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= r16[si] + flags.carry;
        r8[cl] |= 0x04;
    case 0x2077:
        if (!(bp & 0x8000)) {
            pc = 0x2089;
            break;
        }
        bp = -bp;
        flags.carry = r16[bx] != 0;
        r16[bx] = -r16[bx];
        bp -= r16[si] + flags.carry;
        if (r8[cl] & 0x02) {
            pc = 0x2089;
            break;
        }
        r8[cl] ^= 0x04;
    case 0x2089:
        r16[di] = bp;
        r16[di] |= r16[dx];
        if (r16[di]) {
            pc = 0x2095;
            break;
        }
        div16(r16[bx]);
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        pc = 0x20b5;
        break;
    case 0x2095:
        push(r16[cx]);
        r16[cx] = 0x0020;
        r16[di] = r16[si];
    case 0x209b:
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        r16[si] = rcl16(r16[si], 0x0001);
        r16[di] = rcl16(r16[di], 0x0001);
        if (r16[di] < bp) {
            pc = 0x20b2;
            break;
        }
        if (r16[di] > bp) {
            pc = 0x20ad;
            break;
        }
        if (r16[si] < r16[bx]) {
            pc = 0x20b2;
            break;
        }
    case 0x20ad:
        flags.carry = r16[si] < r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= bp + flags.carry;
        r16[ax]++;
    case 0x20b2:
        if (--r16[cx]) {
            pc = 0x209b;
            break;
        }
        r16[cx] = pop();
    case 0x20b5:
        if (!(r8[cl] & 0x02)) {
            pc = 0x20bd;
            break;
        }
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = r16[di];
    case 0x20bd:
        if (!(r8[cl] & 0x04)) {
            pc = 0x20c9;
            break;
        }
        r16[dx] = -r16[dx];
        flags.carry = r16[ax] != 0;
        r16[ax] = -r16[ax];
        r16[dx] -= flags.carry;
    case 0x20c9:
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    } while (1);
}
function* sub_20cf() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (r16[cx] <= 0x0020) {
            pc = 0x20d9;
            break;
        }
        r16[ax] = 0;
        r16[dx] = 0;
        cs = pop();
        return;
    case 0x20d9:
        r16[tx] = r16[cx];
        r16[cx]--;
        if (r16s[tx] < 1) {
            pc = 0x20e2;
            break;
        }
        flags.carry = !!(r16[ax] & 0x8000);
        r16[ax] <<= 1;
        r16[dx] = rcl16(r16[dx], 0x0001);
        pc = 0x20d9;
        break;
    case 0x20e2:
        cs = pop();
        return;
    } while (1);
}
function* sub_20f5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (r16[cx] <= 0x0020) {
            pc = 0x20ff;
            break;
        }
        r16[ax] = 0;
        r16[dx] = 0;
        cs = pop();
        return;
    case 0x20ff:
        r16[tx] = r16[cx];
        r16[cx]--;
        if (r16s[tx] < 1) {
            pc = 0x2108;
            break;
        }
        flags.carry = r16[dx] & 1;
        r16[dx] >>= 1;
        r16[ax] = rcr16(r16[ax], 0x0001);
        pc = 0x20ff;
        break;
    case 0x2108:
        cs = pop();
        return;
    } while (1);
}
function* sub_2109() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        r16[tx] = r16[dx];
        r16[dx] = r16[ax];
        r16[ax] = r16[tx];
        if (!r16[ax]) {
            pc = 0x2112;
            break;
        }
        mul16(r16[bx]);
    case 0x2112:
        r16[tx] = r16[cx];
        r16[cx] = r16[ax];
        r16[ax] = r16[tx];
        if (!r16[ax]) {
            pc = 0x211b;
            break;
        }
        mul16(r16[si]);
        r16[cx] += r16[ax];
    case 0x211b:
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        mul16(r16[bx]);
        r16[dx] += r16[cx];
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_2122() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (r16s[cx] >= 0) {
            pc = 0x2133;
            break;
        }
        r16[bx] = ~r16[bx];
        r16[cx] = ~r16[cx];
        flags.carry = (r16[bx] + 0x0001) >= 0x10000;
        r16[bx] += 0x0001;
        r16[cx] += flags.carry;
        pc = 0x215f;
        break;
    case 0x2133:
        flags.carry = (r16[ax] + r16[bx]) >= 0x10000;
        r16[ax] += r16[bx];
        if (!flags.carry) {
            pc = 0x213b;
            break;
        }
        r16[dx] += 0x1000;
    case 0x213b:
        r8[ch] = r8[cl];
        r8[cl] = 0x04;
        r8[ch] <<= r8[cl];
        r8[dh] += r8[ch];
        r8[ch] = r8[al];
        r16[ax] >>= r8[cl];
        r16[dx] += r16[ax];
        r8[al] = r8[ch];
        r16[ax] &= 0x000f;
        cs = pop();
        return;
    case 0x215f:
        flags.carry = r16[ax] < r16[bx];
        r16[ax] -= r16[bx];
        if (!flags.carry) {
            pc = 0x2167;
            break;
        }
        r16[dx] -= 0x1000;
    case 0x2167:
        r8[bh] = r8[cl];
        r8[cl] = 0x04;
        r8[bh] <<= r8[cl];
        r8[bl] = 0;
        r16[dx] -= r16[bx];
        r8[ch] = r8[al];
        r16[ax] >>= r8[cl];
        r16[dx] += r16[ax];
        r8[al] = r8[ch];
        r16[ax] &= 0x000f;
        cs = pop();
        return;
    } while (1);
}
function* sub_217d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[cx]);
        r8[ch] = r8[al];
        r8[cl] = 0x04;
        r16[ax] >>= r8[cl];
        r16[dx] += r16[ax];
        r8[al] = r8[ch];
        r8[ah] = r8[bl];
        r16[bx] >>= r8[cl];
        r16[cx] = pop();
        r16[cx] += r16[bx];
        r8[bl] = r8[ah];
        r16[ax] &= 0x000f;
        r16[bx] &= 0x000f;
        flags.carry = r16[dx] < r16[cx];
        flags.zero = r16[dx] == r16[cx];
        if (r16[dx] != r16[cx]) {
            pc = 0x219e;
            break;
        }
        flags.carry = r16[ax] < r16[bx];
        flags.zero = r16[ax] == r16[bx];
    case 0x219e:
        cs = pop();
        return;
    } while (1);
}
function* sub_219f() {
    //CStackGuardFar sg(0, false);
    push(r16[di]);
    r16[di] = r16[cx];
    r8[ch] = r8[dh];
    r8[cl] = 0x04;
    r16[dx] <<= r8[cl];
    r8[ch] >>= r8[cl];
    flags.carry = (r16[dx] + r16[ax]) >= 0x10000;
    r16[dx] += r16[ax];
    r8[ch] += flags.carry;
    r16[ax] = r16[di];
    r16[di] <<= r8[cl];
    r8[ah] >>= r8[cl];
    flags.carry = (r16[bx] + r16[di]) >= 0x10000;
    r16[bx] += r16[di];
    r8[ah] += flags.carry;
    flags.carry = r16[dx] < r16[bx];
    r16[dx] -= r16[bx];
    r8[ch] -= r8[ah] + flags.carry;
    r8[al] = r8[ch];
    cbw();
    r16[tx] = r16[dx];
    r16[dx] = r16[ax];
    r16[ax] = r16[tx];
    r16[di] = pop();
    cs = pop();
}
function* sub_21c4() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(8, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(r16[si]);
        push(r16[di]);
        push(ds);
        r16[si] = memory16get(ss, bp + 6);
        ds = memory16get(ss, bp + 6 + 2);
        r16[di] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[ax] = ds;
        r16[dx] = es;
        if (r16[ax] > r16[dx]) {
            pc = 0x21e7;
            break;
        }
        if (r16[si] > r16[di]) {
            pc = 0x21e7;
            break;
        }
        flags.direction = false;
    case 0x21dd:
        flags.direction ? rep_movsb_data_data_backward() : rep_movsb_data_data_forward();
        flags.direction = false;
        ds = pop();
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 8;
        return;
    case 0x21e7:
        r16[si] += r16[cx];
        r16[di] += r16[cx];
        r16[si]--;
        r16[di]--;
        flags.direction = true;
        pc = 0x21dd;
        break;
        return;
    } while (1);
}
function* sub_21f8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        push(0x7777);
        memory16set(cs, 0x0320, pop());
        memory16set(cs, 0x0322, pop());
        memory16set(cs, 0x0324, ds);
        flags.direction = false;
        es = memory16get(ds, 0x006f);
        r16[si] = 0x0080;
        r16[ax] = 0;
        lodsb_es_psp_forward();
        r16[ax]++;
        bp = es;
        r16[tx] = r16[si];
        r16[si] = r16[dx];
        r16[dx] = r16[tx];
        r16[tx] = r16[bx];
        r16[bx] = r16[ax];
        r16[ax] = r16[tx];
        r16[si] = memory16get(ds, 0x0069);
        r16[si] += 0x0002;
        r16[cx] = 0x0001;
        if (memory[ds*16 + 0x0071] < 0x03) {
            pc = 0x223b;
            break;
        }
        es = memory16get(ds, 0x006b);
        r16[di] = r16[si];
        r8[cl] = 0x7f;
        r8[al] = 0;
        repne_scasb_psp_forward(r8[al]);
        if (r16[cx] == 0) {
            pc = 0x22ae;
            break;
        }
        r8[cl] ^= 0x7f;
    case 0x223b:
        sp -= 0x0002;
        r16[ax] = 0x0001;
        r16[ax] += r16[bx];
        r16[ax] += r16[cx];
        r16[ax] &= 0xfffe;
        r16[di] = sp;
        r16[tx] = r16[di];
        r16[di] -= r16[ax];
        if (r16[tx] < r16[ax]) {
            pc = 0x22ae;
            break;
        }
        sp = r16[di];
        r16[ax] = es;
        ds = r16[ax];
        r16[ax] = ss;
        es = r16[ax];
        push(r16[cx]);
        r16[cx]--;
        rep_movsb_data_psp_forward();
        r8[al] = 0;
        stosb_data_forward();
        ds = bp;
        r16[tx] = r16[dx];
        r16[dx] = r16[si];
        r16[si] = r16[tx];
        r16[tx] = r16[cx];
        r16[cx] = r16[bx];
        r16[bx] = r16[tx];
        r16[ax] = r16[bx];
        r16[dx] = r16[ax];
        r16[bx]++;
    case 0x226a:
        yield* sub_2286();
        if (!flags.zero && !flags.carry) {
            pc = 0x2276;
            break;
        }
    case 0x226f:
        if (flags.carry) {
            pc = 0x22b3;
            break;
        }
        yield* sub_2286();
        if (!flags.zero && !flags.carry) {
            pc = 0x226f;
            break;
        }
    case 0x2276:
        if (r8[al] == 0x20) {
            pc = 0x2282;
            break;
        }
        if (r8[al] == 0x0d) {
            pc = 0x2282;
            break;
        }
        if (r8[al] != 0x09) {
            pc = 0x226a;
            break;
        }
    case 0x2282:
        r8[al] = 0;
        pc = 0x226a;
        break;
    case 0x22ae:
        stop();
    case 0x22b3:
        r16[cx] = pop();
        r16[cx] += r16[dx];
        ds = memory16get(cs, 0x0324);
        memory16set(ds, 0x005f, r16[bx]);
        r16[bx]++;
        r16[bx] += r16[bx];
        r16[bx] += r16[bx];
        r16[si] = sp;
        bp = sp;
        r16[tx] = bp;
        bp -= r16[bx];
        if (r16[tx] < r16[bx]) {
            pc = 0x22ae;
            break;
        }
        sp = bp;
        memory16set(ds, 0x0061, bp);
        memory16set(ds, 0x0063, ss);
    case 0x22d6:
        if (r16[cx] == 0) {
            pc = 0x22e9;
            break;
        }
        memory16set(ss, bp, r16[si]);
        memory16set(ss, bp + 2, ss);
        bp += 0x0004;
    case 0x22e1:
        lodsb_ss_data_forward();
        if (--r16[cx] && r8[al]) {
            pc = 0x22e1;
            break;
        }
        if (!r8[al]) {
            pc = 0x22d6;
            break;
        }
    case 0x22e9:
        flags.carry = false;
        r16[ax] = 0;
        memory16set(ss, bp, r16[ax]);
        memory16set(ss, bp + 2, r16[ax]);
        daa();
        return;
    } while (1);
}
function* sub_2286() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(0, false);
        if (!r16[ax]) {
            pc = 0x2291;
            break;
        }
        r16[dx]++;
        stosb_data_forward();
        if (r8[al]) {
            pc = 0x2291;
            break;
        }
        r16[bx]++;
    case 0x2291:
        r8[tl] = r8[al];
        r8[al] = r8[ah];
        r8[ah] = r8[tl];
        r8[al] = 0;
        flags.carry = true;
        if (r16[cx] == 0)
            {
            flags.zero = true;
            pc = 0x22ad;
            break;
        }
        lodsb_psp_forward();
        r16[cx]--;
        r8[al] -= 0x22;
        if (r8[al] == 0)
            {
            flags.zero = true;
            pc = 0x22ad;
            break;
        }
        r8[al] += 0x22;
        if (r8[al] != 0x5c)
            {
            flags.zero = false;
            pc = 0x22ab;
            break;
        }
        if (memory[ds*16 + r16[si]] != 0x22)
            {
            flags.zero = false;
            pc = 0x22ab;
            break;
        }
        lodsb_data_forward();
        r16[cx]--;
        flags.zero = r16[cx] == 0;
    case 0x22ab:
        flags.carry = false;
    case 0x22ad:
        return;
    } while (1);
}
function* sub_22f6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        es = memory16get(ds, 0x006b);
        r16[di] = 0;
        push(es);
        push(memory16get(ds, 0x006d));
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x01ed);
        sp += 0x0002;
        r16[bx] = r16[ax];
        es = pop();
        memory16set(ds, 0x0065, r16[ax]);
        memory16set(ds, 0x0067, r16[dx]);
        push(ds);
        ds = r16[dx];
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x231f;
            break;
        }
        cs = 0x01ed;
        yield* callIndirect(0x01ed, 0x015a);
    case 0x231f:
        r16[ax] = 0;
        r16[cx] = 0xffff;
    case 0x2324:
        memory16set(ds, r16[bx], r16[di]);
        memory16set(ds, r16[bx] + 2, es);
        r16[bx] += 0x0004;
        repne_scasb_psp_forward(r8[al]);
        if (memoryPsp(es, r16[di]) != r8[al]) {
            pc = 0x2324;
            break;
        }
        memory16set(ds, r16[bx], r16[ax]);
        memory16set(ds, r16[bx] + 2, r16[ax]);
        ds = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_23f1() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[ax] = memory16get(ss, bp + 6);
    memory16set(ds, 0x0084, r16[ax]);
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_23fc() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    memory16set(ds, 0x92e4, 0x2000);
    memory[ds*16 + 0x92e1] = 0x01;
    push(ds);
    r16[ax] = 0x8d62;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x92e0;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    push(cs);
    cs = 0x1f0d;
    yield* sub_1f0d4();
    assert(cs == 0x023f);
    sp += 0x000a;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_241e() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    memory[ds*16 + 0x92e1] = 0x0f;
    push(ds);
    r16[ax] = 0x8d62;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x92e0;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    push(cs);
    cs = 0x1f0d;
    yield* sub_1f0d4();
    assert(cs == 0x023f);
    sp += 0x000a;
    r8[al] = memory[ds*16 + 0x8d62];
    r8[ah] = 0x00;
    r16[si] = r16[ax];
    r16[ax] = r16[si];
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_2445() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x2460;
            break;
        }
    case 0x244c:
        r16[dx] = 0x03ba;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x80)) {
            pc = 0x244c;
            break;
        }
    case 0x2455:
        r16[dx] = 0x03ba;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x80) {
            pc = 0x2455;
            break;
        }
        pc = 0x2472;
        break;
    case 0x2460:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x08) {
            pc = 0x2460;
            break;
        }
    case 0x2469:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x08)) {
            pc = 0x2469;
            break;
        }
    case 0x2472:
        cs = pop();
        return;
    } while (1);
}
function* sub_2473() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = 0;
        pc = 0x24be;
        break;
    case 0x2478:
        memory[ds*16 + 0x92e1] = 0x10;
        memory[ds*16 + 0x92e0] = 0x15;
        memory16set(ds, 0x92e2, r16[si]);
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x023f);
        sp += 0x000a;
        r8[al] = memory[ds*16 + 0x8d69];
        memory[ds*16 + r16[si] + 36740] = r8[al];
        memory[ds*16 + r16[si] + 37300] = r8[al];
        r8[al] = memory[ds*16 + 0x8d67];
        memory[ds*16 + r16[si] + 35931] = r8[al];
        memory[ds*16 + r16[si] + 35434] = r8[al];
        r8[al] = memory[ds*16 + 0x8d66];
        memory[ds*16 + r16[si] + 37010] = r8[al];
        memory[ds*16 + r16[si] + 36414] = r8[al];
        r16[si]++;
    case 0x24be:
        if (r16[si] < 0x0100) {
            pc = 0x2478;
            break;
        }
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_24c6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 10);
        push(memory16get(ss, bp + 14));
        r16[ax] = memory16get(ss, bp + 16);
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(r16[si]);
        push(cs);
        cs = 0x0e97;
        yield* sub_ee3e();
        assert(cs == 0x023f);
        sp = bp;
        r16[di] = 0;
        pc = 0x250f;
        break;
    case 0x24e4:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ds*16 + r16[si] + 36740] = r8[al];
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r16[bx] = memory16get(ss, bp + 14);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ds*16 + r16[si] + 35931] = r8[al];
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r16[bx] = memory16get(ss, bp + 14);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = r16[si];
        memory[ds*16 + r16[bx] + 37010] = r8[al];
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r16[si]++;
        r16[di]++;
    case 0x250f:
        if (r16[di] < memory16get(ss, bp + 12)) {
            pc = 0x24e4;
            break;
        }
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2518() {
    var counter = 0;
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0038;
        r16[ax] = 0x0048;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x023f);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 7] = 0x00;
        pc = 0x256b;
        break;
    case 0x2539:
        r8[al] = 0x00;
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x18;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x28;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x38;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 7] += 1;
    case 0x256b:
        if (memory[ss*16 + bp - 7] < 0x10) {
            pc = 0x2539;
            break;
        }
    case 0x2571:
        if (memory[ss*16 + bp - 6] == 0x00) {
            pc = 0x257a;
            break;
        }
        pc = 0x26c4;
        break;
    case 0x257a:
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 7] = 0x00;
        pc = 0x2697;
        break;
    case 0x2585:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x38;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        if (r8[al] >= memory[ds*16 + r16[bx] + 37300]) {
            pc = 0x25b2;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x38;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] += 1;
        pc = 0x25b5;
        break;
    case 0x25b2:
        memory[ss*16 + bp - 6] += 1;
    case 0x25b5:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        if (r8[al] >= memory[ds*16 + r16[bx] + 35434]) {
            pc = 0x25e2;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] += 1;
        pc = 0x25e5;
        break;
    case 0x25e2:
        memory[ss*16 + bp - 6] += 1;
    case 0x25e5:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        if (r8[al] >= memory[ds*16 + r16[bx] + 36414]) {
            pc = 0x2612;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] += 1;
        pc = 0x2615;
        break;
    case 0x2612:
        memory[ss*16 + bp - 6] += 1;
    case 0x2615:
        if (memory[ss*16 + bp - 7] >= 0x08) {
            pc = 0x262a;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        memory[ss*16 + bp - 5] = r8[al];
        pc = 0x263a;
        break;
    case 0x262a:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[ax] += 0x0008;
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        memory[ss*16 + bp - 5] = r8[al];
    case 0x263a:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x38;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 5];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 5] += 1;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 5];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 5] += 1;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 5];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 7] += 1;
    case 0x2697:
        if (memory[ss*16 + bp - 7] >= 0x10) {
            pc = 0x26a0;
            break;
        }
        pc = 0x2585;
        break;
    case 0x26a0:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0018;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        if (prehistorikFade && counter++ % 5 == 0)
        {yield* sync();}
        sp += 0x0008;
        if (memory[ss*16 + bp - 6] != 0x30) {
            pc = 0x26bd;
            break;
        }
        pc = 0x2571;
        break;
    case 0x26bd:
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x2571;
        break;
    case 0x26c4:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x023f);
        sp += 0x0004;
        memory[ds*16 + 0x8de6] = 0x01;
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_26db() {
    var counter = 0;
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0038;
        r16[ax] = 0x0048;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x023f);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 7] = 0x00;
        pc = 0x279c;
        break;
    case 0x26fd:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 36740];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x38;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35931];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x28;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 37010];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x18;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 36756];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x30;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35947];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x20;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 37026];
        r8[dl] = memory[ss*16 + bp - 7];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x10;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 7] += 1;
    case 0x279c:
        if (memory[ss*16 + bp - 7] >= 0x08) {
            pc = 0x27a5;
            break;
        }
        pc = 0x26fd;
        break;
    case 0x27a5:
        if (memory[ss*16 + bp - 6] == 0x00) {
            pc = 0x27ae;
            break;
        }
        pc = 0x28da;
        break;
    case 0x27ae:
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 7] = 0x00;
        pc = 0x28ad;
        break;
    case 0x27b9:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x38;
        r16[bx] += r16[ax];
        if (memory[ss*16 + r16[bx]] == 0x00) {
            pc = 0x27dc;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x38;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] -= 1;
        pc = 0x27df;
        break;
    case 0x27dc:
        memory[ss*16 + bp - 6] += 1;
    case 0x27df:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        if (memory[ss*16 + r16[bx]] == 0x00) {
            pc = 0x2802;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] -= 1;
        pc = 0x2805;
        break;
    case 0x2802:
        memory[ss*16 + bp - 6] += 1;
    case 0x2805:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        if (memory[ss*16 + r16[bx]] == 0x00) {
            pc = 0x2828;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] -= 1;
        pc = 0x282b;
        break;
    case 0x2828:
        memory[ss*16 + bp - 6] += 1;
    case 0x282b:
        if (memory[ss*16 + bp - 7] >= 0x08) {
            pc = 0x2840;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        memory[ss*16 + bp - 5] = r8[al];
        pc = 0x2850;
        break;
    case 0x2840:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[ax] += 0x0008;
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        memory[ss*16 + bp - 5] = r8[al];
    case 0x2850:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x38;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 5];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 5] += 1;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 5];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 5] += 1;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 5];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        memory[ss*16 + bp - 7] += 1;
    case 0x28ad:
        if (memory[ss*16 + bp - 7] >= 0x10) {
            pc = 0x28b6;
            break;
        }
        pc = 0x27b9;
        break;
    case 0x28b6:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0018;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        sp += 0x0008;
        if (prehistorikFade && counter++ % 5 == 0)
        {yield* sync(); }
        if (memory[ss*16 + bp - 6] != 0x30) {
            pc = 0x28d3;
            break;
        }
        pc = 0x27a5;
        break;
    case 0x28d3:
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x27a5;
        break;
    case 0x28da:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x023f);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_28ec() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0186;
        r16[ax] = 0x0180;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x023f);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[si] = 0;
        pc = 0x291c;
        break;
    case 0x290a:
        r8[al] = 0x00;
        memory[ss*16 + bp + r16[si] + 65402] = r8[al];
        memory[ss*16 + bp + r16[si] + 65274] = r8[al];
        memory[ss*16 + bp + r16[si] + 65146] = r8[al];
        r16[si]++;
    case 0x291c:
        if (r16[si] < 0x0080) {
            pc = 0x290a;
            break;
        }
        memory16set(ss, bp - 6, 0x003f);
    case 0x2927:
        if (memory16get(ss, bp - 6) != 0x0000) {
            pc = 0x2930;
            break;
        }
        pc = 0x29de;
        break;
    case 0x2930:
        r16[si] = 0;
        pc = 0x29bb;
        break;
    case 0x2935:
        r8[al] = memory[ss*16 + bp + r16[si] + 65146];
        if (r8[al] >= memory[ds*16 + r16[si] + 37300]) {
            pc = 0x2950;
            break;
        }
        r8[al] = memory[ds*16 + r16[si] + 37300];
        r8[ah] = 0x00;
        if (r16[ax] < memory16get(ss, bp - 6)) {
            pc = 0x2950;
            break;
        }
        memory[ss*16 + bp + r16[si] + 65146] += 1;
    case 0x2950:
        r8[al] = memory[ss*16 + bp + r16[si] + 65274];
        if (r8[al] >= memory[ds*16 + r16[si] + 35434]) {
            pc = 0x296b;
            break;
        }
        r8[al] = memory[ds*16 + r16[si] + 35434];
        r8[ah] = 0x00;
        if (r16[ax] < memory16get(ss, bp - 6)) {
            pc = 0x296b;
            break;
        }
        memory[ss*16 + bp + r16[si] + 65274] += 1;
    case 0x296b:
        r8[al] = memory[ss*16 + bp + r16[si] + 65402];
        if (r8[al] >= memory[ds*16 + r16[si] + 36414]) {
            pc = 0x2986;
            break;
        }
        r8[al] = memory[ds*16 + r16[si] + 36414];
        r8[ah] = 0x00;
        if (r16[ax] < memory16get(ss, bp - 6)) {
            pc = 0x2986;
            break;
        }
        memory[ss*16 + bp + r16[si] + 65402] += 1;
    case 0x2986:
        r16[ax] = r16[si];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r8[al] = memory[ss*16 + bp + r16[si] + 65146];
        r16[dx] = r16[di];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[di]++;
        r8[al] = memory[ss*16 + bp + r16[si] + 65274];
        r16[dx] = r16[di];
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[di]++;
        r8[al] = memory[ss*16 + bp + r16[si] + 65402];
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + r16[di]] = r8[al];
        r16[si]++;
    case 0x29bb:
        if (r16[si] >= 0x0080) {
            pc = 0x29c4;
            break;
        }
        pc = 0x2935;
        break;
    case 0x29c4:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        sp += 0x0008;
        yield* sync();
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) - 1);
        pc = 0x2927;
        break;
    case 0x29de:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x023f);
        sp += 0x0004;
        memory[ds*16 + 0x8de6] = 0x01;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_29f7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0186;
        r16[ax] = 0x0180;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x023f);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ss, bp - 6, 0x0000);
        r16[si] = 0;
        pc = 0x2a36;
        break;
    case 0x2a1a:
        r8[al] = memory[ds*16 + r16[si] + 36740];
        memory[ss*16 + bp + r16[si] + 65146] = r8[al];
        r8[al] = memory[ds*16 + r16[si] + 35931];
        memory[ss*16 + bp + r16[si] + 65274] = r8[al];
        r8[al] = memory[ds*16 + r16[si] + 37010];
        memory[ss*16 + bp + r16[si] + 65402] = r8[al];
        r16[si]++;
    case 0x2a36:
        if (r16[si] < 0x0080) {
            pc = 0x2a1a;
            break;
        }
    case 0x2a3c:
        if (memory16get(ss, bp - 6) == 0x0000) {
            pc = 0x2a45;
            break;
        }
        pc = 0x2ae5;
        break;
    case 0x2a45:
        memory16set(ss, bp - 6, 0x0000);
        r16[si] = 0;
        pc = 0x2ab9;
        break;
    case 0x2a4e:
        if (memory[ss*16 + bp + r16[si] + 65146] == 0x00) {
            pc = 0x2a5d;
            break;
        }
        memory[ss*16 + bp + r16[si] + 65146] -= 1;
        pc = 0x2a60;
        break;
    case 0x2a5d:
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
    case 0x2a60:
        if (memory[ss*16 + bp + r16[si] + 65274] == 0x00) {
            pc = 0x2a6f;
            break;
        }
        memory[ss*16 + bp + r16[si] + 65274] -= 1;
        pc = 0x2a72;
        break;
    case 0x2a6f:
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
    case 0x2a72:
        if (memory[ss*16 + bp + r16[si] + 65402] == 0x00) {
            pc = 0x2a81;
            break;
        }
        memory[ss*16 + bp + r16[si] + 65402] -= 1;
        pc = 0x2a84;
        break;
    case 0x2a81:
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
    case 0x2a84:
        r16[ax] = r16[si];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r8[al] = memory[ss*16 + bp + r16[si] + 65146];
        r16[dx] = r16[di];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[di]++;
        r8[al] = memory[ss*16 + bp + r16[si] + 65274];
        r16[dx] = r16[di];
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[di]++;
        r8[al] = memory[ss*16 + bp + r16[si] + 65402];
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + r16[di]] = r8[al];
        r16[si]++;
    case 0x2ab9:
        if (r16[si] < 0x0080) {
            pc = 0x2a4e;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        sp += 0x0008;
        yield* sync();
        if (memory16get(ss, bp - 6) != 0x0180) {
            pc = 0x2add;
            break;
        }
        pc = 0x2a3c;
        break;
    case 0x2add:
        memory16set(ss, bp - 6, 0x0000);
        pc = 0x2a3c;
        break;
    case 0x2ae5:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x023f);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2af9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        if (memory[ds*16 + 0x8de6] != 0x00) {
            pc = 0x2b81;
            break;
        }
        r16[ax] = 0x0048;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x023f);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[si] = 0;
        pc = 0x2b4e;
        break;
    case 0x2b1d:
        r16[ax] = r16[si];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r8[al] = memory[ds*16 + r16[si] + 37300];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + r16[di]] = r8[al];
        r8[al] = memory[ds*16 + r16[si] + 35434];
        r16[dx] = r16[di];
        r16[dx]++;
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r8[al] = memory[ds*16 + r16[si] + 36414];
        r16[dx] = r16[di];
        r16[dx] += 0x0002;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[si]++;
    case 0x2b4e:
        if (r16[si] < 0x0010) {
            pc = 0x2b1d;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        yield* sync();
        sp += 0x0008;
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0018;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        yield* sync();
        sp += 0x0008;
    case 0x2b81:
        memory[ds*16 + 0x8de6] = 0x01;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2b8c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[ax] = 0x0180;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x023f);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        if (memory[ds*16 + 0x8de6] != 0x00) {
            pc = 0x2bfa;
            break;
        }
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x2be0;
        break;
    case 0x2bb2:
        r8[al] = memory[ds*16 + r16[di] + 37300];
        r16[dx] = r16[si];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[di] + 35434];
        r16[dx] = r16[si];
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[di] + 36414];
        r16[dx] = r16[si];
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x2be0:
        if (r16[di] < 0x0080) {
            pc = 0x2bb2;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_24c6();
        yield* sync();
        sp += 0x0008;
    case 0x2bfa:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x023f);
        sp += 0x0004;
        memory[ds*16 + 0x8de6] = 0x01;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2c13() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        memory[ss*16 + bp - 1] = 0x00;
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0x2c2c;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_a70c();
        assert(cs == 0x023f);
        memory[ss*16 + bp - 1] = 0x01;
    case 0x2c2c:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        memory[ds*16 + 0x8f66] = r8[al];
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x2c7c;
            break;
        }
        memory[ds*16 + 0x92e1] = 0x05;
        r8[al] = memory[es*16 + r16[bx] + 4];
        memory[ds*16 + 0x92e0] = r8[al];
    case 0x2c49:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x08) {
            pc = 0x2c49;
            break;
        }
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x023f);
        sp += 0x000a;
    case 0x2c68:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x08)) {
            pc = 0x2c68;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x2c7c;
            break;
        }
        push(cs);
        yield* sub_2af9();
    case 0x2c7c:
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x2ce6;
            break;
        }
        r16[ax] = 0x8e20;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 8)) {
            pc = 0x2c95;
            break;
        }
        if (r16[ax] != memory16get(ss, bp + 6)) {
            pc = 0x2c95;
            break;
        }
        pc = 0x2db8;
        break;
    case 0x2c95:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        if (memory[es*16 + r16[bx] + 4] != 0x01) {
            pc = 0x2cb0;
            break;
        }
        r16[dx] = 0xb800;
        r16[ax] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_be10();
        assert(cs == 0x023f);
        sp += 0x0004;
        pc = 0x2cbf;
        break;
    case 0x2cb0:
        r16[dx] = 0xb000;
        r16[ax] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_be10();
        assert(cs == 0x023f);
        sp += 0x0004;
    case 0x2cbf:
        r8[al] = memory[ds*16 + 0x8f66];
        r16[cx] = 0x0007;
        r8[al] <<= r8[cl];
        r8[al] += 0x0a;
        memory[ss*16 + bp - 2] = r8[al];
    case 0x2ccd:
        r16[dx] = 0x03ba;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x80)) {
            pc = 0x2ccd;
            break;
        }
        r8[al] = memory[ss*16 + bp - 2];
        r16[dx] = 0x03b8;
        out8(r16[dx], r8[al]);
    case 0x2cdd:
        r16[dx] = 0x03ba;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x80) {
            pc = 0x2cdd;
            break;
        }
    case 0x2ce6:
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x2d2d;
            break;
        }
        memory[ds*16 + 0x8f66] = 0x00;
    case 0x2cf2:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x08) {
            pc = 0x2cf2;
            break;
        }
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 8)) {
            pc = 0x2d0a;
            break;
        }
        if (r16[ax] == memory16get(ss, bp + 6)) {
            pc = 0x2d24;
            break;
        }
    case 0x2d0a:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0xb800;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        push(memory16get(es, r16[bx]));
        r16[ax] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_bbd5();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x2d24:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x08)) {
            pc = 0x2d24;
            break;
        }
    case 0x2d2d:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x2d66;
            break;
        }
        memory[ds*16 + 0x8f66] = 0x00;
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 8)) {
            pc = 0x2d48;
            break;
        }
        if (r16[ax] == memory16get(ss, bp + 6)) {
            pc = 0x2d62;
            break;
        }
    case 0x2d48:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0xa000;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        push(memory16get(es, r16[bx]));
        r16[ax] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(cs);
        cs = 0x0e97;
        yield* sub_edb1();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x2d62:
        push(cs);
        yield* sub_2b8c();
    case 0x2d66:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x2dad;
            break;
        }
        memory[ds*16 + 0x8f66] = 0x00;
    case 0x2d72:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x08) {
            pc = 0x2d72;
            break;
        }
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 8)) {
            pc = 0x2d8a;
            break;
        }
        if (r16[ax] == memory16get(ss, bp + 6)) {
            pc = 0x2da4;
            break;
        }
    case 0x2d8a:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0xb800;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        push(memory16get(es, r16[bx]));
        r16[ax] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e20c();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x2da4:
        r16[dx] = 0x03da;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x08)) {
            pc = 0x2da4;
            break;
        }
    case 0x2dad:
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0x2db8;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_a6c3();
        assert(cs == 0x023f);
    case 0x2db8:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2dbc() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(memory16get(ss, bp + 8));
    push(memory16get(ss, bp + 6));
    push(cs);
    yield* sub_2c13();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_2dcd() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 10);
        if (r16[si] <= 0x0007) {
            pc = 0x2dea;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x2de7;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x2dea;
            break;
        }
    case 0x2de7:
        r16[si] += 0x0008;
    case 0x2dea:
        memory[ds*16 + 0x92e1] = 0x10;
        memory[ds*16 + 0x92e0] = 0x00;
        r8[al] = memory[ss*16 + bp + 8];
        memory[ds*16 + 0x92e2] = r8[al];
        r16[ax] = r16[si];
        memory[ds*16 + 0x92e3] = r8[al];
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x023f);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2e17() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        memory[ss*16 + bp - 1] = 0x00;
        if (memory[ss*16 + bp + 14] <= 0x01) {
            pc = 0x2e30;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        memory[ds*16 + 0x8f66] = r8[al];
    case 0x2e30:
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0x2e5e;
            break;
        }
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 8)) {
            pc = 0x2e46;
            break;
        }
        if (r16[ax] == memory16get(ss, bp + 6)) {
            pc = 0x2e55;
            break;
        }
    case 0x2e46:
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 12)) {
            pc = 0x2e5e;
            break;
        }
        if (r16[ax] != memory16get(ss, bp + 10)) {
            pc = 0x2e5e;
            break;
        }
    case 0x2e55:
        push(cs);
        cs = 0x0a34;
        yield* sub_a70c();
        assert(cs == 0x023f);
        memory[ss*16 + bp - 1] = 0x01;
    case 0x2e5e:
        if (memory[ss*16 + bp + 14] != 0x07) {
            pc = 0x2e7b;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(memory16get(ss, bp + 6));
        push(cs);
        cs = 0x023f;
        yield* sub_4679();
        assert(cs == 0x023f);
        sp += 0x0008;
        pc = 0x2f1b;
        break;
    case 0x2e7b:
        if (memory[ss*16 + bp + 14] != 0x02) {
            pc = 0x2e8c;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x2e8c;
            break;
        }
        push(cs);
        yield* sub_26db();
    case 0x2e8c:
        if (memory[ds*16 + 0x8f67] != 0x00) {
            pc = 0x2eb8;
            break;
        }
        if (memory[ss*16 + bp + 14] != 0x02) {
            pc = 0x2eb8;
            break;
        }
        memory[ss*16 + bp - 2] = 0x00;
        pc = 0x2eb2;
        break;
    case 0x2e9f:
        r16[ax] = 0;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 2];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_2dcd();
        sp += 0x0004;
        memory[ss*16 + bp - 2] += 1;
    case 0x2eb2:
        if (memory[ss*16 + bp - 2] < 0x10) {
            pc = 0x2e9f;
            break;
        }
    case 0x2eb8:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d472();
        assert(cs == 0x023f);
        sp += 0x0004;
        if (memory[ds*16 + 0x8f67] != 0x00) {
            pc = 0x2f0a;
            break;
        }
        if (memory[ss*16 + bp + 14] != 0x02) {
            pc = 0x2f0a;
            break;
        }
        memory[ss*16 + bp - 2] = 0x00;
        pc = 0x2f04;
        break;
    case 0x2ee3:
        r8[al] = memory[ss*16 + bp - 2];
        r8[ah] = 0x00;
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[ah] = 0x00;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 2];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_2dcd();
        sp += 0x0004;
        memory[ss*16 + bp - 2] += 1;
    case 0x2f04:
        if (memory[ss*16 + bp - 2] < 0x10) {
            pc = 0x2ee3;
            break;
        }
    case 0x2f0a:
        if (memory[ss*16 + bp + 14] != 0x02) {
            pc = 0x2f1b;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x2f1b;
            break;
        }
        push(cs);
        yield* sub_2518();
    case 0x2f1b:
        if (memory[ss*16 + bp + 14] <= 0x00) {
            pc = 0x2f32;
            break;
        }
        if (memory[ss*16 + bp + 14] >= 0x07) {
            pc = 0x2f32;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x2f32;
            break;
        }
        push(cs);
        yield* sub_2af9();
    case 0x2f32:
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0x2f3d;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_a6c3();
        assert(cs == 0x023f);
    case 0x2f3d:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_2f41() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0010;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0xf8c0);
        r16[di] = 0;
        pc = 0x2f89;
        break;
    case 0x2f61:
        r16[si] = 0;
        pc = 0x2f74;
        break;
    case 0x2f65:
        r8[al] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + r16[si]] = r8[al];
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory[es*16 + r16[bx] + r16[si]] = r8[al];
        r16[si]++;
    case 0x2f74:
        if (r16[si] < 0x0140) {
            pc = 0x2f65;
            break;
        }
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0280);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x0280);
        push(cs);
        yield* sub_2445();
        r16[di]++;
    case 0x2f89:
        if (r16[di] < 0x0064) {
            pc = 0x2f61;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0xf8c0);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0xf8c0);
        push(cs);
        yield* sub_2b8c();
        r16[di] = 0;
        pc = 0x2ffa;
        break;
    case 0x2fbe:
        r16[si] = 0;
        pc = 0x2fdb;
        break;
    case 0x2fc2:
        r16[bx] = memory16get(ss, bp - 16);
        es = memory16get(ss, bp - 16 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory[es*16 + r16[bx] + r16[si]] = r8[al];
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + r16[si]] = r8[al];
        r16[si]++;
    case 0x2fdb:
        if (r16[si] < 0x0140) {
            pc = 0x2fc2;
            break;
        }
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 0x0280);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - 0x0280);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0280);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x0280);
        push(cs);
        yield* sub_2445();
        r16[di]++;
    case 0x2ffa:
        if (r16[di] < 0x0064) {
            pc = 0x2fbe;
            break;
        }
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3005() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory[ss*16 + bp - 13] = 0x00;
        if (memory[ss*16 + bp + 18] <= 0x01) {
            pc = 0x3039;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        memory[ds*16 + 0x8f66] = r8[al];
    case 0x3039:
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0x3067;
            break;
        }
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 12)) {
            pc = 0x304f;
            break;
        }
        if (r16[ax] == memory16get(ss, bp + 10)) {
            pc = 0x305e;
            break;
        }
    case 0x304f:
        r16[ax] = 0x8bfa;
        r16[dx] = ds;
        if (r16[dx] != memory16get(ss, bp + 16)) {
            pc = 0x3067;
            break;
        }
        if (r16[ax] != memory16get(ss, bp + 14)) {
            pc = 0x3067;
            break;
        }
    case 0x305e:
        push(cs);
        cs = 0x0a34;
        yield* sub_a70c();
        assert(cs == 0x023f);
        memory[ss*16 + bp - 13] = 0x01;
    case 0x3067:
        if (memory[ss*16 + bp + 18] != 0x07) {
            pc = 0x3080;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_2f41();
        sp += 0x0008;
    case 0x3080:
        if (memory[ss*16 + bp + 18] != 0x02) {
            pc = 0x308a;
            break;
        }
        push(cs);
        yield* sub_29f7();
    case 0x308a:
        if (memory[ss*16 + bp + 18] == 0x07) {
            pc = 0x30b0;
            break;
        }
        r16[si] = memory16get(ss, bp - 6);
        r16[di] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 2);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x0e97;
        yield* sub_edb1();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x30b0:
        if (memory[ss*16 + bp + 18] != 0x02) {
            pc = 0x30ba;
            break;
        }
        push(cs);
        yield* sub_28ec();
    case 0x30ba:
        if (memory[ss*16 + bp + 18] <= 0x01) {
            pc = 0x30c4;
            break;
        }
        push(cs);
        yield* sub_2b8c();
    case 0x30c4:
        if (memory[ss*16 + bp - 13] == 0x00) {
            pc = 0x30cf;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_a6c3();
        assert(cs == 0x023f);
    case 0x30cf:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_30d5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        memory[ss*16 + bp - 1] = 0x00;
        pc = 0x30fe;
        break;
    case 0x30e0:
        r8[al] = memory[ss*16 + bp - 1];
        r8[ah] = 0x00;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 1];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx] + 5] = r8[al];
        memory[ss*16 + bp - 1] += 1;
    case 0x30fe:
        if (memory[ss*16 + bp - 1] < 0x10) {
            pc = 0x30e0;
            break;
        }
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3108() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001a;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[bx] = 0x0010;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 18] = r8[dl];
        if (signed16(r16[si]) >= 0) {
            pc = 0x312a;
            break;
        }
        r16[si] = 0;
    case 0x312a:
        if (signed16(r16[di]) >= 0) {
            pc = 0x3130;
            break;
        }
        r16[di] = 0;
    case 0x3130:
        if (signed16(r16[si]) <= signed16(0x013f)) {
            pc = 0x3139;
            break;
        }
        r16[si] = 0x013f;
    case 0x3139:
        if (signed16(r16[di]) <= signed16(0x00c7)) {
            pc = 0x3142;
            break;
        }
        r16[di] = 0x00c7;
    case 0x3142:
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        if (r16s[ax] <= signed16(0x013f)) {
            pc = 0x3154;
            break;
        }
        r16[ax] = 0x013f;
        r16[ax] -= r16[si];
        memory16set(ss, bp + 14, r16[ax]);
    case 0x3154:
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp + 16);
        if (r16s[ax] <= signed16(0x00c7)) {
            pc = 0x3166;
            break;
        }
        r16[ax] = 0x00c7;
        r16[ax] -= r16[di];
        memory16set(ss, bp + 16, r16[ax]);
    case 0x3166:
        r16[ax] = r16[si];
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 21] = r8[dl];
        if (memory[ss*16 + bp - 21] == 0x00) {
            pc = 0x3188;
            break;
        }
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r16[ax] = 0x00ff;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ss*16 + bp - 20] = r8[al];
        pc = 0x318c;
        break;
    case 0x3188:
        memory[ss*16 + bp - 20] = 0x00;
    case 0x318c:
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        r16[ax]++;
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 21] = r8[dl];
        if (memory[ss*16 + bp - 21] == 0x00) {
            pc = 0x31b3;
            break;
        }
        r16[cx] = r16[bx];
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] -= r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        memory[ss*16 + bp - 19] = r8[al];
        pc = 0x31b7;
        break;
    case 0x31b3:
        memory[ss*16 + bp - 19] = 0x00;
    case 0x31b7:
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax]++;
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = r16[si];
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] -= memory16get(ss, bp - 18);
        r16[ax]++;
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ss*16 + bp - 20] == 0x00) {
            pc = 0x31e4;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 1);
    case 0x31e4:
        if (memory[ss*16 + bp - 19] == 0x00) {
            pc = 0x31ed;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 1);
    case 0x31ed:
        if (memory16gets(ss, bp - 2) >= signed16(0x0000)) {
            pc = 0x3202;
            break;
        }
        memory16set(ss, bp - 2, 0x0000);
        r8[al] = memory[ss*16 + bp - 19];
        memory[ss*16 + bp - 20] = memory[ss*16 + bp - 20] & r8[al];
        memory[ss*16 + bp - 19] = 0x00;
    case 0x3202:
        r8[al] = memory[ss*16 + bp - 19];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 20];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 10, r16[ax]);
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[ax] &= 0x000f;
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        r16[ax] += memory16get(ss, bp - 18);
        memory16set(ss, bp - 4, r16[ax]);
        r16[bx] = memory16get(ss, bp + 20);
        es = memory16get(ss, bp + 20 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 26, r16[bx]);
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 6, r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0cc2;
        yield* sub_d5a0();
        assert(cs == 0x023f);
        sp += 0x000c;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3268() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0022;
        r16[si] = memory16get(ss, bp + 14);
        r16[di] = memory16get(ss, bp + 12);
        if (memory16gets(ss, bp + 10) >= signed16(0x0000)) {
            pc = 0x327f;
            break;
        }
        pc = 0x3442;
        break;
    case 0x327f:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += memory16get(ss, bp + 10);
        if (r16[ax] < 0x0140) {
            pc = 0x32a1;
            break;
        }
        pc = 0x3442;
        break;
    case 0x32a1:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16[ax] <= r16[di]) {
            pc = 0x32b9;
            break;
        }
        pc = 0x3442;
        break;
    case 0x32b9:
        if (signed16(r16[di]) < signed16(0x00c8)) {
            pc = 0x32c2;
            break;
        }
        pc = 0x3442;
        break;
    case 0x32c2:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[di] -= r16[ax];
        if (signed16(r16[di]) >= 0) {
            pc = 0x32db;
            break;
        }
        r16[di] = 0;
    case 0x32db:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx] + 21];
        r8[ah] = 0x00;
        memory16set(ss, bp - 12, r16[ax]);
        r8[al] = memory[es*16 + r16[bx] + 22];
        r8[ah] = 0x00;
        memory16set(ss, bp - 10, r16[ax]);
        if (memory[es*16 + r16[bx] + 23] != 0x00) {
            pc = 0x332d;
            break;
        }
        push(memory16get(ss, bp + 18));
        push(r16[bx]);
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax]--;
        push(r16[ax]);
        push(r16[di]);
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x023f);
        sp += 0x000e;
    case 0x332d:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 26] = r8[dl];
        if (memory[ss*16 + bp - 26] != 0x00) {
            pc = 0x336d;
            break;
        }
        memory[ss*16 + bp - 25] = 0x00;
        pc = 0x3375;
        break;
    case 0x336d:
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 26];
        memory[ss*16 + bp - 25] = r8[al];
    case 0x3375:
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 26];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 8, r16[ax]);
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = r16[di];
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = r16[cx];
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 14, r16[dx]);
        r16[bx] = memory16get(ss, bp - 30);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 4, r16[ax]);
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        if (r16s[dx] > memory16gets(ss, bp - 22)) {
            pc = 0x3432;
            break;
        }
        if (r16s[dx] < memory16gets(ss, bp - 22)) {
            pc = 0x33f9;
            break;
        }
        if (r16[ax] >= memory16get(ss, bp - 24)) {
            pc = 0x3432;
            break;
        }
    case 0x33f9:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += 0x2000;
        if (r16s[dx] < memory16gets(ss, bp - 22)) {
            pc = 0x3432;
            break;
        }
        if (r16s[dx] > memory16gets(ss, bp - 22)) {
            pc = 0x3412;
            break;
        }
        if (r16[ax] <= memory16get(ss, bp - 24)) {
            pc = 0x3432;
            break;
        }
    case 0x3412:
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0cc2;
        yield* sub_d63e();
        assert(cs == 0x023f);
        sp += 0x0010;
    case 0x3432:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
    case 0x3442:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3448() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001c;
        if (memory16gets(ss, bp + 10) < signed16(0x0140)) {
            pc = 0x345a;
            break;
        }
        pc = 0x37c9;
        break;
    case 0x345a:
        r16[ax] = memory16get(ds, 0x0084);
        r16[ax]++;
        if (r16s[ax] > memory16gets(ss, bp + 12)) {
            pc = 0x3466;
            break;
        }
        pc = 0x37c9;
        break;
    case 0x3466:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[tx] = r16[ax];
        r16[ax] += memory16get(ss, bp + 10);
        if (r16s[tx] + memory16gets(ss, bp + 10) > 0) {
            pc = 0x347f;
            break;
        }
        pc = 0x37c9;
        break;
    case 0x347f:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[tx] = r16[ax];
        r16[ax] += memory16get(ss, bp + 12);
        if (r16s[tx] + memory16gets(ss, bp + 12) > 0) {
            pc = 0x3499;
            break;
        }
        pc = 0x37c9;
        break;
    case 0x3499:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 26, es);
        memory16set(ss, bp - 28, r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 20, r16[ax]);
        if (memory16gets(ss, bp + 12) >= signed16(0x0000)) {
            pc = 0x350f;
            break;
        }
        r16[ax] = memory16get(ss, bp + 12);
        if (r16s[ax] >= 0) {
            pc = 0x34ea;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x34ea:
        mul16(memory16get(ss, bp - 4));
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += memory16get(ss, bp - 6);
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = memory16get(ss, bp - 28);
        es = memory16get(ss, bp - 28 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 28, r16[bx]);
        r16[ax] = memory16get(ss, bp + 12);
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + r16[ax]);
        memory16set(ss, bp + 12, 0x0000);
        pc = 0x3537;
        break;
    case 0x350f:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += memory16get(ss, bp + 12);
        r16[dx] = memory16get(ds, 0x0084);
        r16[dx]++;
        if (r16[ax] <= r16[dx]) {
            pc = 0x3537;
            break;
        }
        r16[ax] = memory16get(ds, 0x0084);
        r16[ax]++;
        r16[ax] -= memory16get(ss, bp + 12);
        memory16set(ss, bp - 20, r16[ax]);
    case 0x3537:
        r16[bx] = memory16get(ss, bp + 18);
        es = memory16get(ss, bp + 18 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        if (memory16gets(ss, bp + 10) < signed16(0x0000)) {
            pc = 0x354c;
            break;
        }
        pc = 0x3629;
        break;
    case 0x354c:
        r16[ax] = memory16get(ss, bp + 10);
        if (r16s[ax] >= 0) {
            pc = 0x3555;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x3555:
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] &= 0x0007;
        memory16set(ss, bp - 10, r16[ax]);
        if (r16[ax]) {
            pc = 0x3566;
            break;
        }
        r16[si] = 0;
        pc = 0x356c;
        break;
    case 0x3566:
        r16[si] = 0x0008;
        r16[si] -= memory16get(ss, bp - 10);
    case 0x356c:
        r16[ax] = memory16get(ss, bp - 10);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += r16[si];
        memory16set(ss, bp - 8, r16[ax]);
        r16[di] = memory16get(ss, bp - 2);
        r16[di] >>= 1;
        r16[di] >>= 1;
        r16[di] >>= 1;
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - r16[di]);
        if (!r16[si]) {
            pc = 0x358c;
            break;
        }
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 1);
    case 0x358c:
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += r16[di];
        r16[di] = r16[ax];
        r16[bx] = memory16get(ss, bp - 28);
        es = memory16get(ss, bp - 28 + 2);
        r16[bx] += r16[di];
        memory16set(ss, bp - 28, r16[bx]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ss, bp - 26);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 14, r16[ax]);
        if (!r16[si]) {
            pc = 0x35ff;
            break;
        }
        push(memory16get(ss, bp - 12));
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d711();
        assert(cs == 0x023f);
        sp += 0x0010;
        r16[di] += 0x0005;
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 0x0005);
    case 0x35ff:
        if (memory16get(ss, bp - 4) != 0x0000) {
            pc = 0x3608;
            break;
        }
        pc = 0x37c9;
        break;
    case 0x3608:
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 8));
        push(r16[di]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d711();
        assert(cs == 0x023f);
        sp += 0x0010;
        pc = 0x37c9;
        break;
    case 0x3629:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ss, bp + 10);
        if (r16[ax] > 0x0140) {
            pc = 0x3645;
            break;
        }
        pc = 0x372e;
        break;
    case 0x3645:
        r16[si] = memory16get(ss, bp + 10);
        r16[si] &= 0x0007;
        if (r16[si]) {
            pc = 0x3657;
            break;
        }
        memory16set(ss, bp - 10, 0x0000);
        pc = 0x365f;
        break;
    case 0x3657:
        r16[ax] = 0x0008;
        r16[ax] -= r16[si];
        memory16set(ss, bp - 10, r16[ax]);
    case 0x365f:
        r16[ax] = memory16get(ss, bp - 10);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += r16[si];
        memory16set(ss, bp - 8, r16[ax]);
        r16[di] = memory16get(ss, bp - 4);
        r16[ax] = 0x0140;
        r16[ax] -= memory16get(ss, bp + 10);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[di] -= r16[ax];
        r16[ax] = 0x0140;
        r16[ax] -= memory16get(ss, bp + 10);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += r16[di];
        r16[di] = r16[ax];
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        r16[dx] = memory16get(ss, bp + 10);
        r16[dx] = sar16(r16[dx], 1);
        r16[dx] = sar16(r16[dx], 1);
        r16[dx] = sar16(r16[dx], 1);
        r16[ax] += r16[dx];
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ss, bp - 26);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 14, r16[ax]);
        if (memory16get(ss, bp - 4) == 0x0000) {
            pc = 0x36ed;
            break;
        }
        push(memory16get(ss, bp - 12));
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 8));
        push(r16[di]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d711();
        assert(cs == 0x023f);
        sp += 0x0010;
    case 0x36ed:
        if (r16[si]) {
            pc = 0x36f4;
            break;
        }
        pc = 0x37c9;
        break;
    case 0x36f4:
        r16[ax] = memory16get(ss, bp - 4);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        r16[di] += r16[ax];
        r16[ax] = memory16get(ss, bp - 4);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(r16[di]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d711();
        assert(cs == 0x023f);
        sp += 0x0010;
        pc = 0x37c9;
        break;
    case 0x372e:
        r16[si] = memory16get(ss, bp + 10);
        r16[si] &= 0x0007;
        if (r16[si]) {
            pc = 0x3740;
            break;
        }
        memory16set(ss, bp - 10, 0x0000);
        pc = 0x3748;
        break;
    case 0x3740:
        r16[ax] = 0x0008;
        r16[ax] -= r16[si];
        memory16set(ss, bp - 10, r16[ax]);
    case 0x3748:
        r16[ax] = memory16get(ss, bp - 10);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += r16[si];
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        r16[dx] = memory16get(ss, bp + 10);
        r16[dx] = sar16(r16[dx], 1);
        r16[dx] = sar16(r16[dx], 1);
        r16[dx] = sar16(r16[dx], 1);
        r16[ax] += r16[dx];
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ss, bp - 26);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 14, r16[ax]);
        if (r16[si]) {
            pc = 0x37ae;
            break;
        }
        push(memory16get(ss, bp - 12));
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 8));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d711();
        assert(cs == 0x023f);
        sp += 0x0010;
        pc = 0x37c9;
        break;
    case 0x37ae:
        push(r16[si]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(cs);
        cs = 0x0cc2;
        yield* sub_da6c();
        assert(cs == 0x023f);
        sp += 0x000e;
    case 0x37c9:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3d09() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r8[al] = memory[ss*16 + bp + 6];
    r16[bx] = memory16get(ss, bp + 8);
    es = memory16get(ss, bp + 8 + 2);
    memory[es*16 + r16[bx] + 21] = r8[al];
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_3d18() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r8[al] = memory[ss*16 + bp + 6];
    r16[bx] = memory16get(ss, bp + 8);
    es = memory16get(ss, bp + 8 + 2);
    memory[es*16 + r16[bx] + 22] = r8[al];
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_3d27() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory[ss*16 + bp + 6] != 0x00) {
            pc = 0x3d3a;
            break;
        }
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory[es*16 + r16[bx] + 23] = 0x00;
        pc = 0x3d42;
        break;
    case 0x3d3a:
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory[es*16 + r16[bx] + 23] = 0x01;
    case 0x3d42:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3d44() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r8[al] = memory[ss*16 + bp + 6];
    memory[ds*16 + 0x92e3] = r8[al];
    r8[al] = memory[ss*16 + bp + 8];
    memory[ds*16 + 0x92e2] = r8[al];
    memory[ds*16 + 0x92e1] = 0x0b;
    push(ds);
    r16[ax] = 0x8d62;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x92e0;
    push(r16[ax]);
    r16[ax] = 0x0010;
    push(r16[ax]);
    push(cs);
    cs = 0x1f0d;
    yield* sub_1f0d4();
    assert(cs == 0x023f);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_3d6f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory[ss*16 + bp + 6] < 0x00) {
            pc = 0x3d93;
            break;
        }
        if (memory[ss*16 + bp + 6] > 0x0f) {
            pc = 0x3d93;
            break;
        }
        r8[al] = memory[ss*16 + bp + 8];
        r16[cx] = 0x0004;
        r8[al] <<= r8[cl];
        r8[al] += memory[ss*16 + bp + 6];
        push(r16[ax]);
        r8[al] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_3d44();
        sp = bp;
    case 0x3d93:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3d95() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        r8[al] = memory[es*16 + r16[bx] + 5];
        memory[ss*16 + bp - 3] = r8[al];
        if (memory[ss*16 + bp - 3] >= 0x00) {
            pc = 0x3dae;
            break;
        }
        pc = 0x3e24;
        break;
    case 0x3dae:
        if (memory[ss*16 + bp - 3] > 0x05) {
            pc = 0x3e24;
            break;
        }
        r8[al] = memory[es*16 + r16[bx] + 6];
        memory[ss*16 + bp - 2] = r8[al];
        r8[al] = memory[ss*16 + bp - 3];
        r8[ah] = 0x00;
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 1] = r8[dl];
        if (memory[ss*16 + bp - 3] <= 0x03) {
            pc = 0x3de3;
            break;
        }
        if (memory[ds*16 + 0x91af] == 0x05) {
            pc = 0x3e17;
            break;
        }
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x023f);
        sp++;
        sp++;
        pc = 0x3e17;
        break;
    case 0x3de3:
        if (memory[ds*16 + 0x91af] == 0x04) {
            pc = 0x3df5;
            break;
        }
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x023f);
        sp++;
        sp++;
    case 0x3df5:
        if (memory[ss*16 + bp - 3] >= 0x02) {
            pc = 0x3e0a;
            break;
        }
        r8[al] = 0x00;
        push(r16[ax]);
        r8[al] = 0x01;
        push(r16[ax]);
        push(cs);
        yield* sub_3d44();
        sp += 0x0004;
        pc = 0x3e17;
        break;
    case 0x3e0a:
        r8[al] = 0x01;
        push(r16[ax]);
        r8[al] = 0x01;
        push(r16[ax]);
        push(cs);
        yield* sub_3d44();
        sp += 0x0004;
    case 0x3e17:
        push(memory16get(ss, bp - 1));
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_3d6f();
        sp += 0x0004;
    case 0x3e24:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3e28() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory[ss*16 + bp + 6] < 0x00) {
            pc = 0x3e57;
            break;
        }
        r8[al] = memory[ss*16 + bp + 6];
        memory[ds*16 + 0x91af] = r8[al];
        memory[ds*16 + 0x92e1] = 0x00;
        r8[al] = memory[ss*16 + bp + 6];
        memory[ds*16 + 0x92e0] = r8[al];
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x023f);
        sp = bp;
    case 0x3e57:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_3e59() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0010;
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x3e7e;
            break;
        }
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_2e17();
        sp += 0x000a;
    case 0x3e7e:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x3e9b;
            break;
        }
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_3005();
        sp += 0x000a;
    case 0x3e9b:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x3eb3;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x3eb3;
            break;
        }
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x3eb3;
            break;
        }
        pc = 0x4026;
        break;
    case 0x3eb3:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 12, es);
        memory16set(ss, bp - 14, r16[bx]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
        r16[di] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = memory16get(ss, bp - 8);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 2, r16[ax]);
        memory[ss*16 + bp - 15] = 0x00;
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0x3f0d;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] == memory[ds*16 + 0x8f66]) {
            pc = 0x3f04;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] != memory[ds*16 + 0x8f66]) {
            pc = 0x3f0d;
            break;
        }
    case 0x3f04:
        push(cs);
        cs = 0x0a34;
        yield* sub_a70c();
        assert(cs == 0x023f);
        memory[ss*16 + bp - 15] = 0x01;
    case 0x3f0d:
        if (memory[ss*16 + bp + 18] <= 0x01) {
            pc = 0x3f60;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        memory[ds*16 + 0x8f66] = r8[al];
        push(memory16get(ds, 0x8bb2));
        push(memory16get(ds, 0x8bb0));
        push(memory16get(ss, bp + 16));
        push(r16[bx]);
        push(cs);
        yield* sub_30d5();
        sp += 0x0008;
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x3f44;
            break;
        }
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(cs);
        yield* sub_3d95();
        sp += 0x0004;
    case 0x3f44:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x3f60;
            break;
        }
        r16[si] = 0;
        pc = 0x3f5b;
        break;
    case 0x3f4f:
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_2dcd();
        sp += 0x0004;
        r16[si]++;
    case 0x3f5b:
        if (r16[si] < 0x0010) {
            pc = 0x3f4f;
            break;
        }
    case 0x3f60:
        if (memory[ss*16 + bp + 18] != 0x07) {
            pc = 0x3f7d;
            break;
        }
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x3f7d;
            break;
        }
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x023f;
        yield* sub_44db();
        assert(cs == 0x023f);
        sp += 0x0004;
        pc = 0x3fcf;
        break;
    case 0x3f7d:
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x3f8b;
            break;
        }
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x3f9d;
            break;
        }
    case 0x3f8b:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(r16[di]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_bbd5();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x3f9d:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x3fb6;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(r16[di]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e20c();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x3fb6:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x3fcf;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(r16[di]);
        push(cs);
        cs = 0x0e97;
        yield* sub_edb1();
        assert(cs == 0x023f);
        sp += 0x0008;
    case 0x3fcf:
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x3ff2;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] != memory[ds*16 + 0x8f66]) {
            pc = 0x3ff2;
            break;
        }
        push(memory16get(es, r16[bx] + 2));
        push(memory16get(es, r16[bx]));
        push(cs);
        cs = 0x0ba1;
        yield* sub_be10();
        assert(cs == 0x023f);
        sp += 0x0004;
    case 0x3ff2:
        if (memory[ss*16 + bp + 18] <= 0x01) {
            pc = 0x401b;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x401b;
            break;
        }
        r16[si] = 0;
        pc = 0x4016;
        break;
    case 0x4003:
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_2dcd();
        sp += 0x0004;
        r16[si]++;
    case 0x4016:
        if (r16[si] < 0x0010) {
            pc = 0x4003;
            break;
        }
    case 0x401b:
        if (memory[ss*16 + bp - 15] != 0x01) {
            pc = 0x4026;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_a6c3();
        assert(cs == 0x023f);
    case 0x4026:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_402c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x4059;
            break;
        }
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[bx] = 0x0010;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        push(r16[dx]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d539();
        assert(cs == 0x023f);
        sp += 0x0004;
        pc = 0x4124;
        break;
    case 0x4059:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r16[di] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 2, r16[ax]);
        r16[si] = 0;
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x4076;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x409e;
            break;
        }
    case 0x4076:
        if (memory[ss*16 + bp + 10] != 0x01) {
            pc = 0x407f;
            break;
        }
        r16[si] = 0x5555;
    case 0x407f:
        if (memory[ss*16 + bp + 10] != 0x02) {
            pc = 0x4088;
            break;
        }
        r16[si] = 0xaaaa;
    case 0x4088:
        if (memory[ss*16 + bp + 10] != 0x03) {
            pc = 0x4091;
            break;
        }
        r16[si] = 0xffff;
    case 0x4091:
        push(memory16get(ss, bp - 2));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_bb20();
        assert(cs == 0x023f);
        sp += 0x0006;
    case 0x409e:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x40da;
            break;
        }
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[si] = r16[ax];
        r16[si] &= 0x000f;
        r16[ax] = r16[si];
        r16[cx] = 0x000c;
        r16[ax] <<= r8[cl];
        r16[dx] = r16[si];
        r16[cx] = 0x0008;
        r16[dx] <<= r8[cl];
        r16[ax] |= r16[dx];
        r16[dx] = r16[si];
        r16[cx] = 0x0004;
        r16[dx] <<= r8[cl];
        r16[ax] |= r16[dx];
        r16[ax] |= r16[si];
        r16[si] = r16[ax];
        push(memory16get(ss, bp - 2));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e15f();
        assert(cs == 0x023f);
        sp += 0x0006;
    case 0x40da:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x4101;
            break;
        }
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[si] = r16[ax];
        r16[cx] = 0x0008;
        r16[si] <<= r8[cl];
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[si] += r16[ax];
        push(memory16get(ss, bp - 2));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x0e97;
        yield* sub_ec4a();
        assert(cs == 0x023f);
        sp += 0x0006;
    case 0x4101:
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x4124;
            break;
        }
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] != memory[ds*16 + 0x8f66]) {
            pc = 0x4124;
            break;
        }
        push(memory16get(es, r16[bx] + 2));
        push(memory16get(es, r16[bx]));
        push(cs);
        cs = 0x0ba1;
        yield* sub_be10();
        assert(cs == 0x023f);
        sp += 0x0004;
    case 0x4124:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_412a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001e;
        r16[si] = memory16get(ss, bp + 10);
        if (signed16(r16[si]) >= 0) {
            pc = 0x413b;
            break;
        }
        r16[si] = 0;
    case 0x413b:
        if (signed16(r16[si]) <= signed16(0x013f)) {
            pc = 0x4144;
            break;
        }
        r16[si] = 0x013f;
    case 0x4144:
        if (memory16gets(ss, bp + 12) >= signed16(0x0000)) {
            pc = 0x414f;
            break;
        }
        memory16set(ss, bp + 12, 0x0000);
    case 0x414f:
        r16[ax] = memory16get(ss, bp + 12);
        if (r16s[ax] <= memory16gets(ds, 0x0084)) {
            pc = 0x415b;
            break;
        }
        pc = 0x44d5;
        break;
    case 0x415b:
        if (memory16gets(ss, bp + 14) >= signed16(0x0000)) {
            pc = 0x4166;
            break;
        }
        memory16set(ss, bp + 14, 0x0000);
    case 0x4166:
        if (memory16gets(ss, bp + 16) >= signed16(0x0000)) {
            pc = 0x4171;
            break;
        }
        memory16set(ss, bp + 16, 0x0000);
    case 0x4171:
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        if (r16s[ax] <= signed16(0x013f)) {
            pc = 0x4183;
            break;
        }
        r16[ax] = 0x013f;
        r16[ax] -= r16[si];
        memory16set(ss, bp + 14, r16[ax]);
    case 0x4183:
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += memory16get(ss, bp + 16);
        if (r16s[ax] <= memory16gets(ds, 0x0084)) {
            pc = 0x4198;
            break;
        }
        r16[ax] = memory16get(ds, 0x0084);
        r16[ax] -= memory16get(ss, bp + 12);
        memory16set(ss, bp + 16, r16[ax]);
    case 0x4198:
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x41bc;
            break;
        }
        push(memory16get(ss, bp + 22));
        push(memory16get(ss, bp + 20));
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(r16[si]);
        push(cs);
        yield* sub_3108();
        sp += 0x000e;
    case 0x41bc:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x41c6;
            break;
        }
        pc = 0x42f9;
        break;
    case 0x41c6:
        memory[ss*16 + bp + 18] = memory[ss*16 + bp + 18] & 0x0f;
        r16[bx] = memory16get(ss, bp + 20);
        es = memory16get(ss, bp + 20 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[ax] = r16[si];
        r8[al] &= 0x01;
        memory[ss*16 + bp - 21] = r8[al];
        if (memory[ss*16 + bp - 21] == 0x00) {
            pc = 0x4201;
            break;
        }
        r8[al] = memory[ss*16 + bp - 21];
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ss*16 + bp - 21] = r8[al];
        r16[cx] = 0x0008;
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] -= r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        memory[ss*16 + bp - 20] = r8[al];
        pc = 0x4205;
        break;
    case 0x4201:
        memory[ss*16 + bp - 20] = 0x00;
    case 0x4205:
        r16[ax] = r16[si];
        r8[al] += memory[ss*16 + bp + 14];
        r8[al]++;
        r8[al] &= 0x01;
        memory[ss*16 + bp - 21] = r8[al];
        if (memory[ss*16 + bp - 21] == 0x00) {
            pc = 0x4233;
            break;
        }
        r8[al] = memory[ss*16 + bp - 21];
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ss*16 + bp - 21] = r8[al];
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r16[ax] = 0x00ff;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ss*16 + bp - 19] = r8[al];
        pc = 0x4237;
        break;
    case 0x4233:
        memory[ss*16 + bp - 19] = 0x00;
    case 0x4237:
        r8[al] = memory[ss*16 + bp - 20];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 19];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax]++;
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[si];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] -= memory16get(ss, bp - 18);
        r16[ax]++;
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ss*16 + bp - 20] == 0x00) {
            pc = 0x4278;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 1);
    case 0x4278:
        if (memory[ss*16 + bp - 19] == 0x00) {
            pc = 0x4281;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 1);
    case 0x4281:
        if (memory16gets(ss, bp - 2) >= signed16(0x0000)) {
            pc = 0x428c;
            break;
        }
        memory16set(ss, bp - 2, 0x7777);
    case 0x428c:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[cx] = 0x0004;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp + 18];
        r8[dh] = 0x00;
        r16[ax] |= r16[dx];
        memory16set(ss, bp - 10, r16[ax]);
        r16[di] = memory16get(ss, bp + 12);
        r16[di] &= 0x0003;
        r16[cx] = 0x000d;
        r16[di] <<= r8[cl];
        r16[ax] = memory16get(ss, bp + 12);
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[di] += r16[ax];
        r16[di] += memory16get(ss, bp - 18);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 14, r16[ax]);
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[di];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 4, r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x0e11;
        yield* sub_e5db();
        assert(cs == 0x023f);
        sp += 0x000e;
    case 0x42f9:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x4350;
            break;
        }
        r16[bx] = memory16get(ss, bp + 20);
        es = memory16get(ss, bp + 20 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        memory16set(ss, bp + 16, memory16get(ss, bp + 16) + 1);
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r16[di] = memory16get(ss, bp + 12);
        r16[ax] = r16[di];
        r16[dx] = 0x0140;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[di] += r16[si];
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        memory16set(ss, bp - 10, r16[ax]);
        r16[bx] += r16[di];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 4, r16[ax]);
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp - 10));
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(cs);
        cs = 0x0e97;
        yield* sub_ee10();
        assert(cs == 0x023f);
        sp += 0x000a;
    case 0x4350:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x4361;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x4361;
            break;
        }
        pc = 0x44d5;
        break;
    case 0x4361:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 18] = r8[dl];
        r16[bx] = memory16get(ss, bp + 20);
        es = memory16get(ss, bp + 20 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[ax] = r16[si];
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 21] = r8[dl];
        if (memory[ss*16 + bp - 21] == 0x00) {
            pc = 0x43a7;
            break;
        }
        r8[al] = memory[ss*16 + bp - 21];
        r8[al] <<= 1;
        memory[ss*16 + bp - 21] = r8[al];
        r16[cx] = 0x0008;
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] -= r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        memory[ss*16 + bp - 20] = r8[al];
        pc = 0x43ab;
        break;
    case 0x43a7:
        memory[ss*16 + bp - 20] = 0x00;
    case 0x43ab:
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        r16[ax]++;
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 21] = r8[dl];
        if (memory[ss*16 + bp - 21] == 0x00) {
            pc = 0x43d9;
            break;
        }
        r8[al] = memory[ss*16 + bp - 21];
        r8[al] <<= 1;
        memory[ss*16 + bp - 21] = r8[al];
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r16[ax] = 0x00ff;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ss*16 + bp - 19] = r8[al];
        pc = 0x43dd;
        break;
    case 0x43d9:
        memory[ss*16 + bp - 19] = 0x00;
    case 0x43dd:
        r8[al] = memory[ss*16 + bp - 20];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 19];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax]++;
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[si];
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp + 14);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] -= memory16get(ss, bp - 18);
        r16[ax]++;
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ss*16 + bp - 20] == 0x00) {
            pc = 0x441e;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 1);
    case 0x441e:
        if (memory[ss*16 + bp - 19] == 0x00) {
            pc = 0x4427;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 1);
    case 0x4427:
        if (memory16gets(ss, bp - 2) >= signed16(0x0000)) {
            pc = 0x4432;
            break;
        }
        memory16set(ss, bp - 2, 0x7777);
    case 0x4432:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0002) {
            pc = 0x4461;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x444c; break;
        case 2: pc = 0x4453; break;
            default:
            assert(0);
        }
        break;
    case 0x444c:
        memory16set(ss, bp - 10, 0x5555);
        pc = 0x4466;
        break;
    case 0x4453:
        memory16set(ss, bp - 10, 0xaaaa);
        pc = 0x4466;
        break;
    case 0x4461:
        memory16set(ss, bp - 10, 0x0000);
    case 0x4466:
        r16[ax] = memory16get(ss, bp + 12);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[di] = r16[ax];
        r16[ax] = r16[di];
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[di] += memory16get(ss, bp - 18);
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        if (!r16[dx]) {
            pc = 0x449e;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x2000;
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        memory16set(ss, bp - 14, 0x0000);
        pc = 0x44ae;
        break;
    case 0x449e:
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[di];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        memory16set(ss, bp - 14, 0x0050);
    case 0x44ae:
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = memory16get(ss, bp - 30);
        memory16set(ss, bp - 4, r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x0ba1;
        yield* sub_c416();
        assert(cs == 0x023f);
        sp += 0x000e;
    case 0x44d5:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_44db() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0072;
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0x6e;
        memory16set(ss, bp - 26, es);
        memory16set(ss, bp - 28, r16[bx]);
        memory[ss*16 + bp - 113] = 0x00;
        pc = 0x4517;
        break;
    case 0x450a:
        r16[bx] = memory16get(ss, bp - 28);
        es = memory16get(ss, bp - 28 + 2);
        memory[es*16 + r16[bx]] = 0x00;
        memory16set(ss, bp - 28, memory16get(ss, bp - 28) + 1);
        memory[ss*16 + bp - 113] += 1;
    case 0x4517:
        if (memory[ss*16 + bp - 113] < 0x51) {
            pc = 0x450a;
            break;
        }
        memory[ss*16 + bp - 112] = 0x00;
        memory[ss*16 + bp - 111] = 0x63;
        memory[ss*16 + bp - 113] = 0x00;
        pc = 0x45b1;
        break;
    case 0x452c:
        r8[al] = memory[ss*16 + bp - 112];
        r8[ah] = 0x00;
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        r8[al] = memory[ss*16 + bp - 111];
        r8[ah] = 0x00;
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[di] += 0x2000;
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0x6e;
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0x6e;
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[bx] += r16[si];
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        r16[bx] += r16[di];
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 24));
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        memory[ss*16 + bp - 112] += 1;
        memory[ss*16 + bp - 111] -= 1;
        memory[ss*16 + bp - 113] += 1;
    case 0x45b1:
        if (memory[ss*16 + bp - 113] >= 0x64) {
            pc = 0x45ba;
            break;
        }
        pc = 0x452c;
        break;
    case 0x45ba:
        push(memory16get(ds, 0x8bb2));
        push(memory16get(ds, 0x8bb0));
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        yield* sub_30d5();
        sp += 0x0008;
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        yield* sub_3d95();
        sp += 0x0004;
        memory[ss*16 + bp - 112] = 0x00;
        memory[ss*16 + bp - 111] = 0x63;
        memory[ss*16 + bp - 113] = 0x00;
        pc = 0x466a;
        break;
    case 0x45e9:
        r8[al] = memory[ss*16 + bp - 112];
        r8[ah] = 0x00;
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        r8[al] = memory[ss*16 + bp - 111];
        r8[ah] = 0x00;
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[di] += 0x2000;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[si];
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += r16[di];
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[bx] += r16[si];
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        r16[bx] += r16[di];
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 24));
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        memory[ss*16 + bp - 112] += 1;
        memory[ss*16 + bp - 111] -= 1;
        memory[ss*16 + bp - 113] += 1;
    case 0x466a:
        if (memory[ss*16 + bp - 113] >= 0x64) {
            pc = 0x4673;
            break;
        }
        pc = 0x45e9;
        break;
    case 0x4673:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4679() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0022;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r8[al] = 0x05;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x0f;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x03;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0xff;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x02;
        r16[dx] = 0x03c4;
        out8(r16[dx], r8[al]);
        r8[al] = 0x0f;
        r16[dx] = 0x03c5;
        out8(r16[dx], r8[al]);
        memory[es*16 + r16[bx]] = 0x00;
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 25] = r8[al];
        r8[al] = 0x05;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        memory16set(ss, bp - 4, 0x0000);
        memory16set(ss, bp - 2, 0x00c7);
        r16[di] = 0;
        pc = 0x4770;
        break;
    case 0x4705:
        r16[ax] = memory16get(ss, bp - 4);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp - 2);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r16[bx] += memory16get(ss, bp - 8);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[bx] = memory16get(ss, bp - 30);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[si] = 0;
        pc = 0x475e;
        break;
    case 0x4736:
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 25] = r8[al];
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 25] = r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r16[bx] = memory16get(ss, bp - 16);
        es = memory16get(ss, bp - 16 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 1);
        r8[al] = memory[ss*16 + bp - 25];
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 1);
        r16[si]++;
    case 0x475e:
        if (r16[si] < 0x0028) {
            pc = 0x4736;
            break;
        }
        push(cs);
        yield* sub_2445();
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0002);
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 0x0002);
        r16[di]++;
    case 0x4770:
        if (r16[di] < 0x0064) {
            pc = 0x4705;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x4780;
            break;
        }
        push(cs);
        yield* sub_2af9();
    case 0x4780:
        if (memory[ds*16 + 0x8f67] != 0x00) {
            pc = 0x47a3;
            break;
        }
        r16[di] = 0;
        pc = 0x479e;
        break;
    case 0x478b:
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[di]];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_2dcd();
        sp += 0x0004;
        r16[di]++;
    case 0x479e:
        if (r16[di] < 0x0010) {
            pc = 0x478b;
            break;
        }
    case 0x47a3:
        memory16set(ss, bp - 4, 0x0000);
        memory16set(ss, bp - 2, 0x00c7);
        r16[di] = 0;
        pc = 0x47b2;
        break;
    case 0x47b1:
        r16[di]++;
    case 0x47b2:
        if (r16[di] < 0x03e8) {
            pc = 0x47b1;
            break;
        }
        r16[di] = 0;
        pc = 0x4848;
        break;
    case 0x47bd:
        r16[ax] = memory16get(ss, bp - 4);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp - 2);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = memory16get(ss, bp - 34);
        es = memory16get(ss, bp - 34 + 2);
        r16[bx] += memory16get(ss, bp - 8);
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[bx] = memory16get(ss, bp - 34);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r16[bx] += memory16get(ss, bp - 8);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[bx] = memory16get(ss, bp - 30);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[si] = 0;
        pc = 0x4836;
        break;
    case 0x4805:
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 25] = r8[al];
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + 1);
        r8[al] = memory[ss*16 + bp - 25];
        r16[bx] = memory16get(ss, bp - 16);
        es = memory16get(ss, bp - 16 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 1);
        r16[bx] = memory16get(ss, bp - 20);
        es = memory16get(ss, bp - 20 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 25] = r8[al];
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + 1);
        r8[al] = memory[ss*16 + bp - 25];
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 1);
        r16[si]++;
    case 0x4836:
        if (r16[si] < 0x0028) {
            pc = 0x4805;
            break;
        }
        push(cs);
        yield* sub_2445();
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0002);
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) - 0x0002);
        r16[di]++;
    case 0x4848:
        if (r16[di] >= 0x0064) {
            pc = 0x4850;
            break;
        }
        pc = 0x47bd;
        break;
    case 0x4850:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4856() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0018;
        r16[si] = memory16get(ss, bp + 12);
        r16[di] = memory16get(ss, bp + 10);
        if (signed16(r16[si]) <= memory16gets(ds, 0x0084)) {
            pc = 0x486d;
            break;
        }
        pc = 0x4a2f;
        break;
    case 0x486d:
        if (signed16(r16[di]) <= signed16(0x013f)) {
            pc = 0x4876;
            break;
        }
        pc = 0x4a2f;
        break;
    case 0x4876:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 10, r16[ax]);
        r16[bx] = memory16get(ss, bp + 18);
        es = memory16get(ss, bp + 18 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        if (signed16(r16[si]) >= 0) {
            pc = 0x48e9;
            break;
        }
        r16[ax] = r16[si];
        if (r16s[ax] >= 0) {
            pc = 0x48d0;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x48d0:
        r16[si] = r16[ax];
        if (r16[si] < memory16get(ss, bp - 10)) {
            pc = 0x48da;
            break;
        }
        pc = 0x4a2f;
        break;
    case 0x48da:
        r16[ax] = r16[si];
        mul16(memory16get(ss, bp - 12));
        r16[ax] <<= 1;
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + r16[ax]);
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) - r16[si]);
        r16[si] = 0;
    case 0x48e9:
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp - 10);
        r16[dx] = memory16get(ds, 0x0084);
        r16[dx]++;
        if (r16[ax] <= r16[dx]) {
            pc = 0x4900;
            break;
        }
        r16[ax] = memory16get(ds, 0x0084);
        r16[ax]++;
        r16[ax] -= r16[si];
        memory16set(ss, bp - 10, r16[ax]);
    case 0x4900:
        r16[ax] = 0x00ff;
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ss, bp - 6, 0x0000);
        if (signed16(r16[di]) < 0) {
            pc = 0x491c;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 16, r16[ax]);
        pc = 0x496f;
        break;
    case 0x491c:
        r16[ax] = r16[di];
        if (r16s[ax] >= 0) {
            pc = 0x4924;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x4924:
        r16[di] = r16[ax];
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        if (r16[ax] > r16[di]) {
            pc = 0x4934;
            break;
        }
        pc = 0x4a2f;
        break;
    case 0x4934:
        r16[ax] = r16[di];
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] <<= 1;
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + r16[ax]);
        r16[ax] >>= 1;
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - r16[ax]);
        if (memory16get(ss, bp - 12) != 0x0001) {
            pc = 0x4950;
            break;
        }
        pc = 0x4a2f;
        break;
    case 0x4950:
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 16, r16[ax]);
        if (!r16[ax]) {
            pc = 0x496d;
            break;
        }
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) - 1);
        r16[ax] = 0x0004;
        r16[ax] -= memory16get(ss, bp - 16);
        memory16set(ss, bp - 16, r16[ax]);
        memory16set(ss, bp - 4, 0x0000);
    case 0x496d:
        r16[di] = 0;
    case 0x496f:
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += r16[di];
        if (r16[ax] <= 0x0140) {
            pc = 0x49a9;
            break;
        }
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += r16[di];
        r16[ax] += 0xfec0;
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) >> 1);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) >> 1);
        r16[ax] = memory16get(ss, bp - 6);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - r16[ax]);
        if (memory16get(ss, bp - 12) != 0x0001) {
            pc = 0x49a1;
            break;
        }
        pc = 0x4a2f;
        break;
    case 0x49a1:
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) << 1);
        memory16set(ss, bp - 2, 0x0000);
    case 0x49a9:
        r16[ax] = r16[si];
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 14, r16[ax]);
        if (!r16[ax]) {
            pc = 0x49ba;
            break;
        }
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + 0x2000);
    case 0x49ba:
        r16[si] = sar16(r16[si], 1);
        r16[ax] = r16[si];
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + r16[ax]);
        r16[ax] = r16[di];
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + r16[ax]);
        memory16set(ss, bp - 14, memory16get(ss, bp - 14) ^ 0x0001);
        if (memory16get(ss, bp - 16) == 0x0000) {
            pc = 0x4a0a;
            break;
        }
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 24));
        r16[ax] = memory16get(ss, bp - 22);
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        r16[ax] = memory16get(ss, bp - 18);
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x0ba1;
        yield* sub_bc26();
        assert(cs == 0x023f);
        sp += 0x0018;
        pc = 0x4a2f;
        break;
    case 0x4a0a:
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 24));
        r16[ax] = memory16get(ss, bp - 22);
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        r16[ax] = memory16get(ss, bp - 18);
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x0ba1;
        yield* sub_be9f();
        assert(cs == 0x023f);
        sp += 0x0012;
    case 0x4a2f:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4a35() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0018;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        if (signed16(r16[di]) <= memory16gets(ds, 0x0084)) {
            pc = 0x4a4c;
            break;
        }
        pc = 0x4bfd;
        break;
    case 0x4a4c:
        if (signed16(r16[si]) <= signed16(0x013f)) {
            pc = 0x4a55;
            break;
        }
        pc = 0x4bfd;
        break;
    case 0x4a55:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 10, r16[ax]);
        r16[bx] = memory16get(ss, bp + 18);
        es = memory16get(ss, bp + 18 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        if (signed16(r16[di]) >= 0) {
            pc = 0x4ac8;
            break;
        }
        r16[ax] = r16[di];
        if (r16s[ax] >= 0) {
            pc = 0x4aaf;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x4aaf:
        r16[di] = r16[ax];
        if (r16[di] < memory16get(ss, bp - 10)) {
            pc = 0x4ab9;
            break;
        }
        pc = 0x4bfd;
        break;
    case 0x4ab9:
        r16[ax] = r16[di];
        mul16(memory16get(ss, bp - 12));
        r16[ax] <<= 1;
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + r16[ax]);
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) - r16[di]);
        r16[di] = 0;
    case 0x4ac8:
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 10);
        r16[dx] = memory16get(ds, 0x0084);
        r16[dx]++;
        if (r16[ax] <= r16[dx]) {
            pc = 0x4adf;
            break;
        }
        r16[ax] = memory16get(ds, 0x0084);
        r16[ax]++;
        r16[ax] -= r16[di];
        memory16set(ss, bp - 10, r16[ax]);
    case 0x4adf:
        r16[ax] = 0x00ff;
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ss, bp - 6, 0x0000);
        if (signed16(r16[si]) < 0) {
            pc = 0x4afb;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 16, r16[ax]);
        pc = 0x4b4a;
        break;
    case 0x4afb:
        r16[ax] = r16[si];
        if (r16s[ax] >= 0) {
            pc = 0x4b03;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x4b03:
        r16[si] = r16[ax];
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] <<= 1;
        if (r16[ax] > r16[si]) {
            pc = 0x4b11;
            break;
        }
        pc = 0x4bfd;
        break;
    case 0x4b11:
        r16[ax] = r16[si];
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] <<= 1;
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + r16[ax]);
        r16[ax] >>= 1;
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - r16[ax]);
        if (memory16get(ss, bp - 12) != 0x0001) {
            pc = 0x4b2b;
            break;
        }
        pc = 0x4bfd;
        break;
    case 0x4b2b:
        r16[ax] = r16[si];
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 16, r16[ax]);
        if (!r16[ax]) {
            pc = 0x4b48;
            break;
        }
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) - 1);
        r16[ax] = 0x0001;
        r16[ax] -= memory16get(ss, bp - 16);
        memory16set(ss, bp - 16, r16[ax]);
        memory16set(ss, bp - 4, 0x0000);
    case 0x4b48:
        r16[si] = 0;
    case 0x4b4a:
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] <<= 1;
        r16[ax] += r16[si];
        if (r16[ax] <= 0x0140) {
            pc = 0x4b7d;
            break;
        }
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] <<= 1;
        r16[ax] += r16[si];
        r16[ax] += 0xfec0;
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) >> 1);
        r16[ax] = memory16get(ss, bp - 6);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - r16[ax]);
        if (memory16get(ss, bp - 12) != 0x0001) {
            pc = 0x4b75;
            break;
        }
        pc = 0x4bfd;
        break;
    case 0x4b75:
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) << 1);
        memory16set(ss, bp - 2, 0x0000);
    case 0x4b7d:
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 14, r16[ax]);
        r16[cx] = 0x000d;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        r16[ax] = r16[si];
        r16[ax] = sar16(r16[ax], 1);
        r16[dx] += r16[ax];
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + r16[dx]);
        if (memory16get(ss, bp - 16) == 0x0000) {
            pc = 0x4bd8;
            break;
        }
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 24));
        r16[ax] = memory16get(ss, bp - 22);
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        r16[ax] = memory16get(ss, bp - 18);
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x0e11;
        yield* sub_e25c();
        assert(cs == 0x023f);
        sp += 0x0018;
        pc = 0x4bfd;
        break;
    case 0x4bd8:
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 24));
        r16[ax] = memory16get(ss, bp - 22);
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        r16[ax] = memory16get(ss, bp - 18);
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x0e11;
        yield* sub_e35e();
        assert(cs == 0x023f);
        sp += 0x0012;
    case 0x4bfd:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4c03() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001e;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x4c2d;
            break;
        }
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        yield* sub_3448();
        sp += 0x000c;
    case 0x4c2d:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x4c3b;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x4c50;
            break;
        }
    case 0x4c3b:
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        yield* sub_4856();
        sp += 0x000c;
    case 0x4c50:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x4c6c;
            break;
        }
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        yield* sub_4a35();
        sp += 0x000c;
    case 0x4c6c:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x4c76;
            break;
        }
        pc = 0x4dab;
        break;
    case 0x4c76:
        if (signed16(r16[di]) <= signed16(0x00c7)) {
            pc = 0x4c7f;
            break;
        }
        pc = 0x4dab;
        break;
    case 0x4c7f:
        if (signed16(r16[si]) <= signed16(0x013f)) {
            pc = 0x4c88;
            break;
        }
        pc = 0x4dab;
        break;
    case 0x4c88:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) << 1);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) << 1);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) << 1);
        r16[ax] = r16[si];
        r16[tx] = r16[ax];
        r16[ax] += memory16get(ss, bp - 6);
        if (r16s[tx] + memory16gets(ss, bp - 6) > 0) {
            pc = 0x4cb0;
            break;
        }
        pc = 0x4dab;
        break;
    case 0x4cb0:
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 18, r16[ax]);
        if (signed16(r16[si]) >= 0) {
            pc = 0x4cd4;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] = -r16[ax];
        memory16set(ss, bp - 4, r16[ax]);
        r16[si] = 0;
        pc = 0x4cd9;
        break;
    case 0x4cd4:
        memory16set(ss, bp - 4, 0x0000);
    case 0x4cd9:
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp - 6);
        if (r16[ax] <= 0x0140) {
            pc = 0x4cf0;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp - 6);
        r16[ax] += 0xfec0;
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0x4cf5;
        break;
    case 0x4cf0:
        memory16set(ss, bp - 2, 0x0000);
    case 0x4cf5:
        if (signed16(r16[di]) >= 0) {
            pc = 0x4cfb;
            break;
        }
        r16[di] = 0;
    case 0x4cfb:
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 18);
        if (r16[ax] <= 0x00c8) {
            pc = 0x4d0d;
            break;
        }
        r16[ax] = 0x00c8;
        r16[ax] -= r16[di];
        memory16set(ss, bp - 18, r16[ax]);
    case 0x4d0d:
        r16[bx] = memory16get(ss, bp + 18);
        es = memory16get(ss, bp + 18 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 20, es);
        memory16set(ss, bp - 22, r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0140;
        mul16(r16[dx]);
        r16[ax] += r16[si];
        memory16set(ss, bp - 8, r16[ax]);
        r16[bx] = memory16get(ss, bp - 22);
        es = memory16get(ss, bp - 22 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 10, r16[ax]);
        if (memory16get(ss, bp - 4) != 0x0000) {
            pc = 0x4d84;
            break;
        }
        if (memory16get(ss, bp - 2) != 0x0000) {
            pc = 0x4d84;
            break;
        }
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0e97;
        yield* sub_ec9e();
        assert(cs == 0x023f);
        sp += 0x000c;
        pc = 0x4dab;
        break;
    case 0x4d84:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 18));
        r16[ax] = memory16get(ss, bp - 6);
        r16[ax] -= memory16get(ss, bp - 4);
        r16[ax] -= memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0e97;
        yield* sub_ece3();
        assert(cs == 0x023f);
        sp += 0x0010;
    case 0x4dab:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4db1() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x000c;
    r16[ax] = memory16get(ss, bp + 14);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    memory16set(ss, bp - 2, es);
    memory16set(ss, bp - 4, r16[bx]);
    r16[si] = memory16get(es, r16[bx] + 2);
    r16[di] = memory16get(es, r16[bx] + 14);
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx] + 10);
    es = memory16get(es, r16[tx] + 10 + 2);
    memory16set(ss, bp - 10, es);
    memory16set(ss, bp - 12, r16[bx]);
    memory16set(ss, bp + 10, sar16(memory16get(ss, bp + 10), 1));
    memory16set(ss, bp + 10, sar16(memory16get(ss, bp + 10), 1));
    memory16set(ss, bp + 10, sar16(memory16get(ss, bp + 10), 1));
    r16[bx] = memory16get(ss, bp + 18);
    es = memory16get(ss, bp + 18 + 2);
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx]);
    es = memory16get(es, r16[tx] + 2);
    memory16set(ss, bp - 6, es);
    memory16set(ss, bp - 8, r16[bx]);
    r16[ax] = memory16get(ss, bp + 12);
    r16[dx] = 0x0028;
    mul16(r16[dx]);
    r16[ax] += memory16get(ss, bp + 10);
    memory16set(ss, bp - 8, memory16get(ss, bp - 8) + r16[ax]);
    push(r16[di]);
    push(r16[si]);
    push(memory16get(ss, bp - 8));
    r16[ax] = memory16get(ss, bp - 6);
    push(r16[ax]);
    push(memory16get(ss, bp - 12));
    r16[ax] = memory16get(ss, bp - 10);
    push(r16[ax]);
    push(cs);
    cs = 0x0cc2;
    yield* sub_d99b();
    assert(cs == 0x023f);
    sp += 0x000c;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_4e20() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0010;
        r16[si] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 6, r16[ax]);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        memory16set(ss, bp + 10, sar16(memory16get(ss, bp + 10), 1));
        memory16set(ss, bp + 10, sar16(memory16get(ss, bp + 10), 1));
        r16[bx] = memory16get(ss, bp + 18);
        es = memory16get(ss, bp + 18 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
        r16[di] = r16[si];
        r16[di] &= 0x0001;
        r16[si] = sar16(r16[si], 1);
        if (!r16[di]) {
            pc = 0x4e8a;
            break;
        }
        r16[ax] = r16[si];
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[ax] += 0x2000;
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
        pc = 0x4e94;
        break;
    case 0x4e8a:
        r16[ax] = r16[si];
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
    case 0x4e94:
        push(r16[di]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 12));
        r16[ax] = memory16get(ss, bp - 10);
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        r16[ax] = memory16get(ss, bp - 14);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c774();
        assert(cs == 0x023f);
        sp += 0x000e;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4eb7() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x0010;
    r16[di] = memory16get(ss, bp + 12);
    r16[ax] = memory16get(ss, bp + 14);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    memory16set(ss, bp - 2, es);
    memory16set(ss, bp - 4, r16[bx]);
    r16[ax] = memory16get(es, r16[bx] + 2);
    memory16set(ss, bp - 8, r16[ax]);
    r16[ax] = memory16get(es, r16[bx] + 14);
    memory16set(ss, bp - 6, r16[ax]);
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx] + 10);
    es = memory16get(es, r16[tx] + 10 + 2);
    memory16set(ss, bp - 14, es);
    memory16set(ss, bp - 16, r16[bx]);
    memory16set(ss, bp + 10, sar16(memory16get(ss, bp + 10), 1));
    r16[bx] = memory16get(ss, bp + 18);
    es = memory16get(ss, bp + 18 + 2);
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx]);
    es = memory16get(es, r16[tx] + 2);
    memory16set(ss, bp - 10, es);
    memory16set(ss, bp - 12, r16[bx]);
    r16[ax] = memory16get(ss, bp + 10);
    memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
    r16[si] = r16[di];
    r16[si] &= 0x0003;
    r16[di] = sar16(r16[di], 1);
    r16[di] = sar16(r16[di], 1);
    r16[ax] = r16[di];
    r16[dx] = 0x00a0;
    mul16(r16[dx]);
    r16[dx] = r16[si];
    r16[cx] = 0x000d;
    r16[dx] <<= r8[cl];
    r16[ax] += r16[dx];
    memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
    push(r16[si]);
    push(memory16get(ss, bp - 6));
    push(memory16get(ss, bp - 8));
    push(memory16get(ss, bp - 12));
    r16[ax] = memory16get(ss, bp - 10);
    push(r16[ax]);
    push(memory16get(ss, bp - 16));
    r16[ax] = memory16get(ss, bp - 14);
    push(r16[ax]);
    push(cs);
    cs = 0x0e11;
    yield* sub_e806();
    assert(cs == 0x023f);
    sp += 0x000e;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_4f43() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x4f69;
            break;
        }
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        yield* sub_4db1();
        sp = bp;
    case 0x4f69:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x4f77;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x4f8b;
            break;
        }
    case 0x4f77:
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        yield* sub_4e20();
        sp = bp;
    case 0x4f8b:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x4fa6;
            break;
        }
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        yield* sub_4eb7();
        sp = bp;
    case 0x4fa6:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_4faa() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0026;
        r16[si] = memory16get(ss, bp + 14);
        r16[di] = memory16get(ss, bp + 12);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x4fd4;
            break;
        }
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(r16[si]);
        push(r16[di]);
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_3268();
        sp += 0x000a;
        pc = 0x54fd;
        break;
    case 0x4fd4:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x4fe5;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x4fe5;
            break;
        }
        pc = 0x5202;
        break;
    case 0x4fe5:
        if (memory16gets(ss, bp + 10) >= signed16(0x0000)) {
            pc = 0x4ff0;
            break;
        }
        memory16set(ss, bp + 10, 0x0000);
    case 0x4ff0:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += memory16get(ss, bp + 10);
        if (r16[ax] <= 0x013f) {
            pc = 0x502c;
            break;
        }
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        memory16set(ss, bp + 10, r16[dx]);
    case 0x502c:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16s[ax] <= signed16(r16[di])) {
            pc = 0x5044;
            break;
        }
        pc = 0x54fd;
        break;
    case 0x5044:
        if (signed16(r16[di]) <= signed16(0x00c7)) {
            pc = 0x504d;
            break;
        }
        r16[di] = 0x00c7;
    case 0x504d:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx] + 21];
        memory[ss*16 + bp - 25] = r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 14, r16[ax]);
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        if (r16[ax] > 0x0003) {
            pc = 0x50ac;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x5092; break;
        case 2: pc = 0x5099; break;
        case 4: pc = 0x50a0; break;
        case 6: pc = 0x50a7; break;
            default:
            assert(0);
        }
        break;
    case 0x5092:
        memory16set(ss, bp - 14, 0x0000);
        pc = 0x50ac;
        break;
    case 0x5099:
        memory16set(ss, bp - 14, 0x5555);
        pc = 0x50ac;
        break;
    case 0x50a0:
        memory16set(ss, bp - 14, 0xaaaa);
        pc = 0x50ac;
        break;
    case 0x50a7:
        memory16set(ss, bp - 14, 0xffff);
    case 0x50ac:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx] + 22];
        memory[ss*16 + bp - 25] = r8[al];
        if (memory[es*16 + r16[bx] + 23] != 0x00) {
            pc = 0x5108;
            break;
        }
        push(memory16get(ss, bp + 18));
        push(r16[bx]);
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_412a();
        sp += 0x000e;
    case 0x5108:
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 12, r16[dx]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 24, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 36, es);
        memory16set(ss, bp - 38, r16[bx]);
        r16[ax] = memory16get(ss, bp - 36);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        r16[ax] >>= 1;
        memory16set(ss, bp - 8, r16[ax]);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp - 6);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + r16[ax]);
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        if (!(r16[ax] & 0x0001)) {
            pc = 0x51c1;
            break;
        }
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] += 0x2000;
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        memory16set(ss, bp - 10, 0x0000);
        pc = 0x51d2;
        break;
    case 0x51c1:
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r16[bx] += memory16get(ss, bp - 8);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        memory16set(ss, bp - 10, 0x0050);
    case 0x51d2:
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp - 34);
        memory16set(ss, bp - 16, r16[ax]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(r16[ax]);
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 24));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x0ba1;
        yield* sub_bef8();
        assert(cs == 0x023f);
        sp += 0x0012;
        pc = 0x54ed;
        break;
    case 0x5202:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x520c;
            break;
        }
        pc = 0x539f;
        break;
    case 0x520c:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx] + 21];
        memory[ss*16 + bp - 25] = r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = 0x0004;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] |= r16[dx];
        memory16set(ss, bp - 14, r16[ax]);
        if (memory[es*16 + r16[bx] + 23] != 0x00) {
            pc = 0x528f;
            break;
        }
        r8[al] = memory[es*16 + r16[bx] + 22];
        memory[ss*16 + bp - 25] = r8[al];
        push(memory16get(ss, bp + 18));
        push(r16[bx]);
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_412a();
        sp += 0x000e;
    case 0x528f:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 24, r16[ax]);
        r16[di] -= r16[ax];
        if (memory16gets(ss, bp + 10) >= signed16(0x0000)) {
            pc = 0x52c4;
            break;
        }
        memory16set(ss, bp + 10, 0x0000);
    case 0x52c4:
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] <<= 1;
        r16[ax] += memory16get(ss, bp + 10);
        if (r16[ax] <= 0x013f) {
            pc = 0x52de;
            break;
        }
        r16[ax] = 0x013f;
        r16[dx] = memory16get(ss, bp - 4);
        r16[dx] <<= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp + 10, r16[ax]);
    case 0x52de:
        if (signed16(r16[di]) >= 0) {
            pc = 0x52e4;
            break;
        }
        r16[di] = 0;
    case 0x52e4:
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 24);
        if (r16[ax] <= 0x00c7) {
            pc = 0x52f4;
            break;
        }
        r16[di] = 0x00c7;
        r16[di] -= memory16get(ss, bp - 24);
    case 0x52f4:
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 36, es);
        memory16set(ss, bp - 38, r16[bx]);
        r16[ax] = memory16get(ss, bp - 36);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        r16[cx] = 0x000d;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        r16[dx] += memory16get(ss, bp - 6);
        memory16set(ss, bp - 8, r16[dx]);
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 10, r16[ax]);
        memory16set(ss, bp - 2, 0x0000);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 24));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 4));
        push(r16[ax]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e465();
        assert(cs == 0x023f);
        sp += 0x001a;
        pc = 0x54ed;
        break;
    case 0x539f:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x53a9;
            break;
        }
        pc = 0x54fd;
        break;
    case 0x53a9:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx] + 21];
        memory[ss*16 + bp - 25] = r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        memory16set(ss, bp - 14, r16[ax]);
        if (memory[es*16 + r16[bx] + 23] != 0x00) {
            pc = 0x5420;
            break;
        }
        r8[al] = memory[es*16 + r16[bx] + 22];
        memory[ss*16 + bp - 25] = r8[al];
        push(memory16get(ss, bp + 18));
        push(r16[bx]);
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_412a();
        sp += 0x000e;
    case 0x5420:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 24, r16[ax]);
        r16[di] -= r16[ax];
        if (memory16gets(ss, bp + 10) >= signed16(0x0000)) {
            pc = 0x5455;
            break;
        }
        memory16set(ss, bp + 10, 0x0000);
    case 0x5455:
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] += memory16get(ss, bp + 10);
        if (r16[ax] <= 0x013f) {
            pc = 0x5477;
            break;
        }
        r16[ax] = 0x013f;
        r16[dx] = memory16get(ss, bp - 4);
        r16[dx] <<= 1;
        r16[dx] <<= 1;
        r16[dx] <<= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp + 10, r16[ax]);
    case 0x5477:
        if (signed16(r16[di]) >= 0) {
            pc = 0x547d;
            break;
        }
        r16[di] = 0;
    case 0x547d:
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 24);
        if (r16[ax] <= 0x00c7) {
            pc = 0x548d;
            break;
        }
        r16[di] = 0x00c7;
        r16[di] -= memory16get(ss, bp - 24);
    case 0x548d:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 36, es);
        memory16set(ss, bp - 38, r16[bx]);
        r16[ax] = memory16get(ss, bp - 36);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0140;
        mul16(r16[dx]);
        r16[ax] += memory16get(ss, bp + 10);
        memory16set(ss, bp - 8, r16[ax]);
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 16, r16[ax]);
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 24));
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(r16[ax]);
        push(memory16get(ss, bp - 18));
        push(cs);
        cs = 0x0e97;
        yield* sub_ed32();
        assert(cs == 0x023f);
        sp += 0x000e;
    case 0x54ed:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
    case 0x54fd:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_5ada() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x000a;
    case 0x5ae0:
        r16[dx] = 0;
        r16[ax] = 0x0005;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x023f);
        r16[dx] |= r16[ax];
        if (!r16[dx]) {
            pc = 0x5b00;
            break;
        }
        flags.carry = (memory16get(ss, bp + 14) + 0x0001) >= 0x10000;
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 0x0001);
        memory16set(ss, bp + 16, memory16get(ss, bp + 16) + flags.carry);
        pc = 0x5ae0;
        break;
    case 0x5b00:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        memory16set(ss, bp - 2, 0x0000);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x5b6a;
        break;
    case 0x5b15:
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        r16[ax] += memory16get(ss, bp - 4);
        r16[ax] += 0x0004;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        r16[ax] += memory16get(ss, bp - 4);
        r16[ax] += 0x0003;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        r16[ax] += memory16get(ss, bp - 4);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        r16[ax] += memory16get(ss, bp - 4);
        r16[ax]++;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x023f;
        yield* sub_5c67();
        assert(cs == 0x023f);
        sp += 0x0016;
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0004);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        flags.carry = (r16[ax] + 0x0005) >= 0x10000;
        r16[ax] += 0x0005;
        r16[dx] += flags.carry;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
    case 0x5b6a:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        if (r16[dx] < memory16get(ss, bp + 16)) {
            pc = 0x5b15;
            break;
        }
        if (r16[dx] != memory16get(ss, bp + 16)) {
            pc = 0x5b7c;
            break;
        }
        if (r16[ax] < memory16get(ss, bp + 14)) {
            pc = 0x5b15;
            break;
        }
    case 0x5b7c:
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(ss, bp + 8, es);
        memory16set(ss, bp + 6, r16[bx]);
        memory16set(ss, bp - 2, 0x0000);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x5c4b;
        break;
    case 0x5b92:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        r16[bx] += memory16get(ss, bp - 4);
        r8[al] = memory[es*16 + r16[bx]];
        r8[al] ^= 0xff;
        memory[ss*16 + bp - 9] = r8[al];
        if (!(memory[ss*16 + bp - 9] & 0x80)) {
            pc = 0x5bb0;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0xf0;
        pc = 0x5bb7;
        break;
    case 0x5bb0:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0x00;
    case 0x5bb7:
        if (!(memory[ss*16 + bp - 9] & 0x40)) {
            pc = 0x5bc7;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] | 0x0f;
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
    case 0x5bc7:
        if (!(memory[ss*16 + bp - 9] & 0x20)) {
            pc = 0x5bd6;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0xf0;
        pc = 0x5bdd;
        break;
    case 0x5bd6:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0x00;
    case 0x5bdd:
        if (!(memory[ss*16 + bp - 9] & 0x10)) {
            pc = 0x5bed;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] | 0x0f;
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
    case 0x5bed:
        if (!(memory[ss*16 + bp - 9] & 0x08)) {
            pc = 0x5bfc;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0xf0;
        pc = 0x5c03;
        break;
    case 0x5bfc:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0x00;
    case 0x5c03:
        if (!(memory[ss*16 + bp - 9] & 0x04)) {
            pc = 0x5c13;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] | 0x0f;
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
    case 0x5c13:
        if (!(memory[ss*16 + bp - 9] & 0x02)) {
            pc = 0x5c22;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0xf0;
        pc = 0x5c29;
        break;
    case 0x5c22:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = 0x00;
    case 0x5c29:
        if (!(memory[ss*16 + bp - 9] & 0x01)) {
            pc = 0x5c39;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] | 0x0f;
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
    case 0x5c39:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        flags.carry = (r16[ax] + 0x0005) >= 0x10000;
        r16[ax] += 0x0005;
        r16[dx] += flags.carry;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
    case 0x5c4b:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        if (r16[dx] >= memory16get(ss, bp + 16)) {
            pc = 0x5c59;
            break;
        }
        pc = 0x5b92;
        break;
    case 0x5c59:
        if (r16[dx] != memory16get(ss, bp + 16)) {
            pc = 0x5c63;
            break;
        }
        if (r16[ax] >= memory16get(ss, bp + 14)) {
            pc = 0x5c63;
            break;
        }
        pc = 0x5b92;
        break;
    case 0x5c63:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_5c67() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[di] = memory16get(ss, bp + 30);
    case 0x5c72:
        r16[ax] = r16[di];
        r16[di]--;
        if (r16[ax]) {
            pc = 0x5c7c;
            break;
        }
        pc = 0x5d49;
        break;
    case 0x5c7c:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 5] = r8[al];
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r16[bx] = memory16get(ss, bp + 18);
        es = memory16get(ss, bp + 18 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 4] = r8[al];
        memory16set(ss, bp + 18, memory16get(ss, bp + 18) + 1);
        r16[bx] = memory16get(ss, bp + 22);
        es = memory16get(ss, bp + 22 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 3] = r8[al];
        memory16set(ss, bp + 22, memory16get(ss, bp + 22) + 1);
        r16[bx] = memory16get(ss, bp + 26);
        es = memory16get(ss, bp + 26 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 2] = r8[al];
        memory16set(ss, bp + 26, memory16get(ss, bp + 26) + 1);
        r16[si] = 0;
        pc = 0x5d3e;
        break;
    case 0x5cb1:
        r16[cx] = 0x0007;
        r16[cx] -= r16[si];
        r8[al] = 0x01;
        r8[al] <<= r8[cl];
        memory[ss*16 + bp - 1] = r8[al];
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 5] & r8[al])) {
            pc = 0x5ccb;
            break;
        }
        memory[ss*16 + bp - 6] = 0x10;
        pc = 0x5ccf;
        break;
    case 0x5ccb:
        memory[ss*16 + bp - 6] = 0x00;
    case 0x5ccf:
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 4] & r8[al])) {
            pc = 0x5cdb;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x20;
    case 0x5cdb:
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 3] & r8[al])) {
            pc = 0x5ce7;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x40;
    case 0x5ce7:
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 2] & r8[al])) {
            pc = 0x5cf3;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x80;
    case 0x5cf3:
        r16[cx] = 0x0006;
        r16[cx] -= r16[si];
        r8[al] = 0x01;
        r8[al] <<= r8[cl];
        memory[ss*16 + bp - 1] = r8[al];
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 5] & r8[al])) {
            pc = 0x5d0b;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x01;
    case 0x5d0b:
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 4] & r8[al])) {
            pc = 0x5d17;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x02;
    case 0x5d17:
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 3] & r8[al])) {
            pc = 0x5d23;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x04;
    case 0x5d23:
        r8[al] = memory[ss*16 + bp - 1];
        if (!(memory[ss*16 + bp - 2] & r8[al])) {
            pc = 0x5d2f;
            break;
        }
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] | 0x08;
    case 0x5d2f:
        r8[al] = memory[ss*16 + bp - 6];
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
        r16[si] += 0x0002;
    case 0x5d3e:
        if (r16[si] >= 0x0008) {
            pc = 0x5d46;
            break;
        }
        pc = 0x5cb1;
        break;
    case 0x5d46:
        pc = 0x5c72;
        break;
    case 0x5d49:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_5d4f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
    case 0x5d57:
        r16[dx] = 0;
        r16[ax] = 0x0005;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 18));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x023f);
        r16[dx] |= r16[ax];
        if (!r16[dx]) {
            pc = 0x5d77;
            break;
        }
        flags.carry = (memory16get(ss, bp + 18) + 0x0001) >= 0x10000;
        memory16set(ss, bp + 18, memory16get(ss, bp + 18) + 0x0001);
        memory16set(ss, bp + 20, memory16get(ss, bp + 20) + flags.carry);
        pc = 0x5d57;
        break;
    case 0x5d77:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        memory16set(ss, bp - 2, 0x0000);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x5e43;
        break;
    case 0x5d8d:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += memory16get(ss, bp - 4);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 14] = r8[al];
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += memory16get(ss, bp - 4);
        r8[al] = memory[es*16 + r16[bx] + 1];
        memory[ss*16 + bp - 13] = r8[al];
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += memory16get(ss, bp - 4);
        r8[al] = memory[es*16 + r16[bx] + 2];
        memory[ss*16 + bp - 12] = r8[al];
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += memory16get(ss, bp - 4);
        r8[al] = memory[es*16 + r16[bx] + 3];
        memory[ss*16 + bp - 11] = r8[al];
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += memory16get(ss, bp - 4);
        r8[al] = memory[es*16 + r16[bx] + 4];
        memory[ss*16 + bp - 10] = r8[al];
        r16[di] = 0;
        pc = 0x5e2c;
        break;
    case 0x5dd1:
        r16[si] = 0x0080;
        r16[cx] = r16[di];
        r16[si] = sar16(r16[si], r8[cl]);
        r8[al] = memory[ss*16 + bp - 14];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x5de7;
            break;
        }
        memory[ss*16 + bp - 9] = 0x80;
        pc = 0x5deb;
        break;
    case 0x5de7:
        memory[ss*16 + bp - 9] = 0x00;
    case 0x5deb:
        r8[al] = memory[ss*16 + bp - 13];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x5df8;
            break;
        }
        memory[ss*16 + bp - 9] = memory[ss*16 + bp - 9] | 0x01;
    case 0x5df8:
        r8[al] = memory[ss*16 + bp - 12];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x5e05;
            break;
        }
        memory[ss*16 + bp - 9] = memory[ss*16 + bp - 9] | 0x02;
    case 0x5e05:
        r8[al] = memory[ss*16 + bp - 11];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x5e12;
            break;
        }
        memory[ss*16 + bp - 9] = memory[ss*16 + bp - 9] | 0x04;
    case 0x5e12:
        r8[al] = memory[ss*16 + bp - 10];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x5e1f;
            break;
        }
        memory[ss*16 + bp - 9] = memory[ss*16 + bp - 9] | 0x08;
    case 0x5e1f:
        r8[al] = memory[ss*16 + bp - 9];
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r16[di]++;
    case 0x5e2c:
        if (r16[di] < 0x0008) {
            pc = 0x5dd1;
            break;
        }
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        flags.carry = (r16[ax] + 0x0005) >= 0x10000;
        r16[ax] += 0x0005;
        r16[dx] += flags.carry;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
    case 0x5e43:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        if (r16[dx] >= memory16get(ss, bp + 20)) {
            pc = 0x5e51;
            break;
        }
        pc = 0x5d8d;
        break;
    case 0x5e51:
        if (r16[dx] != memory16get(ss, bp + 20)) {
            pc = 0x5e5b;
            break;
        }
        if (r16[ax] >= memory16get(ss, bp + 18)) {
            pc = 0x5e5b;
            break;
        }
        pc = 0x5d8d;
        break;
    case 0x5e5b:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_5e61() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 16);
    case 0x5e68:
        r16[ax] = r16[si];
        r16[si]--;
        if (!r16[ax]) {
            pc = 0x5e83;
            break;
        }
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        r8[al] = videoGet(es, r16[bx]);
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        videoSet(es, r16[bx], r8[al]);
        memory16set(ss, bp + 8, memory16get(ss, bp + 8) + 1);
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        pc = 0x5e68;
        break;
    case 0x5e83:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_5e86() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r8[al] = 0x00;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        yield* sub_3e59();
        sp += 0x000a;
        r16[bx] = memory16get(ds, 0x8e20);
        es = memory16get(ds, 0x8e20 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ds, 0x92c8);
        es = memory16get(ds, 0x92c8 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x5ec0;
            break;
        }
        pc = 0x5fbc;
        break;
    case 0x5ec0:
        r8[al] = 0x05;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x0f;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x03;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0xff;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x02;
        r16[dx] = 0x03c4;
        out8(r16[dx], r8[al]);
        r8[al] = 0x0f;
        r16[dx] = 0x03c5;
        out8(r16[dx], r8[al]);
        r8[al] = 0x05;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0168);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0168);
        if (memory16get(ss, bp + 10) != 0x0000) {
            pc = 0x5f71;
            break;
        }
        r16[si] = 0;
        pc = 0x5f69;
        break;
    case 0x5f28:
        r16[ax] = 0x0026;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_5e61();
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0026;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_5e61();
        sp += 0x000a;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0028);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0028);
        r16[si]++;
    case 0x5f69:
        if (r16[si] < 0x00bf) {
            pc = 0x5f28;
            break;
        }
        pc = 0x5fbc;
        break;
    case 0x5f71:
        r16[si] = 0;
        pc = 0x5fb6;
        break;
    case 0x5f75:
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] += 0x0026;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_5e61();
        sp += 0x000a;
        r16[ax] = 0x0026;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_5e61();
        sp += 0x000a;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0028);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0028);
        r16[si]++;
    case 0x5fb6:
        if (r16[si] < 0x00bf) {
            pc = 0x5f75;
            break;
        }
    case 0x5fbc:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x5fcd;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x5fcd;
            break;
        }
        pc = 0x60aa;
        break;
    case 0x5fcd:
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x2140);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x2140);
        r16[di] = 0x0001;
        if (memory16get(ss, bp + 10) != 0x0000) {
            pc = 0x6046;
            break;
        }
        r16[si] = 0;
        pc = 0x603e;
        break;
    case 0x5fe4:
        r16[ax] = 0x004c;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] += 0x0004;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        r16[ax] = 0x0004;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x004c;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        if (!r16[di]) {
            pc = 0x6030;
            break;
        }
        r16[di] = 0;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) - 0x1fb0);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x1fb0);
        pc = 0x603d;
        break;
    case 0x6030:
        r16[di] = 0x0001;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x2000);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x2000);
    case 0x603d:
        r16[si]++;
    case 0x603e:
        if (r16[si] < 0x00bf) {
            pc = 0x5fe4;
            break;
        }
        pc = 0x60aa;
        break;
    case 0x6046:
        r16[si] = 0;
        pc = 0x60a4;
        break;
    case 0x604a:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] += 0x004c;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        r16[ax] = 0x004c;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0004;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x1f24;
        yield* sub_1f244();
        assert(cs == 0x023f);
        sp += 0x000a;
        if (!r16[di]) {
            pc = 0x6096;
            break;
        }
        r16[di] = 0;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) - 0x1fb0);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x1fb0);
        pc = 0x60a3;
        break;
    case 0x6096:
        r16[di] = 0x0001;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x2000);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x2000);
    case 0x60a3:
        r16[si]++;
    case 0x60a4:
        if (r16[si] < 0x00bf) {
            pc = 0x604a;
            break;
        }
    case 0x60aa:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_60b0() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    r16[ax] = memory16get(ss, bp + 8);
    r16[ax] <<= 1;
    r16[bx] = memory16get(ds, 0x8c54);
    es = memory16get(ds, 0x8c54 + 2);
    r16[bx] += r16[ax];
    r16[si] = memory16get(es, r16[bx]);
    r16[bx] = memory16get(ds, 0x8dc8);
    es = memory16get(ds, 0x8dc8 + 2);
    r16[bx] += r16[si];
    memory16set(ss, bp - 2, es);
    memory16set(ss, bp - 4, r16[bx]);
    r16[dx] = memory16get(ss, bp - 2);
    r16[ax] = r16[bx];
    sp = bp;
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_60db() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x6119;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x60f7;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x6109;
            break;
        }
    case 0x60f7:
        if (memory[ss*16 + bp + 16] != 0x01) {
            pc = 0x6103;
            break;
        }
        memory[ss*16 + bp + 16] = 0x0f;
        pc = 0x6119;
        break;
    case 0x6103:
        memory[ss*16 + bp + 16] = memory[ss*16 + bp + 16] & 0x0f;
        pc = 0x6119;
        break;
    case 0x6109:
        if (memory[ss*16 + bp + 16] != 0x01) {
            pc = 0x6115;
            break;
        }
        memory[ss*16 + bp + 16] = 0x03;
        pc = 0x6119;
        break;
    case 0x6115:
        memory[ss*16 + bp + 16] = memory[ss*16 + bp + 16] & 0x03;
    case 0x6119:
        if (memory[ss*16 + bp + 14] != 0x00) {
            pc = 0x612b;
            break;
        }
        r16[si] = 0x0100;
        r16[di] = 0x0040;
        memory16set(ds, 0x92b8, 0x0000);
    case 0x612b:
        if (memory[ss*16 + bp + 14] != 0x01) {
            pc = 0x613d;
            break;
        }
        r16[si] = 0x00d8;
        r16[di] = 0x00b0;
        memory16set(ds, 0x92b8, 0x0000);
    case 0x613d:
        if (memory[ss*16 + bp + 14] != 0x02) {
            pc = 0x6149;
            break;
        }
        r16[si] = 0x00a4;
        r16[di] = 0x008b;
    case 0x6149:
        if (memory[ss*16 + bp + 14] != 0x03) {
            pc = 0x6155;
            break;
        }
        r16[si] = 0x005f;
        r16[di] = 0x003e;
    case 0x6155:
        if (memory[ss*16 + bp + 14] != 0x04) {
            pc = 0x6161;
            break;
        }
        r16[si] = 0x007e;
        r16[di] = 0x00a7;
    case 0x6161:
        if (memory[ss*16 + bp + 14] != 0x05) {
            pc = 0x616d;
            break;
        }
        r16[si] = 0x0069;
        r16[di] = 0x0045;
    case 0x616d:
        if (memory[ss*16 + bp + 14] != 0x06) {
            pc = 0x6179;
            break;
        }
        r16[si] = 0x00d2;
        r16[di] = 0x0085;
    case 0x6179:
        if (memory[ss*16 + bp + 18] == 0x01) {
            pc = 0x6185;
            break;
        }
        if (memory[ss*16 + bp + 18] != 0x03) {
            pc = 0x6193;
            break;
        }
    case 0x6185:
        r16[ax] = 0x0140;
        r16[ax] -= r16[si];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp + 10, r16[ax]);
    case 0x6193:
        if (memory[ss*16 + bp + 18] == 0x02) {
            pc = 0x619f;
            break;
        }
        if (memory[ss*16 + bp + 18] != 0x03) {
            pc = 0x61ad;
            break;
        }
    case 0x619f:
        r16[ax] = 0x00c8;
        r16[ax] -= r16[di];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp + 12, r16[ax]);
    case 0x61ad:
        if (memory16get(ds, 0x92b8) == 0x0000) {
            pc = 0x61b7;
            break;
        }
        pc = 0x6253;
        break;
    case 0x61b7:
        push(memory16get(ds, 0x8bee));
        push(memory16get(ds, 0x8bec));
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x060b);
        sp += 0x000e;
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x61f1;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x61e7;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x61ed;
            break;
        }
    case 0x61e7:
        memory[ss*16 + bp - 1] = 0x0c;
        pc = 0x61f1;
        break;
    case 0x61ed:
        memory[ss*16 + bp - 1] = 0x02;
    case 0x61f1:
        push(memory16get(ds, 0x8bee));
        push(memory16get(ds, 0x8bec));
        r8[al] = memory[ss*16 + bp - 1];
        r8[ah] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0xfffc;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0xfffc;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += 0x0002;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] += 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x060b);
        sp += 0x000e;
        push(memory16get(ds, 0x8bee));
        push(memory16get(ds, 0x8bec));
        r8[al] = memory[ss*16 + bp + 16];
        r8[ah] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0xfff8;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0xfff8;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += 0x0004;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] += 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x060b);
        sp += 0x000e;
        pc = 0x6278;
        break;
    case 0x6253:
        if (memory16get(ds, 0x92b8) >= 0x03e8) {
            pc = 0x6278;
            break;
        }
        push(memory16get(ds, 0x8bee));
        push(memory16get(ds, 0x8bec));
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x92b8));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x060b);
        sp += 0x000c;
    case 0x6278:
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] += 0x0008;
        r8[dl] = memory[ds*16 + 0x8de8];
        r8[dh] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[dx];
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += 0x0008;
        r8[dl] = memory[ds*16 + 0x8de8];
        r8[dh] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[dx];
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0xfff0;
        r8[dl] = memory[ds*16 + 0x8de8];
        r8[dh] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[dx];
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0xfff0;
        r8[dl] = memory[ds*16 + 0x8de8];
        r8[dh] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[dx];
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 6, r16[ax]);
        r8[al] = memory[ds*16 + 0x8de8];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 8, 0x0000);
        r8[al] = memory[ds*16 + 0x8de8];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 10, 0x0000);
        memory16set(ds, 0x92b8, 0x0000);
        r8[al] = memory[ds*16 + 0x8de8];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        memory[ds*16 + r16[bx] + 34742] = 0x00;
        memory[ds*16 + 0x8de8] += 1;
        r8[al] = memory[ds*16 + 0x8de8];
        r8[al] += 0xff;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6372() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    r16[ax] = 0;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x8bfa;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x8e20;
    push(r16[ax]);
    push(cs);
    cs = 0x023f;
    yield* sub_3e59();
    assert(cs == 0x060b);
    sp += 0x000a;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_6388() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    r16[ax] = 0;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x8bfa;
    push(r16[ax]);
    push(memory16get(ds, 0x8bee));
    push(memory16get(ds, 0x8bec));
    push(cs);
    cs = 0x023f;
    yield* sub_3e59();
    assert(cs == 0x060b);
    sp += 0x000a;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_63a1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[si] = 0;
        if (memory[ss*16 + bp + 14] != 0x00) {
            pc = 0x63b3;
            break;
        }
        r16[di] = 0x0020;
        pc = 0x63b6;
        break;
    case 0x63b3:
        r16[di] = 0xffc0;
    case 0x63b6:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x63da;
            break;
        }
        r8[al] = memory[es*16 + r16[bx]];
        cbw();
        r16[ax] -= r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[si] += r16[ax];
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
        pc = 0x63b6;
        break;
    case 0x63da:
        r16[ax] = r16[si];
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6410() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x644a;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x642c;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x643c;
            break;
        }
    case 0x642c:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[bx] = 0x0010;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 18] = r8[dl];
        pc = 0x644a;
        break;
    case 0x643c:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 18] = r8[dl];
    case 0x644a:
        push(memory16get(ss, bp + 24));
        push(memory16get(ss, bp + 22));
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3d09();
        assert(cs == 0x060b);
        sp += 0x0006;
        push(memory16get(ss, bp + 24));
        push(memory16get(ss, bp + 22));
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3d27();
        assert(cs == 0x060b);
        sp += 0x0006;
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ss*16 + bp + 20] != 0x00) {
            pc = 0x6484;
            break;
        }
        r16[di] = 0x0020;
        pc = 0x6487;
        break;
    case 0x6484:
        r16[di] = 0xffc0;
    case 0x6487:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x64b0;
            break;
        }
        push(memory16get(ss, bp + 24));
        push(memory16get(ss, bp + 22));
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        cbw();
        r16[ax] -= r16[di];
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4faa();
        assert(cs == 0x060b);
        sp += 0x000a;
        r16[si] += r16[ax];
        pc = 0x6487;
        break;
    case 0x64b0:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6604() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x6655;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x6621;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x663c;
            break;
        }
    case 0x6621:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[bx] = 0x0010;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 18] = r8[dl];
        r8[al] = memory[ss*16 + bp + 20];
        r8[ah] = 0x00;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 20] = r8[dl];
        pc = 0x6655;
        break;
    case 0x663c:
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 18] = r8[dl];
        r8[al] = memory[ss*16 + bp + 20];
        r8[ah] = 0x00;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp + 20] = r8[dl];
    case 0x6655:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        push(memory16get(ss, bp + 26));
        push(memory16get(ss, bp + 24));
        r8[al] = memory[ss*16 + bp + 18];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3d09();
        assert(cs == 0x060b);
        sp += 0x0006;
        push(memory16get(ss, bp + 26));
        push(memory16get(ss, bp + 24));
        r8[al] = memory[ss*16 + bp + 20];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3d18();
        assert(cs == 0x060b);
        sp += 0x0006;
        push(memory16get(ss, bp + 26));
        push(memory16get(ss, bp + 24));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3d27();
        assert(cs == 0x060b);
        sp += 0x0006;
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ss*16 + bp + 22] != 0x00) {
            pc = 0x66ab;
            break;
        }
        r16[di] = 0x0020;
        pc = 0x66ae;
        break;
    case 0x66ab:
        r16[di] = 0xffc0;
    case 0x66ae:
        r16[bx] = memory16get(ss, bp - 6);
        es = memory16get(ss, bp - 6 + 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x66d7;
            break;
        }
        push(memory16get(ss, bp + 26));
        push(memory16get(ss, bp + 24));
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        cbw();
        r16[ax] -= r16[di];
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4faa();
        assert(cs == 0x060b);
        sp += 0x000a;
        r16[si] += r16[ax];
        pc = 0x66ae;
        break;
    case 0x66d7:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_66dd() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0068;
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 34742] != 0x20) {
            pc = 0x6701;
            break;
        }
    case 0x66f3:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (memory[es*16 + r16[bx]] != 0x20) {
            pc = 0x6701;
            break;
        }
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        pc = 0x66f3;
        break;
    case 0x6701:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (memory[es*16 + r16[bx]] != 0x00) {
            pc = 0x670d;
            break;
        }
        pc = 0x68dc;
        break;
    case 0x670d:
        memory[ss*16 + bp - 1] = 0x00;
    case 0x6711:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (memory[es*16 + r16[bx]] == 0x20) {
            pc = 0x6740;
            break;
        }
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x6740;
            break;
        }
        if (memory[es*16 + r16[bx]] == 0x0d) {
            pc = 0x6740;
            break;
        }
        r8[al] = memory[es*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 1];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x68;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        memory[ss*16 + bp - 1] += 1;
        pc = 0x6711;
        break;
    case 0x6740:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (memory[es*16 + r16[bx]] != 0x20) {
            pc = 0x6761;
            break;
        }
        r8[al] = memory[es*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp - 1];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        r16[dx] = bp - 0x68;
        r16[bx] += r16[dx];
        memory[ss*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        memory[ss*16 + bp - 1] += 1;
    case 0x6761:
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0x6781;
            break;
        }
        r8[al] = memory[ss*16 + bp - 1];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x69;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r8[dl] = memory[ss*16 + bp + 10];
        r8[dh] = 0x00;
        r16[bx] = r16[dx];
        memory[ds*16 + r16[bx] + 34742] = r8[al];
    case 0x6781:
        r8[al] = memory[ss*16 + bp - 1];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[ax] = bp - 0x68;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] = 0x00;
        if (memory[ss*16 + bp - 104] != 0x00) {
            pc = 0x679a;
            break;
        }
        pc = 0x6893;
        break;
    case 0x679a:
        r16[ax] = 0;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x68;
        push(r16[ax]);
        push(cs);
        yield* sub_63a1();
        sp += 0x0006;
        r16[si] = r16[ax];
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[ax] += r16[si];
        r8[dl] = memory[ss*16 + bp + 10];
        r8[dh] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[dx];
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        if (r16s[ax] <= memory16gets(es, r16[bx] + 4)) {
            pc = 0x6806;
            break;
        }
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 8, 0x0000);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) + 0x0008);
    case 0x6806:
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        r16[bx] += r16[ax];
        r16[di] = memory16get(es, r16[bx]);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[di] += memory16get(es, r16[bx] + 8);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r8[dl] = memory[ss*16 + bp + 10];
        r8[dh] = 0x00;
        push(r16[ax]);
        r16[ax] = r16[dx];
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] += memory16get(es, r16[bx] + 10);
        memory16set(ss, bp - 4, r16[ax]);
        push(memory16get(ds, 0x8bee));
        push(memory16get(ds, 0x8bec));
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x8db0));
        push(ss);
        r16[ax] = bp - 0x68;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0008;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_6410();
        sp += 0x0010;
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) + r16[si]);
    case 0x6893:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (memory[es*16 + r16[bx]] == 0x0d) {
            pc = 0x689f;
            break;
        }
        pc = 0x6701;
        break;
    case 0x689f:
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        memory[ds*16 + r16[bx] + 34742] = 0x00;
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 8, 0x0000);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) + 0x0008);
        pc = 0x6701;
        break;
    case 0x68dc:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_690a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 6, r16[ax]);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 4, r16[ax]);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[si] = memory16get(es, r16[bx] + 4);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        r16[dx] = 0x000c;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8dd2);
        r16[bx] += r16[ax];
        r16[di] = memory16get(es, r16[bx] + 6);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_63a1();
        sp += 0x0006;
        memory16set(ss, bp - 2, r16[ax]);
        if (r16s[ax] >= signed16(r16[si])) {
            pc = 0x69c2;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] -= memory16get(ss, bp - 2);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[si] = r16[ax];
        r16[ax] = r16[di];
        r16[ax] += 0xfff8;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[di] = r16[ax];
        push(memory16get(ds, 0x8bee));
        push(memory16get(ds, 0x8bec));
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x8db0));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += r16[di];
        r16[ax] += 0x0008;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 6);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(cs);
        yield* sub_6410();
        sp += 0x0010;
        pc = 0x69e7;
        break;
    case 0x69c2:
        push(ds);
        r16[ax] = 0x0086;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_66dd();
        sp += 0x0006;
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        r8[al] = memory[ss*16 + bp + 10];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_66dd();
        sp += 0x0006;
    case 0x69e7:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_69ed() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(memory16get(ss, bp + 8));
    push(cs);
    yield* sub_60b0();
    sp++;
    sp++;
    memory16set(ss, bp - 2, r16[dx]);
    memory16set(ss, bp - 4, r16[ax]);
    push(r16[dx]);
    push(r16[ax]);
    r8[al] = memory[ss*16 + bp + 6];
    r8[ah] = 0x00;
    push(r16[ax]);
    push(cs);
    yield* sub_690a();
    sp += 0x0006;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_6a15() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x000a;
        memory16set(ss, bp - 8, 0x3b9a);
        memory16set(ss, bp - 10, 0xca00);
        memory[ss*16 + bp - 1] = 0x00;
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] |= memory16get(ss, bp + 12);
        if (r16[ax]) {
            pc = 0x6a3b;
            break;
        }
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory[es*16 + r16[bx]] = 0x30;
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) + 1);
    case 0x6a3b:
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] |= memory16get(ss, bp - 8);
        if (r16[ax]) {
            pc = 0x6a46;
            break;
        }
        pc = 0x6ac6;
        break;
    case 0x6a46:
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x060b);
        memory16set(ss, bp - 4, r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] |= r16[dx];
        if (!r16[ax]) {
            pc = 0x6a76;
            break;
        }
        r8[al] = memory[ss*16 + bp - 6];
        r8[al] += 0x30;
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) + 1);
        memory[ss*16 + bp - 1] = 0x01;
        pc = 0x6a86;
        break;
    case 0x6a76:
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0x6a86;
            break;
        }
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory[es*16 + r16[bx]] = 0x30;
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) + 1);
    case 0x6a86:
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 10);
        r16[cx] = memory16get(ss, bp - 4);
        r16[bx] = memory16get(ss, bp - 6);
        push(r16[dx]);
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x060b);
        r16[bx] = pop();
        r16[cx] = pop();
        flags.carry = r16[bx] < r16[ax];
        r16[bx] -= r16[ax];
        r16[cx] -= r16[dx] + flags.carry;
        memory16set(ss, bp + 12, r16[cx]);
        memory16set(ss, bp + 10, r16[bx]);
        r16[dx] = 0;
        r16[ax] = 0x000a;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x060b);
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        pc = 0x6a3b;
        break;
    case 0x6ac6:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory[es*16 + r16[bx]] = 0x00;
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6ae8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
    case 0x6aeb:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x6af9;
            break;
        }
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) + 1);
        pc = 0x6aeb;
        break;
    case 0x6af9:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x6b13;
            break;
        }
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) + 1);
        pc = 0x6af9;
        break;
    case 0x6b13:
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory[es*16 + r16[bx]] = 0x00;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6c11() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[di] = 0;
        memory16set(ss, bp - 2, r16[di]);
    case 0x6c1d:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        if (memory[es*16 + r16[bx] + r16[di]] == 0x2e) {
            pc = 0x6c29;
            break;
        }
        r16[di]++;
        pc = 0x6c1d;
        break;
    case 0x6c29:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += memory16get(ss, bp - 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x6c3a;
            break;
        }
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 1);
        pc = 0x6c29;
        break;
    case 0x6c3a:
        if (r16[di] != memory16get(ss, bp - 2)) {
            pc = 0x6c51;
            break;
        }
        r16[si] = 0;
        pc = 0x6c56;
        break;
    case 0x6c43:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (r8[al] == memory[es*16 + r16[bx] + r16[si]]) {
            pc = 0x6c55;
            break;
        }
    case 0x6c51:
        r16[ax] = 0;
        pc = 0x6c5d;
        break;
    case 0x6c55:
        r16[si]++;
    case 0x6c56:
        if (r16[si] < r16[di]) {
            pc = 0x6c43;
            break;
        }
        r16[ax] = 0x0001;
    case 0x6c5d:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6c63() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[si] = 0;
    case 0x6c6d:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 138);
        es = memory16get(ds, r16[tx] + 138 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        push(memory16get(ss, bp - 2));
        push(r16[bx]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6c11();
        sp += 0x0008;
        if (!r16[ax]) {
            pc = 0x6cb2;
            break;
        }
        r16[ax] = r16[si];
        r16[cx] = 0x0004;
        r16[ax] <<= r8[cl];
        r16[si] = r16[ax];
        r16[di] = 0;
        pc = 0x6cab;
        break;
    case 0x6c9f:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 222];
        memory[ds*16 + r16[di] + 36716] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x6cab:
        if (r16[di] < 0x0010) {
            pc = 0x6c9f;
            break;
        }
        pc = 0x6cb5;
        break;
    case 0x6cb2:
        r16[si]++;
        pc = 0x6c6d;
        break;
    case 0x6cb5:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6cbb() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[di] = 0;
    case 0x6cc5:
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 558);
        es = memory16get(ds, r16[tx] + 558 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        push(memory16get(ss, bp - 2));
        push(r16[bx]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6c11();
        sp += 0x0008;
        if (!r16[ax]) {
            pc = 0x6d19;
            break;
        }
        r16[ax] = r16[di];
        r16[dx] = 0x0011;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r8[al] = memory[ds*16 + r16[di] + 606];
        memory[ss*16 + bp - 5] = r8[al];
        r16[si] = 0x0001;
        pc = 0x6d0f;
        break;
    case 0x6cff:
        r16[bx] = r16[di];
        r16[bx] += r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 606];
        r16[bx] = r16[si];
        r16[bx]--;
        memory[ds*16 + r16[bx] + 36716] = r8[al];
        r16[si]++;
    case 0x6d0f:
        if (r16[si] < 0x0011) {
            pc = 0x6cff;
            break;
        }
        r8[al] = memory[ss*16 + bp - 5];
        pc = 0x6d1c;
        break;
    case 0x6d19:
        r16[di]++;
        pc = 0x6cc5;
        break;
    case 0x6d1c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6d22() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[di] = 0;
    case 0x6d2c:
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 558);
        es = memory16get(ds, r16[tx] + 558 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        push(memory16get(ss, bp - 2));
        push(r16[bx]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6c11();
        sp += 0x0008;
        if (!r16[ax]) {
            pc = 0x6d75;
            break;
        }
        r16[ax] = r16[di];
        r16[cx] = 0x0004;
        r16[ax] <<= r8[cl];
        r16[di] = r16[ax];
        r16[si] = 0;
        pc = 0x6d6e;
        break;
    case 0x6d5e:
        r16[bx] = r16[di];
        r16[bx] += r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 810];
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        memory[es*16 + r16[bx] + r16[si]] = r8[al];
        r16[si]++;
    case 0x6d6e:
        if (r16[si] < 0x0010) {
            pc = 0x6d5e;
            break;
        }
        pc = 0x6d78;
        break;
    case 0x6d75:
        r16[di]++;
        pc = 0x6d2c;
        break;
    case 0x6d78:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6d7e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ds, 0x87d6, r16[ax]);
        if (memory16get(ds, 0x87d8) == 0x0000) {
            pc = 0x6dc0;
            break;
        }
        r16[di] = 0;
        r16[si] = memory16get(ds, 0x87dc);
        r16[si] += 0xff00;
        pc = 0x6dac;
        break;
    case 0x6d9c:
        r16[bx] = memory16get(ds, 0x87de);
        es = memory16get(ds, 0x87de + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r16[dx] = r16[di];
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[di]++;
        r16[si]++;
    case 0x6dac:
        if (r16[si] < memory16get(ds, 0x87dc)) {
            pc = 0x6d9c;
            break;
        }
        memory16set(ds, 0x87dc, 0x0100);
        memory16set(ds, 0x87d8, 0x0100);
        pc = 0x6dec;
        break;
    case 0x6dc0:
        r16[ax] = 0;
        memory16set(ds, 0x87d8, r16[ax]);
        memory16set(ds, 0x87dc, r16[ax]);
        push(memory16get(ds, 0x87de));
        r16[ax] = memory16get(ds, 0x87e0);
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x87d4);
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x87d2);
        r16[ax] &= 0xffff;
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x129d;
        yield* sub_12dfc();
        assert(cs == 0x06c1);
        sp = bp;
        push(cs);
        cs = 0x129d;
        yield* sub_12e24();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x6dec:
        memory16set(ds, 0x87d0, 0x0000);
        push(memory16get(ss, bp + 12));
        push(memory16get(ds, 0x87dc));
        push(memory16get(ds, 0x87d0));
        push(cs);
        cs = 0x129d;
        yield* sub_12f08();
        assert(cs == 0x06c1);
        sp = bp;
        push(cs);
        cs = 0x129d;
        yield* sub_12df2();
        assert(cs == 0x06c1);
        sp = bp;
        memory16set(ds, 0x87dc, r16[ax]);
        memory16set(ds, 0x87d0, r16[ax]);
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6e15() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[ax] = memory16get(ds, 0x87d8);
        if (r16[ax] != memory16get(ds, 0x87d0)) {
            pc = 0x6e56;
            break;
        }
        if (memory16get(ds, 0x919a) != 0x0000) {
            pc = 0x6e49;
            break;
        }
        push(memory16get(ds, 0x8b8c));
        push(memory16get(ds, 0x87e0));
        push(memory16get(ds, 0x87de));
        push(memory16get(ss, bp + 6));
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp = bp;
        memory16set(ds, 0x87d0, r16[ax]);
        memory16set(ds, 0x87d8, 0x0000);
        pc = 0x6e56;
        break;
    case 0x6e49:
        push(memory16get(ds, 0x8b8c));
        push(memory16get(ss, bp + 6));
        push(cs);
        yield* sub_6d7e();
        sp = bp;
    case 0x6e56:
        r16[ax] = memory16get(ds, 0x87d8);
        memory16set(ds, 0x87d8, memory16get(ds, 0x87d8) + 1);
        r16[bx] = memory16get(ds, 0x87de);
        es = memory16get(ds, 0x87de + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[ah] = 0x00;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6e6a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[di] = memory16get(ss, bp + 16);
        memory16set(ss, bp - 6, 0x0000);
        if (memory16get(ds, 0x87e2) != 0x0000) {
            pc = 0x6e9f;
            break;
        }
    case 0x6e81:
        r16[ax] = r16[di];
        r16[di]--;
        if (r16[ax]) {
            pc = 0x6e8b;
            break;
        }
        pc = 0x6f3c;
        break;
    case 0x6e8b:
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        pc = 0x6e81;
        break;
    case 0x6e9f:
        r16[ax] = memory16get(ss, bp - 6);
        if (r16[ax] != r16[di]) {
            pc = 0x6ea9;
            break;
        }
        pc = 0x6f3c;
        break;
    case 0x6ea9:
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 3] = r8[al];
        r8[al] = memory[ss*16 + bp - 3];
        cbw();
        if (r16[ax] == 0xff80) {
            pc = 0x6e9f;
            break;
        }
        if (memorys[ss*16 + bp - 3] < signed8(0x00)) {
            pc = 0x6ed5;
            break;
        }
        if (memorys[ss*16 + bp - 3] > signed8(0x7f)) {
            pc = 0x6ed5;
            break;
        }
        memory[ss*16 + bp - 2] = 0x00;
        r8[al] = memory[ss*16 + bp - 3];
        cbw();
        r16[si] = r16[ax];
        r16[si]++;
    case 0x6ed5:
        if (memorys[ss*16 + bp - 3] >= signed8(0x00)) {
            pc = 0x6efd;
            break;
        }
        r8[al] = memory[ss*16 + bp - 3];
        cbw();
        if (r16s[ax] < signed16(0xff81)) {
            pc = 0x6efd;
            break;
        }
        memory[ss*16 + bp - 2] = 0x01;
        r8[al] = memory[ss*16 + bp - 3];
        cbw();
        r16[si] = r16[ax];
        r16[si] = (-r16[si]) & 0xffff; // gabo!!!!!!!!!
        r16[si]++;
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 1] = r8[al];
    case 0x6efd:
        if (memory[ss*16 + bp - 2] != 0x00) {
            pc = 0x6f21;
            break;
        }
    case 0x6f03:
        r16[ax] = r16[si];
        r16[si] = (r16[si]-1) & 0xffff; // gabo!!!!!
        if (!r16[ax]) {
            pc = 0x6e9f;
            break;
        }
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (es >= 0xa000)
            videoSet(es, r16[bx], r8[al]);
        else
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
        pc = 0x6f03;
        break;
    case 0x6f21:
        r16[ax] = r16[si];
        r16[si] = (r16[si]-1)&0xffff;
        if (r16[ax]) {
            pc = 0x6f2b;
            break;
        }
        pc = 0x6e9f;
        break;
    case 0x6f2b:
        r8[al] = memory[ss*16 + bp - 1];
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (es >= 0xa000)
            videoSet(es, r16[bx], r8[al]);
        else
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + 1);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
        pc = 0x6f21;
        break;
    case 0x6f3c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6f42() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        push(cs);
        cs = 0x0ba1;
        yield* sub_ba46();
        assert(cs == 0x06c1);
        sp = bp;
        if (memory16get(ss, bp + 8) != 0x0000) {
            pc = 0x6f65;
            break;
        }
        r16[ax] = 0x8001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x04cb;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp = bp;
        pc = 0x6f75;
        break;
    case 0x6f65:
        r16[ax] = 0x8001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x04d8;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x6f75:
        push(cs);
        cs = 0x0ba1;
        yield* sub_ba4d();
        assert(cs == 0x06c1);
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_6fe0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        memory[ss*16 + bp - 4] = 0x00;
        memory[ss*16 + bp - 3] = 0x00;
        memory[ss*16 + bp - 1] = 0x00;
        if (memory[ds*16 + 0x91a2] != 0x46) {
            pc = 0x6ffd;
            break;
        }
        r16[di] = 0;
    case 0x6ffd:
        if (memory[ds*16 + 0x91a2] != 0x49) {
            pc = 0x7007;
            break;
        }
        r16[di] = 0x0003;
    case 0x7007:
        if (memory[ds*16 + 0x91a2] != 0x47) {
            pc = 0x7011;
            break;
        }
        r16[di] = 0x0006;
    case 0x7011:
        if (memory[ds*16 + 0x91a2] != 0x53) {
            pc = 0x701b;
            break;
        }
        r16[di] = 0x0009;
    case 0x701b:
        if (memory[ds*16 + 0x91a2] != 0x45) {
            pc = 0x7025;
            break;
        }
        r16[di] = 0x000c;
    case 0x7025:
        if (memory[ss*16 + bp + 10] == 0x00) {
            pc = 0x702e;
            break;
        }
        pc = 0x70fb;
        break;
    case 0x702e:
        r8[al] = 0x00;
        memory[ss*16 + bp - 5] = r8[al];
        memory[ss*16 + bp - 6] = r8[al];
        memory[ss*16 + bp - 7] = r8[al];
        memory[ss*16 + bp - 8] = r8[al];
        if (memory16get(ds, 0x87da) & 0x0001) {
            pc = 0x708e;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x04e5;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x7069;
            break;
        }
        memory[ss*16 + bp - 8] = 0x01;
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x7069:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x04f3;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x708e;
            break;
        }
        memory[ss*16 + bp - 7] = 0x01;
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x708e:
        if (memory[ds*16 + 0x92b4] <= 0x01) {
            pc = 0x70e7;
            break;
        }
        if (memory16get(ds, 0x87da) & 0x0002) {
            pc = 0x70e7;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0501;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x70c2;
            break;
        }
        memory[ss*16 + bp - 8] = 0x01;
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x70c2:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x050f;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x70e7;
            break;
        }
        memory[ss*16 + bp - 7] = 0x01;
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x70e7:
        if (memory[ss*16 + bp - 8] == 0x00) {
            pc = 0x70f4;
            break;
        }
        memory16set(ss, bp - 12, 0x0002);
        pc = 0x7100;
        break;
    case 0x70f4:
        memory16set(ss, bp - 12, 0x0001);
        pc = 0x7100;
        break;
    case 0x70fb:
        memory16set(ss, bp - 12, 0x0000);
    case 0x7100:
        r16[di] += memory16get(ss, bp - 12);
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0x7113;
            break;
        }
        memory[ss*16 + bp - 4] = 0x01;
        push(cs);
        cs = 0x0a34;
        yield* sub_a70c();
        assert(cs == 0x06c1);
    case 0x7113:
        r8[al] = memory[ds*16 + 0x8db0];
        memory[ss*16 + bp - 2] = r8[al];
        memory16set(ds, 0x8db0, 0x0000);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x06c1);
        sp += 0x000a;
        memory16set(ds, 0x8bee, ds);
        memory16set(ds, 0x8bec, 0x8bfa);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x714c;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x7153;
            break;
        }
    case 0x714c:
        memory16set(ss, bp - 10, 0x000f);
        pc = 0x7158;
        break;
    case 0x7153:
        memory16set(ss, bp - 10, 0x0003);
    case 0x7158:
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_60db();
        assert(cs == 0x06c1);
        sp += 0x000a;
        r8[ah] = 0x00;
        memory16set(ss, bp - 14, r16[ax]);
        push(r16[di]);
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_69ed();
        assert(cs == 0x06c1);
        sp += 0x0004;
        push(cs);
        cs = 0x060b;
        yield* sub_6388();
        assert(cs == 0x06c1);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9d5();
        assert(cs == 0x06c1);
        push(cs);
        cs = 0x060b;
        yield* sub_6372();
        assert(cs == 0x06c1);
        memory[ds*16 + 0x8de8] -= 1;
        memory16set(ds, 0x8bee, ds);
        memory16set(ds, 0x8bec, 0x8b70);
        r8[al] = memory[ss*16 + bp - 2];
        r8[ah] = 0x00;
        memory16set(ds, 0x8db0, r16[ax]);
        if (memory[ss*16 + bp - 4] == 0x00) {
            pc = 0x71ab;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_a6c3();
        assert(cs == 0x06c1);
    case 0x71ab:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_71b1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0028;
        memory[ss*16 + bp - 40] = 0x00;
        if (memory[ds*16 + 0x919c] != 0x00) {
            pc = 0x71d5;
            break;
        }
        push(ds);
        r16[ax] = 0x051d;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x06c1);
        sp += 0x0008;
    case 0x71d5:
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (memory[ds*16 + 0x919c] != 0x00) {
            pc = 0x7207;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_6f42();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x7207;
            break;
        }
        memory16set(ds, 0x87da, memory16get(ds, 0x87da) | 0x0001);
        r16[ax] = 0xffff;
        pc = 0x721c;
        break;
    case 0x7207:
        r16[ax] = 0x8001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
    case 0x721c:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_7221() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0028;
        memory[ss*16 + bp - 40] = 0x00;
        if (memory[ds*16 + 0x919c] != 0x00) {
            pc = 0x7245;
            break;
        }
        push(ds);
        r16[ax] = 0x0521;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x06c1);
        sp += 0x0008;
    case 0x7245:
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (memory[ds*16 + 0x919c] != 0x00) {
            pc = 0x7278;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_6f42();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x7278;
            break;
        }
        memory16set(ds, 0x87da, memory16get(ds, 0x87da) | 0x0002);
        r16[ax] = 0xffff;
        pc = 0x728d;
        break;
    case 0x7278:
        r16[ax] = 0x8001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
    case 0x728d:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_7292() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0036;
        r16[di] = memory16get(ss, bp + 10);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x36;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r16[ax] = memory16get(ss, bp - 54);
        r16[dx] = 0;
        memory16set(ss, bp - 46, r16[dx]);
        memory16set(ss, bp - 48, r16[ax]);
    case 0x72ba:
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x34;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x32;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r16[dx] = memory16get(ss, bp - 50);
        r16[ax] = memory16get(ss, bp - 52);
        memory16set(ss, bp - 42, r16[dx]);
        memory16set(ss, bp - 44, r16[ax]);
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x72f2;
            break;
        }
        r16[ax] = 0;
        pc = 0x7369;
        break;
    case 0x72f2:
        r16[si] = 0;
    case 0x72f4:
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = bp - 0x28;
        r16[ax] += r16[si];
        r16[dx] = ss;
        push(r16[dx]);
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r16[si]++;
        r16[bx] = r16[si];
        r16[bx]--;
        r16[ax] = bp - 0x28;
        r16[bx] += r16[ax];
        if (memory[ss*16 + r16[bx]] != 0x00) {
            pc = 0x72f4;
            break;
        }
        push(ss);
        r16[ax] = bp - 0x28;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        cs = 0x1f66;
        yield* sub_1f663();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0x7354;
            break;
        }
        r16[dx] = memory16get(ss, bp - 42);
        r16[ax] = memory16get(ss, bp - 44);
        memory16set(ds, 0x87ce, r16[dx]);
        memory16set(ds, 0x87cc, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 46));
        push(memory16get(ss, bp - 48));
        push(r16[di]);
        push(cs);
        cs = 0x1f20;
        yield* sub_1f206();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r16[ax] = 0x0001;
        pc = 0x7369;
        break;
    case 0x7354:
        r16[dx] = memory16get(ss, bp - 46);
        r16[ax] = memory16get(ss, bp - 48);
        flags.carry = (r16[ax] + memory16get(ss, bp - 44)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 44);
        r16[dx] += memory16get(ss, bp - 42) + flags.carry;
        memory16set(ss, bp - 46, r16[dx]);
        memory16set(ss, bp - 48, r16[ax]);
        pc = 0x72ba;
        break;
    case 0x7369:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_736f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        if (memory16get(ss, bp + 8) == 0x0000) {
            pc = 0x73d1;
            break;
        }
        push(ds);
        r16[ax] = 0x0525;
        push(r16[ax]);
        push(cs);
        yield* sub_71b1();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x73a8;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (!r16[ax]) {
            pc = 0x73a0;
            break;
        }
        pc = 0x7421;
        break;
    case 0x73a0:
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x73a8:
        push(ds);
        r16[ax] = 0x0530;
        push(r16[ax]);
        push(cs);
        yield* sub_71b1();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] >= 0) {
            pc = 0x73be;
            break;
        }
        pc = 0x742d;
        break;
    case 0x73be:
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (r16[ax]) {
            pc = 0x7421;
            break;
        }
        pc = 0x7425;
        break;
    case 0x73d1:
        push(ds);
        r16[ax] = 0x053b;
        push(r16[ax]);
        push(cs);
        yield* sub_71b1();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x73fd;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (r16[ax]) {
            pc = 0x7421;
            break;
        }
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x73fd:
        push(ds);
        r16[ax] = 0x0546;
        push(r16[ax]);
        push(cs);
        yield* sub_71b1();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x742d;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (!r16[ax]) {
            pc = 0x7425;
            break;
        }
    case 0x7421:
        r16[ax] = r16[si];
        pc = 0x7430;
        break;
    case 0x7425:
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x742d:
        r16[ax] = 0xffff;
    case 0x7430:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_7433() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        if (memory16get(ss, bp + 8) == 0x0000) {
            pc = 0x7495;
            break;
        }
        push(ds);
        r16[ax] = 0x0551;
        push(r16[ax]);
        push(cs);
        yield* sub_7221();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x746c;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (!r16[ax]) {
            pc = 0x7464;
            break;
        }
        pc = 0x74e5;
        break;
    case 0x7464:
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x746c:
        push(ds);
        r16[ax] = 0x055c;
        push(r16[ax]);
        push(cs);
        yield* sub_7221();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] >= 0) {
            pc = 0x7482;
            break;
        }
        pc = 0x74f1;
        break;
    case 0x7482:
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (r16[ax]) {
            pc = 0x74e5;
            break;
        }
        pc = 0x74e9;
        break;
    case 0x7495:
        push(ds);
        r16[ax] = 0x0567;
        push(r16[ax]);
        push(cs);
        yield* sub_7221();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x74c1;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (r16[ax]) {
            pc = 0x74e5;
            break;
        }
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x74c1:
        push(ds);
        r16[ax] = 0x0572;
        push(r16[ax]);
        push(cs);
        yield* sub_7221();
        sp = bp;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x74f1;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7292();
        sp = bp;
        if (!r16[ax]) {
            pc = 0x74e9;
            break;
        }
    case 0x74e5:
        r16[ax] = r16[si];
        pc = 0x74f4;
        break;
    case 0x74e9:
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x74f1:
        r16[ax] = 0xffff;
    case 0x74f4:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_74f7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(memory16get(ss, bp + 6));
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp = bp;
        r16[ax] = memory16get(ds, 0x87de);
        r16[ax] |= memory16get(ds, 0x87e0);
        if (!r16[ax]) {
            pc = 0x751c;
            break;
        }
        push(memory16get(ds, 0x87e0));
        push(memory16get(ds, 0x87de));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp = bp;
    case 0x751c:
        memory16set(ds, 0x87e0, 0x0000);
        memory16set(ds, 0x87de, 0x0000);
        memory16set(ds, 0x919a, 0x0000);
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_7530() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x002c;
        r16[di] = 0;
        memory[ss*16 + bp - 44] = 0x00;
        if (memory[ss*16 + bp + 14] == 0x00) {
            pc = 0x756a;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x7567;
            break;
        }
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x7567;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x7567;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x7567;
            break;
        }
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x756a;
            break;
        }
    case 0x7567:
        r16[di] = 0x0001;
    case 0x756a:
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r16[si] = 0xffff;
        memory16set(ds, 0x87ca, 0x0000);
        memory16set(ds, 0x87c8, 0x0000);
        r16[bx] = 0;
        es = r16[bx];
        memory16set(ds, 0x87e0, es);
        memory16set(ds, 0x87de, r16[bx]);
    case 0x7598:
        if (signed16(r16[si]) < 0) {
            pc = 0x759f;
            break;
        }
        pc = 0x7652;
        break;
    case 0x759f:
        memory16set(ds, 0x87da, 0x0000);
        if (memory16get(ds, 0x03fe) != 0x0001) {
            pc = 0x75e1;
            break;
        }
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_736f();
        sp += 0x0006;
        r16[si] = r16[ax];
        if (signed16(r16[si]) >= 0) {
            pc = 0x760d;
            break;
        }
        if (memory[ds*16 + 0x92b4] <= 0x01) {
            pc = 0x760d;
            break;
        }
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_7433();
        sp += 0x0006;
        r16[si] = r16[ax];
        if (signed16(r16[si]) < 0) {
            pc = 0x760d;
            break;
        }
        memory16set(ds, 0x03fe, 0x0002);
        pc = 0x760d;
        break;
    case 0x75e1:
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_7433();
        sp += 0x0006;
        r16[si] = r16[ax];
        if (signed16(r16[si]) >= 0) {
            pc = 0x760d;
            break;
        }
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_736f();
        sp += 0x0006;
        r16[si] = r16[ax];
        if (signed16(r16[si]) < 0) {
            pc = 0x760d;
            break;
        }
        memory16set(ds, 0x03fe, 0x0001);
    case 0x760d:
        if (signed16(r16[si]) < 0) {
            pc = 0x7614;
            break;
        }
        pc = 0x7598;
        break;
    case 0x7614:
        if (memory[ds*16 + 0x92b4] != 0x01) {
            pc = 0x7623;
            break;
        }
        if (memory16get(ds, 0x87da) & 0x0001) {
            pc = 0x763a;
            break;
        }
    case 0x7623:
        if (memory[ds*16 + 0x92b4] <= 0x01) {
            pc = 0x7646;
            break;
        }
        if (!(memory16get(ds, 0x87da) & 0x0001)) {
            pc = 0x7646;
            break;
        }
        if (!(memory16get(ds, 0x87da) & 0x0002)) {
            pc = 0x7646;
            break;
        }
    case 0x763a:
        r8[al] = 0x01;
        push(r16[ax]);
        push(cs);
        yield* sub_6fe0();
        sp++;
        sp++;
        pc = 0x7598;
        break;
    case 0x7646:
        r8[al] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_6fe0();
        sp++;
        sp++;
        pc = 0x7598;
        break;
    case 0x7652:
        r16[ax] = 0;
        memory16set(ds, 0x87e2, r16[ax]);
        memory16set(ds, 0x87d0, r16[ax]);
        memory16set(ds, 0x87d8, r16[ax]);
        r16[ax] = memory16get(ds, 0x8b8c);
        r16[ax] += 0x012c;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ds, 0x87e0, r16[dx]);
        memory16set(ds, 0x87de, r16[ax]);
        if (memory16get(ds, 0x919a) != 0x0000) {
            pc = 0x767c;
            break;
        }
        pc = 0x7794;
        break;
    case 0x767c:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87c1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r8[al] = memory[ds*16 + 0x87c1];
        cbw();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] &= 0x00ff;
        r16[dx] &= 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
        r16[cx] = 0x0008;
        push(cs);
        cs = 0x01ed;
        yield* sub_20cf();
        assert(cs == 0x06c1);
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87c1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r8[al] = memory[ds*16 + 0x87c1];
        cbw();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] &= 0x00ff;
        r16[dx] &= 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[dx] = memory16get(ds, 0x87d4);
        r16[ax] = memory16get(ds, 0x87d2);
        flags.carry = (r16[ax] + memory16get(ss, bp - 4)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 4);
        r16[dx] += memory16get(ss, bp - 2) + flags.carry;
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
        r16[cx] = 0x0008;
        push(cs);
        cs = 0x01ed;
        yield* sub_20cf();
        assert(cs == 0x06c1);
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87c1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r8[al] = memory[ds*16 + 0x87c1];
        cbw();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] &= 0x00ff;
        r16[dx] &= 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[dx] = memory16get(ds, 0x87d4);
        r16[ax] = memory16get(ds, 0x87d2);
        flags.carry = (r16[ax] + memory16get(ss, bp - 4)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 4);
        r16[dx] += memory16get(ss, bp - 2) + flags.carry;
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
        r16[cx] = 0x0008;
        push(cs);
        cs = 0x01ed;
        yield* sub_20cf();
        assert(cs == 0x06c1);
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87c1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        r8[al] = memory[ds*16 + 0x87c1];
        cbw();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] &= 0x00ff;
        r16[dx] &= 0x0000;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[dx] = memory16get(ds, 0x87d4);
        r16[ax] = memory16get(ds, 0x87d2);
        flags.carry = (r16[ax] + memory16get(ss, bp - 4)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 4);
        r16[dx] += memory16get(ss, bp - 2) + flags.carry;
        memory16set(ds, 0x87d4, r16[dx]);
        memory16set(ds, 0x87d2, r16[ax]);
    case 0x7794:
        r16[ax] = r16[si];
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_779c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x4;
        push(r16[ax]);
        push(memory16get(ss, bp - 14));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[dx] = memory16get(ds, 0x87ce);
        r16[ax] = memory16get(ds, 0x87cc);
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ds, 0x8dca, r16[dx]);
        memory16set(ds, 0x8dc8, r16[ax]);
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x77f5;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x77f5:
        push(memory16get(ss, bp - 12));
        push(memory16get(ds, 0x8dca));
        push(memory16get(ds, 0x8dc8));
        push(memory16get(ss, bp - 14));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        push(memory16get(ss, bp - 14));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[bx] = memory16get(ds, 0x8dc8);
        es = memory16get(ds, 0x8dc8 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        flags.carry = (r16[ax] + 0xfffe) >= 0x10000;
        r16[ax] += 0xfffe;
        r16[dx] += 0xffff + flags.carry;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
    case 0x782f:
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        flags.carry = memory16get(ss, bp - 12) < 0x0001;
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - 0x0001);
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) - flags.carry);
        r16[dx] |= r16[ax];
        if (!r16[dx]) {
            pc = 0x7859;
            break;
        }
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 1] = r8[al];
        memory[ss*16 + bp - 1] -= 0x32;
        r8[al] = memory[ss*16 + bp - 1];
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 1);
        pc = 0x782f;
        break;
    case 0x7859:
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] <<= 1;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ds, 0x8c56, r16[dx]);
        memory16set(ds, 0x8c54, r16[ax]);
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x787c;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x787c:
        r16[bx] = memory16get(ds, 0x8dc8);
        es = memory16get(ds, 0x8dc8 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[si] = 0;
        r16[bx] = memory16get(ds, 0x8c54);
        es = memory16get(ds, 0x8c54 + 2);
        memory16set(es, r16[bx], r16[si]);
        r16[di] = 0x0001;
        pc = 0x78b5;
        break;
    case 0x7894:
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x78a3;
            break;
        }
        r16[si]++;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 1);
        pc = 0x7894;
        break;
    case 0x78a3:
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 1);
        r16[si]++;
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ds, 0x8c54);
        es = memory16get(ds, 0x8c54 + 2);
        r16[bx] += r16[ax];
        memory16set(es, r16[bx], r16[si]);
        r16[di]++;
    case 0x78b5:
        if (r16[di] < memory16get(ss, bp - 4)) {
            pc = 0x7894;
            break;
        }
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_7bd0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = 0;
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        r16[dx] = 0;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        flags.carry = (r16[ax] + memory16get(ss, bp - 4)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 4);
        r8[tl] = (r16[dx] + memory16get(ss, bp - 2) + flags.carry) >= 0x10000;
        r16[dx] += memory16get(ss, bp - 2) + flags.carry;
        flags.carry = r8[tl];
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        flags.zero = !r16[dx];
        if (flags.carry) {
            pc = 0x7c0e;
            break;
        }
        if (!flags.carry && !flags.zero) {
            pc = 0x7c09;
            break;
        }
        if (r16[ax] <= 0xfa00) {
            pc = 0x7c0e;
            break;
        }
    case 0x7c09:
        r16[ax] = 0x0001;
        pc = 0x7c10;
        break;
    case 0x7c0e:
        r16[ax] = 0;
    case 0x7c10:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_7c14() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0044;
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0x7c41;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 12, r16[dx]);
        memory16set(ss, bp - 14, r16[ax]);
        pc = 0x7c4b;
        break;
    case 0x7c41:
        memory16set(ss, bp - 12, 0x0000);
        memory16set(ss, bp - 14, 0x0000);
    case 0x7c4b:
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[ax]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 34] = r8[al];
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 35] = r8[al];
        r8[al] = memory[ss*16 + bp - 34];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 35];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 24, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] += memory16get(ss, bp - 24);
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 32, r16[ax]);
        pc = 0x80c1;
        break;
    case 0x7c9d:
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 34] = r8[al];
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 35] = r8[al];
        r8[al] = memory[ss*16 + bp - 34];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 35];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 34] = r8[al];
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 35] = r8[al];
        r8[al] = memory[ss*16 + bp - 34];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 35];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 34] = r8[al];
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 35] = r8[al];
        r8[al] = memory[ss*16 + bp - 34];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 35];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        if (memory16get(es, r16[bx] + 4) == 0x0000) {
            pc = 0x7d70;
            break;
        }
        memory16set(ds, 0x87e2, 0x0001);
        pc = 0x7d76;
        break;
    case 0x7d70:
        memory16set(ds, 0x87e2, 0x0000);
    case 0x7d76:
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ss, bp - 28, r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[al] &= 0x07;
        memory[ss*16 + bp - 33] = r8[al];
        if (memory[ss*16 + bp - 33] == 0x00) {
            pc = 0x7db8;
            break;
        }
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 33];
        memory[ss*16 + bp - 33] = r8[al];
        memory16set(ss, bp - 28, memory16get(ss, bp - 28) + 1);
    case 0x7db8:
        r16[ax] = memory16get(ss, bp - 28);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        mul16(memory16get(ss, bp - 28));
        memory16set(ss, bp - 26, r16[ax]);
        r16[dx] = 0x0006;
        mul16(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 66, r16[dx]);
        memory16set(ss, bp - 68, r16[ax]);
        r16[bx] = memory16get(ss, bp - 68);
        es = memory16get(ss, bp - 68 + 2);
        memory16set(ss, bp - 38, es);
        memory16set(ss, bp - 40, r16[bx]);
        r16[bx] = r16[ax];
        r16[bx] += memory16get(ss, bp - 26);
        memory16set(ss, bp - 62, es);
        memory16set(ss, bp - 64, r16[bx]);
        r16[bx] += memory16get(ss, bp - 26);
        memory16set(ss, bp - 58, es);
        memory16set(ss, bp - 60, r16[bx]);
        r16[bx] += memory16get(ss, bp - 26);
        memory16set(ss, bp - 54, es);
        memory16set(ss, bp - 56, r16[bx]);
        r16[bx] += memory16get(ss, bp - 26);
        memory16set(ss, bp - 50, es);
        memory16set(ss, bp - 52, r16[bx]);
        r16[bx] += memory16get(ss, bp - 26);
        memory16set(ss, bp - 46, es);
        memory16set(ss, bp - 48, r16[bx]);
        r16[ax] = memory16get(ss, bp - 26);
        r16[dx] = 0x0006;
        mul16(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 66));
        push(memory16get(ss, bp - 68));
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory16set(ss, bp - 30, 0x0000);
        pc = 0x7ee9;
        break;
    case 0x7e53:
        if (memory[ss*16 + bp - 33] != 0x00) {
            pc = 0x7e5c;
            break;
        }
        pc = 0x7ee6;
        break;
    case 0x7e5c:
        r16[ax] = memory16get(ss, bp - 30);
        mul16(memory16get(ss, bp - 28));
        r16[ax] += memory16get(ss, bp - 28);
        r16[ax]--;
        r16[dx] = 0;
        memory16set(ss, bp - 16, r16[dx]);
        memory16set(ss, bp - 18, r16[ax]);
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 68);
        es = memory16get(ss, bp - 68 + 2);
        r16[bx] += memory16get(ss, bp - 18);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 64);
        es = memory16get(ss, bp - 64 + 2);
        r16[bx] += memory16get(ss, bp - 18);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 60);
        es = memory16get(ss, bp - 60 + 2);
        r16[bx] += memory16get(ss, bp - 18);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        r16[bx] += memory16get(ss, bp - 18);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 52);
        es = memory16get(ss, bp - 52 + 2);
        r16[bx] += memory16get(ss, bp - 18);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r16[bx] += memory16get(ss, bp - 18);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
    case 0x7ee6:
        memory16set(ss, bp - 30, memory16get(ss, bp - 30) + 1);
    case 0x7ee9:
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16[ax] <= memory16get(ss, bp - 30)) {
            pc = 0x7f03;
            break;
        }
        pc = 0x7e53;
        break;
    case 0x7f03:
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 30, r16[ax]);
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x06c1);
        r16[si] = r16[ax];
        r16[ax] = memory16get(ss, bp - 26);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_7bd0();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x7f5c;
            break;
        }
        memory16set(ss, bp - 30, memory16get(ss, bp - 30) + 1);
        r16[si] = 0;
        r16[ax] = memory16get(ss, bp - 30);
        r16[dx] = 0;
        r16[cx] = r16[si];
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 12, r16[dx]);
        memory16set(ss, bp - 14, r16[ax]);
    case 0x7f5c:
        r16[bx] = memory16get(ss, bp - 30);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 42, es);
        memory16set(ss, bp - 44, r16[bx]);
        memory16set(ss, bp - 44, memory16get(ss, bp - 44) + r16[si]);
        r16[dx] = memory16get(ss, bp - 42);
        r16[ax] = memory16get(ss, bp - 44);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[dx] = memory16get(ss, bp - 42);
        r16[ax] = memory16get(ss, bp - 44);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 18, r16[dx]);
        memory16set(es, r16[bx] + 16, r16[ax]);
        memory16set(ss, bp - 30, 0x0000);
        pc = 0x8074;
        break;
    case 0x7fb8:
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 7] = r8[al];
        memory16set(ss, bp - 48, memory16get(ss, bp - 48) + 1);
        r16[bx] = memory16get(ss, bp - 68);
        es = memory16get(ss, bp - 68 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 6] = r8[al];
        memory16set(ss, bp - 68, memory16get(ss, bp - 68) + 1);
        r16[bx] = memory16get(ss, bp - 64);
        es = memory16get(ss, bp - 64 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 5] = r8[al];
        memory16set(ss, bp - 64, memory16get(ss, bp - 64) + 1);
        r16[bx] = memory16get(ss, bp - 60);
        es = memory16get(ss, bp - 60 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 4] = r8[al];
        memory16set(ss, bp - 60, memory16get(ss, bp - 60) + 1);
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 3] = r8[al];
        memory16set(ss, bp - 56, memory16get(ss, bp - 56) + 1);
        r16[bx] = memory16get(ss, bp - 52);
        es = memory16get(ss, bp - 52 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 2] = r8[al];
        memory16set(ss, bp - 52, memory16get(ss, bp - 52) + 1);
        r16[di] = 0;
        pc = 0x806c;
        break;
    case 0x8004:
        r16[si] = 0x0080;
        r16[cx] = r16[di];
        r16[si] = sar16(r16[si], r8[cl]);
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x801a;
            break;
        }
        memory[ss*16 + bp - 1] = 0x80;
        pc = 0x801e;
        break;
    case 0x801a:
        memory[ss*16 + bp - 1] = 0x00;
    case 0x801e:
        r8[al] = memory[ss*16 + bp - 6];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x802b;
            break;
        }
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] | 0x01;
    case 0x802b:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x8038;
            break;
        }
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] | 0x02;
    case 0x8038:
        r8[al] = memory[ss*16 + bp - 4];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x8045;
            break;
        }
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] | 0x04;
    case 0x8045:
        r8[al] = memory[ss*16 + bp - 3];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x8052;
            break;
        }
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] | 0x08;
    case 0x8052:
        r8[al] = memory[ss*16 + bp - 2];
        r8[ah] = 0x00;
        if (!(r16[si] & r16[ax])) {
            pc = 0x805f;
            break;
        }
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] | 0x10;
    case 0x805f:
        r8[al] = memory[ss*16 + bp - 1];
        r16[bx] = memory16get(ss, bp - 44);
        es = memory16get(ss, bp - 44 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 44, memory16get(ss, bp - 44) + 1);
        r16[di]++;
    case 0x806c:
        if (r16[di] < 0x0008) {
            pc = 0x8004;
            break;
        }
        memory16set(ss, bp - 30, memory16get(ss, bp - 30) + 1);
    case 0x8074:
        r16[ax] = memory16get(ss, bp - 30);
        if (r16[ax] >= memory16get(ss, bp - 26)) {
            pc = 0x807f;
            break;
        }
        pc = 0x7fb8;
        break;
    case 0x807f:
        r16[ax] = memory16get(ss, bp - 26);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 14)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 14);
        r16[dx] += memory16get(ss, bp - 12) + flags.carry;
        memory16set(ss, bp - 12, r16[dx]);
        memory16set(ss, bp - 14, r16[ax]);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 32);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        push(memory16get(ss, bp - 38));
        push(memory16get(ss, bp - 40));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        memory16set(ss, bp - 32, memory16get(ss, bp - 32) + 1);
    case 0x80c1:
        r16[ax] = memory16get(ss, bp - 32);
        if (r16[ax] >= memory16get(ss, bp - 20)) {
            pc = 0x80cc;
            break;
        }
        pc = 0x7c9d;
        break;
    case 0x80cc:
        push(memory16get(ss, bp - 10));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[ax] = memory16get(ss, bp - 24);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_80de() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0038;
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0x810b;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        pc = 0x8115;
        break;
    case 0x810b:
        memory16set(ss, bp - 6, 0x0000);
        memory16set(ss, bp - 8, 0x0000);
    case 0x8115:
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 4, r16[ax]);
        push(r16[ax]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] += memory16get(ss, bp - 18);
        memory16set(ss, bp - 14, r16[ax]);
        r16[di] = memory16get(ss, bp - 16);
        pc = 0x8510;
        break;
    case 0x8164:
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        if (memory16get(es, r16[bx] + 4) == 0x0000) {
            pc = 0x8233;
            break;
        }
        memory16set(ds, 0x87e2, 0x0001);
        pc = 0x8239;
        break;
    case 0x8233:
        memory16set(ds, 0x87e2, 0x0000);
    case 0x8239:
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[al] &= 0x07;
        memory[ss*16 + bp - 25] = r8[al];
        if (memory[ss*16 + bp - 25] == 0x00) {
            pc = 0x8279;
            break;
        }
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 25];
        memory[ss*16 + bp - 25] = r8[al];
        memory16set(ss, bp - 22, memory16get(ss, bp - 22) + 1);
    case 0x8279:
        r16[ax] = memory16get(ss, bp - 22);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        mul16(memory16get(ss, bp - 22));
        memory16set(ss, bp - 20, r16[ax]);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 54, r16[dx]);
        memory16set(ss, bp - 56, r16[ax]);
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        memory16set(ss, bp - 30, es);
        memory16set(ss, bp - 32, r16[bx]);
        r16[bx] = r16[ax];
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 50, es);
        memory16set(ss, bp - 52, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 46, es);
        memory16set(ss, bp - 48, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 42, es);
        memory16set(ss, bp - 44, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 38, es);
        memory16set(ss, bp - 40, r16[bx]);
        r16[ax] = memory16get(ss, bp - 20);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 54));
        push(memory16get(ss, bp - 56));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 24, r16[ax]);
        r16[si] = 0;
        pc = 0x8396;
        break;
    case 0x831a:
        if (memory[ss*16 + bp - 25] == 0x00) {
            pc = 0x8395;
            break;
        }
        r16[ax] = r16[si];
        mul16(memory16get(ss, bp - 22));
        r16[ax] += memory16get(ss, bp - 22);
        r16[ax]--;
        r16[dx] = 0;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 52);
        es = memory16get(ss, bp - 52 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 44);
        es = memory16get(ss, bp - 44 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 40);
        es = memory16get(ss, bp - 40 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
    case 0x8395:
        r16[si]++;
    case 0x8396:
        if (r16[si] >= memory16get(ss, bp - 24)) {
            pc = 0x839e;
            break;
        }
        pc = 0x831a;
        break;
    case 0x839e:
        if (memory[ss*16 + bp + 16] != 0x00) {
            pc = 0x83b1;
            break;
        }
        r16[ax] = memory16get(ss, bp - 20);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0x83c5;
        break;
    case 0x83b1:
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp - 38, 0x0000);
        memory16set(ss, bp - 40, 0x0000);
    case 0x83c5:
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        r16[si] = r16[ax];
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 24, r16[ax]);
        push(memory16get(ss, bp - 2));
        push(r16[ax]);
        push(cs);
        yield* sub_7bd0();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x8417;
            break;
        }
        r16[si]++;
        memory16set(ss, bp - 24, 0x0000);
        r16[ax] = r16[si];
        r16[dx] = 0;
        r16[cx] = 0;
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
    case 0x8417:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 34, es);
        memory16set(ss, bp - 36, r16[bx]);
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + r16[ax]);
        r16[dx] = memory16get(ss, bp - 34);
        r16[ax] = memory16get(ss, bp - 36);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[dx] = memory16get(ss, bp - 34);
        r16[ax] = memory16get(ss, bp - 36);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 18, r16[dx]);
        memory16set(es, r16[bx] + 16, r16[ax]);
        r16[si] = 0;
        pc = 0x84d2;
        break;
    case 0x846f:
        r16[ax] = memory16get(ss, bp - 40);
        r16[ax] |= memory16get(ss, bp - 38);
        if (!r16[ax]) {
            pc = 0x8489;
            break;
        }
        r16[bx] = memory16get(ss, bp - 40);
        es = memory16get(ss, bp - 40 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 36);
        es = memory16get(ss, bp - 36 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 40, memory16get(ss, bp - 40) + 1);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + 1);
    case 0x8489:
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 36);
        es = memory16get(ss, bp - 36 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 56, memory16get(ss, bp - 56) + 1);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + 1);
        r16[bx] = memory16get(ss, bp - 52);
        es = memory16get(ss, bp - 52 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 36);
        es = memory16get(ss, bp - 36 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 52, memory16get(ss, bp - 52) + 1);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + 1);
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 36);
        es = memory16get(ss, bp - 36 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 48, memory16get(ss, bp - 48) + 1);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + 1);
        r16[bx] = memory16get(ss, bp - 44);
        es = memory16get(ss, bp - 44 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 36);
        es = memory16get(ss, bp - 36 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 44, memory16get(ss, bp - 44) + 1);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + 1);
        r16[si]++;
    case 0x84d2:
        if (r16[si] < memory16get(ss, bp - 20)) {
            pc = 0x846f;
            break;
        }
        r16[ax] = memory16get(ss, bp - 2);
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 8)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 8);
        r16[dx] += memory16get(ss, bp - 6) + flags.carry;
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        push(memory16get(ss, bp - 30));
        push(memory16get(ss, bp - 32));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        r16[di]++;
    case 0x8510:
        if (r16[di] >= memory16get(ss, bp - 14)) {
            pc = 0x8518;
            break;
        }
        pc = 0x8164;
        break;
    case 0x8518:
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[ax] = memory16get(ss, bp - 18);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_852f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0026;
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0x855c;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        pc = 0x8566;
        break;
    case 0x855c:
        memory16set(ss, bp - 8, 0x0000);
        memory16set(ss, bp - 10, 0x0000);
    case 0x8566:
        r8[al] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] += memory16get(ss, bp - 16);
        memory16set(ss, bp - 12, r16[ax]);
        r16[di] = memory16get(ss, bp - 14);
        pc = 0x88ca;
        break;
    case 0x85c5:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[al] &= 0x07;
        memory[ss*16 + bp - 23] = r8[al];
        if (memory[ss*16 + bp - 23] == 0x00) {
            pc = 0x86e2;
            break;
        }
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 23];
        memory[ss*16 + bp - 23] = r8[al];
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + 1);
    case 0x86e2:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x86f3;
            break;
        }
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x86f3;
            break;
        }
        pc = 0x870c;
        break;
    case 0x86f3:
        r16[ax] = memory16get(ss, bp - 20);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
        pc = 0x8726;
        break;
    case 0x870c:
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
    case 0x8726:
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        mul16(memory16get(ss, bp - 20));
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 36, r16[dx]);
        memory16set(ss, bp - 38, r16[ax]);
        r16[bx] = memory16get(ss, bp - 38);
        es = memory16get(ss, bp - 38 + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x8764;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x8764:
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 36));
        push(memory16get(ss, bp - 38));
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[si] = 0;
        pc = 0x87ab;
        break;
    case 0x877c:
        if (memory[ss*16 + bp - 23] != 0x00) {
            pc = 0x8785;
            break;
        }
        pc = 0x87aa;
        break;
    case 0x8785:
        r16[ax] = r16[si];
        mul16(memory16get(ss, bp - 20));
        r16[ax] += memory16get(ss, bp - 20);
        r16[ax]--;
        r16[dx] = 0;
        memory16set(ss, bp - 4, r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r8[al] = memory[ss*16 + bp - 23];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 38);
        es = memory16get(ss, bp - 38 + 2);
        r16[bx] += memory16get(ss, bp - 6);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
    case 0x87aa:
        r16[si]++;
    case 0x87ab:
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16[ax] <= r16[si]) {
            pc = 0x87c3;
            break;
        }
        pc = 0x877c;
        break;
    case 0x87c3:
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        r16[si] = r16[ax];
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 22, r16[ax]);
        push(memory16get(ss, bp - 18));
        push(r16[ax]);
        push(cs);
        yield* sub_7bd0();
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x87fe;
            break;
        }
        pc = 0x8818;
        break;
    case 0x87fe:
        r16[si]++;
        memory16set(ss, bp - 22, 0x0000);
        r16[ax] = r16[si];
        r16[dx] = 0;
        r16[cx] = 0;
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
    case 0x8818:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 30, memory16get(ss, bp - 30) + r16[ax]);
        r16[dx] = memory16get(ss, bp - 28);
        r16[ax] = memory16get(ss, bp - 30);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[dx] = memory16get(ss, bp - 28);
        r16[ax] = memory16get(ss, bp - 30);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 18, r16[dx]);
        memory16set(es, r16[bx] + 16, r16[ax]);
        r16[bx] = memory16get(ss, bp - 34);
        es = memory16get(ss, bp - 34 + 2);
        memory16set(ss, bp - 36, es);
        memory16set(ss, bp - 38, r16[bx]);
        r16[si] = 0;
        pc = 0x888c;
        break;
    case 0x8879:
        r16[bx] = memory16get(ss, bp - 38);
        es = memory16get(ss, bp - 38 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 30);
        es = memory16get(ss, bp - 30 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 38, memory16get(ss, bp - 38) + 1);
        memory16set(ss, bp - 30, memory16get(ss, bp - 30) + 1);
        r16[si]++;
    case 0x888c:
        if (r16[si] < memory16get(ss, bp - 18)) {
            pc = 0x8879;
            break;
        }
        r16[ax] = memory16get(ss, bp - 18);
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 10)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 10);
        r16[dx] += memory16get(ss, bp - 8) + flags.carry;
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        push(memory16get(ss, bp - 32));
        push(memory16get(ss, bp - 34));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        r16[di]++;
    case 0x88ca:
        if (r16[di] >= memory16get(ss, bp - 12)) {
            pc = 0x88d2;
            break;
        }
        pc = 0x85c5;
        break;
    case 0x88d2:
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[ax] = memory16get(ss, bp - 16);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_88e4() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[ax] = 0x0004;
    push(r16[ax]);
    push(memory16get(ss, bp + 10));
    push(memory16get(ss, bp + 8));
    push(memory16get(ss, bp + 6));
    push(cs);
    yield* sub_6e6a();
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_88fc() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000a;
        r16[ax] = 0x8f6c;
        r16[dx] = ds;
        push(r16[ax]);
        r16[ax] = 0x8f6c;
        r16[dx] = ds;
        push(r16[dx]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c7ba();
        assert(cs == 0x06c1);
        sp += 0x0004;
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x894f;
            break;
        }
        r8[al] = 0x05;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x03;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r8[al] = 0xff;
        r16[dx] = 0x03cf;
        out8(r16[dx], r8[al]);
    case 0x894f:
        r16[di] = 0;
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 4, r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r8[al] = memory[ss*16 + bp + 12];
        r8[ah] = 0x00;
        memory16set(ds, 0x87e2, r16[ax]);
        memory16set(ss, bp - 2, 0x0000);
        pc = 0x8a6c;
        break;
    case 0x897b:
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x89b4;
            break;
        }
        r16[si] = 0;
        pc = 0x89ab;
        break;
    case 0x8986:
        r8[al] = 0x02;
        r16[dx] = 0x03c4;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[cx] = r16[si];
        r8[al] <<= r8[cl];
        r16[dx] = 0x03c5;
        out8(r16[dx], r8[al]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[si]++;
    case 0x89ab:
        if (r16[si] < 0x0004) {
            pc = 0x8986;
            break;
        }
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 0x0028);
    case 0x89b4:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x89c2;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x8a05;
            break;
        }
    case 0x89c2:
        r16[ax] = 0x00a0;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        r16[ax] = memory16get(ss, bp - 8);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        r16[ax] = memory16get(ss, bp - 4);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c9bc();
        assert(cs == 0x06c1);
        sp += 0x000a;
        if (r16[di]) {
            pc = 0x89fe;
            break;
        }
        r16[di] = 0x0001;
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 0x2000);
        pc = 0x8a05;
        break;
    case 0x89fe:
        r16[di] = 0;
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) - 0x1fb0);
    case 0x8a05:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x8a4f;
            break;
        }
        r16[ax] = 0x00a0;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        r16[ax] = memory16get(ss, bp - 4);
        push(r16[ax]);
        push(memory16get(ss, bp - 10));
        r16[ax] = memory16get(ss, bp - 8);
        push(r16[ax]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e8f3();
        assert(cs == 0x06c1);
        sp += 0x000a;
        r16[di]++;
        r16[di] &= 0x0003;
        if (r16[di]) {
            pc = 0x8a4a;
            break;
        }
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) - 0x5f60);
        pc = 0x8a4f;
        break;
    case 0x8a4a:
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 0x2000);
    case 0x8a4f:
        if (memory[ss*16 + bp + 14] == 0x00) {
            pc = 0x8a69;
            break;
        }
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
    case 0x8a69:
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 1);
    case 0x8a6c:
        if (memory16get(ss, bp - 2) >= 0x00c8) {
            pc = 0x8a76;
            break;
        }
        pc = 0x897b;
        break;
    case 0x8a76:
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_8a8a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x002a;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
        memory[ds*16 + 0x8de6] = 0x00;
        if (memory[ds*16 + 0x8f67] != 0x00) {
            pc = 0x8ac1;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_6d22();
        sp += 0x0004;
    case 0x8ac1:
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        r16[si] = r16[ax];
        memory[ss*16 + bp - 18] = 0x00;
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88e4();
        sp += 0x0006;
        r16[di] = 0;
        pc = 0x8af0;
        break;
    case 0x8ae8:
        push(r16[si]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        r16[di]++;
    case 0x8af0:
        if (r16[di] < 0x0004) {
            pc = 0x8ae8;
            break;
        }
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88e4();
        sp += 0x0006;
    case 0x8b02:
        push(ds);
        r16[ax] = 0x0585;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0x8b1b;
            break;
        }
        pc = 0x8ce1;
        break;
    case 0x8b1b:
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88e4();
        sp += 0x0006;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x7;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[dx] = 0;
        mul16(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x7;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[dx] = 0;
        mul16(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        flags.carry = (r16[ax] + memory16get(ss, bp - 16)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 16);
        r16[dx] += memory16get(ss, bp - 14) + flags.carry;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x7;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        flags.carry = (r16[ax] + memory16get(ss, bp - 16)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 16);
        r16[dx] += memory16get(ss, bp - 14) + flags.carry;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x7;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        flags.carry = (r16[ax] + memory16get(ss, bp - 16)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 16);
        r16[dx] += memory16get(ss, bp - 14) + flags.carry;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        push(ds);
        r16[ax] = 0x058a;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0x8bec;
            break;
        }
        r16[ax] = 0x0014;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x2a;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
    case 0x8bec:
        push(ds);
        r16[ax] = 0x058f;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0x8c18;
            break;
        }
        r16[dx] = memory16get(ss, bp - 14);
        r16[ax] = memory16get(ss, bp - 16);
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
    case 0x8c18:
        push(ds);
        r16[ax] = 0x0594;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (!r16[ax]) {
            pc = 0x8c31;
            break;
        }
        pc = 0x8cba;
        break;
    case 0x8c31:
        r16[di] = 0;
        pc = 0x8c90;
        break;
    case 0x8c35:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] >> 1;
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] >> 1;
        r8[al] = memory[ss*16 + bp - 1];
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] >> 1;
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] >> 1;
        r8[al] = memory[ss*16 + bp - 1];
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x1;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] >> 1;
        memory[ss*16 + bp - 1] = memory[ss*16 + bp - 1] >> 1;
        r8[al] = memory[ss*16 + bp - 1];
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[di]++;
    case 0x8c90:
        r16[dx] = 0;
        r16[ax] = 0x0003;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        r16[bx] = r16[di];
        r16[cx] = 0;
        if (r16[dx] > r16[cx]) {
            pc = 0x8c35;
            break;
        }
        if (r16[dx] != r16[cx]) {
            pc = 0x8cb0;
            break;
        }
        if (r16[ax] > r16[bx]) {
            pc = 0x8c35;
            break;
        }
    case 0x8cb0:
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
    case 0x8cba:
        r16[ax] = memory16get(ss, bp - 16);
        r16[ax] |= memory16get(ss, bp - 14);
        if (r16[ax]) {
            pc = 0x8cc5;
            break;
        }
        pc = 0x8b02;
        break;
    case 0x8cc5:
        r16[ax] = memory16get(ss, bp - 16);
        r16[ax] |= memory16get(ss, bp - 14);
        if (r16[ax]) {
            pc = 0x8cd0;
            break;
        }
        pc = 0x8b02;
        break;
    case 0x8cd0:
        push(r16[si]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        flags.carry = memory16get(ss, bp - 16) < 0x0001;
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) - 0x0001);
        memory16set(ss, bp - 14, memory16get(ss, bp - 14) - flags.carry);
        pc = 0x8cc5;
        break;
    case 0x8ce1:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] != memory[ds*16 + 0x8f66]) {
            pc = 0x8d13;
            break;
        }
        push(memory16get(ds, 0x8bb2));
        push(memory16get(ds, 0x8bb0));
        push(memory16get(ss, bp + 16));
        push(r16[bx]);
        push(cs);
        cs = 0x023f;
        yield* sub_30d5();
        assert(cs == 0x06c1);
        sp += 0x0008;
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x06c1);
        sp += 0x0006;
    case 0x8d13:
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 32];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sync();
        yield* sub_88fc();
        sp += 0x000a;
        push(r16[si]);
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_8d3a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0018;
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x06c1);
        sp += 0x0006;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        r16[di] = r16[ax];
        memory16set(ss, bp - 16, 0x0000);
        pc = 0x8e02;
        break;
    case 0x8d79:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x8;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x9;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 8];
        r8[ah] = 0x00;
        memory16set(ss, bp - 14, r16[ax]);
        r16[cx] = 0x0008;
        memory16set(ss, bp - 14, memory16get(ss, bp - 14) << r8[cl]);
        r8[al] = memory[ss*16 + bp - 9];
        r8[ah] = 0x00;
        memory16set(ss, bp - 14, memory16get(ss, bp - 14) + r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] &= 0x0f00;
        memory16set(ss, bp - 12, r16[ax]);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) >> r8[cl]);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) << 1);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) << 1);
        r8[al] = memory[ss*16 + bp - 12];
        r16[bx] = memory16get(ss, bp - 16);
        memory[ds*16 + r16[bx] + 37300] = r8[al];
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] &= 0x00f0;
        memory16set(ss, bp - 12, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) >> r8[cl]);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) << 1);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) << 1);
        r8[al] = memory[ss*16 + bp - 12];
        memory[ds*16 + r16[bx] + 35434] = r8[al];
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] &= 0x000f;
        memory16set(ss, bp - 12, r16[ax]);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) << 1);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) << 1);
        r8[al] = memory[ss*16 + bp - 12];
        memory[ds*16 + r16[bx] + 36414] = r8[al];
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 1);
    case 0x8e02:
        if (memory16get(ss, bp - 16) >= 0x0020) {
            pc = 0x8e0b;
            break;
        }
        pc = 0x8d79;
        break;
    case 0x8e0b:
        memory[ds*16 + 0x8de6] = 0x00;
        memory16set(ss, bp - 16, 0x0000);
        pc = 0x8e21;
        break;
    case 0x8e17:
        push(r16[di]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 1);
    case 0x8e21:
        if (memory16get(ss, bp - 16) < 0x0004) {
            pc = 0x8e17;
            break;
        }
        r16[ax] = 0x1388;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 18, r16[dx]);
        memory16set(ss, bp - 20, r16[ax]);
        memory16set(ds, 0x87e2, 0x0001);
        r16[ax] = 0x1388;
        push(r16[ax]);
        push(r16[dx]);
        push(memory16get(ss, bp - 20));
        push(r16[di]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory16set(ds, 0x87e2, 0x0000);
        push(r16[di]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        push(r16[di]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        push(r16[di]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        push(r16[di]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 16, 0x0000);
        memory[ss*16 + bp - 7] = 0x01;
        pc = 0x8f6e;
        break;
    case 0x8e7c:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x8f62;
        break;
    case 0x8e90:
        memory16set(ss, bp - 2, 0x0000);
        pc = 0x8f51;
        break;
    case 0x8e98:
        r16[ax] = memory16get(ss, bp - 16);
        r16[bx] = memory16get(ss, bp - 20);
        es = memory16get(ss, bp - 20 + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 6] = r8[al];
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 1);
        r16[si] = 0;
        pc = 0x8f46;
        break;
    case 0x8eae:
        if (memory[ss*16 + bp - 6] & 0x01) {
            pc = 0x8ebe;
            break;
        }
        push(r16[di]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 5] = r8[al];
    case 0x8ebe:
        if (!(memory[ss*16 + bp - 5] & 0x80)) {
            pc = 0x8ecd;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] | r8[al];
    case 0x8ecd:
        if (!(memory[ss*16 + bp - 5] & 0x40)) {
            pc = 0x8edd;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 1] = memory[es*16 + r16[bx] + 1] | r8[al];
    case 0x8edd:
        if (!(memory[ss*16 + bp - 5] & 0x20)) {
            pc = 0x8eed;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 2] = memory[es*16 + r16[bx] + 2] | r8[al];
    case 0x8eed:
        if (!(memory[ss*16 + bp - 5] & 0x10)) {
            pc = 0x8efd;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 3] = memory[es*16 + r16[bx] + 3] | r8[al];
    case 0x8efd:
        if (!(memory[ss*16 + bp - 5] & 0x08)) {
            pc = 0x8f0d;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 4] = memory[es*16 + r16[bx] + 4] | r8[al];
    case 0x8f0d:
        if (!(memory[ss*16 + bp - 5] & 0x04)) {
            pc = 0x8f1d;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 5] = memory[es*16 + r16[bx] + 5] | r8[al];
    case 0x8f1d:
        if (!(memory[ss*16 + bp - 5] & 0x02)) {
            pc = 0x8f2d;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 6] = memory[es*16 + r16[bx] + 6] | r8[al];
    case 0x8f2d:
        if (!(memory[ss*16 + bp - 5] & 0x01)) {
            pc = 0x8f3d;
            break;
        }
        r8[al] = memory[ss*16 + bp - 7];
        r16[bx] = memory16get(ss, bp - 24);
        es = memory16get(ss, bp - 24 + 2);
        memory[es*16 + r16[bx] + 7] = memory[es*16 + r16[bx] + 7] | r8[al];
    case 0x8f3d:
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + 0x0140);
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] >> 1;
        r16[si]++;
    case 0x8f46:
        if (r16[si] >= 0x0008) {
            pc = 0x8f4e;
            break;
        }
        pc = 0x8eae;
        break;
    case 0x8f4e:
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 1);
    case 0x8f51:
        if (memory16get(ss, bp - 2) >= 0x0019) {
            pc = 0x8f5a;
            break;
        }
        pc = 0x8e98;
        break;
    case 0x8f5a:
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) - 0xf9f8);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x8f62:
        if (memory16get(ss, bp - 4) >= 0x0028) {
            pc = 0x8f6b;
            break;
        }
        pc = 0x8e90;
        break;
    case 0x8f6b:
        memory[ss*16 + bp - 7] = memory[ss*16 + bp - 7] << 1;
    case 0x8f6e:
        if (memory[ss*16 + bp - 7] >= 0x20) {
            pc = 0x8f77;
            break;
        }
        pc = 0x8e7c;
        break;
    case 0x8f77:
        push(r16[di]);
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_90aa() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0038;
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0x90d7;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        pc = 0x90e1;
        break;
    case 0x90d7:
        memory16set(ss, bp - 6, 0x0000);
        memory16set(ss, bp - 8, 0x0000);
    case 0x90e1:
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 4, r16[ax]);
        push(r16[ax]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] += memory16get(ss, bp - 18);
        memory16set(ss, bp - 14, r16[ax]);
        r16[di] = memory16get(ss, bp - 16);
        pc = 0x949e;
        break;
    case 0x9130:
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 26] = r8[al];
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 27] = r8[al];
        r8[al] = memory[ss*16 + bp - 26];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 27];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        if (memory16get(es, r16[bx] + 4) == 0x0000) {
            pc = 0x91ff;
            break;
        }
        memory16set(ds, 0x87e2, 0x0001);
        pc = 0x9205;
        break;
    case 0x91ff:
        memory16set(ds, 0x87e2, 0x0000);
    case 0x9205:
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[al] &= 0x07;
        memory[ss*16 + bp - 25] = r8[al];
        if (memory[ss*16 + bp - 25] == 0x00) {
            pc = 0x9245;
            break;
        }
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 25];
        memory[ss*16 + bp - 25] = r8[al];
        memory16set(ss, bp - 22, memory16get(ss, bp - 22) + 1);
    case 0x9245:
        r16[ax] = memory16get(ss, bp - 22);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        mul16(memory16get(ss, bp - 22));
        memory16set(ss, bp - 20, r16[ax]);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 54, r16[dx]);
        memory16set(ss, bp - 56, r16[ax]);
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        memory16set(ss, bp - 30, es);
        memory16set(ss, bp - 32, r16[bx]);
        r16[bx] = r16[ax];
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 50, es);
        memory16set(ss, bp - 52, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 46, es);
        memory16set(ss, bp - 48, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 42, es);
        memory16set(ss, bp - 44, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 38, es);
        memory16set(ss, bp - 40, r16[bx]);
        r16[ax] = memory16get(ss, bp - 20);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 54));
        push(memory16get(ss, bp - 56));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 24, r16[ax]);
        r16[si] = 0;
        pc = 0x9366;
        break;
    case 0x92ea:
        if (memory[ss*16 + bp - 25] == 0x00) {
            pc = 0x9365;
            break;
        }
        r16[ax] = r16[si];
        mul16(memory16get(ss, bp - 22));
        r16[ax] += memory16get(ss, bp - 22);
        r16[ax]--;
        r16[dx] = 0;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 56);
        es = memory16get(ss, bp - 56 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 52);
        es = memory16get(ss, bp - 52 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 44);
        es = memory16get(ss, bp - 44 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r8[al] = memory[ss*16 + bp - 25];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 40);
        es = memory16get(ss, bp - 40 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
    case 0x9365:
        r16[si]++;
    case 0x9366:
        if (r16[si] >= memory16get(ss, bp - 24)) {
            pc = 0x936e;
            break;
        }
        pc = 0x92ea;
        break;
    case 0x936e:
        if (memory[ss*16 + bp + 16] != 0x00) {
            pc = 0x9382;
            break;
        }
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0x9396;
        break;
    case 0x9382:
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp - 38, 0x0000);
        memory16set(ss, bp - 40, 0x0000);
    case 0x9396:
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        r16[si] = r16[ax];
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 24, r16[ax]);
        push(memory16get(ss, bp - 2));
        push(r16[ax]);
        push(cs);
        yield* sub_7bd0();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x93e8;
            break;
        }
        r16[si]++;
        memory16set(ss, bp - 24, 0x0000);
        r16[ax] = r16[si];
        r16[dx] = 0;
        r16[cx] = 0;
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
    case 0x93e8:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 34, es);
        memory16set(ss, bp - 36, r16[bx]);
        r16[ax] = r16[bx];
        r16[ax] |= memory16get(ss, bp - 34);
        if (r16[ax]) {
            pc = 0x9404;
            break;
        }
        push(cs);
        cs = 0x12f9;
        yield* sub_13be3();
        assert(cs == 0x06c1);
    case 0x9404:
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 36, memory16get(ss, bp - 36) + r16[ax]);
        r16[dx] = memory16get(ss, bp - 34);
        r16[ax] = memory16get(ss, bp - 36);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 40);
        r16[ax] |= memory16get(ss, bp - 38);
        if (!r16[ax]) {
            pc = 0x944c;
            break;
        }
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 56));
        r16[ax] = memory16get(ss, bp - 54);
        push(r16[ax]);
        push(memory16get(ss, bp - 36));
        r16[ax] = memory16get(ss, bp - 34);
        push(r16[ax]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e84e();
        assert(cs == 0x06c1);
        sp += 0x000a;
        pc = 0x9465;
        break;
    case 0x944c:
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 56));
        r16[ax] = memory16get(ss, bp - 54);
        push(r16[ax]);
        push(memory16get(ss, bp - 36));
        r16[ax] = memory16get(ss, bp - 34);
        push(r16[ax]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e8f3();
        assert(cs == 0x06c1);
        sp += 0x000a;
    case 0x9465:
        r16[ax] = memory16get(ss, bp - 2);
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 8)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 8);
        r16[dx] += memory16get(ss, bp - 6) + flags.carry;
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        push(memory16get(ss, bp - 30));
        push(memory16get(ss, bp - 32));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        r16[di]++;
    case 0x949e:
        if (r16[di] >= memory16get(ss, bp - 14)) {
            pc = 0x94a6;
            break;
        }
        pc = 0x9130;
        break;
    case 0x94a6:
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[ax] = memory16get(ss, bp - 18);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_94b8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0042;
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x94d1;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x94d1;
            break;
        }
        pc = 0x9935;
        break;
    case 0x94d1:
        r16[ax] = 0x0012;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 44, r16[dx]);
        memory16set(ss, bp - 46, r16[ax]);
        r16[bx] = memory16get(ss, bp - 46);
        es = memory16get(ss, bp - 46 + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_6c63();
        sp += 0x0004;
        r16[ax] = 0x8f6c;
        r16[dx] = ds;
        push(r16[ax]);
        r16[ax] = 0x8f6c;
        r16[dx] = ds;
        push(r16[dx]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c7ba();
        assert(cs == 0x06c1);
        sp += 0x0004;
        r16[si] = 0;
        pc = 0x956a;
        break;
    case 0x9510:
        r16[ax] = r16[si];
        r8[al] &= 0x08;
        r16[cx] = 0x0004;
        r8[al] <<= r8[cl];
        r16[dx] = r16[si];
        r8[dl] &= 0x08;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[si];
        r8[dl] &= 0x04;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[si];
        r8[dl] &= 0x04;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[si];
        r8[dl] &= 0x02;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[si];
        r8[dl] &= 0x02;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[si];
        r8[dl] &= 0x01;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[si];
        r8[dl] &= 0x01;
        r8[al] |= r8[dl];
        r16[bx] = memory16get(ss, bp - 46);
        es = memory16get(ss, bp - 46 + 2);
        memory[es*16 + r16[bx] + r16[si]] = r8[al];
        r16[si]++;
    case 0x956a:
        if (r16[si] < 0x0010) {
            pc = 0x9510;
            break;
        }
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0x9594;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        pc = 0x959e;
        break;
    case 0x9594:
        memory16set(ss, bp - 6, 0x0000);
        memory16set(ss, bp - 8, 0x0000);
    case 0x959e:
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 4, r16[ax]);
        push(r16[ax]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 28, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 30, r16[ax]);
        r16[ax] = memory16get(ss, bp - 28);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += memory16get(ss, bp - 30);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] += memory16get(ss, bp - 18);
        memory16set(ss, bp - 14, r16[ax]);
        r16[si] = memory16get(ss, bp - 16);
        pc = 0x9913;
        break;
    case 0x95e7:
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 28, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 30, r16[ax]);
        r16[ax] = memory16get(ss, bp - 28);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += memory16get(ss, bp - 30);
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 28, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 30, r16[ax]);
        r16[ax] = memory16get(ss, bp - 28);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += memory16get(ss, bp - 30);
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 28, r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory16set(ss, bp - 30, r16[ax]);
        r16[ax] = memory16get(ss, bp - 28);
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[ax] += memory16get(ss, bp - 30);
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        if (memory16get(es, r16[bx] + 4) == 0x0000) {
            pc = 0x96a4;
            break;
        }
        memory16set(ds, 0x87e2, 0x0001);
        pc = 0x96aa;
        break;
    case 0x96a4:
        memory16set(ds, 0x87e2, 0x0000);
    case 0x96aa:
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] &= 0x0007;
        memory16set(ss, bp - 26, r16[ax]);
        if (!r16[ax]) {
            pc = 0x96e9;
            break;
        }
        r16[ax] = 0x0008;
        r16[ax] -= memory16get(ss, bp - 26);
        memory16set(ss, bp - 26, r16[ax]);
        memory16set(ss, bp - 22, memory16get(ss, bp - 22) + 1);
    case 0x96e9:
        r16[ax] = memory16get(ss, bp - 22);
        r16[ax] <<= 1;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        mul16(memory16get(ss, bp - 22));
        memory16set(ss, bp - 20, r16[ax]);
        memory16set(ss, bp - 2, r16[ax]);
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        memory16set(ss, bp - 2, r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 64, r16[dx]);
        memory16set(ss, bp - 66, r16[ax]);
        r16[bx] = memory16get(ss, bp - 66);
        es = memory16get(ss, bp - 66 + 2);
        memory16set(ss, bp - 36, es);
        memory16set(ss, bp - 38, r16[bx]);
        r16[bx] = r16[ax];
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 60, es);
        memory16set(ss, bp - 62, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 56, es);
        memory16set(ss, bp - 58, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 52, es);
        memory16set(ss, bp - 54, r16[bx]);
        r16[bx] += memory16get(ss, bp - 20);
        memory16set(ss, bp - 48, es);
        memory16set(ss, bp - 50, r16[bx]);
        push(memory16get(ss, bp - 2));
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 24, r16[ax]);
        r16[di] = 0x00ff;
        r16[cx] = memory16get(ss, bp - 26);
        r16[di] <<= r8[cl];
        r16[ax] = memory16get(ss, bp - 22);
        r16[ax]--;
        r16[dx] = 0;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
    case 0x9797:
        if (memory16get(ss, bp - 24) == 0x0000) {
            pc = 0x97f0;
            break;
        }
        if (memory16get(ss, bp - 26) == 0x0000) {
            pc = 0x97da;
            break;
        }
        r16[ax] = r16[di];
        r16[bx] = memory16get(ss, bp - 66);
        es = memory16get(ss, bp - 66 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r16[ax] = r16[di];
        r16[bx] = memory16get(ss, bp - 62);
        es = memory16get(ss, bp - 62 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r16[ax] = r16[di];
        r16[bx] = memory16get(ss, bp - 58);
        es = memory16get(ss, bp - 58 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r16[ax] = r16[di];
        r16[bx] = memory16get(ss, bp - 54);
        es = memory16get(ss, bp - 54 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
        r16[ax] = r16[di];
        r16[bx] = memory16get(ss, bp - 50);
        es = memory16get(ss, bp - 50 + 2);
        r16[bx] += memory16get(ss, bp - 12);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
    case 0x97da:
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) - 1);
        r16[ax] = memory16get(ss, bp - 22);
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 12)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 12);
        r16[dx] += memory16get(ss, bp - 10) + flags.carry;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        pc = 0x9797;
        break;
    case 0x97f0:
        if (memory[ss*16 + bp + 16] == 0x00) {
            pc = 0x97f9;
            break;
        }
        pc = 0x9805;
        break;
    case 0x97f9:
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0x9817;
        break;
    case 0x9805:
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp - 48, 0x0000);
        memory16set(ss, bp - 50, 0x0000);
    case 0x9817:
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        r16[di] = r16[ax];
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 24, r16[ax]);
        push(memory16get(ss, bp - 2));
        push(r16[ax]);
        push(cs);
        yield* sub_7bd0();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x9869;
            break;
        }
        r16[di]++;
        memory16set(ss, bp - 24, 0x0000);
        r16[ax] = r16[di];
        r16[dx] = 0;
        r16[cx] = 0;
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
    case 0x9869:
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 40, es);
        memory16set(ss, bp - 42, r16[bx]);
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 42, memory16get(ss, bp - 42) + r16[ax]);
        r16[dx] = memory16get(ss, bp - 40);
        r16[ax] = memory16get(ss, bp - 42);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 50);
        r16[ax] |= memory16get(ss, bp - 48);
        if (!r16[ax]) {
            pc = 0x98c1;
            break;
        }
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 42));
        r16[ax] = memory16get(ss, bp - 40);
        push(r16[ax]);
        push(memory16get(ss, bp - 66));
        r16[ax] = memory16get(ss, bp - 64);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c7e2();
        assert(cs == 0x06c1);
        sp += 0x000a;
        pc = 0x98da;
        break;
    case 0x98c1:
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 42));
        r16[ax] = memory16get(ss, bp - 40);
        push(r16[ax]);
        push(memory16get(ss, bp - 66));
        r16[ax] = memory16get(ss, bp - 64);
        push(r16[ax]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c9bc();
        assert(cs == 0x06c1);
        sp += 0x000a;
    case 0x98da:
        r16[ax] = memory16get(ss, bp - 2);
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 8)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 8);
        r16[dx] += memory16get(ss, bp - 6) + flags.carry;
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        push(memory16get(ss, bp - 36));
        push(memory16get(ss, bp - 38));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        r16[si]++;
    case 0x9913:
        if (r16[si] >= memory16get(ss, bp - 14)) {
            pc = 0x991b;
            break;
        }
        pc = 0x95e7;
        break;
    case 0x991b:
        push(memory16get(ss, bp - 32));
        push(memory16get(ss, bp - 34));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[ax] = memory16get(ss, bp - 18);
    case 0x9935:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_993b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        memory16set(ds, 0x919a, 0x0001);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x9961;
            break;
        }
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_80de();
        sp = bp;
        pc = 0x99b1;
        break;
    case 0x9961:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x997a;
            break;
        }
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_90aa();
        sp = bp;
        pc = 0x99b1;
        break;
    case 0x997a:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x9993;
            break;
        }
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_7c14();
        sp = bp;
        pc = 0x99b1;
        break;
    case 0x9993:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x99a1;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x99b1;
            break;
        }
    case 0x99a1:
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(r16[si]);
        push(cs);
        yield* sub_94b8();
        sp = bp;
    case 0x99b1:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_99b4() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0030;
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x99d1;
            break;
        }
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x99d1;
            break;
        }
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x99e7;
            break;
        }
    case 0x99d1:
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_852f();
        sp += 0x0008;
        pc = 0x9e37;
        break;
    case 0x99e7:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x99f8;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x99f8;
            break;
        }
        pc = 0x9e37;
        break;
    case 0x99f8:
        r16[ax] = 0x0012;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 40, r16[dx]);
        memory16set(ss, bp - 42, r16[ax]);
        r16[bx] = memory16get(ss, bp - 42);
        es = memory16get(ss, bp - 42 + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x9a21;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x9a21:
        r16[di] = 0;
        pc = 0x9a7f;
        break;
    case 0x9a25:
        r16[ax] = r16[di];
        r8[al] &= 0x08;
        r16[cx] = 0x0004;
        r8[al] <<= r8[cl];
        r16[dx] = r16[di];
        r8[dl] &= 0x08;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[di];
        r8[dl] &= 0x04;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[di];
        r8[dl] &= 0x04;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[di];
        r8[dl] &= 0x02;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[di];
        r8[dl] &= 0x02;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[di];
        r8[dl] &= 0x01;
        r8[dl] <<= 1;
        r8[al] |= r8[dl];
        r16[dx] = r16[di];
        r8[dl] &= 0x01;
        r8[al] |= r8[dl];
        r16[bx] = memory16get(ss, bp - 42);
        es = memory16get(ss, bp - 42 + 2);
        memory[es*16 + r16[bx] + r16[di]] = r8[al];
        r16[di]++;
    case 0x9a7f:
        if (r16[di] < 0x0010) {
            pc = 0x9a25;
            break;
        }
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0x9aa9;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        pc = 0x9ab3;
        break;
    case 0x9aa9:
        memory16set(ss, bp - 8, 0x0000);
        memory16set(ss, bp - 10, 0x0000);
    case 0x9ab3:
        r8[al] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] += memory16get(ss, bp - 16);
        memory16set(ss, bp - 12, r16[ax]);
        r16[di] = memory16get(ss, bp - 14);
        pc = 0x9e15;
        break;
    case 0x9b12:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx], r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 2, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x19;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 24];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 25];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 4, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r8[al] &= 0x07;
        memory[ss*16 + bp - 23] = r8[al];
        if (memory[ss*16 + bp - 23] == 0x00) {
            pc = 0x9c2f;
            break;
        }
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 23];
        memory[ss*16 + bp - 23] = r8[al];
        memory16set(ss, bp - 20, memory16get(ss, bp - 20) + 1);
    case 0x9c2f:
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax] <<= 1;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        memory16set(es, r16[bx] + 14, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        mul16(memory16get(ss, bp - 20));
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 46, r16[dx]);
        memory16set(ss, bp - 48, r16[ax]);
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] |= r16[dx];
        if (r16[ax]) {
            pc = 0x9c85;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x06c1);
        sp++;
        sp++;
    case 0x9c85:
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 46));
        push(memory16get(ss, bp - 48));
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r16[si] = 0;
        pc = 0x9cc8;
        break;
    case 0x9c9c:
        if (memory[ss*16 + bp - 23] == 0x00) {
            pc = 0x9cc7;
            break;
        }
        r16[ax] = r16[si];
        mul16(memory16get(ss, bp - 20));
        r16[ax] += memory16get(ss, bp - 20);
        r16[ax]--;
        r16[dx] = 0;
        memory16set(ss, bp - 4, r16[dx]);
        memory16set(ss, bp - 6, r16[ax]);
        r8[al] = memory[ss*16 + bp - 23];
        r8[ah] = 0x00;
        r16[cx] = r16[ax];
        r8[al] = 0xff;
        r8[al] <<= r8[cl];
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r16[bx] += memory16get(ss, bp - 6);
        memory[es*16 + r16[bx]] = memory[es*16 + r16[bx]] & r8[al];
    case 0x9cc7:
        r16[si]++;
    case 0x9cc8:
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16[ax] > r16[si]) {
            pc = 0x9c9c;
            break;
        }
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x06c1);
        r16[si] = r16[ax];
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        r16[ax] <<= 1;
        push(r16[ax]);
        push(memory16get(ss, bp - 22));
        push(cs);
        yield* sub_7bd0();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x9d34;
            break;
        }
        r16[si]++;
        memory16set(ss, bp - 22, 0x0000);
        r16[ax] = r16[si];
        r16[dx] = 0;
        r16[cx] = 0;
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
    case 0x9d34:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 36, es);
        memory16set(ss, bp - 38, r16[bx]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 38, memory16get(ss, bp - 38) + r16[ax]);
        r16[dx] = memory16get(ss, bp - 36);
        r16[ax] = memory16get(ss, bp - 38);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[dx] = memory16get(ss, bp - 36);
        r16[ax] = memory16get(ss, bp - 38);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 18, r16[dx]);
        memory16set(es, r16[bx] + 16, r16[ax]);
        r16[si] = 0;
        pc = 0x9dd5;
        break;
    case 0x9d8c:
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r8[ah] = 0x00;
        r16[cx] = 0x0004;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ss*16 + bp - 43] = r8[al];
        r8[al] = memory[ss*16 + bp - 43];
        r8[ah] = 0x00;
        r16[bx] = memory16get(ss, bp - 42);
        es = memory16get(ss, bp - 42 + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 38);
        es = memory16get(ss, bp - 38 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 38, memory16get(ss, bp - 38) + 1);
        r16[bx] = memory16get(ss, bp - 48);
        es = memory16get(ss, bp - 48 + 2);
        r8[al] = memory[es*16 + r16[bx] + r16[si]];
        r8[al] &= 0x0f;
        memory[ss*16 + bp - 43] = r8[al];
        r8[al] = memory[ss*16 + bp - 43];
        r8[ah] = 0x00;
        r16[bx] = memory16get(ss, bp - 42);
        es = memory16get(ss, bp - 42 + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 38);
        es = memory16get(ss, bp - 38 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 38, memory16get(ss, bp - 38) + 1);
        r16[si]++;
    case 0x9dd5:
        if (r16[si] < memory16get(ss, bp - 18)) {
            pc = 0x9d8c;
            break;
        }
        r16[ax] = memory16get(ss, bp - 18);
        r16[ax] <<= 1;
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 10)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 10);
        r16[dx] += memory16get(ss, bp - 8) + flags.carry;
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        push(memory16get(ss, bp - 32));
        push(memory16get(ss, bp - 34));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        r16[di]++;
    case 0x9e15:
        if (r16[di] >= memory16get(ss, bp - 12)) {
            pc = 0x9e1d;
            break;
        }
        pc = 0x9b12;
        break;
    case 0x9e1d:
        push(memory16get(ss, bp - 28));
        push(memory16get(ss, bp - 30));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[ax] = memory16get(ss, bp - 16);
    case 0x9e37:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_9e3d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x002a;
        memory16set(ds, 0x919a, 0x0001);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x9e58;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x9e71;
            break;
        }
    case 0x9e58:
        r8[al] = memory[ss*16 + bp + 16];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(cs);
        yield* sub_8a8a();
        sp += 0x000a;
    case 0x9e71:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x9e91;
            break;
        }
        r8[al] = memory[ss*16 + bp + 16];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(cs);
        yield* sub_8d3a();
        sp += 0x000a;
    case 0x9e91:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x9ea2;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x9ea2;
            break;
        }
        pc = 0xa10a;
        break;
    case 0x9ea2:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(cs);
        yield* sub_6cbb();
        sp += 0x0004;
        memory[ss*16 + bp - 8] = r8[al];
        memory[ss*16 + bp - 7] = 0x00;
        r8[al] = 0x01;
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        r16[si] = r16[ax];
        memory[ss*16 + bp - 18] = 0x00;
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88e4();
        sp += 0x0006;
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x9eff;
        break;
    case 0x9ef5:
        push(r16[si]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        memory[ss*16 + bp - 6] += 1;
    case 0x9eff:
        if (memory[ss*16 + bp - 6] < 0x04) {
            pc = 0x9ef5;
            break;
        }
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88e4();
        sp += 0x0006;
    case 0x9f12:
        push(ds);
        r16[ax] = 0x0599;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0x9f2b;
            break;
        }
        pc = 0xa04f;
        break;
    case 0x9f2b:
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88e4();
        sp += 0x0006;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x5;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        r16[dx] = 0;
        mul16(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x5;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        r16[dx] = 0;
        mul16(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        flags.carry = (r16[ax] + memory16get(ss, bp - 16)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 16);
        r16[dx] += memory16get(ss, bp - 14) + flags.carry;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x5;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        flags.carry = (r16[ax] + memory16get(ss, bp - 16)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 16);
        r16[dx] += memory16get(ss, bp - 14) + flags.carry;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x5;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        flags.carry = (r16[ax] + memory16get(ss, bp - 16)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 16);
        r16[dx] += memory16get(ss, bp - 14) + flags.carry;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        push(ds);
        r16[ax] = 0x059e;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0x9ffc;
            break;
        }
        r16[ax] = 0x0014;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x2a;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
    case 0x9ffc:
        push(ds);
        r16[ax] = 0x05a3;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x16;
        push(r16[ax]);
        push(cs);
        cs = 0x1f63;
        yield* sub_1f63a();
        assert(cs == 0x06c1);
        sp += 0x0008;
        if (r16[ax]) {
            pc = 0xa028;
            break;
        }
        r16[dx] = memory16get(ss, bp - 14);
        r16[ax] = memory16get(ss, bp - 16);
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        memory16set(ss, bp - 14, 0x0000);
        memory16set(ss, bp - 16, 0x0000);
    case 0xa028:
        r16[ax] = memory16get(ss, bp - 16);
        r16[ax] |= memory16get(ss, bp - 14);
        if (r16[ax]) {
            pc = 0xa033;
            break;
        }
        pc = 0x9f12;
        break;
    case 0xa033:
        r16[ax] = memory16get(ss, bp - 16);
        r16[ax] |= memory16get(ss, bp - 14);
        if (r16[ax]) {
            pc = 0xa03e;
            break;
        }
        pc = 0x9f12;
        break;
    case 0xa03e:
        push(r16[si]);
        push(cs);
        yield* sub_6e15();
        sp++;
        sp++;
        flags.carry = memory16get(ss, bp - 16) < 0x0001;
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) - 0x0001);
        memory16set(ss, bp - 14, memory16get(ss, bp - 14) - flags.carry);
        pc = 0xa033;
        break;
    case 0xa04f:
        r8[al] = memory[ss*16 + bp - 8];
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        memory[es*16 + r16[bx] + 1] = r8[al];
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0xa0a3;
            break;
        }
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        if (memory[es*16 + r16[bx] + 4] != 0x00) {
            pc = 0xa0a3;
            break;
        }
        push(memory16get(ds, 0x8bb2));
        push(memory16get(ds, 0x8bb0));
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_30d5();
        assert(cs == 0x06c1);
        sp += 0x0008;
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3d95();
        assert(cs == 0x06c1);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x06c1);
        sp += 0x0006;
    case 0xa0a3:
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0xa0c6;
            break;
        }
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] != memory[ds*16 + 0x8f66]) {
            pc = 0xa0c6;
            break;
        }
        push(memory16get(ss, bp + 14));
        push(r16[bx]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x06c1);
        sp += 0x0006;
    case 0xa0c6:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r8[al] = memory[ss*16 + bp - 33];
        r8[ah] = 0x00;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 32];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_88fc();
        sp += 0x000a;
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0xa103;
            break;
        }
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r8[al] = memory[es*16 + r16[bx] + 4];
        if (r8[al] != memory[ds*16 + 0x8f66]) {
            pc = 0xa103;
            break;
        }
        push(memory16get(es, r16[bx] + 2));
        push(memory16get(es, r16[bx]));
        push(cs);
        cs = 0x0ba1;
        yield* sub_be10();
        assert(cs == 0x06c1);
        sp += 0x0004;
    case 0xa103:
        push(r16[si]);
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
    case 0xa10a:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a10f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        if (memory[ds*16 + 0x8db5] == 0x4e) {
            pc = 0xa181;
            break;
        }
        memory16set(ds, 0x919a, 0x0001);
        r8[al] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[dx] = memory16get(ds, 0x87d4);
        r16[ax] = memory16get(ds, 0x87d2);
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] |= r16[dx];
        if (!r16[ax]) {
            pc = 0xa165;
            break;
        }
        push(memory16get(ss, bp - 4));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
    case 0xa165:
        push(r16[si]);
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[bx] = memory16get(ss, bp + 8);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 36672, r16[dx]);
        memory16set(ds, r16[bx] + 36670, r16[ax]);
    case 0xa181:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a186() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[di] = memory16get(ss, bp + 10);
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 36342);
        r16[ax] |= memory16get(ds, r16[bx] + 36344);
        if (!r16[ax]) {
            pc = 0xa1b7;
            break;
        }
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 36344));
        push(memory16get(ds, r16[bx] + 36342));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
    case 0xa1b7:
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x06c1);
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r8[al] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_7530();
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[dx] = memory16get(ds, 0x87ce);
        r16[ax] = memory16get(ds, 0x87cc);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 36344, 0x0000);
        memory16set(ds, r16[bx] + 36342, 0x0000);
        if (r16[dx] > memory16get(ss, bp - 2)) {
            pc = 0xa21c;
            break;
        }
        if (r16[dx] != memory16get(ss, bp - 2)) {
            pc = 0xa1ff;
            break;
        }
        if (r16[ax] > memory16get(ss, bp - 4)) {
            pc = 0xa21c;
            break;
        }
    case 0xa1ff:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        flags.carry = r16[ax] < memory16get(ss, bp - 8);
        r16[ax] -= memory16get(ss, bp - 8);
        r8[tl] = r16[dx] < memory16get(ss, bp - 6) + flags.carry;
        r16[dx] -= memory16get(ss, bp - 6) + flags.carry;
        flags.carry = r8[tl];
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        if (flags.carry == 0 && r16[dx] == 0) {
            pc = 0xa225;
            break;
        }
        if (flags.carry) {
            pc = 0xa21c;
            break;
        }
        if (r16[ax] >= 0x4e20) {
            pc = 0xa225;
            break;
        }
    case 0xa21c:
        push(r16[si]);
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        pc = 0xa25d;
        break;
    case 0xa225:
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        push(memory16get(ss, bp - 8));
        push(r16[dx]);
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_6e6a();
        sp += 0x0008;
        push(r16[si]);
        push(cs);
        yield* sub_74f7();
        sp++;
        sp++;
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 36344, r16[dx]);
        memory16set(ds, r16[bx] + 36342, r16[ax]);
    case 0xa25d:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a263() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0012;
        push(ss);
        r16[ax] = bp - 0x8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0400;
        push(r16[ax]);
        r16[cx] = 0x0008;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x06c1);
        memory[ds*16 + 0x92c6] = 0x00;
        r16[ax] = 0x8001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x05a8;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x06c1);
        sp += 0x0006;
        memory16set(ss, bp - 18, r16[ax]);
        if (r16s[ax] >= 0) {
            pc = 0xa29d;
            break;
        }
        pc = 0xa349;
        break;
    case 0xa29d:
        push(r16[ax]);
        push(cs);
        cs = 0x1ee6;
        yield* sub_1ee6d();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 14, r16[dx]);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] += 0x000f;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ds, 0x8bf4, r16[dx]);
        memory16set(ds, 0x8bf2, r16[ax]);
        memory16set(ds, 0x8df4, r16[dx]);
        memory16set(ds, 0x8df2, r16[ax]);
        r16[ax] = r16[dx];
        memory16set(ss, bp - 10, r16[ax]);
        r16[di] = memory16get(ds, 0x8df2);
        r16[di] += 0x000f;
        r16[ax] = r16[di];
        r16[cx] = 0x0004;
        r16[ax] >>= r8[cl];
        r16[di] = r16[ax];
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + r16[di]);
        r16[di] = 0;
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = r16[di];
        memory16set(ds, 0x8df4, r16[dx]);
        memory16set(ds, 0x8df2, r16[ax]);
        push(memory16get(ss, bp - 16));
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 18));
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x06c1);
        sp += 0x0008;
        push(memory16get(ss, bp - 18));
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x06c1);
        sp++;
        sp++;
        memory16set(ss, bp - 12, 0x0000);
        r16[si] = 0;
        pc = 0xa327;
        break;
    case 0xa30d:
        r16[ax] = r16[si];
        r16[ax] += 0x0003;
        r16[bx] = memory16get(ds, 0x8df2);
        es = memory16get(ds, 0x8df2 + 2);
        r16[bx] += r16[ax];
        r8[al] = memory[es*16 + r16[bx]];
        if (r8[al] == memory[ss*16 + bp + r16[si] - 8]) {
            pc = 0xa326;
            break;
        }
        memory16set(ss, bp - 12, 0x0001);
    case 0xa326:
        r16[si]++;
    case 0xa327:
        if (r16[si] < 0x0008) {
            pc = 0xa30d;
            break;
        }
        if (memory16get(ss, bp - 12) == 0x0000) {
            pc = 0xa344;
            break;
        }
        push(memory16get(ds, 0x8bf4));
        push(memory16get(ds, 0x8bf2));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x06c1);
        sp += 0x0004;
        pc = 0xa349;
        break;
    case 0xa344:
        memory[ds*16 + 0x92c6] = 0x01;
    case 0xa349:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a34f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (memory[ds*16 + 0x87eb] == 0x00) {
            pc = 0xa35b;
            break;
        }
        push(cs);
        cs = 0x12f9;
        yield* sub_13be3();
        assert(cs == 0x0a34);
    case 0xa35b:
        if (memory[ds*16 + 0x05b6] == 0x00) {
            pc = 0xa373;
            break;
        }
        if (memory[ds*16 + 0x05b6] != 0x02) {
            pc = 0xa36e;
            break;
        }
        push(cs);
        cs = 0x127c;
        yield* sub_12886();
        assert(cs == 0x0a34);
    case 0xa36e:
        memory[ds*16 + 0x05b6] = 0x00;
    case 0xa373:
        cs = pop();
        return;
    } while (1);
}
function* sub_a374() {
    var pc = 0;
    do switch (pc) {
    case 0:
        push(r16[ax]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = 0x1f86;
        ds = bp;
        bp = sp;
        sp -= 0x0004;
        memory16set(ds, 0x8dd8, memory16get(ds, 0x8dd8) + 1);
        if (memory[ds*16 + 0x8b6a] != 0x00) {
            pc = 0xa395;
            break;
        }
        pc = 0xa4d6;
        break;
    case 0xa395:
        if (!(memory16get(ds, 0x8dd8) & 0x0001)) {
            pc = 0xa3ba;
            break;
        }
        push(memory16get(ds, 0x8d74));
        push(cs);
        cs = 0x0cb4;
        yield* sub_cba0();
        assert(cs == 0x0a34);
        sp++;
        sp++;
        push(cs);
        cs = 0x0cb4;
        yield* sub_cbee();
        assert(cs == 0x0a34);
        memory16set(ss, bp - 4, r16[ax]);
        push(cs);
        cs = 0x0cb4;
        yield* sub_cbf3();
        assert(cs == 0x0a34);
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0xa3c6;
        break;
    case 0xa3ba:
        r16[ax] = memory16get(ds, 0x87e8);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = memory16get(ds, 0x880c);
        memory16set(ss, bp - 2, r16[ax]);
    case 0xa3c6:
        r16[ax] = memory16get(ss, bp - 4);
        memory16set(ds, 0x87e8, r16[ax]);
        r16[ax] = memory16get(ss, bp - 2);
        memory16set(ds, 0x880c, r16[ax]);
        r16[di] = memory16get(ds, 0x8dc0);
        r16[di] = sar16(r16[di], 1);
        r16[di] = sar16(r16[di], 1);
        if (r16[di]) {
            pc = 0xa3e1;
            break;
        }
        r16[di] = 0x0001;
    case 0xa3e1:
        r16[ax] = memory16get(ss, bp - 4);
        if (r16s[ax] <= memory16gets(ds, 0x8dc0)) {
            pc = 0xa41f;
            break;
        }
        r16[ax] -= memory16get(ds, 0x8dc0);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv(r16[di]);
        r16[si] = r16[ax];
        if (signed16(r16[si]) <= signed16(0x0003)) {
            pc = 0xa3fb;
            break;
        }
        r16[si] = 0x0003;
    case 0xa3fb:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 1464);
        memory16set(ds, 0x8d60, memory16get(ds, 0x8d60) + r16[ax]);
        if (signed16(r16[si]) <= signed16(0x0002)) {
            pc = 0xa413;
            break;
        }
        memory[ds*16 + 0x8da6] = 0x01;
        pc = 0xa418;
        break;
    case 0xa413:
        memory[ds*16 + 0x8da6] = 0x00;
    case 0xa418:
        memory[ds*16 + 0x8baf] = 0x00;
        pc = 0xa454;
        break;
    case 0xa41f:
        r16[ax] = memory16get(ds, 0x8dc0);
        r16[ax] -= memory16get(ss, bp - 4);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv(r16[di]);
        r16[si] = r16[ax];
        if (signed16(r16[si]) <= signed16(0x0003)) {
            pc = 0xa432;
            break;
        }
        r16[si] = 0x0003;
    case 0xa432:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 1464);
        memory16set(ds, 0x8d60, memory16get(ds, 0x8d60) - r16[ax]);
        if (signed16(r16[si]) <= signed16(0x0002)) {
            pc = 0xa44a;
            break;
        }
        memory[ds*16 + 0x8baf] = 0x01;
        pc = 0xa44f;
        break;
    case 0xa44a:
        memory[ds*16 + 0x8baf] = 0x00;
    case 0xa44f:
        memory[ds*16 + 0x8da6] = 0x00;
    case 0xa454:
        r16[di] = memory16get(ds, 0x8b9a);
        r16[di] = sar16(r16[di], 1);
        r16[di] = sar16(r16[di], 1);
        if (r16[di]) {
            pc = 0xa463;
            break;
        }
        r16[di] = 0x0001;
    case 0xa463:
        r16[ax] = memory16get(ss, bp - 2);
        if (r16s[ax] <= memory16gets(ds, 0x8b9a)) {
            pc = 0xa4a1;
            break;
        }
        r16[ax] -= memory16get(ds, 0x8b9a);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv(r16[di]);
        r16[si] = r16[ax];
        if (signed16(r16[si]) <= signed16(0x0003)) {
            pc = 0xa47d;
            break;
        }
        r16[si] = 0x0003;
    case 0xa47d:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 1464);
        memory16set(ds, 0x8db8, memory16get(ds, 0x8db8) + r16[ax]);
        if (signed16(r16[si]) <= signed16(0x0002)) {
            pc = 0xa495;
            break;
        }
        memory[ds*16 + 0x92b6] = 0x01;
        pc = 0xa49a;
        break;
    case 0xa495:
        memory[ds*16 + 0x92b6] = 0x00;
    case 0xa49a:
        memory[ds*16 + 0x8db4] = 0x00;
        pc = 0xa4d6;
        break;
    case 0xa4a1:
        r16[ax] = memory16get(ds, 0x8b9a);
        r16[ax] -= memory16get(ss, bp - 2);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv(r16[di]);
        r16[si] = r16[ax];
        if (signed16(r16[si]) <= signed16(0x0003)) {
            pc = 0xa4b4;
            break;
        }
        r16[si] = 0x0003;
    case 0xa4b4:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 1464);
        memory16set(ds, 0x8db8, memory16get(ds, 0x8db8) - r16[ax]);
        if (signed16(r16[si]) <= signed16(0x0002)) {
            pc = 0xa4cc;
            break;
        }
        memory[ds*16 + 0x8db4] = 0x01;
        pc = 0xa4d1;
        break;
    case 0xa4cc:
        memory[ds*16 + 0x8db4] = 0x00;
    case 0xa4d1:
        memory[ds*16 + 0x92b6] = 0x00;
    case 0xa4d6:
        if (memory[ds*16 + 0x8ddf] == 0x00) {
            pc = 0xa514;
            break;
        }
        memory16set(ds, 0x87fc, 0x0003);
        push(ds);
        r16[ax] = 0x87ec;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87fc;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0a34);
        sp += 0x000a;
        if (memory[ds*16 + 0x8da7] == 0x00) {
            pc = 0xa50e;
            break;
        }
        r16[ax] = memory16get(ds, 0x87f0);
        r16[ax] >>= 1;
        memory16set(ds, 0x8d60, r16[ax]);
        r16[ax] = memory16get(ds, 0x87f2);
        memory16set(ds, 0x8db8, r16[ax]);
    case 0xa50e:
        r16[ax] = memory16get(ds, 0x87ee);
        memory16set(ds, 0x880e, r16[ax]);
    case 0xa514:
        if (memory[ds*16 + 0x8da7] != 0x00) {
            pc = 0xa566;
            break;
        }
        if (memory[ds*16 + 0x8b6a] != 0x00) {
            pc = 0xa566;
            break;
        }
        if (memory[ds*16 + 0x8dd1] == 0x00) {
            pc = 0xa534;
            break;
        }
        r8[al] = memory[ds*16 + 0x92c2];
        r8[ah] = 0x00;
        memory16set(ds, 0x8d60, memory16get(ds, 0x8d60) - r16[ax]);
        pc = 0xa544;
        break;
    case 0xa534:
        if (memory[ds*16 + 0x8de9] == 0x00) {
            pc = 0xa544;
            break;
        }
        r8[al] = memory[ds*16 + 0x92c2];
        r8[ah] = 0x00;
        memory16set(ds, 0x8d60, memory16get(ds, 0x8d60) + r16[ax]);
    case 0xa544:
        if (memory[ds*16 + 0x8bf1] == 0x00) {
            pc = 0xa556;
            break;
        }
        r8[al] = memory[ds*16 + 0x92c2];
        r8[ah] = 0x00;
        memory16set(ds, 0x8db8, memory16get(ds, 0x8db8) - r16[ax]);
        pc = 0xa566;
        break;
    case 0xa556:
        if (memory[ds*16 + 0x8b9c] == 0x00) {
            pc = 0xa566;
            break;
        }
        r8[al] = memory[ds*16 + 0x92c2];
        r8[ah] = 0x00;
        memory16set(ds, 0x8db8, memory16get(ds, 0x8db8) + r16[ax]);
    case 0xa566:
        if (memory16gets(ds, 0x8d60) >= signed16(0x0000)) {
            pc = 0xa573;
            break;
        }
        memory16set(ds, 0x8d60, 0x0000);
    case 0xa573:
        if (memory16gets(ds, 0x8d60) <= signed16(0x0133)) {
            pc = 0xa581;
            break;
        }
        memory16set(ds, 0x8d60, 0x0133);
    case 0xa581:
        if (memory16gets(ds, 0x8db8) >= signed16(0x0000)) {
            pc = 0xa58e;
            break;
        }
        memory16set(ds, 0x8db8, 0x0000);
    case 0xa58e:
        if (memory16gets(ds, 0x8db8) <= signed16(0x00c7)) {
            pc = 0xa59c;
            break;
        }
        memory16set(ds, 0x8db8, 0x00c7);
    case 0xa59c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[ax] = pop();
        stop();
        return;
    } while (1);
}
function* sub_a5a8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        push(r16[ax]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = 0x1f86;
        ds = bp;
        memory16set(ds, 0x8dd8, memory16get(ds, 0x8dd8) + 1);
        if (memory[ds*16 + 0x8ddf] != 0x00) {
            pc = 0xa5c4;
            break;
        }
        pc = 0xa668;
        break;
    case 0xa5c4:
        memory16set(ds, 0x87fc, 0x0003);
        push(ds);
        r16[ax] = 0x87ec;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87fc;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0a34);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x87ee);
        memory16set(ds, 0x880e, r16[ax]);
        if (memory[ds*16 + 0x8da7] != 0x00) {
            pc = 0xa5f0;
            break;
        }
        pc = 0xa668;
        break;
    case 0xa5f0:
        r16[si] = memory16get(ds, 0x87f0);
        r16[di] = memory16get(ds, 0x87f2);
        r8[al] = 0x00;
        memory[ds*16 + 0x8db4] = r8[al];
        memory[ds*16 + 0x92b6] = r8[al];
        memory[ds*16 + 0x8baf] = r8[al];
        memory[ds*16 + 0x8da6] = r8[al];
        if (r16[si] <= 0x014a) {
            pc = 0xa613;
            break;
        }
        memory[ds*16 + 0x8da6] = 0x01;
        pc = 0xa61e;
        break;
    case 0xa613:
        if (r16[si] >= 0x0136) {
            pc = 0xa61e;
            break;
        }
        memory[ds*16 + 0x8baf] = 0x01;
    case 0xa61e:
        if (r16[di] <= 0x006e) {
            pc = 0xa62a;
            break;
        }
        memory[ds*16 + 0x92b6] = 0x01;
        pc = 0xa634;
        break;
    case 0xa62a:
        if (r16[di] >= 0x005a) {
            pc = 0xa634;
            break;
        }
        memory[ds*16 + 0x8db4] = 0x01;
    case 0xa634:
        if (memory[ds*16 + 0x87e5] == 0x00) {
            pc = 0xa668;
            break;
        }
        memory[ds*16 + 0x87e5] = 0x00;
        memory16set(ds, 0x87fc, 0x0004);
        memory16set(ds, 0x8800, 0x0140);
        memory16set(ds, 0x8802, 0x0064);
        push(ds);
        r16[ax] = 0x87ec;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x87fc;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0a34);
        sp += 0x000a;
    case 0xa668:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[ax] = pop();
        stop();
        return;
    } while (1);
}
function* sub_a672() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    memory16set(ds, 0x92e0, 0x0007);
    memory16set(ds, 0x92e4, 0x0000);
    memory16set(ds, 0x92e6, 0x0280);
    push(ds);
    r16[ax] = 0x8d62;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x92e0;
    push(r16[ax]);
    r16[ax] = 0x0033;
    push(r16[ax]);
    push(cs);
    cs = 0x1f0d;
    yield* sub_1f0d4();
    assert(cs == 0x0a34);
    sp += 0x000a;
    memory16set(ds, 0x92e0, 0x0008);
    memory16set(ds, 0x92e4, 0x0000);
    memory16set(ds, 0x92e6, 0x00c8);
    push(ds);
    r16[ax] = 0x8d62;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x92e0;
    push(r16[ax]);
    r16[ax] = 0x0033;
    push(r16[ax]);
    push(cs);
    cs = 0x1f0d;
    yield* sub_1f0d4();
    assert(cs == 0x0a34);
    sp += 0x000a;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_a6c3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8b94] != 0x00) {
            pc = 0xa70b;
            break;
        }
        r16[ax] = 0x0034;
        r16[dx] = cs;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0x001c;
        push(r16[ax]);
        push(cs);
        cs = 0x1f09;
        yield* sub_1f0af();
        assert(cs == 0x0a34);
        sp += 0x0006;
        r16[ax] = memory16get(ds, 0x8d60);
        memory16set(ds, 0x8a28, r16[ax]);
        r16[ax] = memory16get(ds, 0x8db8);
        memory16set(ds, 0x91a0, r16[ax]);
        push(r16[ax]);
        push(memory16get(ds, 0x8a28));
        push(cs);
        cs = 0x0a34;
        yield* sub_b0e7();
        assert(cs == 0x0a34);
        sp += 0x0004;
        push(memory16get(ds, 0x91a0));
        push(memory16get(ds, 0x8a28));
        push(cs);
        cs = 0x0a34;
        yield* sub_b384();
        assert(cs == 0x0a34);
        sp += 0x0004;
        memory[ds*16 + 0x8b94] = 0x01;
    case 0xa70b:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a70c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0xa73b;
            break;
        }
        r16[ax] = 0x0268;
        r16[dx] = cs;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0x001c;
        push(r16[ax]);
        push(cs);
        cs = 0x1f09;
        yield* sub_1f0af();
        assert(cs == 0x0a34);
        sp += 0x0006;
        push(memory16get(ds, 0x91a0));
        push(memory16get(ds, 0x8a28));
        push(cs);
        cs = 0x0a34;
        yield* sub_b6f4();
        assert(cs == 0x0a34);
        sp += 0x0004;
        memory[ds*16 + 0x8b94] = 0x00;
    case 0xa73b:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a73c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0xa78e;
            break;
        }
        r16[ax] = memory16get(ds, 0x8a28);
        if (r16[ax] != memory16get(ds, 0x8d60)) {
            pc = 0xa755;
            break;
        }
        r16[ax] = memory16get(ds, 0x91a0);
        if (r16[ax] == memory16get(ds, 0x8db8)) {
            pc = 0xa78e;
            break;
        }
    case 0xa755:
        push(memory16get(ds, 0x91a0));
        push(memory16get(ds, 0x8a28));
        push(cs);
        cs = 0x0a34;
        yield* sub_b6f4();
        assert(cs == 0x0a34);
        sp += 0x0004;
        r16[ax] = memory16get(ds, 0x8d60);
        memory16set(ds, 0x8a28, r16[ax]);
        r16[ax] = memory16get(ds, 0x8db8);
        memory16set(ds, 0x91a0, r16[ax]);
        push(r16[ax]);
        push(memory16get(ds, 0x8a28));
        push(cs);
        cs = 0x0a34;
        yield* sub_b0e7();
        assert(cs == 0x0a34);
        sp += 0x0004;
        push(memory16get(ds, 0x91a0));
        push(memory16get(ds, 0x8a28));
        push(cs);
        cs = 0x0a34;
        yield* sub_b384();
        assert(cs == 0x0a34);
        sp += 0x0004;
    case 0xa78e:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a78f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        push(cs);
        yield* sub_a34f();
        push(cs);
        yield* sub_a73c();
        if (memory[ds*16 + 0x8dc4] == 0x00) {
            pc = 0xa7e8;
            break;
        }
        push(memory16get(ds, 0x8d74));
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x0cb4;
        yield* sub_cbf8();
        assert(cs == 0x0a34);
        sp += 0x0004;
        memory[ss*16 + bp - 1] = r8[al];
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0xa7dc;
            break;
        }
        r8[al] = 0x01;
        memory[ds*16 + 0x8b6a] = r8[al];
        memory[ds*16 + 0x92b5] = r8[al];
        r16[ax] = 0;
        memory16set(ds, 0x880e, r16[ax]);
        memory[ds*16 + 0x8da7] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8de9] = r8[al];
        memory[ds*16 + 0x8dd1] = r8[al];
        memory[ds*16 + 0x8bf1] = r8[al];
        memory[ds*16 + 0x8b9c] = r8[al];
        pc = 0xa7e8;
        break;
    case 0xa7dc:
        if (memory[ds*16 + 0x8b6a] == 0x00) {
            pc = 0xa7e8;
            break;
        }
        memory[ds*16 + 0x92b5] = 0x00;
    case 0xa7e8:
        if (memory[ds*16 + 0x8ddf] == 0x00) {
            pc = 0xa85f;
            break;
        }
        if (memory[ds*16 + 0x8db3] != 0x00) {
            pc = 0xa85f;
            break;
        }
        r8[al] = memory[ds*16 + 0x880e];
        r8[al] &= 0x01;
        memory[ss*16 + bp - 1] = r8[al];
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0xa853;
            break;
        }
        if (memory[ds*16 + 0x8da7] != 0x00) {
            pc = 0xa844;
            break;
        }
        memory16set(ds, 0x92e0, 0x0004);
        r16[ax] = memory16get(ds, 0x8d60);
        r16[ax] <<= 1;
        memory16set(ds, 0x92e4, r16[ax]);
        r16[ax] = memory16get(ds, 0x8db8);
        memory16set(ds, 0x92e6, r16[ax]);
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0a34);
        sp += 0x000a;
        r8[al] = 0x00;
        memory[ds*16 + 0x8de9] = r8[al];
        memory[ds*16 + 0x8dd1] = r8[al];
        memory[ds*16 + 0x8bf1] = r8[al];
        memory[ds*16 + 0x8b9c] = r8[al];
    case 0xa844:
        r8[al] = 0x01;
        memory[ds*16 + 0x92b5] = r8[al];
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = 0x00;
        pc = 0xa85f;
        break;
    case 0xa853:
        if (memory[ds*16 + 0x8da7] == 0x00) {
            pc = 0xa85f;
            break;
        }
        memory[ds*16 + 0x92b5] = 0x00;
    case 0xa85f:
        r8[al] = memory[ds*16 + 0x92b5];
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a99a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r8[al] = memory[ss*16 + bp + 8];
        r8[ah] = 0x00;
        r16[dx] = 0x0032;
        mul16(r16[dx]);
        r16[si] = r16[ax];
    case 0xa9aa:
        push(cs);
        yield* sub_a78f();
        sp = bp;
        if (r8[al]) {
            pc = 0xa9aa;
            break;
        }
    case 0xa9b4:
        r16[ax] = r16[si];
        r16[si]--;
        if (!r16[ax]) {
            pc = 0xa9d2;
            break;
        }
        push(cs);
        yield* sub_a78f();
        sp = bp;
        if (r8[al]) {
            pc = 0xa9d2;
            break;
        }
        r16[ax] = 0x0014;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0a34);
        sp = bp;
        pc = 0xa9b4;
        break;
    case 0xa9d2:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_a9d5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
    case 0xa9d5:
        push(cs);
        yield* sub_a78f();
        if (r8[al]) {
            pc = 0xa9d5;
            break;
        }
    case 0xa9dd:
        yield* sync();
        push(cs);
        yield* sub_a78f();
    case 0xa9e5:
        push(cs);
        yield* sub_a78f();
        if (r8[al]) {
            pc = 0xa9e5;
            break;
        }
        push(cs);
        cs = 0x023f;
        yield* sub_2445();
        assert(cs == 0x0a34);
        cs = pop();
        return;
    } while (1);
}
function* sub_a9f3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        push(cs);
        yield* sub_a78f();
        memory[ss*16 + bp - 1] = r8[al];
        if (memory[ds*16 + 0x8b6a] != 0x00) {
            pc = 0xaa0b;
            break;
        }
        pc = 0xaa88;
        break;
    case 0xaa0b:
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0xaa15;
            break;
        }
        pc = 0xaa88;
        break;
    case 0xaa15:
        push(memory16get(ds, 0x8d74));
        push(cs);
        cs = 0x0cb4;
        yield* sub_cba0();
        assert(cs == 0x0a34);
        sp++;
        sp++;
        push(cs);
        cs = 0x0cb4;
        yield* sub_cbee();
        assert(cs == 0x0a34);
        r16[si] = r16[ax];
        push(cs);
        cs = 0x0cb4;
        yield* sub_cbf3();
        assert(cs == 0x0a34);
        r16[di] = r16[ax];
        memory16set(ds, 0x8bf6, r16[si]);
        memory16set(ds, 0x8b96, r16[di]);
        r8[al] = 0x00;
        memory[ds*16 + 0x92b6] = r8[al];
        memory[ds*16 + 0x8db4] = r8[al];
        memory[ds*16 + 0x8da6] = r8[al];
        memory[ds*16 + 0x8baf] = r8[al];
        r16[ax] = memory16get(ds, 0x8dc0);
        r16[ax] = sar16(r16[ax], 1);
        if (r16s[ax] <= signed16(r16[si])) {
            pc = 0xaa54;
            break;
        }
        memory[ds*16 + 0x8baf] = 0x01;
        pc = 0xaa66;
        break;
    case 0xaa54:
        r16[ax] = memory16get(ds, 0x8dc0);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] += memory16get(ds, 0x8dc0);
        if (r16s[ax] >= signed16(r16[si])) {
            pc = 0xaa66;
            break;
        }
        memory[ds*16 + 0x8da6] = 0x01;
    case 0xaa66:
        r16[ax] = memory16get(ds, 0x8b9a);
        r16[ax] = sar16(r16[ax], 1);
        if (r16s[ax] <= signed16(r16[di])) {
            pc = 0xaa76;
            break;
        }
        memory[ds*16 + 0x8db4] = 0x01;
        pc = 0xaa88;
        break;
    case 0xaa76:
        r16[ax] = memory16get(ds, 0x8b9a);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] += memory16get(ds, 0x8b9a);
        if (r16s[ax] >= signed16(r16[di])) {
            pc = 0xaa88;
            break;
        }
        memory[ds*16 + 0x92b6] = 0x01;
    case 0xaa88:
        if (memory[ds*16 + 0x8da7] == 0x00) {
            pc = 0xaa94;
            break;
        }
        memory[ds*16 + 0x87e5] = 0x01;
    case 0xaa94:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_aa9a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        push(r16[ax]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = 0x1f86;
        ds = bp;
        bp = sp;
        sp--;
        sp--;
        r8[al] = in8(0x60);
        memory[ds*16 + 0x8b95] = r8[al];
        r8[al] = in8(0x61);
        memory[ss*16 + bp - 2] = r8[al];
        if (!(memory[ds*16 + 0x8b95] & 0x80)) {
            pc = 0xaac5;
            break;
        }
        r8[al] = 0x00;
        memory[ds*16 + 0x87e4] = r8[al];
        memory[ds*16 + 0x87e6] = r8[al];
    case 0xaac5:
        if (memory[ds*16 + 0x8b95] != 0x01) {
            pc = 0xaad1;
            break;
        }
        memory[ds*16 + 0x87eb] = 0x01;
    case 0xaad1:
        if (memory[ds*16 + 0x87e6] != 0x00) {
            pc = 0xaae3;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x1d) {
            pc = 0xaae3;
            break;
        }
        memory[ds*16 + 0x87e6] += 1;
    case 0xaae3:
        if (memory[ds*16 + 0x87e6] != 0x01) {
            pc = 0xaaf5;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x38) {
            pc = 0xaaf5;
            break;
        }
        memory[ds*16 + 0x87e6] += 1;
    case 0xaaf5:
        if (memory[ds*16 + 0x87e6] != 0x02) {
            pc = 0xab08;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x53) {
            pc = 0xab08;
            break;
        }
        push(cs);
        cs = 0x0ba1;
        yield* sub_bacb();
        assert(cs == 0x0a34);
    case 0xab08:
        memory[ss*16 + bp - 1] = 0x00;
        r8[al] = memory[ds*16 + 0x8b95];
        if (r8[al] != memory[ds*16 + 0x8e1e]) {
            pc = 0xab1c;
            break;
        }
        memory[ds*16 + 0x87ea] = 0x01;
        pc = 0xab21;
        break;
    case 0xab1c:
        memory[ds*16 + 0x87ea] = 0x00;
    case 0xab21:
        if (memory[ds*16 + 0x8b95] == 0x4b) {
            pc = 0xab2f;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x7a) {
            pc = 0xab42;
            break;
        }
    case 0xab2f:
        r8[al] = 0x01;
        memory[ss*16 + bp - 1] = r8[al];
        memory[ds*16 + 0x8dd1] = r8[al];
        memory[ds*16 + 0x8baf] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8de9] = r8[al];
        memory[ds*16 + 0x8da6] = r8[al];
    case 0xab42:
        if (memory[ds*16 + 0x8b95] == 0xcb) {
            pc = 0xab50;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xfa) {
            pc = 0xab58;
            break;
        }
    case 0xab50:
        r8[al] = 0x00;
        memory[ds*16 + 0x8dd1] = r8[al];
        memory[ds*16 + 0x8baf] = r8[al];
    case 0xab58:
        if (memory[ds*16 + 0x8b95] == 0x4d) {
            pc = 0xab66;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x79) {
            pc = 0xab79;
            break;
        }
    case 0xab66:
        r8[al] = 0x01;
        memory[ss*16 + bp - 1] = r8[al];
        memory[ds*16 + 0x8de9] = r8[al];
        memory[ds*16 + 0x8da6] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8dd1] = r8[al];
        memory[ds*16 + 0x8baf] = r8[al];
    case 0xab79:
        if (memory[ds*16 + 0x8b95] == 0xcd) {
            pc = 0xab87;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xf9) {
            pc = 0xab8f;
            break;
        }
    case 0xab87:
        r8[al] = 0x00;
        memory[ds*16 + 0x8de9] = r8[al];
        memory[ds*16 + 0x8da6] = r8[al];
    case 0xab8f:
        if (memory[ds*16 + 0x8b95] == 0x48) {
            pc = 0xab9d;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x7c) {
            pc = 0xabb0;
            break;
        }
    case 0xab9d:
        r8[al] = 0x01;
        memory[ss*16 + bp - 1] = r8[al];
        memory[ds*16 + 0x8bf1] = r8[al];
        memory[ds*16 + 0x8db4] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8b9c] = r8[al];
        memory[ds*16 + 0x92b6] = r8[al];
    case 0xabb0:
        if (memory[ds*16 + 0x8b95] == 0xc8) {
            pc = 0xabbe;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xfc) {
            pc = 0xabc6;
            break;
        }
    case 0xabbe:
        r8[al] = 0x00;
        memory[ds*16 + 0x8bf1] = r8[al];
        memory[ds*16 + 0x8db4] = r8[al];
    case 0xabc6:
        if (memory[ds*16 + 0x8b95] == 0x50) {
            pc = 0xabd4;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x7b) {
            pc = 0xabe7;
            break;
        }
    case 0xabd4:
        r8[al] = 0x01;
        memory[ss*16 + bp - 1] = r8[al];
        memory[ds*16 + 0x8b9c] = r8[al];
        memory[ds*16 + 0x92b6] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8bf1] = r8[al];
        memory[ds*16 + 0x8db4] = r8[al];
    case 0xabe7:
        if (memory[ds*16 + 0x8b95] == 0xd0) {
            pc = 0xabf5;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xfb) {
            pc = 0xabfd;
            break;
        }
    case 0xabf5:
        r8[al] = 0x00;
        memory[ds*16 + 0x8b9c] = r8[al];
        memory[ds*16 + 0x92b6] = r8[al];
    case 0xabfd:
        if (memory[ds*16 + 0x8b95] == 0x39) {
            pc = 0xac0b;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x77) {
            pc = 0xac1b;
            break;
        }
    case 0xac0b:
        memory[ds*16 + 0x92b5] = 0x01;
        r16[ax] = 0;
        memory16set(ds, 0x880e, r16[ax]);
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = r8[al];
    case 0xac1b:
        if (memory[ds*16 + 0x8b95] == 0xb9) {
            pc = 0xac29;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xf7) {
            pc = 0xac2e;
            break;
        }
    case 0xac29:
        memory[ds*16 + 0x92b5] = 0x00;
    case 0xac2e:
        if (memory[ds*16 + 0x8b95] != 0x7e) {
            pc = 0xac42;
            break;
        }
        r8[al] = 0x01;
        memory[ds*16 + 0x92b5] = r8[al];
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = 0x00;
    case 0xac42:
        if (memory[ds*16 + 0x8b95] != 0xfe) {
            pc = 0xac4e;
            break;
        }
        memory[ds*16 + 0x92b5] = 0x00;
    case 0xac4e:
        if (memory[ds*16 + 0x8b95] == 0x2a) {
            pc = 0xac5c;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x78) {
            pc = 0xac6c;
            break;
        }
    case 0xac5c:
        memory[ds*16 + 0x8d9e] = 0x01;
        r16[ax] = 0;
        memory16set(ds, 0x880e, r16[ax]);
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = r8[al];
    case 0xac6c:
        if (memory[ds*16 + 0x8b95] == 0xaa) {
            pc = 0xac7a;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xf8) {
            pc = 0xac7f;
            break;
        }
    case 0xac7a:
        memory[ds*16 + 0x8d9e] = 0x00;
    case 0xac7f:
        if (memory[ds*16 + 0x8b95] != 0x7d) {
            pc = 0xac93;
            break;
        }
        r8[al] = 0x01;
        memory[ds*16 + 0x8d9e] = r8[al];
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = 0x00;
    case 0xac93:
        if (memory[ds*16 + 0x8b95] != 0xfd) {
            pc = 0xac9f;
            break;
        }
        memory[ds*16 + 0x8d9e] = 0x00;
    case 0xac9f:
        if (memory[ds*16 + 0x8b94] == 0x00) {
            pc = 0xaccc;
            break;
        }
        if (memory[ds*16 + 0x8b95] == 0x2a) {
            pc = 0xacb4;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0x36) {
            pc = 0xacb9;
            break;
        }
    case 0xacb4:
        memory[ds*16 + 0x92c2] = 0x01;
    case 0xacb9:
        if (memory[ds*16 + 0x8b95] == 0xaa) {
            pc = 0xacc7;
            break;
        }
        if (memory[ds*16 + 0x8b95] != 0xb6) {
            pc = 0xaccc;
            break;
        }
    case 0xacc7:
        memory[ds*16 + 0x92c2] = 0x08;
    case 0xaccc:
        r8[al] = memory[ds*16 + 0x8b95];
        if (r8[al] != memory[ds*16 + 0x8bd3]) {
            pc = 0xacef;
            break;
        }
        memory[ds*16 + 0x919e] = memory[ds*16 + 0x919e] ^ 0x01;
        if (memory[ds*16 + 0x919e] == 0x00) {
            pc = 0xace9;
            break;
        }
        memory16set(ds, 0x88d6, 0x007f);
        pc = 0xacef;
        break;
    case 0xace9:
        memory16set(ds, 0x88d6, 0x0000);
    case 0xacef:
        r8[al] = memory[ds*16 + 0x8b95];
        if (r8[al] != memory[ds*16 + 0x8b6b]) {
            pc = 0xacfd;
            break;
        }
        memory[ds*16 + 0x9091] = memory[ds*16 + 0x9091] ^ 0x01;
    case 0xacfd:
        r8[al] = memory[ss*16 + bp - 2];
        r8[al] |= 0x80;
        out8(0x61, r8[al]);
        r8[al] = memory[ss*16 + bp - 2];
        out8(0x61, r8[al]);
        r8[al] = 0x20;
        out8(0x20, r8[al]);
        if (memory[ss*16 + bp - 1] == 0x00) {
            pc = 0xad1f;
            break;
        }
        r16[ax] = 0;
        memory16set(ds, 0x880e, r16[ax]);
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = r8[al];
    case 0xad1f:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[ax] = pop();
        stop();
        return;
    } while (1);
}
function* sub_ad5a() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f09f();
    assert(cs == 0x0a34);
    sp++;
    sp++;
    memory16set(ds, 0x8a68, r16[dx]);
    memory16set(ds, 0x8a66, r16[ax]);
    r16[ax] = 0x001c;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f09f();
    assert(cs == 0x0a34);
    sp++;
    sp++;
    memory16set(ds, 0x8a24, r16[dx]);
    memory16set(ds, 0x8a22, r16[ax]);
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f09f();
    assert(cs == 0x0a34);
    sp++;
    sp++;
    memory16set(ds, 0x8ba0, r16[dx]);
    memory16set(ds, 0x8b9e, r16[ax]);
    r8[al] = 0x00;
    memory[ds*16 + 0x87eb] = r8[al];
    memory[ds*16 + 0x87e4] = r8[al];
    memory[ds*16 + 0x87e6] = r8[al];
    r8[al] = 0x00;
    memory[ds*16 + 0x92b6] = r8[al];
    memory[ds*16 + 0x8db4] = r8[al];
    memory[ds*16 + 0x8baf] = r8[al];
    memory[ds*16 + 0x8da6] = r8[al];
    r8[al] = 0x00;
    memory[ds*16 + 0x8de9] = r8[al];
    memory[ds*16 + 0x8dd1] = r8[al];
    memory[ds*16 + 0x8bf1] = r8[al];
    memory[ds*16 + 0x8b9c] = r8[al];
    r16[ax] = 0x075a;
    r16[dx] = cs;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0a34);
    sp += 0x0006;
    r16[ax] = 0x0268;
    r16[dx] = cs;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x001c;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0a34);
    sp += 0x0006;
    r16[ax] = 0x0019;
    r16[dx] = 0x0ba1;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0a34);
    sp += 0x0006;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_adf2() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(memory16get(ds, 0x8a68));
    push(memory16get(ds, 0x8a66));
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0a34);
    sp += 0x0006;
    push(memory16get(ds, 0x8a24));
    push(memory16get(ds, 0x8a22));
    r16[ax] = 0x001c;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0a34);
    sp += 0x0006;
    push(memory16get(ds, 0x8ba0));
    push(memory16get(ds, 0x8b9e));
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0a34);
    sp += 0x0006;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_ae2f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001e;
        r16[di] = memory16get(ss, bp + 10);
        if (signed16(r16[di]) < signed16(0x0134)) {
            pc = 0xae43;
            break;
        }
        pc = 0xaf5b;
        break;
    case 0xae43:
        if (memory16gets(ss, bp + 12) < signed16(0x00c8)) {
            pc = 0xae4d;
            break;
        }
        pc = 0xaf5b;
        break;
    case 0xae4d:
        if (signed16(r16[di]) >= 0) {
            pc = 0xae54;
            break;
        }
        pc = 0xaf5b;
        break;
    case 0xae54:
        if (memory16gets(ss, bp + 12) >= signed16(0x0000)) {
            pc = 0xae5d;
            break;
        }
        pc = 0xaf5b;
        break;
    case 0xae5d:
        r16[bx] = memory16get(ds, 0x8dee);
        es = memory16get(ds, 0x8dee + 2);
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        memory16set(ss, bp - 6, 0x0002);
        r16[si] = 0x00c8;
        r16[si] -= memory16get(ss, bp + 12);
        if (r16[si] <= 0x000c) {
            pc = 0xae7a;
            break;
        }
        r16[si] = 0x000c;
    case 0xae7a:
        memory16set(ss, bp - 8, 0x0000);
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xaec3;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xae9b; break;
        case 2: pc = 0xaea5; break;
        case 4: pc = 0xaeaf; break;
        case 6: pc = 0xaeb9; break;
            default:
            assert(0);
        }
        break;
    case 0xae9b:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xaecb;
        break;
    case 0xaea5:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xaecb;
        break;
    case 0xaeaf:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xaecb;
        break;
    case 0xaeb9:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xaecb;
        break;
    case 0xaec3:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xaecb:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[ax] = r16[di];
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory[ss*16 + bp - 22] = r8[dl];
        if (memory[ss*16 + bp - 22] != 0x00) {
            pc = 0xaeee;
            break;
        }
        memory[ss*16 + bp - 21] = 0x00;
        pc = 0xaef6;
        break;
    case 0xaeee:
        r8[al] = 0x08;
        r8[al] -= memory[ss*16 + bp - 22];
        memory[ss*16 + bp - 21] = r8[al];
    case 0xaef6:
        r8[al] = memory[ss*16 + bp - 21];
        r8[ah] = 0x00;
        r16[cx] = 0x0008;
        r16[ax] <<= r8[cl];
        r8[dl] = memory[ss*16 + bp - 22];
        r8[dh] = 0x00;
        r16[ax] += r16[dx];
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[bx] = r16[cx];
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 12, r16[dx]);
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 26, r16[bx]);
        r16[ax] = memory16get(ss, bp - 30);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 16, r16[ax]);
        push(memory16get(ss, bp - 14));
        push(r16[ax]);
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 20));
        push(r16[si]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x0cc2;
        yield* sub_d711();
        assert(cs == 0x0a34);
        sp += 0x0010;
    case 0xaf5b:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_af61() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0014;
        r16[si] = 0x00c8;
        r16[si] -= memory16get(ss, bp + 12);
        if (r16[si] <= 0x000c) {
            pc = 0xaf77;
            break;
        }
        r16[si] = 0x000c;
    case 0xaf77:
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xafbb;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xaf93; break;
        case 2: pc = 0xaf9d; break;
        case 4: pc = 0xafa7; break;
        case 6: pc = 0xafb1; break;
            default:
            assert(0);
        }
        break;
    case 0xaf93:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xafc3;
        break;
    case 0xaf9d:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xafc3;
        break;
    case 0xafa7:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xafc3;
        break;
    case 0xafb1:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xafc3;
        break;
    case 0xafbb:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xafc3:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 6, r16[dx]);
        r16[bx] = memory16get(ss, bp - 20);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 20, r16[bx]);
        r16[bx] = memory16get(ds, 0x91b0);
        es = memory16get(ds, 0x91b0 + 2);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[di] = memory16get(ss, bp - 20);
        r16[ax] = memory16get(ss, bp - 18);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        memory16set(ss, bp - 8, r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(r16[ax]);
        push(r16[di]);
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0cc2;
        yield* sub_d8d2();
        assert(cs == 0x0a34);
        sp += 0x000a;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_b024() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0014;
        r16[si] = 0x00c8;
        r16[si] -= memory16get(ss, bp + 12);
        if (r16[si] <= 0x000c) {
            pc = 0xb03a;
            break;
        }
        r16[si] = 0x000c;
    case 0xb03a:
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb07e;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb056; break;
        case 2: pc = 0xb060; break;
        case 4: pc = 0xb06a; break;
        case 6: pc = 0xb074; break;
            default:
            assert(0);
        }
        break;
    case 0xb056:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb086;
        break;
    case 0xb060:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb086;
        break;
    case 0xb06a:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb086;
        break;
    case 0xb074:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb086;
        break;
    case 0xb07e:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb086:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0008;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 6, r16[dx]);
        r16[bx] = memory16get(ss, bp - 16);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 16, r16[bx]);
        r16[bx] = memory16get(ds, 0x91b0);
        es = memory16get(ds, 0x91b0 + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[di] = r16[bx];
        r16[ax] = memory16get(ss, bp - 18);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp - 16);
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        memory16set(ss, bp - 8, r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(r16[ax]);
        push(r16[di]);
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0cc2;
        yield* sub_d929();
        assert(cs == 0x0a34);
        sp += 0x000a;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_b0e7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0014;
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0xb103;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_af61();
        sp += 0x0004;
    case 0xb103:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0xb114;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0xb114;
            break;
        }
        pc = 0xb1f9;
        break;
    case 0xb114:
        r16[si] = 0x00c8;
        r16[si] -= memory16get(ss, bp + 12);
        if (r16[si] <= 0x000c) {
            pc = 0xb122;
            break;
        }
        r16[si] = 0x000c;
    case 0xb122:
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[di] = r16[ax];
        r16[ax] = r16[di];
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[di] += memory16get(ss, bp - 6);
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb189;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb161; break;
        case 2: pc = 0xb16b; break;
        case 4: pc = 0xb175; break;
        case 6: pc = 0xb17f; break;
            default:
            assert(0);
        }
        break;
    case 0xb161:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb191;
        break;
    case 0xb16b:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb191;
        break;
    case 0xb175:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb191;
        break;
    case 0xb17f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb191;
        break;
    case 0xb189:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb191:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        if (!r16[dx]) {
            pc = 0xb1be;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x2000;
        r16[bx] = memory16get(ss, bp - 20);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 20, r16[bx]);
        memory16set(ss, bp - 8, 0x0000);
        pc = 0xb1cb;
        break;
    case 0xb1be:
        r16[bx] = memory16get(ss, bp - 20);
        es = memory16get(ss, bp - 20 + 2);
        r16[bx] += r16[di];
        memory16set(ss, bp - 20, r16[bx]);
        memory16set(ss, bp - 8, 0x0050);
    case 0xb1cb:
        r16[ax] = memory16get(ds, 0x91b2);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b0);
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ss, bp - 20);
        memory16set(ss, bp - 14, r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x0ba1;
        yield* sub_bb3c();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb1f9:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0xb203;
            break;
        }
        pc = 0xb2cf;
        break;
    case 0xb203:
        r16[si] = 0x00c8;
        r16[si] -= memory16get(ss, bp + 12);
        if (r16[si] <= 0x000c) {
            pc = 0xb211;
            break;
        }
        r16[si] = 0x000c;
    case 0xb211:
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 6, r16[ax]);
        r16[di] = memory16get(ss, bp + 12);
        r16[di] &= 0x0003;
        r16[cx] = 0x000d;
        r16[di] <<= r8[cl];
        r16[ax] = memory16get(ss, bp + 12);
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[di] += r16[ax];
        r16[di] += memory16get(ss, bp - 6);
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb280;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb258; break;
        case 2: pc = 0xb262; break;
        case 4: pc = 0xb26c; break;
        case 6: pc = 0xb276; break;
            default:
            assert(0);
        }
        break;
    case 0xb258:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb288;
        break;
    case 0xb262:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb288;
        break;
    case 0xb26c:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb288;
        break;
    case 0xb276:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb288;
        break;
    case 0xb280:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb288:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[bx] += r16[di];
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b2);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b0);
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 14, r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x0e11;
        yield* sub_e1c6();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb2cf:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0xb2d9;
            break;
        }
        pc = 0xb37e;
        break;
    case 0xb2d9:
        r16[si] = 0x00c8;
        r16[si] -= memory16get(ss, bp + 12);
        if (r16[si] <= 0x000c) {
            pc = 0xb2e7;
            break;
        }
        r16[si] = 0x000c;
    case 0xb2e7:
        r16[ax] = memory16get(ss, bp + 12);
        r16[dx] = 0x0140;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[di] += memory16get(ss, bp + 10);
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb338;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb310; break;
        case 2: pc = 0xb31a; break;
        case 4: pc = 0xb324; break;
        case 6: pc = 0xb32e; break;
            default:
            assert(0);
        }
        break;
    case 0xb310:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb340;
        break;
    case 0xb31a:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb340;
        break;
    case 0xb324:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb340;
        break;
    case 0xb32e:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb340;
        break;
    case 0xb338:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb340:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[bx] += r16[di];
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = memory16get(ds, 0x91b2);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b0);
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 14, r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(r16[ax]);
        push(memory16get(ss, bp - 16));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x0e97;
        yield* sub_ec66();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb37e:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_b384() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0022;
        r16[di] = memory16get(ss, bp + 12);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0xb3a1;
            break;
        }
        push(r16[di]);
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_ae2f();
        sp += 0x0004;
    case 0xb3a1:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0xb3b2;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0xb3b2;
            break;
        }
        pc = 0xb4f9;
        break;
    case 0xb3b2:
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 14, r16[dx]);
        r16[si] = 0x00c8;
        r16[si] -= r16[di];
        if (r16[si] <= 0x000c) {
            pc = 0xb3cb;
            break;
        }
        r16[si] = 0x000c;
    case 0xb3cb:
        memory16set(ss, bp - 6, 0x0003);
        memory16set(ss, bp - 10, 0x0024);
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb419;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb3f1; break;
        case 2: pc = 0xb3fb; break;
        case 4: pc = 0xb405; break;
        case 6: pc = 0xb40f; break;
            default:
            assert(0);
        }
        break;
    case 0xb3f1:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb421;
        break;
    case 0xb3fb:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb421;
        break;
    case 0xb405:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb421;
        break;
    case 0xb40f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb421;
        break;
    case 0xb419:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb421:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[bx] = memory16get(ds, 0x8dee);
        es = memory16get(ds, 0x8dee + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0001;
        r16[cx] = 0x000d;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0004;
        push(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 8, r16[dx]);
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0xb490;
            break;
        }
        r16[ax] = r16[di];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x0080;
        memory16set(ss, bp - 12, r16[dx]);
        pc = 0xb49b;
        break;
    case 0xb490:
        r16[ax] = r16[di];
        r16[ax] &= 0x0001;
        r16[ax] ^= 0x0001;
        memory16set(ss, bp - 12, r16[ax]);
    case 0xb49b:
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp - 30);
        memory16set(ss, bp - 16, r16[ax]);
        if (memory16get(ss, bp - 14) == 0x0000) {
            pc = 0xb4d8;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 14));
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0ba1;
        yield* sub_bc26();
        assert(cs == 0x0a34);
        sp += 0x0018;
        pc = 0xb4f9;
        break;
    case 0xb4d8:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0ba1;
        yield* sub_be9f();
        assert(cs == 0x0a34);
        sp += 0x0012;
    case 0xb4f9:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0xb503;
            break;
        }
        pc = 0xb62b;
        break;
    case 0xb503:
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 14, r16[ax]);
        r16[si] = 0x00c8;
        r16[si] -= r16[di];
        if (r16[si] <= 0x000c) {
            pc = 0xb519;
            break;
        }
        r16[si] = 0x000c;
    case 0xb519:
        memory16set(ss, bp - 6, 0x0008);
        memory16set(ss, bp - 10, 0x0060);
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb567;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb53f; break;
        case 2: pc = 0xb549; break;
        case 4: pc = 0xb553; break;
        case 6: pc = 0xb55d; break;
            default:
            assert(0);
        }
        break;
    case 0xb53f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb56f;
        break;
    case 0xb549:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb56f;
        break;
    case 0xb553:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb56f;
        break;
    case 0xb55d:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb56f;
        break;
    case 0xb567:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb56f:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[bx] = memory16get(ds, 0x8dee);
        es = memory16get(ds, 0x8dee + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        r16[cx] = 0x000d;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0002;
        push(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 8, r16[dx]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 12, r16[ax]);
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 16, r16[ax]);
        if (memory16get(ss, bp - 14) == 0x0000) {
            pc = 0xb60a;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(memory16get(ss, bp - 14));
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0e11;
        yield* sub_e25c();
        assert(cs == 0x0a34);
        sp += 0x0018;
        pc = 0xb62b;
        break;
    case 0xb60a:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(r16[si]);
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x0e11;
        yield* sub_e3b9();
        assert(cs == 0x0a34);
        sp += 0x0012;
    case 0xb62b:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0xb635;
            break;
        }
        pc = 0xb6ee;
        break;
    case 0xb635:
        r16[si] = 0x00c8;
        r16[si] -= r16[di];
        if (r16[si] <= 0x000c) {
            pc = 0xb642;
            break;
        }
        r16[si] = 0x000c;
    case 0xb642:
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb686;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb65e; break;
        case 2: pc = 0xb668; break;
        case 4: pc = 0xb672; break;
        case 6: pc = 0xb67c; break;
            default:
            assert(0);
        }
        break;
    case 0xb65e:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb68e;
        break;
    case 0xb668:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb68e;
        break;
    case 0xb672:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb68e;
        break;
    case 0xb67c:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb68e;
        break;
    case 0xb686:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb68e:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 24, es);
        memory16set(ss, bp - 26, r16[bx]);
        r16[bx] = memory16get(ds, 0x8dee);
        es = memory16get(ds, 0x8dee + 2);
        memory16set(ss, bp - 32, es);
        memory16set(ss, bp - 34, r16[bx]);
        r16[ax] = memory16get(ss, bp - 32);
        memory16set(ss, bp - 22, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0x0140;
        mul16(r16[dx]);
        r16[ax] += memory16get(ss, bp + 10);
        memory16set(ss, bp - 8, r16[ax]);
        r16[bx] = memory16get(ss, bp - 26);
        es = memory16get(ss, bp - 26 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 28, es);
        memory16set(ss, bp - 30, r16[bx]);
        r16[ax] = memory16get(ss, bp - 28);
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = 0x000c;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(memory16get(ss, bp - 20));
        push(memory16get(ss, bp - 22));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 18));
        push(cs);
        cs = 0x0e97;
        yield* sub_ec9e();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb6ee:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_b6f4() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0018;
        r16[di] = memory16get(ss, bp + 12);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0xb711;
            break;
        }
        push(r16[di]);
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_b024();
        sp += 0x0004;
    case 0xb711:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0xb722;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0xb722;
            break;
        }
        pc = 0xb80e;
        break;
    case 0xb722:
        r16[si] = 0x00c8;
        r16[si] -= r16[di];
        if (r16[si] <= 0x000c) {
            pc = 0xb72f;
            break;
        }
        r16[si] = 0x000c;
    case 0xb72f:
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb773;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb74b; break;
        case 2: pc = 0xb755; break;
        case 4: pc = 0xb75f; break;
        case 6: pc = 0xb769; break;
            default:
            assert(0);
        }
        break;
    case 0xb74b:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb77b;
        break;
    case 0xb755:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb77b;
        break;
    case 0xb75f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb77b;
        break;
    case 0xb769:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb77b;
        break;
    case 0xb773:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb77b:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0001;
        r16[cx] = 0x000d;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0004;
        push(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 6, r16[dx]);
        r16[bx] = memory16get(ss, bp - 20);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0xb7d5;
            break;
        }
        r16[ax] = r16[di];
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x0080;
        memory16set(ss, bp - 8, r16[dx]);
        pc = 0xb7e0;
        break;
    case 0xb7d5:
        r16[ax] = r16[di];
        r16[ax] &= 0x0001;
        r16[ax] ^= 0x0001;
        memory16set(ss, bp - 8, r16[ax]);
    case 0xb7e0:
        r16[ax] = memory16get(ds, 0x91b2);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b0);
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = memory16get(ss, bp - 24);
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[si]);
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x0ba1;
        yield* sub_be37();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb80e:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0xb818;
            break;
        }
        pc = 0xb8e8;
        break;
    case 0xb818:
        r16[si] = 0x00c8;
        r16[si] -= r16[di];
        if (r16[si] <= 0x000c) {
            pc = 0xb825;
            break;
        }
        r16[si] = 0x000c;
    case 0xb825:
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb869;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb841; break;
        case 2: pc = 0xb84b; break;
        case 4: pc = 0xb855; break;
        case 6: pc = 0xb85f; break;
            default:
            assert(0);
        }
        break;
    case 0xb841:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb871;
        break;
    case 0xb84b:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb871;
        break;
    case 0xb855:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb871;
        break;
    case 0xb85f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb871;
        break;
    case 0xb869:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb871:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        r16[cx] = 0x000d;
        r16[ax] <<= r8[cl];
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = 0x0002;
        push(r16[dx]);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] = pop();
        r16[dx] += r16[ax];
        memory16set(ss, bp - 6, r16[dx]);
        r16[bx] = memory16get(ss, bp - 20);
        r16[bx] += r16[dx];
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = r16[di];
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b2);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b0);
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[si]);
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x0e11;
        yield* sub_e318();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb8e8:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0xb8f2;
            break;
        }
        pc = 0xb999;
        break;
    case 0xb8f2:
        r16[si] = 0x00c8;
        r16[si] -= r16[di];
        if (r16[si] <= 0x000c) {
            pc = 0xb8ff;
            break;
        }
        r16[si] = 0x000c;
    case 0xb8ff:
        r8[al] = memory[ds*16 + 0x8f66];
        r8[ah] = 0x00;
        r16[ax]--;
        if (r16[ax] > 0x0003) {
            pc = 0xb943;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0xb91b; break;
        case 2: pc = 0xb925; break;
        case 4: pc = 0xb92f; break;
        case 6: pc = 0xb939; break;
            default:
            assert(0);
        }
        break;
    case 0xb91b:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0xb94b;
        break;
    case 0xb925:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        pc = 0xb94b;
        break;
    case 0xb92f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        pc = 0xb94b;
        break;
    case 0xb939:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bba);
        pc = 0xb94b;
        break;
    case 0xb943:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0xb94b:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 18, es);
        memory16set(ss, bp - 20, r16[bx]);
        r16[ax] = r16[di];
        r16[dx] = 0x0140;
        mul16(r16[dx]);
        r16[ax] += memory16get(ss, bp + 10);
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 22, es);
        memory16set(ss, bp - 24, r16[bx]);
        r16[ax] = memory16get(ds, 0x91b2);
        memory16set(ss, bp - 16, r16[ax]);
        r16[ax] = memory16get(ds, 0x91b0);
        memory16set(ss, bp - 14, r16[ax]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 12, r16[ax]);
        r16[ax] = r16[bx];
        memory16set(ss, bp - 10, r16[ax]);
        push(r16[si]);
        push(r16[ax]);
        push(memory16get(ss, bp - 12));
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 16));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x0e97;
        yield* sub_edd8();
        assert(cs == 0x0a34);
        sp += 0x000c;
    case 0xb999:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_b99f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (memory[ds*16 + 0x87ea] == 0x00) {
            pc = 0xb9ab;
            break;
        }
        r16[ax] = 0x0001;
        pc = 0xb9ad;
        break;
    case 0xb9ab:
        r16[ax] = 0;
    case 0xb9ad:
        cs = pop();
        return;
    } while (1);
}
function* sub_b9ae() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(cs);
        yield* sub_b99f();
        if (!r16[ax]) {
            pc = 0xb9ce;
            break;
        }
    case 0xb9b6:
        push(cs);
        yield* sub_b99f();
        if (r16[ax]) {
            pc = 0xb9b6;
            break;
        }
    case 0xb9be:
        push(cs);
        yield* sub_b99f();
        if (!r16[ax]) {
            pc = 0xb9be;
            break;
        }
    case 0xb9c6:
        push(cs);
        yield* sub_b99f();
        if (r16[ax]) {
            pc = 0xb9c6;
            break;
        }
    case 0xb9ce:
        cs = pop();
        return;
    } while (1);
}
function* sub_b9cf() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        r16[si] >>= 1;
        if (!r16[si]) {
            pc = 0xb9dd;
            break;
        }
        r16[si]--;
    case 0xb9dd:
        memory16set(ds, 0x8dd8, 0x0000);
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_b9ed() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        r16[si] >>= 1;
        if (!r16[si]) {
            pc = 0xb9fb;
            break;
        }
        r16[si]--;
    case 0xb9fb:
        yield* sync();
        r16[ax] = memory16get(ds, 0x8dd8);
        if (r16[ax] >= r16[si]) {
            pc = 0xba0b;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x0a34);
        sp = bp;
        pc = 0xb9fb;
        break;
    case 0xba0b:
        memory16set(ds, 0x8dd8, 0x0000);
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ba29() {
    var pc = 0;
    do switch (pc) {
    case 0:
        if (!(r8[ah] & 0x80)) {
            pc = 0xba33;
            break;
        }
        cs = 0x0a34;
        yield* callIndirect(0x0a34, 0x09eb);
    case 0xba33:
        memory[cs*16 + 0x0004] = 0x01;
        memory16set(cs, 0x0005, bp);
        memory16set(cs, 0x0007, r16[si]);
        r8[al] = 0x00;
        stop();
        return;
    } while (1);
}
function* sub_ba46() {
    //CStackGuardFar sg(0, false);
    r8[al] = 0x00;
    memory[cs*16 + 0x0004] = r8[al];
    cs = pop();
}
function* sub_ba4d() {
    //CStackGuardFar sg(0, false);
    r16[ax] = 0x0000;
    r8[al] = memory[cs*16 + 0x0004];
    cs = pop();
}
function* sub_bacb() {
    //CStackGuardFar sg(0, false);
    r16[ax] = 0xf000;
    push(r16[ax]);
    r16[ax] = 0xe05b;
    push(r16[ax]);
    stop(/*inject ret*/);
    cs = pop();
}
function* sub_bb20() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(r16[di]);
    push(r16[cx]);
    flags.direction = false;
    r16[ax] = memory16get(ss, bp + 8);
    es = r16[ax];
    r16[di] = memory16get(ss, bp + 10);
    r16[ax] = memory16get(ss, bp + 6);
    r16[cx] = 0x2000;
    rep_stosw_data_forward();
    r16[cx] = pop();
    r16[di] = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_bb3c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xbb5d:
        push(r16[si]);
        r16[cx] = 0x0004;
        rep_movsb_data_data_forward();
        r16[si] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xbb7e;
            break;
        }
        if (r16[ax] == 0x0050) {
            pc = 0xbb75;
            break;
        }
        r16[si] -= 0x1fb0;
        r16[ax] = 0x0050;
        pc = 0xbb5d;
        break;
    case 0xbb75:
        r16[si] += 0x2000;
        r16[ax] = 0x0000;
        pc = 0xbb5d;
        break;
    case 0xbb7e:
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_bbd5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[ax] = 0x0050;
        r16[dx] = 0x0064;
    case 0xbbf5:
        push(r16[dx]);
        r16[cx] = 0x0050;
        rep_movsw_data_data_forward();
        r16[dx] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xbc1e;
            break;
        }
        if (r16[ax] == 0x0050) {
            pc = 0xbc11;
            break;
        }
        r16[di] -= 0x2000;
        r16[si] -= 0x2000;
        r16[ax] = 0x0050;
        pc = 0xbbf5;
        break;
    case 0xbc11:
        r16[si] += 0x1f60;
        r16[di] += 0x1f60;
        r16[ax] = 0x0000;
        pc = 0xbbf5;
        break;
    case 0xbc1e:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_bc26() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[di]);
        push(r16[si]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 16);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 20);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 18);
        r16[di] = memory16get(ss, bp + 22);
        r16[bx] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 14);
        if (r16[cx] != 0x0001) {
            pc = 0xbc55;
            break;
        }
        pc = 0xbd79;
        break;
    case 0xbc55:
        if (r16[cx] != 0x0002) {
            pc = 0xbc5d;
            break;
        }
        pc = 0xbceb;
        break;
    case 0xbc5d:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r16[bx] = memory16get(es, r16[di]);
        if (memory16get(ss, bp + 24) == 0x0000) {
            pc = 0xbc85;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[al] |= 0xfc;
        r8[ah] &= 0x03;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xbc85:
        r16[si]++;
        r16[cx]--;
    case 0xbc87:
        r16[ax] = r16[bx];
        r16[di] += 0x0002;
        r16[dx] = memory16get(es, r16[di]);
        r16[bx] = r16[dx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] &= 0xfcfc;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] &= 0x0303;
        r16[ax] |= r16[dx];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xbc87;
            break;
        }
        if (memory16get(ss, bp + 26) == 0x0000) {
            pc = 0xbcca;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r8[al] |= 0x03;
        r8[ah] &= 0xfc;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xbcca:
        r16[di] += 0x0002;
        r16[di] += memory16get(ss, bp + 28);
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xbcd9;
            break;
        }
        pc = 0xbe07;
        break;
    case 0xbcd9:
        r8[al] ^= 0x01;
        if (!r8[al]) {
            pc = 0xbce4;
            break;
        }
        r16[si] -= 0x1fb0;
        pc = 0xbc5d;
        break;
    case 0xbce4:
        r16[si] += 0x2000;
        pc = 0xbc5d;
        break;
    case 0xbceb:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r16[bx] = memory16get(es, r16[di]);
        if (memory16get(ss, bp + 24) == 0x0000) {
            pc = 0xbd0f;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[al] |= 0xf0;
        r8[ah] &= 0x0f;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xbd0f:
        r16[si]++;
        r16[cx]--;
    case 0xbd11:
        r16[ax] = r16[bx];
        r16[di] += 0x0002;
        r16[dx] = memory16get(es, r16[di]);
        r16[bx] = r16[dx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] &= 0xf0f0;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] &= 0x0f0f;
        r16[ax] |= r16[dx];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xbd11;
            break;
        }
        if (memory16get(ss, bp + 26) == 0x0000) {
            pc = 0xbd58;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r8[al] |= 0x0f;
        r8[ah] &= 0xf0;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xbd58:
        r16[di] += 0x0002;
        r16[di] += memory16get(ss, bp + 28);
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xbd67;
            break;
        }
        pc = 0xbe07;
        break;
    case 0xbd67:
        r8[al] ^= 0x01;
        if (!r8[al]) {
            pc = 0xbd72;
            break;
        }
        r16[si] -= 0x1fb0;
        pc = 0xbceb;
        break;
    case 0xbd72:
        r16[si] += 0x2000;
        pc = 0xbceb;
        break;
    case 0xbd79:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r16[bx] = memory16get(es, r16[di]);
        if (memory16get(ss, bp + 24) == 0x0000) {
            pc = 0xbd99;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[al] |= 0xc0;
        r8[ah] &= 0x3f;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xbd99:
        r16[si]++;
        r16[cx]--;
    case 0xbd9b:
        r16[ax] = r16[bx];
        r16[di] += 0x0002;
        r16[dx] = memory16get(es, r16[di]);
        r16[bx] = r16[dx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] &= 0xc0c0;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] &= 0x3f3f;
        r16[ax] |= r16[dx];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xbd9b;
            break;
        }
        if (memory16get(ss, bp + 26) == 0x0000) {
            pc = 0xbde6;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r8[al] |= 0x3f;
        r8[ah] &= 0xc0;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xbde6:
        r16[di] += 0x0002;
        r16[di] += memory16get(ss, bp + 28);
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xbdf5;
            break;
        }
        pc = 0xbe07;
        break;
    case 0xbdf5:
        r8[al] ^= 0x01;
        if (!r8[al]) {
            pc = 0xbe00;
            break;
        }
        r16[si] -= 0x1fb0;
        pc = 0xbd79;
        break;
    case 0xbe00:
        r16[si] += 0x2000;
        pc = 0xbd79;
        break;
    case 0xbe07:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_be10() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    flags.direction = false;
    r16[ax] = memory16get(ss, bp + 8);
    es = r16[ax];
    ds = r16[ax];
    r16[ax] = memory16get(ss, bp + 6);
    r16[ax] += 0x2000;
    r16[si] = r16[ax];
    r16[ax] += 0x2000;
    r16[di] = r16[ax];
    r16[cx] = 0x1000;
    rep_movsw_data_data_forward();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_be37() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xbe58:
        push(r16[di]);
        r16[cx] = 0x0004;
        rep_movsb_data_data_forward();
        r16[di] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xbe96;
            break;
        }
        r8[al] ^= 0x01;
        if (!r8[al]) {
            pc = 0xbe6c;
            break;
        }
        r16[di] -= 0x1fb0;
        pc = 0xbe58;
        break;
    case 0xbe6c:
        r16[di] += 0x2000;
        pc = 0xbe58;
        break;
    case 0xbe96:
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_be9f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 18);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 16);
        r16[di] = memory16get(ss, bp + 20);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 12);
        r8[dh] = r8[al];
        r16[bx] = memory16get(ss, bp + 8);
    case 0xbec4:
        r16[cx] = r16[bx];
    case 0xbec6:
        r16[ax] = memory16get(es, r16[di]);
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[di] += 0x0002;
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xbec6;
            break;
        }
        r16[di] += memory16get(ss, bp + 22);
        r16[si] -= r16[bx];
        r8[dl]--;
        if (r8[dl] == 0) {
            pc = 0xbeef;
            break;
        }
        r8[dh] ^= 0x01;
        if (!r8[dh]) {
            pc = 0xbee9;
            break;
        }
        r16[si] -= 0x1fb0;
        pc = 0xbec4;
        break;
    case 0xbee9:
        r16[si] += 0x2000;
        pc = 0xbec4;
        break;
    case 0xbeef:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_bef8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[di]);
        push(r16[si]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 16);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 20);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 18);
        r16[di] = memory16get(ss, bp + 22);
        r16[bx] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 14);
        if (r16[cx] != 0x0001) {
            pc = 0xbf26;
            break;
        }
        pc = 0xc094;
        break;
    case 0xbf26:
        if (r16[cx] != 0x0002) {
            pc = 0xbf2e;
            break;
        }
        pc = 0xbfe5;
        break;
    case 0xbf2e:
        if (r16[cx] != 0x0000) {
            pc = 0xbf36;
            break;
        }
        pc = 0xc143;
        break;
    case 0xbf36:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] |= 0xfc;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r16[cx]--;
    case 0xbf69:
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r16[di]++;
        r8[ah] = memory[es*16 + r16[di]];
        r8[dh] = r8[ah];
        r8[ah] = ~r8[ah];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[al] |= r8[ah];
        r8[dl] |= r8[dh];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[dl] &= r8[bl];
        r8[al] |= r8[dl];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xbf69;
            break;
        }
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] |= 0x03;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[di]++;
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xbfcc;
            break;
        }
        pc = 0xc17e;
        break;
    case 0xbfcc:
        if (r16[ax] == 0x0050) {
            pc = 0xbfdb;
            break;
        }
        r16[si] -= 0x1fb0;
        r16[ax] = 0x0050;
        pc = 0xbf36;
        break;
    case 0xbfdb:
        r16[si] += 0x2000;
        r16[ax] = 0x0000;
        pc = 0xbf36;
        break;
    case 0xbfe5:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] |= 0xf0;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r16[cx]--;
    case 0xc010:
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r16[di]++;
        r8[ah] = memory[es*16 + r16[di]];
        r8[dh] = r8[ah];
        r8[ah] = ~r8[ah];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[al] |= r8[ah];
        r8[dl] |= r8[dh];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[dl] &= r8[bl];
        r8[al] |= r8[dl];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xc010;
            break;
        }
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] |= 0x0f;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[di]++;
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xc07b;
            break;
        }
        pc = 0xc17e;
        break;
    case 0xc07b:
        if (r16[ax] == 0x0050) {
            pc = 0xc08a;
            break;
        }
        r16[si] -= 0x1fb0;
        r16[ax] = 0x0050;
        pc = 0xbfe5;
        break;
    case 0xc08a:
        r16[si] += 0x2000;
        r16[ax] = 0x0000;
        pc = 0xbfe5;
        break;
    case 0xc094:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] |= 0xc0;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r16[cx]--;
    case 0xc0b7:
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r16[di]++;
        r8[ah] = memory[es*16 + r16[di]];
        r8[dh] = r8[ah];
        r8[ah] = ~r8[ah];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[al] |= r8[ah];
        r8[dl] |= r8[dh];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[dl] &= r8[bl];
        r8[al] |= r8[dl];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xc0b7;
            break;
        }
        r8[al] = memory[es*16 + r16[di]];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] |= 0x3f;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[di]++;
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xc12a;
            break;
        }
        pc = 0xc17e;
        break;
    case 0xc12a:
        if (r16[ax] == 0x0050) {
            pc = 0xc139;
            break;
        }
        r16[si] -= 0x1fb0;
        r16[ax] = 0x0050;
        pc = 0xc094;
        break;
    case 0xc139:
        r16[si] += 0x2000;
        r16[ax] = 0x0000;
        pc = 0xc094;
        break;
    case 0xc143:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
    case 0xc149:
        r8[al] = memory[es*16 + r16[di]];
        r16[di]++;
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] &= r8[bl];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xc149;
            break;
        }
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xc167;
            break;
        }
        pc = 0xc17e;
        break;
    case 0xc167:
        if (r16[ax] == 0x0050) {
            pc = 0xc175;
            break;
        }
        r16[si] -= 0x1fb0;
        r16[ax] = 0x0050;
        pc = 0xc143;
        break;
    case 0xc175:
        r16[si] += 0x2000;
        r16[ax] = 0x0000;
        pc = 0xc143;
        break;
    case 0xc17e:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_c416() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 16);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 18);
        r16[ax] = memory16get(ss, bp + 10);
        r8[dh] = r8[al];
        r16[ax] = memory16get(ss, bp + 14);
        r8[dl] = r8[al];
        r16[bx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        r8[ah] = r8[al];
    case 0xc439:
        push(r16[di]);
        r16[cx] = memory16get(ss, bp + 8);
        if (r16[cx] != 0x7777) {
            pc = 0xc45e;
            break;
        }
        r8[al] = r8[bh];
        r8[al] |= r8[bl];
        r8[al] = ~r8[al];
        r8[al] &= r8[dl];
        push(r16[dx]);
        r8[dl] = r8[al];
        r8[al] = r8[bh];
        r8[al] |= r8[bl];
        r8[al] &= memory[es*16 + r16[di]];
        r8[al] |= r8[dl];
        r16[dx] = pop();
        memory[es*16 + r16[di]] = r8[al];
        pc = 0xc49a;
        break;
    case 0xc45e:
        if (r8[bh] == 0x00) {
            pc = 0xc478;
            break;
        }
        r8[al] = r8[bh];
        r8[al] = ~r8[al];
        r8[al] &= r8[dl];
        push(r16[dx]);
        r8[dl] = r8[al];
        r8[al] = r8[bh];
        r8[al] &= memory[es*16 + r16[di]];
        r8[al] |= r8[dl];
        r16[dx] = pop();
        memory[es*16 + r16[di]] = r8[al];
        r16[di]++;
    case 0xc478:
        if (r16[cx] == 0x0000) {
            pc = 0xc481;
            break;
        }
        r8[al] = r8[dl];
        rep_stosb_data_forward();
    case 0xc481:
        if (r8[bl] == 0x00) {
            pc = 0xc49a;
            break;
        }
        r8[al] = r8[bl];
        r8[al] = ~r8[al];
        r8[al] &= r8[dl];
        push(r16[dx]);
        r8[dl] = r8[al];
        r8[al] = r8[bl];
        r8[al] &= memory[es*16 + r16[di]];
        r8[al] |= r8[dl];
        r16[dx] = pop();
        memory[es*16 + r16[di]] = r8[al];
    case 0xc49a:
        r16[di] = pop();
        r8[dh]--;
        if (r8[dh] != 0) {
            pc = 0xc4a1;
            break;
        }
        pc = 0xc4b6;
        break;
    case 0xc4a1:
        if (r8[ah] == 0x50) {
            pc = 0xc4ae;
            break;
        }
        r16[di] -= 0x1fb0;
        r8[ah] = 0x50;
        pc = 0xc439;
        break;
    case 0xc4ae:
        r16[di] += 0x2000;
        r8[ah] = 0x00;
        pc = 0xc439;
        break;
    case 0xc4b6:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_c6ac() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 16);
        r16[dx] = memory16get(ss, bp + 18);
        r16[dx] &= 0x0001;
        flags.direction = false;
    case 0xc6d3:
        r16[cx] = r16[bx];
        r16[cx] >>= 1;
        rep_movsw_data_data_forward();
        r16[di] -= r16[bx];
        r16[si] -= r16[bx];
        if (r8[dl] == 0x01) {
            pc = 0xc6f1;
            break;
        }
        r8[dl] = 0x01;
        r16[si] += 0x2000;
        r16[di] += 0x2000;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xc6d3;
            break;
        }
        pc = 0xc6fe;
        break;
    case 0xc6f1:
        r8[dl] = 0x00;
        r16[si] -= 0x1fb0;
        r16[di] -= 0x1fb0;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xc6d3;
            break;
        }
    case 0xc6fe:
        r16[bx] = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_c707() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 16);
        r16[dx] = memory16get(ss, bp + 18);
        r16[dx] &= 0x0001;
        flags.direction = false;
    case 0xc72e:
        r16[cx] = r16[bx];
        r16[cx] >>= 1;
        rep_movsw_data_data_forward();
        r16[di] -= r16[bx];
        r16[si] -= r16[bx];
        if (r8[dl] == 0x01) {
            pc = 0xc74c;
            break;
        }
        r8[dl] = 0x01;
        r16[si] += 0x2000;
        r16[di] += 0x2000;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xc72e;
            break;
        }
        pc = 0xc76b;
        break;
    case 0xc74c:
        r8[dl] = 0x00;
        r16[cx] = r16[bx];
        r16[cx] >>= 1;
        r16[di] += 0x2000;
        rep_movsw_data_data_forward();
        r16[di] -= r16[bx];
        r16[si] -= r16[bx];
        r16[di] -= 0x2000;
        r16[si] -= 0x1fb0;
        r16[di] -= 0x1fb0;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xc72e;
            break;
        }
    case 0xc76b:
        r16[bx] = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_c774() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 18);
        r16[bx] = memory16get(ss, bp + 14);
    case 0xc794:
        r16[cx] = memory16get(ss, bp + 16);
        rep_movsb_data_data_forward();
        r16[di] -= memory16get(ss, bp + 16);
        r8[dl] ^= 0x01;
        if (!r8[dl]) {
            pc = 0xc7aa;
            break;
        }
        r16[di] += 0x2000;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xc794;
            break;
        }
        pc = 0xc7b1;
        break;
    case 0xc7aa:
        r16[di] -= 0x1fb0;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xc794;
            break;
        }
    case 0xc7b1:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_c7ba() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    r16[ax] = memory16get(ss, bp + 6);
    ds = r16[ax];
    r16[si] = memory16get(ss, bp + 8);
    r16[ax] = 0x0ba1;
    es = r16[ax];
    r16[di] = 0x0009;
    r16[cx] = 0x0010;
    rep_movsb_data_data_forward();
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_c7e2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 12);
    case 0xc7ff:
        push(r16[cx]);
        r16[bx] = 0;
        r16[ax] = memory16get(ss, bp + 14);
        r8[ch] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[cl] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dh] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dl] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[ah] = memory[es*16 + r16[bx] + r16[di]];
        r8[ah] ^= 0xff;
        r16[di]++;
        r8[al] = 0x00;
        if (!(r8[ah] & 0x80)) {
            pc = 0xc829;
            break;
        }
        r8[al] |= 0xc0;
    case 0xc829:
        if (!(r8[ah] & 0x40)) {
            pc = 0xc830;
            break;
        }
        r8[al] |= 0x30;
    case 0xc830:
        if (!(r8[ah] & 0x20)) {
            pc = 0xc837;
            break;
        }
        r8[al] |= 0x0c;
    case 0xc837:
        if (!(r8[ah] & 0x10)) {
            pc = 0xc83e;
            break;
        }
        r8[al] |= 0x03;
    case 0xc83e:
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        push(r16[ax]);
        r8[bh] = 0;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] = memory[cs*16 + r16[bx] + 9];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] |= memory[cs*16 + r16[bx] + 9];
        memory[ds*16 + r16[si]] = r8[ah];
        r16[si]++;
        r16[ax] = pop();
        r8[al] = 0x00;
        if (!(r8[ah] & 0x08)) {
            pc = 0xc8f1;
            break;
        }
        r8[al] |= 0xc0;
    case 0xc8f1:
        if (!(r8[ah] & 0x04)) {
            pc = 0xc8f8;
            break;
        }
        r8[al] |= 0x30;
    case 0xc8f8:
        if (!(r8[ah] & 0x02)) {
            pc = 0xc8ff;
            break;
        }
        r8[al] |= 0x0c;
    case 0xc8ff:
        if (!(r8[ah] & 0x01)) {
            pc = 0xc906;
            break;
        }
        r8[al] |= 0x03;
    case 0xc906:
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] = memory[cs*16 + r16[bx] + 9];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] |= memory[cs*16 + r16[bx] + 9];
        memory[ds*16 + r16[si]] = r8[ah];
        r16[si]++;
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xc9b3;
            break;
        }
        pc = 0xc7ff;
        break;
    case 0xc9b3:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_c9bc() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 12);
    case 0xc9d9:
        push(r16[cx]);
        r16[bx] = 0;
        r16[ax] = memory16get(ss, bp + 14);
        r8[ch] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[cl] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dh] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dl] = memory[es*16 + r16[bx] + r16[di]];
        r16[di]++;
        r8[bh] = 0;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] = memory[cs*16 + r16[bx] + 9];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] |= memory[cs*16 + r16[bx] + 9];
        memory[ds*16 + r16[si]] = r8[ah];
        r16[si]++;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] = memory[cs*16 + r16[bx] + 9];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[al] = memory[cs*16 + r16[bx] + 9];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[ah] |= r8[al];
        r8[bl] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bl] += flags.carry;
        r8[bl] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bl] += flags.carry;
        r8[ah] |= memory[cs*16 + r16[bx] + 9];
        memory[ds*16 + r16[si]] = r8[ah];
        r16[si]++;
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xcb41;
            break;
        }
        pc = 0xc9d9;
        break;
    case 0xcb41:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_cb4e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x0201;
        r16[cx] = 0x9c40;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[bx] = 0x0001;
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x01;
        r8[ah] = r8[al];
    case 0xcb64:
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x01;
        if (r8[al] != r8[ah]) {
            pc = 0xcb71;
            break;
        }
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xcb64;
            break;
        }
        r16[bx] = 0x0000;
    case 0xcb71:
        r16[ax] = r16[bx];
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_cb77() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x0201;
        r16[cx] = 0x9c40;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[bx] = 0x0001;
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x08;
        r8[ah] = r8[al];
    case 0xcb8d:
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x08;
        if (r8[al] != r8[ah]) {
            pc = 0xcb9a;
            break;
        }
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xcb8d;
            break;
        }
        r16[bx] = 0x0000;
    case 0xcb9a:
        r16[ax] = r16[bx];
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_cba0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r8[bl] = 0x01;
        r8[bh] = 0x02;
        r16[ax] = memory16get(ss, bp + 6);
        if (r8[al] != 0x02) {
            pc = 0xcbb9;
            break;
        }
        r8[bl] += r8[bl];
        r8[bl] += r8[bl];
        r8[bh] += r8[bh];
        r8[bh] += r8[bh];
    case 0xcbb9:
        r16[cx] = 0x0000;
        memory16set(cs, 0x000a, r16[cx]);
        memory16set(cs, 0x000c, r16[cx]);
        r8[cl] = r8[bl];
        r8[cl] |= r8[bh];
        r16[dx] = 0x0201;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
    case 0xcbd2:
        r8[al] = in8(r16[dx]);
        if (!(r8[bl] & r8[al])) {
            pc = 0xcbdc;
            break;
        }
        memory16set(cs, 0x000a, memory16get(cs, 0x000a) + 1);
    case 0xcbdc:
        if (!(r8[bh] & r8[al])) {
            pc = 0xcbe5;
            break;
        }
        memory16set(cs, 0x000c, memory16get(cs, 0x000c) + 1);
    case 0xcbe5:
        if (r8[cl] & r8[al]) {
            pc = 0xcbd2;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_cbee() {
    //CStackGuardFar sg(0, false);
    r16[ax] = memory16get(cs, 0x000a);
    cs = pop();
}
function* sub_cbf3() {
    //CStackGuardFar sg(0, false);
    r16[ax] = memory16get(cs, 0x000c);
    cs = pop();
}
function* sub_cbf8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(r16[dx]);
        push(r16[cx]);
        r16[ax] = memory16get(ss, bp + 6);
        r8[cl] = 0x04;
        r8[al] <<= r8[cl];
        r8[cl] = r8[al];
        r16[ax] = memory16get(ss, bp + 8);
        if (r8[al] != 0x02) {
            pc = 0xcc11;
            break;
        }
        r8[cl] += r8[cl];
        r8[cl] += r8[cl];
    case 0xcc11:
        r16[dx] = 0x0201;
        r8[al] = in8(r16[dx]);
        r8[al] &= r8[cl];
        if (r8[al] != 0) {
            pc = 0xcc1e;
            break;
        }
        r16[ax] = 0x0001;
        pc = 0xcc21;
        break;
    case 0xcc1e:
        r16[ax] = 0x0000;
    case 0xcc21:
        r16[cx] = pop();
        r16[dx] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d069() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[bx] = 0;
        r16[cx] = 0;
    case 0xd070:
        r8[ah] = r8[cl];
        r8[ch] = 0x08;
        r8[al] = 0x00;
    case 0xd076:
        r8[al] += r8[al];
        if (!(r8[ah] & 0x01)) {
            pc = 0xd07f;
            break;
        }
        r8[al]++;
    case 0xd07f:
        r8[ah] >>= 1;
        r8[ch]--;
        if (r8[ch] != 0) {
            pc = 0xd076;
            break;
        }
        memory[cs*16 + r16[bx] + 326] = r8[al];
        r16[bx]++;
        r8[ch] = 0x00;
        r16[cx]++;
        if (r16[cx] != 0x0100) {
            pc = 0xd070;
            break;
        }
        r16[bx] = 0;
        r16[cx] = 0;
    case 0xd098:
        r8[dh] = r8[cl];
        r8[dh] &= 0xc0;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dl] = r8[cl];
        r8[dl] &= 0x30;
        r8[dl] >>= 1;
        r8[dl] >>= 1;
        r8[ah] = r8[cl];
        r8[ah] &= 0x0c;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[al] = r8[cl];
        r8[al] &= 0x03;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] |= r8[ah];
        r8[al] |= r8[dh];
        r8[al] |= r8[dl];
        memory[cs*16 + r16[bx] + 582] = r8[al];
        r16[bx]++;
        r8[ch] = 0x00;
        r16[cx]++;
        if (r16[cx] != 0x0100) {
            pc = 0xd098;
            break;
        }
        r16[bx] = 0;
        r16[cx] = 0;
    case 0xd0e4:
        r8[dh] = r8[cl];
        r8[dh] &= 0xf0;
        r8[dl] = r8[cl];
        r8[dl] &= 0x0f;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dh] |= r8[dl];
        memory[cs*16 + r16[bx] + 838] = r8[dh];
        r16[bx]++;
        r8[ch] = 0x00;
        r16[cx]++;
        if (r16[cx] != 0x0100) {
            pc = 0xd0e4;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_d113() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 10);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 12);
        r16[dx] = 0x0cc2;
        r16[bx] = 0x0146;
    case 0xd12c:
        r16[ax] = 0x0cc2;
        es = r16[ax];
        r16[di] = 0x0006;
        r16[cx] = memory16get(ss, bp + 8);
        push(r16[cx]);
        push(ds);
        push(r16[si]);
        rep_movsb_data_data_forward();
        r16[di] = pop();
        es = pop();
        r16[cx] = pop();
        r16[di] += r16[cx];
        r16[di] -= 0x0005;
        r16[di] &= 0xffff;
        ds = r16[dx];
        r16[si] = 0x0000;
    case 0xd149:
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r16[di] -= 0x000a;
        if (r16[si] != r16[cx]) {
            pc = 0xd149;
            break;
        }
        r16[di] += 0x0005;
        r16[di] += r16[cx];
        r16[di] &= 0xffff;
        r16[si] = r16[di];
        r16[ax] = es;
        ds = r16[ax];
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) - 1);
        if (memory16get(ss, bp + 6) != 0) {
            pc = 0xd12c;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d191() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 10);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 12);
        r16[dx] = 0x0cc2;
        r16[bx] = 0x0246;
    case 0xd1aa:
        r16[ax] = 0x0cc2;
        es = r16[ax];
        r16[di] = 0x0006;
        r16[cx] = memory16get(ss, bp + 8);
        push(r16[cx]);
        push(ds);
        push(r16[si]);
        rep_movsb_data_data_forward();
        r16[di] = pop();
        es = pop();
        r16[cx] = pop();
        r16[di] += r16[cx];
        r16[di] -= 0x0002;
        ds = r16[dx];
        r16[si] = 0x0000;
    case 0xd1c7:
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r16[di] -= 0x0004;
        if (r16[si] != r16[cx]) {
            pc = 0xd1c7;
            break;
        }
        r16[di] += 0x0002;
        r16[di] += r16[cx];
        r16[si] = r16[di];
        r16[ax] = es;
        ds = r16[ax];
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) - 1);
        if (memory16get(ss, bp + 6) != 0) {
            pc = 0xd1aa;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d1f7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 10);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 12);
        r16[dx] = 0x0cc2;
        r16[bx] = 0x0346;
    case 0xd210:
        r16[ax] = 0x0cc2;
        es = r16[ax];
        r16[di] = 0x0006;
        r16[cx] = memory16get(ss, bp + 8);
        push(r16[cx]);
        push(ds);
        push(r16[si]);
        rep_movsb_data_data_forward();
        r16[di] = pop();
        es = pop();
        r16[cx] = pop();
        r16[di] += r16[cx];
        r16[di] -= 0x0002;
        ds = r16[dx];
        r16[si] = 0x0000;
    case 0xd22d:
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r8[al] = memory[cs*16 + r16[si] + 6];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[bx]+r8[al]];
        stosb_data_forward();
        r16[di] -= 0x0004;
        if (r16[si] != r16[cx]) {
            pc = 0xd22d;
            break;
        }
        r16[di] += 0x0002;
        r16[di] += r16[cx];
        r16[si] = r16[di];
        r16[ax] = es;
        ds = r16[ax];
        memory16set(ss, bp + 6, memory16get(ss, bp + 6) - 1);
        if (memory16get(ss, bp + 6) != 0) {
            pc = 0xd210;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d472() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[cx]);
    push(r16[dx]);
    r16[dx] = 0x03ce;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x0f;
    out8(r16[dx], r8[al]);
    r16[ax] = memory16get(ss, bp + 6);
    ds = r16[ax];
    r16[ax] = memory16get(ss, bp + 8);
    es = r16[ax];
    r16[si] = 0;
    r16[di] = r16[si];
    r16[cx] = 0x1f40;
    flags.direction = false;
    rep_movsb_video_video_forward();
    r16[dx] = pop();
    r16[cx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_d4ec() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x0f;
        out8(r16[dx], r8[al]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 16);
        flags.direction = false;
    case 0xd520:
        r16[cx] = r16[dx];
        rep_movsb_video_video_forward();
        r16[di] -= r16[dx];
        r16[di] += 0x0028;
        r16[si] -= r16[dx];
        r16[si] += 0x0028;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xd520;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d539() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(r16[di]);
    push(r16[cx]);
    push(r16[dx]);
    r16[dx] = 0x03ce;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x00;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03ce;
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x0f;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03ce;
    r8[al] = 0x00;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r16[ax] = memory16get(ss, bp + 6);
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03ce;
    r8[al] = 0x03;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x00;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03ce;
    r8[al] = 0x08;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0xff;
    out8(r16[dx], r8[al]);
    r16[dx] = 0x03c4;
    r8[al] = 0x02;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x0f;
    out8(r16[dx], r8[al]);
    r16[ax] = memory16get(ss, bp + 8);
    es = r16[ax];
    r16[di] = 0;
    videoSet(es, r16[di], r8[al]);
    r16[dx] = 0x03ce;
    r8[al] = 0x05;
    out8(r16[dx], r8[al]);
    r16[dx]++;
    r8[al] = 0x01;
    out8(r16[dx], r8[al]);
    r8[al] = videoGet(es, r16[di]);
    r16[cx] = 0x1f40;
    flags.direction = false;
    rep_stosb_video_forward();
    r16[dx] = pop();
    r16[cx] = pop();
    r16[di] = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_d5a0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        flags.direction = false;
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03ce;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x0f;
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03ce;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r16[ax] = memory16get(ss, bp + 6);
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03ce;
        r8[al] = 0x03;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x0f;
        out8(r16[dx], r8[al]);
        r16[bx] = memory16get(ss, bp + 8);
        r16[cx] = memory16get(ss, bp + 10);
        r16[si] = memory16get(ss, bp + 12);
        r16[di] = memory16get(ss, bp + 14);
        es = r16[di];
        r16[di] = memory16get(ss, bp + 16);
        r16[dx] = 0x03ce;
        r8[al] = 0x08;
    case 0xd5f4:
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        if (!r8[bl]) {
            pc = 0xd605;
            break;
        }
        r8[ah] = r8[bl];
        out16(r16[dx], r16[ax]);
        r16[si] = es;
        ds = r16[si];
        r16[si] = r16[di];
        movsb_video_video_forward();
    case 0xd605:
        if (!r16[cx]) {
            pc = 0xd615;
            break;
        }
        r8[ah] = r8[al];
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0xff;
        out8(r16[dx], r8[al]);
        r8[al] = r8[ah];
        r16[dx]--;
        rep_stosb_video_forward();
    case 0xd615:
        if (!r8[bh]) {
            pc = 0xd62a;
            break;
        }
        r8[ah] = r8[al];
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[bh];
        out8(r16[dx], r8[al]);
        r8[al] = r8[ah];
        r16[dx]--;
        r16[si] = es;
        ds = r16[si];
        r16[si] = r16[di];
        movsb_video_video_forward();
    case 0xd62a:
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        r16[si]--;
        if (r16[si] == 0) {
            pc = 0xd635;
            break;
        }
        r16[di] += 0x0028;
        pc = 0xd5f4;
        break;
    case 0xd635:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d63e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x0f;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r16[ax] = memory16get(ss, bp + 6);
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x03;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x0f;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r16[bx] = memory16get(ss, bp + 8);
        r16[cx] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 14);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 16);
        r16[ax] = memory16get(ss, bp + 18);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 20);
        r8[al] = 0x08;
    case 0xd691:
        push(r16[dx]);
        push(r16[di]);
        push(r16[cx]);
        r16[dx] = 0x03ce;
        if (!r8[bl]) {
            pc = 0xd6e9;
            break;
        }
        push(r16[cx]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x08;
        r8[ah] = videoGet(es, r16[di]);
        videoSet(es, r16[di], r8[ah]);
        r16[di]++;
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xd6d9;
            break;
        }
    case 0xd6b5:
        push(r16[cx]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[ch] = r8[ah];
        r16[si]++;
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[ah] |= r8[ch];
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x08;
        r8[ah] = memory[es*16 + r16[di]];
        memory[es*16 + r16[di]] = r8[ah];
        r16[di]++;
        r16[cx] = pop();
        if (--r16[cx]) {
            pc = 0xd6b5;
            break;
        }
    case 0xd6d9:
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        out16(r16[dx], r16[ax]);
        r8[ah] = videoGet(es, r16[di]);
        videoSet(es, r16[di], r8[ah]);
        r16[si]++;
        pc = 0xd6fd;
        break;
    case 0xd6e9:
        r8[ah] = memory[ds*16 + r16[si]];
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x08;
        r8[ah] = videoGet(es, r16[di]);
        videoSet(es, r16[di], r8[ah]);
        r16[si]++;
        r16[di]++;
        if (--r16[cx]) {
            pc = 0xd6e9;
            break;
        }
    case 0xd6fd:
        r16[cx] = pop();
        r16[di] = pop();
        r16[dx] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xd708;
            break;
        }
        r16[di] += 0x0028;
        pc = 0xd691;
        break;
    case 0xd708:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d711() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x03;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r16[bx] = memory16get(ss, bp + 8);
        r16[cx] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 14);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 16);
        r16[ax] = memory16get(ss, bp + 18);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 20);
    case 0xd74f:
        push(r16[cx]);
        push(r16[dx]);
        push(r16[di]);
        if (r8[bl]) {
            pc = 0xd760;
            break;
        }
        if (r8[bh]) {
            pc = 0xd75d;
            break;
        }
        pc = 0xd88e;
        break;
    case 0xd75d:
        pc = 0xd845;
        break;
    case 0xd760:
        push(r16[cx]);
        r8[ah] = videoGet(es, r16[di]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si] + 1];
        r8[ah] >>= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si] + 2];
        r8[ah] >>= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si] + 3];
        r8[ah] >>= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si] + 4];
        r8[ah] >>= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r16[di]++;
        r16[cx] = pop();
        if (r16[cx]) {
            pc = 0xd7b0;
            break;
        }
        pc = 0xd8ba;
        break;
    case 0xd7b0:
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xd7b6;
            break;
        }
        pc = 0xd845;
        break;
    case 0xd7b6:
        push(r16[cx]);
        r8[ah] = videoGet(es, r16[di]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[ch] = r8[ah];
        r8[ah] = memory[ds*16 + r16[si] + 5];
        r16[si]++;
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[ah] |= r8[ch];
        r16[dx] = 0x03ce;
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[ch] = r8[ah];
        r8[ah] = memory[ds*16 + r16[si] + 5];
        r16[si]++;
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[ah] |= r8[ch];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[ch] = r8[ah];
        r8[ah] = memory[ds*16 + r16[si] + 5];
        r16[si]++;
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[ah] |= r8[ch];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[ch] = r8[ah];
        r8[ah] = memory[ds*16 + r16[si] + 5];
        r16[si]++;
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[ah] |= r8[ch];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[ch] = r8[ah];
        r8[ah] = memory[ds*16 + r16[si] + 5];
        r16[si]++;
        r8[cl] = r8[bl];
        r8[ah] >>= r8[cl];
        r8[ah] |= r8[ch];
        videoSet(es, r16[di], r8[ah]);
        r16[di]++;
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xd845;
            break;
        }
        pc = 0xd7b6;
        break;
    case 0xd845:
        r8[ah] = videoGet(es, r16[di]);
        r8[ah] = memory[ds*16 + r16[si]];
        r16[si]++;
        r8[cl] = r8[bh];
        r8[ah] <<= r8[cl];
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r16[si]++;
        r8[ah] <<= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r16[si]++;
        r8[ah] <<= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r16[si]++;
        r8[ah] <<= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[ds*16 + r16[si]];
        r16[si]++;
        r8[ah] <<= r8[cl];
        videoSet(es, r16[di], r8[ah]);
        pc = 0xd8ba;
        break;
    case 0xd88e:
        r8[ah] = videoGet(es, r16[di]);
        r8[ah] = memory[ds*16 + r16[si]];
        r16[si]++;
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ah];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        movsb_video_data_forward();
        r16[di]--;
        r8[al] <<= 1;
        out8(r16[dx], r8[al]);
        movsb_video_data_forward();
        r16[di]--;
        r8[al] <<= 1;
        out8(r16[dx], r8[al]);
        movsb_video_data_forward();
        r16[di]--;
        r8[al] <<= 1;
        out8(r16[dx], r8[al]);
        movsb_video_data_forward();
        if (--r16[cx]) {
            pc = 0xd88e;
            break;
        }
    case 0xd8ba:
        r16[di] = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xd8c9;
            break;
        }
        r16[di] += 0x0028;
        r16[si] += memory16get(ss, bp + 6);
        pc = 0xd74f;
        break;
    case 0xd8c9:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d8d2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[cx] = memory16get(ss, bp + 14);
        r8[al] = 0x04;
        flags.direction = false;
        out8(r16[dx], r8[al]);
        r16[dx]++;
    case 0xd8ff:
        push(r16[cx]);
        push(r16[si]);
        r16[cx] = 0x0003;
    case 0xd904:
        r8[al] = 0;
        r16[bx] = 0x0004;
    case 0xd909:
        out8(r16[dx], r8[al]);
        movsb_data_data_forward();
        r16[bx]--;
        if (r16[bx] == 0) {
            pc = 0xd913;
            break;
        }
        r16[si]--;
        r8[al]++;
        pc = 0xd909;
        break;
    case 0xd913:
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xd904;
            break;
        }
        r16[si] = pop();
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xd920;
            break;
        }
        r16[si] += 0x0028;
        pc = 0xd8ff;
        break;
    case 0xd920:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d929() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0xff;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x03;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[dx] = 0x03c4;
        r16[cx] = memory16get(ss, bp + 14);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        flags.direction = false;
    case 0xd971:
        push(r16[cx]);
        push(r16[di]);
        r16[cx] = 0x0003;
    case 0xd976:
        r8[al] = 0x01;
        r16[bx] = 0x0004;
    case 0xd97b:
        out8(r16[dx], r8[al]);
        movsb_data_data_forward();
        r16[bx]--;
        if (r16[bx] == 0) {
            pc = 0xd985;
            break;
        }
        r16[di]--;
        r8[al] <<= 1;
        pc = 0xd97b;
        break;
    case 0xd985:
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xd976;
            break;
        }
        r16[di] = pop();
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xd992;
            break;
        }
        r16[di] += 0x0028;
        pc = 0xd971;
        break;
    case 0xd992:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_d99b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0xff;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x03;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        push(r16[di]);
        push(r16[si]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[al] = 0x01;
        r16[dx]++;
        out8(r16[dx], r8[al]);
        r16[bx] = memory16get(ss, bp + 14);
    case 0xd9e7:
        r16[cx] = memory16get(ss, bp + 16);
    case 0xd9ea:
        movsb_data_data_forward();
        r16[si] += 0x0003;
        if (--r16[cx]) {
            pc = 0xd9ea;
            break;
        }
        r16[di] -= memory16get(ss, bp + 16);
        r16[di] += 0x0028;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xd9e7;
            break;
        }
        r16[si] = pop();
        r16[di] = pop();
        r16[si]++;
        push(r16[di]);
        push(r16[si]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[al] = 0x02;
        r16[dx]++;
        out8(r16[dx], r8[al]);
        r16[bx] = memory16get(ss, bp + 14);
    case 0xda0b:
        r16[cx] = memory16get(ss, bp + 16);
    case 0xda0e:
        movsb_data_data_forward();
        r16[si] += 0x0003;
        if (--r16[cx]) {
            pc = 0xda0e;
            break;
        }
        r16[di] -= memory16get(ss, bp + 16);
        r16[di] += 0x0028;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xda0b;
            break;
        }
        r16[si] = pop();
        r16[di] = pop();
        r16[si]++;
        push(r16[di]);
        push(r16[si]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[al] = 0x04;
        r16[dx]++;
        out8(r16[dx], r8[al]);
        r16[bx] = memory16get(ss, bp + 14);
    case 0xda2f:
        r16[cx] = memory16get(ss, bp + 16);
    case 0xda32:
        movsb_data_data_forward();
        r16[si] += 0x0003;
        if (--r16[cx]) {
            pc = 0xda32;
            break;
        }
        r16[di] -= memory16get(ss, bp + 16);
        r16[di] += 0x0028;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xda2f;
            break;
        }
        r16[si] = pop();
        r16[di] = pop();
        r16[si]++;
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[al] = 0x08;
        r16[dx]++;
        out8(r16[dx], r8[al]);
        r16[bx] = memory16get(ss, bp + 14);
    case 0xda51:
        r16[cx] = memory16get(ss, bp + 16);
    case 0xda54:
        movsb_data_data_forward();
        r16[si] += 0x0003;
        if (--r16[cx]) {
            pc = 0xda54;
            break;
        }
        r16[di] -= memory16get(ss, bp + 16);
        r16[di] += 0x0028;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xda51;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_da6c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[dx] = 0x03ce;
        r8[al] = 0x05;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x03;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x00;
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r16[ax] = memory16get(ss, bp + 6);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 12);
        r16[cx] = memory16get(ss, bp + 18);
        r16[dx] = memory16get(ss, bp + 16);
        r16[ax] = memory16get(ss, bp + 14);
        r8[ch] = r8[al];
        if (r8[cl] != 0x01) {
            pc = 0xdab4;
            break;
        }
        pc = 0xdadf;
        break;
    case 0xdab4:
        if (r8[cl] != 0x02) {
            pc = 0xdabc;
            break;
        }
        pc = 0xdbb0;
        break;
    case 0xdabc:
        if (r8[cl] != 0x03) {
            pc = 0xdac4;
            break;
        }
        pc = 0xdc8e;
        break;
    case 0xdac4:
        if (r8[cl] != 0x04) {
            pc = 0xdacc;
            break;
        }
        pc = 0xdd76;
        break;
    case 0xdacc:
        if (r8[cl] != 0x05) {
            pc = 0xdad4;
            break;
        }
        pc = 0xde68;
        break;
    case 0xdad4:
        if (r8[cl] != 0x06) {
            pc = 0xdadc;
            break;
        }
        pc = 0xdf3b;
        break;
    case 0xdadc:
        pc = 0xe00e;
        break;
    case 0xdadf:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xdaf2:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= 1;
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= 1;
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] != 0) {
            pc = 0xdaf2;
            break;
        }
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xdbad;
            break;
        }
        pc = 0xdadf;
        break;
    case 0xdbad:
        pc = 0xe0e1;
        break;
    case 0xdbb0:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xdbc3:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] == 0) {
            pc = 0xdc49;
            break;
        }
        pc = 0xdbc3;
        break;
    case 0xdc49:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xdc8b;
            break;
        }
        pc = 0xdbb0;
        break;
    case 0xdc8b:
        pc = 0xe0e1;
        break;
    case 0xdc8e:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xdca1:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] == 0) {
            pc = 0xdd31;
            break;
        }
        pc = 0xdca1;
        break;
    case 0xdd31:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xdd73;
            break;
        }
        pc = 0xdc8e;
        break;
    case 0xdd73:
        pc = 0xe0e1;
        break;
    case 0xdd76:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xdd89:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] == 0) {
            pc = 0xde23;
            break;
        }
        pc = 0xdd89;
        break;
    case 0xde23:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xde65;
            break;
        }
        pc = 0xdd76;
        break;
    case 0xde65:
        pc = 0xe0e1;
        break;
    case 0xde68:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xde7b:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] == 0) {
            pc = 0xdef6;
            break;
        }
        pc = 0xde7b;
        break;
    case 0xdef6:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xdf38;
            break;
        }
        pc = 0xde68;
        break;
    case 0xdf38:
        pc = 0xe0e1;
        break;
    case 0xdf3b:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xdf4e:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] == 0) {
            pc = 0xdfc9;
            break;
        }
        pc = 0xdf4e;
        break;
    case 0xdfc9:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xe00b;
            break;
        }
        pc = 0xdf3b;
        break;
    case 0xe00b:
        pc = 0xe0e1;
        break;
    case 0xe00e:
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r8[al] = 0;
        r16[bx] = 0;
        memory[cs*16 + 0x0446] = r8[al];
        memory[cs*16 + 0x0447] = r8[al];
        memory[cs*16 + 0x0448] = r8[al];
    case 0xe021:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[ah] = memory[es*16 + r16[di]];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= r8[bl];
        r8[bl] = r8[al];
        r8[tl] = r8[ah];
        r8[ah] = r8[al];
        r8[al] = r8[tl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 1];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= r8[bh];
        r8[bh] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 2];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0446];
        memory[cs*16 + 0x0446] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 3];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0447];
        memory[cs*16 + 0x0447] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[es*16 + r16[di] + 4];
        r8[al] = 0;
        r16[ax] >>= r8[cl];
        r8[ah] |= memory[cs*16 + 0x0448];
        memory[cs*16 + 0x0448] = r8[al];
        videoSet(ds, r16[si], r8[ah]);
        r16[si]++;
        r16[di] += 0x0005;
        r8[ch]--;
        if (r8[ch] == 0) {
            pc = 0xe09c;
            break;
        }
        pc = 0xe021;
        break;
    case 0xe09c:
        r8[al] = 0x08;
        r16[dx] = 0x03ce;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = videoGet(ds, r16[si]);
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03c4;
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = 0x01;
        out8(r16[dx], r8[al]);
        videoSet(ds, r16[si], r8[bh]);
        r8[al] = 0x02;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0446];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x04;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0447];
        videoSet(ds, r16[si], r8[ah]);
        r8[al] = 0x08;
        out8(r16[dx], r8[al]);
        r8[ah] = memory[cs*16 + 0x0448];
        videoSet(ds, r16[si], r8[ah]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0028;
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xe0de;
            break;
        }
        pc = 0xe00e;
        break;
    case 0xe0de:
        pc = 0xe0e1;
        break;
    case 0xe0e1:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e0ea() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(r16[dx]);
        push(r16[cx]);
        r16[cx] = memory16get(ss, bp + 6);
        flags.interrupts = false;
        r16[dx] = 0x03d4;
        r8[al] = 0x0c;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[ch];
        out8(r16[dx], r8[al]);
        r16[dx]--;
        r8[al] = 0x0d;
        out8(r16[dx], r8[al]);
        r16[dx]++;
        r8[al] = r8[cl];
        out8(r16[dx], r8[al]);
        flags.interrupts = true;
        r16[dx] = 0x03da;
    case 0xe109:
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x08;
        if (r8[al] == 0) {
            pc = 0xe109;
            break;
        }
        r16[cx] = pop();
        r16[dx] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e15f() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(r16[di]);
    push(r16[cx]);
    flags.direction = false;
    r16[ax] = memory16get(ss, bp + 8);
    es = r16[ax];
    r16[di] = memory16get(ss, bp + 10);
    r16[ax] = memory16get(ss, bp + 6);
    r16[cx] = 0x4000;
    rep_stosw_data_forward();
    r16[cx] = pop();
    r16[di] = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_e1c6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xe1e7:
        push(r16[si]);
        r16[cx] = 0x0008;
        rep_movsb_data_data_forward();
        r16[si] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xe203;
            break;
        }
        r8[al]++;
        r8[al] &= 0x03;
        if (r8[al] == 0) {
            pc = 0xe1fd;
            break;
        }
        r16[si] += 0x2000;
        pc = 0xe1e7;
        break;
    case 0xe1fd:
        r16[si] -= 0x5f60;
        pc = 0xe1e7;
        break;
    case 0xe203:
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e20c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[ax] = 0x0000;
        r16[dx] = 0x00c8;
    case 0xe22c:
        push(r16[dx]);
        push(r16[di]);
        push(r16[si]);
        r16[cx] = 0x0050;
        rep_movsw_data_data_forward();
        r16[si] = pop();
        r16[di] = pop();
        r16[dx] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xe254;
            break;
        }
        r8[al]++;
        r8[al] &= 0x03;
        if (r8[al] == 0) {
            pc = 0xe24a;
            break;
        }
        r16[di] += 0x2000;
        r16[si] += 0x2000;
        pc = 0xe22c;
        break;
    case 0xe24a:
        r16[si] -= 0x5f60;
        r16[di] -= 0x5f60;
        pc = 0xe22c;
        break;
    case 0xe254:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e25c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[di]);
        push(r16[si]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 16);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 20);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 18);
        r16[di] = memory16get(ss, bp + 22);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        r8[dh] = r8[al];
    case 0xe27e:
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r16[bx] = memory16get(es, r16[di]);
        if (memory16get(ss, bp + 24) == 0x0000) {
            pc = 0xe2a0;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        r8[al] |= 0xf0;
        r8[ah] &= 0x0f;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xe2a0:
        r16[si]++;
        r16[cx]--;
    case 0xe2a2:
        r16[ax] = r16[bx];
        r16[di] += 0x0002;
        r16[dx] = memory16get(es, r16[di]);
        r16[bx] = r16[dx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] &= 0xf0f0;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] &= 0x0f0f;
        r16[ax] |= r16[dx];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xe2a2;
            break;
        }
        if (memory16get(ss, bp + 26) == 0x0000) {
            pc = 0xe2e9;
            break;
        }
        r16[ax] = r16[bx];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r8[al] |= 0x0f;
        r8[ah] &= 0xf0;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
    case 0xe2e9:
        r16[di] += 0x0002;
        r16[di] += memory16get(ss, bp + 28);
        r16[si] -= memory16get(ss, bp + 8);
        r16[dx] = pop();
        r8[dl]--;
        if (r8[dl] != 0) {
            pc = 0xe2fa;
            break;
        }
        pc = 0xe30f;
        break;
    case 0xe2fa:
        r8[dh]++;
        r8[dh] &= 0x03;
        if (r8[dh] == 0) {
            pc = 0xe308;
            break;
        }
        r16[si] += 0x2000;
        pc = 0xe27e;
        break;
    case 0xe308:
        r16[si] -= 0x5f60;
        pc = 0xe27e;
        break;
    case 0xe30f:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e318() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xe339:
        push(r16[di]);
        r16[cx] = 0x0008;
        rep_movsb_data_data_forward();
        r16[di] = pop();
        r16[dx]--;
        if (r16[dx] == 0) {
            pc = 0xe355;
            break;
        }
        r8[al]++;
        r8[al] &= 0x03;
        if (r8[al] == 0) {
            pc = 0xe34f;
            break;
        }
        r16[di] += 0x2000;
        pc = 0xe339;
        break;
    case 0xe34f:
        r16[di] -= 0x5f60;
        pc = 0xe339;
        break;
    case 0xe355:
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e35e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 18);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 16);
        r16[di] = memory16get(ss, bp + 20);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 12);
        r8[dh] = r8[al];
        r16[bx] = memory16get(ss, bp + 8);
    case 0xe383:
        r16[cx] = r16[bx];
    case 0xe385:
        r16[ax] = memory16get(es, r16[di]);
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[di] += 0x0002;
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xe385;
            break;
        }
        r16[di] += memory16get(ss, bp + 22);
        r16[si] -= r16[bx];
        r8[dl]--;
        if (r8[dl] == 0) {
            pc = 0xe3b0;
            break;
        }
        r8[dh]++;
        r8[dh] &= 0x03;
        if (r8[dh] == 0) {
            pc = 0xe3aa;
            break;
        }
        r16[si] += 0x2000;
        pc = 0xe383;
        break;
    case 0xe3aa:
        r16[si] -= 0x5f60;
        pc = 0xe383;
        break;
    case 0xe3b0:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e3b9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 14);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 18);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 16);
        r16[di] = memory16get(ss, bp + 20);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 20);
        r16[ax] += r16[bx];
        r16[bx] = r16[ax];
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 12);
    case 0xe3e3:
        push(r16[ax]);
        push(r16[si]);
        push(r16[cx]);
        r16[cx] = memory16get(ss, bp + 8);
    case 0xe3e9:
        r8[al] = memory[es*16 + r16[bx] + r16[di]];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[al] |= memory[es*16 + r16[di]];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r16[di]++;
        if (--r16[cx]) {
            pc = 0xe3e9;
            break;
        }
        r16[cx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xe40f;
            break;
        }
        r8[al]++;
        r8[al] &= 0x03;
        if (r8[al] == 0) {
            pc = 0xe409;
            break;
        }
        r16[si] += 0x2000;
        pc = 0xe3e3;
        break;
    case 0xe409:
        r16[si] -= 0x5f60;
        pc = 0xe3e3;
        break;
    case 0xe40f:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e418() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[ax]);
        r8[bh] = memory[es*16 + r16[di]];
        r16[di]++;
        r16[ax] = 0;
        if (!(r8[bh] & 0x80)) {
            pc = 0xe426;
            break;
        }
        r8[al] |= 0xf0;
    case 0xe426:
        if (!(r8[bh] & 0x40)) {
            pc = 0xe42d;
            break;
        }
        r8[al] |= 0x0f;
    case 0xe42d:
        if (!(r8[bh] & 0x20)) {
            pc = 0xe435;
            break;
        }
        r8[ah] |= 0xf0;
    case 0xe435:
        if (!(r8[bh] & 0x10)) {
            pc = 0xe43d;
            break;
        }
        r8[ah] |= 0x0f;
    case 0xe43d:
        memory16set(ss, bp + 26, r16[ax]);
        r16[ax] = 0;
        if (!(r8[bh] & 0x08)) {
            pc = 0xe449;
            break;
        }
        r8[al] |= 0xf0;
    case 0xe449:
        if (!(r8[bh] & 0x04)) {
            pc = 0xe450;
            break;
        }
        r8[al] |= 0x0f;
    case 0xe450:
        if (!(r8[bh] & 0x02)) {
            pc = 0xe458;
            break;
        }
        r8[ah] |= 0xf0;
    case 0xe458:
        if (!(r8[bh] & 0x01)) {
            pc = 0xe460;
            break;
        }
        r8[ah] |= 0x0f;
    case 0xe460:
        memory16set(ss, bp + 28, r16[ax]);
        r16[ax] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_e465() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[di]);
        push(r16[si]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 16);
        ds = r16[ax];
        r16[ax] = memory16get(ss, bp + 20);
        es = r16[ax];
        r16[si] = memory16get(ss, bp + 18);
        r16[di] = memory16get(ss, bp + 22);
        r16[bx] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 14);
        r8[bl] = memory[ss*16 + bp + 24];
        if (r8[bl] & 0x03) {
            pc = 0xe498;
            break;
        }
        push(cs);
        cs = 0x0e11;
        yield* sub_e418();
        assert(cs == 0x0e11);
    case 0xe498:
        push(r16[di]);
        r8[bh] = 0;
        r16[di] = r16[bx];
        r8[bh] = memory[ss*16 + bp + r16[di] + 26];
        r16[di] = pop();
        r8[bl]++;
        r8[bl] &= 0x03;
        if (r16[cx] == 0x0001) {
            pc = 0xe4ae;
            break;
        }
        pc = 0xe585;
        break;
    case 0xe4ae:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
        r8[al] = r8[bh];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] >>= 1;
        r8[al] |= 0xf0;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] &= memory[ss*16 + bp + 10];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r16[cx]--;
    case 0xe4d9:
        r8[al] = r8[bh];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        if (r8[bl] & 0x03) {
            pc = 0xe4e9;
            break;
        }
        push(cs);
        cs = 0x0e11;
        yield* sub_e418();
        assert(cs == 0x0e11);
    case 0xe4e9:
        push(r16[di]);
        r8[bh] = 0;
        r16[di] = r16[bx];
        r8[bh] = memory[ss*16 + bp + r16[di] + 26];
        r16[di] = pop();
        r8[bl]++;
        r8[bl] &= 0x03;
        r8[ah] = r8[bh];
        r8[dh] = r8[ah];
        r8[ah] = ~r8[ah];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[ah] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[dh] >>= 1;
        r8[al] |= r8[ah];
        r8[dl] |= r8[dh];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[dl] &= memory[ss*16 + bp + 10];
        r8[al] |= r8[dl];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xe4d9;
            break;
        }
        r8[al] = r8[bh];
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] |= 0x0f;
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        r8[ah] &= memory[ss*16 + bp + 10];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        if (r8[bl] & 0x03) {
            pc = 0xe55a;
            break;
        }
        push(cs);
        cs = 0x0e11;
        yield* sub_e418();
        assert(cs == 0x0e11);
    case 0xe55a:
        push(r16[di]);
        r8[bh] = 0;
        r16[di] = r16[bx];
        r8[bh] = memory[ss*16 + bp + r16[di] + 26];
        r16[di] = pop();
        r8[bl]++;
        r8[bl] &= 0x03;
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xe571;
            break;
        }
        pc = 0xe5d2;
        break;
    case 0xe571:
        r8[al]++;
        r8[al] &= 0x03;
        if (r8[al] == 0) {
            pc = 0xe57e;
            break;
        }
        r16[si] += 0x2000;
        pc = 0xe4ae;
        break;
    case 0xe57e:
        r16[si] -= 0x5f60;
        pc = 0xe4ae;
        break;
    case 0xe585:
        push(r16[ax]);
        push(r16[si]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 8);
    case 0xe58b:
        r8[al] = r8[bh];
        if (r8[bl] & 0x03) {
            pc = 0xe597;
            break;
        }
        push(cs);
        cs = 0x0e11;
        yield* sub_e418();
        assert(cs == 0x0e11);
    case 0xe597:
        push(r16[di]);
        r8[bh] = 0;
        r16[di] = r16[bx];
        r8[bh] = memory[ss*16 + bp + r16[di] + 26];
        r16[di] = pop();
        r8[bl]++;
        r8[bl] &= 0x03;
        r8[dl] = r8[al];
        r8[al] = ~r8[al];
        r8[al] &= memory[ds*16 + r16[si]];
        r8[ah] = r8[dl];
        r8[ah] &= memory[ss*16 + bp + 10];
        r8[al] |= r8[ah];
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        if (--r16[cx]) {
            pc = 0xe58b;
            break;
        }
        r16[dx] = pop();
        r16[si] = pop();
        r16[ax] = pop();
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xe5c0;
            break;
        }
        pc = 0xe5d2;
        break;
    case 0xe5c0:
        r8[al]++;
        r8[al] &= 0x03;
        if (r8[al] == 0) {
            pc = 0xe5cc;
            break;
        }
        r16[si] += 0x2000;
        pc = 0xe585;
        break;
    case 0xe5cc:
        r16[si] -= 0x5f60;
        pc = 0xe585;
        break;
    case 0xe5d2:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e5db() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 16);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 18);
        r16[ax] = memory16get(ss, bp + 10);
        r8[dh] = r8[al];
        r16[ax] = memory16get(ss, bp + 14);
        r8[dl] = r8[al];
        r16[bx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        r8[ah] = r8[al];
    case 0xe5fe:
        push(r16[di]);
        r16[cx] = memory16get(ss, bp + 8);
        if (r16[cx] != 0x7777) {
            pc = 0xe623;
            break;
        }
        r8[al] = r8[bh];
        r8[al] |= r8[bl];
        r8[al] = ~r8[al];
        r8[al] &= r8[dl];
        push(r16[dx]);
        r8[dl] = r8[al];
        r8[al] = r8[bh];
        r8[al] |= r8[bl];
        r8[al] &= memory[es*16 + r16[di]];
        r8[al] |= r8[dl];
        r16[dx] = pop();
        memory[es*16 + r16[di]] = r8[al];
        pc = 0xe65f;
        break;
    case 0xe623:
        if (r8[bh] == 0x00) {
            pc = 0xe63d;
            break;
        }
        r8[al] = r8[bh];
        r8[al] = ~r8[al];
        r8[al] &= r8[dl];
        push(r16[dx]);
        r8[dl] = r8[al];
        r8[al] = r8[bh];
        r8[al] &= memory[es*16 + r16[di]];
        r8[al] |= r8[dl];
        r16[dx] = pop();
        memory[es*16 + r16[di]] = r8[al];
        r16[di]++;
    case 0xe63d:
        if (r16[cx] == 0x0000) {
            pc = 0xe646;
            break;
        }
        r8[al] = r8[dl];
        rep_stosb_data_forward();
    case 0xe646:
        if (r8[bl] == 0x00) {
            pc = 0xe65f;
            break;
        }
        r8[al] = r8[bl];
        r8[al] = ~r8[al];
        r8[al] &= r8[dl];
        push(r16[dx]);
        r8[dl] = r8[al];
        r8[al] = r8[bl];
        r8[al] &= memory[es*16 + r16[di]];
        r8[al] |= r8[dl];
        r16[dx] = pop();
        memory[es*16 + r16[di]] = r8[al];
    case 0xe65f:
        r16[di] = pop();
        r8[dh]--;
        if (r8[dh] != 0) {
            pc = 0xe666;
            break;
        }
        pc = 0xe679;
        break;
    case 0xe666:
        r8[ah]++;
        r8[ah] &= 0x03;
        if (r8[ah] == 0) {
            pc = 0xe673;
            break;
        }
        r16[di] += 0x2000;
        pc = 0xe5fe;
        break;
    case 0xe673:
        r16[di] -= 0x5f60;
        pc = 0xe5fe;
        break;
    case 0xe679:
        r16[bx] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e680() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        push(r16[bx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 16);
        r16[dx] = memory16get(ss, bp + 18);
        r16[dx] &= 0x0003;
        flags.direction = false;
    case 0xe6a7:
        r16[cx] = r16[bx];
        r16[cx] >>= 1;
        rep_movsw_data_data_forward();
        r16[di] -= r16[bx];
        r16[si] -= r16[bx];
        r8[dl]++;
        r8[dl] &= 0x03;
        if (r8[dl] == 0) {
            pc = 0xe6c5;
            break;
        }
        r16[di] += 0x2000;
        r16[si] += 0x2000;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xe6a7;
            break;
        }
        pc = 0xe6d0;
        break;
    case 0xe6c5:
        r16[di] -= 0x5f60;
        r16[si] -= 0x5f60;
        r16[ax]--;
        if (r16[ax] != 0) {
            pc = 0xe6a7;
            break;
        }
    case 0xe6d0:
        r16[bx] = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e806() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 18);
        r16[bx] = memory16get(ss, bp + 14);
    case 0xe826:
        r16[cx] = memory16get(ss, bp + 16);
        rep_movsb_data_data_forward();
        r16[di] -= memory16get(ss, bp + 16);
        r8[dl]++;
        r8[dl] &= 0x03;
        if (r8[dl] == 0) {
            pc = 0xe83e;
            break;
        }
        r16[di] += 0x2000;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xe826;
            break;
        }
        pc = 0xe845;
        break;
    case 0xe83e:
        r16[di] -= 0x5f60;
        r16[bx]--;
        if (r16[bx] != 0) {
            pc = 0xe826;
            break;
        }
    case 0xe845:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e84e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
    case 0xe86b:
        push(r16[cx]);
        r16[bx] = 0;
        r16[ax] = memory16get(ss, bp + 14);
        r8[ch] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[cl] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dh] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dl] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[ah] = memory[es*16 + r16[bx] + r16[di]];
        r8[ah] ^= 0xff;
        r16[di]++;
        r8[bl] = 0x04;
    case 0xe88e:
        r8[al] = 0;
        if (!(r8[ah] & 0x80)) {
            pc = 0xe897;
            break;
        }
        r8[al] = 0xf0;
    case 0xe897:
        if (!(r8[ah] & 0x40)) {
            pc = 0xe89e;
            break;
        }
        r8[al] |= 0x0f;
    case 0xe89e:
        r8[ah] <<= 1;
        r8[ah] <<= 1;
        memory[ds*16 + r16[si]] = r8[al];
        r16[si]++;
        r8[bh] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bh] += flags.carry;
        memory[ds*16 + r16[si]] = r8[bh];
        r16[si]++;
        r8[bl]--;
        if (r8[bl] != 0) {
            pc = 0xe88e;
            break;
        }
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xe8ea;
            break;
        }
        pc = 0xe86b;
        break;
    case 0xe8ea:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_e8f3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[cx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
    case 0xe910:
        push(r16[cx]);
        r16[bx] = 0;
        r16[ax] = memory16get(ss, bp + 14);
        r8[ch] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[cl] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dh] = memory[es*16 + r16[bx] + r16[di]];
        r16[bx] += r16[ax];
        r8[dl] = memory[es*16 + r16[bx] + r16[di]];
        r16[di]++;
        r8[bl] = 0x04;
    case 0xe92b:
        r8[bh] = 0;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[dl] & 0x80);
        r8[dl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[dh] & 0x80);
        r8[dh] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[cl] & 0x80);
        r8[cl] <<= 1;
        r8[bh] += flags.carry;
        r8[bh] <<= 1;
        flags.carry = !!(r8[ch] & 0x80);
        r8[ch] <<= 1;
        r8[bh] += flags.carry;
        memory[ds*16 + r16[si]] = r8[bh];
        r16[si]++;
        r8[bl]--;
        if (r8[bl] != 0) {
            pc = 0xe92b;
            break;
        }
        r16[cx] = pop();
        r16[cx]--;
        if (r16[cx] == 0) {
            pc = 0xe970;
            break;
        }
        pc = 0xe910;
        break;
    case 0xe970:
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ec4a() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(r16[di]);
    push(r16[cx]);
    flags.direction = false;
    r16[ax] = memory16get(ss, bp + 8);
    es = r16[ax];
    r16[di] = memory16get(ss, bp + 10);
    r16[ax] = memory16get(ss, bp + 6);
    r16[cx] = 0x7d00;
    rep_stosw_data_forward();
    r16[cx] = pop();
    r16[di] = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_ec66() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xec87:
        push(r16[si]);
        r16[cx] = 0x0010;
        rep_movsb_data_data_forward();
        r16[si] = pop();
        r16[si] += 0x0140;
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xec87;
            break;
        }
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ec9e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[cx] = memory16get(ss, bp + 14);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xecbf:
        push(r16[si]);
        push(r16[cx]);
    case 0xecc1:
        r8[al] = memory[es*16 + r16[di]];
        if (!(r8[al] & 0x80)) {
            pc = 0xeccc;
            break;
        }
        r8[al] &= 0x7f;
        memory[ds*16 + r16[si]] = r8[al];
    case 0xeccc:
        r16[si]++;
        r16[di]++;
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xecc1;
            break;
        }
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0140;
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xecbf;
            break;
        }
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ece3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[cx] = memory16get(ss, bp + 14);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xed04:
        push(r16[si]);
        push(r16[cx]);
        r16[ax] = memory16get(ss, bp + 18);
        r16[di] += r16[ax];
    case 0xed0b:
        r8[al] = memory[es*16 + r16[di]];
        if (!(r8[al] & 0x80)) {
            pc = 0xed16;
            break;
        }
        r8[al] &= 0x7f;
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed16:
        r16[si]++;
        r16[di]++;
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xed0b;
            break;
        }
        r16[ax] = memory16get(ss, bp + 20);
        r16[di] += r16[ax];
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0140;
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xed04;
            break;
        }
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ed32() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 12);
        r16[cx] = memory16get(ss, bp + 14);
        r16[dx] = memory16get(ss, bp + 16);
        r16[ax] = memory16get(ss, bp + 18);
    case 0xed56:
        push(r16[si]);
        push(r16[cx]);
    case 0xed58:
        r8[ah] = memory[es*16 + r16[di]];
        if (!(r8[ah] & 0x80)) {
            pc = 0xed62;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed62:
        r16[si]++;
        if (!(r8[ah] & 0x40)) {
            pc = 0xed6a;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed6a:
        r16[si]++;
        if (!(r8[ah] & 0x20)) {
            pc = 0xed72;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed72:
        r16[si]++;
        if (!(r8[ah] & 0x10)) {
            pc = 0xed7a;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed7a:
        r16[si]++;
        if (!(r8[ah] & 0x08)) {
            pc = 0xed82;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed82:
        r16[si]++;
        if (!(r8[ah] & 0x04)) {
            pc = 0xed8a;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed8a:
        r16[si]++;
        if (!(r8[ah] & 0x02)) {
            pc = 0xed92;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed92:
        r16[si]++;
        if (!(r8[ah] & 0x01)) {
            pc = 0xed9a;
            break;
        }
        memory[ds*16 + r16[si]] = r8[al];
    case 0xed9a:
        r16[si]++;
        r16[di]++;
        r16[cx]--;
        if (r16[cx] != 0) {
            pc = 0xed58;
            break;
        }
        r16[cx] = pop();
        r16[si] = pop();
        r16[si] += 0x0140;
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xed56;
            break;
        }
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_edb1() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    flags.direction = false;
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[cx]);
    push(r16[dx]);
    r16[ax] = memory16get(ss, bp + 6);
    ds = r16[ax];
    r16[si] = memory16get(ss, bp + 8);
    r16[ax] = memory16get(ss, bp + 10);
    es = r16[ax];
    r16[di] = memory16get(ss, bp + 12);
    r16[cx] = 0x7d00;
    rep_movsw_data_data_forward();
    r16[dx] = pop();
    r16[cx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_edd8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(ds);
        push(es);
        push(r16[si]);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        ds = r16[ax];
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 12);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 16);
    case 0xedf9:
        push(r16[di]);
        r16[cx] = 0x0010;
        rep_movsb_data_data_forward();
        r16[di] = pop();
        r16[di] += 0x0140;
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xedf9;
            break;
        }
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        r16[si] = pop();
        es = pop();
        ds = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ee10() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        flags.direction = false;
        push(bp);
        bp = sp;
        push(es);
        push(r16[di]);
        push(r16[dx]);
        push(r16[cx]);
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        es = r16[ax];
        r16[di] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        r16[cx] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 14);
    case 0xee2a:
        push(r16[di]);
        push(r16[cx]);
        rep_stosb_data_forward();
        r16[cx] = pop();
        r16[di] = pop();
        r16[di] += 0x0140;
        r16[dx]--;
        if (r16[dx] != 0) {
            pc = 0xee2a;
            break;
        }
        r16[ax] = pop();
        r16[cx] = pop();
        r16[dx] = pop();
        r16[di] = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ee3e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[cx]);
        push(r16[dx]);
        r16[bx] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 10);
        es = r16[ax];
        r16[dx] = memory16get(ss, bp + 12);
        r16[di] = r16[dx];
        r16[dx] = 0x03da;
    case 0xee5a:
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x08;
        if (r8[al] == 0) {
            pc = 0xee5a;
            break;
        }
        r16[ax] = r16[cx];
        r16[cx] += r16[cx];
        r16[cx] += r16[ax];
        r16[dx] = 0x03c8;
        r8[al] = r8[bl];
        out8(r16[dx], r8[al]);
        r16[dx]++;
    case 0xee6c:
        r8[al] = memory[es*16 + r16[di]];
        out8(r16[dx], r8[al]);
        r16[di]++;
        if (--r16[cx]) {
            pc = 0xee6c;
            break;
        }
        r16[dx] = pop();
        r16[cx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ee7b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory[ds*16 + 0x91a2] != 0x46) {
            pc = 0xee8d;
            break;
        }
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        pc = 0xeece;
        break;
    case 0xee8d:
        if (memory[ds*16 + 0x91a2] != 0x47) {
            pc = 0xee9c;
            break;
        }
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 10);
        pc = 0xeece;
        break;
    case 0xee9c:
        if (memory[ds*16 + 0x91a2] != 0x49) {
            pc = 0xeeab;
            break;
        }
        r16[dx] = memory16get(ss, bp + 16);
        r16[ax] = memory16get(ss, bp + 14);
        pc = 0xeece;
        break;
    case 0xeeab:
        if (memory[ds*16 + 0x91a2] != 0x53) {
            pc = 0xeeba;
            break;
        }
        r16[dx] = memory16get(ss, bp + 20);
        r16[ax] = memory16get(ss, bp + 18);
        pc = 0xeece;
        break;
    case 0xeeba:
        if (memory[ds*16 + 0x91a2] == 0x45) {
            pc = 0xeec8;
            break;
        }
        if (memory[ds*16 + 0x91a2] != 0x00) {
            pc = 0xeece;
            break;
        }
    case 0xeec8:
        r16[dx] = memory16get(ss, bp + 24);
        r16[ax] = memory16get(ss, bp + 22);
    case 0xeece:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_eed0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory[ds*16 + 0x91a2] != 0x46) {
            pc = 0xeee2;
            break;
        }
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        pc = 0xef23;
        break;
    case 0xeee2:
        if (memory[ds*16 + 0x91a2] != 0x47) {
            pc = 0xeef1;
            break;
        }
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 10);
        pc = 0xef23;
        break;
    case 0xeef1:
        if (memory[ds*16 + 0x91a2] != 0x49) {
            pc = 0xef00;
            break;
        }
        r16[dx] = memory16get(ss, bp + 16);
        r16[ax] = memory16get(ss, bp + 14);
        pc = 0xef23;
        break;
    case 0xef00:
        if (memory[ds*16 + 0x91a2] != 0x53) {
            pc = 0xef0f;
            break;
        }
        r16[dx] = memory16get(ss, bp + 20);
        r16[ax] = memory16get(ss, bp + 18);
        pc = 0xef23;
        break;
    case 0xef0f:
        if (memory[ds*16 + 0x91a2] == 0x45) {
            pc = 0xef1d;
            break;
        }
        if (memory[ds*16 + 0x91a2] != 0x00) {
            pc = 0xef23;
            break;
        }
    case 0xef1d:
        r16[dx] = memory16get(ss, bp + 24);
        r16[ax] = memory16get(ss, bp + 22);
    case 0xef23:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ef25() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp--;
        sp--;
    case 0xef2a:
        r8[al] = memory[ds*16 + 0x91ac];
        memory[ss*16 + bp - 1] = r8[al];
        if (!r8[al]) {
            pc = 0xef2a;
            break;
        }
    case 0xef34:
        yield* sync();
        if (memory[ds*16 + 0x91ac] != 0x00) {
            pc = 0xef34;
            break;
        }
        if (memorys[ss*16 + bp - 1] >= signed8(0x32)) {
            pc = 0xef2a;
            break;
        }
        memory[ss*16 + bp - 1] -= 1;
        if (memory[ds*16 + 0x91a2] == 0x45) {
            pc = 0xef52;
            break;
        }
        if (memory[ds*16 + 0x91a2] != 0x00) {
            pc = 0xef61;
            break;
        }
    case 0xef52:
        r8[al] = memory[ss*16 + bp - 1];
        cbw();
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 2461];
        memory[ss*16 + bp - 2] = r8[al];
        pc = 0xef6e;
        break;
    case 0xef61:
        r8[al] = memory[ss*16 + bp - 1];
        cbw();
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 2412];
        memory[ss*16 + bp - 2] = r8[al];
    case 0xef6e:
        if (memory[ss*16 + bp - 2] == 0x00) {
            pc = 0xef2a;
            break;
        }
        r8[al] = memory[ss*16 + bp - 2];
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_ef7b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        push(r16[ax]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        push(es);
        push(ds);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = 0x1f86;
        ds = bp;
        bp = sp;
        sp--;
        sp--;
        r8[al] = in8(0x60);
        memory[ds*16 + 0x8b95] = r8[al];
        r8[al] = in8(0x61);
        memory[ss*16 + bp - 1] = r8[al];
        if (!(memory[ds*16 + 0x8b95] & 0x80)) {
            pc = 0xefa5;
            break;
        }
        memory[ds*16 + 0x91ac] = 0x00;
        pc = 0xefab;
        break;
    case 0xefa5:
        r8[al] = memory[ds*16 + 0x8b95];
        memory[ds*16 + 0x91ac] = r8[al];
    case 0xefab:
        r8[al] = memory[ss*16 + bp - 1];
        r8[al] |= 0x80;
        out8(0x61, r8[al]);
        r8[al] = memory[ss*16 + bp - 1];
        out8(0x61, r8[al]);
        r8[al] = 0x20;
        out8(0x20, r8[al]);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        ds = pop();
        es = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[ax] = pop();
        stop();
        return;
    } while (1);
}
function* sub_efc8() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f09f();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    memory16set(ds, 0x8a68, r16[dx]);
    memory16set(ds, 0x8a66, r16[ax]);
    r16[ax] = 0x010b;
    r16[dx] = cs;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0ee7);
    sp += 0x0006;
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f09f();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    memory16set(ds, 0x8ba0, r16[dx]);
    memory16set(ds, 0x8b9e, r16[ax]);
    r16[ax] = 0x0019;
    r16[dx] = 0x0ba1;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0ee7);
    sp += 0x0006;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_f014() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(memory16get(ds, 0x8a68));
    push(memory16get(ds, 0x8a66));
    r16[ax] = 0x0009;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0ee7);
    sp += 0x0006;
    push(memory16get(ds, 0x8ba0));
    push(memory16get(ds, 0x8b9e));
    r16[ax] = 0x0024;
    push(r16[ax]);
    push(cs);
    cs = 0x1f09;
    yield* sub_1f0af();
    assert(cs == 0x0ee7);
    sp += 0x0006;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_f03d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[si] = 0x8000;
        r8[al] = 0x0f;
        r16[dx] = 0x03b4;
        out8(r16[dx], r8[al]);
        r16[dx] = 0x03b5;
        r8[al] = in8(r16[dx]);
        memory[ss*16 + bp - 2] = r8[al];
        r8[al] = 0x66;
        out8(r16[dx], r8[al]);
        r8[al] = in8(r16[dx]);
        memory[ss*16 + bp - 1] = r8[al];
        r8[al] = memory[ss*16 + bp - 2];
        out8(r16[dx], r8[al]);
        if (memory[ss*16 + bp - 1] != 0x66) {
            pc = 0xf08f;
            break;
        }
        r16[dx] = 0x03ba;
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x80;
        memory[ss*16 + bp - 2] = r8[al];
    case 0xf06e:
        r16[dx] = 0x03ba;
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x80;
        memory[ss*16 + bp - 1] = r8[al];
        r16[ax] = r16[si];
        r16[si]--;
        if (!r16[ax]) {
            pc = 0xf087;
            break;
        }
        r8[al] = memory[ss*16 + bp - 1];
        if (r8[al] == memory[ss*16 + bp - 2]) {
            pc = 0xf06e;
            break;
        }
    case 0xf087:
        r8[al] = memory[ss*16 + bp - 1];
        if (r8[al] != memory[ss*16 + bp - 2]) {
            pc = 0xf093;
            break;
        }
    case 0xf08f:
        r16[ax] = 0;
        pc = 0xf096;
        break;
    case 0xf093:
        r16[ax] = 0x0001;
    case 0xf096:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f09b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[si] = memory16get(ss, bp + 10);
        memory[ds*16 + 0x92e1] = 0x00;
        r16[ax] = r16[si];
        memory[ds*16 + 0x92e0] = r8[al];
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0ee7);
        sp += 0x000a;
        memory[ds*16 + 0x92e1] = 0x0f;
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0ee7);
        sp += 0x000a;
        r8[al] = memory[ds*16 + 0x8d62];
        r8[ah] = 0x00;
        r16[di] = r16[ax];
        if (r16[di] != r16[si]) {
            pc = 0xf104;
            break;
        }
        if (signed16(r16[si]) <= signed16(0x000c)) {
            pc = 0xf108;
            break;
        }
        memory16set(ss, bp - 2, 0x0040);
        memory16set(ss, bp - 4, 0x0088);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memoryBiosGet(es, r16[bx]) != 0x00) {
            pc = 0xf108;
            break;
        }
    case 0xf104:
        r16[ax] = 0;
        pc = 0xf10b;
        break;
    case 0xf108:
        r16[ax] = 0x0001;
    case 0xf10b:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f111() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        r16[si] = 0;
        push(cs);
        cs = 0x0cb4;
        yield* sub_cb4e();
        assert(cs == 0x0ee7);
        if (!r8[al]) {
            pc = 0xf122;
            break;
        }
        r16[si] = 0x0001;
        pc = 0xf12e;
        break;
    case 0xf122:
        push(cs);
        cs = 0x0cb4;
        yield* sub_cb77();
        assert(cs == 0x0ee7);
        if (!r8[al]) {
            pc = 0xf12e;
            break;
        }
        r16[si] = 0x0002;
    case 0xf12e:
        r16[ax] = r16[si];
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_f132() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[si] = 0;
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f09;
        yield* sub_1f09f();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] |= r16[dx];
        if (!r16[ax]) {
            pc = 0xf1a8;
            break;
        }
        memory16set(ds, 0x92e0, 0x0000);
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0ee7);
        sp += 0x000a;
        r16[si] = memory16get(ds, 0x8d62);
        if (r16[si] != 0xffff) {
            pc = 0xf17a;
            break;
        }
        r16[si] = 0x0001;
        pc = 0xf17c;
        break;
    case 0xf17a:
        r16[si] = 0;
    case 0xf17c:
        if (!r16[si]) {
            pc = 0xf1a8;
            break;
        }
        memory16set(ds, 0x92e0, 0x0004);
        memory16set(ds, 0x92e4, 0x0140);
        memory16set(ds, 0x92e6, 0x0064);
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0ee7);
        sp += 0x000a;
    case 0xf1a8:
        r16[ax] = r16[si];
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f1af() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[si] = 0;
        memory16set(ss, bp - 2, 0xffff);
        memory16set(ss, bp - 4, 0x000e);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memoryBiosGet(es, r16[bx]) != 0xff) {
            pc = 0xf1df;
            break;
        }
        memory16set(ss, bp - 2, 0xfc00);
        memory16set(ss, bp - 4, r16[si]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memory[es*16 + r16[bx]] != 0x21) {
            pc = 0xf1df;
            break;
        }
        r16[si] = 0x0001;
    case 0xf1df:
        r16[ax] = r16[si];
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f1e6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = 0;
        flags.interrupts = false;
        memory[ds*16 + 0x92e1] = 0x06;
        memory16set(ds, 0x92e2, r16[si]);
        memory16set(ds, 0x92ec, r16[si]);
        push(ds);
        r16[ax] = 0x8d62;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92e0;
        push(r16[ax]);
        r16[ax] = 0x0015;
        push(r16[ax]);
        push(cs);
        cs = 0x1f0d;
        yield* sub_1f0d4();
        assert(cs == 0x0ee7);
        sp += 0x000a;
        if (memory16get(ds, 0x8d6e) == 0x0001) {
            pc = 0xf21e;
            break;
        }
        if (memory16get(ds, 0x8d64) == 0x0000) {
            pc = 0xf21e;
            break;
        }
        r16[si] = 0x0001;
    case 0xf21e:
        flags.interrupts = true;
        r16[ax] = r16[si];
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f223() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    r16[ax] = 0x01b8;
    push(r16[ax]);
    push(cs);
    cs = 0x1f5c;
    yield* sub_1f5c9();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    r16[ax] = 0x0064;
    push(r16[ax]);
    push(cs);
    cs = 0x1e9e;
    yield* sub_1e9e2();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    push(cs);
    cs = 0x1f5c;
    yield* sub_1f5f5();
    assert(cs == 0x0ee7);
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_f23f() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(memory16get(ds, 0x8de0));
    push(cs);
    cs = 0x127c;
    yield* sub_127ed();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    r8[al] = memory[ds*16 + 0x8dbb];
    r8[ah] = 0x00;
    push(r16[ax]);
    push(cs);
    cs = 0x127c;
    yield* sub_12809();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    push(cs);
    cs = 0x127c;
    yield* sub_12825();
    assert(cs == 0x0ee7);
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_f25d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[di] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 2, 0x0000);
        r16[si] = 0;
    case 0xf26f:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x40)) {
            pc = 0xf28d;
            break;
        }
        r16[si]++;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        if (r16[si] <= 0x00fa) {
            pc = 0xf26f;
            break;
        }
        pc = 0xf379;
        break;
    case 0xf28d:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = 0xff;
        out8(r16[dx], r8[al]);
        r16[si] = 0;
    case 0xf295:
        if (r16[si] >= 0x00fa) {
            pc = 0xf2b2;
            break;
        }
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x80)) {
            pc = 0xf2b2;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        r16[si]++;
        pc = 0xf295;
        break;
    case 0xf2b2:
        if (r16[si] >= 0x00fa) {
            pc = 0xf322;
            break;
        }
        r16[dx] = r16[di];
        r8[al] = in8(r16[dx]);
        r8[ah] = 0x00;
        memory16set(ss, bp - 4, r16[ax]);
        if (r16[ax] == 0x00fe) {
            pc = 0xf2c8;
            break;
        }
        pc = 0xf379;
        break;
    case 0xf2c8:
        memory16set(ds, 0x8a2a, 0x0000);
        r16[si] = 0;
    case 0xf2d0:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x40)) {
            pc = 0xf2ee;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        r16[si]++;
        if (r16[si] <= 0x00fa) {
            pc = 0xf2d0;
            break;
        }
        pc = 0xf379;
        break;
    case 0xf2ee:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = 0x3f;
        out8(r16[dx], r8[al]);
        r16[si] = 0;
    case 0xf2f6:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x80)) {
            pc = 0xf313;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        r16[si]++;
        if (r16[si] <= 0x00fa) {
            pc = 0xf2f6;
            break;
        }
        pc = 0xf379;
        break;
    case 0xf313:
        r16[dx] = r16[di];
        r8[al] = in8(r16[dx]);
        r8[ah] = 0x00;
        memory16set(ss, bp - 4, r16[ax]);
        if (r16[ax] != 0x00fe) {
            pc = 0xf379;
            break;
        }
        pc = 0xf37d;
        break;
    case 0xf322:
        memory16set(ds, 0x8a2a, 0x0001);
        r16[si] = 0;
    case 0xf32a:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x40)) {
            pc = 0xf347;
            break;
        }
        r16[si]++;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        if (r16[si] <= 0x00fa) {
            pc = 0xf32a;
            break;
        }
        pc = 0xf379;
        break;
    case 0xf347:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = 0x3f;
        out8(r16[dx], r8[al]);
        r16[si] = 0;
    case 0xf34f:
        r16[dx] = r16[di];
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (!(r8[al] & 0x80)) {
            pc = 0xf36c;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        r16[si]++;
        if (r16[si] <= 0x00fa) {
            pc = 0xf34f;
            break;
        }
        pc = 0xf379;
        break;
    case 0xf36c:
        r16[dx] = r16[di];
        r8[al] = in8(r16[dx]);
        r8[ah] = 0x00;
        memory16set(ss, bp - 4, r16[ax]);
        if (r16[ax] == 0x00fe) {
            pc = 0xf37d;
            break;
        }
    case 0xf379:
        r16[ax] = 0;
        pc = 0xf384;
        break;
    case 0xf37d:
        memory16set(ds, 0x8f7c, r16[di]);
        r16[ax] = 0x0001;
    case 0xf384:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f38a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        r8[al] = 0x00;
        memory[ds*16 + 0x881d] = r8[al];
        memory[ds*16 + 0x8810] = r8[al];
        memory[ds*16 + 0x881a] = r8[al];
        memory[ds*16 + 0x8811] = r8[al];
        memory[ds*16 + 0x8819] = r8[al];
        memory[ds*16 + 0x881b] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8818] = r8[al];
        memory[ds*16 + 0x8816] = r8[al];
        memory[ds*16 + 0x881e] = 0x00;
        memory[ds*16 + 0x881c] = 0x00;
        r16[ax] = 0x0012;
        push(r16[ax]);
        push(cs);
        yield* sub_f09b();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0xf3c3;
            break;
        }
        memory[ds*16 + 0x881b] = 0x01;
    case 0xf3c3:
        r16[ax] = 0x0013;
        push(r16[ax]);
        push(cs);
        yield* sub_f09b();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0xf3d6;
            break;
        }
        memory[ds*16 + 0x8819] = 0x01;
    case 0xf3d6:
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        yield* sub_f09b();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0xf3e9;
            break;
        }
        memory[ds*16 + 0x8811] = 0x01;
    case 0xf3e9:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_f09b();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0xf3fc;
            break;
        }
        memory[ds*16 + 0x881a] = 0x01;
    case 0xf3fc:
        push(cs);
        yield* sub_f03d();
        if (!r16[ax]) {
            pc = 0xf409;
            break;
        }
        memory[ds*16 + 0x881d] = 0x01;
    case 0xf409:
        push(cs);
        yield* sub_f1af();
        if (!r16[ax]) {
            pc = 0xf416;
            break;
        }
        memory[ds*16 + 0x8810] = 0x01;
    case 0xf416:
        push(cs);
        yield* sub_f132();
        if (!r16[ax]) {
            pc = 0xf423;
            break;
        }
        memory[ds*16 + 0x8816] = 0x01;
    case 0xf423:
        push(cs);
        yield* sub_f111();
        memory[ds*16 + 0x8818] = r8[al];
        r8[ah] = 0x00;
        memory16set(ds, 0x8d74, r16[ax]);
        r16[ax] = 0x0388;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11cd0();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        r16[ax] = 1;
        if (!r16[ax]) {
            pc = 0xf443;
            break;
        }
        memory[ds*16 + 0x881e] = 0x01;
    case 0xf443:
        r16[ax] = 0x0300;
        push(r16[ax]);
        push(cs);
        yield* sub_f25d();
        sp++;
        sp++;
        if (r16[ax]) {
            pc = 0xf45f;
            break;
        }
        r16[ax] = 0x0330;
        push(r16[ax]);
        push(cs);
        yield* sub_f25d();
        sp++;
        sp++;
        r16[ax] = 1;
        if (!r16[ax]) {
            pc = 0xf464;
            break;
        }
    case 0xf45f:
        memory[ds*16 + 0x881c] = 0x01;
    case 0xf464:
        r8[al] = memory[ds*16 + 0x881c];
        r8[ah] = 0x00;
        memory16set(ds, 0x92c4, r16[ax]);
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f46d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        if (memory[ds*16 + 0x8812] == 0x00) {
            pc = 0xf487;
            break;
        }
        memory16set(ss, bp - 2, 0xb800);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0xf491;
        break;
    case 0xf487:
        memory16set(ss, bp - 2, 0xb000);
        memory16set(ss, bp - 4, 0x0000);
    case 0xf491:
        r16[si] = 0;
        pc = 0xf4a2;
        break;
    case 0xf495:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        videoSet16(es, r16[bx], 0x0000);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0002);
        r16[si]++;
    case 0xf4a2:
        if (signed16(r16[si]) < signed16(0x07d0)) {
            pc = 0xf495;
            break;
        }
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f4ad() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        if (memory[ds*16 + 0x8812] != 0x00) {
            pc = 0xf4d0;
            break;
        }
        memory16set(ss, bp + 10, 0x0007);
        memory16set(ss, bp + 12, 0x0000);
        memory16set(ss, bp - 2, 0xb000);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0xf4da;
        break;
    case 0xf4d0:
        memory16set(ss, bp - 2, 0xb800);
        memory16set(ss, bp - 4, 0x0000);
    case 0xf4da:
        r8[al] = memory[ss*16 + bp + 12];
        r16[cx] = 0x0004;
        r8[al] <<= r8[cl];
        r8[al] |= memory[ss*16 + bp + 10];
        r8[dl] = memory[ss*16 + bp + 14];
        r16[cx] = 0x0007;
        r8[dl] <<= r8[cl];
        r8[al] |= r8[dl];
        r8[al] |= 0x08;
        memory[ss*16 + bp - 6] = r8[al];
        r16[ax] = memory16get(ss, bp + 8);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[ax] += memory16get(ss, bp + 6);
        r16[ax] <<= 1;
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + r16[ax]);
    case 0xf505:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 5] = r8[al];
        if (!r8[al]) {
            pc = 0xf52f;
            break;
        }
        r8[al] = memory[ss*16 + bp - 5];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        videoSet(es, r16[bx], r8[al]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        r8[al] = memory[ss*16 + bp - 6];
        r16[bx] = memory16get(ss, bp - 4);
        videoSet(es, r16[bx], r8[al]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        memory16set(ss, bp + 16, memory16get(ss, bp + 16) + 1);
        pc = 0xf505;
        break;
    case 0xf52f:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f533() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = 0;
    case 0xf539:
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory16set(ss, bp + 8, memory16get(ss, bp + 8) + 1);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0xf548;
            break;
        }
        r16[si]++;
        pc = 0xf539;
        break;
    case 0xf548:
        r16[ax] = r16[si];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f54d() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(cs);
    yield* sub_f46d();
    push(memory16get(ds, 0x05c2));
    push(memory16get(ds, 0x05c0));
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x000a;
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(memory16get(ds, 0x05c2));
    push(memory16get(ds, 0x05c0));
    push(cs);
    yield* sub_f533();
    sp += 0x0004;
    r16[ax] >>= 1;
    r16[dx] = pop();
    r16[dx] -= r16[ax];
    push(r16[dx]);
    push(cs);
    yield* sub_f4ad();
    sp += 0x000e;
    push(memory16get(ds, 0x05c6));
    push(memory16get(ds, 0x05c4));
    r16[ax] = 0;
    push(r16[ax]);
    push(r16[ax]);
    r16[ax] = 0x000f;
    push(r16[ax]);
    r16[ax] = 0x000c;
    push(r16[ax]);
    r16[ax] = 0x0028;
    push(r16[ax]);
    push(memory16get(ds, 0x05c6));
    push(memory16get(ds, 0x05c4));
    push(cs);
    yield* sub_f533();
    sp += 0x0004;
    r16[ax] >>= 1;
    r16[dx] = pop();
    r16[dx] -= r16[ax];
    push(r16[dx]);
    push(cs);
    yield* sub_f4ad();
    sp += 0x000e;
    r16[ax] = 0x05dc;
    push(r16[ax]);
    push(cs);
    cs = 0x1e9e;
    yield* sub_1e9e2();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    push(cs);
    yield* sub_f46d();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_f5c9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        memory16set(ss, bp - 6, 0x002a);
        push(cs);
        yield* sub_f46d();
        r16[di] = memory16get(ss, bp + 14);
        r16[di] <<= 1;
        r16[di] += 0x000b;
        r16[ax] = 0x0028;
        r16[dx] = memory16get(ss, bp - 6);
        r16[dx] >>= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp - 4, r16[ax]);
        r16[si] = 0x000c;
        r16[ax] = r16[di];
        r16[ax] >>= 1;
        r16[si] -= r16[ax];
        push(ds);
        r16[ax] = 0x18f4;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        memory16set(ss, bp - 2, 0x0000);
        pc = 0xf63e;
        break;
    case 0xf61a:
        push(ds);
        r16[ax] = 0x191f;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax]++;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 1);
    case 0xf63e:
        r16[ax] = r16[di];
        r16[ax] += 0xfffe;
        if (r16[ax] > memory16get(ss, bp - 2)) {
            pc = 0xf61a;
            break;
        }
        push(ds);
        r16[ax] = 0x194a;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        r16[ax]--;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ds, 0x08ba));
        push(memory16get(ds, 0x08b8));
        push(memory16get(ds, 0x0806));
        push(memory16get(ds, 0x0804));
        push(memory16get(ds, 0x0752));
        push(memory16get(ds, 0x0750));
        push(memory16get(ds, 0x069e));
        push(memory16get(ds, 0x069c));
        push(memory16get(ds, 0x05ca));
        push(memory16get(ds, 0x05c8));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08ba));
        push(memory16get(ds, 0x08b8));
        push(memory16get(ds, 0x0806));
        push(memory16get(ds, 0x0804));
        push(memory16get(ds, 0x0752));
        push(memory16get(ds, 0x0750));
        push(memory16get(ds, 0x069e));
        push(memory16get(ds, 0x069c));
        push(memory16get(ds, 0x05ca));
        push(memory16get(ds, 0x05c8));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x1975;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x0002;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ds, 0x08be));
        push(memory16get(ds, 0x08bc));
        push(memory16get(ds, 0x080a));
        push(memory16get(ds, 0x0808));
        push(memory16get(ds, 0x0756));
        push(memory16get(ds, 0x0754));
        push(memory16get(ds, 0x06a2));
        push(memory16get(ds, 0x06a0));
        push(memory16get(ds, 0x05ce));
        push(memory16get(ds, 0x05cc));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x0004;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08be));
        push(memory16get(ds, 0x08bc));
        push(memory16get(ds, 0x080a));
        push(memory16get(ds, 0x0808));
        push(memory16get(ds, 0x0756));
        push(memory16get(ds, 0x0754));
        push(memory16get(ds, 0x06a2));
        push(memory16get(ds, 0x06a0));
        push(memory16get(ds, 0x05ce));
        push(memory16get(ds, 0x05cc));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ds, 0x08c6));
        push(memory16get(ds, 0x08c4));
        push(memory16get(ds, 0x0812));
        push(memory16get(ds, 0x0810));
        push(memory16get(ds, 0x075e));
        push(memory16get(ds, 0x075c));
        push(memory16get(ds, 0x06aa));
        push(memory16get(ds, 0x06a8));
        push(memory16get(ds, 0x05d6));
        push(memory16get(ds, 0x05d4));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        r16[ax] += 0xfffe;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08c6));
        push(memory16get(ds, 0x08c4));
        push(memory16get(ds, 0x0812));
        push(memory16get(ds, 0x0810));
        push(memory16get(ds, 0x075e));
        push(memory16get(ds, 0x075c));
        push(memory16get(ds, 0x06aa));
        push(memory16get(ds, 0x06a8));
        push(memory16get(ds, 0x05d6));
        push(memory16get(ds, 0x05d4));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ds, 0x08c2));
        push(memory16get(ds, 0x08c0));
        push(memory16get(ds, 0x080e));
        push(memory16get(ds, 0x080c));
        push(memory16get(ds, 0x075a));
        push(memory16get(ds, 0x0758));
        push(memory16get(ds, 0x06a6));
        push(memory16get(ds, 0x06a4));
        push(memory16get(ds, 0x05d2));
        push(memory16get(ds, 0x05d0));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        r16[ax] += 0xfffd;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08c2));
        push(memory16get(ds, 0x08c0));
        push(memory16get(ds, 0x080e));
        push(memory16get(ds, 0x080c));
        push(memory16get(ds, 0x075a));
        push(memory16get(ds, 0x0758));
        push(memory16get(ds, 0x06a6));
        push(memory16get(ds, 0x06a4));
        push(memory16get(ds, 0x05d2));
        push(memory16get(ds, 0x05d0));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x199e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        r16[ax] += 0xfffc;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        r16[ax] += 0xfffb;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f925() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = 0;
        r8[al] = memory[ss*16 + bp + 8];
        cbw();
        if (r16[ax] == 0x0048) {
            pc = 0xf96c;
            break;
        }
        if (r16s[ax] > signed16(0x0048)) {
            pc = 0xf942;
            break;
        }
        if (r16[ax] == 0x0043) {
            pc = 0xf94e;
            break;
        }
        if (r16[ax] == 0x0045) {
            pc = 0xf95a;
            break;
        }
        pc = 0xf97c;
        break;
    case 0xf942:
        if (r16[ax] == 0x0054) {
            pc = 0xf975;
            break;
        }
        if (r16[ax] == 0x0056) {
            pc = 0xf963;
            break;
        }
        pc = 0xf97c;
        break;
    case 0xf94e:
        if (memory[ds*16 + 0x881a] == 0x00) {
            pc = 0xf97c;
            break;
        }
    case 0xf955:
        r16[si] = 0x0001;
        pc = 0xf97c;
        break;
    case 0xf95a:
        if (memory[ds*16 + 0x8811] == 0x00) {
            pc = 0xf97c;
            break;
        }
        pc = 0xf955;
        break;
    case 0xf963:
        if (memory[ds*16 + 0x881b] == 0x00) {
            pc = 0xf97c;
            break;
        }
        pc = 0xf955;
        break;
    case 0xf96c:
        if (memory[ds*16 + 0x881d] == 0x00) {
            pc = 0xf97c;
            break;
        }
        pc = 0xf955;
        break;
    case 0xf975:
        if (memory[ds*16 + 0x8810] != 0x00) {
            pc = 0xf955;
            break;
        }
    case 0xf97c:
        r16[ax] = r16[si];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f981() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = 0;
        r8[al] = memory[ss*16 + bp + 8];
        cbw();
        if (r16[ax] == 0x004e) {
            pc = 0xf9aa;
            break;
        }
        if (r16s[ax] > signed16(0x004e)) {
            pc = 0xf99e;
            break;
        }
        if (r16[ax] == 0x0041) {
            pc = 0xf9af;
            break;
        }
        if (r16[ax] == 0x0049) {
            pc = 0xf9aa;
            break;
        }
        pc = 0xf9c8;
        break;
    case 0xf99e:
        if (r16[ax] == 0x0052) {
            pc = 0xf9c1;
            break;
        }
        if (r16[ax] == 0x0053) {
            pc = 0xf9b8;
            break;
        }
        pc = 0xf9c8;
        break;
    case 0xf9aa:
        r16[si] = 0x0001;
        pc = 0xf9c8;
        break;
    case 0xf9af:
        if (memory[ds*16 + 0x881e] == 0x00) {
            pc = 0xf9c8;
            break;
        }
        pc = 0xf9aa;
        break;
    case 0xf9b8:
        if (memory[ds*16 + 0x92c6] == 0x00) {
            pc = 0xf9c8;
            break;
        }
        pc = 0xf9aa;
        break;
    case 0xf9c1:
        if (memory[ds*16 + 0x881c] != 0x00) {
            pc = 0xf9aa;
            break;
        }
    case 0xf9c8:
        r16[ax] = r16[si];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_f9cd() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = 0;
        r8[al] = memory[ss*16 + bp + 8];
        cbw();
        if (r16[ax] == 0x0043) {
            pc = 0xf9e8;
            break;
        }
        if (r16[ax] == 0x004a) {
            pc = 0xf9f6;
            break;
        }
        if (r16[ax] == 0x004d) {
            pc = 0xf9ed;
            break;
        }
        pc = 0xf9fd;
        break;
    case 0xf9e8:
        r16[si] = 0x0001;
        pc = 0xf9fd;
        break;
    case 0xf9ed:
        if (memory[ds*16 + 0x8816] == 0x00) {
            pc = 0xf9fd;
            break;
        }
        pc = 0xf9e8;
        break;
    case 0xf9f6:
        if (memory[ds*16 + 0x8818] != 0x00) {
            pc = 0xf9e8;
            break;
        }
    case 0xf9fd:
        r16[ax] = r16[si];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_fa02() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        memory16set(ss, bp - 4, 0x0000);
        r16[si] = 0;
        pc = 0xfa4b;
        break;
    case 0xfa13:
        r16[ax] = r16[si];
        r16[ax] += 0x0003;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        push(memory16get(ss, bp - 10));
        push(r16[bx]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        if (r16[ax] <= memory16get(ss, bp - 4)) {
            pc = 0xfa4a;
            break;
        }
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        memory16set(ss, bp - 4, r16[ax]);
    case 0xfa4a:
        r16[si]++;
    case 0xfa4b:
        if (r16[si] < memory16get(ss, bp + 14)) {
            pc = 0xfa13;
            break;
        }
        r16[ax] = 0x0028;
        r16[dx] = memory16get(ss, bp - 4);
        r16[dx] >>= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[ax] <<= 1;
        r16[ax] += 0x000a;
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = 0x000c;
        r16[dx] = memory16get(ss, bp - 2);
        r16[dx] >>= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 0x0006);
        r16[si] = 0;
        pc = 0xfac6;
        break;
    case 0xfa7d:
        r16[ax] = r16[si];
        r16[ax] += 0x0003;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r8[al] = memory[es*16 + r16[bx]];
        cbw();
        if (r16[ax] != memory16get(ds, 0x8814)) {
            pc = 0xfaa3;
            break;
        }
        r16[di] = 0x0001;
        pc = 0xfaa5;
        break;
    case 0xfaa3:
        r16[di] = 0;
    case 0xfaa5:
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(r16[di]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 0x0002);
        r16[si]++;
    case 0xfac6:
        if (r16[si] < memory16get(ss, bp + 14)) {
            pc = 0xfa7d;
            break;
        }
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_fad1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[di] = memory16get(ss, bp + 14);
    case 0xfadc:
        push(cs);
        yield* sub_ef25();
        memory[ss*16 + bp - 1] = r8[al];
        if (memory[ss*16 + bp - 1] != 0x01) {
            pc = 0xfaed;
            break;
        }
        r16[ax] = 0;
        pc = 0xfb33;
        break;
    case 0xfaed:
        if (memory[ss*16 + bp - 1] != 0x0d) {
            pc = 0xfafc;
            break;
        }
        push(cs);
        yield* sub_f223();
        r16[ax] = 0x0002;
        pc = 0xfb33;
        break;
    case 0xfafc:
        r16[si] = 0;
        pc = 0xfb2d;
        break;
    case 0xfb00:
        r16[ax] = r16[si];
        r16[ax] += 0x0003;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        r8[al] = memory[es*16 + r16[bx]];
        if (r8[al] != memory[ss*16 + bp - 1]) {
            pc = 0xfb2c;
            break;
        }
        r8[al] = memory[ss*16 + bp - 1];
        r8[ah] = 0x00;
        memory16set(ds, 0x8814, r16[ax]);
        r16[ax] = 0x0001;
        pc = 0xfb33;
        break;
    case 0xfb2c:
        r16[si]++;
    case 0xfb2d:
        if (r16[si] < r16[di]) {
            pc = 0xfb00;
            break;
        }
        pc = 0xfadc;
        break;
    case 0xfb33:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_fb39() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0010;
        if (memory[ds*16 + 0x8812] != 0x00) {
            pc = 0xfb54;
            break;
        }
        memory16set(ss, bp - 14, 0xb000);
        memory16set(ss, bp - 16, 0x0000);
        pc = 0xfb5e;
        break;
    case 0xfb54:
        memory16set(ss, bp - 14, 0xb800);
        memory16set(ss, bp - 16, 0x0000);
    case 0xfb5e:
        r16[ax] = 0x0fa0;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        r16[si] = 0;
        pc = 0xfb8c;
        break;
    case 0xfb73:
        r16[ax] = r16[si];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp - 16);
        es = memory16get(ss, bp - 16 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[dx] = r16[si];
        r16[dx] <<= 1;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] += r16[dx];
        memory16set(es, r16[bx], r16[ax]);
        r16[si]++;
    case 0xfb8c:
        if (signed16(r16[si]) < signed16(0x07d0)) {
            pc = 0xfb73;
            break;
        }
        memory16set(ss, bp - 4, 0x0028);
        memory16set(ss, bp - 2, 0x0004);
        r16[ax] = 0x0028;
        r16[dx] = memory16get(ss, bp - 4);
        r16[dx] >>= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp - 8, r16[ax]);
        r16[ax] = 0x000c;
        r16[dx] = memory16get(ss, bp - 2);
        r16[dx] >>= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp - 6, r16[ax]);
        push(ds);
        r16[ax] = 0x19c7;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        r16[si] = 0;
        pc = 0xfbf9;
        break;
    case 0xfbd7:
        push(ds);
        r16[ax] = 0x19f0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 6);
        r16[ax] += r16[si];
        r16[ax]++;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        r16[si]++;
    case 0xfbf9:
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax] += 0xfffe;
        if (r16[ax] > r16[si]) {
            pc = 0xfbd7;
            break;
        }
        push(ds);
        r16[ax] = 0x1a19;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 6);
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax]--;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ds, 0x08ca));
        push(memory16get(ds, 0x08c8));
        push(memory16get(ds, 0x0816));
        push(memory16get(ds, 0x0814));
        push(memory16get(ds, 0x0762));
        push(memory16get(ds, 0x0760));
        push(memory16get(ds, 0x06ae));
        push(memory16get(ds, 0x06ac));
        push(memory16get(ds, 0x05da));
        push(memory16get(ds, 0x05d8));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 6);
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax] += 0xfffd;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08ca));
        push(memory16get(ds, 0x08c8));
        push(memory16get(ds, 0x0816));
        push(memory16get(ds, 0x0814));
        push(memory16get(ds, 0x0762));
        push(memory16get(ds, 0x0760));
        push(memory16get(ds, 0x06ae));
        push(memory16get(ds, 0x06ac));
        push(memory16get(ds, 0x05da));
        push(memory16get(ds, 0x05d8));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(memory16get(ds, 0x08ce));
        push(memory16get(ds, 0x08cc));
        push(memory16get(ds, 0x081a));
        push(memory16get(ds, 0x0818));
        push(memory16get(ds, 0x0766));
        push(memory16get(ds, 0x0764));
        push(memory16get(ds, 0x06b2));
        push(memory16get(ds, 0x06b0));
        push(memory16get(ds, 0x05de));
        push(memory16get(ds, 0x05dc));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 6);
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax] += 0xfffe;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08ce));
        push(memory16get(ds, 0x08cc));
        push(memory16get(ds, 0x081a));
        push(memory16get(ds, 0x0818));
        push(memory16get(ds, 0x0766));
        push(memory16get(ds, 0x0764));
        push(memory16get(ds, 0x06b2));
        push(memory16get(ds, 0x06b0));
        push(memory16get(ds, 0x05de));
        push(memory16get(ds, 0x05dc));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        push(cs);
        yield* sub_f223();
        r16[di] = 0;
    case 0xfd49:
        if (!r16[di]) {
            pc = 0xfd50;
            break;
        }
        pc = 0xfdc7;
        break;
    case 0xfd50:
        push(cs);
        yield* sub_ef25();
        r8[ah] = 0x00;
        r16[si] = r16[ax];
        if (memory[ds*16 + 0x91a2] != 0x46) {
            pc = 0xfd6f;
            break;
        }
        if (r16[si] != 0x004f) {
            pc = 0xfd67;
            break;
        }
        r16[di] = 0x0002;
    case 0xfd67:
        if (r16[si] != 0x004e) {
            pc = 0xfd6f;
            break;
        }
        r16[di] = 0x0001;
    case 0xfd6f:
        if (memory[ds*16 + 0x91a2] != 0x45) {
            pc = 0xfd86;
            break;
        }
        if (r16[si] != 0x0059) {
            pc = 0xfd7e;
            break;
        }
        r16[di] = 0x0002;
    case 0xfd7e:
        if (r16[si] != 0x004e) {
            pc = 0xfd86;
            break;
        }
        r16[di] = 0x0001;
    case 0xfd86:
        if (memory[ds*16 + 0x91a2] == 0x47) {
            pc = 0xfd90;
            break;
        }
        pc = 0xfda0;
        break;
    case 0xfd90:
        if (r16[si] != 0x004a) {
            pc = 0xfd98;
            break;
        }
        r16[di] = 0x0002;
    case 0xfd98:
        if (r16[si] != 0x004e) {
            pc = 0xfda0;
            break;
        }
        r16[di] = 0x0001;
    case 0xfda0:
        if (memory[ds*16 + 0x91a2] == 0x53) {
            pc = 0xfdb1;
            break;
        }
        if (memory[ds*16 + 0x91a2] == 0x49) {
            pc = 0xfdb1;
            break;
        }
        pc = 0xfd49;
        break;
    case 0xfdb1:
        if (r16[si] != 0x0053) {
            pc = 0xfdb9;
            break;
        }
        r16[di] = 0x0002;
    case 0xfdb9:
        if (r16[si] == 0x004e) {
            pc = 0xfdc1;
            break;
        }
        pc = 0xfd49;
        break;
    case 0xfdc1:
        r16[di] = 0x0001;
        pc = 0xfd49;
        break;
    case 0xfdc7:
        r16[di]--;
        r16[si] = 0;
        pc = 0xfde5;
        break;
    case 0xfdcc:
        r16[ax] = r16[si];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[dx] = r16[si];
        r16[dx] <<= 1;
        r16[bx] = memory16get(ss, bp - 16);
        es = memory16get(ss, bp - 16 + 2);
        r16[bx] += r16[dx];
        memory16set(es, r16[bx], r16[ax]);
        r16[si]++;
    case 0xfde5:
        if (signed16(r16[si]) < signed16(0x07d0)) {
            pc = 0xfdcc;
            break;
        }
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x0ee7);
        sp += 0x0004;
        r16[ax] = r16[di];
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_fe01() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        if (memory[ds*16 + 0x8812] != 0x00) {
            pc = 0xfe1c;
            break;
        }
        memory16set(ss, bp - 12, 0xb000);
        memory16set(ss, bp - 14, 0x0000);
        pc = 0xfe26;
        break;
    case 0xfe1c:
        memory16set(ss, bp - 12, 0xb800);
        memory16set(ss, bp - 14, 0x0000);
    case 0xfe26:
        r16[ax] = 0x0fa0;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        r16[si] = 0;
        pc = 0xfe54;
        break;
    case 0xfe3b:
        r16[ax] = r16[si];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp - 14);
        es = memory16get(ss, bp - 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[dx] = r16[si];
        r16[dx] <<= 1;
        r16[bx] = memory16get(ss, bp - 10);
        es = memory16get(ss, bp - 10 + 2);
        r16[bx] += r16[dx];
        memory16set(es, r16[bx], r16[ax]);
        r16[si]++;
    case 0xfe54:
        if (signed16(r16[si]) < signed16(0x07d0)) {
            pc = 0xfe3b;
            break;
        }
        memory16set(ss, bp - 4, 0x0020);
        memory16set(ss, bp - 2, 0x0004);
        r16[ax] = 0x0028;
        r16[dx] = memory16get(ss, bp - 4);
        r16[dx] >>= 1;
        r16[ax] -= r16[dx];
        memory16set(ss, bp - 6, r16[ax]);
        r16[di] = 0x000c;
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax] >>= 1;
        r16[di] -= r16[ax];
        push(ds);
        r16[ax] = 0x1a42;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(r16[di]);
        push(memory16get(ss, bp - 6));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        r16[si] = 0;
        pc = 0xfebb;
        break;
    case 0xfe9a:
        push(ds);
        r16[ax] = 0x1a63;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += r16[si];
        r16[ax]++;
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        r16[si]++;
    case 0xfebb:
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax] += 0xfffe;
        if (r16[ax] > r16[si]) {
            pc = 0xfe9a;
            break;
        }
        push(ds);
        r16[ax] = 0x1a84;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax]--;
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        if (memory16get(ss, bp + 10) == 0x0000) {
            pc = 0xfeef;
            break;
        }
        pc = 0xff80;
        break;
    case 0xfeef:
        push(memory16get(ds, 0x08d2));
        push(memory16get(ds, 0x08d0));
        push(memory16get(ds, 0x081e));
        push(memory16get(ds, 0x081c));
        push(memory16get(ds, 0x076a));
        push(memory16get(ds, 0x0768));
        push(memory16get(ds, 0x06b6));
        push(memory16get(ds, 0x06b4));
        push(memory16get(ds, 0x05e2));
        push(memory16get(ds, 0x05e0));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax] += 0xfffd;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08d2));
        push(memory16get(ds, 0x08d0));
        push(memory16get(ds, 0x081e));
        push(memory16get(ds, 0x081c));
        push(memory16get(ds, 0x076a));
        push(memory16get(ds, 0x0768));
        push(memory16get(ds, 0x06b6));
        push(memory16get(ds, 0x06b4));
        push(memory16get(ds, 0x05e2));
        push(memory16get(ds, 0x05e0));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
        pc = 0x1000e;
        break;
    case 0xff80:
        push(memory16get(ds, 0x08d6));
        push(memory16get(ds, 0x08d4));
        push(memory16get(ds, 0x0822));
        push(memory16get(ds, 0x0820));
        push(memory16get(ds, 0x076e));
        push(memory16get(ds, 0x076c));
        push(memory16get(ds, 0x06ba));
        push(memory16get(ds, 0x06b8));
        push(memory16get(ds, 0x05e6));
        push(memory16get(ds, 0x05e4));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += memory16get(ss, bp - 2);
        r16[ax] += 0xfffd;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ds, 0x08d6));
        push(memory16get(ds, 0x08d4));
        push(memory16get(ds, 0x0822));
        push(memory16get(ds, 0x0820));
        push(memory16get(ds, 0x076e));
        push(memory16get(ds, 0x076c));
        push(memory16get(ds, 0x06ba));
        push(memory16get(ds, 0x06b8));
        push(memory16get(ds, 0x05e6));
        push(memory16get(ds, 0x05e4));
        push(cs);
        yield* sub_ee7b();
        sp += 0x0014;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_f533();
        sp += 0x0004;
        r16[ax] >>= 1;
        r16[dx] = pop();
        r16[dx] -= r16[ax];
        push(r16[dx]);
        push(cs);
        yield* sub_f4ad();
        sp += 0x000e;
    case 0x1000e:
        push(cs);
        yield* sub_f223();
        push(cs);
        yield* sub_ef25();
        r16[si] = 0;
        pc = 0x10033;
        break;
    case 0x1001a:
        r16[ax] = r16[si];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp - 10);
        es = memory16get(ss, bp - 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[dx] = r16[si];
        r16[dx] <<= 1;
        r16[bx] = memory16get(ss, bp - 14);
        es = memory16get(ss, bp - 14 + 2);
        r16[bx] += r16[dx];
        memory16set(es, r16[bx], r16[ax]);
        r16[si]++;
    case 0x10033:
        if (signed16(r16[si]) < signed16(0x07d0)) {
            pc = 0x1001a;
            break;
        }
        push(memory16get(ss, bp - 8));
        push(memory16get(ss, bp - 10));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x0ee7);
        sp += 0x0004;
        memory[ds*16 + 0x8db5] = 0x00;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10052() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[si] = 0x0005;
        memory[ss*16 + bp - 1] = 0x00;
        if (memory[ds*16 + 0x91a2] == 0x00) {
            pc = 0x1006a;
            break;
        }
        pc = 0x100e2;
        break;
    case 0x1006a:
        push(memory16get(ds, 0x05f2));
        push(memory16get(ds, 0x05f0));
        push(r16[si]);
        push(memory16get(ds, 0x05ee));
        push(memory16get(ds, 0x05ec));
        push(cs);
        yield* sub_f5c9();
        sp += 0x000a;
        r16[bx] = memory16get(ds, 0x05e8);
        es = memory16get(ds, 0x05e8 + 2);
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 7] = r8[al];
        r8[al] = memory[ss*16 + bp - 7];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
    case 0x1009c:
        if (memory[ss*16 + bp - 1] != 0x00) {
            pc = 0x100dc;
            break;
        }
        push(r16[si]);
        push(ds);
        r16[ax] = 0x05e8;
        push(r16[ax]);
        push(cs);
        yield* sub_fa02();
        sp += 0x0006;
        r8[al] = memory[ds*16 + 0x8814];
        memory[ss*16 + bp - 7] = r8[al];
        push(r16[si]);
        push(ds);
        r16[ax] = 0x05e8;
        push(r16[ax]);
        push(cs);
        yield* sub_fad1();
        sp += 0x0006;
        memory[ss*16 + bp - 1] = r8[al];
        if (memory[ss*16 + bp - 1] != 0x00) {
            pc = 0x100d0;
            break;
        }
        r16[ax] = 0x0001;
        pc = 0x100e4;
        break;
    case 0x100d0:
        if (memory[ss*16 + bp - 1] != 0x01) {
            pc = 0x100da;
            break;
        }
        memory[ss*16 + bp - 1] = 0x00;
    case 0x100da:
        pc = 0x1009c;
        break;
    case 0x100dc:
        r8[al] = memory[ds*16 + 0x8814];
        memory[ds*16 + 0x91a2] = r8[al];
    case 0x100e2:
        r16[ax] = 0;
    case 0x100e4:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_100e9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[si] = 0x0005;
        memory[ss*16 + bp - 5] = 0x00;
        push(ds);
        r16[ax] = 0x08d8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0824;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0770;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x06bc;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0608;
        push(r16[ax]);
        push(cs);
        yield* sub_eed0();
        sp += 0x0014;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        if (memory[ds*16 + 0x8dde] == 0x00) {
            pc = 0x10137;
            break;
        }
        r8[al] = memory[ds*16 + 0x8dde];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_f925();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x10137;
            break;
        }
        pc = 0x101f8;
        break;
    case 0x10137:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[si]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        yield* sub_f5c9();
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
    case 0x1015e:
        r16[bx] = memory16get(ss, bp - 10);
        es = memory16get(ss, bp - 10 + 2);
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 11] = r8[al];
        if (!r8[al]) {
            pc = 0x1017d;
            break;
        }
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        push(r16[ax]);
        push(cs);
        yield* sub_f925();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x1015e;
            break;
        }
    case 0x1017d:
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
    case 0x10184:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x101f2;
            break;
        }
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fa02();
        sp += 0x0006;
        r8[al] = memory[ds*16 + 0x8814];
        memory[ss*16 + bp - 11] = r8[al];
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fad1();
        sp += 0x0006;
        memory[ss*16 + bp - 5] = r8[al];
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x101bf;
            break;
        }
        memory[ds*16 + 0x91a2] = 0x00;
        r16[ax] = 0x0001;
        pc = 0x101fa;
        break;
    case 0x101bf:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x101c9;
            break;
        }
        memory[ss*16 + bp - 5] = 0x00;
    case 0x101c9:
        if (memory[ss*16 + bp - 5] != 0x02) {
            pc = 0x10184;
            break;
        }
        push(memory16get(ds, 0x8814));
        push(cs);
        yield* sub_f925();
        sp++;
        sp++;
        if (r16[ax]) {
            pc = 0x10184;
            break;
        }
        push(cs);
        yield* sub_fb39();
        if (r16[ax]) {
            pc = 0x10184;
            break;
        }
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
        memory[ss*16 + bp - 5] = 0x00;
        pc = 0x10184;
        break;
    case 0x101f2:
        r8[al] = memory[ds*16 + 0x8814];
        memory[ds*16 + 0x8dde] = r8[al];
    case 0x101f8:
        r16[ax] = 0;
    case 0x101fa:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_101ff() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[si] = 0x0005;
        memory[ss*16 + bp - 5] = 0x00;
        push(ds);
        r16[ax] = 0x08f8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0844;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0790;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x06dc;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0628;
        push(r16[ax]);
        push(cs);
        yield* sub_eed0();
        sp += 0x0014;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        if (memory[ds*16 + 0x8db5] == 0x00) {
            pc = 0x1024d;
            break;
        }
        r8[al] = memory[ds*16 + 0x8db5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_f981();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x1024d;
            break;
        }
        pc = 0x1030e;
        break;
    case 0x1024d:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[si]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        yield* sub_f5c9();
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
    case 0x10274:
        r16[bx] = memory16get(ss, bp - 10);
        es = memory16get(ss, bp - 10 + 2);
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 11] = r8[al];
        if (!r8[al]) {
            pc = 0x10293;
            break;
        }
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        push(r16[ax]);
        push(cs);
        yield* sub_f981();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x10274;
            break;
        }
    case 0x10293:
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
    case 0x1029a:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x10308;
            break;
        }
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fa02();
        sp += 0x0006;
        r8[al] = memory[ds*16 + 0x8814];
        memory[ss*16 + bp - 11] = r8[al];
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fad1();
        sp += 0x0006;
        memory[ss*16 + bp - 5] = r8[al];
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x102d5;
            break;
        }
        memory[ds*16 + 0x8dde] = 0x00;
        r16[ax] = 0x0001;
        pc = 0x10310;
        break;
    case 0x102d5:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x102df;
            break;
        }
        memory[ss*16 + bp - 5] = 0x00;
    case 0x102df:
        if (memory[ss*16 + bp - 5] != 0x02) {
            pc = 0x1029a;
            break;
        }
        push(memory16get(ds, 0x8814));
        push(cs);
        yield* sub_f981();
        sp++;
        sp++;
        if (r16[ax]) {
            pc = 0x1029a;
            break;
        }
        push(cs);
        yield* sub_fb39();
        if (r16[ax]) {
            pc = 0x1029a;
            break;
        }
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
        memory[ss*16 + bp - 5] = 0x00;
        pc = 0x1029a;
        break;
    case 0x10308:
        r8[al] = memory[ds*16 + 0x8814];
        memory[ds*16 + 0x8db5] = r8[al];
    case 0x1030e:
        r16[ax] = 0;
    case 0x10310:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10315() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[si] = 0x0006;
        memory[ss*16 + bp - 5] = 0x00;
        push(ds);
        r16[ax] = 0x0918;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0864;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x07b0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x06fc;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0648;
        push(r16[ax]);
        push(cs);
        yield* sub_eed0();
        sp += 0x0014;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[si]);
        r16[bx] = r16[ax];
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        yield* sub_f5c9();
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 11] = r8[al];
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
    case 0x10382:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x103c9;
            break;
        }
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fa02();
        sp += 0x0006;
        r8[al] = memory[ds*16 + 0x8814];
        memory[ss*16 + bp - 11] = r8[al];
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fad1();
        sp += 0x0006;
        memory[ss*16 + bp - 5] = r8[al];
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x103bd;
            break;
        }
        memory[ds*16 + 0x8db5] = 0x00;
        r16[ax] = 0x0001;
        pc = 0x10419;
        break;
    case 0x103bd:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x10382;
            break;
        }
        memory[ss*16 + bp - 5] = 0x00;
        pc = 0x10382;
        break;
    case 0x103c9:
        if (memory16get(ds, 0x8814) != 0x0041) {
            pc = 0x103d6;
            break;
        }
        memory16set(ds, 0x8de0, 0x0210);
    case 0x103d6:
        if (memory16get(ds, 0x8814) != 0x0042) {
            pc = 0x103e3;
            break;
        }
        memory16set(ds, 0x8de0, 0x0220);
    case 0x103e3:
        if (memory16get(ds, 0x8814) != 0x0043) {
            pc = 0x103f0;
            break;
        }
        memory16set(ds, 0x8de0, 0x0230);
    case 0x103f0:
        if (memory16get(ds, 0x8814) != 0x0044) {
            pc = 0x103fd;
            break;
        }
        memory16set(ds, 0x8de0, 0x0240);
    case 0x103fd:
        if (memory16get(ds, 0x8814) != 0x0045) {
            pc = 0x1040a;
            break;
        }
        memory16set(ds, 0x8de0, 0x0250);
    case 0x1040a:
        if (memory16get(ds, 0x8814) != 0x0046) {
            pc = 0x10417;
            break;
        }
        memory16set(ds, 0x8de0, 0x0260);
    case 0x10417:
        r16[ax] = 0;
    case 0x10419:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1041e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[si] = 0x0004;
        memory[ss*16 + bp - 5] = 0x00;
        push(ds);
        r16[ax] = 0x093c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0888;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x07d4;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0720;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x066c;
        push(r16[ax]);
        push(cs);
        yield* sub_eed0();
        sp += 0x0014;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[si]);
        r16[bx] = r16[ax];
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        yield* sub_f5c9();
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 11] = r8[al];
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
    case 0x1048b:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x104d2;
            break;
        }
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fa02();
        sp += 0x0006;
        r8[al] = memory[ds*16 + 0x8814];
        memory[ss*16 + bp - 11] = r8[al];
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fad1();
        sp += 0x0006;
        memory[ss*16 + bp - 5] = r8[al];
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x104c6;
            break;
        }
        memory[ds*16 + 0x8db5] = 0x00;
        r16[ax] = 0x0001;
        pc = 0x10504;
        break;
    case 0x104c6:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x1048b;
            break;
        }
        memory[ss*16 + bp - 5] = 0x00;
        pc = 0x1048b;
        break;
    case 0x104d2:
        if (memory16get(ds, 0x8814) != 0x0041) {
            pc = 0x104de;
            break;
        }
        memory[ds*16 + 0x8dbb] = 0x02;
    case 0x104de:
        if (memory16get(ds, 0x8814) != 0x0042) {
            pc = 0x104ea;
            break;
        }
        memory[ds*16 + 0x8dbb] = 0x03;
    case 0x104ea:
        if (memory16get(ds, 0x8814) != 0x0043) {
            pc = 0x104f6;
            break;
        }
        memory[ds*16 + 0x8dbb] = 0x05;
    case 0x104f6:
        if (memory16get(ds, 0x8814) != 0x0044) {
            pc = 0x10502;
            break;
        }
        memory[ds*16 + 0x8dbb] = 0x07;
    case 0x10502:
        r16[ax] = 0;
    case 0x10504:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10509() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[si] = 0x0002;
        memory[ss*16 + bp - 5] = 0x00;
        push(ds);
        r16[ax] = 0x0958;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x08a4;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x07f0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x073c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x0688;
        push(r16[ax]);
        push(cs);
        yield* sub_eed0();
        sp += 0x0014;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        if (memory[ds*16 + 0x8bda] == 0x00) {
            pc = 0x10557;
            break;
        }
        r8[al] = memory[ds*16 + 0x8bda];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        yield* sub_f9cd();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x10557;
            break;
        }
        pc = 0x10618;
        break;
    case 0x10557:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[si]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        yield* sub_f5c9();
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
    case 0x1057e:
        r16[bx] = memory16get(ss, bp - 10);
        es = memory16get(ss, bp - 10 + 2);
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 11] = r8[al];
        if (!r8[al]) {
            pc = 0x1059d;
            break;
        }
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        push(r16[ax]);
        push(cs);
        yield* sub_f9cd();
        sp++;
        sp++;
        if (!r16[ax]) {
            pc = 0x1057e;
            break;
        }
    case 0x1059d:
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
    case 0x105a4:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x10612;
            break;
        }
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fa02();
        sp += 0x0006;
        r8[al] = memory[ds*16 + 0x8814];
        memory[ss*16 + bp - 11] = r8[al];
        push(r16[si]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_fad1();
        sp += 0x0006;
        memory[ss*16 + bp - 5] = r8[al];
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x105df;
            break;
        }
        memory[ds*16 + 0x8db5] = 0x00;
        r16[ax] = 0x0001;
        pc = 0x1061a;
        break;
    case 0x105df:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x105e9;
            break;
        }
        memory[ss*16 + bp - 5] = 0x00;
    case 0x105e9:
        if (memory[ss*16 + bp - 5] != 0x02) {
            pc = 0x105a4;
            break;
        }
        push(memory16get(ds, 0x8814));
        push(cs);
        yield* sub_f9cd();
        sp++;
        sp++;
        if (r16[ax]) {
            pc = 0x105a4;
            break;
        }
        push(cs);
        yield* sub_fb39();
        if (r16[ax]) {
            pc = 0x105a4;
            break;
        }
        r8[al] = memory[ss*16 + bp - 11];
        cbw();
        memory16set(ds, 0x8814, r16[ax]);
        memory[ss*16 + bp - 5] = 0x00;
        pc = 0x105a4;
        break;
    case 0x10612:
        r8[al] = memory[ds*16 + 0x8814];
        memory[ds*16 + 0x8bda] = r8[al];
    case 0x10618:
        r16[ax] = 0;
    case 0x1061a:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1061f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_241e();
        assert(cs == 0x0ee7);
        memory16set(ds, 0x8de4, r16[ax]);
        push(cs);
        yield* sub_f38a();
        r16[ax] = 1;
        memory[ds*16 + 0x8812] = 0x00;
        if (memory[ds*16 + 0x881b] != 0x00) {
            pc = 0x10654;
            break;
        }
        if (memory[ds*16 + 0x8819] != 0x00) {
            pc = 0x10654;
            break;
        }
        if (memory[ds*16 + 0x8811] != 0x00) {
            pc = 0x10654;
            break;
        }
        if (memory[ds*16 + 0x881a] != 0x00) {
            pc = 0x10654;
            break;
        }
        if (memory[ds*16 + 0x8810] == 0x00) {
            pc = 0x1065b;
            break;
        }
    case 0x10654:
        memory[ds*16 + 0x8812] = 0x02;
        pc = 0x10667;
        break;
    case 0x1065b:
        if (memory[ds*16 + 0x881d] == 0x00) {
            pc = 0x10667;
            break;
        }
        memory[ds*16 + 0x8812] = 0x01;
    case 0x10667:
        if (memory[ds*16 + 0x8812] != 0x00) {
            pc = 0x10687;
            break;
        }
        push(memory16get(ds, 0x8de4));
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        push(cs);
        yield* sub_f223();
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
    case 0x10687:
        memory[ds*16 + 0x8812] -= 1;
        if (memory[ds*16 + 0x8812] != 0x00) {
            pc = 0x106a4;
            break;
        }
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        push(cs);
        cs = 0x023f;
        yield* sub_23fc();
        assert(cs == 0x0ee7);
        pc = 0x106af;
        break;
    case 0x106a4:
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
    case 0x106af:
        push(cs);
        yield* sub_efc8();
        memory[ds*16 + 0x91ac] = 0x00;
        push(cs);
        yield* sub_f54d();
    case 0x106bc:
        push(cs);
        yield* sub_10052();
        if (!r16[ax]) {
            pc = 0x106fe;
            break;
        }
        push(cs);
        yield* sub_f014();
        push(memory16get(ds, 0x8de4));
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        if (memory16get(ds, 0x92c4) == 0x0000) {
            pc = 0x106f4;
            break;
        }
        if (memory16get(ds, 0x8a2a) != 0x0000) {
            pc = 0x106f4;
            break;
        }
    case 0x106e1:
        r16[dx] = memory16get(ds, 0x8f7c);
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x40) {
            pc = 0x106e1;
            break;
        }
        r16[dx] = memory16get(ds, 0x8f7c);
        r16[dx]++;
        r8[al] = 0xff;
        out8(r16[dx], r8[al]);
    case 0x106f4:
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
    case 0x106fe:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x10708;
            break;
        }
        pc = 0x10778;
        break;
    case 0x10708:
        push(cs);
        yield* sub_100e9();
        if (r16[ax]) {
            pc = 0x106bc;
            break;
        }
    case 0x10710:
        push(cs);
        yield* sub_101ff();
        if (r16[ax]) {
            pc = 0x10708;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x1076d;
            break;
        }
        if (memory[ds*16 + 0x92c6] != 0x00) {
            pc = 0x10732;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_fe01();
        sp++;
        sp++;
        pc = 0x10710;
        break;
    case 0x10732:
        if (memory16get(ds, 0x8de0) == 0x0000) {
            pc = 0x10740;
            break;
        }
        if (memory[ds*16 + 0x8dbb] != 0x00) {
            pc = 0x10750;
            break;
        }
    case 0x10740:
        push(cs);
        yield* sub_10315();
        if (r16[ax]) {
            pc = 0x10710;
            break;
        }
        push(cs);
        yield* sub_1041e();
        if (r16[ax]) {
            pc = 0x10710;
            break;
        }
    case 0x10750:
        push(cs);
        yield* sub_f23f();
        if (!r16[ax]) {
            pc = 0x1076d;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_fe01();
        sp++;
        sp++;
        r8[al] = 0x00;
        memory[ds*16 + 0x8dbb] = r8[al];
        r8[ah] = 0x00;
        memory16set(ds, 0x8de0, r16[ax]);
        pc = 0x10710;
        break;
    case 0x1076d:
        push(cs);
        yield* sub_10509();
        if (r16[ax]) {
            pc = 0x10710;
            break;
        }
        pc = 0x10821;
        break;
    case 0x10778:
        r16[bx] = memory16get(ds, 0x0610);
        es = memory16get(ds, 0x0610 + 2);
        memory16set(ds, 0x0632, es);
        memory16set(ds, 0x0630, r16[bx]);
        r16[bx] = memory16get(ds, 0x06c4);
        es = memory16get(ds, 0x06c4 + 2);
        memory16set(ds, 0x06e6, es);
        memory16set(ds, 0x06e4, r16[bx]);
        r16[bx] = memory16get(ds, 0x0778);
        es = memory16get(ds, 0x0778 + 2);
        memory16set(ds, 0x07fa, es);
        memory16set(ds, 0x07f8, r16[bx]);
        r16[bx] = memory16get(ds, 0x082c);
        es = memory16get(ds, 0x082c + 2);
        memory16set(ds, 0x08ae, es);
        memory16set(ds, 0x08ac, r16[bx]);
        r16[bx] = memory16get(ds, 0x08e0);
        es = memory16get(ds, 0x08e0 + 2);
        memory16set(ds, 0x0962, es);
        memory16set(ds, 0x0960, r16[bx]);
    case 0x107b4:
        push(cs);
        yield* sub_101ff();
        if (!r16[ax]) {
            pc = 0x107bf;
            break;
        }
        pc = 0x106bc;
        break;
    case 0x107bf:
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x10814;
            break;
        }
        if (memory[ds*16 + 0x92c6] != 0x00) {
            pc = 0x107d9;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_fe01();
        sp++;
        sp++;
        pc = 0x107b4;
        break;
    case 0x107d9:
        if (memory16get(ds, 0x8de0) == 0x0000) {
            pc = 0x107e7;
            break;
        }
        if (memory[ds*16 + 0x8dbb] != 0x00) {
            pc = 0x107f7;
            break;
        }
    case 0x107e7:
        push(cs);
        yield* sub_10315();
        if (r16[ax]) {
            pc = 0x107b4;
            break;
        }
        push(cs);
        yield* sub_1041e();
        if (r16[ax]) {
            pc = 0x107b4;
            break;
        }
    case 0x107f7:
        push(cs);
        yield* sub_f23f();
        if (!r16[ax]) {
            pc = 0x10814;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_fe01();
        sp++;
        sp++;
        r8[al] = 0x00;
        memory[ds*16 + 0x8dbb] = r8[al];
        r8[ah] = 0x00;
        memory16set(ds, 0x8de0, r16[ax]);
        pc = 0x107b4;
        break;
    case 0x10814:
        push(cs);
        yield* sub_10509();
        if (r16[ax]) {
            pc = 0x107b4;
            break;
        }
        memory[ds*16 + 0x8dde] = 0x56;
    case 0x10821:
        push(cs);
        yield* sub_f46d();
        r16[si] = 0;
        if (memory[ds*16 + 0x919c] != 0x00) {
            pc = 0x10842;
            break;
        }
        push(cs);
        cs = 0x1e93;
        yield* sub_1e958();
        assert(cs == 0x0ee7);
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_6f42();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
        if (!r8[al]) {
            pc = 0x10842;
            break;
        }
        r16[si] = 0xffff;
    case 0x10842:
        if (r16[si]) {
            pc = 0x1085d;
            break;
        }
        r16[ax] = 0x0180;
        push(r16[ax]);
        r16[ax] = 0x8302;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1aa5;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        r16[si] = r16[ax];
    case 0x1085d:
        if (r16[si] == 0xffff) {
            pc = 0x108d6;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x91a2;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f6b;
        yield* sub_1f6b7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8dde;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f6b;
        yield* sub_1f6b7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8db5;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f6b;
        yield* sub_1f6b7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bda;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f6b;
        yield* sub_1f6b7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8de0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f6b;
        yield* sub_1f6b7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8dbb;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f6b;
        yield* sub_1f6b7();
        assert(cs == 0x0ee7);
        sp += 0x0008;
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x0ee7);
        sp++;
        sp++;
    case 0x108d6:
        push(cs);
        yield* sub_f014();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10a05() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0036;
        push(ss);
        r16[ax] = bp - 0x34;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x09ce;
        push(r16[ax]);
        r16[cx] = 0x0014;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x0ee7);
        memory16set(ss, bp - 30, 0x0040);
        memory16set(ss, bp - 32, 0x0049);
        r16[si] = 0xffff;
        memory16set(ss, bp - 26, 0xb000);
        memory16set(ss, bp - 28, 0x0000);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x09e2;
        push(r16[ax]);
        r16[cx] = 0x0018;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x0ee7);
        r8[al] = 0x03;
        r16[dx] = 0x03bf;
        out8(r16[dx], r8[al]);
        r8[al] = 0x00;
        r16[dx] = 0x03b8;
        out8(r16[dx], r8[al]);
        memory[ss*16 + bp - 53] = 0x00;
        pc = 0x10a78;
        break;
    case 0x10a59:
        r8[al] = memory[ss*16 + bp - 53];
        r16[dx] = 0x03b4;
        out8(r16[dx], r8[al]);
        r8[al] = memory[ss*16 + bp - 53];
        r8[ah] = 0x00;
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r8[al] = memory[ss*16 + r16[bx]];
        r16[dx] = 0x03b5;
        out8(r16[dx], r8[al]);
        memory[ss*16 + bp - 53] += 1;
    case 0x10a78:
        if (memory[ss*16 + bp - 53] < 0x0c) {
            pc = 0x10a59;
            break;
        }
    case 0x10a7e:
        r16[ax] = r16[si];
        r16[si]--;
        if (!r16[ax]) {
            pc = 0x10a93;
            break;
        }
        r16[bx] = memory16get(ss, bp - 28);
        es = memory16get(ss, bp - 28 + 2);
        memory16set(es, r16[bx], 0x0000);
        memory16set(ss, bp - 28, memory16get(ss, bp - 28) + 0x0002);
        pc = 0x10a7e;
        break;
    case 0x10a93:
        r8[al] = 0x0a;
        r16[dx] = 0x03b8;
        out8(r16[dx], r8[al]);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10a9e() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(memory16get(ds, 0x8d74));
    push(cs);
    cs = 0x0cb4;
    yield* sub_cba0();
    assert(cs == 0x0ee7);
    sp++;
    sp++;
    push(cs);
    cs = 0x0cb4;
    yield* sub_cbee();
    assert(cs == 0x0ee7);
    memory16set(ds, 0x8dc0, r16[ax]);
    push(cs);
    cs = 0x0cb4;
    yield* sub_cbf3();
    assert(cs == 0x0ee7);
    memory16set(ds, 0x8b9a, r16[ax]);
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_10aba() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r8[al] = 0x00;
        memory[ds*16 + 0x8b95] = r8[al];
        memory[ds*16 + 0x8ba8] = r8[al];
        memory[ds*16 + 0x8b94] = r8[al];
        memory[ds*16 + 0x8d9e] = r8[al];
        memory[ds*16 + 0x92b5] = r8[al];
        memory[ds*16 + 0x92b6] = r8[al];
        memory[ds*16 + 0x8db4] = r8[al];
        memory[ds*16 + 0x8da6] = r8[al];
        memory[ds*16 + 0x8baf] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8da7] = r8[al];
        memory[ds*16 + 0x8b6a] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8f66] = r8[al];
        memory[ds*16 + 0x919c] = r8[al];
        push(cs);
        cs = 0x1e93;
        yield* sub_1e958();
        assert(cs == 0x0ee7);
        if (r16s[ax] <= signed16(0x0001)) {
            pc = 0x10afd;
            break;
        }
        memory[ds*16 + 0x919c] = 0x01;
    case 0x10afd:
        memory[ds*16 + 0x92b7] = 0x00;
        push(cs);
        yield* sub_f1af();
        if (!r16[ax]) {
            pc = 0x10b0f;
            break;
        }
        memory[ds*16 + 0x92b7] = 0x01;
    case 0x10b0f:
        memory[ds*16 + 0x8db3] = 0x00;
        if (memory[ds*16 + 0x92b7] != 0x00) {
            pc = 0x10b28;
            break;
        }
        push(cs);
        yield* sub_f1e6();
        if (!r16[ax]) {
            pc = 0x10b28;
            break;
        }
        memory[ds*16 + 0x8db3] = 0x01;
    case 0x10b28:
        push(cs);
        cs = 0x1e92;
        yield* sub_1e924();
        assert(cs == 0x0ee7);
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        r16[cx] = 0x000e;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ds*16 + 0x8e38] = r8[al];
        r16[ax] = r16[si];
        r16[ax] &= 0x2000;
        r16[cx] = 0x000d;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ds*16 + 0x8dc6] = r8[al];
        r16[ax] = r16[si];
        r16[ax] &= 0x0e00;
        r16[cx] = 0x0009;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ds*16 + 0x8bd2] = r8[al];
        r16[ax] = r16[si];
        r16[ax] &= 0x0100;
        r16[cx] = 0x0008;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ds*16 + 0x8b99] = r8[al];
        if (!(r16[si] & 0x0001)) {
            pc = 0x10b77;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] &= 0x00c0;
        r16[cx] = 0x0006;
        r16[ax] = sar16(r16[ax], r8[cl]);
        r8[al]++;
        memory[ds*16 + 0x92b4] = r8[al];
        pc = 0x10b7c;
        break;
    case 0x10b77:
        memory[ds*16 + 0x92b4] = 0x00;
    case 0x10b7c:
        if (!(r16[si] & 0x0002)) {
            pc = 0x10b89;
            break;
        }
        memory[ds*16 + 0x8c5a] = 0x01;
        pc = 0x10b8e;
        break;
    case 0x10b89:
        memory[ds*16 + 0x8c5a] = 0x00;
    case 0x10b8e:
        memory[ds*16 + 0x92c2] = 0x08;
        memory16set(ds, 0x8d60, 0x00a0);
        memory16set(ds, 0x8db8, 0x0064);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10baa() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (memory[ds*16 + 0x1ab8] != 0x00) {
            pc = 0x10bc0;
            break;
        }
        push(cs);
        cs = 0x1e7a;
        yield* sub_1e7fc();
        assert(cs == 0x10ba);
        memory[ds*16 + 0x1ab8] = 0x01;
        memory[ds*16 + 0x8876] = 0x00;
    case 0x10bc0:
        cs = pop();
        return;
    } while (1);
}
function* sub_10bc1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory[ds*16 + 0x1ab8] != 0x00) {
            pc = 0x10bcf;
            break;
        }
        r16[ax] = 0;
        pc = 0x10bf9;
        break;
    case 0x10bcf:
        memory[ds*16 + 0x8876] = 0x00;
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory16set(ds, 0x88be, es);
        memory16set(ds, 0x88bc, r16[bx]);
        memory[ds*16 + 0x1ab9] = 0x00;
        push(memory16get(ss, bp + 8));
        push(r16[bx]);
        push(cs);
        cs = 0x10ba;
        yield* sub_10d7f();
        assert(cs == 0x10ba);
        sp = bp;
        push(cs);
        cs = 0x10ba;
        yield* sub_10e28();
        assert(cs == 0x10ba);
        sp = bp;
        r16[ax] = 0x0001;
    case 0x10bf9:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10bfb() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (memory[ds*16 + 0x1ab8] == 0x00) {
            pc = 0x10c07;
            break;
        }
        push(cs);
        cs = 0x1e7a;
        yield* sub_1e844();
        assert(cs == 0x10ba);
    case 0x10c07:
        memory[ds*16 + 0x1ab8] = 0x00;
        cs = pop();
        return;
    } while (1);
}
function* sub_10c0d() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[bx] = memory16get(ss, bp + 8);
    es = memory16get(ss, bp + 8 + 2);
    r8[al] = memory[es*16 + r16[bx]];
    r8[ah] = 0x00;
    r16[si] = r16[ax];
    memory16set(ss, bp + 8, memory16get(ss, bp + 8) + 1);
    r16[ax] = r16[si];
    r16[cx] = 0x0008;
    r16[ax] <<= r8[cl];
    r16[bx] = memory16get(ss, bp + 8);
    r8[dl] = memory[es*16 + r16[bx]];
    r8[dh] = 0x00;
    r16[ax] += r16[dx];
    r16[si] = r16[ax];
    memory16set(ss, bp + 8, memory16get(ss, bp + 8) + 1);
    r16[ax] = r16[si];
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_10c39() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        memory16set(ss, bp - 2, 0x0000);
        memory16set(ss, bp - 4, 0x0000);
        r16[si] = 0;
        pc = 0x10c79;
        break;
    case 0x10c4e:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[cx] = 0x0008;
        push(cs);
        cs = 0x01ed;
        yield* sub_20cf();
        assert(cs == 0x10ba);
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        r8[bl] = memory[es*16 + r16[bx]];
        r8[bh] = 0x00;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[bx];
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        r16[bx] = pop();
        r16[cx] = pop();
        flags.carry = (r16[bx] + r16[ax]) >= 0x10000;
        r16[bx] += r16[ax];
        r16[cx] += r16[dx] + flags.carry;
        memory16set(ss, bp - 2, r16[cx]);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp + 8, memory16get(ss, bp + 8) + 1);
        r16[si]++;
    case 0x10c79:
        if (signed16(r16[si]) < signed16(0x0004)) {
            pc = 0x10c4e;
            break;
        }
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10c89() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[di] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8834);
        r16[si] = 0;
        pc = 0x10ce3;
        break;
    case 0x10ca0:
        r16[dx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += 0x0004;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_10c39();
        sp += 0x0004;
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[dx] = memory16get(ss, bp + 14);
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += 0x0008;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(r16[dx]);
        push(r16[ax]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[ax] = pop();
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[dx] = pop();
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] += 0x0008;
        memory16set(ss, bp + 12, memory16get(ss, bp + 12) + r16[ax]);
        r16[si]++;
    case 0x10ce3:
        if (signed16(r16[si]) < signed16(r16[di])) {
            pc = 0x10ca0;
            break;
        }
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10ced() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x000a;
        r16[bx] = memory16get(ds, 0x8820);
        es = memory16get(ds, 0x8820 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        r8[ah] = 0;
        r16[dx] = 0;
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
        r16[ax] &= 0x0080;
        r16[dx] &= 0x0000;
        r16[dx] |= r16[ax];
        if (!r16[dx]) {
            pc = 0x10d64;
            break;
        }
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] &= 0x007f;
        r16[dx] &= 0x0000;
        memory16set(ss, bp - 8, r16[dx]);
        memory16set(ss, bp - 10, r16[ax]);
    case 0x10d2e:
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[cx] = 0x0007;
        push(cs);
        cs = 0x01ed;
        yield* sub_20cf();
        assert(cs == 0x10ba);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r8[bl] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 5] = r8[bl];
        r8[bh] = 0x00;
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = r16[bx];
        r16[ax] &= 0x007f;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        r16[bx] = pop();
        r16[cx] = pop();
        flags.carry = (r16[bx] + r16[ax]) >= 0x10000;
        r16[bx] += r16[ax];
        r16[cx] += r16[dx] + flags.carry;
        memory16set(ss, bp - 8, r16[cx]);
        memory16set(ss, bp - 10, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        if (memory[ss*16 + bp - 5] & 0x80) {
            pc = 0x10d2e;
            break;
        }
    case 0x10d64:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        r16[bx] = memory16get(ds, 0x8820);
        es = memory16get(ds, 0x8820 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10d7f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[dx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 8);
        r16[ax] += 0x0004;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_10c39();
        sp += 0x0004;
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[dx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 8);
        r16[ax] += 0x000a;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_10c0d();
        sp += 0x0004;
        memory16set(ds, 0x1ab2, r16[ax]);
        r16[dx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 8);
        r16[ax] += 0x000c;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_10c0d();
        sp += 0x0004;
        memory16set(ds, 0x8874, r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0008;
        memory16set(ss, bp + 8, memory16get(ss, bp + 8) + r16[ax]);
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(memory16get(ds, 0x1ab2));
        push(cs);
        yield* sub_10c89();
        sp += 0x0006;
        r16[si] = 0;
        pc = 0x10e1d;
        break;
    case 0x10de6:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] += 0x8834;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ds, 0x8822, es);
        memory16set(ds, 0x8820, r16[bx]);
        push(cs);
        yield* sub_10ced();
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34938, r16[dx]);
        memory16set(ds, r16[bx] + 34936, r16[ax]);
        r16[bx] = memory16get(ds, 0x8820);
        es = memory16get(ds, 0x8820 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ds*16 + r16[si] + 34852] = r8[al];
        r16[si]++;
    case 0x10e1d:
        if (signed16(r16[si]) < memory16gets(ds, 0x1ab2)) {
            pc = 0x10de6;
            break;
        }
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10e28() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    memory16set(ds, 0x1abc, 0x0000);
    memory16set(ds, 0x1aba, 0x0000);
    memory16set(ds, 0x1abe, 0x0000);
    memory16set(ds, 0x8822, ds);
    memory16set(ds, 0x8820, 0x8834);
    memory16set(ds, 0x88ba, ds);
    memory16set(ds, 0x88b8, 0x8824);
    memory[ds*16 + 0x88d8] = 0x00;
    memory[ds*16 + 0x8876] = 0x01;
    r16[dx] = 0x0007;
    r16[ax] = 0xa120;
    push(r16[dx]);
    push(r16[ax]);
    r16[ax] = 0x01e0;
    push(r16[ax]);
    push(cs);
    cs = 0x10ba;
    yield* sub_10e8e();
    assert(cs == 0x10ba);
    sp += 0x0006;
    r16[ax] = 0x0001;
    push(r16[ax]);
    push(cs);
    cs = 0x1e7a;
    yield* sub_1e859();
    assert(cs == 0x10ba);
    sp++;
    sp++;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_10e78() {
    //CStackGuardFar sg(0, false);
    memory[ds*16 + 0x8876] = 0x00;
    push(cs);
    cs = 0x10ba;
    yield* sub_10e83();
    assert(cs == 0x10ba);
    cs = pop();
}
function* sub_10e83() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    cs = 0x1e7a;
    yield* sub_1e7d8();
    assert(cs == 0x10ba);
    sp++;
    sp++;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_10e8e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        if (memory16get(ss, bp + 6) != 0x0000) {
            pc = 0x10ea6;
            break;
        }
        memory16set(ss, bp - 2, 0x0000);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x10ee2;
        break;
    case 0x10ea6:
        r16[dx] = 0;
        r16[ax] = 0x03e8;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp + 8));
        push(cs);
        cs = 0x01ed;
        yield* sub_2050();
        assert(cs == 0x10ba);
        memory16set(ss, bp + 10, r16[dx]);
        memory16set(ss, bp + 8, r16[ax]);
        r16[ax] = memory16get(ss, bp + 6);
        r16[dx] = 0;
        push(r16[dx]);
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 8);
        r16[cx] = 0;
        r16[bx] = 0x04aa;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x10ba);
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        cs = 0x01ed;
        yield* sub_2050();
        assert(cs == 0x10ba);
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
    case 0x10ee2:
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1e7a;
        yield* sub_1e7d8();
        assert(cs == 0x10ba);
        sp++;
        sp++;
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_10ffa() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[di] = memory16get(ss, bp + 14);
        r16[si] = memory16get(ss, bp + 10);
        if (memory16get(ds, 0x1ab6) == 0x0000) {
            pc = 0x1102e;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x41) {
            pc = 0x11018;
            break;
        }
        if (r16[si] == 0x0003) {
            pc = 0x11022;
            break;
        }
    case 0x11018:
        if (signed16(r16[di]) <= memory16gets(ds, 0x88d6)) {
            pc = 0x11022;
            break;
        }
        r16[di] = memory16get(ds, 0x88d6);
    case 0x11022:
        if (r16[di]) {
            pc = 0x11038;
            break;
        }
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_1205c();
        assert(cs == 0x10ba);
        sp = bp;
    case 0x1102e:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35008, r16[di]);
        pc = 0x11060;
        break;
    case 0x11038:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 35008);
        if (r16[ax] == r16[di]) {
            pc = 0x11055;
            break;
        }
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11f04();
        assert(cs == 0x10ba);
        sp = bp;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35008, r16[di]);
    case 0x11055:
        push(memory16get(ss, bp + 12));
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11fba();
        assert(cs == 0x10ba);
        sp = bp;
    case 0x11060:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11620() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[di] = memory16get(ss, bp + 10);
        if (r16[di] == memory16get(ds, 0x1ab6)) {
            pc = 0x1166b;
            break;
        }
        if (r16[di]) {
            pc = 0x11651;
            break;
        }
        r16[si] = 0;
        pc = 0x1164a;
        break;
    case 0x11636:
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11f04();
        assert(cs == 0x1162);
        sp = bp;
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_1205c();
        assert(cs == 0x1162);
        sp = bp;
        r16[si]++;
    case 0x1164a:
        if (signed16(r16[si]) < signed16(0x000b)) {
            pc = 0x11636;
            break;
        }
        pc = 0x1166b;
        break;
    case 0x11651:
        r16[si] = 0;
        pc = 0x11666;
        break;
    case 0x11655:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 35008));
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11f04();
        assert(cs == 0x1162);
        sp = bp;
        r16[si]++;
    case 0x11666:
        if (signed16(r16[si]) < signed16(0x000b)) {
            pc = 0x11655;
            break;
        }
    case 0x1166b:
        memory16set(ds, 0x1ab6, r16[di]);
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11673() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = 0;
        pc = 0x116aa;
        break;
    case 0x11678:
        push(memory16get(ds, 0x8f7c));
        r16[ax] = r16[si];
        r16[ax] += 0x00b0;
        push(r16[ax]);
        push(cs);
        cs = 0x129a;
        yield* sub_129c3();
        assert(cs == 0x1162);
        sp += 0x0004;
        push(memory16get(ds, 0x8f7c));
        r16[ax] = 0x007b;
        push(r16[ax]);
        push(cs);
        cs = 0x129a;
        yield* sub_129c3();
        assert(cs == 0x1162);
        sp += 0x0004;
        push(memory16get(ds, 0x8f7c));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x129a;
        yield* sub_129c3();
        assert(cs == 0x1162);
        sp += 0x0004;
        r16[si]++;
    case 0x116aa:
        if (r16[si] < 0x0010) {
            pc = 0x11678;
            break;
        }
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_116b1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8db5] == 0x4e) {
            pc = 0x11703;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x41) {
            pc = 0x116c6;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x116cf;
            break;
        }
    case 0x116c6:
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_11620();
        sp++;
        sp++;
    case 0x116cf:
        push(cs);
        cs = 0x10ba;
        yield* sub_10e78();
        assert(cs == 0x1162);
        if (memory[ds*16 + 0x8db5] == 0x41) {
            pc = 0x116e2;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x116ec;
            break;
        }
    case 0x116e2:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11620();
        sp++;
        sp++;
    case 0x116ec:
        if (memory[ds*16 + 0x8db5] != 0x52) {
            pc = 0x116f7;
            break;
        }
        push(cs);
        yield* sub_11673();
    case 0x116f7:
        if (memory[ds*16 + 0x8db5] != 0x49) {
            pc = 0x11703;
            break;
        }
        push(cs);
        cs = 0x1f5c;
        yield* sub_1f5f5();
        assert(cs == 0x1162);
    case 0x11703:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11704() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        r16[di] = memory16get(ds, 0x88d6);
        if (memory[ds*16 + 0x8db5] == 0x4e) {
            pc = 0x1173e;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x4e) {
            pc = 0x1173a;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1173a;
            break;
        }
        r16[si] = r16[di];
        pc = 0x11735;
        break;
    case 0x11723:
        memory16set(ds, 0x88d6, r16[si]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9cf();
        assert(cs == 0x1162);
        sp++;
        sp++;
        r16[si] -= 0x0004;
    case 0x11735:
        if (signed16(r16[si]) >= signed16(0x0004)) {
            pc = 0x11723;
            break;
        }
    case 0x1173a:
        push(cs);
        yield* sub_116b1();
    case 0x1173e:
        memory16set(ds, 0x88d6, r16[di]);
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11745() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(memory16get(ds, 0x8f7c));
    r16[ax] = memory16get(ss, bp + 6);
    r16[ax] += 0x00c0;
    push(r16[ax]);
    push(cs);
    cs = 0x129a;
    yield* sub_129c3();
    assert(cs == 0x1162);
    sp = bp;
    push(memory16get(ds, 0x8f7c));
    push(memory16get(ss, bp + 8));
    push(cs);
    cs = 0x129a;
    yield* sub_129c3();
    assert(cs == 0x1162);
    sp = bp;
    push(memory16get(ds, 0x8f7c));
    r16[ax] = memory16get(ss, bp + 6);
    r16[ax] += 0x00b0;
    push(r16[ax]);
    push(cs);
    cs = 0x129a;
    yield* sub_129c3();
    assert(cs == 0x1162);
    sp = bp;
    push(memory16get(ds, 0x8f7c));
    r16[ax] = 0x0007;
    push(r16[ax]);
    push(cs);
    cs = 0x129a;
    yield* sub_129c3();
    assert(cs == 0x1162);
    sp = bp;
    push(memory16get(ds, 0x8f7c));
    r16[ax] = 0x007f;
    push(r16[ax]);
    push(cs);
    cs = 0x129a;
    yield* sub_129c3();
    assert(cs == 0x1162);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1179a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 36670);
        r16[ax] |= memory16get(ds, r16[bx] + 36672);
        if (!r16[ax]) {
            pc = 0x117c6;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 36672));
        push(memory16get(ds, r16[bx] + 36670));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x1162);
        sp = bp;
    case 0x117c6:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 36672, 0x0000);
        memory16set(ds, r16[bx] + 36670, 0x0000);
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_117db() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        if (memory[ds*16 + 0x8db5] == 0x41) {
            pc = 0x117ff;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x53) {
            pc = 0x117ff;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x52) {
            pc = 0x117ff;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x117ff;
            break;
        }
        pc = 0x11cc1;
        break;
    case 0x117ff:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 36670);
        r16[ax] |= memory16get(ds, r16[bx] + 36672);
        if (r16[ax]) {
            pc = 0x11813;
            break;
        }
        pc = 0x11ccc;
        break;
    case 0x11813:
        if (memory[ds*16 + 0x8876] == 0x00) {
            pc = 0x11820;
            break;
        }
        push(cs);
        yield* sub_11704();
        sp = bp;
    case 0x11820:
        r16[ax] = 0x000a;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9cf();
        assert(cs == 0x1162);
        sp = bp;
        r16[si] = 0;
        pc = 0x1183a;
        break;
    case 0x1182f:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35008, 0x0000);
        r16[si]++;
    case 0x1183a:
        if (signed16(r16[si]) < signed16(0x000b)) {
            pc = 0x1182f;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x53) {
            pc = 0x1184d;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x41) {
            pc = 0x11858;
            break;
        }
    case 0x1184d:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11d74();
        assert(cs == 0x1162);
        sp = bp;
    case 0x11858:
        if (memory[ds*16 + 0x8db5] == 0x52) {
            pc = 0x11862;
            break;
        }
        pc = 0x11cab;
        break;
    case 0x11862:
        r16[di] = 0;
        pc = 0x1186c;
        break;
    case 0x11866:
        memory[ds*16 + r16[di] + 6848] = 0x80;
        r16[di]++;
    case 0x1186c:
        if (r16[di] < 0x0010) {
            pc = 0x11866;
            break;
        }
        r8[al] = 0x09;
        memory[ds*16 + 0x1ada] = r8[al];
        memory[ds*16 + 0x1ad9] = r8[al];
        memory[ds*16 + 0x1ad8] = r8[al];
        memory[ds*16 + 0x1ad7] = r8[al];
        memory[ds*16 + 0x1ad6] = r8[al];
        r8[al] = 0x09;
        memory[ds*16 + 0x1adf] = r8[al];
        memory[ds*16 + 0x1ade] = r8[al];
        memory[ds*16 + 0x1add] = r8[al];
        memory[ds*16 + 0x1adc] = r8[al];
        memory[ds*16 + 0x1adb] = r8[al];
        memory[ds*16 + 0x1ae0] = 0x01;
        r16[ax] = memory16get(ss, bp + 12);
        if (r16[ax] <= 0x0008) {
            pc = 0x118a3;
            break;
        }
        pc = 0x11cab;
        break;
    case 0x118a3:
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x118be; break;
        case 2: pc = 0x11925; break;
        case 4: pc = 0x1199a; break;
        case 6: pc = 0x11a0f; break;
        case 8: pc = 0x11a84; break;
        case 10: pc = 0x11adc; break;
        case 12: pc = 0x11b43; break;
        case 14: pc = 0x11bb8; break;
        case 16: pc = 0x11c2c; break;
            default:
            assert(0);
        }
        break;
    case 0x118be:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x05;
        r16[ax] = 0x000e;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0022;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0020;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0038;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x004d;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11925:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x06;
        r16[ax] = 0x0045;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x001a;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002c;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0018;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x003f;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x1199a:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x06;
        r16[ax] = 0x001c;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0062;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002c;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0075;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0025;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11a0f:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x06;
        r16[ax] = 0x0042;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x005c;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0068;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002b;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11a84:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x04;
        memory[ds*16 + 0x1ad5] = 0x04;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x007a;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x005f;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11adc:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x02;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x004e;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0057;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11b43:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x06;
        r16[ax] = 0x003f;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0062;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002c;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002b;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0071;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11bb8:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x06;
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0062;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002c;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002b;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0019;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        pc = 0x11c9e;
        break;
    case 0x11c2c:
        memory[ds*16 + 0x1ad0] = 0x01;
        memory[ds*16 + 0x1ad1] = 0x02;
        memory[ds*16 + 0x1ad2] = 0x03;
        memory[ds*16 + 0x1ad3] = 0x04;
        memory[ds*16 + 0x1ad4] = 0x05;
        memory[ds*16 + 0x1ad5] = 0x06;
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0061;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x002b;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0044;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0062;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
        r16[ax] = 0x0033;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
    case 0x11c9e:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        push(cs);
        yield* sub_11745();
        sp = bp;
    case 0x11cab:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 36672));
        push(memory16get(ds, r16[bx] + 36670));
        push(cs);
        cs = 0x10ba;
        yield* sub_10bc1();
        assert(cs == 0x1162);
        sp = bp;
    case 0x11cc1:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9cf();
        assert(cs == 0x1162);
        sp = bp;
    case 0x11ccc:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11cd0() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[ax] = memory16get(ss, bp + 8);
    memory16set(ds, 0x8a08, r16[ax]);
    push(cs);
    cs = 0x11cd;
    yield* sub_125ea();
    assert(cs == 0x11cd);
    sp = bp;
    r16[si] = r16[ax];
    push(cs);
    cs = 0x11cd;
    yield* sub_11cef();
    assert(cs == 0x11cd);
    sp = bp;
    r16[ax] = r16[si];
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_11cef() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = 0x0001;
        pc = 0x11d02;
        break;
    case 0x11cf5:
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[si]++;
    case 0x11d02:
        if (signed16(r16[si]) <= signed16(0x00f5)) {
            pc = 0x11cf5;
            break;
        }
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[si] = 0;
        pc = 0x11d31;
        break;
    case 0x11d1c:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35304, 0x2000);
        memory[ds*16 + r16[si] + 35340] = 0x00;
        memory[ds*16 + r16[si] + 35326] = 0x00;
        r16[si]++;
    case 0x11d31:
        if (signed16(r16[si]) < signed16(0x0009)) {
            pc = 0x11d1c;
            break;
        }
        r16[si] = 0;
        pc = 0x11d40;
        break;
    case 0x11d3a:
        memory[ds*16 + r16[si] + 35290] = 0x7f;
        r16[si]++;
    case 0x11d40:
        if (signed16(r16[si]) < signed16(0x000b)) {
            pc = 0x11d3a;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11d74();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11e36();
        assert(cs == 0x11cd);
        sp += 0x0006;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11e18();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11dd5();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11d74() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        if (!r16[si]) {
            pc = 0x11dab;
            break;
        }
        memory[ds*16 + 0x8a06] = 0x18;
        memory16set(ds, 0x89f8, 0x2000);
        r16[ax] = 0x0008;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_125c0();
        assert(cs == 0x11cd);
        sp = bp;
        memory[ds*16 + 0x8a05] = 0x1f;
        memory16set(ds, 0x89f6, 0x2000);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_125c0();
        assert(cs == 0x11cd);
        sp = bp;
    case 0x11dab:
        r16[ax] = r16[si];
        memory[ds*16 + 0x8a0b] = r8[al];
        if (!r16[si]) {
            pc = 0x11db9;
            break;
        }
        r16[ax] = 0x000b;
        pc = 0x11dbc;
        break;
    case 0x11db9:
        r16[ax] = 0x0009;
    case 0x11dbc:
        memory16set(ds, 0x89fc, r16[ax]);
        memory[ds*16 + 0x89fa] = 0x00;
        push(cs);
        cs = 0x11cd;
        yield* sub_120b8();
        assert(cs == 0x11cd);
        sp = bp;
        push(cs);
        cs = 0x11cd;
        yield* sub_12541();
        assert(cs == 0x11cd);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11dd5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        if (memory16get(ss, bp + 8) == 0x0000) {
            pc = 0x11de4;
            break;
        }
        r16[ax] = 0x0020;
        pc = 0x11de6;
        break;
    case 0x11de4:
        r16[ax] = 0;
    case 0x11de6:
        memory16set(ds, 0x88dc, r16[ax]);
        r16[si] = 0;
        pc = 0x11e01;
        break;
    case 0x11ded:
        r16[ax] = 0;
        push(r16[ax]);
        r8[al] = memory[ds*16 + r16[si] + 7057];
        cbw();
        r16[ax] += 0x00e0;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp = bp;
        r16[si]++;
    case 0x11e01:
        if (signed16(r16[si]) < signed16(0x0012)) {
            pc = 0x11ded;
            break;
        }
        push(memory16get(ds, 0x88dc));
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11e18() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        if (r16[si] <= 0x000c) {
            pc = 0x11e27;
            break;
        }
        r16[si] = 0x000c;
    case 0x11e27:
        if (r16[si] >= 0x0001) {
            pc = 0x11e2f;
            break;
        }
        r16[si] = 0x0001;
    case 0x11e2f:
        memory16set(ds, 0x89e6, r16[si]);
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11e36() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r8[al] = memory[ss*16 + bp + 6];
    memory[ds*16 + 0x8a0a] = r8[al];
    r8[al] = memory[ss*16 + bp + 8];
    memory[ds*16 + 0x8a15] = r8[al];
    r8[al] = memory[ss*16 + bp + 10];
    memory[ds*16 + 0x88da] = r8[al];
    push(cs);
    cs = 0x11cd;
    yield* sub_12541();
    assert(cs == 0x11cd);
    sp = bp;
    push(cs);
    cs = 0x11cd;
    yield* sub_123ba();
    assert(cs == 0x11cd);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_11e5b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        r16[si] = memory16get(ss, bp + 10);
        if (r16[si] < memory16get(ds, 0x89fc)) {
            pc = 0x11e6f;
            break;
        }
        pc = 0x11efe;
        break;
    case 0x11e6f:
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r16[bx] += 0x0034;
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[di] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0002);
        r16[bx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 14, r16[ax]);
        r16[bx] = memory16get(ss, bp + 12);
        r16[bx] += 0x001a;
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x11eb2;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] += 0x1b7b;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        pc = 0x11ec4;
        break;
    case 0x11eb2:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] += 0x1b69;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
    case 0x11ec4:
        push(r16[di]);
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_12197();
        assert(cs == 0x11cd);
        sp += 0x0008;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memory[es*16 + r16[bx] + 1] == 0xff) {
            pc = 0x11efe;
            break;
        }
        push(memory16get(ss, bp - 14));
        push(memory16get(ss, bp - 10));
        push(memory16get(ss, bp - 12));
        r8[al] = memory[es*16 + r16[bx] + 1];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_12197();
        assert(cs == 0x11cd);
        sp += 0x0008;
    case 0x11efe:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11f04() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        if (r16[si] >= memory16get(ds, 0x89fc)) {
            pc = 0x11f7b;
            break;
        }
        if (r16[di] <= 0x007f) {
            pc = 0x11f20;
            break;
        }
        r16[di] = 0x007f;
    case 0x11f20:
        r16[ax] = r16[di];
        memory[ds*16 + r16[si] + 35290] = r8[al];
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x11f41;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] += 0x1b7b;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        pc = 0x11f53;
        break;
    case 0x11f41:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] += 0x1b69;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
    case 0x11f53:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_12305();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memory[es*16 + r16[bx] + 1] == 0xff) {
            pc = 0x11f7b;
            break;
        }
        r8[al] = memory[es*16 + r16[bx] + 1];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_12305();
        assert(cs == 0x11cd);
        sp++;
        sp++;
    case 0x11f7b:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_11fba() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        r16[di] -= 0x000c;
        if (signed16(r16[di]) >= 0) {
            pc = 0x11fce;
            break;
        }
        r16[di] = 0;
    case 0x11fce:
        if (memory[ds*16 + 0x8a0b] != 0x00) {
            pc = 0x11fda;
            break;
        }
        if (r16[si] < 0x0009) {
            pc = 0x11fdf;
            break;
        }
    case 0x11fda:
        if (r16[si] >= 0x0006) {
            pc = 0x11ff4;
            break;
        }
    case 0x11fdf:
        r16[ax] = r16[di];
        memory[ds*16 + r16[si] + 35326] = r8[al];
        memory[ds*16 + r16[si] + 35340] = 0x20;
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_125c0();
        assert(cs == 0x11cd);
        sp = bp;
        pc = 0x12058;
        break;
    case 0x11ff4:
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x12058;
            break;
        }
        if (r16[si] > 0x000a) {
            pc = 0x12058;
            break;
        }
        if (r16[si] != 0x0006) {
            pc = 0x12014;
            break;
        }
        r16[ax] = r16[di];
        memory[ds*16 + 0x8a04] = r8[al];
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_125c0();
        assert(cs == 0x11cd);
        sp = bp;
        pc = 0x12044;
        break;
    case 0x12014:
        if (r16[si] != 0x0008) {
            pc = 0x12044;
            break;
        }
        r8[al] = memory[ds*16 + 0x8a06];
        cbw();
        if (r16[ax] == r16[di]) {
            pc = 0x12044;
            break;
        }
        r16[ax] = r16[di];
        memory[ds*16 + 0x8a06] = r8[al];
        r16[ax] = r16[di];
        r8[al] += 0x07;
        memory[ds*16 + 0x8a05] = r8[al];
        r16[ax] = 0x0008;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_125c0();
        assert(cs == 0x11cd);
        sp = bp;
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_125c0();
        assert(cs == 0x11cd);
        sp = bp;
    case 0x12044:
        r16[bx] = r16[si];
        r16[bx] += 0xfffa;
        r8[al] = memory[ds*16 + r16[bx] + 6900];
        memory[ds*16 + 0x89fa] = memory[ds*16 + 0x89fa] | r8[al];
        push(cs);
        cs = 0x11cd;
        yield* sub_12541();
        assert(cs == 0x11cd);
        sp = bp;
    case 0x12058:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1205c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        if (memory[ds*16 + 0x8a0b] != 0x00) {
            pc = 0x1206f;
            break;
        }
        if (r16[si] < 0x0009) {
            pc = 0x12074;
            break;
        }
    case 0x1206f:
        if (r16[si] >= 0x0006) {
            pc = 0x12093;
            break;
        }
    case 0x12074:
        memory[ds*16 + r16[si] + 35340] = 0x00;
        memory[ds*16 + r16[si] + 35350] = memory[ds*16 + r16[si] + 35350] & 0xdf;
        r8[al] = memory[ds*16 + r16[si] + 35350];
        cbw();
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x00b0;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp = bp;
        pc = 0x120b5;
        break;
    case 0x12093:
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x120b5;
            break;
        }
        if (r16[si] > 0x000a) {
            pc = 0x120b5;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] += 0xfffa;
        r8[al] = memory[ds*16 + r16[bx] + 6900];
        r8[al] = ~r8[al];
        memory[ds*16 + 0x89fa] = memory[ds*16 + 0x89fa] & r8[al];
        push(cs);
        cs = 0x11cd;
        yield* sub_12541();
        assert(cs == 0x11cd);
        sp = bp;
    case 0x120b5:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_120b8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = 0;
        pc = 0x120e9;
        break;
    case 0x120bd:
        if (memory[ds*16 + r16[si] + 7075] == 0x00) {
            pc = 0x120d7;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b07;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
        pc = 0x120e8;
        break;
    case 0x120d7:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1af9;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
    case 0x120e8:
        r16[si]++;
    case 0x120e9:
        if (signed16(r16[si]) < signed16(0x0012)) {
            pc = 0x120bd;
            break;
        }
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x1216d;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b15;
        push(r16[ax]);
        r16[ax] = 0x000c;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b23;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b31;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b3f;
        push(r16[ax]);
        r16[ax] = 0x000e;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b4d;
        push(r16[ax]);
        r16[ax] = 0x0011;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1b5b;
        push(r16[ax]);
        r16[ax] = 0x000d;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_121f0();
        assert(cs == 0x11cd);
        sp += 0x0008;
    case 0x1216d:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12197() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[si] = 0;
        r16[ax] = memory16get(ss, bp + 8);
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r16[bx] += 0x88de;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        pc = 0x121ce;
        break;
    case 0x121ba:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        r16[si]++;
    case 0x121ce:
        if (signed16(r16[si]) < signed16(0x000d)) {
            pc = 0x121ba;
            break;
        }
        memory16set(ss, bp + 14, memory16get(ss, bp + 14) & 0x0003);
        r16[ax] = memory16get(ss, bp + 14);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        push(memory16get(ss, bp + 8));
        push(cs);
        cs = 0x11cd;
        yield* sub_122bd();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_121f0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x001c;
        r16[si] = 0;
        pc = 0x12213;
        break;
    case 0x121fb:
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r8[ah] = 0x00;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[dx] = bp - 0x1c;
        r16[bx] += r16[dx];
        memory16set(ss, r16[bx], r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 1);
        r16[si]++;
    case 0x12213:
        if (signed16(r16[si]) < signed16(0x000d)) {
            pc = 0x121fb;
            break;
        }
        push(memory16get(ss, bp + 14));
        push(ss);
        r16[ax] = bp - 0x1c;
        push(r16[ax]);
        push(memory16get(ss, bp + 8));
        push(cs);
        yield* sub_12197();
        sp += 0x0008;
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_122bd() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[si] = memory16get(ss, bp + 8);
    push(cs);
    cs = 0x11cd;
    yield* sub_12541();
    assert(cs == 0x11cd);
    sp = bp;
    push(cs);
    cs = 0x11cd;
    yield* sub_123ba();
    assert(cs == 0x11cd);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x11cd;
    yield* sub_12305();
    assert(cs == 0x11cd);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x11cd;
    yield* sub_123d6();
    assert(cs == 0x11cd);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x11cd;
    yield* sub_12425();
    assert(cs == 0x11cd);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x11cd;
    yield* sub_1246a();
    assert(cs == 0x11cd);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x11cd;
    yield* sub_124af();
    assert(cs == 0x11cd);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x11cd;
    yield* sub_12585();
    assert(cs == 0x11cd);
    sp = bp;
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_12305() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[di] = memory16get(ss, bp + 10);
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x12321;
            break;
        }
        r8[al] = memory[ds*16 + r16[di] + 7111];
        cbw();
        memory16set(ss, bp - 4, r16[ax]);
        pc = 0x12329;
        break;
    case 0x12321:
        r8[al] = memory[ds*16 + r16[di] + 7093];
        cbw();
        memory16set(ss, bp - 4, r16[ax]);
    case 0x12329:
        r16[si] = 0x003f;
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35046];
        cbw();
        r16[ax] &= r16[si];
        r16[si] -= r16[ax];
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x12350;
            break;
        }
        if (memory16get(ss, bp - 4) <= 0x0006) {
            pc = 0x12350;
            break;
        }
        r16[ax] = 0x0001;
        pc = 0x12352;
        break;
    case 0x12350:
        r16[ax] = 0;
    case 0x12352:
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ds*16 + r16[di] + 7075] != 0x00) {
            pc = 0x12372;
            break;
        }
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 35050] == 0x00) {
            pc = 0x12372;
            break;
        }
        if (memory16get(ss, bp - 2) == 0x0000) {
            pc = 0x12386;
            break;
        }
    case 0x12372:
        r16[bx] = memory16get(ss, bp - 4);
        r8[al] = memory[ds*16 + r16[bx] + 35290];
        cbw();
        mul16(r16[si]);
        r16[ax] += 0x0040;
        r16[cx] = 0x0007;
        r16[ax] >>= r8[cl];
        r16[si] = r16[ax];
    case 0x12386:
        r16[ax] = 0x003f;
        r16[ax] -= r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35038];
        cbw();
        r16[cx] = 0x0006;
        r16[ax] <<= r8[cl];
        r16[si] |= r16[ax];
        push(r16[si]);
        r8[al] = memory[ds*16 + r16[di] + 7057];
        cbw();
        r16[ax] += 0x0040;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_123ba() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x88da] == 0x00) {
            pc = 0x123c6;
            break;
        }
        r16[ax] = 0x0040;
        pc = 0x123c8;
        break;
    case 0x123c6:
        r16[ax] = 0;
    case 0x123c8:
        push(r16[ax]);
        r16[ax] = 0x0008;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_123d6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 10);
        if (memory[ds*16 + r16[si] + 7075] != 0x00) {
            pc = 0x12421;
            break;
        }
        r16[ax] = r16[si];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35040];
        cbw();
        r16[di] = r16[ax];
        r16[di] <<= 1;
        r16[ax] = r16[si];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 35050] == 0x00) {
            pc = 0x1240b;
            break;
        }
        r16[ax] = 0;
        pc = 0x1240e;
        break;
    case 0x1240b:
        r16[ax] = 0x0001;
    case 0x1240e:
        r16[di] |= r16[ax];
        push(r16[di]);
        r8[al] = memory[ds*16 + r16[si] + 7093];
        cbw();
        r16[ax] += 0x00c0;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp = bp;
    case 0x12421:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12425() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    r16[di] = memory16get(ss, bp + 10);
    r16[ax] = r16[di];
    r16[dx] = 0x000e;
    mul16(r16[dx]);
    r16[bx] = r16[ax];
    r8[al] = memory[ds*16 + r16[bx] + 35041];
    cbw();
    r16[si] = r16[ax];
    r16[cx] = 0x0004;
    r16[si] <<= r8[cl];
    r16[ax] = r16[di];
    r16[dx] = 0x000e;
    mul16(r16[dx]);
    r16[bx] = r16[ax];
    r8[al] = memory[ds*16 + r16[bx] + 35044];
    cbw();
    r16[ax] &= 0x000f;
    r16[si] |= r16[ax];
    push(r16[si]);
    r8[al] = memory[ds*16 + r16[di] + 7057];
    cbw();
    r16[ax] += 0x0060;
    push(r16[ax]);
    push(cs);
    cs = 0x1e69;
    yield* sub_1e69a();
    assert(cs == 0x11cd);
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1246a() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    r16[di] = memory16get(ss, bp + 10);
    r16[ax] = r16[di];
    r16[dx] = 0x000e;
    mul16(r16[dx]);
    r16[bx] = r16[ax];
    r8[al] = memory[ds*16 + r16[bx] + 35042];
    cbw();
    r16[si] = r16[ax];
    r16[cx] = 0x0004;
    r16[si] <<= r8[cl];
    r16[ax] = r16[di];
    r16[dx] = 0x000e;
    mul16(r16[dx]);
    r16[bx] = r16[ax];
    r8[al] = memory[ds*16 + r16[bx] + 35045];
    cbw();
    r16[ax] &= 0x000f;
    r16[si] |= r16[ax];
    push(r16[si]);
    r8[al] = memory[ds*16 + r16[di] + 7057];
    cbw();
    r16[ax] += 0x0080;
    push(r16[ax]);
    push(cs);
    cs = 0x1e69;
    yield* sub_1e69a();
    assert(cs == 0x11cd);
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_124af() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[di] = memory16get(ss, bp + 10);
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 35047] == 0x00) {
            pc = 0x124cc;
            break;
        }
        r16[si] = 0x0080;
        pc = 0x124ce;
        break;
    case 0x124cc:
        r16[si] = 0;
    case 0x124ce:
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 35048] == 0x00) {
            pc = 0x124e3;
            break;
        }
        r16[ax] = 0x0040;
        pc = 0x124e5;
        break;
    case 0x124e3:
        r16[ax] = 0;
    case 0x124e5:
        r16[si] += r16[ax];
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 35043] == 0x00) {
            pc = 0x124fc;
            break;
        }
        r16[ax] = 0x0020;
        pc = 0x124fe;
        break;
    case 0x124fc:
        r16[ax] = 0;
    case 0x124fe:
        r16[si] += r16[ax];
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        if (memory[ds*16 + r16[bx] + 35049] == 0x00) {
            pc = 0x12515;
            break;
        }
        r16[ax] = 0x0010;
        pc = 0x12517;
        break;
    case 0x12515:
        r16[ax] = 0;
    case 0x12517:
        r16[si] += r16[ax];
        r16[ax] = r16[di];
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35039];
        cbw();
        r16[ax] &= 0x000f;
        r16[si] += r16[ax];
        push(r16[si]);
        r8[al] = memory[ds*16 + r16[di] + 7057];
        cbw();
        r16[ax] += 0x0020;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12541() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory[ds*16 + 0x8a0a] == 0x00) {
            pc = 0x1254e;
            break;
        }
        r16[si] = 0x0080;
        pc = 0x12550;
        break;
    case 0x1254e:
        r16[si] = 0;
    case 0x12550:
        if (memory[ds*16 + 0x8a15] == 0x00) {
            pc = 0x1255c;
            break;
        }
        r16[ax] = 0x0040;
        pc = 0x1255e;
        break;
    case 0x1255c:
        r16[ax] = 0;
    case 0x1255e:
        r16[si] |= r16[ax];
        if (memory[ds*16 + 0x8a0b] == 0x00) {
            pc = 0x1256c;
            break;
        }
        r16[ax] = 0x0020;
        pc = 0x1256e;
        break;
    case 0x1256c:
        r16[ax] = 0;
    case 0x1256e:
        r16[si] |= r16[ax];
        r8[al] = memory[ds*16 + 0x89fa];
        cbw();
        r16[si] |= r16[ax];
        push(r16[si]);
        r16[ax] = 0x00bd;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12585() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        if (memory16get(ds, 0x88dc) == 0x0000) {
            pc = 0x125a7;
            break;
        }
        r16[ax] = memory16get(ss, bp + 8);
        r16[dx] = 0x000e;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r8[al] = memory[ds*16 + r16[bx] + 35051];
        cbw();
        r16[si] = r16[ax];
        r16[si] &= 0x0003;
        pc = 0x125a9;
        break;
    case 0x125a7:
        r16[si] = 0;
    case 0x125a9:
        push(r16[si]);
        r16[bx] = memory16get(ss, bp + 8);
        r8[al] = memory[ds*16 + r16[bx] + 7057];
        cbw();
        r16[ax] += 0x00e0;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_125c0() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[si] = memory16get(ss, bp + 8);
    r8[al] = memory[ds*16 + r16[si] + 35340];
    cbw();
    push(r16[ax]);
    r16[bx] = r16[si];
    r16[bx] <<= 1;
    push(memory16get(ds, r16[bx] + 35304));
    r8[al] = memory[ds*16 + r16[si] + 35326];
    cbw();
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    cs = 0x1e6d;
    yield* sub_1e6d6();
    assert(cs == 0x11cd);
    sp = bp;
    memory[ds*16 + r16[si] + 35350] = r8[al];
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_125ea() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[ax] = 0x0060;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        push(memory16get(ds, 0x8a08));
        push(cs);
        cs = 0x1f0c;
        yield* sub_1f0c9();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        r16[di] = r16[ax];
        r16[ax] = 0x00ff;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[ax] = 0x0021;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[si] = 0;
        pc = 0x1264e;
        break;
    case 0x12642:
        push(memory16get(ds, 0x8a08));
        push(cs);
        cs = 0x1f0c;
        yield* sub_1f0c9();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        r16[si]++;
    case 0x1264e:
        if (r16[si] < 0x00c8) {
            pc = 0x12642;
            break;
        }
        push(memory16get(ds, 0x8a08));
        push(cs);
        cs = 0x1f0c;
        yield* sub_1f0c9();
        assert(cs == 0x11cd);
        sp++;
        sp++;
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = 0x0060;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x11cd);
        sp += 0x0004;
        if (r16[di] & 0x00e0) {
            pc = 0x12698;
            break;
        }
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax] &= 0x00e0;
        if (r16[ax] != 0x00c0) {
            pc = 0x12698;
            break;
        }
        r16[ax] = 0x0001;
        pc = 0x1269a;
        break;
    case 0x12698:
        r16[ax] = 0;
    case 0x1269a:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_126a0() {
    cs = pop();
}
function* sub_126a8() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    r16[ax] = memory16get(ss, bp + 10);
    r16[bx] = 0x0001;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_126c9() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    r16[ax] = memory16get(ss, bp + 10);
    r16[bx] = 0x0002;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_126ea() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    r16[ax] = memory16get(ss, bp + 8);
    r16[si] = 0x0000;
    r16[ax] = 0x0000;
    r16[bx] = 0x0003;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_12738() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    es = memory16get(ss, bp + 10);
    r16[ax] = memory16get(ss, bp + 12);
    r16[di] = r16[ax];
    r16[si] = 0x0000;
    r16[bx] = 0x0005;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_12761() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    es = memory16get(ss, bp + 10);
    r16[ax] = memory16get(ss, bp + 12);
    r16[di] = r16[ax];
    r16[si] = 0x0000;
    r16[bx] = 0x0006;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1278a() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    r16[si] = 0x0000;
    r16[bx] = 0x0008;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_127ab() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(es);
    push(ds);
    push(r16[di]);
    push(r16[si]);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    ds = memory16get(ss, bp + 6);
    r16[si] = 0x0000;
    r16[bx] = 0x0009;
    push(cs);
    cs = 0x126a;
    yield* sub_126a0();
    assert(cs == 0x126a);
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    r16[si] = pop();
    r16[di] = pop();
    ds = pop();
    es = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_127cc() {
    //CStackGuardFar sg(0, false);
    push(r16[si]);
    push(r16[di]);
    r16[di] = memory16get(ds, 0x8bf4);
    r16[si] = memory16get(ds, 0x8bf2);
    r16[si] += 0x000f;
    r16[ax] = r16[si];
    r16[cx] = 0x0004;
    r16[ax] >>= r8[cl];
    r16[si] = r16[ax];
    r16[di] += r16[si];
    r16[si] = 0;
    memory16set(ds, 0x8a20, r16[di]);
    r16[di] = pop();
    r16[si] = pop();
    cs = pop();
}
function* sub_127ed() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(cs);
    yield* sub_127cc();
    sp = bp;
    push(memory16get(ss, bp + 6));
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ds, 0x8a20));
    push(cs);
    cs = 0x126a;
    yield* sub_126a8();
    assert(cs == 0x127c);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_12809() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(cs);
    yield* sub_127cc();
    sp = bp;
    push(memory16get(ss, bp + 6));
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ds, 0x8a20));
    push(cs);
    cs = 0x126a;
    yield* sub_126c9();
    assert(cs == 0x127c);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_12825() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        push(cs);
        yield* sub_127cc();
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x8a20));
        push(cs);
        cs = 0x126a;
        yield* sub_126ea();
        assert(cs == 0x127c);
        sp += 0x0004;
        memory[ss*16 + bp - 5] = r8[al];
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x12865;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8dbe);
        push(memory16get(ss, bp - 4));
        r16[ax] = memory16get(ss, bp - 2);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x8a20));
        push(cs);
        cs = 0x126a;
        yield* sub_12738();
        assert(cs == 0x127c);
        sp += 0x0008;
    case 0x12865:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12886() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(cs);
    yield* sub_127cc();
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ds, 0x8a20));
    push(cs);
    cs = 0x126a;
    yield* sub_1278a();
    assert(cs == 0x127c);
    sp += 0x0004;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_128b3() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[bx] = memory16get(ss, bp + 8);
    es = memory16get(ss, bp + 8 + 2);
    r8[al] = memory[es*16 + r16[bx] + 21];
    r8[ah] = 0x00;
    r16[si] = r16[ax];
    r16[cx] = 0x0008;
    r16[si] <<= r8[cl];
    r8[al] = memory[es*16 + r16[bx] + 20];
    r8[ah] = 0x00;
    r16[si] += r16[ax];
    memory16set(ss, bp + 8, memory16get(ss, bp + 8) + r16[si]);
    push(cs);
    yield* sub_12886();
    sp = bp;
    push(cs);
    yield* sub_127cc();
    sp = bp;
    push(memory16get(ss, bp + 8));
    r16[ax] = memory16get(ss, bp + 10);
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ds, 0x8a20));
    push(cs);
    cs = 0x126a;
    yield* sub_12761();
    assert(cs == 0x127c);
    sp = bp;
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_128f6() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(cs);
    yield* sub_127cc();
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ds, 0x8a20));
    push(cs);
    cs = 0x126a;
    yield* sub_127ab();
    assert(cs == 0x127c);
    sp += 0x0004;
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1290a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[bx] = memory16get(ss, bp + 6);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 36342);
        es = memory16get(ds, r16[tx] + 36342 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        r16[ax] = r16[bx];
        r16[ax] |= memory16get(ss, bp - 2);
        if (!r16[ax]) {
            pc = 0x12935;
            break;
        }
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        yield* sub_128b3();
        sp += 0x0004;
    case 0x12935:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_129c3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(r16[dx]);
        push(r16[cx]);
        r16[cx] = memory16get(ss, bp + 6);
        r16[dx] = memory16get(ss, bp + 8);
        r16[dx]++;
    case 0x129cf:
        r8[al] = in8(r16[dx]);
        r8[al] &= 0x40;
        if (r8[al] != 0) {
            pc = 0x129cf;
            break;
        }
        r8[al] = r8[cl];
        r16[dx]--;
        out8(r16[dx], r8[al]);
        r16[cx] = pop();
        r16[dx] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12df2() {
    //CStackGuardFar sg(0, false);
    r16[ax] = memory16get(cs, 0x041c);
    cs = pop();
}
function* sub_12dfc() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[ax] = memory16get(ss, bp + 6);
    memory16set(cs, 0x0010, r16[ax]);
    r16[ax] = memory16get(ss, bp + 8);
    memory16set(cs, 0x0412, r16[ax]);
    r16[ax] = memory16get(ss, bp + 10);
    memory16set(cs, 0x0414, r16[ax]);
    r16[ax] = memory16get(ss, bp + 12);
    memory16set(cs, 0x0416, r16[ax]);
    r16[ax] = memory16get(ss, bp + 14);
    memory16set(cs, 0x0418, r16[ax]);
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_12e24() {
    //CStackGuardFar sg(0, false);
    push(r16[bx]);
    push(r16[cx]);
    push(r16[dx]);
    push(ds);
    r8[ah] = 0x3f;
    r16[bx] = memory16get(cs, 0x0010);
    r16[cx] = 0x0400;
    r16[dx] = 0x129d;
    ds = r16[dx];
    r16[dx] = 0x0012;
    interrupt(0x21);
    r16[ax] = 0x0001;
    memory16set(cs, 0x000c, r16[ax]);
    r8[al] = memory[cs*16 + 0x0012];
    memory[cs*16 + 0x000e] = r8[al];
    r8[al] = 0x80;
    memory[cs*16 + 0x000f] = r8[al];
    ds = pop();
    r16[dx] = pop();
    r16[cx] = pop();
    r16[bx] = pop();
    cs = pop();
}
function* sub_12e56() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(0, false);
        r8[al] = r8[dh];
        r8[al] &= r8[dl];
        r8[dl] >>= 1;
        if (r8[dl] == 0) {
            pc = 0x12e61;
            break;
        }
        flags.zero = r8[al] == 0;
        return;
    case 0x12e61:
        r8[dl] = 0x80;
        r16[bx] = memory16get(cs, 0x000c);
        if (r16[bx] == 0x0400) {
            pc = 0x12e7b;
            break;
        }
        r8[dh] = memory[cs*16 + r16[bx] + 18];
        memory16set(cs, 0x000c, memory16get(cs, 0x000c) + 1);
        flags.zero = r8[al] == 0;
        return;
    case 0x12e7b:
        push(r16[ax]);
        push(cs);
        cs = 0x129d;
        yield* sub_12e24();
        assert(cs == 0x129d);
        r8[dl] = 0x80;
        r8[dh] = memory[cs*16 + 0x000e];
        r16[ax] = pop();
        flags.zero = r8[al] == 0;
        return;
    } while (1);
}
function* sub_12e8c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(0, false);
        r8[cl] = 0x00;
        r8[ch] = 0x80;
    case 0x12e90:
        r8[al] = r8[dh];
        r8[al] &= r8[dl];
        r8[dl] >>= 1;
        if (r8[dl] != 0) {
            pc = 0x12ebf;
            break;
        }
        r8[dl] = 0x80;
        r16[bx] = memory16get(cs, 0x000c);
        if (r16[bx] != 0x0400) {
            pc = 0x12eb5;
            break;
        }
        push(r16[ax]);
        push(cs);
        cs = 0x129d;
        yield* sub_12e24();
        assert(cs == 0x129d);
        r8[dl] = 0x80;
        r8[dh] = memory[cs*16 + 0x000e];
        r16[ax] = pop();
        pc = 0x12ebf;
        break;
    case 0x12eb5:
        r8[dh] = memory[cs*16 + r16[bx] + 18];
        memory16set(cs, 0x000c, memory16get(cs, 0x000c) + 1);
    case 0x12ebf:
        if (r8[al] == 0) {
            pc = 0x12ec5;
            break;
        }
        r8[cl] |= r8[ch];
    case 0x12ec5:
        r8[ch] >>= 1;
        if (r8[ch] != 0) {
            pc = 0x12e90;
            break;
        }
        r8[al] = r8[cl];
        return;
    } while (1);
}
function* sub_12ed7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(0, false);
        pc = 0x12ed7;
        break;
    case 0x12ecc:
        yield* sub_12e8c();
        memory[es*16 + r16[di]] = r8[al];
        r16[di]++;
        r16[bx] = 0x0001;
        return;
    case 0x12ed7:
        yield* sub_12e56();
        if (flags.zero) {
            pc = 0x12ecc;
            break;
        }
        r16[cx] = 0x0000;
        push(r16[cx]);
        yield* sub_12e56();
        r16[cx] = pop();
        if (flags.zero) {
            pc = 0x12ee9;
            break;
        }
        r16[cx] = 0x0002;
    case 0x12ee9:
        push(r16[cx]);
        yield* sub_12e56();
        r16[cx] = pop();
        if (flags.zero) {
            pc = 0x12ef1;
            break;
        }
        r16[cx]++;
    case 0x12ef1:
        r16[cx] += 0x0002;
        push(r16[cx]);
        yield* sub_12e8c();
        r8[ah] = 0x00;
        r16[ax]++;
        r16[cx] = pop();
        r16[si] = r16[di];
        r16[si] -= r16[ax];
        push(es);
        ds = pop();
        r16[bx] = r16[cx];
        flags.direction = false;
        rep_movsb_data_data_forward();
        return;
    } while (1);
}
function* sub_12f08() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(es);
        push(ds);
        push(r16[di]);
        push(r16[si]);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        r16[ax] = memory16get(ss, bp + 6);
        memory16set(cs, 0x041a, r16[ax]);
        r16[ax] = memory16get(ss, bp + 8);
        memory16set(cs, 0x041c, r16[ax]);
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(cs, 0x041e, r16[ax]);
        r16[ax] += memory16get(cs, 0x0418);
        memory16set(cs, 0x0420, r16[ax]);
        r16[ax] = memory16get(cs, 0x0416);
        es = r16[ax];
        r16[di] = memory16get(cs, 0x0418);
        r16[ax] = memory16get(ss, bp + 8);
        r16[di] += r16[ax];
        r8[dl] = memory[cs*16 + 0x000f];
        r8[dh] = memory[cs*16 + 0x000e];
        r16[ax] = memory16get(cs, 0x0412);
        r16[cx] = memory16get(cs, 0x0414);
    case 0x12f53:
        if (signed16(r16[di]) >= memory16gets(cs, 0x0420)) {
            pc = 0x12f6c;
            break;
        }
        push(r16[ax]);
        push(r16[cx]);
        yield* sub_12ed7();
        r16[cx] = pop();
        r16[ax] = pop();
        flags.carry = r16[ax] < r16[bx];
        r16[ax] -= r16[bx];
        r16[cx] -= flags.carry;
        if (r16[cx] != 0) {
            pc = 0x12f53;
            break;
        }
        if (r16[ax] != 0) {
            pc = 0x12f53;
            break;
        }
    case 0x12f6c:
        memory16set(cs, 0x0412, r16[ax]);
        memory16set(cs, 0x0414, r16[cx]);
        memory[cs*16 + 0x000f] = r8[dl];
        memory[cs*16 + 0x000e] = r8[dh];
        r16[di] -= memory16get(cs, 0x0418);
        memory16set(cs, 0x041c, r16[di]);
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[si] = pop();
        r16[di] = pop();
        ds = pop();
        es = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12f92() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[si] = 0;
        pc = 0x12fb1;
        break;
    case 0x12f9e:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35376, 0x0000);
        memory16set(ds, r16[bx] + 35374, 0x0000);
        r16[si]++;
    case 0x12fb1:
        if (r16[si] < 0x000e) {
            pc = 0x12f9e;
            break;
        }
        r16[di] = 0;
    case 0x12fb8:
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] |= memory16get(ss, bp + 12);
        if (!r16[ax]) {
            pc = 0x13026;
            break;
        }
        if (memory16get(ss, bp + 12) < 0x0000) {
            pc = 0x12fe8;
            break;
        }
        if (memory16get(ss, bp + 12) > 0x0000) {
            pc = 0x12fcf;
            break;
        }
        if (memory16get(ss, bp + 10) <= 0xfa00) {
            pc = 0x12fe8;
            break;
        }
    case 0x12fcf:
        memory16set(ss, bp - 2, 0xfa00);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 10);
        flags.carry = (r16[ax] + 0x0600) >= 0x10000;
        r16[ax] += 0x0600;
        r16[dx] += 0xffff + flags.carry;
        memory16set(ss, bp + 12, r16[dx]);
        memory16set(ss, bp + 10, r16[ax]);
        pc = 0x12ff8;
        break;
    case 0x12fe8:
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp + 12, 0x0000);
        memory16set(ss, bp + 10, 0x0000);
    case 0x12ff8:
        if (memory16get(ss, bp + 12) < 0x0000) {
            pc = 0x1300a;
            break;
        }
        if (memory16get(ss, bp + 12) != 0x0000) {
            pc = 0x13007;
            break;
        }
        if (memory16get(ss, bp + 10) < 0x8000) {
            pc = 0x1300a;
            break;
        }
    case 0x13007:
        memory16set(ss, bp - 4, r16[di]);
    case 0x1300a:
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35376, r16[dx]);
        memory16set(ds, r16[bx] + 35374, r16[ax]);
        r16[di]++;
        pc = 0x12fb8;
        break;
    case 0x13026:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_12f99() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        r8[al] += 0x33;
        imul8(r8[bl]);
        stop(/*8*/);
        r16[cx] += memory16get(ss, bp + r16[di] + 53726) + flags.carry;
        if (r16[cx] == 0) {
            pc = 0x22f74;
            break;
        }
        if (r16[cx] == 0) {
            pc = 0x22f6c;
            break;
        }
        r16[tx] = memory16get(ds, r16[bx] + r16[si]);
        memory16set(ds, r16[bx] + r16[si], r16[si]);
        r16[si] = r16[tx];
        r8[al] = memory[ds*16 + r16[bx] + r16[si]];
        r8[bh] += r8[al];
        r16[tx] = memory16get(ds, 0x008a);
        memory16set(ds, 0x008a, bp);
        bp = r16[tx];
        memory[ss*16 + bp - 125] += r8[al];
        memory[ds*16 + 0xe872] -= 1;
        r16[di] = 0;
    case 0x12fb8:
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] |= memory16get(ss, bp + 12);
        if (!r16[ax]) {
            pc = 0x13026;
            break;
        }
        if (memory16get(ss, bp + 12) < 0x0000) {
            pc = 0x12fe8;
            break;
        }
        if (memory16get(ss, bp + 12) > 0x0000) {
            pc = 0x12fcf;
            break;
        }
        if (memory16get(ss, bp + 10) <= 0xfa00) {
            pc = 0x12fe8;
            break;
        }
    case 0x12fcf:
        memory16set(ss, bp - 2, 0xfa00);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 10);
        flags.carry = (r16[ax] + 0x0600) >= 0x10000;
        r16[ax] += 0x0600;
        r16[dx] += 0xffff + flags.carry;
        memory16set(ss, bp + 12, r16[dx]);
        memory16set(ss, bp + 10, r16[ax]);
        pc = 0x12ff8;
        break;
    case 0x12fe8:
        r16[ax] = memory16get(ss, bp + 10);
        memory16set(ss, bp - 2, r16[ax]);
        memory16set(ss, bp + 12, 0x0000);
        memory16set(ss, bp + 10, 0x0000);
    case 0x12ff8:
        if (memory16get(ss, bp + 12) < 0x0000) {
            pc = 0x1300a;
            break;
        }
        if (memory16get(ss, bp + 12) != 0x0000) {
            pc = 0x13007;
            break;
        }
        if (memory16get(ss, bp + 10) < 0x8000) {
            pc = 0x1300a;
            break;
        }
    case 0x13007:
        memory16set(ss, bp - 4, r16[di]);
    case 0x1300a:
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 35376, r16[dx]);
        memory16set(ds, r16[bx] + 35374, r16[ax]);
        r16[di]++;
        pc = 0x12fb8;
        break;
    case 0x13026:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    case 0x22f6c:
        push(bp);
        memory[ds*16 + r16[si]] += r8[cl];
        memory[ss*16 + bp + r16[si]] += r8[dl];
        memory[ds*16 + r16[si]] += r8[al];
    case 0x22f74:
        memory16set(ds, r16[bx] + r16[si], memory16get(ds, r16[bx] + r16[si]) + 0x000d);
        r8[al] += 0x00;
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1302c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x00d6;
        push(ss);
        r16[ax] = bp - 0xc4;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1bf4;
        push(r16[ax]);
        r16[cx] = 0x0078;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x12f9);
        push(ss);
        r16[ax] = bp - 0x4c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1c6c;
        push(r16[ax]);
        r16[cx] = 0x0048;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x12f9);
        memory[ds*16 + 0x8dd0] = 0x00;
        push(cs);
        cs = 0x023f;
        yield* sub_241e();
        assert(cs == 0x12f9);
        memory16set(ds, 0x8de4, r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a263();
        assert(cs == 0x12f9);
        push(cs);
        cs = 0x0ee7;
        yield* sub_10aba();
        assert(cs == 0x12f9);
        memory[ss*16 + bp - 214] = 0x00;
        r16[ax] = 0x8001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1cb4;
        push(r16[ax]);
        push(cs);
        cs = 0x1f2b;
        yield* sub_1f2e7();
        assert(cs == 0x12f9);
        sp += 0x0006;
        r16[si] = r16[ax];
        if (r16[si] != 0xffff) {
            pc = 0x13094;
            break;
        }
        memory[ss*16 + bp - 214] = 0x01;
        pc = 0x13108;
        break;
    case 0x13094:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x91a2;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x12f9);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8dde;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x12f9);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8db5;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x12f9);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bda;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x12f9);
        sp += 0x0008;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8de0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x12f9);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8dbb;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f4a;
        yield* sub_1f4af();
        assert(cs == 0x12f9);
        sp += 0x0008;
        push(r16[si]);
        push(cs);
        cs = 0x1e98;
        yield* sub_1e98c();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x13108:
        if (memory16gets(ss, bp + 8) <= signed16(0x0001)) {
            pc = 0x1312f;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 213] = r8[al];
        if (memory[ss*16 + bp - 213] == 0x52) {
            pc = 0x1312a;
            break;
        }
        if (memory[ss*16 + bp - 213] != 0x72) {
            pc = 0x1312f;
            break;
        }
    case 0x1312a:
        memory[ss*16 + bp - 214] = 0x01;
    case 0x1312f:
        r8[al] = 0x00;
        memory[ds*16 + 0x8c58] = r8[al];
        memory[ds*16 + 0x8bf0] = r8[al];
        memory[ds*16 + 0x8a2c] = r8[al];
        memory[ds*16 + 0x8f67] = r8[al];
        memory[ds*16 + 0x919d] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8ddf] = r8[al];
        memory[ds*16 + 0x8dc4] = r8[al];
        if (memory[ss*16 + bp - 214] == 0x00) {
            pc = 0x13167;
            break;
        }
        r8[al] = 0x00;
        memory[ds*16 + 0x91a2] = r8[al];
        memory[ds*16 + 0x8bda] = r8[al];
        memory[ds*16 + 0x8db5] = r8[al];
        memory[ds*16 + 0x8dde] = r8[al];
        r8[al] = 0x00;
        memory[ds*16 + 0x8dbb] = r8[al];
        r8[ah] = 0x00;
        memory16set(ds, 0x8de0, r16[ax]);
    case 0x13167:
        push(cs);
        cs = 0x0ee7;
        yield* sub_1061f();
        assert(cs == 0x12f9);
        r8[al] = memory[ds*16 + 0x8dde];
        r8[ah] = 0x00;
        if (r16[ax] == 0x0048) {
            pc = 0x131af;
            break;
        }
        if (r16s[ax] > signed16(0x0048)) {
            pc = 0x13184;
            break;
        }
        if (r16[ax] == 0x0043) {
            pc = 0x13190;
            break;
        }
        if (r16[ax] == 0x0045) {
            pc = 0x13197;
            break;
        }
        pc = 0x131bb;
        break;
    case 0x13184:
        if (r16[ax] == 0x0054) {
            pc = 0x131b6;
            break;
        }
        if (r16[ax] == 0x0056) {
            pc = 0x1319e;
            break;
        }
        pc = 0x131bb;
        break;
    case 0x13190:
        memory[ds*16 + 0x8a2c] = 0x01;
        pc = 0x131bb;
        break;
    case 0x13197:
        memory[ds*16 + 0x919d] = 0x01;
        pc = 0x131bb;
        break;
    case 0x1319e:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x131bb;
            break;
        }
        r8[al] = 0x01;
        memory[ds*16 + 0x8f67] = r8[al];
        memory[ds*16 + 0x919d] = r8[al];
        pc = 0x131bb;
        break;
    case 0x131af:
        memory[ds*16 + 0x8c58] = 0x01;
        pc = 0x131bb;
        break;
    case 0x131b6:
        memory[ds*16 + 0x8bf0] = 0x01;
    case 0x131bb:
        r8[al] = memory[ds*16 + 0x8bda];
        r8[ah] = 0x00;
        if (r16[ax] == 0x0043) {
            pc = 0x131d1;
            break;
        }
        if (r16[ax] == 0x004a) {
            pc = 0x131f1;
            break;
        }
        if (r16[ax] == 0x004d) {
            pc = 0x131db;
            break;
        }
        pc = 0x13205;
        break;
    case 0x131d1:
        r8[al] = 0x00;
        memory[ds*16 + 0x8ddf] = r8[al];
        memory[ds*16 + 0x8dc4] = r8[al];
        pc = 0x13205;
        break;
    case 0x131db:
        memory[ds*16 + 0x8ddf] = 0x01;
        memory[ds*16 + 0x8dc4] = 0x00;
        memory[ds*16 + 0x8da7] = 0x01;
        push(cs);
        cs = 0x0a34;
        yield* sub_a672();
        assert(cs == 0x12f9);
        pc = 0x13205;
        break;
    case 0x131f1:
        memory[ds*16 + 0x8dc4] = 0x01;
        memory[ds*16 + 0x8ddf] = 0x00;
        push(cs);
        cs = 0x0ee7;
        yield* sub_10a9e();
        assert(cs == 0x12f9);
        memory[ds*16 + 0x8b6a] = 0x01;
    case 0x13205:
        if (memory[ds*16 + 0x8db5] == 0x4e) {
            pc = 0x13211;
            break;
        }
        push(cs);
        cs = 0x10ba;
        yield* sub_10baa();
        assert(cs == 0x12f9);
    case 0x13211:
        if (memory[ds*16 + 0x8db5] != 0x52) {
            pc = 0x1321d;
            break;
        }
        push(cs);
        cs = 0x1162;
        yield* sub_11673();
        assert(cs == 0x12f9);
    case 0x1321d:
        memory[ds*16 + 0x8a26] = 0x3b;
        memory[ds*16 + 0x8bd3] = 0x3c;
        memory[ds*16 + 0x8b6b] = 0x3d;
        memory[ds*16 + 0x91ad] = 0x3e;
        memory[ds*16 + 0x8d5b] = 0x3f;
        memory[ds*16 + 0x8dd7] = 0x40;
        memory[ds*16 + 0x9192] = 0x41;
        memory[ds*16 + 0x8dbc] = 0x42;
        memory[ds*16 + 0x8bea] = 0x43;
        memory[ds*16 + 0x8e1e] = 0x44;
        memory[ds*16 + 0x8dc5] = 0x39;
        memory[ds*16 + 0x8bf8] = 0x48;
        memory[ds*16 + 0x9090] = 0x4d;
        memory[ds*16 + 0x8ba7] = 0x50;
        memory[ds*16 + 0x8db2] = 0x4b;
        memory[ds*16 + 0x8f66] = 0x00;
        push(cs);
        cs = 0x0a34;
        yield* sub_ad5a();
        assert(cs == 0x12f9);
        memory[ds*16 + 0x8bd9] = 0x00;
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x132af;
            break;
        }
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        if (r16[dx] <= 0x0004) {
            pc = 0x1328b;
            break;
        }
        pc = 0x13343;
        break;
    case 0x1328b:
        if (r16[dx] < 0x0004) {
            pc = 0x13295;
            break;
        }
        if (r16[ax] < 0xd648) {
            pc = 0x13295;
            break;
        }
        pc = 0x13343;
        break;
    case 0x13295:
        push(cs);
        cs = 0x0a34;
        yield* sub_adf2();
        assert(cs == 0x12f9);
        push(memory16get(ds, 0x8de4));
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x132af:
        memory[ds*16 + 0x8dd0] = 0x00;
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x132cc;
            break;
        }
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        if (r16[dx] > 0x0004) {
            pc = 0x13311;
            break;
        }
        if (r16[dx] < 0x0004) {
            pc = 0x132cc;
            break;
        }
        if (r16[ax] >= 0x0358) {
            pc = 0x13311;
            break;
        }
    case 0x132cc:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x13300;
            break;
        }
        r16[ax] = 0x0009;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        if (r16[dx] > 0x0005) {
            pc = 0x13311;
            break;
        }
        if (r16[dx] < 0x0005) {
            pc = 0x132ef;
            break;
        }
        if (r16[ax] >= 0x8358) {
            pc = 0x13311;
            break;
        }
    case 0x132ef:
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        if (r16[dx] > 0x0003) {
            pc = 0x13343;
            break;
        }
        if (r16[dx] < 0x0003) {
            pc = 0x13300;
            break;
        }
        if (r16[ax] >= 0x2e98) {
            pc = 0x13343;
            break;
        }
    case 0x13300:
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        if (r16[dx] < 0x0003) {
            pc = 0x13318;
            break;
        }
        if (r16[dx] != 0x0003) {
            pc = 0x13311;
            break;
        }
        if (r16[ax] < 0x1390) {
            pc = 0x13318;
            break;
        }
    case 0x13311:
        memory[ds*16 + 0x8bd9] = 0x01;
        pc = 0x13343;
        break;
    case 0x13318:
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        if (r16[dx] > 0x0001) {
            pc = 0x13343;
            break;
        }
        if (r16[dx] < 0x0001) {
            pc = 0x13329;
            break;
        }
        if (r16[ax] >= 0x7400) {
            pc = 0x13343;
            break;
        }
    case 0x13329:
        push(cs);
        cs = 0x0a34;
        yield* sub_adf2();
        assert(cs == 0x12f9);
        push(memory16get(ds, 0x8de4));
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x13343:
        memory[ds*16 + 0x8bd9] = 0x00;
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x1335a;
            break;
        }
        r16[ax] = 0x0013;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x1335a:
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x1336c;
            break;
        }
        r16[ax] = 0x000d;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x1336c:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x1337e;
            break;
        }
        r16[ax] = 0x0009;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x1337e:
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1338a;
            break;
        }
        push(cs);
        cs = 0x0ee7;
        yield* sub_10a05();
        assert(cs == 0x12f9);
    case 0x1338a:
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x1339c;
            break;
        }
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
    case 0x1339c:
        if (memory[ds*16 + 0x8dd0] != 0x00) {
            pc = 0x133aa;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x133af;
            break;
        }
    case 0x133aa:
        push(cs);
        cs = 0x023f;
        yield* sub_2473();
        assert(cs == 0x12f9);
    case 0x133af:
        memory16set(ds, 0x908e, 0x0000);
        memory16set(ds, 0x908c, 0x0000);
        r16[bx] = 0;
        es = r16[bx];
        memory16set(ds, 0x8b6e, es);
        memory16set(ds, 0x8b6c, r16[bx]);
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x133fb;
            break;
        }
        r16[dx] = 0x0002;
        r16[ax] = 0x22e0;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_12f92();
        sp += 0x0004;
        r16[ax] = 0x1f40;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8da4, r16[dx]);
        memory16set(ds, 0x8da2, r16[ax]);
        r16[bx] = memory16get(ds, 0x908c);
        es = memory16get(ds, 0x908c + 2);
        memory16set(ds, 0x8b6e, es);
        memory16set(ds, 0x8b6c, r16[bx]);
    case 0x133fb:
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x1342f;
            break;
        }
        r16[dx] = 0x0002;
        r16[ax] = 0x9810;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_12f92();
        sp += 0x0004;
        r16[bx] = memory16get(ds, 0x908c);
        es = memory16get(ds, 0x908c + 2);
        memory16set(ds, 0x8b6e, es);
        memory16set(ds, 0x8b6c, r16[bx]);
        r16[ax] = 0x1b58;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8da4, r16[dx]);
        memory16set(ds, 0x8da2, r16[ax]);
    case 0x1342f:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x13463;
            break;
        }
        r16[dx] = 0x0003;
        r16[ax] = 0xf7a0;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_12f92();
        sp += 0x0004;
        r16[bx] = memory16get(ds, 0x908c);
        es = memory16get(ds, 0x908c + 2);
        memory16set(ds, 0x8b6e, es);
        memory16set(ds, 0x8b6c, r16[bx]);
        r16[ax] = 0x1b58;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8da4, r16[dx]);
        memory16set(ds, 0x8da2, r16[ax]);
    case 0x13463:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x13471;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1349e;
            break;
        }
    case 0x13471:
        r16[dx] = 0x0001;
        r16[ax] = 0xfbd0;
        push(r16[dx]);
        push(r16[ax]);
        push(cs);
        yield* sub_12f92();
        sp += 0x0004;
        r16[bx] = memory16get(ds, 0x908c);
        es = memory16get(ds, 0x908c + 2);
        memory16set(ds, 0x8b6e, es);
        memory16set(ds, 0x8b6c, r16[bx]);
        r16[ax] = 0x1b58;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8da4, r16[dx]);
        memory16set(ds, 0x8da2, r16[ax]);
    case 0x1349e:
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8f6a, r16[dx]);
        memory16set(ds, 0x8f68, r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8bb2, r16[dx]);
        memory16set(ds, 0x8bb0, r16[ax]);
        r16[bx] = memory16get(ds, 0x8f68);
        es = memory16get(ds, 0x8f68 + 2);
        memory16set(ss, bp - 210, es);
        memory16set(ss, bp - 212, r16[bx]);
        r16[bx] += 0x0008;
        memory16set(ss, bp - 206, es);
        memory16set(ss, bp - 208, r16[bx]);
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        memory16set(ss, bp - 202, es);
        memory16set(ss, bp - 204, r16[bx]);
        r16[bx] = r16[ax];
        r16[bx] += 0x0008;
        memory16set(ss, bp - 198, es);
        memory16set(ss, bp - 200, r16[bx]);
        memory[ss*16 + bp - 214] = 0x00;
        pc = 0x1353f;
        break;
    case 0x134f9:
        r8[al] = memory[ss*16 + bp - 214];
        r16[bx] = memory16get(ss, bp - 212);
        es = memory16get(ss, bp - 212 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 212, memory16get(ss, bp - 212) + 1);
        r8[al] = memory[ss*16 + bp - 214];
        r16[bx] = memory16get(ss, bp - 204);
        es = memory16get(ss, bp - 204 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 204, memory16get(ss, bp - 204) + 1);
        r8[al] = memory[ss*16 + bp - 214];
        r8[al] += 0x08;
        r16[bx] = memory16get(ss, bp - 208);
        es = memory16get(ss, bp - 208 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 208, memory16get(ss, bp - 208) + 1);
        r8[al] = memory[ss*16 + bp - 214];
        r8[al] += 0x08;
        r16[bx] = memory16get(ss, bp - 200);
        es = memory16get(ss, bp - 200 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 200, memory16get(ss, bp - 200) + 1);
        memory[ss*16 + bp - 214] += 1;
    case 0x1353f:
        if (memory[ss*16 + bp - 214] < 0x08) {
            pc = 0x134f9;
            break;
        }
        memory[ss*16 + bp - 214] = 0x00;
        pc = 0x135e9;
        break;
    case 0x1354e:
        if (memory[ss*16 + bp - 214] >= 0x08) {
            pc = 0x1355f;
            break;
        }
        r8[al] = memory[ss*16 + bp - 214];
        memory[ss*16 + bp - 213] = r8[al];
        pc = 0x1356a;
        break;
    case 0x1355f:
        r8[al] = memory[ss*16 + bp - 214];
        r8[al] += 0x08;
        memory[ss*16 + bp - 213] = r8[al];
    case 0x1356a:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
        r8[al] = memory[ss*16 + bp - 213];
        r8[dl] = memory[ss*16 + bp - 214];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx] + 5] = r8[al];
        memory16set(ss, bp - 4, 0x8b70);
        r8[al] = memory[ss*16 + bp - 213];
        r8[dl] = memory[ss*16 + bp - 214];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx] + 5] = r8[al];
        memory16set(ss, bp - 4, 0x8e20);
        r8[al] = memory[ss*16 + bp - 213];
        r8[dl] = memory[ss*16 + bp - 214];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx] + 5] = r8[al];
        memory16set(ss, bp - 4, 0x92c8);
        r8[al] = memory[ss*16 + bp - 213];
        r8[dl] = memory[ss*16 + bp - 214];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx] + 5] = r8[al];
        memory16set(ss, bp - 4, 0x8bba);
        r8[al] = memory[ss*16 + bp - 213];
        r8[dl] = memory[ss*16 + bp - 214];
        r8[dh] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx] + 5] = r8[al];
        memory[ss*16 + bp - 214] += 1;
    case 0x135e9:
        if (memory[ss*16 + bp - 214] >= 0x10) {
            pc = 0x135f3;
            break;
        }
        pc = 0x1354e;
        break;
    case 0x135f3:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, 0xa000);
        memory16set(es, r16[bx], 0x0000);
        memory[es*16 + r16[bx] + 4] = 0x00;
        memory[es*16 + r16[bx] + 21] = 0x01;
        memory[es*16 + r16[bx] + 22] = 0x00;
        memory[es*16 + r16[bx] + 23] = 0x01;
        memory16set(ss, bp - 4, 0x8b70);
        r16[bx] = memory16get(ss, bp - 4);
        memory16set(es, r16[bx] + 2, 0xa200);
        memory16set(es, r16[bx], 0x0000);
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 4] = 0x01;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 21] = 0x01;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 22] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 23] = 0x01;
        memory16set(ss, bp - 4, 0x8e20);
        r16[bx] = memory16get(ss, bp - 4);
        memory16set(es, r16[bx] + 2, 0xa400);
        memory16set(es, r16[bx], 0x0000);
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 4] = 0x02;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 21] = 0x01;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 22] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 23] = 0x01;
        memory16set(ss, bp - 4, 0x92c8);
        r16[bx] = memory16get(ss, bp - 4);
        memory16set(es, r16[bx] + 2, 0xa600);
        memory16set(es, r16[bx], 0x0000);
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 4] = 0x03;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 21] = 0x01;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 22] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 23] = 0x01;
        memory16set(ss, bp - 4, 0x8bba);
        r16[bx] = memory16get(ss, bp - 4);
        memory16set(es, r16[bx] + 2, 0xa800);
        memory16set(es, r16[bx], 0x0000);
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 4] = 0x04;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 21] = 0x01;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 22] = 0x00;
        r16[bx] = memory16get(ss, bp - 4);
        memory[es*16 + r16[bx] + 23] = 0x01;
        r8[al] = 0x01;
        memory[ds*16 + 0x9091] = r8[al];
        memory[ds*16 + 0x919e] = r8[al];
        memory16set(ds, 0x88d6, 0x007f);
        r16[ax] = 0;
        memory16set(ds, 0x92b8, r16[ax]);
        memory16set(ds, 0x8bd6, r16[ax]);
        r16[ax] = 0x00c8;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x91b2, r16[dx]);
        memory16set(ds, 0x91b0, r16[ax]);
        r16[ax] = 0x0190;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8f82, r16[dx]);
        memory16set(ds, 0x8f80, r16[ax]);
        r16[ax] = 0x00c8;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8ba4, r16[dx]);
        memory16set(ds, 0x8ba2, r16[ax]);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x1374c;
            break;
        }
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0xc4;
        memory16set(ds, 0x8df0, es);
        memory16set(ds, 0x8dee, r16[bx]);
    case 0x1374c:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1375a;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x13769;
            break;
        }
    case 0x1375a:
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0x4c;
        memory16set(ds, 0x8df0, es);
        memory16set(ds, 0x8dee, r16[bx]);
    case 0x13769:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x1377c;
            break;
        }
        r16[bx] = memory16get(ds, 0x8f80);
        es = memory16get(ds, 0x8f80 + 2);
        memory16set(ds, 0x8df0, es);
        memory16set(ds, 0x8dee, r16[bx]);
    case 0x1377c:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x1378f;
            break;
        }
        r16[bx] = memory16get(ds, 0x8ba2);
        es = memory16get(ds, 0x8ba2 + 2);
        memory16set(ds, 0x8df0, es);
        memory16set(ds, 0x8dee, r16[bx]);
    case 0x1378f:
        r16[ax] = 0x00a0;
        memory16set(ds, 0x8a28, r16[ax]);
        memory16set(ds, 0x8d60, r16[ax]);
        r16[ax] = 0x0064;
        memory16set(ds, 0x91a0, r16[ax]);
        memory16set(ds, 0x8db8, r16[ax]);
        r16[dx] = 0;
        r16[ax] = 0x0078;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ds, 0x8f82));
        push(memory16get(ds, 0x8f80));
        push(ss);
        r16[ax] = bp - 0xc4;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_5ada();
        assert(cs == 0x12f9);
        sp += 0x000c;
        r16[dx] = 0;
        r16[ax] = 0x0078;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ds, 0x8ba4));
        push(memory16get(ds, 0x8ba2));
        push(ss);
        r16[ax] = bp - 0xc4;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_5d4f();
        assert(cs == 0x12f9);
        sp += 0x000c;
        r16[ax] = 0x0088;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8dae, r16[dx]);
        memory16set(ds, 0x8dac, r16[ax]);
        r16[bx] = memory16get(ds, 0x8dac);
        es = memory16get(ds, 0x8dac + 2);
        memory16set(ds, 0x8ddc, es);
        memory16set(ds, 0x8dda, r16[bx]);
        r16[ax] = 0x003c;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8dd4, r16[dx]);
        memory16set(ds, 0x8dd2, r16[ax]);
        r16[bx] = memory16get(ds, 0x8dd2);
        es = memory16get(ds, 0x8dd2 + 2);
        memory16set(ds, 0x8e3c, es);
        memory16set(ds, 0x8e3a, r16[bx]);
        r16[ax] = 0x0102;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8d5e, r16[dx]);
        memory16set(ds, 0x8d5c, r16[ax]);
        r16[bx] = memory16get(ds, 0x8d5c);
        es = memory16get(ds, 0x8d5c + 2);
        memory16set(ds, 0x91aa, es);
        memory16set(ds, 0x91a8, r16[bx]);
        memory16set(ds, 0x8da0, 0x0000);
        pc = 0x138a9;
        break;
    case 0x1383d:
        r16[ax] = memory16get(ds, 0x8da0);
        r16[ax] >>= 1;
        r8[al] &= 0x20;
        r8[dl] = memory[ds*16 + 0x8da0];
        r8[dl] &= 0x80;
        r8[al] |= r8[dl];
        r16[dx] = memory16get(ds, 0x8da0);
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r8[dl] &= 0x08;
        r8[al] |= r8[dl];
        r16[dx] = memory16get(ds, 0x8da0);
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r16[dx] >>= 1;
        r8[dl] &= 0x02;
        r8[al] |= r8[dl];
        r8[dl] = memory[ds*16 + 0x8da0];
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] &= 0x40;
        r8[al] |= r8[dl];
        r8[dl] = memory[ds*16 + 0x8da0];
        r8[dl] <<= 1;
        r8[dl] <<= 1;
        r8[dl] &= 0x10;
        r8[al] |= r8[dl];
        r8[dl] = memory[ds*16 + 0x8da0];
        r8[dl] <<= 1;
        r8[dl] &= 0x04;
        r8[al] |= r8[dl];
        r8[dl] = memory[ds*16 + 0x8da0];
        r8[dl] &= 0x01;
        r8[al] |= r8[dl];
        r16[bx] = memory16get(ds, 0x8d5c);
        es = memory16get(ds, 0x8d5c + 2);
        r16[bx] += memory16get(ds, 0x8da0);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ds, 0x8da0, memory16get(ds, 0x8da0) + 1);
    case 0x138a9:
        if (memory16get(ds, 0x8da0) < 0x0100) {
            pc = 0x1383d;
            break;
        }
        r16[bx] = memory16get(ds, 0x8dcc);
        es = memory16get(ds, 0x8dcc + 2);
        memory16set(ds, 0x8be4, es);
        memory16set(ds, 0x8be2, r16[bx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        memory16set(ds, 0x8bde, es);
        memory16set(ds, 0x8bdc, r16[bx]);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x138d3;
            break;
        }
        pc = 0x13ae2;
        break;
    case 0x138d3:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x138e1;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x138ee;
            break;
        }
    case 0x138e1:
        r16[bx] = memory16get(ds, 0x8bb0);
        es = memory16get(ds, 0x8bb0 + 2);
        memory[es*16 + r16[bx]] = 0x03;
        memory[es*16 + r16[bx] + 1] = 0x00;
    case 0x138ee:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x13900;
            break;
        }
        pc = 0x1390e;
        break;
    case 0x13900:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, 0xb000);
        memory16set(es, r16[bx], 0x0000);
    case 0x1390e:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1391c;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x1392a;
            break;
        }
    case 0x1391c:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, 0xb800);
        memory16set(es, r16[bx], 0x0000);
    case 0x1392a:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x1393f;
            break;
        }
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, 0xa000);
        memory16set(es, r16[bx], 0x0000);
    case 0x1393f:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1394d;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1395a;
            break;
        }
    case 0x1394d:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + 6] = 0x00;
        memory[es*16 + r16[bx] + 5] = 0x00;
    case 0x1395a:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x13975;
            break;
        }
        memory16set(ds, 0x8dec, 0xb800);
        memory16set(ds, 0x8dea, 0x0000);
    case 0x13975:
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x1398e;
            break;
        }
        r16[ax] = 0x4000;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8dec, r16[dx]);
        memory16set(ds, 0x8dea, r16[ax]);
    case 0x1398e:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x139a7;
            break;
        }
        r16[ax] = 0x8000;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8dec, r16[dx]);
        memory16set(ds, 0x8dea, r16[ax]);
    case 0x139a7:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x139c0;
            break;
        }
        r16[ax] = 0xfa00;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8dec, r16[dx]);
        memory16set(ds, 0x8dea, r16[ax]);
    case 0x139c0:
        r16[dx] = memory16get(ds, 0x8dec);
        r16[ax] = memory16get(ds, 0x8dea);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x139e2;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x139e2;
            break;
        }
        pc = 0x139ef;
        break;
    case 0x139e2:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + 6] = 0x00;
        memory[es*16 + r16[bx] + 5] = 0x00;
    case 0x139ef:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8e20);
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x13a05;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x13a17;
            break;
        }
    case 0x13a05:
        r16[ax] = 0x4000;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x92c0, r16[dx]);
        memory16set(ds, 0x92be, r16[ax]);
    case 0x13a17:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x13a30;
            break;
        }
        r16[ax] = 0x8000;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x92c0, r16[dx]);
        memory16set(ds, 0x92be, r16[ax]);
    case 0x13a30:
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x13a49;
            break;
        }
        r16[ax] = 0xfa00;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x92c0, r16[dx]);
        memory16set(ds, 0x92be, r16[ax]);
    case 0x13a49:
        r16[dx] = memory16get(ds, 0x92c0);
        r16[ax] = memory16get(ds, 0x92be);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x13a68;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x13a75;
            break;
        }
    case 0x13a68:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + 6] = 0x00;
        memory[es*16 + r16[bx] + 5] = 0x00;
    case 0x13a75:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x92c8);
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x13a8b;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x13a9d;
            break;
        }
    case 0x13a8b:
        r16[ax] = 0x4000;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8bac, r16[dx]);
        memory16set(ds, 0x8baa, r16[ax]);
    case 0x13a9d:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x13ab6;
            break;
        }
        r16[ax] = 0x8000;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        memory16set(ds, 0x8bac, r16[dx]);
        memory16set(ds, 0x8baa, r16[ax]);
    case 0x13ab6:
        r16[dx] = memory16get(ds, 0x8bac);
        r16[ax] = memory16get(ds, 0x8baa);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x13ad5;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x13ae2;
            break;
        }
    case 0x13ad5:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory[es*16 + r16[bx] + 6] = 0x00;
        memory[es*16 + r16[bx] + 5] = 0x00;
    case 0x13ae2:
        memory16set(ds, 0x8bee, ds);
        memory16set(ds, 0x8bec, 0x8b70);
        memory16set(ds, 0x8db0, 0x0000);
        push(cs);
        cs = 0x1ec1;
        yield* sub_1ec1f();
        assert(cs == 0x12f9);
        memory16set(ds, 0x8b8e, r16[dx]);
        memory16set(ds, 0x8b8c, r16[ax]);
        r16[cx] = 0x0003;
        push(cs);
        cs = 0x01ed;
        yield* sub_20f5();
        assert(cs == 0x12f9);
        memory16set(ds, 0x8b8e, r16[dx]);
        memory16set(ds, 0x8b8c, r16[ax]);
        r16[cx] = 0x0009;
        push(cs);
        cs = 0x01ed;
        yield* sub_20f5();
        assert(cs == 0x12f9);
        memory16set(ds, 0x8b8e, r16[dx]);
        memory16set(ds, 0x8b8c, r16[ax]);
        r16[cx] = 0x0009;
        push(cs);
        cs = 0x01ed;
        yield* sub_20cf();
        assert(cs == 0x12f9);
        memory16set(ds, 0x8b8e, r16[dx]);
        memory16set(ds, 0x8b8c, r16[ax]);
        if (r16[dx]) {
            pc = 0x13b42;
            break;
        }
        if (false) {
            pc = 0x13b36;
            break;
        }
        if (r16[ax] >= 0x0800) {
            pc = 0x13b42;
            break;
        }
    case 0x13b36:
        memory16set(ds, 0x8b8e, 0x0000);
        memory16set(ds, 0x8b8c, 0x0800);
    case 0x13b42:
        if (memory16get(ds, 0x8b8e) < 0x0000) {
            pc = 0x13b5f;
            break;
        }
        if (memory16get(ds, 0x8b8e) > 0x0000) {
            pc = 0x13b53;
            break;
        }
        if (memory16get(ds, 0x8b8c) <= 0x5000) {
            pc = 0x13b5f;
            break;
        }
    case 0x13b53:
        memory16set(ds, 0x8b8e, 0x0000);
        memory16set(ds, 0x8b8c, 0x5000);
    case 0x13b5f:
        memory16set(ds, 0x8b8e, 0x0000);
        memory16set(ds, 0x8b8c, 0x0800);
        memory16set(ds, 0x919a, 0x0000);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1cc0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_779c();
        assert(cs == 0x12f9);
        sp += 0x0006;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1cca;
        push(r16[ax]);
        push(memory16get(ds, 0x8bd6));
        push(cs);
        cs = 0x06c1;
        yield* sub_99b4();
        assert(cs == 0x12f9);
        sp += 0x0008;
        memory16set(ds, 0x8bd6, memory16get(ds, 0x8bd6) + r16[ax]);
        memory16set(ds, 0x8dd8, 0x0000);
        memory[ss*16 + bp - 214] = 0x00;
        pc = 0x13bd2;
        break;
    case 0x13ba6:
        r16[dx] = 0;
        r16[ax] = r16[dx];
        r8[bl] = memory[ss*16 + bp - 214];
        r8[bh] = 0x00;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 36344, r16[dx]);
        memory16set(ds, r16[bx] + 36342, r16[ax]);
        r8[bl] = memory[ss*16 + bp - 214];
        r8[bh] = 0x00;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 36672, r16[dx]);
        memory16set(ds, r16[bx] + 36670, r16[ax]);
        memory[ss*16 + bp - 214] += 1;
    case 0x13bd2:
        if (memory[ss*16 + bp - 214] < 0x0a) {
            pc = 0x13ba6;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e0fe();
        assert(cs == 0x12f9);
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_13be3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(memory16get(ds, 0x91b2));
        push(memory16get(ds, 0x91b0));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8f82));
        push(memory16get(ds, 0x8f80));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8ba4));
        push(memory16get(ds, 0x8ba2));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x91aa));
        push(memory16get(ds, 0x91a8));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x13c70;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x13c40;
            break;
        }
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x13c40;
            break;
        }
        if (memory[ds*16 + 0x8dd0] == 0x00) {
            pc = 0x13c50;
            break;
        }
    case 0x13c40:
        push(memory16get(ds, 0x8dec));
        push(memory16get(ds, 0x8dea));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13c50:
        push(memory16get(ds, 0x92c0));
        push(memory16get(ds, 0x92be));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8bac));
        push(memory16get(ds, 0x8baa));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13c70:
        push(memory16get(ds, 0x8bde));
        push(memory16get(ds, 0x8bdc));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8be4));
        push(memory16get(ds, 0x8be2));
        push(cs);
        cs = 0x1ec3;
        yield* sub_1ec34();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8e3c));
        push(memory16get(ds, 0x8e3a));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8ddc));
        push(memory16get(ds, 0x8dda));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        r16[ax] = memory16get(ds, 0x8b6c);
        r16[ax] |= memory16get(ds, 0x8b6e);
        if (!r16[ax]) {
            pc = 0x13cc9;
            break;
        }
        push(memory16get(ds, 0x8b6e));
        push(memory16get(ds, 0x8b6c));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13cc9:
        push(memory16get(ds, 0x8f6a));
        push(memory16get(ds, 0x8f68));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        push(memory16get(ds, 0x8bb2));
        push(memory16get(ds, 0x8bb0));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
        if (memory[ds*16 + 0x8db5] == 0x4e) {
            pc = 0x13cff;
            break;
        }
        push(cs);
        cs = 0x1162;
        yield* sub_116b1();
        assert(cs == 0x12f9);
        push(cs);
        cs = 0x11cd;
        yield* sub_11cef();
        assert(cs == 0x12f9);
        push(cs);
        cs = 0x10ba;
        yield* sub_10bfb();
        assert(cs == 0x12f9);
    case 0x13cff:
        if (memory[ds*16 + 0x92c6] == 0x00) {
            pc = 0x13d16;
            break;
        }
        push(memory16get(ds, 0x8bf4));
        push(memory16get(ds, 0x8bf2));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13d16:
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x13d27;
            break;
        }
        push(cs);
        cs = 0x127c;
        yield* sub_12886();
        assert(cs == 0x12f9);
        push(cs);
        cs = 0x127c;
        yield* sub_128f6();
        assert(cs == 0x12f9);
    case 0x13d27:
        if (memory[ds*16 + 0x8db5] != 0x52) {
            pc = 0x13d54;
            break;
        }
        push(cs);
        cs = 0x1162;
        yield* sub_11673();
        assert(cs == 0x12f9);
        if (memory16get(ds, 0x92c4) == 0x0000) {
            pc = 0x13d54;
            break;
        }
        if (memory16get(ds, 0x8a2a) != 0x0000) {
            pc = 0x13d54;
            break;
        }
    case 0x13d41:
        r16[dx] = memory16get(ds, 0x8f7c);
        r16[dx]++;
        r8[al] = in8(r16[dx]);
        if (r8[al] & 0x40) {
            pc = 0x13d41;
            break;
        }
        r16[dx] = memory16get(ds, 0x8f7c);
        r16[dx]++;
        r8[al] = 0xff;
        out8(r16[dx], r8[al]);
    case 0x13d54:
        r16[si] = 0;
        pc = 0x13d7f;
        break;
    case 0x13d58:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 36670);
        r16[ax] |= memory16get(ds, r16[bx] + 36672);
        if (!r16[ax]) {
            pc = 0x13d7e;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 36672));
        push(memory16get(ds, r16[bx] + 36670));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13d7e:
        r16[si]++;
    case 0x13d7f:
        if (signed16(r16[si]) < signed16(0x000a)) {
            pc = 0x13d58;
            break;
        }
        r16[si] = 0;
        pc = 0x13daf;
        break;
    case 0x13d88:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 36342);
        r16[ax] |= memory16get(ds, r16[bx] + 36344);
        if (!r16[ax]) {
            pc = 0x13dae;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 36344));
        push(memory16get(ds, r16[bx] + 36342));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13dae:
        r16[si]++;
    case 0x13daf:
        if (signed16(r16[si]) < signed16(0x000a)) {
            pc = 0x13d88;
            break;
        }
        r16[si] = 0;
        pc = 0x13ddf;
        break;
    case 0x13db8:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 35374);
        r16[ax] |= memory16get(ds, r16[bx] + 35376);
        if (!r16[ax]) {
            pc = 0x13dde;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 35376));
        push(memory16get(ds, r16[bx] + 35374));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x12f9);
        sp += 0x0004;
    case 0x13dde:
        r16[si]++;
    case 0x13ddf:
        if (signed16(r16[si]) < signed16(0x000e)) {
            pc = 0x13db8;
            break;
        }
        push(cs);
        cs = 0x0a34;
        yield* sub_adf2();
        assert(cs == 0x12f9);
        push(memory16get(ds, 0x8de4));
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1ea9;
        yield* sub_1ea99();
        assert(cs == 0x12f9);
        sp++;
        sp++;
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_13e00() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x97e0, 0x0011);
    memory16set(ds, 0x9872, 0x0000);
    r16[ax] = 0;
    memory16set(ds, 0x9c6e, r16[ax]);
    memory16set(ds, 0x9c68, prehistorikScreen);
    memory16set(ds, 0x9c6a, r16[ax]);
    memory16set(ds, 0x9874, 0x0028);
    memory16set(ds, 0x988e, 0x0064);
    memory16set(ds, 0x97f2, 0x0042);
    memory16set(ds, 0x9800, r16[ax]);
    memory16set(ds, 0x97e2, r16[ax]);
    memory16set(ds, 0x9892, r16[ax]);
    memory16set(ds, 0x97ea, r16[ax]);
    memory16set(ds, 0x9c62, r16[ax]);
    memory16set(ds, 0x9868, r16[ax]);
    memory16set(ds, 0x97f4, 0x0014);
    memory16set(ds, 0x989c, r16[ax]);
    memory16set(ds, 0x97e8, r16[ax]);
    memory16set(ds, 0x97f8, r16[ax]);
    memory16set(ds, 0x9862, r16[ax]);
    memory16set(ds, 0x97fa, r16[ax]);
    memory16set(ds, 0x9870, r16[ax]);
    memory16set(ds, 0x97f0, r16[ax]);
    memory16set(ds, 0x97ee, 0x0001);
    memory16set(ds, 0x9c66, 0x0063);
    memory16set(ds, 0x985a, r16[ax]);
    memory16set(ds, 0x9880, r16[ax]);
    memory16set(ds, 0x989a, 0x000a);
    cs = pop();
}
function* sub_13e6f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 5] = 0x00;
        memory16set(ds, 0x9c6c, 0x0001);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        r16[ax] = 0x1f40;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        memory16set(ds, 0x987c, r16[dx]);
        memory16set(ds, 0x987a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d00;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x13e0);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d0a;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x13e0);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9896, r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x13e0);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d14;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x13e0);
        sp += 0x0008;
        r16[di] = r16[ax];
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[di];
        memory16set(ds, 0x9882, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d1f;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x13e0);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x9882);
        memory16set(ds, 0x9878, r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        r16[ax] = 0x0031;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        r16[ax] = memory16get(ds, 0x9878);
        r16[ax] += 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x1d29;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e49();
        assert(cs == 0x13e0);
        sp += 0x0004;
        push(cs);
        yield* sub_13e00();
        push(ds);
        r16[ax] = 0x33c2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x13e0);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x13e0);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x29e2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x13e0);
        sp += 0x0004;
        r16[ax] = 0x0002;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x13e0);
        sp += 0x0004;
    case 0x13f97:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x13fa1;
            break;
        }
        pc = 0x14605;
        break;
    case 0x13fa1:
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x13fab;
            break;
        }
        pc = 0x14605;
        break;
    case 0x13fab:
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x13ff4;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x000b) {
            pc = 0x13fdc;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x209e;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2076;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19f50();
        assert(cs == 0x13e0);
        sp += 0x000a;
        pc = 0x14002;
        break;
    case 0x13fdc:
        r16[ax] = 0x000a;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x209e;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2076;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19f50();
        assert(cs == 0x13e0);
        sp += 0x000a;
        pc = 0x14002;
        break;
    case 0x13ff4:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a03f();
        assert(cs == 0x13e0);
        sp++;
        sp++;
    case 0x14002:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x1401c;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x33c2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x13e0);
        sp += 0x0006;
        pc = 0x14030;
        break;
    case 0x1401c:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x13e0);
        sp += 0x0006;
    case 0x14030:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x1404a;
            break;
        }
        r16[bx] = memory16get(ds, 0x9c68);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7384));
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        pc = 0x14055;
        break;
    case 0x1404a:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x13e0);
        sp++;
        sp++;
    case 0x14055:
        push(cs);
        cs = 0x19e4;
        yield* sub_1a4da();
        assert(cs == 0x13e0);
        memory[ss*16 + bp - 7] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x13e0);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x13e0);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x13e0);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x13e0);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b341();
        assert(cs == 0x13e0);
        r16[si] = 0;
        pc = 0x14090;
        break;
    case 0x14081:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, 0x0000);
        r16[si]++;
    case 0x14090:
        if (r16[si] < 0x000a) {
            pc = 0x14081;
            break;
        }
        memory16set(ds, 0x97e4, 0x0000);
        memory16set(ds, 0x9894, 0x0000);
        memory16set(ds, 0x97e6, 0x0000);
        memory16set(ds, 0x987e, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x13e0);
    case 0x140b2:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x140bc;
            break;
        }
        pc = 0x145ce;
        break;
    case 0x140bc:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x140c6;
            break;
        }
        pc = 0x145ce;
        break;
    case 0x140c6:
        r16[ax] = memory16get(ds, 0x985a);
        memory16set(ds, 0x985a, memory16get(ds, 0x985a) + 1);
        if (r16[ax] <= 0x003c) {
            pc = 0x14103;
            break;
        }
        if (memory16get(ds, 0x9c66) == 0x0000) {
            pc = 0x140df;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) - 1);
        pc = 0x140f8;
        break;
    case 0x140df:
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x140f8;
            break;
        }
        memory16set(ds, 0x9874, 0x0000);
        memory16set(ds, 0x9870, 0x0001);
        memory16set(ds, 0x97fa, 0x0001);
    case 0x140f8:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x13e0);
        memory16set(ds, 0x985a, 0x0000);
    case 0x14103:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b0b7();
        assert(cs == 0x13e0);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a5d8();
        assert(cs == 0x13e0);
        memory16set(ds, 0x97e6, 0x0000);
        push(cs);
        cs = 0x1bf1;
        yield* sub_1bf13();
        assert(cs == 0x13e0);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a6df();
        assert(cs == 0x13e0);
        if (memory16get(ds, 0x9c68) == 0x0064) {
            pc = 0x1412b;
            break;
        }
        if (memory16get(ds, 0x9c68) != 0x0065) {
            pc = 0x14190;
            break;
        }
    case 0x1412b:
        if (memory16gets(ds, 0x988e) >= signed16(0x0014)) {
            pc = 0x14176;
            break;
        }
        if (memory16get(ds, 0x97f2) != 0x008b) {
            pc = 0x14176;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0014);
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        memory16set(ds, 0x97f4, r16[ax]);
        if (r16[ax] <= 0x007f) {
            pc = 0x14154;
            break;
        }
        memory16set(ds, 0x97f4, 0x007f);
    case 0x14154:
        memory16set(ds, 0x9868, 0x0001);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0093;
        push(r16[ax]);
        r16[ax] = 0x0094;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x13e0);
        sp += 0x000a;
        pc = 0x14190;
        break;
    case 0x14176:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0093;
        push(r16[ax]);
        r16[ax] = 0x00a4;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x13e0);
        sp += 0x000a;
    case 0x14190:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x141a8;
            break;
        }
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x141a8;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0003);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0003);
    case 0x141a8:
        if (memory16get(ds, 0x9c68) != 0x000c) {
            pc = 0x141e2;
            break;
        }
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x141e2;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x003c)) {
            pc = 0x141ca;
            break;
        }
        memory16set(ds, 0x97f2, 0x0050);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0005);
        pc = 0x141e2;
        break;
    case 0x141ca:
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9c64, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x97fc, r16[ax]);
        memory16set(ds, 0x97e8, 0x0000);
        memory16set(ds, 0x9874, 0x0027);
    case 0x141e2:
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x13e0);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x13e0);
        if (memory16get(ds, 0x9c68) == 0x000a) {
            pc = 0x1422f;
            break;
        }
        if (memory16get(ds, 0x9c68) != 0x000b) {
            pc = 0x14234;
            break;
        }
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x14234;
            break;
        }
    case 0x1422f:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b934();
        assert(cs == 0x13e0);
    case 0x14234:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x1423f;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b991();
        assert(cs == 0x13e0);
    case 0x1423f:
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x142a6;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1bdb2();
        assert(cs == 0x13e0);
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x14264;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x14264;
            break;
        }
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x14264;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b107();
        assert(cs == 0x13e0);
    case 0x14264:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x142a6;
            break;
        }
        if (memory16get(ds, 0x9880) >= 0x002d) {
            pc = 0x142a6;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0053;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x006e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x13e0);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005c;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x00ad;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x13e0);
        sp += 0x000a;
    case 0x142a6:
        if (memory[ss*16 + bp - 7] != 0x00) {
            pc = 0x142b6;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x142be;
        break;
    case 0x142b6:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x142be:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x142cc;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x142d0;
            break;
        }
    case 0x142cc:
        memory[ss*16 + bp - 7] = memory[ss*16 + bp - 7] ^ 0x01;
    case 0x142d0:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x13e0);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x13e0);
        sp += 0x0004;
        if (memory[ss*16 + bp - 6] != 0x00) {
            pc = 0x1430c;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x13e0);
        sp += 0x000a;
        memory[ss*16 + bp - 6] = 0x01;
    case 0x1430c:
        if (memory[ss*16 + bp - 5] == 0x00) {
            pc = 0x14334;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x14320;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x14334;
            break;
        }
    case 0x14320:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x1432d;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e3e9();
        assert(cs == 0x13e0);
        pc = 0x14342;
        break;
    case 0x1432d:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e59e();
        assert(cs == 0x13e0);
        pc = 0x14342;
        break;
    case 0x14334:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x13e0);
        sp += 0x0004;
    case 0x14342:
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x13e0);
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x14360;
            break;
        }
        pc = 0x140b2;
        break;
    case 0x14360:
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x1436a;
            break;
        }
        pc = 0x140b2;
        break;
    case 0x1436a:
        if (memory16gets(ds, 0x988e) >= signed16(0x0000)) {
            pc = 0x14377;
            break;
        }
        memory16set(ds, 0x988e, 0x0000);
    case 0x14377:
        if (memory16gets(ds, 0x988e) <= signed16(0x012c)) {
            pc = 0x14385;
            break;
        }
        memory16set(ds, 0x988e, 0x012c);
    case 0x14385:
        if (memory16gets(ds, 0x97f2) <= signed16(0x00b4)) {
            pc = 0x1439d;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1439d;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9870, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
    case 0x1439d:
        if (memory16get(ds, 0x9c68) != 0x0005) {
            pc = 0x143db;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0069)) {
            pc = 0x143db;
            break;
        }
        if (memory16gets(ds, 0x97f2) <= signed16(0x009b)) {
            pc = 0x143db;
            break;
        }
        memory16set(ds, 0x97f2, 0x000a);
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x9c68, 0x0064);
        memory16set(ds, 0x9870, 0x0000);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x143d7;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_1946f();
        assert(cs == 0x13e0);
    case 0x143d7:
        memory[ss*16 + bp - 6] = 0x00;
    case 0x143db:
        if (memory16get(ds, 0x9c68) != 0x000e) {
            pc = 0x14419;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0069)) {
            pc = 0x14419;
            break;
        }
        if (memory16gets(ds, 0x97f2) <= signed16(0x009b)) {
            pc = 0x14419;
            break;
        }
        memory16set(ds, 0x97f2, 0x000a);
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x9c68, 0x0065);
        memory16set(ds, 0x9870, 0x0000);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x14415;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_1946f();
        assert(cs == 0x13e0);
    case 0x14415:
        memory[ss*16 + bp - 6] = 0x00;
    case 0x14419:
        if (memory16get(ds, 0x9c68) < 0x0064) {
            pc = 0x14423;
            break;
        }
        pc = 0x144fc;
        break;
    case 0x14423:
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x14457;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x14457;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0000) {
            pc = 0x14457;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) - 1);
        memory16set(ds, 0x988e, 0x011d);
        memory16set(ds, 0x9872, 0x0001);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_5e86();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        memory[ss*16 + bp - 5] = 0x02;
    case 0x14457:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x14478;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0104)) {
            pc = 0x14478;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x14478;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0002);
        memory16set(ds, 0x97e8, 0x0001);
    case 0x14478:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x144a2;
            break;
        }
        if (memory16gets(ds, 0x988e) < signed16(0x012c)) {
            pc = 0x144a2;
            break;
        }
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x144a2;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x988e, 0x0006);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x01;
    case 0x144a2:
        if (memory16gets(ds, 0x988e) <= signed16(0x0127)) {
            pc = 0x144d6;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0009) {
            pc = 0x144d6;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0012) {
            pc = 0x144d6;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x988e, 0x0006);
        memory16set(ds, 0x9872, 0x0001);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_5e86();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        memory[ss*16 + bp - 5] = 0x01;
    case 0x144d6:
        if (memory16gets(ds, 0x988e) <= signed16(0x0104)) {
            pc = 0x144fc;
            break;
        }
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x144fc;
            break;
        }
        if (memory16get(ds, 0x9880) <= 0x002c) {
            pc = 0x144fc;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x988e, 0x0006);
        memory16set(ds, 0x9872, 0x0001);
    case 0x144fc:
        if (memory16get(ds, 0x9c68) != 0x0064) {
            pc = 0x14561;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x14561;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x001e)) {
            pc = 0x14561;
            break;
        }
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x14561;
            break;
        }
        memory16set(ds, 0x9c68, 0x0005);
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x97f2, 0x0046);
        memory16set(ds, 0x988e, 0x0064);
        r16[ax] = 0;
        memory16set(ds, 0x9800, r16[ax]);
        memory16set(ds, 0x9868, r16[ax]);
        if (memory16get(ds, 0x97f4) >= 0x007f) {
            pc = 0x1454b;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ds, 0x97f4, r16[ax]);
        pc = 0x14551;
        break;
    case 0x1454b:
        memory16set(ds, 0x97f4, 0x0022);
    case 0x14551:
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1455d;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_194a1();
        assert(cs == 0x13e0);
    case 0x1455d:
        memory[ss*16 + bp - 6] = 0x00;
    case 0x14561:
        if (memory16get(ds, 0x9c68) != 0x0065) {
            pc = 0x145b7;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x145b7;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x001e)) {
            pc = 0x145b7;
            break;
        }
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x145b7;
            break;
        }
        memory16set(ds, 0x9c68, 0x000e);
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x97f2, 0x0064);
        memory16set(ds, 0x988e, 0x0050);
        r16[ax] = 0;
        memory16set(ds, 0x9800, r16[ax]);
        memory16set(ds, 0x9868, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] >>= 1;
        r16[ax] >>= 1;
        memory16set(ds, 0x97f4, r16[ax]);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x145b3;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_194a1();
        assert(cs == 0x13e0);
    case 0x145b3:
        memory[ss*16 + bp - 6] = 0x00;
    case 0x145b7:
        r16[ax] = memory16get(ds, 0x987e);
        r16[ax] &= 0x0003;
        if (r16[ax] == 0x0003) {
            pc = 0x145c5;
            break;
        }
        pc = 0x140b2;
        break;
    case 0x145c5:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x140b2;
        break;
    case 0x145ce:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        if (memory16get(ds, 0x987e) & 0x0003) {
            pc = 0x145e6;
            break;
        }
        pc = 0x13f97;
        break;
    case 0x145e6:
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        push(memory16get(ds, 0x987e));
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1946;
        yield* sub_19aa5();
        assert(cs == 0x13e0);
        sp += 0x0004;
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x13f97;
        break;
    case 0x14605:
        push(memory16get(ds, 0x987c));
        push(memory16get(ds, 0x987a));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x13e0);
        sp += 0x0004;
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x13e0);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x14637;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x13e0);
        sp += 0x0004;
    case 0x14637:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1463d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[di] = 0;
        pc = 0x14652;
        break;
    case 0x14649:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[di]] = 0x00;
        r16[di]++;
    case 0x14652:
        if (r16[di] < 0x1f40) {
            pc = 0x14649;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x1463);
        sp += 0x0006;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        r16[ax] = 0x00a7;
        push(r16[ax]);
        r16[ax] = 0x0062;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0x0062;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        r16[ax] = 0x0059;
        push(r16[ax]);
        r16[ax] = 0x0062;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        r16[ax] = 0x0032;
        push(r16[ax]);
        r16[ax] = 0x0062;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9882);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x0017;
        push(r16[ax]);
        r16[ax] = 0x0062;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        if (memory16get(ss, bp + 18) == 0x000a) {
            pc = 0x1475d;
            break;
        }
        if (memory16get(ss, bp + 18) == 0x000b) {
            pc = 0x1475d;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1463);
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
    case 0x1475d:
        if (memory16get(ss, bp + 18) <= 0x000b) {
            pc = 0x14788;
            break;
        }
        if (memory16get(ss, bp + 18) == 0x0012) {
            pc = 0x14788;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1463);
        sp += 0x000e;
    case 0x14788:
        memory16set(ss, bp - 4, 0x0000);
        if (memory16get(ss, bp + 18) == 0x0000) {
            pc = 0x147af;
            break;
        }
        r16[di] = 0;
        pc = 0x147aa;
        break;
    case 0x14797:
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + r16[ax]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        r16[di]++;
    case 0x147aa:
        if (r16[di] < memory16get(ss, bp + 18)) {
            pc = 0x14797;
            break;
        }
    case 0x147af:
        r16[ax] = memory16get(ss, bp - 4);
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[di] = 0;
        pc = 0x14857;
        break;
    case 0x147bf:
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 2, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 2, sar16(memory16get(ss, bp - 2), r8[cl]));
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) << r8[cl]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[si] = memory16get(es, r16[bx]);
        if (r16[si] != 0x001e) {
            pc = 0x147f0;
            break;
        }
        r16[si] = 0x001f;
    case 0x147f0:
        if (r16[si] != 0x001d) {
            pc = 0x147f8;
            break;
        }
        r16[si] = 0x001e;
    case 0x147f8:
        if (r16[si] != 0x0014) {
            pc = 0x14800;
            break;
        }
        r16[si] = 0x0020;
    case 0x14800:
        if (r16[si] != 0x0005) {
            pc = 0x14808;
            break;
        }
        r16[si] = 0x001d;
    case 0x14808:
        if (r16[si] == 0x001e) {
            pc = 0x14852;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[si];
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        push(memory16get(ss, bp - 2));
        r16[ax] = r16[si];
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19eac();
        assert(cs == 0x1463);
        sp += 0x0006;
    case 0x14852:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0003);
        r16[di]++;
    case 0x14857:
        r16[ax] = memory16get(ss, bp + 18);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        if (r16[ax] < r16[di]) {
            pc = 0x1486b;
            break;
        }
        pc = 0x147bf;
        break;
    case 0x1486b:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0020;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        if (memory16get(ss, bp + 18) != 0x000b) {
            pc = 0x148ac;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0034;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0x005a;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1463);
        sp += 0x000e;
    case 0x148ac:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_148b2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000a;
        memory16set(ss, bp - 2, 0x0000);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x008c;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1463);
        sp += 0x000e;
        memory16set(ss, bp - 8, 0x0000);
        pc = 0x149fa;
        break;
    case 0x148e6:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1463);
        sp += 0x000a;
        r16[di] = 0;
        if (memory16get(ss, bp + 18) == r16[di]) {
            pc = 0x14922;
            break;
        }
        memory16set(ss, bp - 10, r16[di]);
        pc = 0x1491a;
        break;
    case 0x14907:
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[di] += r16[ax];
        r16[di]++;
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
    case 0x1491a:
        r16[ax] = memory16get(ss, bp - 10);
        if (r16[ax] < memory16get(ss, bp + 18)) {
            pc = 0x14907;
            break;
        }
    case 0x14922:
        r16[ax] = r16[di];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        memory16set(ss, bp - 6, 0x0000);
        pc = 0x149ab;
        break;
    case 0x14933:
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 4, sar16(memory16get(ss, bp - 4), r8[cl]));
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) << r8[cl]);
        r16[ax] = r16[di];
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[si] = memory16get(es, r16[bx]);
        if (r16[si] != 0x001e) {
            pc = 0x14962;
            break;
        }
        r16[si] = 0x001f;
    case 0x14962:
        if (r16[si] != 0x001d) {
            pc = 0x1496a;
            break;
        }
        r16[si] = 0x001e;
    case 0x1496a:
        if (r16[si] != 0x0014) {
            pc = 0x14972;
            break;
        }
        r16[si] = 0x0020;
    case 0x14972:
        if (r16[si] != 0x0005) {
            pc = 0x1497a;
            break;
        }
        r16[si] = 0x001d;
    case 0x1497a:
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[si];
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        r16[di] += 0x0003;
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
    case 0x149ab:
        if (memory16get(ss, bp - 6) > 0x000f) {
            pc = 0x149b4;
            break;
        }
        pc = 0x14933;
        break;
    case 0x149b4:
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ds, 0x988e));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1463);
        sp += 0x000a;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x1463);
        sp++;
        sp++;
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 0x0004);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 1);
    case 0x149fa:
        if (memory16get(ss, bp - 8) >= 0x002c) {
            pc = 0x14a03;
            break;
        }
        pc = 0x148e6;
        break;
    case 0x14a03:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_14a09() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000a;
        memory16set(ss, bp - 2, 0xffb0);
        push(memory16get(ss, bp + 18));
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_1463d();
        sp += 0x000a;
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b341();
        assert(cs == 0x1463);
        memory16set(ss, bp + 18, 0x0011);
        memory16set(ss, bp - 8, 0x0000);
        pc = 0x14c98;
        break;
    case 0x14a52:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1463);
        sp += 0x000a;
        r16[di] = 0;
        if (memory16get(ss, bp + 18) == r16[di]) {
            pc = 0x14a8e;
            break;
        }
        memory16set(ss, bp - 10, r16[di]);
        pc = 0x14a86;
        break;
    case 0x14a73:
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[di] += r16[ax];
        r16[di]++;
        memory16set(ss, bp - 10, memory16get(ss, bp - 10) + 1);
    case 0x14a86:
        r16[ax] = memory16get(ss, bp - 10);
        if (r16[ax] < memory16get(ss, bp + 18)) {
            pc = 0x14a73;
            break;
        }
    case 0x14a8e:
        r16[ax] = r16[di];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        memory16set(ss, bp - 6, 0x0000);
        pc = 0x14b3d;
        break;
    case 0x14a9f:
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 4, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 4, sar16(memory16get(ss, bp - 4), r8[cl]));
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) << r8[cl]);
        r16[ax] = r16[di];
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[si] = memory16get(es, r16[bx]);
        if (r16[si] != 0x001e) {
            pc = 0x14ace;
            break;
        }
        r16[si] = 0x001f;
    case 0x14ace:
        if (r16[si] != 0x001d) {
            pc = 0x14ad6;
            break;
        }
        r16[si] = 0x001e;
    case 0x14ad6:
        if (r16[si] != 0x0014) {
            pc = 0x14ade;
            break;
        }
        r16[si] = 0x0020;
    case 0x14ade:
        if (r16[si] != 0x0005) {
            pc = 0x14ae6;
            break;
        }
        r16[si] = 0x001d;
    case 0x14ae6:
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[si];
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        if (memory16get(ss, bp - 8) != 0x0014) {
            pc = 0x14b37;
            break;
        }
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[ax] = r16[si];
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19eac();
        assert(cs == 0x1463);
        sp += 0x0006;
    case 0x14b37:
        r16[di] += 0x0003;
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
    case 0x14b3d:
        if (memory16get(ss, bp - 6) > 0x000f) {
            pc = 0x14b46;
            break;
        }
        pc = 0x14a9f;
        break;
    case 0x14b46:
        if (memory16get(ss, bp - 8) != 0x0014) {
            pc = 0x14b4f;
            break;
        }
        pc = 0x14bf8;
        break;
    case 0x14b4f:
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ds, 0x988e));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] &= 0x0001;
        r16[ax] += memory16get(ds, 0x988a);
        r16[ax] += 0x0055;
        push(r16[ax]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1463);
        r16[bx] = 0x000a;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x00af;
        push(r16[dx]);
        r16[ax] = 0x0031;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] &= 0x0001;
        r16[ax] += memory16get(ds, 0x988a);
        r16[ax] += 0x0056;
        push(r16[ax]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1463);
        r16[bx] = 0x000a;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x00aa;
        push(r16[dx]);
        r16[ax] = 0x0041;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 8);
        r16[ax] &= 0x0001;
        r16[ax] += memory16get(ds, 0x988a);
        r16[ax] += 0x0055;
        push(r16[ax]);
        r16[ax] = 0x00b2;
        push(r16[ax]);
        r16[ax] = 0x004f;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
    case 0x14bf8:
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        r16[ax] = 0x00b9;
        push(r16[ax]);
        r16[ax] = 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x00b9;
        push(r16[ax]);
        r16[ax] = 0x0020;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x00b9;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x00b9;
        push(r16[ax]);
        r16[ax] = 0x0080;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1463);
        sp += 0x000c;
        if (memory16get(ss, bp - 8) == 0x0014) {
            pc = 0x14c86;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1463);
        sp += 0x000a;
    case 0x14c86:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x1463);
        sp++;
        sp++;
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 0x0004);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 1);
    case 0x14c98:
        if (memory16get(ss, bp - 8) >= 0x0015) {
            pc = 0x14ca1;
            break;
        }
        pc = 0x14a52;
        break;
    case 0x14ca1:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1463);
        sp += 0x000a;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_14cbc() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x97e0, 0x0011);
    memory16set(ds, 0x9872, 0x0000);
    r16[ax] = 0;
    memory16set(ds, 0x9c6e, r16[ax]);
    memory16set(ds, 0x9c68, prehistorikScreen);
    memory16set(ds, 0x9c6a, r16[ax]);
    memory16set(ds, 0x9874, 0x0028);
    memory16set(ds, 0x988e, 0x0073);
    memory16set(ds, 0x97f2, 0x006e);
    memory16set(ds, 0x9800, r16[ax]);
    memory16set(ds, 0x97e2, r16[ax]);
    memory16set(ds, 0x9892, r16[ax]);
    memory16set(ds, 0x97ea, r16[ax]);
    memory16set(ds, 0x9c62, r16[ax]);
    memory16set(ds, 0x9868, r16[ax]);
    memory16set(ds, 0x97f4, 0x0014);
    memory16set(ds, 0x989c, r16[ax]);
    memory16set(ds, 0x97e8, r16[ax]);
    memory16set(ds, 0x97f8, r16[ax]);
    memory16set(ds, 0x9862, r16[ax]);
    memory16set(ds, 0x97fa, r16[ax]);
    memory16set(ds, 0x9870, r16[ax]);
    memory16set(ds, 0x9c66, 0x0063);
    memory16set(ds, 0x985a, r16[ax]);
    memory16set(ds, 0x9880, r16[ax]);
    memory16set(ds, 0x989a, 0x000a);
    cs = pop();
}
function* sub_14d22() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x1463);
        sp++;
        sp++;
        r16[ax] = 0x1f40;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x1463);
        sp++;
        sp++;
        memory16set(ds, 0x987c, r16[dx]);
        memory16set(ds, 0x987a, r16[ax]);
        memory16set(ds, 0x9c6c, 0x0003);
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d5e;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x1463);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9896, r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x1463);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d68;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x1463);
        sp += 0x0008;
        r16[di] = r16[ax];
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d73;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x1463);
        sp += 0x0008;
        r16[dx] = memory16get(ds, 0x9896);
        r16[dx] += r16[di];
        r16[ax] += r16[dx];
        memory16set(ds, 0x9882, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1d7f;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x1463);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x9882);
        memory16set(ds, 0x9878, r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x1463);
        sp++;
        sp++;
        r16[ax] = 0x0031;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x1463);
        sp++;
        sp++;
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x1463);
        sp++;
        sp++;
        r16[ax] = 0x0033;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x1463);
        sp++;
        sp++;
        r16[ax] = memory16get(ds, 0x9878);
        r16[ax] += 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x1463);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x1d89;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e49();
        assert(cs == 0x1463);
        sp += 0x0004;
        push(cs);
        yield* sub_14cbc();
        push(ds);
        r16[ax] = 0x47ee;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x1463);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x1463);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x29e2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x1463);
        sp += 0x0004;
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x14e4b;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_1959f();
        assert(cs == 0x1463);
    case 0x14e4b:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x14e59;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x14e66;
            break;
        }
    case 0x14e59:
        push(ds);
        r16[ax] = 0x1d94;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_6d22();
        assert(cs == 0x1463);
        sp += 0x0004;
    case 0x14e66:
        r16[ax] = 0x0003;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x1463);
        sp += 0x0004;
    case 0x14e75:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x14e7f;
            break;
        }
        pc = 0x154ae;
        break;
    case 0x14e7f:
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x14e89;
            break;
        }
        pc = 0x154ae;
        break;
    case 0x14e89:
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x1463);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x14eb0;
            break;
        }
        r16[ax] = 0x0012;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x39d2;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x39aa;
        push(r16[ax]);
        push(cs);
        yield* sub_14a09();
        sp += 0x000a;
    case 0x14eb0:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x14ed5;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0012) {
            pc = 0x14ee3;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x39d2;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x39aa;
        push(r16[ax]);
        push(cs);
        yield* sub_1463d();
        sp += 0x000a;
        pc = 0x14ee3;
        break;
    case 0x14ed5:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a03f();
        assert(cs == 0x1463);
        sp++;
        sp++;
    case 0x14ee3:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x14efd;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x47ee;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x1463);
        sp += 0x0006;
        pc = 0x14f11;
        break;
    case 0x14efd:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x1463);
        sp += 0x0006;
    case 0x14f11:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x14f2b;
            break;
        }
        r16[bx] = memory16get(ds, 0x9c68);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7478));
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x1463);
        sp++;
        sp++;
        pc = 0x14f36;
        break;
    case 0x14f2b:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x1463);
        sp++;
        sp++;
    case 0x14f36:
        push(cs);
        cs = 0x19e4;
        yield* sub_1a4da();
        assert(cs == 0x1463);
        memory[ss*16 + bp - 7] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b341();
        assert(cs == 0x1463);
        r16[si] = 0;
        pc = 0x14f71;
        break;
    case 0x14f62:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, 0x0000);
        r16[si]++;
    case 0x14f71:
        if (r16[si] < 0x000a) {
            pc = 0x14f62;
            break;
        }
        memory16set(ds, 0x97e4, 0x0000);
        memory16set(ds, 0x9894, 0x0000);
        memory16set(ds, 0x97e6, 0x0000);
        memory16set(ds, 0x987e, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x1463);
    case 0x14f93:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x14f9d;
            break;
        }
        pc = 0x15449;
        break;
    case 0x14f9d:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x14fa7;
            break;
        }
        pc = 0x15449;
        break;
    case 0x14fa7:
        r16[ax] = memory16get(ds, 0x985a);
        memory16set(ds, 0x985a, memory16get(ds, 0x985a) + 1);
        if (r16[ax] <= 0x003c) {
            pc = 0x14fe4;
            break;
        }
        if (memory16get(ds, 0x9c66) == 0x0000) {
            pc = 0x14fc0;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) - 1);
        pc = 0x14fd9;
        break;
    case 0x14fc0:
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x14fd9;
            break;
        }
        memory16set(ds, 0x9874, 0x0000);
        memory16set(ds, 0x9870, 0x0001);
        memory16set(ds, 0x97fa, 0x0001);
    case 0x14fd9:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x1463);
        memory16set(ds, 0x985a, 0x0000);
    case 0x14fe4:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b0b7();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a5d8();
        assert(cs == 0x1463);
        memory16set(ds, 0x97e6, 0x0000);
        push(cs);
        cs = 0x1bf1;
        yield* sub_1bf13();
        assert(cs == 0x1463);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a6df();
        assert(cs == 0x1463);
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x1463);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x1463);
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x15041;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b991();
        assert(cs == 0x1463);
    case 0x15041:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x1504b;
            break;
        }
        pc = 0x150de;
        break;
    case 0x1504b:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x15056;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1bdb2();
        assert(cs == 0x1463);
    case 0x15056:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1506f;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1506f;
            break;
        }
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x1506f;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b107();
        assert(cs == 0x1463);
    case 0x1506f:
        if (memory16get(ds, 0x9c68) != 0x0011) {
            pc = 0x150b1;
            break;
        }
        if (memory16get(ds, 0x9880) >= 0x002d) {
            pc = 0x150b1;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0053;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x006e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1463);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005c;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x00ad;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1463);
        sp += 0x000a;
    case 0x150b1:
        if (memory16get(ds, 0x9c68) != 0x000a) {
            pc = 0x150de;
            break;
        }
        if (!(memory[ds*16 + 0x1d34] & 0x01)) {
            pc = 0x150d9;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x007f;
        push(r16[ax]);
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x00a5;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1463);
        sp += 0x000a;
    case 0x150d9:
        memory[ds*16 + 0x1d34] = memory[ds*16 + 0x1d34] ^ 0x01;
    case 0x150de:
        if (memory[ss*16 + bp - 7] != 0x00) {
            pc = 0x150ee;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x150f6;
        break;
    case 0x150ee:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x150f6:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x15104;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x15108;
            break;
        }
    case 0x15104:
        memory[ss*16 + bp - 7] = memory[ss*16 + bp - 7] ^ 0x01;
    case 0x15108:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x1463);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x1463);
        sp += 0x0004;
        if (memory[ss*16 + bp - 6] != 0x00) {
            pc = 0x15144;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1463);
        sp += 0x000a;
        memory[ss*16 + bp - 6] = 0x01;
    case 0x15144:
        if (memory[ss*16 + bp - 5] == 0x00) {
            pc = 0x15186;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x15158;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x15186;
            break;
        }
    case 0x15158:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x15163;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e3e9();
        assert(cs == 0x1463);
    case 0x15163:
        if (memory[ss*16 + bp - 5] != 0x02) {
            pc = 0x1516e;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e59e();
        assert(cs == 0x1463);
    case 0x1516e:
        if (memory[ss*16 + bp - 5] != 0x03) {
            pc = 0x15179;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e32a();
        assert(cs == 0x1463);
    case 0x15179:
        if (memory[ss*16 + bp - 5] != 0x04) {
            pc = 0x15194;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e4a4();
        assert(cs == 0x1463);
        pc = 0x15194;
        break;
    case 0x15186:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x1463);
        sp += 0x0004;
    case 0x15194:
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x1463);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x1463);
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x151b2;
            break;
        }
        pc = 0x14f93;
        break;
    case 0x151b2:
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x151bc;
            break;
        }
        pc = 0x14f93;
        break;
    case 0x151bc:
        if (memory16gets(ds, 0x988e) >= signed16(0x0000)) {
            pc = 0x151c9;
            break;
        }
        memory16set(ds, 0x988e, 0x0000);
    case 0x151c9:
        if (memory16gets(ds, 0x988e) <= signed16(0x012c)) {
            pc = 0x151d7;
            break;
        }
        memory16set(ds, 0x988e, 0x012c);
    case 0x151d7:
        if (memory16gets(ds, 0x97f2) <= signed16(0x00b4)) {
            pc = 0x151ef;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x151ef;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9870, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
    case 0x151ef:
        if (memory16get(ds, 0x9c68) < 0x0064) {
            pc = 0x151f9;
            break;
        }
        pc = 0x15432;
        break;
    case 0x151f9:
        if (memory16get(ds, 0x9c68) != 0x000c) {
            pc = 0x15214;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x15214;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x000a)) {
            pc = 0x15214;
            break;
        }
        memory16set(ds, 0x988e, 0x000a);
    case 0x15214:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x15228;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0014)) {
            pc = 0x15228;
            break;
        }
        memory16set(ds, 0x988e, 0x0014);
    case 0x15228:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x15248;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x15248;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x012b)) {
            pc = 0x15248;
            break;
        }
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
    case 0x15248:
        if (memory16get(ds, 0x9c68) == 0x000b) {
            pc = 0x15252;
            break;
        }
        pc = 0x152f3;
        break;
    case 0x15252:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x1525c;
            break;
        }
        pc = 0x152f3;
        break;
    case 0x1525c:
        if (memory16gets(ds, 0x988e) >= signed16(0x0064)) {
            pc = 0x15272;
            break;
        }
        if (memory16gets(ds, 0x97f2) <= signed16(0x0022)) {
            pc = 0x15272;
            break;
        }
        memory16set(ds, 0x988e, 0x0064);
        pc = 0x15280;
        break;
    case 0x15272:
        if (memory16gets(ds, 0x988e) <= signed16(0x00cc)) {
            pc = 0x15280;
            break;
        }
        memory16set(ds, 0x988e, 0x00cc);
    case 0x15280:
        if (memory16gets(ds, 0x97f2) <= signed16(0x00a4)) {
            pc = 0x1529c;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) - 1);
        memory16set(ds, 0x97f2, 0xffff);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x03;
    case 0x1529c:
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x152f3;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x0087)) {
            pc = 0x152f3;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x005a)) {
            pc = 0x152f3;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x988e, 0x0096);
        memory16set(ds, 0x97f2, 0x0032);
        memory16set(ds, 0x9872, 0x0001);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x152d4;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_1959f();
        assert(cs == 0x1463);
    case 0x152d4:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x152e2;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x152ef;
            break;
        }
    case 0x152e2:
        push(ds);
        r16[ax] = 0x1d9e;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_6d22();
        assert(cs == 0x1463);
        sp += 0x0004;
    case 0x152ef:
        memory[ss*16 + bp - 6] = 0x00;
    case 0x152f3:
        if (memory16get(ds, 0x9c68) != 0x000a) {
            pc = 0x1533e;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x1533e;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0064)) {
            pc = 0x1530e;
            break;
        }
        memory16set(ds, 0x988e, 0x0064);
    case 0x1530e:
        if (memory16gets(ds, 0x988e) <= signed16(0x00cc)) {
            pc = 0x1531c;
            break;
        }
        memory16set(ds, 0x988e, 0x00cc);
    case 0x1531c:
        if (memory16gets(ds, 0x97f2) >= signed16(0xffff)) {
            pc = 0x1533e;
            break;
        }
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x1533e;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x97f2, 0x00a4);
        memory[ss*16 + bp - 5] = 0x04;
    case 0x1533e:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x15389;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x15389;
            break;
        }
        if (memory16get(ds, 0x987e) != 0x0000) {
            pc = 0x15389;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x010e)) {
            pc = 0x15361;
            break;
        }
        memory16set(ds, 0x988e, 0x010e);
    case 0x15361:
        if (memory16gets(ds, 0x988e) <= signed16(0x0070)) {
            pc = 0x15389;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x007c)) {
            pc = 0x15389;
            break;
        }
        if (memory16get(ds, 0x97f2) != 0x004c) {
            pc = 0x15389;
            break;
        }
        if (memory16get(ds, 0x9802) == 0x0000) {
            pc = 0x15389;
            break;
        }
        memory16set(ds, 0x988e, 0x0077);
        memory16set(ds, 0x987e, 0x0fa1);
    case 0x15389:
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x153b9;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x153b9;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0000) {
            pc = 0x153b9;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x153b9;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) - 1);
        memory16set(ds, 0x988e, 0x011d);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x02;
    case 0x153b9:
        if (memory16gets(ds, 0x988e) <= signed16(0x0127)) {
            pc = 0x153e3;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0012) {
            pc = 0x153e3;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x153e3;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x988e, 0x0006);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x01;
    case 0x153e3:
        if (memory16get(ds, 0x9c68) != 0x0011) {
            pc = 0x15432;
            break;
        }
        if (memory16get(ds, 0x9880) <= 0x002c) {
            pc = 0x15432;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x15432;
            break;
        }
        if (memory16get(ds, 0x97f2) != 0x0044) {
            pc = 0x15432;
            break;
        }
        if (memory16get(ds, 0x9860) == 0x0000) {
            pc = 0x15432;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x9872, 0x0001);
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x1463);
        sp++;
        sp++;
        r16[ax] = 0x0011;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x39d2;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x39aa;
        push(r16[ax]);
        push(cs);
        yield* sub_148b2();
        sp += 0x000a;
    case 0x15432:
        r16[ax] = memory16get(ds, 0x987e);
        r16[ax] &= 0x0003;
        if (r16[ax] == 0x0003) {
            pc = 0x15440;
            break;
        }
        pc = 0x14f93;
        break;
    case 0x15440:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x14f93;
        break;
    case 0x15449:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x1463);
        sp++;
        sp++;
        if (memory16get(ds, 0x987e) & 0x0003) {
            pc = 0x15461;
            break;
        }
        pc = 0x14e75;
        break;
    case 0x15461:
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        if (memory16get(ds, 0x987e) == 0x03e8) {
            pc = 0x15483;
            break;
        }
        push(memory16get(ds, 0x987e));
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x1946;
        yield* sub_19aa5();
        assert(cs == 0x1463);
        sp += 0x0004;
        pc = 0x154a7;
        break;
    case 0x15483:
        memory16set(ds, 0x9872, 0x0001);
        memory16set(ds, 0x9c68, 0x000a);
        memory16set(ds, 0x988e, 0x0064);
        memory16set(ds, 0x97f2, 0x009f);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x154a7;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_1955b();
        assert(cs == 0x1463);
    case 0x154a7:
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x14e75;
        break;
    case 0x154ae:
        push(memory16get(ds, 0x987c));
        push(memory16get(ds, 0x987a));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x1463);
        sp += 0x0004;
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x1463);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x154e0;
            break;
        }
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x1463);
        sp += 0x0004;
    case 0x154e0:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_154e6() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x97e0, 0x0011);
    memory16set(ds, 0x9872, 0x0000);
    r16[ax] = 0;
    memory16set(ds, 0x9c6e, r16[ax]);
    memory16set(ds, 0x9c68, prehistorikScreen);
    memory16set(ds, 0x9c6a, r16[ax]);
    memory16set(ds, 0x9874, 0x0028);
    memory16set(ds, 0x988e, 0x008c);
    memory16set(ds, 0x97f2, 0x0041);
    memory16set(ds, 0x9800, r16[ax]);
    memory16set(ds, 0x97e2, r16[ax]);
    memory16set(ds, 0x9892, r16[ax]);
    memory16set(ds, 0x97ea, r16[ax]);
    memory16set(ds, 0x9c62, r16[ax]);
    memory16set(ds, 0x9868, r16[ax]);
    memory16set(ds, 0x97f4, 0x0014);
    memory16set(ds, 0x9880, r16[ax]);
    memory16set(ds, 0x989c, r16[ax]);
    memory16set(ds, 0x97e8, r16[ax]);
    memory16set(ds, 0x97f8, r16[ax]);
    memory16set(ds, 0x9862, r16[ax]);
    memory16set(ds, 0x97fa, r16[ax]);
    memory16set(ds, 0x9870, r16[ax]);
    memory16set(ds, 0x9c66, 0x0063);
    memory16set(ds, 0x985a, r16[ax]);
    memory16set(ds, 0x989a, 0x000a);
    cs = pop();
}
function* sub_1554c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x154e);
        sp++;
        sp++;
        r16[ax] = 0x1f40;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x154e);
        sp++;
        sp++;
        memory16set(ds, 0x987c, r16[dx]);
        memory16set(ds, 0x987a, r16[ax]);
        memory16set(ds, 0x9c6c, 0x0005);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1dce;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x154e);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1dd8;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x154e);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9896, r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x154e);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1de2;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x154e);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x9896);
        memory16set(ds, 0x9882, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1ded;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x154e);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x9882);
        memory16set(ds, 0x9878, r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x154e);
        sp++;
        sp++;
        r16[ax] = 0x0035;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x154e);
        sp++;
        sp++;
        r16[ax] = 0x0031;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x154e);
        sp++;
        sp++;
        r16[ax] = 0x0036;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x154e);
        sp++;
        sp++;
        r16[ax] = memory16get(ds, 0x9878);
        r16[ax] += 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x154e);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x1df7;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e49();
        assert(cs == 0x154e);
        sp += 0x0004;
        push(cs);
        yield* sub_154e6();
        push(ds);
        r16[ax] = 0x5840;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x154e);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x154e);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x29e2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x154e);
        sp += 0x0004;
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x154e);
        sp += 0x0004;
    case 0x15670:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x1567a;
            break;
        }
        pc = 0x15b8a;
        break;
    case 0x1567a:
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x15684;
            break;
        }
        pc = 0x15b8a;
        break;
    case 0x15684:
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x154e);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x156ae;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x4e50;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x4e2a;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19f50();
        assert(cs == 0x154e);
        sp += 0x000a;
        pc = 0x156bc;
        break;
    case 0x156ae:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a03f();
        assert(cs == 0x154e);
        sp++;
        sp++;
    case 0x156bc:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x156d6;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x5840;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x154e);
        sp += 0x0006;
        pc = 0x156ea;
        break;
    case 0x156d6:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x154e);
        sp += 0x0006;
    case 0x156ea:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x15704;
            break;
        }
        r16[bx] = memory16get(ds, 0x9c68);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7592));
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x154e);
        sp++;
        sp++;
        pc = 0x1570f;
        break;
    case 0x15704:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x154e);
        sp++;
        sp++;
    case 0x1570f:
        push(cs);
        cs = 0x19e4;
        yield* sub_1a4da();
        assert(cs == 0x154e);
        memory[ss*16 + bp - 7] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x154e);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x154e);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x154e);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x154e);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b341();
        assert(cs == 0x154e);
        r16[si] = 0;
        pc = 0x1574a;
        break;
    case 0x1573b:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, 0x0000);
        r16[si]++;
    case 0x1574a:
        if (r16[si] < 0x000a) {
            pc = 0x1573b;
            break;
        }
        memory16set(ds, 0x97e4, 0x0000);
        memory16set(ds, 0x9894, 0x0000);
        memory16set(ds, 0x97e6, 0x0000);
        memory16set(ds, 0x987e, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x154e);
    case 0x1576c:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x15776;
            break;
        }
        pc = 0x15b48;
        break;
    case 0x15776:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x15780;
            break;
        }
        pc = 0x15b48;
        break;
    case 0x15780:
        r16[ax] = memory16get(ds, 0x985a);
        memory16set(ds, 0x985a, memory16get(ds, 0x985a) + 1);
        if (r16[ax] <= 0x003c) {
            pc = 0x157bd;
            break;
        }
        if (memory16get(ds, 0x9c66) == 0x0000) {
            pc = 0x15799;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) - 1);
        pc = 0x157b2;
        break;
    case 0x15799:
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x157b2;
            break;
        }
        memory16set(ds, 0x9874, 0x0000);
        memory16set(ds, 0x9870, 0x0001);
        memory16set(ds, 0x97fa, 0x0001);
    case 0x157b2:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x154e);
        memory16set(ds, 0x985a, 0x0000);
    case 0x157bd:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b0b7();
        assert(cs == 0x154e);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a5d8();
        assert(cs == 0x154e);
        memory16set(ds, 0x97e6, 0x0000);
        push(cs);
        cs = 0x1bf1;
        yield* sub_1bf13();
        assert(cs == 0x154e);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a6df();
        assert(cs == 0x154e);
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x157ee;
            break;
        }
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x157ee;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0003);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 1);
    case 0x157ee:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x15819;
            break;
        }
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x15819;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0003);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 1);
        if (memory16gets(ds, 0x988e) <= signed16(0x012c)) {
            pc = 0x15819;
            break;
        }
        memory16set(ds, 0x9c68, 0x0013);
        memory16set(ds, 0x9872, 0x0001);
    case 0x15819:
        if (memory16get(ds, 0x9c68) != 0x000c) {
            pc = 0x15881;
            break;
        }
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x15839;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9876, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x9804, r16[ax]);
        memory16set(ds, 0x989c, 0x0000);
    case 0x15839:
        if (memory16gets(ds, 0x9804) <= signed16(0xffe2)) {
            pc = 0x15881;
            break;
        }
        memory16set(ds, 0x9876, memory16get(ds, 0x9876) + 0x0005);
        memory16set(ds, 0x9804, memory16get(ds, 0x9804) - 0x0004);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0076;
        push(r16[ax]);
        push(memory16get(ds, 0x9804));
        push(memory16get(ds, 0x9876));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x154e);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x007d;
        push(r16[ax]);
        push(memory16get(ds, 0x9804));
        r16[ax] = memory16get(ds, 0x9876);
        r16[ax] += 0x0015;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x154e);
        sp += 0x000a;
    case 0x15881:
        if (memory16get(ds, 0x9c68) == 0x000a) {
            pc = 0x1588f;
            break;
        }
        if (memory16get(ds, 0x9c68) != 0x000b) {
            pc = 0x158a1;
            break;
        }
    case 0x1588f:
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x158a1;
            break;
        }
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x158a1;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b934();
        assert(cs == 0x154e);
    case 0x158a1:
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x154e);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x154e);
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x158e4;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b991();
        assert(cs == 0x154e);
    case 0x158e4:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x158ee;
            break;
        }
        pc = 0x159ad;
        break;
    case 0x158ee:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x158f9;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1bdb2();
        assert(cs == 0x154e);
    case 0x158f9:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x15912;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x15912;
            break;
        }
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x15912;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b107();
        assert(cs == 0x154e);
    case 0x15912:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x1593b;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x00d7)) {
            pc = 0x1593b;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x0014)) {
            pc = 0x1593b;
            break;
        }
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x1593b;
            break;
        }
        memory16set(ds, 0x989c, 0x0001);
        memory16set(ds, 0x9874, 0x000f);
    case 0x1593b:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x1596b;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x008c)) {
            pc = 0x1596b;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x0003)) {
            pc = 0x1596b;
            break;
        }
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x1596b;
            break;
        }
        if (memory16get(ds, 0x9880) <= 0x002c) {
            pc = 0x1596b;
            break;
        }
        memory16set(ds, 0x989c, 0x0001);
        memory16set(ds, 0x9874, 0x0027);
    case 0x1596b:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x159ad;
            break;
        }
        if (memory16get(ds, 0x9880) >= 0x002d) {
            pc = 0x159ad;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0053;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x006e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x154e);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005c;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x00ad;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x154e);
        sp += 0x000a;
    case 0x159ad:
        if (memory[ss*16 + bp - 7] != 0x00) {
            pc = 0x159bd;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x159c5;
        break;
    case 0x159bd:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x159c5:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x159d3;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x159d7;
            break;
        }
    case 0x159d3:
        memory[ss*16 + bp - 7] = memory[ss*16 + bp - 7] ^ 0x01;
    case 0x159d7:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x154e);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x154e);
        sp += 0x0004;
        if (memory[ss*16 + bp - 6] != 0x00) {
            pc = 0x15a13;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x154e);
        sp += 0x000a;
        memory[ss*16 + bp - 6] = 0x01;
    case 0x15a13:
        if (memory[ss*16 + bp - 5] == 0x00) {
            pc = 0x15a3b;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x15a27;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x15a3b;
            break;
        }
    case 0x15a27:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x15a34;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e3e9();
        assert(cs == 0x154e);
        pc = 0x15a49;
        break;
    case 0x15a34:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e59e();
        assert(cs == 0x154e);
        pc = 0x15a49;
        break;
    case 0x15a3b:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x154e);
        sp += 0x0004;
    case 0x15a49:
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x154e);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x154e);
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x15a67;
            break;
        }
        pc = 0x1576c;
        break;
    case 0x15a67:
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x15a71;
            break;
        }
        pc = 0x1576c;
        break;
    case 0x15a71:
        if (memory16gets(ds, 0x988e) >= signed16(0x0000)) {
            pc = 0x15a7e;
            break;
        }
        memory16set(ds, 0x988e, 0x0000);
    case 0x15a7e:
        if (memory16gets(ds, 0x988e) <= signed16(0x012c)) {
            pc = 0x15a8c;
            break;
        }
        memory16set(ds, 0x988e, 0x012c);
    case 0x15a8c:
        if (memory16gets(ds, 0x97f2) <= signed16(0x00b4)) {
            pc = 0x15aa4;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x15aa4;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9870, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
    case 0x15aa4:
        if (memory16get(ds, 0x9c68) < 0x0064) {
            pc = 0x15aae;
            break;
        }
        pc = 0x15b31;
        break;
    case 0x15aae:
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x15ae9;
            break;
        }
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x15ae9;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0000) {
            pc = 0x15ae9;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x15ae9;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) - 1);
        memory16set(ds, 0x988e, 0x011d);
        memory16set(ds, 0x9872, 0x0001);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_5e86();
        assert(cs == 0x154e);
        sp++;
        sp++;
        memory[ss*16 + bp - 5] = 0x02;
    case 0x15ae9:
        if (memory16gets(ds, 0x988e) <= signed16(0x0127)) {
            pc = 0x15b31;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0012) {
            pc = 0x15b31;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x15b31;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        if (memory16get(ds, 0x9c68) != 0x000c) {
            pc = 0x15b17;
            break;
        }
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x15b17;
            break;
        }
        memory16set(ds, 0x97f2, 0x0046);
    case 0x15b17:
        memory16set(ds, 0x988e, 0x0006);
        memory16set(ds, 0x9872, 0x0001);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_5e86();
        assert(cs == 0x154e);
        sp++;
        sp++;
        memory[ss*16 + bp - 5] = 0x01;
    case 0x15b31:
        r16[ax] = memory16get(ds, 0x987e);
        r16[ax] &= 0x0003;
        if (r16[ax] == 0x0003) {
            pc = 0x15b3f;
            break;
        }
        pc = 0x1576c;
        break;
    case 0x15b3f:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x1576c;
        break;
    case 0x15b48:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x154e);
        sp++;
        sp++;
        if (memory16get(ds, 0x987e) & 0x0003) {
            pc = 0x15b60;
            break;
        }
        pc = 0x15670;
        break;
    case 0x15b60:
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        if (memory16get(ds, 0x987e) != 0x03e8) {
            pc = 0x15b73;
            break;
        }
        pc = 0x15670;
        break;
    case 0x15b73:
        push(memory16get(ds, 0x987e));
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(cs);
        cs = 0x1946;
        yield* sub_19aa5();
        assert(cs == 0x154e);
        sp += 0x0004;
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x15670;
        break;
    case 0x15b8a:
        memory16set(ds, 0x989c, 0x0000);
        push(memory16get(ds, 0x987c));
        push(memory16get(ds, 0x987a));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x154e);
        sp += 0x0004;
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x154e);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x15bc2;
            break;
        }
        r16[ax] = 0x0003;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x154e);
        sp += 0x0004;
    case 0x15bc2:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_15bc7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x002c;
        r16[ax] = memory16get(ds, 0x9c5e);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        push(r16[dx]);
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6a15();
        assert(cs == 0x15bc);
        sp += 0x0008;
        r16[di] = 0;
    case 0x15be4:
        if (memory[ss*16 + bp + r16[di] - 44] == 0x00) {
            pc = 0x15bee;
            break;
        }
        r16[di]++;
        pc = 0x15be4;
        break;
    case 0x15bee:
        r16[si] = 0;
    case 0x15bf0:
        r16[ax] = 0x0002;
        r16[ax] -= r16[di];
        if (r16[ax] <= r16[si]) {
            pc = 0x15c07;
            break;
        }
        r16[bx] = r16[si];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] = 0x30;
        r16[si]++;
        pc = 0x15bf0;
        break;
    case 0x15c07:
        memory[ss*16 + bp + r16[si] - 24] = 0x00;
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x15bc);
        sp += 0x0008;
        memory16set(ss, bp - 4, 0x000f);
        memory16set(ss, bp - 2, 0x0009);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6604();
        assert(cs == 0x15bc);
        sp += 0x0012;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x15bc);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_15c56() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory16get(ds, 0x9870) != 0x0001) {
            pc = 0x15c6a;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9c60, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x97de, r16[ax]);
    case 0x15c6a:
        if (memory16get(ds, 0x9870) >= 0x0009) {
            pc = 0x15c9e;
            break;
        }
        r16[bx] = memory16get(ds, 0x9870);
        r16[bx]--;
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 7682);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(memory16get(ds, 0x97f2));
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfffb;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        memory16set(ds, 0x9870, memory16get(ds, 0x9870) + 1);
        pc = 0x15d49;
        break;
    case 0x15c9e:
        if (memory16get(ds, 0x97fa) == 0x0000) {
            pc = 0x15ce5;
            break;
        }
        r16[si] = memory16get(ds, 0x97fa);
        r16[si] &= 0x0001;
        r16[si] += 0x0011;
        memory16set(ds, 0x97fa, memory16get(ds, 0x97fa) + 1);
        memory16set(ds, 0x97de, memory16get(ds, 0x97de) - 0x0004);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(memory16get(ds, 0x97de));
        push(memory16get(ds, 0x9c60));
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        if (memory16get(ds, 0x9890) == 0x0000) {
            pc = 0x15cde;
            break;
        }
        memory16set(ds, 0x97de, 0xffff);
    case 0x15cde:
        if (memory16gets(ds, 0x97de) > signed16(0x0000)) {
            pc = 0x15d49;
            break;
        }
    case 0x15ce5:
        memory16set(ds, 0x97fa, 0x0000);
        r16[ax] = memory16get(ds, 0x9c64);
        memory16set(ds, 0x988e, r16[ax]);
        r16[ax] = memory16get(ds, 0x97fc);
        memory16set(ds, 0x97f2, r16[ax]);
        memory16set(ds, 0x9874, 0x0027);
        memory16set(ds, 0x9800, 0x0000);
        memory16set(ds, 0x9892, 0x0000);
        memory16set(ds, 0x97ea, 0x0000);
        memory16set(ds, 0x9c62, 0x0000);
        memory16set(ds, 0x9868, 0x0000);
        r16[ax] = 0;
        memory16set(ds, 0x97f8, r16[ax]);
        memory16set(ds, 0x9862, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        if (!prehistorikInifniteLives)
            memory16set(ds, 0x9c5e, memory16get(ds, 0x9c5e) - 1);
        if (memory16gets(ds, 0x9c5e) < r16s[ax]) {
            pc = 0x15d37;
            break;
        }
        push(cs);
        yield* sub_15bc7();
    case 0x15d37:
        if (memory16get(ds, 0x9c66) >= 0x001e) {
            pc = 0x15d43;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) + 0x000a);
    case 0x15d43:
        memory16set(ds, 0x985a, 0x0000);
    case 0x15d49:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_15d4b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[di] = 0;
        if (memory16gets(ds, 0x9c5e) >= signed16(r16[di])) {
            pc = 0x15d5d;
            break;
        }
        pc = 0x16019;
        break;
    case 0x15d5d:
        if (memory16get(ds, 0x97e8) == r16[di]) {
            pc = 0x15d91;
            break;
        }
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = 0x0031;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        r16[ax] = memory16get(ds, 0x97e8);
        r16[ax] &= 0x0001;
        r16[ax] += memory16get(ds, 0x988e);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0004);
        memory16set(ds, 0x97e8, memory16get(ds, 0x97e8) - 1);
        pc = 0x16019;
        break;
    case 0x15d91:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x15d9f;
            break;
        }
        push(cs);
        yield* sub_15c56();
        pc = 0x16019;
        break;
    case 0x15d9f:
        memory16set(ss, bp - 2, 0x0001);
        r16[ax] = 0;
        memory16set(ds, 0x985e, r16[ax]);
        memory16set(ds, 0x986e, r16[ax]);
        r16[si] = r16[ax];
        if (memory16get(ds, 0x9868) != r16[ax]) {
            pc = 0x15dd6;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x00a6)) {
            pc = 0x15dd6;
            break;
        }
        r16[di] = 0x0001;
        memory16set(ss, bp - 2, 0x0004);
    case 0x15dc4:
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 1);
        r16[si]++;
        if (r16[si] >= 0x000a) {
            pc = 0x15dd6;
            break;
        }
        if (memory16gets(ds, 0x97f2) < signed16(0x00a6)) {
            pc = 0x15dc4;
            break;
        }
    case 0x15dd6:
        if (memory16get(ds, 0x986a) != 0x0000) {
            pc = 0x15de0;
            break;
        }
        pc = 0x15e62;
        break;
    case 0x15de0:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x15dea;
            break;
        }
        pc = 0x15e62;
        break;
    case 0x15dea:
        r16[si] = 0x0005;
        if (r16[di]) {
            pc = 0x15e35;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15e35;
            break;
        }
        memory16set(ds, 0x9892, memory16get(ds, 0x9892) + 1);
        if (memory16get(ds, 0x9892) <= r16[si]) {
            pc = 0x15e08;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
    case 0x15e08:
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7698);
        memory16set(ss, bp - 2, r16[ax]);
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 7710);
        if (memory16get(ds, 0x9800) != 0x0001) {
            pc = 0x15e35;
            break;
        }
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7722);
        r16[ax] = -r16[ax];
        memory16set(ds, 0x986e, r16[ax]);
    case 0x15e35:
        if (memory16get(ds, 0x9800) == 0x0001) {
            pc = 0x15e4c;
            break;
        }
        if (r16[di]) {
            pc = 0x15e4c;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15e4c;
            break;
        }
        memory16set(ss, bp - 2, 0x001d);
    case 0x15e4c:
        memory16set(ds, 0x9800, 0x0001);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - r16[si]);
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x15e62;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - 0x0002);
    case 0x15e62:
        if (memory16get(ds, 0x988c) != 0x0000) {
            pc = 0x15e6c;
            break;
        }
        pc = 0x15eec;
        break;
    case 0x15e6c:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x15e76;
            break;
        }
        pc = 0x15eec;
        break;
    case 0x15e76:
        r16[si] = 0x0005;
        if (r16[di]) {
            pc = 0x15ebf;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15ebf;
            break;
        }
        memory16set(ds, 0x9892, memory16get(ds, 0x9892) + 1);
        if (memory16get(ds, 0x9892) <= r16[si]) {
            pc = 0x15e94;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
    case 0x15e94:
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7698);
        memory16set(ss, bp - 2, r16[ax]);
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 7710);
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x15ebf;
            break;
        }
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7722);
        memory16set(ds, 0x986e, r16[ax]);
    case 0x15ebf:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x15ed6;
            break;
        }
        if (r16[di]) {
            pc = 0x15ed6;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15ed6;
            break;
        }
        memory16set(ss, bp - 2, 0x001d);
    case 0x15ed6:
        memory16set(ds, 0x9800, 0x0000);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + r16[si]);
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x15eec;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0002);
    case 0x15eec:
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15ef6;
            break;
        }
        pc = 0x15f61;
        break;
    case 0x15ef6:
        r16[si] = 0;
    case 0x15ef8:
        memory16set(ds, 0x9868, memory16get(ds, 0x9868) + 1);
        r16[si]++;
        if (memory16get(ds, 0x9868) != 0x0002) {
            pc = 0x15f14;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        if (r16[ax] <= 0x0014) {
            pc = 0x15f14;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dcd2();
        assert(cs == 0x15bc);
    case 0x15f14:
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] += 0xfff8;
        if (r16[ax] >= memory16get(ds, 0x9868)) {
            pc = 0x15f2d;
            break;
        }
        r16[ax] = memory16get(ds, 0x9868);
        if (r16[ax] >= memory16get(ds, 0x97f4)) {
            pc = 0x15f2d;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 1);
    case 0x15f2d:
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] += 0xfffa;
        if (r16[ax] <= memory16get(ds, 0x9868)) {
            pc = 0x15f3e;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0002);
    case 0x15f3e:
        r16[ax] = memory16get(ds, 0x9868);
        if (r16[ax] <= memory16get(ds, 0x97f4)) {
            pc = 0x15f50;
            break;
        }
        memory16set(ds, 0x9868, 0x0000);
        r16[di] = 0x0001;
    case 0x15f50:
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x15f5c;
            break;
        }
        if (r16[si] < 0x0004) {
            pc = 0x15ef8;
            break;
        }
    case 0x15f5c:
        memory16set(ss, bp - 2, 0x0004);
    case 0x15f61:
        if (r16[di]) {
            pc = 0x15f7f;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15f7f;
            break;
        }
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x15f7f;
            break;
        }
        memory16set(ds, 0x9868, 0x0001);
        memory16set(ds, 0x97f4, 0x0011);
    case 0x15f7f:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x15fd8;
            break;
        }
        r16[si] = 0x0002;
        r16[si] -= memory16get(ds, 0x9862);
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15f98;
            break;
        }
        if (!r16[di]) {
            pc = 0x15f9b;
            break;
        }
    case 0x15f98:
        r16[si] += 0x0002;
    case 0x15f9b:
        r16[si] <<= 1;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7734);
        memory16set(ss, bp - 2, r16[ax]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7734);
        memory16set(ds, 0x985e, r16[ax]);
        if (memory16get(ds, 0x986a) == 0x0000) {
            pc = 0x15fc6;
            break;
        }
        memory16set(ds, 0x9800, 0x0001);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - 0x0005);
    case 0x15fc6:
        if (memory16get(ds, 0x988c) == 0x0000) {
            pc = 0x15fd8;
            break;
        }
        memory16set(ds, 0x9800, 0x0000);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0005);
    case 0x15fd8:
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x15ff6;
            break;
        }
        if (r16[di]) {
            pc = 0x15ff6;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x15ff6;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9c64, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x97fc, r16[ax]);
    case 0x15ff6:
        push(memory16get(ds, 0x9800));
        push(memory16get(ss, bp - 2));
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += memory16get(ds, 0x985e);
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += memory16get(ds, 0x986e);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x16019:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1601f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001e;
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1e46;
        push(r16[ax]);
        r16[cx] = 0x0018;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x15bc);
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x16043;
            break;
        }
        pc = 0x160d9;
        break;
    case 0x16043:
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x15bc);
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x16056;
            break;
        }
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x1605f;
            break;
        }
    case 0x16056:
        memory16set(ds, 0x9862, 0x0000);
        pc = 0x160d9;
        break;
    case 0x1605f:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x160d9;
            break;
        }
        r16[ax] = memory16get(ds, 0x9800);
        memory16set(ss, bp - 26, r16[ax]);
        r16[si] = 0x0002;
        r16[si] -= memory16get(ds, 0x9862);
        r16[ax] = r16[si];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r16[di] = memory16get(ss, r16[bx]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ss, r16[bx]);
        memory16set(ss, bp - 28, r16[ax]);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ss, r16[bx]);
        memory16set(ss, bp - 30, r16[ax]);
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x160b7;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] = -r16[ax];
        r16[di] = r16[ax];
    case 0x160b7:
        push(memory16get(ss, bp - 26));
        push(memory16get(ss, bp - 30));
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += memory16get(ss, bp - 28);
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += r16[di];
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        memory16set(ds, 0x9862, memory16get(ds, 0x9862) - 1);
    case 0x160d9:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_160df() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory16get(ds, 0x9874) == 0x0000) {
            pc = 0x1612a;
            break;
        }
        if (memory16get(ds, 0x9874) >= 0x0064) {
            pc = 0x1612a;
            break;
        }
        memory16set(ds, 0x9874, memory16get(ds, 0x9874) - 1);
        r16[ax] = 0x0001;
        r16[ax] -= memory16get(ds, 0x9c6a);
        memory16set(ds, 0x9c6a, r16[ax]);
        if (memory16get(ds, 0x9874) > 0x000f) {
            pc = 0x16106;
            break;
        }
        if (!r16[ax]) {
            pc = 0x1612a;
            break;
        }
    case 0x16106:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9c6a);
        r16[ax] += 0x001b;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff5;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfffb;
        push(r16[ax]);
        r16[ax] = 0x000d;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x1612a:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1612b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory16get(ds, 0x932c) != 0x0000) {
            pc = 0x16135;
            break;
        }
        pc = 0x161d4;
        break;
    case 0x16135:
        if (memory16get(ds, 0x932c) != 0x0001) {
            pc = 0x16158;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x00aa;
        push(r16[ax]);
        r16[ax] = 0x0088;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        pc = 0x16172;
        break;
    case 0x16158:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0x00a8;
        push(r16[ax]);
        r16[ax] = 0x0088;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x16172:
        memory16set(ds, 0x932c, memory16get(ds, 0x932c) + 1);
        if (memory16get(ds, 0x932c) == 0x0003) {
            pc = 0x16180;
            break;
        }
        pc = 0x16212;
        break;
    case 0x16180:
        memory16set(ds, 0x932c, 0x0000);
        if (memory16get(ds, 0x932a) > 0x0110) {
            pc = 0x16191;
            break;
        }
        pc = 0x16212;
        break;
    case 0x16191:
        memory16set(ds, 0x932a, memory16get(ds, 0x932a) - 1);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(memory16get(ds, 0x932a));
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x15bc);
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(memory16get(ds, 0x932a));
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x15bc);
        sp += 0x000e;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x15bc);
        pc = 0x16212;
        break;
    case 0x161d4:
        if (memory16get(ds, 0x932a) >= 0x0122) {
            pc = 0x161f8;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x00aa;
        push(r16[ax]);
        r16[ax] = 0x0088;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        pc = 0x16212;
        break;
    case 0x161f8:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0026;
        push(r16[ax]);
        r16[ax] = 0x00b1;
        push(r16[ax]);
        r16[ax] = 0x0089;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x16212:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_16213() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = memory16get(ds, 0x9330);
        r16[ax] = r16[si];
        if (!r16[ax]) {
            pc = 0x16290;
            break;
        }
        r16[si]--;
        r16[ax] = r16[si];
        r16[dx] = 0x0006;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7774));
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7774));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7774));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = r16[si];
        r16[bx] += 0x0005;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7774));
        r16[bx] = r16[si];
        r16[bx] += 0x0004;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7774));
        r16[bx] = r16[si];
        r16[bx] += 0x0003;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 7774));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        memory16set(ds, 0x9330, memory16get(ds, 0x9330) + 1);
        if (memory16get(ds, 0x9330) != 0x0006) {
            pc = 0x162aa;
            break;
        }
        memory16set(ds, 0x9330, 0x0000);
        pc = 0x162aa;
        break;
    case 0x16290:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0023;
        push(r16[ax]);
        r16[ax] = 0x0032;
        push(r16[ax]);
        r16[ax] = 0x0086;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x162aa:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_162ac() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        if (memory16get(ds, 0x9328) == 0x0000) {
            pc = 0x162be;
            break;
        }
        memory16set(ds, 0x9328, memory16get(ds, 0x9328) - 1);
    case 0x162be:
        r16[si] = 0;
        pc = 0x16552;
        break;
    case 0x162c3:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 37616);
        if (r16[ax] <= 0x0002) {
            pc = 0x162d3;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x162d3:
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x162e2; break;
        case 2: pc = 0x16363; break;
        case 4: pc = 0x164f0; break;
            default:
            assert(0);
        }
        break;
    case 0x162e2:
        if (memory16get(ds, 0x9328) == 0x0000) {
            pc = 0x162ec;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x162ec:
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x15bc);
        r16[bx] = 0x0064;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        if (r16s[dx] <= signed16(0x0032)) {
            pc = 0x16316;
            break;
        }
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0001);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0168);
        pc = 0x1632e;
        break;
    case 0x16316:
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0000);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0xffd8);
    case 0x1632e:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0001);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x15bc);
        r16[bx] = 0x0004;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = r16[si];
        r16[bx] += 0x0003;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, r16[dx]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x15bc);
        r16[bx] = 0x000a;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x001e;
        memory16set(ds, 0x9328, r16[dx]);
        pc = 0x1654f;
        break;
    case 0x16363:
        r16[bx] = r16[si];
        r16[bx] += 0x0003;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, memory16get(ds, r16[bx] + 37616) + 1);
        r16[bx] = r16[si];
        r16[bx] += 0x0003;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, memory16get(ds, r16[bx] + 37616) & 0x0003);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        r16[di] = memory16get(ds, r16[bx] + 37616);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        if (memory16get(ds, r16[bx] + 37616) == 0x0000) {
            pc = 0x163a1;
            break;
        }
        memory16set(ss, bp - 2, 0x002d);
        r16[di] -= 0x0004;
        if (signed16(r16[di]) >= signed16(0xff9c)) {
            pc = 0x163b9;
            break;
        }
        pc = 0x163af;
        break;
    case 0x163a1:
        memory16set(ss, bp - 2, 0x0029);
        r16[di] += 0x0004;
        if (signed16(r16[di]) <= signed16(0x0190)) {
            pc = 0x163b9;
            break;
        }
    case 0x163af:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0000);
    case 0x163b9:
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, r16[di]);
        r16[bx] = r16[si];
        r16[bx] += 0x0003;
        r16[bx] <<= 1;
        r16[bx] = memory16get(ds, r16[bx] + 37616);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 7834);
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        r16[ax] = 0x00a4;
        push(r16[ax]);
        push(r16[di]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x16440;
            break;
        }
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x16440;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0028;
        if (r16s[ax] <= signed16(r16[di])) {
            pc = 0x16440;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0003;
        if (r16s[ax] >= signed16(r16[di])) {
            pc = 0x16440;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001e;
        if (r16s[ax] <= signed16(0x00a4)) {
            pc = 0x16440;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] >= signed16(0x00a4)) {
            pc = 0x16440;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x15bc);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0002);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0000);
    case 0x16440:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x16490;
            break;
        }
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x16490;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] <= signed16(r16[di])) {
            pc = 0x16490;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x0024;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x16490;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001e;
        if (r16s[ax] <= signed16(0x00a4)) {
            pc = 0x16490;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] >= signed16(0x00a4)) {
            pc = 0x16490;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x15bc);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0002);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0001);
    case 0x16490:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        if (memory16get(ds, r16[bx] + 37616) == 0x0001) {
            pc = 0x1649e;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x1649e:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x001e;
        if (r16s[ax] > signed16(r16[di])) {
            pc = 0x164ab;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x164ab:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xffe2;
        if (r16s[ax] < signed16(r16[di])) {
            pc = 0x164b8;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x164b8:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x000a;
        if (r16s[ax] > signed16(0x00a4)) {
            pc = 0x164c6;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x164c6:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] < signed16(0x00a4)) {
            pc = 0x164d4;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x164d4:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x164de;
            break;
        }
        pc = 0x1654f;
        break;
    case 0x164de:
        if (memory16get(ds, 0x9874) != 0x0000) {
            pc = 0x1654f;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        pc = 0x1654f;
        break;
    case 0x164f0:
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        r16[di] = memory16get(ds, r16[bx] + 37616);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        if (memory16get(ds, r16[bx] + 37616) == 0x0000) {
            pc = 0x16516;
            break;
        }
        memory16set(ss, bp - 2, 0x002a);
        r16[di] -= 0x0010;
        if (signed16(r16[di]) >= signed16(0xff9c)) {
            pc = 0x1652e;
            break;
        }
        pc = 0x16524;
        break;
    case 0x16516:
        memory16set(ss, bp - 2, 0x002e);
        r16[di] += 0x0010;
        if (signed16(r16[di]) <= signed16(0x0190)) {
            pc = 0x1652e;
            break;
        }
    case 0x16524:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0000);
    case 0x1652e:
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, r16[di]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        r16[ax] = 0x00a4;
        push(r16[ax]);
        push(r16[di]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x1654f:
        r16[si] += 0x0004;
    case 0x16552:
        if (r16[si] >= 0x0010) {
            pc = 0x1655a;
            break;
        }
        pc = 0x162c3;
        break;
    case 0x1655a:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_16560() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        memory16set(ds, 0x97e0, 0x0011);
        memory16set(ds, 0x9872, 0x0000);
        r16[ax] = 0;
        memory16set(ds, 0x9c6e, r16[ax]);
        memory16set(ds, 0x9c68, prehistorikScreen);
        memory16set(ds, 0x9c6a, r16[ax]);
        memory16set(ds, 0x9874, 0x0027);
        memory16set(ds, 0x988e, 0x003c);
        memory16set(ds, 0x97f2, 0xffd8);
        memory16set(ds, 0x9800, r16[ax]);
        memory16set(ds, 0x9892, r16[ax]);
        memory16set(ds, 0x97ea, r16[ax]);
        memory16set(ds, 0x9c62, r16[ax]);
        memory16set(ds, 0x9868, r16[ax]);
        memory16set(ds, 0x97f8, r16[ax]);
        memory16set(ds, 0x9862, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        memory16set(ds, 0x97e8, 0x002a);
        memory16set(ds, 0x932e, 0x0028);
        memory16set(ds, 0x9328, r16[ax]);
        memory16set(ds, 0x9330, r16[ax]);
        memory16set(ds, 0x932c, r16[ax]);
        memory16set(ds, 0x932a, 0x013d);
        r16[si] = r16[ax];
        pc = 0x165d3;
        break;
    case 0x165c4:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 37616, 0x0000);
        r16[si]++;
    case 0x165d3:
        if (r16[si] < 0x0007) {
            pc = 0x165c4;
            break;
        }
        memory16set(ds, 0x97e2, 0x0000);
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_165e0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x15bc);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1ea2;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x15bc);
        sp += 0x000a;
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1661e;
            break;
        }
        memory[ds*16 + 0x91b9] = 0x20;
        memory[ds*16 + 0x8a6f] = 0x00;
        memory[ds*16 + 0x8e43] = 0x08;
    case 0x1661e:
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1eab;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x15bc);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9896, r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x15bc);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1eb5;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x15bc);
        sp += 0x0008;
        r16[di] = r16[ax];
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[di];
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x15bc);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x15bc);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0090;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = 0x0015;
        push(r16[ax]);
        r16[ax] = 0x0097;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x0022;
        push(r16[ax]);
        r16[ax] = 0x0032;
        push(r16[ax]);
        r16[ax] = 0x0086;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x0025;
        push(r16[ax]);
        r16[ax] = 0x00b1;
        push(r16[ax]);
        r16[ax] = 0x0089;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0x0004;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x15bc);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x15bc);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0090;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = 0x0015;
        push(r16[ax]);
        r16[ax] = 0x0097;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x15bc);
        sp += 0x000a;
        push(cs);
        yield* sub_16560();
        memory[ss*16 + bp - 5] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x15bc);
        push(cs);
        yield* sub_15bc7();
    case 0x16797:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x167a1;
            break;
        }
        pc = 0x16986;
        break;
    case 0x167a1:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x167ab;
            break;
        }
        pc = 0x16986;
        break;
    case 0x167ab:
        memory16set(ds, 0x932e, memory16get(ds, 0x932e) + 1);
        if (memory16get(ds, 0x932e) > 0x0031) {
            pc = 0x167b9;
            break;
        }
        pc = 0x167c3;
        break;
    case 0x167b9:
        if (memory16get(ds, 0x932e) >= 0x0034) {
            pc = 0x167c3;
            break;
        }
        pc = 0x167cd;
        break;
    case 0x167c3:
        if (memory16get(ds, 0x932e) > 0x0035) {
            pc = 0x167cd;
            break;
        }
        pc = 0x167e8;
        break;
    case 0x167cd:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0021;
        push(r16[ax]);
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x009b;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x167e8:
        if (memory16get(ds, 0x932e) > 0x0033) {
            pc = 0x167f2;
            break;
        }
        pc = 0x16817;
        break;
    case 0x167f2:
        if (memory16get(ds, 0x932e) < 0x0036) {
            pc = 0x167fc;
            break;
        }
        pc = 0x16817;
        break;
    case 0x167fc:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0022;
        push(r16[ax]);
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x009b;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x16817:
        if (memory16get(ds, 0x932e) > 0x0036) {
            pc = 0x16821;
            break;
        }
        pc = 0x16833;
        break;
    case 0x16821:
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x15bc);
        r16[bx] = 0x001e;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x0014;
        memory16set(ds, 0x932e, r16[dx]);
    case 0x16833:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1683d;
            break;
        }
        pc = 0x16876;
        break;
    case 0x1683d:
        if (memory16get(ds, 0x97f2) == 0x00a6) {
            pc = 0x16848;
            break;
        }
        pc = 0x16876;
        break;
    case 0x16848:
        if (memory16gets(ds, 0x988e) > signed16(0x0060)) {
            pc = 0x16852;
            break;
        }
        pc = 0x16876;
        break;
    case 0x16852:
        if (memory16gets(ds, 0x988e) >= signed16(0x0081)) {
            pc = 0x16876;
            break;
        }
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x16876;
            break;
        }
        if (memory16get(ds, 0x932c) != 0x0000) {
            pc = 0x16876;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9330, r16[ax]);
        memory16set(ds, 0x932c, r16[ax]);
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x15bc);
    case 0x16876:
        if (memory16gets(ds, 0x988e) > signed16(0x0078)) {
            pc = 0x16880;
            break;
        }
        pc = 0x1689c;
        break;
    case 0x16880:
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - 0x0014);
        if (memory16get(ds, 0x9874) != 0x0000) {
            pc = 0x1689c;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1689c;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
    case 0x1689c:
        push(cs);
        yield* sub_1612b();
        push(cs);
        yield* sub_16213();
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x15bc);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x15bc);
        push(cs);
        yield* sub_15d4b();
        push(cs);
        yield* sub_1601f();
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x168f6;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x168f6;
            break;
        }
        push(cs);
        yield* sub_160df();
    case 0x168f6:
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x16901;
            break;
        }
        push(cs);
        yield* sub_162ac();
    case 0x16901:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x16911;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x16919;
        break;
    case 0x16911:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x16919:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x16927;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1692b;
            break;
        }
    case 0x16927:
        memory[ss*16 + bp - 5] = memory[ss*16 + bp - 5] ^ 0x01;
    case 0x1692b:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x15bc);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x15bc);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x15bc);
        sp += 0x0004;
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x16962;
            break;
        }
        memory16set(ds, 0x988e, 0x0006);
    case 0x16962:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x15bc);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x15bc);
        if (memory16get(ds, 0x932a) == 0x0110) {
            pc = 0x1697d;
            break;
        }
        pc = 0x16797;
        break;
    case 0x1697d:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x16797;
        break;
    case 0x16986:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x15bc);
        sp++;
        sp++;
        memory[ss*16 + bp - 5] = 0x00;
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x169a1;
            break;
        }
        pc = 0x16b91;
        break;
    case 0x169a1:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x15bc);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0090;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x15bc);
        sp += 0x000c;
        push(cs);
        yield* sub_15bc7();
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x15bc);
        r16[si] = 0;
        pc = 0x16b6c;
        break;
    case 0x169e0:
        if (r16[si] & 0x0001) {
            pc = 0x169e9;
            break;
        }
        pc = 0x16a6f;
        break;
    case 0x169e9:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        r16[ax] = 0x0011;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0034;
        push(r16[ax]);
        r16[ax] = 0x0011;
        push(r16[ax]);
        r16[ax] = 0x00e0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0035;
        push(r16[ax]);
        r16[ax] = 0x004f;
        push(r16[ax]);
        r16[ax] = 0x00a4;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0036;
        push(r16[ax]);
        r16[ax] = 0x004f;
        push(r16[ax]);
        r16[ax] = 0x00e4;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0x00a8;
        push(r16[ax]);
        r16[ax] = 0x0088;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        pc = 0x16af2;
        break;
    case 0x16a6f:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0037;
        push(r16[ax]);
        r16[ax] = 0x0011;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0038;
        push(r16[ax]);
        r16[ax] = 0x0011;
        push(r16[ax]);
        r16[ax] = 0x00e0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0039;
        push(r16[ax]);
        r16[ax] = 0x004f;
        push(r16[ax]);
        r16[ax] = 0x00a5;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x003a;
        push(r16[ax]);
        r16[ax] = 0x004f;
        push(r16[ax]);
        r16[ax] = 0x00e5;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0027;
        push(r16[ax]);
        r16[ax] = 0x00aa;
        push(r16[ax]);
        r16[ax] = 0x0088;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
    case 0x16af2:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x001d;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x15bc);
        sp += 0x000a;
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x16b1c;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x16b24;
        break;
    case 0x16b1c:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x16b24:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x16b32;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x16b36;
            break;
        }
    case 0x16b32:
        memory[ss*16 + bp - 5] = memory[ss*16 + bp - 5] ^ 0x01;
    case 0x16b36:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x15bc);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x15bc);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x15bc);
        sp += 0x0004;
        r16[ax] = 0x000f;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9cf();
        assert(cs == 0x15bc);
        sp++;
        sp++;
        r16[si]++;
    case 0x16b6c:
        if (r16[si] >= 0x0012) {
            pc = 0x16b74;
            break;
        }
        pc = 0x169e0;
        break;
    case 0x16b74:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x15bc);
        sp++;
        sp++;
        r16[ax] = 0x0002;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x15bc);
        sp += 0x0004;
    case 0x16b91:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_16b97() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        if (memory16get(ds, 0x9336) != 0x0000) {
            pc = 0x16c0b;
            break;
        }
        if (memory16get(ds, 0x9872) == 0x0002) {
            pc = 0x16c0b;
            break;
        }
        if (memory16get(ds, 0x9342) != 0x0000) {
            pc = 0x16bdc;
            break;
        }
        memory16set(ds, 0x933c, memory16get(ds, 0x933c) + 0x0006);
        if (memory16gets(ds, 0x933c) <= signed16(0x010e)) {
            pc = 0x16bfa;
            break;
        }
        if (memory16get(ds, 0x9872) == 0x0003) {
            pc = 0x16bfa;
            break;
        }
        memory16set(ds, 0x933c, 0x00f0);
        memory16set(ds, 0x9336, 0x0001);
        memory16set(ds, 0x9342, 0x0001);
        pc = 0x16bfa;
        break;
    case 0x16bdc:
        memory16set(ds, 0x933c, memory16get(ds, 0x933c) - 0x0006);
        if (memory16gets(ds, 0x933c) >= signed16(0xfff6)) {
            pc = 0x16bfa;
            break;
        }
        memory16set(ds, 0x933c, 0x000a);
        memory16set(ds, 0x9336, 0x0001);
        memory16set(ds, 0x9342, 0x0000);
    case 0x16bfa:
        memory16set(ds, 0x9334, memory16get(ds, 0x9334) + 1);
        if (memory16get(ds, 0x9334) != 0x0005) {
            pc = 0x16c0b;
            break;
        }
        memory16set(ds, 0x9334, 0x0000);
    case 0x16c0b:
        if (memory16get(ds, 0x9336) == 0x0000) {
            pc = 0x16c39;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0022;
        push(r16[ax]);
        push(memory16get(ds, 0x9332));
        push(memory16get(ds, 0x933c));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        memory16set(ds, 0x9336, memory16get(ds, 0x9336) + 1);
        memory16set(ds, 0x9336, memory16get(ds, 0x9336) & 0x0003);
        pc = 0x16d96;
        break;
    case 0x16c39:
        memory16set(ss, bp - 2, 0x0000);
        if (memory16gets(ds, 0x933c) <= signed16(0x0064)) {
            pc = 0x16c52;
            break;
        }
        if (memory16gets(ds, 0x933c) >= signed16(0x00aa)) {
            pc = 0x16c52;
            break;
        }
        r16[di] = 0x0020;
        pc = 0x16c5a;
        break;
    case 0x16c52:
        memory16set(ss, bp - 2, 0x0005);
        r16[di] = 0x0021;
    case 0x16c5a:
        r16[si] = memory16get(ds, 0x9334);
        r16[si] <<= 1;
        r16[si] <<= 1;
        r16[si] <<= 1;
        r16[ax] = memory16get(ds, 0x9334);
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[si] += r16[ax];
        if (memory16get(ds, 0x9342) != 0x0000) {
            pc = 0x16c88;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] += 0x1ec0;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        pc = 0x16c9a;
        break;
    case 0x16c88:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] += 0x1f38;
        r16[ax] = ds;
        es = r16[ax];
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
    case 0x16c9a:
        push(memory16get(ds, 0x9342));
        r16[bx] = memory16get(ss, bp - 6);
        es = memory16get(ss, bp - 6 + 2);
        push(memory16get(es, r16[bx] + 10));
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[ax] += memory16get(ds, 0x9332);
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += memory16get(ds, 0x933c);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        push(memory16get(ds, 0x9342));
        r16[bx] = memory16get(ss, bp - 6);
        es = memory16get(ss, bp - 6 + 2);
        push(memory16get(es, r16[bx] + 16));
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += memory16get(ds, 0x9332);
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += memory16get(ds, 0x933c);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        if (memory16get(ds, 0x933e) != 0x0000) {
            pc = 0x16d22;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x16d22;
            break;
        }
        push(memory16get(ds, 0x9342));
        r16[bx] = memory16get(ss, bp - 6);
        es = memory16get(ss, bp - 6 + 2);
        push(memory16get(es, r16[bx] + 22));
        r16[ax] = memory16get(es, r16[bx] + 20);
        r16[ax] += memory16get(ds, 0x9332);
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 18);
        r16[ax] += memory16get(ds, 0x933c);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        pc = 0x16d70;
        break;
    case 0x16d22:
        if (memory16get(ds, 0x9342) != 0x0000) {
            pc = 0x16d4b;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x001f;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9332);
        r16[ax] += 0x0009;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xffc9;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        pc = 0x16d6c;
        break;
    case 0x16d4b:
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x001f;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9332);
        r16[ax] += 0x0009;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0x0056;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
    case 0x16d6c:
        memory16set(ds, 0x933e, memory16get(ds, 0x933e) - 1);
    case 0x16d70:
        push(memory16get(ds, 0x9342));
        push(r16[di]);
        r16[ax] = memory16get(ds, 0x9332);
        r16[ax] += memory16get(ss, bp - 2);
        r16[bx] = memory16get(ss, bp - 6);
        es = memory16get(ss, bp - 6 + 2);
        r16[ax] += memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ds, 0x933c);
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
    case 0x16d96:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_16d9c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory16get(ds, 0x9340) != 0x0000) {
            pc = 0x16dd2;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x008b)) {
            pc = 0x16dd2;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x00a5)) {
            pc = 0x16dd2;
            break;
        }
        if (memory16get(ds, 0x97f2) != 0x00a6) {
            pc = 0x16dd2;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x16dd2;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9340, r16[ax]);
        memory16set(ds, 0x9868, r16[ax]);
        memory16set(ds, 0x97f4, 0x0028);
    case 0x16dd2:
        r16[si] = memory16get(ds, 0x9340);
        r16[si] <<= 1;
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 8112));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 8112));
        r16[ax] = 0x0096;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        if (memory16get(ds, 0x9340) == 0x0000) {
            pc = 0x16e11;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x000f);
        memory16set(ds, 0x9340, memory16get(ds, 0x9340) + 1);
        memory16set(ds, 0x9340, memory16get(ds, 0x9340) & 0x0003);
    case 0x16e11:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_16e13() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x97e0, 0x0011);
    memory16set(ds, 0x9872, 0x0000);
    r16[ax] = 0;
    memory16set(ds, 0x9c6e, r16[ax]);
    memory16set(ds, 0x9c68, prehistorikScreen);
    memory16set(ds, 0x9c6a, r16[ax]);
    memory16set(ds, 0x9874, 0x0027);
    memory16set(ds, 0x988e, 0x00d2);
    memory16set(ds, 0x97f2, 0xffd8);
    memory16set(ds, 0x9800, r16[ax]);
    memory16set(ds, 0x9892, r16[ax]);
    memory16set(ds, 0x97ea, r16[ax]);
    memory16set(ds, 0x9c62, r16[ax]);
    memory16set(ds, 0x9868, r16[ax]);
    memory16set(ds, 0x97e2, r16[ax]);
    memory16set(ds, 0x97f8, r16[ax]);
    memory16set(ds, 0x9862, r16[ax]);
    memory16set(ds, 0x97fa, r16[ax]);
    memory16set(ds, 0x9870, r16[ax]);
    memory16set(ds, 0x97e8, 0x002a);
    memory16set(ds, 0x9338, 0x013d);
    memory16set(ds, 0x933e, r16[ax]);
    memory16set(ds, 0x9336, r16[ax]);
    memory16set(ds, 0x9334, r16[ax]);
    memory16set(ds, 0x9342, r16[ax]);
    memory16set(ds, 0x9340, r16[ax]);
    memory16set(ds, 0x933c, 0x00b4);
    memory16set(ds, 0x9332, 0x0088);
    cs = pop();
}
function* sub_16e82() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1fc0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x16b9);
        sp += 0x000a;
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x16ebe;
            break;
        }
        memory[ds*16 + 0x91b9] = 0x20;
        memory[ds*16 + 0x8a6f] = 0x00;
        memory[ds*16 + 0x8e43] = 0x08;
    case 0x16ebe:
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1fc9;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x16b9);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9878, r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x16b9);
        r16[ax] = 0x001e;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x001f;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0020;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0021;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0023;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0024;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0025;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0026;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0027;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0029;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x002a;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x002b;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x002c;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = memory16get(ds, 0x9878);
        r16[ax] += 0x000d;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x16b9);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x16b9);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x16b9);
        sp += 0x000a;
        r16[ax] = 0x0004;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x16b9);
        sp += 0x0004;
        push(cs);
        yield* sub_16e13();
        memory[ss*16 + bp - 5] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x16b9);
        push(cs);
        cs = 0x15bc;
        yield* sub_15bc7();
        assert(cs == 0x16b9);
    case 0x16ff3:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x16ffd;
            break;
        }
        pc = 0x17232;
        break;
    case 0x16ffd:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x17007;
            break;
        }
        pc = 0x17232;
        break;
    case 0x17007:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x17011;
            break;
        }
        pc = 0x170de;
        break;
    case 0x17011:
        if (memory16gets(ds, 0x97f2) > signed16(0x0082)) {
            pc = 0x1701c;
            break;
        }
        pc = 0x170de;
        break;
    case 0x1701c:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x17026;
            break;
        }
        pc = 0x17053;
        break;
    case 0x17026:
        if (memory16get(ds, 0x9342) == 0x0000) {
            pc = 0x17030;
            break;
        }
        pc = 0x17053;
        break;
    case 0x17030:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x001e;
        r16[dx] = memory16get(ds, 0x933c);
        r16[dx] += 0xffb0;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x17053;
            break;
        }
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xffc9;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x17053;
            break;
        }
        memory16set(ds, 0x933e, 0x0006);
    case 0x17053:
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1705d;
            break;
        }
        pc = 0x1708a;
        break;
    case 0x1705d:
        if (memory16get(ds, 0x9342) != 0x0000) {
            pc = 0x17067;
            break;
        }
        pc = 0x1708a;
        break;
    case 0x17067:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x001e;
        r16[dx] = memory16get(ds, 0x933c);
        r16[dx] += 0x0069;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1708a;
            break;
        }
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0x0091;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1708a;
            break;
        }
        memory16set(ds, 0x933e, 0x0006);
    case 0x1708a:
        if (memory16get(ds, 0x933e) == 0x0006) {
            pc = 0x17094;
            break;
        }
        pc = 0x170de;
        break;
    case 0x17094:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x16b9);
        if (memory16get(ds, 0x9338) > 0x0110) {
            pc = 0x170a4;
            break;
        }
        pc = 0x170de;
        break;
    case 0x170a4:
        memory16set(ds, 0x9338, memory16get(ds, 0x9338) - 0x0002);
        if (memory16get(ds, 0x9338) < 0x0110) {
            pc = 0x170b4;
            break;
        }
        pc = 0x170ba;
        break;
    case 0x170b4:
        memory16set(ds, 0x9338, 0x0110);
    case 0x170ba:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9338));
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x16b9);
        sp += 0x000e;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x16b9);
    case 0x170de:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x170e8;
            break;
        }
        pc = 0x17142;
        break;
    case 0x170e8:
        if (memory16get(ds, 0x9874) == 0x0000) {
            pc = 0x170f2;
            break;
        }
        pc = 0x17142;
        break;
    case 0x170f2:
        if (memory16gets(ds, 0x97f2) > signed16(0x0082)) {
            pc = 0x170fd;
            break;
        }
        pc = 0x17142;
        break;
    case 0x170fd:
        if (memory16get(ds, 0x9342) == 0x0000) {
            pc = 0x17107;
            break;
        }
        pc = 0x17121;
        break;
    case 0x17107:
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xffb2;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x17142;
            break;
        }
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0x0032;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x17142;
            break;
        }
        pc = 0x17139;
        break;
    case 0x17121:
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xffe7;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x17142;
            break;
        }
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0x005a;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x17142;
            break;
        }
    case 0x17139:
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
    case 0x17142:
        push(cs);
        yield* sub_16b97();
        push(cs);
        yield* sub_16d9c();
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x16b9);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x16b9);
        push(cs);
        cs = 0x15bc;
        yield* sub_15d4b();
        assert(cs == 0x16b9);
        push(cs);
        cs = 0x15bc;
        yield* sub_1601f();
        assert(cs == 0x16b9);
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1719f;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x1719f;
            break;
        }
        push(cs);
        cs = 0x15bc;
        yield* sub_160df();
        assert(cs == 0x16b9);
    case 0x1719f:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x171af;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x171b7;
        break;
    case 0x171af:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x171b7:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x171c5;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x171c9;
            break;
        }
    case 0x171c5:
        memory[ss*16 + bp - 5] = memory[ss*16 + bp - 5] ^ 0x01;
    case 0x171c9:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x16b9);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x16b9);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x16b9);
        sp += 0x0004;
        if (memory16gets(ds, 0x988e) >= signed16(0x000a)) {
            pc = 0x17200;
            break;
        }
        memory16set(ds, 0x988e, 0x000a);
    case 0x17200:
        if (memory16gets(ds, 0x988e) <= signed16(0x0118)) {
            pc = 0x1720e;
            break;
        }
        memory16set(ds, 0x988e, 0x0118);
    case 0x1720e:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x16b9);
        if (memory16get(ds, 0x9338) == 0x0110) {
            pc = 0x17229;
            break;
        }
        pc = 0x16ff3;
        break;
    case 0x17229:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x16ff3;
        break;
    case 0x17232:
        if (memory16gets(ds, 0x988e) <= signed16(0x00dc)) {
            pc = 0x17240;
            break;
        }
        memory16set(ds, 0x988e, 0x00dc);
    case 0x17240:
        if (memory16gets(ds, 0x988e) >= signed16(0x0014)) {
            pc = 0x1724d;
            break;
        }
        memory16set(ds, 0x988e, 0x0014);
    case 0x1724d:
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x17257;
            break;
        }
        pc = 0x173b2;
        break;
    case 0x17257:
        memory16set(ds, 0x97f2, 0x00a6);
        memory16set(ds, 0x9800, 0x0000);
    case 0x17263:
        if (memory16get(ds, 0x9872) < 0x0064) {
            pc = 0x1726d;
            break;
        }
        pc = 0x17393;
        break;
    case 0x1726d:
        push(cs);
        yield* sub_16b97();
        if (memory16get(ds, 0x9872) != 0x0001) {
            pc = 0x1729d;
            break;
        }
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xffc4;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1729d;
            break;
        }
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xffec;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1729d;
            break;
        }
        if (memory16get(ds, 0x9342) != 0x0000) {
            pc = 0x1729d;
            break;
        }
        memory16set(ds, 0x9872, 0x0002);
    case 0x1729d:
        if (memory16get(ds, 0x9872) != 0x0001) {
            pc = 0x172be;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x001d;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
    case 0x172be:
        if (memory16get(ds, 0x9872) == 0x0002) {
            pc = 0x172c8;
            break;
        }
        pc = 0x172ff;
        break;
    case 0x172c8:
        if (memory16gets(ds, 0x97f2) > signed16(0x0077)) {
            pc = 0x172d2;
            break;
        }
        pc = 0x172f3;
        break;
    case 0x172d2:
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0008);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        pc = 0x172ff;
        break;
    case 0x172f3:
        memory16set(ds, 0x97f2, 0x0077);
        memory16set(ds, 0x9872, 0x0003);
    case 0x172ff:
        if (memory16get(ds, 0x9872) != 0x0003) {
            pc = 0x17331;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x003b;
        push(r16[ax]);
        r16[ax] = 0x0077;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x933c);
        r16[ax] += 0xfff4;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x16b9);
        sp += 0x000a;
        if (memory16gets(ds, 0x933c) <= signed16(0x0168)) {
            pc = 0x17331;
            break;
        }
        memory16set(ds, 0x9872, 0x0064);
    case 0x17331:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x17341;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x17349;
        break;
    case 0x17341:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x17349:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x17357;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1735b;
            break;
        }
    case 0x17357:
        memory[ss*16 + bp - 5] = memory[ss*16 + bp - 5] ^ 0x01;
    case 0x1735b:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x16b9);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x16b9);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x16b9);
        sp += 0x0004;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9cf();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        pc = 0x17263;
        break;
    case 0x17393:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x16b9);
        sp++;
        sp++;
        r16[ax] = 0x0004;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x16b9);
        sp += 0x0004;
        pc = 0x173bf;
        break;
    case 0x173b2:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x16b9);
        sp++;
        sp++;
    case 0x173bf:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_173c3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory16get(ds, 0x9352) != 0x0000) {
            pc = 0x173f7;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0063)) {
            pc = 0x173f7;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x007d)) {
            pc = 0x173f7;
            break;
        }
        if (memory16get(ds, 0x97f2) != 0x00a6) {
            pc = 0x173f7;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x173f7;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9352, r16[ax]);
        memory16set(ds, 0x9868, r16[ax]);
        memory16set(ds, 0x97f4, 0x0046);
    case 0x173f7:
        r16[si] = memory16get(ds, 0x9352);
        r16[si] <<= 1;
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 8148));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 8148));
        r16[ax] = 0x006e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x173c);
        sp += 0x000a;
        if (memory16get(ds, 0x9352) == 0x0000) {
            pc = 0x17436;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x000f);
        memory16set(ds, 0x9352, memory16get(ds, 0x9352) + 1);
        memory16set(ds, 0x9352, memory16get(ds, 0x9352) & 0x0003);
    case 0x17436:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_17438() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        memory16set(ds, 0x9348, memory16get(ds, 0x9348) + 1);
        memory16set(ds, 0x9348, memory16get(ds, 0x9348) & 0x001f);
        if (memory16get(ds, 0x9348) != 0x0000) {
            pc = 0x1744f;
            break;
        }
        memory16set(ds, 0x9348, 0x0007);
    case 0x1744f:
        if (memory16gets(ds, 0x9348) > signed16(0x000f)) {
            pc = 0x17459;
            break;
        }
        pc = 0x1755f;
        break;
    case 0x17459:
        if (memory16gets(ds, 0x9348) < signed16(0x0015)) {
            pc = 0x17463;
            break;
        }
        pc = 0x1755f;
        break;
    case 0x17463:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ds, 0x9348);
        r16[bx] += 0xfff0;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 8164);
        r16[ax] += memory16get(ds, 0x9896);
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4f43();
        assert(cs == 0x173c);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ds, 0x9348);
        r16[bx] += 0xfff0;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 8164);
        r16[ax] += memory16get(ds, 0x9896);
        r16[ax] += 0x0003;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x00d0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4f43();
        assert(cs == 0x173c);
        sp += 0x000c;
        push(cs);
        cs = 0x1829;
        yield* sub_184a6();
        assert(cs == 0x173c);
        if (memory16get(ds, 0x9348) != 0x0011) {
            pc = 0x1750b;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1750b;
            break;
        }
        if (memory16get(ds, 0x9874) != 0x0000) {
            pc = 0x1750b;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x00b4)) {
            pc = 0x174f3;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0078)) {
            pc = 0x174f3;
            break;
        }
        if (memory16gets(ds, 0x97f2) >= signed16(0x0028)) {
            pc = 0x174f3;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
    case 0x174f3:
        if (memory16gets(ds, 0x988e) <= signed16(0x0064)) {
            pc = 0x1750b;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0082)) {
            pc = 0x1750b;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
    case 0x1750b:
        if (memory16get(ds, 0x9348) == 0x0012) {
            pc = 0x17515;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17515:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x1751f;
            break;
        }
        pc = 0x17608;
        break;
    case 0x1751f:
        if (memory16get(ds, 0x9874) == 0x0000) {
            pc = 0x17529;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17529:
        if (memory16gets(ds, 0x97f2) > signed16(0x0078)) {
            pc = 0x17533;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17533:
        if (memory16gets(ds, 0x97f2) < signed16(0x0082)) {
            pc = 0x1753e;
            break;
        }
        pc = 0x17608;
        break;
    case 0x1753e:
        if (memory16gets(ds, 0x988e) > signed16(0x005c)) {
            pc = 0x17548;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17548:
        if (memory16gets(ds, 0x988e) < signed16(0x0096)) {
            pc = 0x17553;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17553:
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        pc = 0x17608;
        break;
    case 0x1755f:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x17569;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17569:
        if (memory16gets(ds, 0x97f2) < signed16(0x0032)) {
            pc = 0x17573;
            break;
        }
        pc = 0x17608;
        break;
    case 0x17573:
        if (memory16gets(ds, 0x988e) > signed16(0x00b6)) {
            pc = 0x1757e;
            break;
        }
        pc = 0x17608;
        break;
    case 0x1757e:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x173c);
        memory16set(ds, 0x9348, 0x0013);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4f43();
        assert(cs == 0x173c);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x00d0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4f43();
        assert(cs == 0x173c);
        sp += 0x000c;
        push(cs);
        cs = 0x1829;
        yield* sub_184a6();
        assert(cs == 0x173c);
        if (memory16get(ds, 0x934a) <= 0x0110) {
            pc = 0x17608;
            break;
        }
        memory16set(ds, 0x934a, memory16get(ds, 0x934a) - 0x0002);
        if (memory16get(ds, 0x934a) >= 0x0110) {
            pc = 0x175e4;
            break;
        }
        memory16set(ds, 0x934a, 0x0110);
    case 0x175e4:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x934a));
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x173c);
        sp += 0x000e;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x173c);
    case 0x17608:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_17609() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x97e0, 0x0011);
    memory16set(ds, 0x9872, 0x0000);
    r16[ax] = 0;
    memory16set(ds, 0x9c6e, r16[ax]);
    memory16set(ds, 0x9c68, prehistorikScreen);
    memory16set(ds, 0x9c6a, r16[ax]);
    memory16set(ds, 0x9874, 0x0027);
    memory16set(ds, 0x988e, 0x003c);
    memory16set(ds, 0x97f2, 0xffd8);
    memory16set(ds, 0x9800, r16[ax]);
    memory16set(ds, 0x9892, r16[ax]);
    memory16set(ds, 0x97ea, r16[ax]);
    memory16set(ds, 0x9c62, r16[ax]);
    memory16set(ds, 0x9868, r16[ax]);
    memory16set(ds, 0x97e2, r16[ax]);
    memory16set(ds, 0x97f8, r16[ax]);
    memory16set(ds, 0x9862, r16[ax]);
    memory16set(ds, 0x97fa, r16[ax]);
    memory16set(ds, 0x9870, r16[ax]);
    memory16set(ds, 0x97e8, 0x002a);
    memory16set(ds, 0x934a, 0x013d);
    memory16set(ds, 0x9350, r16[ax]);
    memory16set(ds, 0x9348, r16[ax]);
    memory16set(ds, 0x9346, r16[ax]);
    memory16set(ds, 0x9352, r16[ax]);
    memory16set(ds, 0x934e, 0x00b4);
    memory16set(ds, 0x9344, 0x0088);
    cs = pop();
}
function* sub_17675() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x173c);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1fee;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x173c);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x1ff7;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x173c);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9896, r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2001;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x173c);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2008;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]++;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x173c);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x200f;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x173c);
        sp += 0x0008;
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2016;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x173c);
        sp += 0x0008;
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0007;
        memory16set(ds, 0x9878, r16[ax]);
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x173c);
        sp++;
        sp++;
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x173c);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x173c);
        sp += 0x000a;
        memory16set(ds, 0x9348, 0x000f);
        push(cs);
        yield* sub_17438();
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x173c);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x173c);
        sp += 0x000a;
        r16[ax] = 0x0004;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x173c);
        sp += 0x0004;
        push(cs);
        yield* sub_17609();
        memory[ss*16 + bp - 5] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x173c);
        push(cs);
        cs = 0x15bc;
        yield* sub_15bc7();
        assert(cs == 0x173c);
    case 0x177a0:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x177aa;
            break;
        }
        pc = 0x178a4;
        break;
    case 0x177aa:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x177b4;
            break;
        }
        pc = 0x178a4;
        break;
    case 0x177b4:
        push(cs);
        yield* sub_173c3();
        push(cs);
        yield* sub_17438();
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x173c);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x173c);
        push(cs);
        cs = 0x15bc;
        yield* sub_15d4b();
        assert(cs == 0x173c);
        push(cs);
        cs = 0x15bc;
        yield* sub_1601f();
        assert(cs == 0x173c);
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x17811;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x17811;
            break;
        }
        push(cs);
        cs = 0x15bc;
        yield* sub_160df();
        assert(cs == 0x173c);
    case 0x17811:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x17821;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x17829;
        break;
    case 0x17821:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x17829:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x17837;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1783b;
            break;
        }
    case 0x17837:
        memory[ss*16 + bp - 5] = memory[ss*16 + bp - 5] ^ 0x01;
    case 0x1783b:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x173c);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x173c);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x173c);
        sp += 0x0004;
        if (memory16gets(ds, 0x988e) >= signed16(0x000a)) {
            pc = 0x17872;
            break;
        }
        memory16set(ds, 0x988e, 0x000a);
    case 0x17872:
        if (memory16gets(ds, 0x988e) <= signed16(0x0118)) {
            pc = 0x17880;
            break;
        }
        memory16set(ds, 0x988e, 0x0118);
    case 0x17880:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x173c);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x173c);
        if (memory16get(ds, 0x934a) == 0x0110) {
            pc = 0x1789b;
            break;
        }
        pc = 0x177a0;
        break;
    case 0x1789b:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x177a0;
        break;
    case 0x178a4:
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x178ae;
            break;
        }
        pc = 0x179ea;
        break;
    case 0x178ae:
        r16[si] = 0;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0002;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4f43();
        assert(cs == 0x173c);
        sp += 0x000c;
        push(cs);
        cs = 0x1829;
        yield* sub_184a6();
        assert(cs == 0x173c);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x0031;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x00d5;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x173c);
        sp += 0x000c;
    case 0x178f3:
        if (memory16get(ds, 0x9872) < 0x001e) {
            pc = 0x178fd;
            break;
        }
        pc = 0x179cb;
        break;
    case 0x178fd:
        if (memory16gets(ds, 0x97f2) >= signed16(0x00a0)) {
            pc = 0x17927;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0004);
        push(memory16get(ds, 0x9800));
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x173c);
        sp += 0x000a;
        pc = 0x17945;
        break;
    case 0x17927:
        memory16set(ds, 0x9872, memory16get(ds, 0x9872) + 1);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x001d;
        push(r16[ax]);
        r16[ax] = 0x00a7;
        push(r16[ax]);
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x173c);
        sp += 0x000a;
    case 0x17945:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x0034;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x00d0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x173c);
        sp += 0x000a;
        r16[si]++;
        if (r16[si] != 0x0004) {
            pc = 0x17969;
            break;
        }
        r16[si] = 0;
    case 0x17969:
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x17979;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x17981;
        break;
    case 0x17979:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x17981:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x1798f;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x17993;
            break;
        }
    case 0x1798f:
        memory[ss*16 + bp - 5] = memory[ss*16 + bp - 5] ^ 0x01;
    case 0x17993:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x173c);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x173c);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x173c);
        sp += 0x0004;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9cf();
        assert(cs == 0x173c);
        sp++;
        sp++;
        pc = 0x178f3;
        break;
    case 0x179cb:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x173c);
        sp++;
        sp++;
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x173c);
        sp += 0x0004;
        pc = 0x179f7;
        break;
    case 0x179ea:
        r8[al] = memory[ss*16 + bp - 5];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x173c);
        sp++;
        sp++;
    case 0x179f7:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_179fc() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x179f);
        sp += 0x000a;
        r16[si] = 0;
        pc = 0x17a25;
        break;
    case 0x17a1c:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[si]] = 0x00;
        r16[si]++;
    case 0x17a25:
        if (r16[si] < 0x1f40) {
            pc = 0x17a1c;
            break;
        }
        if (memory16get(ss, bp + 18) <= 0x0009) {
            pc = 0x17aa0;
            break;
        }
        if (memory16get(ss, bp + 18) >= 0x000d) {
            pc = 0x17aa0;
            break;
        }
        r16[si] = 0;
        pc = 0x17a98;
        break;
    case 0x17a3b:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = 0x004f;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x179f);
        sp += 0x000c;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001f;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x179f);
        sp += 0x000c;
        r16[ax] = 0x004f;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0x001d;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19eac();
        assert(cs == 0x179f);
        sp += 0x0006;
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0x001f;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19eac();
        assert(cs == 0x179f);
        sp += 0x0006;
        r16[si] += 0x0040;
    case 0x17a98:
        if (r16[si] <= 0x0140) {
            pc = 0x17a3b;
            break;
        }
        pc = 0x17ad4;
        break;
    case 0x17aa0:
        r16[si] = 0x0009;
        pc = 0x17ace;
        break;
    case 0x17aa5:
        r16[di] = 0;
        pc = 0x17ac5;
        break;
    case 0x17aa9:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0013;
        push(r16[ax]);
        push(r16[si]);
        push(r16[di]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x179f);
        sp += 0x000c;
        r16[di] += 0x0040;
    case 0x17ac5:
        if (r16[di] <= 0x0140) {
            pc = 0x17aa9;
            break;
        }
        r16[si] += 0x003f;
    case 0x17ace:
        if (r16[si] <= 0x00c8) {
            pc = 0x17aa5;
            break;
        }
    case 0x17ad4:
        r16[di] = 0;
        if (memory16get(ss, bp + 18) == r16[di]) {
            pc = 0x17af4;
            break;
        }
        r16[si] = r16[di];
        pc = 0x17aef;
        break;
    case 0x17adf:
        r16[ax] = r16[si];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[di] += r16[ax];
        r16[di]++;
        r16[si]++;
    case 0x17aef:
        if (r16[si] < memory16get(ss, bp + 18)) {
            pc = 0x17adf;
            break;
        }
    case 0x17af4:
        r16[ax] = r16[di];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[si] = 0;
        pc = 0x17b7b;
        break;
    case 0x17b01:
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 2, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 2, sar16(memory16get(ss, bp - 2), r8[cl]));
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) << r8[cl]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ds, 0x9896);
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x179f);
        sp += 0x000c;
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        push(memory16get(ss, bp - 2));
        r16[ax] = r16[di];
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19eac();
        assert(cs == 0x179f);
        sp += 0x0006;
        r16[di] += 0x0003;
        r16[si]++;
    case 0x17b7b:
        r16[ax] = memory16get(ss, bp + 18);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        if (r16[ax] < r16[si]) {
            pc = 0x17b8f;
            break;
        }
        pc = 0x17b01;
        break;
    case 0x17b8f:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_17b95() {
    //CStackGuardFar sg(0, false);
    memory16set(ds, 0x97e0, 0x0011);
    memory16set(ds, 0x9872, 0x0000);
    r16[ax] = 0;
    memory16set(ds, 0x9c6e, r16[ax]);
    memory16set(ds, 0x9c68, prehistorikScreen);
    memory16set(ds, 0x9c6a, r16[ax]);
    memory16set(ds, 0x9874, 0x0028);
    memory16set(ds, 0x988e, 0x005f);
    memory16set(ds, 0x97f2, 0x000a);
    memory16set(ds, 0x9800, r16[ax]);
    memory16set(ds, 0x97e2, r16[ax]);
    memory16set(ds, 0x9892, r16[ax]);
    memory16set(ds, 0x97ea, r16[ax]);
    memory16set(ds, 0x9c62, r16[ax]);
    memory16set(ds, 0x9868, r16[ax]);
    memory16set(ds, 0x97f4, 0x0014);
    memory16set(ds, 0x989c, r16[ax]);
    memory16set(ds, 0x97e8, r16[ax]);
    memory16set(ds, 0x97f8, r16[ax]);
    memory16set(ds, 0x9862, r16[ax]);
    memory16set(ds, 0x97fa, r16[ax]);
    memory16set(ds, 0x9870, r16[ax]);
    memory16set(ds, 0x9c66, 0x0063);
    memory16set(ds, 0x985a, r16[ax]);
    memory16set(ds, 0x9880, r16[ax]);
    memory16set(ds, 0x989a, 0x000a);
    cs = pop();
}
function* sub_17bfb() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        memory[ss*16 + bp - 6] = 0x00;
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19382();
        assert(cs == 0x179f);
        sp++;
        sp++;
        r16[ax] = 0x1f40;
        push(r16[ax]);
        push(cs);
        cs = 0x1f23;
        yield* sub_1f231();
        assert(cs == 0x179f);
        sp++;
        sp++;
        memory16set(ds, 0x987c, r16[dx]);
        memory16set(ds, 0x987a, r16[ax]);
        memory16set(ds, 0x9c6c, 0x0007);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2044;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x179f);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x8bd6);
        memory16set(ds, 0x988a, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x204e;
        push(r16[ax]);
        push(memory16get(ds, 0x988a));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x179f);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x988a);
        memory16set(ds, 0x9896, r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18293();
        assert(cs == 0x179f);
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2058;
        push(r16[ax]);
        push(memory16get(ds, 0x9896));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x179f);
        sp += 0x0008;
        r16[ax] += memory16get(ds, 0x9896);
        memory16set(ds, 0x9882, r16[ax]);
        memory16set(ds, 0x9878, r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x179f);
        sp++;
        sp++;
        r16[ax] = 0x0031;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x179f);
        sp++;
        sp++;
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x179f);
        sp++;
        sp++;
        r16[ax] = 0x0037;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18d9b();
        assert(cs == 0x179f);
        sp++;
        sp++;
        r16[ax] = memory16get(ds, 0x9878);
        r16[ax] += 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_1946a();
        assert(cs == 0x179f);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x2063;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e49();
        assert(cs == 0x179f);
        sp += 0x0004;
        push(cs);
        yield* sub_17b95();
        push(ds);
        r16[ax] = 0x74fc;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x179f);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x179f);
        sp += 0x0004;
        push(ds);
        r16[ax] = 0x29e2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a10b();
        assert(cs == 0x179f);
        sp += 0x0004;
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x179f);
        sp += 0x0004;
    case 0x17d07:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x17d11;
            break;
        }
        pc = 0x18256;
        break;
    case 0x17d11:
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x17d1b;
            break;
        }
        pc = 0x18256;
        break;
    case 0x17d1b:
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x179f);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x17d44;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x5e5e;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x5e36;
        push(r16[ax]);
        push(cs);
        yield* sub_179fc();
        sp += 0x000a;
        pc = 0x17d52;
        break;
    case 0x17d44:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a03f();
        assert(cs == 0x179f);
        sp++;
        sp++;
    case 0x17d52:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x17d6c;
            break;
        }
        push(memory16get(ds, 0x9c68));
        push(ds);
        r16[ax] = 0x74fc;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x179f);
        sp += 0x0006;
        pc = 0x17d80;
        break;
    case 0x17d6c:
        r16[ax] = memory16get(ds, 0x9c68);
        r16[ax] += 0xff9c;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2950;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x179f);
        sp += 0x0006;
    case 0x17d80:
        if (memory16get(ds, 0x9c68) >= 0x0064) {
            pc = 0x17d9a;
            break;
        }
        r16[bx] = memory16get(ds, 0x9c68);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 8222));
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x179f);
        sp++;
        sp++;
        pc = 0x17da5;
        break;
    case 0x17d9a:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x179f);
        sp++;
        sp++;
    case 0x17da5:
        push(cs);
        cs = 0x19e4;
        yield* sub_1a4da();
        assert(cs == 0x179f);
        memory[ss*16 + bp - 7] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x179f);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x179f);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x179f);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x179f);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b341();
        assert(cs == 0x179f);
        r16[si] = 0;
        pc = 0x17de0;
        break;
    case 0x17dd1:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, 0x0000);
        r16[si]++;
    case 0x17de0:
        if (r16[si] < 0x000a) {
            pc = 0x17dd1;
            break;
        }
        memory16set(ds, 0x97e4, 0x0000);
        memory16set(ds, 0x9894, 0x0000);
        memory16set(ds, 0x97e6, 0x0000);
        memory16set(ds, 0x987e, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x179f);
    case 0x17e02:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x17e0c;
            break;
        }
        pc = 0x181ec;
        break;
    case 0x17e0c:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x17e16;
            break;
        }
        pc = 0x181ec;
        break;
    case 0x17e16:
        r16[ax] = memory16get(ds, 0x985a);
        memory16set(ds, 0x985a, memory16get(ds, 0x985a) + 1);
        if (r16[ax] <= 0x003c) {
            pc = 0x17e53;
            break;
        }
        if (memory16get(ds, 0x9c66) == 0x0000) {
            pc = 0x17e2f;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) - 1);
        pc = 0x17e48;
        break;
    case 0x17e2f:
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x17e48;
            break;
        }
        memory16set(ds, 0x9874, 0x0000);
        memory16set(ds, 0x9870, 0x0001);
        memory16set(ds, 0x97fa, 0x0001);
    case 0x17e48:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x179f);
        memory16set(ds, 0x985a, 0x0000);
    case 0x17e53:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b0b7();
        assert(cs == 0x179f);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a5d8();
        assert(cs == 0x179f);
        memory16set(ds, 0x97e6, 0x0000);
        push(cs);
        cs = 0x1bf1;
        yield* sub_1bf13();
        assert(cs == 0x179f);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a6df();
        assert(cs == 0x179f);
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x179f);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x179f);
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x17eb0;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b991();
        assert(cs == 0x179f);
    case 0x17eb0:
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x17f1d;
            break;
        }
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x17ec2;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1bdb2();
        assert(cs == 0x179f);
    case 0x17ec2:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x17edb;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x17edb;
            break;
        }
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x17edb;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b107();
        assert(cs == 0x179f);
    case 0x17edb:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x17f1d;
            break;
        }
        if (memory16get(ds, 0x9880) >= 0x002d) {
            pc = 0x17f1d;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0053;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x006e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x179f);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005c;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x00ad;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x179f);
        sp += 0x000a;
    case 0x17f1d:
        if (memory[ss*16 + bp - 7] != 0x00) {
            pc = 0x17f2d;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x17f35;
        break;
    case 0x17f2d:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x17f35:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x17f43;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x17f47;
            break;
        }
    case 0x17f43:
        memory[ss*16 + bp - 7] = memory[ss*16 + bp - 7] ^ 0x01;
    case 0x17f47:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x179f);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x179f);
        sp += 0x0004;
        if (memory[ss*16 + bp - 6] != 0x00) {
            pc = 0x17f83;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x179f);
        sp += 0x000a;
        memory[ss*16 + bp - 6] = 0x01;
    case 0x17f83:
        if (memory[ss*16 + bp - 5] == 0x00) {
            pc = 0x17fc5;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x17f97;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x17fc5;
            break;
        }
    case 0x17f97:
        if (memory[ss*16 + bp - 5] != 0x01) {
            pc = 0x17fa2;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e3e9();
        assert(cs == 0x179f);
    case 0x17fa2:
        if (memory[ss*16 + bp - 5] != 0x02) {
            pc = 0x17fad;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e59e();
        assert(cs == 0x179f);
    case 0x17fad:
        if (memory[ss*16 + bp - 5] != 0x03) {
            pc = 0x17fb8;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e32a();
        assert(cs == 0x179f);
    case 0x17fb8:
        if (memory[ss*16 + bp - 5] != 0x04) {
            pc = 0x17fd3;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1e4a4();
        assert(cs == 0x179f);
        pc = 0x17fd3;
        break;
    case 0x17fc5:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x179f);
        sp += 0x0004;
    case 0x17fd3:
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x179f);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x179f);
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x17ff1;
            break;
        }
        pc = 0x17e02;
        break;
    case 0x17ff1:
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x17ffb;
            break;
        }
        pc = 0x17e02;
        break;
    case 0x17ffb:
        if (memory16gets(ds, 0x988e) >= signed16(0x0000)) {
            pc = 0x18008;
            break;
        }
        memory16set(ds, 0x988e, 0x0000);
    case 0x18008:
        if (memory16gets(ds, 0x988e) <= signed16(0x012c)) {
            pc = 0x18016;
            break;
        }
        memory16set(ds, 0x988e, 0x012c);
    case 0x18016:
        if (memory16gets(ds, 0x97f2) <= signed16(0x00b4)) {
            pc = 0x1802e;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1802e;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ds, 0x9870, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
    case 0x1802e:
        if (memory16get(ds, 0x9c68) < 0x0064) {
            pc = 0x18038;
            break;
        }
        pc = 0x181d5;
        break;
    case 0x18038:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x1804d;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0132)) {
            pc = 0x1804d;
            break;
        }
        memory16set(ds, 0x988e, 0x0132);
    case 0x1804d:
        if (memory16get(ds, 0x9c68) != 0x0012) {
            pc = 0x18093;
            break;
        }
        if (memory16get(ds, 0x9860) == 0x0000) {
            pc = 0x18093;
            break;
        }
        if (memory16get(ds, 0x9880) <= 0x002c) {
            pc = 0x18093;
            break;
        }
        if (memory16get(ds, 0x987e) != 0x0000) {
            pc = 0x18093;
            break;
        }
        if (memory16get(ds, 0x9802) == 0x0000) {
            pc = 0x18093;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x00eb)) {
            pc = 0x18093;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x00f5)) {
            pc = 0x18093;
            break;
        }
        if (memory16get(ds, 0x97f2) != 0x007f) {
            pc = 0x18093;
            break;
        }
        memory16set(ds, 0x987e, 0x0fa1);
        memory16set(ds, 0x988e, 0x00f0);
    case 0x18093:
        if (memory16get(ds, 0x9c68) != 0x000d) {
            pc = 0x180a7;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x000f)) {
            pc = 0x180a7;
            break;
        }
        memory16set(ds, 0x988e, 0x000f);
    case 0x180a7:
        if (memory16get(ds, 0x9c68) != 0x0005) {
            pc = 0x180bc;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0109)) {
            pc = 0x180bc;
            break;
        }
        memory16set(ds, 0x988e, 0x0109);
    case 0x180bc:
        if (memory16get(ds, 0x9c68) != 0x0005) {
            pc = 0x180df;
            break;
        }
        if (memory16gets(ds, 0x97f2) <= signed16(0x00a0)) {
            pc = 0x180df;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x97f2, 0xfff6);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x03;
    case 0x180df:
        if (memory16get(ds, 0x9c68) != 0x0006) {
            pc = 0x1811d;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x001e)) {
            pc = 0x180f3;
            break;
        }
        memory16set(ds, 0x988e, 0x001e);
    case 0x180f3:
        if (memory16gets(ds, 0x988e) <= signed16(0x0109)) {
            pc = 0x18101;
            break;
        }
        memory16set(ds, 0x988e, 0x0109);
    case 0x18101:
        if (memory16gets(ds, 0x97f2) <= signed16(0x00a0)) {
            pc = 0x1811d;
            break;
        }
        memory16set(ds, 0x97f2, 0x0000);
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x03;
    case 0x1811d:
        if (memory16get(ds, 0x9c68) != 0x0007) {
            pc = 0x18131;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x000f)) {
            pc = 0x18131;
            break;
        }
        memory16set(ds, 0x988e, 0x000f);
    case 0x18131:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x18146;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0109)) {
            pc = 0x18146;
            break;
        }
        memory16set(ds, 0x988e, 0x0109);
    case 0x18146:
        if (memory16get(ds, 0x9c68) != 0x000a) {
            pc = 0x1815a;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0007)) {
            pc = 0x1815a;
            break;
        }
        memory16set(ds, 0x988e, 0x0007);
    case 0x1815a:
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x1818a;
            break;
        }
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x1818a;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0000) {
            pc = 0x1818a;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x1818a;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) - 1);
        memory16set(ds, 0x988e, 0x011d);
        memory16set(ds, 0x9872, 0x0001);
        memory[ss*16 + bp - 5] = 0x02;
    case 0x1818a:
        if (memory16gets(ds, 0x988e) <= signed16(0x0127)) {
            pc = 0x181d5;
            break;
        }
        if (memory16get(ds, 0x9c68) == 0x0012) {
            pc = 0x181d5;
            break;
        }
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x181d5;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x181b0;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0010);
    case 0x181b0:
        memory16set(ds, 0x988e, 0x0006);
        memory16set(ds, 0x9872, 0x0001);
        if (memory16get(ds, 0x9c68) != 0x000d) {
            pc = 0x181d1;
            break;
        }
        memory16set(ds, 0x988e, 0x0030);
        memory16set(ds, 0x97f2, 0x0082);
        pc = 0x181d5;
        break;
    case 0x181d1:
        memory[ss*16 + bp - 5] = 0x01;
    case 0x181d5:
        r16[ax] = memory16get(ds, 0x987e);
        r16[ax] &= 0x0003;
        if (r16[ax] == 0x0003) {
            pc = 0x181e3;
            break;
        }
        pc = 0x17e02;
        break;
    case 0x181e3:
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x17e02;
        break;
    case 0x181ec:
        r8[al] = memory[ss*16 + bp - 7];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x179f);
        sp++;
        sp++;
        if (memory16get(ds, 0x987e) & 0x0003) {
            pc = 0x18204;
            break;
        }
        pc = 0x17d07;
        break;
    case 0x18204:
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) >> 1);
        if (memory16get(ds, 0x987e) != 0x03e8) {
            pc = 0x18217;
            break;
        }
        pc = 0x1822e;
        break;
    case 0x18217:
        push(memory16get(ds, 0x987e));
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x1946;
        yield* sub_19aa5();
        assert(cs == 0x179f);
        sp += 0x0004;
        memory[ss*16 + bp - 6] = 0x00;
        pc = 0x17d07;
        break;
    case 0x1822e:
        if (memory16get(ds, 0x9c68) != 0x0009) {
            pc = 0x18245;
            break;
        }
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        memory16set(ds, 0x988e, 0x000a);
        memory16set(ds, 0x97f2, 0x0083);
    case 0x18245:
        if (memory16get(ds, 0x9c68) == 0x0012) {
            pc = 0x1824f;
            break;
        }
        pc = 0x17d07;
        break;
    case 0x1824f:
        memory16set(ds, 0x9c68, memory16get(ds, 0x9c68) + 1);
        pc = 0x17d07;
        break;
    case 0x18256:
        memory16set(ds, 0x989c, 0x0000);
        push(memory16get(ds, 0x987c));
        push(memory16get(ds, 0x987a));
        push(cs);
        cs = 0x1f01;
        yield* sub_1f01d();
        assert(cs == 0x179f);
        sp += 0x0004;
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x179f);
        sp++;
        sp++;
        if (memory16get(ds, 0x9c68) != 0x0013) {
            pc = 0x1828e;
            break;
        }
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x01f4;
        push(r16[ax]);
        push(cs);
        cs = 0x18f7;
        yield* sub_19124();
        assert(cs == 0x179f);
        sp += 0x0004;
    case 0x1828e:
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18293() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d069();
        assert(cs == 0x1829);
        r16[si] = 0;
        pc = 0x182a9;
        break;
    case 0x1829e:
        memory[ds*16 + r16[si] + 38574] = 0x00;
        memory[ds*16 + r16[si] + 38196] = 0x00;
        r16[si]++;
    case 0x182a9:
        if (r16[si] < 0x0100) {
            pc = 0x1829e;
            break;
        }
        r16[si] = 0;
        pc = 0x182bb;
        break;
    case 0x182b3:
        memory[ds*16 + r16[si] + 37756] = 0x00;
        r16[si] += 0x0005;
    case 0x182bb:
        if (r16[si] < 0x0190) {
            pc = 0x182b3;
            break;
        }
        memory16set(ds, 0x9684, 0x0000);
        memory16set(ds, 0x206e, 0x0000);
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_182d0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = 0;
    case 0x182d6:
        if (memory[ds*16 + r16[si] + 37756] == 0x00) {
            pc = 0x182e2;
            break;
        }
        r16[si] += 0x0005;
        pc = 0x182d6;
        break;
    case 0x182e2:
        r8[al] = memory[ss*16 + bp + 8];
        memory[ds*16 + r16[si] + 37756] = r8[al];
        r8[al] = memory[ss*16 + bp + 10];
        r16[bx] = r16[si];
        r16[bx]++;
        memory[ds*16 + r16[bx] + 37756] = r8[al];
        r8[al] = memory[ss*16 + bp + 12];
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        memory[ds*16 + r16[bx] + 37756] = r8[al];
        r8[al] = memory[ss*16 + bp + 14];
        r16[bx] = r16[si];
        r16[bx] += 0x0003;
        memory[ds*16 + r16[bx] + 37756] = r8[al];
        r8[al] = memory[ss*16 + bp + 16];
        r16[bx] = r16[si];
        r16[bx] += 0x0004;
        memory[ds*16 + r16[bx] + 37756] = r8[al];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1831a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x18328;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x18356;
            break;
        }
    case 0x18328:
        r16[ax] = 0x00c8;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
        r16[ax] = 0x00c8;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18356:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x18364;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1837b;
            break;
        }
    case 0x18364:
        r16[ax] = 0x00c8;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x1837b:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18399;
            break;
        }
        r16[ax] = 0x00c8;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18399:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1839a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x183a8;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x183d6;
            break;
        }
    case 0x183a8:
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x183d6:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x183e4;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x183fb;
            break;
        }
    case 0x183e4:
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x183fb:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18419;
            break;
        }
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18419:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1841a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x18428;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1845c;
            break;
        }
    case 0x18428:
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x1845c:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1846a;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x18484;
            break;
        }
    case 0x1846a:
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0x0050;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18484:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x184a5;
            break;
        }
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x184a5:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_184a6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x184b4;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x184ea;
            break;
        }
    case 0x184b4:
        r16[ax] = 0x00c0;
        push(r16[ax]);
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
        r16[ax] = 0x00c0;
        push(r16[ax]);
        r16[ax] = 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x184ea:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x184f8;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x18513;
            break;
        }
    case 0x184f8:
        r16[ax] = 0x00c0;
        push(r16[ax]);
        r16[ax] = 0x003c;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x0014;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18513:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18535;
            break;
        }
        r16[ax] = 0x00c0;
        push(r16[ax]);
        r16[ax] = 0x0078;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18535:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_185ef() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx] + 10);
    es = memory16get(es, r16[tx] + 10 + 2);
    memory16set(ss, bp - 4, es);
    memory16set(ss, bp - 6, r16[bx]);
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    r16[si] = memory16get(es, r16[bx] + 14);
    r16[ax] = r16[si];
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] += r16[si];
    r16[si] = r16[ax];
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    r16[bx] += r16[ax];
    r8[al] = memory[es*16 + r16[bx] + 2];
    memory[ss*16 + bp - 1] = r8[al];
    push(memory16get(ss, bp - 6));
    r16[ax] = memory16get(ss, bp - 4);
    push(r16[ax]);
    push(r16[si]);
    r8[al] = memory[ss*16 + bp - 1];
    r8[ah] = 0x00;
    push(r16[ax]);
    push(cs);
    cs = 0x0cc2;
    yield* sub_d113();
    assert(cs == 0x1829);
    sp += 0x0008;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1865c() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx] + 10);
    es = memory16get(es, r16[tx] + 10 + 2);
    memory16set(ss, bp - 4, es);
    memory16set(ss, bp - 6, r16[bx]);
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    r16[si] = memory16get(es, r16[bx] + 14);
    r16[si] <<= 1;
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    r16[bx] += r16[ax];
    r8[al] = memory[es*16 + r16[bx] + 2];
    memory[ss*16 + bp - 1] = r8[al];
    push(memory16get(ss, bp - 6));
    r16[ax] = memory16get(ss, bp - 4);
    push(r16[ax]);
    push(r16[si]);
    r8[al] = memory[ss*16 + bp - 1];
    r8[ah] = 0x00;
    push(r16[ax]);
    push(cs);
    cs = 0x0cc2;
    yield* sub_d191();
    assert(cs == 0x1829);
    sp += 0x0008;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_186c1() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x0006;
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    r16[tx] = r16[bx];
    r16[bx] = memory16get(es, r16[tx] + 10);
    es = memory16get(es, r16[tx] + 10 + 2);
    memory16set(ss, bp - 4, es);
    memory16set(ss, bp - 6, r16[bx]);
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    es = memory16get(ds, 0x8da2 + 2);
    r16[bx] += r16[ax];
    r16[si] = memory16get(es, r16[bx] + 14);
    r16[si] <<= 1;
    r16[ax] = memory16get(ss, bp + 10);
    r16[dx] = 0x0014;
    mul16(r16[dx]);
    r16[bx] = memory16get(ds, 0x8da2);
    r16[bx] += r16[ax];
    r8[al] = memory[es*16 + r16[bx] + 2];
    memory[ss*16 + bp - 1] = r8[al];
    push(memory16get(ss, bp - 6));
    r16[ax] = memory16get(ss, bp - 4);
    push(r16[ax]);
    push(r16[si]);
    r8[al] = memory[ss*16 + bp - 1];
    r8[ah] = 0x00;
    push(r16[ax]);
    push(cs);
    cs = 0x0cc2;
    yield* sub_d1f7();
    assert(cs == 0x1829);
    sp += 0x0008;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_18726() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        r16[bx] = memory16get(ds, 0x8e20);
        es = memory16get(ds, 0x8e20 + 2);
        memory16set(ss, bp - 12, es);
        memory16set(ss, bp - 14, r16[bx]);
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx]);
        es = memory16get(es, r16[tx] + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
        r16[di] = 0;
        pc = 0x188f7;
        break;
    case 0x18749:
        if (memory[ds*16 + r16[di] + 37756] != 0x00) {
            pc = 0x18753;
            break;
        }
        pc = 0x188f4;
        break;
    case 0x18753:
        r16[bx] = r16[di];
        r16[bx] += 0x0003;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        memory16set(ss, bp - 4, r16[ax]);
        r16[bx] = r16[di];
        r16[bx]++;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x187ca;
            break;
        }
        if (memory[ds*16 + r16[di] + 37756] != 0x02) {
            pc = 0x187ca;
            break;
        }
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[dx] = 0x0028;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        r16[si] += memory16get(ss, bp - 2);
        r16[bx] = r16[di];
        r16[bx] += 0x0004;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[dx]);
        r16[dx] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[dx]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d4ec();
        assert(cs == 0x1829);
        sp += 0x000c;
        memory[ds*16 + r16[di] + 37756] = 0x00;
    case 0x187ca:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x187db;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x187db;
            break;
        }
        pc = 0x18861;
        break;
    case 0x187db:
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] = sar16(r16[ax], 1);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        if (memory16get(ss, bp - 6) == 0x0000) {
            pc = 0x1880a;
            break;
        }
        r16[si] += 0x2000;
    case 0x1880a:
        if (!(memory16get(ss, bp - 2) & 0x0001)) {
            pc = 0x1881c;
            break;
        }
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax]--;
        r16[si] += r16[ax];
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        pc = 0x1881f;
        break;
    case 0x1881c:
        r16[si] += memory16get(ss, bp - 2);
    case 0x1881f:
        if (!(memory16get(ss, bp - 4) & 0x0001)) {
            pc = 0x18829;
            break;
        }
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x18829:
        push(memory16get(ss, bp - 6));
        r16[bx] = r16[di];
        r16[bx] += 0x0004;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[dx]);
        r16[dx] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[dx]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c6ac();
        assert(cs == 0x1829);
        sp += 0x000e;
    case 0x18861:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x1886b;
            break;
        }
        pc = 0x188f0;
        break;
    case 0x1886b:
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 6, r16[ax]);
        r16[si] = r16[ax];
        r16[cx] = 0x000d;
        r16[si] <<= r8[cl];
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[si] += r16[ax];
        if (!(memory16get(ss, bp - 2) & 0x0001)) {
            pc = 0x188ab;
            break;
        }
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax]--;
        r16[si] += r16[ax];
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        pc = 0x188ae;
        break;
    case 0x188ab:
        r16[si] += memory16get(ss, bp - 2);
    case 0x188ae:
        if (!(memory16get(ss, bp - 4) & 0x0001)) {
            pc = 0x188b8;
            break;
        }
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x188b8:
        push(memory16get(ss, bp - 6));
        r16[bx] = r16[di];
        r16[bx] += 0x0004;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[dx]);
        r16[dx] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[dx]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e680();
        assert(cs == 0x1829);
        sp += 0x000e;
    case 0x188f0:
        memory[ds*16 + r16[di] + 37756] = memory[ds*16 + r16[di] + 37756] << 1;
    case 0x188f4:
        r16[di] += 0x0005;
    case 0x188f7:
        if (r16[di] >= 0x0190) {
            pc = 0x18900;
            break;
        }
        pc = 0x18749;
        break;
    case 0x18900:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18906() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x1891c;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1892d;
            break;
        }
    case 0x1891c:
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x023f;
        yield* sub_2dbc();
        assert(cs == 0x1829);
        sp += 0x0004;
        pc = 0x18ae2;
        break;
    case 0x1892d:
        r16[bx] = memory16get(ds, 0x8b70);
        es = memory16get(ds, 0x8b70 + 2);
        memory16set(ss, bp - 12, es);
        memory16set(ss, bp - 14, r16[bx]);
        r16[bx] = memory16get(ds, 0x8bfa);
        es = memory16get(ds, 0x8bfa + 2);
        memory16set(ss, bp - 8, es);
        memory16set(ss, bp - 10, r16[bx]);
        r16[di] = 0;
        pc = 0x18ad9;
        break;
    case 0x18946:
        if (memory[ds*16 + r16[di] + 37756] != 0x00) {
            pc = 0x18950;
            break;
        }
        pc = 0x18ad6;
        break;
    case 0x18950:
        r16[bx] = r16[di];
        r16[bx] += 0x0003;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        memory16set(ss, bp - 4, r16[ax]);
        r16[bx] = r16[di];
        r16[bx]++;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        memory16set(ss, bp - 2, r16[ax]);
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1897b;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x1897b;
            break;
        }
        pc = 0x18a42;
        break;
    case 0x1897b:
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] &= 0x0001;
        memory16set(ss, bp - 6, r16[ax]);
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] = sar16(r16[ax], 1);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        if (memory16get(ss, bp - 6) == 0x0000) {
            pc = 0x189aa;
            break;
        }
        r16[si] += 0x2000;
    case 0x189aa:
        if (!(memory16get(ss, bp - 2) & 0x0001)) {
            pc = 0x189bc;
            break;
        }
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax]--;
        r16[si] += r16[ax];
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        pc = 0x189bf;
        break;
    case 0x189bc:
        r16[si] += memory16get(ss, bp - 2);
    case 0x189bf:
        if (!(memory16get(ss, bp - 4) & 0x0001)) {
            pc = 0x189c9;
            break;
        }
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x189c9:
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x18a0a;
            break;
        }
        push(memory16get(ss, bp - 6));
        r16[bx] = r16[di];
        r16[bx] += 0x0004;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[dx]);
        r16[dx] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[dx]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c6ac();
        assert(cs == 0x1829);
        sp += 0x000e;
        pc = 0x18a42;
        break;
    case 0x18a0a:
        push(memory16get(ss, bp - 6));
        r16[bx] = r16[di];
        r16[bx] += 0x0004;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[dx]);
        r16[dx] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[dx]);
        push(cs);
        cs = 0x0ba1;
        yield* sub_c707();
        assert(cs == 0x1829);
        sp += 0x000e;
    case 0x18a42:
        if (memory[ds*16 + 0x8bf0] != 0x00) {
            pc = 0x18a4c;
            break;
        }
        pc = 0x18ad1;
        break;
    case 0x18a4c:
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 6, r16[ax]);
        r16[si] = r16[ax];
        r16[cx] = 0x000d;
        r16[si] <<= r8[cl];
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[dx] = 0x00a0;
        mul16(r16[dx]);
        r16[si] += r16[ax];
        if (!(memory16get(ss, bp - 2) & 0x0001)) {
            pc = 0x18a8c;
            break;
        }
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax]--;
        r16[si] += r16[ax];
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        pc = 0x18a8f;
        break;
    case 0x18a8c:
        r16[si] += memory16get(ss, bp - 2);
    case 0x18a8f:
        if (!(memory16get(ss, bp - 4) & 0x0001)) {
            pc = 0x18a99;
            break;
        }
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x18a99:
        push(memory16get(ss, bp - 6));
        r16[bx] = r16[di];
        r16[bx] += 0x0004;
        r8[al] = memory[ds*16 + r16[bx] + 37756];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[dx] = memory16get(ss, bp - 8);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 10);
        r16[ax] += r16[si];
        push(r16[dx]);
        r16[dx] = memory16get(ss, bp - 12);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 14);
        r16[ax] += r16[si];
        push(r16[dx]);
        push(cs);
        cs = 0x0e11;
        yield* sub_e680();
        assert(cs == 0x1829);
        sp += 0x000e;
    case 0x18ad1:
        memory[ds*16 + r16[di] + 37756] = memory[ds*16 + r16[di] + 37756] & 0x01;
    case 0x18ad6:
        r16[di] += 0x0005;
    case 0x18ad9:
        if (r16[di] >= 0x0190) {
            pc = 0x18ae2;
            break;
        }
        pc = 0x18946;
        break;
    case 0x18ae2:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18ae8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[si] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[di] = memory16get(es, r16[bx] + 14);
        r16[di]++;
        if (memory16gets(ss, bp + 12) <= signed16(0x00c7)) {
            pc = 0x18b24;
            break;
        }
        pc = 0x18bbb;
        break;
    case 0x18b24:
        if (signed16(r16[si]) <= signed16(0x013f)) {
            pc = 0x18b2d;
            break;
        }
        pc = 0x18bbb;
        break;
    case 0x18b2d:
        if (signed16(r16[si]) >= 0) {
            pc = 0x18b33;
            break;
        }
        r16[si] = 0;
    case 0x18b33:
        if (memory16gets(ss, bp + 12) >= signed16(0x0000)) {
            pc = 0x18b3e;
            break;
        }
        memory16set(ss, bp + 12, 0x0000);
    case 0x18b3e:
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] += memory16get(ss, bp - 2);
        if (r16[ax] <= 0x00c8) {
            pc = 0x18b52;
            break;
        }
        r16[ax] = 0x00c8;
        r16[ax] -= memory16get(ss, bp + 12);
        memory16set(ss, bp - 2, r16[ax]);
    case 0x18b52:
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x18b6f;
            break;
        }
        r16[si] = sar16(r16[si], 1);
        r16[si] = sar16(r16[si], 1);
        r16[si] = sar16(r16[si], 1);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        if (r16s[ax] <= signed16(0x0028)) {
            pc = 0x18ba8;
            break;
        }
        r16[di] = 0x0028;
        r16[di] -= r16[si];
        pc = 0x18ba8;
        break;
    case 0x18b6f:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x18b7d;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x18b91;
            break;
        }
    case 0x18b7d:
        r16[si] = sar16(r16[si], 1);
        r16[si] = sar16(r16[si], 1);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        if (r16s[ax] <= signed16(0x0050)) {
            pc = 0x18ba8;
            break;
        }
        r16[di] = 0x0050;
        r16[di] -= r16[si];
        pc = 0x18ba8;
        break;
    case 0x18b91:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18bbb;
            break;
        }
        r16[si] = sar16(r16[si], 1);
        r16[ax] = r16[si];
        r16[ax] += r16[di];
        if (r16s[ax] <= signed16(0x00a0)) {
            pc = 0x18ba8;
            break;
        }
        r16[di] = 0x00a0;
        r16[di] -= r16[si];
    case 0x18ba8:
        push(memory16get(ss, bp - 2));
        push(r16[di]);
        push(memory16get(ss, bp + 12));
        push(r16[si]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_182d0();
        sp += 0x000a;
    case 0x18bbb:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18bc1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        if (memory16get(ds, 0x9c6c) != 0x0003) {
            pc = 0x18bd5;
            break;
        }
        r16[si] = 0x000d;
        r16[di] = 0x000f;
        pc = 0x18bdb;
        break;
    case 0x18bd5:
        r16[si] = 0x0001;
        r16[di] = 0x0003;
    case 0x18bdb:
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]--;
        r16[si] += r16[ax];
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]--;
        r16[di] += r16[ax];
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1829);
        sp = bp;
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[di]);
        push(memory16get(ss, bp + 12));
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] += 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1829);
        sp = bp;
        push(r16[si]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_18ae8();
        sp = bp;
        push(r16[di]);
        push(memory16get(ss, bp + 12));
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] += 0x0010;
        push(r16[ax]);
        push(cs);
        yield* sub_18ae8();
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18c3b() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[bx] = memory16get(ds, 0x206e);
    r16[bx] <<= 1;
    memory16set(ds, r16[bx] + 37716, 0x0001);
    r16[ax] = memory16get(ss, bp + 8);
    r16[bx] = memory16get(ds, 0x206e);
    r16[bx] <<= 1;
    memory16set(ds, r16[bx] + 38492, r16[ax]);
    r16[ax] = memory16get(ss, bp + 10);
    r16[bx] = memory16get(ds, 0x206e);
    r16[bx] <<= 1;
    memory16set(ds, r16[bx] + 38452, r16[ax]);
    r16[ax] = memory16get(ss, bp + 12);
    r16[ax]--;
    r16[bx] = memory16get(ds, 0x206e);
    r16[bx] <<= 1;
    memory16set(ds, r16[bx] + 38156, r16[ax]);
    r16[ax] = memory16get(ss, bp + 14);
    r16[bx] = memory16get(ds, 0x206e);
    r16[bx] <<= 1;
    memory16set(ds, r16[bx] + 38534, r16[ax]);
    memory16set(ds, 0x206e, memory16get(ds, 0x206e) + 1);
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_18c85() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[si] = 0;
        pc = 0x18d86;
        break;
    case 0x18c91:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[di] = memory16get(ds, r16[bx] + 38156);
        if (r16[di] != 0x03e7) {
            pc = 0x18cbf;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38452));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38492));
        push(cs);
        yield* sub_18bc1();
        sp += 0x0008;
        pc = 0x18d85;
        break;
    case 0x18cbf:
        if (memory[ds*16 + r16[di] + 38574] == 0x00) {
            pc = 0x18ce1;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        if (memory16get(ds, r16[bx] + 38534) == 0x0000) {
            pc = 0x18d3f;
            break;
        }
        r8[al] = memory[ds*16 + r16[di] + 38574];
        r8[ah] = 0x00;
        r16[ax] += memory16get(ds, 0x9878);
        r16[ax]--;
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0x18d47;
        break;
    case 0x18ce1:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 38534);
        r8[dl] = memory[ds*16 + r16[di] + 38196];
        r8[dh] = 0x00;
        if (r16[ax] == r16[dx]) {
            pc = 0x18d3f;
            break;
        }
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x18d06;
            break;
        }
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        yield* sub_185ef();
        sp++;
        sp++;
    case 0x18d06:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x18d14;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x18d20;
            break;
        }
    case 0x18d14:
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        yield* sub_1865c();
        sp++;
        sp++;
    case 0x18d20:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18d33;
            break;
        }
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        yield* sub_186c1();
        sp++;
        sp++;
    case 0x18d33:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r8[al] = memory[ds*16 + r16[bx] + 38534];
        memory[ds*16 + r16[di] + 38196] = r8[al];
    case 0x18d3f:
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += r16[di];
        memory16set(ss, bp - 2, r16[ax]);
    case 0x18d47:
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38452));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38492));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1829);
        sp += 0x000c;
        push(memory16get(ss, bp - 2));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38452));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38492));
        push(cs);
        yield* sub_18ae8();
        sp += 0x0006;
    case 0x18d85:
        r16[si]++;
    case 0x18d86:
        if (r16[si] >= memory16get(ds, 0x206e)) {
            pc = 0x18d8f;
            break;
        }
        pc = 0x18c91;
        break;
    case 0x18d8f:
        memory16set(ds, 0x206e, 0x0000);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18d9b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001c;
        r16[ax] = memory16get(ds, 0x9878);
        r16[ax] += memory16get(ds, 0x9684);
        memory16set(ss, bp - 20, r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += memory16get(ss, bp + 10);
        r16[ax]--;
        memory16set(ss, bp - 18, r16[ax]);
        r16[ax] = memory16get(ss, bp - 20);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ss, bp - 26, r16[dx]);
        memory16set(ss, bp - 28, r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(ss, bp - 18);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 14);
        mul16(r16[si]);
        r16[si] = r16[ax];
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x18e11;
            break;
        }
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x18e11;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18e13;
            break;
        }
    case 0x18e11:
        r16[si] <<= 1;
    case 0x18e13:
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x18e23;
            break;
        }
        r16[ax] = r16[si];
        r16[dx] = 0x0005;
        mul16(r16[dx]);
        r16[si] = r16[ax];
    case 0x18e23:
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 26));
        push(memory16get(ss, bp - 28));
        push(cs);
        cs = 0x01ed;
        yield* sub_204c();
        assert(cs == 0x1829);
        memory16set(ss, bp - 24, r16[ax]);
        r16[dx] = 0;
        r16[ax] = 0xfa00;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ss, bp - 26));
        push(memory16get(ss, bp - 28));
        push(cs);
        cs = 0x01ed;
        yield* sub_2044();
        assert(cs == 0x1829);
        memory16set(ss, bp - 22, r16[ax]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_7bd0();
        assert(cs == 0x1829);
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x18e78;
            break;
        }
        memory16set(ss, bp - 24, memory16get(ss, bp - 24) + 1);
        memory16set(ss, bp - 22, 0x0000);
        r16[ax] = memory16get(ss, bp - 24);
        r16[dx] = 0;
        r16[cx] = 0;
        r16[bx] = 0xfa00;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x1829);
        memory16set(ss, bp - 26, r16[dx]);
        memory16set(ss, bp - 28, r16[ax]);
    case 0x18e78:
        r16[bx] = memory16get(ss, bp - 24);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[tx] = r16[bx];
        r16[bx] = memory16get(ds, r16[tx] + 35374);
        es = memory16get(ds, r16[tx] + 35374 + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[ax] = memory16get(ss, bp - 22);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 10);
        es = memory16get(es, r16[tx] + 10 + 2);
        memory16set(ss, bp - 14, es);
        memory16set(ss, bp - 16, r16[bx]);
        r16[di] = 0;
        pc = 0x18ebe;
        break;
    case 0x18eab:
        r16[bx] = memory16get(ss, bp - 16);
        es = memory16get(ss, bp - 16 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 16, memory16get(ss, bp - 16) + 1);
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 1);
        r16[di]++;
    case 0x18ebe:
        if (r16[di] < r16[si]) {
            pc = 0x18eab;
            break;
        }
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) - r16[si]);
        r16[ax] = r16[si];
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ss, bp - 28)) >= 0x10000;
        r16[ax] += memory16get(ss, bp - 28);
        r16[dx] += memory16get(ss, bp - 26) + flags.carry;
        memory16set(ss, bp - 26, r16[dx]);
        memory16set(ss, bp - 28, r16[ax]);
        r16[ax] = memory16get(ss, bp - 18);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[ax] = memory16get(ss, bp - 20);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        r16[bx] += r16[ax];
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        push(es);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        push(es);
        push(r16[bx]);
        r16[cx] = 0x0014;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x1829);
        r16[dx] = memory16get(ss, bp - 26);
        r16[ax] = memory16get(ss, bp - 28);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 8, r16[dx]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        memory16set(es, r16[bx] + 12, r16[dx]);
        memory16set(es, r16[bx] + 10, r16[ax]);
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x18f3b;
            break;
        }
        push(memory16get(ss, bp - 20));
        push(cs);
        yield* sub_185ef();
        sp++;
        sp++;
    case 0x18f3b:
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x18f49;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x18f52;
            break;
        }
    case 0x18f49:
        push(memory16get(ss, bp - 20));
        push(cs);
        yield* sub_1865c();
        sp++;
        sp++;
    case 0x18f52:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x18f62;
            break;
        }
        push(memory16get(ss, bp - 20));
        push(cs);
        yield* sub_186c1();
        sp++;
        sp++;
    case 0x18f62:
        r8[al] = memory[ds*16 + 0x9684];
        r8[al]++;
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx]--;
        memory[ds*16 + r16[bx] + 38574] = r8[al];
        memory16set(ds, 0x9684, memory16get(ds, 0x9684) + 1);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18f79() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        if (memory[ds*16 + 0x8c58] != 0x00) {
            pc = 0x18f93;
            break;
        }
        memory16set(ss, bp - 2, 0xb800);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x18f9d;
        break;
    case 0x18f93:
        memory16set(ss, bp - 2, 0xb000);
        memory16set(ss, bp - 4, 0x0000);
    case 0x18f9d:
        r16[si] = 0;
        pc = 0x18fae;
        break;
    case 0x18fa1:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        videoSet16(es, r16[bx], 0x0000);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0002);
        r16[si]++;
    case 0x18fae:
        if (signed16(r16[si]) < signed16(0x07d0)) {
            pc = 0x18fa1;
            break;
        }
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_18fb9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x18fdc;
            break;
        }
        memory16set(ss, bp + 10, 0x0007);
        memory16set(ss, bp + 12, 0x0000);
        memory16set(ss, bp - 2, 0xb000);
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x18fe6;
        break;
    case 0x18fdc:
        memory16set(ss, bp - 2, 0xb800);
        memory16set(ss, bp - 4, 0x0000);
    case 0x18fe6:
        r8[al] = memory[ss*16 + bp + 12];
        r16[cx] = 0x0004;
        r8[al] <<= r8[cl];
        r8[al] |= memory[ss*16 + bp + 10];
        r8[dl] = memory[ss*16 + bp + 14];
        r16[cx] = 0x0007;
        r8[dl] <<= r8[cl];
        r8[al] |= r8[dl];
        r8[al] |= 0x08;
        memory[ss*16 + bp - 6] = r8[al];
        r16[ax] = memory16get(ss, bp + 8);
        r16[dx] = 0x0050;
        mul16(r16[dx]);
        r16[ax] += memory16get(ss, bp + 6);
        r16[ax] <<= 1;
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + r16[ax]);
    case 0x19011:
        r16[bx] = memory16get(ss, bp + 16);
        es = memory16get(ss, bp + 16 + 2);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 5] = r8[al];
        if (!r8[al]) {
            pc = 0x1903b;
            break;
        }
        r8[al] = memory[ss*16 + bp - 5];
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        videoSet(es, r16[bx], r8[al]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        r8[al] = memory[ss*16 + bp - 6];
        r16[bx] = memory16get(ss, bp - 4);
        videoSet(es, r16[bx], r8[al]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
        memory16set(ss, bp + 16, memory16get(ss, bp + 16) + 1);
        pc = 0x19011;
        break;
    case 0x1903b:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1903f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = 0;
    case 0x19045:
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory16set(ss, bp + 8, memory16get(ss, bp + 8) + 1);
        if (memory[es*16 + r16[bx]] == 0x00) {
            pc = 0x19054;
            break;
        }
        r16[si]++;
        pc = 0x19045;
        break;
    case 0x19054:
        r16[ax] = r16[si];
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19059() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    push(memory16get(ss, bp + 12));
    push(memory16get(ss, bp + 10));
    push(cs);
    yield* sub_1903f();
    sp += 0x0004;
    r16[si] = r16[ax];
    r16[di] = 0x0028;
    r16[ax] = r16[si];
    r16[ax] >>= 1;
    r16[di] -= r16[ax];
    memory16set(ss, bp - 4, 0x000f);
    memory16set(ss, bp - 2, 0x0000);
    push(memory16get(ss, bp + 12));
    push(memory16get(ss, bp + 10));
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ss, bp - 2));
    push(memory16get(ss, bp - 4));
    push(memory16get(ss, bp + 14));
    push(r16[di]);
    push(cs);
    yield* sub_18fb9();
    sp += 0x000e;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_190a3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0014;
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(ss);
        r16[ax] = bp - 0x14;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6a15();
        assert(cs == 0x18f7);
        sp += 0x0008;
        push(ss);
        r16[ax] = bp - 0x14;
        push(r16[ax]);
        push(cs);
        yield* sub_1903f();
        sp += 0x0004;
        r16[di] = r16[ax];
        r16[si] = 0;
        pc = 0x190e1;
        break;
    case 0x190d0:
        r8[al] = memory[ss*16 + bp + 18];
        r16[dx] = r16[si];
        r16[dx] += 0x0008;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[si]++;
    case 0x190e1:
        r16[ax] = 0x0006;
        r16[ax] -= r16[di];
        if (r16[ax] > r16[si]) {
            pc = 0x190d0;
            break;
        }
        r16[si] = 0;
        pc = 0x19105;
        break;
    case 0x190ee:
        r8[al] = memory[ss*16 + bp + r16[si] + 65516];
        r16[dx] = 0x0006;
        r16[dx] -= r16[di];
        r16[dx] += r16[si];
        r16[dx] += 0x0008;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[dx];
        memory[es*16 + r16[bx]] = r8[al];
        r16[si]++;
    case 0x19105:
        if (r16[si] < r16[di]) {
            pc = 0x190ee;
            break;
        }
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(memory16get(ss, bp + 20));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        yield* sub_19059();
        sp += 0x000a;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19124() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[di] = memory16get(ss, bp + 10);
        if (!(memory16get(ss, bp + 12) & 0x0001)) {
            pc = 0x1913a;
            break;
        }
        memory16set(ds, 0x9c5e, memory16get(ds, 0x9c5e) + 1);
    case 0x1913a:
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x18f7);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x18f7);
        sp++;
        sp++;
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x19162;
            break;
        }
        push(ds);
        r16[ax] = 0x7cae;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x18f7);
        sp += 0x0006;
        pc = 0x19172;
        break;
    case 0x19162:
        push(ds);
        r16[ax] = 0x7cb8;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x18f7);
        sp += 0x0006;
    case 0x19172:
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x18f7);
        sp += 0x0004;
        r16[si] = memory16get(ds, 0x9c5e);
        r16[bx] = memory16get(ds, 0x7c30);
        es = memory16get(ds, 0x7c30 + 2);
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        r8[al] = memory[ss*16 + bp + 12];
        r8[al] += 0x30;
        memory[es*16 + r16[bx] + 6] = r8[al];
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x191b2;
            break;
        }
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x18f7);
        sp++;
        sp++;
        push(cs);
        cs = 0x023f;
        yield* sub_23fc();
        assert(cs == 0x18f7);
        pc = 0x191bd;
        break;
    case 0x191b2:
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x18f7);
        sp++;
        sp++;
    case 0x191bd:
        push(cs);
        yield* sub_18f79();
        memory[ss*16 + bp - 1] = 0x20;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(memory16get(ds, 0x7c32));
        push(memory16get(ds, 0x7c30));
        push(cs);
        yield* sub_19059();
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(memory16get(ds, 0x7c36));
        push(memory16get(ds, 0x7c34));
        push(cs);
        yield* sub_19059();
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        push(memory16get(ds, 0x7c3a));
        push(memory16get(ds, 0x7c38));
        push(cs);
        yield* sub_19059();
        sp += 0x000a;
        r16[ax] = 0x000c;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 1];
        cbw();
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ds, 0x7c3e));
        push(memory16get(ds, 0x7c3c));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        r16[ax] = 0x000f;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 1];
        cbw();
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ds, 0x7c42));
        push(memory16get(ds, 0x7c40));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        r16[ax] = 0x0012;
        push(r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(memory16get(ds, 0x9888));
        push(memory16get(ds, 0x9886));
        push(memory16get(ds, 0x7c46));
        push(memory16get(ds, 0x7c44));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a99a();
        assert(cs == 0x18f7);
        sp++;
        sp++;
    case 0x19273:
        if (!r16[di]) {
            pc = 0x192d2;
            break;
        }
        r16[di] -= 0x0002;
        r16[dx] = memory16get(ds, 0x9888);
        r16[ax] = memory16get(ds, 0x9886);
        flags.carry = (r16[ax] + 0x0014) >= 0x10000;
        r16[ax] += 0x0014;
        r16[dx] += flags.carry;
        memory16set(ds, 0x9888, r16[dx]);
        memory16set(ds, 0x9886, r16[ax]);
        r16[ax] = 0x000c;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 1];
        cbw();
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[dx] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ds, 0x7c3e));
        push(memory16get(ds, 0x7c3c));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        r16[ax] = 0x0012;
        push(r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(memory16get(ds, 0x9888));
        push(memory16get(ds, 0x9886));
        push(memory16get(ds, 0x7c46));
        push(memory16get(ds, 0x7c44));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        push(cs);
        cs = 0x023f;
        yield* sub_2445();
        assert(cs == 0x18f7);
        pc = 0x19273;
        break;
    case 0x192d2:
        if (!r16[si]) {
            pc = 0x1932f;
            break;
        }
        r16[si]--;
        r16[dx] = memory16get(ds, 0x9888);
        r16[ax] = memory16get(ds, 0x9886);
        flags.carry = (r16[ax] + 0x03e8) >= 0x10000;
        r16[ax] += 0x03e8;
        r16[dx] += flags.carry;
        memory16set(ds, 0x9888, r16[dx]);
        memory16set(ds, 0x9886, r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        r8[al] = memory[ss*16 + bp - 1];
        cbw();
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[dx] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(memory16get(ds, 0x7c42));
        push(memory16get(ds, 0x7c40));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        r16[ax] = 0x0012;
        push(r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(memory16get(ds, 0x9888));
        push(memory16get(ds, 0x9886));
        push(memory16get(ds, 0x7c46));
        push(memory16get(ds, 0x7c44));
        push(cs);
        yield* sub_190a3();
        sp += 0x000c;
        push(cs);
        cs = 0x023f;
        yield* sub_2445();
        assert(cs == 0x18f7);
        pc = 0x192d2;
        break;
    case 0x1932f:
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a99a();
        assert(cs == 0x18f7);
        sp++;
        sp++;
        if (memory[ds*16 + 0x919d] == 0x00) {
            pc = 0x1934c;
            break;
        }
        r16[ax] = 0x000d;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x18f7);
        sp++;
        sp++;
    case 0x1934c:
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x1935e;
            break;
        }
        r16[ax] = 0x0009;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x18f7);
        sp++;
        sp++;
    case 0x1935e:
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1936a;
            break;
        }
        push(cs);
        cs = 0x0ee7;
        yield* sub_10a05();
        assert(cs == 0x18f7);
    case 0x1936a:
        if (memory[ds*16 + 0x8a2c] == 0x00) {
            pc = 0x1937c;
            break;
        }
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e28();
        assert(cs == 0x18f7);
        sp++;
        sp++;
    case 0x1937c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19382() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    sp -= 0x0004;
    r8[al] = memory[ss*16 + bp + 10];
    r8[al] += 0x30;
    r16[bx] = memory16get(ds, 0x7c4c);
    es = memory16get(ds, 0x7c4c + 2);
    memory[es*16 + r16[bx] + 20] = r8[al];
    push(ds);
    r16[ax] = 0x8b70;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(cs);
    cs = 0x023f;
    yield* sub_402c();
    assert(cs == 0x18f7);
    sp += 0x0006;
    r16[si] = 0x000b;
    memory16set(ss, bp - 2, 0x000f);
    push(memory16get(ds, 0x7c4a));
    push(memory16get(ds, 0x7c48));
    push(cs);
    yield* sub_1903f();
    sp += 0x0004;
    r16[di] = r16[ax];
    r16[di] <<= 1;
    r16[di] <<= 1;
    r16[di] <<= 1;
    r16[ax] = 0x00a0;
    r16[dx] = r16[di];
    r16[dx] >>= 1;
    r16[ax] -= r16[dx];
    memory16set(ss, bp - 4, r16[ax]);
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] += 0x0008;
    push(ds);
    r16[ax] = 0x8b70;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ss, bp - 2));
    push(memory16get(ds, 0x7c4a));
    push(memory16get(ds, 0x7c48));
    push(r16[si]);
    push(memory16get(ss, bp - 4));
    push(cs);
    cs = 0x060b;
    yield* sub_6410();
    assert(cs == 0x18f7);
    sp += 0x0010;
    r16[si] = 0x000d;
    memory16set(ss, bp - 2, 0x000f);
    push(memory16get(ds, 0x7c4e));
    push(memory16get(ds, 0x7c4c));
    push(cs);
    yield* sub_1903f();
    sp += 0x0004;
    r16[di] = r16[ax];
    r16[di] <<= 1;
    r16[di] <<= 1;
    r16[di] <<= 1;
    r16[ax] = 0x00a0;
    r16[dx] = r16[di];
    r16[dx] >>= 1;
    r16[ax] -= r16[dx];
    memory16set(ss, bp - 4, r16[ax]);
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] <<= 1;
    r16[si] += 0x0008;
    push(ds);
    r16[ax] = 0x8b70;
    push(r16[ax]);
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ss, bp - 2));
    push(memory16get(ds, 0x7c4e));
    push(memory16get(ds, 0x7c4c));
    push(r16[si]);
    push(memory16get(ss, bp - 4));
    push(cs);
    cs = 0x060b;
    yield* sub_6410();
    assert(cs == 0x18f7);
    sp += 0x0010;
    r16[ax] = 0x0002;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x8bfa;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x8b70;
    push(r16[ax]);
    push(cs);
    cs = 0x023f;
    yield* sub_3e59();
    assert(cs == 0x18f7);
    sp += 0x000a;
    sp = bp;
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1946a() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1946f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x19499;
        break;
    case 0x19477:
        r8[al] = memory[ds*16 + r16[di] + 37300];
        r16[bx] = r16[si];
        memory[ds*16 + r16[bx] + 38830] = r8[al];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[di] + 35434];
        r16[bx] = r16[si];
        memory[ds*16 + r16[bx] + 38830] = r8[al];
        r16[si]++;
        r8[al] = memory[ds*16 + r16[di] + 36414];
        r16[bx] = r16[si];
        memory[ds*16 + r16[bx] + 38830] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x19499:
        if (r16[di] < 0x0010) {
            pc = 0x19477;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_194a1() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x194cb;
        break;
    case 0x194a9:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 38830];
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 38830];
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 38830];
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x194cb:
        if (r16[di] < 0x0010) {
            pc = 0x194a9;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_194d3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x1950f;
        break;
    case 0x194db:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32074];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32074];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32074];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x1950f:
        if (r16[di] < 0x0010) {
            pc = 0x194db;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_19517() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x19553;
        break;
    case 0x1951f:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32122];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32122];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32122];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x19553:
        if (r16[di] < 0x0010) {
            pc = 0x1951f;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_1955b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x19597;
        break;
    case 0x19563:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32170];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32170];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32170];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x19597:
        if (r16[di] < 0x0010) {
            pc = 0x19563;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_1959f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x195db;
        break;
    case 0x195a7:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32218];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32218];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32218];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x195db:
        if (r16[di] < 0x0010) {
            pc = 0x195a7;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_195e3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x1961f;
        break;
    case 0x195eb:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32266];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32266];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32266];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x1961f:
        if (r16[di] < 0x0010) {
            pc = 0x195eb;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_19627() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(r16[si]);
        push(r16[di]);
        r16[si] = 0;
        r16[di] = r16[si];
        pc = 0x19663;
        break;
    case 0x1962f:
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32314];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 37300] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32314];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 35434] = r8[al];
        r16[si]++;
        r16[bx] = r16[si];
        r8[al] = memory[ds*16 + r16[bx] + 32314];
        r8[al] <<= 1;
        r8[al] <<= 1;
        r8[al] <<= 1;
        memory[ds*16 + r16[di] + 36414] = r8[al];
        r16[si]++;
        r16[di]++;
    case 0x19663:
        if (r16[di] < 0x0010) {
            pc = 0x1962f;
            break;
        }
        r16[di] = pop();
        r16[si] = pop();
        cs = pop();
        return;
    } while (1);
}
function* sub_1966b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x196d4;
            break;
        }
        push(cs);
        yield* sub_1946f();
        memory16set(ss, bp - 2, 0x0000);
        pc = 0x196c0;
        break;
    case 0x19684:
        if (!(memory16get(ss, bp - 2) & 0x0001)) {
            pc = 0x19690;
            break;
        }
        r16[di] = 0x003f;
        pc = 0x19692;
        break;
    case 0x19690:
        r16[di] = 0;
    case 0x19692:
        r16[si] = 0;
        pc = 0x196a9;
        break;
    case 0x19696:
        r16[ax] = r16[di];
        memory[ds*16 + r16[si] + 36414] = r8[al];
        memory[ds*16 + r16[si] + 35434] = r8[al];
        memory[ds*16 + r16[si] + 37300] = r8[al];
        r16[di] ^= 0x003f;
        r16[si]++;
    case 0x196a9:
        if (r16[si] < 0x0010) {
            pc = 0x19696;
            break;
        }
        memory[ds*16 + 0x8de6] = 0x00;
        push(cs);
        cs = 0x023f;
        yield* sub_2af9();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x023f;
        yield* sub_2445();
        assert(cs == 0x1946);
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) + 1);
    case 0x196c0:
        if (memory16get(ss, bp - 2) < 0x0014) {
            pc = 0x19684;
            break;
        }
        memory[ds*16 + 0x8de6] = 0x00;
        push(cs);
        yield* sub_194a1();
        push(cs);
        cs = 0x023f;
        yield* sub_2af9();
        assert(cs == 0x1946);
    case 0x196d4:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_196da() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1946);
        sp = bp;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1946);
        sp = bp;
        r16[di] = 0;
        pc = 0x1971e;
        break;
    case 0x19715:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[di]] = 0x00;
        r16[di]++;
    case 0x1971e:
        if (r16[di] < 0x1f40) {
            pc = 0x19715;
            break;
        }
        r16[si] = 0xffe0;
        pc = 0x19745;
        break;
    case 0x19729:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9882);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        r16[si] += 0x0040;
    case 0x19745:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 31976);
        if (r16s[ax] > signed16(r16[si])) {
            pc = 0x19729;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        r16[si] = 0;
        pc = 0x1977b;
        break;
    case 0x1976e:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e7b();
        assert(cs == 0x1946);
        sp = bp;
        r16[si]++;
    case 0x1977b:
        if (signed16(r16[si]) < signed16(0x0140)) {
            pc = 0x1976e;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 31976);
        r16[ax] += 0xfff8;
        memory16set(ds, 0x985c, r16[ax]);
        memory16set(ds, 0x986c, 0x0028);
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1979a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1946);
        sp = bp;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1946);
        sp = bp;
        r16[di] = 0;
        pc = 0x197de;
        break;
    case 0x197d5:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[di]] = 0x00;
        r16[di]++;
    case 0x197de:
        if (r16[di] < 0x1f40) {
            pc = 0x197d5;
            break;
        }
        r16[si] = 0xfff0;
        pc = 0x19827;
        break;
    case 0x197e9:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = 0x0057;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001f;
        push(r16[ax]);
        r16[ax] = 0x0032;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x0010;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        r16[si] += 0x0040;
    case 0x19827:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += 0xffd9;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32046);
        r16[ax] += 0xffe0;
        if (r16s[ax] >= signed16(r16[si])) {
            pc = 0x197e9;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x001e;
        push(r16[ax]);
        r16[ax] = 0x0057;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        r16[si] = 0;
        pc = 0x19866;
        break;
    case 0x19859:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e7b();
        assert(cs == 0x1946);
        sp = bp;
        r16[si]++;
    case 0x19866:
        if (signed16(r16[si]) < signed16(0x0140)) {
            pc = 0x19859;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += 0xffd9;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32046);
        r16[ax] += 0xfff8;
        memory16set(ds, 0x985c, r16[ax]);
        memory16set(ds, 0x986c, 0x0028);
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19888() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1946);
        sp = bp;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1946);
        sp = bp;
        r16[di] = 0;
        pc = 0x198cc;
        break;
    case 0x198c3:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[di]] = 0x00;
        r16[di]++;
    case 0x198cc:
        if (r16[di] < 0x1f40) {
            pc = 0x198c3;
            break;
        }
        r16[si] = 0xffe0;
        pc = 0x198f3;
        break;
    case 0x198d7:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9882);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        r16[si] += 0x0040;
    case 0x198f3:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += 0xffe6;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32020);
        if (r16s[ax] > signed16(r16[si])) {
            pc = 0x198d7;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x9882));
        r16[ax] = 0x0032;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp = bp;
        r16[si] = 0;
        pc = 0x1992c;
        break;
    case 0x1991f:
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19e7b();
        assert(cs == 0x1946);
        sp = bp;
        r16[si]++;
    case 0x1992c:
        if (signed16(r16[si]) < signed16(0x0140)) {
            pc = 0x1991f;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] += 0xffe6;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32020);
        r16[ax] += 0xfff8;
        memory16set(ds, 0x985c, r16[ax]);
        memory16set(ds, 0x986c, 0x0028);
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1994e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x1946);
        sp += 0x0006;
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x1997b;
        break;
    case 0x1996d:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        r16[bx] += memory16get(ss, bp - 4);
        memory[es*16 + r16[bx]] = 0x00;
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x1997b:
        if (memory16get(ss, bp - 4) < 0x1f40) {
            pc = 0x1996d;
            break;
        }
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) - 0x0016);
        r16[di] = 0;
        if (memory16get(ss, bp + 10) & 0x0001) {
            pc = 0x19992;
            break;
        }
        r16[di] = 0x0020;
    case 0x19992:
        r16[ax] = r16[di];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        memory16set(ss, bp - 4, 0x0000);
        pc = 0x19a4f;
        break;
    case 0x199a3:
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32362);
        memory16set(ss, bp - 2, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 2, sar16(memory16get(ss, bp - 2), r8[cl]));
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) << r8[cl]);
        r16[bx] = r16[di];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 32362);
        if (r16[si] != 0x001e) {
            pc = 0x199ca;
            break;
        }
        r16[si] = 0x001f;
    case 0x199ca:
        if (r16[si] != 0x001d) {
            pc = 0x199d2;
            break;
        }
        r16[si] = 0x001e;
    case 0x199d2:
        if (r16[si] != 0x0014) {
            pc = 0x199da;
            break;
        }
        r16[si] = 0x0020;
    case 0x199da:
        if (r16[si] != 0x0005) {
            pc = 0x199e2;
            break;
        }
        r16[si] = 0x001d;
    case 0x199e2:
        if (r16[si] >= 0x001e) {
            pc = 0x19a24;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += r16[si];
        r16[ax]--;
        push(r16[ax]);
        r16[bx] = r16[di];
        r16[bx]++;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32362));
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp += 0x000c;
        r16[bx] = r16[di];
        r16[bx]++;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32362));
        push(memory16get(ss, bp - 2));
        r16[ax] = r16[si];
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_19eac();
        assert(cs == 0x1946);
        sp += 0x0006;
        pc = 0x19a49;
        break;
    case 0x19a24:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9882);
        r16[ax] += r16[si];
        r16[ax] += 0xffe2;
        push(r16[ax]);
        r16[bx] = r16[di];
        r16[bx]++;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32362));
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp += 0x000c;
    case 0x19a49:
        r16[di] += 0x0003;
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 1);
    case 0x19a4f:
        if (memory16get(ss, bp - 4) > 0x001f) {
            pc = 0x19a58;
            break;
        }
        pc = 0x199a3;
        break;
    case 0x19a58:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0026;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x00a0;
        push(r16[ax]);
        r16[ax] = 0x004a;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x1946);
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax] += 0x0020;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1946);
        sp += 0x000c;
        memory16set(ds, 0x985c, 0x00b7);
        memory16set(ds, 0x986c, 0x0055);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19aa5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[si] = memory16get(ss, bp + 10);
        memory[ss*16 + bp - 5] = 0x00;
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x97fe, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x9864, r16[ax]);
        if (r16[si] == 0x0001) {
            pc = 0x19acf;
            break;
        }
        if (r16[si] == 0x0005) {
            pc = 0x19acf;
            break;
        }
        if (r16[si] != 0x0007) {
            pc = 0x19ae1;
            break;
        }
    case 0x19acf:
        r16[ax] = 0x0008;
        memory16set(ds, 0x9c64, r16[ax]);
        memory16set(ds, 0x988e, r16[ax]);
        r16[ax] = 0x008b;
        memory16set(ds, 0x97fc, r16[ax]);
        memory16set(ds, 0x97f2, r16[ax]);
    case 0x19ae1:
        if (r16[si] != 0x0003) {
            pc = 0x19af8;
            break;
        }
        r16[ax] = 0x0056;
        memory16set(ds, 0x9c64, r16[ax]);
        memory16set(ds, 0x988e, r16[ax]);
        r16[ax] = 0x009f;
        memory16set(ds, 0x97fc, r16[ax]);
        memory16set(ds, 0x97f2, r16[ax]);
    case 0x19af8:
        memory16set(ds, 0x9800, 0x0000);
        r16[ax] = 0;
        memory16set(ds, 0x987e, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        memory16set(ds, 0x9868, r16[ax]);
        memory16set(ds, 0x9872, r16[ax]);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19b1a;
            break;
        }
        push(cs);
        yield* sub_1946f();
    case 0x19b1a:
        if (r16[si] != 0x0001) {
            pc = 0x19b2a;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19b2a;
            break;
        }
        push(cs);
        yield* sub_19517();
    case 0x19b2a:
        if (r16[si] != 0x0003) {
            pc = 0x19b3a;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19b3a;
            break;
        }
        push(cs);
        yield* sub_1955b();
    case 0x19b3a:
        if (r16[si] != 0x0003) {
            pc = 0x19b5a;
            break;
        }
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x19b4d;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x19b5a;
            break;
        }
    case 0x19b4d:
        push(ds);
        r16[ax] = 0x7fea;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_6d22();
        assert(cs == 0x1946);
        sp += 0x0004;
    case 0x19b5a:
        if (r16[si] != 0x0005) {
            pc = 0x19b6a;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19b6a;
            break;
        }
        push(cs);
        yield* sub_195e3();
    case 0x19b6a:
        if (r16[si] != 0x0007) {
            pc = 0x19b7a;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19b7a;
            break;
        }
        push(cs);
        yield* sub_19627();
    case 0x19b7a:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x19b84;
            break;
        }
        pc = 0x19df1;
        break;
    case 0x19b84:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x19b8e;
            break;
        }
        pc = 0x19df1;
        break;
    case 0x19b8e:
        r16[ax] = 0x00c7;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_23f1();
        assert(cs == 0x1946);
        sp++;
        sp++;
        if (r16[si] != 0x0001) {
            pc = 0x19ba7;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_196da();
        sp++;
        sp++;
    case 0x19ba7:
        if (r16[si] != 0x0003) {
            pc = 0x19bb5;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_1994e();
        sp++;
        sp++;
    case 0x19bb5:
        if (r16[si] != 0x0005) {
            pc = 0x19bc3;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_19888();
        sp++;
        sp++;
    case 0x19bc3:
        if (r16[si] != 0x0007) {
            pc = 0x19bd1;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(cs);
        yield* sub_1979a();
        sp++;
        sp++;
    case 0x19bd1:
        push(memory16get(ss, bp + 12));
        push(ds);
        r16[ax] = 0x29e2;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a412();
        assert(cs == 0x1946);
        sp += 0x0006;
        push(cs);
        cs = 0x19e4;
        yield* sub_1a4da();
        assert(cs == 0x1946);
        memory[ss*16 + bp - 6] = 0x00;
        memory16set(ds, 0x9872, 0x0000);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b341();
        assert(cs == 0x1946);
        r16[di] = 0;
        pc = 0x19c1c;
        break;
    case 0x19c0d:
        r16[bx] = r16[di];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, 0x0000);
        r16[di]++;
    case 0x19c1c:
        if (r16[di] < 0x000a) {
            pc = 0x19c0d;
            break;
        }
        memory16set(ds, 0x97e4, 0x0000);
        memory16set(ds, 0x9894, 0x0000);
        memory16set(ds, 0x97e6, 0x0000);
        push(cs);
        cs = 0x1829;
        yield* sub_1831a();
        assert(cs == 0x1946);
    case 0x19c38:
        if (memory16get(ds, 0x9872) == 0x0000) {
            pc = 0x19c42;
            break;
        }
        pc = 0x19b7a;
        break;
    case 0x19c42:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x19c4c;
            break;
        }
        pc = 0x19b7a;
        break;
    case 0x19c4c:
        r16[ax] = memory16get(ds, 0x985a);
        memory16set(ds, 0x985a, memory16get(ds, 0x985a) + 1);
        if (r16[ax] <= 0x003c) {
            pc = 0x19c89;
            break;
        }
        if (memory16get(ds, 0x9c66) == 0x0000) {
            pc = 0x19c65;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) - 1);
        pc = 0x19c7e;
        break;
    case 0x19c65:
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x19c7e;
            break;
        }
        memory16set(ds, 0x9874, 0x0000);
        memory16set(ds, 0x9870, 0x0001);
        memory16set(ds, 0x97fa, 0x0001);
    case 0x19c7e:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b4ad();
        assert(cs == 0x1946);
        memory16set(ds, 0x985a, 0x0000);
    case 0x19c89:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b0b7();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a5d8();
        assert(cs == 0x1946);
        memory16set(ds, 0x97e6, 0x0000);
        push(cs);
        cs = 0x1bf1;
        yield* sub_1bf13();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a6df();
        assert(cs == 0x1946);
        r16[ax] = 0;
        memory16set(ds, 0x9898, r16[ax]);
        memory16set(ds, 0x9802, r16[ax]);
        memory16set(ds, 0x988c, r16[ax]);
        memory16set(ds, 0x986a, r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a9f3();
        assert(cs == 0x1946);
        r8[al] = memory[ds*16 + 0x8db4];
        r8[ah] = 0x00;
        memory16set(ds, 0x9898, r16[ax]);
        r8[al] = memory[ds*16 + 0x92b6];
        r8[ah] = 0x00;
        memory16set(ds, 0x9802, r16[ax]);
        r8[al] = memory[ds*16 + 0x8baf];
        r8[ah] = 0x00;
        memory16set(ds, 0x986a, r16[ax]);
        r8[al] = memory[ds*16 + 0x8da6];
        r8[ah] = 0x00;
        memory16set(ds, 0x988c, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x1946);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b991();
        assert(cs == 0x1946);
        if (memory16get(ds, 0x9872) != 0x0000) {
            pc = 0x19cff;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1bdb2();
        assert(cs == 0x1946);
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x19cff;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x19cff;
            break;
        }
        push(cs);
        cs = 0x19e4;
        yield* sub_1b107();
        assert(cs == 0x1946);
    case 0x19cff:
        if (memory[ss*16 + bp - 6] != 0x00) {
            pc = 0x19d0f;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
        pc = 0x19d17;
        break;
    case 0x19d0f:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
    case 0x19d17:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x19d25;
            break;
        }
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19d29;
            break;
        }
    case 0x19d25:
        memory[ss*16 + bp - 6] = memory[ss*16 + bp - 6] ^ 0x01;
    case 0x19d29:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18726();
        assert(cs == 0x1946);
        sp += 0x0004;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18c85();
        assert(cs == 0x1946);
        sp += 0x0004;
        if (memory[ss*16 + bp - 5] != 0x00) {
            pc = 0x19d65;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1946);
        sp += 0x000a;
        memory[ss*16 + bp - 5] = 0x01;
    case 0x19d65:
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x1829;
        yield* sub_18906();
        assert(cs == 0x1946);
        sp += 0x0004;
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ed();
        assert(cs == 0x1946);
        sp++;
        sp++;
        push(cs);
        cs = 0x0a34;
        yield* sub_b9ae();
        assert(cs == 0x1946);
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x19d8d;
            break;
        }
        pc = 0x19c38;
        break;
    case 0x19d8d:
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x19d97;
            break;
        }
        pc = 0x19c38;
        break;
    case 0x19d97:
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x19db3;
            break;
        }
        if (r16[si] == 0x0001) {
            pc = 0x19dad;
            break;
        }
        if (r16[si] == 0x0005) {
            pc = 0x19dad;
            break;
        }
        if (r16[si] != 0x0007) {
            pc = 0x19db3;
            break;
        }
    case 0x19dad:
        memory16set(ds, 0x9872, 0x0001);
    case 0x19db3:
        if (r16[si] != 0x0003) {
            pc = 0x19ddc;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x0056)) {
            pc = 0x19dcf;
            break;
        }
        if (memory16gets(ds, 0x97f2) <= signed16(0x0096)) {
            pc = 0x19dcf;
            break;
        }
        memory16set(ds, 0x9872, 0x0001);
        pc = 0x19ddc;
        break;
    case 0x19dcf:
        if (memory16gets(ds, 0x988e) >= signed16(0x0055)) {
            pc = 0x19ddc;
            break;
        }
        memory16set(ds, 0x988e, 0x0055);
    case 0x19ddc:
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] > memory16gets(ds, 0x985c)) {
            pc = 0x19de8;
            break;
        }
        pc = 0x19c38;
        break;
    case 0x19de8:
        r16[ax] = memory16get(ds, 0x985c);
        memory16set(ds, 0x988e, r16[ax]);
        pc = 0x19c38;
        break;
    case 0x19df1:
        r8[al] = memory[ss*16 + bp - 6];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b6d5();
        assert(cs == 0x1946);
        sp++;
        sp++;
        r16[ax] = memory16get(ds, 0x97fe);
        memory16set(ds, 0x9c64, r16[ax]);
        memory16set(ds, 0x988e, r16[ax]);
        r16[ax] = memory16get(ds, 0x9864);
        memory16set(ds, 0x97fc, r16[ax]);
        memory16set(ds, 0x97f2, r16[ax]);
        r16[ax] = 0;
        memory16set(ds, 0x9868, r16[ax]);
        memory16set(ds, 0x9872, r16[ax]);
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x19e23;
            break;
        }
        push(cs);
        yield* sub_194a1();
    case 0x19e23:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x19e31;
            break;
        }
        if (memory[ds*16 + 0x8bf0] == 0x00) {
            pc = 0x19e43;
            break;
        }
    case 0x19e31:
        if (r16[si] != 0x0003) {
            pc = 0x19e43;
            break;
        }
        push(ds);
        r16[ax] = 0x7ff4;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_6d22();
        assert(cs == 0x1946);
        sp += 0x0004;
    case 0x19e43:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19e49() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[ax] = 0;
    push(r16[ax]);
    push(memory16get(ss, bp + 10));
    push(memory16get(ss, bp + 8));
    push(cs);
    cs = 0x06c1;
    yield* sub_7530();
    assert(cs == 0x19e4);
    sp = bp;
    r16[si] = r16[ax];
    r16[ax] = 0x03c0;
    push(r16[ax]);
    push(ds);
    r16[ax] = 0x989e;
    push(r16[ax]);
    push(r16[si]);
    push(cs);
    cs = 0x06c1;
    yield* sub_6e6a();
    assert(cs == 0x19e4);
    sp = bp;
    push(r16[si]);
    push(cs);
    cs = 0x06c1;
    yield* sub_74f7();
    assert(cs == 0x19e4);
    sp = bp;
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_19e7b() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    r16[si] = memory16get(ss, bp + 10);
    r16[si] >>= 1;
    r16[si] >>= 1;
    r16[si] >>= 1;
    r16[ax] = memory16get(ss, bp + 12);
    r16[dx] = 0x0028;
    mul16(r16[dx]);
    r16[si] += r16[ax];
    r16[cx] = memory16get(ss, bp + 10);
    r16[cx] &= 0x0007;
    r16[di] = 0x0080;
    r16[di] = sar16(r16[di], r8[cl]);
    r16[ax] = r16[di];
    r16[bx] = memory16get(ds, 0x987a);
    es = memory16get(ds, 0x987a + 2);
    memory[es*16 + r16[bx] + r16[si]] = memory[es*16 + r16[bx] + r16[si]] | r8[al];
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_19eac() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        memory16set(ss, bp - 6, 0x0000);
    case 0x19eb9:
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = 0x0018;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r16[ax] = memory16get(ss, bp - 6);
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] <<= 1;
        r16[bx] += r16[ax];
        if (memory16get(ds, r16[bx] + 39070) == 0xffff) {
            pc = 0x19f4a;
            break;
        }
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = 0x0018;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax] <<= 1;
        r16[bx] += r16[ax];
        r16[si] = memory16get(ds, r16[bx] + 39070);
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = 0x0018;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] += r16[ax];
        r16[di] = memory16get(ds, r16[bx] + 39070);
        r16[ax] = memory16get(ss, bp + 10);
        r16[dx] = 0x0018;
        mul16(r16[dx]);
        r16[bx] = r16[ax];
        r16[ax] = memory16get(ss, bp - 2);
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ds, r16[bx] + 39070);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + 1);
        r16[si] += memory16get(ss, bp + 12);
    case 0x19f25:
        r16[ax] = memory16get(ss, bp - 4);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 1);
        if (!r16[ax]) {
            pc = 0x19eb9;
            break;
        }
        if (signed16(r16[si]) < 0) {
            pc = 0x19f47;
            break;
        }
        if (signed16(r16[si]) >= signed16(0x0140)) {
            pc = 0x19f47;
            break;
        }
        r16[ax] = memory16get(ss, bp + 14);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_19e7b();
        sp += 0x0004;
    case 0x19f47:
        r16[si]++;
        pc = 0x19f25;
        break;
    case 0x19f4a:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_19f50() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x92c8;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[si] = 0;
        pc = 0x19f79;
        break;
    case 0x19f70:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[si]] = 0x00;
        r16[si]++;
    case 0x19f79:
        if (r16[si] < 0x1f40) {
            pc = 0x19f70;
            break;
        }
        r16[di] = 0;
        if (memory16get(ss, bp + 18) == r16[di]) {
            pc = 0x19f9f;
            break;
        }
        r16[si] = r16[di];
        pc = 0x19f9a;
        break;
    case 0x19f8a:
        r16[ax] = r16[si];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[di] += r16[ax];
        r16[di]++;
        r16[si]++;
    case 0x19f9a:
        if (r16[si] < memory16get(ss, bp + 18)) {
            pc = 0x19f8a;
            break;
        }
    case 0x19f9f:
        r16[ax] = r16[di];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[di] = r16[ax];
        r16[si] = 0;
        pc = 0x1a025;
        break;
    case 0x19fac:
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 2, r16[ax]);
        r16[cx] = 0x0004;
        memory16set(ss, bp - 2, sar16(memory16get(ss, bp - 2), r8[cl]));
        memory16set(ss, bp - 2, memory16get(ss, bp - 2) << r8[cl]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ds, 0x9896);
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        push(memory16get(ss, bp - 2));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x19e4);
        sp += 0x000c;
        r16[ax] = r16[di];
        r16[ax]++;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[bx] += r16[ax];
        push(memory16get(es, r16[bx]));
        push(memory16get(ss, bp - 2));
        r16[ax] = r16[di];
        r16[ax] += 0x0002;
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 14);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax]--;
        push(r16[ax]);
        push(cs);
        yield* sub_19eac();
        sp += 0x0006;
        r16[di] += 0x0003;
        r16[si]++;
    case 0x1a025:
        r16[ax] = memory16get(ss, bp + 18);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        if (r16[ax] < r16[si]) {
            pc = 0x1a039;
            break;
        }
        pc = 0x19fac;
        break;
    case 0x1a039:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a03f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        if (memory[ds*16 + 0x8f67] == 0x00) {
            pc = 0x1a051;
            break;
        }
        push(cs);
        cs = 0x1946;
        yield* sub_194d3();
        assert(cs == 0x19e4);
        sp = bp;
    case 0x1a051:
        r16[si] = 0;
        pc = 0x1a05e;
        break;
    case 0x1a055:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory[es*16 + r16[bx] + r16[si]] = 0x00;
        r16[si]++;
    case 0x1a05e:
        if (r16[si] < 0x1f40) {
            pc = 0x1a055;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1a072;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1a077;
            break;
        }
    case 0x1a072:
        r16[si] = 0x0001;
        pc = 0x1a07a;
        break;
    case 0x1a077:
        r16[si] = 0x0004;
    case 0x1a07a:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0x00be;
        push(r16[ax]);
        r16[ax] = 0x013f;
        push(r16[ax]);
        r16[ax] = 0x0009;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp = bp;
        r16[si] = 0;
        pc = 0x1a102;
        break;
    case 0x1a09a:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9896);
        r16[ax]++;
        push(r16[ax]);
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x19e4);
        sp = bp;
        r16[ax] = 0x00a8;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        yield* sub_19eac();
        sp = bp;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += memory16get(ds, 0x9896);
        r16[dx] += 0x0011;
        push(r16[dx]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0086;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x000a;
        push(r16[dx]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0140;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        push(r16[dx]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x19e4);
        sp = bp;
        r16[si] += 0x0030;
    case 0x1a102:
        if (r16[si] < 0x2710) {
            pc = 0x1a09a;
            break;
        }
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a10b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[bx] = memory16get(ss, bp + 6);
        es = memory16get(ss, bp + 6 + 2);
        memory16set(ds, 0x9858, es);
        memory16set(ds, 0x9856, r16[bx]);
    case 0x1a11c:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        if (memory16get(es, r16[bx]) != 0x00ff) {
            pc = 0x1a12a;
            break;
        }
        pc = 0x1a40e;
        break;
    case 0x1a12a:
        r16[ax] = memory16get(es, r16[bx]);
        if (r16[ax] > 0x0027) {
            pc = 0x1a11c;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x1a18b; break;
        case 2: pc = 0x1a298; break;
        case 4: pc = 0x1a3c6; break;
        case 6: pc = 0x1a279; break;
        case 8: pc = 0x1a1a7; break;
        case 10: pc = 0x1a192; break;
        case 12: pc = 0x1a1b4; break;
        case 14: pc = 0x1a257; break;
        case 16: pc = 0x1a3be; break;
        case 18: pc = 0x1a1c1; break;
        case 20: pc = 0x1a3ce; break;
        case 22: pc = 0x1a3ce; break;
        case 24: pc = 0x1a3ce; break;
        case 26: pc = 0x1a3ce; break;
        case 28: pc = 0x1a2ed; break;
        case 30: pc = 0x1a1ea; break;
        case 32: pc = 0x1a1ff; break;
        case 34: pc = 0x1a298; break;
        case 36: pc = 0x1a298; break;
        case 38: pc = 0x1a219; break;
        case 40: pc = 0x1a257; break;
        case 42: pc = 0x1a298; break;
        case 44: pc = 0x1a225; break;
        case 46: pc = 0x1a23a; break;
        case 48: pc = 0x1a263; break;
        case 50: pc = 0x1a298; break;
        case 52: pc = 0x1a3ce; break;
        case 54: pc = 0x1a3ce; break;
        case 56: pc = 0x1a279; break;
        case 58: pc = 0x1a285; break;
        case 60: pc = 0x1a2a0; break;
        case 62: pc = 0x1a2ac; break;
        case 64: pc = 0x1a2ed; break;
        case 66: pc = 0x1a3ce; break;
        case 68: pc = 0x1a3ce; break;
        case 70: pc = 0x1a2fe; break;
        case 72: pc = 0x1a398; break;
        case 74: pc = 0x1a3c6; break;
        case 76: pc = 0x1a3ce; break;
        case 78: pc = 0x1a3ce; break;
            default:
            assert(0);
        }
        break;
    case 0x1a18b:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0002);
        pc = 0x1a11c;
        break;
    case 0x1a192:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 8, r16[ax]);
        memory16set(es, r16[bx] + 10, 0x0000);
        pc = 0x1a2e5;
        break;
    case 0x1a1a7:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, 0x0003);
        pc = 0x1a298;
        break;
    case 0x1a1b4:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 8, 0x0002);
        pc = 0x1a271;
        break;
    case 0x1a1c1:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 4, 0x00dc);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0005;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x0010;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 8, 0x0000);
        pc = 0x1a271;
        break;
    case 0x1a1ea:
        r16[ax] = 0;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 8, r16[ax]);
        memory16set(es, r16[bx] + 6, r16[ax]);
        memory16set(es, r16[bx] + 2, r16[ax]);
        pc = 0x1a390;
        break;
    case 0x1a1ff:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        memory16set(es, r16[bx] + 6, r16[ax]);
        memory16set(es, r16[bx] + 12, 0x0000);
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0010);
        pc = 0x1a11c;
        break;
    case 0x1a219:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 4, 0x0000);
        pc = 0x1a298;
        break;
    case 0x1a225:
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x000f;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 4, r16[dx]);
        pc = 0x1a298;
        break;
    case 0x1a23a:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, 0x0000);
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(es, r16[bx] + 8, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        memory16set(es, r16[bx] + 10, r16[ax]);
        pc = 0x1a2e5;
        break;
    case 0x1a257:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 8, 0x0001);
        pc = 0x1a271;
        break;
    case 0x1a263:
        r16[ax] = 0;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 8, r16[ax]);
        memory16set(es, r16[bx] + 6, r16[ax]);
    case 0x1a271:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x000a);
        pc = 0x1a11c;
        break;
    case 0x1a279:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, 0x0002);
        pc = 0x1a298;
        break;
    case 0x1a285:
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x000a;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
    case 0x1a298:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0008);
        pc = 0x1a11c;
        break;
    case 0x1a2a0:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 2, 0x0000);
        pc = 0x1a2e5;
        break;
    case 0x1a2ac:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 4, 0x00dc);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0005;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x0010;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 8, 0x0000);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x00d2;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
    case 0x1a2e5:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x000c);
        pc = 0x1a11c;
        break;
    case 0x1a2ed:
        r16[ax] = 0;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 8, r16[ax]);
        memory16set(es, r16[bx] + 2, r16[ax]);
        pc = 0x1a3be;
        break;
    case 0x1a2fe:
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        r16[bx] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        r16[cx] = pop();
        r16[cx] -= memory16get(es, r16[bx] + 4);
        r16[ax] = pop();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[cx]);
        r16[bx] = memory16get(ds, 0x9856);
        r16[dx] += memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ds, 0x9856);
        memory16set(es, r16[bx] + 6, r16[dx]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        r16[bx] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        r16[cx] = pop();
        r16[cx] -= memory16get(es, r16[bx] + 4);
        r16[ax] = pop();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[cx]);
        r16[bx] = memory16get(ds, 0x9856);
        r16[dx] += memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ds, 0x9856);
        memory16set(es, r16[bx] + 8, r16[dx]);
        r16[bx] = memory16get(ds, 0x9856);
        memory16set(es, r16[bx] + 10, 0x0038);
        r16[bx] = memory16get(ds, 0x9856);
        memory16set(es, r16[bx] + 12, 0x004d);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 14, r16[dx]);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0002;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 16, r16[dx]);
    case 0x1a390:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0012);
        pc = 0x1a11c;
        break;
    case 0x1a398:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 4, 0x00dc);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0005;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[dx] += 0x0010;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 8, 0x0000);
    case 0x1a3be:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x000e);
        pc = 0x1a11c;
        break;
    case 0x1a3c6:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0006);
        pc = 0x1a11c;
        break;
    case 0x1a3ce:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        r16[bx] += 0x0002;
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(es, r16[bx] + 8, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        memory16set(es, r16[bx] + 12, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 14, r16[ax]);
        memory16set(es, r16[bx] + 18, 0x0000);
        memory16set(es, r16[bx] + 20, 0x0000);
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x001a);
        pc = 0x1a11c;
        break;
    case 0x1a40e:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a412() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 12);
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory16set(ds, 0x9858, es);
        memory16set(ds, 0x9856, r16[bx]);
    case 0x1a424:
        if (r16[si]) {
            pc = 0x1a42b;
            break;
        }
        pc = 0x1a4d7;
        break;
    case 0x1a42b:
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        r16[ax] = memory16get(es, r16[bx]);
        if (r16[ax] > 0x0027) {
            pc = 0x1a424;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x1a490; break;
        case 2: pc = 0x1a4a7; break;
        case 4: pc = 0x1a4c7; break;
        case 6: pc = 0x1a4a7; break;
        case 8: pc = 0x1a4a7; break;
        case 10: pc = 0x1a4af; break;
        case 12: pc = 0x1a49f; break;
        case 14: pc = 0x1a49f; break;
        case 16: pc = 0x1a4bf; break;
        case 18: pc = 0x1a49f; break;
        case 20: pc = 0x1a4cf; break;
        case 22: pc = 0x1a4cf; break;
        case 24: pc = 0x1a4cf; break;
        case 26: pc = 0x1a4cf; break;
        case 28: pc = 0x1a4bf; break;
        case 30: pc = 0x1a4b7; break;
        case 32: pc = 0x1a498; break;
        case 34: pc = 0x1a4a7; break;
        case 36: pc = 0x1a4a7; break;
        case 38: pc = 0x1a4a7; break;
        case 40: pc = 0x1a49f; break;
        case 42: pc = 0x1a4a7; break;
        case 44: pc = 0x1a4a7; break;
        case 46: pc = 0x1a4af; break;
        case 48: pc = 0x1a49f; break;
        case 50: pc = 0x1a4a7; break;
        case 52: pc = 0x1a4cf; break;
        case 54: pc = 0x1a4cf; break;
        case 56: pc = 0x1a4a7; break;
        case 58: pc = 0x1a4a7; break;
        case 60: pc = 0x1a4af; break;
        case 62: pc = 0x1a4af; break;
        case 64: pc = 0x1a4bf; break;
        case 66: pc = 0x1a4cf; break;
        case 68: pc = 0x1a4cf; break;
        case 70: pc = 0x1a4b7; break;
        case 72: pc = 0x1a4bf; break;
        case 74: pc = 0x1a4c7; break;
        case 76: pc = 0x1a4cf; break;
        case 78: pc = 0x1a4cf; break;
            default:
            assert(0);
        }
        break;
    case 0x1a490:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0002);
        r16[si]--;
        pc = 0x1a424;
        break;
    case 0x1a498:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0010);
        pc = 0x1a424;
        break;
    case 0x1a49f:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x000a);
        pc = 0x1a424;
        break;
    case 0x1a4a7:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0008);
        pc = 0x1a424;
        break;
    case 0x1a4af:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x000c);
        pc = 0x1a424;
        break;
    case 0x1a4b7:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0012);
        pc = 0x1a424;
        break;
    case 0x1a4bf:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x000e);
        pc = 0x1a424;
        break;
    case 0x1a4c7:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x0006);
        pc = 0x1a424;
        break;
    case 0x1a4cf:
        memory16set(ds, 0x9856, memory16get(ds, 0x9856) + 0x001a);
        pc = 0x1a424;
        break;
    case 0x1a4d7:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a4da() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
    case 0x1a4ea:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memory16get(es, r16[bx]) != 0x0000) {
            pc = 0x1a4f6;
            break;
        }
        pc = 0x1a5d4;
        break;
    case 0x1a4f6:
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax]--;
        if (r16[ax] > 0x0026) {
            pc = 0x1a4ea;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x1a5a3; break;
        case 2: pc = 0x1a556; break;
        case 4: pc = 0x1a5a3; break;
        case 6: pc = 0x1a5a3; break;
        case 8: pc = 0x1a5aa; break;
        case 10: pc = 0x1a5b1; break;
        case 12: pc = 0x1a5b1; break;
        case 14: pc = 0x1a5bf; break;
        case 16: pc = 0x1a5b1; break;
        case 18: pc = 0x1a5cd; break;
        case 20: pc = 0x1a5cd; break;
        case 22: pc = 0x1a5cd; break;
        case 24: pc = 0x1a5cd; break;
        case 26: pc = 0x1a5bf; break;
        case 28: pc = 0x1a5b8; break;
        case 30: pc = 0x1a57a; break;
        case 32: pc = 0x1a5a3; break;
        case 34: pc = 0x1a5a3; break;
        case 36: pc = 0x1a5a3; break;
        case 38: pc = 0x1a5b1; break;
        case 40: pc = 0x1a581; break;
        case 42: pc = 0x1a5a3; break;
        case 44: pc = 0x1a5aa; break;
        case 46: pc = 0x1a5b1; break;
        case 48: pc = 0x1a5a3; break;
        case 50: pc = 0x1a5cd; break;
        case 52: pc = 0x1a5cd; break;
        case 54: pc = 0x1a5a3; break;
        case 56: pc = 0x1a5a3; break;
        case 58: pc = 0x1a5aa; break;
        case 60: pc = 0x1a5b1; break;
        case 62: pc = 0x1a5bf; break;
        case 64: pc = 0x1a5cd; break;
        case 66: pc = 0x1a5cd; break;
        case 68: pc = 0x1a5b8; break;
        case 70: pc = 0x1a5bf; break;
        case 72: pc = 0x1a5c6; break;
        case 74: pc = 0x1a5cd; break;
        case 76: pc = 0x1a5cd; break;
            default:
            assert(0);
        }
        break;
    case 0x1a556:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x0081;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x19e4);
        sp += 0x000c;
        pc = 0x1a5c6;
        break;
    case 0x1a57a:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0010);
        pc = 0x1a4ea;
        break;
    case 0x1a581:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += 0x008e;
        push(r16[ax]);
        r16[ax] = 0x0073;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x985c);
        r16[ax] += 0xfff1;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x19e4);
        sp += 0x000c;
    case 0x1a5a3:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0008);
        pc = 0x1a4ea;
        break;
    case 0x1a5aa:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x000c);
        pc = 0x1a4ea;
        break;
    case 0x1a5b1:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x000a);
        pc = 0x1a4ea;
        break;
    case 0x1a5b8:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0012);
        pc = 0x1a4ea;
        break;
    case 0x1a5bf:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x000e);
        pc = 0x1a4ea;
        break;
    case 0x1a5c6:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0006);
        pc = 0x1a4ea;
        break;
    case 0x1a5cd:
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x001a);
        pc = 0x1a4ea;
        break;
    case 0x1a5d4:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a5d8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        r16[si] = 0;
        pc = 0x1a636;
        break;
    case 0x1a5dd:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        if (memory16get(ds, r16[bx] + 38918) == 0x0000) {
            pc = 0x1a635;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, memory16get(ds, r16[bx] + 38918) - 1);
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38924));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38922));
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 38920));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38922, memory16get(ds, r16[bx] + 38922) - 0x0004);
    case 0x1a635:
        r16[si]++;
    case 0x1a636:
        if (r16[si] < 0x000a) {
            pc = 0x1a5dd;
            break;
        }
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a63d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 14);
        r16[dx] = 0;
        flags.carry = (r16[ax] + memory16get(ds, 0x9886)) >= 0x10000;
        r16[ax] += memory16get(ds, 0x9886);
        r16[dx] += memory16get(ds, 0x9888) + flags.carry;
        memory16set(ds, 0x9888, r16[dx]);
        memory16set(ds, 0x9886, r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b214();
        assert(cs == 0x19e4);
        sp = bp;
        r16[di] = 0;
        r16[si] = r16[di];
        pc = 0x1a674;
        break;
    case 0x1a663:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32770);
        if (r16[ax] != memory16get(ss, bp + 14)) {
            pc = 0x1a673;
            break;
        }
        r16[di] = r16[si];
        r16[di]++;
    case 0x1a673:
        r16[si]++;
    case 0x1a674:
        if (r16[si] < 0x0005) {
            pc = 0x1a663;
            break;
        }
        if (!r16[di]) {
            pc = 0x1a6db;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dc46();
        assert(cs == 0x19e4);
        sp = bp;
        r16[di] += 0x0021;
        r16[si] = 0;
    case 0x1a689:
        if (r16[si] >= 0x000a) {
            pc = 0x1a6db;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        if (memory16get(ds, r16[bx] + 38918) != 0x0000) {
            pc = 0x1a6d8;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38918, 0x000a);
        r16[ax] = memory16get(ss, bp + 10);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38920, r16[ax]);
        r16[ax] = memory16get(ss, bp + 12);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38922, r16[ax]);
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 38924, r16[di]);
        r16[si] = 0x0014;
    case 0x1a6d8:
        r16[si]++;
        pc = 0x1a689;
        break;
    case 0x1a6db:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a6df() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory16get(ds, 0x97e4) != 0x0000) {
            pc = 0x1a6e9;
            break;
        }
        pc = 0x1a77c;
        break;
    case 0x1a6e9:
        if (memory16get(ds, 0x97e4) != 0x0001) {
            pc = 0x1a6ff;
            break;
        }
        memory16set(ds, 0x97f6, memory16get(ds, 0x97f6) + 0x0008);
        if (memory16gets(ds, 0x97f6) <= signed16(0x0140)) {
            pc = 0x1a711;
            break;
        }
        pc = 0x1a70b;
        break;
    case 0x1a6ff:
        memory16set(ds, 0x97f6, memory16get(ds, 0x97f6) - 0x0008);
        if (memory16gets(ds, 0x97f6) >= signed16(0x0000)) {
            pc = 0x1a711;
            break;
        }
    case 0x1a70b:
        memory16set(ds, 0x97e4, 0x0000);
    case 0x1a711:
        if (memory16get(ds, 0x97e4) == 0x0000) {
            pc = 0x1a77c;
            break;
        }
        r16[ax] = memory16get(ds, 0x97e4);
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = 0x006d;
        push(r16[ax]);
        push(memory16get(ds, 0x9884));
        push(memory16get(ds, 0x97f6));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0019;
        if (r16s[ax] <= memory16gets(ds, 0x97f6)) {
            pc = 0x1a77c;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfff6;
        if (r16s[ax] >= memory16gets(ds, 0x97f6)) {
            pc = 0x1a77c;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff3;
        if (r16s[ax] >= memory16gets(ds, 0x9884)) {
            pc = 0x1a77c;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x0010;
        if (r16s[ax] <= memory16gets(ds, 0x9884)) {
            pc = 0x1a77c;
            break;
        }
        if (memory16get(ds, 0x987e) != 0x0000) {
            pc = 0x1a77c;
            break;
        }
        memory16set(ds, 0x97e4, 0x0000);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x19e4);
        sp++;
        sp++;
    case 0x1a77c:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1a77d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x001e;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 30, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 28, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 26, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[di] = memory16get(es, r16[bx]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[si] = memory16get(es, r16[bx]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 24, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 22, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 20, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 18, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 16, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 14, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 12, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 10, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 8, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        r16[bx] = memory16get(ss, bp + 10);
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ss, bp + 10, memory16get(ss, bp + 10) + 0x0002);
        if (memory16get(ds, 0x9894) == 0x0000) {
            pc = 0x1a879;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 10, 0x0000);
        if (memory16get(es, r16[bx] + 8) == 0x0006) {
            pc = 0x1a879;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0005);
        if (memory16gets(es, r16[bx] + 20) >= signed16(0x0064)) {
            pc = 0x1a879;
            break;
        }
        memory16set(es, r16[bx] + 20, 0x1f40);
    case 0x1a879:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 10) != 0x0000) {
            pc = 0x1a88a;
            break;
        }
        if (memory16gets(es, r16[bx] + 8) >= signed16(0x0006)) {
            pc = 0x1a8ca;
            break;
        }
    case 0x1a88a:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0014;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (r16s[ax] <= memory16gets(es, r16[bx] + 4)) {
            pc = 0x1a8ca;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] -= memory16get(ss, bp - 24);
        if (r16s[ax] >= memory16gets(es, r16[bx] + 4)) {
            pc = 0x1a8ca;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x000a;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 6)) {
            pc = 0x1a8ca;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff1;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 6)) {
            pc = 0x1a8ca;
            break;
        }
        if (memory16get(ds, 0x987e) == 0x0000) {
            pc = 0x1a8ca;
            break;
        }
        memory16set(ds, 0x987e, 0x0000);
    case 0x1a8ca:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0006) {
            pc = 0x1a917;
            break;
        }
        if (memory16get(es, r16[bx] + 10) == 0x0000) {
            pc = 0x1a917;
            break;
        }
        r16[ax] = memory16get(es, r16[bx]);
        memory16set(es, r16[bx] + 8, r16[ax]);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) - 1);
        r16[ax] = memory16get(es, r16[bx] + 4);
        memory16set(es, r16[bx] + 12, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 14, r16[ax]);
        memory16set(es, r16[bx] + 16, 0x0000);
        memory16set(es, r16[bx] + 18, 0x0000);
        memory16set(es, r16[bx] + 20, 0x0000);
        memory16set(es, r16[bx] + 22, 0x0000);
        memory16set(ds, 0x9860, 0x0000);
        pc = 0x1b03c;
        break;
    case 0x1a917:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 8) <= signed16(0x0005)) {
            pc = 0x1a924;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1a924:
        memory16set(ds, 0x9860, 0x0000);
        r16[ax] = memory16get(es, r16[bx] + 8);
        if (r16[ax] <= 0x0005) {
            pc = 0x1a936;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1a936:
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x1a94b; break;
        case 2: pc = 0x1a9d4; break;
        case 4: pc = 0x1b03c; break;
        case 6: pc = 0x1aa17; break;
        case 8: pc = 0x1ad9e; break;
        case 10: pc = 0x1af2a; break;
            default:
            assert(0);
        }
        break;
    case 0x1a94b:
        if (memory16gets(ds, 0x988e) > signed16(0x0002)) {
            pc = 0x1a955;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1a955:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001e;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (r16s[ax] > memory16gets(es, r16[bx] + 14)) {
            pc = 0x1a967;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1a967:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff1;
        if (r16s[ax] < memory16gets(es, r16[bx] + 14)) {
            pc = 0x1a976;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1a976:
        memory16set(es, r16[bx] + 8, 0x0001);
        memory16set(es, r16[bx] + 18, 0x0000);
        memory16set(es, r16[bx] + 20, 0x0000);
        memory16set(es, r16[bx] + 22, 0x0000);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0014;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1a9a3;
            break;
        }
        memory16set(es, r16[bx] + 16, 0x0000);
        pc = 0x1a9ac;
        break;
    case 0x1a9a3:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 16, 0x0001);
    case 0x1a9ac:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 18);
        r16[ax] += memory16get(ss, bp - 16);
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 14));
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0002;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        pc = 0x1b03c;
        break;
    case 0x1a9d4:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 18);
        r16[ax] += memory16get(ss, bp - 16);
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 14));
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0002;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1aa07;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 18, memory16get(es, r16[bx] + 18) + 1);
    case 0x1aa07:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 18) == 0x0002) {
            pc = 0x1aa14;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1aa14:
        pc = 0x1afd6;
        break;
    case 0x1aa17:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1aa37;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 16) == 0x0000) {
            pc = 0x1aa2f;
            break;
        }
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) - 0x0004);
        pc = 0x1aa37;
        break;
    case 0x1aa2f:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) + 0x0004);
    case 0x1aa37:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 12) < signed16(0x0014)) {
            pc = 0x1aa80;
            break;
        }
        if (memory16gets(es, r16[bx] + 12) > signed16(0x0113)) {
            pc = 0x1aa80;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1aa80;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1aa80;
            break;
        }
        pc = 0x1ab40;
        break;
    case 0x1aa80:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 12) >= signed16(0x0014)) {
            pc = 0x1aa90;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x0014);
    case 0x1aa90:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 12) <= signed16(0x0113)) {
            pc = 0x1aaa1;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x0113);
    case 0x1aaa1:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 16) != 0x0000) {
            pc = 0x1aaf4;
            break;
        }
        memory16set(es, r16[bx] + 16, 0x0001);
    case 0x1aab1:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1aaeb;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1aaeb;
            break;
        }
        pc = 0x1abb0;
        break;
    case 0x1aaeb:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) - 1);
        pc = 0x1aab1;
        break;
    case 0x1aaf4:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 16, 0x0000);
    case 0x1aafd:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1ab37;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1ab37;
            break;
        }
        pc = 0x1abb0;
        break;
    case 0x1ab37:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) + 1);
        pc = 0x1aafd;
        break;
    case 0x1ab40:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 18) != 0x0000) {
            pc = 0x1abb0;
            break;
        }
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x19e4);
        r16[bx] = 0x0014;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 2, r16[dx]);
        if (r16[dx] == 0x0002) {
            pc = 0x1ab67;
            break;
        }
        if (r16[dx] == 0x000c) {
            pc = 0x1ab67;
            break;
        }
        if (r16[dx] != 0x0010) {
            pc = 0x1ab70;
            break;
        }
    case 0x1ab67:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 16, memory16get(es, r16[bx] + 16) ^ 0x0001);
    case 0x1ab70:
        if (memory16get(ds, 0x9874) != 0x0000) {
            pc = 0x1abb0;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x000a;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (r16s[ax] <= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1abb0;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff1;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1abb0;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0014;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1aba7;
            break;
        }
        memory16set(es, r16[bx] + 16, 0x0000);
        pc = 0x1abb0;
        break;
    case 0x1aba7:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 16, 0x0001);
    case 0x1abb0:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1abbe;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 18, memory16get(es, r16[bx] + 18) + 1);
    case 0x1abbe:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 18, memory16get(es, r16[bx] + 18) & 0x0007);
        memory16set(ss, bp - 2, 0x0000);
        if (memory16get(ss, bp + 18) != 0x0000) {
            pc = 0x1abd5;
            break;
        }
        pc = 0x1ac61;
        break;
    case 0x1abd5:
        if (memory16get(ds, 0x97e4) == 0x0000) {
            pc = 0x1abdf;
            break;
        }
        pc = 0x1ac61;
        break;
    case 0x1abdf:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x0005;
        if (r16s[ax] > memory16gets(es, r16[bx] + 14)) {
            pc = 0x1abee;
            break;
        }
        pc = 0x1ac61;
        break;
    case 0x1abee:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfffb;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ac61;
            break;
        }
        if (memory16get(es, r16[bx] + 16) == 0x0000) {
            pc = 0x1ac0e;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0014;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1ac22;
            break;
        }
    case 0x1ac0e:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 16) != 0x0000) {
            pc = 0x1ac61;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1ac61;
            break;
        }
    case 0x1ac22:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 16);
        r16[ax]++;
        memory16set(ds, 0x97e4, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        memory16set(ds, 0x97f6, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += 0x0004;
        memory16set(ds, 0x9884, r16[ax]);
        push(memory16get(es, r16[bx] + 16));
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 14));
        push(memory16get(es, r16[bx] + 12));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        memory16set(ss, bp - 2, 0x0001);
    case 0x1ac61:
        if (memory16get(ss, bp - 2) != 0x0000) {
            pc = 0x1ac96;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        push(memory16get(es, r16[bx] + 16));
        r16[ax] = memory16get(es, r16[bx] + 18);
        r16[ax] <<= 1;
        r16[bx] = memory16get(ss, bp + 10);
        es = memory16get(ss, bp + 10 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax] += memory16get(ss, bp - 12);
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        push(memory16get(es, r16[bx] + 14));
        push(memory16get(es, r16[bx] + 12));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
    case 0x1ac96:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x1aca0;
            break;
        }
        pc = 0x1ad3d;
        break;
    case 0x1aca0:
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1acf4;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += memory16get(ss, bp - 28);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (r16s[ax] > memory16gets(es, r16[bx] + 12)) {
            pc = 0x1acb9;
            break;
        }
        pc = 0x1ad3d;
        break;
    case 0x1acb9:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0003;
        if (r16s[ax] < memory16gets(es, r16[bx] + 12)) {
            pc = 0x1acc8;
            break;
        }
        pc = 0x1ad3d;
        break;
    case 0x1acc8:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ad3d;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff1;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ad3d;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0004);
        memory16set(es, r16[bx] + 18, 0x0000);
        memory16set(es, r16[bx] + 16, 0x0001);
        pc = 0x1ad38;
        break;
    case 0x1acf4:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 12);
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1ad3d;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += memory16get(ss, bp - 22);
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1ad3d;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ad3d;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff1;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ad3d;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0004);
        memory16set(es, r16[bx] + 18, 0x0000);
        memory16set(es, r16[bx] + 16, 0x0000);
    case 0x1ad38:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x19e4);
    case 0x1ad3d:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 8) == 0x0003) {
            pc = 0x1ad4a;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1ad4a:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0014;
        if (r16s[ax] > memory16gets(es, r16[bx] + 12)) {
            pc = 0x1ad59;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1ad59:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] -= memory16get(ss, bp - 24);
        if (r16s[ax] < memory16gets(es, r16[bx] + 12)) {
            pc = 0x1ad68;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1ad68:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x000a;
        if (r16s[ax] > memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ad77;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1ad77:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff1;
        if (r16s[ax] < memory16gets(es, r16[bx] + 14)) {
            pc = 0x1ad86;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1ad86:
        if (memory16get(ds, 0x987e) == 0x0000) {
            pc = 0x1ad90;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1ad90:
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x19e4);
        sp++;
        sp++;
        pc = 0x1b03c;
        break;
    case 0x1ad9e:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1adbe;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 16) == 0x0000) {
            pc = 0x1adb6;
            break;
        }
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) + 0x0008);
        pc = 0x1adbe;
        break;
    case 0x1adb6:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) - 0x0008);
    case 0x1adbe:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 12) < signed16(0x0014)) {
            pc = 0x1ae07;
            break;
        }
        if (memory16gets(es, r16[bx] + 12) > signed16(0x0113)) {
            pc = 0x1ae07;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1ae07;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1ae07;
            break;
        }
        pc = 0x1aeb2;
        break;
    case 0x1ae07:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 12) >= signed16(0x0014)) {
            pc = 0x1ae17;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x0014);
    case 0x1ae17:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 12) <= signed16(0x0113)) {
            pc = 0x1ae28;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x0113);
    case 0x1ae28:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 16) != 0x0000) {
            pc = 0x1ae72;
            break;
        }
    case 0x1ae32:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1ae69;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x1aeb2;
            break;
        }
    case 0x1ae69:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) + 1);
        pc = 0x1ae32;
        break;
    case 0x1ae72:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1aea9;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b19e();
        assert(cs == 0x19e4);
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x1aeb2;
            break;
        }
    case 0x1aea9:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) - 1);
        pc = 0x1ae72;
        break;
    case 0x1aeb2:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        push(memory16get(es, r16[bx] + 16));
        push(memory16get(ss, bp - 8));
        push(memory16get(es, r16[bx] + 14));
        push(memory16get(es, r16[bx] + 12));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1aedd;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 18, memory16get(es, r16[bx] + 18) + 1);
    case 0x1aedd:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 18) == 0x0002) {
            pc = 0x1aeea;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1aeea:
        memory16set(es, r16[bx] + 8, 0x0003);
        r16[ax] = memory16get(ss, bp - 4);
        memory16set(es, r16[bx] + 16, memory16get(es, r16[bx] + 16) ^ r16[ax]);
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1af02;
            break;
        }
        memory16set(es, r16[bx] + 20, memory16get(es, r16[bx] + 20) + 1);
    case 0x1af02:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 20);
        if (r16[ax] == memory16get(ss, bp - 6)) {
            pc = 0x1af18;
            break;
        }
        if (memory16get(ds, 0x97f8) != 0x0000) {
            pc = 0x1af18;
            break;
        }
        pc = 0x1b03c;
        break;
    case 0x1af18:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 20, 0x0028);
        memory16set(es, r16[bx] + 8, 0x0005);
        pc = 0x1b03c;
        break;
    case 0x1af2a:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 20);
        r16[ax] &= 0x0001;
        r16[ax] += memory16get(ss, bp - 18);
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += memory16get(ss, bp - 18);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        push(memory16get(es, r16[bx] + 12));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16gets(es, r16[bx] + 20) >= signed16(0x0014)) {
            pc = 0x1afbe;
            break;
        }
        if (!(memory16get(es, r16[bx] + 20) & 0x0001)) {
            pc = 0x1afbe;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0069;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += r16[si];
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988a);
        r16[ax] += memory16get(ss, bp - 18);
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = pop();
        r16[ax] -= memory16get(es, r16[bx] + 2);
        r16[ax] += 0xfff8;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += memory16get(ss, bp - 30);
        r16[ax] += 0xfffd;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
    case 0x1afbe:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1afcc;
            break;
        }
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 20, memory16get(es, r16[bx] + 20) - 1);
    case 0x1afcc:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        if (memory16get(es, r16[bx] + 20) != 0x0000) {
            pc = 0x1afe1;
            break;
        }
    case 0x1afd6:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 8, 0x0003);
        pc = 0x1b03c;
        break;
    case 0x1afe1:
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0014;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1b03c;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0xfff6;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1b03c;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1b03c;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += 0x0017;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1b03c;
            break;
        }
        push(memory16get(ss, bp - 20));
        push(memory16get(es, r16[bx] + 14));
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        yield* sub_1a63d();
        sp += 0x0006;
        r16[bx] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        memory16set(es, r16[bx] + 8, 0x0006);
        memory16set(ds, 0x9880, memory16get(ds, 0x9880) + 1);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x19e4);
    case 0x1b03c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b042() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 6);
        if (r16[ax] > 0x0005) {
            pc = 0x1b0b5;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x1b062; break;
        case 2: pc = 0x1b06a; break;
        case 4: pc = 0x1b079; break;
        case 6: pc = 0x1b093; break;
        case 8: pc = 0x1b0a7; break;
        case 10: pc = 0x1b0af; break;
            default:
            assert(0);
        }
        break;
    case 0x1b062:
        memory16set(ds, 0x97f4, 0x0022);
        pc = 0x1b0b5;
        break;
    case 0x1b06a:
        memory16set(ds, 0x9894, 0x0001);
        push(cs);
        cs = 0x1946;
        yield* sub_1966b();
        assert(cs == 0x19e4);
        sp = bp;
        pc = 0x1b0b5;
        break;
    case 0x1b079:
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) + 0x001e);
        if (memory16get(ds, 0x9c66) <= 0x0063) {
            pc = 0x1b08b;
            break;
        }
        memory16set(ds, 0x9c66, 0x0063);
    case 0x1b08b:
        memory16set(ds, 0x985a, 0x003c);
        pc = 0x1b0b5;
        break;
    case 0x1b093:
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0063)) {
            pc = 0x1b09e;
            break;
        }
        memory16set(ds, 0x9c5e, memory16get(ds, 0x9c5e) + 1);
    case 0x1b09e:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x19e4);
        sp = bp;
        pc = 0x1b0b5;
        break;
    case 0x1b0a7:
        memory16set(ds, 0x9874, 0x0063);
        pc = 0x1b0b5;
        break;
    case 0x1b0af:
        memory16set(ds, 0x97f8, 0x0001);
    case 0x1b0b5:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b0b7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory16get(ds, 0x97e0) <= 0x0001) {
            pc = 0x1b106;
            break;
        }
        if (memory16get(ds, 0x97e0) >= 0x0012) {
            pc = 0x1b106;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0085;
        push(r16[ax]);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = 0x0080;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0086;
        push(r16[ax]);
        r16[ax] = 0x0061;
        push(r16[ax]);
        r16[ax] = 0x00a2;
        push(r16[ax]);
        r16[ax] = 0x000e;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1b106;
            break;
        }
        memory16set(ds, 0x97e0, memory16get(ds, 0x97e0) - 1);
    case 0x1b106:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b107() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x1b114;
            break;
        }
        r16[si] = 0x0004;
        pc = 0x1b116;
        break;
    case 0x1b114:
        r16[si] = 0;
    case 0x1b116:
        if (memory16get(ds, 0x9874) != 0x0000) {
            pc = 0x1b120;
            break;
        }
        pc = 0x1b19c;
        break;
    case 0x1b120:
        if (memory16get(ds, 0x9874) < 0x0064) {
            pc = 0x1b12a;
            break;
        }
        pc = 0x1b19c;
        break;
    case 0x1b12a:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1b13f;
            break;
        }
        memory16set(ds, 0x9874, memory16get(ds, 0x9874) - 1);
        r16[ax] = 0x0001;
        r16[ax] -= memory16get(ds, 0x9c6a);
        memory16set(ds, 0x9c6a, r16[ax]);
    case 0x1b13f:
        if (memory16get(ds, 0x9874) > 0x000f) {
            pc = 0x1b14d;
            break;
        }
        if (memory16get(ds, 0x9c6a) == 0x0000) {
            pc = 0x1b19c;
            break;
        }
    case 0x1b14d:
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x1b17c;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x9c6a);
        r16[ax] += 0x0080;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff5;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfffb;
        r16[ax] -= r16[si];
        push(r16[ax]);
        r16[ax] = 0x000d;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        pc = 0x1b19c;
        break;
    case 0x1b17c:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x008d;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x000a;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0006;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
    case 0x1b19c:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b19e() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0006;
        r16[di] = memory16get(ss, bp + 12);
        r16[si] = memory16get(ss, bp + 10);
        if (signed16(r16[si]) >= 0) {
            pc = 0x1b1b2;
            break;
        }
        r16[si] = 0;
    case 0x1b1b2:
        if (signed16(r16[si]) <= signed16(0x013f)) {
            pc = 0x1b1bb;
            break;
        }
        r16[si] = 0x013f;
    case 0x1b1bb:
        if (r16[di] <= 0x00c7) {
            pc = 0x1b1c4;
            break;
        }
        r16[di] = 0x00c7;
    case 0x1b1c4:
        r16[bx] = memory16get(ds, 0x987a);
        es = memory16get(ds, 0x987a + 2);
        memory16set(ss, bp - 4, es);
        memory16set(ss, bp - 6, r16[bx]);
        r16[ax] = r16[di];
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        r16[ax] <<= 1;
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + r16[ax]);
        r16[ax] = r16[di];
        r16[cx] = 0x0005;
        r16[ax] <<= r8[cl];
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + r16[ax]);
        r16[ax] = r16[si];
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        memory16set(ss, bp - 6, memory16get(ss, bp - 6) + r16[ax]);
        r16[cx] = r16[si];
        r16[cx] &= 0x0007;
        r16[ax] = 0x0080;
        r16[ax] = sar16(r16[ax], r8[cl]);
        memory[ss*16 + bp - 1] = r8[al];
        r8[al] = memory[ss*16 + bp - 1];
        r16[bx] = memory16get(ss, bp - 6);
        if (!(memory[es*16 + r16[bx]] & r8[al])) {
            pc = 0x1b20b;
            break;
        }
        r16[ax] = 0;
        pc = 0x1b20e;
        break;
    case 0x1b20b:
        r16[ax] = 0x0001;
    case 0x1b20e:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b214() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x002c;
    case 0x1b21c:
        if (memory16get(ds, 0x9888) < 0x000f) {
            pc = 0x1b243;
            break;
        }
        if (memory16get(ds, 0x9888) > 0x000f) {
            pc = 0x1b22d;
            break;
        }
        if (memory16get(ds, 0x9886) <= 0x423f) {
            pc = 0x1b243;
            break;
        }
    case 0x1b22d:
        r16[dx] = memory16get(ds, 0x9888);
        r16[ax] = memory16get(ds, 0x9886);
        flags.carry = (r16[ax] + 0xbdc0) >= 0x10000;
        r16[ax] += 0xbdc0;
        r16[dx] += 0xfff0 + flags.carry;
        memory16set(ds, 0x9888, r16[dx]);
        memory16set(ds, 0x9886, r16[ax]);
        pc = 0x1b21c;
        break;
    case 0x1b243:
        push(memory16get(ds, 0x9888));
        push(memory16get(ds, 0x9886));
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6a15();
        assert(cs == 0x19e4);
        sp += 0x0008;
        r16[di] = 0;
    case 0x1b25a:
        if (memory[ss*16 + bp + r16[di] - 44] == 0x00) {
            pc = 0x1b264;
            break;
        }
        r16[di]++;
        pc = 0x1b25a;
        break;
    case 0x1b264:
        r16[si] = 0;
    case 0x1b266:
        r16[ax] = 0x0006;
        r16[ax] -= r16[di];
        if (r16[ax] <= r16[si]) {
            pc = 0x1b27d;
            break;
        }
        r16[bx] = r16[si];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] = 0x30;
        r16[si]++;
        pc = 0x1b266;
        break;
    case 0x1b27d:
        memory[ss*16 + bp + r16[si] - 24] = 0x00;
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x19e4);
        sp += 0x0008;
        memory16set(ss, bp - 4, 0x000f);
        if (memory16get(ds, 0x9c6c) != 0x0001) {
            pc = 0x1b2ba;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b2ae;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b2b5;
            break;
        }
    case 0x1b2ae:
        memory16set(ss, bp - 2, 0x0001);
        pc = 0x1b2ba;
        break;
    case 0x1b2b5:
        memory16set(ss, bp - 2, 0x0004);
    case 0x1b2ba:
        if (memory16get(ds, 0x9c6c) == 0x0003) {
            pc = 0x1b2cf;
            break;
        }
        if (memory16get(ds, 0x9c6c) == 0x0005) {
            pc = 0x1b2cf;
            break;
        }
        if (memory16get(ds, 0x9c6c) != 0x0007) {
            pc = 0x1b2d4;
            break;
        }
    case 0x1b2cf:
        memory16set(ss, bp - 2, 0x0000);
    case 0x1b2d4:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0x0030;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6604();
        assert(cs == 0x19e4);
        sp += 0x0012;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x19e4);
        r16[dx] = memory16get(ds, 0x97f0);
        r16[ax] = memory16get(ds, 0x97ee);
        r16[cx] = 0;
        r16[bx] = 0x2710;
        push(cs);
        cs = 0x01ed;
        yield* sub_2109();
        assert(cs == 0x19e4);
        if (r16[dx] > memory16get(ds, 0x9888)) {
            pc = 0x1b33b;
            break;
        }
        if (r16[dx] != memory16get(ds, 0x9888)) {
            pc = 0x1b31b;
            break;
        }
        if (r16[ax] > memory16get(ds, 0x9886)) {
            pc = 0x1b33b;
            break;
        }
    case 0x1b31b:
        flags.carry = (memory16get(ds, 0x97ee) + 0x0001) >= 0x10000;
        memory16set(ds, 0x97ee, memory16get(ds, 0x97ee) + 0x0001);
        memory16set(ds, 0x97f0, memory16get(ds, 0x97f0) + flags.carry);
        memory16set(ds, 0x9c5e, memory16get(ds, 0x9c5e) + 1);
        if (memory16gets(ds, 0x9c5e) <= signed16(0x0063)) {
            pc = 0x1b336;
            break;
        }
        memory16set(ds, 0x9c5e, 0x0063);
    case 0x1b336:
        push(cs);
        cs = 0x19e4;
        yield* sub_1b3e8();
        assert(cs == 0x19e4);
    case 0x1b33b:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b341() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8080;
        push(r16[ax]);
        r16[ax] = 0x0012;
        push(r16[ax]);
        r16[ax] = 0x0004;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6410();
        assert(cs == 0x19e4);
        sp += 0x0010;
        memory16set(ss, bp - 4, 0x002a);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]--;
        push(r16[ax]);
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0040;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        r16[si] = 0x0002;
        r16[di] = 0;
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b3a3;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b3aa;
            break;
        }
    case 0x1b3a3:
        memory16set(ss, bp - 2, 0x0002);
        pc = 0x1b3af;
        break;
    case 0x1b3aa:
        memory16set(ss, bp - 2, 0x0005);
    case 0x1b3af:
        if (r16[di] >= memory16get(ds, 0x989a)) {
            pc = 0x1b3dd;
            break;
        }
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        r16[ax] = 0x000b;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x003f;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        r16[si] += 0x0004;
        r16[di]++;
        pc = 0x1b3af;
        break;
    case 0x1b3dd:
        push(cs);
        cs = 0x1829;
        yield* sub_1841a();
        assert(cs == 0x19e4);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b3e8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x002c;
        r16[ax] = memory16get(ds, 0x9c5e);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        push(r16[dx]);
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6a15();
        assert(cs == 0x19e4);
        sp += 0x0008;
        r16[di] = 0;
    case 0x1b405:
        if (memory[ss*16 + bp + r16[di] - 44] == 0x00) {
            pc = 0x1b40f;
            break;
        }
        r16[di]++;
        pc = 0x1b405;
        break;
    case 0x1b40f:
        r16[si] = 0;
    case 0x1b411:
        r16[ax] = 0x0002;
        r16[ax] -= r16[di];
        if (r16[ax] <= r16[si]) {
            pc = 0x1b428;
            break;
        }
        r16[bx] = r16[si];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] = 0x30;
        r16[si]++;
        pc = 0x1b411;
        break;
    case 0x1b428:
        memory[ss*16 + bp + r16[si] - 24] = 0x00;
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x19e4);
        sp += 0x0008;
        memory16set(ss, bp - 4, 0x000f);
        if (memory16get(ds, 0x9c6c) != 0x0001) {
            pc = 0x1b465;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b459;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b460;
            break;
        }
    case 0x1b459:
        memory16set(ss, bp - 2, 0x0001);
        pc = 0x1b465;
        break;
    case 0x1b460:
        memory16set(ss, bp - 2, 0x0004);
    case 0x1b465:
        if (memory16get(ds, 0x9c6c) == 0x0003) {
            pc = 0x1b47a;
            break;
        }
        if (memory16get(ds, 0x9c6c) == 0x0005) {
            pc = 0x1b47a;
            break;
        }
        if (memory16get(ds, 0x9c6c) != 0x0007) {
            pc = 0x1b47f;
            break;
        }
    case 0x1b47a:
        memory16set(ss, bp - 2, 0x0000);
    case 0x1b47f:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0x00e8;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6604();
        assert(cs == 0x19e4);
        sp += 0x0012;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x19e4);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b4ad() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x002c;
        r16[ax] = memory16get(ds, 0x9c66);
        r16[dx] = 0;
        push(r16[dx]);
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6a15();
        assert(cs == 0x19e4);
        sp += 0x0008;
        r16[di] = 0;
    case 0x1b4cb:
        if (memory[ss*16 + bp + r16[di] - 44] == 0x00) {
            pc = 0x1b4d5;
            break;
        }
        r16[di]++;
        pc = 0x1b4cb;
        break;
    case 0x1b4d5:
        r16[si] = 0;
    case 0x1b4d7:
        r16[ax] = 0x0002;
        r16[ax] -= r16[di];
        if (r16[ax] <= r16[si]) {
            pc = 0x1b4ee;
            break;
        }
        r16[bx] = r16[si];
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        memory[ss*16 + r16[bx]] = 0x30;
        r16[si]++;
        pc = 0x1b4d7;
        break;
    case 0x1b4ee:
        memory[ss*16 + bp + r16[si] - 24] = 0x00;
        push(ss);
        r16[ax] = bp - 0x2c;
        push(r16[ax]);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6ae8();
        assert(cs == 0x19e4);
        sp += 0x0008;
        if (memory16get(ds, 0x9c66) >= 0x000b) {
            pc = 0x1b528;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b51a;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b521;
            break;
        }
    case 0x1b51a:
        memory16set(ss, bp - 4, 0x0002);
        pc = 0x1b52d;
        break;
    case 0x1b521:
        memory16set(ss, bp - 4, 0x0005);
        pc = 0x1b52d;
        break;
    case 0x1b528:
        memory16set(ss, bp - 4, 0x000f);
    case 0x1b52d:
        if (memory16get(ds, 0x9c6c) != 0x0001) {
            pc = 0x1b54e;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b542;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b549;
            break;
        }
    case 0x1b542:
        memory16set(ss, bp - 2, 0x0001);
        pc = 0x1b54e;
        break;
    case 0x1b549:
        memory16set(ss, bp - 2, 0x0004);
    case 0x1b54e:
        if (memory16get(ds, 0x9c6c) == 0x0003) {
            pc = 0x1b563;
            break;
        }
        if (memory16get(ds, 0x9c6c) == 0x0005) {
            pc = 0x1b563;
            break;
        }
        if (memory16get(ds, 0x9c6c) != 0x0007) {
            pc = 0x1b568;
            break;
        }
    case 0x1b563:
        memory16set(ss, bp - 2, 0x0000);
    case 0x1b568:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        r16[ax] = 0x0008;
        push(r16[ax]);
        r16[ax] = 0x0128;
        push(r16[ax]);
        push(cs);
        cs = 0x060b;
        yield* sub_6604();
        assert(cs == 0x19e4);
        sp += 0x0012;
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x19e4);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b596() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        if (memory16get(ds, 0x9c6c) != 0x0001) {
            pc = 0x1b5bf;
            break;
        }
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b5b3;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b5ba;
            break;
        }
    case 0x1b5b3:
        memory16set(ss, bp - 2, 0x0001);
        pc = 0x1b5bf;
        break;
    case 0x1b5ba:
        memory16set(ss, bp - 2, 0x0004);
    case 0x1b5bf:
        if (memory16get(ds, 0x9c6c) == 0x0003) {
            pc = 0x1b5d4;
            break;
        }
        if (memory16get(ds, 0x9c6c) == 0x0005) {
            pc = 0x1b5d4;
            break;
        }
        if (memory16get(ds, 0x9c6c) != 0x0007) {
            pc = 0x1b5d9;
            break;
        }
    case 0x1b5d4:
        memory16set(ss, bp - 2, 0x0000);
    case 0x1b5d9:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x002e;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0080;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        if (memory[ds*16 + 0x8a2c] != 0x00) {
            pc = 0x1b606;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1b60d;
            break;
        }
    case 0x1b606:
        memory16set(ss, bp - 4, 0x0002);
        pc = 0x1b612;
        break;
    case 0x1b60d:
        memory16set(ss, bp - 4, 0x0005);
    case 0x1b612:
        if (memory16get(ds, 0x9880) <= 0x002e) {
            pc = 0x1b61f;
            break;
        }
        memory16set(ds, 0x9880, 0x002e);
    case 0x1b61f:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[ax] = 0x0005;
        push(r16[ax]);
        push(memory16get(ds, 0x9880));
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0080;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        memory16set(ss, bp - 4, 0x000f);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x0080;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x002d;
        push(r16[ax]);
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0x0081;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0005;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x00ae;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        r16[di] = 0x0088;
        r16[si] = 0;
        pc = 0x1b6c5;
        break;
    case 0x1b6a4:
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        r16[ax] = 0x000f;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(r16[di]);
        push(cs);
        cs = 0x023f;
        yield* sub_412a();
        assert(cs == 0x19e4);
        sp += 0x000e;
        r16[di] += 0x0007;
        r16[si]++;
    case 0x1b6c5:
        if (r16[si] < 0x0005) {
            pc = 0x1b6a4;
            break;
        }
        push(cs);
        cs = 0x1829;
        yield* sub_1839a();
        assert(cs == 0x19e4);
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b6d5() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        if (memory16get(ss, bp + 8) == 0x0000) {
            pc = 0x1b6ff;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x19e4);
        sp = bp;
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x19e4);
        sp = bp;
    case 0x1b6ff:
        r16[si] = 0;
        pc = 0x1b70b;
        break;
    case 0x1b703:
        memory[ds*16 + r16[si] + 37756] = 0x00;
        r16[si] += 0x0005;
    case 0x1b70b:
        if (r16[si] < 0x0190) {
            pc = 0x1b703;
            break;
        }
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b714() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        if (memory16get(ds, 0x9874) != 0x0000) {
            pc = 0x1b75f;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1b75f;
            break;
        }
        r16[ax] = memory16get(ss, bp + 6);
        if (r16[ax] < memory16get(ds, 0x989a)) {
            pc = 0x1b74c;
            break;
        }
        if (memory16get(ds, 0x987e) != 0x0000) {
            pc = 0x1b75f;
            break;
        }
        memory16set(ds, 0x989a, 0x0000);
        push(cs);
        yield* sub_1b341();
        sp = bp;
        r16[ax] = 0x0001;
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        pc = 0x1b75f;
        break;
    case 0x1b74c:
        r16[ax] = memory16get(ss, bp + 6);
        if (!prehistorikInifniteEnergy)
            memory16set(ds, 0x989a, memory16get(ds, 0x989a) - r16[ax]);
        push(cs);
        yield* sub_1b341();
        sp = bp;
        memory16set(ds, 0x9874, 0x0013);
    case 0x1b75f:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b761() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory16get(ds, 0x9870) != 0x0001) {
            pc = 0x1b792;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9c60, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x97de, r16[ax]);
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x1b783;
            break;
        }
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x1b792;
            break;
        }
    case 0x1b783:
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9876, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xffe2;
        memory16set(ds, 0x9804, r16[ax]);
    case 0x1b792:
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x1b7a0;
            break;
        }
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x1b7ff;
            break;
        }
    case 0x1b7a0:
        memory16set(ds, 0x9804, memory16get(ds, 0x9804) - 0x0008);
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x1b7c8;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0076;
        push(r16[ax]);
        push(memory16get(ds, 0x9804));
        push(memory16get(ds, 0x9876));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        pc = 0x1b7ff;
        break;
    case 0x1b7c8:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0076;
        push(r16[ax]);
        push(memory16get(ds, 0x9804));
        push(memory16get(ds, 0x9876));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x007d;
        push(r16[ax]);
        push(memory16get(ds, 0x9804));
        r16[ax] = memory16get(ds, 0x9876);
        r16[ax] += 0x0015;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
    case 0x1b7ff:
        if (memory16get(ds, 0x9870) >= 0x0009) {
            pc = 0x1b833;
            break;
        }
        r16[bx] = memory16get(ds, 0x9870);
        r16[bx]--;
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 32780);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(memory16get(ds, 0x97f2));
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfffb;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        memory16set(ds, 0x9870, memory16get(ds, 0x9870) + 1);
        pc = 0x1b932;
        break;
    case 0x1b833:
        if (memory16get(ds, 0x97fa) == 0x0000) {
            pc = 0x1b87d;
            break;
        }
        r16[si] = memory16get(ds, 0x97fa);
        r16[si] &= 0x0001;
        r16[si] += 0x0027;
        memory16set(ds, 0x97fa, memory16get(ds, 0x97fa) + 1);
        memory16set(ds, 0x97de, memory16get(ds, 0x97de) - 0x0004);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(memory16get(ds, 0x97de));
        push(memory16get(ds, 0x9c60));
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        if (memory16get(ds, 0x9890) == 0x0000) {
            pc = 0x1b873;
            break;
        }
        memory16set(ds, 0x97de, 0xffff);
    case 0x1b873:
        if (memory16gets(ds, 0x97de) <= signed16(0x0000)) {
            pc = 0x1b87d;
            break;
        }
        pc = 0x1b932;
        break;
    case 0x1b87d:
        memory16set(ds, 0x97fa, 0x0000);
        r16[ax] = memory16get(ds, 0x9c64);
        memory16set(ds, 0x988e, r16[ax]);
        r16[ax] = memory16get(ds, 0x97fc);
        memory16set(ds, 0x97f2, r16[ax]);
        if (memory16gets(ds, 0x988e) >= signed16(0x0006)) {
            pc = 0x1b89c;
            break;
        }
        memory16set(ds, 0x988e, 0x0006);
    case 0x1b89c:
        if (memory16gets(ds, 0x988e) <= signed16(0x011d)) {
            pc = 0x1b8aa;
            break;
        }
        memory16set(ds, 0x988e, 0x011d);
    case 0x1b8aa:
        memory16set(ds, 0x9874, 0x0027);
        memory16set(ds, 0x989a, 0x000a);
        push(cs);
        yield* sub_1b341();
        memory16set(ds, 0x9800, 0x0000);
        memory16set(ds, 0x9892, 0x0000);
        memory16set(ds, 0x97ea, 0x0000);
        memory16set(ds, 0x9c62, 0x0000);
        memory16set(ds, 0x9868, 0x0000);
        memory16set(ds, 0x97f4, 0x0014);
        r16[ax] = 0;
        memory16set(ds, 0x97e2, r16[ax]);
        memory16set(ds, 0x97f8, r16[ax]);
        memory16set(ds, 0x9862, r16[ax]);
        memory16set(ds, 0x97fa, r16[ax]);
        memory16set(ds, 0x9870, r16[ax]);
        if (memory16gets(ds, 0x9c5e) < r16s[ax]) {
            pc = 0x1b8fd;
            break;
        }
        push(cs);
        yield* sub_1b3e8();
    case 0x1b8fd:
        if (memory16get(ds, 0x9c66) != 0x0000) {
            pc = 0x1b90a;
            break;
        }
        memory16set(ds, 0x9c66, 0x0032);
    case 0x1b90a:
        if (memory16get(ds, 0x9c66) >= 0x000b) {
            pc = 0x1b916;
            break;
        }
        memory16set(ds, 0x9c66, memory16get(ds, 0x9c66) + 0x000a);
    case 0x1b916:
        push(cs);
        yield* sub_1b4ad();
        memory16set(ds, 0x985a, 0x0000);
        r16[ax] = memory16get(ds, 0x9866);
        if (r16[ax] == memory16get(ds, 0x9c68)) {
            pc = 0x1b932;
            break;
        }
        memory16set(ds, 0x9c68, r16[ax]);
        memory16set(ds, 0x9872, 0x0001);
    case 0x1b932:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1b934() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1b990;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0002);
        if (memory16get(ds, 0x986a) == 0x0000) {
            pc = 0x1b953;
            break;
        }
        if (memory16gets(ds, 0x988e) <= signed16(0x0004)) {
            pc = 0x1b953;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - 0x0005);
    case 0x1b953:
        if (memory16get(ds, 0x988c) == 0x0000) {
            pc = 0x1b95f;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0005);
    case 0x1b95f:
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x1b972;
            break;
        }
        if (memory16gets(ds, 0x97f2) <= signed16(0x001e)) {
            pc = 0x1b972;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0008);
    case 0x1b972:
        if (memory16get(ds, 0x9802) == 0x0000) {
            pc = 0x1b97e;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0005);
    case 0x1b97e:
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9c64, r16[ax]);
        memory16set(ds, 0x97fc, 0x0064);
        r16[ax] = memory16get(ds, 0x9c68);
        memory16set(ds, 0x9866, r16[ax]);
    case 0x1b990:
        cs = pop();
        return;
    } while (1);
}
function* sub_1b991() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[di] = 0;
        if (memory16gets(ds, 0x9c5e) >= signed16(r16[di])) {
            pc = 0x1b9a3;
            break;
        }
        pc = 0x1bdac;
        break;
    case 0x1b9a3:
        if (!(memory16get(ds, 0x987e) & 0x0003)) {
            pc = 0x1b9e3;
            break;
        }
        r16[ax] = r16[di];
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x987e);
        r16[ax] &= 0x0003;
        r16[ax] += 0x002c;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0004;
        push(r16[ax]);
        r16[ax] = r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x987e);
        r16[ax] &= 0x0003;
        if (r16[ax] != 0x0003) {
            pc = 0x1b9dc;
            break;
        }
        pc = 0x1bdac;
        break;
    case 0x1b9dc:
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) + 1);
        pc = 0x1bdac;
        break;
    case 0x1b9e3:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x1b9f1;
            break;
        }
        push(cs);
        yield* sub_1b761();
        pc = 0x1bdac;
        break;
    case 0x1b9f1:
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x1ba48;
            break;
        }
        memory16set(ds, 0x9868, 0x0000);
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x1ba10;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0004);
        memory16set(ds, 0x9892, memory16get(ds, 0x9892) ^ 0x0001);
    case 0x1ba10:
        if (memory16get(ds, 0x9802) == 0x0000) {
            pc = 0x1ba22;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0004);
        memory16set(ds, 0x9892, memory16get(ds, 0x9892) ^ 0x0001);
    case 0x1ba22:
        r16[ax] = memory16get(ds, 0x9892);
        r16[ax] &= 0x0001;
        r16[ax] += 0x0010;
        memory16set(ss, bp - 2, r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ds, 0x97f2));
        push(memory16get(ds, 0x988e));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        pc = 0x1bdac;
        break;
    case 0x1ba48:
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x1ba6f;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0075;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xffe2;
        push(r16[ax]);
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        pc = 0x1bdac;
        break;
    case 0x1ba6f:
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x1bab0;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0075;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        push(memory16get(ds, 0x988e));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x007d;
        push(r16[ax]);
        push(memory16get(ds, 0x97f2));
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0015;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        pc = 0x1bdac;
        break;
    case 0x1bab0:
        memory16set(ss, bp - 2, 0x0001);
        r16[ax] = 0;
        memory16set(ds, 0x985e, r16[ax]);
        memory16set(ds, 0x986e, r16[ax]);
        r16[si] = r16[ax];
        if (memory16get(ds, 0x9868) == r16[ax]) {
            pc = 0x1bac8;
            break;
        }
        pc = 0x1bb45;
        break;
    case 0x1bac8:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0008;
        push(r16[ax]);
        push(cs);
        yield* sub_1b19e();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x1bb45;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0017;
        push(r16[ax]);
        push(cs);
        yield* sub_1b19e();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x1bb45;
            break;
        }
        if (memory16get(ds, 0x97e6) != 0x0000) {
            pc = 0x1bb45;
            break;
        }
        r16[di] = 0x0001;
        memory16set(ss, bp - 2, 0x0004);
    case 0x1bb09:
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 1);
        r16[si]++;
        if (r16[si] >= 0x000a) {
            pc = 0x1bb45;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0008;
        push(r16[ax]);
        push(cs);
        yield* sub_1b19e();
        sp += 0x0004;
        if (!r16[ax]) {
            pc = 0x1bb45;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0017;
        push(r16[ax]);
        push(cs);
        yield* sub_1b19e();
        sp += 0x0004;
        if (r16[ax]) {
            pc = 0x1bb09;
            break;
        }
    case 0x1bb45:
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bb70;
            break;
        }
        if (r16[di]) {
            pc = 0x1bb70;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1bb70;
            break;
        }
        if (memory16get(ds, 0x97e6) != 0x0000) {
            pc = 0x1bb70;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        memory16set(ds, 0x9c64, r16[ax]);
        r16[ax] = memory16get(ds, 0x97f2);
        memory16set(ds, 0x97fc, r16[ax]);
        r16[ax] = memory16get(ds, 0x9c68);
        memory16set(ds, 0x9866, r16[ax]);
    case 0x1bb70:
        if (memory16get(ds, 0x986a) != 0x0000) {
            pc = 0x1bb7a;
            break;
        }
        pc = 0x1bbfc;
        break;
    case 0x1bb7a:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x1bb84;
            break;
        }
        pc = 0x1bbfc;
        break;
    case 0x1bb84:
        r16[si] = 0x0005;
        if (r16[di]) {
            pc = 0x1bbcf;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bbcf;
            break;
        }
        memory16set(ds, 0x9892, memory16get(ds, 0x9892) + 1);
        if (memory16get(ds, 0x9892) <= r16[si]) {
            pc = 0x1bba2;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
    case 0x1bba2:
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32796);
        memory16set(ss, bp - 2, r16[ax]);
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 32808);
        if (memory16get(ds, 0x9800) != 0x0001) {
            pc = 0x1bbcf;
            break;
        }
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32820);
        r16[ax] = -r16[ax];
        memory16set(ds, 0x986e, r16[ax]);
    case 0x1bbcf:
        if (memory16get(ds, 0x9800) == 0x0001) {
            pc = 0x1bbe6;
            break;
        }
        if (r16[di]) {
            pc = 0x1bbe6;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bbe6;
            break;
        }
        memory16set(ss, bp - 2, 0x0087);
    case 0x1bbe6:
        memory16set(ds, 0x9800, 0x0001);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - r16[si]);
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x1bbfc;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - 0x0002);
    case 0x1bbfc:
        if (memory16get(ds, 0x988c) != 0x0000) {
            pc = 0x1bc06;
            break;
        }
        pc = 0x1bc86;
        break;
    case 0x1bc06:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x1bc10;
            break;
        }
        pc = 0x1bc86;
        break;
    case 0x1bc10:
        r16[si] = 0x0005;
        if (r16[di]) {
            pc = 0x1bc59;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bc59;
            break;
        }
        memory16set(ds, 0x9892, memory16get(ds, 0x9892) + 1);
        if (memory16get(ds, 0x9892) <= r16[si]) {
            pc = 0x1bc2e;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
    case 0x1bc2e:
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32796);
        memory16set(ss, bp - 2, r16[ax]);
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[si] = memory16get(ds, r16[bx] + 32808);
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1bc59;
            break;
        }
        r16[bx] = memory16get(ds, 0x9892);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32820);
        memory16set(ds, 0x986e, r16[ax]);
    case 0x1bc59:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1bc70;
            break;
        }
        if (r16[di]) {
            pc = 0x1bc70;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bc70;
            break;
        }
        memory16set(ss, bp - 2, 0x0087);
    case 0x1bc70:
        memory16set(ds, 0x9800, 0x0000);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + r16[si]);
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x1bc86;
            break;
        }
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0002);
    case 0x1bc86:
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bc90;
            break;
        }
        pc = 0x1bd18;
        break;
    case 0x1bc90:
        r16[si] = 0;
    case 0x1bc92:
        memory16set(ds, 0x9868, memory16get(ds, 0x9868) + 1);
        r16[si]++;
        if (memory16get(ds, 0x9868) != 0x0002) {
            pc = 0x1bcae;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        if (r16[ax] <= 0x0014) {
            pc = 0x1bcae;
            break;
        }
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dcd2();
        assert(cs == 0x19e4);
    case 0x1bcae:
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        r16[ax] += 0xfff8;
        if (r16[ax] >= memory16get(ds, 0x9868)) {
            pc = 0x1bccd;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        if (r16[ax] <= memory16get(ds, 0x9868)) {
            pc = 0x1bccd;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 1);
    case 0x1bccd:
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        r16[ax] += 0xfffa;
        if (r16[ax] <= memory16get(ds, 0x9868)) {
            pc = 0x1bce1;
            break;
        }
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0002);
    case 0x1bce1:
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        if (r16[ax] >= memory16get(ds, 0x9868)) {
            pc = 0x1bd04;
            break;
        }
        memory16set(ds, 0x9868, 0x0000);
        r16[di] = 0x0001;
        if (!(memory16get(ds, 0x97f4) & 0x0080)) {
            pc = 0x1bd04;
            break;
        }
        r16[ax] = memory16get(ds, 0x9c70);
        memory16set(ds, 0x97f4, r16[ax]);
    case 0x1bd04:
        if (memory16get(ds, 0x9868) == 0x0000) {
            pc = 0x1bd13;
            break;
        }
        if (r16[si] >= 0x0004) {
            pc = 0x1bd13;
            break;
        }
        pc = 0x1bc92;
        break;
    case 0x1bd13:
        memory16set(ss, bp - 2, 0x0004);
    case 0x1bd18:
        if (r16[di]) {
            pc = 0x1bd30;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bd30;
            break;
        }
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x1bd30;
            break;
        }
        memory16set(ds, 0x9868, 0x0001);
    case 0x1bd30:
        if (memory16get(ds, 0x9862) == 0x0000) {
            pc = 0x1bd89;
            break;
        }
        r16[si] = 0x0002;
        r16[si] -= memory16get(ds, 0x9862);
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1bd49;
            break;
        }
        if (!r16[di]) {
            pc = 0x1bd4c;
            break;
        }
    case 0x1bd49:
        r16[si] += 0x0002;
    case 0x1bd4c:
        r16[si] <<= 1;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32832);
        memory16set(ss, bp - 2, r16[ax]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32832);
        memory16set(ds, 0x985e, r16[ax]);
        if (memory16get(ds, 0x986a) == 0x0000) {
            pc = 0x1bd77;
            break;
        }
        memory16set(ds, 0x9800, 0x0001);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) - 0x0005);
    case 0x1bd77:
        if (memory16get(ds, 0x988c) == 0x0000) {
            pc = 0x1bd89;
            break;
        }
        memory16set(ds, 0x9800, 0x0000);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0005);
    case 0x1bd89:
        push(memory16get(ds, 0x9800));
        push(memory16get(ss, bp - 2));
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += memory16get(ds, 0x985e);
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += memory16get(ds, 0x986e);
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
    case 0x1bdac:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1bdb2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0036;
        push(ss);
        r16[ax] = bp - 0x30;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8050;
        push(r16[ax]);
        r16[cx] = 0x0018;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x19e4);
        push(ss);
        r16[ax] = bp - 0x18;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8068;
        push(r16[ax]);
        r16[cx] = 0x0018;
        push(cs);
        cs = 0x01ed;
        yield* sub_21c4();
        assert(cs == 0x19e4);
        push(cs);
        cs = 0x19e4;
        yield* sub_1bebe();
        assert(cs == 0x19e4);
        if (memory16gets(ds, 0x9c5e) >= signed16(0x0000)) {
            pc = 0x1bded;
            break;
        }
        pc = 0x1beb8;
        break;
    case 0x1bded:
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1bdfb;
            break;
        }
        if (memory16get(ds, 0x987e) == 0x0000) {
            pc = 0x1be04;
            break;
        }
    case 0x1bdfb:
        memory16set(ds, 0x9862, 0x0000);
        pc = 0x1beb8;
        break;
    case 0x1be04:
        if (memory16get(ds, 0x9862) != 0x0000) {
            pc = 0x1be0e;
            break;
        }
        pc = 0x1beb8;
        break;
    case 0x1be0e:
        r16[ax] = memory16get(ds, 0x9800);
        memory16set(ss, bp - 50, r16[ax]);
        r16[si] = 0x0002;
        r16[si] -= memory16get(ds, 0x9862);
        r16[ax] = r16[si];
        r16[dx] = 0x0003;
        mul16(r16[dx]);
        r16[si] = r16[ax];
        if (memory16get(ds, 0x97f8) == 0x0000) {
            pc = 0x1be5b;
            break;
        }
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r16[di] = memory16get(ss, r16[bx]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ss, r16[bx]);
        memory16set(ss, bp - 52, r16[ax]);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        r16[ax] = bp - 0x18;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ss, r16[bx]);
        memory16set(ss, bp - 54, r16[ax]);
        pc = 0x1be89;
        break;
    case 0x1be5b:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        r16[ax] = bp - 0x30;
        r16[bx] += r16[ax];
        r16[di] = memory16get(ss, r16[bx]);
        r16[bx] = r16[si];
        r16[bx]++;
        r16[bx] <<= 1;
        r16[ax] = bp - 0x30;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ss, r16[bx]);
        memory16set(ss, bp - 52, r16[ax]);
        r16[bx] = r16[si];
        r16[bx] += 0x0002;
        r16[bx] <<= 1;
        r16[ax] = bp - 0x30;
        r16[bx] += r16[ax];
        r16[ax] = memory16get(ss, r16[bx]);
        memory16set(ss, bp - 54, r16[ax]);
    case 0x1be89:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1be96;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] = -r16[ax];
        r16[di] = r16[ax];
    case 0x1be96:
        push(memory16get(ss, bp - 50));
        push(memory16get(ss, bp - 54));
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += memory16get(ss, bp - 52);
        push(r16[ax]);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += r16[di];
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x19e4);
        sp += 0x000a;
        memory16set(ds, 0x9862, memory16get(ds, 0x9862) - 1);
    case 0x1beb8:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1bebe() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, false);
        push(cs);
        cs = 0x0a34;
        yield* sub_a78f();
        assert(cs == 0x19e4);
        r8[ah] = 0x00;
        memory16set(ds, 0x9890, r16[ax]);
        if (!r16[ax]) {
            pc = 0x1bf0c;
            break;
        }
        if (memory16get(ds, 0x97ec) == 0x0000) {
            pc = 0x1bedb;
            break;
        }
        memory16set(ds, 0x9890, 0x0000);
        pc = 0x1bf12;
        break;
    case 0x1bedb:
        if (memory16get(ds, 0x9862) != 0x0000) {
            pc = 0x1bf12;
            break;
        }
        if (memory16get(ds, 0x9870) != 0x0000) {
            pc = 0x1bf12;
            break;
        }
        if (memory16get(ds, 0x97e2) != 0x0000) {
            pc = 0x1bf12;
            break;
        }
        if (memory16get(ds, 0x97e8) != 0x0000) {
            pc = 0x1bf12;
            break;
        }
        if (memory16get(ds, 0x989c) != 0x0000) {
            pc = 0x1bf12;
            break;
        }
        memory16set(ds, 0x97ec, 0x0001);
        memory16set(ds, 0x9862, 0x0002);
        pc = 0x1bf12;
        break;
    case 0x1bf0c:
        memory16set(ds, 0x97ec, 0x0000);
    case 0x1bf12:
        cs = pop();
        return;
    } while (1);
}
function* sub_1bf13() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        memory16set(ds, 0x9860, 0x0001);
        r16[bx] = memory16get(ds, 0x9856);
        es = memory16get(ds, 0x9856 + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[ax] = r16[bx];
        r16[ax] |= memory16get(ss, bp - 10);
        if (r16[ax]) {
            pc = 0x1bf35;
            break;
        }
        pc = 0x1dc40;
        break;
    case 0x1bf35:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx]) != 0x0000) {
            pc = 0x1bf41;
            break;
        }
        pc = 0x1dc40;
        break;
    case 0x1bf41:
        r16[ax] = memory16get(es, r16[bx]);
        r16[ax]--;
        if (r16[ax] > 0x0026) {
            pc = 0x1bf35;
            break;
        }
        r16[bx] = r16[ax];
        r16[bx] <<= 1;
        switch (r16[bx])
        {
        case 0: pc = 0x1bff1; break;
        case 2: pc = 0x1bfa1; break;
        case 4: pc = 0x1c26d; break;
        case 6: pc = 0x1c35f; break;
        case 8: pc = 0x1c0ba; break;
        case 10: pc = 0x1c454; break;
        case 12: pc = 0x1c57f; break;
        case 14: pc = 0x1c61f; break;
        case 16: pc = 0x1c66c; break;
        case 18: pc = 0x1c73e; break;
        case 20: pc = 0x1c75c; break;
        case 22: pc = 0x1c77b; break;
        case 24: pc = 0x1c799; break;
        case 26: pc = 0x1c7b7; break;
        case 28: pc = 0x1c988; break;
        case 30: pc = 0x1cafa; break;
        case 32: pc = 0x1cbb7; break;
        case 34: pc = 0x1cbd5; break;
        case 36: pc = 0x1cc38; break;
        case 38: pc = 0x1cf58; break;
        case 40: pc = 0x1cca7; break;
        case 42: pc = 0x1ccdd; break;
        case 44: pc = 0x1cdea; break;
        case 46: pc = 0x1cff3; break;
        case 48: pc = 0x1d0b7; break;
        case 50: pc = 0x1d1a1; break;
        case 52: pc = 0x1d204; break;
        case 54: pc = 0x1d2e3; break;
        case 56: pc = 0x1d3b9; break;
        case 58: pc = 0x1d4e1; break;
        case 60: pc = 0x1d646; break;
        case 62: pc = 0x1d74e; break;
        case 64: pc = 0x1d920; break;
        case 66: pc = 0x1d93e; break;
        case 68: pc = 0x1d95c; break;
        case 70: pc = 0x1da4b; break;
        case 72: pc = 0x1db3d; break;
        case 74: pc = 0x1dbb5; break;
        case 76: pc = 0x1dc1e; break;
            default:
            assert(0);
        }
        break;
    case 0x1bfa1:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0xffeb;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1bfb4;
            break;
        }
        pc = 0x1dbae;
        break;
    case 0x1bfb4:
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0005;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1bfc4;
            break;
        }
        pc = 0x1dbae;
        break;
    case 0x1bfc4:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001b;
        if (r16s[ax] > memory16gets(es, r16[bx] + 4)) {
            pc = 0x1bfd3;
            break;
        }
        pc = 0x1dbae;
        break;
    case 0x1bfd3:
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfff0;
        if (r16s[ax] > memory16gets(ds, 0x97f2)) {
            pc = 0x1bfe3;
            break;
        }
        pc = 0x1dbae;
        break;
    case 0x1bfe3:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
        pc = 0x1dbae;
        break;
    case 0x1bff1:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfff8;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (r16s[ax] < memory16gets(es, r16[bx] + 2)) {
            pc = 0x1c003;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c003:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0008;
        if (r16s[ax] > memory16gets(es, r16[bx] + 2)) {
            pc = 0x1c012;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c012:
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x1c062;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] -= memory16get(es, r16[bx] + 6);
        if (r16s[ax] >= signed16(0x0003)) {
            pc = 0x1c03a;
            break;
        }
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x1c03a;
            break;
        }
        memory16set(ds, 0x97e2, 0x0000);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax]--;
        memory16set(ds, 0x97f2, r16[ax]);
    case 0x1c03a:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        if (r16[ax] != memory16get(ds, 0x97f2)) {
            pc = 0x1c062;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
        memory16set(ds, 0x97e2, 0x0001);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0004;
        memory16set(ds, 0x988e, r16[ax]);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0004);
    case 0x1c062:
        if (memory16get(ds, 0x9802) != 0x0000) {
            pc = 0x1c06c;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c06c:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        if (r16[ax] != memory16get(ds, 0x97f2)) {
            pc = 0x1c094;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
        memory16set(ds, 0x97e2, 0x0001);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0004;
        memory16set(ds, 0x988e, r16[ax]);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0004);
    case 0x1c094:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] -= memory16get(ds, 0x97f2);
        if (r16s[ax] < signed16(0x0003)) {
            pc = 0x1c0a7;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c0a7:
        if (memory16get(ds, 0x97e2) != 0x0000) {
            pc = 0x1c0b1;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c0b1:
        memory16set(ds, 0x97e2, 0x0000);
        pc = 0x1d4da;
        break;
    case 0x1c0ba:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (!(memory16get(es, r16[bx] + 10) & 0x0080)) {
            pc = 0x1c112;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(es, r16[bx] + 10);
        r16[bx] += 0xff80;
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32904));
        push(memory16get(ds, 0x9c76));
        push(memory16get(ds, 0x988e));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        memory16set(ds, 0x9c74, memory16get(ds, 0x9c74) + 0x0004);
        r16[ax] = memory16get(ds, 0x9c74);
        memory16set(ds, 0x9c76, memory16get(ds, 0x9c76) + r16[ax]);
        if (r16[ax] != 0x0014) {
            pc = 0x1c112;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[ax] += 0xff80;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b042();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, 0x0000);
    case 0x1c112:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 8) < signed16(0x0046)) {
            pc = 0x1c11f;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c11f:
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) + 1);
        if (memory16gets(es, r16[bx] + 8) <= signed16(0x000f)) {
            pc = 0x1c15c;
            break;
        }
        if (memory16gets(es, r16[bx] + 8) >= signed16(0x0015)) {
            pc = 0x1c15c;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[ax] += 0xfff0;
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] += 0x0056;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x000b;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0004;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
    case 0x1c15c:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 8) > signed16(0x0014)) {
            pc = 0x1c169;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c169:
        if (memory16get(es, r16[bx] + 8) != 0x0015) {
            pc = 0x1c182;
            break;
        }
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = 0x0006;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, r16[dx]);
    case 0x1c182:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 8) < signed16(0x0041)) {
            pc = 0x1c18f;
            break;
        }
        pc = 0x1c23a;
        break;
    case 0x1c18f:
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[ax] &= 0x0003;
        memory16set(ss, bp - 6, r16[ax]);
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        if (r16[ax]) {
            pc = 0x1c1a6;
            break;
        }
        r16[si]++;
    case 0x1c1a6:
        if (memory16get(ss, bp - 6) != 0x0001) {
            pc = 0x1c1ad;
            break;
        }
        r16[di]++;
    case 0x1c1ad:
        if (memory16get(ss, bp - 6) != 0x0002) {
            pc = 0x1c1b4;
            break;
        }
        r16[si]--;
    case 0x1c1b4:
        if (memory16get(ss, bp - 6) != 0x0003) {
            pc = 0x1c1bb;
            break;
        }
        r16[di]--;
    case 0x1c1bb:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0059;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = r16[si];
        r16[ax] += 0x0023;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1c1dd;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c1dd:
        r16[ax] = r16[si];
        r16[ax] += 0xffd8;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1c1eb;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c1eb:
        r16[ax] = r16[di];
        r16[ax] += 0xffe3;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1c1f9;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c1f9:
        r16[ax] = r16[di];
        r16[ax] += 0x0014;
        if (r16s[ax] > memory16gets(ds, 0x97f2)) {
            pc = 0x1c207;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c207:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x1c211;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1c211:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) | 0x0080);
        memory16set(ds, 0x9c74, 0xffec);
        memory16set(ds, 0x9c72, r16[si]);
        r16[ax] = r16[di];
        r16[ax] += 0x000a;
        memory16set(ds, 0x9c76, r16[ax]);
        memory16set(es, r16[bx] + 8, 0x0041);
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x1bf1);
        pc = 0x1d747;
        break;
    case 0x1c23a:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0058;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[dx] = memory16get(es, r16[bx] + 8);
        r16[dx] += 0xffbf;
        r16[dx] = sar16(r16[dx], 1);
        r16[ax] -= r16[dx];
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x000b;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0004;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1d747;
        break;
    case 0x1c26d:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1c27a;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c27a:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0080;
        r16[ax] -= memory16get(es, r16[bx] + 6);
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ds, 0x9c6c) == 0x0005) {
            pc = 0x1c2a6;
            break;
        }
        if (memory16get(ds, 0x9c6c) != 0x0007) {
            pc = 0x1c2ab;
            break;
        }
    case 0x1c2a6:
        r16[di] = 0x000d;
        pc = 0x1c2ae;
        break;
    case 0x1c2ab:
        r16[di] = 0x0009;
    case 0x1c2ae:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] -= r16[di];
        if (r16[ax] == memory16get(ds, 0x97f2)) {
            pc = 0x1c2c0;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c2c0:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x1c2ca;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c2ca:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1c2e8;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1c2e8;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1c312;
            break;
        }
    case 0x1c2e8:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1c2f2;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c2f2:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1c302;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c302:
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0xffdd;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1c312;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c312:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
        if (memory16get(es, r16[bx] + 6) == 0x0000) {
            pc = 0x1c32b;
            break;
        }
        if (memory16get(ds, 0x97f8) == 0x0000) {
            pc = 0x1c32b;
            break;
        }
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
    case 0x1c32b:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) == 0x0000) {
            pc = 0x1c338;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c338:
        memory16set(ds, 0x9880, memory16get(ds, 0x9880) + 1);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1bf1);
        r16[ax] = 0x0032;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfffc;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 2));
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
        pc = 0x1d4da;
        break;
    case 0x1c35f:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1c36c;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c36c:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0093;
        r16[ax] -= memory16get(es, r16[bx] + 6);
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfffe;
        if (r16[ax] != memory16get(ds, 0x97f2)) {
            pc = 0x1c3fd;
            break;
        }
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x1c3fd;
            break;
        }
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1c3be;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0028;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 2)) {
            pc = 0x1c3be;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1c3df;
            break;
        }
    case 0x1c3be:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1c3fd;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0023;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1c3fd;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 2);
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1c3fd;
            break;
        }
    case 0x1c3df:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
        if (memory16get(ds, 0x97f8) == 0x0000) {
            pc = 0x1c3f8;
            break;
        }
        if (memory16get(es, r16[bx] + 6) == 0x0000) {
            pc = 0x1c3f8;
            break;
        }
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
    case 0x1c3f8:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x1bf1);
    case 0x1c3fd:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1c40a;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c40a:
        r16[ax] = memory16get(es, r16[bx] + 4);
        if (r16s[ax] > memory16gets(ds, 0x97f2)) {
            pc = 0x1c417;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c417:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0019;
        if (r16s[ax] > memory16gets(es, r16[bx] + 2)) {
            pc = 0x1c426;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c426:
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0019;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1c436;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c436:
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xffdd;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1c446;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1c446:
        r16[ax] = 0x000a;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
        pc = 0x1d4da;
        break;
    case 0x1c454:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1c461;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c461:
        if (memory16get(es, r16[bx] + 8) == 0x0001) {
            pc = 0x1c46b;
            break;
        }
        pc = 0x1c504;
        break;
    case 0x1c46b:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x003d;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0028;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0014;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[dx] += 0x0028;
        if (r16s[ax] > r16s[dx]) {
            pc = 0x1c4a4;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c4a4:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xffec;
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[dx] += 0x0028;
        if (r16s[ax] < r16s[dx]) {
            pc = 0x1c4b8;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c4b8:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x0019;
        if (r16s[ax] > memory16gets(es, r16[bx] + 4)) {
            pc = 0x1c4c7;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c4c7:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] < memory16gets(es, r16[bx] + 4)) {
            pc = 0x1c4d6;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c4d6:
        memory16set(es, r16[bx] + 8, 0x0000);
        r16[ax] = 0x0064;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfffc;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0028;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
    case 0x1c4f8:
        memory16set(ds, 0x9880, memory16get(ds, 0x9880) + 1);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1bf1);
        pc = 0x1d0b0;
        break;
    case 0x1c504:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (r16s[ax] > memory16gets(es, r16[bx] + 2)) {
            pc = 0x1c516;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c516:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfff6;
        if (r16s[ax] < memory16gets(es, r16[bx] + 2)) {
            pc = 0x1c525;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c525:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x1c52f;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c52f:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x000f;
        if (r16s[ax] > memory16gets(es, r16[bx] + 4)) {
            pc = 0x1c53e;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c53e:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] < memory16gets(es, r16[bx] + 4)) {
            pc = 0x1c54d;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c54d:
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) - 1);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x003d;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfffa;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0028;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x1bf1);
        pc = 0x1d0b0;
        break;
    case 0x1c57f:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) == 0x0001) {
            pc = 0x1c58c;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c58c:
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += memory16get(ds, 0x988a);
        r16[ax] += 0x003d;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[di] -= r16[ax];
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x003e;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0014;
        if (r16s[ax] > signed16(r16[si])) {
            pc = 0x1c5d8;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c5d8:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xffec;
        if (r16s[ax] < signed16(r16[si])) {
            pc = 0x1c5e5;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c5e5:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x0019;
        if (r16s[ax] > signed16(r16[di])) {
            pc = 0x1c5f2;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c5f2:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] < signed16(r16[di])) {
            pc = 0x1c5ff;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c5ff:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 8, 0x0000);
        r16[bx] = memory16get(es, r16[bx] + 6);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32916));
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
        pc = 0x1c4f8;
        break;
    case 0x1c61f:
        if (memory16get(ds, 0x97e8) == 0x0000) {
            pc = 0x1c629;
            break;
        }
        pc = 0x1db36;
        break;
    case 0x1c629:
        if (memory16get(ds, 0x989c) == 0x0000) {
            pc = 0x1c633;
            break;
        }
        pc = 0x1db36;
        break;
    case 0x1c633:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 12));
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1db36;
        break;
    case 0x1c66c:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1c6ae;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0054;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) - r16[ax]);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1c6ed;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0001);
        pc = 0x1c6ed;
        break;
    case 0x1c6ae:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0055;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + r16[ax]);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + 1);
        if (memory16get(es, r16[bx] + 6) != 0x0014) {
            pc = 0x1c6ed;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0000);
        memory16set(es, r16[bx] + 4, 0x00dc);
    case 0x1c6ed:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0xffe9;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1c700;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c700:
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x000f;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1c710;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c710:
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xffe7;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1c720;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c720:
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x0019;
        if (r16s[ax] > memory16gets(ds, 0x97f2)) {
            pc = 0x1c730;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1c730:
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
        pc = 0x1d0b0;
        break;
    case 0x1c73e:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2890;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1c75c:
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x28c0;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1c77b:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x28f0;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1c799:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x2920;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1c7b7:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 2) < signed16(0x0004)) {
            pc = 0x1c7c4;
            break;
        }
        pc = 0x1c8f5;
        break;
    case 0x1c7c4:
        if (memory16get(es, r16[bx] + 2) != 0x0000) {
            pc = 0x1c805;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005e;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) == 0x0000) {
            pc = 0x1c7f2;
            break;
        }
        pc = 0x1c896;
        break;
    case 0x1c7f2:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x1c7fc;
            break;
        }
        pc = 0x1c896;
        break;
    case 0x1c7fc:
        memory16set(es, r16[bx] + 2, 0x0001);
        pc = 0x1c896;
        break;
    case 0x1c805:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 2) >= signed16(0x0003)) {
            pc = 0x1c863;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x005c;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, memory16get(es, r16[bx] + 2) + 1);
        if (memory16get(es, r16[bx] + 2) == 0x0003) {
            pc = 0x1c83e;
            break;
        }
        pc = 0x1c896;
        break;
    case 0x1c83e:
        memory16set(es, r16[bx] + 8, 0x0001);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfff4;
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x0012;
        memory16set(es, r16[bx] + 12, r16[ax]);
        memory16set(es, r16[bx] + 2, 0x0000);
        pc = 0x1c896;
        break;
    case 0x1c863:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005f;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + 0x000a);
        if (memory16gets(es, r16[bx] + 4) <= signed16(0x0140)) {
            pc = 0x1c896;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0004);
    case 0x1c896:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 2) >= signed16(0x0003)) {
            pc = 0x1c8f5;
            break;
        }
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x1c8f5;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1c8f5;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xffdc;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1c8f5;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1c8f5;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1c8f5;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0003);
        r16[ax] = 0x0064;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
    case 0x1c8f5:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1c902;
            break;
        }
        pc = 0x1db36;
        break;
    case 0x1c902:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0060;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(memory16get(es, r16[bx] + 10));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = memory16get(ds, 0x988e);
        r16[dx] += 0x0014;
        if (r16s[ax] >= r16s[dx]) {
            pc = 0x1c96a;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = memory16get(ds, 0x988e);
        r16[dx] += 0xfff6;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1c96a;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x000c;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1c96a;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[dx] = memory16get(ds, 0x97f2);
        r16[dx] += 0x0017;
        if (r16s[ax] >= r16s[dx]) {
            pc = 0x1c96a;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0000);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1c96a:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) - 0x000c);
        if (memory16gets(es, r16[bx] + 10) < signed16(0xffba)) {
            pc = 0x1c97c;
            break;
        }
        pc = 0x1db36;
        break;
    case 0x1c97c:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 8, 0x0000);
        pc = 0x1db36;
        break;
    case 0x1c988:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 2) != 0x0000) {
            pc = 0x1c9b0;
            break;
        }
        if (memory16gets(ds, 0x988e) >= signed16(0x00dc)) {
            pc = 0x1c9b0;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0001);
        memory16set(es, r16[bx] + 4, 0x0163);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) + 1);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) & 0x0003);
    case 0x1c9b0:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[ax] += 0x0005;
        r16[ax] <<= 1;
        r16[bx] += r16[ax];
        r16[di] = memory16get(es, r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        if (memory16get(es, r16[bx] + 2) == 0x0001) {
            pc = 0x1c9ce;
            break;
        }
        pc = 0x1cab0;
        break;
    case 0x1c9ce:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1c9dd;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) - 0x0008);
    case 0x1c9dd:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 4);
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(es, r16[bx] + 6);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32936);
        r16[ax] += 0x0029;
        push(r16[ax]);
        push(r16[di]);
        r16[bx] = memory16get(ss, bp - 12);
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1ca16;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + 1);
    case 0x1ca16:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) & 0x0007);
        if (memory16gets(es, r16[bx] + 4) >= signed16(0xffce)) {
            pc = 0x1ca2f;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0000);
        pc = 0x1cab0;
        break;
    case 0x1ca2f:
        r16[ax] = r16[si];
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1ca66;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x000a;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1ca66;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0xffec;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1ca66;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x0012;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1ca66;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1ca66:
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x1cab0;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0034;
        if (r16s[ax] <= signed16(r16[si])) {
            pc = 0x1cab0;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xffd1;
        if (r16s[ax] >= signed16(r16[si])) {
            pc = 0x1cab0;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        if (r16s[ax] <= signed16(r16[di])) {
            pc = 0x1cab0;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xffe3;
        if (r16s[ax] >= signed16(r16[di])) {
            pc = 0x1cab0;
            break;
        }
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1cab0;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, 0x0002);
        memory16set(es, r16[bx] + 6, 0x0000);
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x1bf1);
    case 0x1cab0:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 2) == 0x0002) {
            pc = 0x1cabd;
            break;
        }
        pc = 0x1da44;
        break;
    case 0x1cabd:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1cacd;
            break;
        }
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + 0x001e);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + 1);
    case 0x1cacd:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0006) {
            pc = 0x1cadd;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0001);
    case 0x1cadd:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x002c;
        push(r16[ax]);
        push(r16[di]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1da44;
        break;
    case 0x1cafa:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        memory16set(ss, bp - 6, 0x0000);
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1cb44;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0xffec;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1cb44;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0014;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1cb44;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001f;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 6)) {
            pc = 0x1cb44;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x0005;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 6)) {
            pc = 0x1cb44;
            break;
        }
        r16[ax] = 0x0001;
        memory16set(ss, bp - 6, r16[ax]);
        memory16set(ds, 0x97e6, r16[ax]);
    case 0x1cb44:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 12) != 0x0000) {
            pc = 0x1cb68;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        if (r16s[ax] >= memory16gets(es, r16[bx] + 8)) {
            pc = 0x1cb83;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x0001);
        pc = 0x1cb83;
        break;
    case 0x1cb68:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 14);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        if (r16s[ax] <= memory16gets(es, r16[bx] + 10)) {
            pc = 0x1cb83;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x0000);
    case 0x1cb83:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x03e8;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 6));
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ss, bp - 6) == 0x0000) {
            pc = 0x1cbb0;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0xffe3;
        memory16set(ds, 0x97f2, r16[ax]);
    case 0x1cbb0:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x0010);
        pc = 0x1bf35;
        break;
    case 0x1cbb7:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1d4da;
        break;
    case 0x1cbd5:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0xfff8;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1cbe8;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cbe8:
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0008;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1cbf8;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cbf8:
        r16[ax] = memory16get(es, r16[bx] + 4);
        if (r16[ax] == memory16get(ds, 0x97f2)) {
            pc = 0x1cc05;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cc05:
        if (memory16get(ds, 0x9802) != 0x0000) {
            pc = 0x1cc0f;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cc0f:
        if (memory16get(ds, 0x987e) == 0x0000) {
            pc = 0x1cc19;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cc19:
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ds, 0x988e, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ds, 0x987e, r16[ax]);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) << 1);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) << 1);
        memory16set(ds, 0x987e, memory16get(ds, 0x987e) | 0x0001);
        pc = 0x1d4da;
        break;
    case 0x1cc38:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1cc48;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) ^ 0x0001);
    case 0x1cc48:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x001a;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = r16[si];
        r16[ax] += 0xffea;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1cc78;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cc78:
        r16[ax] = r16[si];
        r16[ax] += 0x0007;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1cc86;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cc86:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0xffec;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1cc99;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cc99:
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
        pc = 0x1d4da;
        break;
    case 0x1cca7:
        r16[ax] = memory16get(ds, 0x985c);
        r16[ax] += 0xfff8;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1ccb6;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1ccb6:
        memory16set(ds, 0x9872, 0x0001);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        memory16set(ds, 0x9c68, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 4);
        memory16set(ds, 0x97fe, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(ds, 0x9864, r16[ax]);
        memory16set(ds, 0x9874, 0x0027);
        pc = 0x1d4da;
        break;
    case 0x1ccdd:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 4) != 0x0011) {
            pc = 0x1ccef;
            break;
        }
        memory16set(es, r16[bx] + 4, 0x0000);
        pc = 0x1ccfd;
        break;
    case 0x1ccef:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1ccfd;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + 1);
    case 0x1ccfd:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        if (memory16gets(es, r16[bx] + 4) < signed16(0x0002)) {
            pc = 0x1cd12;
            break;
        }
        if (memory16gets(es, r16[bx] + 4) <= signed16(0x0007)) {
            pc = 0x1cd3e;
            break;
        }
    case 0x1cd12:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0077;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 6));
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x97f4);
        r16[ax] &= 0x007f;
        if (r16[ax] <= 0x0014) {
            pc = 0x1cd3c;
            break;
        }
        r16[di] = 0x001e;
        pc = 0x1cd3e;
        break;
    case 0x1cd3c:
        r16[di] = 0;
    case 0x1cd3e:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 4) == 0x0002) {
            pc = 0x1cd56;
            break;
        }
        if (memory16get(es, r16[bx] + 4) == 0x0006) {
            pc = 0x1cd56;
            break;
        }
        if (memory16get(es, r16[bx] + 4) != 0x0007) {
            pc = 0x1cd77;
            break;
        }
    case 0x1cd56:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0078;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x000a;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[di] = 0x002d;
    case 0x1cd77:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 4) <= signed16(0x0002)) {
            pc = 0x1cda6;
            break;
        }
        if (memory16gets(es, r16[bx] + 4) >= signed16(0x0006)) {
            pc = 0x1cda6;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0079;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x0010;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[di] = 0x0040;
    case 0x1cda6:
        r16[ax] = r16[si];
        r16[ax] += 0xffe9;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1cdb4;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cdb4:
        r16[ax] = r16[si];
        r16[ax] += 0x0010;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1cdc2;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cdc2:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x0019;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1cdd5;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cdd5:
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += r16[di];
        r16[ax] += 0x0010;
        if (r16s[ax] > memory16gets(ds, 0x97f2)) {
            pc = 0x1cde7;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1cde7:
        pc = 0x1cc99;
        break;
    case 0x1cdea:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (!(memory16get(es, r16[bx] + 6) & 0x0002)) {
            pc = 0x1cdf8;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1cdf8:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1ce37;
            break;
        }
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = 0x0007;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 6, r16[dx]);
        r16[ax] = r16[dx];
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) + r16[ax]);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) - 0x0003);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = 0x000b;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        memory16set(ss, bp - 6, r16[dx]);
        r16[ax] = r16[dx];
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) + r16[ax]);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) - 0x0005);
    case 0x1ce37:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 8);
        if (r16s[ax] >= memory16gets(ds, 0x986c)) {
            pc = 0x1ce4b;
            break;
        }
        r16[ax] = memory16get(ds, 0x986c);
        memory16set(es, r16[bx] + 8, r16[ax]);
    case 0x1ce4b:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[dx] = memory16get(ds, 0x985c);
        r16[dx] += 0xffe2;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1ce67;
            break;
        }
        r16[ax] = memory16get(ds, 0x985c);
        r16[ax] += 0xffe2;
        memory16set(es, r16[bx] + 8, r16[ax]);
    case 0x1ce67:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 10) <= signed16(0x008c)) {
            pc = 0x1ce78;
            break;
        }
        memory16set(es, r16[bx] + 10, 0x0082);
    case 0x1ce78:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 8);
        r16[di] = memory16get(es, r16[bx] + 10);
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1ce90;
            break;
        }
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) ^ 0x0001);
    case 0x1ce90:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] &= 0x0001;
        r16[ax] += 0x007a;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] >= signed16(r16[si])) {
            pc = 0x1ced5;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1ced5;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfffc;
        if (r16s[ax] >= signed16(r16[di])) {
            pc = 0x1ced5;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1ced5:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] < signed16(r16[di])) {
            pc = 0x1cee2;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1cee2:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x1ceec;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1ceec:
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1cf1c;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] >= signed16(r16[si])) {
            pc = 0x1cf1c;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0xffdd;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1cf1c;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) | 0x0002);
        r16[ax] = 0x000a;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
    case 0x1cf1c:
        if (memory16get(ds, 0x9800) != 0x0000) {
            pc = 0x1cf26;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1cf26:
        r16[ax] = r16[si];
        r16[ax] += 0x0032;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1cf34;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1cf34:
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] > signed16(r16[si])) {
            pc = 0x1cf3e;
            break;
        }
        pc = 0x1d747;
        break;
    case 0x1cf3e:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) | 0x0002);
        r16[ax] = 0x000a;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
        pc = 0x1d747;
        break;
    case 0x1cf58:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) == 0x0001) {
            pc = 0x1cf65;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1cf65:
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(es, r16[bx] + 6);
        r16[bx] <<= 1;
        r16[ax] = memory16get(ds, r16[bx] + 32904);
        r16[ax] += memory16get(ds, 0x988a);
        r16[ax]--;
        r16[dx] = 0x0014;
        mul16(r16[dx]);
        r16[bx] = memory16get(ds, 0x8da2);
        es = memory16get(ds, 0x8da2 + 2);
        r16[bx] += r16[ax];
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[di] -= r16[ax];
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] = memory16get(es, r16[bx] + 6);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32904));
        push(r16[di]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0014;
        if (r16s[ax] > signed16(r16[si])) {
            pc = 0x1cfb5;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1cfb5:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xffec;
        if (r16s[ax] < signed16(r16[si])) {
            pc = 0x1cfc2;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1cfc2:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x0014;
        if (r16s[ax] > signed16(r16[di])) {
            pc = 0x1cfcf;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1cfcf:
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xfff6;
        if (r16s[ax] < signed16(r16[di])) {
            pc = 0x1cfdc;
            break;
        }
        pc = 0x1d0b0;
        break;
    case 0x1cfdc:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 8, 0x0000);
        push(memory16get(es, r16[bx] + 6));
        push(cs);
        cs = 0x19e4;
        yield* sub_1b042();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
        pc = 0x1d0b0;
        break;
    case 0x1cff3:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(es, r16[bx] + 6);
        r16[bx] <<= 1;
        push(memory16get(ds, r16[bx] + 32952));
        push(r16[di]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) == 0x0000) {
            pc = 0x1d04e;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0xffec;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1d04e;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0012;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d04e;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        r16[dx] = r16[di];
        r16[dx]--;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1d04e;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d04e:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0003) {
            pc = 0x1d05e;
            break;
        }
        memory16set(es, r16[bx] + 6, 0x0000);
    case 0x1d05e:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0001) {
            pc = 0x1d06e;
            break;
        }
        memory16set(es, r16[bx] + 6, 0x0002);
    case 0x1d06e:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1d07c;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) + 1);
    case 0x1d07c:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x000f) {
            pc = 0x1d08e;
            break;
        }
        memory16set(es, r16[bx] + 6, 0x0001);
        pc = 0x1d0b0;
        break;
    case 0x1d08e:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x001e) {
            pc = 0x1d0a0;
            break;
        }
        memory16set(es, r16[bx] + 6, 0x0003);
        pc = 0x1d0b0;
        break;
    case 0x1d0a0:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x002d) {
            pc = 0x1d0b0;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x000e);
    case 0x1d0b0:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x000a);
        pc = 0x1bf35;
        break;
    case 0x1d0b7:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xfff8;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (r16s[ax] < memory16gets(es, r16[bx] + 2)) {
            pc = 0x1d0c9;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d0c9:
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0008;
        if (r16s[ax] > memory16gets(es, r16[bx] + 2)) {
            pc = 0x1d0d8;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d0d8:
        if (memory16get(ds, 0x9898) == 0x0000) {
            pc = 0x1d138;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x000c;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1d110;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x0004;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1d110;
            break;
        }
        if (memory16get(ds, 0x97e2) == 0x0000) {
            pc = 0x1d110;
            break;
        }
        memory16set(ds, 0x97e2, 0x0000);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0xfffe;
        memory16set(ds, 0x97f2, r16[ax]);
    case 0x1d110:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        if (r16[ax] != memory16get(ds, 0x97f2)) {
            pc = 0x1d138;
            break;
        }
        memory16set(ds, 0x9892, 0x0000);
        memory16set(ds, 0x97e2, 0x0001);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0004;
        memory16set(ds, 0x988e, r16[ax]);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x0004);
    case 0x1d138:
        if (memory16get(ds, 0x9802) != 0x0000) {
            pc = 0x1d142;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d142:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        if (r16[ax] != memory16get(ds, 0x97f2)) {
            pc = 0x1d174;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x000c;
        memory16set(ds, 0x97f2, r16[ax]);
        memory16set(ds, 0x9892, 0x0000);
        memory16set(ds, 0x97e2, 0x0001);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x0004;
        memory16set(ds, 0x988e, r16[ax]);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) + 0x0004);
    case 0x1d174:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfff8;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1d187;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d187:
        if (memory16get(ds, 0x97e2) != 0x0000) {
            pc = 0x1d191;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d191:
        memory16set(ds, 0x97e2, 0x0000);
        r16[ax] = memory16get(es, r16[bx] + 4);
        memory16set(ds, 0x97f2, r16[ax]);
        pc = 0x1d4da;
        break;
    case 0x1d1a1:
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1d1ac;
            break;
        }
        memory16set(ds, 0x8000, memory16get(ds, 0x8000) + 1);
    case 0x1d1ac:
        memory16set(ds, 0x8000, memory16get(ds, 0x8000) & 0x001f);
        if (memory16gets(ds, 0x8000) <= signed16(0x0010)) {
            pc = 0x1d1e6;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 10) == 0x0005) {
            pc = 0x1d1e6;
            break;
        }
        memory16set(es, r16[bx] + 22, 0x0000);
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = r16[bx];
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x475e;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1d1e6:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x478e;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1d204:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x47be;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] += 0x0002;
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        if (memory16get(es, r16[bx] + 8) != 0x0003) {
            pc = 0x1d26d;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x0014;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 12)) {
            pc = 0x1d26d;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0xffe7;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 12)) {
            pc = 0x1d26d;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1d26d;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(es, r16[bx] + 14)) {
            pc = 0x1d26d;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d26d:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memory16get(es, r16[bx] + 8) == 0x0005) {
            pc = 0x1d27a;
            break;
        }
        pc = 0x1dc39;
        break;
    case 0x1d27a:
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x0014;
        if (r16s[ax] > memory16gets(ds, 0x988e)) {
            pc = 0x1d28a;
            break;
        }
        pc = 0x1dc39;
        break;
    case 0x1d28a:
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0xfff6;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1d29a;
            break;
        }
        pc = 0x1dc39;
        break;
    case 0x1d29a:
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += 0xffe2;
        if (r16s[ax] < memory16gets(ds, 0x97f2)) {
            pc = 0x1d2aa;
            break;
        }
        pc = 0x1dc39;
        break;
    case 0x1d2aa:
        r16[ax] = memory16get(es, r16[bx] + 14);
        r16[ax] += 0x001e;
        if (r16s[ax] > memory16gets(ds, 0x97f2)) {
            pc = 0x1d2ba;
            break;
        }
        pc = 0x1dc39;
        break;
    case 0x1d2ba:
        r16[ax] = 0x0064;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 14));
        push(memory16get(es, r16[bx] + 12));
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 8, 0x0006);
        memory16set(ds, 0x9880, memory16get(ds, 0x9880) + 1);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1bf1);
        pc = 0x1dc39;
        break;
    case 0x1d2e3:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1d2f0;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d2f0:
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        if (memory16get(es, r16[bx] + 6) != 0x0002) {
            pc = 0x1d306;
            break;
        }
        memory16set(ss, bp - 8, 0x0075);
        pc = 0x1d30b;
        break;
    case 0x1d306:
        memory16set(ss, bp - 8, 0x007e);
    case 0x1d30b:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(r16[di]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = r16[di];
        r16[ax] += 0xfff9;
        if (r16[ax] == memory16get(ds, 0x97f2)) {
            pc = 0x1d32a;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d32a:
        if (memory16get(ds, 0x9862) == 0x0001) {
            pc = 0x1d334;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d334:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1d34d;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0032;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d34d;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] > signed16(r16[si])) {
            pc = 0x1d36f;
            break;
        }
    case 0x1d34d:
        if (memory16get(ds, 0x9800) == 0x0000) {
            pc = 0x1d357;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d357:
        r16[ax] = memory16get(ds, 0x988e);
        if (r16s[ax] < signed16(r16[si])) {
            pc = 0x1d361;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d361:
        r16[ax] = r16[si];
        r16[ax] += 0xffd8;
        if (r16s[ax] < memory16gets(ds, 0x988e)) {
            pc = 0x1d36f;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d36f:
        push(cs);
        cs = 0x1dc4;
        yield* sub_1dd4b();
        assert(cs == 0x1bf1);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
        if (memory16get(es, r16[bx] + 6) == 0x0000) {
            pc = 0x1d38d;
            break;
        }
        if (memory16get(ds, 0x97f8) == 0x0000) {
            pc = 0x1d38d;
            break;
        }
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
    case 0x1d38d:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) == 0x0000) {
            pc = 0x1d39a;
            break;
        }
        pc = 0x1d4da;
        break;
    case 0x1d39a:
        memory16set(ds, 0x9880, memory16get(ds, 0x9880) + 1);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b596();
        assert(cs == 0x1bf1);
        r16[ax] = 0x0032;
        push(r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0xfffc;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
        pc = 0x1d4da;
        break;
    case 0x1d3b9:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0096;
        push(r16[ax]);
        push(r16[di]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1d3e6;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + 1);
    case 0x1d3e6:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 6) != 0x0028) {
            pc = 0x1d3f6;
            break;
        }
        memory16set(es, r16[bx] + 6, 0x0000);
    case 0x1d3f6:
        memory16set(ss, bp - 8, 0x0097);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 6) <= signed16(0x000a)) {
            pc = 0x1d411;
            break;
        }
        if (memory16gets(es, r16[bx] + 6) >= signed16(0x000c)) {
            pc = 0x1d411;
            break;
        }
        memory16set(ss, bp - 8, 0x0098);
    case 0x1d411:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 6) <= signed16(0x000b)) {
            pc = 0x1d427;
            break;
        }
        if (memory16gets(es, r16[bx] + 6) >= signed16(0x0014)) {
            pc = 0x1d427;
            break;
        }
        memory16set(ss, bp - 8, 0x0099);
    case 0x1d427:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 6) <= signed16(0x0013)) {
            pc = 0x1d43d;
            break;
        }
        if (memory16gets(es, r16[bx] + 6) >= signed16(0x0015)) {
            pc = 0x1d43d;
            break;
        }
        memory16set(ss, bp - 8, 0x0098);
    case 0x1d43d:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[ax] = r16[di];
        r16[ax] += 0x0014;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x0010;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ss, bp - 8) != 0x0097) {
            pc = 0x1d49c;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x0019;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1d49c;
            break;
        }
        r16[ax] = memory16get(ds, 0x97f2);
        r16[ax] += 0x001d;
        r16[dx] = r16[di];
        r16[dx] += 0x0014;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1d49c;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x002c;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d49c;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x000f;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1d49c;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d49c:
        if (memory16gets(ss, bp - 8) <= signed16(0x0097)) {
            pc = 0x1d4da;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x0035;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1d4da;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0x0017;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1d4da;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0033;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d4da;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x000e;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1d4da;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d4da:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x0008);
        pc = 0x1bf35;
        break;
    case 0x1d4e1:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 4);
        r16[di] = memory16get(es, r16[bx] + 6);
        if (memory16get(es, r16[bx] + 2) != 0x0000) {
            pc = 0x1d554;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0005;
        memory16set(es, r16[bx] + 8, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0x0005;
        memory16set(es, r16[bx] + 10, r16[ax]);
        memory16set(es, r16[bx] + 2, 0x0002);
        r16[ax] = r16[si];
        r16[ax] += 0xffe2;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d52e;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0004;
        memory16set(es, r16[bx] + 8, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0x0005;
        memory16set(es, r16[bx] + 10, r16[ax]);
        memory16set(es, r16[bx] + 2, 0x0001);
    case 0x1d52e:
        r16[ax] = r16[si];
        r16[ax] += 0x001e;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1d554;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0008;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 8, r16[ax]);
        r16[ax] = r16[di];
        r16[ax] += 0x0005;
        memory16set(es, r16[bx] + 10, r16[ax]);
        memory16set(es, r16[bx] + 2, 0x0003);
    case 0x1d554:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = memory16get(ds, 0x97f2);
        r16[dx] += 0xfffe;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1d59e;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = memory16get(ds, 0x97f2);
        r16[dx] += 0x0014;
        if (r16s[ax] >= r16s[dx]) {
            pc = 0x1d59e;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[dx] = memory16get(ds, 0x988e);
        r16[dx] += 0xfffe;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1d59e;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 8);
        r16[dx] = memory16get(ds, 0x988e);
        r16[dx] += 0x0018;
        if (r16s[ax] >= r16s[dx]) {
            pc = 0x1d59e;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d59e:
        memory16set(ss, bp - 8, 0x009a);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) + 0x0007);
        if (memory16get(es, r16[bx] + 2) != 0x0001) {
            pc = 0x1d5c9;
            break;
        }
        memory16set(ss, bp - 8, 0x0094);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) - 0x0006);
        if (memory16gets(es, r16[bx] + 8) >= signed16(0xfff6)) {
            pc = 0x1d5c9;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0000);
    case 0x1d5c9:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 2) != 0x0003) {
            pc = 0x1d5eb;
            break;
        }
        memory16set(ss, bp - 8, 0x0095);
        memory16set(es, r16[bx] + 8, memory16get(es, r16[bx] + 8) + 0x0006);
        if (memory16gets(es, r16[bx] + 8) <= signed16(0x0140)) {
            pc = 0x1d5eb;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0000);
    case 0x1d5eb:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = r16[di];
        r16[dx] += 0x001e;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1d602;
            break;
        }
        memory16set(ss, bp - 6, 0x0092);
        pc = 0x1d607;
        break;
    case 0x1d602:
        memory16set(ss, bp - 6, 0x0093);
    case 0x1d607:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 10) <= signed16(0x00c8)) {
            pc = 0x1d618;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0000);
    case 0x1d618:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 6));
        push(r16[di]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 10));
        push(memory16get(es, r16[bx] + 8));
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1d747;
        break;
    case 0x1d646:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1d6a4;
            break;
        }
        if (memory16get(es, r16[bx] + 10) != 0x0000) {
            pc = 0x1d669;
            break;
        }
        r16[si] -= 0x0003;
        memory16set(ss, bp - 8, 0x0038);
        pc = 0x1d671;
        break;
    case 0x1d669:
        r16[si] += 0x0003;
        memory16set(ss, bp - 8, 0x003a);
    case 0x1d671:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(r16[di]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) - r16[ax]);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
        memory16set(es, r16[bx] + 2, r16[si]);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1d709;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0001);
        pc = 0x1d709;
        break;
    case 0x1d6a4:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 10) != 0x0000) {
            pc = 0x1d6b8;
            break;
        }
        r16[si] -= 0x0003;
        memory16set(ss, bp - 8, 0x0039);
        pc = 0x1d6c0;
        break;
    case 0x1d6b8:
        r16[si] += 0x0003;
        memory16set(ss, bp - 8, 0x003b);
    case 0x1d6c0:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        push(r16[di]);
        push(r16[si]);
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + r16[ax]);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + 1);
        memory16set(es, r16[bx] + 2, r16[si]);
        if (memory16get(es, r16[bx] + 6) != 0x0014) {
            pc = 0x1d709;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0000);
        memory16set(es, r16[bx] + 4, 0x00dc);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = 0x00d2;
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
    case 0x1d709:
        r16[ax] = r16[si];
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1d747;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x000a;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d747;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfff6;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1d747;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x0014;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1d747;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d747:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x000c);
        pc = 0x1bf35;
        break;
    case 0x1d74e:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 2) < signed16(0x0008)) {
            pc = 0x1d75b;
            break;
        }
        pc = 0x1d896;
        break;
    case 0x1d75b:
        if (memory16get(es, r16[bx] + 2) != 0x0000) {
            pc = 0x1d79c;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005d;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) == 0x0000) {
            pc = 0x1d789;
            break;
        }
        pc = 0x1d837;
        break;
    case 0x1d789:
        if (memory16get(ds, 0x9870) == 0x0000) {
            pc = 0x1d793;
            break;
        }
        pc = 0x1d837;
        break;
    case 0x1d793:
        memory16set(es, r16[bx] + 2, 0x0001);
        pc = 0x1d837;
        break;
    case 0x1d79c:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 2) >= signed16(0x0007)) {
            pc = 0x1d800;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005e;
        push(r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x0005;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, memory16get(es, r16[bx] + 2) + 1);
        if (memory16get(es, r16[bx] + 2) != 0x0002) {
            pc = 0x1d7ee;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0001);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xfff4;
        memory16set(es, r16[bx] + 10, r16[ax]);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x0012;
        memory16set(es, r16[bx] + 12, r16[ax]);
    case 0x1d7ee:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 2) != 0x0006) {
            pc = 0x1d837;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0000);
        pc = 0x1d837;
        break;
    case 0x1d800:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x005f;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0xfff9;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + 0x000a);
        if (memory16gets(es, r16[bx] + 4) <= signed16(0x0140)) {
            pc = 0x1d837;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0008);
    case 0x1d837:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16gets(es, r16[bx] + 2) >= signed16(0x0003)) {
            pc = 0x1d896;
            break;
        }
        if (memory16get(ds, 0x9862) != 0x0001) {
            pc = 0x1d896;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1d896;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xffdc;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1d896;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0xffe2;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1d896;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 6);
        r16[ax] += 0x001e;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1d896;
            break;
        }
        memory16set(es, r16[bx] + 2, 0x0007);
        r16[ax] = 0x0064;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        push(memory16get(es, r16[bx] + 4));
        push(cs);
        cs = 0x19e4;
        yield* sub_1a63d();
        assert(cs == 0x1bf1);
        sp += 0x0006;
    case 0x1d896:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1d8a3;
            break;
        }
        pc = 0x1db36;
        break;
    case 0x1d8a3:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0060;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 12));
        push(memory16get(es, r16[bx] + 10));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = memory16get(ds, 0x988e);
        r16[dx] += 0x0014;
        if (r16s[ax] >= r16s[dx]) {
            pc = 0x1d90b;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 10);
        r16[dx] = memory16get(ds, 0x988e);
        r16[dx] += 0xfff6;
        if (r16s[ax] <= r16s[dx]) {
            pc = 0x1d90b;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[ax] += 0x000c;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1d90b;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 12);
        r16[dx] = memory16get(ds, 0x97f2);
        r16[dx] += 0x0017;
        if (r16s[ax] >= r16s[dx]) {
            pc = 0x1d90b;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0000);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1d90b:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) - 0x000c);
        if (memory16gets(es, r16[bx] + 10) < signed16(0xffba)) {
            pc = 0x1d91d;
            break;
        }
        pc = 0x1db36;
        break;
    case 0x1d91d:
        pc = 0x1c97c;
        break;
    case 0x1d920:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x57e0;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1d93e:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x5810;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1d95c:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 10));
        r16[ax] = 0x009f;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 6));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1d987;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 14, memory16get(es, r16[bx] + 14) + 1);
    case 0x1d987:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 14) != 0x0003) {
            pc = 0x1d9d0;
            break;
        }
        memory16set(es, r16[bx] + 14, 0x0000);
        memory16set(es, r16[bx] + 10, memory16get(es, r16[bx] + 10) + 1);
        if (memory16get(es, r16[bx] + 10) != 0x003d) {
            pc = 0x1d9d0;
            break;
        }
        memory16set(es, r16[bx] + 10, 0x0038);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        r16[cx] = pop();
        r16[cx] -= memory16get(es, r16[bx] + 4);
        r16[ax] = pop();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[cx]);
        r16[bx] = memory16get(ss, bp - 12);
        r16[dx] += memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 12);
        memory16set(es, r16[bx] + 6, r16[dx]);
    case 0x1d9d0:
        r16[ax] = 0;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 12));
        r16[ax] = 0x00a5;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 8));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        if (memory16get(ds, 0x7ffe) == 0x0000) {
            pc = 0x1d9fb;
            break;
        }
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 16, memory16get(es, r16[bx] + 16) + 1);
    case 0x1d9fb:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 16) != 0x0003) {
            pc = 0x1da44;
            break;
        }
        memory16set(es, r16[bx] + 16, 0x0000);
        memory16set(es, r16[bx] + 12, memory16get(es, r16[bx] + 12) + 1);
        if (memory16get(es, r16[bx] + 12) != 0x0051) {
            pc = 0x1da44;
            break;
        }
        memory16set(es, r16[bx] + 12, 0x004d);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] = memory16get(es, r16[bx] + 2);
        push(r16[ax]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        r16[cx] = pop();
        r16[cx] -= memory16get(es, r16[bx] + 4);
        r16[ax] = pop();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[cx]);
        r16[bx] = memory16get(ss, bp - 12);
        r16[dx] += memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 12);
        memory16set(es, r16[bx] + 8, r16[dx]);
    case 0x1da44:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x0012);
        pc = 0x1bf35;
        break;
    case 0x1da4b:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1da8d;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0054;
        push(r16[ax]);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) - r16[ax]);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) - 1);
        if (memory16get(es, r16[bx] + 6) != 0x0000) {
            pc = 0x1daf4;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0001);
        pc = 0x1daf4;
        break;
    case 0x1da8d:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0055;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        push(memory16get(es, r16[bx] + 4));
        push(memory16get(es, r16[bx] + 2));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 6);
        memory16set(es, r16[bx] + 4, memory16get(es, r16[bx] + 4) + r16[ax]);
        memory16set(es, r16[bx] + 6, memory16get(es, r16[bx] + 6) + 1);
        if (memory16get(es, r16[bx] + 6) != 0x0014) {
            pc = 0x1daf4;
            break;
        }
        memory16set(es, r16[bx] + 8, 0x0000);
        memory16set(es, r16[bx] + 4, 0x00dc);
        push(cs);
        cs = 0x1f47;
        yield* sub_1f489();
        assert(cs == 0x1bf1);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] = memory16get(es, r16[bx] + 10);
        push(r16[ax]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        r16[cx] = pop();
        r16[cx] -= memory16get(es, r16[bx] + 12);
        r16[ax] = pop();
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
        idiv16(r16[cx]);
        r16[bx] = memory16get(ss, bp - 12);
        r16[dx] += memory16get(es, r16[bx] + 12);
        r16[bx] = memory16get(ss, bp - 12);
        memory16set(es, r16[bx] + 2, r16[dx]);
    case 0x1daf4:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0xffe9;
        if (r16s[ax] >= memory16gets(ds, 0x988e)) {
            pc = 0x1db36;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 2);
        r16[ax] += 0x000f;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1db36;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0xffe7;
        if (r16s[ax] >= memory16gets(ds, 0x97f2)) {
            pc = 0x1db36;
            break;
        }
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[ax] += 0x0019;
        if (r16s[ax] <= memory16gets(ds, 0x97f2)) {
            pc = 0x1db36;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1b714();
        assert(cs == 0x1bf1);
        sp++;
        sp++;
    case 0x1db36:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x000e);
        pc = 0x1bf35;
        break;
    case 0x1db3d:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[si] = memory16get(es, r16[bx] + 2);
        r16[di] = memory16get(es, r16[bx] + 4);
        memory16set(ss, bp - 8, 0x0093);
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] += 0x000a;
        if (r16s[ax] <= signed16(r16[si])) {
            pc = 0x1db96;
            break;
        }
        r16[ax] = r16[si];
        r16[ax] += 0x0014;
        if (r16s[ax] <= memory16gets(ds, 0x988e)) {
            pc = 0x1db96;
            break;
        }
        r16[ax] = r16[di];
        r16[ax] += 0xfff4;
        if (r16[ax] != memory16get(ds, 0x97f2)) {
            pc = 0x1db96;
            break;
        }
        if (memory16get(ds, 0x9868) != 0x0000) {
            pc = 0x1db96;
            break;
        }
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 1);
        memory16set(ds, 0x988e, memory16get(ds, 0x988e) + 0x0005);
        memory16set(ds, 0x97f2, memory16get(ds, 0x97f2) - 0x000a);
        r16[ax] = memory16get(ds, 0x97f4);
        memory16set(ds, 0x9c70, r16[ax]);
        memory16set(ds, 0x97f4, 0x00a8);
        memory16set(ds, 0x9868, 0x0001);
        r16[di] -= 0x0004;
    case 0x1db96:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[ax] = r16[di];
        r16[ax] += 0x0004;
        push(r16[ax]);
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
    case 0x1dbae:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x0006);
        pc = 0x1bf35;
        break;
    case 0x1dbb5:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[bx] += 0x0002;
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1dbda;
            break;
        }
        r16[ax] = memory16get(ds, 0x988e);
        r16[ax] -= memory16get(es, r16[bx] + 12);
        if (r16s[ax] >= 0) {
            pc = 0x1dbd5;
            break;
        }
        r16[ax] = -r16[ax];
    case 0x1dbd5:
        if (r16s[ax] > signed16(0x0046)) {
            pc = 0x1dbff;
            break;
        }
    case 0x1dbda:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x749c;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        if (memory16get(es, r16[bx] + 8) != 0x0000) {
            pc = 0x1dc39;
            break;
        }
    case 0x1dbff:
        r16[ax] = 0;
        push(r16[ax]);
        r16[ax] = 0x0033;
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        push(memory16get(es, r16[bx] + 14));
        push(memory16get(es, r16[bx] + 12));
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1829;
        yield* sub_18c3b();
        assert(cs == 0x1bf1);
        sp += 0x000a;
        pc = 0x1dc39;
        break;
    case 0x1dc1e:
        r16[ax] = 0;
        push(r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0002;
        push(r16[dx]);
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x74cc;
        push(r16[ax]);
        push(cs);
        cs = 0x19e4;
        yield* sub_1a77d();
        assert(cs == 0x1bf1);
        sp += 0x000a;
    case 0x1dc39:
        memory16set(ss, bp - 12, memory16get(ss, bp - 12) + 0x001a);
        pc = 0x1bf35;
        break;
    case 0x1dc40:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1dc46() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory[ds*16 + 0x9091] != 0x00) {
            pc = 0x1dc51;
            break;
        }
        pc = 0x1dcd0;
        break;
    case 0x1dc51:
        if (memory[ds*16 + 0x8db5] != 0x52) {
            pc = 0x1dc87;
            break;
        }
        flags.interrupts = false;
        r16[ax] = 0x002e;
        push(r16[ax]);
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_11745();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[si] = 0;
        pc = 0x1dc81;
        break;
    case 0x1dc6d:
        push(memory16get(ds, 0x8f7c));
        r8[al] = memory[ds*16 + r16[si] + 32961];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x129a;
        yield* sub_129c3();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[si]++;
    case 0x1dc81:
        if (r16[si] < 0x000a) {
            pc = 0x1dc6d;
            break;
        }
        flags.interrupts = true;
    case 0x1dc87:
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x1dc99;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x127c;
        yield* sub_1290a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1dc99:
        if (memory[ds*16 + 0x8db5] != 0x41) {
            pc = 0x1dcd0;
            break;
        }
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_1205c();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x80cc;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11e5b();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        r16[ax] = 0x007f;
        push(r16[ax]);
        r16[ax] = 0x0024;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x10ba;
        yield* sub_10ffa();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1dcd0:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1dcd2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory[ds*16 + 0x9091] == 0x00) {
            pc = 0x1dd49;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x52) {
            pc = 0x1dd00;
            break;
        }
        flags.interrupts = false;
        r16[si] = 0;
        pc = 0x1dcfa;
        break;
    case 0x1dce6:
        push(memory16get(ds, 0x8f7c));
        r8[al] = memory[ds*16 + r16[si] + 33028];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x129a;
        yield* sub_129c3();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[si]++;
    case 0x1dcfa:
        if (r16[si] < 0x0006) {
            pc = 0x1dce6;
            break;
        }
        flags.interrupts = true;
    case 0x1dd00:
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x1dd12;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x127c;
        yield* sub_1290a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1dd12:
        if (memory[ds*16 + 0x8db5] != 0x41) {
            pc = 0x1dd49;
            break;
        }
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_1205c();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x810a;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11e5b();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        r16[ax] = 0x007f;
        push(r16[ax]);
        r16[ax] = 0x0024;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x10ba;
        yield* sub_10ffa();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1dd49:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1dd4b() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        if (memory[ds*16 + 0x9091] == 0x00) {
            pc = 0x1ddc1;
            break;
        }
        if (memory[ds*16 + 0x8db5] != 0x52) {
            pc = 0x1dd79;
            break;
        }
        flags.interrupts = false;
        r16[si] = 0;
        pc = 0x1dd73;
        break;
    case 0x1dd5f:
        push(memory16get(ds, 0x8f7c));
        r8[al] = memory[ds*16 + r16[si] + 33090];
        r8[ah] = 0x00;
        push(r16[ax]);
        push(cs);
        cs = 0x129a;
        yield* sub_129c3();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[si]++;
    case 0x1dd73:
        if (r16[si] < 0x0006) {
            pc = 0x1dd5f;
            break;
        }
        flags.interrupts = true;
    case 0x1dd79:
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x1dd8a;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x127c;
        yield* sub_1290a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1dd8a:
        if (memory[ds*16 + 0x8db5] != 0x41) {
            pc = 0x1ddc1;
            break;
        }
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_1205c();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        push(ds);
        r16[ax] = 0x8148;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x11cd;
        yield* sub_11e5b();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        r16[ax] = 0x007f;
        push(r16[ax]);
        r16[ax] = 0x0018;
        push(r16[ax]);
        r16[ax] = 0x0003;
        push(r16[ax]);
        push(cs);
        cs = 0x10ba;
        yield* sub_10ffa();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1ddc1:
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1ddc3() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[di] = 0;
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1dde6;
            break;
        }
        push(ds);
        r16[ax] = 0x8180;
        push(r16[ax]);
        r16[ax] = r16[di];
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1ddf6;
        break;
    case 0x1dde6:
        push(ds);
        r16[ax] = 0x8188;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1ddf6:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8193;
        push(r16[ax]);
        push(memory16get(ds, 0x8bd6));
        push(cs);
        cs = 0x06c1;
        yield* sub_993b();
        assert(cs == 0x1dc4);
        sp += 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x819d;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0007;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[si] = 0x00c6;
        pc = 0x1deb9;
        break;
    case 0x1de49:
        if (!r16[di]) {
            pc = 0x1de57;
            break;
        }
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8bfa);
        pc = 0x1de5f;
        break;
    case 0x1de57:
        memory16set(ss, bp - 2, ds);
        memory16set(ss, bp - 4, 0x8b70);
    case 0x1de5f:
        if (memory[ds*16 + 0x919d] != 0x00) {
            pc = 0x1de74;
            break;
        }
        if (memory[ds*16 + 0x8f67] != 0x00) {
            pc = 0x1de74;
            break;
        }
        if (memory[ds*16 + 0x8c58] == 0x00) {
            pc = 0x1de78;
            break;
        }
    case 0x1de74:
        r16[di] ^= 0x0001;
    case 0x1de78:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(ds);
        r16[ax] = 0x8e20;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ds, 0x8bd6));
        push(r16[si]);
        r16[ax] = 0x0040;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_4c03();
        assert(cs == 0x1dc4);
        sp += 0x000c;
        push(memory16get(ss, bp - 2));
        push(memory16get(ss, bp - 4));
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[si] -= 0x0002;
    case 0x1deb9:
        yield* sync();
        if (signed16(r16[si]) < signed16(0x0049)) {
            pc = 0x1dec1;
            break;
        }
        pc = 0x1de49;
        break;
    case 0x1dec1:
        if (!r16[di]) {
            pc = 0x1dee7;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
    case 0x1dee7:
        push(cs);
        cs = 0x0a34;
        yield* sub_a9d5();
        assert(cs == 0x1dc4);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_402c();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1df27() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1df40;
            break;
        }
        push(ds);
        r16[ax] = 0x81a7;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1df50;
        break;
    case 0x1df40:
        push(ds);
        r16[ax] = 0x81b0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1df50:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x81bc;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0x0007;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0008;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a99a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1dfa2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1dfbb;
            break;
        }
        push(ds);
        r16[ax] = 0x81c7;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1dfcb;
        break;
    case 0x1dfbb:
        push(ds);
        r16[ax] = 0x81d1;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1dfcb:
        if (memory[ds*16 + 0x80c0] != 0x00) {
            pc = 0x1dffd;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x81de;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
    case 0x1dffd:
        r16[ax] = 0x0006;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_117db();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        if (memory[ds*16 + 0x80c0] != 0x00) {
            pc = 0x1e07f;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x81e8;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0014;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a99a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x81f3;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0014;
        push(r16[ax]);
        push(cs);
        cs = 0x0a34;
        yield* sub_a99a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e07f:
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x81fe;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_9e3d();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(cs);
        cs = 0x0a34;
        yield* sub_a9d5();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        memory[ds*16 + 0x80c0] = 0x01;
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e0c4() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        if (memory[ds*16 + 0x8db5] != 0x53) {
            pc = 0x1e0fd;
            break;
        }
        push(ds);
        r16[ax] = 0x8208;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a186();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        push(ds);
        r16[ax] = 0x8214;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a186();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        push(ds);
        r16[ax] = 0x8220;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a186();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e0fd:
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e0fe() {
    var pc = 0;
    do switch (pc) {
    case 0:
        push(cs);
        yield* sub_1e0c4();
        memory16set(ds, 0x9888, 0x0000);
        memory16set(ds, 0x9886, 0x0000);
        memory16set(ds, 0x9c5e, 0x0003);
        switch (prehistorikLevel)
        {
        case 0: pc = 0x1e102; break;
        case 1: pc = 0x1e131; break;
        case 2: pc = 0x1e175; break;
        case 3: pc = 0x1e1b9; break;
        case 4: pc = 0x1e1fd; break;
        case 5: pc = 0x1e241; break;
        case 6: pc = 0x1e285; break;
        case 7: pc = 0x1e2c9; break;
        case 8: pc = 0x1e2ed; break;
        }
        break;
    case 0x1e102:
        push(cs);
        yield* sub_1dfa2();
        memory16set(ds, 0x9888, 0x0000);
        memory16set(ds, 0x9886, 0x0000);
        memory16set(ds, 0x9c5e, 0x0003);
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e131;
            break;
        }
        push(ds);
        r16[ax] = 0x822a;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e141;
        break;
    case 0x1e131:
        push(ds);
        r16[ax] = 0x8233;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e141:
        push(cs);
        cs = 0x13e0;
        yield* sub_13e6f();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e199;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e175;
            break;
        }
        push(ds);
        r16[ax] = 0x823f;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e185;
        break;
    case 0x1e175:
        push(ds);
        r16[ax] = 0x8249;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e185:
        push(cs);
        cs = 0x15bc;
        yield* sub_165e0();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e199:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e1dd;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e1b9;
            break;
        }
        push(ds);
        r16[ax] = 0x8256;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e1c9;
        break;
    case 0x1e1b9:
        push(ds);
        r16[ax] = 0x825f;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e1c9:
        push(cs);
        cs = 0x154e;
        yield* sub_1554c();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e1dd:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e221;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e1fd;
            break;
        }
        push(ds);
        r16[ax] = 0x826b;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e20d;
        break;
    case 0x1e1fd:
        push(ds);
        r16[ax] = 0x8275;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e20d:
        push(cs);
        cs = 0x16b9;
        yield* sub_16e82();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e221:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e265;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e241;
            break;
        }
        push(ds);
        r16[ax] = 0x8282;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e251;
        break;
    case 0x1e241:
        push(ds);
        r16[ax] = 0x828c;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e251:
        push(cs);
        cs = 0x1463;
        yield* sub_14d22();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e265:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e2a9;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e285;
            break;
        }
        push(ds);
        r16[ax] = 0x8299;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e295;
        break;
    case 0x1e285:
        push(ds);
        r16[ax] = 0x82a3;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e295:
        push(cs);
        cs = 0x173c;
        yield* sub_17675();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e2a9:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e2ed;
            break;
        }
        if (memory[ds*16 + 0x8db5] == 0x49) {
            pc = 0x1e2c9;
            break;
        }
        push(ds);
        r16[ax] = 0x82b0;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
        pc = 0x1e2d9;
        break;
    case 0x1e2c9:
        push(ds);
        r16[ax] = 0x82b9;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x06c1;
        yield* sub_a10f();
        assert(cs == 0x1dc4);
        sp += 0x0006;
    case 0x1e2d9:
        push(cs);
        cs = 0x179f;
        yield* sub_17bfb();
        assert(cs == 0x1dc4);
        push(cs);
        cs = 0x1162;
        yield* sub_11704();
        assert(cs == 0x1dc4);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        cs = 0x1162;
        yield* sub_1179a();
        assert(cs == 0x1dc4);
        sp++;
        sp++;
    case 0x1e2ed:
        if (memory16gets(ds, 0x9c5e) < signed16(0x0000)) {
            pc = 0x1e2fb;
            break;
        }
        push(cs);
        yield* sub_1ddc3();
        pc = 0x1e102;
        break;
    case 0x1e2fb:
        push(cs);
        yield* sub_1df27();
        pc = 0x1e102;
        break;
        return;
    } while (1);
}
function* sub_1e303() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[si] = memory16get(ss, bp + 8);
    r16[ax] = memory16get(ss, bp + 10);
    r16[cx] = 0x0005;
    r16[ax] <<= r8[cl];
    r16[si] += r16[ax];
    r16[ax] = memory16get(ss, bp + 10);
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[ax] <<= 1;
    r16[si] += r16[ax];
    push(r16[si]);
    push(cs);
    cs = 0x0cc2;
    yield* sub_e0ea();
    assert(cs == 0x1dc4);
    sp = bp;
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1e32a() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[bx] = memory16get(ds, 0x8b70);
        es = memory16get(ds, 0x8b70 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ds, 0x8bfa);
        es = memory16get(ds, 0x8bfa + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x1f40);
        r16[si] = 0x000a;
        pc = 0x1e39a;
        break;
    case 0x1e364:
        push(r16[si]);
        r16[ax] = 0;
        push(r16[ax]);
        push(cs);
        yield* sub_1e303();
        sp += 0x0004;
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[ax] = memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[ax] = memory16get(ss, bp - 6);
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d4ec();
        assert(cs == 0x1dc4);
        sp += 0x000c;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0190);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0190);
        r16[si] += 0x000a;
    case 0x1e39a:
        if (r16[si] < 0x00d2) {
            pc = 0x1e364;
            break;
        }
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e3e9() {
    var counter = 0;
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[bx] = memory16get(ds, 0x8b70);
        es = memory16get(ds, 0x8b70 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ds, 0x8bfa);
        es = memory16get(ds, 0x8bfa + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0028);
        r16[si] = 0x0002;
        pc = 0x1e456;
        break;
    case 0x1e422:
        if (counter++%2==0)
            yield* sync();
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        yield* sub_1e303();
        sp += 0x0004;
        r16[ax] = 0x00c8;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[ax] = memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[ax] = memory16get(ss, bp - 6);
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d4ec();
        assert(cs == 0x1dc4);
        sp += 0x000c;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0002);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x0002);
        r16[si] += 0x0002;
    case 0x1e456:
        if (r16[si] < 0x002a) {
            pc = 0x1e422;
            break;
        }
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e4a4() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[bx] = memory16get(ds, 0x8bba);
        es = memory16get(ds, 0x8bba + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ds, 0x8bfa);
        es = memory16get(ds, 0x8bfa + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x1db0);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) + 0x1e70);
        r16[si] = 0x00be;
        pc = 0x1e551;
        break;
    case 0x1e51a:
        push(r16[si]);
        r16[ax] = 0x00c0;
        push(r16[ax]);
        push(cs);
        yield* sub_1e303();
        sp += 0x0004;
        r16[ax] = 0x000a;
        push(r16[ax]);
        r16[ax] = 0x0028;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[ax] = memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[ax] = memory16get(ss, bp - 6);
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d4ec();
        assert(cs == 0x1dc4);
        sp += 0x000c;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) - 0x0190);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x0190);
        r16[si] -= 0x000a;
    case 0x1e551:
        if (r16[si]) {
            pc = 0x1e51a;
            break;
        }
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e59e() {
    var counter = 0;
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[bx] = memory16get(ds, 0x8bba);
        es = memory16get(ds, 0x8bba + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ds, 0x8b70);
        es = memory16get(ds, 0x8b70 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) + 0x0026);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x0002);
        r16[si] = 0x0026;
        pc = 0x1e64c;
        break;
    case 0x1e612:
        if (counter++%2==0)
            yield* sync();
        r16[ax] = 0x00cb;
        push(r16[ax]);
        r16[ax] = r16[si];
        r16[ax] += 0x0020;
        push(r16[ax]);
        push(cs);
        yield* sub_1e303();
        sp += 0x0004;
        r16[ax] = 0x00c8;
        push(r16[ax]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        push(memory16get(ss, bp - 4));
        r16[ax] = memory16get(ss, bp - 2);
        push(r16[ax]);
        push(memory16get(ss, bp - 8));
        r16[ax] = memory16get(ss, bp - 6);
        push(r16[ax]);
        push(cs);
        cs = 0x0cc2;
        yield* sub_d4ec();
        assert(cs == 0x1dc4);
        sp += 0x000c;
        memory16set(ss, bp - 8, memory16get(ss, bp - 8) - 0x0002);
        memory16set(ss, bp - 4, memory16get(ss, bp - 4) - 0x0002);
        r16[si] -= 0x0002;
    case 0x1e64c:
        if (r16[si]) {
            pc = 0x1e612;
            break;
        }
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bfa;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        r16[ax] = 0;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(ds);
        r16[ax] = 0x8bba;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_3e59();
        assert(cs == 0x1dc4);
        sp += 0x000a;
        push(ds);
        r16[ax] = 0x8b70;
        push(r16[ax]);
        push(cs);
        cs = 0x023f;
        yield* sub_2c13();
        assert(cs == 0x1dc4);
        sp += 0x0004;
        sp = bp;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e69a() {
    cs = pop();
    return;
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[dx] = memory16get(ds, 0x8a08);
    r16[ax] = memory16get(ss, bp + 6);
    out8(r16[dx], r8[al]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r16[dx]++;
    r16[ax] = memory16get(ss, bp + 8);
    out8(r16[dx], r8[al]);
    r16[dx]--;
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    r8[al] = in8(r16[dx]);
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1e6d6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[ax] = memory16get(ss, bp + 10);
        r16[ax] -= 0x2000;
        if (r16[ax] == 0) {
            pc = 0x1e712;
            break;
        }
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[cx] = r16[ax];
        r16[bx] = memory16get(ds, 0x89e6);
        r16[bx] <<= 1;
        r16[bx] = -r16[bx];
        r16[bx] += 0x0044;
        stop(/*2*/);
    case 0x1e712:
        r8[ah] += memory[ss*16 + bp + 8];
        r16[ax] += 0x0008;
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        r16[ax] = sar16(r16[ax], 1);
        if (r16s[ax] >= 0) {
            pc = 0x1e727;
            break;
        }
        r16[ax] = 0;
        pc = 0x1e72f;
        break;
    case 0x1e727:
        if (r16s[ax] < signed16(0x05ff)) {
            pc = 0x1e72f;
            break;
        }
        r16[ax] = 0x05ff;
    case 0x1e72f:
        r16[di] = r16[ax];
        r16[di] >>= 1;
        r16[di] >>= 1;
        r16[di] >>= 1;
        r16[di] >>= 1;
        r16[dx] = r16[di];
        r8[bl] = memory[ds*16 + r16[di] + 33958];
        r8[bh] = 0;
        r16[di] = r16[bx];
        r16[di] <<= 1;
        r16[di] <<= 1;
        r16[di] <<= 1;
        r16[di] <<= 1;
        r16[di] <<= 1;
        r16[ax] <<= 1;
        r16[ax] &= 0x001f;
        r16[di] += r16[ax];
        r16[ax] = memory16get(ds, r16[di] + 33478);
        r16[di] = r16[dx];
        r8[bl] = memory[ds*16 + r16[di] + 33862];
        r8[bl]--;
        if (r16s[ax] >= 0) {
            pc = 0x1e766;
            break;
        }
        r8[bl]++;
    case 0x1e766:
        if (r8s[bl] >= 0) {
            pc = 0x1e76e;
            break;
        }
        r8[bl]++;
        r16[ax] = sar16(r16[ax], 1);
    case 0x1e76e:
        push(r16[bx]);
        push(r16[ax]);
        r8[ah] = 0;
        push(r16[ax]);
        r8[al] = 0xa0;
        r8[al] += memory[ss*16 + bp + 6];
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x1e6d);
        sp += 0x0004;
        r16[ax] = pop();
        r16[bx] = pop();
        r8[al] = r8[ah];
        r8[al] &= 0x03;
        r8[bl] <<= 1;
        r8[bl] <<= 1;
        r8[al] += r8[bl];
        r8[al] += memory[ss*16 + bp + 12];
        r8[ah] = 0;
        push(r16[ax]);
        push(r16[ax]);
        r16[ax] = 0x00b0;
        r16[ax] += memory16get(ss, bp + 6);
        push(r16[ax]);
        push(cs);
        cs = 0x1e69;
        yield* sub_1e69a();
        assert(cs == 0x1e6d);
        sp += 0x0004;
        r16[ax] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e7b9() {
    //CStackGuardFar sg(0, false);
    push(r16[ax]);
    r8[al] = 0x36;
    out8(0x43, r8[al]);
    r16[ax] = pop();
    out8(0x40, r8[al]);
    r8[tl] = r8[al];
    r8[al] = r8[ah];
    r8[ah] = r8[tl];
    out8(0x40, r8[al]);
    r8[tl] = r8[al];
    r8[al] = r8[ah];
    r8[ah] = r8[tl];
    cs = pop();
}
function* sub_1e7d8() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[ax] = memory16get(ss, bp + 6);
    r16[tx] = flags.carry | (flags.zero << 1);
    push(r16[tx]);
    flags.interrupts = false;
    memory16set(cs, 0x0008, r16[ax]);
    flags.carry = r16[ax] < 0x0001;
    memory16set(cs, 0x0006, 0x0000);
    memory16set(cs, 0x0006, memory16get(cs, 0x0006) + flags.carry);
    push(cs);
    cs = 0x1e7a;
    yield* sub_1e7b9();
    assert(cs == 0x1e7a);
    r16[tx] = pop();
    flags.carry = r16[tx] & 1;
    flags.zero = (r16[tx] << 1) & 1;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1e7fc() {
    //CStackGuardFar sg(0, false);
    push(r16[ax]);
    push(r16[dx]);
    r16[ax] = 0;
    push(cs);
    cs = 0x1e7a;
    yield* sub_1e7b9();
    assert(cs == 0x1e7a);
    memory16set(cs, 0x0006, 0x0001);
    memory16set(cs, 0x0008, r16[ax]);
    memory16set(cs, 0x000a, r16[ax]);
    memory[cs*16 + 0x0018] = 0x00;
    r16[ax] = ds;
    memory16set(cs, 0x0010, r16[ax]);
    push(es);
    r8[ah] = 0x35;
    r8[al] = 0x08;
    interrupt(0x21);
    memory16set(cs, 0x000c, r16[bx]);
    memory16set(cs, 0x000e, es);
    es = pop();
    push(ds);
    r8[ah] = 0x25;
    r8[al] = 0x08;
    r16[dx] = 0x00c8;
    r16[bx] = cs;
    ds = r16[bx];
    interrupt(0x21);
    ds = pop();
    r16[dx] = pop();
    r16[ax] = pop();
    cs = pop();
}
function* sub_1e844() {
    //CStackGuardFar sg(0, false);
    r16[ax] = 0;
    push(cs);
    cs = 0x1e7a;
    yield* sub_1e7b9();
    assert(cs == 0x1e7a);
    push(ds);
    r8[ah] = 0x25;
    r8[al] = 0x08;
    r16[dx] = memory16get(cs, 0x000c);
    ds = memory16get(cs, 0x000c + 2);
    interrupt(0x21);
    ds = pop();
    cs = pop();
}
function* sub_1e859() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[tx] = flags.carry | (flags.zero << 1);
    push(r16[tx]);
    flags.interrupts = false;
    r16[ax] = memory16get(ss, bp + 6);
    memory16set(cs, 0x0016, r16[ax]);
    r16[tx] = pop();
    flags.carry = r16[tx] & 1;
    flags.zero = (r16[tx] << 1) & 1;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1e924() {
    //CStackGuardFar sg(0, false);
    interrupt(0x11);
    cs = pop();
}
function* sub_1e958() {
    //CStackGuardFar sg(0, false);
    r8[ah] = 0x19;
    interrupt(0x21);
    r8[ah] = 0;
    cs = pop();
}
function* sub_1e96d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        r8[ah] = 0x43;
        r8[al] = memory[ss*16 + bp + 10];
        r16[cx] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 6);
        ds = memory16get(ss, bp + 6 + 2);
        interrupt(0x21);
        ds = pop();
        if (flags.carry) {
            pc = 0x1e984;
            break;
        }
        r16[tx] = r16[cx];
        r16[cx] = r16[ax];
        r16[ax] = r16[tx];
        pc = 0x1e98a;
        break;
    case 0x1e984:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1e96);
    case 0x1e98a:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e98c() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        if (signed16(r16[si]) < 0) {
            pc = 0x1e99c;
            break;
        }
        if (signed16(r16[si]) < signed16(0x0014)) {
            pc = 0x1e9a7;
            break;
        }
    case 0x1e99c:
        r16[ax] = 0x0006;
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1e98);
        pc = 0x1e9b8;
        break;
    case 0x1e9a7:
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, 0xffff);
        push(r16[si]);
        push(cs);
        cs = 0x1e9b;
        yield* sub_1e9bb();
        assert(cs == 0x1e98);
        r16[cx] = pop();
    case 0x1e9b8:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e9bb() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        r8[ah] = 0x3e;
        r16[bx] = r16[si];
        interrupt(0x21);
        if (flags.carry) {
            pc = 0x1e9d6;
            break;
        }
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, 0xffff);
        r16[ax] = 0;
        pc = 0x1e9dc;
        break;
    case 0x1e9d6:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1e9b);
    case 0x1e9dc:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1e9e2() {
    cs = pop();
    return;

    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        sp--;
        sp--;
        push(bp);
        bp = sp;
        push(r16[si]);
        push(r16[di]);
        push(ds);
        push(es);
        r16[cx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(cs, 0x0000);
        if (r16[ax]) {
            pc = 0x1ea19;
            break;
        }
        r16[ax] = 0x0040;
        es = r16[ax];
        r16[bx] = memoryBiosGet16(es, 0x006c);
        yield* sub_1ea3d();
        r16[bx] -= memoryBiosGet16(es, 0x006c);
        r16[bx] = -r16[bx];
        r16[ax] = 0x0037;
        mul16(r16[bx]);
        if (r16[cx] <= r16[ax]) {
            pc = 0x1ea31;
            break;
        }
        r16[cx] -= r16[ax];
        r16[ax] = memory16get(cs, 0x0000);
    case 0x1ea19:
        r16[bx] = 0;
        es = r16[bx];
        r8[dl] = memoryBiosGet(es, r16[bx]);
        if (r16[cx] == 0) {
            pc = 0x1ea31;
            break;
        }
    case 0x1ea22:
        r16[si] = r16[cx];
        r16[cx] = r16[ax];
    case 0x1ea26:
        if (r8[dl] != memoryBiosGet(es, r16[bx])) {
            pc = 0x1ea2b;
            break;
        }
    case 0x1ea2b:
        if (--r16[cx]) {
            pc = 0x1ea26;
            break;
        }
        r16[cx] = r16[si];
        if (--r16[cx]) {
            pc = 0x1ea22;
            break;
        }
    case 0x1ea31:
        r16[ax] = memory16get(cs, 0x0000);
        es = pop();
        ds = pop();
        r16[di] = pop();
        r16[si] = pop();
        bp = pop();
        sp++;
        sp++;
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1ea3d() {
//throw "x";
    return;
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(0, false);
        push(r16[bx]);
        push(r16[cx]);
        push(r16[dx]);
        push(es);
        r16[ax] = 0x0040;
        es = r16[ax];
        r16[bx] = 0x006c;
        r8[al] = memoryBiosGet(es, r16[bx]);
        r16[cx] = 0xffff;
    case 0x1ea4f:
        r8[dl] = memoryBiosGet(es, r16[bx]);
        if (r8[al] == r8[dl]) {
            pc = 0x1ea4f;
            break;
        }
    case 0x1ea56:
        if (r8[dl] != memoryBiosGet(es, r16[bx])) {
            pc = 0x1ea5d;
            break;
        }
        if (--r16[cx]) {
            pc = 0x1ea56;
            break;
        }
    case 0x1ea5d:
        r16[cx] = -r16[cx];
        r16[cx]--;
        r16[ax] = 0x0037;
        r16[tx] = r16[cx];
        r16[cx] = r16[ax];
        r16[ax] = r16[tx];
        r16[dx] = 0;
        div16(r16[cx]);
        memory16set(cs, 0x0000, r16[ax]);
    case 0x1ea6c:
        r8[al] = memoryBiosGet(es, r16[bx]);
        r16[cx] = 0xffff;
    case 0x1ea72:
        r8[dl] = memoryBiosGet(es, r16[bx]);
        if (r8[al] == r8[dl]) {
            pc = 0x1ea72;
            break;
        }
        push(r16[bx]);
        push(r16[dx]);
        r16[ax] = 0x0037;
        push(r16[ax]);
        push(cs);
        cs = 0x1e9e;
        yield* sub_1e9e2();
        assert(cs == 0x1e9e);
        r16[ax] = pop();
        r16[dx] = pop();
        r16[bx] = pop();
        if (r8[dl] == memoryBiosGet(es, r16[bx])) {
            pc = 0x1ea93;
            break;
        }
        memory16set(cs, 0x0000, memory16get(cs, 0x0000) - 1);
        pc = 0x1ea6c;
        break;
    case 0x1ea93:
        es = pop();
        r16[dx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        return;
    } while (1);
}
function* sub_1ea99() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
    case 0x1ea9c:
        r16[ax] = memory16get(ds, 0x8708);
        memory16set(ds, 0x8708, memory16get(ds, 0x8708) - 1);
        if (!r16[ax]) {
            pc = 0x1eab5;
            break;
        }
        r16[bx] = memory16get(ds, 0x8708);
        r16[bx] <<= 1;
        r16[bx] <<= 1;
        push(cs);
        cs = memory16get(ds, r16[bx] + 40056 + 2);
        yield* callIndirect(memory16get(ds, r16[bx] + 40056 + 2), memory16get(ds, r16[bx] + 40056));
        assert(cs == 0x1ea9);
        pc = 0x1ea9c;
        break;
    case 0x1eab5:
        push(cs);
        cs = memory16get(ds, 0x870a + 2);
        yield* callIndirect(memory16get(ds, 0x870a + 2), memory16get(ds, 0x870a));
        assert(cs == 0x1ea9);
        push(cs);
        cs = memory16get(ds, 0x870e + 2);
        yield* callIndirect(memory16get(ds, 0x870e + 2), memory16get(ds, 0x870e));
        assert(cs == 0x1ea9);
        push(cs);
        cs = memory16get(ds, 0x8712 + 2);
        yield* callIndirect(memory16get(ds, 0x8712 + 2), memory16get(ds, 0x8712));
        assert(cs == 0x1ea9);
        push(memory16get(ss, bp + 6));
        push(cs);
        cs = 0x01ed;
        yield* sub_1fd1();
        assert(cs == 0x1ea9);
        r16[cx] = pop();
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1eacc() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(4, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 10);
        r16[si]++;
        r16[si] -= memory16get(ds, 0x006f);
        r16[ax] = r16[si];
        r16[ax] += 0x003f;
        r16[cx] = 0x0006;
        r16[ax] >>= r8[cl];
        r16[si] = r16[ax];
        if (r16[si] != memory16get(ds, 0x8716)) {
            pc = 0x1eafb;
            break;
        }
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory16set(ds, 0x007d, es);
        memory16set(ds, 0x007b, r16[bx]);
        r16[ax] = 0x0001;
        pc = 0x1eb59;
        break;
    case 0x1eafb:
        r16[cx] = 0x0006;
        r16[si] <<= r8[cl];
        r16[di] = memory16get(ds, 0x0081);
        r16[ax] = r16[si];
        r16[ax] += memory16get(ds, 0x006f);
        if (r16[ax] <= r16[di]) {
            pc = 0x1eb14;
            break;
        }
        r16[si] = r16[di];
        r16[si] -= memory16get(ds, 0x006f);
    case 0x1eb14:
        push(r16[si]);
        push(memory16get(ds, 0x006f));
        push(cs);
        cs = 0x1f5a;
        yield* sub_1f5ab();
        assert(cs == 0x1eac);
        sp = bp;
        r16[di] = r16[ax];
        if (r16[di] != 0xffff) {
            pc = 0x1eb43;
            break;
        }
        r16[ax] = r16[si];
        r16[cx] = 0x0006;
        r16[ax] >>= r8[cl];
        memory16set(ds, 0x8716, r16[ax]);
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 8 + 2);
        memory16set(ds, 0x007d, es);
        memory16set(ds, 0x007b, r16[bx]);
        r16[ax] = 0x0001;
        pc = 0x1eb59;
        break;
    case 0x1eb43:
        r16[ax] = memory16get(ds, 0x006f);
        r16[ax] += r16[di];
        r16[dx] = 0;
        r16[dx] = r16[ax];
        r16[ax] = 0;
        memory16set(ds, 0x0081, r16[dx]);
        memory16set(ds, 0x007f, r16[ax]);
        r16[ax] = 0;
    case 0x1eb59:
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        sp += 4;
        return;
    } while (1);
}
function* sub_1eb5f() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ds, 0x0079);
        r16[bx] = memory16get(ds, 0x0077);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1eac);
        if (flags.carry) {
            pc = 0x1eb99;
            break;
        }
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ds, 0x0081);
        r16[bx] = memory16get(ds, 0x007f);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1eac);
        if (!flags.zero && !flags.carry) {
            pc = 0x1eb99;
            break;
        }
        push(memory16get(ss, bp + 8));
        push(memory16get(ss, bp + 6));
        yield* sub_1eacc();
        if (r16[ax]) {
            pc = 0x1eba0;
            break;
        }
    case 0x1eb99:
        r16[ax] = 0xffff;
        pc = 0x1eba4;
        break;
    case 0x1eba0:
        r16[ax] = 0;
    case 0x1eba4:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1eba6() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[dx] = memory16get(ds, 0x007d);
        r16[ax] = memory16get(ds, 0x007b);
        r16[cx] = memory16get(ss, bp + 8);
        r16[bx] = memory16get(ss, bp + 6);
        push(cs);
        cs = 0x01ed;
        yield* sub_2122();
        assert(cs == 0x1eac);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[cx] = memory16get(ds, 0x0079);
        r16[bx] = memory16get(ds, 0x0077);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1eac);
        if (flags.carry) {
            pc = 0x1ebee;
            break;
        }
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[cx] = memory16get(ds, 0x0081);
        r16[bx] = memory16get(ds, 0x007f);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1eac);
        if (flags.zero || flags.carry) {
            pc = 0x1ebf6;
            break;
        }
    case 0x1ebee:
        r16[dx] = 0xffff;
        r16[ax] = 0xffff;
        pc = 0x1ec1b;
        break;
    case 0x1ebf6:
        r16[bx] = memory16get(ds, 0x007b);
        es = memory16get(ds, 0x007b + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        yield* sub_1eacc();
        if (r16[ax]) {
            pc = 0x1ec15;
            break;
        }
        r16[dx] = 0xffff;
        r16[ax] = 0xffff;
        pc = 0x1ec1b;
        break;
    case 0x1ec15:
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
    case 0x1ec1b:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1ec1f() {
    //CStackGuardFar sg(0, false);
    r16[dx] = memory16get(ds, 0x0081);
    r16[ax] = memory16get(ds, 0x007f);
    r16[cx] = memory16get(ds, 0x007d);
    r16[bx] = memory16get(ds, 0x007b);
    push(cs);
    cs = 0x01ed;
    yield* sub_219f();
    assert(cs == 0x1ec1);
    cs = pop();
}
function* sub_1ec34() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0008;
        r16[ax] = memory16get(ss, bp + 6);
        r16[ax] |= memory16get(ss, bp + 8);
        if (r16[ax]) {
            pc = 0x1ec45;
            break;
        }
        pc = 0x1ee69;
        break;
    case 0x1ec45:
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        r16[cx] = 0xffff;
        r16[bx] = 0xfffc;
        push(cs);
        cs = 0x01ed;
        yield* sub_2122();
        assert(cs == 0x1ec3);
        memory16set(ss, bp - 6, r16[dx]);
        memory16set(ss, bp - 8, r16[ax]);
        r16[bx] = memory16get(ds, 0x8748);
        es = memory16get(ds, 0x8748 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        pc = 0x1ecc0;
        break;
    case 0x1ec68:
        r16[cx] = memory16get(ss, bp - 2);
        r16[bx] = memory16get(ss, bp - 4);
        push(r16[cx]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = pop();
        r16[cx] = pop();
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero && !flags.carry) {
            pc = 0x1ecb3;
            break;
        }
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[cx] = memory16get(ss, bp - 2);
        r16[bx] = memory16get(ss, bp - 4);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero && !flags.carry) {
            pc = 0x1ecf2;
            break;
        }
        r16[cx] = memory16get(ss, bp - 6);
        r16[bx] = memory16get(ss, bp - 8);
        push(r16[cx]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = pop();
        r16[cx] = pop();
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero && !flags.carry) {
            pc = 0x1ecf2;
            break;
        }
    case 0x1ecb3:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
    case 0x1ecc0:
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[cx] = memory16get(ss, bp - 2);
        r16[bx] = memory16get(ss, bp - 4);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (flags.zero || flags.carry) {
            pc = 0x1ec68;
            break;
        }
        r16[cx] = memory16get(ss, bp - 6);
        r16[bx] = memory16get(ss, bp - 8);
        push(r16[cx]);
        push(r16[bx]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = pop();
        r16[cx] = pop();
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero && !flags.carry) {
            pc = 0x1ecf2;
            break;
        }
        pc = 0x1ec68;
        break;
    case 0x1ecf2:
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[cx] = memory16get(es, r16[bx] + 2);
        r16[bx] = memory16get(es, r16[bx]);
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        push(cs);
        cs = 0x01ed;
        yield* sub_2122();
        assert(cs == 0x1ec3);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[cx] = memory16get(es, r16[bx] + 6);
        r16[bx] = memory16get(es, r16[bx] + 4);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero) {
            pc = 0x1ed57;
            break;
        }
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        flags.carry = (r16[ax] + memory16get(es, r16[bx])) >= 0x10000;
        r16[ax] += memory16get(es, r16[bx]);
        r16[dx] += memory16get(es, r16[bx] + 2) + flags.carry;
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 4, r16[ax]);
        pc = 0x1ed6d;
        break;
    case 0x1ed57:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 4, r16[ax]);
    case 0x1ed6d:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[cx] = memory16get(es, r16[bx] + 2);
        r16[bx] = memory16get(es, r16[bx]);
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        push(cs);
        cs = 0x01ed;
        yield* sub_2122();
        assert(cs == 0x1ec3);
        r16[cx] = memory16get(ss, bp - 6);
        r16[bx] = memory16get(ss, bp - 8);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero) {
            pc = 0x1edcb;
            break;
        }
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        flags.carry = (r16[ax] + memory16get(es, r16[bx])) >= 0x10000;
        r16[ax] += memory16get(es, r16[bx]);
        r16[dx] += memory16get(es, r16[bx] + 2) + flags.carry;
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 4, r16[ax]);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        pc = 0x1eddc;
        break;
    case 0x1edcb:
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 4, r16[ax]);
    case 0x1eddc:
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[cx] = memory16get(es, r16[bx] + 2);
        r16[bx] = memory16get(es, r16[bx]);
        r16[dx] = memory16get(ss, bp - 6);
        r16[ax] = memory16get(ss, bp - 8);
        push(cs);
        cs = 0x01ed;
        yield* sub_2122();
        assert(cs == 0x1ec3);
        r16[bx] = r16[ax];
        r16[cx] = r16[dx];
        push(r16[cx]);
        push(r16[bx]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x1eac;
        yield* sub_1eba6();
        assert(cs == 0x1ec3);
        r16[cx] = pop();
        r16[cx] = pop();
        r16[bx] = pop();
        r16[cx] = pop();
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero) {
            pc = 0x1ee5e;
            break;
        }
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
        pc = 0x1ee23;
        break;
    case 0x1ee16:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        memory16set(ss, bp - 2, es);
        memory16set(ss, bp - 4, r16[bx]);
    case 0x1ee23:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[cx] = memory16get(ss, bp - 6);
        r16[bx] = memory16get(ss, bp - 8);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1ec3);
        if (!flags.zero) {
            pc = 0x1ee16;
            break;
        }
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 4, r16[ax]);
        push(memory16get(ss, bp - 6));
        push(memory16get(ss, bp - 8));
        push(cs);
        cs = 0x1eac;
        yield* sub_1eb5f();
        assert(cs == 0x1ec3);
        r16[cx] = pop();
        r16[cx] = pop();
    case 0x1ee5e:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(ds, 0x874a, es);
        memory16set(ds, 0x8748, r16[bx]);
    case 0x1ee69:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1ee6d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[ax] = 0x4201;
        r16[bx] = memory16get(ss, bp + 6);
        r16[cx] = 0;
        r16[dx] = 0;
        interrupt(0x21);
        if (flags.carry) {
            pc = 0x1eea5;
            break;
        }
        push(r16[dx]);
        push(r16[ax]);
        r16[ax] = 0x4202;
        r16[cx] = 0;
        r16[dx] = 0;
        interrupt(0x21);
        memory16set(ss, bp - 4, r16[ax]);
        memory16set(ss, bp - 2, r16[dx]);
        r16[dx] = pop();
        r16[cx] = pop();
        if (flags.carry) {
            pc = 0x1eea5;
            break;
        }
        r16[ax] = 0x4200;
        interrupt(0x21);
        if (flags.carry) {
            pc = 0x1eea5;
            break;
        }
        r16[dx] = memory16get(ss, bp - 2);
        r16[ax] = memory16get(ss, bp - 4);
        pc = 0x1eeac;
        break;
    case 0x1eea5:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1ee6);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    case 0x1eeac:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1eeb0() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        sp -= 0x000c;
        r16[ax] = memory16get(ss, bp + 6);
        r16[ax] |= memory16get(ss, bp + 8);
        if (r16[ax]) {
            pc = 0x1eec5;
            break;
        }
        r16[dx] = 0;
        r16[ax] = 0;
        pc = 0x1f019;
        break;
    case 0x1eec5:
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        flags.carry = (r16[ax] + 0x0009) >= 0x10000;
        r16[ax] += 0x0009;
        r16[dx] += flags.carry;
        r16[ax] &= 0xfffe;
        r16[dx] &= 0xffff;
        memory16set(ss, bp + 8, r16[dx]);
        memory16set(ss, bp + 6, r16[ax]);
        r16[bx] = memory16get(ds, 0x8748);
        es = memory16get(ds, 0x8748 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
    case 0x1eef5:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        if (r16[dx] >= memory16get(ss, bp + 8)) {
            pc = 0x1ef07;
            break;
        }
        pc = 0x1efa5;
        break;
    case 0x1ef07:
        if (r16[dx] != memory16get(ss, bp + 8)) {
            pc = 0x1ef11;
            break;
        }
        if (r16[ax] >= memory16get(ss, bp + 6)) {
            pc = 0x1ef11;
            break;
        }
        pc = 0x1efa5;
        break;
    case 0x1ef11:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        r16[cx] = memory16get(ss, bp + 8);
        r16[bx] = memory16get(ss, bp + 6);
        flags.carry = (r16[bx] + 0x0008) >= 0x10000;
        r16[bx] += 0x0008;
        r16[cx] += flags.carry;
        if (r16[dx] > r16[cx]) {
            pc = 0x1ef49;
            break;
        }
        if (r16[dx] != r16[cx]) {
            pc = 0x1ef31;
            break;
        }
        if (r16[ax] > r16[bx]) {
            pc = 0x1ef49;
            break;
        }
    case 0x1ef31:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[dx] = memory16get(es, r16[bx] + 6);
        r16[ax] = memory16get(es, r16[bx] + 4);
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(es, r16[bx] + 6, r16[dx]);
        memory16set(es, r16[bx] + 4, r16[ax]);
        pc = 0x1ef8e;
        break;
    case 0x1ef49:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[dx] = memory16get(es, r16[bx] + 2);
        r16[ax] = memory16get(es, r16[bx]);
        flags.carry = r16[ax] < memory16get(ss, bp + 6);
        r16[ax] -= memory16get(ss, bp + 6);
        r16[dx] -= memory16get(ss, bp + 8) + flags.carry;
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[cx] = memory16get(es, r16[bx] + 2);
        r16[bx] = memory16get(es, r16[bx]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        push(cs);
        cs = 0x01ed;
        yield* sub_2122();
        assert(cs == 0x1eeb);
        memory16set(ss, bp - 10, r16[dx]);
        memory16set(ss, bp - 12, r16[ax]);
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
    case 0x1ef8e:
        r16[bx] = memory16get(ss, bp - 8);
        es = memory16get(ss, bp - 8 + 2);
        memory16set(ds, 0x874a, es);
        memory16set(ds, 0x8748, r16[bx]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0004;
        pc = 0x1f019;
        break;
    case 0x1efa5:
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        if (r16[dx] != memory16get(ds, 0x874a)) {
            pc = 0x1efb9;
            break;
        }
        if (r16[ax] != memory16get(ds, 0x8748)) {
            pc = 0x1efb9;
            break;
        }
        pc = 0x1efd2;
        break;
    case 0x1efb9:
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(ss, bp - 6, es);
        memory16set(ss, bp - 8, r16[bx]);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        r16[tx] = r16[bx];
        r16[bx] = memory16get(es, r16[tx] + 4);
        es = memory16get(es, r16[tx] + 4 + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        pc = 0x1eef5;
        break;
    case 0x1efd2:
        push(memory16get(ss, bp + 8));
        push(memory16get(ss, bp + 6));
        push(cs);
        cs = 0x1eac;
        yield* sub_1eba6();
        assert(cs == 0x1eeb);
        r16[cx] = pop();
        r16[cx] = pop();
        memory16set(ss, bp - 2, r16[dx]);
        memory16set(ss, bp - 4, r16[ax]);
        if (memory16get(ss, bp - 2) != 0xffff) {
            pc = 0x1eff7;
            break;
        }
        if (memory16get(ss, bp - 4) != 0xffff) {
            pc = 0x1eff7;
            break;
        }
        r16[dx] = 0;
        r16[ax] = 0;
        pc = 0x1f019;
        break;
    case 0x1eff7:
        r16[bx] = memory16get(ss, bp - 4);
        es = memory16get(ss, bp - 4 + 2);
        memory16set(ss, bp - 10, es);
        memory16set(ss, bp - 12, r16[bx]);
        r16[dx] = memory16get(ss, bp + 8);
        r16[ax] = memory16get(ss, bp + 6);
        r16[bx] = memory16get(ss, bp - 12);
        es = memory16get(ss, bp - 12 + 2);
        memory16set(es, r16[bx] + 2, r16[dx]);
        memory16set(es, r16[bx], r16[ax]);
        r16[dx] = memory16get(ss, bp - 10);
        r16[ax] = memory16get(ss, bp - 12);
        r16[ax] += 0x0004;
    case 0x1f019:
        sp = bp;
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f01d() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    push(memory16get(ss, bp + 8));
    push(memory16get(ss, bp + 6));
    push(cs);
    cs = 0x1ec3;
    yield* sub_1ec34();
    assert(cs == 0x1f01);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f09f() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r8[ah] = 0x35;
    r8[al] = memory[ss*16 + bp + 6];
    interrupt(0x21);
    r16[ax] = r16[bx];
    r16[dx] = es;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f0af() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r8[ah] = 0x25;
    r8[al] = memory[ss*16 + bp + 6];
    push(ds);
    r16[dx] = memory16get(ss, bp + 8);
    ds = memory16get(ss, bp + 8 + 2);
    interrupt(0x21);
    ds = pop();
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f0c9() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[dx] = memory16get(ss, bp + 6);
    r8[al] = in8(r16[dx]);
    r8[ah] = 0;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f0d4() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    push(ss);
    r16[ax] = bp - 0x8;
    push(r16[ax]);
    push(cs);
    cs = 0x1f59;
    yield* sub_1f590();
    assert(cs == 0x1f0d);
    r16[cx] = pop();
    r16[cx] = pop();
    push(ss);
    r16[ax] = bp - 0x8;
    push(r16[ax]);
    push(memory16get(ss, bp + 14));
    push(memory16get(ss, bp + 12));
    push(memory16get(ss, bp + 10));
    push(memory16get(ss, bp + 8));
    push(memory16get(ss, bp + 6));
    push(cs);
    cs = 0x1f0d;
    yield* sub_1f106();
    assert(cs == 0x1f0d);
    sp += 0x000e;
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f106() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x000e;
        push(ds);
        r16[cx] = bp - 0xa;
        memory16set(ss, bp - 14, r16[cx]);
        memory16set(ss, bp - 12, ss);
        memory[ss*16 + bp - 10] = 0x55;
        memory[ss*16 + bp - 9] = 0xcd;
        r16[ax] = memory16get(ss, bp + 10);
        memory[ss*16 + bp - 8] = r8[al];
        memory16set(ss, bp - 7, 0xcb5d);
        if (r8[al] < 0x25) {
            pc = 0x1f144;
            break;
        }
        if (r8[al] > 0x26) {
            pc = 0x1f144;
            break;
        }
        memory[ss*16 + bp - 7] = 0x36;
        memory16set(ss, bp - 6, 0x068f);
        memory16set(ss, bp - 4, r16[cx]);
        memory16set(ss, bp - 2, 0xcb5d);
    case 0x1f144:
        r16[si] = memory16get(ss, bp + 20);
        ds = memory16get(ss, bp + 20 + 2);
        push(memory16get(ds, r16[si]));
        push(memory16get(ds, r16[si] + 6));
        r16[si] = memory16get(ss, bp + 12);
        ds = memory16get(ss, bp + 12 + 2);
        r16[ax] = memory16get(ds, r16[si]);
        r16[bx] = memory16get(ds, r16[si] + 2);
        r16[cx] = memory16get(ds, r16[si] + 4);
        r16[dx] = memory16get(ds, r16[si] + 6);
        r16[di] = memory16get(ds, r16[si] + 10);
        r16[si] = memory16get(ds, r16[si] + 8);
        ds = pop();
        es = pop();
        {
            var buf = [
                memory[memory16get(ss, bp - 14 + 2)*16 + memory16get(ss, bp - 14)],
                memory[memory16get(ss, bp - 14 + 2)*16 + memory16get(ss, bp - 14)+1],
                memory[memory16get(ss, bp - 14 + 2)*16 + memory16get(ss, bp - 14)+2],
                memory[memory16get(ss, bp - 14 + 2)*16 + memory16get(ss, bp - 14)+3],
                memory[memory16get(ss, bp - 14 + 2)*16 + memory16get(ss, bp - 14)+4]
            ];
            if (buf[0] == 0x55 && buf[1] == 0xcd && buf[3] == 0x5d && buf[4] == 0xcb)
                interrupt(buf[2]);
            else
                assert(0);
        }
        r16[tx] = flags.carry | (flags.zero << 1);
        push(r16[tx]);
        r16[tx] = flags.carry | (flags.zero << 1);
        push(r16[tx]);
        push(r16[si]);
        push(ds);
        push(es);
        r16[si] = memory16get(ss, bp + 20);
        ds = memory16get(ss, bp + 20 + 2);
        memory16set(ds, r16[si], pop());
        memory16set(ds, r16[si] + 6, pop());
        r16[si] = memory16get(ss, bp + 16);
        ds = memory16get(ss, bp + 16 + 2);
        memory16set(ds, r16[si] + 8, pop());
        memory16set(ds, r16[si] + 14, pop());
        memory16set(ds, r16[si] + 12, pop());
        memory16set(ds, r16[si] + 12, memory16get(ds, r16[si] + 12) & 0x0001);
        memory16set(ds, r16[si] + 10, r16[di]);
        memory16set(ds, r16[si] + 6, r16[dx]);
        memory16set(ds, r16[si] + 4, r16[cx]);
        memory16set(ds, r16[si] + 2, r16[bx]);
        memory16set(ds, r16[si], r16[ax]);
        ds = pop();
        if (memory16get(ds, r16[si] + 12) == 0) {
            pc = 0x1f19c;
            break;
        }
        push(r16[ax]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f0d);
        r16[ax] = pop();
    case 0x1f19c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f1a2() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        r8[ah] = 0x44;
        r8[al] = memory[ss*16 + bp + 8];
        r16[bx] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 14);
        r16[dx] = memory16get(ss, bp + 10);
        ds = memory16get(ss, bp + 10 + 2);
        interrupt(0x21);
        ds = pop();
        if (flags.carry) {
            pc = 0x1f1c5;
            break;
        }
        if (memory16get(ss, bp + 8) != 0x0000) {
            pc = 0x1f1c3;
            break;
        }
        r16[ax] = r16[dx];
        pc = 0x1f1cb;
        break;
    case 0x1f1c3:
        pc = 0x1f1cb;
        break;
    case 0x1f1c5:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f1a);
    case 0x1f1cb:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f1cd() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(2, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r16[si] = memory16get(ss, bp + 8);
        if (signed16(r16[si]) < 0) {
            pc = 0x1f1ec;
            break;
        }
        if (r16[si] <= 0x0058) {
            pc = 0x1f1e0;
            break;
        }
    case 0x1f1dd:
        r16[si] = 0x0057;
    case 0x1f1e0:
        memory16set(ds, 0x8750, r16[si]);
        r8[al] = memory[ds*16 + r16[si] + 34642];
        cbw();
        r16[tx] = r16[si];
        r16[si] = r16[ax];
        r16[ax] = r16[tx];
        pc = 0x1f1f9;
        break;
    case 0x1f1ec:
        r16[si] = -r16[si];
        if (r16[si] > 0x0022) {
            pc = 0x1f1dd;
            break;
        }
        memory16set(ds, 0x8750, 0xffff);
    case 0x1f1f9:
        r16[ax] = r16[si];
        memory16set(ds, 0x0073, r16[ax]);
        r16[ax] = 0xffff;
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        sp += 2;
        return;
    } while (1);
}
function* sub_1f206() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[bx] = memory16get(ss, bp + 6);
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, memory16get(ds, r16[bx] + 34584) & 0xfdff);
        r8[ah] = 0x42;
        r8[al] = memory[ss*16 + bp + 12];
        r16[bx] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 10);
        r16[dx] = memory16get(ss, bp + 8);
        interrupt(0x21);
        if (flags.carry) {
            pc = 0x1f228;
            break;
        }
        pc = 0x1f22f;
        break;
    case 0x1f228:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f20);
        r16[dx] = r16[ax] & 0x8000 ? 0xffff : 0x0000;
    case 0x1f22f:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f231() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[ax] = memory16get(ss, bp + 6);
    r16[dx] = 0;
    push(r16[dx]);
    push(r16[ax]);
    push(cs);
    cs = 0x1eeb;
    yield* sub_1eeb0();
    assert(cs == 0x1f23);
    sp = bp;
    bp = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f244() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        push(ds);
        r16[dx] = memory16get(ss, bp + 12);
        r16[ax] = memory16get(ss, bp + 10);
        r16[cx] = memory16get(ss, bp + 16);
        r16[bx] = memory16get(ss, bp + 14);
        push(cs);
        cs = 0x01ed;
        yield* sub_217d();
        assert(cs == 0x1f24);
        if (!flags.carry) {
            pc = 0x1f263;
            break;
        }
        flags.direction = true;
        r16[ax] = 0x0001;
        pc = 0x1f266;
        break;
    case 0x1f263:
        flags.direction = false;
        r16[ax] = 0;
    case 0x1f266:
        r16[si] = memory16get(ss, bp + 10);
        ds = memory16get(ss, bp + 10 + 2);
        r16[di] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
        r16[cx] = memory16get(ss, bp + 18);
        if (!r16[ax]) {
            pc = 0x1f279;
            break;
        }
        r16[si] += r16[cx];
        r16[si]--;
        r16[di] += r16[cx];
        r16[di]--;
    case 0x1f279:
        if (!(r16[di] & 0x0001)) {
            pc = 0x1f283;
            break;
        }
        if (r16[cx] == 0) {
            pc = 0x1f292;
            break;
        }
        movsb_data_data_forward();
        r16[cx]--;
    case 0x1f283:
        r16[si] -= r16[ax];
        r16[di] -= r16[ax];
        flags.carry = r16[cx] & 1;
        r16[cx] >>= 1;
        rep_movsw_data_data_forward();
        if (!flags.carry) {
            pc = 0x1f292;
            break;
        }
        r16[si] += r16[ax];
        r16[di] += r16[ax];
        movsb_data_data_forward();
    case 0x1f292:
        flags.direction = false;
        ds = pop();
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f2b8() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuard sg(6, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        r16[cx] = memory16get(ss, bp + 4);
        r8[ah] = 0x3c;
        r16[dx] = memory16get(ss, bp + 6);
        ds = memory16get(ss, bp + 6 + 2);
        interrupt(0x21);
        ds = pop();
        if (flags.carry) {
            pc = 0x1f2cb;
            break;
        }
        pc = 0x1f2d1;
        break;
    case 0x1f2cb:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f2b);
    case 0x1f2d1:
        bp = pop();
        assert(pop() == 0x7777);
        sp += 6;
        return;
    } while (1);
}
function* sub_1f2d5() {
    //CStackGuard sg(2, true);
    push(0x7777);
    push(bp);
    bp = sp;
    r16[bx] = memory16get(ss, bp + 4);
    r16[cx] = 0;
    r16[dx] = 0;
    r8[ah] = 0x40;
    interrupt(0x21);
    bp = pop();
    assert(pop() == 0x7777);
    sp += 2;
}
function* sub_1f2e7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp--;
        sp--;
        r16[di] = memory16get(ss, bp + 14);
        if (r16[di] & 0xc000) {
            pc = 0x1f2ff;
            break;
        }
        r16[ax] = memory16get(ds, 0x874c);
        r16[ax] &= 0xc000;
        r16[di] |= r16[ax];
    case 0x1f2ff:
        if (r16[di] & 0x0100) {
            pc = 0x1f308;
            break;
        }
        pc = 0x1f3a6;
        break;
    case 0x1f308:
        r16[ax] = memory16get(ds, 0x874e);
        memory16set(ss, bp + 16, memory16get(ss, bp + 16) & r16[ax]);
        r16[ax] = memory16get(ss, bp + 16);
        if (r16[ax] & 0x0180) {
            pc = 0x1f31f;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f2b);
    case 0x1f31f:
        r16[ax] = 0;
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1e96;
        yield* sub_1e96d();
        assert(cs == 0x1f2b);
        sp += 0x0006;
        memory16set(ss, bp - 2, r16[ax]);
        if (r16[ax] != 0xffff) {
            pc = 0x1f34b;
            break;
        }
        if (!(memory16get(ss, bp + 16) & 0x0080)) {
            pc = 0x1f343;
            break;
        }
        r16[ax] = 0;
        pc = 0x1f346;
        break;
    case 0x1f343:
        r16[ax] = 0x0001;
    case 0x1f346:
        memory16set(ss, bp - 2, r16[ax]);
        pc = 0x1f361;
        break;
    case 0x1f34b:
        if (!(r16[di] & 0x0400)) {
            pc = 0x1f35f;
            break;
        }
        r16[ax] = 0x0050;
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f2b);
        pc = 0x1f427;
        break;
    case 0x1f35f:
        pc = 0x1f3a6;
        break;
    case 0x1f361:
        if (!(r16[di] & 0x00f0)) {
            pc = 0x1f38b;
            break;
        }
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        r16[ax] = 0;
        push(r16[ax]);
        yield* sub_1f2b8();
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] >= 0) {
            pc = 0x1f380;
            break;
        }
        r16[ax] = r16[si];
        pc = 0x1f427;
        break;
    case 0x1f380:
        push(r16[si]);
        push(cs);
        cs = 0x1e9b;
        yield* sub_1e9bb();
        assert(cs == 0x1f2b);
        r16[cx] = pop();
        pc = 0x1f3ab;
        break;
    case 0x1f38b:
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(memory16get(ss, bp - 2));
        yield* sub_1f2b8();
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] >= 0) {
            pc = 0x1f3a4;
            break;
        }
        r16[ax] = r16[si];
        pc = 0x1f427;
        break;
    case 0x1f3a4:
        pc = 0x1f404;
        break;
    case 0x1f3a6:
        memory16set(ss, bp - 2, 0x0000);
    case 0x1f3ab:
        push(r16[di]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f42;
        yield* sub_1f42d();
        assert(cs == 0x1f2b);
        sp += 0x0006;
        r16[si] = r16[ax];
        r16[ax] = r16[si];
        if (r16s[ax] < 0) {
            pc = 0x1f404;
            break;
        }
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[si]);
        push(cs);
        cs = 0x1f1a;
        yield* sub_1f1a2();
        assert(cs == 0x1f2b);
        r16[cx] = pop();
        r16[cx] = pop();
        if (!(r16[ax] & 0x0080)) {
            pc = 0x1f3d8;
            break;
        }
        r16[di] |= 0x2000;
        pc = 0x1f3e2;
        break;
    case 0x1f3d8:
        if (!(r16[di] & 0x0200)) {
            pc = 0x1f3e2;
            break;
        }
        push(r16[si]);
        yield* sub_1f2d5();
    case 0x1f3e2:
        if (memory16get(ss, bp - 2) == 0x0000) {
            pc = 0x1f404;
            break;
        }
        if (!(r16[di] & 0x00f0)) {
            pc = 0x1f404;
            break;
        }
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1e96;
        yield* sub_1e96d();
        assert(cs == 0x1f2b);
        sp += 0x0008;
    case 0x1f404:
        if (signed16(r16[si]) < 0) {
            pc = 0x1f425;
            break;
        }
        if (!(r16[di] & 0x0300)) {
            pc = 0x1f413;
            break;
        }
        r16[ax] = 0x1000;
        pc = 0x1f415;
        break;
    case 0x1f413:
        r16[ax] = 0;
    case 0x1f415:
        r16[dx] = r16[di];
        r16[dx] &= 0xf8ff;
        r16[ax] |= r16[dx];
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, r16[ax]);
    case 0x1f425:
        r16[ax] = r16[si];
    case 0x1f427:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f42d() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(bp);
        bp = sp;
        r8[al] = 0x01;
        r16[cx] = memory16get(ss, bp + 12);
        if (r16[cx] & 0x0002) {
            pc = 0x1f446;
            break;
        }
        r8[al] = 0x02;
        if (r16[cx] & 0x0004) {
            pc = 0x1f446;
            break;
        }
        r8[al] = 0x00;
    case 0x1f446:
        push(ds);
        r16[dx] = memory16get(ss, bp + 8);
        ds = memory16get(ss, bp + 8 + 2);
        r8[cl] = 0xf0;
        r8[cl] &= memory[ss*16 + bp + 12];
        r8[al] |= r8[cl];
        r8[ah] = 0x3d;
        interrupt(0x21);
        ds = pop();
        if (flags.carry) {
            pc = 0x1f46f;
            break;
        }
        r16[si] = r16[ax];
        r16[ax] = memory16get(ss, bp + 12);
        r16[ax] &= 0xf8ff;
        r16[ax] |= 0x8000;
        r16[bx] = r16[si];
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, r16[ax]);
        r16[ax] = r16[si];
        pc = 0x1f475;
        break;
    case 0x1f46f:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f42);
    case 0x1f475:
        bp = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f489() {
    //CStackGuardFar sg(0, false);
    r16[dx] = memory16get(ds, 0x87ae);
    r16[ax] = memory16get(ds, 0x87ac);
    r16[cx] = 0x015a;
    r16[bx] = 0x4e35;
    push(cs);
    cs = 0x01ed;
    yield* sub_2109();
    assert(cs == 0x1f47);
    flags.carry = (r16[ax] + 0x0001) >= 0x10000;
    r16[ax] += 0x0001;
    r16[dx] += flags.carry;
    memory16set(ds, 0x87ae, r16[dx]);
    memory16set(ds, 0x87ac, r16[ax]);
    r16[ax] = memory16get(ds, 0x87ae);
    r16[ax] &= 0x7fff;
    cs = pop();
}
function* sub_1f4af() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x0004;
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax]++;
        if (r16[ax] < 0x0002) {
            pc = 0x1f4cd;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        if (!(memory16get(ds, r16[bx] + 34584) & 0x0200)) {
            pc = 0x1f4d2;
            break;
        }
    case 0x1f4cd:
        r16[ax] = 0;
        pc = 0x1f56c;
        break;
    case 0x1f4d2:
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f57;
        yield* sub_1f572();
        assert(cs == 0x1f4a);
        sp += 0x0008;
        memory16set(ss, bp - 4, r16[ax]);
        r16[ax] = memory16get(ss, bp - 4);
        r16[ax]++;
        if (r16[ax] < 0x0002) {
            pc = 0x1f4ff;
            break;
        }
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        if (!(memory16get(ds, r16[bx] + 34584) & 0x8000)) {
            pc = 0x1f505;
            break;
        }
    case 0x1f4ff:
        r16[ax] = memory16get(ss, bp - 4);
        pc = 0x1f56c;
        break;
    case 0x1f505:
        r16[cx] = memory16get(ss, bp - 4);
        r16[si] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        r16[di] = r16[si];
        r16[bx] = r16[si];
        flags.direction = false;
    case 0x1f510:
        lodsb_es_data_forward();
        if (r8[al] == 0x1a) {
            pc = 0x1f546;
            break;
        }
        if (r8[al] == 0x0d) {
            pc = 0x1f51f;
            break;
        }
        stosb_data_forward();
        if (--r16[cx]) {
            pc = 0x1f510;
            break;
        }
        pc = 0x1f53e;
        break;
    case 0x1f51f:
        if (--r16[cx]) {
            pc = 0x1f510;
            break;
        }
        push(es);
        push(r16[bx]);
        r16[ax] = 0x0001;
        push(r16[ax]);
        r16[ax] = bp - 0x1;
        push(ss);
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f57;
        yield* sub_1f572();
        assert(cs == 0x1f4a);
        sp += 0x0008;
        r16[bx] = pop();
        es = pop();
        flags.direction = false;
        r8[al] = memory[ss*16 + bp - 1];
        stosb_data_forward();
    case 0x1f53e:
        if (r16[di] != r16[bx]) {
            pc = 0x1f544;
            break;
        }
        pc = 0x1f4d2;
        break;
    case 0x1f544:
        pc = 0x1f568;
        break;
    case 0x1f546:
        push(r16[bx]);
        r16[ax] = 0x0002;
        push(r16[ax]);
        flags.carry = r16[cx] != 0;
        r16[cx] = -r16[cx];
        r16[ax] -= r16[ax] + flags.carry;
        push(r16[ax]);
        push(r16[cx]);
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f20;
        yield* sub_1f206();
        assert(cs == 0x1f4a);
        sp += 0x0008;
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, memory16get(ds, r16[bx] + 34584) | 0x0200);
        r16[bx] = pop();
    case 0x1f568:
        r16[ax] = r16[di];
        r16[ax] -= r16[bx];
    case 0x1f56c:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f572() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        push(ds);
        r8[ah] = 0x3f;
        r16[bx] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 8);
        ds = memory16get(ss, bp + 8 + 2);
        interrupt(0x21);
        ds = pop();
        if (flags.carry) {
            pc = 0x1f588;
            break;
        }
        pc = 0x1f58e;
        break;
    case 0x1f588:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f57);
    case 0x1f58e:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f590() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(bp);
    bp = sp;
    r16[ax] = es;
    r16[si] = memory16get(ss, bp + 8);
    es = memory16get(ss, bp + 8 + 2);
    memory16set(es, r16[si], r16[ax]);
    memory16set(es, r16[si] + 2, cs);
    memory16set(es, r16[si] + 4, ss);
    memory16set(es, r16[si] + 6, ds);
    bp = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f5ab() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r8[ah] = 0x4a;
        r16[bx] = memory16get(ss, bp + 8);
        es = memory16get(ss, bp + 6);
        interrupt(0x21);
        if (flags.carry) {
            pc = 0x1f5bf;
            break;
        }
        r16[ax] = 0xffff;
        pc = 0x1f5c7;
        break;
    case 0x1f5bf:
        push(r16[bx]);
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f5a);
        r16[ax] = pop();
    case 0x1f5c7:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f5c9() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[bx] = memory16get(ss, bp + 6);
        r16[ax] = 0x34dd;
        r16[dx] = 0x0012;
        if (r16[dx] >= r16[bx]) {
            pc = 0x1f5f3;
            break;
        }
        div16(r16[bx]);
        r16[bx] = r16[ax];
        r8[al] = in8(0x61);
        if (r8[al] & 0x03) {
            pc = 0x1f5eb;
            break;
        }
        r8[al] |= 0x03;
        out8(0x61, r8[al]);
        r8[al] = 0xb6;
        out8(0x43, r8[al]);
    case 0x1f5eb:
        r8[al] = r8[bl];
        out8(0x42, r8[al]);
        r8[al] = r8[bh];
        out8(0x42, r8[al]);
    case 0x1f5f3:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f5f5() {
    //CStackGuardFar sg(0, false);
    r8[al] = in8(0x61);
    r8[al] &= 0xfc;
    out8(0x61, r8[al]);
    cs = pop();
}
function* sub_1f63a() {
    //CStackGuardFar sg(0, true);
    push(0x7777);
    push(r16[si]);
    push(r16[di]);
    push(bp);
    bp = sp;
    push(ds);
    flags.direction = false;
    r16[di] = memory16get(ss, bp + 14);
    es = memory16get(ss, bp + 14 + 2);
    r16[si] = r16[di];
    r8[al] = 0;
    r16[cx] = 0xffff;
    repne_scasb_data_forward(r8[al]);
    r16[cx] = ~r16[cx];
    r16[di] = r16[si];
    r16[si] = memory16get(ss, bp + 10);
    ds = memory16get(ss, bp + 10 + 2);
    repe_cmpsb_data_data_forward();
    r8[al] = memory[ds*16 + r16[si] - 1];
    r8[al] -= memory[es*16 + r16[di] - 1];
    cbw();
    ds = pop();
    bp = pop();
    r16[di] = pop();
    r16[si] = pop();
    assert(pop() == 0x7777);
    cs = pop();
}
function* sub_1f663() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        push(ds);
        flags.direction = false;
        r16[si] = memory16get(ss, bp + 10);
        ds = memory16get(ss, bp + 10 + 2);
        r16[di] = memory16get(ss, bp + 14);
        es = memory16get(ss, bp + 14 + 2);
    case 0x1f670:
        lodsb_data_forward();
        r8[ah] = memory[es*16 + r16[di]];
        if (!r8[al]) {
            pc = 0x1f696;
            break;
        }
        flags.zero = memory[es*16 + r16[di]++] == r8[al];
        if (flags.zero) {
            pc = 0x1f670;
            break;
        }
        if (r8[al] < 0x61) {
            pc = 0x1f685;
            break;
        }
        if (r8[al] > 0x7a) {
            pc = 0x1f685;
            break;
        }
        r8[al] -= 0x20;
    case 0x1f685:
        if (r8[ah] < 0x61) {
            pc = 0x1f692;
            break;
        }
        if (r8[ah] > 0x7a) {
            pc = 0x1f692;
            break;
        }
        r8[ah] -= 0x20;
    case 0x1f692:
        if (r8[al] == r8[ah]) {
            pc = 0x1f670;
            break;
        }
    case 0x1f696:
        r8[al] -= r8[ah];
        cbw();
        ds = pop();
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f6b7() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(r16[si]);
        push(r16[di]);
        push(bp);
        bp = sp;
        sp -= 0x008e;
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax]++;
        if (r16[ax] >= 0x0002) {
            pc = 0x1f6ce;
            break;
        }
        r16[ax] = 0;
        pc = 0x1f803;
        break;
    case 0x1f6ce:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        if (!(memory16get(ds, r16[bx] + 34584) & 0x8000)) {
            pc = 0x1f6f2;
            break;
        }
        push(memory16get(ss, bp + 16));
        push(memory16get(ss, bp + 14));
        push(memory16get(ss, bp + 12));
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f80;
        yield* sub_1f809();
        assert(cs == 0x1f6b);
        sp += 0x0008;
        pc = 0x1f803;
        break;
    case 0x1f6f2:
        r16[bx] = memory16get(ss, bp + 10);
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, memory16get(ds, r16[bx] + 34584) & 0xfdff);
        r16[bx] = memory16get(ss, bp + 12);
        es = memory16get(ss, bp + 12 + 2);
        memory16set(ss, bp - 134, es);
        memory16set(ss, bp - 136, r16[bx]);
        r16[si] = memory16get(ss, bp + 16);
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0x82;
        memory16set(ss, bp - 140, es);
        memory16set(ss, bp - 142, r16[bx]);
    case 0x1f71b:
        if (r16[si]) {
            pc = 0x1f722;
            break;
        }
        pc = 0x1f7b9;
        break;
    case 0x1f722:
        r16[si]--;
        r16[bx] = memory16get(ss, bp - 136);
        es = memory16get(ss, bp - 136 + 2);
        memory16set(ss, bp - 136, memory16get(ss, bp - 136) + 1);
        r8[al] = memory[es*16 + r16[bx]];
        memory[ss*16 + bp - 137] = r8[al];
        if (r8[al] != 0x0a) {
            pc = 0x1f743;
            break;
        }
        r16[bx] = memory16get(ss, bp - 142);
        es = memory16get(ss, bp - 142 + 2);
        memory[es*16 + r16[bx]] = 0x0d;
        memory16set(ss, bp - 142, memory16get(ss, bp - 142) + 1);
    case 0x1f743:
        r8[al] = memory[ss*16 + bp - 137];
        r16[bx] = memory16get(ss, bp - 142);
        es = memory16get(ss, bp - 142 + 2);
        memory[es*16 + r16[bx]] = r8[al];
        memory16set(ss, bp - 142, memory16get(ss, bp - 142) + 1);
        r16[ax] = memory16get(ss, bp - 142);
        r16[cx] = ss;
        r16[bx] = bp - 0x82;
        r16[ax] -= r16[bx];
        if (r16s[ax] < signed16(0x0080)) {
            pc = 0x1f7b6;
            break;
        }
        r16[ax] = memory16get(ss, bp - 142);
        r16[cx] = ss;
        r16[bx] = bp - 0x82;
        r16[ax] -= r16[bx];
        r16[di] = r16[ax];
        push(r16[di]);
        push(ss);
        r16[ax] = bp - 0x82;
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f80;
        yield* sub_1f809();
        assert(cs == 0x1f6b);
        sp += 0x0008;
        memory16set(ss, bp - 132, r16[ax]);
        if (r16[ax] == r16[di]) {
            pc = 0x1f7a6;
            break;
        }
        if (memory16get(ss, bp - 132) >= 0x0000) {
            pc = 0x1f799;
            break;
        }
        r16[ax] = 0xffff;
        pc = 0x1f803;
        break;
    case 0x1f799:
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax] -= r16[si];
        r16[ax] += memory16get(ss, bp - 132);
        r16[ax] -= r16[di];
        pc = 0x1f803;
        break;
    case 0x1f7a6:
        r16[bx] = ss;
        es = r16[bx];
        r16[bx] = bp - 0x82;
        memory16set(ss, bp - 140, es);
        memory16set(ss, bp - 142, r16[bx]);
    case 0x1f7b6:
        pc = 0x1f71b;
        break;
    case 0x1f7b9:
        r16[ax] = memory16get(ss, bp - 142);
        r16[cx] = ss;
        r16[bx] = bp - 0x82;
        r16[ax] -= r16[bx];
        r16[di] = r16[ax];
        r16[ax] = r16[di];
        if (stop(/*condition!*/)) {
            pc = 0x1f800;
            break;
        }
        push(r16[di]);
        push(ss);
        r16[ax] = bp - 0x82;
        push(r16[ax]);
        push(memory16get(ss, bp + 10));
        push(cs);
        cs = 0x1f80;
        yield* sub_1f809();
        assert(cs == 0x1f6b);
        sp += 0x0008;
        memory16set(ss, bp - 132, r16[ax]);
        if (r16[ax] == r16[di]) {
            pc = 0x1f800;
            break;
        }
        if (memory16get(ss, bp - 132) >= 0x0000) {
            pc = 0x1f7f5;
            break;
        }
        r16[ax] = 0xffff;
        pc = 0x1f803;
        break;
    case 0x1f7f5:
        r16[ax] = memory16get(ss, bp + 16);
        r16[ax] += memory16get(ss, bp - 132);
        r16[ax] -= r16[di];
        pc = 0x1f803;
        break;
    case 0x1f800:
        r16[ax] = memory16get(ss, bp + 16);
    case 0x1f803:
        sp = bp;
        bp = pop();
        r16[di] = pop();
        r16[si] = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}
function* sub_1f809() {
    var pc = 0;
    do switch (pc) {
    case 0:
        //CStackGuardFar sg(0, true);
        push(0x7777);
        push(bp);
        bp = sp;
        r16[bx] = memory16get(ss, bp + 6);
        r16[bx] <<= 1;
        if (!(memory16get(ds, r16[bx] + 34584) & 0x0800)) {
            pc = 0x1f82b;
            break;
        }
        r16[ax] = 0x0002;
        push(r16[ax]);
        r16[ax] = 0;
        push(r16[ax]);
        push(r16[ax]);
        push(memory16get(ss, bp + 6));
        push(cs);
        cs = 0x1f20;
        yield* sub_1f206();
        assert(cs == 0x1f80);
        sp = bp;
    case 0x1f82b:
        push(ds);
        r8[ah] = 0x40;
        r16[bx] = memory16get(ss, bp + 6);
        r16[cx] = memory16get(ss, bp + 12);
        r16[dx] = memory16get(ss, bp + 8);
        ds = memory16get(ss, bp + 8 + 2);
        interrupt(0x21);
        ds = pop();
        if (flags.carry) {
            pc = 0x1f84b;
            break;
        }
        push(r16[ax]);
        r16[bx] = memory16get(ss, bp + 6);
        r16[bx] <<= 1;
        memory16set(ds, r16[bx] + 34584, memory16get(ds, r16[bx] + 34584) | 0x1000);
        r16[ax] = pop();
        pc = 0x1f851;
        break;
    case 0x1f84b:
        push(r16[ax]);
        push(cs);
        cs = 0x1f1c;
        yield* sub_1f1cd();
        assert(cs == 0x1f80);
    case 0x1f851:
        bp = pop();
        assert(pop() == 0x7777);
        cs = pop();
        return;
    } while (1);
}