<canvas id="canvas" width="320" height="200" style="border: 1px solid #d0d0d0; transform:translate(320px, 175px) scale(2);"></canvas>

<script src="app_inline.js"></script>
<script>
/*
    ABORT = false;
     function _apiPrint(ptr)
    { 
      console.log(UTF8ToString(ptr));
    }
//  int apiRead(char* name, int readofs, int readlen, void* targetofs);

    function _apiRead(ptrName, readOfs, readLen, ptrData) 
    {
      var name = UTF8ToString(ptrName);
      console.log("Read ", name);
      var b = Module[name];
      var willRead = Math.min(b.length-readOfs, readLen);
      var memory = HEAP8; //Module['memory'];
      for (var i=0; i<readLen; i++)
        memory[i+ptrData] = b[i+readOfs];
      return willRead;
    }

  Module['wasm'] = Module['wasmBinary'];
*/
</script>
<!--<script src="app.js"></script>-->
<script src="resources.js"></script>
<!--<script src="fibers.js"></script>-->
<script>

var Module = typeof Module !== 'undefined' ? Module : {};

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  var HEAPU8;
  var HEAPU32;
function Main() 
{
  var WASM_PAGE_SIZE = 65536;
  var TOTAL_MEMORY = 65536;
  var DYNAMICTOP_PTR = 11856;

  var abort = (what) => { throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.'};
  var env =
     { "abort": () => {console.log("abort1"); abort()}, 
       "_abort": () => {console.log("abort2"); abort()},
       "__assert_fail": ___assert_fail, 
       "__setErrNo": () => {console.log("abort3"); abort()}, 
       "emscripten_get_heap_size": () => {console.log("abort4"); abort()}, 
       "emscripten_memcpy_big": (dest, src, num) => {
         HEAPU8.copyWithin(dest, src, src + num);
       }, 
       "emscripten_resize_heap": () => {console.log("abort6"); abort()},
       "abortOnCannotGrowMemory": () => {console.log("abort7"); abort()}, 
       "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
       memory:new WebAssembly.Memory({ 'initial': TOTAL_MEMORY / WASM_PAGE_SIZE, 'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE }),
       table:new WebAssembly.Table({'initial': 84,'maximum': 84,'element': 'anyfunc'}),
       '__memory_base': 1024, 
       '__table_base': 0
  };

  var imports = Module["imports"];
  for (var i in imports)
    env[i] = imports[i];

  return WebAssembly.instantiate(new Uint8Array(Module['wasmBinary']), {env:env,wasi_snapshot_preview1: env})
  .then( output => 
   {
    HEAPU8 = new Uint8Array(output.instance.exports.memory.buffer);
    HEAP32 = new Int32Array(output.instance.exports.memory.buffer);
    var exports = output.instance.exports;
    Module['asm'] = exports;
    if (Module["asm"]["__wasm_call_ctors"]) Module["asm"]["__wasm_call_ctors"]();
//    Module["memory"] = new Uint8Array(env.memory.buffer);

    var _exports = Module['exports'];
    for (var i in _exports)
      Module[i] = _exports[i] = Module["asm"][i];

    Module["memory"] = new Uint8Array(exports.memory.buffer);
    return output;
  });
};

var rewinding = false;
var startup = 0;

  Module['imports'] = {
    apiPrint: (ptr) => { 
      var msg = Module['imports'].string(ptr);
      console.log(msg);
    },
    string: (ptr) => {
      var text = "";
      for (var i=0; i<50 && Module['memory'][ptr+i] != 0; i++)
        text += String.fromCharCode(Module['memory'][ptr+i]);
      return text;
    },
    apiRead: (ptrName, readOfs, readLen, ptrData) =>
    {
      var name = Module['imports'].string(ptrName);
      console.log("Read ", name);
      var b = Module[name];
      var willRead = Math.min(b.length-readOfs, readLen);
      var memory = Module['memory'];
      for (var i=0; i<readLen; i++)
        memory[i+ptrData] = b[i+readOfs];
      return willRead;
    },
    // https://gov.near.org/t/discussion-synchronous-contracts/11869/8
    emscripten_sleep: () => {
        if (!rewinding)
        {
          var ptr = Module.asm.asyncifyBuffer.value;
          HEAP32[((ptr)>>2)] = ptr+12;
          HEAP32[(((ptr)+(4))>>2)] = ptr+12 + 4096;
          HEAP32[(((ptr)+(8))>>2)] = 0;
          Module.asm.asyncify_start_unwind(ptr);

          setTimeout( ()=> {
            rewinding = true;

            Module.asm.asyncify_start_rewind(ptr);
            Module.asm.appInit();
            Module.asm.asyncify_stop_unwind();

          }, 30);

        } else {
          Module.asm.asyncify_stop_rewind();

        var memory = Module["memory"]//HEAPU8;
  switch (startup++)
  {
    case 1: memory[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3d] = 1; break; 
    case 2: memory[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3d] = 0; break; 
    case 3: memory[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3f] = 1; break; 
    case 4: memory[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3f] = 0; break; 
  }
  var ptr = Module.asm.appVideo();
  if (ptr)
  {
    const data = new Uint8ClampedArray(Module.asm.memory.buffer, ptr, 320 * 200 * 4);
    const img = new ImageData(data, 320, 200);
    this.ctx.putImageData(img, 0, 0);
  }

          rewinding = false;
          return 0;
        }
    },
    fd_close: () => {
     console.log("close");
      throw "close"
    },
    fd_write: () => {
     console.log("write");

      throw "write"
    },
    fd_seek: () => {
     console.log("seek");

      throw "seek"
    },
    __assert_fail: () => {
     console.log("assert");

       throw "assert";
    }
//    emscripten_fiber_swap: () => {}
//    emscripten_fiber_init_from_current_context: _emscripten_fiber_init_from_current_context,
//    emscripten_fiber_init: _emscripten_fiber_init,
  }
  Module['exports'] = {
    appFinish: null,
    appInit: null,
    appLoop: null,
    appVideo: null
  };
Module['run'] = Main;

var memoryOfs = -1;
Main().then( (m)=>
{
  memoryOfs = HEAP32[Module.asm.appMemory.value>>2];
  console.log("pre main call");
  Module.appInit();
  Module.asm.asyncify_stop_unwind();

  console.log("post main call");
});
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var imageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);


/*
setTimeout(ready, 100);
var phase = 0;
var memoryOfs = 0;

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var imageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);


var counter = 0;
function __onSleep()
{
  switch (counter++)
  {
    case 1: HEAP8[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3d] = 1; break; 
    case 2: HEAP8[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3d] = 0; break; 
    case 3: HEAP8[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3f] = 1; break; 
    case 4: HEAP8[memoryOfs+0x1228 * 16 + 0x4d44 + 0x3f] = 0; break; 
  }

  var ptr = _appVideo();
  if (!ptr)
    return;

    const data = new Uint8ClampedArray(Module.asm.memory.buffer, ptr, 320 * 200 * 4);
    const img = new ImageData(data, 320, 200);
    this.ctx.putImageData(img, 0, 0);

//  console.log("video", ptr);
}
setInterval(()=>{
//  var ptr = _appVideo();
//  console.log("video", ptr);
}, 1000);

var bumpyStartupLevel = window.location.hash ? parseInt(window.location.hash.substr(1)) : 1;

function ready() {
  HEAP8[Module.asm.bumpyStartupLevel.value] = bumpyStartupLevel;
  _appInit();
  memoryOfs = _appMemory();
//  _appLoop();
// switch(phase++)
}
*/
    document.onkeydown = function(evt) {
        evt = evt || window.event;
        var memory = Module["memory"]//HEAPU8;
        var mo = memoryOfs // Module.asm.memory;
//        console.log(mo);
        switch (evt.keyCode)
        {
          case 0x33: memory[mo+0x1228 * 16 + 0x4d44 + 0x3d] = 1; break; 
          case 0x35: memory[mo+0x1228 * 16 + 0x4d44 + 0x3f] = 1; break; 
          case 38: memory[mo+0x1228 * 16 + 0x4d44 + "H".charCodeAt(0)] = 1; break; // right
          case 39: memory[mo+0x1228 * 16 + 0x4d44 + "M".charCodeAt(0)] = 1; break; // right
          case 40: memory[mo+0x1228 * 16 + 0x4d44 + "P".charCodeAt(0)] = 1; break; // down
          case 37: memory[mo+0x1228 * 16 + 0x4d44 + "K".charCodeAt(0)] = 1; break; // left
          case 32: memory[mo+0x1228 * 16 + 0x4d44 + 0x1c] = 1; break; // space -> enter
          case 27: memory[mo+0x1228 * 16 + 0x4d44 + 1] = 1; break; // esc
        }
    }
    document.onkeyup = function(evt) {
        evt = evt || window.event;
        var memory = Module["memory"]//HEAPU8;
        var mo = memoryOfs // Module.asm.memory;
//        console.log(mo);
        switch (evt.keyCode)
        {
          case 0x33: memory[mo+0x1228 * 16 + 0x4d44 + 0x3d] = 0; break; 
          case 0x35: memory[mo+0x1228 * 16 + 0x4d44 + 0x3f] = 0; break; 
          case 38: memory[mo+0x1228 * 16 + 0x4d44 + "H".charCodeAt(0)] = 0; break; // up
          case 39: memory[mo+0x1228 * 16 + 0x4d44 + "M".charCodeAt(0)] = 0; break; // right
          case 40: memory[mo+0x1228 * 16 + 0x4d44 + "P".charCodeAt(0)] = 0; break; // down
          case 37: memory[mo+0x1228 * 16 + 0x4d44 + "K".charCodeAt(0)] = 0; break; // left
          case 32: memory[mo+0x1228 * 16 + 0x4d44 + 0x1c] = 0; break; // space -> enter
          case 27: memory[mo+0x1228 * 16 + 0x4d44 + 1] = 0; break; // esc
        }
    }


</script>