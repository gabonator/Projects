<canvas id="canvas" width="640" height="400" style="border: 1px solid #d0d0d0;"></canvas>

<script src="app_inline.js"></script>
<script src="resources.js"></script>
<script>

var Module = typeof Module !== 'undefined' ? Module : {};
var HEAPU8;
var HEAPU32;
var refreshInterval = 300;

function Main() 
{
  var WASM_PAGE_SIZE = 65536;
  var TOTAL_MEMORY = 65536;
  var DYNAMICTOP_PTR = 11856;

  var abort = (what) => { throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.'};
  var env = {
    "abort": () => abort(1), 
    "_abort": () => abort(2),
    "__assert_fail": (condition, filename, line, func) =>
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']),
    "__setErrNo": () => abort(3), 
    "emscripten_get_heap_size": () => abort(4),
    "emscripten_memcpy_big": (dest, src, num) =>
      HEAPU8.copyWithin(dest, src, src + num), 
    "emscripten_memcpy_js": (dest, src, num) =>
      HEAPU8.copyWithin(dest, src, src + num),
    "emscripten_resize_heap": () => abort(6),
    "abortOnCannotGrowMemory": () => abort(7), 
    "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
    memory: new WebAssembly.Memory({ 'initial': TOTAL_MEMORY / WASM_PAGE_SIZE, 'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE }),
    table: new WebAssembly.Table({'initial': 84,'maximum': 84,'element': 'anyfunc'}),
    '__memory_base': 1024, 
    '__table_base': 0
  };

  var imports = Module["imports"];
  for (var i in imports)
    env[i] = imports[i];

  return WebAssembly.instantiate(new Uint8Array(Module['wasmBinary']), {env:env,wasi_snapshot_preview1: env})
  .then( output => 
   {
    HEAPU8 = new Uint8Array(output.instance.exports.memory.buffer);
    HEAP32 = new Int32Array(output.instance.exports.memory.buffer);
    var exports = output.instance.exports;
    Module['asm'] = exports;
    if (Module["asm"]["__wasm_call_ctors"]) Module["asm"]["__wasm_call_ctors"]();
    var _exports = Module['exports'];
    for (var i in _exports)
      Module[i] = _exports[i] = Module["asm"][i];
    Module["memory"] = new Uint8Array(exports.memory.buffer);
    return output;
  });
};

var rewinding = false;
var videoBuffer;
var memoryBuffer;

Module['imports'] = {
  apiPrint: (ptr) => { 
    var msg = Module['imports'].string(ptr);
    console.log(msg);
  },
  string: (ptr) => {
    var text = "";
    for (var i=0; i<50 && Module['memory'][ptr+i] != 0; i++)
      text += String.fromCharCode(Module['memory'][ptr+i]);
    return text;
  },
  apiRead: (ptrName, readOfs, readLen, ptrData) =>
  {
    var name = Module['imports'].string(ptrName);
    console.log("Read ", name, readOfs, readLen);
    var b = Module[name];
    var willRead = Math.min(b.length-readOfs, readLen);
    var memory = Module['memory'];
    for (var i=0; i<readLen; i++)
      memory[i+ptrData] = b[i+readOfs];
    return willRead;
  },
  // https://gov.near.org/t/discussion-synchronous-contracts/11869/8
  emscripten_sleep: () => {
      if (!rewinding)
      {
        var ptr = Module.asm.asyncifyBuffer.value;
        HEAP32[((ptr)>>2)] = ptr+12;
        HEAP32[(((ptr)+(4))>>2)] = ptr+12 + 1024;
        HEAP32[(((ptr)+(8))>>2)] = 0;
        Module.asm.asyncify_start_unwind(ptr);
      } else {
        Module.asm.asyncify_stop_rewind();
        sync();
        rewinding = false;
        return 0;
      }
  },
  fd_close: () => {
    console.log("close");
    throw "close"
  },
  fd_write: (handle, x, y, ptr) => {
   console.log("write");

    var msg = Module['imports'].string(ptr);
    console.log(msg);

    throw "write"
  },
  fd_seek: () => {
   console.log("seek");

    throw "seek"
  },
  __assert_fail: () => {
   console.log("assert");
     throw "assert";
  }
}
Module['exports'] = {
  appFinish: null,
  appInit: null,
  appLoop: null,
  appVideo: null
};
Module['run'] = Main;

Main().then( (m)=>
{
  videoBuffer = new Uint8ClampedArray(Module.asm.memory.buffer, HEAP32[Module.asm.appVideo.value>>2], 640 * 400 * 4);
  memoryBuffer = new Uint8ClampedArray(Module.asm.memory.buffer, HEAP32[Module.asm.appMemory.value>>2], 0x10000*14);
  keyBuffer = new Uint32Array(Module.asm.memory.buffer, HEAP32[Module.asm.lastKey.value>>2], 4);
  Module.appLoop();
  Module.asm.asyncify_stop_unwind();
  // wait until map is generated
  resume();
  resume();
  resume();
  resume();
  // F1 to start a game
  keyBuffer[0] = 0x3b00;
  setInterval(()=>{
    resume();
  }, 20);
});

function resume()
{
  var ptr = Module.asm.asyncifyBuffer.value;
  rewinding = true;

  Module.asm.asyncify_start_rewind(ptr);
  Module.asm.appLoop();
  Module.asm.asyncify_stop_unwind();
}

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var imageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);

function onKey(code, pressed)
{
  switch (code)
  {
    case 38: memoryBuffer[0x0ac3 * 16 + 0x14f0 + "H".charCodeAt(0)] = pressed; break; // up
    case 39: memoryBuffer[0x0ac3 * 16 + 0x14f0 + "M".charCodeAt(0)] = pressed; break; // right
    case 40: memoryBuffer[0x0ac3 * 16 + 0x14f0 + "P".charCodeAt(0)] = pressed; break; // down
    case 37: memoryBuffer[0x0ac3 * 16 + 0x14f0 + "K".charCodeAt(0)] = pressed; break; // left
    case 32: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 0x1c] = pressed; break; // space -> enter
    case 27: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 1] = pressed; break; // esc
    case 87: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 0x11] = pressed; break; //up ok
    case 83: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 0x2d] = pressed; break; //down
    case 65: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 0x1e] = pressed; break; //left wrong right
    case 68: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 0x20] = pressed; break; // right
    case 16: memoryBuffer[0x0ac3 * 16 + 0x14f0 + 0x1d] = pressed; break; // 2a 0f 10
  }
}

document.onkeydown = evt => onKey(evt.keyCode || window.event.keyCode, 1);
document.onkeyup = evt => onKey(evt.keyCode || window.event.keyCode, 0);

function sync()
{
  var memory = Module["memory"];
  var ptr = Module.asm.appBlit();
  var now = new Date().getTime();
  if (ptr)
  {
    const img = new ImageData(videoBuffer, 640, 400);
    this.ctx.putImageData(img, 0, 0);
  }
}
</script>
