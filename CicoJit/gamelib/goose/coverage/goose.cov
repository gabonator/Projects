cicoData = (() => { var code="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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAABgZGRoaGhsbHBwcHR0dHh4fHx8gICEhISIiIiMjJCQkJSUmJiYnJycoKCkpKSoqKisrLCwsLS0uLi4vLy8wMDExNjk+QURIS1BTVlhbMTY5PkFDSUtQU1ZaXv/8/Pzz8PDw8/Dw8PPw8PDPzMzMw8DAwMPAwMDDwMDAz8zMzMPAwMDDwMDAw8DAwM/MzMzDwMDAw8DAwMPAwMA/PDw8MzAwMDMwMDAzMDAwDwwMDAMAAAADAAAAAwAAAA8MDAwDAAAAAwAAAAMAAAAPDAwMAwAAAAMAAAADAAAAPzw8PDMwMDAzMDAwMzAwMA8MDAwDAAAAAwAAAAMAAAAPDAwMAwAAAAMAAAADAAAADwwMDAMAAAADAAAAAwAAAD88PDwzMDAwMzAwMDMwMDAPDAwMAwAAAAMAAAADAAAADwwMDAMAAAADAAAAAwAAAA8MDAwDAAAAAwAAAAMAAAAAAwAADA8MDAADAAAAAwAAMDMwMDw/PDwwMzAwMDMwMAADAAAMDwwMAAMAAAADAAAAAwAADA8MDAADAAAAAwAAwMPAwMzPzMzAw8DAwMPAwPDz8PD8//z88PPw8PDz8PDAw8DAzM/MzMDDwMDAw8DAwMPAwMzPzMzAw8DAwMPAwAADAAAMDwwMAAMAAAADAAAwMzAwPD88PDAzMDAwMzAwAAMAAAwPDAwAAwAAAAMAAAADAAAMDwwMAAMAAAADAAAAAwAADA8MDAADAAAAAwAAMDMwMDw/PDwwMzAwMDMwMAADAAAMDwwMAAMAAAADAAAAAwAADA8MDAADAAAAAwAAAAADAAAAAwAMDA8MAAADAAAAAwAAAAMADAwPDAAAAwAwMDMwMDAzMDw8PzwwMDMwAAADAAAAAwAMDA8MAAADAAAAAwAAAAMADAwPDAAAAwAAAAMAAAADAAwMDwwAAAMAMDAzMDAwMzA8PD88MDAzMAAAAwAAAAMADAwPDAAAAwDAwMPAwMDDwMzMz8zAwMPAwMDDwMDAw8DMzM/MwMDDwPDw8/Dw8PPw/Pz//PDw8/DAwMPAwMDDwMzMz8zAwMPAAAADAAAAAwAMDA8MAAADAAAAAwAAAAMADAwPDAAAAwAwMDMwMDAzMDw8PzwwMDMwAAADAAAAAwAMDA8MAAADAAAAAAMAAAADAAAAAwwMDA8AAAADAAAAAwAAAAMMDAwPAAAAAwAAAAMAAAADDAwMDzAwMDMwMDAzMDAwMzw8PD8AAAADAAAAAwAAAAMMDAwPAAAAAwAAAAMAAAADDAwMDwAAAAMAAAADAAAAAwwMDA8wMDAzMDAwMzAwMDM8PDw/AAAAAwAAAAMAAAADDAwMDwAAAAMAAAADAAAAAwwMDA8AAAADAAAAAwAAAAMMDAwPMDAwMzAwMDMwMDAzPDw8P8DAwMPAwMDDwMDAw8zMzM/AwMDDwMDAw8DAwMPMzMzPwMDAw8DAwMPAwMDDzMzMz/Dw8PPw8PDz8PDw8/z8/P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxVMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxVMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="; return Uint8Array.from(atob(code), c => c.charCodeAt(0));})();
cicoArgs = `-asm -coverage -reloc -tree /Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos/GOOSE.EXE -simplestack -ctx -recursive start,sub_133d7+sync -jumptable 1000:104e 1000:105a 35 callwords bx `
cicoText = `
#include "cicoctx.h"
using namespace CicoContext;

void sub_10010();
void fixReloc(uint16_t seg);

// info: executable /Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos/GOOSE.EXE
// info: arguments -asm -coverage -reloc -tree /Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos/GOOSE.EXE -simplestack -ctx -recursive start,sub_133d7+sync -jumptable 1000:104e 1000:105a 35 callwords bx
// info: entry sub_10010
// info: linearToFile 0xfe00
void start()
{
    // coverage: 0x0-0x1c header
    headerSize = 0x0200;
    loadAddress = 0x1000;
    endAddress = 0x1d20;
    cs = 0x1000;
    ds = 0x0ff0;
    es = 0x0ff0;
    ss = 0x1cfc;
    sp = 0x0100;
    load("/Users/gabrielvalky/Documents/git/Projects/CicoJit/gamelib/goose/dos", "GOOSE.EXE", 53684);
    fixReloc(cs);
    sub_10010();
}
void fixReloc(uint16_t seg)
{
    // coverage: 0x1e-0x2e reloc
    memory16(0x0000 + seg, 0x0011) += seg; // 03a5 -> 13a5
    memory16(0x0000 + seg, 0x04d1) += seg; // 03a5 -> 13a5
    memory16(0x0000 + seg, 0x05d8) += seg; // 03a5 -> 13a5
    memory16(0x0000 + seg, 0x0b59) += seg; // 03a5 -> 13a5
}
void sub_10010();
void sub_100a9();
void sub_100cf();
void sub_100fd();
void sub_10103();
void sub_1019d();
void sub_101ad();
void sub_101c0();
void sub_1033b();
void sub_10442();
void sub_104a5();
void sub_104f3();
void sub_10529();
void sub_10541();
void sub_10588();
void sub_10591();
void sub_105bc();
void sub_105ec();
void sub_10600();
void sub_10637();
void sub_10644();
void sub_1064d();
void sub_10674();
void sub_1069a();
void sub_107af();
void sub_107fd();
void sub_108ba();
void sub_1094a();
void sub_109a4();
void sub_109b5();
void sub_109e9();
void sub_10a1b();
void sub_10a51();
void sub_10ad5();
void sub_10b58();
void sub_10b7c();
void sub_10b8e();
void sub_10bc5();
void sub_10bdc();
void sub_10c24();
void sub_10d98();
void sub_10da7();
void sub_10dc0();
void sub_10e07();
void sub_10e3d();
void sub_10e84();
void sub_10f3c();
void sub_10f9d();
void sub_10fda();
void sub_110a0();
void sub_110c6();
void sub_110f3();
void sub_11108();
void sub_112a7();
void sub_112cb();
void sub_112eb();
void sub_11384();
void sub_113a8();
void sub_11429();
void sub_114f0();
void sub_115fc();
void sub_116d6();
void sub_116df();
void sub_116fe();
void sub_1171f();
void sub_11740();
void sub_1176c();
void sub_11783();
void sub_117ac();
void sub_117d6();
void sub_117f4();
void sub_118a9();
void sub_118c7();
void sub_1196f();
void sub_11993();
void sub_119c2();
void sub_11a04();
void sub_11a9e();
void sub_11b09();
void sub_11b4a();
void sub_11b57();
void sub_11b80();
void sub_11bb9();
void sub_11c0a();
void sub_11c33();
void sub_11c56();
void sub_11c78();
void sub_11cd9();
void sub_11d1e();
void sub_11def();
void sub_11e7d();
void sub_11f0b();
void sub_11fba();
void sub_12005();
void sub_12047();
void sub_12092();
void sub_12099();
void sub_120a0();
void sub_120db();
void sub_120f0();
void sub_12121();
void sub_1215b();
void sub_121dc();
void sub_12200();
void sub_1220d();
void sub_122b1();
void sub_122c1();
void sub_122e1();
void sub_122f9();
void sub_12311();
void sub_12329();
void sub_1237c();
void sub_1239b();
void sub_123d4();
void sub_123ec();
void sub_12404();
void sub_1241c();
void sub_12434();
void sub_1244c();
void sub_12464();
void sub_1250b();
void sub_1252f();
void sub_12536();
void sub_12542();
void sub_12553();
void sub_12577();
void sub_1257e();
void sub_1258a();
void sub_1259b();
void sub_125bf();
void sub_125c6();
void sub_125d2();
void sub_125e3();
void sub_1264a();
void sub_12662();
void sub_12676();
void sub_1268a();
void sub_1269e();
void sub_12714();
void sub_12762();
void sub_1279f();
void sub_12809();
void sub_12872();
void sub_128da();
void sub_12907();
void sub_12959();
void sub_1296f();
void sub_129ae();
void sub_129db();
void sub_12a64();
void sub_12a7f();
void sub_12b28();
void sub_12c07();
void sub_12c45();
void sub_12c9a();
void sub_12cc7();
void sub_12cea();
void sub_12d9a();
void sub_12ddc();
void sub_12df6();
void sub_12e02();
void sub_12f50();
void sub_12fe8();
void sub_1300a();
void sub_13059();
void sub_13084();
void sub_1309d();
void sub_13130();
void sub_1315e();
void sub_13170();
void sub_13181();
void sub_13191();
void sub_131a4();
void sub_131e7();
void sub_13209();
void sub_13291();
void sub_132fe();
void sub_1333c();
void sub_13383();
void sub_133b3();
void sub_133d7();
void sub_133e5();
void sub_13423();
void sub_13439();
void sub_13472();
void sub_13498();
void sub_134a8();
void sub_135bc();
void sub_136d4();
void sub_13801();
void sub_1382a();
void sub_13840();
void sub_13914();
void sub_139a3();
void sub_139b8();
/* Assembly listing of 1000:0010 sub_10010()
                            sub_10010 PROC
1000:0010  b8 a5 13         mov ax, 0x13a5
1000:0013  8e d8            mov ds, ax
1000:0015  bb 70 96         mov bx, 0x9670
1000:0018  83 c3 0f         add bx, 0xf
1000:001b  d1 eb            shr bx, 1
1000:001d  d1 eb            shr bx, 1
1000:001f  d1 eb            shr bx, 1
1000:0021  d1 eb            shr bx, 1
1000:0023  03 c3            add ax, bx
1000:0025  a3 e8 94         mov word ptr [0x94e8], ax
1000:0028  05 00 08         add ax, 0x800
1000:002b  a3 ea 94         mov word ptr [0x94ea], ax
1000:002e  05 00 08         add ax, 0x800
1000:0031  a3 ec 94         mov word ptr [0x94ec], ax
1000:0034  05 00 08         add ax, 0x800
1000:0037  a3 ee 94         mov word ptr [0x94ee], ax
1000:003a  05 00 08         add ax, 0x800
1000:003d  a3 f0 94         mov word ptr [0x94f0], ax
1000:0040  05 00 08         add ax, 0x800
1000:0043  a3 f2 94         mov word ptr [0x94f2], ax
1000:0046  05 00 08         add ax, 0x800
1000:0049  a3 f4 94         mov word ptr [0x94f4], ax
1000:004c  05 00 08         add ax, 0x800
1000:004f  a3 f6 94         mov word ptr [0x94f6], ax
1000:0052  cd 12            int 0x12
1000:0054  3d 00 02         cmp ax, 0x200
1000:0057  73 0e            jae loc_10067
1000:0059  ba 07 00         mov dx, 7
1000:005c  b4 09            mov ah, 9
1000:005e  cd 21            int 0x21
1000:0060  b8 00 4c         mov ax, 0x4c00
1000:0063  cd 21            int 0x21
1000:0065  eb 07            jmp loc_1006e
                            loc_10067:
1000:0067  ba 2a 00         mov dx, 0x2a
1000:006a  b4 09            mov ah, 9
1000:006c  cd 21            int 0x21
                            loc_1006e:
1000:006e  e8 8f 05         call 0x600
1000:0071  e8 c8 32         call 0x333c
1000:0074  e8 eb 26         call 0x2762
1000:0077  e8 72 05         call 0x5ec
1000:007a  e8 c5 03         call 0x442
1000:007d  e8 08 05         call 0x588
1000:0080  e8 0e 05         call 0x591
1000:0083  e8 a4 37         call 0x382a
1000:0086  c6 06 01 95 00   mov byte ptr [0x9501], 0
                            loc_1008b:
1000:008b  e8 1b 00         call 0xa9
1000:008e  e8 3e 00         call 0xcf
1000:0091  e8 69 00         call 0xfd
1000:0094  eb f5            jmp loc_1008b
                            sub_10010 ENDP
*/
void sub_10010()
{
    // coverage: 0x210-0x296 method sub_10010
    // coverage2: 1000:0010-1000:0096 method sub_10010 // ins(0x0010, 0x0096, 0x0010);
    // no return
    ax = 0x13a5;
    ds = ax;
    bx = 0x9670;
    bx += 0x000f;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    ax += bx;
    memoryASet16(ds, 0x94e8, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94ea, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94ec, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94ee, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f0, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f2, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f4, ax);
    ax += 0x0800;
    memoryASet16(ds, 0x94f6, ax);
    interrupt(0x12);
    if (ax >= 0x0200)
        goto loc_10067;
    dx = 0x0007;
    ah = 0x09;
    interrupt(0x21);
    ax = 0x4c00;
    interrupt(0x21);
    goto loc_1006e;
loc_10067:
    dx = 0x002a;
    ah = 0x09;
    interrupt(0x21);
loc_1006e:
    sub_10600();
    sub_1333c();
    sub_12762();
    sub_105ec();
    sub_10442();
    sub_10588();
    sub_10591();
    sub_1382a();
    memoryASet(ds, 0x9501, 0x00);
loc_1008b:
    sub_100a9();
    sub_100cf();
    sub_100fd();
    goto loc_1008b;
}
/* Assembly listing of 1000:00a9 sub_100a9()
                            sub_100a9 PROC
1000:00a9  e8 57 00         call 0x103
1000:00ac  c6 06 00 95 00   mov byte ptr [0x9500], 0
1000:00b1  c6 06 fe 94 01   mov byte ptr [0x94fe], 1
1000:00b6  c6 06 fc 94 10   mov byte ptr [0x94fc], 0x10
1000:00bb  c6 06 ff 94 00   mov byte ptr [0x94ff], 0
1000:00c0  c6 06 02 95 00   mov byte ptr [0x9502], 0
1000:00c5  e8 df 0c         call 0xda7
1000:00c8  e8 58 33         call 0x3423
1000:00cb  e8 0e 21         call 0x21dc
1000:00ce  c3               ret 
                            sub_100a9 ENDP
*/
void sub_100a9()
{
    // coverage: 0x2a9-0x2cf method sub_100a9
    // coverage2: 1000:00a9-1000:00cf method sub_100a9 // ins(0x00a9, 0x00cf, 0x00a9);
    sub_10103();
    memoryASet(ds, 0x9500, 0x00);
    memoryASet(ds, 0x94fe, 0x01);
    memoryASet(ds, 0x94fc, 0x10);
    memoryASet(ds, 0x94ff, 0x00);
    memoryASet(ds, 0x9502, 0x00);
    sub_10da7();
    sub_13423();
    sub_121dc();
}
/* Assembly listing of 1000:00cf sub_100cf()
                            sub_100cf PROC
                            loc_100cf:
1000:00cf  e8 ee 00         call 0x1c0
1000:00d2  e8 05 0f         call 0xfda
1000:00d5  a0 ff 94         mov al, byte ptr [0x94ff]
1000:00d8  3c 00            cmp al, 0
1000:00da  75 08            jne loc_100e4
1000:00dc  e8 1f 32         call 0x32fe
1000:00df  e8 ac 0a         call 0xb8e
1000:00e2  eb 09            jmp loc_100ed
                            loc_100e4:
1000:00e4  e8 c1 33         call 0x34a8
1000:00e7  e8 ba 30         call 0x31a4
1000:00ea  e8 a1 0a         call 0xb8e
                            loc_100ed:
1000:00ed  e8 1d 21         call 0x220d
1000:00f0  e8 90 32         call 0x3383
1000:00f3  a0 00 95         mov al, byte ptr [0x9500]
1000:00f6  3c 00            cmp al, 0
1000:00f8  75 02            jne loc_100fc
1000:00fa  eb d3            jmp loc_100cf
                            loc_100fc:
1000:00fc  c3               ret 
                            sub_100cf ENDP
*/
void sub_100cf()
{
    // coverage: 0x2cf-0x2fd method sub_100cf
    // coverage2: 1000:00cf-1000:00fd method sub_100cf // ins(0x00cf, 0x00fd, 0x00cf);
loc_100cf:
    sub_101c0();
    sub_10fda();
    al = memoryAGet(ds, 0x94ff);
    if (al != 0x00)
        goto loc_100e4;
    sub_132fe();
    sub_10b8e();
    goto loc_100ed;
loc_100e4:
    sub_134a8();
    sub_131a4();
    sub_10b8e();
loc_100ed:
    sub_1220d();
    sub_13383();
    al = memoryAGet(ds, 0x9500);
    if (al != 0x00)
        return;
    goto loc_100cf;
}
/* Assembly listing of 1000:00fd sub_100fd()
                            sub_100fd PROC
1000:00fd  c6 06 06 00 01   mov byte ptr [6], 1
1000:0102  c3               ret 
                            sub_100fd ENDP
*/
void sub_100fd()
{
    // coverage: 0x2fd-0x303 method sub_100fd
    // coverage2: 1000:00fd-1000:0103 method sub_100fd // ins(0x00fd, 0x0103, 0x00fd);
    memoryASet(ds, 0x0006, 0x01);
}
/* Assembly listing of 1000:0103 sub_10103()
                            sub_10103 PROC
1000:0103  a0 06 00         mov al, byte ptr [6]
1000:0106  3c 00            cmp al, 0
1000:0108  74 0b            je loc_10115
1000:010a  c7 06 7e 8e da 00  mov word ptr [0x8e7e], 0xda
1000:0110  e8 8c 26         call 0x279f
1000:0113  eb 09            jmp loc_1011e
                            loc_10115:
1000:0115  c7 06 7e 8e e9 00  mov word ptr [0x8e7e], 0xe9
1000:011b  e8 bc 27         call 0x28da
                            loc_1011e:
1000:011e  e8 97 38         call 0x39b8
1000:0121  e8 4e 33         call 0x3472
1000:0124  c6 06 03 95 01   mov byte ptr [0x9503], 1
1000:0129  c7 06 80 8e 00 00  mov word ptr [0x8e80], 0
1000:012f  e8 66 0c         call 0xd98
                            loc_10132:
1000:0132  e8 8b 00         call 0x1c0
1000:0135  e8 a2 0e         call 0xfda
1000:0138  e8 5d 33         call 0x3498
1000:013b  e8 50 0a         call 0xb8e
1000:013e  e8 42 32         call 0x3383
1000:0141  a1 4c 95         mov ax, word ptr [0x954c]
1000:0144  a9 80 00         test ax, 0x80
1000:0147  75 4e            jne loc_10197
1000:0149  ff 06 80 8e      inc word ptr [0x8e80]
1000:014d  8b 1e 80 8e      mov bx, word ptr [0x8e80]
1000:0151  f7 c3 07 00      test bx, 7
1000:0155  75 3e            jne loc_10195
1000:0157  d1 eb            shr bx, 1
1000:0159  d1 eb            shr bx, 1
1000:015b  d1 eb            shr bx, 1
1000:015d  03 1e 7e 8e      add bx, word ptr [0x8e7e]
1000:0161  8a 07            mov al, byte ptr [bx]
1000:0163  3c 00            cmp al, 0
1000:0165  74 2e            je loc_10195
1000:0167  3c ff            cmp al, 0xff
1000:0169  74 2c            je loc_10197
1000:016b  3c fe            cmp al, 0xfe
1000:016d  75 11            jne loc_10180
1000:016f  a0 46 95         mov al, byte ptr [0x9546]
1000:0172  3c 00            cmp al, 0
1000:0174  74 05            je loc_1017b
1000:0176  e8 62 28         call 0x29db
1000:0179  eb 03            jmp loc_1017e
                            loc_1017b:
1000:017b  e8 2f 00         call 0x1ad
                            loc_1017e:
1000:017e  eb 15            jmp loc_10195
                            loc_10180:
1000:0180  a8 80            test al, 0x80
1000:0182  75 05            jne loc_10189
1000:0184  e8 16 00         call 0x19d
1000:0187  eb 0c            jmp loc_10195
                            loc_10189:
1000:0189  24 3f            and al, 0x3f
1000:018b  50               push ax
1000:018c  e8 0e 00         call 0x19d
1000:018f  58               pop ax
1000:0190  fe c0            inc al
1000:0192  e8 08 00         call 0x19d
                            loc_10195:
1000:0195  eb 9b            jmp loc_10132
                            loc_10197:
1000:0197  c6 06 03 95 00   mov byte ptr [0x9503], 0
1000:019c  c3               ret 
                            sub_10103 ENDP
*/
void sub_10103()
{
    // coverage: 0x303-0x39d method sub_10103
    // coverage2: 1000:0103-1000:019d method sub_10103 // ins(0x0103, 0x019d, 0x0103);
    al = memoryAGet(ds, 0x0006);
    if (al == 0x00)
        goto loc_10115;
    memoryASet16(ds, 0x8e7e, 0x00da);
    sub_1279f();
    goto loc_1011e;
loc_10115:
    memoryASet16(ds, 0x8e7e, 0x00e9);
    sub_128da();
loc_1011e:
    sub_139b8();
    sub_13472();
    memoryASet(ds, 0x9503, 0x01);
    memoryASet16(ds, 0x8e80, 0x0000);
    sub_10d98();
loc_10132:
    sub_101c0();
    sub_10fda();
    sub_13498();
    sub_10b8e();
    sub_13383();
    ax = memoryAGet16(ds, 0x954c);
    if (ax & 0x0080)
        goto loc_10197;
    memoryASet16(ds, 0x8e80, memoryAGet16(ds, 0x8e80) + 1);
    bx = memoryAGet16(ds, 0x8e80);
    if (bx & 0x0007)
        goto loc_10195;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx += memoryAGet16(ds, 0x8e7e);
    al = memoryAGet(ds, bx);
    if (al == 0x00)
        goto loc_10195;
    if (al == 0xff)
        goto loc_10197;
    if (al != 0xfe)
        goto loc_10180;
    al = memoryAGet(ds, 0x9546);
    if (al == 0x00)
        goto loc_1017b;
    sub_129db();
    goto loc_1017e;
loc_1017b:
    sub_101ad();
loc_1017e:
    goto loc_10195;
loc_10180:
    if (al & 0x80)
        goto loc_10189;
    sub_1019d();
    goto loc_10195;
loc_10189:
    al &= 0x3f;
    push(ax);
    sub_1019d();
    ax = pop();
    al++;
    sub_1019d();
loc_10195:
    goto loc_10132;
loc_10197:
    memoryASet(ds, 0x9503, 0x00);
}
/* Assembly listing of 1000:019d sub_1019d()
                            sub_1019d PROC
1000:019d  be 09 01         mov si, 0x109
1000:01a0  88 44 04         mov byte ptr [si + 4], al
1000:01a3  bb 20 01         mov bx, 0x120
1000:01a6  e8 78 1f         call 0x2121
1000:01a9  e8 ac 09         call 0xb58
1000:01ac  c3               ret 
                            sub_1019d ENDP
*/
void sub_1019d()
{
    // coverage: 0x39d-0x3ad method sub_1019d
    // coverage2: 1000:019d-1000:01ad method sub_1019d // ins(0x019d, 0x01ad, 0x019d);
    si = 0x0109;
    memoryASet(ds, si + 4, al);
    bx = 0x0120;
    sub_12121();
    sub_10b58();
}
/* Assembly listing of 1000:01ad sub_101ad()
                            sub_101ad PROC
1000:01ad  b9 40 1f         mov cx, 0x1f40
                            loc_101b0:
1000:01b0  51               push cx
1000:01b1  e8 0c 00         call 0x1c0
1000:01b4  59               pop cx
1000:01b5  a1 4c 95         mov ax, word ptr [0x954c]
1000:01b8  a8 80            test al, 0x80
1000:01ba  74 01            je loc_101bd
1000:01bc  c3               ret 
                            loc_101bd:
1000:01bd  e2 f1            loop loc_101b0
1000:01bf  c3               ret 
                            sub_101ad ENDP
*/
void sub_101ad()
{
    // coverage: 0x3ad-0x3c0 method sub_101ad
    // coverage2: 1000:01ad-1000:01c0 method sub_101ad // ins(0x01ad, 0x01c0, 0x01ad);
    cx = 0x1f40;
loc_101b0:
    push(cx);
    sub_101c0();
    cx = pop();
    ax = memoryAGet16(ds, 0x954c);
    if (!(al & 0x80))
        goto loc_101bd;
    return;
loc_101bd:
    if (--cx)
        goto loc_101b0;
}
/* Assembly listing of 1000:01c0 sub_101c0()
                            sub_101c0 PROC
1000:01c0                    
                            loc_10096:
1000:0096  e8 0a 39         call 0x39a3
1000:0099  e8 20 05         call 0x5bc
1000:009c  e8 06 04         call 0x4a5
1000:009f  b8 03 00         mov ax, 3
1000:00a2  cd 10            int 0x10
1000:00a4  b8 00 4c         mov ax, 0x4c00
1000:00a7  cd 21            int 0x21
1000:00a9  e8 57 00         call 0x103
1000:00ac  c6 06 00 95 00   mov byte ptr [0x9500], 0
1000:00b1  c6 06 fe 94 01   mov byte ptr [0x94fe], 1
1000:00b6  c6 06 fc 94 10   mov byte ptr [0x94fc], 0x10
1000:00bb  c6 06 ff 94 00   mov byte ptr [0x94ff], 0
1000:00c0  c6 06 02 95 00   mov byte ptr [0x9502], 0
1000:00c5  e8 df 0c         call 0xda7
1000:00c8  e8 58 33         call 0x3423
1000:00cb  e8 0e 21         call 0x21dc
1000:00ce  c3               ret 
1000:00cf                    
                            loc_101c0:
1000:01c0  bb 8a 8e         mov bx, 0x8e8a
1000:01c3  be 3d 00         mov si, 0x3d
1000:01c6  8a 00            mov al, byte ptr [bx + si]
1000:01c8  3c 00            cmp al, 0
1000:01ca  74 09            je loc_101d5
1000:01cc  be 3e 00         mov si, 0x3e
                            loc_101cf:
1000:01cf  8a 00            mov al, byte ptr [bx + si]
1000:01d1  3c 00            cmp al, 0
1000:01d3  74 fa            je loc_101cf
                            loc_101d5:
1000:01d5  be 3b 00         mov si, 0x3b
1000:01d8  8a 00            mov al, byte ptr [bx + si]
1000:01da  3c 00            cmp al, 0
1000:01dc  74 03            je loc_101e1
1000:01de  e8 5a 01         call 0x33b
                            loc_101e1:
1000:01e1  bb 8a 8e         mov bx, 0x8e8a
1000:01e4  8b 36 0d 8f      mov si, word ptr [0x8f0d]
1000:01e8  8a 00            mov al, byte ptr [bx + si]
1000:01ea  3c 00            cmp al, 0
1000:01ec  74 08            je loc_101f6
1000:01ee  c7 06 4c 95 01 00  mov word ptr [0x954c], 1
1000:01f4  eb 18            jmp loc_1020e
                            loc_101f6:
1000:01f6  8b 36 0f 8f      mov si, word ptr [0x8f0f]
1000:01fa  8a 00            mov al, byte ptr [bx + si]
1000:01fc  3c 00            cmp al, 0
1000:01fe  74 08            je loc_10208
1000:0200  c7 06 4c 95 02 00  mov word ptr [0x954c], 2
1000:0206  eb 06            jmp loc_1020e
                            loc_10208:
1000:0208  c7 06 4c 95 00 00  mov word ptr [0x954c], 0
                            loc_1020e:
1000:020e  8b 36 11 8f      mov si, word ptr [0x8f11]
1000:0212  8a 00            mov al, byte ptr [bx + si]
1000:0214  3c 00            cmp al, 0
1000:0216  74 07            je loc_1021f
1000:0218  83 0e 4c 95 04   or word ptr [0x954c], 4
1000:021d  eb 0f            jmp loc_1022e
                            loc_1021f:
1000:021f  8b 36 13 8f      mov si, word ptr [0x8f13]
1000:0223  8a 00            mov al, byte ptr [bx + si]
1000:0225  3c 00            cmp al, 0
1000:0227  74 05            je loc_1022e
1000:0229  83 0e 4c 95 08   or word ptr [0x954c], 8
                            loc_1022e:
1000:022e  8b 36 15 8f      mov si, word ptr [0x8f15]
1000:0232  8a 00            mov al, byte ptr [bx + si]
1000:0234  3c 00            cmp al, 0
1000:0236  74 06            je loc_1023e
1000:0238  81 0e 4c 95 80 00  or word ptr [0x954c], 0x80
                            loc_1023e:
1000:023e  8b 36 17 8f      mov si, word ptr [0x8f17]
1000:0242  8a 00            mov al, byte ptr [bx + si]
1000:0244  3c 00            cmp al, 0
1000:0246  74 05            je loc_1024d
1000:0248  83 0e 4c 95 40   or word ptr [0x954c], 0x40
                            loc_1024d:
1000:024d  8b 36 19 8f      mov si, word ptr [0x8f19]
1000:0251  8a 00            mov al, byte ptr [bx + si]
1000:0253  3c 00            cmp al, 0
1000:0255  74 05            je loc_1025c
1000:0257  83 0e 4c 95 20   or word ptr [0x954c], 0x20
                            loc_1025c:
1000:025c  8b 36 1b 8f      mov si, word ptr [0x8f1b]
1000:0260  8a 00            mov al, byte ptr [bx + si]
1000:0262  3c 00            cmp al, 0
1000:0264  74 26            je loc_1028c
1000:0266  e8 dc 29         call 0x2c45
1000:0269  bb 8a 8e         mov bx, 0x8e8a
                            loc_1026c:
1000:026c  8a 47 15         mov al, byte ptr [bx + 0x15]
1000:026f  3c 00            cmp al, 0
1000:0271  75 09            jne loc_1027c
1000:0273  8a 47 31         mov al, byte ptr [bx + 0x31]
1000:0276  3c 00            cmp al, 0
1000:0278  75 02            jne loc_1027c
1000:027a  eb f0            jmp loc_1026c
                            loc_1027c:
1000:027c  bb 8a 8e         mov bx, 0x8e8a
1000:027f  8a 47 15         mov al, byte ptr [bx + 0x15]
1000:0282  3c 00            cmp al, 0
1000:0284  74 03            je loc_10289
1000:0286  e9 0d fe         jmp loc_10096
                            loc_10289:
1000:0289  e8 9d 02         call 0x529
                            loc_1028c:
1000:028c  bb 8a 8e         mov bx, 0x8e8a
1000:028f  be 3c 00         mov si, 0x3c
1000:0292  8a 00            mov al, byte ptr [bx + si]
1000:0294  3c 00            cmp al, 0
1000:0296  74 2d            je loc_102c5
1000:0298  a0 05 95         mov al, byte ptr [0x9505]
1000:029b  3c 00            cmp al, 0
1000:029d  75 11            jne loc_102b0
1000:029f  b0 0e            mov al, 0xe
1000:02a1  e8 9c 35         call 0x3840
1000:02a4  c6 06 05 95 01   mov byte ptr [0x9505], 1
1000:02a9  c6 06 06 95 00   mov byte ptr [0x9506], 0
1000:02ae  eb 13            jmp loc_102c3
                            loc_102b0:
1000:02b0  3c 02            cmp al, 2
1000:02b2  75 0f            jne loc_102c3
1000:02b4  c6 06 05 95 03   mov byte ptr [0x9505], 3
1000:02b9  c6 06 06 95 01   mov byte ptr [0x9506], 1
1000:02be  b0 0d            mov al, 0xd
1000:02c0  e8 7d 35         call 0x3840
                            loc_102c3:
1000:02c3  eb 17            jmp loc_102dc
                            loc_102c5:
1000:02c5  a0 05 95         mov al, byte ptr [0x9505]
1000:02c8  3c 01            cmp al, 1
1000:02ca  75 07            jne loc_102d3
1000:02cc  c6 06 05 95 02   mov byte ptr [0x9505], 2
1000:02d1  eb 09            jmp loc_102dc
                            loc_102d3:
1000:02d3  3c 03            cmp al, 3
1000:02d5  75 05            jne loc_102dc
1000:02d7  c6 06 05 95 00   mov byte ptr [0x9505], 0
                            loc_102dc:
1000:02dc  a0 0a 8f         mov al, byte ptr [0x8f0a]
1000:02df  3c 00            cmp al, 0
1000:02e1  75 01            jne loc_102e4
1000:02e3  c3               ret 
                            loc_102e4:
1000:02e4  b8 03 00         mov ax, 3
1000:02e7  cd 33            int 0x33
1000:02e9  f7 c3 01 00      test bx, 1
1000:02ed  74 06            je loc_102f5
1000:02ef  81 0e 4c 95 80 00  or word ptr [0x954c], 0x80
                            loc_102f5:
1000:02f5  f7 c3 02 00      test bx, 2
1000:02f9  74 05            je loc_10300
1000:02fb  83 0e 4c 95 20   or word ptr [0x954c], 0x20
                            loc_10300:
1000:0300  a1 4c 95         mov ax, word ptr [0x954c]
1000:0303  25 0f 00         and ax, 0xf
1000:0306  74 01            je loc_10309
1000:0308  c3               ret 
                            loc_10309:
1000:0309  b8 0b 00         mov ax, 0xb
1000:030c  cd 33            int 0x33
1000:030e  83 f9 fb         cmp cx, -5
1000:0311  7d 07            jge loc_1031a
1000:0313  83 0e 4c 95 01   or word ptr [0x954c], 1
1000:0318  eb 0a            jmp loc_10324
                            loc_1031a:
1000:031a  83 f9 05         cmp cx, 5
1000:031d  7e 05            jle loc_10324
1000:031f  83 0e 4c 95 02   or word ptr [0x954c], 2
                            loc_10324:
1000:0324  83 fa f6         cmp dx, -0xa
1000:0327  7d 07            jge loc_10330
1000:0329  83 0e 4c 95 04   or word ptr [0x954c], 4
1000:032e  eb 0a            jmp loc_1033a
                            loc_10330:
1000:0330  83 fa 0a         cmp dx, 0xa
1000:0333  7e 05            jle loc_1033a
1000:0335  83 0e 4c 95 08   or word ptr [0x954c], 8
                            loc_1033a:
1000:033a  c3               ret 
                            sub_101c0 ENDP
*/
void sub_101c0()
{
    // coverage: 0x296-0x2cf method sub_101c0
    // coverage2: 1000:0096-1000:00cf method sub_101c0 // ins(0x0096, 0x00cf, 0x01c0);
    // coverage: 0x3c0-0x53b method sub_101c0
    // coverage2: 1000:01c0-1000:033b method sub_101c0 // ins(0x01c0, 0x033b, 0x01c0);
    goto loc_101c0;
loc_10096:
    sub_139a3();
    sub_105bc();
    sub_104a5();
    ax = 0x0003;
    interrupt(0x10);
    ax = 0x4c00;
    interrupt(0x21);
    sub_10103();
    memoryASet(ds, 0x9500, 0x00);
    memoryASet(ds, 0x94fe, 0x01);
    memoryASet(ds, 0x94fc, 0x10);
    memoryASet(ds, 0x94ff, 0x00);
    memoryASet(ds, 0x9502, 0x00);
    sub_10da7();
    sub_13423();
    sub_121dc();
    return;
    //   gap of 241 bytes
loc_101c0:
    bx = 0x8e8a;
    si = 0x003d;
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101d5;
    si = 0x003e;
loc_101cf:
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101cf;
loc_101d5:
    si = 0x003b;
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101e1;
    sub_1033b();
loc_101e1:
    bx = 0x8e8a;
    si = memoryAGet16(ds, 0x8f0d);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_101f6;
    memoryASet16(ds, 0x954c, 0x0001);
    goto loc_1020e;
loc_101f6:
    si = memoryAGet16(ds, 0x8f0f);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_10208;
    memoryASet16(ds, 0x954c, 0x0002);
    goto loc_1020e;
loc_10208:
    memoryASet16(ds, 0x954c, 0x0000);
loc_1020e:
    si = memoryAGet16(ds, 0x8f11);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1021f;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0004);
    goto loc_1022e;
loc_1021f:
    si = memoryAGet16(ds, 0x8f13);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1022e;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0008);
loc_1022e:
    si = memoryAGet16(ds, 0x8f15);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1023e;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0080);
loc_1023e:
    si = memoryAGet16(ds, 0x8f17);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1024d;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0040);
loc_1024d:
    si = memoryAGet16(ds, 0x8f19);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1025c;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0020);
loc_1025c:
    si = memoryAGet16(ds, 0x8f1b);
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_1028c;
    sub_12c45();
    bx = 0x8e8a;
loc_1026c:
    al = memoryAGet(ds, bx + 21);
    if (al != 0x00)
        goto loc_1027c;
    al = memoryAGet(ds, bx + 49);
    if (al != 0x00)
        goto loc_1027c;
    goto loc_1026c;
loc_1027c:
    bx = 0x8e8a;
    al = memoryAGet(ds, bx + 21);
    if (al == 0x00)
        goto loc_10289;
    goto loc_10096;
loc_10289:
    sub_10529();
loc_1028c:
    bx = 0x8e8a;
    si = 0x003c;
    al = memoryAGet(ds, bx + si);
    if (al == 0x00)
        goto loc_102c5;
    al = memoryAGet(ds, 0x9505);
    if (al != 0x00)
        goto loc_102b0;
    al = 0x0e;
    sub_13840();
    memoryASet(ds, 0x9505, 0x01);
    memoryASet(ds, 0x9506, 0x00);
    goto loc_102c3;
loc_102b0:
    if (al != 0x02)
        goto loc_102c3;
    memoryASet(ds, 0x9505, 0x03);
    memoryASet(ds, 0x9506, 0x01);
    al = 0x0d;
    sub_13840();
loc_102c3:
    goto loc_102dc;
loc_102c5:
    al = memoryAGet(ds, 0x9505);
    if (al != 0x01)
        goto loc_102d3;
    memoryASet(ds, 0x9505, 0x02);
    goto loc_102dc;
loc_102d3:
    if (al != 0x03)
        goto loc_102dc;
    memoryASet(ds, 0x9505, 0x00);
loc_102dc:
    al = memoryAGet(ds, 0x8f0a);
    if (al != 0x00)
        goto loc_102e4;
    return;
loc_102e4:
    ax = 0x0003;
    interrupt(0x33);
    if (!(bx & 0x0001))
        goto loc_102f5;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0080);
loc_102f5:
    if (!(bx & 0x0002))
        goto loc_10300;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0020);
loc_10300:
    ax = memoryAGet16(ds, 0x954c);
    ax &= 0x000f;
    if (ax == 0)
        goto loc_10309;
    return;
loc_10309:
    ax = 0x000b;
    interrupt(0x33);
    if ((short)cx >= (short)0xfffb)
        goto loc_1031a;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0001);
    goto loc_10324;
loc_1031a:
    if ((short)cx <= (short)0x0005)
        goto loc_10324;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0002);
loc_10324:
    if ((short)dx >= (short)0xfff6)
        goto loc_10330;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0004);
    return;
loc_10330:
    if ((short)dx <= (short)0x000a)
        return;
    memoryASet16(ds, 0x954c, memoryAGet16(ds, 0x954c) | 0x0008);
}
/* Assembly listing of 1000:033b sub_1033b()
                            sub_1033b PROC
1000:033b  e8 c9 28         call 0x2c07
1000:033e  b0 04            mov al, 4
1000:0340  e8 57 29         call 0x2c9a
1000:0343  e8 ad 01         call 0x4f3
1000:0346  a3 15 8f         mov word ptr [0x8f15], ax
1000:0349  b0 00            mov al, 0
1000:034b  e8 4c 29         call 0x2c9a
                            loc_1034e:
1000:034e  e8 a2 01         call 0x4f3
1000:0351  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:0355  74 f7            je loc_1034e
1000:0357  a3 0d 8f         mov word ptr [0x8f0d], ax
1000:035a  b0 01            mov al, 1
1000:035c  e8 3b 29         call 0x2c9a
                            loc_1035f:
1000:035f  e8 91 01         call 0x4f3
1000:0362  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:0366  74 f7            je loc_1035f
1000:0368  3b 06 0d 8f      cmp ax, word ptr [0x8f0d]
1000:036c  74 f1            je loc_1035f
1000:036e  a3 0f 8f         mov word ptr [0x8f0f], ax
1000:0371  b0 02            mov al, 2
1000:0373  e8 24 29         call 0x2c9a
                            loc_10376:
1000:0376  e8 7a 01         call 0x4f3
1000:0379  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:037d  74 f7            je loc_10376
1000:037f  3b 06 0d 8f      cmp ax, word ptr [0x8f0d]
1000:0383  74 f1            je loc_10376
1000:0385  3b 06 0f 8f      cmp ax, word ptr [0x8f0f]
1000:0389  74 eb            je loc_10376
1000:038b  a3 11 8f         mov word ptr [0x8f11], ax
1000:038e  b0 03            mov al, 3
1000:0390  e8 07 29         call 0x2c9a
                            loc_10393:
1000:0393  e8 5d 01         call 0x4f3
1000:0396  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:039a  74 f7            je loc_10393
1000:039c  3b 06 0d 8f      cmp ax, word ptr [0x8f0d]
1000:03a0  74 f1            je loc_10393
1000:03a2  3b 06 0f 8f      cmp ax, word ptr [0x8f0f]
1000:03a6  74 eb            je loc_10393
1000:03a8  3b 06 11 8f      cmp ax, word ptr [0x8f11]
1000:03ac  74 e5            je loc_10393
1000:03ae  a3 13 8f         mov word ptr [0x8f13], ax
1000:03b1  b0 06            mov al, 6
1000:03b3  e8 e4 28         call 0x2c9a
                            loc_103b6:
1000:03b6  e8 3a 01         call 0x4f3
1000:03b9  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:03bd  74 f7            je loc_103b6
1000:03bf  3b 06 0d 8f      cmp ax, word ptr [0x8f0d]
1000:03c3  74 f1            je loc_103b6
1000:03c5  3b 06 0f 8f      cmp ax, word ptr [0x8f0f]
1000:03c9  74 eb            je loc_103b6
1000:03cb  3b 06 11 8f      cmp ax, word ptr [0x8f11]
1000:03cf  74 e5            je loc_103b6
1000:03d1  3b 06 13 8f      cmp ax, word ptr [0x8f13]
1000:03d5  74 df            je loc_103b6
1000:03d7  a3 17 8f         mov word ptr [0x8f17], ax
1000:03da  b0 07            mov al, 7
1000:03dc  e8 bb 28         call 0x2c9a
                            loc_103df:
1000:03df  e8 11 01         call 0x4f3
1000:03e2  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:03e6  74 f7            je loc_103df
1000:03e8  3b 06 0d 8f      cmp ax, word ptr [0x8f0d]
1000:03ec  74 f1            je loc_103df
1000:03ee  3b 06 0f 8f      cmp ax, word ptr [0x8f0f]
1000:03f2  74 eb            je loc_103df
1000:03f4  3b 06 11 8f      cmp ax, word ptr [0x8f11]
1000:03f8  74 e5            je loc_103df
1000:03fa  3b 06 13 8f      cmp ax, word ptr [0x8f13]
1000:03fe  74 df            je loc_103df
1000:0400  3b 06 17 8f      cmp ax, word ptr [0x8f17]
1000:0404  74 d9            je loc_103df
1000:0406  a3 19 8f         mov word ptr [0x8f19], ax
1000:0409  b0 05            mov al, 5
1000:040b  e8 8c 28         call 0x2c9a
                            loc_1040e:
1000:040e  e8 e2 00         call 0x4f3
1000:0411  3b 06 15 8f      cmp ax, word ptr [0x8f15]
1000:0415  74 f7            je loc_1040e
1000:0417  3b 06 0d 8f      cmp ax, word ptr [0x8f0d]
1000:041b  74 f1            je loc_1040e
1000:041d  3b 06 0f 8f      cmp ax, word ptr [0x8f0f]
1000:0421  74 eb            je loc_1040e
1000:0423  3b 06 11 8f      cmp ax, word ptr [0x8f11]
1000:0427  74 e5            je loc_1040e
1000:0429  3b 06 13 8f      cmp ax, word ptr [0x8f13]
1000:042d  74 df            je loc_1040e
1000:042f  3b 06 17 8f      cmp ax, word ptr [0x8f17]
1000:0433  74 d9            je loc_1040e
1000:0435  3b 06 19 8f      cmp ax, word ptr [0x8f19]
1000:0439  74 d3            je loc_1040e
1000:043b  a3 1b 8f         mov word ptr [0x8f1b], ax
1000:043e  e8 e8 00         call 0x529
1000:0441  c3               ret 
                            sub_1033b ENDP
*/
void sub_1033b()
{
    // coverage: 0x53b-0x642 method sub_1033b
    // coverage2: 1000:033b-1000:0442 method sub_1033b // ins(0x033b, 0x0442, 0x033b);
    sub_12c07();
    al = 0x04;
    sub_12c9a();
    sub_104f3();
    memoryASet16(ds, 0x8f15, ax);
    al = 0x00;
    sub_12c9a();
loc_1034e:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_1034e;
    memoryASet16(ds, 0x8f0d, ax);
    al = 0x01;
    sub_12c9a();
loc_1035f:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_1035f;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_1035f;
    memoryASet16(ds, 0x8f0f, ax);
    al = 0x02;
    sub_12c9a();
loc_10376:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_10376;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_10376;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_10376;
    memoryASet16(ds, 0x8f11, ax);
    al = 0x03;
    sub_12c9a();
loc_10393:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_10393;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_10393;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_10393;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_10393;
    memoryASet16(ds, 0x8f13, ax);
    al = 0x06;
    sub_12c9a();
loc_103b6:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_103b6;
    if (ax == memoryAGet16(ds, 0x8f13))
        goto loc_103b6;
    memoryASet16(ds, 0x8f17, ax);
    al = 0x07;
    sub_12c9a();
loc_103df:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f13))
        goto loc_103df;
    if (ax == memoryAGet16(ds, 0x8f17))
        goto loc_103df;
    memoryASet16(ds, 0x8f19, ax);
    al = 0x05;
    sub_12c9a();
loc_1040e:
    sub_104f3();
    if (ax == memoryAGet16(ds, 0x8f15))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f0d))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f0f))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f11))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f13))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f17))
        goto loc_1040e;
    if (ax == memoryAGet16(ds, 0x8f19))
        goto loc_1040e;
    memoryASet16(ds, 0x8f1b, ax);
    sub_10529();
}
/* Assembly listing of 1000:0442 sub_10442()
                            sub_10442 PROC
1000:0442  c7 06 0b 8f 00 00  mov word ptr [0x8f0b], 0
1000:0448  c7 06 0d 8f 4b 00  mov word ptr [0x8f0d], 0x4b
1000:044e  c7 06 0f 8f 4d 00  mov word ptr [0x8f0f], 0x4d
1000:0454  c7 06 11 8f 48 00  mov word ptr [0x8f11], 0x48
1000:045a  c7 06 13 8f 50 00  mov word ptr [0x8f13], 0x50
1000:0460  c7 06 15 8f 39 00  mov word ptr [0x8f15], 0x39
1000:0466  c7 06 17 8f 31 00  mov word ptr [0x8f17], 0x31
1000:046c  c7 06 19 8f 32 00  mov word ptr [0x8f19], 0x32
1000:0472  c7 06 1b 8f 10 00  mov word ptr [0x8f1b], 0x10
1000:0478  8c d8            mov ax, ds
1000:047a  8e c0            mov es, ax
1000:047c  b8 00 00         mov ax, 0
1000:047f  b9 40 00         mov cx, 0x40
1000:0482  bf 8a 8e         mov di, 0x8e8a
1000:0485  f3 ab            rep stosw word ptr es:[di], ax
1000:0487  b0 09            mov al, 9
1000:0489  b4 35            mov ah, 0x35
1000:048b  cd 21            int 0x21
1000:048d  89 1e 84 8e      mov word ptr [0x8e84], bx
1000:0491  8c 06 82 8e      mov word ptr [0x8e82], es
1000:0495  1e               push ds
1000:0496  ba b7 04         mov dx, 0x4b7
1000:0499  8c c8            mov ax, cs
1000:049b  8e d8            mov ds, ax
1000:049d  b0 09            mov al, 9
1000:049f  b4 25            mov ah, 0x25
1000:04a1  cd 21            int 0x21
1000:04a3  1f               pop ds
1000:04a4  c3               ret 
                            sub_10442 ENDP
*/
void sub_10442()
{
    // coverage: 0x642-0x6a5 method sub_10442
    // coverage2: 1000:0442-1000:04a5 method sub_10442 // ins(0x0442, 0x04a5, 0x0442);
    memoryASet16(ds, 0x8f0b, 0x0000);
    memoryASet16(ds, 0x8f0d, 0x004b);
    memoryASet16(ds, 0x8f0f, 0x004d);
    memoryASet16(ds, 0x8f11, 0x0048);
    memoryASet16(ds, 0x8f13, 0x0050);
    memoryASet16(ds, 0x8f15, 0x0039);
    memoryASet16(ds, 0x8f17, 0x0031);
    memoryASet16(ds, 0x8f19, 0x0032);
    memoryASet16(ds, 0x8f1b, 0x0010);
    ax = ds;
    es = ax;
    ax = 0x0000;
    cx = 0x0040;
    di = 0x8e8a;
    rep_stosw<MemAuto, DirAuto>();
    al = 0x09;
    ah = 0x35;
    interrupt(0x21);
    memoryASet16(ds, 0x8e84, bx);
    memoryASet16(ds, 0x8e82, es);
    push(ds);
    dx = 0x04b7;
    ax = cs;
    ds = ax;
    al = 0x09;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:04a5 sub_104a5()
                            sub_104a5 PROC
1000:04a5  8b 16 84 8e      mov dx, word ptr [0x8e84]
1000:04a9  a1 82 8e         mov ax, word ptr [0x8e82]
1000:04ac  1e               push ds
1000:04ad  8e d8            mov ds, ax
1000:04af  b0 09            mov al, 9
1000:04b1  b4 25            mov ah, 0x25
1000:04b3  cd 21            int 0x21
1000:04b5  1f               pop ds
1000:04b6  c3               ret 
                            sub_104a5 ENDP
*/
void sub_104a5()
{
    // coverage: 0x6a5-0x6b7 method sub_104a5
    // coverage2: 1000:04a5-1000:04b7 method sub_104a5 // ins(0x04a5, 0x04b7, 0x04a5);
    dx = memoryAGet16(ds, 0x8e84);
    ax = memoryAGet16(ds, 0x8e82);
    push(ds);
    ds = ax;
    al = 0x09;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:04f3 sub_104f3()
                            sub_104f3 PROC
1000:04f3  fc               cld 
                            loc_104f4:
1000:04f4  be 8a 8e         mov si, 0x8e8a
                            loc_104f7:
1000:04f7  ac               lodsb al, byte ptr [si]
1000:04f8  3c 00            cmp al, 0
1000:04fa  74 24            je loc_10520
1000:04fc  8b c6            mov ax, si
1000:04fe  2d 8b 8e         sub ax, 0x8e8b
1000:0501  3d 3b 00         cmp ax, 0x3b
1000:0504  74 1a            je loc_10520
1000:0506  3d 3c 00         cmp ax, 0x3c
1000:0509  74 15            je loc_10520
1000:050b  3d 3d 00         cmp ax, 0x3d
1000:050e  74 10            je loc_10520
1000:0510  3d 3e 00         cmp ax, 0x3e
1000:0513  74 0b            je loc_10520
1000:0515  3d 2a 00         cmp ax, 0x2a
1000:0518  74 06            je loc_10520
1000:051a  3d 36 00         cmp ax, 0x36
1000:051d  74 01            je loc_10520
1000:051f  c3               ret 
                            loc_10520:
1000:0520  81 fe 0a 8f      cmp si, 0x8f0a
1000:0524  75 d1            jne loc_104f7
1000:0526  eb cc            jmp loc_104f4
                            sub_104f3 ENDP
*/
void sub_104f3()
{
    // coverage: 0x6f3-0x728 method sub_104f3
    // coverage2: 1000:04f3-1000:0528 method sub_104f3 // ins(0x04f3, 0x0528, 0x04f3);
    flags.direction = false;
loc_104f4:
    si = 0x8e8a;
loc_104f7:
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_10520;
    ax = si;
    ax -= 0x8e8b;
    if (ax == 0x003b)
        goto loc_10520;
    if (ax == 0x003c)
        goto loc_10520;
    if (ax == 0x003d)
        goto loc_10520;
    if (ax == 0x003e)
        goto loc_10520;
    if (ax == 0x002a)
        goto loc_10520;
    if (ax == 0x0036)
        goto loc_10520;
    return;
loc_10520:
    if (si != 0x8f0a)
        goto loc_104f7;
    goto loc_104f4;
}
/* Assembly listing of 1000:0529 sub_10529()
                            sub_10529 PROC
                            loc_10529:
1000:0529  be 8a 8e         mov si, 0x8e8a
1000:052c  b4 00            mov ah, 0
                            loc_1052e:
1000:052e  ac               lodsb al, byte ptr [si]
1000:052f  3c 00            cmp al, 0
1000:0531  74 02            je loc_10535
1000:0533  fe c4            inc ah
                            loc_10535:
1000:0535  81 fe 0a 8f      cmp si, 0x8f0a
1000:0539  75 f3            jne loc_1052e
1000:053b  80 fc 00         cmp ah, 0
1000:053e  75 e9            jne loc_10529
1000:0540  c3               ret 
                            sub_10529 ENDP
*/
void sub_10529()
{
    // coverage: 0x729-0x741 method sub_10529
    // coverage2: 1000:0529-1000:0541 method sub_10529 // ins(0x0529, 0x0541, 0x0529);
loc_10529:
    si = 0x8e8a;
    ah = 0x00;
loc_1052e:
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_10535;
    ah++;
loc_10535:
    if (si != 0x8f0a)
        goto loc_1052e;
    if (ah != 0x00)
        goto loc_10529;
}
/* Assembly listing of 1000:0541 sub_10541()
                            sub_10541 PROC
1000:0541  b9 20 4e         mov cx, 0x4e20
                            loc_10544:
1000:0544  be 8a 8e         mov si, 0x8e8a
1000:0547  b4 00            mov ah, 0
1000:0549  fc               cld 
                            loc_1054a:
1000:054a  ac               lodsb al, byte ptr [si]
1000:054b  3c 00            cmp al, 0
1000:054d  74 08            je loc_10557
1000:054f  b4 01            mov ah, 1
1000:0551  3b 36 0b 8f      cmp si, word ptr [0x8f0b]
1000:0555  75 08            jne loc_1055f
                            loc_10557:
1000:0557  81 fe 0a 8f      cmp si, 0x8f0a
1000:055b  74 02            je loc_1055f
1000:055d  eb eb            jmp loc_1054a
                            loc_1055f:
1000:055f  74 17            je loc_10578
1000:0561  89 36 0b 8f      mov word ptr [0x8f0b], si
1000:0565  81 ee 8b 8e      sub si, 0x8e8b
1000:0569  8a 84 5a 00      mov al, byte ptr [si + 0x5a]
1000:056d  3c 00            cmp al, 0
1000:056f  74 05            je loc_10576
1000:0571  79 02            jns loc_10575
1000:0573  b0 00            mov al, 0
                            loc_10575:
1000:0575  c3               ret 
                            loc_10576:
1000:0576  eb 0b            jmp loc_10583
                            loc_10578:
1000:0578  80 fc 00         cmp ah, 0
1000:057b  75 06            jne loc_10583
1000:057d  c7 06 0b 8f 00 00  mov word ptr [0x8f0b], 0
                            loc_10583:
1000:0583  e2 bf            loop loc_10544
1000:0585  b0 00            mov al, 0
1000:0587  c3               ret 
                            sub_10541 ENDP
*/
void sub_10541()
{
    // coverage: 0x741-0x788 method sub_10541
    // coverage2: 1000:0541-1000:0588 method sub_10541 // ins(0x0541, 0x0588, 0x0541);
    cx = 0x4e20;
loc_10544:
    si = 0x8e8a;
    ah = 0x00;
    flags.direction = false;
loc_1054a:
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_10557;
    ah = 0x01;
    flags.zero = si == memoryAGet16(ds, 0x8f0b);
    if (si != memoryAGet16(ds, 0x8f0b))
        goto loc_1055f;
loc_10557:
    flags.zero = si == 0x8f0a;
    if (si == 0x8f0a)
        goto loc_1055f;
    goto loc_1054a;
loc_1055f:
    if (flags.zero)
        goto loc_10578;
    memoryASet16(ds, 0x8f0b, si);
    si -= 0x8e8b;
    al = memoryAGet(ds, si + 90);
    if (al == 0x00)
        goto loc_10576;
    if ((char)al >= 0)
        goto loc_10575;
    al = 0x00;
loc_10575:
    return;
loc_10576:
    goto loc_10583;
loc_10578:
    if (ah != 0x00)
        goto loc_10583;
    memoryASet16(ds, 0x8f0b, 0x0000);
loc_10583:
    if (--cx)
        goto loc_10544;
    al = 0x00;
}
/* Assembly listing of 1000:0588 sub_10588()
                            sub_10588 PROC
1000:0588  b8 00 00         mov ax, 0
1000:058b  cd 33            int 0x33
1000:058d  a2 0a 8f         mov byte ptr [0x8f0a], al
1000:0590  c3               ret 
                            sub_10588 ENDP
*/
void sub_10588()
{
    // coverage: 0x788-0x791 method sub_10588
    // coverage2: 1000:0588-1000:0591 method sub_10588 // ins(0x0588, 0x0591, 0x0588);
    ax = 0x0000;
    interrupt(0x33);
    memoryASet(ds, 0x8f0a, al);
}
/* Assembly listing of 1000:0591 sub_10591()
                            sub_10591 PROC
1000:0591  b0 1c            mov al, 0x1c
1000:0593  b4 35            mov ah, 0x35
1000:0595  cd 21            int 0x21
1000:0597  89 1e 88 8e      mov word ptr [0x8e88], bx
1000:059b  8c 06 86 8e      mov word ptr [0x8e86], es
1000:059f  1e               push ds
1000:05a0  ba ce 05         mov dx, 0x5ce
1000:05a3  8c c8            mov ax, cs
1000:05a5  8e d8            mov ds, ax
1000:05a7  b0 1c            mov al, 0x1c
1000:05a9  b4 25            mov ah, 0x25
1000:05ab  cd 21            int 0x21
1000:05ad  1f               pop ds
1000:05ae  b0 36            mov al, 0x36
1000:05b0  e6 43            out 0x43, al
1000:05b2  b8 0e 4d         mov ax, 0x4d0e
1000:05b5  e6 40            out 0x40, al
1000:05b7  8a c4            mov al, ah
1000:05b9  e6 40            out 0x40, al
1000:05bb  c3               ret 
                            sub_10591 ENDP
*/
void sub_10591()
{
    // coverage: 0x791-0x7bc method sub_10591
    // coverage2: 1000:0591-1000:05bc method sub_10591 // ins(0x0591, 0x05bc, 0x0591);
    al = 0x1c;
    ah = 0x35;
    interrupt(0x21);
    memoryASet16(ds, 0x8e88, bx);
    memoryASet16(ds, 0x8e86, es);
    push(ds);
    dx = 0x05ce;
    ax = cs;
    ds = ax;
    al = 0x1c;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
    al = 0x36;
    out(0x43, al);
    ax = 0x4d0e;
    out(0x40, al);
    al = ah;
    out(0x40, al);
}
/* Assembly listing of 1000:05bc sub_105bc()
                            sub_105bc PROC
1000:05bc  8b 16 88 8e      mov dx, word ptr [0x8e88]
1000:05c0  a1 86 8e         mov ax, word ptr [0x8e86]
1000:05c3  1e               push ds
1000:05c4  8e d8            mov ds, ax
1000:05c6  b0 1c            mov al, 0x1c
1000:05c8  b4 25            mov ah, 0x25
1000:05ca  cd 21            int 0x21
1000:05cc  1f               pop ds
1000:05cd  c3               ret 
                            sub_105bc ENDP
*/
void sub_105bc()
{
    // coverage: 0x7bc-0x7ce method sub_105bc
    // coverage2: 1000:05bc-1000:05ce method sub_105bc // ins(0x05bc, 0x05ce, 0x05bc);
    dx = memoryAGet16(ds, 0x8e88);
    ax = memoryAGet16(ds, 0x8e86);
    push(ds);
    ds = ax;
    al = 0x1c;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:05ec sub_105ec()
                            sub_105ec PROC
1000:05ec  1e               push ds
1000:05ed  ba fc 05         mov dx, 0x5fc
1000:05f0  8c c8            mov ax, cs
1000:05f2  8e d8            mov ds, ax
1000:05f4  b0 24            mov al, 0x24
1000:05f6  b4 25            mov ah, 0x25
1000:05f8  cd 21            int 0x21
1000:05fa  1f               pop ds
1000:05fb  c3               ret 
                            sub_105ec ENDP
*/
void sub_105ec()
{
    // coverage: 0x7ec-0x7fc method sub_105ec
    // coverage2: 1000:05ec-1000:05fc method sub_105ec // ins(0x05ec, 0x05fc, 0x05ec);
    push(ds);
    dx = 0x05fc;
    ax = cs;
    ds = ax;
    al = 0x24;
    ah = 0x25;
    interrupt(0x21);
    ds = pop();
}
/* Assembly listing of 1000:0600 sub_10600()
                            sub_10600 PROC
1000:0600  ba e2 01         mov dx, 0x1e2
1000:0603  a1 e8 94         mov ax, word ptr [0x94e8]
1000:0606  e8 2e 00         call 0x637
1000:0609  ba ea 01         mov dx, 0x1ea
1000:060c  a1 ea 94         mov ax, word ptr [0x94ea]
1000:060f  e8 25 00         call 0x637
1000:0612  ba f2 01         mov dx, 0x1f2
1000:0615  a1 ec 94         mov ax, word ptr [0x94ec]
1000:0618  e8 1c 00         call 0x637
1000:061b  ba f9 01         mov dx, 0x1f9
1000:061e  a1 ee 94         mov ax, word ptr [0x94ee]
1000:0621  e8 13 00         call 0x637
1000:0624  ba 03 02         mov dx, 0x203
1000:0627  a1 f0 94         mov ax, word ptr [0x94f0]
1000:062a  e8 0a 00         call 0x637
1000:062d  ba 0b 02         mov dx, 0x20b
1000:0630  a1 f2 94         mov ax, word ptr [0x94f2]
1000:0633  e8 01 00         call 0x637
1000:0636  c3               ret 
                            sub_10600 ENDP
*/
void sub_10600()
{
    // coverage: 0x800-0x837 method sub_10600
    // coverage2: 1000:0600-1000:0637 method sub_10600 // ins(0x0600, 0x0637, 0x0600);
    dx = 0x01e2;
    ax = memoryAGet16(ds, 0x94e8);
    sub_10637();
    dx = 0x01ea;
    ax = memoryAGet16(ds, 0x94ea);
    sub_10637();
    dx = 0x01f2;
    ax = memoryAGet16(ds, 0x94ec);
    sub_10637();
    dx = 0x01f9;
    ax = memoryAGet16(ds, 0x94ee);
    sub_10637();
    dx = 0x0203;
    ax = memoryAGet16(ds, 0x94f0);
    sub_10637();
    dx = 0x020b;
    ax = memoryAGet16(ds, 0x94f2);
    sub_10637();
}
/* Assembly listing of 1000:0637 sub_10637()
                            sub_10637 PROC
1000:0637  a3 20 8f         mov word ptr [0x8f20], ax
1000:063a  bf 00 00         mov di, 0
1000:063d  b9 00 7d         mov cx, 0x7d00
1000:0640  e8 0a 00         call 0x64d
1000:0643  c3               ret 
                            sub_10637 ENDP
*/
void sub_10637()
{
    // coverage: 0x837-0x844 method sub_10637
    // coverage2: 1000:0637-1000:0644 method sub_10637 // ins(0x0637, 0x0644, 0x0637);
    memoryASet16(ds, 0x8f20, ax);
    di = 0x0000;
    cx = 0x7d00;
    sub_1064d();
}
/* Assembly listing of 1000:0644 sub_10644()
                            sub_10644 PROC
1000:0644  8c d8            mov ax, ds
1000:0646  a3 20 8f         mov word ptr [0x8f20], ax
1000:0649  e8 01 00         call 0x64d
1000:064c  c3               ret 
                            sub_10644 ENDP
*/
void sub_10644()
{
    // coverage: 0x844-0x84d method sub_10644
    // coverage2: 1000:0644-1000:064d method sub_10644 // ins(0x0644, 0x064d, 0x0644);
    ax = ds;
    memoryASet16(ds, 0x8f20, ax);
    sub_1064d();
}
/* Assembly listing of 1000:064d sub_1064d()
                            sub_1064d PROC
1000:064d  57               push di
1000:064e  51               push cx
1000:064f  b8 00 3d         mov ax, 0x3d00
1000:0652  cd 21            int 0x21
1000:0654  59               pop cx
1000:0655  5a               pop dx
1000:0656  73 01            jae loc_10659
1000:0658  c3               ret 
                            loc_10659:
1000:0659  a3 1e 8f         mov word ptr [0x8f1e], ax
1000:065c  8b d8            mov bx, ax
1000:065e  a1 20 8f         mov ax, word ptr [0x8f20]
1000:0661  1e               push ds
1000:0662  8e d8            mov ds, ax
1000:0664  b8 00 3f         mov ax, 0x3f00
1000:0667  cd 21            int 0x21
1000:0669  1f               pop ds
1000:066a  b8 00 3e         mov ax, 0x3e00
1000:066d  8b 1e 1e 8f      mov bx, word ptr [0x8f1e]
1000:0671  cd 21            int 0x21
1000:0673  c3               ret 
                            sub_1064d ENDP
*/
void sub_1064d()
{
    // coverage: 0x84d-0x874 method sub_1064d
    // coverage2: 1000:064d-1000:0674 method sub_1064d // ins(0x064d, 0x0674, 0x064d);
    push(di);
    push(cx);
    ax = 0x3d00;
    interrupt(0x21);
    cx = pop();
    dx = pop();
    if (!flags.carry)
        goto loc_10659;
    return;
loc_10659:
    memoryASet16(ds, 0x8f1e, ax);
    bx = ax;
    ax = memoryAGet16(ds, 0x8f20);
    push(ds);
    ds = ax;
    ax = 0x3f00;
    interrupt(0x21);
    ds = pop();
    ax = 0x3e00;
    bx = memoryAGet16(ds, 0x8f1e);
    interrupt(0x21);
}
/* Assembly listing of 1000:0674 sub_10674()
                            sub_10674 PROC
1000:0674  57               push di
1000:0675  51               push cx
1000:0676  b9 00 00         mov cx, 0
1000:0679  b8 00 3c         mov ax, 0x3c00
1000:067c  cd 21            int 0x21
1000:067e  59               pop cx
1000:067f  5a               pop dx
1000:0680  73 01            jae loc_10683
1000:0682  c3               ret 
                            loc_10683:
1000:0683  a3 1e 8f         mov word ptr [0x8f1e], ax
1000:0686  8b d8            mov bx, ax
1000:0688  b8 00 40         mov ax, 0x4000
1000:068b  cd 21            int 0x21
1000:068d  73 01            jae loc_10690
1000:068f  c3               ret 
                            loc_10690:
1000:0690  b8 00 3e         mov ax, 0x3e00
1000:0693  8b 1e 1e 8f      mov bx, word ptr [0x8f1e]
1000:0697  cd 21            int 0x21
1000:0699  c3               ret 
                            sub_10674 ENDP
*/
void sub_10674()
{
    // coverage: 0x874-0x89a method sub_10674
    // coverage2: 1000:0674-1000:069a method sub_10674 // ins(0x0674, 0x069a, 0x0674);
    push(di);
    push(cx);
    cx = 0x0000;
    ax = 0x3c00;
    interrupt(0x21);
    cx = pop();
    dx = pop();
    if (!flags.carry)
        goto loc_10683;
    return;
loc_10683:
    memoryASet16(ds, 0x8f1e, ax);
    bx = ax;
    ax = 0x4000;
    interrupt(0x21);
    if (!flags.carry)
        goto loc_10690;
    return;
loc_10690:
    ax = 0x3e00;
    bx = memoryAGet16(ds, 0x8f1e);
    interrupt(0x21);
}
/* Assembly listing of 1000:069a sub_1069a()
                            sub_1069a PROC
1000:069a  a0 01 95         mov al, byte ptr [0x9501]
1000:069d  8a d8            mov bl, al
1000:069f  d0 e3            shl bl, 1
1000:06a1  02 d8            add bl, al
1000:06a3  02 1e 02 95      add bl, byte ptr [0x9502]
1000:06a7  b7 00            mov bh, 0
1000:06a9  d1 e3            shl bx, 1
1000:06ab  8b b7 44 02      mov si, word ptr [bx + 0x244]
1000:06af  bf 29 92         mov di, 0x9229
1000:06b2  b9 40 00         mov cx, 0x40
1000:06b5  8c d8            mov ax, ds
1000:06b7  8e c0            mov es, ax
1000:06b9  b8 00 00         mov ax, 0
1000:06bc  fc               cld 
1000:06bd  f3 ab            rep stosw word ptr es:[di], ax
1000:06bf  bf 29 92         mov di, 0x9229
                            loc_106c2:
1000:06c2  ac               lodsb al, byte ptr [si]
1000:06c3  3c ff            cmp al, 0xff
1000:06c5  74 24            je loc_106eb
1000:06c7  d0 e0            shl al, 1
1000:06c9  d0 e0            shl al, 1
1000:06cb  8a e0            mov ah, al
1000:06cd  ac               lodsb al, byte ptr [si]
1000:06ce  d0 e0            shl al, 1
1000:06d0  8a d8            mov bl, al
1000:06d2  b7 00            mov bh, 0
1000:06d4  b0 00            mov al, 0
1000:06d6  0b 87 d7 0c      or ax, word ptr [bx + 0xcd7]
1000:06da  8b c8            mov cx, ax
1000:06dc  ac               lodsb al, byte ptr [si]
1000:06dd  f6 d8            neg al
1000:06df  04 3f            add al, 0x3f
1000:06e1  d0 e0            shl al, 1
1000:06e3  8a d8            mov bl, al
1000:06e5  09 8f 29 92      or word ptr [bx - 0x6dd7], cx
1000:06e9  eb d7            jmp loc_106c2
                            loc_106eb:
1000:06eb  a0 01 95         mov al, byte ptr [0x9501]
1000:06ee  8a d8            mov bl, al
1000:06f0  d0 e3            shl bl, 1
1000:06f2  02 d8            add bl, al
1000:06f4  02 1e 02 95      add bl, byte ptr [0x9502]
1000:06f8  b7 00            mov bh, 0
1000:06fa  d1 e3            shl bx, 1
1000:06fc  8b b7 14 02      mov si, word ptr [bx + 0x214]
1000:0700  bf 29 8f         mov di, 0x8f29
1000:0703  b9 00 03         mov cx, 0x300
1000:0706  b3 00            mov bl, 0
                            loc_10708:
1000:0708  fe cb            dec bl
1000:070a  79 20            jns loc_1072c
1000:070c  ac               lodsb al, byte ptr [si]
1000:070d  8a d0            mov dl, al
1000:070f  80 e2 3f         and dl, 0x3f
1000:0712  24 c0            and al, 0xc0
1000:0714  75 04            jne loc_1071a
1000:0716  b3 00            mov bl, 0
1000:0718  eb 12            jmp loc_1072c
                            loc_1071a:
1000:071a  3c 40            cmp al, 0x40
1000:071c  75 04            jne loc_10722
1000:071e  b3 01            mov bl, 1
1000:0720  eb 0a            jmp loc_1072c
                            loc_10722:
1000:0722  3c 80            cmp al, 0x80
1000:0724  75 04            jne loc_1072a
1000:0726  b3 02            mov bl, 2
1000:0728  eb 02            jmp loc_1072c
                            loc_1072a:
1000:072a  b3 03            mov bl, 3
                            loc_1072c:
1000:072c  88 15            mov byte ptr [di], dl
1000:072e  47               inc di
1000:072f  e2 d7            loop loc_10708
1000:0731  bf 00 00         mov di, 0
1000:0734  b8 00 a8         mov ax, 0xa800
1000:0737  8e c0            mov es, ax
1000:0739  ba ce 03         mov dx, 0x3ce
1000:073c  b4 00            mov ah, 0
1000:073e  b0 00            mov al, 0
1000:0740  ef               out dx, ax
1000:0741  b8 01 0f         mov ax, 0xf01
1000:0744  ef               out dx, ax
1000:0745  b9 00 40         mov cx, 0x4000
1000:0748  f3 ab            rep stosw word ptr es:[di], ax
1000:074a  b8 29 8f         mov ax, 0x8f29
1000:074d  a3 25 8f         mov word ptr [0x8f25], ax
1000:0750  c7 06 23 8f f0 03  mov word ptr [0x8f23], 0x3f0
1000:0756  b9 40 00         mov cx, 0x40
                            loc_10759:
1000:0759  51               push cx
1000:075a  c6 06 22 8f 00   mov byte ptr [0x8f22], 0
1000:075f  e8 4d 00         call 0x7af
1000:0762  c7 06 79 02 00 00  mov word ptr [0x279], 0
1000:0768  c6 06 7d 02 08   mov byte ptr [0x27d], 8
1000:076d  83 06 83 02 08   add word ptr [0x283], 8
1000:0772  be 74 02         mov si, 0x274
1000:0775  e8 4d 04         call 0xbc5
1000:0778  c7 06 79 02 08 00  mov word ptr [0x279], 8
1000:077e  c6 06 7d 02 18   mov byte ptr [0x27d], 0x18
1000:0783  b9 0a 00         mov cx, 0xa
                            loc_10786:
1000:0786  51               push cx
1000:0787  e8 25 00         call 0x7af
1000:078a  be 74 02         mov si, 0x274
1000:078d  e8 35 04         call 0xbc5
1000:0790  83 06 79 02 18   add word ptr [0x279], 0x18
1000:0795  59               pop cx
1000:0796  e2 ee            loop loc_10786
1000:0798  c6 06 7d 02 08   mov byte ptr [0x27d], 8
1000:079d  e8 0f 00         call 0x7af
1000:07a0  be 74 02         mov si, 0x274
1000:07a3  e8 1f 04         call 0xbc5
1000:07a6  83 2e 23 8f 10   sub word ptr [0x8f23], 0x10
1000:07ab  59               pop cx
1000:07ac  e2 ab            loop loc_10759
1000:07ae  c3               ret 
                            sub_1069a ENDP
*/
void sub_1069a()
{
    // coverage: 0x89a-0x9af method sub_1069a
    // coverage2: 1000:069a-1000:07af method sub_1069a // ins(0x069a, 0x07af, 0x069a);
    al = memoryAGet(ds, 0x9501);
    bl = al;
    bl <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    si = memoryAGet16(ds, bx + 580);
    di = 0x9229;
    cx = 0x0040;
    ax = ds;
    es = ax;
    ax = 0x0000;
    flags.direction = false;
    rep_stosw<MemAuto, DirAuto>();
    di = 0x9229;
loc_106c2:
    lodsb<MemAuto, DirAuto>();
    if (al == 0xff)
        goto loc_106eb;
    al <<= 1;
    al <<= 1;
    ah = al;
    lodsb<MemAuto, DirAuto>();
    al <<= 1;
    bl = al;
    bh = 0x00;
    al = 0x00;
    ax |= memoryAGet16(ds, bx + 3287);
    cx = ax;
    lodsb<MemAuto, DirAuto>();
    al = -al;
    al += 0x3f;
    al <<= 1;
    bl = al;
    memoryASet16(ds, bx + 37417, memoryAGet16(ds, bx + 37417) | cx);
    goto loc_106c2;
loc_106eb:
    al = memoryAGet(ds, 0x9501);
    bl = al;
    bl <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    si = memoryAGet16(ds, bx + 532);
    di = 0x8f29;
    cx = 0x0300;
    bl = 0x00;
loc_10708:
    bl--;
    if ((char)bl >= 0)
        goto loc_1072c;
    lodsb<MemAuto, DirAuto>();
    dl = al;
    dl &= 0x3f;
    al &= 0xc0;
    if (al != 0)
        goto loc_1071a;
    bl = 0x00;
    goto loc_1072c;
loc_1071a:
    if (al != 0x40)
        goto loc_10722;
    bl = 0x01;
    goto loc_1072c;
loc_10722:
    if (al != 0x80)
        goto loc_1072a;
    bl = 0x02;
    goto loc_1072c;
loc_1072a:
    bl = 0x03;
loc_1072c:
    memoryASet(ds, di, dl);
    di++;
    if (--cx)
        goto loc_10708;
    di = 0x0000;
    ax = 0xa800;
    es = ax;
    dx = 0x03ce;
    ah = 0x00;
    al = 0x00;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    cx = 0x4000;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x8f29;
    memoryASet16(ds, 0x8f25, ax);
    memoryASet16(ds, 0x8f23, 0x03f0);
    cx = 0x0040;
loc_10759:
    push(cx);
    memoryASet(ds, 0x8f22, 0x00);
    sub_107af();
    memoryASet16(ds, 0x0279, 0x0000);
    memoryASet(ds, 0x027d, 0x08);
    memoryASet16(ds, 0x0283, memoryAGet16(ds, 0x0283) + 0x0008);
    si = 0x0274;
    sub_10bc5();
    memoryASet16(ds, 0x0279, 0x0008);
    memoryASet(ds, 0x027d, 0x18);
    cx = 0x000a;
loc_10786:
    push(cx);
    sub_107af();
    si = 0x0274;
    sub_10bc5();
    memoryASet16(ds, 0x0279, memoryAGet16(ds, 0x0279) + 0x0018);
    cx = pop();
    if (--cx)
        goto loc_10786;
    memoryASet(ds, 0x027d, 0x08);
    sub_107af();
    si = 0x0274;
    sub_10bc5();
    memoryASet16(ds, 0x8f23, memoryAGet16(ds, 0x8f23) - 0x0010);
    cx = pop();
    if (--cx)
        goto loc_10759;
}
/* Assembly listing of 1000:07af sub_107af()
                            sub_107af PROC
1000:07af  a0 22 8f         mov al, byte ptr [0x8f22]
1000:07b2  a2 77 02         mov byte ptr [0x277], al
1000:07b5  8b 1e 25 8f      mov bx, word ptr [0x8f25]
1000:07b9  8a 07            mov al, byte ptr [bx]
1000:07bb  43               inc bx
1000:07bc  89 1e 25 8f      mov word ptr [0x8f25], bx
1000:07c0  b7 00            mov bh, 0
1000:07c2  8a d8            mov bl, al
1000:07c4  8a 87 1d 05      mov al, byte ptr [bx + 0x51d]
1000:07c8  a2 7e 02         mov byte ptr [0x27e], al
1000:07cb  8a 87 71 05      mov al, byte ptr [bx + 0x571]
1000:07cf  00 06 22 8f      add byte ptr [0x8f22], al
1000:07d3  8a 87 47 05      mov al, byte ptr [bx + 0x547]
1000:07d7  98               cwde 
1000:07d8  03 06 23 8f      add ax, word ptr [0x8f23]
1000:07dc  a3 7b 02         mov word ptr [0x27b], ax
1000:07df  83 fb 26         cmp bx, 0x26
1000:07e2  72 08            jb loc_107ec
1000:07e4  c7 06 81 02 02 00  mov word ptr [0x281], 2
1000:07ea  eb 06            jmp loc_107f2
                            loc_107ec:
1000:07ec  c7 06 81 02 04 00  mov word ptr [0x281], 4
                            loc_107f2:
1000:07f2  d1 e3            shl bx, 1
1000:07f4  8b 9f ef 05      mov bx, word ptr [bx + 0x5ef]
1000:07f8  89 1e 83 02      mov word ptr [0x283], bx
1000:07fc  c3               ret 
                            sub_107af ENDP
*/
void sub_107af()
{
    // coverage: 0x9af-0x9fd method sub_107af
    // coverage2: 1000:07af-1000:07fd method sub_107af // ins(0x07af, 0x07fd, 0x07af);
    al = memoryAGet(ds, 0x8f22);
    memoryASet(ds, 0x0277, al);
    bx = memoryAGet16(ds, 0x8f25);
    al = memoryAGet(ds, bx);
    bx++;
    memoryASet16(ds, 0x8f25, bx);
    bh = 0x00;
    bl = al;
    al = memoryAGet(ds, bx + 1309);
    memoryASet(ds, 0x027e, al);
    al = memoryAGet(ds, bx + 1393);
    memoryASet(ds, 0x8f22, memoryAGet(ds, 0x8f22) + al);
    al = memoryAGet(ds, bx + 1351);
    cbw();
    ax += memoryAGet16(ds, 0x8f23);
    memoryASet16(ds, 0x027b, ax);
    if (bx < 0x0026)
        goto loc_107ec;
    memoryASet16(ds, 0x0281, 0x0002);
    goto loc_107f2;
loc_107ec:
    memoryASet16(ds, 0x0281, 0x0004);
loc_107f2:
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 1519);
    memoryASet16(ds, 0x0283, bx);
}
/* Assembly listing of 1000:07fd sub_107fd()
                            sub_107fd PROC
1000:07fd  55               push bp
1000:07fe  8b ec            mov bp, sp
1000:0800  83 ec 08         sub sp, 8
1000:0803  8b 46 06         mov ax, word ptr [bp + 6]
1000:0806  05 10 00         add ax, 0x10
1000:0809  b1 18            mov cl, 0x18
1000:080b  f6 f1            div cl
1000:080d  50               push ax
1000:080e  b4 00            mov ah, 0
1000:0810  89 46 fe         mov word ptr [bp - 2], ax
1000:0813  58               pop ax
1000:0814  8a c4            mov al, ah
1000:0816  b4 00            mov ah, 0
1000:0818  b1 03            mov cl, 3
1000:081a  f6 f1            div cl
1000:081c  b4 00            mov ah, 0
1000:081e  89 46 fc         mov word ptr [bp - 4], ax
1000:0821  8b 46 04         mov ax, word ptr [bp + 4]
1000:0824  25 ff 03         and ax, 0x3ff
1000:0827  d1 e8            shr ax, 1
1000:0829  d1 e8            shr ax, 1
1000:082b  d1 e8            shr ax, 1
1000:082d  d1 e8            shr ax, 1
1000:082f  f7 d8            neg ax
1000:0831  05 3f 00         add ax, 0x3f
1000:0834  89 46 fa         mov word ptr [bp - 6], ax
1000:0837  8b 46 04         mov ax, word ptr [bp + 4]
1000:083a  25 0f 00         and ax, 0xf
1000:083d  d1 e8            shr ax, 1
1000:083f  89 46 f8         mov word ptr [bp - 8], ax
1000:0842  8b 46 fa         mov ax, word ptr [bp - 6]
1000:0845  d1 e0            shl ax, 1
1000:0847  d1 e0            shl ax, 1
1000:0849  8b d8            mov bx, ax
1000:084b  d1 e0            shl ax, 1
1000:084d  03 d8            add bx, ax
1000:084f  81 c3 29 8f      add bx, 0x8f29
1000:0853  8b f3            mov si, bx
1000:0855  03 5e fe         add bx, word ptr [bp - 2]
1000:0858  8a 07            mov al, byte ptr [bx]
1000:085a  b4 00            mov ah, 0
1000:085c  50               push ax
1000:085d  d1 e0            shl ax, 1
1000:085f  8b d8            mov bx, ax
1000:0861  8b 9f 43 06      mov bx, word ptr [bx + 0x643]
1000:0865  8b 46 f8         mov ax, word ptr [bp - 8]
1000:0868  d1 e0            shl ax, 1
1000:086a  d1 e0            shl ax, 1
1000:086c  d1 e0            shl ax, 1
1000:086e  03 d8            add bx, ax
1000:0870  03 5e fc         add bx, word ptr [bp - 4]
1000:0873  8a 0f            mov cl, byte ptr [bx]
1000:0875  51               push cx
1000:0876  80 e1 1f         and cl, 0x1f
1000:0879  f6 c1 10         test cl, 0x10
1000:087c  74 03            je loc_10881
1000:087e  80 c9 e0         or cl, 0xe0
                            loc_10881:
1000:0881  8b 56 fe         mov dx, word ptr [bp - 2]
1000:0884  fc               cld 
                            loc_10885:
1000:0885  83 fa 00         cmp dx, 0
1000:0888  74 0c            je loc_10896
1000:088a  ac               lodsb al, byte ptr [si]
1000:088b  b7 00            mov bh, 0
1000:088d  8a d8            mov bl, al
1000:088f  02 8f 71 05      add cl, byte ptr [bx + 0x571]
1000:0893  4a               dec dx
1000:0894  eb ef            jmp loc_10885
                            loc_10896:
1000:0896  8a c1            mov al, cl
1000:0898  98               cwde 
1000:0899  59               pop cx
1000:089a  5b               pop bx
1000:089b  f6 c1 80         test cl, 0x80
1000:089e  75 06            jne loc_108a6
1000:08a0  8a 9f 9b 05      mov bl, byte ptr [bx + 0x59b]
1000:08a4  eb 04            jmp loc_108aa
                            loc_108a6:
1000:08a6  8a 9f c5 05      mov bl, byte ptr [bx + 0x5c5]
                            loc_108aa:
1000:08aa  b7 00            mov bh, 0
1000:08ac  8b 4e fa         mov cx, word ptr [bp - 6]
1000:08af  f7 d9            neg cx
1000:08b1  83 c1 3f         add cx, 0x3f
1000:08b4  8b e5            mov sp, bp
1000:08b6  5d               pop bp
1000:08b7  c2 04 00         ret 4
                            sub_107fd ENDP
*/
void sub_107fd()
{
    // coverage: 0x9fd-0xaba method sub_107fd
    // coverage2: 1000:07fd-1000:08ba method sub_107fd // ins(0x07fd, 0x08ba, 0x07fd);
    push(bp);
    bp = sp;
    sp -= 0x0008;
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax += 0x0010;
    cl = 0x18;
    div(cl);
    push(ax);
    ah = 0x00;
    memoryASet16(ss, bp - 2 - 2, ax);
    ax = pop();
    al = ah;
    ah = 0x00;
    cl = 0x03;
    div(cl);
    ah = 0x00;
    memoryASet16(ss, bp - 4 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax &= 0x03ff;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax = -ax;
    ax += 0x003f;
    memoryASet16(ss, bp - 6 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax &= 0x000f;
    ax >>= 1;
    memoryASet16(ss, bp - 8 - 2, ax);
    ax = memoryAGet16(ss, bp - 6 - 2);
    ax <<= 1;
    ax <<= 1;
    bx = ax;
    ax <<= 1;
    bx += ax;
    bx += 0x8f29;
    si = bx;
    bx += memoryAGet16(ss, bp - 2 - 2);
    al = memoryAGet(ds, bx);
    ah = 0x00;
    push(ax);
    ax <<= 1;
    bx = ax;
    bx = memoryAGet16(ds, bx + 1603);
    ax = memoryAGet16(ss, bp - 8 - 2);
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    bx += ax;
    bx += memoryAGet16(ss, bp - 4 - 2);
    cl = memoryAGet(ds, bx);
    push(cx);
    cl &= 0x1f;
    if (!(cl & 0x10))
        goto loc_10881;
    cl |= 0xe0;
loc_10881:
    dx = memoryAGet16(ss, bp - 2 - 2);
    flags.direction = false;
loc_10885:
    if (dx == 0x0000)
        goto loc_10896;
    lodsb<MemAuto, DirAuto>();
    bh = 0x00;
    bl = al;
    cl += memoryAGet(ds, bx + 1393);
    dx--;
    goto loc_10885;
loc_10896:
    al = cl;
    cbw();
    cx = pop();
    bx = pop();
    if (cl & 0x80)
        goto loc_108a6;
    bl = memoryAGet(ds, bx + 1435);
    goto loc_108aa;
loc_108a6:
    bl = memoryAGet(ds, bx + 1477);
loc_108aa:
    bh = 0x00;
    cx = memoryAGet16(ss, bp - 6 - 2);
    cx = -cx;
    cx += 0x003f;
    sp = bp;
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:08ba sub_108ba()
                            sub_108ba PROC
1000:08ba  55               push bp
1000:08bb  8b ec            mov bp, sp
1000:08bd  8b 5e 04         mov bx, word ptr [bp + 4]
1000:08c0  d1 e3            shl bx, 1
1000:08c2  8b 87 29 92      mov ax, word ptr [bx - 0x6dd7]
1000:08c6  3d 00 00         cmp ax, 0
1000:08c9  74 7b            je loc_10946
1000:08cb  50               push ax
1000:08cc  d0 ec            shr ah, 1
1000:08ce  d0 ec            shr ah, 1
1000:08d0  8a dc            mov bl, ah
1000:08d2  b7 00            mov bh, 0
1000:08d4  d1 e3            shl bx, 1
1000:08d6  8b b7 8b 02      mov si, word ptr [bx + 0x28b]
1000:08da  80 fc 0f         cmp ah, 0xf
1000:08dd  72 23            jb loc_10902
1000:08df  80 fc 14         cmp ah, 0x14
1000:08e2  77 1e            ja loc_10902
1000:08e4  80 ec 0f         sub ah, 0xf
1000:08e7  88 64 01         mov byte ptr [si + 1], ah
1000:08ea  8a dc            mov bl, ah
1000:08ec  b7 00            mov bh, 0
1000:08ee  8a 87 2e 95      mov al, byte ptr [bx - 0x6ad2]
1000:08f2  3c 00            cmp al, 0
1000:08f4  74 03            je loc_108f9
1000:08f6  58               pop ax
1000:08f7  eb 4d            jmp loc_10946
                            loc_108f9:
1000:08f9  d1 e3            shl bx, 1
1000:08fb  8b 87 2e 03      mov ax, word ptr [bx + 0x32e]
1000:08ff  89 44 0f         mov word ptr [si + 0xf], ax
                            loc_10902:
1000:0902  c6 44 13 0a      mov byte ptr [si + 0x13], 0xa
1000:0906  8b 46 04         mov ax, word ptr [bp + 4]
1000:0909  88 44 14         mov byte ptr [si + 0x14], al
1000:090c  58               pop ax
1000:090d  b9 0a 00         mov cx, 0xa
                            loc_10910:
1000:0910  d1 e8            shr ax, 1
1000:0912  73 2d            jae loc_10941
1000:0914  50               push ax
1000:0915  51               push cx
1000:0916  e8 31 00         call 0x94a
1000:0919  8a 44 13         mov al, byte ptr [si + 0x13]
1000:091c  b4 00            mov ah, 0
1000:091e  50               push ax
1000:091f  8b 46 04         mov ax, word ptr [bp + 4]
1000:0922  50               push ax
1000:0923  e8 c3 00         call 0x9e9
1000:0926  3d 00 00         cmp ax, 0
1000:0929  74 07            je loc_10932
1000:092b  56               push si
1000:092c  e8 29 02         call 0xb58
1000:092f  5e               pop si
1000:0930  eb 0d            jmp loc_1093f
                            loc_10932:
1000:0932  56               push si
1000:0933  e8 22 02         call 0xb58
1000:0936  83 fe 00         cmp si, 0
1000:0939  74 03            je loc_1093e
1000:093b  e8 dd 00         call 0xa1b
                            loc_1093e:
1000:093e  5e               pop si
                            loc_1093f:
1000:093f  59               pop cx
1000:0940  58               pop ax
                            loc_10941:
1000:0941  fe 4c 13         dec byte ptr [si + 0x13]
1000:0944  e2 ca            loop loc_10910
                            loc_10946:
1000:0946  5d               pop bp
1000:0947  c2 02 00         ret 2
                            sub_108ba ENDP
*/
void sub_108ba()
{
    // coverage: 0xaba-0xb4a method sub_108ba
    // coverage2: 1000:08ba-1000:094a method sub_108ba // ins(0x08ba, 0x094a, 0x08ba);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 37417);
    if (ax == 0x0000)
        goto loc_10946;
    push(ax);
    ah >>= 1;
    ah >>= 1;
    bl = ah;
    bh = 0x00;
    bx <<= 1;
    si = memoryAGet16(ds, bx + 651);
    if (ah < 0x0f)
        goto loc_10902;
    if (ah > 0x14)
        goto loc_10902;
    ah -= 0x0f;
    memoryASet(ds, si + 1, ah);
    bl = ah;
    bh = 0x00;
    al = memoryAGet(ds, bx + 38190);
    if (al == 0x00)
        goto loc_108f9;
    ax = pop();
    goto loc_10946;
loc_108f9:
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 814);
    memoryASet16(ds, si + 15, ax);
loc_10902:
    memoryASet(ds, si + 19, 0x0a);
    ax = memoryAGet16(ss, bp + 4 - 2);
    memoryASet(ds, si + 20, al);
    ax = pop();
    cx = 0x000a;
loc_10910:
    flags.carry = ax & 1;
    ax >>= 1;
    if (!flags.carry)
        goto loc_10941;
    push(ax);
    push(cx);
    sub_1094a();
    al = memoryAGet(ds, si + 19);
    ah = 0x00;
    push(ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_109e9();
    if (ax == 0x0000)
        goto loc_10932;
    push(si);
    sub_10b58();
    si = pop();
    goto loc_1093f;
loc_10932:
    push(si);
    sub_10b58();
    if (si == 0x0000)
        goto loc_1093e;
    sub_10a1b();
loc_1093e:
    si = pop();
loc_1093f:
    cx = pop();
    ax = pop();
loc_10941:
    memoryASet(ds, si + 19, memoryAGet(ds, si + 19) - 1);
    if (--cx)
        goto loc_10910;
loc_10946:
    bp = pop();
    sp += 2;
}
/* Assembly listing of 1000:094a sub_1094a()
                            sub_1094a PROC
1000:094a  8a 54 13         mov dl, byte ptr [si + 0x13]
1000:094d  56               push si
1000:094e  b0 3f            mov al, 0x3f
1000:0950  2a 44 14         sub al, byte ptr [si + 0x14]
1000:0953  d0 e0            shl al, 1
1000:0955  d0 e0            shl al, 1
1000:0957  b4 00            mov ah, 0
1000:0959  8b f0            mov si, ax
1000:095b  d1 e0            shl ax, 1
1000:095d  03 f0            add si, ax
1000:095f  81 c6 29 8f      add si, 0x8f29
1000:0963  b1 00            mov cl, 0
1000:0965  fc               cld 
                            loc_10966:
1000:0966  80 fa 00         cmp dl, 0
1000:0969  74 0d            je loc_10978
1000:096b  ac               lodsb al, byte ptr [si]
1000:096c  b7 00            mov bh, 0
1000:096e  8a d8            mov bl, al
1000:0970  02 8f 71 05      add cl, byte ptr [bx + 0x571]
1000:0974  fe ca            dec dl
1000:0976  eb ee            jmp loc_10966
                            loc_10978:
1000:0978  5e               pop si
1000:0979  88 4c 03         mov byte ptr [si + 3], cl
1000:097c  8a 44 14         mov al, byte ptr [si + 0x14]
1000:097f  b4 00            mov ah, 0
1000:0981  d1 e0            shl ax, 1
1000:0983  d1 e0            shl ax, 1
1000:0985  d1 e0            shl ax, 1
1000:0987  d1 e0            shl ax, 1
1000:0989  89 44 07         mov word ptr [si + 7], ax
1000:098c  8a 44 13         mov al, byte ptr [si + 0x13]
1000:098f  b4 00            mov ah, 0
1000:0991  d1 e0            shl ax, 1
1000:0993  8b c8            mov cx, ax
1000:0995  d1 e0            shl ax, 1
1000:0997  03 c1            add ax, cx
1000:0999  d1 e0            shl ax, 1
1000:099b  d1 e0            shl ax, 1
1000:099d  2d 04 00         sub ax, 4
1000:09a0  89 44 05         mov word ptr [si + 5], ax
1000:09a3  c3               ret 
                            sub_1094a ENDP
*/
void sub_1094a()
{
    // coverage: 0xb4a-0xba4 method sub_1094a
    // coverage2: 1000:094a-1000:09a4 method sub_1094a // ins(0x094a, 0x09a4, 0x094a);
    dl = memoryAGet(ds, si + 19);
    push(si);
    al = 0x3f;
    al -= memoryAGet(ds, si + 20);
    al <<= 1;
    al <<= 1;
    ah = 0x00;
    si = ax;
    ax <<= 1;
    si += ax;
    si += 0x8f29;
    cl = 0x00;
    flags.direction = false;
loc_10966:
    if (dl == 0x00)
        goto loc_10978;
    lodsb<MemAuto, DirAuto>();
    bh = 0x00;
    bl = al;
    cl += memoryAGet(ds, bx + 1393);
    dl--;
    goto loc_10966;
loc_10978:
    si = pop();
    memoryASet(ds, si + 3, cl);
    al = memoryAGet(ds, si + 20);
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, si + 19);
    ah = 0x00;
    ax <<= 1;
    cx = ax;
    ax <<= 1;
    ax += cx;
    ax <<= 1;
    ax <<= 1;
    ax -= 0x0004;
    memoryASet16(ds, si + 5, ax);
}
/* Assembly listing of 1000:09a4 sub_109a4()
                            sub_109a4 PROC
1000:09a4  bf a9 92         mov di, 0x92a9
1000:09a7  b9 c0 00         mov cx, 0xc0
1000:09aa  8c d8            mov ax, ds
1000:09ac  8e c0            mov es, ax
1000:09ae  b8 ff ff         mov ax, 0xffff
1000:09b1  fc               cld 
1000:09b2  f3 ab            rep stosw word ptr es:[di], ax
1000:09b4  c3               ret 
                            sub_109a4 ENDP
*/
void sub_109a4()
{
    // coverage: 0xba4-0xbb5 method sub_109a4
    // coverage2: 1000:09a4-1000:09b5 method sub_109a4 // ins(0x09a4, 0x09b5, 0x09a4);
    di = 0x92a9;
    cx = 0x00c0;
    ax = ds;
    es = ax;
    ax = 0xffff;
    flags.direction = false;
    rep_stosw<MemAuto, DirAuto>();
}
/* Assembly listing of 1000:09b5 sub_109b5()
                            sub_109b5 PROC
1000:09b5  55               push bp
1000:09b6  8b ec            mov bp, sp
1000:09b8  8b 76 08         mov si, word ptr [bp + 8]
1000:09bb  e8 5d 00         call 0xa1b
1000:09be  8b 5e 06         mov bx, word ptr [bp + 6]
1000:09c1  d1 e3            shl bx, 1
1000:09c3  8b 8f eb 0c      mov cx, word ptr [bx + 0xceb]
1000:09c7  8b 5e 04         mov bx, word ptr [bp + 4]
1000:09ca  d1 e3            shl bx, 1
1000:09cc  a0 02 95         mov al, byte ptr [0x9502]
1000:09cf  3c 01            cmp al, 1
1000:09d1  75 06            jne loc_109d9
1000:09d3  81 c3 80 00      add bx, 0x80
1000:09d7  eb 08            jmp loc_109e1
                            loc_109d9:
1000:09d9  3c 02            cmp al, 2
1000:09db  75 04            jne loc_109e1
1000:09dd  81 c3 00 01      add bx, 0x100
                            loc_109e1:
1000:09e1  21 8f a9 92      and word ptr [bx - 0x6d57], cx
1000:09e5  5d               pop bp
1000:09e6  c2 06 00         ret 6
                            sub_109b5 ENDP
*/
void sub_109b5()
{
    // coverage: 0xbb5-0xbe9 method sub_109b5
    // coverage2: 1000:09b5-1000:09e9 method sub_109b5 // ins(0x09b5, 0x09e9, 0x09b5);
    push(bp);
    bp = sp;
    si = memoryAGet16(ss, bp + 8 - 2);
    sub_10a1b();
    bx = memoryAGet16(ss, bp + 6 - 2);
    bx <<= 1;
    cx = memoryAGet16(ds, bx + 3307);
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_109d9;
    bx += 0x0080;
    goto loc_109e1;
loc_109d9:
    if (al != 0x02)
        goto loc_109e1;
    bx += 0x0100;
loc_109e1:
    memoryASet16(ds, bx + 37545, memoryAGet16(ds, bx + 37545) & cx);
    bp = pop();
    sp += 6;
}
/* Assembly listing of 1000:09e9 sub_109e9()
                            sub_109e9 PROC
1000:09e9  55               push bp
1000:09ea  8b ec            mov bp, sp
1000:09ec  8b 5e 06         mov bx, word ptr [bp + 6]
1000:09ef  d1 e3            shl bx, 1
1000:09f1  8b 8f eb 0c      mov cx, word ptr [bx + 0xceb]
1000:09f5  8b 5e 04         mov bx, word ptr [bp + 4]
1000:09f8  d1 e3            shl bx, 1
1000:09fa  a0 02 95         mov al, byte ptr [0x9502]
1000:09fd  3c 01            cmp al, 1
1000:09ff  75 06            jne loc_10a07
1000:0a01  81 c3 80 00      add bx, 0x80
1000:0a05  eb 08            jmp loc_10a0f
                            loc_10a07:
1000:0a07  3c 02            cmp al, 2
1000:0a09  75 04            jne loc_10a0f
1000:0a0b  81 c3 00 01      add bx, 0x100
                            loc_10a0f:
1000:0a0f  f7 d1            not cx
1000:0a11  8b 87 a9 92      mov ax, word ptr [bx - 0x6d57]
1000:0a15  23 c1            and ax, cx
1000:0a17  5d               pop bp
1000:0a18  c2 04 00         ret 4
                            sub_109e9 ENDP
*/
void sub_109e9()
{
    // coverage: 0xbe9-0xc1b method sub_109e9
    // coverage2: 1000:09e9-1000:0a1b method sub_109e9 // ins(0x09e9, 0x0a1b, 0x09e9);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 6 - 2);
    bx <<= 1;
    cx = memoryAGet16(ds, bx + 3307);
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_10a07;
    bx += 0x0080;
    goto loc_10a0f;
loc_10a07:
    if (al != 0x02)
        goto loc_10a0f;
    bx += 0x0100;
loc_10a0f:
    cx = ~cx;
    ax = memoryAGet16(ds, bx + 37545);
    ax &= cx;
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:0a1b sub_10a1b()
                            sub_10a1b PROC
1000:0a1b  8a 44 12         mov al, byte ptr [si + 0x12]
1000:0a1e  d0 e0            shl al, 1
1000:0a20  8a d8            mov bl, al
1000:0a22  b7 00            mov bh, 0
1000:0a24  8b bf 1e 03      mov di, word ptr [bx + 0x31e]
1000:0a28  8a 05            mov al, byte ptr [di]
1000:0a2a  88 04            mov byte ptr [si], al
1000:0a2c  8a 45 09         mov al, byte ptr [di + 9]
1000:0a2f  88 44 09         mov byte ptr [si + 9], al
1000:0a32  8a 45 0a         mov al, byte ptr [di + 0xa]
1000:0a35  88 44 0a         mov byte ptr [si + 0xa], al
1000:0a38  8a 45 0b         mov al, byte ptr [di + 0xb]
1000:0a3b  88 44 0b         mov byte ptr [si + 0xb], al
1000:0a3e  8a 45 0c         mov al, byte ptr [di + 0xc]
1000:0a41  88 44 0c         mov byte ptr [si + 0xc], al
1000:0a44  8b 45 0f         mov ax, word ptr [di + 0xf]
1000:0a47  89 44 0f         mov word ptr [si + 0xf], ax
1000:0a4a  8a 45 12         mov al, byte ptr [di + 0x12]
1000:0a4d  88 44 12         mov byte ptr [si + 0x12], al
1000:0a50  c3               ret 
                            sub_10a1b ENDP
*/
void sub_10a1b()
{
    // coverage: 0xc1b-0xc51 method sub_10a1b
    // coverage2: 1000:0a1b-1000:0a51 method sub_10a1b // ins(0x0a1b, 0x0a51, 0x0a1b);
    al = memoryAGet(ds, si + 18);
    al <<= 1;
    bl = al;
    bh = 0x00;
    di = memoryAGet16(ds, bx + 798);
    al = memoryAGet(ds, di);
    memoryASet(ds, si, al);
    al = memoryAGet(ds, di + 9);
    memoryASet(ds, si + 9, al);
    al = memoryAGet(ds, di + 10);
    memoryASet(ds, si + 10, al);
    al = memoryAGet(ds, di + 11);
    memoryASet(ds, si + 11, al);
    al = memoryAGet(ds, di + 12);
    memoryASet(ds, si + 12, al);
    ax = memoryAGet16(ds, di + 15);
    memoryASet16(ds, si + 15, ax);
    al = memoryAGet(ds, di + 18);
    memoryASet(ds, si + 18, al);
}
/* Assembly listing of 1000:0a51 sub_10a51()
                            sub_10a51 PROC
1000:0a51  8a 1e 9e 1b      mov bl, byte ptr [0x1b9e]
1000:0a55  b7 00            mov bh, 0
1000:0a57  d1 e3            shl bx, 1
1000:0a59  8b f3            mov si, bx
1000:0a5b  a0 02 95         mov al, byte ptr [0x9502]
1000:0a5e  3c 01            cmp al, 1
1000:0a60  75 06            jne loc_10a68
1000:0a62  81 c6 80 00      add si, 0x80
1000:0a66  eb 08            jmp loc_10a70
                            loc_10a68:
1000:0a68  3c 02            cmp al, 2
1000:0a6a  75 04            jne loc_10a70
1000:0a6c  81 c6 00 01      add si, 0x100
                            loc_10a70:
1000:0a70  8b 84 a9 92      mov ax, word ptr [si - 0x6d57]
1000:0a74  23 87 29 92      and ax, word ptr [bx - 0x6dd7]
1000:0a78  3d 00 00         cmp ax, 0
1000:0a7b  74 54            je loc_10ad1
1000:0a7d  8a dc            mov bl, ah
1000:0a7f  d0 eb            shr bl, 1
1000:0a81  d0 eb            shr bl, 1
1000:0a83  b7 00            mov bh, 0
1000:0a85  8a 8f b5 02      mov cl, byte ptr [bx + 0x2b5]
1000:0a89  80 f9 00         cmp cl, 0
1000:0a8c  74 43            je loc_10ad1
1000:0a8e  88 0e 29 94      mov byte ptr [0x9429], cl
1000:0a92  c7 06 2c 94 0a 00  mov word ptr [0x942c], 0xa
1000:0a98  d1 e3            shl bx, 1
1000:0a9a  8b 97 ca 02      mov dx, word ptr [bx + 0x2ca]
1000:0a9e  8b 9f f4 02      mov bx, word ptr [bx + 0x2f4]
1000:0aa2  b9 0a 00         mov cx, 0xa
                            loc_10aa5:
1000:0aa5  d1 e8            shr ax, 1
1000:0aa7  73 1f            jae loc_10ac8
1000:0aa9  53               push bx
1000:0aaa  2b da            sub bx, dx
1000:0aac  3b 1e 8f 1b      cmp bx, word ptr [0x1b8f]
1000:0ab0  7f 15            jg loc_10ac7
1000:0ab2  03 da            add bx, dx
1000:0ab4  03 da            add bx, dx
1000:0ab6  3b 1e 8f 1b      cmp bx, word ptr [0x1b8f]
1000:0aba  7c 0b            jl loc_10ac7
1000:0abc  58               pop ax
1000:0abd  a0 29 94         mov al, byte ptr [0x9429]
1000:0ac0  b4 00            mov ah, 0
1000:0ac2  8b 1e 2c 94      mov bx, word ptr [0x942c]
1000:0ac6  c3               ret 
                            loc_10ac7:
1000:0ac7  5b               pop bx
                            loc_10ac8:
1000:0ac8  83 eb 18         sub bx, 0x18
1000:0acb  ff 0e 2c 94      dec word ptr [0x942c]
1000:0acf  e2 d4            loop loc_10aa5
                            loc_10ad1:
1000:0ad1  b8 00 00         mov ax, 0
1000:0ad4  c3               ret 
                            sub_10a51 ENDP
*/
void sub_10a51()
{
    // coverage: 0xc51-0xcd5 method sub_10a51
    // coverage2: 1000:0a51-1000:0ad5 method sub_10a51 // ins(0x0a51, 0x0ad5, 0x0a51);
    bl = memoryAGet(ds, 0x1b9e);
    bh = 0x00;
    bx <<= 1;
    si = bx;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_10a68;
    si += 0x0080;
    goto loc_10a70;
loc_10a68:
    if (al != 0x02)
        goto loc_10a70;
    si += 0x0100;
loc_10a70:
    ax = memoryAGet16(ds, si + 37545);
    ax &= memoryAGet16(ds, bx + 37417);
    if (ax == 0x0000)
        goto loc_10ad1;
    bl = ah;
    bl >>= 1;
    bl >>= 1;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 693);
    if (cl == 0x00)
        goto loc_10ad1;
    memoryASet(ds, 0x9429, cl);
    memoryASet16(ds, 0x942c, 0x000a);
    bx <<= 1;
    dx = memoryAGet16(ds, bx + 714);
    bx = memoryAGet16(ds, bx + 756);
    cx = 0x000a;
loc_10aa5:
    flags.carry = ax & 1;
    ax >>= 1;
    if (!flags.carry)
        goto loc_10ac8;
    push(bx);
    bx -= dx;
    if ((short)bx > (short)memoryAGet16(ds, 0x1b8f))
        goto loc_10ac7;
    bx += dx;
    bx += dx;
    if ((short)bx < (short)memoryAGet16(ds, 0x1b8f))
        goto loc_10ac7;
    ax = pop();
    al = memoryAGet(ds, 0x9429);
    ah = 0x00;
    bx = memoryAGet16(ds, 0x942c);
    return;
loc_10ac7:
    bx = pop();
loc_10ac8:
    bx -= 0x0018;
    memoryASet16(ds, 0x942c, memoryAGet16(ds, 0x942c) - 1);
    if (--cx)
        goto loc_10aa5;
loc_10ad1:
    ax = 0x0000;
}
/* Assembly listing of 1000:0ad5 sub_10ad5()
                            sub_10ad5 PROC
1000:0ad5  55               push bp
1000:0ad6  8b ec            mov bp, sp
1000:0ad8  8b 5e 04         mov bx, word ptr [bp + 4]
1000:0adb  d1 e3            shl bx, 1
1000:0add  8b f3            mov si, bx
1000:0adf  a0 02 95         mov al, byte ptr [0x9502]
1000:0ae2  3c 01            cmp al, 1
1000:0ae4  75 06            jne loc_10aec
1000:0ae6  81 c6 80 00      add si, 0x80
1000:0aea  eb 08            jmp loc_10af4
                            loc_10aec:
1000:0aec  3c 02            cmp al, 2
1000:0aee  75 04            jne loc_10af4
1000:0af0  81 c6 00 01      add si, 0x100
                            loc_10af4:
1000:0af4  8b 84 a9 92      mov ax, word ptr [si - 0x6d57]
1000:0af8  23 87 29 92      and ax, word ptr [bx - 0x6dd7]
1000:0afc  3d 00 00         cmp ax, 0
1000:0aff  74 50            je loc_10b51
1000:0b01  8a dc            mov bl, ah
1000:0b03  d0 eb            shr bl, 1
1000:0b05  d0 eb            shr bl, 1
1000:0b07  b7 00            mov bh, 0
1000:0b09  8a 8f b5 02      mov cl, byte ptr [bx + 0x2b5]
1000:0b0d  80 f9 00         cmp cl, 0
1000:0b10  74 3f            je loc_10b51
1000:0b12  c7 06 2c 94 0a 00  mov word ptr [0x942c], 0xa
1000:0b18  d1 e3            shl bx, 1
1000:0b1a  8b 97 ca 02      mov dx, word ptr [bx + 0x2ca]
1000:0b1e  83 ea 0e         sub dx, 0xe
1000:0b21  8b 9f f4 02      mov bx, word ptr [bx + 0x2f4]
1000:0b25  b9 0a 00         mov cx, 0xa
                            loc_10b28:
1000:0b28  d1 e8            shr ax, 1
1000:0b2a  73 1c            jae loc_10b48
1000:0b2c  53               push bx
1000:0b2d  2b da            sub bx, dx
1000:0b2f  3b 5e 06         cmp bx, word ptr [bp + 6]
1000:0b32  7f 13            jg loc_10b47
1000:0b34  03 da            add bx, dx
1000:0b36  03 da            add bx, dx
1000:0b38  3b 5e 06         cmp bx, word ptr [bp + 6]
1000:0b3b  7c 0a            jl loc_10b47
1000:0b3d  58               pop ax
1000:0b3e  b8 01 00         mov ax, 1
1000:0b41  8b 1e 2c 94      mov bx, word ptr [0x942c]
1000:0b45  eb 0d            jmp loc_10b54
                            loc_10b47:
1000:0b47  5b               pop bx
                            loc_10b48:
1000:0b48  83 eb 18         sub bx, 0x18
1000:0b4b  ff 0e 2c 94      dec word ptr [0x942c]
1000:0b4f  e2 d7            loop loc_10b28
                            loc_10b51:
1000:0b51  b8 00 00         mov ax, 0
                            loc_10b54:
1000:0b54  5d               pop bp
1000:0b55  c2 04 00         ret 4
                            sub_10ad5 ENDP
*/
void sub_10ad5()
{
    // coverage: 0xcd5-0xd58 method sub_10ad5
    // coverage2: 1000:0ad5-1000:0b58 method sub_10ad5 // ins(0x0ad5, 0x0b58, 0x0ad5);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx <<= 1;
    si = bx;
    al = memoryAGet(ds, 0x9502);
    if (al != 0x01)
        goto loc_10aec;
    si += 0x0080;
    goto loc_10af4;
loc_10aec:
    if (al != 0x02)
        goto loc_10af4;
    si += 0x0100;
loc_10af4:
    ax = memoryAGet16(ds, si + 37545);
    ax &= memoryAGet16(ds, bx + 37417);
    if (ax == 0x0000)
        goto loc_10b51;
    bl = ah;
    bl >>= 1;
    bl >>= 1;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 693);
    if (cl == 0x00)
        goto loc_10b51;
    memoryASet16(ds, 0x942c, 0x000a);
    bx <<= 1;
    dx = memoryAGet16(ds, bx + 714);
    dx -= 0x000e;
    bx = memoryAGet16(ds, bx + 756);
    cx = 0x000a;
loc_10b28:
    flags.carry = ax & 1;
    ax >>= 1;
    if (!flags.carry)
        goto loc_10b48;
    push(bx);
    bx -= dx;
    if ((short)bx > (short)memoryAGet16(ss, bp + 6 - 2))
        goto loc_10b47;
    bx += dx;
    bx += dx;
    if ((short)bx < (short)memoryAGet16(ss, bp + 6 - 2))
        goto loc_10b47;
    ax = pop();
    ax = 0x0001;
    bx = memoryAGet16(ds, 0x942c);
    goto loc_10b54;
loc_10b47:
    bx = pop();
loc_10b48:
    bx -= 0x0018;
    memoryASet16(ds, 0x942c, memoryAGet16(ds, 0x942c) - 1);
    if (--cx)
        goto loc_10b28;
loc_10b51:
    ax = 0x0000;
loc_10b54:
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:0b58 sub_10b58()
                            sub_10b58 PROC
1000:0b58  b8 a5 13         mov ax, 0x13a5
1000:0b5b  8e c0            mov es, ax
1000:0b5d  bf 8a 1b         mov di, 0x1b8a
                            loc_10b60:
1000:0b60  8a 05            mov al, byte ptr [di]
1000:0b62  a8 80            test al, 0x80
1000:0b64  75 12            jne loc_10b78
1000:0b66  a8 01            test al, 1
1000:0b68  75 09            jne loc_10b73
1000:0b6a  57               push di
1000:0b6b  b9 17 00         mov cx, 0x17
1000:0b6e  fc               cld 
1000:0b6f  f3 a4            rep movsb byte ptr es:[di], byte ptr [si]
1000:0b71  5e               pop si
1000:0b72  c3               ret 
                            loc_10b73:
1000:0b73  83 c7 17         add di, 0x17
1000:0b76  eb e8            jmp loc_10b60
                            loc_10b78:
1000:0b78  be 00 00         mov si, 0
1000:0b7b  c3               ret 
                            sub_10b58 ENDP
*/
void sub_10b58()
{
    // coverage: 0xd58-0xd7c method sub_10b58
    // coverage2: 1000:0b58-1000:0b7c method sub_10b58 // ins(0x0b58, 0x0b7c, 0x0b58);
    ax = 0x13a5;
    es = ax;
    di = 0x1b8a;
loc_10b60:
    al = memoryAGet(ds, di);
    if (al & 0x80)
        goto loc_10b78;
    if (al & 0x01)
        goto loc_10b73;
    push(di);
    cx = 0x0017;
    flags.direction = false;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    si = pop();
    return;
loc_10b73:
    di += 0x0017;
    goto loc_10b60;
loc_10b78:
    si = 0x0000;
}
/* Assembly listing of 1000:0b7c sub_10b7c()
                            sub_10b7c PROC
1000:0b7c  be 8a 1b         mov si, 0x1b8a
                            loc_10b7f:
1000:0b7f  8a 04            mov al, byte ptr [si]
1000:0b81  a8 80            test al, 0x80
1000:0b83  75 08            jne loc_10b8d
1000:0b85  c6 04 00         mov byte ptr [si], 0
1000:0b88  83 c6 17         add si, 0x17
1000:0b8b  eb f2            jmp loc_10b7f
                            loc_10b8d:
1000:0b8d  c3               ret 
                            sub_10b7c ENDP
*/
void sub_10b7c()
{
    // coverage: 0xd7c-0xd8e method sub_10b7c
    // coverage2: 1000:0b7c-1000:0b8e method sub_10b7c // ins(0x0b7c, 0x0b8e, 0x0b7c);
    si = 0x1b8a;
loc_10b7f:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        return;
    memoryASet(ds, si, 0x00);
    si += 0x0017;
    goto loc_10b7f;
}
/* Assembly listing of 1000:0b8e sub_10b8e()
                            sub_10b8e PROC
1000:0b8e  a1 f8 94         mov ax, word ptr [0x94f8]
1000:0b91  a3 2e 94         mov word ptr [0x942e], ax
1000:0b94  2e c7 06 93 0d 28 00  mov word ptr cs:[0xd93], 0x28
1000:0b9b  c7 06 30 94 01 00  mov word ptr [0x9430], 1
1000:0ba1  b9 07 00         mov cx, 7
                            loc_10ba4:
1000:0ba4  be 8a 1b         mov si, 0x1b8a
                            loc_10ba7:
1000:0ba7  8a 04            mov al, byte ptr [si]
1000:0ba9  a8 80            test al, 0x80
1000:0bab  75 15            jne loc_10bc2
1000:0bad  a8 01            test al, 1
1000:0baf  74 0c            je loc_10bbd
1000:0bb1  3a 4c 02         cmp cl, byte ptr [si + 2]
1000:0bb4  75 07            jne loc_10bbd
1000:0bb6  51               push cx
1000:0bb7  56               push si
1000:0bb8  e8 21 00         call 0xbdc
1000:0bbb  5e               pop si
1000:0bbc  59               pop cx
                            loc_10bbd:
1000:0bbd  83 c6 17         add si, 0x17
1000:0bc0  eb e5            jmp loc_10ba7
                            loc_10bc2:
1000:0bc2  e2 e0            loop loc_10ba4
1000:0bc4  c3               ret 
                            sub_10b8e ENDP
*/
void sub_10b8e()
{
    // coverage: 0xd8e-0xdc5 method sub_10b8e
    // coverage2: 1000:0b8e-1000:0bc5 method sub_10b8e // ins(0x0b8e, 0x0bc5, 0x0b8e);
    ax = memoryAGet16(ds, 0x94f8);
    memoryASet16(ds, 0x942e, ax);
    memoryASet16(cs, 0x0d93, 0x0028);
    memoryASet16(ds, 0x9430, 0x0001);
    cx = 0x0007;
loc_10ba4:
    si = 0x1b8a;
loc_10ba7:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_10bc2;
    if (!(al & 0x01))
        goto loc_10bbd;
    if (cl != memoryAGet(ds, si + 2))
        goto loc_10bbd;
    push(cx);
    push(si);
    sub_10bdc();
    si = pop();
    cx = pop();
loc_10bbd:
    si += 0x0017;
    goto loc_10ba7;
loc_10bc2:
    if (--cx)
        goto loc_10ba4;
}
/* Assembly listing of 1000:0bc5 sub_10bc5()
                            sub_10bc5 PROC
1000:0bc5  b8 00 a8         mov ax, 0xa800
1000:0bc8  a3 2e 94         mov word ptr [0x942e], ax
1000:0bcb  2e c7 06 93 0d 20 00  mov word ptr cs:[0xd93], 0x20
1000:0bd2  c7 06 30 94 00 00  mov word ptr [0x9430], 0
1000:0bd8  e8 01 00         call 0xbdc
1000:0bdb  c3               ret 
                            sub_10bc5 ENDP
*/
void sub_10bc5()
{
    // coverage: 0xdc5-0xddc method sub_10bc5
    // coverage2: 1000:0bc5-1000:0bdc method sub_10bc5 // ins(0x0bc5, 0x0bdc, 0x0bc5);
    ax = 0xa800;
    memoryASet16(ds, 0x942e, ax);
    memoryASet16(cs, 0x0d93, 0x0020);
    memoryASet16(ds, 0x9430, 0x0000);
    sub_10bdc();
}
/* Assembly listing of 1000:0bdc sub_10bdc()
                            sub_10bdc PROC
1000:0bdc  8a 44 0b         mov al, byte ptr [si + 0xb]
1000:0bdf  98               cwde 
1000:0be0  8b 5c 05         mov bx, word ptr [si + 5]
1000:0be3  2b d8            sub bx, ax
1000:0be5  53               push bx
1000:0be6  8a 44 03         mov al, byte ptr [si + 3]
1000:0be9  02 44 0c         add al, byte ptr [si + 0xc]
1000:0bec  98               cwde 
1000:0bed  f7 d8            neg ax
1000:0bef  03 44 07         add ax, word ptr [si + 7]
1000:0bf2  50               push ax
1000:0bf3  8a 44 09         mov al, byte ptr [si + 9]
1000:0bf6  b4 00            mov ah, 0
1000:0bf8  50               push ax
1000:0bf9  8a 44 0a         mov al, byte ptr [si + 0xa]
1000:0bfc  b4 00            mov ah, 0
1000:0bfe  50               push ax
1000:0bff  8b 5c 0d         mov bx, word ptr [si + 0xd]
1000:0c02  8b 9f e8 94      mov bx, word ptr [bx - 0x6b18]
1000:0c06  8a 44 11         mov al, byte ptr [si + 0x11]
1000:0c09  2e a2 95 0d      mov byte ptr cs:[0xd95], al
1000:0c0d  8a c8            mov cl, al
1000:0c0f  d0 e1            shl cl, 1
1000:0c11  d0 e1            shl cl, 1
1000:0c13  d0 e1            shl cl, 1
1000:0c15  d0 e1            shl cl, 1
1000:0c17  0a c1            or al, cl
1000:0c19  2e a2 96 0d      mov byte ptr cs:[0xd96], al
1000:0c1d  8b 74 0f         mov si, word ptr [si + 0xf]
1000:0c20  e8 01 00         call 0xc24
1000:0c23  c3               ret 
                            sub_10bdc ENDP
*/
void sub_10bdc()
{
    // coverage: 0xddc-0xe24 method sub_10bdc
    // coverage2: 1000:0bdc-1000:0c24 method sub_10bdc // ins(0x0bdc, 0x0c24, 0x0bdc);
    al = memoryAGet(ds, si + 11);
    cbw();
    bx = memoryAGet16(ds, si + 5);
    bx -= ax;
    push(bx);
    al = memoryAGet(ds, si + 3);
    al += memoryAGet(ds, si + 12);
    cbw();
    ax = -ax;
    ax += memoryAGet16(ds, si + 7);
    push(ax);
    al = memoryAGet(ds, si + 9);
    ah = 0x00;
    push(ax);
    al = memoryAGet(ds, si + 10);
    ah = 0x00;
    push(ax);
    bx = memoryAGet16(ds, si + 13);
    bx = memoryAGet16(ds, bx + 38120);
    al = memoryAGet(ds, si + 17);
    memoryASet(cs, 0x0d95, al);
    cl = al;
    cl <<= 1;
    cl <<= 1;
    cl <<= 1;
    cl <<= 1;
    al |= cl;
    memoryASet(cs, 0x0d96, al);
    si = memoryAGet16(ds, si + 15);
    sub_10c24();
}
/* Assembly listing of 1000:0c24 sub_10c24()
                            sub_10c24 PROC
1000:0c24  55               push bp
1000:0c25  8b ec            mov bp, sp
1000:0c27  a1 30 94         mov ax, word ptr [0x9430]
1000:0c2a  3d 00 00         cmp ax, 0
1000:0c2d  75 03            jne loc_10c32
1000:0c2f  e9 8a 00         jmp loc_10cbc
                            loc_10c32:
1000:0c32  8b 46 08         mov ax, word ptr [bp + 8]
1000:0c35  2b 06 28 95      sub ax, word ptr [0x9528]
1000:0c39  25 ff 03         and ax, 0x3ff
1000:0c3c  a9 00 02         test ax, 0x200
1000:0c3f  74 03            je loc_10c44
1000:0c41  0d 00 fc         or ax, 0xfc00
                            loc_10c44:
1000:0c44  89 46 08         mov word ptr [bp + 8], ax
1000:0c47  3d 00 00         cmp ax, 0
1000:0c4a  7d 2b            jge loc_10c77
1000:0c4c  01 46 04         add word ptr [bp + 4], ax
1000:0c4f  79 03            jns loc_10c54
1000:0c51  e9 3b 01         jmp loc_10d8f
                            loc_10c54:
1000:0c54  75 03            jne loc_10c59
1000:0c56  e9 36 01         jmp loc_10d8f
                            loc_10c59:
1000:0c59  f7 d8            neg ax
1000:0c5b  d1 e0            shl ax, 1
1000:0c5d  d1 e0            shl ax, 1
1000:0c5f  d1 e0            shl ax, 1
1000:0c61  8b c8            mov cx, ax
1000:0c63  d1 e0            shl ax, 1
1000:0c65  d1 e0            shl ax, 1
1000:0c67  03 c8            add cx, ax
1000:0c69  d1 e1            shl cx, 1
1000:0c6b  d1 e1            shl cx, 1
1000:0c6d  03 f1            add si, cx
1000:0c6f  b8 00 00         mov ax, 0
1000:0c72  89 46 08         mov word ptr [bp + 8], ax
1000:0c75  eb 18            jmp loc_10c8f
                            loc_10c77:
1000:0c77  03 46 04         add ax, word ptr [bp + 4]
1000:0c7a  2d a0 00         sub ax, 0xa0
1000:0c7d  78 10            js loc_10c8f
1000:0c7f  f7 d8            neg ax
1000:0c81  03 46 04         add ax, word ptr [bp + 4]
1000:0c84  3d 00 00         cmp ax, 0
1000:0c87  7f 03            jg loc_10c8c
1000:0c89  e9 03 01         jmp loc_10d8f
                            loc_10c8c:
1000:0c8c  89 46 04         mov word ptr [bp + 4], ax
                            loc_10c8f:
1000:0c8f  b8 20 00         mov ax, 0x20
1000:0c92  01 46 0a         add word ptr [bp + 0xa], ax
1000:0c95  b8 08 00         mov ax, 8
1000:0c98  01 46 08         add word ptr [bp + 8], ax
1000:0c9b  8b 46 0a         mov ax, word ptr [bp + 0xa]
1000:0c9e  3d 20 00         cmp ax, 0x20
1000:0ca1  7d 08            jge loc_10cab
1000:0ca3  b8 20 00         mov ax, 0x20
1000:0ca6  89 46 0a         mov word ptr [bp + 0xa], ax
1000:0ca9  eb 11            jmp loc_10cbc
                            loc_10cab:
1000:0cab  03 46 06         add ax, word ptr [bp + 6]
1000:0cae  3d 20 01         cmp ax, 0x120
1000:0cb1  7e 09            jle loc_10cbc
1000:0cb3  b8 20 01         mov ax, 0x120
1000:0cb6  2b 46 06         sub ax, word ptr [bp + 6]
1000:0cb9  89 46 0a         mov word ptr [bp + 0xa], ax
                            loc_10cbc:
1000:0cbc  1e               push ds
1000:0cbd  53               push bx
1000:0cbe  ba ce 03         mov dx, 0x3ce
1000:0cc1  b8 05 0a         mov ax, 0xa05
1000:0cc4  ef               out dx, ax
1000:0cc5  b8 07 00         mov ax, 7
1000:0cc8  ef               out dx, ax
1000:0cc9  8b 46 0a         mov ax, word ptr [bp + 0xa]
1000:0ccc  8b 5e 08         mov bx, word ptr [bp + 8]
1000:0ccf  51               push cx
1000:0cd0  d1 e3            shl bx, 1
1000:0cd2  d1 e3            shl bx, 1
1000:0cd4  d1 e3            shl bx, 1
1000:0cd6  2e 8b 0e 93 0d   mov cx, word ptr cs:[0xd93]
1000:0cdb  83 f9 28         cmp cx, 0x28
1000:0cde  75 04            jne loc_10ce4
1000:0ce0  8b fb            mov di, bx
1000:0ce2  eb 03            jmp loc_10ce7
                            loc_10ce4:
1000:0ce4  bf 00 00         mov di, 0
                            loc_10ce7:
1000:0ce7  d1 e3            shl bx, 1
1000:0ce9  d1 e3            shl bx, 1
1000:0ceb  03 fb            add di, bx
1000:0ced  8a c8            mov cl, al
1000:0cef  d1 e8            shr ax, 1
1000:0cf1  d1 e8            shr ax, 1
1000:0cf3  d1 e8            shr ax, 1
1000:0cf5  03 f8            add di, ax
1000:0cf7  80 e1 07         and cl, 7
1000:0cfa  b8 80 00         mov ax, 0x80
1000:0cfd  d3 e8            shr ax, cl
1000:0cff  8a e0            mov ah, al
1000:0d01  8b 1e 2e 94      mov bx, word ptr [0x942e]
1000:0d05  8e c3            mov es, bx
1000:0d07  59               pop cx
1000:0d08  8b 4e 06         mov cx, word ptr [bp + 6]
1000:0d0b  d1 e9            shr cx, 1
1000:0d0d  b0 08            mov al, 8
1000:0d0f  1f               pop ds
1000:0d10  8b 5e 04         mov bx, word ptr [bp + 4]
                            loc_10d13:
1000:0d13  50               push ax
1000:0d14  53               push bx
1000:0d15  51               push cx
1000:0d16  57               push di
1000:0d17  56               push si
                            loc_10d18:
1000:0d18  2e 8a 3e 96 0d   mov bh, byte ptr cs:[0xd96]
                            loc_10d1d:
1000:0d1d  8a 1c            mov bl, byte ptr [si]
1000:0d1f  46               inc si
1000:0d20  3a fb            cmp bh, bl
1000:0d22  75 16            jne loc_10d3a
1000:0d24  d0 ec            shr ah, 1
1000:0d26  75 07            jne loc_10d2f
1000:0d28  b4 40            mov ah, 0x40
1000:0d2a  47               inc di
1000:0d2b  e2 f0            loop loc_10d1d
1000:0d2d  eb 3e            jmp loc_10d6d
                            loc_10d2f:
1000:0d2f  d0 ec            shr ah, 1
1000:0d31  75 03            jne loc_10d36
1000:0d33  b4 80            mov ah, 0x80
1000:0d35  47               inc di
                            loc_10d36:
1000:0d36  e2 e5            loop loc_10d1d
1000:0d38  eb 33            jmp loc_10d6d
                            loc_10d3a:
1000:0d3a  8a fb            mov bh, bl
1000:0d3c  d0 eb            shr bl, 1
1000:0d3e  d0 eb            shr bl, 1
1000:0d40  d0 eb            shr bl, 1
1000:0d42  d0 eb            shr bl, 1
1000:0d44  2e 3a 1e 95 0d   cmp bl, byte ptr cs:[0xd95]
1000:0d49  74 04            je loc_10d4f
1000:0d4b  ef               out dx, ax
1000:0d4c  26 20 1d         and byte ptr es:[di], bl
                            loc_10d4f:
1000:0d4f  d0 ec            shr ah, 1
1000:0d51  75 03            jne loc_10d56
1000:0d53  b4 80            mov ah, 0x80
1000:0d55  47               inc di
                            loc_10d56:
1000:0d56  80 e7 0f         and bh, 0xf
1000:0d59  2e 3a 3e 95 0d   cmp bh, byte ptr cs:[0xd95]
1000:0d5e  74 04            je loc_10d64
1000:0d60  ef               out dx, ax
1000:0d61  26 20 3d         and byte ptr es:[di], bh
                            loc_10d64:
1000:0d64  d0 ec            shr ah, 1
1000:0d66  75 03            jne loc_10d6b
1000:0d68  b4 80            mov ah, 0x80
1000:0d6a  47               inc di
                            loc_10d6b:
1000:0d6b  e2 ab            loop loc_10d18
                            loc_10d6d:
1000:0d6d  5e               pop si
1000:0d6e  81 c6 a0 00      add si, 0xa0
1000:0d72  5f               pop di
1000:0d73  2e 03 3e 93 0d   add di, word ptr cs:[0xd93]
1000:0d78  81 e7 ff 7f      and di, 0x7fff
1000:0d7c  59               pop cx
1000:0d7d  5b               pop bx
1000:0d7e  58               pop ax
1000:0d7f  4b               dec bx
1000:0d80  75 91            jne loc_10d13
1000:0d82  1f               pop ds
1000:0d83  b8 08 ff         mov ax, 0xff08
1000:0d86  ef               out dx, ax
1000:0d87  b8 05 00         mov ax, 5
1000:0d8a  ef               out dx, ax
1000:0d8b  b8 07 0f         mov ax, 0xf07
1000:0d8e  ef               out dx, ax
                            loc_10d8f:
1000:0d8f  5d               pop bp
1000:0d90  c2 08 00         ret 8
                            sub_10c24 ENDP
*/
void sub_10c24()
{
    // coverage: 0xe24-0xf93 method sub_10c24
    // coverage2: 1000:0c24-1000:0d93 method sub_10c24 // ins(0x0c24, 0x0d93, 0x0c24);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ds, 0x9430);
    if (ax != 0x0000)
        goto loc_10c32;
    goto loc_10cbc;
loc_10c32:
    ax = memoryAGet16(ss, bp + 8 - 2);
    ax -= memoryAGet16(ds, 0x9528);
    ax &= 0x03ff;
    if (!(ax & 0x0200))
        goto loc_10c44;
    ax |= 0xfc00;
loc_10c44:
    memoryASet16(ss, bp + 8 - 2, ax);
    if ((short)ax >= (short)0x0000)
        goto loc_10c77;
    memoryASet16(ss, bp + 4 - 2, memoryAGet16(ss, bp + 4 - 2) + ax);
    if ((short)memoryAGet16(ss, bp + 4 - 2) >= 0)
        goto loc_10c54;
    goto loc_10d8f;
loc_10c54:
    if (memoryAGet16(ss, bp + 4 - 2) != 0)
        goto loc_10c59;
    goto loc_10d8f;
loc_10c59:
    ax = -ax;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    cx = ax;
    ax <<= 1;
    ax <<= 1;
    cx += ax;
    cx <<= 1;
    cx <<= 1;
    si += cx;
    ax = 0x0000;
    memoryASet16(ss, bp + 8 - 2, ax);
    goto loc_10c8f;
loc_10c77:
    ax += memoryAGet16(ss, bp + 4 - 2);
    ax -= 0x00a0;
    if ((short)ax < 0)
        goto loc_10c8f;
    ax = -ax;
    ax += memoryAGet16(ss, bp + 4 - 2);
    if ((short)ax > (short)0x0000)
        goto loc_10c8c;
    goto loc_10d8f;
loc_10c8c:
    memoryASet16(ss, bp + 4 - 2, ax);
loc_10c8f:
    ax = 0x0020;
    memoryASet16(ss, bp + 10 - 2, memoryAGet16(ss, bp + 10 - 2) + ax);
    ax = 0x0008;
    memoryASet16(ss, bp + 8 - 2, memoryAGet16(ss, bp + 8 - 2) + ax);
    ax = memoryAGet16(ss, bp + 10 - 2);
    if ((short)ax >= (short)0x0020)
        goto loc_10cab;
    ax = 0x0020;
    memoryASet16(ss, bp + 10 - 2, ax);
    goto loc_10cbc;
loc_10cab:
    ax += memoryAGet16(ss, bp + 6 - 2);
    if ((short)ax <= (short)0x0120)
        goto loc_10cbc;
    ax = 0x0120;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    memoryASet16(ss, bp + 10 - 2, ax);
loc_10cbc:
    push(ds);
    push(bx);
    dx = 0x03ce;
    ax = 0x0a05;
    out(dx, ax);
    ax = 0x0007;
    out(dx, ax);
    ax = memoryAGet16(ss, bp + 10 - 2);
    bx = memoryAGet16(ss, bp + 8 - 2);
    push(cx);
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    cx = memoryAGet16(cs, 0x0d93);
    if (cx != 0x0028)
        goto loc_10ce4;
    di = bx;
    goto loc_10ce7;
loc_10ce4:
    di = 0x0000;
loc_10ce7:
    bx <<= 1;
    bx <<= 1;
    di += bx;
    cl = al;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    di += ax;
    cl &= 0x07;
    ax = 0x0080;
    ax >>= cl;
    ah = al;
    bx = memoryAGet16(ds, 0x942e);
    es = bx;
    cx = pop();
    cx = memoryAGet16(ss, bp + 6 - 2);
    cx >>= 1;
    al = 0x08;
    ds = pop();
    bx = memoryAGet16(ss, bp + 4 - 2);
loc_10d13:
    push(ax);
    push(bx);
    push(cx);
    push(di);
    push(si);
loc_10d18:
    bh = memoryAGet(cs, 0x0d96);
loc_10d1d:
    bl = memoryAGet(ds, si);
    si++;
    if (bh != bl)
        goto loc_10d3a;
    ah >>= 1;
    if (ah != 0)
        goto loc_10d2f;
    ah = 0x40;
    di++;
    if (--cx)
        goto loc_10d1d;
    goto loc_10d6d;
loc_10d2f:
    ah >>= 1;
    if (ah != 0)
        goto loc_10d36;
    ah = 0x80;
    di++;
loc_10d36:
    if (--cx)
        goto loc_10d1d;
    goto loc_10d6d;
loc_10d3a:
    bh = bl;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    if (bl == memoryAGet(cs, 0x0d95))
        goto loc_10d4f;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bl);
loc_10d4f:
    ah >>= 1;
    if (ah != 0)
        goto loc_10d56;
    ah = 0x80;
    di++;
loc_10d56:
    bh &= 0x0f;
    if (bh == memoryAGet(cs, 0x0d95))
        goto loc_10d64;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bh);
loc_10d64:
    ah >>= 1;
    if (ah != 0)
        goto loc_10d6b;
    ah = 0x80;
    di++;
loc_10d6b:
    if (--cx)
        goto loc_10d18;
loc_10d6d:
    si = pop();
    si += 0x00a0;
    di = pop();
    di += memoryAGet16(cs, 0x0d93);
    di &= 0x7fff;
    cx = pop();
    bx = pop();
    ax = pop();
    bx--;
    if (bx != 0)
        goto loc_10d13;
    ds = pop();
    ax = 0xff08;
    out(dx, ax);
    ax = 0x0005;
    out(dx, ax);
    ax = 0x0f07;
    out(dx, ax);
loc_10d8f:
    bp = pop();
    sp += 8;
}
/* Assembly listing of 1000:0d98 sub_10d98()
                            sub_10d98 PROC
1000:0d98  c7 06 28 95 1a 00  mov word ptr [0x9528], 0x1a
1000:0d9e  c6 06 13 95 00   mov byte ptr [0x9513], 0
1000:0da3  e8 d6 fd         call 0xb7c
1000:0da6  c3               ret 
                            sub_10d98 ENDP
*/
void sub_10d98()
{
    // coverage: 0xf98-0xfa7 method sub_10d98
    // coverage2: 1000:0d98-1000:0da7 method sub_10d98 // ins(0x0d98, 0x0da7, 0x0d98);
    memoryASet16(ds, 0x9528, 0x001a);
    memoryASet(ds, 0x9513, 0x00);
    sub_10b7c();
}
/* Assembly listing of 1000:0da7 sub_10da7()
                            sub_10da7 PROC
1000:0da7  e8 fa fb         call 0x9a4
1000:0daa  e8 ed f8         call 0x69a
1000:0dad  c6 06 19 95 00   mov byte ptr [0x9519], 0
1000:0db2  c6 06 1a 95 00   mov byte ptr [0x951a], 0
1000:0db7  c6 06 1b 95 00   mov byte ptr [0x951b], 0
1000:0dbc  e8 7e 00         call 0xe3d
1000:0dbf  c3               ret 
                            sub_10da7 ENDP
*/
void sub_10da7()
{
    // coverage: 0xfa7-0xfc0 method sub_10da7
    // coverage2: 1000:0da7-1000:0dc0 method sub_10da7 // ins(0x0da7, 0x0dc0, 0x0da7);
    sub_109a4();
    sub_1069a();
    memoryASet(ds, 0x9519, 0x00);
    memoryASet(ds, 0x951a, 0x00);
    memoryASet(ds, 0x951b, 0x00);
    sub_10e3d();
}
/* Assembly listing of 1000:0dc0 sub_10dc0()
                            sub_10dc0 PROC
1000:0dc0  fe 06 fe 94      inc byte ptr [0x94fe]
1000:0dc4  a0 fe 94         mov al, byte ptr [0x94fe]
1000:0dc7  3c 06            cmp al, 6
1000:0dc9  72 08            jb loc_10dd3
1000:0dcb  c7 06 fc 94 30 00  mov word ptr [0x94fc], 0x30
1000:0dd1  eb 12            jmp loc_10de5
                            loc_10dd3:
1000:0dd3  3c 03            cmp al, 3
1000:0dd5  72 08            jb loc_10ddf
1000:0dd7  c7 06 fc 94 20 00  mov word ptr [0x94fc], 0x20
1000:0ddd  eb 06            jmp loc_10de5
                            loc_10ddf:
1000:0ddf  c7 06 fc 94 10 00  mov word ptr [0x94fc], 0x10
                            loc_10de5:
1000:0de5  fe 06 01 95      inc byte ptr [0x9501]
1000:0de9  a0 01 95         mov al, byte ptr [0x9501]
1000:0dec  3c 07            cmp al, 7
1000:0dee  76 05            jbe loc_10df5
1000:0df0  c6 06 01 95 01   mov byte ptr [0x9501], 1
                            loc_10df5:
1000:0df5  e8 ac fb         call 0x9a4
1000:0df8  e8 9f f8         call 0x69a
1000:0dfb  c6 06 19 95 00   mov byte ptr [0x9519], 0
1000:0e00  e8 3a 00         call 0xe3d
1000:0e03  e8 79 1c         call 0x2a7f
1000:0e06  c3               ret 
                            sub_10dc0 ENDP
*/
void sub_10dc0()
{
    // coverage: 0xfc0-0x1007 method sub_10dc0
    // coverage2: 1000:0dc0-1000:0e07 method sub_10dc0 // ins(0x0dc0, 0x0e07, 0x0dc0);
    memoryASet(ds, 0x94fe, memoryAGet(ds, 0x94fe) + 1);
    al = memoryAGet(ds, 0x94fe);
    if (al < 0x06)
        goto loc_10dd3;
    memoryASet16(ds, 0x94fc, 0x0030);
    goto loc_10de5;
loc_10dd3:
    if (al < 0x03)
        goto loc_10ddf;
    memoryASet16(ds, 0x94fc, 0x0020);
    goto loc_10de5;
loc_10ddf:
    memoryASet16(ds, 0x94fc, 0x0010);
loc_10de5:
    memoryASet(ds, 0x9501, memoryAGet(ds, 0x9501) + 1);
    al = memoryAGet(ds, 0x9501);
    if (al <= 0x07)
        goto loc_10df5;
    memoryASet(ds, 0x9501, 0x01);
loc_10df5:
    sub_109a4();
    sub_1069a();
    memoryASet(ds, 0x9519, 0x00);
    sub_10e3d();
    sub_12a7f();
}
/* Assembly listing of 1000:0e07 sub_10e07()
                            sub_10e07 PROC
1000:0e07  a1 34 95         mov ax, word ptr [0x9534]
1000:0e0a  3d 00 00         cmp ax, 0
1000:0e0d  75 06            jne loc_10e15
1000:0e0f  c6 06 00 95 01   mov byte ptr [0x9500], 1
1000:0e14  c3               ret 
                            loc_10e15:
1000:0e15  e8 11 15         call 0x2329
1000:0e18  a0 02 95         mov al, byte ptr [0x9502]
1000:0e1b  3c 00            cmp al, 0
1000:0e1d  74 08            je loc_10e27
1000:0e1f  c6 06 02 95 00   mov byte ptr [0x9502], 0
1000:0e24  e8 73 f8         call 0x69a
                            loc_10e27:
1000:0e27  e8 d6 13         call 0x2200
1000:0e2a  c6 06 19 95 01   mov byte ptr [0x9519], 1
1000:0e2f  c6 06 1a 95 00   mov byte ptr [0x951a], 0
1000:0e34  c6 06 1b 95 00   mov byte ptr [0x951b], 0
1000:0e39  e8 01 00         call 0xe3d
1000:0e3c  c3               ret 
                            sub_10e07 ENDP
*/
void sub_10e07()
{
    // coverage: 0x1007-0x103d method sub_10e07
    // coverage2: 1000:0e07-1000:0e3d method sub_10e07 // ins(0x0e07, 0x0e3d, 0x0e07);
    ax = memoryAGet16(ds, 0x9534);
    if (ax != 0x0000)
        goto loc_10e15;
    memoryASet(ds, 0x9500, 0x01);
    return;
loc_10e15:
    sub_12329();
    al = memoryAGet(ds, 0x9502);
    if (al == 0x00)
        goto loc_10e27;
    memoryASet(ds, 0x9502, 0x00);
    sub_1069a();
loc_10e27:
    sub_12200();
    memoryASet(ds, 0x9519, 0x01);
    memoryASet(ds, 0x951a, 0x00);
    memoryASet(ds, 0x951b, 0x00);
    sub_10e3d();
}
/* Assembly listing of 1000:0e3d sub_10e3d()
                            sub_10e3d PROC
1000:0e3d  8a 1e 01 95      mov bl, byte ptr [0x9501]
1000:0e41  b7 00            mov bh, 0
1000:0e43  d1 e3            shl bx, 1
1000:0e45  8b 87 f5 14      mov ax, word ptr [bx + 0x14f5]
1000:0e49  25 ff 03         and ax, 0x3ff
1000:0e4c  a3 28 95         mov word ptr [0x9528], ax
1000:0e4f  a1 fc 94         mov ax, word ptr [0x94fc]
1000:0e52  a3 2a 95         mov word ptr [0x952a], ax
1000:0e55  c7 06 0a 95 80 00  mov word ptr [0x950a], 0x80
1000:0e5b  c6 06 0e 95 00   mov byte ptr [0x950e], 0
1000:0e60  c7 06 0f 95 00 00  mov word ptr [0x950f], 0
1000:0e66  c7 06 11 95 00 00  mov word ptr [0x9511], 0
1000:0e6c  c6 06 13 95 00   mov byte ptr [0x9513], 0
1000:0e71  c6 06 15 95 00   mov byte ptr [0x9515], 0
1000:0e76  c6 06 17 95 00   mov byte ptr [0x9517], 0
1000:0e7b  c6 06 32 94 00   mov byte ptr [0x9432], 0
1000:0e80  e8 01 00         call 0xe84
1000:0e83  c3               ret 
                            sub_10e3d ENDP
*/
void sub_10e3d()
{
    // coverage: 0x103d-0x1084 method sub_10e3d
    // coverage2: 1000:0e3d-1000:0e84 method sub_10e3d // ins(0x0e3d, 0x0e84, 0x0e3d);
    bl = memoryAGet(ds, 0x9501);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5365);
    ax &= 0x03ff;
    memoryASet16(ds, 0x9528, ax);
    ax = memoryAGet16(ds, 0x94fc);
    memoryASet16(ds, 0x952a, ax);
    memoryASet16(ds, 0x950a, 0x0080);
    memoryASet(ds, 0x950e, 0x00);
    memoryASet16(ds, 0x950f, 0x0000);
    memoryASet16(ds, 0x9511, 0x0000);
    memoryASet(ds, 0x9513, 0x00);
    memoryASet(ds, 0x9515, 0x00);
    memoryASet(ds, 0x9517, 0x00);
    memoryASet(ds, 0x9432, 0x00);
    sub_10e84();
}
/* Assembly listing of 1000:0e84 sub_10e84()
                            sub_10e84 PROC
1000:0e84  a0 0e 95         mov al, byte ptr [0x950e]
1000:0e87  3c 00            cmp al, 0
1000:0e89  74 08            je loc_10e93
1000:0e8b  c6 06 0e 95 00   mov byte ptr [0x950e], 0
1000:0e90  e8 07 f8         call 0x69a
                            loc_10e93:
1000:0e93  c7 06 2c 95 00 00  mov word ptr [0x952c], 0
1000:0e99  e8 e0 fc         call 0xb7c
1000:0e9c  be 32 0d         mov si, 0xd32
1000:0e9f  e8 b6 fc         call 0xb58
1000:0ea2  a1 0a 95         mov ax, word ptr [0x950a]
1000:0ea5  a3 8f 1b         mov word ptr [0x1b8f], ax
1000:0ea8  e8 ac 0c         call 0x1b57
1000:0eab  a1 28 95         mov ax, word ptr [0x9528]
1000:0eae  d1 e8            shr ax, 1
1000:0eb0  d1 e8            shr ax, 1
1000:0eb2  d1 e8            shr ax, 1
1000:0eb4  d1 e8            shr ax, 1
1000:0eb6  2d 03 00         sub ax, 3
1000:0eb9  25 3f 00         and ax, 0x3f
1000:0ebc  a3 07 95         mov word ptr [0x9507], ax
1000:0ebf  b9 0f 00         mov cx, 0xf
                            loc_10ec2:
1000:0ec2  51               push cx
1000:0ec3  50               push ax
1000:0ec4  50               push ax
1000:0ec5  e8 f2 f9         call 0x8ba
1000:0ec8  58               pop ax
1000:0ec9  59               pop cx
1000:0eca  40               inc ax
1000:0ecb  25 3f 00         and ax, 0x3f
1000:0ece  e2 f2            loop loc_10ec2
1000:0ed0  a0 32 94         mov al, byte ptr [0x9432]
1000:0ed3  3c 00            cmp al, 0
1000:0ed5  74 13            je loc_10eea
1000:0ed7  be 8a 1b         mov si, 0x1b8a
1000:0eda  bb 49 0d         mov bx, 0xd49
1000:0edd  c6 44 04 0a      mov byte ptr [si + 4], 0xa
1000:0ee1  e8 3d 12         call 0x2121
1000:0ee4  c6 06 9c 1b 23   mov byte ptr [0x1b9c], 0x23
1000:0ee9  c3               ret 
                            loc_10eea:
1000:0eea  a0 19 95         mov al, byte ptr [0x9519]
1000:0eed  3c 00            cmp al, 0
1000:0eef  74 17            je loc_10f08
1000:0ef1  c6 06 19 95 00   mov byte ptr [0x9519], 0
1000:0ef6  be a2 0d         mov si, 0xda2
1000:0ef9  a1 91 1b         mov ax, word ptr [0x1b91]
1000:0efc  89 44 07         mov word ptr [si + 7], ax
1000:0eff  a0 8d 1b         mov al, byte ptr [0x1b8d]
1000:0f02  88 44 03         mov byte ptr [si + 3], al
1000:0f05  e8 50 fc         call 0xb58
                            loc_10f08:
1000:0f08  e8 92 00         call 0xf9d
1000:0f0b  a0 1a 95         mov al, byte ptr [0x951a]
1000:0f0e  3c 00            cmp al, 0
1000:0f10  74 11            je loc_10f23
1000:0f12  c6 06 1a 95 01   mov byte ptr [0x951a], 1
1000:0f17  be c3 0d         mov si, 0xdc3
1000:0f1a  80 24 df         and byte ptr [si], 0xdf
1000:0f1d  e8 b9 0d         call 0x1cd9
1000:0f20  e8 35 fc         call 0xb58
                            loc_10f23:
1000:0f23  a0 1b 95         mov al, byte ptr [0x951b]
1000:0f26  3c 00            cmp al, 0
1000:0f28  74 11            je loc_10f3b
1000:0f2a  c6 06 1b 95 01   mov byte ptr [0x951b], 1
1000:0f2f  be c3 0d         mov si, 0xdc3
1000:0f32  80 0c 20         or byte ptr [si], 0x20
1000:0f35  e8 a1 0d         call 0x1cd9
1000:0f38  e8 1d fc         call 0xb58
                            loc_10f3b:
1000:0f3b  c3               ret 
                            sub_10e84 ENDP
*/
void sub_10e84()
{
    // coverage: 0x1084-0x113c method sub_10e84
    // coverage2: 1000:0e84-1000:0f3c method sub_10e84 // ins(0x0e84, 0x0f3c, 0x0e84);
    al = memoryAGet(ds, 0x950e);
    if (al == 0x00)
        goto loc_10e93;
    memoryASet(ds, 0x950e, 0x00);
    sub_1069a();
loc_10e93:
    memoryASet16(ds, 0x952c, 0x0000);
    sub_10b7c();
    si = 0x0d32;
    sub_10b58();
    ax = memoryAGet16(ds, 0x950a);
    memoryASet16(ds, 0x1b8f, ax);
    sub_11b57();
    ax = memoryAGet16(ds, 0x9528);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax -= 0x0003;
    ax &= 0x003f;
    memoryASet16(ds, 0x9507, ax);
    cx = 0x000f;
loc_10ec2:
    push(cx);
    push(ax);
    push(ax);
    sub_108ba();
    ax = pop();
    cx = pop();
    ax++;
    ax &= 0x003f;
    if (--cx)
        goto loc_10ec2;
    al = memoryAGet(ds, 0x9432);
    if (al == 0x00)
        goto loc_10eea;
    si = 0x1b8a;
    bx = 0x0d49;
    memoryASet(ds, si + 4, 0x0a);
    sub_12121();
    memoryASet(ds, 0x1b9c, 0x23);
    return;
loc_10eea:
    al = memoryAGet(ds, 0x9519);
    if (al == 0x00)
        goto loc_10f08;
    memoryASet(ds, 0x9519, 0x00);
    si = 0x0da2;
    ax = memoryAGet16(ds, 0x1b91);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1b8d);
    memoryASet(ds, si + 3, al);
    sub_10b58();
loc_10f08:
    sub_10f9d();
    al = memoryAGet(ds, 0x951a);
    if (al == 0x00)
        goto loc_10f23;
    memoryASet(ds, 0x951a, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    sub_11cd9();
    sub_10b58();
loc_10f23:
    al = memoryAGet(ds, 0x951b);
    if (al == 0x00)
        return;
    memoryASet(ds, 0x951b, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    sub_11cd9();
    sub_10b58();
}
/* Assembly listing of 1000:0f3c sub_10f3c()
                            sub_10f3c PROC
1000:0f3c  c6 06 1c 95 00   mov byte ptr [0x951c], 0
1000:0f41  e8 98 1e         call 0x2ddc
1000:0f44  c7 06 28 95 1a 00  mov word ptr [0x9528], 0x1a
1000:0f4a  c7 06 47 95 00 00  mov word ptr [0x9547], 0
1000:0f50  c7 06 1e 95 00 00  mov word ptr [0x951e], 0
1000:0f56  c6 06 24 95 00   mov byte ptr [0x9524], 0
1000:0f5b  c6 06 49 95 03   mov byte ptr [0x9549], 3
1000:0f60  e8 19 fc         call 0xb7c
1000:0f63  be 04 0d         mov si, 0xd04
1000:0f66  e8 ef fb         call 0xb58
1000:0f69  e8 8a 1e         call 0x2df6
1000:0f6c  a0 1a 95         mov al, byte ptr [0x951a]
1000:0f6f  3c 00            cmp al, 0
1000:0f71  74 11            je loc_10f84
1000:0f73  c6 06 1a 95 01   mov byte ptr [0x951a], 1
1000:0f78  be 1b 0d         mov si, 0xd1b
1000:0f7b  80 24 df         and byte ptr [si], 0xdf
1000:0f7e  e8 cf 1f         call 0x2f50
1000:0f81  e8 d4 fb         call 0xb58
                            loc_10f84:
1000:0f84  a0 1b 95         mov al, byte ptr [0x951b]
1000:0f87  3c 00            cmp al, 0
1000:0f89  74 11            je loc_10f9c
1000:0f8b  c6 06 1b 95 01   mov byte ptr [0x951b], 1
1000:0f90  be 1b 0d         mov si, 0xd1b
1000:0f93  80 0c 20         or byte ptr [si], 0x20
1000:0f96  e8 b7 1f         call 0x2f50
1000:0f99  e8 bc fb         call 0xb58
                            loc_10f9c:
1000:0f9c  c3               ret 
                            sub_10f3c ENDP
*/
void sub_10f3c()
{
    // coverage: 0x113c-0x119d method sub_10f3c
    // coverage2: 1000:0f3c-1000:0f9d method sub_10f3c // ins(0x0f3c, 0x0f9d, 0x0f3c);
    memoryASet(ds, 0x951c, 0x00);
    sub_12ddc();
    memoryASet16(ds, 0x9528, 0x001a);
    memoryASet16(ds, 0x9547, 0x0000);
    memoryASet16(ds, 0x951e, 0x0000);
    memoryASet(ds, 0x9524, 0x00);
    memoryASet(ds, 0x9549, 0x03);
    sub_10b7c();
    si = 0x0d04;
    sub_10b58();
    sub_12df6();
    al = memoryAGet(ds, 0x951a);
    if (al == 0x00)
        goto loc_10f84;
    memoryASet(ds, 0x951a, 0x01);
    si = 0x0d1b;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    sub_12f50();
    sub_10b58();
loc_10f84:
    al = memoryAGet(ds, 0x951b);
    if (al == 0x00)
        return;
    memoryASet(ds, 0x951b, 0x01);
    si = 0x0d1b;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    sub_12f50();
    sub_10b58();
}
/* Assembly listing of 1000:0f9d sub_10f9d()
                            sub_10f9d PROC
1000:0f9d  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:0fa0  a3 33 94         mov word ptr [0x9433], ax
1000:0fa3  a3 35 94         mov word ptr [0x9435], ax
1000:0fa6  a3 37 94         mov word ptr [0x9437], ax
1000:0fa9  a3 39 94         mov word ptr [0x9439], ax
1000:0fac  a1 91 1b         mov ax, word ptr [0x1b91]
1000:0faf  a3 3b 94         mov word ptr [0x943b], ax
1000:0fb2  a3 3d 94         mov word ptr [0x943d], ax
1000:0fb5  a3 3f 94         mov word ptr [0x943f], ax
1000:0fb8  a3 41 94         mov word ptr [0x9441], ax
1000:0fbb  a0 8e 1b         mov al, byte ptr [0x1b8e]
1000:0fbe  a2 43 94         mov byte ptr [0x9443], al
1000:0fc1  a2 44 94         mov byte ptr [0x9444], al
1000:0fc4  a2 45 94         mov byte ptr [0x9445], al
1000:0fc7  a2 46 94         mov byte ptr [0x9446], al
1000:0fca  a0 8d 1b         mov al, byte ptr [0x1b8d]
1000:0fcd  a2 47 94         mov byte ptr [0x9447], al
1000:0fd0  a2 48 94         mov byte ptr [0x9448], al
1000:0fd3  a2 49 94         mov byte ptr [0x9449], al
1000:0fd6  a2 4a 94         mov byte ptr [0x944a], al
1000:0fd9  c3               ret 
                            sub_10f9d ENDP
*/
void sub_10f9d()
{
    // coverage: 0x119d-0x11da method sub_10f9d
    // coverage2: 1000:0f9d-1000:0fda method sub_10f9d // ins(0x0f9d, 0x0fda, 0x0f9d);
    ax = memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, 0x9433, ax);
    memoryASet16(ds, 0x9435, ax);
    memoryASet16(ds, 0x9437, ax);
    memoryASet16(ds, 0x9439, ax);
    ax = memoryAGet16(ds, 0x1b91);
    memoryASet16(ds, 0x943b, ax);
    memoryASet16(ds, 0x943d, ax);
    memoryASet16(ds, 0x943f, ax);
    memoryASet16(ds, 0x9441, ax);
    al = memoryAGet(ds, 0x1b8e);
    memoryASet(ds, 0x9443, al);
    memoryASet(ds, 0x9444, al);
    memoryASet(ds, 0x9445, al);
    memoryASet(ds, 0x9446, al);
    al = memoryAGet(ds, 0x1b8d);
    memoryASet(ds, 0x9447, al);
    memoryASet(ds, 0x9448, al);
    memoryASet(ds, 0x9449, al);
    memoryASet(ds, 0x944a, al);
}
/* Assembly listing of 1000:0fda sub_10fda()
                            sub_10fda PROC
                            loc_10fda:
1000:0fda  a0 ff 94         mov al, byte ptr [0x94ff]
1000:0fdd  a2 09 95         mov byte ptr [0x9509], al
1000:0fe0  be 8a 1b         mov si, 0x1b8a
                            loc_10fe3:
1000:0fe3  a0 13 95         mov al, byte ptr [0x9513]
1000:0fe6  3c 00            cmp al, 0
1000:0fe8  74 0b            je loc_10ff5
1000:0fea  e8 1a fe         call 0xe07
1000:0fed  a0 00 95         mov al, byte ptr [0x9500]
1000:0ff0  3c 00            cmp al, 0
1000:0ff2  74 e6            je loc_10fda
1000:0ff4  c3               ret 
                            loc_10ff5:
1000:0ff5  a0 ff 94         mov al, byte ptr [0x94ff]
1000:0ff8  3a 06 09 95      cmp al, byte ptr [0x9509]
1000:0ffc  74 38            je loc_11036
1000:0ffe  3c 01            cmp al, 1
1000:1000  75 0c            jne loc_1100e
1000:1002  b0 0b            mov al, 0xb
1000:1004  e8 39 28         call 0x3840
1000:1007  e8 32 ff         call 0xf3c
1000:100a  eb ce            jmp loc_10fda
1000:100c                    
                            loc_1100e:
1000:100e  b0 0b            mov al, 0xb
1000:1010  e8 2d 28         call 0x3840
1000:1013  a0 1d 95         mov al, byte ptr [0x951d]
1000:1016  3c f0            cmp al, 0xf0
1000:1018  75 05            jne loc_1101f
1000:101a  e8 a3 fd         call 0xdc0
1000:101d  eb 15            jmp loc_11034
                            loc_1101f:
1000:101f  a0 a0 1b         mov al, byte ptr [0x1ba0]
1000:1022  24 7f            and al, 0x7f
1000:1024  3c 28            cmp al, 0x28
1000:1026  76 09            jbe loc_11031
1000:1028  3c 58            cmp al, 0x58
1000:102a  73 05            jae loc_11031
1000:102c  c6 06 32 94 01   mov byte ptr [0x9432], 1
                            loc_11031:
1000:1031  e8 50 fe         call 0xe84
                            loc_11034:
1000:1034  eb a4            jmp loc_10fda
                            loc_11036:
1000:1036  8a 04            mov al, byte ptr [si]
1000:1038  a8 80            test al, 0x80
1000:103a  75 1d            jne loc_11059
1000:103c  a8 02            test al, 2
1000:103e  74 14            je loc_11054
1000:1040  56               push si
1000:1041  8a 5c 12         mov bl, byte ptr [si + 0x12]
1000:1044  80 fb 00         cmp bl, 0
1000:1047  74 0a            je loc_11053
1000:1049  b7 00            mov bh, 0
1000:104b  4b               dec bx
1000:104c  d1 e3            shl bx, 1
1000:104e  2e ff 97 5a 10   call word ptr cs:[bx + 0x105a]
                            loc_11053:
1000:1053  5e               pop si
                            loc_11054:
1000:1054  83 c6 17         add si, 0x17
1000:1057  eb 8a            jmp loc_10fe3
                            loc_11059:
1000:1059  c3               ret 
                            sub_10fda ENDP
*/
void sub_10fda()
{
    // coverage: 0x11da-0x120c method sub_10fda
    // coverage2: 1000:0fda-1000:100c method sub_10fda // ins(0x0fda, 0x100c, 0x0fda);
    // coverage: 0x120e-0x125a method sub_10fda
    // coverage2: 1000:100e-1000:105a method sub_10fda // ins(0x100e, 0x105a, 0x0fda);
loc_10fda:
    al = memoryAGet(ds, 0x94ff);
    memoryASet(ds, 0x9509, al);
    si = 0x1b8a;
loc_10fe3:
    al = memoryAGet(ds, 0x9513);
    if (al == 0x00)
        goto loc_10ff5;
    sub_10e07();
    al = memoryAGet(ds, 0x9500);
    if (al == 0x00)
        goto loc_10fda;
    return;
loc_10ff5:
    al = memoryAGet(ds, 0x94ff);
    if (al == memoryAGet(ds, 0x9509))
        goto loc_11036;
    if (al != 0x01)
        goto loc_1100e;
    al = 0x0b;
    sub_13840();
    sub_10f3c();
    goto loc_10fda;
    //   gap of 2 bytes
loc_1100e:
    al = 0x0b;
    sub_13840();
    al = memoryAGet(ds, 0x951d);
    if (al != 0xf0)
        goto loc_1101f;
    sub_10dc0();
    goto loc_11034;
loc_1101f:
    al = memoryAGet(ds, 0x1ba0);
    al &= 0x7f;
    if (al <= 0x28)
        goto loc_11031;
    if (al >= 0x58)
        goto loc_11031;
    memoryASet(ds, 0x9432, 0x01);
loc_11031:
    sub_10e84();
loc_11034:
    goto loc_10fda;
loc_11036:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        return;
    if (!(al & 0x02))
        goto loc_11054;
    push(si);
    bl = memoryAGet(ds, si + 18);
    if (bl == 0x00)
        goto loc_11053;
    bh = 0x00;
    bx--;
    bx <<= 1;
    switch (bx)
    {
        // coverage: 0x125a-0x129e switch sw_1105a
        case 0: sub_11108(); break;
        case 2: sub_1176c(); break;
        case 4: sub_11783(); break;
        case 6: sub_110c6(); break;
        case 8: sub_117ac(); break;
        case 10: sub_117d6(); break;
        case 12: sub_118a9(); break;
        case 14: sub_11a9e(); break;
        case 16: sub_110c6(); break;
        case 18: sub_11993(); break;
        case 20: sub_119c2(); break;
        case 22: sub_12e02(); break;
        case 24: sub_110c6(); break;
        case 26: sub_12fe8(); break;
        case 28: sub_1300a(); break;
        case 30: sub_116fe(); break;
        case 32: sub_112cb(); break;
        case 34: sub_110c6(); break;
        case 36: sub_112eb(); break;
        case 38: sub_115fc(); break;
        case 40: sub_116df(); break;
        case 42: sub_116d6(); break;
        case 44: sub_11740(); break;
        case 46: sub_11384(); break;
        case 48: sub_113a8(); break;
        case 50: sub_114f0(); break;
        case 52: sub_110f3(); break;
        case 54: sub_118c7(); break;
        case 56: sub_11429(); break;
        case 58: sub_117f4(); break;
        case 60: sub_1171f(); break;
        case 62: sub_11b09(); break;
        case 64: sub_11b4a(); break;
        case 66: sub_12f50(); break;
        case 68: sub_112a7(); break;
        default:
        assert(0);
    }
loc_11053:
    si = pop();
loc_11054:
    si += 0x0017;
    goto loc_10fe3;
}
/* Assembly listing of 1000:10a0 sub_110a0()
                            sub_110a0 PROC
1000:10a0  8a 44 0a         mov al, byte ptr [si + 0xa]
1000:10a3  2a 44 03         sub al, byte ptr [si + 3]
1000:10a6  2a 44 0c         sub al, byte ptr [si + 0xc]
1000:10a9  98               cwde 
1000:10aa  03 44 07         add ax, word ptr [si + 7]
1000:10ad  25 ff 03         and ax, 0x3ff
1000:10b0  8b 1e 28 95      mov bx, word ptr [0x9528]
1000:10b4  3b c3            cmp ax, bx
1000:10b6  73 03            jae loc_110bb
1000:10b8  05 00 04         add ax, 0x400
                            loc_110bb:
1000:10bb  2b c3            sub ax, bx
1000:10bd  3d 00 02         cmp ax, 0x200
1000:10c0  76 03            jbe loc_110c5
1000:10c2  c6 04 00         mov byte ptr [si], 0
                            loc_110c5:
1000:10c5  c3               ret 
                            sub_110a0 ENDP
*/
void sub_110a0()
{
    // coverage: 0x12a0-0x12c6 method sub_110a0
    // coverage2: 1000:10a0-1000:10c6 method sub_110a0 // ins(0x10a0, 0x10c6, 0x10a0);
    al = memoryAGet(ds, si + 10);
    al -= memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, si + 12);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    bx = memoryAGet16(ds, 0x9528);
    if (ax >= bx)
        goto loc_110bb;
    ax += 0x0400;
loc_110bb:
    ax -= bx;
    if (ax <= 0x0200)
        return;
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:10c6 sub_110c6()
                            sub_110c6 PROC
1000:10c6  8a 44 03         mov al, byte ptr [si + 3]
1000:10c9  02 44 0c         add al, byte ptr [si + 0xc]
1000:10cc  98               cwde 
1000:10cd  f7 d8            neg ax
1000:10cf  03 44 07         add ax, word ptr [si + 7]
1000:10d2  25 ff 03         and ax, 0x3ff
1000:10d5  8b 1e 28 95      mov bx, word ptr [0x9528]
1000:10d9  81 c3 a0 00      add bx, 0xa0
1000:10dd  81 e3 ff 03      and bx, 0x3ff
1000:10e1  3b c3            cmp ax, bx
1000:10e3  73 03            jae loc_110e8
1000:10e5  05 00 04         add ax, 0x400
                            loc_110e8:
1000:10e8  2b c3            sub ax, bx
1000:10ea  3d 00 02         cmp ax, 0x200
1000:10ed  73 03            jae loc_110f2
1000:10ef  c6 04 00         mov byte ptr [si], 0
                            loc_110f2:
1000:10f2  c3               ret 
                            sub_110c6 ENDP
*/
void sub_110c6()
{
    // coverage: 0x12c6-0x12f3 method sub_110c6
    // coverage2: 1000:10c6-1000:10f3 method sub_110c6 // ins(0x10c6, 0x10f3, 0x10c6);
    al = memoryAGet(ds, si + 3);
    al += memoryAGet(ds, si + 12);
    cbw();
    ax = -ax;
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    bx = memoryAGet16(ds, 0x9528);
    bx += 0x00a0;
    bx &= 0x03ff;
    if (ax >= bx)
        goto loc_110e8;
    ax += 0x0400;
loc_110e8:
    ax -= bx;
    if (ax >= 0x0200)
        return;
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:10f3 sub_110f3()
                            sub_110f3 PROC
1000:10f3  fe 44 16         inc byte ptr [si + 0x16]
1000:10f6  8a 44 16         mov al, byte ptr [si + 0x16]
1000:10f9  3c 08            cmp al, 8
1000:10fb  76 02            jbe loc_110ff
1000:10fd  b0 08            mov al, 8
                            loc_110ff:
1000:10ff  b4 00            mov ah, 0
1000:1101  29 44 07         sub word ptr [si + 7], ax
1000:1104  e8 99 ff         call 0x10a0
1000:1107  c3               ret 
                            sub_110f3 ENDP
*/
void sub_110f3()
{
    // coverage: 0x12f3-0x1308 method sub_110f3
    // coverage2: 1000:10f3-1000:1108 method sub_110f3 // ins(0x10f3, 0x1108, 0x10f3);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    if (al <= 0x08)
        goto loc_110ff;
    al = 0x08;
loc_110ff:
    ah = 0x00;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - ax);
    sub_110a0();
}
/* Assembly listing of 1000:1108 sub_11108()
                            sub_11108 PROC
1000:1108  e8 75 0a         call 0x1b80
1000:110b  e8 ab 0a         call 0x1bb9
1000:110e  8b 1e 4c 95      mov bx, word ptr [0x954c]
1000:1112  a1 2c 95         mov ax, word ptr [0x952c]
1000:1115  f6 c3 01         test bl, 1
1000:1118  74 17            je loc_11131
1000:111a  2d 01 00         sub ax, 1
1000:111d  78 08            js loc_11127
1000:111f  3d 04 00         cmp ax, 4
1000:1122  7e 03            jle loc_11127
1000:1124  b8 04 00         mov ax, 4
                            loc_11127:
1000:1127  3d e8 ff         cmp ax, 0xffe8
1000:112a  7d 03            jge loc_1112f
1000:112c  b8 e8 ff         mov ax, 0xffe8
                            loc_1112f:
1000:112f  eb 27            jmp loc_11158
                            loc_11131:
1000:1131  f6 c3 02         test bl, 2
1000:1134  74 17            je loc_1114d
1000:1136  05 01 00         add ax, 1
1000:1139  79 08            jns loc_11143
1000:113b  3d fc ff         cmp ax, 0xfffc
1000:113e  7d 03            jge loc_11143
1000:1140  b8 fc ff         mov ax, 0xfffc
                            loc_11143:
1000:1143  3d 18 00         cmp ax, 0x18
1000:1146  7e 03            jle loc_1114b
1000:1148  b8 18 00         mov ax, 0x18
                            loc_1114b:
1000:114b  eb 0b            jmp loc_11158
                            loc_1114d:
1000:114d  3d 00 00         cmp ax, 0
1000:1150  74 06            je loc_11158
1000:1152  7e 03            jle loc_11157
1000:1154  48               dec ax
1000:1155  eb 01            jmp loc_11158
                            loc_11157:
1000:1157  40               inc ax
                            loc_11158:
1000:1158  a3 2c 95         mov word ptr [0x952c], ax
1000:115b  05 03 00         add ax, 3
1000:115e  d1 f8            sar ax, 1
1000:1160  d1 f8            sar ax, 1
1000:1162  03 06 8f 1b      add ax, word ptr [0x1b8f]
1000:1166  3d 14 00         cmp ax, 0x14
1000:1169  7d 09            jge loc_11174
1000:116b  b8 14 00         mov ax, 0x14
1000:116e  c7 06 2c 95 00 00  mov word ptr [0x952c], 0
                            loc_11174:
1000:1174  3d ec 00         cmp ax, 0xec
1000:1177  7e 09            jle loc_11182
1000:1179  b8 ec 00         mov ax, 0xec
1000:117c  c7 06 2c 95 00 00  mov word ptr [0x952c], 0
                            loc_11182:
1000:1182  a3 8f 1b         mov word ptr [0x1b8f], ax
1000:1185  a0 8e 1b         mov al, byte ptr [0x1b8e]
1000:1188  3c 00            cmp al, 0
1000:118a  74 03            je loc_1118f
1000:118c  e8 c8 09         call 0x1b57
                            loc_1118f:
1000:118f  e8 e6 0a         call 0x1c78
1000:1192  e8 bc f8         call 0xa51
1000:1195  3d 00 00         cmp ax, 0
1000:1198  74 05            je loc_1119f
1000:119a  e8 b9 0a         call 0x1c56
1000:119d  eb 1d            jmp loc_111bc
                            loc_1119f:
1000:119f  fe 06 9e 1b      inc byte ptr [0x1b9e]
1000:11a3  80 26 9e 1b 3f   and byte ptr [0x1b9e], 0x3f
1000:11a8  e8 a6 f8         call 0xa51
1000:11ab  3d 00 00         cmp ax, 0
1000:11ae  74 03            je loc_111b3
1000:11b0  e8 a3 0a         call 0x1c56
                            loc_111b3:
1000:11b3  fe 0e 9e 1b      dec byte ptr [0x1b9e]
1000:11b7  80 26 9e 1b 3f   and byte ptr [0x1b9e], 0x3f
                            loc_111bc:
1000:11bc  a1 42 95         mov ax, word ptr [0x9542]
1000:11bf  3d 00 00         cmp ax, 0
1000:11c2  7f 04            jg loc_111c8
1000:11c4  e8 6c 0a         call 0x1c33
1000:11c7  c3               ret 
                            loc_111c8:
1000:11c8  a0 8e 1b         mov al, byte ptr [0x1b8e]
1000:11cb  3c 00            cmp al, 0
1000:11cd  75 0f            jne loc_111de
1000:11cf  fe 06 15 95      inc byte ptr [0x9515]
1000:11d3  a0 15 95         mov al, byte ptr [0x9515]
1000:11d6  3c 04            cmp al, 4
1000:11d8  72 03            jb loc_111dd
1000:11da  e8 56 0a         call 0x1c33
                            loc_111dd:
1000:11dd  c3               ret 
                            loc_111de:
1000:11de  a1 3e 95         mov ax, word ptr [0x953e]
1000:11e1  3d 00 00         cmp ax, 0
1000:11e4  7e 0a            jle loc_111f0
1000:11e6  a1 4c 95         mov ax, word ptr [0x954c]
1000:11e9  a8 80            test al, 0x80
1000:11eb  74 03            je loc_111f0
1000:11ed  e8 2e 0b         call 0x1d1e
                            loc_111f0:
1000:11f0  a1 4c 95         mov ax, word ptr [0x954c]
1000:11f3  8a 1e 1a 95      mov bl, byte ptr [0x951a]
1000:11f7  a8 40            test al, 0x40
1000:11f9  74 3a            je loc_11235
1000:11fb  80 fb 00         cmp bl, 0
1000:11fe  75 24            jne loc_11224
1000:1200  a1 36 95         mov ax, word ptr [0x9536]
1000:1203  3d 00 00         cmp ax, 0
1000:1206  76 1a            jbe loc_11222
1000:1208  c6 06 1a 95 01   mov byte ptr [0x951a], 1
1000:120d  be c3 0d         mov si, 0xdc3
1000:1210  80 24 df         and byte ptr [si], 0xdf
1000:1213  e8 c3 0a         call 0x1cd9
1000:1216  e8 3f f9         call 0xb58
1000:1219  ff 0e 38 95      dec word ptr [0x9538]
1000:121d  b0 01            mov al, 1
1000:121f  e8 1e 26         call 0x3840
                            loc_11222:
1000:1222  eb 0f            jmp loc_11233
                            loc_11224:
1000:1224  80 fb 02         cmp bl, 2
1000:1227  75 0a            jne loc_11233
1000:1229  c6 06 1a 95 03   mov byte ptr [0x951a], 3
1000:122e  b0 02            mov al, 2
1000:1230  e8 0d 26         call 0x3840
                            loc_11233:
1000:1233  eb 16            jmp loc_1124b
                            loc_11235:
1000:1235  80 fb 01         cmp bl, 1
1000:1238  75 07            jne loc_11241
1000:123a  c6 06 1a 95 02   mov byte ptr [0x951a], 2
1000:123f  eb 0a            jmp loc_1124b
                            loc_11241:
1000:1241  80 fb 03         cmp bl, 3
1000:1244  75 05            jne loc_1124b
1000:1246  c6 06 1a 95 00   mov byte ptr [0x951a], 0
                            loc_1124b:
1000:124b  a1 4c 95         mov ax, word ptr [0x954c]
1000:124e  8a 1e 1b 95      mov bl, byte ptr [0x951b]
1000:1252  a8 20            test al, 0x20
1000:1254  74 3a            je loc_11290
1000:1256  80 fb 00         cmp bl, 0
1000:1259  75 24            jne loc_1127f
1000:125b  a1 36 95         mov ax, word ptr [0x9536]
1000:125e  3d 00 00         cmp ax, 0
1000:1261  76 1a            jbe loc_1127d
1000:1263  c6 06 1b 95 01   mov byte ptr [0x951b], 1
1000:1268  be c3 0d         mov si, 0xdc3
1000:126b  80 0c 20         or byte ptr [si], 0x20
1000:126e  e8 68 0a         call 0x1cd9
1000:1271  e8 e4 f8         call 0xb58
1000:1274  ff 0e 38 95      dec word ptr [0x9538]
1000:1278  b0 01            mov al, 1
1000:127a  e8 c3 25         call 0x3840
                            loc_1127d:
1000:127d  eb 0f            jmp loc_1128e
                            loc_1127f:
1000:127f  80 fb 02         cmp bl, 2
1000:1282  75 0a            jne loc_1128e
1000:1284  c6 06 1b 95 03   mov byte ptr [0x951b], 3
1000:1289  b0 02            mov al, 2
1000:128b  e8 b2 25         call 0x3840
                            loc_1128e:
1000:128e  eb 16            jmp loc_112a6
                            loc_11290:
1000:1290  80 fb 01         cmp bl, 1
1000:1293  75 07            jne loc_1129c
1000:1295  c6 06 1b 95 02   mov byte ptr [0x951b], 2
1000:129a  eb 0a            jmp loc_112a6
                            loc_1129c:
1000:129c  80 fb 03         cmp bl, 3
1000:129f  75 05            jne loc_112a6
1000:12a1  c6 06 1b 95 00   mov byte ptr [0x951b], 0
                            loc_112a6:
1000:12a6  c3               ret 
                            sub_11108 ENDP
*/
void sub_11108()
{
    // coverage: 0x1308-0x14a7 method sub_11108
    // coverage2: 1000:1108-1000:12a7 method sub_11108 // ins(0x1108, 0x12a7, 0x1108);
    sub_11b80();
    sub_11bb9();
    bx = memoryAGet16(ds, 0x954c);
    ax = memoryAGet16(ds, 0x952c);
    if (!(bl & 0x01))
        goto loc_11131;
    ax -= 0x0001;
    if ((short)ax < 0)
        goto loc_11127;
    if ((short)ax <= (short)0x0004)
        goto loc_11127;
    ax = 0x0004;
loc_11127:
    if ((short)ax >= (short)0xffe8)
        goto loc_1112f;
    ax = 0xffe8;
loc_1112f:
    goto loc_11158;
loc_11131:
    if (!(bl & 0x02))
        goto loc_1114d;
    ax += 0x0001;
    if ((short)ax >= 0)
        goto loc_11143;
    if ((short)ax >= (short)0xfffc)
        goto loc_11143;
    ax = 0xfffc;
loc_11143:
    if ((short)ax <= (short)0x0018)
        goto loc_1114b;
    ax = 0x0018;
loc_1114b:
    goto loc_11158;
loc_1114d:
    if (ax == 0x0000)
        goto loc_11158;
    if ((short)ax <= (short)0x0000)
        goto loc_11157;
    ax--;
    goto loc_11158;
loc_11157:
    ax++;
loc_11158:
    memoryASet16(ds, 0x952c, ax);
    ax += 0x0003;
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    ax += memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= (short)0x0014)
        goto loc_11174;
    ax = 0x0014;
    memoryASet16(ds, 0x952c, 0x0000);
loc_11174:
    if ((short)ax <= (short)0x00ec)
        goto loc_11182;
    ax = 0x00ec;
    memoryASet16(ds, 0x952c, 0x0000);
loc_11182:
    memoryASet16(ds, 0x1b8f, ax);
    al = memoryAGet(ds, 0x1b8e);
    if (al == 0x00)
        goto loc_1118f;
    sub_11b57();
loc_1118f:
    sub_11c78();
    sub_10a51();
    if (ax == 0x0000)
        goto loc_1119f;
    sub_11c56();
    goto loc_111bc;
loc_1119f:
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) + 1);
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) & 0x3f);
    sub_10a51();
    if (ax == 0x0000)
        goto loc_111b3;
    sub_11c56();
loc_111b3:
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) - 1);
    memoryASet(ds, 0x1b9e, memoryAGet(ds, 0x1b9e) & 0x3f);
loc_111bc:
    ax = memoryAGet16(ds, 0x9542);
    if ((short)ax > (short)0x0000)
        goto loc_111c8;
    sub_11c33();
    return;
loc_111c8:
    al = memoryAGet(ds, 0x1b8e);
    if (al != 0x00)
        goto loc_111de;
    memoryASet(ds, 0x9515, memoryAGet(ds, 0x9515) + 1);
    al = memoryAGet(ds, 0x9515);
    if (al < 0x04)
        goto loc_111dd;
    sub_11c33();
loc_111dd:
    return;
loc_111de:
    ax = memoryAGet16(ds, 0x953e);
    if ((short)ax <= (short)0x0000)
        goto loc_111f0;
    ax = memoryAGet16(ds, 0x954c);
    if (!(al & 0x80))
        goto loc_111f0;
    sub_11d1e();
loc_111f0:
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951a);
    if (!(al & 0x40))
        goto loc_11235;
    if (bl != 0x00)
        goto loc_11224;
    ax = memoryAGet16(ds, 0x9536);
    if (ax <= 0x0000)
        goto loc_11222;
    memoryASet(ds, 0x951a, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    sub_11cd9();
    sub_10b58();
    memoryASet16(ds, 0x9538, memoryAGet16(ds, 0x9538) - 1);
    al = 0x01;
    sub_13840();
loc_11222:
    goto loc_11233;
loc_11224:
    if (bl != 0x02)
        goto loc_11233;
    memoryASet(ds, 0x951a, 0x03);
    al = 0x02;
    sub_13840();
loc_11233:
    goto loc_1124b;
loc_11235:
    if (bl != 0x01)
        goto loc_11241;
    memoryASet(ds, 0x951a, 0x02);
    goto loc_1124b;
loc_11241:
    if (bl != 0x03)
        goto loc_1124b;
    memoryASet(ds, 0x951a, 0x00);
loc_1124b:
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951b);
    if (!(al & 0x20))
        goto loc_11290;
    if (bl != 0x00)
        goto loc_1127f;
    ax = memoryAGet16(ds, 0x9536);
    if (ax <= 0x0000)
        goto loc_1127d;
    memoryASet(ds, 0x951b, 0x01);
    si = 0x0dc3;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    sub_11cd9();
    sub_10b58();
    memoryASet16(ds, 0x9538, memoryAGet16(ds, 0x9538) - 1);
    al = 0x01;
    sub_13840();
loc_1127d:
    goto loc_1128e;
loc_1127f:
    if (bl != 0x02)
        goto loc_1128e;
    memoryASet(ds, 0x951b, 0x03);
    al = 0x02;
    sub_13840();
loc_1128e:
    return;
loc_11290:
    if (bl != 0x01)
        goto loc_1129c;
    memoryASet(ds, 0x951b, 0x02);
    return;
loc_1129c:
    if (bl != 0x03)
        return;
    memoryASet(ds, 0x951b, 0x00);
}
/* Assembly listing of 1000:12a7 sub_112a7()
                            sub_112a7 PROC
1000:12a7  a1 2a 95         mov ax, word ptr [0x952a]
1000:12aa  2d 03 00         sub ax, 3
1000:12ad  78 05            js loc_112b4
1000:12af  a3 2a 95         mov word ptr [0x952a], ax
1000:12b2  eb 03            jmp loc_112b7
                            loc_112b4:
1000:12b4  e8 7c 09         call 0x1c33
                            loc_112b7:
1000:12b7  e8 ff 08         call 0x1bb9
1000:12ba  e8 9a 08         call 0x1b57
1000:12bd  be 8a 1b         mov si, 0x1b8a
1000:12c0  bb 49 0d         mov bx, 0xd49
1000:12c3  c6 44 04 0a      mov byte ptr [si + 4], 0xa
1000:12c7  e8 57 0e         call 0x2121
1000:12ca  c3               ret 
                            sub_112a7 ENDP
*/
void sub_112a7()
{
    // coverage: 0x14a7-0x14cb method sub_112a7
    // coverage2: 1000:12a7-1000:12cb method sub_112a7 // ins(0x12a7, 0x12cb, 0x12a7);
    ax = memoryAGet16(ds, 0x952a);
    ax -= 0x0003;
    if ((short)ax < 0)
        goto loc_112b4;
    memoryASet16(ds, 0x952a, ax);
    goto loc_112b7;
loc_112b4:
    sub_11c33();
loc_112b7:
    sub_11bb9();
    sub_11b57();
    si = 0x1b8a;
    bx = 0x0d49;
    memoryASet(ds, si + 4, 0x0a);
    sub_12121();
}
/* Assembly listing of 1000:12cb sub_112cb()
                            sub_112cb PROC
1000:12cb  a1 2a 95         mov ax, word ptr [0x952a]
1000:12ce  48               dec ax
1000:12cf  78 03            js loc_112d4
1000:12d1  a3 2a 95         mov word ptr [0x952a], ax
                            loc_112d4:
1000:12d4  e8 e2 08         call 0x1bb9
1000:12d7  e8 7d 08         call 0x1b57
1000:12da  fe 06 14 95      inc byte ptr [0x9514]
1000:12de  a0 14 95         mov al, byte ptr [0x9514]
1000:12e1  3c 28            cmp al, 0x28
1000:12e3  72 05            jb loc_112ea
1000:12e5  c6 06 13 95 01   mov byte ptr [0x9513], 1
                            loc_112ea:
1000:12ea  c3               ret 
                            sub_112cb ENDP
*/
void sub_112cb()
{
    // coverage: 0x14cb-0x14eb method sub_112cb
    // coverage2: 1000:12cb-1000:12eb method sub_112cb // ins(0x12cb, 0x12eb, 0x12cb);
    ax = memoryAGet16(ds, 0x952a);
    ax--;
    if ((short)ax < 0)
        goto loc_112d4;
    memoryASet16(ds, 0x952a, ax);
loc_112d4:
    sub_11bb9();
    sub_11b57();
    memoryASet(ds, 0x9514, memoryAGet(ds, 0x9514) + 1);
    al = memoryAGet(ds, 0x9514);
    if (al < 0x28)
        return;
    memoryASet(ds, 0x9513, 0x01);
}
/* Assembly listing of 1000:12eb sub_112eb()
                            sub_112eb PROC
1000:12eb  e8 b2 fd         call 0x10a0
1000:12ee  8a 04            mov al, byte ptr [si]
1000:12f0  3c 00            cmp al, 0
1000:12f2  75 01            jne loc_112f5
1000:12f4  c3               ret 
                            loc_112f5:
1000:12f5  83 6c 07 10      sub word ptr [si + 7], 0x10
1000:12f9  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:12fe  8a 44 04         mov al, byte ptr [si + 4]
1000:1301  3c 01            cmp al, 1
1000:1303  75 0d            jne loc_11312
1000:1305  8a 44 03         mov al, byte ptr [si + 3]
1000:1308  3c 9c            cmp al, 0x9c
1000:130a  7e 04            jle loc_11310
1000:130c  80 6c 03 08      sub byte ptr [si + 3], 8
                            loc_11310:
1000:1310  eb 0f            jmp loc_11321
                            loc_11312:
1000:1312  3c 02            cmp al, 2
1000:1314  75 0b            jne loc_11321
1000:1316  8a 44 03         mov al, byte ptr [si + 3]
1000:1319  3c 64            cmp al, 0x64
1000:131b  7d 04            jge loc_11321
1000:131d  80 44 03 08      add byte ptr [si + 3], 8
                            loc_11321:
1000:1321  56               push si
1000:1322  8b 44 05         mov ax, word ptr [si + 5]
1000:1325  50               push ax
1000:1326  8b 44 07         mov ax, word ptr [si + 7]
1000:1329  50               push ax
1000:132a  e8 d0 f4         call 0x7fd
1000:132d  5e               pop si
1000:132e  3a 44 03         cmp al, byte ptr [si + 3]
1000:1331  7c 05            jl loc_11338
1000:1333  e8 5c 0d         call 0x2092
1000:1336  eb 4b            jmp loc_11383
                            loc_11338:
1000:1338  56               push si
1000:1339  8b 44 05         mov ax, word ptr [si + 5]
1000:133c  50               push ax
1000:133d  88 4c 14         mov byte ptr [si + 0x14], cl
1000:1340  51               push cx
1000:1341  e8 91 f7         call 0xad5
1000:1344  5e               pop si
1000:1345  3d 00 00         cmp ax, 0
1000:1348  74 39            je loc_11383
1000:134a  56               push si
1000:134b  8a 44 14         mov al, byte ptr [si + 0x14]
1000:134e  b4 00            mov ah, 0
1000:1350  53               push bx
1000:1351  50               push ax
1000:1352  e8 b5 08         call 0x1c0a
1000:1355  8a 04            mov al, byte ptr [si]
1000:1357  a8 80            test al, 0x80
1000:1359  75 27            jne loc_11382
1000:135b  5b               pop bx
1000:135c  53               push bx
1000:135d  8a 44 03         mov al, byte ptr [si + 3]
1000:1360  2a 47 03         sub al, byte ptr [bx + 3]
1000:1363  79 02            jns loc_11367
1000:1365  f6 d8            neg al
                            loc_11367:
1000:1367  3c 10            cmp al, 0x10
1000:1369  73 17            jae loc_11382
1000:136b  fe 4c 15         dec byte ptr [si + 0x15]
1000:136e  79 0a            jns loc_1137a
1000:1370  e8 68 0d         call 0x20db
1000:1373  b0 06            mov al, 6
1000:1375  e8 c8 24         call 0x3840
1000:1378  eb 03            jmp loc_1137d
                            loc_1137a:
1000:137a  e8 e5 12         call 0x2662
                            loc_1137d:
1000:137d  5e               pop si
1000:137e  56               push si
1000:137f  e8 c5 0c         call 0x2047
                            loc_11382:
1000:1382  5e               pop si
                            loc_11383:
1000:1383  c3               ret 
                            sub_112eb ENDP
*/
void sub_112eb()
{
    // coverage: 0x14eb-0x1584 method sub_112eb
    // coverage2: 1000:12eb-1000:1384 method sub_112eb // ins(0x12eb, 0x1384, 0x12eb);
    sub_110a0();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_112f5;
    return;
loc_112f5:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - 0x0010);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    al = memoryAGet(ds, si + 4);
    if (al != 0x01)
        goto loc_11312;
    al = memoryAGet(ds, si + 3);
    if ((char)al <= (char)0x9c)
        goto loc_11310;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) - 0x08);
loc_11310:
    goto loc_11321;
loc_11312:
    if (al != 0x02)
        goto loc_11321;
    al = memoryAGet(ds, si + 3);
    if ((char)al >= (char)0x64)
        goto loc_11321;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + 0x08);
loc_11321:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    if ((char)al < (char)memoryAGet(ds, si + 3))
        goto loc_11338;
    sub_12092();
    return;
loc_11338:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    memoryASet(ds, si + 20, cl);
    push(cx);
    sub_10ad5();
    si = pop();
    if (ax == 0x0000)
        return;
    push(si);
    al = memoryAGet(ds, si + 20);
    ah = 0x00;
    push(bx);
    push(ax);
    sub_11c0a();
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_11382;
    bx = pop();
    push(bx);
    al = memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, bx + 3);
    if ((char)al >= 0)
        goto loc_11367;
    al = -al;
loc_11367:
    if (al >= 0x10)
        goto loc_11382;
    memoryASet(ds, si + 21, memoryAGet(ds, si + 21) - 1);
    if ((char)memoryAGet(ds, si + 21) >= 0)
        goto loc_1137a;
    sub_120db();
    al = 0x06;
    sub_13840();
    goto loc_1137d;
loc_1137a:
    sub_12662();
loc_1137d:
    si = pop();
    push(si);
    sub_12047();
loc_11382:
    si = pop();
}
/* Assembly listing of 1000:1384 sub_11384()
                            sub_11384 PROC
1000:1384  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:1387  3c 11            cmp al, 0x11
1000:1389  75 03            jne loc_1138e
1000:138b  c6 04 00         mov byte ptr [si], 0
                            loc_1138e:
1000:138e  e8 48 09         call 0x1cd9
1000:1391  8a 04            mov al, byte ptr [si]
1000:1393  a8 20            test al, 0x20
1000:1395  75 05            jne loc_1139c
1000:1397  a0 1a 95         mov al, byte ptr [0x951a]
1000:139a  eb 03            jmp loc_1139f
                            loc_1139c:
1000:139c  a0 1b 95         mov al, byte ptr [0x951b]
                            loc_1139f:
1000:139f  3c 03            cmp al, 3
1000:13a1  75 04            jne loc_113a7
1000:13a3  c6 44 12 19      mov byte ptr [si + 0x12], 0x19
                            loc_113a7:
1000:13a7  c3               ret 
                            sub_11384 ENDP
*/
void sub_11384()
{
    // coverage: 0x1584-0x15a8 method sub_11384
    // coverage2: 1000:1384-1000:13a8 method sub_11384 // ins(0x1384, 0x13a8, 0x1384);
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_1138e;
    memoryASet(ds, si, 0x00);
loc_1138e:
    sub_11cd9();
    al = memoryAGet(ds, si);
    if (al & 0x20)
        goto loc_1139c;
    al = memoryAGet(ds, 0x951a);
    goto loc_1139f;
loc_1139c:
    al = memoryAGet(ds, 0x951b);
loc_1139f:
    if (al != 0x03)
        return;
    memoryASet(ds, si + 18, 0x19);
}
/* Assembly listing of 1000:13a8 sub_113a8()
                            sub_113a8 PROC
1000:13a8  e8 f5 fc         call 0x10a0
1000:13ab  8a 04            mov al, byte ptr [si]
1000:13ad  3c 00            cmp al, 0
1000:13af  75 01            jne loc_113b2
1000:13b1  c3               ret 
                            loc_113b2:
1000:13b2  83 6c 07 06      sub word ptr [si + 7], 6
1000:13b6  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:13bb  56               push si
1000:13bc  8b 44 05         mov ax, word ptr [si + 5]
1000:13bf  50               push ax
1000:13c0  8b 44 07         mov ax, word ptr [si + 7]
1000:13c3  50               push ax
1000:13c4  e8 36 f4         call 0x7fd
1000:13c7  5e               pop si
1000:13c8  04 04            add al, 4
1000:13ca  88 44 03         mov byte ptr [si + 3], al
1000:13cd  88 4c 14         mov byte ptr [si + 0x14], cl
1000:13d0  88 5c 04         mov byte ptr [si + 4], bl
1000:13d3  bb da 0d         mov bx, 0xdda
1000:13d6  e8 48 0d         call 0x2121
1000:13d9  8a 44 04         mov al, byte ptr [si + 4]
1000:13dc  3c 00            cmp al, 0
1000:13de  75 15            jne loc_113f5
1000:13e0  83 44 07 04      add word ptr [si + 7], 4
1000:13e4  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:13e9  fe 4c 15         dec byte ptr [si + 0x15]
1000:13ec  79 07            jns loc_113f5
1000:13ee  e8 ff 0c         call 0x20f0
1000:13f1  c6 04 00         mov byte ptr [si], 0
1000:13f4  c3               ret 
                            loc_113f5:
1000:13f5  56               push si
1000:13f6  8b 44 05         mov ax, word ptr [si + 5]
1000:13f9  50               push ax
1000:13fa  8a 4c 14         mov cl, byte ptr [si + 0x14]
1000:13fd  b5 00            mov ch, 0
1000:13ff  51               push cx
1000:1400  e8 d2 f6         call 0xad5
1000:1403  5e               pop si
1000:1404  3d 00 00         cmp ax, 0
1000:1407  74 1f            je loc_11428
1000:1409  56               push si
1000:140a  8a 44 14         mov al, byte ptr [si + 0x14]
1000:140d  b4 00            mov ah, 0
1000:140f  53               push bx
1000:1410  50               push ax
1000:1411  e8 f6 07         call 0x1c0a
1000:1414  8a 04            mov al, byte ptr [si]
1000:1416  a8 80            test al, 0x80
1000:1418  75 0d            jne loc_11427
1000:141a  e8 be 0c         call 0x20db
1000:141d  b0 06            mov al, 6
1000:141f  e8 1e 24         call 0x3840
1000:1422  5e               pop si
1000:1423  56               push si
1000:1424  c6 04 00         mov byte ptr [si], 0
                            loc_11427:
1000:1427  5e               pop si
                            loc_11428:
1000:1428  c3               ret 
                            sub_113a8 ENDP
*/
void sub_113a8()
{
    // coverage: 0x15a8-0x1629 method sub_113a8
    // coverage2: 1000:13a8-1000:1429 method sub_113a8 // ins(0x13a8, 0x1429, 0x13a8);
    sub_110a0();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_113b2;
    return;
loc_113b2:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - 0x0006);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    al += 0x04;
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 20, cl);
    memoryASet(ds, si + 4, bl);
    bx = 0x0dda;
    sub_12121();
    al = memoryAGet(ds, si + 4);
    if (al != 0x00)
        goto loc_113f5;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0004);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    memoryASet(ds, si + 21, memoryAGet(ds, si + 21) - 1);
    if ((char)memoryAGet(ds, si + 21) >= 0)
        goto loc_113f5;
    sub_120f0();
    memoryASet(ds, si, 0x00);
    return;
loc_113f5:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    cl = memoryAGet(ds, si + 20);
    ch = 0x00;
    push(cx);
    sub_10ad5();
    si = pop();
    if (ax == 0x0000)
        return;
    push(si);
    al = memoryAGet(ds, si + 20);
    ah = 0x00;
    push(bx);
    push(ax);
    sub_11c0a();
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_11427;
    sub_120db();
    al = 0x06;
    sub_13840();
    si = pop();
    push(si);
    memoryASet(ds, si, 0x00);
loc_11427:
    si = pop();
}
/* Assembly listing of 1000:1429 sub_11429()
                            sub_11429 PROC
1000:1429  e8 9a fc         call 0x10c6
1000:142c  8a 04            mov al, byte ptr [si]
1000:142e  3c 00            cmp al, 0
1000:1430  75 01            jne loc_11433
1000:1432  c3               ret 
                            loc_11433:
1000:1433  8a 44 01         mov al, byte ptr [si + 1]
1000:1436  3c 02            cmp al, 2
1000:1438  75 06            jne loc_11440
1000:143a  83 44 07 05      add word ptr [si + 7], 5
1000:143e  eb 2a            jmp loc_1146a
                            loc_11440:
1000:1440  3c 00            cmp al, 0
1000:1442  75 06            jne loc_1144a
1000:1444  83 6c 05 05      sub word ptr [si + 5], 5
1000:1448  eb 20            jmp loc_1146a
                            loc_1144a:
1000:144a  3c 01            cmp al, 1
1000:144c  75 0a            jne loc_11458
1000:144e  83 6c 05 03      sub word ptr [si + 5], 3
1000:1452  83 44 07 02      add word ptr [si + 7], 2
1000:1456  eb 12            jmp loc_1146a
                            loc_11458:
1000:1458  3c 03            cmp al, 3
1000:145a  75 0a            jne loc_11466
1000:145c  83 44 05 03      add word ptr [si + 5], 3
1000:1460  83 44 07 02      add word ptr [si + 7], 2
1000:1464  eb 04            jmp loc_1146a
                            loc_11466:
1000:1466  83 44 05 05      add word ptr [si + 5], 5
                            loc_1146a:
1000:146a  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:146f  8b 44 05         mov ax, word ptr [si + 5]
1000:1472  3d 0c 00         cmp ax, 0xc
1000:1475  7d 04            jge loc_1147b
1000:1477  c6 04 00         mov byte ptr [si], 0
1000:147a  c3               ret 
                            loc_1147b:
1000:147b  3d f4 00         cmp ax, 0xf4
1000:147e  7e 04            jle loc_11484
1000:1480  c6 04 00         mov byte ptr [si], 0
1000:1483  c3               ret 
                            loc_11484:
1000:1484  56               push si
1000:1485  8b 44 05         mov ax, word ptr [si + 5]
1000:1488  50               push ax
1000:1489  8b 44 07         mov ax, word ptr [si + 7]
1000:148c  50               push ax
1000:148d  e8 6d f3         call 0x7fd
1000:1490  5e               pop si
1000:1491  04 08            add al, 8
1000:1493  88 44 03         mov byte ptr [si + 3], al
1000:1496  88 4c 14         mov byte ptr [si + 0x14], cl
1000:1499  88 5c 04         mov byte ptr [si + 4], bl
1000:149c  8a 5c 01         mov bl, byte ptr [si + 1]
1000:149f  b7 00            mov bh, 0
1000:14a1  d1 e3            shl bx, 1
1000:14a3  8b 9f ff 10      mov bx, word ptr [bx + 0x10ff]
1000:14a7  e8 77 0c         call 0x2121
1000:14aa  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:14ad  3c 11            cmp al, 0x11
1000:14af  75 01            jne loc_114b2
1000:14b1  c3               ret 
                            loc_114b2:
1000:14b2  8b 44 05         mov ax, word ptr [si + 5]
1000:14b5  2b 06 8f 1b      sub ax, word ptr [0x1b8f]
1000:14b9  79 02            jns loc_114bd
1000:14bb  f7 d8            neg ax
                            loc_114bd:
1000:14bd  3d 10 00         cmp ax, 0x10
1000:14c0  73 2d            jae loc_114ef
1000:14c2  8b 44 07         mov ax, word ptr [si + 7]
1000:14c5  2b 06 91 1b      sub ax, word ptr [0x1b91]
1000:14c9  2d 08 00         sub ax, 8
1000:14cc  79 02            jns loc_114d0
1000:14ce  f7 d8            neg ax
                            loc_114d0:
1000:14d0  3d 10 00         cmp ax, 0x10
1000:14d3  73 1a            jae loc_114ef
1000:14d5  b0 05            mov al, 5
1000:14d7  e8 66 23         call 0x3840
1000:14da  83 2e 44 95 64   sub word ptr [0x9544], 0x64
1000:14df  c6 06 a0 12 01   mov byte ptr [0x12a0], 1
1000:14e4  e8 09 0c         call 0x20f0
1000:14e7  c6 06 a0 12 05   mov byte ptr [0x12a0], 5
1000:14ec  c6 04 00         mov byte ptr [si], 0
                            loc_114ef:
1000:14ef  c3               ret 
                            sub_11429 ENDP
*/
void sub_11429()
{
    // coverage: 0x1629-0x16f0 method sub_11429
    // coverage2: 1000:1429-1000:14f0 method sub_11429 // ins(0x1429, 0x14f0, 0x1429);
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11433;
    return;
loc_11433:
    al = memoryAGet(ds, si + 1);
    if (al != 0x02)
        goto loc_11440;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0005);
    goto loc_1146a;
loc_11440:
    if (al != 0x00)
        goto loc_1144a;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0005);
    goto loc_1146a;
loc_1144a:
    if (al != 0x01)
        goto loc_11458;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0003);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0002);
    goto loc_1146a;
loc_11458:
    if (al != 0x03)
        goto loc_11466;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0003);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0002);
    goto loc_1146a;
loc_11466:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0005);
loc_1146a:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    ax = memoryAGet16(ds, si + 5);
    if ((short)ax >= (short)0x000c)
        goto loc_1147b;
    memoryASet(ds, si, 0x00);
    return;
loc_1147b:
    if ((short)ax <= (short)0x00f4)
        goto loc_11484;
    memoryASet(ds, si, 0x00);
    return;
loc_11484:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    al += 0x08;
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 20, cl);
    memoryASet(ds, si + 4, bl);
    bl = memoryAGet(ds, si + 1);
    bh = 0x00;
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4351);
    sub_12121();
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_114b2;
    return;
loc_114b2:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_114bd;
    ax = -ax;
loc_114bd:
    if (ax >= 0x0010)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    ax -= 0x0008;
    if ((short)ax >= 0)
        goto loc_114d0;
    ax = -ax;
loc_114d0:
    if (ax >= 0x0010)
        return;
    al = 0x05;
    sub_13840();
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x0064);
    memoryASet(ds, 0x12a0, 0x01);
    sub_120f0();
    memoryASet(ds, 0x12a0, 0x05);
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:14f0 sub_114f0()
                            sub_114f0 PROC
1000:14f0  83 44 07 01      add word ptr [si + 7], 1
1000:14f4  56               push si
1000:14f5  8b 44 05         mov ax, word ptr [si + 5]
1000:14f8  50               push ax
1000:14f9  8b 44 07         mov ax, word ptr [si + 7]
1000:14fc  50               push ax
1000:14fd  e8 fd f2         call 0x7fd
1000:1500  5e               pop si
1000:1501  88 44 03         mov byte ptr [si + 3], al
1000:1504  88 4c 14         mov byte ptr [si + 0x14], cl
1000:1507  88 5c 04         mov byte ptr [si + 4], bl
1000:150a  8a 5c 01         mov bl, byte ptr [si + 1]
1000:150d  b7 00            mov bh, 0
1000:150f  d1 e3            shl bx, 1
1000:1511  8b 9f e1 0f      mov bx, word ptr [bx + 0xfe1]
1000:1515  e8 09 0c         call 0x2121
1000:1518  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:151b  3c 11            cmp al, 0x11
1000:151d  74 29            je loc_11548
1000:151f  8b 44 05         mov ax, word ptr [si + 5]
1000:1522  2b 06 8f 1b      sub ax, word ptr [0x1b8f]
1000:1526  79 02            jns loc_1152a
1000:1528  f7 d8            neg ax
                            loc_1152a:
1000:152a  3d 1a 00         cmp ax, 0x1a
1000:152d  73 19            jae loc_11548
1000:152f  8b 44 07         mov ax, word ptr [si + 7]
1000:1532  2b 06 91 1b      sub ax, word ptr [0x1b91]
1000:1536  79 02            jns loc_1153a
1000:1538  f7 d8            neg ax
                            loc_1153a:
1000:153a  3d 12 00         cmp ax, 0x12
1000:153d  73 09            jae loc_11548
1000:153f  83 2e 44 95 0c   sub word ptr [0x9544], 0xc
1000:1544  c6 44 15 ff      mov byte ptr [si + 0x15], 0xff
                            loc_11548:
1000:1548  bf a1 1b         mov di, 0x1ba1
                            loc_1154b:
1000:154b  8a 44 15         mov al, byte ptr [si + 0x15]
1000:154e  3c 00            cmp al, 0
1000:1550  7d 0f            jge loc_11561
1000:1552  b0 07            mov al, 7
1000:1554  e8 e9 22         call 0x3840
1000:1557  e8 96 0b         call 0x20f0
1000:155a  c6 04 00         mov byte ptr [si], 0
1000:155d  e8 16 11         call 0x2676
1000:1560  c3               ret 
                            loc_11561:
1000:1561  8a 05            mov al, byte ptr [di]
1000:1563  a8 80            test al, 0x80
1000:1565  75 59            jne loc_115c0
1000:1567  a8 40            test al, 0x40
1000:1569  74 50            je loc_115bb
1000:156b  57               push di
1000:156c  8b 45 05         mov ax, word ptr [di + 5]
1000:156f  2b 44 05         sub ax, word ptr [si + 5]
1000:1572  79 02            jns loc_11576
1000:1574  f7 d8            neg ax
                            loc_11576:
1000:1576  3d 14 00         cmp ax, 0x14
1000:1579  73 3f            jae loc_115ba
1000:157b  8b 45 07         mov ax, word ptr [di + 7]
1000:157e  2b 44 07         sub ax, word ptr [si + 7]
1000:1581  79 02            jns loc_11585
1000:1583  f7 d8            neg ax
                            loc_11585:
1000:1585  3d 10 00         cmp ax, 0x10
1000:1588  73 30            jae loc_115ba
1000:158a  8a 45 12         mov al, byte ptr [di + 0x12]
1000:158d  3c 19            cmp al, 0x19
1000:158f  75 09            jne loc_1159a
1000:1591  c6 44 15 ff      mov byte ptr [si + 0x15], 0xff
1000:1595  c6 05 00         mov byte ptr [di], 0
1000:1598  eb 20            jmp loc_115ba
                            loc_1159a:
1000:159a  8a 45 03         mov al, byte ptr [di + 3]
1000:159d  2a 44 03         sub al, byte ptr [si + 3]
1000:15a0  79 02            jns loc_115a4
1000:15a2  f6 d8            neg al
                            loc_115a4:
1000:15a4  3c 10            cmp al, 0x10
1000:15a6  73 12            jae loc_115ba
1000:15a8  fe 4c 15         dec byte ptr [si + 0x15]
1000:15ab  56               push si
1000:15ac  8b f7            mov si, di
1000:15ae  e8 e1 0a         call 0x2092
1000:15b1  b0 03            mov al, 3
1000:15b3  e8 8a 22         call 0x3840
1000:15b6  e8 a9 10         call 0x2662
1000:15b9  5e               pop si
                            loc_115ba:
1000:15ba  5f               pop di
                            loc_115bb:
1000:15bb  83 c7 17         add di, 0x17
1000:15be  eb 8b            jmp loc_1154b
                            loc_115c0:
1000:15c0  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:15c3  3c 11            cmp al, 0x11
1000:15c5  74 31            je loc_115f8
1000:15c7  a1 91 1b         mov ax, word ptr [0x1b91]
1000:15ca  3b 44 07         cmp ax, word ptr [si + 7]
1000:15cd  76 29            jbe loc_115f8
1000:15cf  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:15d2  2b 44 05         sub ax, word ptr [si + 5]
1000:15d5  79 02            jns loc_115d9
1000:15d7  f7 d8            neg ax
                            loc_115d9:
1000:15d9  3d 20 00         cmp ax, 0x20
1000:15dc  73 1a            jae loc_115f8
1000:15de  fe 4c 16         dec byte ptr [si + 0x16]
1000:15e1  79 0b            jns loc_115ee
1000:15e3  c6 44 16 07      mov byte ptr [si + 0x16], 7
1000:15e7  c6 06 18 95 01   mov byte ptr [0x9518], 1
1000:15ec  eb 05            jmp loc_115f3
                            loc_115ee:
1000:15ee  c6 06 18 95 00   mov byte ptr [0x9518], 0
                            loc_115f3:
1000:15f3  56               push si
1000:15f4  e8 f8 07         call 0x1def
1000:15f7  5e               pop si
                            loc_115f8:
1000:15f8  e8 cb fa         call 0x10c6
1000:15fb  c3               ret 
                            sub_114f0 ENDP
*/
void sub_114f0()
{
    // coverage: 0x16f0-0x17fc method sub_114f0
    // coverage2: 1000:14f0-1000:15fc method sub_114f0 // ins(0x14f0, 0x15fc, 0x14f0);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0001);
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 20, cl);
    memoryASet(ds, si + 4, bl);
    bl = memoryAGet(ds, si + 1);
    bh = 0x00;
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4065);
    sub_12121();
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_11548;
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_1152a;
    ax = -ax;
loc_1152a:
    if (ax >= 0x001a)
        goto loc_11548;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_1153a;
    ax = -ax;
loc_1153a:
    if (ax >= 0x0012)
        goto loc_11548;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x000c);
    memoryASet(ds, si + 21, 0xff);
loc_11548:
    di = 0x1ba1;
loc_1154b:
    al = memoryAGet(ds, si + 21);
    if ((char)al >= (char)0x00)
        goto loc_11561;
    al = 0x07;
    sub_13840();
    sub_120f0();
    memoryASet(ds, si, 0x00);
    sub_12676();
    return;
loc_11561:
    al = memoryAGet(ds, di);
    if (al & 0x80)
        goto loc_115c0;
    if (!(al & 0x40))
        goto loc_115bb;
    push(di);
    ax = memoryAGet16(ds, di + 5);
    ax -= memoryAGet16(ds, si + 5);
    if ((short)ax >= 0)
        goto loc_11576;
    ax = -ax;
loc_11576:
    if (ax >= 0x0014)
        goto loc_115ba;
    ax = memoryAGet16(ds, di + 7);
    ax -= memoryAGet16(ds, si + 7);
    if ((short)ax >= 0)
        goto loc_11585;
    ax = -ax;
loc_11585:
    if (ax >= 0x0010)
        goto loc_115ba;
    al = memoryAGet(ds, di + 18);
    if (al != 0x19)
        goto loc_1159a;
    memoryASet(ds, si + 21, 0xff);
    memoryASet(ds, di, 0x00);
    goto loc_115ba;
loc_1159a:
    al = memoryAGet(ds, di + 3);
    al -= memoryAGet(ds, si + 3);
    if ((char)al >= 0)
        goto loc_115a4;
    al = -al;
loc_115a4:
    if (al >= 0x10)
        goto loc_115ba;
    memoryASet(ds, si + 21, memoryAGet(ds, si + 21) - 1);
    push(si);
    si = di;
    sub_12092();
    al = 0x03;
    sub_13840();
    sub_12662();
    si = pop();
loc_115ba:
    di = pop();
loc_115bb:
    di += 0x0017;
    goto loc_1154b;
loc_115c0:
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_115f8;
    ax = memoryAGet16(ds, 0x1b91);
    if (ax <= memoryAGet16(ds, si + 7))
        goto loc_115f8;
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    if ((short)ax >= 0)
        goto loc_115d9;
    ax = -ax;
loc_115d9:
    if (ax >= 0x0020)
        goto loc_115f8;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_115ee;
    memoryASet(ds, si + 22, 0x07);
    memoryASet(ds, 0x9518, 0x01);
    goto loc_115f3;
loc_115ee:
    memoryASet(ds, 0x9518, 0x00);
loc_115f3:
    push(si);
    sub_11def();
    si = pop();
loc_115f8:
    sub_110c6();
}
/* Assembly listing of 1000:15fc sub_115fc()
                            sub_115fc PROC
1000:15fc  e8 c7 fa         call 0x10c6
1000:15ff  8a 04            mov al, byte ptr [si]
1000:1601  3c 00            cmp al, 0
1000:1603  75 01            jne loc_11606
1000:1605  c3               ret 
                            loc_11606:
1000:1606  8a 44 01         mov al, byte ptr [si + 1]
1000:1609  3c 02            cmp al, 2
1000:160b  75 06            jne loc_11613
1000:160d  83 44 07 08      add word ptr [si + 7], 8
1000:1611  eb 2a            jmp loc_1163d
                            loc_11613:
1000:1613  3c 00            cmp al, 0
1000:1615  75 06            jne loc_1161d
1000:1617  83 6c 05 08      sub word ptr [si + 5], 8
1000:161b  eb 20            jmp loc_1163d
                            loc_1161d:
1000:161d  3c 01            cmp al, 1
1000:161f  75 0a            jne loc_1162b
1000:1621  83 6c 05 06      sub word ptr [si + 5], 6
1000:1625  83 44 07 04      add word ptr [si + 7], 4
1000:1629  eb 12            jmp loc_1163d
                            loc_1162b:
1000:162b  3c 03            cmp al, 3
1000:162d  75 0a            jne loc_11639
1000:162f  83 44 05 06      add word ptr [si + 5], 6
1000:1633  83 44 07 04      add word ptr [si + 7], 4
1000:1637  eb 04            jmp loc_1163d
                            loc_11639:
1000:1639  83 44 05 08      add word ptr [si + 5], 8
                            loc_1163d:
1000:163d  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:1642  8b 44 05         mov ax, word ptr [si + 5]
1000:1645  3d 04 00         cmp ax, 4
1000:1648  7d 04            jge loc_1164e
1000:164a  c6 04 00         mov byte ptr [si], 0
1000:164d  c3               ret 
                            loc_1164e:
1000:164e  3d fc 00         cmp ax, 0xfc
1000:1651  7e 04            jle loc_11657
1000:1653  c6 04 00         mov byte ptr [si], 0
1000:1656  c3               ret 
                            loc_11657:
1000:1657  8a 44 04         mov al, byte ptr [si + 4]
1000:165a  3c 01            cmp al, 1
1000:165c  75 0d            jne loc_1166b
1000:165e  8a 44 03         mov al, byte ptr [si + 3]
1000:1661  3c 64            cmp al, 0x64
1000:1663  7d 04            jge loc_11669
1000:1665  80 44 03 04      add byte ptr [si + 3], 4
                            loc_11669:
1000:1669  eb 0f            jmp loc_1167a
                            loc_1166b:
1000:166b  3c 02            cmp al, 2
1000:166d  75 0b            jne loc_1167a
1000:166f  8a 44 03         mov al, byte ptr [si + 3]
1000:1672  3c 9c            cmp al, 0x9c
1000:1674  7e 04            jle loc_1167a
1000:1676  80 6c 03 04      sub byte ptr [si + 3], 4
                            loc_1167a:
1000:167a  56               push si
1000:167b  8b 44 05         mov ax, word ptr [si + 5]
1000:167e  50               push ax
1000:167f  8b 44 07         mov ax, word ptr [si + 7]
1000:1682  50               push ax
1000:1683  e8 77 f1         call 0x7fd
1000:1686  5e               pop si
1000:1687  3a 44 03         cmp al, byte ptr [si + 3]
1000:168a  7c 05            jl loc_11691
1000:168c  e8 03 0a         call 0x2092
1000:168f  eb 44            jmp loc_116d5
                            loc_11691:
1000:1691  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:1694  3c 11            cmp al, 0x11
1000:1696  75 01            jne loc_11699
1000:1698  c3               ret 
                            loc_11699:
1000:1699  8b 44 05         mov ax, word ptr [si + 5]
1000:169c  2b 06 8f 1b      sub ax, word ptr [0x1b8f]
1000:16a0  79 02            jns loc_116a4
1000:16a2  f7 d8            neg ax
                            loc_116a4:
1000:16a4  3d 0c 00         cmp ax, 0xc
1000:16a7  73 2c            jae loc_116d5
1000:16a9  8b 44 07         mov ax, word ptr [si + 7]
1000:16ac  2b 06 91 1b      sub ax, word ptr [0x1b91]
1000:16b0  79 02            jns loc_116b4
1000:16b2  f7 d8            neg ax
                            loc_116b4:
1000:16b4  3d 08 00         cmp ax, 8
1000:16b7  73 1c            jae loc_116d5
1000:16b9  8a 44 03         mov al, byte ptr [si + 3]
1000:16bc  2a 06 8d 1b      sub al, byte ptr [0x1b8d]
1000:16c0  79 02            jns loc_116c4
1000:16c2  f6 d8            neg al
                            loc_116c4:
1000:16c4  3c 10            cmp al, 0x10
1000:16c6  73 0d            jae loc_116d5
1000:16c8  83 2e 44 95 01   sub word ptr [0x9544], 1
1000:16cd  e8 c2 09         call 0x2092
1000:16d0  b0 04            mov al, 4
1000:16d2  e8 6b 21         call 0x3840
                            loc_116d5:
1000:16d5  c3               ret 
                            sub_115fc ENDP
*/
void sub_115fc()
{
    // coverage: 0x17fc-0x18d6 method sub_115fc
    // coverage2: 1000:15fc-1000:16d6 method sub_115fc // ins(0x15fc, 0x16d6, 0x15fc);
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11606;
    return;
loc_11606:
    al = memoryAGet(ds, si + 1);
    if (al != 0x02)
        goto loc_11613;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0008);
    goto loc_1163d;
loc_11613:
    if (al != 0x00)
        goto loc_1161d;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0008);
    goto loc_1163d;
loc_1161d:
    if (al != 0x01)
        goto loc_1162b;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0006);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0004);
    goto loc_1163d;
loc_1162b:
    if (al != 0x03)
        goto loc_11639;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0006);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0004);
    goto loc_1163d;
loc_11639:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0008);
loc_1163d:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    ax = memoryAGet16(ds, si + 5);
    if ((short)ax >= (short)0x0004)
        goto loc_1164e;
    memoryASet(ds, si, 0x00);
    return;
loc_1164e:
    if ((short)ax <= (short)0x00fc)
        goto loc_11657;
    memoryASet(ds, si, 0x00);
    return;
loc_11657:
    al = memoryAGet(ds, si + 4);
    if (al != 0x01)
        goto loc_1166b;
    al = memoryAGet(ds, si + 3);
    if ((char)al >= (char)0x64)
        goto loc_11669;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + 0x04);
loc_11669:
    goto loc_1167a;
loc_1166b:
    if (al != 0x02)
        goto loc_1167a;
    al = memoryAGet(ds, si + 3);
    if ((char)al <= (char)0x9c)
        goto loc_1167a;
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) - 0x04);
loc_1167a:
    push(si);
    ax = memoryAGet16(ds, si + 5);
    push(ax);
    ax = memoryAGet16(ds, si + 7);
    push(ax);
    sub_107fd();
    si = pop();
    if ((char)al < (char)memoryAGet(ds, si + 3))
        goto loc_11691;
    sub_12092();
    return;
loc_11691:
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_11699;
    return;
loc_11699:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_116a4;
    ax = -ax;
loc_116a4:
    if (ax >= 0x000c)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_116b4;
    ax = -ax;
loc_116b4:
    if (ax >= 0x0008)
        return;
    al = memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, 0x1b8d);
    if ((char)al >= 0)
        goto loc_116c4;
    al = -al;
loc_116c4:
    if (al >= 0x10)
        return;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x0001);
    sub_12092();
    al = 0x04;
    sub_13840();
}
/* Assembly listing of 1000:16d6 sub_116d6()
                            sub_116d6 PROC
1000:16d6  fe 4c 04         dec byte ptr [si + 4]
1000:16d9  79 03            jns loc_116de
1000:16db  c6 04 00         mov byte ptr [si], 0
                            loc_116de:
1000:16de  c3               ret 
                            sub_116d6 ENDP
*/
void sub_116d6()
{
    // coverage: 0x18d6-0x18df method sub_116d6
    // coverage2: 1000:16d6-1000:16df method sub_116d6 // ins(0x16d6, 0x16df, 0x16d6);
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) - 1);
    if ((char)memoryAGet(ds, si + 4) >= 0)
        return;
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:16df sub_116df()
                            sub_116df PROC
1000:16df  8a 44 04         mov al, byte ptr [si + 4]
1000:16e2  fe 44 04         inc byte ptr [si + 4]
1000:16e5  3c 04            cmp al, 4
1000:16e7  72 04            jb loc_116ed
1000:16e9  c6 04 00         mov byte ptr [si], 0
1000:16ec  c3               ret 
                            loc_116ed:
1000:16ed  d0 e0            shl al, 1
1000:16ef  8a d8            mov bl, al
1000:16f1  b7 00            mov bh, 0
1000:16f3  8b 87 3e 14      mov ax, word ptr [bx + 0x143e]
1000:16f7  89 44 0f         mov word ptr [si + 0xf], ax
1000:16fa  e8 c9 f9         call 0x10c6
1000:16fd  c3               ret 
                            sub_116df ENDP
*/
void sub_116df()
{
    // coverage: 0x18df-0x18fe method sub_116df
    // coverage2: 1000:16df-1000:16fe method sub_116df // ins(0x16df, 0x16fe, 0x16df);
    al = memoryAGet(ds, si + 4);
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) + 1);
    if (al < 0x04)
        goto loc_116ed;
    memoryASet(ds, si, 0x00);
    return;
loc_116ed:
    al <<= 1;
    bl = al;
    bh = 0x00;
    ax = memoryAGet16(ds, bx + 5182);
    memoryASet16(ds, si + 15, ax);
    sub_110c6();
}
/* Assembly listing of 1000:16fe sub_116fe()
                            sub_116fe PROC
1000:16fe  fe 44 16         inc byte ptr [si + 0x16]
1000:1701  8a 44 16         mov al, byte ptr [si + 0x16]
1000:1704  d0 e8            shr al, 1
1000:1706  d0 e8            shr al, 1
1000:1708  24 07            and al, 7
1000:170a  3c 05            cmp al, 5
1000:170c  7c 04            jl loc_11712
1000:170e  c6 04 00         mov byte ptr [si], 0
1000:1711  c3               ret 
                            loc_11712:
1000:1712  88 44 04         mov byte ptr [si + 4], al
1000:1715  bb b5 12         mov bx, 0x12b5
1000:1718  e8 06 0a         call 0x2121
1000:171b  e8 a8 f9         call 0x10c6
1000:171e  c3               ret 
                            sub_116fe ENDP
*/
void sub_116fe()
{
    // coverage: 0x18fe-0x191f method sub_116fe
    // coverage2: 1000:16fe-1000:171f method sub_116fe // ins(0x16fe, 0x171f, 0x16fe);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al >>= 1;
    al &= 0x07;
    if ((char)al < (char)0x05)
        goto loc_11712;
    memoryASet(ds, si, 0x00);
    return;
loc_11712:
    memoryASet(ds, si + 4, al);
    bx = 0x12b5;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:171f sub_1171f()
                            sub_1171f PROC
1000:171f  fe 44 16         inc byte ptr [si + 0x16]
1000:1722  8a 44 16         mov al, byte ptr [si + 0x16]
1000:1725  d0 e8            shr al, 1
1000:1727  d0 e8            shr al, 1
1000:1729  24 07            and al, 7
1000:172b  3c 06            cmp al, 6
1000:172d  7c 04            jl loc_11733
1000:172f  c6 04 00         mov byte ptr [si], 0
1000:1732  c3               ret 
                            loc_11733:
1000:1733  88 44 04         mov byte ptr [si + 4], al
1000:1736  bb f5 12         mov bx, 0x12f5
1000:1739  e8 e5 09         call 0x2121
1000:173c  e8 87 f9         call 0x10c6
1000:173f  c3               ret 
                            sub_1171f ENDP
*/
void sub_1171f()
{
    // coverage: 0x191f-0x1940 method sub_1171f
    // coverage2: 1000:171f-1000:1740 method sub_1171f // ins(0x171f, 0x1740, 0x171f);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al >>= 1;
    al &= 0x07;
    if ((char)al < (char)0x06)
        goto loc_11733;
    memoryASet(ds, si, 0x00);
    return;
loc_11733:
    memoryASet(ds, si + 4, al);
    bx = 0x12f5;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:1740 sub_11740()
                            sub_11740 PROC
1000:1740  fe 44 16         inc byte ptr [si + 0x16]
1000:1743  8a 44 16         mov al, byte ptr [si + 0x16]
1000:1746  24 07            and al, 7
1000:1748  3c 04            cmp al, 4
1000:174a  7c 16            jl loc_11762
1000:174c  8a 04            mov al, byte ptr [si]
1000:174e  a8 20            test al, 0x20
1000:1750  74 07            je loc_11759
1000:1752  80 26 17 95 7f   and byte ptr [0x9517], 0x7f
1000:1757  eb 05            jmp loc_1175e
                            loc_11759:
1000:1759  80 26 17 95 fe   and byte ptr [0x9517], 0xfe
                            loc_1175e:
1000:175e  c6 04 00         mov byte ptr [si], 0
1000:1761  c3               ret 
                            loc_11762:
1000:1762  88 44 04         mov byte ptr [si + 4], al
1000:1765  bb 3d 13         mov bx, 0x133d
1000:1768  e8 b6 09         call 0x2121
1000:176b  c3               ret 
                            sub_11740 ENDP
*/
void sub_11740()
{
    // coverage: 0x1940-0x196c method sub_11740
    // coverage2: 1000:1740-1000:176c method sub_11740 // ins(0x1740, 0x176c, 0x1740);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al &= 0x07;
    if ((char)al < (char)0x04)
        goto loc_11762;
    al = memoryAGet(ds, si);
    if (!(al & 0x20))
        goto loc_11759;
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) & 0x7f);
    goto loc_1175e;
loc_11759:
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) & 0xfe);
loc_1175e:
    memoryASet(ds, si, 0x00);
    return;
loc_11762:
    memoryASet(ds, si + 4, al);
    bx = 0x133d;
    sub_12121();
}
/* Assembly listing of 1000:176c sub_1176c()
                            sub_1176c PROC
1000:176c  fe 44 16         inc byte ptr [si + 0x16]
1000:176f  8a 44 16         mov al, byte ptr [si + 0x16]
1000:1772  d0 e8            shr al, 1
1000:1774  24 03            and al, 3
1000:1776  88 44 04         mov byte ptr [si + 4], al
1000:1779  bb 2b 0e         mov bx, 0xe2b
1000:177c  e8 a2 09         call 0x2121
1000:177f  e8 44 f9         call 0x10c6
1000:1782  c3               ret 
                            sub_1176c ENDP
*/
void sub_1176c()
{
    // coverage: 0x196c-0x1983 method sub_1176c
    // coverage2: 1000:176c-1000:1783 method sub_1176c // ins(0x176c, 0x1783, 0x176c);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al &= 0x03;
    memoryASet(ds, si + 4, al);
    bx = 0x0e2b;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:1783 sub_11783()
                            sub_11783 PROC
1000:1783  fe 44 16         inc byte ptr [si + 0x16]
1000:1786  8a 44 16         mov al, byte ptr [si + 0x16]
1000:1789  d0 e8            shr al, 1
1000:178b  24 07            and al, 7
1000:178d  3c 06            cmp al, 6
1000:178f  72 06            jb loc_11797
1000:1791  b0 00            mov al, 0
1000:1793  c6 44 16 00      mov byte ptr [si + 0x16], 0
                            loc_11797:
1000:1797  8a d8            mov bl, al
1000:1799  b7 00            mov bh, 0
1000:179b  8a 87 4c 0e      mov al, byte ptr [bx + 0xe4c]
1000:179f  88 44 04         mov byte ptr [si + 4], al
1000:17a2  bb 52 0e         mov bx, 0xe52
1000:17a5  e8 79 09         call 0x2121
1000:17a8  e8 1b f9         call 0x10c6
1000:17ab  c3               ret 
                            sub_11783 ENDP
*/
void sub_11783()
{
    // coverage: 0x1983-0x19ac method sub_11783
    // coverage2: 1000:1783-1000:17ac method sub_11783 // ins(0x1783, 0x17ac, 0x1783);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    al = memoryAGet(ds, si + 22);
    al >>= 1;
    al &= 0x07;
    if (al < 0x06)
        goto loc_11797;
    al = 0x00;
    memoryASet(ds, si + 22, 0x00);
loc_11797:
    bl = al;
    bh = 0x00;
    al = memoryAGet(ds, bx + 3660);
    memoryASet(ds, si + 4, al);
    bx = 0x0e52;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:17ac sub_117ac()
                            sub_117ac PROC
1000:17ac  e8 ac 09         call 0x215b
1000:17af  83 f9 00         cmp cx, 0
1000:17b2  74 18            je loc_117cc
1000:17b4  fe 4c 16         dec byte ptr [si + 0x16]
1000:17b7  79 0b            jns loc_117c4
1000:17b9  c6 44 16 08      mov byte ptr [si + 0x16], 8
1000:17bd  c6 06 18 95 01   mov byte ptr [0x9518], 1
1000:17c2  eb 05            jmp loc_117c9
                            loc_117c4:
1000:17c4  c6 06 18 95 00   mov byte ptr [0x9518], 0
                            loc_117c9:
1000:17c9  e8 3f 07         call 0x1f0b
                            loc_117cc:
1000:17cc  bb 73 0e         mov bx, 0xe73
1000:17cf  e8 4f 09         call 0x2121
1000:17d2  e8 f1 f8         call 0x10c6
1000:17d5  c3               ret 
                            sub_117ac ENDP
*/
void sub_117ac()
{
    // coverage: 0x19ac-0x19d6 method sub_117ac
    // coverage2: 1000:17ac-1000:17d6 method sub_117ac // ins(0x17ac, 0x17d6, 0x17ac);
    sub_1215b();
    if (cx == 0x0000)
        goto loc_117cc;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_117c4;
    memoryASet(ds, si + 22, 0x08);
    memoryASet(ds, 0x9518, 0x01);
    goto loc_117c9;
loc_117c4:
    memoryASet(ds, 0x9518, 0x00);
loc_117c9:
    sub_11f0b();
loc_117cc:
    bx = 0x0e73;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:17d6 sub_117d6()
                            sub_117d6 PROC
1000:17d6  e8 82 09         call 0x215b
1000:17d9  83 f9 00         cmp cx, 0
1000:17dc  74 0c            je loc_117ea
1000:17de  fe 4c 16         dec byte ptr [si + 0x16]
1000:17e1  79 07            jns loc_117ea
1000:17e3  c6 44 16 12      mov byte ptr [si + 0x16], 0x12
1000:17e7  e8 1b 08         call 0x2005
                            loc_117ea:
1000:17ea  bb 9c 0e         mov bx, 0xe9c
1000:17ed  e8 31 09         call 0x2121
1000:17f0  e8 d3 f8         call 0x10c6
1000:17f3  c3               ret 
                            sub_117d6 ENDP
*/
void sub_117d6()
{
    // coverage: 0x19d6-0x19f4 method sub_117d6
    // coverage2: 1000:17d6-1000:17f4 method sub_117d6 // ins(0x17d6, 0x17f4, 0x17d6);
    sub_1215b();
    if (cx == 0x0000)
        goto loc_117ea;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_117ea;
    memoryASet(ds, si + 22, 0x12);
    sub_12005();
loc_117ea:
    bx = 0x0e9c;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:17f4 sub_117f4()
                            sub_117f4 PROC
1000:17f4  e8 cf f8         call 0x10c6
1000:17f7  8a 04            mov al, byte ptr [si]
1000:17f9  3c 00            cmp al, 0
1000:17fb  75 01            jne loc_117fe
1000:17fd  c3               ret 
                            loc_117fe:
1000:17fe  8a 44 01         mov al, byte ptr [si + 1]
1000:1801  3c 02            cmp al, 2
1000:1803  75 06            jne loc_1180b
1000:1805  83 44 07 03      add word ptr [si + 7], 3
1000:1809  eb 2a            jmp loc_11835
                            loc_1180b:
1000:180b  3c 00            cmp al, 0
1000:180d  75 06            jne loc_11815
1000:180f  83 6c 05 04      sub word ptr [si + 5], 4
1000:1813  eb 20            jmp loc_11835
                            loc_11815:
1000:1815  3c 01            cmp al, 1
1000:1817  75 0a            jne loc_11823
1000:1819  83 6c 05 04      sub word ptr [si + 5], 4
1000:181d  83 44 07 03      add word ptr [si + 7], 3
1000:1821  eb 12            jmp loc_11835
                            loc_11823:
1000:1823  3c 03            cmp al, 3
1000:1825  75 0a            jne loc_11831
1000:1827  83 44 05 04      add word ptr [si + 5], 4
1000:182b  83 44 07 03      add word ptr [si + 7], 3
1000:182f  eb 04            jmp loc_11835
                            loc_11831:
1000:1831  83 44 05 04      add word ptr [si + 5], 4
                            loc_11835:
1000:1835  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:183a  8b 44 05         mov ax, word ptr [si + 5]
1000:183d  3d 08 00         cmp ax, 8
1000:1840  7d 04            jge loc_11846
1000:1842  c6 04 00         mov byte ptr [si], 0
1000:1845  c3               ret 
                            loc_11846:
1000:1846  3d f8 00         cmp ax, 0xf8
1000:1849  7e 04            jle loc_1184f
1000:184b  c6 04 00         mov byte ptr [si], 0
1000:184e  c3               ret 
                            loc_1184f:
1000:184f  fe 44 16         inc byte ptr [si + 0x16]
1000:1852  8a 5c 16         mov bl, byte ptr [si + 0x16]
1000:1855  80 fb 10         cmp bl, 0x10
1000:1858  72 04            jb loc_1185e
1000:185a  e8 3c 08         call 0x2099
1000:185d  c3               ret 
                            loc_1185e:
1000:185e  b7 00            mov bh, 0
1000:1860  8a 87 67 14      mov al, byte ptr [bx + 0x1467]
1000:1864  00 44 03         add byte ptr [si + 3], al
1000:1867  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:186a  3c 11            cmp al, 0x11
1000:186c  75 01            jne loc_1186f
1000:186e  c3               ret 
                            loc_1186f:
1000:186f  8b 44 05         mov ax, word ptr [si + 5]
1000:1872  2b 06 8f 1b      sub ax, word ptr [0x1b8f]
1000:1876  79 02            jns loc_1187a
1000:1878  f7 d8            neg ax
                            loc_1187a:
1000:187a  3d 0e 00         cmp ax, 0xe
1000:187d  73 29            jae loc_118a8
1000:187f  8b 44 07         mov ax, word ptr [si + 7]
1000:1882  2b 06 91 1b      sub ax, word ptr [0x1b91]
1000:1886  79 02            jns loc_1188a
1000:1888  f7 d8            neg ax
                            loc_1188a:
1000:188a  3d 0a 00         cmp ax, 0xa
1000:188d  73 19            jae loc_118a8
1000:188f  8a 44 03         mov al, byte ptr [si + 3]
1000:1892  2a 06 8d 1b      sub al, byte ptr [0x1b8d]
1000:1896  79 02            jns loc_1189a
1000:1898  f6 d8            neg al
                            loc_1189a:
1000:189a  3c 10            cmp al, 0x10
1000:189c  73 0a            jae loc_118a8
1000:189e  83 2e 44 95 0a   sub word ptr [0x9544], 0xa
1000:18a3  b0 05            mov al, 5
1000:18a5  e8 98 1f         call 0x3840
                            loc_118a8:
1000:18a8  c3               ret 
                            sub_117f4 ENDP
*/
void sub_117f4()
{
    // coverage: 0x19f4-0x1aa9 method sub_117f4
    // coverage2: 1000:17f4-1000:18a9 method sub_117f4 // ins(0x17f4, 0x18a9, 0x17f4);
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_117fe;
    return;
loc_117fe:
    al = memoryAGet(ds, si + 1);
    if (al != 0x02)
        goto loc_1180b;
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0003);
    goto loc_11835;
loc_1180b:
    if (al != 0x00)
        goto loc_11815;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0004);
    goto loc_11835;
loc_11815:
    if (al != 0x01)
        goto loc_11823;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0004);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0003);
    goto loc_11835;
loc_11823:
    if (al != 0x03)
        goto loc_11831;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0004);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) + 0x0003);
    goto loc_11835;
loc_11831:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0004);
loc_11835:
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    ax = memoryAGet16(ds, si + 5);
    if ((short)ax >= (short)0x0008)
        goto loc_11846;
    memoryASet(ds, si, 0x00);
    return;
loc_11846:
    if ((short)ax <= (short)0x00f8)
        goto loc_1184f;
    memoryASet(ds, si, 0x00);
    return;
loc_1184f:
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + 1);
    bl = memoryAGet(ds, si + 22);
    if (bl < 0x10)
        goto loc_1185e;
    sub_12099();
    return;
loc_1185e:
    bh = 0x00;
    al = memoryAGet(ds, bx + 5223);
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + al);
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_1186f;
    return;
loc_1186f:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_1187a;
    ax = -ax;
loc_1187a:
    if (ax >= 0x000e)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_1188a;
    ax = -ax;
loc_1188a:
    if (ax >= 0x000a)
        return;
    al = memoryAGet(ds, si + 3);
    al -= memoryAGet(ds, 0x1b8d);
    if ((char)al >= 0)
        goto loc_1189a;
    al = -al;
loc_1189a:
    if (al >= 0x10)
        return;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) - 0x000a);
    al = 0x05;
    sub_13840();
}
/* Assembly listing of 1000:18a9 sub_118a9()
                            sub_118a9 PROC
1000:18a9  e8 af 08         call 0x215b
1000:18ac  83 f9 00         cmp cx, 0
1000:18af  74 0c            je loc_118bd
1000:18b1  fe 4c 16         dec byte ptr [si + 0x16]
1000:18b4  79 07            jns loc_118bd
1000:18b6  c6 44 16 28      mov byte ptr [si + 0x16], 0x28
1000:18ba  e8 fd 06         call 0x1fba
                            loc_118bd:
1000:18bd  bb c5 0e         mov bx, 0xec5
1000:18c0  e8 5e 08         call 0x2121
1000:18c3  e8 00 f8         call 0x10c6
1000:18c6  c3               ret 
                            sub_118a9 ENDP
*/
void sub_118a9()
{
    // coverage: 0x1aa9-0x1ac7 method sub_118a9
    // coverage2: 1000:18a9-1000:18c7 method sub_118a9 // ins(0x18a9, 0x18c7, 0x18a9);
    sub_1215b();
    if (cx == 0x0000)
        goto loc_118bd;
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) - 1);
    if ((char)memoryAGet(ds, si + 22) >= 0)
        goto loc_118bd;
    memoryASet(ds, si + 22, 0x28);
    sub_11fba();
loc_118bd:
    bx = 0x0ec5;
    sub_12121();
    sub_110c6();
}
/* Assembly listing of 1000:18c7 sub_118c7()
                            sub_118c7 PROC
1000:18c7  a0 2e 95         mov al, byte ptr [0x952e]
1000:18ca  22 06 2f 95      and al, byte ptr [0x952f]
1000:18ce  22 06 30 95      and al, byte ptr [0x9530]
1000:18d2  22 06 31 95      and al, byte ptr [0x9531]
1000:18d6  22 06 32 95      and al, byte ptr [0x9532]
1000:18da  22 06 33 95      and al, byte ptr [0x9533]
1000:18de  75 04            jne loc_118e4
1000:18e0  e8 e3 f7         call 0x10c6
1000:18e3  c3               ret 
                            loc_118e4:
1000:18e4  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:18e7  2b 44 05         sub ax, word ptr [si + 5]
1000:18ea  2d 0c 00         sub ax, 0xc
1000:18ed  79 02            jns loc_118f1
1000:18ef  f7 d8            neg ax
                            loc_118f1:
1000:18f1  8b 0e 91 1b      mov cx, word ptr [0x1b91]
1000:18f5  83 e9 08         sub cx, 8
1000:18f8  2b 4c 07         sub cx, word ptr [si + 7]
1000:18fb  79 02            jns loc_118ff
1000:18fd  f7 d9            neg cx
                            loc_118ff:
1000:18ff  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1902  d0 eb            shr bl, 1
1000:1904  03 c1            add ax, cx
1000:1906  3d 40 00         cmp ax, 0x40
1000:1909  77 0a            ja loc_11915
1000:190b  80 fb 08         cmp bl, 8
1000:190e  74 03            je loc_11913
1000:1910  fe 44 04         inc byte ptr [si + 4]
                            loc_11913:
1000:1913  eb 08            jmp loc_1191d
                            loc_11915:
1000:1915  80 fb 00         cmp bl, 0
1000:1918  74 03            je loc_1191d
1000:191a  fe 4c 04         dec byte ptr [si + 4]
                            loc_1191d:
1000:191d  53               push bx
1000:191e  b7 00            mov bh, 0
1000:1920  d1 e3            shl bx, 1
1000:1922  8b 87 83 14      mov ax, word ptr [bx + 0x1483]
1000:1926  89 44 0f         mov word ptr [si + 0xf], ax
1000:1929  5b               pop bx
1000:192a  80 fb 02         cmp bl, 2
1000:192d  72 3c            jb loc_1196b
1000:192f  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1932  2b 44 05         sub ax, word ptr [si + 5]
1000:1935  2d 0c 00         sub ax, 0xc
1000:1938  79 0d            jns loc_11947
1000:193a  f7 d8            neg ax
1000:193c  3d 18 00         cmp ax, 0x18
1000:193f  77 04            ja loc_11945
1000:1941  ff 06 8f 1b      inc word ptr [0x1b8f]
                            loc_11945:
1000:1945  eb 0b            jmp loc_11952
                            loc_11947:
1000:1947  74 09            je loc_11952
1000:1949  3d 18 00         cmp ax, 0x18
1000:194c  77 04            ja loc_11952
1000:194e  ff 0e 8f 1b      dec word ptr [0x1b8f]
                            loc_11952:
1000:1952  80 fb 08         cmp bl, 8
1000:1955  75 14            jne loc_1196b
1000:1957  83 f9 08         cmp cx, 8
1000:195a  77 0f            ja loc_1196b
1000:195c  3d 08 00         cmp ax, 8
1000:195f  77 0a            ja loc_1196b
1000:1961  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:1964  3c 11            cmp al, 0x11
1000:1966  74 03            je loc_1196b
1000:1968  e8 04 00         call 0x196f
                            loc_1196b:
1000:196b  e8 58 f7         call 0x10c6
1000:196e  c3               ret 
                            sub_118c7 ENDP
*/
void sub_118c7()
{
    // coverage: 0x1ac7-0x1b6f method sub_118c7
    // coverage2: 1000:18c7-1000:196f method sub_118c7 // ins(0x18c7, 0x196f, 0x18c7);
    al = memoryAGet(ds, 0x952e);
    al &= memoryAGet(ds, 0x952f);
    al &= memoryAGet(ds, 0x9530);
    al &= memoryAGet(ds, 0x9531);
    al &= memoryAGet(ds, 0x9532);
    al &= memoryAGet(ds, 0x9533);
    if (al != 0)
        goto loc_118e4;
    sub_110c6();
    return;
loc_118e4:
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_118f1;
    ax = -ax;
loc_118f1:
    cx = memoryAGet16(ds, 0x1b91);
    cx -= 0x0008;
    cx -= memoryAGet16(ds, si + 7);
    if ((short)cx >= 0)
        goto loc_118ff;
    cx = -cx;
loc_118ff:
    bl = memoryAGet(ds, si + 4);
    bl >>= 1;
    ax += cx;
    if (ax > 0x0040)
        goto loc_11915;
    if (bl == 0x08)
        goto loc_11913;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) + 1);
loc_11913:
    goto loc_1191d;
loc_11915:
    if (bl == 0x00)
        goto loc_1191d;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) - 1);
loc_1191d:
    push(bx);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5251);
    memoryASet16(ds, si + 15, ax);
    bx = pop();
    if (bl < 0x02)
        goto loc_1196b;
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11947;
    ax = -ax;
    if (ax > 0x0018)
        goto loc_11945;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) + 1);
loc_11945:
    goto loc_11952;
loc_11947:
    if (ax == 0)
        goto loc_11952;
    if (ax > 0x0018)
        goto loc_11952;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) - 1);
loc_11952:
    if (bl != 0x08)
        goto loc_1196b;
    if (cx > 0x0008)
        goto loc_1196b;
    if (ax > 0x0008)
        goto loc_1196b;
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_1196b;
    sub_1196f();
loc_1196b:
    sub_110c6();
}
/* Assembly listing of 1000:196f sub_1196f()
                            sub_1196f PROC
1000:196f  a0 8e 1b         mov al, byte ptr [0x1b8e]
1000:1972  3c 00            cmp al, 0
1000:1974  75 0c            jne loc_11982
1000:1976  c6 06 1d 95 f0   mov byte ptr [0x951d], 0xf0
1000:197b  c6 06 ff 94 01   mov byte ptr [0x94ff], 1
1000:1980  eb 10            jmp loc_11992
                            loc_11982:
1000:1982  56               push si
1000:1983  c6 06 8e 1b 00   mov byte ptr [0x1b8e], 0
1000:1988  be 8a 1b         mov si, 0x1b8a
1000:198b  bb 49 0d         mov bx, 0xd49
1000:198e  e8 90 07         call 0x2121
1000:1991  5e               pop si
                            loc_11992:
1000:1992  c3               ret 
                            sub_1196f ENDP
*/
void sub_1196f()
{
    // coverage: 0x1b6f-0x1b93 method sub_1196f
    // coverage2: 1000:196f-1000:1993 method sub_1196f // ins(0x196f, 0x1993, 0x196f);
    al = memoryAGet(ds, 0x1b8e);
    if (al != 0x00)
        goto loc_11982;
    memoryASet(ds, 0x951d, 0xf0);
    memoryASet(ds, 0x94ff, 0x01);
    return;
loc_11982:
    push(si);
    memoryASet(ds, 0x1b8e, 0x00);
    si = 0x1b8a;
    bx = 0x0d49;
    sub_12121();
    si = pop();
}
/* Assembly listing of 1000:1993 sub_11993()
                            sub_11993 PROC
1000:1993  e8 6e 00         call 0x1a04
1000:1996  a0 ff 94         mov al, byte ptr [0x94ff]
1000:1999  3c 01            cmp al, 1
1000:199b  75 24            jne loc_119c1
1000:199d  a0 01 95         mov al, byte ptr [0x9501]
1000:19a0  8a d8            mov bl, al
1000:19a2  d0 e0            shl al, 1
1000:19a4  02 d8            add bl, al
1000:19a6  02 1e 02 95      add bl, byte ptr [0x9502]
1000:19aa  b7 00            mov bh, 0
1000:19ac  d1 e3            shl bx, 1
1000:19ae  8b 87 95 14      mov ax, word ptr [bx + 0x1495]
1000:19b2  8a fc            mov bh, ah
1000:19b4  25 ff 03         and ax, 0x3ff
1000:19b7  a3 0c 95         mov word ptr [0x950c], ax
1000:19ba  80 e7 c0         and bh, 0xc0
1000:19bd  88 3e 1d 95      mov byte ptr [0x951d], bh
                            loc_119c1:
1000:19c1  c3               ret 
                            sub_11993 ENDP
*/
void sub_11993()
{
    // coverage: 0x1b93-0x1bc2 method sub_11993
    // coverage2: 1000:1993-1000:19c2 method sub_11993 // ins(0x1993, 0x19c2, 0x1993);
    sub_11a04();
    al = memoryAGet(ds, 0x94ff);
    if (al != 0x01)
        return;
    al = memoryAGet(ds, 0x9501);
    bl = al;
    al <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5269);
    bh = ah;
    ax &= 0x03ff;
    memoryASet16(ds, 0x950c, ax);
    bh &= 0xc0;
    memoryASet(ds, 0x951d, bh);
}
/* Assembly listing of 1000:19c2 sub_119c2()
                            sub_119c2 PROC
1000:19c2  e8 3f 00         call 0x1a04
1000:19c5  a0 ff 94         mov al, byte ptr [0x94ff]
1000:19c8  3c 01            cmp al, 1
1000:19ca  75 37            jne loc_11a03
1000:19cc  a0 01 95         mov al, byte ptr [0x9501]
1000:19cf  8a d8            mov bl, al
1000:19d1  d0 e0            shl al, 1
1000:19d3  02 d8            add bl, al
1000:19d5  02 1e 02 95      add bl, byte ptr [0x9502]
1000:19d9  b7 00            mov bh, 0
1000:19db  d1 e3            shl bx, 1
1000:19dd  8b 87 c5 14      mov ax, word ptr [bx + 0x14c5]
1000:19e1  8a fc            mov bh, ah
1000:19e3  25 ff 03         and ax, 0x3ff
1000:19e6  a3 0c 95         mov word ptr [0x950c], ax
1000:19e9  80 e7 c0         and bh, 0xc0
1000:19ec  88 3e 1d 95      mov byte ptr [0x951d], bh
1000:19f0  c6 06 0e 95 01   mov byte ptr [0x950e], 1
1000:19f5  a0 02 95         mov al, byte ptr [0x9502]
1000:19f8  fe c0            inc al
1000:19fa  3c 02            cmp al, 2
1000:19fc  76 02            jbe loc_11a00
1000:19fe  b0 00            mov al, 0
                            loc_11a00:
1000:1a00  a2 02 95         mov byte ptr [0x9502], al
                            loc_11a03:
1000:1a03  c3               ret 
                            sub_119c2 ENDP
*/
void sub_119c2()
{
    // coverage: 0x1bc2-0x1c04 method sub_119c2
    // coverage2: 1000:19c2-1000:1a04 method sub_119c2 // ins(0x19c2, 0x1a04, 0x19c2);
    sub_11a04();
    al = memoryAGet(ds, 0x94ff);
    if (al != 0x01)
        return;
    al = memoryAGet(ds, 0x9501);
    bl = al;
    al <<= 1;
    bl += al;
    bl += memoryAGet(ds, 0x9502);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5317);
    bh = ah;
    ax &= 0x03ff;
    memoryASet16(ds, 0x950c, ax);
    bh &= 0xc0;
    memoryASet(ds, 0x951d, bh);
    memoryASet(ds, 0x950e, 0x01);
    al = memoryAGet(ds, 0x9502);
    al++;
    if (al <= 0x02)
        goto loc_11a00;
    al = 0x00;
loc_11a00:
    memoryASet(ds, 0x9502, al);
}
/* Assembly listing of 1000:1a04 sub_11a04()
                            sub_11a04 PROC
1000:1a04  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1a07  2b 44 05         sub ax, word ptr [si + 5]
1000:1a0a  2d 0c 00         sub ax, 0xc
1000:1a0d  79 02            jns loc_11a11
1000:1a0f  f7 d8            neg ax
                            loc_11a11:
1000:1a11  8b 0e 91 1b      mov cx, word ptr [0x1b91]
1000:1a15  2b 4c 07         sub cx, word ptr [si + 7]
1000:1a18  79 02            jns loc_11a1c
1000:1a1a  f7 d9            neg cx
                            loc_11a1c:
1000:1a1c  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1a1f  d0 eb            shr bl, 1
1000:1a21  03 c1            add ax, cx
1000:1a23  3d 40 00         cmp ax, 0x40
1000:1a26  77 0a            ja loc_11a32
1000:1a28  80 fb 06         cmp bl, 6
1000:1a2b  74 03            je loc_11a30
1000:1a2d  fe 44 04         inc byte ptr [si + 4]
                            loc_11a30:
1000:1a30  eb 08            jmp loc_11a3a
                            loc_11a32:
1000:1a32  80 fb 00         cmp bl, 0
1000:1a35  74 03            je loc_11a3a
1000:1a37  fe 4c 04         dec byte ptr [si + 4]
                            loc_11a3a:
1000:1a3a  80 fb 06         cmp bl, 6
1000:1a3d  75 06            jne loc_11a45
1000:1a3f  c6 44 02 00      mov byte ptr [si + 2], 0
1000:1a43  eb 11            jmp loc_11a56
                            loc_11a45:
1000:1a45  53               push bx
1000:1a46  c6 44 02 07      mov byte ptr [si + 2], 7
1000:1a4a  b7 00            mov bh, 0
1000:1a4c  d1 e3            shl bx, 1
1000:1a4e  8b 87 77 14      mov ax, word ptr [bx + 0x1477]
1000:1a52  89 44 0f         mov word ptr [si + 0xf], ax
1000:1a55  5b               pop bx
                            loc_11a56:
1000:1a56  80 fb 01         cmp bl, 1
1000:1a59  72 3f            jb loc_11a9a
1000:1a5b  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1a5e  2b 44 05         sub ax, word ptr [si + 5]
1000:1a61  2d 0c 00         sub ax, 0xc
1000:1a64  79 0d            jns loc_11a73
1000:1a66  f7 d8            neg ax
1000:1a68  3d 18 00         cmp ax, 0x18
1000:1a6b  77 04            ja loc_11a71
1000:1a6d  ff 06 8f 1b      inc word ptr [0x1b8f]
                            loc_11a71:
1000:1a71  eb 0b            jmp loc_11a7e
                            loc_11a73:
1000:1a73  74 09            je loc_11a7e
1000:1a75  3d 18 00         cmp ax, 0x18
1000:1a78  77 04            ja loc_11a7e
1000:1a7a  ff 0e 8f 1b      dec word ptr [0x1b8f]
                            loc_11a7e:
1000:1a7e  83 f9 08         cmp cx, 8
1000:1a81  77 17            ja loc_11a9a
1000:1a83  3d 08 00         cmp ax, 8
1000:1a86  77 12            ja loc_11a9a
1000:1a88  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:1a8b  3c 11            cmp al, 0x11
1000:1a8d  74 0b            je loc_11a9a
1000:1a8f  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1a92  a3 0a 95         mov word ptr [0x950a], ax
1000:1a95  c6 06 ff 94 01   mov byte ptr [0x94ff], 1
                            loc_11a9a:
1000:1a9a  e8 29 f6         call 0x10c6
1000:1a9d  c3               ret 
                            sub_11a04 ENDP
*/
void sub_11a04()
{
    // coverage: 0x1c04-0x1c9e method sub_11a04
    // coverage2: 1000:1a04-1000:1a9e method sub_11a04 // ins(0x1a04, 0x1a9e, 0x1a04);
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11a11;
    ax = -ax;
loc_11a11:
    cx = memoryAGet16(ds, 0x1b91);
    cx -= memoryAGet16(ds, si + 7);
    if ((short)cx >= 0)
        goto loc_11a1c;
    cx = -cx;
loc_11a1c:
    bl = memoryAGet(ds, si + 4);
    bl >>= 1;
    ax += cx;
    if (ax > 0x0040)
        goto loc_11a32;
    if (bl == 0x06)
        goto loc_11a30;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) + 1);
loc_11a30:
    goto loc_11a3a;
loc_11a32:
    if (bl == 0x00)
        goto loc_11a3a;
    memoryASet(ds, si + 4, memoryAGet(ds, si + 4) - 1);
loc_11a3a:
    if (bl != 0x06)
        goto loc_11a45;
    memoryASet(ds, si + 2, 0x00);
    goto loc_11a56;
loc_11a45:
    push(bx);
    memoryASet(ds, si + 2, 0x07);
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5239);
    memoryASet16(ds, si + 15, ax);
    bx = pop();
loc_11a56:
    if (bl < 0x01)
        goto loc_11a9a;
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11a73;
    ax = -ax;
    if (ax > 0x0018)
        goto loc_11a71;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) + 1);
loc_11a71:
    goto loc_11a7e;
loc_11a73:
    if (ax == 0)
        goto loc_11a7e;
    if (ax > 0x0018)
        goto loc_11a7e;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) - 1);
loc_11a7e:
    if (cx > 0x0008)
        goto loc_11a9a;
    if (ax > 0x0008)
        goto loc_11a9a;
    al = memoryAGet(ds, 0x1b9c);
    if (al == 0x11)
        goto loc_11a9a;
    ax = memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, 0x950a, ax);
    memoryASet(ds, 0x94ff, 0x01);
loc_11a9a:
    sub_110c6();
}
/* Assembly listing of 1000:1a9e sub_11a9e()
                            sub_11a9e PROC
1000:1a9e  e8 25 f6         call 0x10c6
1000:1aa1  8a 04            mov al, byte ptr [si]
1000:1aa3  3c 00            cmp al, 0
1000:1aa5  75 01            jne loc_11aa8
1000:1aa7  c3               ret 
                            loc_11aa8:
1000:1aa8  8b 1e 91 1b      mov bx, word ptr [0x1b91]
1000:1aac  2b 5c 07         sub bx, word ptr [si + 7]
1000:1aaf  79 0a            jns loc_11abb
1000:1ab1  83 fb f0         cmp bx, -0x10
1000:1ab4  7d 04            jge loc_11aba
1000:1ab6  c6 44 02 01      mov byte ptr [si + 2], 1
                            loc_11aba:
1000:1aba  c3               ret 
                            loc_11abb:
1000:1abb  83 fb 20         cmp bx, 0x20
1000:1abe  7e 01            jle loc_11ac1
1000:1ac0  c3               ret 
                            loc_11ac1:
1000:1ac1  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1ac4  2b 44 05         sub ax, word ptr [si + 5]
1000:1ac7  2d 0c 00         sub ax, 0xc
1000:1aca  79 0d            jns loc_11ad9
1000:1acc  f7 d8            neg ax
1000:1ace  3d 18 00         cmp ax, 0x18
1000:1ad1  73 04            jae loc_11ad7
1000:1ad3  ff 06 8f 1b      inc word ptr [0x1b8f]
                            loc_11ad7:
1000:1ad7  eb 0e            jmp loc_11ae7
                            loc_11ad9:
1000:1ad9  3d 18 00         cmp ax, 0x18
1000:1adc  73 09            jae loc_11ae7
1000:1ade  3d 00 00         cmp ax, 0
1000:1ae1  74 04            je loc_11ae7
1000:1ae3  ff 0e 8f 1b      dec word ptr [0x1b8f]
                            loc_11ae7:
1000:1ae7  83 fb 08         cmp bx, 8
1000:1aea  76 01            jbe loc_11aed
1000:1aec  c3               ret 
                            loc_11aed:
1000:1aed  3d 02 00         cmp ax, 2
1000:1af0  77 06            ja loc_11af8
1000:1af2  ff 06 38 95      inc word ptr [0x9538]
1000:1af6  eb 10            jmp loc_11b08
                            loc_11af8:
1000:1af8  3d 24 00         cmp ax, 0x24
1000:1afb  73 0b            jae loc_11b08
1000:1afd  c7 06 42 95 00 00  mov word ptr [0x9542], 0
1000:1b03  b0 06            mov al, 6
1000:1b05  e8 38 1d         call 0x3840
                            loc_11b08:
1000:1b08  c3               ret 
                            sub_11a9e ENDP
*/
void sub_11a9e()
{
    // coverage: 0x1c9e-0x1d09 method sub_11a9e
    // coverage2: 1000:1a9e-1000:1b09 method sub_11a9e // ins(0x1a9e, 0x1b09, 0x1a9e);
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11aa8;
    return;
loc_11aa8:
    bx = memoryAGet16(ds, 0x1b91);
    bx -= memoryAGet16(ds, si + 7);
    if ((short)bx >= 0)
        goto loc_11abb;
    if ((short)bx >= (short)0xfff0)
        goto loc_11aba;
    memoryASet(ds, si + 2, 0x01);
loc_11aba:
    return;
loc_11abb:
    if ((short)bx <= (short)0x0020)
        goto loc_11ac1;
    return;
loc_11ac1:
    ax = memoryAGet16(ds, 0x1b8f);
    ax -= memoryAGet16(ds, si + 5);
    ax -= 0x000c;
    if ((short)ax >= 0)
        goto loc_11ad9;
    ax = -ax;
    if (ax >= 0x0018)
        goto loc_11ad7;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) + 1);
loc_11ad7:
    goto loc_11ae7;
loc_11ad9:
    if (ax >= 0x0018)
        goto loc_11ae7;
    if (ax == 0x0000)
        goto loc_11ae7;
    memoryASet16(ds, 0x1b8f, memoryAGet16(ds, 0x1b8f) - 1);
loc_11ae7:
    if (bx <= 0x0008)
        goto loc_11aed;
    return;
loc_11aed:
    if (ax > 0x0002)
        goto loc_11af8;
    memoryASet16(ds, 0x9538, memoryAGet16(ds, 0x9538) + 1);
    return;
loc_11af8:
    if (ax >= 0x0024)
        return;
    memoryASet16(ds, 0x9542, 0x0000);
    al = 0x06;
    sub_13840();
}
/* Assembly listing of 1000:1b09 sub_11b09()
                            sub_11b09 PROC
1000:1b09  e8 ba f5         call 0x10c6
1000:1b0c  8a 04            mov al, byte ptr [si]
1000:1b0e  3c 00            cmp al, 0
1000:1b10  75 01            jne loc_11b13
1000:1b12  c3               ret 
                            loc_11b13:
1000:1b13  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:1b16  3c 11            cmp al, 0x11
1000:1b18  75 01            jne loc_11b1b
1000:1b1a  c3               ret 
                            loc_11b1b:
1000:1b1b  8b 44 05         mov ax, word ptr [si + 5]
1000:1b1e  2b 06 8f 1b      sub ax, word ptr [0x1b8f]
1000:1b22  79 02            jns loc_11b26
1000:1b24  f7 d8            neg ax
                            loc_11b26:
1000:1b26  3d 12 00         cmp ax, 0x12
1000:1b29  73 1e            jae loc_11b49
1000:1b2b  8b 44 07         mov ax, word ptr [si + 7]
1000:1b2e  2b 06 91 1b      sub ax, word ptr [0x1b91]
1000:1b32  79 02            jns loc_11b36
1000:1b34  f7 d8            neg ax
                            loc_11b36:
1000:1b36  3d 10 00         cmp ax, 0x10
1000:1b39  73 0e            jae loc_11b49
1000:1b3b  c6 04 00         mov byte ptr [si], 0
1000:1b3e  8a 44 01         mov al, byte ptr [si + 1]
1000:1b41  e8 e4 0f         call 0x2b28
1000:1b44  b0 0a            mov al, 0xa
1000:1b46  e8 f7 1c         call 0x3840
                            loc_11b49:
1000:1b49  c3               ret 
                            sub_11b09 ENDP
*/
void sub_11b09()
{
    // coverage: 0x1d09-0x1d4a method sub_11b09
    // coverage2: 1000:1b09-1000:1b4a method sub_11b09 // ins(0x1b09, 0x1b4a, 0x1b09);
    sub_110c6();
    al = memoryAGet(ds, si);
    if (al != 0x00)
        goto loc_11b13;
    return;
loc_11b13:
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_11b1b;
    return;
loc_11b1b:
    ax = memoryAGet16(ds, si + 5);
    ax -= memoryAGet16(ds, 0x1b8f);
    if ((short)ax >= 0)
        goto loc_11b26;
    ax = -ax;
loc_11b26:
    if (ax >= 0x0012)
        return;
    ax = memoryAGet16(ds, si + 7);
    ax -= memoryAGet16(ds, 0x1b91);
    if ((short)ax >= 0)
        goto loc_11b36;
    ax = -ax;
loc_11b36:
    if (ax >= 0x0010)
        return;
    memoryASet(ds, si, 0x00);
    al = memoryAGet(ds, si + 1);
    sub_12b28();
    al = 0x0a;
    sub_13840();
}
/* Assembly listing of 1000:1b4a sub_11b4a()
                            sub_11b4a PROC
1000:1b4a  83 6c 07 02      sub word ptr [si + 7], 2
1000:1b4e  81 64 07 ff 03   and word ptr [si + 7], 0x3ff
1000:1b53  e8 4a f5         call 0x10a0
1000:1b56  c3               ret 
                            sub_11b4a ENDP
*/
void sub_11b4a()
{
    // coverage: 0x1d4a-0x1d57 method sub_11b4a
    // coverage2: 1000:1b4a-1000:1b57 method sub_11b4a // ins(0x1b4a, 0x1b57, 0x1b4a);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) - 0x0002);
    memoryASet16(ds, si + 7, memoryAGet16(ds, si + 7) & 0x03ff);
    sub_110a0();
}
/* Assembly listing of 1000:1b57 sub_11b57()
                            sub_11b57 PROC
1000:1b57  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1b5a  50               push ax
1000:1b5b  a1 28 95         mov ax, word ptr [0x9528]
1000:1b5e  05 70 00         add ax, 0x70
1000:1b61  25 ff 03         and ax, 0x3ff
1000:1b64  a3 91 1b         mov word ptr [0x1b91], ax
1000:1b67  50               push ax
1000:1b68  e8 92 ec         call 0x7fd
1000:1b6b  a2 8d 1b         mov byte ptr [0x1b8d], al
1000:1b6e  88 0e 9e 1b      mov byte ptr [0x1b9e], cl
1000:1b72  88 1e 8e 1b      mov byte ptr [0x1b8e], bl
1000:1b76  be 8a 1b         mov si, 0x1b8a
1000:1b79  bb 49 0d         mov bx, 0xd49
1000:1b7c  e8 a2 05         call 0x2121
1000:1b7f  c3               ret 
                            sub_11b57 ENDP
*/
void sub_11b57()
{
    // coverage: 0x1d57-0x1d80 method sub_11b57
    // coverage2: 1000:1b57-1000:1b80 method sub_11b57 // ins(0x1b57, 0x1b80, 0x1b57);
    ax = memoryAGet16(ds, 0x1b8f);
    push(ax);
    ax = memoryAGet16(ds, 0x9528);
    ax += 0x0070;
    ax &= 0x03ff;
    memoryASet16(ds, 0x1b91, ax);
    push(ax);
    sub_107fd();
    memoryASet(ds, 0x1b8d, al);
    memoryASet(ds, 0x1b9e, cl);
    memoryASet(ds, 0x1b8e, bl);
    si = 0x1b8a;
    bx = 0x0d49;
    sub_12121();
}
/* Assembly listing of 1000:1b80 sub_11b80()
                            sub_11b80 PROC
1000:1b80  8b 1e 2a 95      mov bx, word ptr [0x952a]
1000:1b84  a1 3a 95         mov ax, word ptr [0x953a]
1000:1b87  3d 00 00         cmp ax, 0
1000:1b8a  7f 05            jg loc_11b91
1000:1b8c  b8 08 00         mov ax, 8
1000:1b8f  eb 03            jmp loc_11b94
                            loc_11b91:
1000:1b91  a1 4c 95         mov ax, word ptr [0x954c]
                            loc_11b94:
1000:1b94  a8 04            test al, 4
1000:1b96  74 0b            je loc_11ba3
1000:1b98  43               inc bx
1000:1b99  83 fb 40         cmp bx, 0x40
1000:1b9c  7e 03            jle loc_11ba1
1000:1b9e  bb 40 00         mov bx, 0x40
                            loc_11ba1:
1000:1ba1  eb 11            jmp loc_11bb4
                            loc_11ba3:
1000:1ba3  a8 08            test al, 8
1000:1ba5  74 0d            je loc_11bb4
1000:1ba7  83 eb 02         sub bx, 2
1000:1baa  3b 1e fc 94      cmp bx, word ptr [0x94fc]
1000:1bae  7d 04            jge loc_11bb4
1000:1bb0  8b 1e fc 94      mov bx, word ptr [0x94fc]
                            loc_11bb4:
1000:1bb4  89 1e 2a 95      mov word ptr [0x952a], bx
1000:1bb8  c3               ret 
                            sub_11b80 ENDP
*/
void sub_11b80()
{
    // coverage: 0x1d80-0x1db9 method sub_11b80
    // coverage2: 1000:1b80-1000:1bb9 method sub_11b80 // ins(0x1b80, 0x1bb9, 0x1b80);
    bx = memoryAGet16(ds, 0x952a);
    ax = memoryAGet16(ds, 0x953a);
    if ((short)ax > (short)0x0000)
        goto loc_11b91;
    ax = 0x0008;
    goto loc_11b94;
loc_11b91:
    ax = memoryAGet16(ds, 0x954c);
loc_11b94:
    if (!(al & 0x04))
        goto loc_11ba3;
    bx++;
    if ((short)bx <= (short)0x0040)
        goto loc_11ba1;
    bx = 0x0040;
loc_11ba1:
    goto loc_11bb4;
loc_11ba3:
    if (!(al & 0x08))
        goto loc_11bb4;
    bx -= 0x0002;
    if ((short)bx >= (short)memoryAGet16(ds, 0x94fc))
        goto loc_11bb4;
    bx = memoryAGet16(ds, 0x94fc);
loc_11bb4:
    memoryASet16(ds, 0x952a, bx);
}
/* Assembly listing of 1000:1bb9 sub_11bb9()
                            sub_11bb9 PROC
1000:1bb9  8b 1e 2a 95      mov bx, word ptr [0x952a]
1000:1bbd  83 c3 0f         add bx, 0xf
1000:1bc0  d1 eb            shr bx, 1
1000:1bc2  d1 eb            shr bx, 1
1000:1bc4  d1 eb            shr bx, 1
1000:1bc6  8b c3            mov ax, bx
1000:1bc8  48               dec ax
1000:1bc9  d1 eb            shr bx, 1
1000:1bcb  03 06 0f 95      add ax, word ptr [0x950f]
1000:1bcf  3d 8b 00         cmp ax, 0x8b
1000:1bd2  76 09            jbe loc_11bdd
1000:1bd4  b8 00 00         mov ax, 0
1000:1bd7  c7 06 3c 95 ff ff  mov word ptr [0x953c], 0xffff
                            loc_11bdd:
1000:1bdd  a3 0f 95         mov word ptr [0x950f], ax
1000:1be0  a1 28 95         mov ax, word ptr [0x9528]
1000:1be3  2b c3            sub ax, bx
1000:1be5  25 ff 03         and ax, 0x3ff
1000:1be8  a3 28 95         mov word ptr [0x9528], ax
1000:1beb  a1 28 95         mov ax, word ptr [0x9528]
1000:1bee  d1 e8            shr ax, 1
1000:1bf0  d1 e8            shr ax, 1
1000:1bf2  d1 e8            shr ax, 1
1000:1bf4  d1 e8            shr ax, 1
1000:1bf6  2d 03 00         sub ax, 3
1000:1bf9  25 3f 00         and ax, 0x3f
1000:1bfc  3b 06 07 95      cmp ax, word ptr [0x9507]
1000:1c00  74 07            je loc_11c09
1000:1c02  a3 07 95         mov word ptr [0x9507], ax
1000:1c05  50               push ax
1000:1c06  e8 b1 ec         call 0x8ba
                            loc_11c09:
1000:1c09  c3               ret 
                            sub_11bb9 ENDP
*/
void sub_11bb9()
{
    // coverage: 0x1db9-0x1e0a method sub_11bb9
    // coverage2: 1000:1bb9-1000:1c0a method sub_11bb9 // ins(0x1bb9, 0x1c0a, 0x1bb9);
    bx = memoryAGet16(ds, 0x952a);
    bx += 0x000f;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    ax = bx;
    ax--;
    bx >>= 1;
    ax += memoryAGet16(ds, 0x950f);
    if (ax <= 0x008b)
        goto loc_11bdd;
    ax = 0x0000;
    memoryASet16(ds, 0x953c, 0xffff);
loc_11bdd:
    memoryASet16(ds, 0x950f, ax);
    ax = memoryAGet16(ds, 0x9528);
    ax -= bx;
    ax &= 0x03ff;
    memoryASet16(ds, 0x9528, ax);
    ax = memoryAGet16(ds, 0x9528);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax -= 0x0003;
    ax &= 0x003f;
    if (ax == memoryAGet16(ds, 0x9507))
        return;
    memoryASet16(ds, 0x9507, ax);
    push(ax);
    sub_108ba();
}
/* Assembly listing of 1000:1c0a sub_11c0a()
                            sub_11c0a PROC
1000:1c0a  55               push bp
1000:1c0b  8b ec            mov bp, sp
1000:1c0d  8b 5e 06         mov bx, word ptr [bp + 6]
1000:1c10  8b 4e 04         mov cx, word ptr [bp + 4]
1000:1c13  be 8a 1b         mov si, 0x1b8a
                            loc_11c16:
1000:1c16  8a 04            mov al, byte ptr [si]
1000:1c18  a8 80            test al, 0x80
1000:1c1a  75 13            jne loc_11c2f
1000:1c1c  a8 08            test al, 8
1000:1c1e  74 0a            je loc_11c2a
1000:1c20  3a 4c 14         cmp cl, byte ptr [si + 0x14]
1000:1c23  75 05            jne loc_11c2a
1000:1c25  3a 5c 13         cmp bl, byte ptr [si + 0x13]
1000:1c28  74 05            je loc_11c2f
                            loc_11c2a:
1000:1c2a  83 c6 17         add si, 0x17
1000:1c2d  eb e7            jmp loc_11c16
                            loc_11c2f:
1000:1c2f  5d               pop bp
1000:1c30  c2 04 00         ret 4
                            sub_11c0a ENDP
*/
void sub_11c0a()
{
    // coverage: 0x1e0a-0x1e33 method sub_11c0a
    // coverage2: 1000:1c0a-1000:1c33 method sub_11c0a // ins(0x1c0a, 0x1c33, 0x1c0a);
    push(bp);
    bp = sp;
    bx = memoryAGet16(ss, bp + 6 - 2);
    cx = memoryAGet16(ss, bp + 4 - 2);
    si = 0x1b8a;
loc_11c16:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_11c2f;
    if (!(al & 0x08))
        goto loc_11c2a;
    if (cl != memoryAGet(ds, si + 20))
        goto loc_11c2a;
    if (bl == memoryAGet(ds, si + 19))
        goto loc_11c2f;
loc_11c2a:
    si += 0x0017;
    goto loc_11c16;
loc_11c2f:
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:1c33 sub_11c33()
                            sub_11c33 PROC
1000:1c33  a0 9c 1b         mov al, byte ptr [0x1b9c]
1000:1c36  3c 11            cmp al, 0x11
1000:1c38  75 01            jne loc_11c3b
1000:1c3a  c3               ret 
                            loc_11c3b:
1000:1c3b  b0 0c            mov al, 0xc
1000:1c3d  e8 00 1c         call 0x3840
1000:1c40  be 8a 1b         mov si, 0x1b8a
1000:1c43  e8 aa 04         call 0x20f0
1000:1c46  c6 06 9c 1b 11   mov byte ptr [0x1b9c], 0x11
1000:1c4b  c6 06 8c 1b 00   mov byte ptr [0x1b8c], 0
1000:1c50  c6 06 14 95 00   mov byte ptr [0x9514], 0
1000:1c55  c3               ret 
                            sub_11c33 ENDP
*/
void sub_11c33()
{
    // coverage: 0x1e33-0x1e56 method sub_11c33
    // coverage2: 1000:1c33-1000:1c56 method sub_11c33 // ins(0x1c33, 0x1c56, 0x1c33);
    al = memoryAGet(ds, 0x1b9c);
    if (al != 0x11)
        goto loc_11c3b;
    return;
loc_11c3b:
    al = 0x0c;
    sub_13840();
    si = 0x1b8a;
    sub_120f0();
    memoryASet(ds, 0x1b9c, 0x11);
    memoryASet(ds, 0x1b8c, 0x00);
    memoryASet(ds, 0x9514, 0x00);
}
/* Assembly listing of 1000:1c56 sub_11c56()
                            sub_11c56 PROC
1000:1c56  f7 d8            neg ax
1000:1c58  a3 44 95         mov word ptr [0x9544], ax
1000:1c5b  50               push ax
1000:1c5c  b0 06            mov al, 6
1000:1c5e  e8 df 1b         call 0x3840
1000:1c61  58               pop ax
1000:1c62  8b c3            mov ax, bx
1000:1c64  50               push ax
1000:1c65  a0 9e 1b         mov al, byte ptr [0x1b9e]
1000:1c68  b4 00            mov ah, 0
1000:1c6a  50               push ax
1000:1c6b  e8 9c ff         call 0x1c0a
1000:1c6e  8a 04            mov al, byte ptr [si]
1000:1c70  a8 80            test al, 0x80
1000:1c72  75 03            jne loc_11c77
1000:1c74  e8 64 04         call 0x20db
                            loc_11c77:
1000:1c77  c3               ret 
                            sub_11c56 ENDP
*/
void sub_11c56()
{
    // coverage: 0x1e56-0x1e78 method sub_11c56
    // coverage2: 1000:1c56-1000:1c78 method sub_11c56 // ins(0x1c56, 0x1c78, 0x1c56);
    ax = -ax;
    memoryASet16(ds, 0x9544, ax);
    push(ax);
    al = 0x06;
    sub_13840();
    ax = pop();
    ax = bx;
    push(ax);
    al = memoryAGet(ds, 0x1b9e);
    ah = 0x00;
    push(ax);
    sub_11c0a();
    al = memoryAGet(ds, si);
    if (al & 0x80)
        return;
    sub_120db();
}
/* Assembly listing of 1000:1c78 sub_11c78()
                            sub_11c78 PROC
1000:1c78  a1 37 94         mov ax, word ptr [0x9437]
1000:1c7b  a3 39 94         mov word ptr [0x9439], ax
1000:1c7e  a1 35 94         mov ax, word ptr [0x9435]
1000:1c81  a3 37 94         mov word ptr [0x9437], ax
1000:1c84  a1 33 94         mov ax, word ptr [0x9433]
1000:1c87  a3 35 94         mov word ptr [0x9435], ax
1000:1c8a  a1 8f 1b         mov ax, word ptr [0x1b8f]
1000:1c8d  a3 33 94         mov word ptr [0x9433], ax
1000:1c90  a1 3f 94         mov ax, word ptr [0x943f]
1000:1c93  a3 41 94         mov word ptr [0x9441], ax
1000:1c96  a1 3d 94         mov ax, word ptr [0x943d]
1000:1c99  a3 3f 94         mov word ptr [0x943f], ax
1000:1c9c  a1 3b 94         mov ax, word ptr [0x943b]
1000:1c9f  a3 3d 94         mov word ptr [0x943d], ax
1000:1ca2  a1 91 1b         mov ax, word ptr [0x1b91]
1000:1ca5  a3 3b 94         mov word ptr [0x943b], ax
1000:1ca8  a0 45 94         mov al, byte ptr [0x9445]
1000:1cab  a2 46 94         mov byte ptr [0x9446], al
1000:1cae  a0 44 94         mov al, byte ptr [0x9444]
1000:1cb1  a2 45 94         mov byte ptr [0x9445], al
1000:1cb4  a0 43 94         mov al, byte ptr [0x9443]
1000:1cb7  a2 44 94         mov byte ptr [0x9444], al
1000:1cba  a0 8e 1b         mov al, byte ptr [0x1b8e]
1000:1cbd  a2 43 94         mov byte ptr [0x9443], al
1000:1cc0  a0 49 94         mov al, byte ptr [0x9449]
1000:1cc3  a2 4a 94         mov byte ptr [0x944a], al
1000:1cc6  a0 48 94         mov al, byte ptr [0x9448]
1000:1cc9  a2 49 94         mov byte ptr [0x9449], al
1000:1ccc  a0 47 94         mov al, byte ptr [0x9447]
1000:1ccf  a2 48 94         mov byte ptr [0x9448], al
1000:1cd2  a0 8d 1b         mov al, byte ptr [0x1b8d]
1000:1cd5  a2 47 94         mov byte ptr [0x9447], al
1000:1cd8  c3               ret 
                            sub_11c78 ENDP
*/
void sub_11c78()
{
    // coverage: 0x1e78-0x1ed9 method sub_11c78
    // coverage2: 1000:1c78-1000:1cd9 method sub_11c78 // ins(0x1c78, 0x1cd9, 0x1c78);
    ax = memoryAGet16(ds, 0x9437);
    memoryASet16(ds, 0x9439, ax);
    ax = memoryAGet16(ds, 0x9435);
    memoryASet16(ds, 0x9437, ax);
    ax = memoryAGet16(ds, 0x9433);
    memoryASet16(ds, 0x9435, ax);
    ax = memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, 0x9433, ax);
    ax = memoryAGet16(ds, 0x943f);
    memoryASet16(ds, 0x9441, ax);
    ax = memoryAGet16(ds, 0x943d);
    memoryASet16(ds, 0x943f, ax);
    ax = memoryAGet16(ds, 0x943b);
    memoryASet16(ds, 0x943d, ax);
    ax = memoryAGet16(ds, 0x1b91);
    memoryASet16(ds, 0x943b, ax);
    al = memoryAGet(ds, 0x9445);
    memoryASet(ds, 0x9446, al);
    al = memoryAGet(ds, 0x9444);
    memoryASet(ds, 0x9445, al);
    al = memoryAGet(ds, 0x9443);
    memoryASet(ds, 0x9444, al);
    al = memoryAGet(ds, 0x1b8e);
    memoryASet(ds, 0x9443, al);
    al = memoryAGet(ds, 0x9449);
    memoryASet(ds, 0x944a, al);
    al = memoryAGet(ds, 0x9448);
    memoryASet(ds, 0x9449, al);
    al = memoryAGet(ds, 0x9447);
    memoryASet(ds, 0x9448, al);
    al = memoryAGet(ds, 0x1b8d);
    memoryASet(ds, 0x9447, al);
}
/* Assembly listing of 1000:1cd9 sub_11cd9()
                            sub_11cd9 PROC
1000:1cd9  a1 39 94         mov ax, word ptr [0x9439]
1000:1cdc  89 44 05         mov word ptr [si + 5], ax
1000:1cdf  a1 41 94         mov ax, word ptr [0x9441]
1000:1ce2  05 06 00         add ax, 6
1000:1ce5  25 ff 03         and ax, 0x3ff
1000:1ce8  89 44 07         mov word ptr [si + 7], ax
1000:1ceb  a0 46 94         mov al, byte ptr [0x9446]
1000:1cee  88 44 04         mov byte ptr [si + 4], al
1000:1cf1  8a d8            mov bl, al
1000:1cf3  b7 00            mov bh, 0
1000:1cf5  8a 8f b9 0d      mov cl, byte ptr [bx + 0xdb9]
1000:1cf9  a0 4a 94         mov al, byte ptr [0x944a]
1000:1cfc  04 06            add al, 6
1000:1cfe  88 44 03         mov byte ptr [si + 3], al
1000:1d01  8a 04            mov al, byte ptr [si]
1000:1d03  a8 20            test al, 0x20
1000:1d05  75 09            jne loc_11d10
1000:1d07  83 6c 05 08      sub word ptr [si + 5], 8
1000:1d0b  00 4c 03         add byte ptr [si + 3], cl
1000:1d0e  eb 07            jmp loc_11d17
                            loc_11d10:
1000:1d10  83 44 05 08      add word ptr [si + 5], 8
1000:1d14  28 4c 03         sub byte ptr [si + 3], cl
                            loc_11d17:
1000:1d17  bb da 0d         mov bx, 0xdda
1000:1d1a  e8 04 04         call 0x2121
1000:1d1d  c3               ret 
                            sub_11cd9 ENDP
*/
void sub_11cd9()
{
    // coverage: 0x1ed9-0x1f1e method sub_11cd9
    // coverage2: 1000:1cd9-1000:1d1e method sub_11cd9 // ins(0x1cd9, 0x1d1e, 0x1cd9);
    ax = memoryAGet16(ds, 0x9439);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x9441);
    ax += 0x0006;
    ax &= 0x03ff;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x9446);
    memoryASet(ds, si + 4, al);
    bl = al;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 3513);
    al = memoryAGet(ds, 0x944a);
    al += 0x06;
    memoryASet(ds, si + 3, al);
    al = memoryAGet(ds, si);
    if (al & 0x20)
        goto loc_11d10;
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) - 0x0008);
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) + cl);
    goto loc_11d17;
loc_11d10:
    memoryASet16(ds, si + 5, memoryAGet16(ds, si + 5) + 0x0008);
    memoryASet(ds, si + 3, memoryAGet(ds, si + 3) - cl);
loc_11d17:
    bx = 0x0dda;
    sub_12121();
}
/* Assembly listing of 1000:1d1e sub_11d1e()
                            sub_11d1e PROC
1000:1d1e  be 5e 13         mov si, 0x135e
1000:1d21  80 24 df         and byte ptr [si], 0xdf
1000:1d24  8a 1e 8e 1b      mov bl, byte ptr [0x1b8e]
1000:1d28  b7 00            mov bh, 0
1000:1d2a  8a 87 9d 13      mov al, byte ptr [bx + 0x139d]
1000:1d2e  88 44 04         mov byte ptr [si + 4], al
1000:1d31  8a 87 75 13      mov al, byte ptr [bx + 0x1375]
1000:1d35  98               cwde 
1000:1d36  03 06 8f 1b      add ax, word ptr [0x1b8f]
1000:1d3a  89 44 05         mov word ptr [si + 5], ax
1000:1d3d  a1 91 1b         mov ax, word ptr [0x1b91]
1000:1d40  2d 04 00         sub ax, 4
1000:1d43  25 ff 03         and ax, 0x3ff
1000:1d46  89 44 07         mov word ptr [si + 7], ax
1000:1d49  a0 8d 1b         mov al, byte ptr [0x1b8d]
1000:1d4c  02 87 89 13      add al, byte ptr [bx + 0x1389]
1000:1d50  88 44 03         mov byte ptr [si + 3], al
1000:1d53  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1d56  b7 00            mov bh, 0
1000:1d58  8a 87 a7 13      mov al, byte ptr [bx + 0x13a7]
1000:1d5c  88 44 0a         mov byte ptr [si + 0xa], al
1000:1d5f  d1 e3            shl bx, 1
1000:1d61  8b 87 aa 13      mov ax, word ptr [bx + 0x13aa]
1000:1d65  89 44 0f         mov word ptr [si + 0xf], ax
1000:1d68  e8 ed ed         call 0xb58
1000:1d6b  be f7 0f         mov si, 0xff7
1000:1d6e  a1 63 13         mov ax, word ptr [0x1363]
1000:1d71  89 44 05         mov word ptr [si + 5], ax
1000:1d74  a1 65 13         mov ax, word ptr [0x1365]
1000:1d77  89 44 07         mov word ptr [si + 7], ax
1000:1d7a  a0 61 13         mov al, byte ptr [0x1361]
1000:1d7d  88 44 03         mov byte ptr [si + 3], al
1000:1d80  fe 06 16 95      inc byte ptr [0x9516]
1000:1d84  8a 1e 16 95      mov bl, byte ptr [0x9516]
1000:1d88  83 e3 0f         and bx, 0xf
1000:1d8b  8a 87 e7 0f      mov al, byte ptr [bx + 0xfe7]
1000:1d8f  88 44 04         mov byte ptr [si + 4], al
1000:1d92  bb 0e 10         mov bx, 0x100e
1000:1d95  e8 89 03         call 0x2121
1000:1d98  e8 bd ed         call 0xb58
1000:1d9b  be 5e 13         mov si, 0x135e
1000:1d9e  80 0c 20         or byte ptr [si], 0x20
1000:1da1  8a 1e 8e 1b      mov bl, byte ptr [0x1b8e]
1000:1da5  b7 00            mov bh, 0
1000:1da7  8a 87 7f 13      mov al, byte ptr [bx + 0x137f]
1000:1dab  98               cwde 
1000:1dac  03 06 8f 1b      add ax, word ptr [0x1b8f]
1000:1db0  89 44 05         mov word ptr [si + 5], ax
1000:1db3  a0 8d 1b         mov al, byte ptr [0x1b8d]
1000:1db6  02 87 93 13      add al, byte ptr [bx + 0x1393]
1000:1dba  88 44 03         mov byte ptr [si + 3], al
1000:1dbd  e8 98 ed         call 0xb58
1000:1dc0  be f7 0f         mov si, 0xff7
1000:1dc3  a1 63 13         mov ax, word ptr [0x1363]
1000:1dc6  89 44 05         mov word ptr [si + 5], ax
1000:1dc9  a1 65 13         mov ax, word ptr [0x1365]
1000:1dcc  89 44 07         mov word ptr [si + 7], ax
1000:1dcf  a0 61 13         mov al, byte ptr [0x1361]
1000:1dd2  88 44 03         mov byte ptr [si + 3], al
1000:1dd5  e8 80 ed         call 0xb58
1000:1dd8  a1 11 95         mov ax, word ptr [0x9511]
1000:1ddb  03 c3            add ax, bx
1000:1ddd  3d 10 00         cmp ax, 0x10
1000:1de0  76 09            jbe loc_11deb
1000:1de2  b8 00 00         mov ax, 0
1000:1de5  c7 06 40 95 ff ff  mov word ptr [0x9540], 0xffff
                            loc_11deb:
1000:1deb  a3 11 95         mov word ptr [0x9511], ax
1000:1dee  c3               ret 
                            sub_11d1e ENDP
*/
void sub_11d1e()
{
    // coverage: 0x1f1e-0x1fef method sub_11d1e
    // coverage2: 1000:1d1e-1000:1def method sub_11d1e // ins(0x1d1e, 0x1def, 0x1d1e);
    si = 0x135e;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    bl = memoryAGet(ds, 0x1b8e);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5021);
    memoryASet(ds, si + 4, al);
    al = memoryAGet(ds, bx + 4981);
    cbw();
    ax += memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x1b91);
    ax -= 0x0004;
    ax &= 0x03ff;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1b8d);
    al += memoryAGet(ds, bx + 5001);
    memoryASet(ds, si + 3, al);
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5031);
    memoryASet(ds, si + 10, al);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5034);
    memoryASet16(ds, si + 15, ax);
    sub_10b58();
    si = 0x0ff7;
    ax = memoryAGet16(ds, 0x1363);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x1365);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1361);
    memoryASet(ds, si + 3, al);
    memoryASet(ds, 0x9516, memoryAGet(ds, 0x9516) + 1);
    bl = memoryAGet(ds, 0x9516);
    bx &= 0x000f;
    al = memoryAGet(ds, bx + 4071);
    memoryASet(ds, si + 4, al);
    bx = 0x100e;
    sub_12121();
    sub_10b58();
    si = 0x135e;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    bl = memoryAGet(ds, 0x1b8e);
    bh = 0x00;
    al = memoryAGet(ds, bx + 4991);
    cbw();
    ax += memoryAGet16(ds, 0x1b8f);
    memoryASet16(ds, si + 5, ax);
    al = memoryAGet(ds, 0x1b8d);
    al += memoryAGet(ds, bx + 5011);
    memoryASet(ds, si + 3, al);
    sub_10b58();
    si = 0x0ff7;
    ax = memoryAGet16(ds, 0x1363);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x1365);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x1361);
    memoryASet(ds, si + 3, al);
    sub_10b58();
    ax = memoryAGet16(ds, 0x9511);
    ax += bx;
    if (ax <= 0x0010)
        goto loc_11deb;
    ax = 0x0000;
    memoryASet16(ds, 0x9540, 0xffff);
loc_11deb:
    memoryASet16(ds, 0x9511, ax);
}
/* Assembly listing of 1000:1def sub_11def()
                            sub_11def PROC
1000:1def  fe 06 16 95      inc byte ptr [0x9516]
1000:1df3  8a 1e 16 95      mov bl, byte ptr [0x9516]
1000:1df7  83 e3 0f         and bx, 0xf
1000:1dfa  8a 87 e7 0f      mov al, byte ptr [bx + 0xfe7]
1000:1dfe  a2 fb 0f         mov byte ptr [0xffb], al
1000:1e01  8a 44 01         mov al, byte ptr [si + 1]
1000:1e04  3c 00            cmp al, 0
1000:1e06  75 26            jne loc_11e2e
1000:1e08  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1e0b  b7 00            mov bh, 0
1000:1e0d  8a 8f cd 13      mov cl, byte ptr [bx + 0x13cd]
1000:1e11  b8 fd ff         mov ax, 0xfffd
1000:1e14  bb 08 00         mov bx, 8
1000:1e17  e8 63 00         call 0x1e7d
1000:1e1a  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1e1d  b7 00            mov bh, 0
1000:1e1f  8a 8f d7 13      mov cl, byte ptr [bx + 0x13d7]
1000:1e23  b8 03 00         mov ax, 3
1000:1e26  bb 08 00         mov bx, 8
1000:1e29  e8 51 00         call 0x1e7d
1000:1e2c  eb 4e            jmp loc_11e7c
                            loc_11e2e:
1000:1e2e  3c 01            cmp al, 1
1000:1e30  75 14            jne loc_11e46
1000:1e32  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1e35  b7 00            mov bh, 0
1000:1e37  8a 8f e1 13      mov cl, byte ptr [bx + 0x13e1]
1000:1e3b  b8 00 00         mov ax, 0
1000:1e3e  bb 08 00         mov bx, 8
1000:1e41  e8 39 00         call 0x1e7d
1000:1e44  eb 36            jmp loc_11e7c
                            loc_11e46:
1000:1e46  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1e49  b7 00            mov bh, 0
1000:1e4b  8a 8f eb 13      mov cl, byte ptr [bx + 0x13eb]
1000:1e4f  b8 f9 ff         mov ax, 0xfff9
1000:1e52  bb 08 00         mov bx, 8
1000:1e55  e8 25 00         call 0x1e7d
1000:1e58  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1e5b  b7 00            mov bh, 0
1000:1e5d  8a 8f f5 13      mov cl, byte ptr [bx + 0x13f5]
1000:1e61  b8 00 00         mov ax, 0
1000:1e64  bb 0b 00         mov bx, 0xb
1000:1e67  e8 13 00         call 0x1e7d
1000:1e6a  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1e6d  b7 00            mov bh, 0
1000:1e6f  8a 8f ff 13      mov cl, byte ptr [bx + 0x13ff]
1000:1e73  b8 07 00         mov ax, 7
1000:1e76  bb 08 00         mov bx, 8
1000:1e79  e8 01 00         call 0x1e7d
                            loc_11e7c:
1000:1e7c  c3               ret 
                            sub_11def ENDP
*/
void sub_11def()
{
    // coverage: 0x1fef-0x207d method sub_11def
    // coverage2: 1000:1def-1000:1e7d method sub_11def // ins(0x1def, 0x1e7d, 0x1def);
    memoryASet(ds, 0x9516, memoryAGet(ds, 0x9516) + 1);
    bl = memoryAGet(ds, 0x9516);
    bx &= 0x000f;
    al = memoryAGet(ds, bx + 4071);
    memoryASet(ds, 0x0ffb, al);
    al = memoryAGet(ds, si + 1);
    if (al != 0x00)
        goto loc_11e2e;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5069);
    ax = 0xfffd;
    bx = 0x0008;
    sub_11e7d();
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5079);
    ax = 0x0003;
    bx = 0x0008;
    sub_11e7d();
    return;
loc_11e2e:
    if (al != 0x01)
        goto loc_11e46;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5089);
    ax = 0x0000;
    bx = 0x0008;
    sub_11e7d();
    return;
loc_11e46:
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5099);
    ax = 0xfff9;
    bx = 0x0008;
    sub_11e7d();
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5109);
    ax = 0x0000;
    bx = 0x000b;
    sub_11e7d();
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    cl = memoryAGet(ds, bx + 5119);
    ax = 0x0007;
    bx = 0x0008;
    sub_11e7d();
}
/* Assembly listing of 1000:1e7d sub_11e7d()
                            sub_11e7d PROC
1000:1e7d  56               push si
1000:1e7e  bf f7 0f         mov di, 0xff7
1000:1e81  03 44 05         add ax, word ptr [si + 5]
1000:1e84  89 45 05         mov word ptr [di + 5], ax
1000:1e87  03 5c 07         add bx, word ptr [si + 7]
1000:1e8a  81 e3 ff 03      and bx, 0x3ff
1000:1e8e  89 5d 07         mov word ptr [di + 7], bx
1000:1e91  02 4c 03         add cl, byte ptr [si + 3]
1000:1e94  88 4d 03         mov byte ptr [di + 3], cl
1000:1e97  8b f7            mov si, di
1000:1e99  bb 39 10         mov bx, 0x1039
1000:1e9c  e8 82 02         call 0x2121
1000:1e9f  e8 b6 ec         call 0xb58
1000:1ea2  83 fe 00         cmp si, 0
1000:1ea5  74 09            je loc_11eb0
1000:1ea7  58               pop ax
1000:1ea8  50               push ax
1000:1ea9  3b c6            cmp ax, si
1000:1eab  76 03            jbe loc_11eb0
1000:1ead  e8 26 f8         call 0x16d6
                            loc_11eb0:
1000:1eb0  5e               pop si
1000:1eb1  a0 18 95         mov al, byte ptr [0x9518]
1000:1eb4  3c 00            cmp al, 0
1000:1eb6  75 01            jne loc_11eb9
1000:1eb8  c3               ret 
                            loc_11eb9:
1000:1eb9  56               push si
1000:1eba  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1ebd  b7 00            mov bh, 0
1000:1ebf  be b0 13         mov si, 0x13b0
1000:1ec2  8a 87 9d 13      mov al, byte ptr [bx + 0x139d]
1000:1ec6  88 44 04         mov byte ptr [si + 4], al
1000:1ec9  a1 fc 0f         mov ax, word ptr [0xffc]
1000:1ecc  89 44 05         mov word ptr [si + 5], ax
1000:1ecf  a1 fe 0f         mov ax, word ptr [0xffe]
1000:1ed2  89 44 07         mov word ptr [si + 7], ax
1000:1ed5  a0 fa 0f         mov al, byte ptr [0xffa]
1000:1ed8  88 44 03         mov byte ptr [si + 3], al
1000:1edb  c6 44 01 02      mov byte ptr [si + 1], 2
1000:1edf  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1ee2  b7 00            mov bh, 0
1000:1ee4  8a 87 a7 13      mov al, byte ptr [bx + 0x13a7]
1000:1ee8  88 44 0a         mov byte ptr [si + 0xa], al
1000:1eeb  c6 44 09 04      mov byte ptr [si + 9], 4
1000:1eef  d1 e3            shl bx, 1
1000:1ef1  8b 87 c7 13      mov ax, word ptr [bx + 0x13c7]
1000:1ef5  89 44 0f         mov word ptr [si + 0xf], ax
1000:1ef8  e8 5d ec         call 0xb58
1000:1efb  83 fe 00         cmp si, 0
1000:1efe  74 09            je loc_11f09
1000:1f00  58               pop ax
1000:1f01  50               push ax
1000:1f02  3b c6            cmp ax, si
1000:1f04  76 03            jbe loc_11f09
1000:1f06  e8 f3 f6         call 0x15fc
                            loc_11f09:
1000:1f09  5e               pop si
1000:1f0a  c3               ret 
                            sub_11e7d ENDP
*/
void sub_11e7d()
{
    // coverage: 0x207d-0x210b method sub_11e7d
    // coverage2: 1000:1e7d-1000:1f0b method sub_11e7d // ins(0x1e7d, 0x1f0b, 0x1e7d);
    push(si);
    di = 0x0ff7;
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    bx += memoryAGet16(ds, si + 7);
    bx &= 0x03ff;
    memoryASet16(ds, di + 7, bx);
    cl += memoryAGet(ds, si + 3);
    memoryASet(ds, di + 3, cl);
    si = di;
    bx = 0x1039;
    sub_12121();
    sub_10b58();
    if (si == 0x0000)
        goto loc_11eb0;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11eb0;
    sub_116d6();
loc_11eb0:
    si = pop();
    al = memoryAGet(ds, 0x9518);
    if (al != 0x00)
        goto loc_11eb9;
    return;
loc_11eb9:
    push(si);
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    si = 0x13b0;
    al = memoryAGet(ds, bx + 5021);
    memoryASet(ds, si + 4, al);
    ax = memoryAGet16(ds, 0x0ffc);
    memoryASet16(ds, si + 5, ax);
    ax = memoryAGet16(ds, 0x0ffe);
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, 0x0ffa);
    memoryASet(ds, si + 3, al);
    memoryASet(ds, si + 1, 0x02);
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5031);
    memoryASet(ds, si + 10, al);
    memoryASet(ds, si + 9, 0x04);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5063);
    memoryASet16(ds, si + 15, ax);
    sub_10b58();
    if (si == 0x0000)
        goto loc_11f09;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11f09;
    sub_115fc();
loc_11f09:
    si = pop();
}
/* Assembly listing of 1000:1f0b sub_11f0b()
                            sub_11f0b PROC
1000:1f0b  56               push si
1000:1f0c  fe 06 16 95      inc byte ptr [0x9516]
1000:1f10  8a 1e 16 95      mov bl, byte ptr [0x9516]
1000:1f14  83 e3 0f         and bx, 0xf
1000:1f17  8a 87 e7 0f      mov al, byte ptr [bx + 0xfe7]
1000:1f1b  a2 fb 0f         mov byte ptr [0xffb], al
1000:1f1e  bf f7 0f         mov di, 0xff7
1000:1f21  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1f24  b7 00            mov bh, 0
1000:1f26  8a 87 09 14      mov al, byte ptr [bx + 0x1409]
1000:1f2a  98               cwde 
1000:1f2b  03 44 05         add ax, word ptr [si + 5]
1000:1f2e  89 45 05         mov word ptr [di + 5], ax
1000:1f31  8a 87 0e 14      mov al, byte ptr [bx + 0x140e]
1000:1f35  98               cwde 
1000:1f36  03 44 07         add ax, word ptr [si + 7]
1000:1f39  25 ff 03         and ax, 0x3ff
1000:1f3c  89 45 07         mov word ptr [di + 7], ax
1000:1f3f  8a 44 03         mov al, byte ptr [si + 3]
1000:1f42  04 04            add al, 4
1000:1f44  88 45 03         mov byte ptr [di + 3], al
1000:1f47  d1 e3            shl bx, 1
1000:1f49  8b 9f 2f 10      mov bx, word ptr [bx + 0x102f]
1000:1f4d  8b f7            mov si, di
1000:1f4f  e8 cf 01         call 0x2121
1000:1f52  e8 03 ec         call 0xb58
1000:1f55  83 fe 00         cmp si, 0
1000:1f58  74 09            je loc_11f63
1000:1f5a  58               pop ax
1000:1f5b  50               push ax
1000:1f5c  3b c6            cmp ax, si
1000:1f5e  76 03            jbe loc_11f63
1000:1f60  e8 73 f7         call 0x16d6
                            loc_11f63:
1000:1f63  5e               pop si
1000:1f64  a0 18 95         mov al, byte ptr [0x9518]
1000:1f67  3c 00            cmp al, 0
1000:1f69  75 01            jne loc_11f6c
1000:1f6b  c3               ret 
                            loc_11f6c:
1000:1f6c  56               push si
1000:1f6d  bf b0 13         mov di, 0x13b0
1000:1f70  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1f73  b7 00            mov bh, 0
1000:1f75  88 5d 01         mov byte ptr [di + 1], bl
1000:1f78  a1 fc 0f         mov ax, word ptr [0xffc]
1000:1f7b  89 45 05         mov word ptr [di + 5], ax
1000:1f7e  a1 fe 0f         mov ax, word ptr [0xffe]
1000:1f81  89 45 07         mov word ptr [di + 7], ax
1000:1f84  a0 fa 0f         mov al, byte ptr [0xffa]
1000:1f87  88 45 03         mov byte ptr [di + 3], al
1000:1f8a  8a 87 13 14      mov al, byte ptr [bx + 0x1413]
1000:1f8e  88 45 09         mov byte ptr [di + 9], al
1000:1f91  8a 87 18 14      mov al, byte ptr [bx + 0x1418]
1000:1f95  88 45 0a         mov byte ptr [di + 0xa], al
1000:1f98  c6 45 04 00      mov byte ptr [di + 4], 0
1000:1f9c  d1 e3            shl bx, 1
1000:1f9e  8b 87 1d 14      mov ax, word ptr [bx + 0x141d]
1000:1fa2  89 45 0f         mov word ptr [di + 0xf], ax
1000:1fa5  8b f7            mov si, di
1000:1fa7  e8 ae eb         call 0xb58
1000:1faa  83 fe 00         cmp si, 0
1000:1fad  74 09            je loc_11fb8
1000:1faf  58               pop ax
1000:1fb0  50               push ax
1000:1fb1  3b c6            cmp ax, si
1000:1fb3  76 03            jbe loc_11fb8
1000:1fb5  e8 44 f6         call 0x15fc
                            loc_11fb8:
1000:1fb8  5e               pop si
1000:1fb9  c3               ret 
                            sub_11f0b ENDP
*/
void sub_11f0b()
{
    // coverage: 0x210b-0x21ba method sub_11f0b
    // coverage2: 1000:1f0b-1000:1fba method sub_11f0b // ins(0x1f0b, 0x1fba, 0x1f0b);
    push(si);
    memoryASet(ds, 0x9516, memoryAGet(ds, 0x9516) + 1);
    bl = memoryAGet(ds, 0x9516);
    bx &= 0x000f;
    al = memoryAGet(ds, bx + 4071);
    memoryASet(ds, 0x0ffb, al);
    di = 0x0ff7;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5129);
    cbw();
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    al = memoryAGet(ds, bx + 5134);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, si + 3);
    al += 0x04;
    memoryASet(ds, di + 3, al);
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4143);
    si = di;
    sub_12121();
    sub_10b58();
    if (si == 0x0000)
        goto loc_11f63;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11f63;
    sub_116d6();
loc_11f63:
    si = pop();
    al = memoryAGet(ds, 0x9518);
    if (al != 0x00)
        goto loc_11f6c;
    return;
loc_11f6c:
    push(si);
    di = 0x13b0;
    bl = memoryAGet(ds, si + 4);
    bh = 0x00;
    memoryASet(ds, di + 1, bl);
    ax = memoryAGet16(ds, 0x0ffc);
    memoryASet16(ds, di + 5, ax);
    ax = memoryAGet16(ds, 0x0ffe);
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, 0x0ffa);
    memoryASet(ds, di + 3, al);
    al = memoryAGet(ds, bx + 5139);
    memoryASet(ds, di + 9, al);
    al = memoryAGet(ds, bx + 5144);
    memoryASet(ds, di + 10, al);
    memoryASet(ds, di + 4, 0x00);
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5149);
    memoryASet16(ds, di + 15, ax);
    si = di;
    sub_10b58();
    if (si == 0x0000)
        goto loc_11fb8;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_11fb8;
    sub_115fc();
loc_11fb8:
    si = pop();
}
/* Assembly listing of 1000:1fba sub_11fba()
                            sub_11fba PROC
1000:1fba  56               push si
1000:1fbb  bf e8 10         mov di, 0x10e8
1000:1fbe  8a 5c 04         mov bl, byte ptr [si + 4]
1000:1fc1  88 5d 01         mov byte ptr [di + 1], bl
1000:1fc4  b7 00            mov bh, 0
1000:1fc6  8a 87 de 10      mov al, byte ptr [bx + 0x10de]
1000:1fca  98               cwde 
1000:1fcb  03 44 05         add ax, word ptr [si + 5]
1000:1fce  89 45 05         mov word ptr [di + 5], ax
1000:1fd1  8a 87 e3 10      mov al, byte ptr [bx + 0x10e3]
1000:1fd5  98               cwde 
1000:1fd6  03 44 07         add ax, word ptr [si + 7]
1000:1fd9  25 ff 03         and ax, 0x3ff
1000:1fdc  89 45 07         mov word ptr [di + 7], ax
1000:1fdf  8a 44 03         mov al, byte ptr [si + 3]
1000:1fe2  04 08            add al, 8
1000:1fe4  88 45 03         mov byte ptr [di + 3], al
1000:1fe7  d1 e3            shl bx, 1
1000:1fe9  8b 9f ff 10      mov bx, word ptr [bx + 0x10ff]
1000:1fed  8b f7            mov si, di
1000:1fef  e8 2f 01         call 0x2121
1000:1ff2  e8 63 eb         call 0xb58
1000:1ff5  83 fe 00         cmp si, 0
1000:1ff8  74 09            je loc_12003
1000:1ffa  58               pop ax
1000:1ffb  50               push ax
1000:1ffc  3b c6            cmp ax, si
1000:1ffe  76 03            jbe loc_12003
1000:2000  e8 26 f4         call 0x1429
                            loc_12003:
1000:2003  5e               pop si
1000:2004  c3               ret 
                            sub_11fba ENDP
*/
void sub_11fba()
{
    // coverage: 0x21ba-0x2205 method sub_11fba
    // coverage2: 1000:1fba-1000:2005 method sub_11fba // ins(0x1fba, 0x2005, 0x1fba);
    push(si);
    di = 0x10e8;
    bl = memoryAGet(ds, si + 4);
    memoryASet(ds, di + 1, bl);
    bh = 0x00;
    al = memoryAGet(ds, bx + 4318);
    cbw();
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    al = memoryAGet(ds, bx + 4323);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, si + 3);
    al += 0x08;
    memoryASet(ds, di + 3, al);
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 4351);
    si = di;
    sub_12121();
    sub_10b58();
    if (si == 0x0000)
        goto loc_12003;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_12003;
    sub_11429();
loc_12003:
    si = pop();
}
/* Assembly listing of 1000:2005 sub_12005()
                            sub_12005 PROC
1000:2005  56               push si
1000:2006  bf 46 14         mov di, 0x1446
1000:2009  8a 5c 04         mov bl, byte ptr [si + 4]
1000:200c  88 5d 01         mov byte ptr [di + 1], bl
1000:200f  b7 00            mov bh, 0
1000:2011  8a 87 5d 14      mov al, byte ptr [bx + 0x145d]
1000:2015  98               cwde 
1000:2016  03 44 05         add ax, word ptr [si + 5]
1000:2019  89 45 05         mov word ptr [di + 5], ax
1000:201c  8a 87 62 14      mov al, byte ptr [bx + 0x1462]
1000:2020  98               cwde 
1000:2021  03 44 07         add ax, word ptr [si + 7]
1000:2024  25 ff 03         and ax, 0x3ff
1000:2027  89 45 07         mov word ptr [di + 7], ax
1000:202a  8a 44 03         mov al, byte ptr [si + 3]
1000:202d  04 08            add al, 8
1000:202f  88 45 03         mov byte ptr [di + 3], al
1000:2032  8b f7            mov si, di
1000:2034  e8 21 eb         call 0xb58
1000:2037  83 fe 00         cmp si, 0
1000:203a  74 09            je loc_12045
1000:203c  58               pop ax
1000:203d  50               push ax
1000:203e  3b c6            cmp ax, si
1000:2040  76 03            jbe loc_12045
1000:2042  e8 af f7         call 0x17f4
                            loc_12045:
1000:2045  5e               pop si
1000:2046  c3               ret 
                            sub_12005 ENDP
*/
void sub_12005()
{
    // coverage: 0x2205-0x2247 method sub_12005
    // coverage2: 1000:2005-1000:2047 method sub_12005 // ins(0x2005, 0x2047, 0x2005);
    push(si);
    di = 0x1446;
    bl = memoryAGet(ds, si + 4);
    memoryASet(ds, di + 1, bl);
    bh = 0x00;
    al = memoryAGet(ds, bx + 5213);
    cbw();
    ax += memoryAGet16(ds, si + 5);
    memoryASet16(ds, di + 5, ax);
    al = memoryAGet(ds, bx + 5218);
    cbw();
    ax += memoryAGet16(ds, si + 7);
    ax &= 0x03ff;
    memoryASet16(ds, di + 7, ax);
    al = memoryAGet(ds, si + 3);
    al += 0x08;
    memoryASet(ds, di + 3, al);
    si = di;
    sub_10b58();
    if (si == 0x0000)
        goto loc_12045;
    ax = pop();
    push(ax);
    if (ax <= si)
        goto loc_12045;
    sub_117f4();
loc_12045:
    si = pop();
}
/* Assembly listing of 1000:2047 sub_12047()
                            sub_12047 PROC
1000:2047  8a 04            mov al, byte ptr [si]
1000:2049  8a 1e 17 95      mov bl, byte ptr [0x9517]
1000:204d  a8 20            test al, 0x20
1000:204f  74 21            je loc_12072
1000:2051  f6 c3 80         test bl, 0x80
1000:2054  75 17            jne loc_1206d
1000:2056  80 0e 17 95 80   or byte ptr [0x9517], 0x80
1000:205b  80 0e 26 13 20   or byte ptr [0x1326], 0x20
1000:2060  bf 26 13         mov di, 0x1326
1000:2063  e8 3a 00         call 0x20a0
1000:2066  b0 03            mov al, 3
1000:2068  e8 d5 17         call 0x3840
1000:206b  eb 03            jmp loc_12070
                            loc_1206d:
1000:206d  c6 04 00         mov byte ptr [si], 0
                            loc_12070:
1000:2070  eb 1f            jmp loc_12091
                            loc_12072:
1000:2072  f6 c3 01         test bl, 1
1000:2075  75 17            jne loc_1208e
1000:2077  80 0e 17 95 01   or byte ptr [0x9517], 1
1000:207c  80 26 26 13 df   and byte ptr [0x1326], 0xdf
1000:2081  bf 26 13         mov di, 0x1326
1000:2084  e8 19 00         call 0x20a0
1000:2087  b0 03            mov al, 3
1000:2089  e8 b4 17         call 0x3840
1000:208c  eb 03            jmp loc_12091
                            loc_1208e:
1000:208e  c6 04 00         mov byte ptr [si], 0
                            loc_12091:
1000:2091  c3               ret 
                            sub_12047 ENDP
*/
void sub_12047()
{
    // coverage: 0x2247-0x2292 method sub_12047
    // coverage2: 1000:2047-1000:2092 method sub_12047 // ins(0x2047, 0x2092, 0x2047);
    al = memoryAGet(ds, si);
    bl = memoryAGet(ds, 0x9517);
    if (!(al & 0x20))
        goto loc_12072;
    if (bl & 0x80)
        goto loc_1206d;
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) | 0x80);
    memoryASet(ds, 0x1326, memoryAGet(ds, 0x1326) | 0x20);
    di = 0x1326;
    sub_120a0();
    al = 0x03;
    sub_13840();
    goto loc_12070;
loc_1206d:
    memoryASet(ds, si, 0x00);
loc_12070:
    return;
loc_12072:
    if (bl & 0x01)
        goto loc_1208e;
    memoryASet(ds, 0x9517, memoryAGet(ds, 0x9517) | 0x01);
    memoryASet(ds, 0x1326, memoryAGet(ds, 0x1326) & 0xdf);
    di = 0x1326;
    sub_120a0();
    al = 0x03;
    sub_13840();
    return;
loc_1208e:
    memoryASet(ds, si, 0x00);
}
/* Assembly listing of 1000:2092 sub_12092()
                            sub_12092 PROC
1000:2092  bf 27 14         mov di, 0x1427
1000:2095  e8 08 00         call 0x20a0
1000:2098  c3               ret 
                            sub_12092 ENDP
*/
void sub_12092()
{
    // coverage: 0x2292-0x2299 method sub_12092
    // coverage2: 1000:2092-1000:2099 method sub_12092 // ins(0x2092, 0x2099, 0x2092);
    di = 0x1427;
    sub_120a0();
}
/* Assembly listing of 1000:2099 sub_12099()
                            sub_12099 PROC
1000:2099  bf de 12         mov di, 0x12de
1000:209c  e8 01 00         call 0x20a0
1000:209f  c3               ret 
                            sub_12099 ENDP
*/
void sub_12099()
{
    // coverage: 0x2299-0x22a0 method sub_12099
    // coverage2: 1000:2099-1000:20a0 method sub_12099 // ins(0x2099, 0x20a0, 0x2099);
    di = 0x12de;
    sub_120a0();
}
/* Assembly listing of 1000:20a0 sub_120a0()
                            sub_120a0 PROC
1000:20a0  8a 05            mov al, byte ptr [di]
1000:20a2  88 04            mov byte ptr [si], al
1000:20a4  8a 45 02         mov al, byte ptr [di + 2]
1000:20a7  88 44 02         mov byte ptr [si + 2], al
1000:20aa  8a 45 16         mov al, byte ptr [di + 0x16]
1000:20ad  88 44 16         mov byte ptr [si + 0x16], al
1000:20b0  8a 45 04         mov al, byte ptr [di + 4]
1000:20b3  88 44 04         mov byte ptr [si + 4], al
1000:20b6  8a 45 09         mov al, byte ptr [di + 9]
1000:20b9  88 44 09         mov byte ptr [si + 9], al
1000:20bc  8a 45 0a         mov al, byte ptr [di + 0xa]
1000:20bf  88 44 0a         mov byte ptr [si + 0xa], al
1000:20c2  8a 45 0b         mov al, byte ptr [di + 0xb]
1000:20c5  88 44 0b         mov byte ptr [si + 0xb], al
1000:20c8  8a 45 0c         mov al, byte ptr [di + 0xc]
1000:20cb  88 44 0c         mov byte ptr [si + 0xc], al
1000:20ce  8b 45 0f         mov ax, word ptr [di + 0xf]
1000:20d1  89 44 0f         mov word ptr [si + 0xf], ax
1000:20d4  8a 45 12         mov al, byte ptr [di + 0x12]
1000:20d7  88 44 12         mov byte ptr [si + 0x12], al
1000:20da  c3               ret 
                            sub_120a0 ENDP
*/
void sub_120a0()
{
    // coverage: 0x22a0-0x22db method sub_120a0
    // coverage2: 1000:20a0-1000:20db method sub_120a0 // ins(0x20a0, 0x20db, 0x20a0);
    al = memoryAGet(ds, di);
    memoryASet(ds, si, al);
    al = memoryAGet(ds, di + 2);
    memoryASet(ds, si + 2, al);
    al = memoryAGet(ds, di + 22);
    memoryASet(ds, si + 22, al);
    al = memoryAGet(ds, di + 4);
    memoryASet(ds, si + 4, al);
    al = memoryAGet(ds, di + 9);
    memoryASet(ds, si + 9, al);
    al = memoryAGet(ds, di + 10);
    memoryASet(ds, si + 10, al);
    al = memoryAGet(ds, di + 11);
    memoryASet(ds, si + 11, al);
    al = memoryAGet(ds, di + 12);
    memoryASet(ds, si + 12, al);
    ax = memoryAGet16(ds, di + 15);
    memoryASet16(ds, si + 15, ax);
    al = memoryAGet(ds, di + 18);
    memoryASet(ds, si + 18, al);
}
/* Assembly listing of 1000:20db sub_120db()
                            sub_120db PROC
1000:20db  e8 98 05         call 0x2676
1000:20de  e8 0f 00         call 0x20f0
1000:20e1  56               push si
1000:20e2  8a 44 13         mov al, byte ptr [si + 0x13]
1000:20e5  b4 00            mov ah, 0
1000:20e7  50               push ax
1000:20e8  8a 44 14         mov al, byte ptr [si + 0x14]
1000:20eb  50               push ax
1000:20ec  e8 c6 e8         call 0x9b5
1000:20ef  c3               ret 
                            sub_120db ENDP
*/
void sub_120db()
{
    // coverage: 0x22db-0x22f0 method sub_120db
    // coverage2: 1000:20db-1000:20f0 method sub_120db // ins(0x20db, 0x20f0, 0x20db);
    sub_12676();
    sub_120f0();
    push(si);
    al = memoryAGet(ds, si + 19);
    ah = 0x00;
    push(ax);
    al = memoryAGet(ds, si + 20);
    push(ax);
    sub_109b5();
}
/* Assembly listing of 1000:20f0 sub_120f0()
                            sub_120f0 PROC
1000:20f0  56               push si
1000:20f1  8b 44 05         mov ax, word ptr [si + 5]
1000:20f4  a3 a3 12         mov word ptr [0x12a3], ax
1000:20f7  8b 44 07         mov ax, word ptr [si + 7]
1000:20fa  a3 a5 12         mov word ptr [0x12a5], ax
1000:20fd  8a 44 03         mov al, byte ptr [si + 3]
1000:2100  a2 a1 12         mov byte ptr [0x12a1], al
1000:2103  8a 04            mov al, byte ptr [si]
1000:2105  a8 10            test al, 0x10
1000:2107  74 10            je loc_12119
1000:2109  83 2e a3 12 0c   sub word ptr [0x12a3], 0xc
1000:210e  83 2e a5 12 08   sub word ptr [0x12a5], 8
1000:2113  81 26 a5 12 ff 03  and word ptr [0x12a5], 0x3ff
                            loc_12119:
1000:2119  be 9e 12         mov si, 0x129e
1000:211c  e8 39 ea         call 0xb58
1000:211f  5e               pop si
1000:2120  c3               ret 
                            sub_120f0 ENDP
*/
void sub_120f0()
{
    // coverage: 0x22f0-0x2321 method sub_120f0
    // coverage2: 1000:20f0-1000:2121 method sub_120f0 // ins(0x20f0, 0x2121, 0x20f0);
    push(si);
    ax = memoryAGet16(ds, si + 5);
    memoryASet16(ds, 0x12a3, ax);
    ax = memoryAGet16(ds, si + 7);
    memoryASet16(ds, 0x12a5, ax);
    al = memoryAGet(ds, si + 3);
    memoryASet(ds, 0x12a1, al);
    al = memoryAGet(ds, si);
    if (!(al & 0x10))
        goto loc_12119;
    memoryASet16(ds, 0x12a3, memoryAGet16(ds, 0x12a3) - 0x000c);
    memoryASet16(ds, 0x12a5, memoryAGet16(ds, 0x12a5) - 0x0008);
    memoryASet16(ds, 0x12a5, memoryAGet16(ds, 0x12a5) & 0x03ff);
loc_12119:
    si = 0x129e;
    sub_10b58();
    si = pop();
}
/* Assembly listing of 1000:2121 sub_12121()
                            sub_12121 PROC
1000:2121  8a 0f            mov cl, byte ptr [bx]
1000:2123  b5 00            mov ch, 0
1000:2125  43               inc bx
1000:2126  8a 44 04         mov al, byte ptr [si + 4]
1000:2129  b4 00            mov ah, 0
1000:212b  8b f8            mov di, ax
1000:212d  8a 01            mov al, byte ptr [bx + di]
1000:212f  88 44 09         mov byte ptr [si + 9], al
1000:2132  03 d9            add bx, cx
1000:2134  8a 01            mov al, byte ptr [bx + di]
1000:2136  88 44 0a         mov byte ptr [si + 0xa], al
1000:2139  03 d9            add bx, cx
1000:213b  8a 01            mov al, byte ptr [bx + di]
1000:213d  88 44 0b         mov byte ptr [si + 0xb], al
1000:2140  03 d9            add bx, cx
1000:2142  8a 01            mov al, byte ptr [bx + di]
1000:2144  88 44 0c         mov byte ptr [si + 0xc], al
1000:2147  03 d9            add bx, cx
1000:2149  d1 e7            shl di, 1
1000:214b  d1 e7            shl di, 1
1000:214d  8b 01            mov ax, word ptr [bx + di]
1000:214f  89 44 0d         mov word ptr [si + 0xd], ax
1000:2152  83 c3 02         add bx, 2
1000:2155  8b 01            mov ax, word ptr [bx + di]
1000:2157  89 44 0f         mov word ptr [si + 0xf], ax
1000:215a  c3               ret 
                            sub_12121 ENDP
*/
void sub_12121()
{
    // coverage: 0x2321-0x235b method sub_12121
    // coverage2: 1000:2121-1000:215b method sub_12121 // ins(0x2121, 0x215b, 0x2121);
    cl = memoryAGet(ds, bx);
    ch = 0x00;
    bx++;
    al = memoryAGet(ds, si + 4);
    ah = 0x00;
    di = ax;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 9, al);
    bx += cx;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 10, al);
    bx += cx;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 11, al);
    bx += cx;
    al = memoryAGet(ds, bx + di);
    memoryASet(ds, si + 12, al);
    bx += cx;
    di <<= 1;
    di <<= 1;
    ax = memoryAGet16(ds, bx + di);
    memoryASet16(ds, si + 13, ax);
    bx += 0x0002;
    ax = memoryAGet16(ds, bx + di);
    memoryASet16(ds, si + 15, ax);
}
/* Assembly listing of 1000:215b sub_1215b()
                            sub_1215b PROC
1000:215b  b9 01 00         mov cx, 1
1000:215e  a1 91 1b         mov ax, word ptr [0x1b91]
1000:2161  2b 44 07         sub ax, word ptr [si + 7]
1000:2164  3d 8c 00         cmp ax, 0x8c
1000:2167  7e 08            jle loc_12171
1000:2169  c6 44 04 02      mov byte ptr [si + 4], 2
1000:216d  b9 00 00         mov cx, 0
1000:2170  c3               ret 
                            loc_12171:
1000:2171  3d f0 ff         cmp ax, 0xfff0
1000:2174  7d 2a            jge loc_121a0
1000:2176  8a 64 04         mov ah, byte ptr [si + 4]
1000:2179  8a 04            mov al, byte ptr [si]
1000:217b  a8 20            test al, 0x20
1000:217d  74 0e            je loc_1218d
1000:217f  fe c4            inc ah
1000:2181  80 fc 04         cmp ah, 4
1000:2184  7e 05            jle loc_1218b
1000:2186  80 24 df         and byte ptr [si], 0xdf
1000:2189  b4 04            mov ah, 4
                            loc_1218b:
1000:218b  eb 0c            jmp loc_12199
                            loc_1218d:
1000:218d  fe cc            dec ah
1000:218f  80 fc 00         cmp ah, 0
1000:2192  7d 05            jge loc_12199
1000:2194  80 0c 20         or byte ptr [si], 0x20
1000:2197  b4 00            mov ah, 0
                            loc_12199:
1000:2199  88 64 04         mov byte ptr [si + 4], ah
1000:219c  b9 00 00         mov cx, 0
1000:219f  c3               ret 
                            loc_121a0:
1000:21a0  8b 1e 8f 1b      mov bx, word ptr [0x1b8f]
1000:21a4  2b 5c 05         sub bx, word ptr [si + 5]
1000:21a7  79 19            jns loc_121c2
1000:21a9  83 fb e0         cmp bx, -0x20
1000:21ac  7e 05            jle loc_121b3
1000:21ae  c6 44 04 02      mov byte ptr [si + 4], 2
1000:21b2  c3               ret 
                            loc_121b3:
1000:21b3  3d 20 00         cmp ax, 0x20
1000:21b6  7e 05            jle loc_121bd
1000:21b8  c6 44 04 01      mov byte ptr [si + 4], 1
1000:21bc  c3               ret 
                            loc_121bd:
1000:21bd  c6 44 04 00      mov byte ptr [si + 4], 0
1000:21c1  c3               ret 
                            loc_121c2:
1000:21c2  83 fb 20         cmp bx, 0x20
1000:21c5  7d 05            jge loc_121cc
1000:21c7  c6 44 04 02      mov byte ptr [si + 4], 2
1000:21cb  c3               ret 
                            loc_121cc:
1000:21cc  3d 20 00         cmp ax, 0x20
1000:21cf  7e 05            jle loc_121d6
1000:21d1  c6 44 04 03      mov byte ptr [si + 4], 3
1000:21d5  c3               ret 
                            loc_121d6:
1000:21d6  c6 44 04 04      mov byte ptr [si + 4], 4
1000:21da  c3               ret 
                            sub_1215b ENDP
*/
void sub_1215b()
{
    // coverage: 0x235b-0x23db method sub_1215b
    // coverage2: 1000:215b-1000:21db method sub_1215b // ins(0x215b, 0x21db, 0x215b);
    cx = 0x0001;
    ax = memoryAGet16(ds, 0x1b91);
    ax -= memoryAGet16(ds, si + 7);
    if ((short)ax <= (short)0x008c)
        goto loc_12171;
    memoryASet(ds, si + 4, 0x02);
    cx = 0x0000;
    return;
loc_12171:
    if ((short)ax >= (short)0xfff0)
        goto loc_121a0;
    ah = memoryAGet(ds, si + 4);
    al = memoryAGet(ds, si);
    if (!(al & 0x20))
        goto loc_1218d;
    ah++;
    if ((char)ah <= (char)0x04)
        goto loc_1218b;
    memoryASet(ds, si, memoryAGet(ds, si) & 0xdf);
    ah = 0x04;
loc_1218b:
    goto loc_12199;
loc_1218d:
    ah--;
    if ((char)ah >= (char)0x00)
        goto loc_12199;
    memoryASet(ds, si, memoryAGet(ds, si) | 0x20);
    ah = 0x00;
loc_12199:
    memoryASet(ds, si + 4, ah);
    cx = 0x0000;
    return;
loc_121a0:
    bx = memoryAGet16(ds, 0x1b8f);
    bx -= memoryAGet16(ds, si + 5);
    if ((short)bx >= 0)
        goto loc_121c2;
    if ((short)bx <= (short)0xffe0)
        goto loc_121b3;
    memoryASet(ds, si + 4, 0x02);
    return;
loc_121b3:
    if ((short)ax <= (short)0x0020)
        goto loc_121bd;
    memoryASet(ds, si + 4, 0x01);
    return;
loc_121bd:
    memoryASet(ds, si + 4, 0x00);
    return;
loc_121c2:
    if ((short)bx >= (short)0x0020)
        goto loc_121cc;
    memoryASet(ds, si + 4, 0x02);
    return;
loc_121cc:
    if ((short)ax <= (short)0x0020)
        goto loc_121d6;
    memoryASet(ds, si + 4, 0x03);
    return;
loc_121d6:
    memoryASet(ds, si + 4, 0x04);
}
/* Assembly listing of 1000:21dc sub_121dc()
                            sub_121dc PROC
1000:21dc  b8 3c 40         mov ax, 0x403c
1000:21df  50               push ax
1000:21e0  b8 11 1e         mov ax, 0x1e11
1000:21e3  50               push ax
1000:21e4  b8 38 00         mov ax, 0x38
1000:21e7  50               push ax
1000:21e8  b8 07 00         mov ax, 7
1000:21eb  50               push ax
1000:21ec  b8 02 00         mov ax, 2
1000:21ef  50               push ax
1000:21f0  e8 f7 0a         call 0x2cea
1000:21f3  e8 0a 00         call 0x2200
1000:21f6  e8 51 04         call 0x264a
1000:21f9  e8 83 08         call 0x2a7f
1000:21fc  e8 b2 00         call 0x22b1
1000:21ff  c3               ret 
                            sub_121dc ENDP
*/
void sub_121dc()
{
    // coverage: 0x23dc-0x2400 method sub_121dc
    // coverage2: 1000:21dc-1000:2200 method sub_121dc // ins(0x21dc, 0x2200, 0x21dc);
    ax = 0x403c;
    push(ax);
    ax = 0x1e11;
    push(ax);
    ax = 0x0038;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    sub_12200();
    sub_1264a();
    sub_12a7f();
    sub_122b1();
}
/* Assembly listing of 1000:2200 sub_12200()
                            sub_12200 PROC
1000:2200  e8 08 03         call 0x250b
1000:2203  e8 4d 03         call 0x2553
1000:2206  e8 92 03         call 0x259b
1000:2209  e8 70 01         call 0x237c
1000:220c  c3               ret 
                            sub_12200 ENDP
*/
void sub_12200()
{
    // coverage: 0x2400-0x240d method sub_12200
    // coverage2: 1000:2200-1000:220d method sub_12200 // ins(0x2200, 0x220d, 0x2200);
    sub_1250b();
    sub_12553();
    sub_1259b();
    sub_1237c();
}
/* Assembly listing of 1000:220d sub_1220d()
                            sub_1220d PROC
1000:220d  fe 06 4c 94      inc byte ptr [0x944c]
1000:2211  a0 4c 94         mov al, byte ptr [0x944c]
1000:2214  24 03            and al, 3
1000:2216  75 10            jne loc_12228
1000:2218  b8 00 00         mov ax, 0
1000:221b  50               push ax
1000:221c  50               push ax
1000:221d  50               push ax
1000:221e  a0 fe 94         mov al, byte ptr [0x94fe]
1000:2221  50               push ax
1000:2222  e8 79 04         call 0x269e
1000:2225  e8 ec 04         call 0x2714
                            loc_12228:
1000:2228  a1 3c 95         mov ax, word ptr [0x953c]
1000:222b  3d 00 00         cmp ax, 0
1000:222e  74 16            je loc_12246
1000:2230  79 05            jns loc_12237
1000:2232  e8 fa 02         call 0x252f
1000:2235  eb 09            jmp loc_12240
                            loc_12237:
1000:2237  8b c8            mov cx, ax
                            loc_12239:
1000:2239  51               push cx
1000:223a  e8 05 03         call 0x2542
1000:223d  59               pop cx
1000:223e  e2 f9            loop loc_12239
                            loc_12240:
1000:2240  c7 06 3c 95 00 00  mov word ptr [0x953c], 0
                            loc_12246:
1000:2246  a1 40 95         mov ax, word ptr [0x9540]
1000:2249  3d 00 00         cmp ax, 0
1000:224c  74 16            je loc_12264
1000:224e  79 05            jns loc_12255
1000:2250  e8 24 03         call 0x2577
1000:2253  eb 09            jmp loc_1225e
                            loc_12255:
1000:2255  8b c8            mov cx, ax
                            loc_12257:
1000:2257  51               push cx
1000:2258  e8 2f 03         call 0x258a
1000:225b  59               pop cx
1000:225c  e2 f9            loop loc_12257
                            loc_1225e:
1000:225e  c7 06 40 95 00 00  mov word ptr [0x9540], 0
                            loc_12264:
1000:2264  a1 44 95         mov ax, word ptr [0x9544]
1000:2267  3d 00 00         cmp ax, 0
1000:226a  74 1e            je loc_1228a
1000:226c  79 0d            jns loc_1227b
1000:226e  f7 d8            neg ax
1000:2270  8b c8            mov cx, ax
                            loc_12272:
1000:2272  51               push cx
1000:2273  e8 49 03         call 0x25bf
1000:2276  59               pop cx
1000:2277  e2 f9            loop loc_12272
1000:2279  eb 09            jmp loc_12284
                            loc_1227b:
1000:227b  8b c8            mov cx, ax
                            loc_1227d:
1000:227d  51               push cx
1000:227e  e8 51 03         call 0x25d2
1000:2281  59               pop cx
1000:2282  e2 f9            loop loc_1227d
                            loc_12284:
1000:2284  c7 06 44 95 00 00  mov word ptr [0x9544], 0
                            loc_1228a:
1000:228a  a1 38 95         mov ax, word ptr [0x9538]
1000:228d  3d 00 00         cmp ax, 0
1000:2290  74 1e            je loc_122b0
1000:2292  79 0d            jns loc_122a1
1000:2294  f7 d8            neg ax
1000:2296  8b c8            mov cx, ax
                            loc_12298:
1000:2298  51               push cx
1000:2299  e8 c8 01         call 0x2464
1000:229c  59               pop cx
1000:229d  e2 f9            loop loc_12298
1000:229f  eb 09            jmp loc_122aa
                            loc_122a1:
1000:22a1  8b c8            mov cx, ax
                            loc_122a3:
1000:22a3  51               push cx
1000:22a4  e8 f4 00         call 0x239b
1000:22a7  59               pop cx
1000:22a8  e2 f9            loop loc_122a3
                            loc_122aa:
1000:22aa  c7 06 38 95 00 00  mov word ptr [0x9538], 0
                            loc_122b0:
1000:22b0  c3               ret 
                            sub_1220d ENDP
*/
void sub_1220d()
{
    // coverage: 0x240d-0x24b1 method sub_1220d
    // coverage2: 1000:220d-1000:22b1 method sub_1220d // ins(0x220d, 0x22b1, 0x220d);
    memoryASet(ds, 0x944c, memoryAGet(ds, 0x944c) + 1);
    al = memoryAGet(ds, 0x944c);
    al &= 0x03;
    if (al != 0)
        goto loc_12228;
    ax = 0x0000;
    push(ax);
    push(ax);
    push(ax);
    al = memoryAGet(ds, 0x94fe);
    push(ax);
    sub_1269e();
    sub_12714();
loc_12228:
    ax = memoryAGet16(ds, 0x953c);
    if (ax == 0x0000)
        goto loc_12246;
    if ((short)ax >= 0)
        goto loc_12237;
    sub_1252f();
    goto loc_12240;
loc_12237:
    cx = ax;
loc_12239:
    push(cx);
    sub_12542();
    cx = pop();
    if (--cx)
        goto loc_12239;
loc_12240:
    memoryASet16(ds, 0x953c, 0x0000);
loc_12246:
    ax = memoryAGet16(ds, 0x9540);
    if (ax == 0x0000)
        goto loc_12264;
    if ((short)ax >= 0)
        goto loc_12255;
    sub_12577();
    goto loc_1225e;
loc_12255:
    cx = ax;
loc_12257:
    push(cx);
    sub_1258a();
    cx = pop();
    if (--cx)
        goto loc_12257;
loc_1225e:
    memoryASet16(ds, 0x9540, 0x0000);
loc_12264:
    ax = memoryAGet16(ds, 0x9544);
    if (ax == 0x0000)
        goto loc_1228a;
    if ((short)ax >= 0)
        goto loc_1227b;
    ax = -ax;
    cx = ax;
loc_12272:
    push(cx);
    sub_125bf();
    cx = pop();
    if (--cx)
        goto loc_12272;
    goto loc_12284;
loc_1227b:
    cx = ax;
loc_1227d:
    push(cx);
    sub_125d2();
    cx = pop();
    if (--cx)
        goto loc_1227d;
loc_12284:
    memoryASet16(ds, 0x9544, 0x0000);
loc_1228a:
    ax = memoryAGet16(ds, 0x9538);
    if (ax == 0x0000)
        return;
    if ((short)ax >= 0)
        goto loc_122a1;
    ax = -ax;
    cx = ax;
loc_12298:
    push(cx);
    sub_12464();
    cx = pop();
    if (--cx)
        goto loc_12298;
    goto loc_122aa;
loc_122a1:
    cx = ax;
loc_122a3:
    push(cx);
    sub_1239b();
    cx = pop();
    if (--cx)
        goto loc_122a3;
loc_122aa:
    memoryASet16(ds, 0x9538, 0x0000);
}
/* Assembly listing of 1000:22b1 sub_122b1()
                            sub_122b1 PROC
1000:22b1  c7 06 34 95 03 00  mov word ptr [0x9534], 3
1000:22b7  e8 27 00         call 0x22e1
1000:22ba  e8 3c 00         call 0x22f9
1000:22bd  e8 51 00         call 0x2311
1000:22c0  c3               ret 
                            sub_122b1 ENDP
*/
void sub_122b1()
{
    // coverage: 0x24b1-0x24c1 method sub_122b1
    // coverage2: 1000:22b1-1000:22c1 method sub_122b1 // ins(0x22b1, 0x22c1, 0x22b1);
    memoryASet16(ds, 0x9534, 0x0003);
    sub_122e1();
    sub_122f9();
    sub_12311();
}
/* Assembly listing of 1000:22c1 sub_122c1()
                            sub_122c1 PROC
1000:22c1  ff 06 34 95      inc word ptr [0x9534]
1000:22c5  a1 34 95         mov ax, word ptr [0x9534]
1000:22c8  3d 03 00         cmp ax, 3
1000:22cb  76 07            jbe loc_122d4
1000:22cd  c7 06 34 95 03 00  mov word ptr [0x9534], 3
1000:22d3  c3               ret 
                            loc_122d4:
1000:22d4  74 3b            je loc_12311
1000:22d6  3d 02 00         cmp ax, 2
1000:22d9  74 1e            je loc_122f9
1000:22db  3d 01 00         cmp ax, 1
1000:22de  74 01            je loc_122e1
1000:22e0  c3               ret 
                            loc_122e1:
1000:22e1  b8 e6 43         mov ax, 0x43e6
1000:22e4  50               push ax
1000:22e5  b8 90 1b         mov ax, 0x1b90
1000:22e8  50               push ax
1000:22e9  b8 10 00         mov ax, 0x10
1000:22ec  50               push ax
1000:22ed  b8 0f 00         mov ax, 0xf
1000:22f0  50               push ax
1000:22f1  b8 02 00         mov ax, 2
1000:22f4  50               push ax
1000:22f5  e8 f2 09         call 0x2cea
1000:22f8  c3               ret 
                            loc_122f9:
1000:22f9  b8 e6 43         mov ax, 0x43e6
1000:22fc  50               push ax
1000:22fd  b8 93 1b         mov ax, 0x1b93
1000:2300  50               push ax
1000:2301  b8 10 00         mov ax, 0x10
1000:2304  50               push ax
1000:2305  b8 0f 00         mov ax, 0xf
1000:2308  50               push ax
1000:2309  b8 02 00         mov ax, 2
1000:230c  50               push ax
1000:230d  e8 da 09         call 0x2cea
1000:2310  c3               ret 
                            loc_12311:
1000:2311  b8 e6 43         mov ax, 0x43e6
1000:2314  50               push ax
1000:2315  b8 96 1b         mov ax, 0x1b96
1000:2318  50               push ax
1000:2319  b8 10 00         mov ax, 0x10
1000:231c  50               push ax
1000:231d  b8 0f 00         mov ax, 0xf
1000:2320  50               push ax
1000:2321  b8 02 00         mov ax, 2
1000:2324  50               push ax
1000:2325  e8 c2 09         call 0x2cea
1000:2328  c3               ret 
                            sub_122c1 ENDP
*/
void sub_122c1()
{
    // coverage: 0x24c1-0x2529 method sub_122c1
    // coverage2: 1000:22c1-1000:2329 method sub_122c1 // ins(0x22c1, 0x2329, 0x22c1);
    memoryASet16(ds, 0x9534, memoryAGet16(ds, 0x9534) + 1);
    ax = memoryAGet16(ds, 0x9534);
    if (ax <= 0x0003)
        goto loc_122d4;
    memoryASet16(ds, 0x9534, 0x0003);
    return;
loc_122d4:
    if (ax == 0x0003)
        goto loc_12311;
    if (ax == 0x0002)
        goto loc_122f9;
    if (ax == 0x0001)
        goto loc_122e1;
    return;
loc_122e1:
    ax = 0x43e6;
    push(ax);
    ax = 0x1b90;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_122f9:
    ax = 0x43e6;
    push(ax);
    ax = 0x1b93;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_12311:
    ax = 0x43e6;
    push(ax);
    ax = 0x1b96;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:22e1 sub_122e1()
                            sub_122e1 PROC
1000:22e1  b8 e6 43         mov ax, 0x43e6
1000:22e4  50               push ax
1000:22e5  b8 90 1b         mov ax, 0x1b90
1000:22e8  50               push ax
1000:22e9  b8 10 00         mov ax, 0x10
1000:22ec  50               push ax
1000:22ed  b8 0f 00         mov ax, 0xf
1000:22f0  50               push ax
1000:22f1  b8 02 00         mov ax, 2
1000:22f4  50               push ax
1000:22f5  e8 f2 09         call 0x2cea
1000:22f8  c3               ret 
                            sub_122e1 ENDP
*/
void sub_122e1()
{
    // coverage: 0x24e1-0x24f9 method sub_122e1
    // coverage2: 1000:22e1-1000:22f9 method sub_122e1 // ins(0x22e1, 0x22f9, 0x22e1);
    ax = 0x43e6;
    push(ax);
    ax = 0x1b90;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:22f9 sub_122f9()
                            sub_122f9 PROC
1000:22f9  b8 e6 43         mov ax, 0x43e6
1000:22fc  50               push ax
1000:22fd  b8 93 1b         mov ax, 0x1b93
1000:2300  50               push ax
1000:2301  b8 10 00         mov ax, 0x10
1000:2304  50               push ax
1000:2305  b8 0f 00         mov ax, 0xf
1000:2308  50               push ax
1000:2309  b8 02 00         mov ax, 2
1000:230c  50               push ax
1000:230d  e8 da 09         call 0x2cea
1000:2310  c3               ret 
                            sub_122f9 ENDP
*/
void sub_122f9()
{
    // coverage: 0x24f9-0x2511 method sub_122f9
    // coverage2: 1000:22f9-1000:2311 method sub_122f9 // ins(0x22f9, 0x2311, 0x22f9);
    ax = 0x43e6;
    push(ax);
    ax = 0x1b93;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2311 sub_12311()
                            sub_12311 PROC
1000:2311  b8 e6 43         mov ax, 0x43e6
1000:2314  50               push ax
1000:2315  b8 96 1b         mov ax, 0x1b96
1000:2318  50               push ax
1000:2319  b8 10 00         mov ax, 0x10
1000:231c  50               push ax
1000:231d  b8 0f 00         mov ax, 0xf
1000:2320  50               push ax
1000:2321  b8 02 00         mov ax, 2
1000:2324  50               push ax
1000:2325  e8 c2 09         call 0x2cea
1000:2328  c3               ret 
                            sub_12311 ENDP
*/
void sub_12311()
{
    // coverage: 0x2511-0x2529 method sub_12311
    // coverage2: 1000:2311-1000:2329 method sub_12311 // ins(0x2311, 0x2329, 0x2311);
    ax = 0x43e6;
    push(ax);
    ax = 0x1b96;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2329 sub_12329()
                            sub_12329 PROC
1000:2329  ff 0e 34 95      dec word ptr [0x9534]
1000:232d  a1 34 95         mov ax, word ptr [0x9534]
1000:2330  3d 02 00         cmp ax, 2
1000:2333  74 33            je loc_12368
1000:2335  3d 01 00         cmp ax, 1
1000:2338  74 1a            je loc_12354
1000:233a  3d 00 00         cmp ax, 0
1000:233d  74 01            je loc_12340
1000:233f  c3               ret 
                            loc_12340:
1000:2340  b8 90 1b         mov ax, 0x1b90
1000:2343  50               push ax
1000:2344  b8 02 00         mov ax, 2
1000:2347  50               push ax
1000:2348  b8 0f 00         mov ax, 0xf
1000:234b  50               push ax
1000:234c  b8 00 00         mov ax, 0
1000:234f  50               push ax
1000:2350  e8 47 0a         call 0x2d9a
1000:2353  c3               ret 
                            loc_12354:
1000:2354  b8 93 1b         mov ax, 0x1b93
1000:2357  50               push ax
1000:2358  b8 02 00         mov ax, 2
1000:235b  50               push ax
1000:235c  b8 0f 00         mov ax, 0xf
1000:235f  50               push ax
1000:2360  b8 00 00         mov ax, 0
1000:2363  50               push ax
1000:2364  e8 33 0a         call 0x2d9a
1000:2367  c3               ret 
                            loc_12368:
1000:2368  b8 96 1b         mov ax, 0x1b96
1000:236b  50               push ax
1000:236c  b8 02 00         mov ax, 2
1000:236f  50               push ax
1000:2370  b8 0f 00         mov ax, 0xf
1000:2373  50               push ax
1000:2374  b8 00 00         mov ax, 0
1000:2377  50               push ax
1000:2378  e8 1f 0a         call 0x2d9a
1000:237b  c3               ret 
                            sub_12329 ENDP
*/
void sub_12329()
{
    // coverage: 0x2529-0x257c method sub_12329
    // coverage2: 1000:2329-1000:237c method sub_12329 // ins(0x2329, 0x237c, 0x2329);
    memoryASet16(ds, 0x9534, memoryAGet16(ds, 0x9534) - 1);
    ax = memoryAGet16(ds, 0x9534);
    if (ax == 0x0002)
        goto loc_12368;
    if (ax == 0x0001)
        goto loc_12354;
    if (ax == 0x0000)
        goto loc_12340;
    return;
loc_12340:
    ax = 0x1b90;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_12354:
    ax = 0x1b93;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_12368:
    ax = 0x1b96;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
}
/* Assembly listing of 1000:237c sub_1237c()
                            sub_1237c PROC
1000:237c  c7 06 36 95 06 00  mov word ptr [0x9536], 6
1000:2382  c7 06 38 95 00 00  mov word ptr [0x9538], 0
1000:2388  e8 49 00         call 0x23d4
1000:238b  e8 5e 00         call 0x23ec
1000:238e  e8 73 00         call 0x2404
1000:2391  e8 88 00         call 0x241c
1000:2394  e8 9d 00         call 0x2434
1000:2397  e8 b2 00         call 0x244c
1000:239a  c3               ret 
                            sub_1237c ENDP
*/
void sub_1237c()
{
    // coverage: 0x257c-0x259b method sub_1237c
    // coverage2: 1000:237c-1000:239b method sub_1237c // ins(0x237c, 0x239b, 0x237c);
    memoryASet16(ds, 0x9536, 0x0006);
    memoryASet16(ds, 0x9538, 0x0000);
    sub_123d4();
    sub_123ec();
    sub_12404();
    sub_1241c();
    sub_12434();
    sub_1244c();
}
/* Assembly listing of 1000:239b sub_1239b()
                            sub_1239b PROC
1000:239b  ff 06 36 95      inc word ptr [0x9536]
1000:239f  a1 36 95         mov ax, word ptr [0x9536]
1000:23a2  3d 06 00         cmp ax, 6
1000:23a5  76 07            jbe loc_123ae
1000:23a7  c7 06 36 95 06 00  mov word ptr [0x9536], 6
1000:23ad  c3               ret 
                            loc_123ae:
1000:23ae  50               push ax
1000:23af  b0 08            mov al, 8
1000:23b1  e8 8c 14         call 0x3840
1000:23b4  58               pop ax
1000:23b5  3d 01 00         cmp ax, 1
1000:23b8  74 1a            je loc_123d4
1000:23ba  3d 02 00         cmp ax, 2
1000:23bd  74 2d            je loc_123ec
1000:23bf  3d 03 00         cmp ax, 3
1000:23c2  74 40            je loc_12404
1000:23c4  3d 04 00         cmp ax, 4
1000:23c7  74 53            je loc_1241c
1000:23c9  3d 05 00         cmp ax, 5
1000:23cc  74 66            je loc_12434
1000:23ce  3d 06 00         cmp ax, 6
1000:23d1  74 79            je loc_1244c
1000:23d3  c3               ret 
                            loc_123d4:
1000:23d4  b8 ee 43         mov ax, 0x43ee
1000:23d7  50               push ax
1000:23d8  b8 99 1b         mov ax, 0x1b99
1000:23db  50               push ax
1000:23dc  b8 10 00         mov ax, 0x10
1000:23df  50               push ax
1000:23e0  b8 0f 00         mov ax, 0xf
1000:23e3  50               push ax
1000:23e4  b8 02 00         mov ax, 2
1000:23e7  50               push ax
1000:23e8  e8 ff 08         call 0x2cea
1000:23eb  c3               ret 
                            loc_123ec:
1000:23ec  b8 ee 43         mov ax, 0x43ee
1000:23ef  50               push ax
1000:23f0  b8 9b 1b         mov ax, 0x1b9b
1000:23f3  50               push ax
1000:23f4  b8 10 00         mov ax, 0x10
1000:23f7  50               push ax
1000:23f8  b8 0f 00         mov ax, 0xf
1000:23fb  50               push ax
1000:23fc  b8 02 00         mov ax, 2
1000:23ff  50               push ax
1000:2400  e8 e7 08         call 0x2cea
1000:2403  c3               ret 
                            loc_12404:
1000:2404  b8 ee 43         mov ax, 0x43ee
1000:2407  50               push ax
1000:2408  b8 9d 1b         mov ax, 0x1b9d
1000:240b  50               push ax
1000:240c  b8 10 00         mov ax, 0x10
1000:240f  50               push ax
1000:2410  b8 0f 00         mov ax, 0xf
1000:2413  50               push ax
1000:2414  b8 02 00         mov ax, 2
1000:2417  50               push ax
1000:2418  e8 cf 08         call 0x2cea
1000:241b  c3               ret 
                            loc_1241c:
1000:241c  b8 ee 43         mov ax, 0x43ee
1000:241f  50               push ax
1000:2420  b8 9f 1b         mov ax, 0x1b9f
1000:2423  50               push ax
1000:2424  b8 10 00         mov ax, 0x10
1000:2427  50               push ax
1000:2428  b8 0f 00         mov ax, 0xf
1000:242b  50               push ax
1000:242c  b8 02 00         mov ax, 2
1000:242f  50               push ax
1000:2430  e8 b7 08         call 0x2cea
1000:2433  c3               ret 
                            loc_12434:
1000:2434  b8 ee 43         mov ax, 0x43ee
1000:2437  50               push ax
1000:2438  b8 a1 1b         mov ax, 0x1ba1
1000:243b  50               push ax
1000:243c  b8 10 00         mov ax, 0x10
1000:243f  50               push ax
1000:2440  b8 0f 00         mov ax, 0xf
1000:2443  50               push ax
1000:2444  b8 02 00         mov ax, 2
1000:2447  50               push ax
1000:2448  e8 9f 08         call 0x2cea
1000:244b  c3               ret 
                            loc_1244c:
1000:244c  b8 ee 43         mov ax, 0x43ee
1000:244f  50               push ax
1000:2450  b8 a3 1b         mov ax, 0x1ba3
1000:2453  50               push ax
1000:2454  b8 10 00         mov ax, 0x10
1000:2457  50               push ax
1000:2458  b8 0f 00         mov ax, 0xf
1000:245b  50               push ax
1000:245c  b8 02 00         mov ax, 2
1000:245f  50               push ax
1000:2460  e8 87 08         call 0x2cea
1000:2463  c3               ret 
                            sub_1239b ENDP
*/
void sub_1239b()
{
    // coverage: 0x259b-0x2664 method sub_1239b
    // coverage2: 1000:239b-1000:2464 method sub_1239b // ins(0x239b, 0x2464, 0x239b);
    memoryASet16(ds, 0x9536, memoryAGet16(ds, 0x9536) + 1);
    ax = memoryAGet16(ds, 0x9536);
    if (ax <= 0x0006)
        goto loc_123ae;
    memoryASet16(ds, 0x9536, 0x0006);
    return;
loc_123ae:
    push(ax);
    al = 0x08;
    sub_13840();
    ax = pop();
    if (ax == 0x0001)
        goto loc_123d4;
    if (ax == 0x0002)
        goto loc_123ec;
    if (ax == 0x0003)
        goto loc_12404;
    if (ax == 0x0004)
        goto loc_1241c;
    if (ax == 0x0005)
        goto loc_12434;
    if (ax == 0x0006)
        goto loc_1244c;
    return;
loc_123d4:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b99;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_123ec:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9b;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_12404:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9d;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_1241c:
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9f;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_12434:
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba1;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    return;
loc_1244c:
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba3;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:23d4 sub_123d4()
                            sub_123d4 PROC
1000:23d4  b8 ee 43         mov ax, 0x43ee
1000:23d7  50               push ax
1000:23d8  b8 99 1b         mov ax, 0x1b99
1000:23db  50               push ax
1000:23dc  b8 10 00         mov ax, 0x10
1000:23df  50               push ax
1000:23e0  b8 0f 00         mov ax, 0xf
1000:23e3  50               push ax
1000:23e4  b8 02 00         mov ax, 2
1000:23e7  50               push ax
1000:23e8  e8 ff 08         call 0x2cea
1000:23eb  c3               ret 
                            sub_123d4 ENDP
*/
void sub_123d4()
{
    // coverage: 0x25d4-0x25ec method sub_123d4
    // coverage2: 1000:23d4-1000:23ec method sub_123d4 // ins(0x23d4, 0x23ec, 0x23d4);
    ax = 0x43ee;
    push(ax);
    ax = 0x1b99;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:23ec sub_123ec()
                            sub_123ec PROC
1000:23ec  b8 ee 43         mov ax, 0x43ee
1000:23ef  50               push ax
1000:23f0  b8 9b 1b         mov ax, 0x1b9b
1000:23f3  50               push ax
1000:23f4  b8 10 00         mov ax, 0x10
1000:23f7  50               push ax
1000:23f8  b8 0f 00         mov ax, 0xf
1000:23fb  50               push ax
1000:23fc  b8 02 00         mov ax, 2
1000:23ff  50               push ax
1000:2400  e8 e7 08         call 0x2cea
1000:2403  c3               ret 
                            sub_123ec ENDP
*/
void sub_123ec()
{
    // coverage: 0x25ec-0x2604 method sub_123ec
    // coverage2: 1000:23ec-1000:2404 method sub_123ec // ins(0x23ec, 0x2404, 0x23ec);
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9b;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2404 sub_12404()
                            sub_12404 PROC
1000:2404  b8 ee 43         mov ax, 0x43ee
1000:2407  50               push ax
1000:2408  b8 9d 1b         mov ax, 0x1b9d
1000:240b  50               push ax
1000:240c  b8 10 00         mov ax, 0x10
1000:240f  50               push ax
1000:2410  b8 0f 00         mov ax, 0xf
1000:2413  50               push ax
1000:2414  b8 02 00         mov ax, 2
1000:2417  50               push ax
1000:2418  e8 cf 08         call 0x2cea
1000:241b  c3               ret 
                            sub_12404 ENDP
*/
void sub_12404()
{
    // coverage: 0x2604-0x261c method sub_12404
    // coverage2: 1000:2404-1000:241c method sub_12404 // ins(0x2404, 0x241c, 0x2404);
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9d;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:241c sub_1241c()
                            sub_1241c PROC
1000:241c  b8 ee 43         mov ax, 0x43ee
1000:241f  50               push ax
1000:2420  b8 9f 1b         mov ax, 0x1b9f
1000:2423  50               push ax
1000:2424  b8 10 00         mov ax, 0x10
1000:2427  50               push ax
1000:2428  b8 0f 00         mov ax, 0xf
1000:242b  50               push ax
1000:242c  b8 02 00         mov ax, 2
1000:242f  50               push ax
1000:2430  e8 b7 08         call 0x2cea
1000:2433  c3               ret 
                            sub_1241c ENDP
*/
void sub_1241c()
{
    // coverage: 0x261c-0x2634 method sub_1241c
    // coverage2: 1000:241c-1000:2434 method sub_1241c // ins(0x241c, 0x2434, 0x241c);
    ax = 0x43ee;
    push(ax);
    ax = 0x1b9f;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2434 sub_12434()
                            sub_12434 PROC
1000:2434  b8 ee 43         mov ax, 0x43ee
1000:2437  50               push ax
1000:2438  b8 a1 1b         mov ax, 0x1ba1
1000:243b  50               push ax
1000:243c  b8 10 00         mov ax, 0x10
1000:243f  50               push ax
1000:2440  b8 0f 00         mov ax, 0xf
1000:2443  50               push ax
1000:2444  b8 02 00         mov ax, 2
1000:2447  50               push ax
1000:2448  e8 9f 08         call 0x2cea
1000:244b  c3               ret 
                            sub_12434 ENDP
*/
void sub_12434()
{
    // coverage: 0x2634-0x264c method sub_12434
    // coverage2: 1000:2434-1000:244c method sub_12434 // ins(0x2434, 0x244c, 0x2434);
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba1;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:244c sub_1244c()
                            sub_1244c PROC
1000:244c  b8 ee 43         mov ax, 0x43ee
1000:244f  50               push ax
1000:2450  b8 a3 1b         mov ax, 0x1ba3
1000:2453  50               push ax
1000:2454  b8 10 00         mov ax, 0x10
1000:2457  50               push ax
1000:2458  b8 0f 00         mov ax, 0xf
1000:245b  50               push ax
1000:245c  b8 02 00         mov ax, 2
1000:245f  50               push ax
1000:2460  e8 87 08         call 0x2cea
1000:2463  c3               ret 
                            sub_1244c ENDP
*/
void sub_1244c()
{
    // coverage: 0x264c-0x2664 method sub_1244c
    // coverage2: 1000:244c-1000:2464 method sub_1244c // ins(0x244c, 0x2464, 0x244c);
    ax = 0x43ee;
    push(ax);
    ax = 0x1ba3;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2464 sub_12464()
                            sub_12464 PROC
1000:2464  a1 36 95         mov ax, word ptr [0x9536]
1000:2467  ff 0e 36 95      dec word ptr [0x9536]
1000:246b  79 07            jns loc_12474
1000:246d  c7 06 36 95 00 00  mov word ptr [0x9536], 0
1000:2473  c3               ret 
                            loc_12474:
1000:2474  3d 01 00         cmp ax, 1
1000:2477  74 1a            je loc_12493
1000:2479  3d 02 00         cmp ax, 2
1000:247c  74 29            je loc_124a7
1000:247e  3d 03 00         cmp ax, 3
1000:2481  74 38            je loc_124bb
1000:2483  3d 04 00         cmp ax, 4
1000:2486  74 47            je loc_124cf
1000:2488  3d 05 00         cmp ax, 5
1000:248b  74 56            je loc_124e3
1000:248d  3d 06 00         cmp ax, 6
1000:2490  74 65            je loc_124f7
1000:2492  c3               ret 
                            loc_12493:
1000:2493  b8 99 1b         mov ax, 0x1b99
1000:2496  50               push ax
1000:2497  b8 02 00         mov ax, 2
1000:249a  50               push ax
1000:249b  b8 0f 00         mov ax, 0xf
1000:249e  50               push ax
1000:249f  b8 00 00         mov ax, 0
1000:24a2  50               push ax
1000:24a3  e8 f4 08         call 0x2d9a
1000:24a6  c3               ret 
                            loc_124a7:
1000:24a7  b8 9b 1b         mov ax, 0x1b9b
1000:24aa  50               push ax
1000:24ab  b8 02 00         mov ax, 2
1000:24ae  50               push ax
1000:24af  b8 0f 00         mov ax, 0xf
1000:24b2  50               push ax
1000:24b3  b8 00 00         mov ax, 0
1000:24b6  50               push ax
1000:24b7  e8 e0 08         call 0x2d9a
1000:24ba  c3               ret 
                            loc_124bb:
1000:24bb  b8 9d 1b         mov ax, 0x1b9d
1000:24be  50               push ax
1000:24bf  b8 02 00         mov ax, 2
1000:24c2  50               push ax
1000:24c3  b8 0f 00         mov ax, 0xf
1000:24c6  50               push ax
1000:24c7  b8 00 00         mov ax, 0
1000:24ca  50               push ax
1000:24cb  e8 cc 08         call 0x2d9a
1000:24ce  c3               ret 
                            loc_124cf:
1000:24cf  b8 9f 1b         mov ax, 0x1b9f
1000:24d2  50               push ax
1000:24d3  b8 02 00         mov ax, 2
1000:24d6  50               push ax
1000:24d7  b8 0f 00         mov ax, 0xf
1000:24da  50               push ax
1000:24db  b8 00 00         mov ax, 0
1000:24de  50               push ax
1000:24df  e8 b8 08         call 0x2d9a
1000:24e2  c3               ret 
                            loc_124e3:
1000:24e3  b8 a1 1b         mov ax, 0x1ba1
1000:24e6  50               push ax
1000:24e7  b8 02 00         mov ax, 2
1000:24ea  50               push ax
1000:24eb  b8 0f 00         mov ax, 0xf
1000:24ee  50               push ax
1000:24ef  b8 00 00         mov ax, 0
1000:24f2  50               push ax
1000:24f3  e8 a4 08         call 0x2d9a
1000:24f6  c3               ret 
                            loc_124f7:
1000:24f7  b8 a3 1b         mov ax, 0x1ba3
1000:24fa  50               push ax
1000:24fb  b8 02 00         mov ax, 2
1000:24fe  50               push ax
1000:24ff  b8 0f 00         mov ax, 0xf
1000:2502  50               push ax
1000:2503  b8 00 00         mov ax, 0
1000:2506  50               push ax
1000:2507  e8 90 08         call 0x2d9a
1000:250a  c3               ret 
                            sub_12464 ENDP
*/
void sub_12464()
{
    // coverage: 0x2664-0x270b method sub_12464
    // coverage2: 1000:2464-1000:250b method sub_12464 // ins(0x2464, 0x250b, 0x2464);
    ax = memoryAGet16(ds, 0x9536);
    memoryASet16(ds, 0x9536, memoryAGet16(ds, 0x9536) - 1);
    if ((short)memoryAGet16(ds, 0x9536) >= 0)
        goto loc_12474;
    memoryASet16(ds, 0x9536, 0x0000);
    return;
loc_12474:
    if (ax == 0x0001)
        goto loc_12493;
    if (ax == 0x0002)
        goto loc_124a7;
    if (ax == 0x0003)
        goto loc_124bb;
    if (ax == 0x0004)
        goto loc_124cf;
    if (ax == 0x0005)
        goto loc_124e3;
    if (ax == 0x0006)
        goto loc_124f7;
    return;
loc_12493:
    ax = 0x1b99;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124a7:
    ax = 0x1b9b;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124bb:
    ax = 0x1b9d;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124cf:
    ax = 0x1b9f;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124e3:
    ax = 0x1ba1;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
    return;
loc_124f7:
    ax = 0x1ba3;
    push(ax);
    ax = 0x0002;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_12d9a();
}
/* Assembly listing of 1000:250b sub_1250b()
                            sub_1250b PROC
1000:250b  c7 06 3a 95 2c 00  mov word ptr [0x953a], 0x2c
1000:2511  c7 06 3c 95 00 00  mov word ptr [0x953c], 0
1000:2517  b8 f6 48         mov ax, 0x48f6
1000:251a  50               push ax
1000:251b  b8 88 1b         mov ax, 0x1b88
1000:251e  50               push ax
1000:251f  b8 2c 00         mov ax, 0x2c
1000:2522  50               push ax
1000:2523  b8 07 00         mov ax, 7
1000:2526  50               push ax
1000:2527  b8 02 00         mov ax, 2
1000:252a  50               push ax
1000:252b  e8 bc 07         call 0x2cea
1000:252e  c3               ret 
                            sub_1250b ENDP
*/
void sub_1250b()
{
    // coverage: 0x270b-0x272f method sub_1250b
    // coverage2: 1000:250b-1000:252f method sub_1250b // ins(0x250b, 0x252f, 0x250b);
    memoryASet16(ds, 0x953a, 0x002c);
    memoryASet16(ds, 0x953c, 0x0000);
    ax = 0x48f6;
    push(ax);
    ax = 0x1b88;
    push(ax);
    ax = 0x002c;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:252f sub_1252f()
                            sub_1252f PROC
1000:252f  a1 3a 95         mov ax, word ptr [0x953a]
1000:2532  48               dec ax
1000:2533  79 01            jns loc_12536
1000:2535  c3               ret 
                            loc_12536:
1000:2536  a3 3a 95         mov word ptr [0x953a], ax
1000:2539  50               push ax
1000:253a  b8 88 1b         mov ax, 0x1b88
1000:253d  50               push ax
1000:253e  e8 a2 00         call 0x25e3
1000:2541  c3               ret 
                            sub_1252f ENDP
*/
void sub_1252f()
{
    // coverage: 0x272f-0x2742 method sub_1252f
    // coverage2: 1000:252f-1000:2542 method sub_1252f // ins(0x252f, 0x2542, 0x252f);
    ax = memoryAGet16(ds, 0x953a);
    ax--;
    if ((short)ax >= 0)
        goto loc_12536;
    return;
loc_12536:
    memoryASet16(ds, 0x953a, ax);
    push(ax);
    ax = 0x1b88;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:2536 sub_12536()
                            sub_12536 PROC
1000:2536  a3 3a 95         mov word ptr [0x953a], ax
1000:2539  50               push ax
1000:253a  b8 88 1b         mov ax, 0x1b88
1000:253d  50               push ax
1000:253e  e8 a2 00         call 0x25e3
1000:2541  c3               ret 
                            sub_12536 ENDP
*/
void sub_12536()
{
    // coverage: 0x2736-0x2742 method sub_12536
    // coverage2: 1000:2536-1000:2542 method sub_12536 // ins(0x2536, 0x2542, 0x2536);
    memoryASet16(ds, 0x953a, ax);
    push(ax);
    ax = 0x1b88;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:2542 sub_12542()
                            sub_12542 PROC
1000:2542  a1 3a 95         mov ax, word ptr [0x953a]
1000:2545  3d 2c 00         cmp ax, 0x2c
1000:2548  72 01            jb loc_1254b
1000:254a  c3               ret 
                            loc_1254b:
1000:254b  e8 e8 ff         call 0x2536
1000:254e  ff 06 3a 95      inc word ptr [0x953a]
1000:2552  c3               ret 
                            sub_12542 ENDP
*/
void sub_12542()
{
    // coverage: 0x2742-0x2753 method sub_12542
    // coverage2: 1000:2542-1000:2553 method sub_12542 // ins(0x2542, 0x2553, 0x2542);
    ax = memoryAGet16(ds, 0x953a);
    if (ax < 0x002c)
        goto loc_1254b;
    return;
loc_1254b:
    sub_12536();
    memoryASet16(ds, 0x953a, memoryAGet16(ds, 0x953a) + 1);
}
/* Assembly listing of 1000:2553 sub_12553()
                            sub_12553 PROC
1000:2553  c7 06 3e 95 30 00  mov word ptr [0x953e], 0x30
1000:2559  c7 06 40 95 00 00  mov word ptr [0x9540], 0
1000:255f  b8 e6 2c         mov ax, 0x2ce6
1000:2562  50               push ax
1000:2563  b8 c8 1c         mov ax, 0x1cc8
1000:2566  50               push ax
1000:2567  b8 30 00         mov ax, 0x30
1000:256a  50               push ax
1000:256b  b8 07 00         mov ax, 7
1000:256e  50               push ax
1000:256f  b8 02 00         mov ax, 2
1000:2572  50               push ax
1000:2573  e8 74 07         call 0x2cea
1000:2576  c3               ret 
                            sub_12553 ENDP
*/
void sub_12553()
{
    // coverage: 0x2753-0x2777 method sub_12553
    // coverage2: 1000:2553-1000:2577 method sub_12553 // ins(0x2553, 0x2577, 0x2553);
    memoryASet16(ds, 0x953e, 0x0030);
    memoryASet16(ds, 0x9540, 0x0000);
    ax = 0x2ce6;
    push(ax);
    ax = 0x1cc8;
    push(ax);
    ax = 0x0030;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2577 sub_12577()
                            sub_12577 PROC
1000:2577  a1 3e 95         mov ax, word ptr [0x953e]
1000:257a  48               dec ax
1000:257b  79 01            jns loc_1257e
1000:257d  c3               ret 
                            loc_1257e:
1000:257e  a3 3e 95         mov word ptr [0x953e], ax
1000:2581  50               push ax
1000:2582  b8 c8 1c         mov ax, 0x1cc8
1000:2585  50               push ax
1000:2586  e8 5a 00         call 0x25e3
1000:2589  c3               ret 
                            sub_12577 ENDP
*/
void sub_12577()
{
    // coverage: 0x2777-0x278a method sub_12577
    // coverage2: 1000:2577-1000:258a method sub_12577 // ins(0x2577, 0x258a, 0x2577);
    ax = memoryAGet16(ds, 0x953e);
    ax--;
    if ((short)ax >= 0)
        goto loc_1257e;
    return;
loc_1257e:
    memoryASet16(ds, 0x953e, ax);
    push(ax);
    ax = 0x1cc8;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:257e sub_1257e()
                            sub_1257e PROC
1000:257e  a3 3e 95         mov word ptr [0x953e], ax
1000:2581  50               push ax
1000:2582  b8 c8 1c         mov ax, 0x1cc8
1000:2585  50               push ax
1000:2586  e8 5a 00         call 0x25e3
1000:2589  c3               ret 
                            sub_1257e ENDP
*/
void sub_1257e()
{
    // coverage: 0x277e-0x278a method sub_1257e
    // coverage2: 1000:257e-1000:258a method sub_1257e // ins(0x257e, 0x258a, 0x257e);
    memoryASet16(ds, 0x953e, ax);
    push(ax);
    ax = 0x1cc8;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:258a sub_1258a()
                            sub_1258a PROC
1000:258a  a1 3e 95         mov ax, word ptr [0x953e]
1000:258d  3d 30 00         cmp ax, 0x30
1000:2590  72 01            jb loc_12593
1000:2592  c3               ret 
                            loc_12593:
1000:2593  e8 e8 ff         call 0x257e
1000:2596  ff 06 3e 95      inc word ptr [0x953e]
1000:259a  c3               ret 
                            sub_1258a ENDP
*/
void sub_1258a()
{
    // coverage: 0x278a-0x279b method sub_1258a
    // coverage2: 1000:258a-1000:259b method sub_1258a // ins(0x258a, 0x259b, 0x258a);
    ax = memoryAGet16(ds, 0x953e);
    if (ax < 0x0030)
        goto loc_12593;
    return;
loc_12593:
    sub_1257e();
    memoryASet16(ds, 0x953e, memoryAGet16(ds, 0x953e) + 1);
}
/* Assembly listing of 1000:259b sub_1259b()
                            sub_1259b PROC
1000:259b  c7 06 42 95 38 00  mov word ptr [0x9542], 0x38
1000:25a1  c7 06 44 95 00 00  mov word ptr [0x9544], 0
1000:25a7  b8 96 44         mov ax, 0x4496
1000:25aa  50               push ax
1000:25ab  b8 08 1e         mov ax, 0x1e08
1000:25ae  50               push ax
1000:25af  b8 38 00         mov ax, 0x38
1000:25b2  50               push ax
1000:25b3  b8 07 00         mov ax, 7
1000:25b6  50               push ax
1000:25b7  b8 02 00         mov ax, 2
1000:25ba  50               push ax
1000:25bb  e8 2c 07         call 0x2cea
1000:25be  c3               ret 
                            sub_1259b ENDP
*/
void sub_1259b()
{
    // coverage: 0x279b-0x27bf method sub_1259b
    // coverage2: 1000:259b-1000:25bf method sub_1259b // ins(0x259b, 0x25bf, 0x259b);
    memoryASet16(ds, 0x9542, 0x0038);
    memoryASet16(ds, 0x9544, 0x0000);
    ax = 0x4496;
    push(ax);
    ax = 0x1e08;
    push(ax);
    ax = 0x0038;
    push(ax);
    ax = 0x0007;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:25bf sub_125bf()
                            sub_125bf PROC
1000:25bf  a1 42 95         mov ax, word ptr [0x9542]
1000:25c2  48               dec ax
1000:25c3  79 01            jns loc_125c6
1000:25c5  c3               ret 
                            loc_125c6:
1000:25c6  a3 42 95         mov word ptr [0x9542], ax
1000:25c9  50               push ax
1000:25ca  b8 08 1e         mov ax, 0x1e08
1000:25cd  50               push ax
1000:25ce  e8 12 00         call 0x25e3
1000:25d1  c3               ret 
                            sub_125bf ENDP
*/
void sub_125bf()
{
    // coverage: 0x27bf-0x27d2 method sub_125bf
    // coverage2: 1000:25bf-1000:25d2 method sub_125bf // ins(0x25bf, 0x25d2, 0x25bf);
    ax = memoryAGet16(ds, 0x9542);
    ax--;
    if ((short)ax >= 0)
        goto loc_125c6;
    return;
loc_125c6:
    memoryASet16(ds, 0x9542, ax);
    push(ax);
    ax = 0x1e08;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:25c6 sub_125c6()
                            sub_125c6 PROC
1000:25c6  a3 42 95         mov word ptr [0x9542], ax
1000:25c9  50               push ax
1000:25ca  b8 08 1e         mov ax, 0x1e08
1000:25cd  50               push ax
1000:25ce  e8 12 00         call 0x25e3
1000:25d1  c3               ret 
                            sub_125c6 ENDP
*/
void sub_125c6()
{
    // coverage: 0x27c6-0x27d2 method sub_125c6
    // coverage2: 1000:25c6-1000:25d2 method sub_125c6 // ins(0x25c6, 0x25d2, 0x25c6);
    memoryASet16(ds, 0x9542, ax);
    push(ax);
    ax = 0x1e08;
    push(ax);
    sub_125e3();
}
/* Assembly listing of 1000:25d2 sub_125d2()
                            sub_125d2 PROC
1000:25d2  a1 42 95         mov ax, word ptr [0x9542]
1000:25d5  3d 38 00         cmp ax, 0x38
1000:25d8  72 01            jb loc_125db
1000:25da  c3               ret 
                            loc_125db:
1000:25db  e8 e8 ff         call 0x25c6
1000:25de  ff 06 42 95      inc word ptr [0x9542]
1000:25e2  c3               ret 
                            sub_125d2 ENDP
*/
void sub_125d2()
{
    // coverage: 0x27d2-0x27e3 method sub_125d2
    // coverage2: 1000:25d2-1000:25e3 method sub_125d2 // ins(0x25d2, 0x25e3, 0x25d2);
    ax = memoryAGet16(ds, 0x9542);
    if (ax < 0x0038)
        goto loc_125db;
    return;
loc_125db:
    sub_125c6();
    memoryASet16(ds, 0x9542, memoryAGet16(ds, 0x9542) + 1);
}
/* Assembly listing of 1000:25e3 sub_125e3()
                            sub_125e3 PROC
1000:25e3  55               push bp
1000:25e4  8b ec            mov bp, sp
1000:25e6  b8 00 a0         mov ax, 0xa000
1000:25e9  8e c0            mov es, ax
1000:25eb  8b 46 06         mov ax, word ptr [bp + 6]
1000:25ee  d1 e8            shr ax, 1
1000:25f0  d1 e8            shr ax, 1
1000:25f2  d1 e8            shr ax, 1
1000:25f4  03 46 04         add ax, word ptr [bp + 4]
1000:25f7  8b f8            mov di, ax
1000:25f9  ba ce 03         mov dx, 0x3ce
1000:25fc  b8 05 08         mov ax, 0x805
1000:25ff  ef               out dx, ax
1000:2600  8b 4e 06         mov cx, word ptr [bp + 6]
1000:2603  83 e1 07         and cx, 7
1000:2606  b4 80            mov ah, 0x80
1000:2608  d2 ec            shr ah, cl
1000:260a  b0 08            mov al, 8
1000:260c  ef               out dx, ax
1000:260d  8a dc            mov bl, ah
1000:260f  b8 03 18         mov ax, 0x1803
1000:2612  ef               out dx, ax
1000:2613  b8 01 0f         mov ax, 0xf01
1000:2616  ef               out dx, ax
1000:2617  b8 00 07         mov ax, 0x700
1000:261a  ef               out dx, ax
1000:261b  b9 07 00         mov cx, 7
                            loc_1261e:
1000:261e  26 8a 05         mov al, byte ptr es:[di]
1000:2621  84 c3            test bl, al
1000:2623  75 08            jne loc_1262d
1000:2625  26 88 1d         mov byte ptr es:[di], bl
1000:2628  26 88 9d 00 20   mov byte ptr es:[di + 0x2000], bl
                            loc_1262d:
1000:262d  83 c7 28         add di, 0x28
1000:2630  e2 ec            loop loc_1261e
1000:2632  b8 05 00         mov ax, 5
1000:2635  ef               out dx, ax
1000:2636  b8 08 ff         mov ax, 0xff08
1000:2639  ef               out dx, ax
1000:263a  b8 03 00         mov ax, 3
1000:263d  ef               out dx, ax
1000:263e  b8 01 00         mov ax, 1
1000:2641  ef               out dx, ax
1000:2642  b8 00 00         mov ax, 0
1000:2645  ef               out dx, ax
1000:2646  5d               pop bp
1000:2647  c2 04 00         ret 4
                            sub_125e3 ENDP
*/
void sub_125e3()
{
    // coverage: 0x27e3-0x284a method sub_125e3
    // coverage2: 1000:25e3-1000:264a method sub_125e3 // ins(0x25e3, 0x264a, 0x25e3);
    push(bp);
    bp = sp;
    ax = 0xa000;
    es = ax;
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax += memoryAGet16(ss, bp + 4 - 2);
    di = ax;
    dx = 0x03ce;
    ax = 0x0805;
    out(dx, ax);
    cx = memoryAGet16(ss, bp + 6 - 2);
    cx &= 0x0007;
    ah = 0x80;
    ah >>= cl;
    al = 0x08;
    out(dx, ax);
    bl = ah;
    ax = 0x1803;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    ax = 0x0700;
    out(dx, ax);
    cx = 0x0007;
loc_1261e:
    al = memoryAGet(es, di);
    if (bl & al)
        goto loc_1262d;
    memoryASet(es, di, bl);
    memoryASet(es, di + 8192, bl);
loc_1262d:
    di += 0x0028;
    if (--cx)
        goto loc_1261e;
    ax = 0x0005;
    out(dx, ax);
    ax = 0xff08;
    out(dx, ax);
    ax = 0x0003;
    out(dx, ax);
    ax = 0x0001;
    out(dx, ax);
    ax = 0x0000;
    out(dx, ax);
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:264a sub_1264a()
                            sub_1264a PROC
1000:264a  b0 00            mov al, 0
1000:264c  a2 a9 94         mov byte ptr [0x94a9], al
1000:264f  a2 aa 94         mov byte ptr [0x94aa], al
1000:2652  a2 ab 94         mov byte ptr [0x94ab], al
1000:2655  a2 ac 94         mov byte ptr [0x94ac], al
1000:2658  a2 ad 94         mov byte ptr [0x94ad], al
1000:265b  a2 ae 94         mov byte ptr [0x94ae], al
1000:265e  e8 b3 00         call 0x2714
1000:2661  c3               ret 
                            sub_1264a ENDP
*/
void sub_1264a()
{
    // coverage: 0x284a-0x2862 method sub_1264a
    // coverage2: 1000:264a-1000:2662 method sub_1264a // ins(0x264a, 0x2662, 0x264a);
    al = 0x00;
    memoryASet(ds, 0x94a9, al);
    memoryASet(ds, 0x94aa, al);
    memoryASet(ds, 0x94ab, al);
    memoryASet(ds, 0x94ac, al);
    memoryASet(ds, 0x94ad, al);
    memoryASet(ds, 0x94ae, al);
    sub_12714();
}
/* Assembly listing of 1000:2662 sub_12662()
                            sub_12662 PROC
1000:2662  b8 00 00         mov ax, 0
1000:2665  50               push ax
1000:2666  b8 00 00         mov ax, 0
1000:2669  50               push ax
1000:266a  b8 01 00         mov ax, 1
1000:266d  50               push ax
1000:266e  b8 00 00         mov ax, 0
1000:2671  50               push ax
1000:2672  e8 29 00         call 0x269e
1000:2675  c3               ret 
                            sub_12662 ENDP
*/
void sub_12662()
{
    // coverage: 0x2862-0x2876 method sub_12662
    // coverage2: 1000:2662-1000:2676 method sub_12662 // ins(0x2662, 0x2676, 0x2662);
    ax = 0x0000;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
}
/* Assembly listing of 1000:2676 sub_12676()
                            sub_12676 PROC
1000:2676  b8 00 00         mov ax, 0
1000:2679  50               push ax
1000:267a  b8 01 00         mov ax, 1
1000:267d  50               push ax
1000:267e  b8 05 00         mov ax, 5
1000:2681  50               push ax
1000:2682  b8 00 00         mov ax, 0
1000:2685  50               push ax
1000:2686  e8 15 00         call 0x269e
1000:2689  c3               ret 
                            sub_12676 ENDP
*/
void sub_12676()
{
    // coverage: 0x2876-0x288a method sub_12676
    // coverage2: 1000:2676-1000:268a method sub_12676 // ins(0x2676, 0x268a, 0x2676);
    ax = 0x0000;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0005;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
}
/* Assembly listing of 1000:268a sub_1268a()
                            sub_1268a PROC
1000:268a  b8 02 00         mov ax, 2
1000:268d  50               push ax
1000:268e  b8 05 00         mov ax, 5
1000:2691  50               push ax
1000:2692  b8 00 00         mov ax, 0
1000:2695  50               push ax
1000:2696  b8 00 00         mov ax, 0
1000:2699  50               push ax
1000:269a  e8 01 00         call 0x269e
1000:269d  c3               ret 
                            sub_1268a ENDP
*/
void sub_1268a()
{
    // coverage: 0x288a-0x289e method sub_1268a
    // coverage2: 1000:268a-1000:269e method sub_1268a // ins(0x268a, 0x269e, 0x268a);
    ax = 0x0002;
    push(ax);
    ax = 0x0005;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
}
/* Assembly listing of 1000:269e sub_1269e()
                            sub_1269e PROC
1000:269e  55               push bp
1000:269f  8b ec            mov bp, sp
1000:26a1  a0 ae 94         mov al, byte ptr [0x94ae]
1000:26a4  02 46 04         add al, byte ptr [bp + 4]
1000:26a7  3c 09            cmp al, 9
1000:26a9  76 06            jbe loc_126b1
1000:26ab  2c 0a            sub al, 0xa
1000:26ad  fe 06 ad 94      inc byte ptr [0x94ad]
                            loc_126b1:
1000:26b1  a2 ae 94         mov byte ptr [0x94ae], al
1000:26b4  a0 ad 94         mov al, byte ptr [0x94ad]
1000:26b7  02 46 06         add al, byte ptr [bp + 6]
1000:26ba  3c 09            cmp al, 9
1000:26bc  76 06            jbe loc_126c4
1000:26be  2c 0a            sub al, 0xa
1000:26c0  fe 06 ac 94      inc byte ptr [0x94ac]
                            loc_126c4:
1000:26c4  a2 ad 94         mov byte ptr [0x94ad], al
1000:26c7  a0 ac 94         mov al, byte ptr [0x94ac]
1000:26ca  02 46 08         add al, byte ptr [bp + 8]
1000:26cd  3c 09            cmp al, 9
1000:26cf  76 06            jbe loc_126d7
1000:26d1  2c 0a            sub al, 0xa
1000:26d3  fe 06 ab 94      inc byte ptr [0x94ab]
                            loc_126d7:
1000:26d7  a2 ac 94         mov byte ptr [0x94ac], al
1000:26da  a0 ab 94         mov al, byte ptr [0x94ab]
1000:26dd  02 46 0a         add al, byte ptr [bp + 0xa]
1000:26e0  3c 09            cmp al, 9
1000:26e2  76 06            jbe loc_126ea
1000:26e4  2c 0a            sub al, 0xa
1000:26e6  fe 06 aa 94      inc byte ptr [0x94aa]
                            loc_126ea:
1000:26ea  a2 ab 94         mov byte ptr [0x94ab], al
1000:26ed  a0 aa 94         mov al, byte ptr [0x94aa]
1000:26f0  3c 09            cmp al, 9
1000:26f2  76 0d            jbe loc_12701
1000:26f4  2c 0a            sub al, 0xa
1000:26f6  fe 06 a9 94      inc byte ptr [0x94a9]
1000:26fa  50               push ax
1000:26fb  56               push si
1000:26fc  e8 c2 fb         call 0x22c1
1000:26ff  5e               pop si
1000:2700  58               pop ax
                            loc_12701:
1000:2701  a2 aa 94         mov byte ptr [0x94aa], al
1000:2704  a0 a9 94         mov al, byte ptr [0x94a9]
1000:2707  3c 09            cmp al, 9
1000:2709  76 02            jbe loc_1270d
1000:270b  2c 0a            sub al, 0xa
                            loc_1270d:
1000:270d  a2 a9 94         mov byte ptr [0x94a9], al
1000:2710  5d               pop bp
1000:2711  c2 08 00         ret 8
                            sub_1269e ENDP
*/
void sub_1269e()
{
    // coverage: 0x289e-0x2914 method sub_1269e
    // coverage2: 1000:269e-1000:2714 method sub_1269e // ins(0x269e, 0x2714, 0x269e);
    push(bp);
    bp = sp;
    al = memoryAGet(ds, 0x94ae);
    al += memoryAGet(ss, bp + 4 - 2);
    if (al <= 0x09)
        goto loc_126b1;
    al -= 0x0a;
    memoryASet(ds, 0x94ad, memoryAGet(ds, 0x94ad) + 1);
loc_126b1:
    memoryASet(ds, 0x94ae, al);
    al = memoryAGet(ds, 0x94ad);
    al += memoryAGet(ss, bp + 6 - 2);
    if (al <= 0x09)
        goto loc_126c4;
    al -= 0x0a;
    memoryASet(ds, 0x94ac, memoryAGet(ds, 0x94ac) + 1);
loc_126c4:
    memoryASet(ds, 0x94ad, al);
    al = memoryAGet(ds, 0x94ac);
    al += memoryAGet(ss, bp + 8 - 2);
    if (al <= 0x09)
        goto loc_126d7;
    al -= 0x0a;
    memoryASet(ds, 0x94ab, memoryAGet(ds, 0x94ab) + 1);
loc_126d7:
    memoryASet(ds, 0x94ac, al);
    al = memoryAGet(ds, 0x94ab);
    al += memoryAGet(ss, bp + 10 - 2);
    if (al <= 0x09)
        goto loc_126ea;
    al -= 0x0a;
    memoryASet(ds, 0x94aa, memoryAGet(ds, 0x94aa) + 1);
loc_126ea:
    memoryASet(ds, 0x94ab, al);
    al = memoryAGet(ds, 0x94aa);
    if (al <= 0x09)
        goto loc_12701;
    al -= 0x0a;
    memoryASet(ds, 0x94a9, memoryAGet(ds, 0x94a9) + 1);
    push(ax);
    push(si);
    sub_122c1();
    si = pop();
    ax = pop();
loc_12701:
    memoryASet(ds, 0x94aa, al);
    al = memoryAGet(ds, 0x94a9);
    if (al <= 0x09)
        goto loc_1270d;
    al -= 0x0a;
loc_1270d:
    memoryASet(ds, 0x94a9, al);
    bp = pop();
    sp += 8;
}
/* Assembly listing of 1000:2714 sub_12714()
                            sub_12714 PROC
1000:2714  c6 06 4d 94 01   mov byte ptr [0x944d], 1
1000:2719  be a9 94         mov si, 0x94a9
1000:271c  b9 06 00         mov cx, 6
1000:271f  ba 00 00         mov dx, 0
                            loc_12722:
1000:2722  51               push cx
1000:2723  ac               lodsb al, byte ptr [si]
1000:2724  3c 00            cmp al, 0
1000:2726  74 05            je loc_1272d
1000:2728  c6 06 4d 94 00   mov byte ptr [0x944d], 0
                            loc_1272d:
1000:272d  8a 0e 4d 94      mov cl, byte ptr [0x944d]
1000:2731  80 f9 00         cmp cl, 0
1000:2734  75 28            jne loc_1275e
1000:2736  52               push dx
1000:2737  56               push si
1000:2738  b7 00            mov bh, 0
1000:273a  8a d8            mov bl, al
1000:273c  d1 e3            shl bx, 1
1000:273e  8b 87 5f 15      mov ax, word ptr [bx + 0x155f]
1000:2742  50               push ax
1000:2743  8b da            mov bx, dx
1000:2745  8b 87 73 15      mov ax, word ptr [bx + 0x1573]
1000:2749  50               push ax
1000:274a  b8 10 00         mov ax, 0x10
1000:274d  50               push ax
1000:274e  b8 09 00         mov ax, 9
1000:2751  50               push ax
1000:2752  b8 02 00         mov ax, 2
1000:2755  50               push ax
1000:2756  e8 91 05         call 0x2cea
1000:2759  5e               pop si
1000:275a  5a               pop dx
1000:275b  83 c2 02         add dx, 2
                            loc_1275e:
1000:275e  59               pop cx
1000:275f  e2 c1            loop loc_12722
1000:2761  c3               ret 
                            sub_12714 ENDP
*/
void sub_12714()
{
    // coverage: 0x2914-0x2962 method sub_12714
    // coverage2: 1000:2714-1000:2762 method sub_12714 // ins(0x2714, 0x2762, 0x2714);
    memoryASet(ds, 0x944d, 0x01);
    si = 0x94a9;
    cx = 0x0006;
    dx = 0x0000;
loc_12722:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_1272d;
    memoryASet(ds, 0x944d, 0x00);
loc_1272d:
    cl = memoryAGet(ds, 0x944d);
    if (cl != 0x00)
        goto loc_1275e;
    push(dx);
    push(si);
    bh = 0x00;
    bl = al;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5471);
    push(ax);
    bx = dx;
    ax = memoryAGet16(ds, bx + 5491);
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0009;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    si = pop();
    dx = pop();
    dx += 0x0002;
loc_1275e:
    cx = pop();
    if (--cx)
        goto loc_12722;
}
/* Assembly listing of 1000:2762 sub_12762()
                            sub_12762 PROC
1000:2762  b9 12 00         mov cx, 0x12
1000:2765  8c d8            mov ax, ds
1000:2767  8e c0            mov es, ax
1000:2769  bf af 94         mov di, 0x94af
1000:276c  fc               cld 
1000:276d  b8 00 00         mov ax, 0
1000:2770  f3 ab            rep stosw word ptr es:[di], ax
1000:2772  b9 2a 00         mov cx, 0x2a
1000:2775  bf 55 94         mov di, 0x9455
1000:2778  b0 2e            mov al, 0x2e
1000:277a  b4 2e            mov ah, 0x2e
1000:277c  f3 ab            rep stosw word ptr es:[di], ax
1000:277e  c6 06 55 94 5f   mov byte ptr [0x9455], 0x5f
1000:2783  b0 00            mov al, 0
1000:2785  b9 07 00         mov cx, 7
1000:2788  be da 94         mov si, 0x94da
                            loc_1278b:
1000:278b  88 04            mov byte ptr [si], al
1000:278d  fe c0            inc al
1000:278f  46               inc si
1000:2790  e2 f9            loop loc_1278b
1000:2792  bf 55 94         mov di, 0x9455
1000:2795  ba 06 15         mov dx, 0x1506
1000:2798  b9 8c 00         mov cx, 0x8c
1000:279b  e8 a6 de         call 0x644
1000:279e  c3               ret 
                            sub_12762 ENDP
*/
void sub_12762()
{
    // coverage: 0x2962-0x299f method sub_12762
    // coverage2: 1000:2762-1000:279f method sub_12762 // ins(0x2762, 0x279f, 0x2762);
    cx = 0x0012;
    ax = ds;
    es = ax;
    di = 0x94af;
    flags.direction = false;
    ax = 0x0000;
    rep_stosw<MemAuto, DirAuto>();
    cx = 0x002a;
    di = 0x9455;
    al = 0x2e;
    ah = 0x2e;
    rep_stosw<MemAuto, DirAuto>();
    memoryASet(ds, 0x9455, 0x5f);
    al = 0x00;
    cx = 0x0007;
    si = 0x94da;
loc_1278b:
    memoryASet(ds, si, al);
    al++;
    si++;
    if (--cx)
        goto loc_1278b;
    di = 0x9455;
    dx = 0x1506;
    cx = 0x008c;
    sub_10644();
}
/* Assembly listing of 1000:279f sub_1279f()
                            sub_1279f PROC
1000:279f  e8 67 00         call 0x2809
1000:27a2  a0 e0 94         mov al, byte ptr [0x94e0]
1000:27a5  3c 00            cmp al, 0
1000:27a7  75 06            jne loc_127af
1000:27a9  c6 06 46 95 00   mov byte ptr [0x9546], 0
1000:27ae  c3               ret 
                            loc_127af:
1000:27af  c6 06 46 95 01   mov byte ptr [0x9546], 1
1000:27b4  8a d8            mov bl, al
1000:27b6  d0 e3            shl bl, 1
1000:27b8  02 d8            add bl, al
1000:27ba  b7 00            mov bh, 0
1000:27bc  d1 e3            shl bx, 1
1000:27be  53               push bx
1000:27bf  81 c3 a9 94      add bx, 0x94a9
1000:27c3  be a9 94         mov si, 0x94a9
1000:27c6  b9 06 00         mov cx, 6
                            loc_127c9:
1000:27c9  ac               lodsb al, byte ptr [si]
1000:27ca  88 07            mov byte ptr [bx], al
1000:27cc  43               inc bx
1000:27cd  e2 fa            loop loc_127c9
1000:27cf  5b               pop bx
1000:27d0  d1 e3            shl bx, 1
1000:27d2  81 c3 55 94      add bx, 0x9455
1000:27d6  89 1e 51 94      mov word ptr [0x9451], bx
1000:27da  be 55 94         mov si, 0x9455
1000:27dd  b9 0c 00         mov cx, 0xc
                            loc_127e0:
1000:27e0  ac               lodsb al, byte ptr [si]
1000:27e1  88 07            mov byte ptr [bx], al
1000:27e3  43               inc bx
1000:27e4  e2 fa            loop loc_127e0
1000:27e6  be da 94         mov si, 0x94da
                            loc_127e9:
1000:27e9  8a 04            mov al, byte ptr [si]
1000:27eb  3c 00            cmp al, 0
1000:27ed  74 03            je loc_127f2
1000:27ef  46               inc si
1000:27f0  eb f7            jmp loc_127e9
                            loc_127f2:
1000:27f2  a0 e0 94         mov al, byte ptr [0x94e0]
1000:27f5  88 04            mov byte ptr [si], al
1000:27f7  c6 06 e0 94 00   mov byte ptr [0x94e0], 0
1000:27fc  81 ee da 94      sub si, 0x94da
1000:2800  8b c6            mov ax, si
1000:2802  a2 50 94         mov byte ptr [0x9450], al
1000:2805  e8 d2 00         call 0x28da
1000:2808  c3               ret 
                            sub_1279f ENDP
*/
void sub_1279f()
{
    // coverage: 0x299f-0x2a09 method sub_1279f
    // coverage2: 1000:279f-1000:2809 method sub_1279f // ins(0x279f, 0x2809, 0x279f);
    sub_12809();
    al = memoryAGet(ds, 0x94e0);
    if (al != 0x00)
        goto loc_127af;
    memoryASet(ds, 0x9546, 0x00);
    return;
loc_127af:
    memoryASet(ds, 0x9546, 0x01);
    bl = al;
    bl <<= 1;
    bl += al;
    bh = 0x00;
    bx <<= 1;
    push(bx);
    bx += 0x94a9;
    si = 0x94a9;
    cx = 0x0006;
loc_127c9:
    lodsb<MemAuto, DirAuto>();
    memoryASet(ds, bx, al);
    bx++;
    if (--cx)
        goto loc_127c9;
    bx = pop();
    bx <<= 1;
    bx += 0x9455;
    memoryASet16(ds, 0x9451, bx);
    si = 0x9455;
    cx = 0x000c;
loc_127e0:
    lodsb<MemAuto, DirAuto>();
    memoryASet(ds, bx, al);
    bx++;
    if (--cx)
        goto loc_127e0;
    si = 0x94da;
loc_127e9:
    al = memoryAGet(ds, si);
    if (al == 0x00)
        goto loc_127f2;
    si++;
    goto loc_127e9;
loc_127f2:
    al = memoryAGet(ds, 0x94e0);
    memoryASet(ds, si, al);
    memoryASet(ds, 0x94e0, 0x00);
    si -= 0x94da;
    ax = si;
    memoryASet(ds, 0x9450, al);
    sub_128da();
}
/* Assembly listing of 1000:2809 sub_12809()
                            sub_12809 PROC
1000:2809  a0 da 94         mov al, byte ptr [0x94da]
1000:280c  a2 d3 94         mov byte ptr [0x94d3], al
1000:280f  a0 db 94         mov al, byte ptr [0x94db]
1000:2812  a2 d4 94         mov byte ptr [0x94d4], al
1000:2815  a0 dc 94         mov al, byte ptr [0x94dc]
1000:2818  a2 d5 94         mov byte ptr [0x94d5], al
1000:281b  a0 dd 94         mov al, byte ptr [0x94dd]
1000:281e  a2 d6 94         mov byte ptr [0x94d6], al
1000:2821  a0 de 94         mov al, byte ptr [0x94de]
1000:2824  a2 d7 94         mov byte ptr [0x94d7], al
1000:2827  a0 df 94         mov al, byte ptr [0x94df]
1000:282a  a2 d8 94         mov byte ptr [0x94d8], al
1000:282d  a0 e0 94         mov al, byte ptr [0x94e0]
1000:2830  a2 d9 94         mov byte ptr [0x94d9], al
1000:2833  be d3 94         mov si, 0x94d3
1000:2836  bf da 94         mov di, 0x94da
1000:2839  b9 07 00         mov cx, 7
                            loc_1283c:
1000:283c  51               push cx
1000:283d  56               push si
                            loc_1283e:
1000:283e  8a 04            mov al, byte ptr [si]
1000:2840  3c ff            cmp al, 0xff
1000:2842  75 03            jne loc_12847
1000:2844  46               inc si
1000:2845  eb f7            jmp loc_1283e
                            loc_12847:
1000:2847  81 fe d9 94      cmp si, 0x94d9
1000:284b  74 18            je loc_12865
1000:284d  8b de            mov bx, si
                            loc_1284f:
1000:284f  43               inc bx
1000:2850  8a 07            mov al, byte ptr [bx]
1000:2852  3c ff            cmp al, 0xff
1000:2854  74 09            je loc_1285f
1000:2856  e8 19 00         call 0x2872
1000:2859  3c 00            cmp al, 0
1000:285b  74 02            je loc_1285f
1000:285d  8b f3            mov si, bx
                            loc_1285f:
1000:285f  81 fb d9 94      cmp bx, 0x94d9
1000:2863  75 ea            jne loc_1284f
                            loc_12865:
1000:2865  8a 04            mov al, byte ptr [si]
1000:2867  c6 04 ff         mov byte ptr [si], 0xff
1000:286a  88 05            mov byte ptr [di], al
1000:286c  47               inc di
1000:286d  5e               pop si
1000:286e  59               pop cx
1000:286f  e2 cb            loop loc_1283c
1000:2871  c3               ret 
                            sub_12809 ENDP
*/
void sub_12809()
{
    // coverage: 0x2a09-0x2a72 method sub_12809
    // coverage2: 1000:2809-1000:2872 method sub_12809 // ins(0x2809, 0x2872, 0x2809);
    al = memoryAGet(ds, 0x94da);
    memoryASet(ds, 0x94d3, al);
    al = memoryAGet(ds, 0x94db);
    memoryASet(ds, 0x94d4, al);
    al = memoryAGet(ds, 0x94dc);
    memoryASet(ds, 0x94d5, al);
    al = memoryAGet(ds, 0x94dd);
    memoryASet(ds, 0x94d6, al);
    al = memoryAGet(ds, 0x94de);
    memoryASet(ds, 0x94d7, al);
    al = memoryAGet(ds, 0x94df);
    memoryASet(ds, 0x94d8, al);
    al = memoryAGet(ds, 0x94e0);
    memoryASet(ds, 0x94d9, al);
    si = 0x94d3;
    di = 0x94da;
    cx = 0x0007;
loc_1283c:
    push(cx);
    push(si);
loc_1283e:
    al = memoryAGet(ds, si);
    if (al != 0xff)
        goto loc_12847;
    si++;
    goto loc_1283e;
loc_12847:
    if (si == 0x94d9)
        goto loc_12865;
    bx = si;
loc_1284f:
    bx++;
    al = memoryAGet(ds, bx);
    if (al == 0xff)
        goto loc_1285f;
    sub_12872();
    if (al == 0x00)
        goto loc_1285f;
    si = bx;
loc_1285f:
    if (bx != 0x94d9)
        goto loc_1284f;
loc_12865:
    al = memoryAGet(ds, si);
    memoryASet(ds, si, 0xff);
    memoryASet(ds, di, al);
    di++;
    si = pop();
    cx = pop();
    if (--cx)
        goto loc_1283c;
}
/* Assembly listing of 1000:2872 sub_12872()
                            sub_12872 PROC
1000:2872  56               push si
1000:2873  57               push di
1000:2874  8a 04            mov al, byte ptr [si]
1000:2876  8a e0            mov ah, al
1000:2878  d0 e0            shl al, 1
1000:287a  02 c4            add al, ah
1000:287c  d0 e0            shl al, 1
1000:287e  b4 00            mov ah, 0
1000:2880  05 a9 94         add ax, 0x94a9
1000:2883  8b f0            mov si, ax
1000:2885  8a 07            mov al, byte ptr [bx]
1000:2887  8a e0            mov ah, al
1000:2889  d0 e0            shl al, 1
1000:288b  02 c4            add al, ah
1000:288d  d0 e0            shl al, 1
1000:288f  b4 00            mov ah, 0
1000:2891  05 a9 94         add ax, 0x94a9
1000:2894  8b f8            mov di, ax
1000:2896  8a 05            mov al, byte ptr [di]
1000:2898  3a 04            cmp al, byte ptr [si]
1000:289a  77 39            ja loc_128d5
1000:289c  72 32            jb loc_128d0
1000:289e  8a 45 01         mov al, byte ptr [di + 1]
1000:28a1  3a 44 01         cmp al, byte ptr [si + 1]
1000:28a4  77 2f            ja loc_128d5
1000:28a6  72 28            jb loc_128d0
1000:28a8  8a 45 02         mov al, byte ptr [di + 2]
1000:28ab  3a 44 02         cmp al, byte ptr [si + 2]
1000:28ae  77 25            ja loc_128d5
1000:28b0  72 1e            jb loc_128d0
1000:28b2  8a 45 03         mov al, byte ptr [di + 3]
1000:28b5  3a 44 03         cmp al, byte ptr [si + 3]
1000:28b8  77 1b            ja loc_128d5
1000:28ba  72 14            jb loc_128d0
1000:28bc  8a 45 04         mov al, byte ptr [di + 4]
1000:28bf  3a 44 04         cmp al, byte ptr [si + 4]
1000:28c2  77 11            ja loc_128d5
1000:28c4  72 0a            jb loc_128d0
1000:28c6  8a 45 05         mov al, byte ptr [di + 5]
1000:28c9  3a 44 05         cmp al, byte ptr [si + 5]
1000:28cc  77 07            ja loc_128d5
1000:28ce  72 00            jb loc_128d0
                            loc_128d0:
1000:28d0  b0 00            mov al, 0
1000:28d2  5f               pop di
1000:28d3  5e               pop si
1000:28d4  c3               ret 
                            loc_128d5:
1000:28d5  b0 01            mov al, 1
1000:28d7  5f               pop di
1000:28d8  5e               pop si
1000:28d9  c3               ret 
                            sub_12872 ENDP
*/
void sub_12872()
{
    // coverage: 0x2a72-0x2ada method sub_12872
    // coverage2: 1000:2872-1000:28da method sub_12872 // ins(0x2872, 0x28da, 0x2872);
    push(si);
    push(di);
    al = memoryAGet(ds, si);
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
    ax += 0x94a9;
    si = ax;
    al = memoryAGet(ds, bx);
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
    ax += 0x94a9;
    di = ax;
    al = memoryAGet(ds, di);
    if (al > memoryAGet(ds, si))
        goto loc_128d5;
    if (al < memoryAGet(ds, si))
        goto loc_128d0;
    al = memoryAGet(ds, di + 1);
    if (al > memoryAGet(ds, si + 1))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 1))
        goto loc_128d0;
    al = memoryAGet(ds, di + 2);
    if (al > memoryAGet(ds, si + 2))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 2))
        goto loc_128d0;
    al = memoryAGet(ds, di + 3);
    if (al > memoryAGet(ds, si + 3))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 3))
        goto loc_128d0;
    al = memoryAGet(ds, di + 4);
    if (al > memoryAGet(ds, si + 4))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 4))
        goto loc_128d0;
    al = memoryAGet(ds, di + 5);
    if (al > memoryAGet(ds, si + 5))
        goto loc_128d5;
    if (al < memoryAGet(ds, si + 5))
        goto loc_128d0;
loc_128d0:
    al = 0x00;
    di = pop();
    si = pop();
    return;
loc_128d5:
    al = 0x01;
    di = pop();
    si = pop();
}
/* Assembly listing of 1000:28da sub_128da()
                            sub_128da PROC
1000:28da  be da 94         mov si, 0x94da
1000:28dd  bf b1 01         mov di, 0x1b1
1000:28e0  b9 06 00         mov cx, 6
                            loc_128e3:
1000:28e3  51               push cx
1000:28e4  83 c7 02         add di, 2
1000:28e7  8b 05            mov ax, word ptr [di]
1000:28e9  83 c7 02         add di, 2
1000:28ec  56               push si
1000:28ed  57               push di
1000:28ee  e8 68 00         call 0x2959
1000:28f1  5f               pop di
1000:28f2  5e               pop si
1000:28f3  83 c7 02         add di, 2
1000:28f6  8b 05            mov ax, word ptr [di]
1000:28f8  83 c7 02         add di, 2
1000:28fb  56               push si
1000:28fc  57               push di
1000:28fd  e8 07 00         call 0x2907
1000:2900  5f               pop di
1000:2901  5e               pop si
1000:2902  46               inc si
1000:2903  59               pop cx
1000:2904  e2 dd            loop loc_128e3
1000:2906  c3               ret 
                            sub_128da ENDP
*/
void sub_128da()
{
    // coverage: 0x2ada-0x2b07 method sub_128da
    // coverage2: 1000:28da-1000:2907 method sub_128da // ins(0x28da, 0x2907, 0x28da);
    si = 0x94da;
    di = 0x01b1;
    cx = 0x0006;
loc_128e3:
    push(cx);
    di += 0x0002;
    ax = memoryAGet16(ds, di);
    di += 0x0002;
    push(si);
    push(di);
    sub_12959();
    di = pop();
    si = pop();
    di += 0x0002;
    ax = memoryAGet16(ds, di);
    di += 0x0002;
    push(si);
    push(di);
    sub_12907();
    di = pop();
    si = pop();
    si++;
    cx = pop();
    if (--cx)
        goto loc_128e3;
}
/* Assembly listing of 1000:2907 sub_12907()
                            sub_12907 PROC
1000:2907  a3 4e 94         mov word ptr [0x944e], ax
1000:290a  8a 04            mov al, byte ptr [si]
1000:290c  8a e0            mov ah, al
1000:290e  d0 e0            shl al, 1
1000:2910  02 c4            add al, ah
1000:2912  b4 00            mov ah, 0
1000:2914  d1 e0            shl ax, 1
1000:2916  05 a9 94         add ax, 0x94a9
1000:2919  8b f0            mov si, ax
1000:291b  c6 06 4d 94 01   mov byte ptr [0x944d], 1
1000:2920  b9 06 00         mov cx, 6
1000:2923  ba 00 00         mov dx, 0
                            loc_12926:
1000:2926  51               push cx
1000:2927  ac               lodsb al, byte ptr [si]
1000:2928  3c 00            cmp al, 0
1000:292a  74 05            je loc_12931
1000:292c  c6 06 4d 94 00   mov byte ptr [0x944d], 0
                            loc_12931:
1000:2931  8a 0e 4d 94      mov cl, byte ptr [0x944d]
1000:2935  80 f9 00         cmp cl, 0
1000:2938  74 05            je loc_1293f
1000:293a  b8 6c 6f         mov ax, 0x6f6c
1000:293d  eb 0a            jmp loc_12949
                            loc_1293f:
1000:293f  b7 00            mov bh, 0
1000:2941  8a d8            mov bl, al
1000:2943  d1 e3            shl bx, 1
1000:2945  8b 87 7f 15      mov ax, word ptr [bx + 0x157f]
                            loc_12949:
1000:2949  52               push dx
1000:294a  56               push si
1000:294b  50               push ax
1000:294c  52               push dx
1000:294d  e8 5e 00         call 0x29ae
1000:2950  5e               pop si
1000:2951  5a               pop dx
1000:2952  83 c2 06         add dx, 6
1000:2955  59               pop cx
1000:2956  e2 ce            loop loc_12926
1000:2958  c3               ret 
                            sub_12907 ENDP
*/
void sub_12907()
{
    // coverage: 0x2b07-0x2b59 method sub_12907
    // coverage2: 1000:2907-1000:2959 method sub_12907 // ins(0x2907, 0x2959, 0x2907);
    memoryASet16(ds, 0x944e, ax);
    al = memoryAGet(ds, si);
    ah = al;
    al <<= 1;
    al += ah;
    ah = 0x00;
    ax <<= 1;
    ax += 0x94a9;
    si = ax;
    memoryASet(ds, 0x944d, 0x01);
    cx = 0x0006;
    dx = 0x0000;
loc_12926:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    if (al == 0x00)
        goto loc_12931;
    memoryASet(ds, 0x944d, 0x00);
loc_12931:
    cl = memoryAGet(ds, 0x944d);
    if (cl == 0x00)
        goto loc_1293f;
    ax = 0x6f6c;
    goto loc_12949;
loc_1293f:
    bh = 0x00;
    bl = al;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5503);
loc_12949:
    push(dx);
    push(si);
    push(ax);
    push(dx);
    sub_129ae();
    si = pop();
    dx = pop();
    dx += 0x0006;
    cx = pop();
    if (--cx)
        goto loc_12926;
}
/* Assembly listing of 1000:2959 sub_12959()
                            sub_12959 PROC
1000:2959  a3 4e 94         mov word ptr [0x944e], ax
1000:295c  8a 04            mov al, byte ptr [si]
1000:295e  8a e0            mov ah, al
1000:2960  d0 e0            shl al, 1
1000:2962  02 c4            add al, ah
1000:2964  b4 00            mov ah, 0
1000:2966  d1 e0            shl ax, 1
1000:2968  d1 e0            shl ax, 1
1000:296a  05 55 94         add ax, 0x9455
1000:296d  8b f0            mov si, ax
1000:296f  b9 0c 00         mov cx, 0xc
1000:2972  ba 00 00         mov dx, 0
                            loc_12975:
1000:2975  51               push cx
1000:2976  ac               lodsb al, byte ptr [si]
1000:2977  56               push si
1000:2978  52               push dx
1000:2979  3c 20            cmp al, 0x20
1000:297b  75 05            jne loc_12982
1000:297d  b8 46 65         mov ax, 0x6546
1000:2980  eb 1e            jmp loc_129a0
                            loc_12982:
1000:2982  3c 2e            cmp al, 0x2e
1000:2984  75 05            jne loc_1298b
1000:2986  b8 6c 6f         mov ax, 0x6f6c
1000:2989  eb 15            jmp loc_129a0
                            loc_1298b:
1000:298b  3c 5f            cmp al, 0x5f
1000:298d  75 05            jne loc_12994
1000:298f  b8 4c 76         mov ax, 0x764c
1000:2992  eb 0c            jmp loc_129a0
                            loc_12994:
1000:2994  2c 41            sub al, 0x41
1000:2996  8a e0            mov ah, al
1000:2998  d0 e0            shl al, 1
1000:299a  02 c4            add al, ah
1000:299c  d0 e0            shl al, 1
1000:299e  b4 00            mov ah, 0
                            loc_129a0:
1000:29a0  50               push ax
1000:29a1  52               push dx
1000:29a2  e8 09 00         call 0x29ae
1000:29a5  5a               pop dx
1000:29a6  83 c2 06         add dx, 6
1000:29a9  5e               pop si
1000:29aa  59               pop cx
1000:29ab  e2 c8            loop loc_12975
1000:29ad  c3               ret 
                            sub_12959 ENDP
*/
void sub_12959()
{
    // coverage: 0x2b59-0x2bae method sub_12959
    // coverage2: 1000:2959-1000:29ae method sub_12959 // ins(0x2959, 0x29ae, 0x2959);
    memoryASet16(ds, 0x944e, ax);
    al = memoryAGet(ds, si);
    ah = al;
    al <<= 1;
    al += ah;
    ah = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax += 0x9455;
    si = ax;
    cx = 0x000c;
    dx = 0x0000;
loc_12975:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    push(si);
    push(dx);
    if (al != 0x20)
        goto loc_12982;
    ax = 0x6546;
    goto loc_129a0;
loc_12982:
    if (al != 0x2e)
        goto loc_1298b;
    ax = 0x6f6c;
    goto loc_129a0;
loc_1298b:
    if (al != 0x5f)
        goto loc_12994;
    ax = 0x764c;
    goto loc_129a0;
loc_12994:
    al -= 0x41;
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
loc_129a0:
    push(ax);
    push(dx);
    sub_129ae();
    dx = pop();
    dx += 0x0006;
    si = pop();
    cx = pop();
    if (--cx)
        goto loc_12975;
}
/* Assembly listing of 1000:296f sub_1296f()
                            sub_1296f PROC
1000:296f  b9 0c 00         mov cx, 0xc
1000:2972  ba 00 00         mov dx, 0
                            loc_12975:
1000:2975  51               push cx
1000:2976  ac               lodsb al, byte ptr [si]
1000:2977  56               push si
1000:2978  52               push dx
1000:2979  3c 20            cmp al, 0x20
1000:297b  75 05            jne loc_12982
1000:297d  b8 46 65         mov ax, 0x6546
1000:2980  eb 1e            jmp loc_129a0
                            loc_12982:
1000:2982  3c 2e            cmp al, 0x2e
1000:2984  75 05            jne loc_1298b
1000:2986  b8 6c 6f         mov ax, 0x6f6c
1000:2989  eb 15            jmp loc_129a0
                            loc_1298b:
1000:298b  3c 5f            cmp al, 0x5f
1000:298d  75 05            jne loc_12994
1000:298f  b8 4c 76         mov ax, 0x764c
1000:2992  eb 0c            jmp loc_129a0
                            loc_12994:
1000:2994  2c 41            sub al, 0x41
1000:2996  8a e0            mov ah, al
1000:2998  d0 e0            shl al, 1
1000:299a  02 c4            add al, ah
1000:299c  d0 e0            shl al, 1
1000:299e  b4 00            mov ah, 0
                            loc_129a0:
1000:29a0  50               push ax
1000:29a1  52               push dx
1000:29a2  e8 09 00         call 0x29ae
1000:29a5  5a               pop dx
1000:29a6  83 c2 06         add dx, 6
1000:29a9  5e               pop si
1000:29aa  59               pop cx
1000:29ab  e2 c8            loop loc_12975
1000:29ad  c3               ret 
                            sub_1296f ENDP
*/
void sub_1296f()
{
    // coverage: 0x2b6f-0x2bae method sub_1296f
    // coverage2: 1000:296f-1000:29ae method sub_1296f // ins(0x296f, 0x29ae, 0x296f);
    cx = 0x000c;
    dx = 0x0000;
loc_12975:
    push(cx);
    lodsb<MemAuto, DirAuto>();
    push(si);
    push(dx);
    if (al != 0x20)
        goto loc_12982;
    ax = 0x6546;
    goto loc_129a0;
loc_12982:
    if (al != 0x2e)
        goto loc_1298b;
    ax = 0x6f6c;
    goto loc_129a0;
loc_1298b:
    if (al != 0x5f)
        goto loc_12994;
    ax = 0x764c;
    goto loc_129a0;
loc_12994:
    al -= 0x41;
    ah = al;
    al <<= 1;
    al += ah;
    al <<= 1;
    ah = 0x00;
loc_129a0:
    push(ax);
    push(dx);
    sub_129ae();
    dx = pop();
    dx += 0x0006;
    si = pop();
    cx = pop();
    if (--cx)
        goto loc_12975;
}
/* Assembly listing of 1000:29ae sub_129ae()
                            sub_129ae PROC
1000:29ae  55               push bp
1000:29af  8b ec            mov bp, sp
1000:29b1  a1 f0 94         mov ax, word ptr [0x94f0]
1000:29b4  8e c0            mov es, ax
1000:29b6  8b 3e 4e 94      mov di, word ptr [0x944e]
1000:29ba  03 7e 04         add di, word ptr [bp + 4]
1000:29bd  a1 ea 94         mov ax, word ptr [0x94ea]
1000:29c0  1e               push ds
1000:29c1  8e d8            mov ds, ax
1000:29c3  8b 76 06         mov si, word ptr [bp + 6]
1000:29c6  b9 0b 00         mov cx, 0xb
                            loc_129c9:
1000:29c9  a5               movsw word ptr es:[di], word ptr [si]
1000:29ca  a5               movsw word ptr es:[di], word ptr [si]
1000:29cb  a5               movsw word ptr es:[di], word ptr [si]
1000:29cc  81 c7 9a 00      add di, 0x9a
1000:29d0  81 c6 9a 00      add si, 0x9a
1000:29d4  e2 f3            loop loc_129c9
1000:29d6  1f               pop ds
1000:29d7  5d               pop bp
1000:29d8  c2 04 00         ret 4
                            sub_129ae ENDP
*/
void sub_129ae()
{
    // coverage: 0x2bae-0x2bdb method sub_129ae
    // coverage2: 1000:29ae-1000:29db method sub_129ae // ins(0x29ae, 0x29db, 0x29ae);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ds, 0x94f0);
    es = ax;
    di = memoryAGet16(ds, 0x944e);
    di += memoryAGet16(ss, bp + 4 - 2);
    ax = memoryAGet16(ds, 0x94ea);
    push(ds);
    ds = ax;
    si = memoryAGet16(ss, bp + 6 - 2);
    cx = 0x000b;
loc_129c9:
    movsw<MemAuto, MemAuto, DirAuto>();
    movsw<MemAuto, MemAuto, DirAuto>();
    movsw<MemAuto, MemAuto, DirAuto>();
    di += 0x009a;
    si += 0x009a;
    if (--cx)
        goto loc_129c9;
    ds = pop();
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:29db sub_129db()
                            sub_129db PROC
1000:29db  c7 06 53 94 00 00  mov word ptr [0x9453], 0
                            loc_129e1:
1000:29e1  a1 53 94         mov ax, word ptr [0x9453]
1000:29e4  3d 0c 00         cmp ax, 0xc
1000:29e7  73 50            jae loc_12a39
1000:29e9  e8 55 db         call 0x541
1000:29ec  3c 00            cmp al, 0
1000:29ee  74 49            je loc_12a39
1000:29f0  3c 08            cmp al, 8
1000:29f2  75 19            jne loc_12a0d
1000:29f4  8b 1e 51 94      mov bx, word ptr [0x9451]
1000:29f8  03 1e 53 94      add bx, word ptr [0x9453]
1000:29fc  c6 07 2e         mov byte ptr [bx], 0x2e
1000:29ff  ff 0e 53 94      dec word ptr [0x9453]
1000:2a03  79 06            jns loc_12a0b
1000:2a05  c7 06 53 94 00 00  mov word ptr [0x9453], 0
                            loc_12a0b:
1000:2a0b  eb 0e            jmp loc_12a1b
                            loc_12a0d:
1000:2a0d  8b 1e 51 94      mov bx, word ptr [0x9451]
1000:2a11  03 1e 53 94      add bx, word ptr [0x9453]
1000:2a15  88 07            mov byte ptr [bx], al
1000:2a17  ff 06 53 94      inc word ptr [0x9453]
                            loc_12a1b:
1000:2a1b  8b 1e 53 94      mov bx, word ptr [0x9453]
1000:2a1f  83 fb 0c         cmp bx, 0xc
1000:2a22  73 07            jae loc_12a2b
1000:2a24  03 1e 51 94      add bx, word ptr [0x9451]
1000:2a28  c6 07 5f         mov byte ptr [bx], 0x5f
                            loc_12a2b:
1000:2a2b  e8 36 00         call 0x2a64
1000:2a2e  e8 67 0a         call 0x3498
1000:2a31  e8 5a e1         call 0xb8e
1000:2a34  e8 4c 09         call 0x3383
1000:2a37  eb a8            jmp loc_129e1
                            loc_12a39:
1000:2a39  8b 1e 53 94      mov bx, word ptr [0x9453]
1000:2a3d  83 fb 0c         cmp bx, 0xc
1000:2a40  73 10            jae loc_12a52
1000:2a42  03 1e 51 94      add bx, word ptr [0x9451]
1000:2a46  8a 07            mov al, byte ptr [bx]
1000:2a48  3c 5f            cmp al, 0x5f
1000:2a4a  75 06            jne loc_12a52
1000:2a4c  c6 07 2e         mov byte ptr [bx], 0x2e
1000:2a4f  e8 12 00         call 0x2a64
                            loc_12a52:
1000:2a52  bf 55 94         mov di, 0x9455
1000:2a55  ba 06 15         mov dx, 0x1506
1000:2a58  b9 8c 00         mov cx, 0x8c
1000:2a5b  e8 16 dc         call 0x674
1000:2a5e  c6 06 46 95 00   mov byte ptr [0x9546], 0
1000:2a63  c3               ret 
                            sub_129db ENDP
*/
void sub_129db()
{
    // coverage: 0x2bdb-0x2c64 method sub_129db
    // coverage2: 1000:29db-1000:2a64 method sub_129db // ins(0x29db, 0x2a64, 0x29db);
    memoryASet16(ds, 0x9453, 0x0000);
loc_129e1:
    ax = memoryAGet16(ds, 0x9453);
    if (ax >= 0x000c)
        goto loc_12a39;
    sub_10541();
    if (al == 0x00)
        goto loc_12a39;
    if (al != 0x08)
        goto loc_12a0d;
    bx = memoryAGet16(ds, 0x9451);
    bx += memoryAGet16(ds, 0x9453);
    memoryASet(ds, bx, 0x2e);
    memoryASet16(ds, 0x9453, memoryAGet16(ds, 0x9453) - 1);
    if ((short)memoryAGet16(ds, 0x9453) >= 0)
        goto loc_12a0b;
    memoryASet16(ds, 0x9453, 0x0000);
loc_12a0b:
    goto loc_12a1b;
loc_12a0d:
    bx = memoryAGet16(ds, 0x9451);
    bx += memoryAGet16(ds, 0x9453);
    memoryASet(ds, bx, al);
    memoryASet16(ds, 0x9453, memoryAGet16(ds, 0x9453) + 1);
loc_12a1b:
    bx = memoryAGet16(ds, 0x9453);
    if (bx >= 0x000c)
        goto loc_12a2b;
    bx += memoryAGet16(ds, 0x9451);
    memoryASet(ds, bx, 0x5f);
loc_12a2b:
    sub_12a64();
    sub_13498();
    sub_10b8e();
    sub_13383();
    goto loc_129e1;
loc_12a39:
    bx = memoryAGet16(ds, 0x9453);
    if (bx >= 0x000c)
        goto loc_12a52;
    bx += memoryAGet16(ds, 0x9451);
    al = memoryAGet(ds, bx);
    if (al != 0x5f)
        goto loc_12a52;
    memoryASet(ds, bx, 0x2e);
    sub_12a64();
loc_12a52:
    di = 0x9455;
    dx = 0x1506;
    cx = 0x008c;
    sub_10674();
    memoryASet(ds, 0x9546, 0x00);
}
/* Assembly listing of 1000:2a64 sub_12a64()
                            sub_12a64 PROC
1000:2a64  8b 36 51 94      mov si, word ptr [0x9451]
1000:2a68  8a 1e 50 94      mov bl, byte ptr [0x9450]
1000:2a6c  b7 00            mov bh, 0
1000:2a6e  d1 e3            shl bx, 1
1000:2a70  d1 e3            shl bx, 1
1000:2a72  d1 e3            shl bx, 1
1000:2a74  8b 87 b3 01      mov ax, word ptr [bx + 0x1b3]
1000:2a78  a3 4e 94         mov word ptr [0x944e], ax
1000:2a7b  e8 f1 fe         call 0x296f
1000:2a7e  c3               ret 
                            sub_12a64 ENDP
*/
void sub_12a64()
{
    // coverage: 0x2c64-0x2c7f method sub_12a64
    // coverage2: 1000:2a64-1000:2a7f method sub_12a64 // ins(0x2a64, 0x2a7f, 0x2a64);
    si = memoryAGet16(ds, 0x9451);
    bl = memoryAGet(ds, 0x9450);
    bh = 0x00;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 435);
    memoryASet16(ds, 0x944e, ax);
    sub_1296f();
}
/* Assembly listing of 1000:2a7f sub_12a7f()
                            sub_12a7f PROC
1000:2a7f  c6 06 2e 95 00   mov byte ptr [0x952e], 0
1000:2a84  c6 06 2f 95 00   mov byte ptr [0x952f], 0
1000:2a89  c6 06 30 95 00   mov byte ptr [0x9530], 0
1000:2a8e  c6 06 31 95 00   mov byte ptr [0x9531], 0
1000:2a93  c6 06 32 95 00   mov byte ptr [0x9532], 0
1000:2a98  c6 06 33 95 00   mov byte ptr [0x9533], 0
1000:2a9d  b8 78 11         mov ax, 0x1178
1000:2aa0  50               push ax
1000:2aa1  b8 82 1b         mov ax, 0x1b82
1000:2aa4  50               push ax
1000:2aa5  b8 10 00         mov ax, 0x10
1000:2aa8  50               push ax
1000:2aa9  b8 08 00         mov ax, 8
1000:2aac  50               push ax
1000:2aad  b8 04 00         mov ax, 4
1000:2ab0  50               push ax
1000:2ab1  e8 36 02         call 0x2cea
1000:2ab4  b8 78 16         mov ax, 0x1678
1000:2ab7  50               push ax
1000:2ab8  b8 c2 1c         mov ax, 0x1cc2
1000:2abb  50               push ax
1000:2abc  b8 10 00         mov ax, 0x10
1000:2abf  50               push ax
1000:2ac0  b8 08 00         mov ax, 8
1000:2ac3  50               push ax
1000:2ac4  b8 04 00         mov ax, 4
1000:2ac7  50               push ax
1000:2ac8  e8 1f 02         call 0x2cea
1000:2acb  b8 78 1b         mov ax, 0x1b78
1000:2ace  50               push ax
1000:2acf  b8 02 1e         mov ax, 0x1e02
1000:2ad2  50               push ax
1000:2ad3  b8 10 00         mov ax, 0x10
1000:2ad6  50               push ax
1000:2ad7  b8 08 00         mov ax, 8
1000:2ada  50               push ax
1000:2adb  b8 04 00         mov ax, 4
1000:2ade  50               push ax
1000:2adf  e8 08 02         call 0x2cea
1000:2ae2  b8 78 20         mov ax, 0x2078
1000:2ae5  50               push ax
1000:2ae6  b8 85 1b         mov ax, 0x1b85
1000:2ae9  50               push ax
1000:2aea  b8 10 00         mov ax, 0x10
1000:2aed  50               push ax
1000:2aee  b8 08 00         mov ax, 8
1000:2af1  50               push ax
1000:2af2  b8 04 00         mov ax, 4
1000:2af5  50               push ax
1000:2af6  e8 f1 01         call 0x2cea
1000:2af9  b8 78 25         mov ax, 0x2578
1000:2afc  50               push ax
1000:2afd  b8 c5 1c         mov ax, 0x1cc5
1000:2b00  50               push ax
1000:2b01  b8 10 00         mov ax, 0x10
1000:2b04  50               push ax
1000:2b05  b8 08 00         mov ax, 8
1000:2b08  50               push ax
1000:2b09  b8 04 00         mov ax, 4
1000:2b0c  50               push ax
1000:2b0d  e8 da 01         call 0x2cea
1000:2b10  b8 78 2a         mov ax, 0x2a78
1000:2b13  50               push ax
1000:2b14  b8 05 1e         mov ax, 0x1e05
1000:2b17  50               push ax
1000:2b18  b8 10 00         mov ax, 0x10
1000:2b1b  50               push ax
1000:2b1c  b8 08 00         mov ax, 8
1000:2b1f  50               push ax
1000:2b20  b8 04 00         mov ax, 4
1000:2b23  50               push ax
1000:2b24  e8 c3 01         call 0x2cea
1000:2b27  c3               ret 
                            sub_12a7f ENDP
*/
void sub_12a7f()
{
    // coverage: 0x2c7f-0x2d28 method sub_12a7f
    // coverage2: 1000:2a7f-1000:2b28 method sub_12a7f // ins(0x2a7f, 0x2b28, 0x2a7f);
    memoryASet(ds, 0x952e, 0x00);
    memoryASet(ds, 0x952f, 0x00);
    memoryASet(ds, 0x9530, 0x00);
    memoryASet(ds, 0x9531, 0x00);
    memoryASet(ds, 0x9532, 0x00);
    memoryASet(ds, 0x9533, 0x00);
    ax = 0x1178;
    push(ax);
    ax = 0x1b82;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x1678;
    push(ax);
    ax = 0x1cc2;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x1b78;
    push(ax);
    ax = 0x1e02;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x2078;
    push(ax);
    ax = 0x1b85;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x2578;
    push(ax);
    ax = 0x1cc5;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    ax = 0x2a78;
    push(ax);
    ax = 0x1e05;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2b28 sub_12b28()
                            sub_12b28 PROC
1000:2b28  50               push ax
1000:2b29  b8 00 00         mov ax, 0
1000:2b2c  50               push ax
1000:2b2d  b8 01 00         mov ax, 1
1000:2b30  50               push ax
1000:2b31  b8 05 00         mov ax, 5
1000:2b34  50               push ax
1000:2b35  b8 00 00         mov ax, 0
1000:2b38  50               push ax
1000:2b39  e8 62 fb         call 0x269e
1000:2b3c  58               pop ax
1000:2b3d  3c 00            cmp al, 0
1000:2b3f  74 18            je loc_12b59
1000:2b41  3c 01            cmp al, 1
1000:2b43  74 31            je loc_12b76
1000:2b45  3c 02            cmp al, 2
1000:2b47  74 4a            je loc_12b93
1000:2b49  3c 03            cmp al, 3
1000:2b4b  74 63            je loc_12bb0
1000:2b4d  3c 04            cmp al, 4
1000:2b4f  74 7c            je loc_12bcd
1000:2b51  3c 05            cmp al, 5
1000:2b53  75 03            jne loc_12b58
1000:2b55  e9 92 00         jmp loc_12bea
                            loc_12b58:
1000:2b58  c3               ret 
                            loc_12b59:
1000:2b59  c6 06 2e 95 01   mov byte ptr [0x952e], 1
1000:2b5e  b8 78 2f         mov ax, 0x2f78
1000:2b61  50               push ax
1000:2b62  b8 82 1b         mov ax, 0x1b82
1000:2b65  50               push ax
1000:2b66  b8 10 00         mov ax, 0x10
1000:2b69  50               push ax
1000:2b6a  b8 08 00         mov ax, 8
1000:2b6d  50               push ax
1000:2b6e  b8 04 00         mov ax, 4
1000:2b71  50               push ax
1000:2b72  e8 75 01         call 0x2cea
1000:2b75  c3               ret 
                            loc_12b76:
1000:2b76  c6 06 2f 95 01   mov byte ptr [0x952f], 1
1000:2b7b  b8 78 2f         mov ax, 0x2f78
1000:2b7e  50               push ax
1000:2b7f  b8 c2 1c         mov ax, 0x1cc2
1000:2b82  50               push ax
1000:2b83  b8 10 00         mov ax, 0x10
1000:2b86  50               push ax
1000:2b87  b8 08 00         mov ax, 8
1000:2b8a  50               push ax
1000:2b8b  b8 04 00         mov ax, 4
1000:2b8e  50               push ax
1000:2b8f  e8 58 01         call 0x2cea
1000:2b92  c3               ret 
                            loc_12b93:
1000:2b93  c6 06 30 95 01   mov byte ptr [0x9530], 1
1000:2b98  b8 78 2f         mov ax, 0x2f78
1000:2b9b  50               push ax
1000:2b9c  b8 02 1e         mov ax, 0x1e02
1000:2b9f  50               push ax
1000:2ba0  b8 10 00         mov ax, 0x10
1000:2ba3  50               push ax
1000:2ba4  b8 08 00         mov ax, 8
1000:2ba7  50               push ax
1000:2ba8  b8 04 00         mov ax, 4
1000:2bab  50               push ax
1000:2bac  e8 3b 01         call 0x2cea
1000:2baf  c3               ret 
                            loc_12bb0:
1000:2bb0  c6 06 31 95 01   mov byte ptr [0x9531], 1
1000:2bb5  b8 78 2f         mov ax, 0x2f78
1000:2bb8  50               push ax
1000:2bb9  b8 85 1b         mov ax, 0x1b85
1000:2bbc  50               push ax
1000:2bbd  b8 10 00         mov ax, 0x10
1000:2bc0  50               push ax
1000:2bc1  b8 08 00         mov ax, 8
1000:2bc4  50               push ax
1000:2bc5  b8 04 00         mov ax, 4
1000:2bc8  50               push ax
1000:2bc9  e8 1e 01         call 0x2cea
1000:2bcc  c3               ret 
                            loc_12bcd:
1000:2bcd  c6 06 32 95 01   mov byte ptr [0x9532], 1
1000:2bd2  b8 78 2f         mov ax, 0x2f78
1000:2bd5  50               push ax
1000:2bd6  b8 c5 1c         mov ax, 0x1cc5
1000:2bd9  50               push ax
1000:2bda  b8 10 00         mov ax, 0x10
1000:2bdd  50               push ax
1000:2bde  b8 08 00         mov ax, 8
1000:2be1  50               push ax
1000:2be2  b8 04 00         mov ax, 4
1000:2be5  50               push ax
1000:2be6  e8 01 01         call 0x2cea
1000:2be9  c3               ret 
                            loc_12bea:
1000:2bea  c6 06 33 95 01   mov byte ptr [0x9533], 1
1000:2bef  b8 78 2f         mov ax, 0x2f78
1000:2bf2  50               push ax
1000:2bf3  b8 05 1e         mov ax, 0x1e05
1000:2bf6  50               push ax
1000:2bf7  b8 10 00         mov ax, 0x10
1000:2bfa  50               push ax
1000:2bfb  b8 08 00         mov ax, 8
1000:2bfe  50               push ax
1000:2bff  b8 04 00         mov ax, 4
1000:2c02  50               push ax
1000:2c03  e8 e4 00         call 0x2cea
1000:2c06  c3               ret 
                            sub_12b28 ENDP
*/
void sub_12b28()
{
    // coverage: 0x2d28-0x2e07 method sub_12b28
    // coverage2: 1000:2b28-1000:2c07 method sub_12b28 // ins(0x2b28, 0x2c07, 0x2b28);
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0001;
    push(ax);
    ax = 0x0005;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_1269e();
    ax = pop();
    if (al == 0x00)
        goto loc_12b59;
    if (al == 0x01)
        goto loc_12b76;
    if (al == 0x02)
        goto loc_12b93;
    if (al == 0x03)
        goto loc_12bb0;
    if (al == 0x04)
        goto loc_12bcd;
    if (al != 0x05)
        goto loc_12b58;
    goto loc_12bea;
loc_12b58:
    return;
loc_12b59:
    memoryASet(ds, 0x952e, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1b82;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12b76:
    memoryASet(ds, 0x952f, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1cc2;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12b93:
    memoryASet(ds, 0x9530, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1e02;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12bb0:
    memoryASet(ds, 0x9531, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1b85;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12bcd:
    memoryASet(ds, 0x9532, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1cc5;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
    return;
loc_12bea:
    memoryASet(ds, 0x9533, 0x01);
    ax = 0x2f78;
    push(ax);
    ax = 0x1e05;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0008;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2c07 sub_12c07()
                            sub_12c07 PROC
1000:2c07  b8 0b 0a         mov ax, 0xa0b
1000:2c0a  50               push ax
1000:2c0b  b8 13 00         mov ax, 0x13
1000:2c0e  50               push ax
1000:2c0f  b8 30 00         mov ax, 0x30
1000:2c12  50               push ax
1000:2c13  b8 05 00         mov ax, 5
1000:2c16  50               push ax
1000:2c17  e8 80 01         call 0x2d9a
1000:2c1a  b8 ac 0a         mov ax, 0xaac
1000:2c1d  50               push ax
1000:2c1e  b8 11 00         mov ax, 0x11
1000:2c21  50               push ax
1000:2c22  b8 28 00         mov ax, 0x28
1000:2c25  50               push ax
1000:2c26  b8 02 00         mov ax, 2
1000:2c29  50               push ax
1000:2c2a  e8 6d 01         call 0x2d9a
1000:2c2d  b8 5c 5a         mov ax, 0x5a5c
1000:2c30  50               push ax
1000:2c31  b8 4d 0b         mov ax, 0xb4d
1000:2c34  50               push ax
1000:2c35  b8 78 00         mov ax, 0x78
1000:2c38  50               push ax
1000:2c39  b8 0f 00         mov ax, 0xf
1000:2c3c  50               push ax
1000:2c3d  b8 04 00         mov ax, 4
1000:2c40  50               push ax
1000:2c41  e8 a6 00         call 0x2cea
1000:2c44  c3               ret 
                            sub_12c07 ENDP
*/
void sub_12c07()
{
    // coverage: 0x2e07-0x2e45 method sub_12c07
    // coverage2: 1000:2c07-1000:2c45 method sub_12c07 // ins(0x2c07, 0x2c45, 0x2c07);
    ax = 0x0a0b;
    push(ax);
    ax = 0x0013;
    push(ax);
    ax = 0x0030;
    push(ax);
    ax = 0x0005;
    push(ax);
    sub_12d9a();
    ax = 0x0aac;
    push(ax);
    ax = 0x0011;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12d9a();
    ax = 0x5a5c;
    push(ax);
    ax = 0x0b4d;
    push(ax);
    ax = 0x0078;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2c45 sub_12c45()
                            sub_12c45 PROC
1000:2c45  b8 ac 0a         mov ax, 0xaac
1000:2c48  50               push ax
1000:2c49  b8 10 00         mov ax, 0x10
1000:2c4c  50               push ax
1000:2c4d  b8 28 00         mov ax, 0x28
1000:2c50  50               push ax
1000:2c51  b8 05 00         mov ax, 5
1000:2c54  50               push ax
1000:2c55  e8 42 01         call 0x2d9a
1000:2c58  b8 4d 0b         mov ax, 0xb4d
1000:2c5b  50               push ax
1000:2c5c  b8 0e 00         mov ax, 0xe
1000:2c5f  50               push ax
1000:2c60  b8 20 00         mov ax, 0x20
1000:2c63  50               push ax
1000:2c64  b8 02 00         mov ax, 2
1000:2c67  50               push ax
1000:2c68  e8 2f 01         call 0x2d9a
1000:2c6b  b8 92 75         mov ax, 0x7592
1000:2c6e  50               push ax
1000:2c6f  b8 8f 0c         mov ax, 0xc8f
1000:2c72  50               push ax
1000:2c73  b8 28 00         mov ax, 0x28
1000:2c76  50               push ax
1000:2c77  b8 0c 00         mov ax, 0xc
1000:2c7a  50               push ax
1000:2c7b  b8 02 00         mov ax, 2
1000:2c7e  50               push ax
1000:2c7f  e8 68 00         call 0x2cea
1000:2c82  b8 b8 1a         mov ax, 0x1ab8
1000:2c85  50               push ax
1000:2c86  b8 e4 0c         mov ax, 0xce4
1000:2c89  50               push ax
1000:2c8a  b8 20 00         mov ax, 0x20
1000:2c8d  50               push ax
1000:2c8e  b8 0d 00         mov ax, 0xd
1000:2c91  50               push ax
1000:2c92  b8 04 00         mov ax, 4
1000:2c95  50               push ax
1000:2c96  e8 51 00         call 0x2cea
1000:2c99  c3               ret 
                            sub_12c45 ENDP
*/
void sub_12c45()
{
    // coverage: 0x2e45-0x2e9a method sub_12c45
    // coverage2: 1000:2c45-1000:2c9a method sub_12c45 // ins(0x2c45, 0x2c9a, 0x2c45);
    ax = 0x0aac;
    push(ax);
    ax = 0x0010;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x0005;
    push(ax);
    sub_12d9a();
    ax = 0x0b4d;
    push(ax);
    ax = 0x000e;
    push(ax);
    ax = 0x0020;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12d9a();
    ax = 0x7592;
    push(ax);
    ax = 0x0c8f;
    push(ax);
    ax = 0x0028;
    push(ax);
    ax = 0x000c;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12cea();
    ax = 0x1ab8;
    push(ax);
    ax = 0x0ce4;
    push(ax);
    ax = 0x0020;
    push(ax);
    ax = 0x000d;
    push(ax);
    ax = 0x0004;
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2c9a sub_12c9a()
                            sub_12c9a PROC
1000:2c9a  50               push ax
1000:2c9b  b8 cc 0d         mov ax, 0xdcc
1000:2c9e  50               push ax
1000:2c9f  b8 11 00         mov ax, 0x11
1000:2ca2  50               push ax
1000:2ca3  b8 0f 00         mov ax, 0xf
1000:2ca6  50               push ax
1000:2ca7  b8 02 00         mov ax, 2
1000:2caa  50               push ax
1000:2cab  e8 ec 00         call 0x2d9a
1000:2cae  58               pop ax
1000:2caf  3c 06            cmp al, 6
1000:2cb1  75 09            jne loc_12cbc
1000:2cb3  b0 00            mov al, 0
1000:2cb5  e8 0f 00         call 0x2cc7
1000:2cb8  b0 06            mov al, 6
1000:2cba  eb 0b            jmp loc_12cc7
                            loc_12cbc:
1000:2cbc  3c 07            cmp al, 7
1000:2cbe  75 07            jne loc_12cc7
1000:2cc0  b0 01            mov al, 1
1000:2cc2  e8 02 00         call 0x2cc7
1000:2cc5  b0 07            mov al, 7
                            loc_12cc7:
1000:2cc7  8a d8            mov bl, al
1000:2cc9  b7 00            mov bh, 0
1000:2ccb  d1 e3            shl bx, 1
1000:2ccd  8b 87 1f 15      mov ax, word ptr [bx + 0x151f]
1000:2cd1  50               push ax
1000:2cd2  8b 87 2f 15      mov ax, word ptr [bx + 0x152f]
1000:2cd6  50               push ax
1000:2cd7  8b 87 3f 15      mov ax, word ptr [bx + 0x153f]
1000:2cdb  50               push ax
1000:2cdc  8b 87 4f 15      mov ax, word ptr [bx + 0x154f]
1000:2ce0  50               push ax
1000:2ce1  8b 87 0f 15      mov ax, word ptr [bx + 0x150f]
1000:2ce5  50               push ax
1000:2ce6  e8 01 00         call 0x2cea
1000:2ce9  c3               ret 
                            sub_12c9a ENDP
*/
void sub_12c9a()
{
    // coverage: 0x2e9a-0x2eea method sub_12c9a
    // coverage2: 1000:2c9a-1000:2cea method sub_12c9a // ins(0x2c9a, 0x2cea, 0x2c9a);
    push(ax);
    ax = 0x0dcc;
    push(ax);
    ax = 0x0011;
    push(ax);
    ax = 0x000f;
    push(ax);
    ax = 0x0002;
    push(ax);
    sub_12d9a();
    ax = pop();
    if (al != 0x06)
        goto loc_12cbc;
    al = 0x00;
    sub_12cc7();
    al = 0x06;
    goto loc_12cc7;
loc_12cbc:
    if (al != 0x07)
        goto loc_12cc7;
    al = 0x01;
    sub_12cc7();
    al = 0x07;
loc_12cc7:
    bl = al;
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5407);
    push(ax);
    ax = memoryAGet16(ds, bx + 5423);
    push(ax);
    ax = memoryAGet16(ds, bx + 5439);
    push(ax);
    ax = memoryAGet16(ds, bx + 5455);
    push(ax);
    ax = memoryAGet16(ds, bx + 5391);
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2cc7 sub_12cc7()
                            sub_12cc7 PROC
1000:2cc7  8a d8            mov bl, al
1000:2cc9  b7 00            mov bh, 0
1000:2ccb  d1 e3            shl bx, 1
1000:2ccd  8b 87 1f 15      mov ax, word ptr [bx + 0x151f]
1000:2cd1  50               push ax
1000:2cd2  8b 87 2f 15      mov ax, word ptr [bx + 0x152f]
1000:2cd6  50               push ax
1000:2cd7  8b 87 3f 15      mov ax, word ptr [bx + 0x153f]
1000:2cdb  50               push ax
1000:2cdc  8b 87 4f 15      mov ax, word ptr [bx + 0x154f]
1000:2ce0  50               push ax
1000:2ce1  8b 87 0f 15      mov ax, word ptr [bx + 0x150f]
1000:2ce5  50               push ax
1000:2ce6  e8 01 00         call 0x2cea
1000:2ce9  c3               ret 
                            sub_12cc7 ENDP
*/
void sub_12cc7()
{
    // coverage: 0x2ec7-0x2eea method sub_12cc7
    // coverage2: 1000:2cc7-1000:2cea method sub_12cc7 // ins(0x2cc7, 0x2cea, 0x2cc7);
    bl = al;
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 5407);
    push(ax);
    ax = memoryAGet16(ds, bx + 5423);
    push(ax);
    ax = memoryAGet16(ds, bx + 5439);
    push(ax);
    ax = memoryAGet16(ds, bx + 5455);
    push(ax);
    ax = memoryAGet16(ds, bx + 5391);
    push(ax);
    sub_12cea();
}
/* Assembly listing of 1000:2cea sub_12cea()
                            sub_12cea PROC
1000:2cea  55               push bp
1000:2ceb  8b ec            mov bp, sp
1000:2ced  b8 00 a0         mov ax, 0xa000
1000:2cf0  8e c0            mov es, ax
1000:2cf2  8b 7e 0a         mov di, word ptr [bp + 0xa]
1000:2cf5  8b 5e 04         mov bx, word ptr [bp + 4]
1000:2cf8  8b 9f e8 94      mov bx, word ptr [bx - 0x6b18]
1000:2cfc  8b 76 0c         mov si, word ptr [bp + 0xc]
1000:2cff  1e               push ds
1000:2d00  53               push bx
1000:2d01  ba ce 03         mov dx, 0x3ce
1000:2d04  b8 05 0a         mov ax, 0xa05
1000:2d07  ef               out dx, ax
1000:2d08  b8 07 00         mov ax, 7
1000:2d0b  ef               out dx, ax
1000:2d0c  8b 4e 08         mov cx, word ptr [bp + 8]
1000:2d0f  d1 e9            shr cx, 1
1000:2d11  b4 80            mov ah, 0x80
1000:2d13  b0 08            mov al, 8
1000:2d15  1f               pop ds
1000:2d16  8b 5e 06         mov bx, word ptr [bp + 6]
                            loc_12d19:
1000:2d19  50               push ax
1000:2d1a  53               push bx
1000:2d1b  51               push cx
1000:2d1c  57               push di
1000:2d1d  56               push si
                            loc_12d1e:
1000:2d1e  b7 22            mov bh, 0x22
                            loc_12d20:
1000:2d20  8a 1c            mov bl, byte ptr [si]
1000:2d22  46               inc si
1000:2d23  3a fb            cmp bh, bl
1000:2d25  75 16            jne loc_12d3d
1000:2d27  d0 ec            shr ah, 1
1000:2d29  75 07            jne loc_12d32
1000:2d2b  b4 40            mov ah, 0x40
1000:2d2d  47               inc di
1000:2d2e  e2 f0            loop loc_12d20
1000:2d30  eb 44            jmp loc_12d76
                            loc_12d32:
1000:2d32  d0 ec            shr ah, 1
1000:2d34  75 03            jne loc_12d39
1000:2d36  b4 80            mov ah, 0x80
1000:2d38  47               inc di
                            loc_12d39:
1000:2d39  e2 e5            loop loc_12d20
1000:2d3b  eb 39            jmp loc_12d76
                            loc_12d3d:
1000:2d3d  8a fb            mov bh, bl
1000:2d3f  d0 eb            shr bl, 1
1000:2d41  d0 eb            shr bl, 1
1000:2d43  d0 eb            shr bl, 1
1000:2d45  d0 eb            shr bl, 1
1000:2d47  80 fb 02         cmp bl, 2
1000:2d4a  74 09            je loc_12d55
1000:2d4c  ef               out dx, ax
1000:2d4d  26 20 1d         and byte ptr es:[di], bl
1000:2d50  26 20 9d 00 20   and byte ptr es:[di + 0x2000], bl
                            loc_12d55:
1000:2d55  d0 ec            shr ah, 1
1000:2d57  75 03            jne loc_12d5c
1000:2d59  b4 80            mov ah, 0x80
1000:2d5b  47               inc di
                            loc_12d5c:
1000:2d5c  80 e7 0f         and bh, 0xf
1000:2d5f  80 ff 02         cmp bh, 2
1000:2d62  74 09            je loc_12d6d
1000:2d64  ef               out dx, ax
1000:2d65  26 20 3d         and byte ptr es:[di], bh
1000:2d68  26 20 bd 00 20   and byte ptr es:[di + 0x2000], bh
                            loc_12d6d:
1000:2d6d  d0 ec            shr ah, 1
1000:2d6f  75 03            jne loc_12d74
1000:2d71  b4 80            mov ah, 0x80
1000:2d73  47               inc di
                            loc_12d74:
1000:2d74  e2 a8            loop loc_12d1e
                            loc_12d76:
1000:2d76  5e               pop si
1000:2d77  81 c6 a0 00      add si, 0xa0
1000:2d7b  5f               pop di
1000:2d7c  83 c7 28         add di, 0x28
1000:2d7f  81 e7 ff 7f      and di, 0x7fff
1000:2d83  59               pop cx
1000:2d84  5b               pop bx
1000:2d85  58               pop ax
1000:2d86  4b               dec bx
1000:2d87  75 90            jne loc_12d19
1000:2d89  1f               pop ds
1000:2d8a  b8 08 ff         mov ax, 0xff08
1000:2d8d  ef               out dx, ax
1000:2d8e  b8 05 00         mov ax, 5
1000:2d91  ef               out dx, ax
1000:2d92  b8 07 0f         mov ax, 0xf07
1000:2d95  ef               out dx, ax
1000:2d96  5d               pop bp
1000:2d97  c2 0a 00         ret 0xa
                            sub_12cea ENDP
*/
void sub_12cea()
{
    // coverage: 0x2eea-0x2f9a method sub_12cea
    // coverage2: 1000:2cea-1000:2d9a method sub_12cea // ins(0x2cea, 0x2d9a, 0x2cea);
    push(bp);
    bp = sp;
    ax = 0xa000;
    es = ax;
    di = memoryAGet16(ss, bp + 10 - 2);
    bx = memoryAGet16(ss, bp + 4 - 2);
    bx = memoryAGet16(ds, bx + 38120);
    si = memoryAGet16(ss, bp + 12 - 2);
    push(ds);
    push(bx);
    dx = 0x03ce;
    ax = 0x0a05;
    out(dx, ax);
    ax = 0x0007;
    out(dx, ax);
    cx = memoryAGet16(ss, bp + 8 - 2);
    cx >>= 1;
    ah = 0x80;
    al = 0x08;
    ds = pop();
    bx = memoryAGet16(ss, bp + 6 - 2);
loc_12d19:
    push(ax);
    push(bx);
    push(cx);
    push(di);
    push(si);
loc_12d1e:
    bh = 0x22;
loc_12d20:
    bl = memoryAGet(ds, si);
    si++;
    if (bh != bl)
        goto loc_12d3d;
    ah >>= 1;
    if (ah != 0)
        goto loc_12d32;
    ah = 0x40;
    di++;
    if (--cx)
        goto loc_12d20;
    goto loc_12d76;
loc_12d32:
    ah >>= 1;
    if (ah != 0)
        goto loc_12d39;
    ah = 0x80;
    di++;
loc_12d39:
    if (--cx)
        goto loc_12d20;
    goto loc_12d76;
loc_12d3d:
    bh = bl;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    bl >>= 1;
    if (bl == 0x02)
        goto loc_12d55;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bl);
    memoryASet(es, di + 8192, memoryAGet(es, di + 8192) & bl);
loc_12d55:
    ah >>= 1;
    if (ah != 0)
        goto loc_12d5c;
    ah = 0x80;
    di++;
loc_12d5c:
    bh &= 0x0f;
    if (bh == 0x02)
        goto loc_12d6d;
    out(dx, ax);
    memoryASet(es, di, memoryAGet(es, di) & bh);
    memoryASet(es, di + 8192, memoryAGet(es, di + 8192) & bh);
loc_12d6d:
    ah >>= 1;
    if (ah != 0)
        goto loc_12d74;
    ah = 0x80;
    di++;
loc_12d74:
    if (--cx)
        goto loc_12d1e;
loc_12d76:
    si = pop();
    si += 0x00a0;
    di = pop();
    di += 0x0028;
    di &= 0x7fff;
    cx = pop();
    bx = pop();
    ax = pop();
    bx--;
    if (bx != 0)
        goto loc_12d19;
    ds = pop();
    ax = 0xff08;
    out(dx, ax);
    ax = 0x0005;
    out(dx, ax);
    ax = 0x0f07;
    out(dx, ax);
    bp = pop();
    sp += 10;
}
/* Assembly listing of 1000:2d9a sub_12d9a()
                            sub_12d9a PROC
1000:2d9a  55               push bp
1000:2d9b  8b ec            mov bp, sp
1000:2d9d  b8 00 a0         mov ax, 0xa000
1000:2da0  8e c0            mov es, ax
1000:2da2  8b 7e 0a         mov di, word ptr [bp + 0xa]
1000:2da5  ba ce 03         mov dx, 0x3ce
1000:2da8  8b 46 04         mov ax, word ptr [bp + 4]
1000:2dab  8a e0            mov ah, al
1000:2dad  b0 00            mov al, 0
1000:2daf  ef               out dx, ax
1000:2db0  b8 01 0f         mov ax, 0xf01
1000:2db3  ef               out dx, ax
1000:2db4  fc               cld 
1000:2db5  8b 5e 06         mov bx, word ptr [bp + 6]
                            loc_12db8:
1000:2db8  57               push di
1000:2db9  8b 4e 08         mov cx, word ptr [bp + 8]
1000:2dbc  f3 aa            rep stosb byte ptr es:[di], al
1000:2dbe  5f               pop di
1000:2dbf  57               push di
1000:2dc0  81 c7 00 20      add di, 0x2000
1000:2dc4  8b 4e 08         mov cx, word ptr [bp + 8]
1000:2dc7  f3 aa            rep stosb byte ptr es:[di], al
1000:2dc9  5f               pop di
1000:2dca  83 c7 28         add di, 0x28
1000:2dcd  4b               dec bx
1000:2dce  75 e8            jne loc_12db8
1000:2dd0  b8 00 00         mov ax, 0
1000:2dd3  ef               out dx, ax
1000:2dd4  fe c0            inc al
1000:2dd6  ef               out dx, ax
1000:2dd7  5d               pop bp
1000:2dd8  c2 08 00         ret 8
                            sub_12d9a ENDP
*/
void sub_12d9a()
{
    // coverage: 0x2f9a-0x2fdb method sub_12d9a
    // coverage2: 1000:2d9a-1000:2ddb method sub_12d9a // ins(0x2d9a, 0x2ddb, 0x2d9a);
    push(bp);
    bp = sp;
    ax = 0xa000;
    es = ax;
    di = memoryAGet16(ss, bp + 10 - 2);
    dx = 0x03ce;
    ax = memoryAGet16(ss, bp + 4 - 2);
    ah = al;
    al = 0x00;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    flags.direction = false;
    bx = memoryAGet16(ss, bp + 6 - 2);
loc_12db8:
    push(di);
    cx = memoryAGet16(ss, bp + 8 - 2);
    rep_stosb<MemAuto, DirAuto>();
    di = pop();
    push(di);
    di += 0x2000;
    cx = memoryAGet16(ss, bp + 8 - 2);
    rep_stosb<MemAuto, DirAuto>();
    di = pop();
    di += 0x0028;
    bx--;
    if (bx != 0)
        goto loc_12db8;
    ax = 0x0000;
    out(dx, ax);
    al++;
    out(dx, ax);
    bp = pop();
    sp += 8;
}
/* Assembly listing of 1000:2ddc sub_12ddc()
                            sub_12ddc PROC
1000:2ddc  8a 1e e4 94      mov bl, byte ptr [0x94e4]
1000:2de0  83 e3 03         and bx, 3
1000:2de3  d1 e3            shl bx, 1
1000:2de5  8b 87 2a 1a      mov ax, word ptr [bx + 0x1a2a]
1000:2de9  a3 e2 94         mov word ptr [0x94e2], ax
1000:2dec  fe 06 e4 94      inc byte ptr [0x94e4]
1000:2df0  c6 06 27 95 ff   mov byte ptr [0x9527], 0xff
1000:2df5  c3               ret 
                            sub_12ddc ENDP
*/
void sub_12ddc()
{
    // coverage: 0x2fdc-0x2ff6 method sub_12ddc
    // coverage2: 1000:2ddc-1000:2df6 method sub_12ddc // ins(0x2ddc, 0x2df6, 0x2ddc);
    bl = memoryAGet(ds, 0x94e4);
    bx &= 0x0003;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 6698);
    memoryASet16(ds, 0x94e2, ax);
    memoryASet(ds, 0x94e4, memoryAGet(ds, 0x94e4) + 1);
    memoryASet(ds, 0x9527, 0xff);
}
/* Assembly listing of 1000:2df6 sub_12df6()
                            sub_12df6 PROC
1000:2df6  b0 00            mov al, 0
1000:2df8  a2 e5 94         mov byte ptr [0x94e5], al
1000:2dfb  a2 e6 94         mov byte ptr [0x94e6], al
1000:2dfe  a2 e7 94         mov byte ptr [0x94e7], al
1000:2e01  c3               ret 
                            sub_12df6 ENDP
*/
void sub_12df6()
{
    // coverage: 0x2ff6-0x3002 method sub_12df6
    // coverage2: 1000:2df6-1000:2e02 method sub_12df6 // ins(0x2df6, 0x2e02, 0x2df6);
    al = 0x00;
    memoryASet(ds, 0x94e5, al);
    memoryASet(ds, 0x94e6, al);
    memoryASet(ds, 0x94e7, al);
}
/* Assembly listing of 1000:2e02 sub_12e02()
                            sub_12e02 PROC
1000:2e02  56               push si
1000:2e03  e8 7a ed         call 0x1b80
1000:2e06  e8 94 02         call 0x309d
1000:2e09  5e               pop si
1000:2e0a  a1 2a 95         mov ax, word ptr [0x952a]
1000:2e0d  d1 e8            shr ax, 1
1000:2e0f  d1 e8            shr ax, 1
1000:2e11  d1 e8            shr ax, 1
1000:2e13  8b 1e 4c 95      mov bx, word ptr [0x954c]
1000:2e17  f6 c3 01         test bl, 1
1000:2e1a  74 07            je loc_12e23
1000:2e1c  f7 d8            neg ax
1000:2e1e  2d 03 00         sub ax, 3
1000:2e21  eb 0d            jmp loc_12e30
                            loc_12e23:
1000:2e23  f6 c3 02         test bl, 2
1000:2e26  74 05            je loc_12e2d
1000:2e28  05 03 00         add ax, 3
1000:2e2b  eb 03            jmp loc_12e30
                            loc_12e2d:
1000:2e2d  b8 00 00         mov ax, 0
                            loc_12e30:
1000:2e30  a3 22 95         mov word ptr [0x9522], ax
1000:2e33  8a 44 16         mov al, byte ptr [si + 0x16]
1000:2e36  25 7f 00         and ax, 0x7f
1000:2e39  3c 3f            cmp al, 0x3f
1000:2e3b  76 0b            jbe loc_12e48
1000:2e3d  f6 d8            neg al
1000:2e3f  04 7f            add al, 0x7f
1000:2e41  e8 40 02         call 0x3084
1000:2e44  f7 d8            neg ax
1000:2e46  eb 03            jmp loc_12e4b
                            loc_12e48:
1000:2e48  e8 39 02         call 0x3084
                            loc_12e4b:
1000:2e4b  a3 20 95         mov word ptr [0x9520], ax
1000:2e4e  a1 1e 95         mov ax, word ptr [0x951e]
1000:2e51  03 06 22 95      add ax, word ptr [0x9522]
1000:2e55  03 06 20 95      add ax, word ptr [0x9520]
1000:2e59  74 0f            je loc_12e6a
1000:2e5b  79 06            jns loc_12e63
1000:2e5d  40               inc ax
1000:2e5e  79 01            jns loc_12e61
1000:2e60  40               inc ax
                            loc_12e61:
1000:2e61  eb 07            jmp loc_12e6a
                            loc_12e63:
1000:2e63  48               dec ax
1000:2e64  3d 00 00         cmp ax, 0
1000:2e67  7e 01            jle loc_12e6a
1000:2e69  48               dec ax
                            loc_12e6a:
1000:2e6a  3d 40 00         cmp ax, 0x40
1000:2e6d  7e 05            jle loc_12e74
1000:2e6f  b8 40 00         mov ax, 0x40
1000:2e72  eb 08            jmp loc_12e7c
                            loc_12e74:
1000:2e74  3d c0 ff         cmp ax, 0xffc0
1000:2e77  7d 03            jge loc_12e7c
1000:2e79  b8 c0 ff         mov ax, 0xffc0
                            loc_12e7c:
1000:2e7c  a3 1e 95         mov word ptr [0x951e], ax
1000:2e7f  d1 f8            sar ax, 1
1000:2e81  d1 f8            sar ax, 1
1000:2e83  00 44 16         add byte ptr [si + 0x16], al
1000:2e86  8a 44 16         mov al, byte ptr [si + 0x16]
1000:2e89  25 7f 00         and ax, 0x7f
1000:2e8c  8b d8            mov bx, ax
1000:2e8e  8a 87 75 16      mov al, byte ptr [bx + 0x1675]
1000:2e92  98               cwde 
1000:2e93  d1 e0            shl ax, 1
1000:2e95  05 80 00         add ax, 0x80
1000:2e98  89 44 05         mov word ptr [si + 5], ax
1000:2e9b  8a 87 f5 16      mov al, byte ptr [bx + 0x16f5]
1000:2e9f  98               cwde 
1000:2ea0  d1 e0            shl ax, 1
1000:2ea2  05 80 00         add ax, 0x80
1000:2ea5  53               push bx
1000:2ea6  3d 00 00         cmp ax, 0
1000:2ea9  74 13            je loc_12ebe
1000:2eab  8b d8            mov bx, ax
1000:2ead  d1 e0            shl ax, 1
1000:2eaf  d1 e0            shl ax, 1
1000:2eb1  03 c3            add ax, bx
1000:2eb3  d1 e0            shl ax, 1
1000:2eb5  05 05 00         add ax, 5
1000:2eb8  b3 0c            mov bl, 0xc
1000:2eba  f6 f3            div bl
1000:2ebc  b4 00            mov ah, 0
                            loc_12ebe:
1000:2ebe  5b               pop bx
1000:2ebf  89 44 07         mov word ptr [si + 7], ax
1000:2ec2  8a 87 75 17      mov al, byte ptr [bx + 0x1775]
1000:2ec6  88 44 04         mov byte ptr [si + 4], al
1000:2ec9  bb 94 15         mov bx, 0x1594
1000:2ecc  e8 52 f2         call 0x2121
1000:2ecf  a0 e6 94         mov al, byte ptr [0x94e6]
1000:2ed2  a2 e7 94         mov byte ptr [0x94e7], al
1000:2ed5  a0 e5 94         mov al, byte ptr [0x94e5]
1000:2ed8  a2 e6 94         mov byte ptr [0x94e6], al
1000:2edb  a0 a0 1b         mov al, byte ptr [0x1ba0]
1000:2ede  a2 e5 94         mov byte ptr [0x94e5], al
1000:2ee1  a1 4c 95         mov ax, word ptr [0x954c]
1000:2ee4  8a 1e 1a 95      mov bl, byte ptr [0x951a]
1000:2ee8  a8 40            test al, 0x40
1000:2eea  74 16            je loc_12f02
1000:2eec  80 fb 02         cmp bl, 2
1000:2eef  75 0f            jne loc_12f00
1000:2ef1  c6 06 1a 95 03   mov byte ptr [0x951a], 3
1000:2ef6  b0 02            mov al, 2
1000:2ef8  e8 45 09         call 0x3840
1000:2efb  c6 06 1c 95 02   mov byte ptr [0x951c], 2
                            loc_12f00:
1000:2f00  eb 16            jmp loc_12f18
                            loc_12f02:
1000:2f02  80 fb 01         cmp bl, 1
1000:2f05  75 07            jne loc_12f0e
1000:2f07  c6 06 1a 95 02   mov byte ptr [0x951a], 2
1000:2f0c  eb 0a            jmp loc_12f18
                            loc_12f0e:
1000:2f0e  80 fb 03         cmp bl, 3
1000:2f11  75 05            jne loc_12f18
1000:2f13  c6 06 1a 95 00   mov byte ptr [0x951a], 0
                            loc_12f18:
1000:2f18  a1 4c 95         mov ax, word ptr [0x954c]
1000:2f1b  8a 1e 1b 95      mov bl, byte ptr [0x951b]
1000:2f1f  a8 20            test al, 0x20
1000:2f21  74 16            je loc_12f39
1000:2f23  80 fb 02         cmp bl, 2
1000:2f26  75 0f            jne loc_12f37
1000:2f28  c6 06 1b 95 03   mov byte ptr [0x951b], 3
1000:2f2d  b0 02            mov al, 2
1000:2f2f  e8 0e 09         call 0x3840
1000:2f32  c6 06 1c 95 02   mov byte ptr [0x951c], 2
                            loc_12f37:
1000:2f37  eb 16            jmp loc_12f4f
                            loc_12f39:
1000:2f39  80 fb 01         cmp bl, 1
1000:2f3c  75 07            jne loc_12f45
1000:2f3e  c6 06 1b 95 02   mov byte ptr [0x951b], 2
1000:2f43  eb 0a            jmp loc_12f4f
                            loc_12f45:
1000:2f45  80 fb 03         cmp bl, 3
1000:2f48  75 05            jne loc_12f4f
1000:2f4a  c6 06 1b 95 00   mov byte ptr [0x951b], 0
                            loc_12f4f:
1000:2f4f  c3               ret 
                            sub_12e02 ENDP
*/
void sub_12e02()
{
    // coverage: 0x3002-0x3150 method sub_12e02
    // coverage2: 1000:2e02-1000:2f50 method sub_12e02 // ins(0x2e02, 0x2f50, 0x2e02);
    push(si);
    sub_11b80();
    sub_1309d();
    si = pop();
    ax = memoryAGet16(ds, 0x952a);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    bx = memoryAGet16(ds, 0x954c);
    if (!(bl & 0x01))
        goto loc_12e23;
    ax = -ax;
    ax -= 0x0003;
    goto loc_12e30;
loc_12e23:
    if (!(bl & 0x02))
        goto loc_12e2d;
    ax += 0x0003;
    goto loc_12e30;
loc_12e2d:
    ax = 0x0000;
loc_12e30:
    memoryASet16(ds, 0x9522, ax);
    al = memoryAGet(ds, si + 22);
    ax &= 0x007f;
    if (al <= 0x3f)
        goto loc_12e48;
    al = -al;
    al += 0x7f;
    sub_13084();
    ax = -ax;
    goto loc_12e4b;
loc_12e48:
    sub_13084();
loc_12e4b:
    memoryASet16(ds, 0x9520, ax);
    ax = memoryAGet16(ds, 0x951e);
    ax += memoryAGet16(ds, 0x9522);
    ax += memoryAGet16(ds, 0x9520);
    if (ax == 0)
        goto loc_12e6a;
    if ((short)ax >= 0)
        goto loc_12e63;
    ax++;
    if ((short)ax >= 0)
        goto loc_12e61;
    ax++;
loc_12e61:
    goto loc_12e6a;
loc_12e63:
    ax--;
    if ((short)ax <= (short)0x0000)
        goto loc_12e6a;
    ax--;
loc_12e6a:
    if ((short)ax <= (short)0x0040)
        goto loc_12e74;
    ax = 0x0040;
    goto loc_12e7c;
loc_12e74:
    if ((short)ax >= (short)0xffc0)
        goto loc_12e7c;
    ax = 0xffc0;
loc_12e7c:
    memoryASet16(ds, 0x951e, ax);
    ax = sar(ax, 1);
    ax = sar(ax, 1);
    memoryASet(ds, si + 22, memoryAGet(ds, si + 22) + al);
    al = memoryAGet(ds, si + 22);
    ax &= 0x007f;
    bx = ax;
    al = memoryAGet(ds, bx + 5749);
    cbw();
    ax <<= 1;
    ax += 0x0080;
    memoryASet16(ds, si + 5, ax);
    al = memoryAGet(ds, bx + 5877);
    cbw();
    ax <<= 1;
    ax += 0x0080;
    push(bx);
    if (ax == 0x0000)
        goto loc_12ebe;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_12ebe:
    bx = pop();
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, bx + 6005);
    memoryASet(ds, si + 4, al);
    bx = 0x1594;
    sub_12121();
    al = memoryAGet(ds, 0x94e6);
    memoryASet(ds, 0x94e7, al);
    al = memoryAGet(ds, 0x94e5);
    memoryASet(ds, 0x94e6, al);
    al = memoryAGet(ds, 0x1ba0);
    memoryASet(ds, 0x94e5, al);
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951a);
    if (!(al & 0x40))
        goto loc_12f02;
    if (bl != 0x02)
        goto loc_12f00;
    memoryASet(ds, 0x951a, 0x03);
    al = 0x02;
    sub_13840();
    memoryASet(ds, 0x951c, 0x02);
loc_12f00:
    goto loc_12f18;
loc_12f02:
    if (bl != 0x01)
        goto loc_12f0e;
    memoryASet(ds, 0x951a, 0x02);
    goto loc_12f18;
loc_12f0e:
    if (bl != 0x03)
        goto loc_12f18;
    memoryASet(ds, 0x951a, 0x00);
loc_12f18:
    ax = memoryAGet16(ds, 0x954c);
    bl = memoryAGet(ds, 0x951b);
    if (!(al & 0x20))
        goto loc_12f39;
    if (bl != 0x02)
        goto loc_12f37;
    memoryASet(ds, 0x951b, 0x03);
    al = 0x02;
    sub_13840();
    memoryASet(ds, 0x951c, 0x02);
loc_12f37:
    return;
loc_12f39:
    if (bl != 0x01)
        goto loc_12f45;
    memoryASet(ds, 0x951b, 0x02);
    return;
loc_12f45:
    if (bl != 0x03)
        return;
    memoryASet(ds, 0x951b, 0x00);
}
/* Assembly listing of 1000:2f50 sub_12f50()
                            sub_12f50 PROC
1000:2f50  8a 04            mov al, byte ptr [si]
1000:2f52  a8 20            test al, 0x20
1000:2f54  75 08            jne loc_12f5e
1000:2f56  8a 26 1a 95      mov ah, byte ptr [0x951a]
1000:2f5a  b0 f8            mov al, 0xf8
1000:2f5c  eb 06            jmp loc_12f64
                            loc_12f5e:
1000:2f5e  8a 26 1b 95      mov ah, byte ptr [0x951b]
1000:2f62  b0 08            mov al, 8
                            loc_12f64:
1000:2f64  80 fc 03         cmp ah, 3
1000:2f67  74 05            je loc_12f6e
1000:2f69  80 fc 00         cmp ah, 0
1000:2f6c  75 22            jne loc_12f90
                            loc_12f6e:
1000:2f6e  c6 04 00         mov byte ptr [si], 0
1000:2f71  be a1 1b         mov si, 0x1ba1
                            loc_12f74:
1000:2f74  8a 04            mov al, byte ptr [si]
1000:2f76  a8 80            test al, 0x80
1000:2f78  75 15            jne loc_12f8f
1000:2f7a  a8 01            test al, 1
1000:2f7c  74 0c            je loc_12f8a
1000:2f7e  8a 44 12         mov al, byte ptr [si + 0x12]
1000:2f81  3c 0f            cmp al, 0xf
1000:2f83  75 05            jne loc_12f8a
1000:2f85  56               push si
1000:2f86  e8 d0 00         call 0x3059
1000:2f89  5e               pop si
                            loc_12f8a:
1000:2f8a  83 c6 17         add si, 0x17
1000:2f8d  eb e5            jmp loc_12f74
                            loc_12f8f:
1000:2f8f  c3               ret 
                            loc_12f90:
1000:2f90  02 06 e7 94      add al, byte ptr [0x94e7]
1000:2f94  25 7f 00         and ax, 0x7f
1000:2f97  8b d8            mov bx, ax
1000:2f99  8a 87 75 16      mov al, byte ptr [bx + 0x1675]
1000:2f9d  98               cwde 
1000:2f9e  8b c8            mov cx, ax
1000:2fa0  d1 f9            sar cx, 1
1000:2fa2  03 c1            add ax, cx
1000:2fa4  05 80 00         add ax, 0x80
1000:2fa7  89 44 05         mov word ptr [si + 5], ax
1000:2faa  8a 87 f5 16      mov al, byte ptr [bx + 0x16f5]
1000:2fae  98               cwde 
1000:2faf  8b c8            mov cx, ax
1000:2fb1  d1 f9            sar cx, 1
1000:2fb3  03 c1            add ax, cx
1000:2fb5  05 80 00         add ax, 0x80
1000:2fb8  3d 00 00         cmp ax, 0
1000:2fbb  74 13            je loc_12fd0
1000:2fbd  8b d8            mov bx, ax
1000:2fbf  d1 e0            shl ax, 1
1000:2fc1  d1 e0            shl ax, 1
1000:2fc3  03 c3            add ax, bx
1000:2fc5  d1 e0            shl ax, 1
1000:2fc7  05 05 00         add ax, 5
1000:2fca  b3 0c            mov bl, 0xc
1000:2fcc  f6 f3            div bl
1000:2fce  b4 00            mov ah, 0
                            loc_12fd0:
1000:2fd0  8a 1e a0 1b      mov bl, byte ptr [0x1ba0]
1000:2fd4  83 e3 7f         and bx, 0x7f
1000:2fd7  89 44 07         mov word ptr [si + 7], ax
1000:2fda  8a 87 92 18      mov al, byte ptr [bx + 0x1892]
1000:2fde  88 44 04         mov byte ptr [si + 4], al
1000:2fe1  bb 11 18         mov bx, 0x1811
1000:2fe4  e8 3a f1         call 0x2121
1000:2fe7  c3               ret 
                            sub_12f50 ENDP
*/
void sub_12f50()
{
    // coverage: 0x3150-0x31e8 method sub_12f50
    // coverage2: 1000:2f50-1000:2fe8 method sub_12f50 // ins(0x2f50, 0x2fe8, 0x2f50);
    al = memoryAGet(ds, si);
    if (al & 0x20)
        goto loc_12f5e;
    ah = memoryAGet(ds, 0x951a);
    al = 0xf8;
    goto loc_12f64;
loc_12f5e:
    ah = memoryAGet(ds, 0x951b);
    al = 0x08;
loc_12f64:
    if (ah == 0x03)
        goto loc_12f6e;
    if (ah != 0x00)
        goto loc_12f90;
loc_12f6e:
    memoryASet(ds, si, 0x00);
    si = 0x1ba1;
loc_12f74:
    al = memoryAGet(ds, si);
    if (al & 0x80)
        goto loc_12f8f;
    if (!(al & 0x01))
        goto loc_12f8a;
    al = memoryAGet(ds, si + 18);
    if (al != 0x0f)
        goto loc_12f8a;
    push(si);
    sub_13059();
    si = pop();
loc_12f8a:
    si += 0x0017;
    goto loc_12f74;
loc_12f8f:
    return;
loc_12f90:
    al += memoryAGet(ds, 0x94e7);
    ax &= 0x007f;
    bx = ax;
    al = memoryAGet(ds, bx + 5749);
    cbw();
    cx = ax;
    cx = sar(cx, 1);
    ax += cx;
    ax += 0x0080;
    memoryASet16(ds, si + 5, ax);
    al = memoryAGet(ds, bx + 5877);
    cbw();
    cx = ax;
    cx = sar(cx, 1);
    ax += cx;
    ax += 0x0080;
    if (ax == 0x0000)
        goto loc_12fd0;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_12fd0:
    bl = memoryAGet(ds, 0x1ba0);
    bx &= 0x007f;
    memoryASet16(ds, si + 7, ax);
    al = memoryAGet(ds, bx + 6290);
    memoryASet(ds, si + 4, al);
    bx = 0x1811;
    sub_12121();
}
/* Assembly listing of 1000:2fe8 sub_12fe8()
                            sub_12fe8 PROC
1000:2fe8  8b 1e 25 95      mov bx, word ptr [0x9525]
1000:2fec  d1 eb            shr bx, 1
1000:2fee  d1 eb            shr bx, 1
1000:2ff0  d1 eb            shr bx, 1
1000:2ff2  83 e3 1f         and bx, 0x1f
1000:2ff5  8a 87 0a 1a      mov al, byte ptr [bx + 0x1a0a]
1000:2ff9  a2 49 95         mov byte ptr [0x9549], al
1000:2ffc  8a 87 ea 19      mov al, byte ptr [bx + 0x19ea]
1000:3000  88 44 04         mov byte ptr [si + 4], al
1000:3003  bb 29 19         mov bx, 0x1929
1000:3006  e8 18 f1         call 0x2121
1000:3009  c3               ret 
                            sub_12fe8 ENDP
*/
void sub_12fe8()
{
    // coverage: 0x31e8-0x320a method sub_12fe8
    // coverage2: 1000:2fe8-1000:300a method sub_12fe8 // ins(0x2fe8, 0x300a, 0x2fe8);
    bx = memoryAGet16(ds, 0x9525);
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx &= 0x001f;
    al = memoryAGet(ds, bx + 6666);
    memoryASet(ds, 0x9549, al);
    al = memoryAGet(ds, bx + 6634);
    memoryASet(ds, si + 4, al);
    bx = 0x1929;
    sub_12121();
}
/* Assembly listing of 1000:300a sub_1300a()
                            sub_1300a PROC
1000:300a  a1 47 95         mov ax, word ptr [0x9547]
1000:300d  2b 44 13         sub ax, word ptr [si + 0x13]
1000:3010  d1 e8            shr ax, 1
1000:3012  d1 e8            shr ax, 1
1000:3014  d1 e8            shr ax, 1
1000:3016  3d 2d 00         cmp ax, 0x2d
1000:3019  76 04            jbe loc_1301f
1000:301b  c6 04 00         mov byte ptr [si], 0
1000:301e  c3               ret 
                            loc_1301f:
1000:301f  50               push ax
1000:3020  e8 0d 01         call 0x3130
1000:3023  58               pop ax
1000:3024  d1 e8            shr ax, 1
1000:3026  88 44 04         mov byte ptr [si + 4], al
1000:3029  8b d8            mov bx, ax
1000:302b  8a 87 9a 1a      mov al, byte ptr [bx + 0x1a9a]
1000:302f  88 44 02         mov byte ptr [si + 2], al
1000:3032  bb c9 1a         mov bx, 0x1ac9
1000:3035  e8 e9 f0         call 0x2121
1000:3038  8a 44 02         mov al, byte ptr [si + 2]
1000:303b  3c 02            cmp al, 2
1000:303d  74 01            je loc_13040
1000:303f  c3               ret 
                            loc_13040:
1000:3040  8a 1e 8e 1b      mov bl, byte ptr [0x1b8e]
1000:3044  b7 00            mov bh, 0
1000:3046  8a 87 f5 17      mov al, byte ptr [bx + 0x17f5]
1000:304a  3a 44 01         cmp al, byte ptr [si + 1]
1000:304d  74 01            je loc_13050
1000:304f  c3               ret 
                            loc_13050:
1000:3050  b0 09            mov al, 9
1000:3052  e8 eb 07         call 0x3840
1000:3055  e8 01 00         call 0x3059
1000:3058  c3               ret 
                            sub_1300a ENDP
*/
void sub_1300a()
{
    // coverage: 0x320a-0x3259 method sub_1300a
    // coverage2: 1000:300a-1000:3059 method sub_1300a // ins(0x300a, 0x3059, 0x300a);
    ax = memoryAGet16(ds, 0x9547);
    ax -= memoryAGet16(ds, si + 19);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    if (ax <= 0x002d)
        goto loc_1301f;
    memoryASet(ds, si, 0x00);
    return;
loc_1301f:
    push(ax);
    sub_13130();
    ax = pop();
    ax >>= 1;
    memoryASet(ds, si + 4, al);
    bx = ax;
    al = memoryAGet(ds, bx + 6810);
    memoryASet(ds, si + 2, al);
    bx = 0x1ac9;
    sub_12121();
    al = memoryAGet(ds, si + 2);
    if (al == 0x02)
        goto loc_13040;
    return;
loc_13040:
    bl = memoryAGet(ds, 0x1b8e);
    bh = 0x00;
    al = memoryAGet(ds, bx + 6133);
    if (al == memoryAGet(ds, si + 1))
        goto loc_13050;
    return;
loc_13050:
    al = 0x09;
    sub_13840();
    sub_13059();
}
/* Assembly listing of 1000:3059 sub_13059()
                            sub_13059 PROC
1000:3059  c6 04 00         mov byte ptr [si], 0
1000:305c  a0 1d 95         mov al, byte ptr [0x951d]
1000:305f  3c 40            cmp al, 0x40
1000:3061  75 07            jne loc_1306a
1000:3063  83 06 40 95 06   add word ptr [0x9540], 6
1000:3068  eb 19            jmp loc_13083
                            loc_1306a:
1000:306a  3c 80            cmp al, 0x80
1000:306c  75 07            jne loc_13075
1000:306e  83 06 3c 95 04   add word ptr [0x953c], 4
1000:3073  eb 0e            jmp loc_13083
                            loc_13075:
1000:3075  3c c0            cmp al, 0xc0
1000:3077  75 07            jne loc_13080
1000:3079  83 06 44 95 08   add word ptr [0x9544], 8
1000:307e  eb 03            jmp loc_13083
                            loc_13080:
1000:3080  e8 07 f6         call 0x268a
                            loc_13083:
1000:3083  c3               ret 
                            sub_13059 ENDP
*/
void sub_13059()
{
    // coverage: 0x3259-0x3284 method sub_13059
    // coverage2: 1000:3059-1000:3084 method sub_13059 // ins(0x3059, 0x3084, 0x3059);
    memoryASet(ds, si, 0x00);
    al = memoryAGet(ds, 0x951d);
    if (al != 0x40)
        goto loc_1306a;
    memoryASet16(ds, 0x9540, memoryAGet16(ds, 0x9540) + 0x0006);
    return;
loc_1306a:
    if (al != 0x80)
        goto loc_13075;
    memoryASet16(ds, 0x953c, memoryAGet16(ds, 0x953c) + 0x0004);
    return;
loc_13075:
    if (al != 0xc0)
        goto loc_13080;
    memoryASet16(ds, 0x9544, memoryAGet16(ds, 0x9544) + 0x0008);
    return;
loc_13080:
    sub_1268a();
}
/* Assembly listing of 1000:3084 sub_13084()
                            sub_13084 PROC
1000:3084  2c 05            sub al, 5
1000:3086  79 05            jns loc_1308d
1000:3088  b8 00 00         mov ax, 0
1000:308b  eb 0f            jmp loc_1309c
                            loc_1308d:
1000:308d  3c 38            cmp al, 0x38
1000:308f  76 02            jbe loc_13093
1000:3091  b0 38            mov al, 0x38
                            loc_13093:
1000:3093  d0 e8            shr al, 1
1000:3095  b4 00            mov ah, 0
1000:3097  f7 d8            neg ax
1000:3099  2d 03 00         sub ax, 3
                            loc_1309c:
1000:309c  c3               ret 
                            sub_13084 ENDP
*/
void sub_13084()
{
    // coverage: 0x3284-0x329d method sub_13084
    // coverage2: 1000:3084-1000:309d method sub_13084 // ins(0x3084, 0x309d, 0x3084);
    al -= 0x05;
    if ((char)al >= 0)
        goto loc_1308d;
    ax = 0x0000;
    return;
loc_1308d:
    if (al <= 0x38)
        goto loc_13093;
    al = 0x38;
loc_13093:
    al >>= 1;
    ah = 0x00;
    ax = -ax;
    ax -= 0x0003;
}
/* Assembly listing of 1000:309d sub_1309d()
                            sub_1309d PROC
1000:309d  8b 1e 2a 95      mov bx, word ptr [0x952a]
1000:30a1  83 c3 07         add bx, 7
1000:30a4  d1 eb            shr bx, 1
1000:30a6  d1 eb            shr bx, 1
1000:30a8  d1 eb            shr bx, 1
1000:30aa  83 c3 02         add bx, 2
1000:30ad  01 1e 47 95      add word ptr [0x9547], bx
1000:30b1  a1 0f 95         mov ax, word ptr [0x950f]
1000:30b4  03 c3            add ax, bx
1000:30b6  3d e8 02         cmp ax, 0x2e8
1000:30b9  76 09            jbe loc_130c4
1000:30bb  b8 00 00         mov ax, 0
1000:30be  c7 06 3c 95 ff ff  mov word ptr [0x953c], 0xffff
                            loc_130c4:
1000:30c4  a3 0f 95         mov word ptr [0x950f], ax
1000:30c7  a1 47 95         mov ax, word ptr [0x9547]
1000:30ca  2d 80 03         sub ax, 0x380
1000:30cd  79 55            jns loc_13124
1000:30cf  f7 d8            neg ax
1000:30d1  3d 00 01         cmp ax, 0x100
1000:30d4  73 17            jae loc_130ed
1000:30d6  a3 25 95         mov word ptr [0x9525], ax
1000:30d9  a0 24 95         mov al, byte ptr [0x9524]
1000:30dc  3c 00            cmp al, 0
1000:30de  75 0b            jne loc_130eb
1000:30e0  be 12 19         mov si, 0x1912
1000:30e3  e8 72 da         call 0xb58
1000:30e6  c6 06 24 95 01   mov byte ptr [0x9524], 1
                            loc_130eb:
1000:30eb  eb 35            jmp loc_13122
                            loc_130ed:
1000:30ed  a1 47 95         mov ax, word ptr [0x9547]
1000:30f0  d1 e8            shr ax, 1
1000:30f2  d1 e8            shr ax, 1
1000:30f4  d1 e8            shr ax, 1
1000:30f6  d1 e8            shr ax, 1
1000:30f8  d1 e8            shr ax, 1
1000:30fa  d1 e8            shr ax, 1
1000:30fc  3a 06 27 95      cmp al, byte ptr [0x9527]
1000:3100  74 20            je loc_13122
1000:3102  a2 27 95         mov byte ptr [0x9527], al
1000:3105  8a d8            mov bl, al
1000:3107  b7 00            mov bh, 0
1000:3109  03 1e e2 94      add bx, word ptr [0x94e2]
1000:310d  8a 07            mov al, byte ptr [bx]
1000:310f  3c 00            cmp al, 0
1000:3111  74 0f            je loc_13122
1000:3113  be b2 1a         mov si, 0x1ab2
1000:3116  88 44 01         mov byte ptr [si + 1], al
1000:3119  a1 47 95         mov ax, word ptr [0x9547]
1000:311c  89 44 13         mov word ptr [si + 0x13], ax
1000:311f  e8 36 da         call 0xb58
                            loc_13122:
1000:3122  eb 0b            jmp loc_1312f
                            loc_13124:
1000:3124  c6 06 ff 94 00   mov byte ptr [0x94ff], 0
1000:3129  a1 0c 95         mov ax, word ptr [0x950c]
1000:312c  a3 28 95         mov word ptr [0x9528], ax
                            loc_1312f:
1000:312f  c3               ret 
                            sub_1309d ENDP
*/
void sub_1309d()
{
    // coverage: 0x329d-0x3330 method sub_1309d
    // coverage2: 1000:309d-1000:3130 method sub_1309d // ins(0x309d, 0x3130, 0x309d);
    bx = memoryAGet16(ds, 0x952a);
    bx += 0x0007;
    bx >>= 1;
    bx >>= 1;
    bx >>= 1;
    bx += 0x0002;
    memoryASet16(ds, 0x9547, memoryAGet16(ds, 0x9547) + bx);
    ax = memoryAGet16(ds, 0x950f);
    ax += bx;
    if (ax <= 0x02e8)
        goto loc_130c4;
    ax = 0x0000;
    memoryASet16(ds, 0x953c, 0xffff);
loc_130c4:
    memoryASet16(ds, 0x950f, ax);
    ax = memoryAGet16(ds, 0x9547);
    ax -= 0x0380;
    if ((short)ax >= 0)
        goto loc_13124;
    ax = -ax;
    if (ax >= 0x0100)
        goto loc_130ed;
    memoryASet16(ds, 0x9525, ax);
    al = memoryAGet(ds, 0x9524);
    if (al != 0x00)
        goto loc_130eb;
    si = 0x1912;
    sub_10b58();
    memoryASet(ds, 0x9524, 0x01);
loc_130eb:
    goto loc_13122;
loc_130ed:
    ax = memoryAGet16(ds, 0x9547);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    if (al == memoryAGet(ds, 0x9527))
        goto loc_13122;
    memoryASet(ds, 0x9527, al);
    bl = al;
    bh = 0x00;
    bx += memoryAGet16(ds, 0x94e2);
    al = memoryAGet(ds, bx);
    if (al == 0x00)
        goto loc_13122;
    si = 0x1ab2;
    memoryASet(ds, si + 1, al);
    ax = memoryAGet16(ds, 0x9547);
    memoryASet16(ds, si + 19, ax);
    sub_10b58();
loc_13122:
    return;
loc_13124:
    memoryASet(ds, 0x94ff, 0x00);
    ax = memoryAGet16(ds, 0x950c);
    memoryASet16(ds, 0x9528, ax);
}
/* Assembly listing of 1000:3130 sub_13130()
                            sub_13130 PROC
1000:3130  8a d8            mov bl, al
1000:3132  b7 00            mov bh, 0
1000:3134  8a 8f 6a 1a      mov cl, byte ptr [bx + 0x1a6a]
1000:3138  b5 00            mov ch, 0
1000:313a  8a 44 01         mov al, byte ptr [si + 1]
1000:313d  3c 01            cmp al, 1
1000:313f  74 1d            je loc_1315e
1000:3141  3c 02            cmp al, 2
1000:3143  74 22            je loc_13167
1000:3145  3c 03            cmp al, 3
1000:3147  74 27            je loc_13170
1000:3149  3c 04            cmp al, 4
1000:314b  74 2b            je loc_13178
1000:314d  3c 05            cmp al, 5
1000:314f  74 30            je loc_13181
1000:3151  3c 06            cmp al, 6
1000:3153  74 33            je loc_13188
1000:3155  3c 07            cmp al, 7
1000:3157  74 38            je loc_13191
1000:3159  3c 08            cmp al, 8
1000:315b  74 3e            je loc_1319b
1000:315d  c3               ret 
                            loc_1315e:
1000:315e  f7 d9            neg cx
1000:3160  83 c1 6a         add cx, 0x6a
1000:3163  89 4c 07         mov word ptr [si + 7], cx
1000:3166  c3               ret 
                            loc_13167:
1000:3167  51               push cx
1000:3168  e8 f3 ff         call 0x315e
1000:316b  59               pop cx
1000:316c  e8 01 00         call 0x3170
1000:316f  c3               ret 
                            loc_13170:
1000:3170  81 c1 80 00      add cx, 0x80
1000:3174  89 4c 05         mov word ptr [si + 5], cx
1000:3177  c3               ret 
                            loc_13178:
1000:3178  51               push cx
1000:3179  e8 f4 ff         call 0x3170
1000:317c  59               pop cx
1000:317d  e8 01 00         call 0x3181
1000:3180  c3               ret 
                            loc_13181:
1000:3181  83 c1 6a         add cx, 0x6a
1000:3184  89 4c 07         mov word ptr [si + 7], cx
1000:3187  c3               ret 
                            loc_13188:
1000:3188  51               push cx
1000:3189  e8 f5 ff         call 0x3181
1000:318c  59               pop cx
1000:318d  e8 01 00         call 0x3191
1000:3190  c3               ret 
                            loc_13191:
1000:3191  f7 d9            neg cx
1000:3193  81 c1 80 00      add cx, 0x80
1000:3197  89 4c 05         mov word ptr [si + 5], cx
1000:319a  c3               ret 
                            loc_1319b:
1000:319b  51               push cx
1000:319c  e8 f2 ff         call 0x3191
1000:319f  59               pop cx
1000:31a0  e8 bb ff         call 0x315e
1000:31a3  c3               ret 
                            sub_13130 ENDP
*/
void sub_13130()
{
    // coverage: 0x3330-0x33a4 method sub_13130
    // coverage2: 1000:3130-1000:31a4 method sub_13130 // ins(0x3130, 0x31a4, 0x3130);
    bl = al;
    bh = 0x00;
    cl = memoryAGet(ds, bx + 6762);
    ch = 0x00;
    al = memoryAGet(ds, si + 1);
    if (al == 0x01)
        goto loc_1315e;
    if (al == 0x02)
        goto loc_13167;
    if (al == 0x03)
        goto loc_13170;
    if (al == 0x04)
        goto loc_13178;
    if (al == 0x05)
        goto loc_13181;
    if (al == 0x06)
        goto loc_13188;
    if (al == 0x07)
        goto loc_13191;
    if (al == 0x08)
        goto loc_1319b;
    return;
loc_1315e:
    cx = -cx;
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
    return;
loc_13167:
    push(cx);
    sub_1315e();
    cx = pop();
    sub_13170();
    return;
loc_13170:
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
    return;
loc_13178:
    push(cx);
    sub_13170();
    cx = pop();
    sub_13181();
    return;
loc_13181:
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
    return;
loc_13188:
    push(cx);
    sub_13181();
    cx = pop();
    sub_13191();
    return;
loc_13191:
    cx = -cx;
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
    return;
loc_1319b:
    push(cx);
    sub_13191();
    cx = pop();
    sub_1315e();
}
/* Assembly listing of 1000:315e sub_1315e()
                            sub_1315e PROC
1000:315e  f7 d9            neg cx
1000:3160  83 c1 6a         add cx, 0x6a
1000:3163  89 4c 07         mov word ptr [si + 7], cx
1000:3166  c3               ret 
                            sub_1315e ENDP
*/
void sub_1315e()
{
    // coverage: 0x335e-0x3367 method sub_1315e
    // coverage2: 1000:315e-1000:3167 method sub_1315e // ins(0x315e, 0x3167, 0x315e);
    cx = -cx;
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
}
/* Assembly listing of 1000:3170 sub_13170()
                            sub_13170 PROC
1000:3170  81 c1 80 00      add cx, 0x80
1000:3174  89 4c 05         mov word ptr [si + 5], cx
1000:3177  c3               ret 
                            sub_13170 ENDP
*/
void sub_13170()
{
    // coverage: 0x3370-0x3378 method sub_13170
    // coverage2: 1000:3170-1000:3178 method sub_13170 // ins(0x3170, 0x3178, 0x3170);
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
}
/* Assembly listing of 1000:3181 sub_13181()
                            sub_13181 PROC
1000:3181  83 c1 6a         add cx, 0x6a
1000:3184  89 4c 07         mov word ptr [si + 7], cx
1000:3187  c3               ret 
                            sub_13181 ENDP
*/
void sub_13181()
{
    // coverage: 0x3381-0x3388 method sub_13181
    // coverage2: 1000:3181-1000:3188 method sub_13181 // ins(0x3181, 0x3188, 0x3181);
    cx += 0x006a;
    memoryASet16(ds, si + 7, cx);
}
/* Assembly listing of 1000:3191 sub_13191()
                            sub_13191 PROC
1000:3191  f7 d9            neg cx
1000:3193  81 c1 80 00      add cx, 0x80
1000:3197  89 4c 05         mov word ptr [si + 5], cx
1000:319a  c3               ret 
                            sub_13191 ENDP
*/
void sub_13191()
{
    // coverage: 0x3391-0x339b method sub_13191
    // coverage2: 1000:3191-1000:319b method sub_13191 // ins(0x3191, 0x319b, 0x3191);
    cx = -cx;
    cx += 0x0080;
    memoryASet16(ds, si + 5, cx);
}
/* Assembly listing of 1000:31a4 sub_131a4()
                            sub_131a4 PROC
1000:31a4  a1 f8 94         mov ax, word ptr [0x94f8]
1000:31a7  8e c0            mov es, ax
1000:31a9  bf 44 01         mov di, 0x144
1000:31ac  8b 1e f4 94      mov bx, word ptr [0x94f4]
1000:31b0  be 40 03         mov si, 0x340
1000:31b3  e8 31 00         call 0x31e7
1000:31b6  f7 d0            not ax
1000:31b8  25 0f 00         and ax, 0xf
1000:31bb  8a e0            mov ah, al
1000:31bd  b0 01            mov al, 1
1000:31bf  ba ce 03         mov dx, 0x3ce
1000:31c2  ef               out dx, ax
1000:31c3  e8 43 00         call 0x3209
1000:31c6  8a e0            mov ah, al
1000:31c8  b0 00            mov al, 0
1000:31ca  ef               out dx, ax
1000:31cb  1e               push ds
1000:31cc  8e db            mov ds, bx
1000:31ce  fc               cld 
1000:31cf  b9 a0 00         mov cx, 0xa0
                            loc_131d2:
1000:31d2  51               push cx
1000:31d3  b9 20 00         mov cx, 0x20
1000:31d6  f3 a4            rep movsb byte ptr es:[di], byte ptr [si]
1000:31d8  83 c7 08         add di, 8
1000:31db  59               pop cx
1000:31dc  e2 f4            loop loc_131d2
1000:31de  1f               pop ds
1000:31df  b8 00 00         mov ax, 0
1000:31e2  ef               out dx, ax
1000:31e3  fe c0            inc al
1000:31e5  ef               out dx, ax
1000:31e6  c3               ret 
                            sub_131a4 ENDP
*/
void sub_131a4()
{
    // coverage: 0x33a4-0x33e7 method sub_131a4
    // coverage2: 1000:31a4-1000:31e7 method sub_131a4 // ins(0x31a4, 0x31e7, 0x31a4);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0144;
    bx = memoryAGet16(ds, 0x94f4);
    si = 0x0340;
    sub_131e7();
    ax = ~ax;
    ax &= 0x000f;
    ah = al;
    al = 0x01;
    dx = 0x03ce;
    out(dx, ax);
    sub_13209();
    ah = al;
    al = 0x00;
    out(dx, ax);
    push(ds);
    ds = bx;
    flags.direction = false;
    cx = 0x00a0;
loc_131d2:
    push(cx);
    cx = 0x0020;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    di += 0x0008;
    cx = pop();
    if (--cx)
        goto loc_131d2;
    ds = pop();
    ax = 0x0000;
    out(dx, ax);
    al++;
    out(dx, ax);
}
/* Assembly listing of 1000:31e7 sub_131e7()
                            sub_131e7 PROC
1000:31e7  a0 1d 95         mov al, byte ptr [0x951d]
1000:31ea  3c 40            cmp al, 0x40
1000:31ec  75 05            jne loc_131f3
1000:31ee  b8 02 00         mov ax, 2
1000:31f1  eb 15            jmp loc_13208
                            loc_131f3:
1000:31f3  3c 80            cmp al, 0x80
1000:31f5  75 05            jne loc_131fc
1000:31f7  b8 04 00         mov ax, 4
1000:31fa  eb 0c            jmp loc_13208
                            loc_131fc:
1000:31fc  3c c0            cmp al, 0xc0
1000:31fe  75 05            jne loc_13205
1000:3200  b8 01 00         mov ax, 1
1000:3203  eb 03            jmp loc_13208
                            loc_13205:
1000:3205  b8 03 00         mov ax, 3
                            loc_13208:
1000:3208  c3               ret 
                            sub_131e7 ENDP
*/
void sub_131e7()
{
    // coverage: 0x33e7-0x3409 method sub_131e7
    // coverage2: 1000:31e7-1000:3209 method sub_131e7 // ins(0x31e7, 0x3209, 0x31e7);
    al = memoryAGet(ds, 0x951d);
    if (al != 0x40)
        goto loc_131f3;
    ax = 0x0002;
    return;
loc_131f3:
    if (al != 0x80)
        goto loc_131fc;
    ax = 0x0004;
    return;
loc_131fc:
    if (al != 0xc0)
        goto loc_13205;
    ax = 0x0001;
    return;
loc_13205:
    ax = 0x0003;
}
/* Assembly listing of 1000:3209 sub_13209()
                            sub_13209 PROC
1000:3209  a0 1c 95         mov al, byte ptr [0x951c]
1000:320c  3c 00            cmp al, 0
1000:320e  75 05            jne loc_13215
1000:3210  b8 00 00         mov ax, 0
1000:3213  eb 16            jmp loc_1322b
                            loc_13215:
1000:3215  3c 01            cmp al, 1
1000:3217  75 0a            jne loc_13223
1000:3219  b8 07 00         mov ax, 7
1000:321c  c6 06 1c 95 00   mov byte ptr [0x951c], 0
1000:3221  eb 08            jmp loc_1322b
                            loc_13223:
1000:3223  b8 0f 00         mov ax, 0xf
1000:3226  c6 06 1c 95 01   mov byte ptr [0x951c], 1
                            loc_1322b:
1000:322b  c3               ret 
                            sub_13209 ENDP
*/
void sub_13209()
{
    // coverage: 0x3409-0x342c method sub_13209
    // coverage2: 1000:3209-1000:322c method sub_13209 // ins(0x3209, 0x322c, 0x3209);
    al = memoryAGet(ds, 0x951c);
    if (al != 0x00)
        goto loc_13215;
    ax = 0x0000;
    return;
loc_13215:
    if (al != 0x01)
        goto loc_13223;
    ax = 0x0007;
    memoryASet(ds, 0x951c, 0x00);
    return;
loc_13223:
    ax = 0x000f;
    memoryASet(ds, 0x951c, 0x01);
}
/* Assembly listing of 1000:3291 sub_13291()
                            sub_13291 PROC
1000:3291  55               push bp
1000:3292  8b ec            mov bp, sp
1000:3294  8b 46 04         mov ax, word ptr [bp + 4]
1000:3297  8e c0            mov es, ax
1000:3299  bf 44 01         mov di, 0x144
1000:329c  8b 5e 06         mov bx, word ptr [bp + 6]
1000:329f  be 44 01         mov si, 0x144
1000:32a2  ba ce 03         mov dx, 0x3ce
1000:32a5  b8 05 01         mov ax, 0x105
1000:32a8  ef               out dx, ax
1000:32a9  1e               push ds
1000:32aa  8e db            mov ds, bx
1000:32ac  fc               cld 
1000:32ad  b9 a0 00         mov cx, 0xa0
                            loc_132b0:
1000:32b0  51               push cx
1000:32b1  b9 20 00         mov cx, 0x20
1000:32b4  f3 a4            rep movsb byte ptr es:[di], byte ptr [si]
1000:32b6  83 c6 08         add si, 8
1000:32b9  83 c7 08         add di, 8
1000:32bc  59               pop cx
1000:32bd  e2 f1            loop loc_132b0
1000:32bf  1f               pop ds
1000:32c0  b8 05 00         mov ax, 5
1000:32c3  ef               out dx, ax
1000:32c4  5d               pop bp
1000:32c5  c2 04 00         ret 4
                            sub_13291 ENDP
*/
void sub_13291()
{
    // coverage: 0x3491-0x34c8 method sub_13291
    // coverage2: 1000:3291-1000:32c8 method sub_13291 // ins(0x3291, 0x32c8, 0x3291);
    push(bp);
    bp = sp;
    ax = memoryAGet16(ss, bp + 4 - 2);
    es = ax;
    di = 0x0144;
    bx = memoryAGet16(ss, bp + 6 - 2);
    si = 0x0144;
    dx = 0x03ce;
    ax = 0x0105;
    out(dx, ax);
    push(ds);
    ds = bx;
    flags.direction = false;
    cx = 0x00a0;
loc_132b0:
    push(cx);
    cx = 0x0020;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    si += 0x0008;
    di += 0x0008;
    cx = pop();
    if (--cx)
        goto loc_132b0;
    ds = pop();
    ax = 0x0005;
    out(dx, ax);
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:32fe sub_132fe()
                            sub_132fe PROC
1000:32fe  ba ce 03         mov dx, 0x3ce
1000:3301  b8 05 01         mov ax, 0x105
1000:3304  ef               out dx, ax
1000:3305  a1 f8 94         mov ax, word ptr [0x94f8]
1000:3308  8e c0            mov es, ax
1000:330a  bf 44 01         mov di, 0x144
1000:330d  a1 28 95         mov ax, word ptr [0x9528]
1000:3310  d1 e0            shl ax, 1
1000:3312  d1 e0            shl ax, 1
1000:3314  d1 e0            shl ax, 1
1000:3316  d1 e0            shl ax, 1
1000:3318  d1 e0            shl ax, 1
1000:331a  8b f0            mov si, ax
1000:331c  1e               push ds
1000:331d  b8 00 a8         mov ax, 0xa800
1000:3320  8e d8            mov ds, ax
1000:3322  fc               cld 
1000:3323  b9 a0 00         mov cx, 0xa0
                            loc_13326:
1000:3326  51               push cx
1000:3327  b9 20 00         mov cx, 0x20
1000:332a  f3 a4            rep movsb byte ptr es:[di], byte ptr [si]
1000:332c  81 e6 ff 7f      and si, 0x7fff
1000:3330  83 c7 08         add di, 8
1000:3333  59               pop cx
1000:3334  e2 f0            loop loc_13326
1000:3336  1f               pop ds
1000:3337  b8 05 00         mov ax, 5
1000:333a  ef               out dx, ax
1000:333b  c3               ret 
                            sub_132fe ENDP
*/
void sub_132fe()
{
    // coverage: 0x34fe-0x353c method sub_132fe
    // coverage2: 1000:32fe-1000:333c method sub_132fe // ins(0x32fe, 0x333c, 0x32fe);
    dx = 0x03ce;
    ax = 0x0105;
    out(dx, ax);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0144;
    ax = memoryAGet16(ds, 0x9528);
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    si = ax;
    push(ds);
    ax = 0xa800;
    ds = ax;
    flags.direction = false;
    cx = 0x00a0;
loc_13326:
    push(cx);
    cx = 0x0020;
    rep_movsb<MemAuto, MemAuto, DirAuto>();
    si &= 0x7fff;
    di += 0x0008;
    cx = pop();
    if (--cx)
        goto loc_13326;
    ds = pop();
    ax = 0x0005;
    out(dx, ax);
}
/* Assembly listing of 1000:333c sub_1333c()
                            sub_1333c PROC
1000:333c  b8 0d 00         mov ax, 0xd
1000:333f  cd 10            int 0x10
1000:3341  b8 00 a0         mov ax, 0xa000
1000:3344  a3 fa 94         mov word ptr [0x94fa], ax
1000:3347  05 00 02         add ax, 0x200
1000:334a  a3 f8 94         mov word ptr [0x94f8], ax
1000:334d  b8 00 00         mov ax, 0
1000:3350  e8 60 00         call 0x33b3
1000:3353  a1 f8 94         mov ax, word ptr [0x94f8]
1000:3356  8b 1e fa 94      mov bx, word ptr [0x94fa]
1000:335a  89 1e f8 94      mov word ptr [0x94f8], bx
1000:335e  a3 fa 94         mov word ptr [0x94fa], ax
1000:3361  e8 73 00         call 0x33d7
1000:3364  8b 1e fa 94      mov bx, word ptr [0x94fa]
1000:3368  d1 e3            shl bx, 1
1000:336a  d1 e3            shl bx, 1
1000:336c  d1 e3            shl bx, 1
1000:336e  d1 e3            shl bx, 1
1000:3370  fa               cli 
1000:3371  ba d4 03         mov dx, 0x3d4
1000:3374  8a e7            mov ah, bh
1000:3376  b0 0c            mov al, 0xc
1000:3378  ef               out dx, ax
1000:3379  8a e3            mov ah, bl
1000:337b  fe c0            inc al
1000:337d  ef               out dx, ax
1000:337e  fb               sti 
1000:337f  e8 55 00         call 0x33d7
1000:3382  c3               ret 
                            sub_1333c ENDP
*/
void sub_1333c()
{
    // coverage: 0x353c-0x3583 method sub_1333c
    // coverage2: 1000:333c-1000:3383 method sub_1333c // ins(0x333c, 0x3383, 0x333c);
    ax = 0x000d;
    interrupt(0x10);
    ax = 0xa000;
    memoryASet16(ds, 0x94fa, ax);
    ax += 0x0200;
    memoryASet16(ds, 0x94f8, ax);
    ax = 0x0000;
    sub_133b3();
    ax = memoryAGet16(ds, 0x94f8);
    bx = memoryAGet16(ds, 0x94fa);
    memoryASet16(ds, 0x94f8, bx);
    memoryASet16(ds, 0x94fa, ax);
    sub_133d7();
    bx = memoryAGet16(ds, 0x94fa);
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    flags.interrupts = false;
    dx = 0x03d4;
    ah = bh;
    al = 0x0c;
    out(dx, ax);
    ah = bl;
    al++;
    out(dx, ax);
    flags.interrupts = true;
    sub_133d7();
}
/* Assembly listing of 1000:3383 sub_13383()
                            sub_13383 PROC
1000:3383  a1 f8 94         mov ax, word ptr [0x94f8]
1000:3386  8b 1e fa 94      mov bx, word ptr [0x94fa]
1000:338a  89 1e f8 94      mov word ptr [0x94f8], bx
1000:338e  a3 fa 94         mov word ptr [0x94fa], ax
1000:3391  8b 1e fa 94      mov bx, word ptr [0x94fa]
1000:3395  d1 e3            shl bx, 1
1000:3397  d1 e3            shl bx, 1
1000:3399  d1 e3            shl bx, 1
1000:339b  d1 e3            shl bx, 1
1000:339d  fa               cli 
1000:339e  ba d4 03         mov dx, 0x3d4
1000:33a1  8a e7            mov ah, bh
1000:33a3  b0 0c            mov al, 0xc
1000:33a5  ef               out dx, ax
1000:33a6  fb               sti 
1000:33a7  ba da 03         mov dx, 0x3da
                            loc_133aa:
1000:33aa  ec               in al, dx
1000:33ab  24 08            and al, 8
1000:33ad  75 fb            jne loc_133aa
1000:33af  e8 25 00         call 0x33d7
1000:33b2  c3               ret 
                            sub_13383 ENDP
*/
void sub_13383()
{
    // coverage: 0x3583-0x35b3 method sub_13383
    // coverage2: 1000:3383-1000:33b3 method sub_13383 // ins(0x3383, 0x33b3, 0x3383);
    ax = memoryAGet16(ds, 0x94f8);
    bx = memoryAGet16(ds, 0x94fa);
    memoryASet16(ds, 0x94f8, bx);
    memoryASet16(ds, 0x94fa, ax);
    bx = memoryAGet16(ds, 0x94fa);
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    bx <<= 1;
    flags.interrupts = false;
    dx = 0x03d4;
    ah = bh;
    al = 0x0c;
    out(dx, ax);
    flags.interrupts = true;
    dx = 0x03da;
loc_133aa:
    in(al, dx);
    al &= 0x08;
    if (al != 0)
        goto loc_133aa;
    sub_133d7();
}
/* Assembly listing of 1000:33b3 sub_133b3()
                            sub_133b3 PROC
1000:33b3  50               push ax
1000:33b4  a1 f8 94         mov ax, word ptr [0x94f8]
1000:33b7  8e c0            mov es, ax
1000:33b9  bf 00 00         mov di, 0
1000:33bc  ba ce 03         mov dx, 0x3ce
1000:33bf  58               pop ax
1000:33c0  8a e0            mov ah, al
1000:33c2  b0 00            mov al, 0
1000:33c4  ef               out dx, ax
1000:33c5  b8 01 0f         mov ax, 0xf01
1000:33c8  ef               out dx, ax
1000:33c9  fc               cld 
1000:33ca  b9 a0 0f         mov cx, 0xfa0
1000:33cd  f3 ab            rep stosw word ptr es:[di], ax
1000:33cf  b8 00 00         mov ax, 0
1000:33d2  ef               out dx, ax
1000:33d3  fe c0            inc al
1000:33d5  ef               out dx, ax
1000:33d6  c3               ret 
                            sub_133b3 ENDP
*/
void sub_133b3()
{
    // coverage: 0x35b3-0x35d7 method sub_133b3
    // coverage2: 1000:33b3-1000:33d7 method sub_133b3 // ins(0x33b3, 0x33d7, 0x33b3);
    push(ax);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0000;
    dx = 0x03ce;
    ax = pop();
    ah = al;
    al = 0x00;
    out(dx, ax);
    ax = 0x0f01;
    out(dx, ax);
    flags.direction = false;
    cx = 0x0fa0;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x0000;
    out(dx, ax);
    al++;
    out(dx, ax);
}
/* Assembly listing of 1000:33d7 sub_133d7()
                            sub_133d7 PROC
1000:33d7  ba da 03         mov dx, 0x3da
                            loc_133da:
1000:33da  ec               in al, dx
1000:33db  24 08            and al, 8
1000:33dd  74 fb            je loc_133da
                            loc_133df:
1000:33df  ec               in al, dx
1000:33e0  24 08            and al, 8
1000:33e2  75 fb            jne loc_133df
1000:33e4  c3               ret 
                            sub_133d7 ENDP
*/
void sub_133d7()
{
    // coverage: 0x35d7-0x35e5 method sub_133d7
    // coverage2: 1000:33d7-1000:33e5 method sub_133d7 // ins(0x33d7, 0x33e5, 0x33d7);
    dx = 0x03da;
loc_133da:
    in(al, dx);
    al &= 0x08;
    if (al == 0)
        goto loc_133da;
loc_133df:
    in(al, dx);
    al &= 0x08;
    if (al != 0)
        goto loc_133df;
}
/* Assembly listing of 1000:33e5 sub_133e5()
                            sub_133e5 PROC
1000:33e5  a1 f8 94         mov ax, word ptr [0x94f8]
1000:33e8  8e c0            mov es, ax
1000:33ea  bf 00 00         mov di, 0
1000:33ed  ba ce 03         mov dx, 0x3ce
1000:33f0  b8 05 08         mov ax, 0x805
1000:33f3  ef               out dx, ax
1000:33f4  b8 07 00         mov ax, 7
1000:33f7  ef               out dx, ax
1000:33f8  b2 c4            mov dl, 0xc4
1000:33fa  b8 02 08         mov ax, 0x802
1000:33fd  1e               push ds
1000:33fe  8e db            mov ds, bx
                            loc_13400:
1000:3400  ef               out dx, ax
1000:3401  50               push ax
1000:3402  57               push di
1000:3403  b9 40 1f         mov cx, 0x1f40
                            loc_13406:
1000:3406  ac               lodsb al, byte ptr [si]
1000:3407  26 20 05         and byte ptr es:[di], al
1000:340a  47               inc di
1000:340b  e2 f9            loop loc_13406
1000:340d  5f               pop di
1000:340e  58               pop ax
1000:340f  d0 ec            shr ah, 1
1000:3411  75 ed            jne loc_13400
1000:3413  1f               pop ds
1000:3414  b8 02 0f         mov ax, 0xf02
1000:3417  ef               out dx, ax
1000:3418  b2 ce            mov dl, 0xce
1000:341a  b8 05 00         mov ax, 5
1000:341d  ef               out dx, ax
1000:341e  b8 07 0f         mov ax, 0xf07
1000:3421  ef               out dx, ax
1000:3422  c3               ret 
                            sub_133e5 ENDP
*/
void sub_133e5()
{
    // coverage: 0x35e5-0x3623 method sub_133e5
    // coverage2: 1000:33e5-1000:3423 method sub_133e5 // ins(0x33e5, 0x3423, 0x33e5);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x0000;
    dx = 0x03ce;
    ax = 0x0805;
    out(dx, ax);
    ax = 0x0007;
    out(dx, ax);
    dl = 0xc4;
    ax = 0x0802;
    push(ds);
    ds = bx;
loc_13400:
    out(dx, ax);
    push(ax);
    push(di);
    cx = 0x1f40;
loc_13406:
    lodsb<MemAuto, DirAuto>();
    memoryASet(es, di, memoryAGet(es, di) & al);
    di++;
    if (--cx)
        goto loc_13406;
    di = pop();
    ax = pop();
    ah >>= 1;
    if (ah != 0)
        goto loc_13400;
    ds = pop();
    ax = 0x0f02;
    out(dx, ax);
    dl = 0xce;
    ax = 0x0005;
    out(dx, ax);
    ax = 0x0f07;
    out(dx, ax);
}
/* Assembly listing of 1000:3423 sub_13423()
                            sub_13423 PROC
1000:3423  b8 00 00         mov ax, 0
1000:3426  e8 8a ff         call 0x33b3
1000:3429  e8 0d 00         call 0x3439
1000:342c  e8 54 ff         call 0x3383
1000:342f  b8 00 00         mov ax, 0
1000:3432  e8 7e ff         call 0x33b3
1000:3435  e8 01 00         call 0x3439
1000:3438  c3               ret 
                            sub_13423 ENDP
*/
void sub_13423()
{
    // coverage: 0x3623-0x3639 method sub_13423
    // coverage2: 1000:3423-1000:3439 method sub_13423 // ins(0x3423, 0x3439, 0x3423);
    ax = 0x0000;
    sub_133b3();
    sub_13439();
    sub_13383();
    ax = 0x0000;
    sub_133b3();
    sub_13439();
}
/* Assembly listing of 1000:3439 sub_13439()
                            sub_13439 PROC
1000:3439  a1 f8 94         mov ax, word ptr [0x94f8]
1000:343c  8e c0            mov es, ax
1000:343e  bf 1c 01         mov di, 0x11c
1000:3441  b8 ff ff         mov ax, 0xffff
1000:3444  b9 10 00         mov cx, 0x10
1000:3447  f3 ab            rep stosw word ptr es:[di], ax
1000:3449  bf 44 1a         mov di, 0x1a44
1000:344c  b9 10 00         mov cx, 0x10
1000:344f  f3 ab            rep stosw word ptr es:[di], ax
1000:3451  bf 1b 01         mov di, 0x11b
1000:3454  b0 01            mov al, 1
1000:3456  b9 a2 00         mov cx, 0xa2
                            loc_13459:
1000:3459  26 88 05         mov byte ptr es:[di], al
1000:345c  83 c7 28         add di, 0x28
1000:345f  e2 f8            loop loc_13459
1000:3461  bf 3c 01         mov di, 0x13c
1000:3464  b0 80            mov al, 0x80
1000:3466  b9 a2 00         mov cx, 0xa2
                            loc_13469:
1000:3469  26 88 05         mov byte ptr es:[di], al
1000:346c  83 c7 28         add di, 0x28
1000:346f  e2 f8            loop loc_13469
1000:3471  c3               ret 
                            sub_13439 ENDP
*/
void sub_13439()
{
    // coverage: 0x3639-0x3672 method sub_13439
    // coverage2: 1000:3439-1000:3472 method sub_13439 // ins(0x3439, 0x3472, 0x3439);
    ax = memoryAGet16(ds, 0x94f8);
    es = ax;
    di = 0x011c;
    ax = 0xffff;
    cx = 0x0010;
    rep_stosw<MemAuto, DirAuto>();
    di = 0x1a44;
    cx = 0x0010;
    rep_stosw<MemAuto, DirAuto>();
    di = 0x011b;
    al = 0x01;
    cx = 0x00a2;
loc_13459:
    memoryASet(es, di, al);
    di += 0x0028;
    if (--cx)
        goto loc_13459;
    di = 0x013c;
    al = 0x80;
    cx = 0x00a2;
loc_13469:
    memoryASet(es, di, al);
    di += 0x0028;
    if (--cx)
        goto loc_13469;
}
/* Assembly listing of 1000:3472 sub_13472()
                            sub_13472 PROC
1000:3472  be 00 00         mov si, 0
1000:3475  8b 1e f2 94      mov bx, word ptr [0x94f2]
1000:3479  e8 69 ff         call 0x33e5
1000:347c  e8 04 ff         call 0x3383
1000:347f  be 00 00         mov si, 0
1000:3482  8b 1e f2 94      mov bx, word ptr [0x94f2]
1000:3486  e8 5c ff         call 0x33e5
1000:3489  a1 f8 94         mov ax, word ptr [0x94f8]
1000:348c  50               push ax
1000:348d  b8 00 a0         mov ax, 0xa000
1000:3490  05 00 04         add ax, 0x400
1000:3493  50               push ax
1000:3494  e8 fa fd         call 0x3291
1000:3497  c3               ret 
                            sub_13472 ENDP
*/
void sub_13472()
{
    // coverage: 0x3672-0x3698 method sub_13472
    // coverage2: 1000:3472-1000:3498 method sub_13472 // ins(0x3472, 0x3498, 0x3472);
    si = 0x0000;
    bx = memoryAGet16(ds, 0x94f2);
    sub_133e5();
    sub_13383();
    si = 0x0000;
    bx = memoryAGet16(ds, 0x94f2);
    sub_133e5();
    ax = memoryAGet16(ds, 0x94f8);
    push(ax);
    ax = 0xa000;
    ax += 0x0400;
    push(ax);
    sub_13291();
}
/* Assembly listing of 1000:3498 sub_13498()
                            sub_13498 PROC
1000:3498  b8 00 a0         mov ax, 0xa000
1000:349b  05 00 04         add ax, 0x400
1000:349e  50               push ax
1000:349f  a1 f8 94         mov ax, word ptr [0x94f8]
1000:34a2  50               push ax
1000:34a3  e8 eb fd         call 0x3291
1000:34a6  c3               ret 
                            sub_13498 ENDP
*/
void sub_13498()
{
    // coverage: 0x3698-0x36a7 method sub_13498
    // coverage2: 1000:3498-1000:34a7 method sub_13498 // ins(0x3498, 0x34a7, 0x3498);
    ax = 0xa000;
    ax += 0x0400;
    push(ax);
    ax = memoryAGet16(ds, 0x94f8);
    push(ax);
    sub_13291();
}
/* Assembly listing of 1000:34a8 sub_134a8()
                            sub_134a8 PROC
1000:34a8  bf 00 00         mov di, 0
1000:34ab  a1 f4 94         mov ax, word ptr [0x94f4]
1000:34ae  8e c0            mov es, ax
1000:34b0  b8 00 00         mov ax, 0
1000:34b3  b9 00 10         mov cx, 0x1000
1000:34b6  fc               cld 
1000:34b7  f3 ab            rep stosw word ptr es:[di], ax
1000:34b9  b8 4f 00         mov ax, 0x4f
1000:34bc  50               push ax
1000:34bd  b8 ff 00         mov ax, 0xff
1000:34c0  50               push ax
1000:34c1  b8 b0 00         mov ax, 0xb0
1000:34c4  50               push ax
1000:34c5  b8 00 00         mov ax, 0
1000:34c8  50               push ax
1000:34c9  e8 08 02         call 0x36d4
1000:34cc  b8 4f 00         mov ax, 0x4f
1000:34cf  50               push ax
1000:34d0  b8 00 00         mov ax, 0
1000:34d3  50               push ax
1000:34d4  b8 b0 00         mov ax, 0xb0
1000:34d7  50               push ax
1000:34d8  b8 ff 00         mov ax, 0xff
1000:34db  50               push ax
1000:34dc  e8 f5 01         call 0x36d4
1000:34df  b8 00 00         mov ax, 0
1000:34e2  50               push ax
1000:34e3  b8 4f 00         mov ax, 0x4f
1000:34e6  50               push ax
1000:34e7  b8 ff 00         mov ax, 0xff
1000:34ea  50               push ax
1000:34eb  b8 b0 00         mov ax, 0xb0
1000:34ee  50               push ax
1000:34ef  e8 e2 01         call 0x36d4
1000:34f2  b8 00 00         mov ax, 0
1000:34f5  50               push ax
1000:34f6  b8 b0 00         mov ax, 0xb0
1000:34f9  50               push ax
1000:34fa  b8 ff 00         mov ax, 0xff
1000:34fd  50               push ax
1000:34fe  b8 4f 00         mov ax, 0x4f
1000:3501  50               push ax
1000:3502  e8 cf 01         call 0x36d4
1000:3505  a1 47 95         mov ax, word ptr [0x9547]
1000:3508  25 3f 00         and ax, 0x3f
1000:350b  a3 4e 95         mov word ptr [0x954e], ax
1000:350e  8b d8            mov bx, ax
1000:3510  05 40 00         add ax, 0x40
1000:3513  50               push ax
1000:3514  8a 87 dc 1f      mov al, byte ptr [bx + 0x1fdc]
1000:3518  b4 00            mov ah, 0
1000:351a  50               push ax
1000:351b  e8 9e 00         call 0x35bc
1000:351e  a1 4e 95         mov ax, word ptr [0x954e]
1000:3521  3d 0c 00         cmp ax, 0xc
1000:3524  76 01            jbe loc_13527
1000:3526  c3               ret 
                            loc_13527:
1000:3527  8b 1e 4e 95      mov bx, word ptr [0x954e]
1000:352b  8a 87 1c 20      mov al, byte ptr [bx + 0x201c]
1000:352f  b4 00            mov ah, 0
1000:3531  05 80 00         add ax, 0x80
1000:3534  50               push ax
1000:3535  b8 00 00         mov ax, 0
1000:3538  50               push ax
1000:3539  b8 ff 00         mov ax, 0xff
1000:353c  50               push ax
1000:353d  8a 87 29 20      mov al, byte ptr [bx + 0x2029]
1000:3541  b4 00            mov ah, 0
1000:3543  f7 d8            neg ax
1000:3545  05 7f 00         add ax, 0x7f
1000:3548  50               push ax
1000:3549  e8 88 01         call 0x36d4
1000:354c  8b 1e 4e 95      mov bx, word ptr [0x954e]
1000:3550  8a 87 1c 20      mov al, byte ptr [bx + 0x201c]
1000:3554  b4 00            mov ah, 0
1000:3556  f7 d8            neg ax
1000:3558  05 7f 00         add ax, 0x7f
1000:355b  50               push ax
1000:355c  b8 00 00         mov ax, 0
1000:355f  50               push ax
1000:3560  b8 00 00         mov ax, 0
1000:3563  50               push ax
1000:3564  8a 87 29 20      mov al, byte ptr [bx + 0x2029]
1000:3568  b4 00            mov ah, 0
1000:356a  f7 d8            neg ax
1000:356c  05 7f 00         add ax, 0x7f
1000:356f  50               push ax
1000:3570  e8 61 01         call 0x36d4
1000:3573  8b 1e 4e 95      mov bx, word ptr [0x954e]
1000:3577  8a 87 1c 20      mov al, byte ptr [bx + 0x201c]
1000:357b  b4 00            mov ah, 0
1000:357d  05 80 00         add ax, 0x80
1000:3580  50               push ax
1000:3581  b8 ff 00         mov ax, 0xff
1000:3584  50               push ax
1000:3585  b8 ff 00         mov ax, 0xff
1000:3588  50               push ax
1000:3589  8a 87 29 20      mov al, byte ptr [bx + 0x2029]
1000:358d  b4 00            mov ah, 0
1000:358f  05 80 00         add ax, 0x80
1000:3592  50               push ax
1000:3593  e8 3e 01         call 0x36d4
1000:3596  8b 1e 4e 95      mov bx, word ptr [0x954e]
1000:359a  8a 87 1c 20      mov al, byte ptr [bx + 0x201c]
1000:359e  b4 00            mov ah, 0
1000:35a0  f7 d8            neg ax
1000:35a2  05 7f 00         add ax, 0x7f
1000:35a5  50               push ax
1000:35a6  b8 ff 00         mov ax, 0xff
1000:35a9  50               push ax
1000:35aa  b8 00 00         mov ax, 0
1000:35ad  50               push ax
1000:35ae  8a 87 29 20      mov al, byte ptr [bx + 0x2029]
1000:35b2  b4 00            mov ah, 0
1000:35b4  05 80 00         add ax, 0x80
1000:35b7  50               push ax
1000:35b8  e8 19 01         call 0x36d4
1000:35bb  c3               ret 
                            sub_134a8 ENDP
*/
void sub_134a8()
{
    // coverage: 0x36a8-0x37bc method sub_134a8
    // coverage2: 1000:34a8-1000:35bc method sub_134a8 // ins(0x34a8, 0x35bc, 0x34a8);
    di = 0x0000;
    ax = memoryAGet16(ds, 0x94f4);
    es = ax;
    ax = 0x0000;
    cx = 0x1000;
    flags.direction = false;
    rep_stosw<MemAuto, DirAuto>();
    ax = 0x004f;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x00b0;
    push(ax);
    ax = 0x0000;
    push(ax);
    sub_136d4();
    ax = 0x004f;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x00b0;
    push(ax);
    ax = 0x00ff;
    push(ax);
    sub_136d4();
    ax = 0x0000;
    push(ax);
    ax = 0x004f;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x00b0;
    push(ax);
    sub_136d4();
    ax = 0x0000;
    push(ax);
    ax = 0x00b0;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x004f;
    push(ax);
    sub_136d4();
    ax = memoryAGet16(ds, 0x9547);
    ax &= 0x003f;
    memoryASet16(ds, 0x954e, ax);
    bx = ax;
    ax += 0x0040;
    push(ax);
    al = memoryAGet(ds, bx + 8156);
    ah = 0x00;
    push(ax);
    sub_135bc();
    ax = memoryAGet16(ds, 0x954e);
    if (ax <= 0x000c)
        goto loc_13527;
    return;
loc_13527:
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x00ff;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    sub_136d4();
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    ax = 0x0000;
    push(ax);
    ax = 0x0000;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    sub_136d4();
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x00ff;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    sub_136d4();
    bx = memoryAGet16(ds, 0x954e);
    al = memoryAGet(ds, bx + 8220);
    ah = 0x00;
    ax = -ax;
    ax += 0x007f;
    push(ax);
    ax = 0x00ff;
    push(ax);
    ax = 0x0000;
    push(ax);
    al = memoryAGet(ds, bx + 8233);
    ah = 0x00;
    ax += 0x0080;
    push(ax);
    sub_136d4();
}
/* Assembly listing of 1000:35bc sub_135bc()
                            sub_135bc PROC
1000:35bc  55               push bp
1000:35bd  8b ec            mov bp, sp
                            loc_135bf:
1000:35bf  b8 7f 00         mov ax, 0x7f
1000:35c2  2b 46 04         sub ax, word ptr [bp + 4]
1000:35c5  50               push ax
1000:35c6  b8 7f 00         mov ax, 0x7f
1000:35c9  2b 46 06         sub ax, word ptr [bp + 6]
1000:35cc  50               push ax
1000:35cd  b8 80 00         mov ax, 0x80
1000:35d0  03 46 04         add ax, word ptr [bp + 4]
1000:35d3  50               push ax
1000:35d4  b8 7f 00         mov ax, 0x7f
1000:35d7  2b 46 06         sub ax, word ptr [bp + 6]
1000:35da  50               push ax
1000:35db  e8 f6 00         call 0x36d4
1000:35de  b8 80 00         mov ax, 0x80
1000:35e1  03 46 04         add ax, word ptr [bp + 4]
1000:35e4  50               push ax
1000:35e5  b8 7f 00         mov ax, 0x7f
1000:35e8  2b 46 06         sub ax, word ptr [bp + 6]
1000:35eb  50               push ax
1000:35ec  b8 80 00         mov ax, 0x80
1000:35ef  03 46 06         add ax, word ptr [bp + 6]
1000:35f2  50               push ax
1000:35f3  b8 7f 00         mov ax, 0x7f
1000:35f6  2b 46 04         sub ax, word ptr [bp + 4]
1000:35f9  50               push ax
1000:35fa  e8 d7 00         call 0x36d4
1000:35fd  b8 80 00         mov ax, 0x80
1000:3600  03 46 06         add ax, word ptr [bp + 6]
1000:3603  50               push ax
1000:3604  b8 7f 00         mov ax, 0x7f
1000:3607  2b 46 04         sub ax, word ptr [bp + 4]
1000:360a  50               push ax
1000:360b  b8 80 00         mov ax, 0x80
1000:360e  03 46 06         add ax, word ptr [bp + 6]
1000:3611  50               push ax
1000:3612  b8 80 00         mov ax, 0x80
1000:3615  03 46 04         add ax, word ptr [bp + 4]
1000:3618  50               push ax
1000:3619  e8 b8 00         call 0x36d4
1000:361c  b8 80 00         mov ax, 0x80
1000:361f  03 46 04         add ax, word ptr [bp + 4]
1000:3622  50               push ax
1000:3623  b8 80 00         mov ax, 0x80
1000:3626  03 46 06         add ax, word ptr [bp + 6]
1000:3629  50               push ax
1000:362a  b8 80 00         mov ax, 0x80
1000:362d  03 46 06         add ax, word ptr [bp + 6]
1000:3630  50               push ax
1000:3631  b8 80 00         mov ax, 0x80
1000:3634  03 46 04         add ax, word ptr [bp + 4]
1000:3637  50               push ax
1000:3638  e8 99 00         call 0x36d4
1000:363b  b8 7f 00         mov ax, 0x7f
1000:363e  2b 46 04         sub ax, word ptr [bp + 4]
1000:3641  50               push ax
1000:3642  b8 80 00         mov ax, 0x80
1000:3645  03 46 06         add ax, word ptr [bp + 6]
1000:3648  50               push ax
1000:3649  b8 80 00         mov ax, 0x80
1000:364c  03 46 04         add ax, word ptr [bp + 4]
1000:364f  50               push ax
1000:3650  b8 80 00         mov ax, 0x80
1000:3653  03 46 06         add ax, word ptr [bp + 6]
1000:3656  50               push ax
1000:3657  e8 7a 00         call 0x36d4
1000:365a  b8 7f 00         mov ax, 0x7f
1000:365d  2b 46 06         sub ax, word ptr [bp + 6]
1000:3660  50               push ax
1000:3661  b8 80 00         mov ax, 0x80
1000:3664  03 46 04         add ax, word ptr [bp + 4]
1000:3667  50               push ax
1000:3668  b8 7f 00         mov ax, 0x7f
1000:366b  2b 46 04         sub ax, word ptr [bp + 4]
1000:366e  50               push ax
1000:366f  b8 80 00         mov ax, 0x80
1000:3672  03 46 06         add ax, word ptr [bp + 6]
1000:3675  50               push ax
1000:3676  e8 5b 00         call 0x36d4
1000:3679  b8 7f 00         mov ax, 0x7f
1000:367c  2b 46 06         sub ax, word ptr [bp + 6]
1000:367f  50               push ax
1000:3680  b8 7f 00         mov ax, 0x7f
1000:3683  2b 46 04         sub ax, word ptr [bp + 4]
1000:3686  50               push ax
1000:3687  b8 7f 00         mov ax, 0x7f
1000:368a  2b 46 06         sub ax, word ptr [bp + 6]
1000:368d  50               push ax
1000:368e  b8 80 00         mov ax, 0x80
1000:3691  03 46 04         add ax, word ptr [bp + 4]
1000:3694  50               push ax
1000:3695  e8 3c 00         call 0x36d4
1000:3698  b8 7f 00         mov ax, 0x7f
1000:369b  2b 46 06         sub ax, word ptr [bp + 6]
1000:369e  50               push ax
1000:369f  b8 7f 00         mov ax, 0x7f
1000:36a2  2b 46 04         sub ax, word ptr [bp + 4]
1000:36a5  50               push ax
1000:36a6  b8 7f 00         mov ax, 0x7f
1000:36a9  2b 46 04         sub ax, word ptr [bp + 4]
1000:36ac  50               push ax
1000:36ad  b8 7f 00         mov ax, 0x7f
1000:36b0  2b 46 06         sub ax, word ptr [bp + 6]
1000:36b3  50               push ax
1000:36b4  e8 1d 00         call 0x36d4
1000:36b7  8b 46 06         mov ax, word ptr [bp + 6]
1000:36ba  d1 e8            shr ax, 1
1000:36bc  3a 06 49 95      cmp al, byte ptr [0x9549]
1000:36c0  76 0e            jbe loc_136d0
1000:36c2  89 46 06         mov word ptr [bp + 6], ax
1000:36c5  8b 46 04         mov ax, word ptr [bp + 4]
1000:36c8  d1 e8            shr ax, 1
1000:36ca  89 46 04         mov word ptr [bp + 4], ax
1000:36cd  e9 ef fe         jmp loc_135bf
                            loc_136d0:
1000:36d0  5d               pop bp
1000:36d1  c2 04 00         ret 4
                            sub_135bc ENDP
*/
void sub_135bc()
{
    // coverage: 0x37bc-0x38d4 method sub_135bc
    // coverage2: 1000:35bc-1000:36d4 method sub_135bc // ins(0x35bc, 0x36d4, 0x35bc);
    push(bp);
    bp = sp;
loc_135bf:
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x0080;
    ax += memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    sub_136d4();
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 4 - 2);
    push(ax);
    ax = 0x007f;
    ax -= memoryAGet16(ss, bp + 6 - 2);
    push(ax);
    sub_136d4();
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax >>= 1;
    if (al <= memoryAGet(ds, 0x9549))
        goto loc_136d0;
    memoryASet16(ss, bp + 6 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax >>= 1;
    memoryASet16(ss, bp + 4 - 2, ax);
    goto loc_135bf;
loc_136d0:
    bp = pop();
    sp += 4;
}
/* Assembly listing of 1000:36d4 sub_136d4()
                            sub_136d4 PROC
1000:36d4  55               push bp
1000:36d5  8b ec            mov bp, sp
1000:36d7  83 ec 0a         sub sp, 0xa
1000:36da  a1 f4 94         mov ax, word ptr [0x94f4]
1000:36dd  8e c0            mov es, ax
1000:36df  8b 46 08         mov ax, word ptr [bp + 8]
1000:36e2  3d 00 00         cmp ax, 0
1000:36e5  74 13            je loc_136fa
1000:36e7  8b d8            mov bx, ax
1000:36e9  d1 e0            shl ax, 1
1000:36eb  d1 e0            shl ax, 1
1000:36ed  03 c3            add ax, bx
1000:36ef  d1 e0            shl ax, 1
1000:36f1  05 05 00         add ax, 5
1000:36f4  b3 0c            mov bl, 0xc
1000:36f6  f6 f3            div bl
1000:36f8  b4 00            mov ah, 0
                            loc_136fa:
1000:36fa  89 46 08         mov word ptr [bp + 8], ax
1000:36fd  8b 46 04         mov ax, word ptr [bp + 4]
1000:3700  3d 00 00         cmp ax, 0
1000:3703  74 13            je loc_13718
1000:3705  8b d8            mov bx, ax
1000:3707  d1 e0            shl ax, 1
1000:3709  d1 e0            shl ax, 1
1000:370b  03 c3            add ax, bx
1000:370d  d1 e0            shl ax, 1
1000:370f  05 05 00         add ax, 5
1000:3712  b3 0c            mov bl, 0xc
1000:3714  f6 f3            div bl
1000:3716  b4 00            mov ah, 0
                            loc_13718:
1000:3718  89 46 04         mov word ptr [bp + 4], ax
1000:371b  8b 46 0a         mov ax, word ptr [bp + 0xa]
1000:371e  8b 5e 06         mov bx, word ptr [bp + 6]
1000:3721  3b d8            cmp bx, ax
1000:3723  73 12            jae loc_13737
1000:3725  89 5e 0a         mov word ptr [bp + 0xa], bx
1000:3728  89 46 06         mov word ptr [bp + 6], ax
1000:372b  8b 46 08         mov ax, word ptr [bp + 8]
1000:372e  8b 5e 04         mov bx, word ptr [bp + 4]
1000:3731  89 5e 08         mov word ptr [bp + 8], bx
1000:3734  89 46 04         mov word ptr [bp + 4], ax
                            loc_13737:
1000:3737  8b 46 06         mov ax, word ptr [bp + 6]
1000:373a  2b 46 0a         sub ax, word ptr [bp + 0xa]
1000:373d  89 46 fe         mov word ptr [bp - 2], ax
1000:3740  8b 46 04         mov ax, word ptr [bp + 4]
1000:3743  2b 46 08         sub ax, word ptr [bp + 8]
1000:3746  79 09            jns loc_13751
1000:3748  f7 d8            neg ax
1000:374a  c7 46 f6 e0 ff   mov word ptr [bp - 0xa], 0xffe0
1000:374f  eb 05            jmp loc_13756
                            loc_13751:
1000:3751  c7 46 f6 20 00   mov word ptr [bp - 0xa], 0x20
                            loc_13756:
1000:3756  89 46 fc         mov word ptr [bp - 4], ax
1000:3759  8b 4e fe         mov cx, word ptr [bp - 2]
1000:375c  83 f9 00         cmp cx, 0
1000:375f  74 7a            je loc_137db
1000:3761  3d 00 00         cmp ax, 0
1000:3764  75 03            jne loc_13769
1000:3766  e9 84 00         jmp loc_137ed
                            loc_13769:
1000:3769  3b 46 fe         cmp ax, word ptr [bp - 2]
1000:376c  73 36            jae loc_137a4
1000:376e  8b 46 fe         mov ax, word ptr [bp - 2]
1000:3771  d1 e8            shr ax, 1
1000:3773  89 46 fa         mov word ptr [bp - 6], ax
1000:3776  e8 88 00         call 0x3801
1000:3779  8b 4e fe         mov cx, word ptr [bp - 2]
                            loc_1377c:
1000:377c  d0 e8            shr al, 1
1000:377e  75 03            jne loc_13783
1000:3780  b0 80            mov al, 0x80
1000:3782  47               inc di
                            loc_13783:
1000:3783  8b 5e fa         mov bx, word ptr [bp - 6]
1000:3786  03 5e fc         add bx, word ptr [bp - 4]
1000:3789  89 5e fa         mov word ptr [bp - 6], bx
1000:378c  3b 5e fe         cmp bx, word ptr [bp - 2]
1000:378f  76 0c            jbe loc_1379d
1000:3791  2b 5e fe         sub bx, word ptr [bp - 2]
1000:3794  89 5e fa         mov word ptr [bp - 6], bx
1000:3797  8b 5e f6         mov bx, word ptr [bp - 0xa]
1000:379a  03 7e f6         add di, word ptr [bp - 0xa]
                            loc_1379d:
1000:379d  26 08 05         or byte ptr es:[di], al
1000:37a0  e2 da            loop loc_1377c
1000:37a2  eb 31            jmp loc_137d5
                            loc_137a4:
1000:37a4  8b 46 fc         mov ax, word ptr [bp - 4]
1000:37a7  d1 e8            shr ax, 1
1000:37a9  89 46 fa         mov word ptr [bp - 6], ax
1000:37ac  e8 52 00         call 0x3801
1000:37af  8b 4e fc         mov cx, word ptr [bp - 4]
                            loc_137b2:
1000:37b2  03 7e f6         add di, word ptr [bp - 0xa]
1000:37b5  8b 5e fa         mov bx, word ptr [bp - 6]
1000:37b8  03 5e fe         add bx, word ptr [bp - 2]
1000:37bb  89 5e fa         mov word ptr [bp - 6], bx
1000:37be  3b 5e fc         cmp bx, word ptr [bp - 4]
1000:37c1  76 0d            jbe loc_137d0
1000:37c3  2b 5e fc         sub bx, word ptr [bp - 4]
1000:37c6  89 5e fa         mov word ptr [bp - 6], bx
1000:37c9  d0 e8            shr al, 1
1000:37cb  75 03            jne loc_137d0
1000:37cd  b0 80            mov al, 0x80
1000:37cf  47               inc di
                            loc_137d0:
1000:37d0  26 08 05         or byte ptr es:[di], al
1000:37d3  e2 dd            loop loc_137b2
                            loc_137d5:
1000:37d5  8b e5            mov sp, bp
1000:37d7  5d               pop bp
1000:37d8  c2 08 00         ret 8
                            loc_137db:
1000:37db  e8 23 00         call 0x3801
1000:37de  8b 4e fc         mov cx, word ptr [bp - 4]
1000:37e1  e3 f2            jcxz loc_137d5
                            loc_137e3:
1000:37e3  03 7e f6         add di, word ptr [bp - 0xa]
1000:37e6  26 08 05         or byte ptr es:[di], al
1000:37e9  e2 f8            loop loc_137e3
1000:37eb  eb e8            jmp loc_137d5
                            loc_137ed:
1000:37ed  e8 11 00         call 0x3801
1000:37f0  8b 4e fe         mov cx, word ptr [bp - 2]
                            loc_137f3:
1000:37f3  d0 e8            shr al, 1
1000:37f5  75 03            jne loc_137fa
1000:37f7  b0 80            mov al, 0x80
1000:37f9  47               inc di
                            loc_137fa:
1000:37fa  26 08 05         or byte ptr es:[di], al
1000:37fd  e2 f4            loop loc_137f3
1000:37ff  eb d4            jmp loc_137d5
                            sub_136d4 ENDP
*/
void sub_136d4()
{
    // coverage: 0x38d4-0x3a01 method sub_136d4
    // coverage2: 1000:36d4-1000:3801 method sub_136d4 // ins(0x36d4, 0x3801, 0x36d4);
    push(bp);
    bp = sp;
    sp -= 0x000a;
    ax = memoryAGet16(ds, 0x94f4);
    es = ax;
    ax = memoryAGet16(ss, bp + 8 - 2);
    if (ax == 0x0000)
        goto loc_136fa;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_136fa:
    memoryASet16(ss, bp + 8 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    if (ax == 0x0000)
        goto loc_13718;
    bx = ax;
    ax <<= 1;
    ax <<= 1;
    ax += bx;
    ax <<= 1;
    ax += 0x0005;
    bl = 0x0c;
    div(bl);
    ah = 0x00;
loc_13718:
    memoryASet16(ss, bp + 4 - 2, ax);
    ax = memoryAGet16(ss, bp + 10 - 2);
    bx = memoryAGet16(ss, bp + 6 - 2);
    if (bx >= ax)
        goto loc_13737;
    memoryASet16(ss, bp + 10 - 2, bx);
    memoryASet16(ss, bp + 6 - 2, ax);
    ax = memoryAGet16(ss, bp + 8 - 2);
    bx = memoryAGet16(ss, bp + 4 - 2);
    memoryASet16(ss, bp + 8 - 2, bx);
    memoryASet16(ss, bp + 4 - 2, ax);
loc_13737:
    ax = memoryAGet16(ss, bp + 6 - 2);
    ax -= memoryAGet16(ss, bp + 10 - 2);
    memoryASet16(ss, bp - 2 - 2, ax);
    ax = memoryAGet16(ss, bp + 4 - 2);
    ax -= memoryAGet16(ss, bp + 8 - 2);
    if ((short)ax >= 0)
        goto loc_13751;
    ax = -ax;
    memoryASet16(ss, bp - 10 - 2, 0xffe0);
    goto loc_13756;
loc_13751:
    memoryASet16(ss, bp - 10 - 2, 0x0020);
loc_13756:
    memoryASet16(ss, bp - 4 - 2, ax);
    cx = memoryAGet16(ss, bp - 2 - 2);
    if (cx == 0x0000)
        goto loc_137db;
    if (ax != 0x0000)
        goto loc_13769;
    goto loc_137ed;
loc_13769:
    if (ax >= memoryAGet16(ss, bp - 2 - 2))
        goto loc_137a4;
    ax = memoryAGet16(ss, bp - 2 - 2);
    ax >>= 1;
    memoryASet16(ss, bp - 6 - 2, ax);
    sub_13801();
    cx = memoryAGet16(ss, bp - 2 - 2);
loc_1377c:
    al >>= 1;
    if (al != 0)
        goto loc_13783;
    al = 0x80;
    di++;
loc_13783:
    bx = memoryAGet16(ss, bp - 6 - 2);
    bx += memoryAGet16(ss, bp - 4 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    if (bx <= memoryAGet16(ss, bp - 2 - 2))
        goto loc_1379d;
    bx -= memoryAGet16(ss, bp - 2 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    bx = memoryAGet16(ss, bp - 10 - 2);
    di += memoryAGet16(ss, bp - 10 - 2);
loc_1379d:
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_1377c;
    goto loc_137d5;
loc_137a4:
    ax = memoryAGet16(ss, bp - 4 - 2);
    ax >>= 1;
    memoryASet16(ss, bp - 6 - 2, ax);
    sub_13801();
    cx = memoryAGet16(ss, bp - 4 - 2);
loc_137b2:
    di += memoryAGet16(ss, bp - 10 - 2);
    bx = memoryAGet16(ss, bp - 6 - 2);
    bx += memoryAGet16(ss, bp - 2 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    if (bx <= memoryAGet16(ss, bp - 4 - 2))
        goto loc_137d0;
    bx -= memoryAGet16(ss, bp - 4 - 2);
    memoryASet16(ss, bp - 6 - 2, bx);
    al >>= 1;
    if (al != 0)
        goto loc_137d0;
    al = 0x80;
    di++;
loc_137d0:
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_137b2;
loc_137d5:
    sp = bp;
    bp = pop();
    sp += 8;
    return;
loc_137db:
    sub_13801();
    cx = memoryAGet16(ss, bp - 4 - 2);
    if (cx == 0)
        goto loc_137d5;
loc_137e3:
    di += memoryAGet16(ss, bp - 10 - 2);
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_137e3;
    goto loc_137d5;
loc_137ed:
    sub_13801();
    cx = memoryAGet16(ss, bp - 2 - 2);
loc_137f3:
    al >>= 1;
    if (al != 0)
        goto loc_137fa;
    al = 0x80;
    di++;
loc_137fa:
    memoryASet(es, di, memoryAGet(es, di) | al);
    if (--cx)
        goto loc_137f3;
    goto loc_137d5;
}
/* Assembly listing of 1000:3801 sub_13801()
                            sub_13801 PROC
1000:3801  8b 46 08         mov ax, word ptr [bp + 8]
1000:3804  d1 e0            shl ax, 1
1000:3806  d1 e0            shl ax, 1
1000:3808  d1 e0            shl ax, 1
1000:380a  d1 e0            shl ax, 1
1000:380c  d1 e0            shl ax, 1
1000:380e  8b f8            mov di, ax
1000:3810  8b 46 0a         mov ax, word ptr [bp + 0xa]
1000:3813  d1 e8            shr ax, 1
1000:3815  d1 e8            shr ax, 1
1000:3817  d1 e8            shr ax, 1
1000:3819  03 f8            add di, ax
1000:381b  8b 4e 0a         mov cx, word ptr [bp + 0xa]
1000:381e  83 e1 07         and cx, 7
1000:3821  b0 80            mov al, 0x80
1000:3823  d2 e8            shr al, cl
1000:3825  26 08 05         or byte ptr es:[di], al
1000:3828  c3               ret 
                            sub_13801 ENDP
*/
void sub_13801()
{
    // coverage: 0x3a01-0x3a29 method sub_13801
    // coverage2: 1000:3801-1000:3829 method sub_13801 // ins(0x3801, 0x3829, 0x3801);
    ax = memoryAGet16(ss, bp + 8 - 2);
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    ax <<= 1;
    di = ax;
    ax = memoryAGet16(ss, bp + 10 - 2);
    ax >>= 1;
    ax >>= 1;
    ax >>= 1;
    di += ax;
    cx = memoryAGet16(ss, bp + 10 - 2);
    cx &= 0x0007;
    al = 0x80;
    al >>= cl;
    memoryASet(es, di, memoryAGet(es, di) | al);
}
/* Assembly listing of 1000:382a sub_1382a()
                            sub_1382a PROC
1000:382a  b0 00            mov al, 0
1000:382c  a2 50 95         mov byte ptr [0x9550], al
1000:382f  a2 51 95         mov byte ptr [0x9551], al
1000:3832  a2 52 95         mov byte ptr [0x9552], al
1000:3835  c6 06 06 95 01   mov byte ptr [0x9506], 1
1000:383a  c6 06 05 95 00   mov byte ptr [0x9505], 0
1000:383f  c3               ret 
                            sub_1382a ENDP
*/
void sub_1382a()
{
    // coverage: 0x3a2a-0x3a40 method sub_1382a
    // coverage2: 1000:382a-1000:3840 method sub_1382a // ins(0x382a, 0x3840, 0x382a);
    al = 0x00;
    memoryASet(ds, 0x9550, al);
    memoryASet(ds, 0x9551, al);
    memoryASet(ds, 0x9552, al);
    memoryASet(ds, 0x9506, 0x01);
    memoryASet(ds, 0x9505, 0x00);
}
/* Assembly listing of 1000:3840 sub_13840()
                            sub_13840 PROC
1000:3840  8a 26 5e 95      mov ah, byte ptr [0x955e]
1000:3844  80 fc 00         cmp ah, 0
1000:3847  74 01            je loc_1384a
1000:3849  c3               ret 
                            loc_1384a:
1000:384a  8a 26 06 95      mov ah, byte ptr [0x9506]
1000:384e  80 fc 00         cmp ah, 0
1000:3851  75 01            jne loc_13854
1000:3853  c3               ret 
                            loc_13854:
1000:3854  8a 26 50 95      mov ah, byte ptr [0x9550]
1000:3858  80 fc 00         cmp ah, 0
1000:385b  75 09            jne loc_13866
1000:385d  53               push bx
1000:385e  a2 50 95         mov byte ptr [0x9550], al
1000:3861  e8 b0 00         call 0x3914
1000:3864  5b               pop bx
1000:3865  c3               ret 
                            loc_13866:
1000:3866  8a 26 51 95      mov ah, byte ptr [0x9551]
1000:386a  80 fc 00         cmp ah, 0
1000:386d  75 04            jne loc_13873
1000:386f  a2 51 95         mov byte ptr [0x9551], al
1000:3872  c3               ret 
                            loc_13873:
1000:3873  3a 06 52 95      cmp al, byte ptr [0x9552]
1000:3877  76 03            jbe loc_1387c
1000:3879  a2 52 95         mov byte ptr [0x9552], al
                            loc_1387c:
1000:387c  c3               ret 
                            sub_13840 ENDP
*/
void sub_13840()
{
    // coverage: 0x3a40-0x3a7d method sub_13840
    // coverage2: 1000:3840-1000:387d method sub_13840 // ins(0x3840, 0x387d, 0x3840);
    ah = memoryAGet(ds, 0x955e);
    if (ah == 0x00)
        goto loc_1384a;
    return;
loc_1384a:
    ah = memoryAGet(ds, 0x9506);
    if (ah != 0x00)
        goto loc_13854;
    return;
loc_13854:
    ah = memoryAGet(ds, 0x9550);
    if (ah != 0x00)
        goto loc_13866;
    push(bx);
    memoryASet(ds, 0x9550, al);
    sub_13914();
    bx = pop();
    return;
loc_13866:
    ah = memoryAGet(ds, 0x9551);
    if (ah != 0x00)
        goto loc_13873;
    memoryASet(ds, 0x9551, al);
    return;
loc_13873:
    if (al <= memoryAGet(ds, 0x9552))
        return;
    memoryASet(ds, 0x9552, al);
}
/* Assembly listing of 1000:3914 sub_13914()
                            sub_13914 PROC
1000:3914  fe c8            dec al
1000:3916  8a d8            mov bl, al
1000:3918  b7 00            mov bh, 0
1000:391a  d1 e3            shl bx, 1
1000:391c  8b 9f e4 8b      mov bx, word ptr [bx - 0x741c]
1000:3920  8a 47 01         mov al, byte ptr [bx + 1]
1000:3923  a2 57 95         mov byte ptr [0x9557], al
1000:3926  81 fb 2c 8c      cmp bx, 0x8c2c
1000:392a  75 15            jne loc_13941
1000:392c  a1 36 95         mov ax, word ptr [0x9536]
1000:392f  8a e0            mov ah, al
1000:3931  b0 00            mov al, 0
1000:3933  d1 e0            shl ax, 1
1000:3935  d1 e0            shl ax, 1
1000:3937  f7 d8            neg ax
1000:3939  05 40 1f         add ax, 0x1f40
1000:393c  a3 2e 8c         mov word ptr [0x8c2e], ax
1000:393f  eb 25            jmp loc_13966
                            loc_13941:
1000:3941  81 fb 32 8c      cmp bx, 0x8c32
1000:3945  75 1f            jne loc_13966
1000:3947  a0 a0 1b         mov al, byte ptr [0x1ba0]
1000:394a  25 7f 00         and ax, 0x7f
1000:394d  3d 3f 00         cmp ax, 0x3f
1000:3950  76 05            jbe loc_13957
1000:3952  2d 40 00         sub ax, 0x40
1000:3955  eb 05            jmp loc_1395c
                            loc_13957:
1000:3957  f7 d8            neg ax
1000:3959  05 3f 00         add ax, 0x3f
                            loc_1395c:
1000:395c  d1 e0            shl ax, 1
1000:395e  d1 e0            shl ax, 1
1000:3960  05 90 01         add ax, 0x190
1000:3963  a3 34 8c         mov word ptr [0x8c34], ax
                            loc_13966:
1000:3966  8b 47 02         mov ax, word ptr [bx + 2]
1000:3969  a3 58 95         mov word ptr [0x9558], ax
1000:396c  8b 47 04         mov ax, word ptr [bx + 4]
1000:396f  a3 5a 95         mov word ptr [0x955a], ax
1000:3972  8a 1f            mov bl, byte ptr [bx]
1000:3974  88 1e 53 95      mov byte ptr [0x9553], bl
1000:3978  80 fb 00         cmp bl, 0
1000:397b  7e 12            jle loc_1398f
1000:397d  fe cb            dec bl
1000:397f  b7 00            mov bh, 0
1000:3981  d1 e3            shl bx, 1
1000:3983  8b 87 5c 8c      mov ax, word ptr [bx - 0x73a4]
1000:3987  a3 55 95         mov word ptr [0x9555], ax
1000:398a  c6 06 54 95 00   mov byte ptr [0x9554], 0
                            loc_1398f:
1000:398f  b0 b6            mov al, 0xb6
1000:3991  e6 43            out 0x43, al
1000:3993  a1 58 95         mov ax, word ptr [0x9558]
1000:3996  e6 42            out 0x42, al
1000:3998  8a c4            mov al, ah
1000:399a  e6 42            out 0x42, al
1000:399c  e4 61            in al, 0x61
1000:399e  0c 03            or al, 3
1000:39a0  e6 61            out 0x61, al
1000:39a2  c3               ret 
                            sub_13914 ENDP
*/
void sub_13914()
{
    // coverage: 0x3b14-0x3ba3 method sub_13914
    // coverage2: 1000:3914-1000:39a3 method sub_13914 // ins(0x3914, 0x39a3, 0x3914);
    al--;
    bl = al;
    bh = 0x00;
    bx <<= 1;
    bx = memoryAGet16(ds, bx + 35812);
    al = memoryAGet(ds, bx + 1);
    memoryASet(ds, 0x9557, al);
    if (bx != 0x8c2c)
        goto loc_13941;
    ax = memoryAGet16(ds, 0x9536);
    ah = al;
    al = 0x00;
    ax <<= 1;
    ax <<= 1;
    ax = -ax;
    ax += 0x1f40;
    memoryASet16(ds, 0x8c2e, ax);
    goto loc_13966;
loc_13941:
    if (bx != 0x8c32)
        goto loc_13966;
    al = memoryAGet(ds, 0x1ba0);
    ax &= 0x007f;
    if (ax <= 0x003f)
        goto loc_13957;
    ax -= 0x0040;
    goto loc_1395c;
loc_13957:
    ax = -ax;
    ax += 0x003f;
loc_1395c:
    ax <<= 1;
    ax <<= 1;
    ax += 0x0190;
    memoryASet16(ds, 0x8c34, ax);
loc_13966:
    ax = memoryAGet16(ds, bx + 2);
    memoryASet16(ds, 0x9558, ax);
    ax = memoryAGet16(ds, bx + 4);
    memoryASet16(ds, 0x955a, ax);
    bl = memoryAGet(ds, bx);
    memoryASet(ds, 0x9553, bl);
    if ((char)bl <= (char)0x00)
        goto loc_1398f;
    bl--;
    bh = 0x00;
    bx <<= 1;
    ax = memoryAGet16(ds, bx + 35932);
    memoryASet16(ds, 0x9555, ax);
    memoryASet(ds, 0x9554, 0x00);
loc_1398f:
    al = 0xb6;
    out(0x43, al);
    ax = memoryAGet16(ds, 0x9558);
    out(0x42, al);
    al = ah;
    out(0x42, al);
    in(al, 0x61);
    al |= 0x03;
    out(0x61, al);
}
/* Assembly listing of 1000:39a3 sub_139a3()
                            sub_139a3 PROC
1000:39a3  b0 00            mov al, 0
1000:39a5  a2 50 95         mov byte ptr [0x9550], al
1000:39a8  a2 51 95         mov byte ptr [0x9551], al
1000:39ab  a2 52 95         mov byte ptr [0x9552], al
1000:39ae  a2 57 95         mov byte ptr [0x9557], al
1000:39b1  e4 61            in al, 0x61
1000:39b3  24 fc            and al, 0xfc
1000:39b5  e6 61            out 0x61, al
1000:39b7  c3               ret 
                            sub_139a3 ENDP
*/
void sub_139a3()
{
    // coverage: 0x3ba3-0x3bb8 method sub_139a3
    // coverage2: 1000:39a3-1000:39b8 method sub_139a3 // ins(0x39a3, 0x39b8, 0x39a3);
    al = 0x00;
    memoryASet(ds, 0x9550, al);
    memoryASet(ds, 0x9551, al);
    memoryASet(ds, 0x9552, al);
    memoryASet(ds, 0x9557, al);
    in(al, 0x61);
    al &= 0xfc;
    out(0x61, al);
}
/* Assembly listing of 1000:39b8 sub_139b8()
                            sub_139b8 PROC
1000:39b8  c6 06 61 95 00   mov byte ptr [0x9561], 0
1000:39bd  c7 06 5f 95 00 00  mov word ptr [0x955f], 0
1000:39c3  c6 06 5e 95 01   mov byte ptr [0x955e], 1
1000:39c8  a0 46 95         mov al, byte ptr [0x9546]
1000:39cb  3c 00            cmp al, 0
1000:39cd  75 05            jne loc_139d4
1000:39cf  b8 ec 8d         mov ax, 0x8dec
1000:39d2  eb 03            jmp loc_139d7
                            loc_139d4:
1000:39d4  b8 4c 8d         mov ax, 0x8d4c
                            loc_139d7:
1000:39d7  a3 62 95         mov word ptr [0x9562], ax
1000:39da  c3               ret 
                            sub_139b8 ENDP
*/
void sub_139b8()
{
    // coverage: 0x3bb8-0x3bdb method sub_139b8
    // coverage2: 1000:39b8-1000:39db method sub_139b8 // ins(0x39b8, 0x39db, 0x39b8);
    memoryASet(ds, 0x9561, 0x00);
    memoryASet16(ds, 0x955f, 0x0000);
    memoryASet(ds, 0x955e, 0x01);
    al = memoryAGet(ds, 0x9546);
    if (al != 0x00)
        goto loc_139d4;
    ax = 0x8dec;
    goto loc_139d7;
loc_139d4:
    ax = 0x8d4c;
loc_139d7:
    memoryASet16(ds, 0x9562, ax);
}
// tree: children of sub_10010 1000:0010+sync: sub_100a9 1000:00a9+sync, sub_100cf 1000:00cf+sync, sub_100fd 1000:00fd, sub_10442 1000:0442, sub_10588 1000:0588, sub_10591 1000:0591, sub_105ec 1000:05ec, sub_10600 1000:0600, sub_12762 1000:2762, sub_1333c 1000:333c+sync, sub_1382a 1000:382a, 
// tree: children of sub_100a9 1000:00a9+sync: sub_10103 1000:0103+sync, sub_10da7 1000:0da7, sub_121dc 1000:21dc, sub_13423 1000:3423+sync, 
// tree: children of sub_100cf 1000:00cf+sync: sub_101c0 1000:01c0+sync, sub_10b8e 1000:0b8e, sub_10fda 1000:0fda, sub_1220d 1000:220d, sub_131a4 1000:31a4, sub_132fe 1000:32fe, sub_13383 1000:3383+sync, sub_134a8 1000:34a8, 
// tree: children of sub_10103 1000:0103+sync: sub_1019d 1000:019d, sub_101ad 1000:01ad+sync, sub_101c0 1000:01c0+sync, sub_10b8e 1000:0b8e, sub_10d98 1000:0d98, sub_10fda 1000:0fda, sub_1279f 1000:279f, sub_128da 1000:28da, sub_129db 1000:29db+sync, sub_13383 1000:3383+sync, sub_13472 1000:3472+sync, sub_13498 1000:3498, sub_139b8 1000:39b8, 
// tree: children of sub_1019d 1000:019d: sub_10b58 1000:0b58, sub_12121 1000:2121, 
// tree: children of sub_101ad 1000:01ad+sync: sub_101c0 1000:01c0+sync, 
// tree: children of sub_101c0 1000:01c0+sync: sub_10103 1000:0103+sync, sub_1033b 1000:033b, sub_104a5 1000:04a5, sub_10529 1000:0529, sub_105bc 1000:05bc, sub_10da7 1000:0da7, sub_121dc 1000:21dc, sub_12c45 1000:2c45, sub_13423 1000:3423+sync, sub_13840 1000:3840, sub_139a3 1000:39a3, 
// tree: children of sub_1033b 1000:033b: sub_104f3 1000:04f3, sub_10529 1000:0529, sub_12c07 1000:2c07, sub_12c9a 1000:2c9a, 
// tree: children of sub_10600 1000:0600: sub_10637 1000:0637, 
// tree: children of sub_10637 1000:0637: sub_1064d 1000:064d, 
// tree: children of sub_10644 1000:0644: sub_1064d 1000:064d, 
// tree: children of sub_1069a 1000:069a: sub_107af 1000:07af, sub_10bc5 1000:0bc5, 
// tree: children of sub_108ba 1000:08ba: sub_1094a 1000:094a, sub_109e9 1000:09e9, sub_10a1b 1000:0a1b, sub_10b58 1000:0b58, 
// tree: children of sub_109b5 1000:09b5: sub_10a1b 1000:0a1b, 
// tree: children of sub_10b8e 1000:0b8e: sub_10bdc 1000:0bdc, 
// tree: children of sub_10bc5 1000:0bc5: sub_10bdc 1000:0bdc, 
// tree: children of sub_10bdc 1000:0bdc: sub_10c24 1000:0c24, 
// tree: children of sub_10d98 1000:0d98: sub_10b7c 1000:0b7c, 
// tree: children of sub_10da7 1000:0da7: sub_1069a 1000:069a, sub_109a4 1000:09a4, sub_10e3d 1000:0e3d, 
// tree: children of sub_10dc0 1000:0dc0: sub_1069a 1000:069a, sub_109a4 1000:09a4, sub_10e3d 1000:0e3d, sub_12a7f 1000:2a7f, 
// tree: children of sub_10e07 1000:0e07: sub_1069a 1000:069a, sub_10e3d 1000:0e3d, sub_12200 1000:2200, sub_12329 1000:2329, 
// tree: children of sub_10e3d 1000:0e3d: sub_10e84 1000:0e84, 
// tree: children of sub_10e84 1000:0e84: sub_1069a 1000:069a, sub_108ba 1000:08ba, sub_10b58 1000:0b58, sub_10b7c 1000:0b7c, sub_10f9d 1000:0f9d, sub_11b57 1000:1b57, sub_11cd9 1000:1cd9, sub_12121 1000:2121, 
// tree: children of sub_10f3c 1000:0f3c: sub_10b58 1000:0b58, sub_10b7c 1000:0b7c, sub_12ddc 1000:2ddc, sub_12df6 1000:2df6, sub_12f50 1000:2f50, 
// tree: children of sub_10fda 1000:0fda: sub_10dc0 1000:0dc0, sub_10e07 1000:0e07, sub_10e84 1000:0e84, sub_10f3c 1000:0f3c, sub_110c6 1000:10c6, sub_110f3 1000:10f3, sub_11108 1000:1108, sub_112a7 1000:12a7, sub_112cb 1000:12cb, sub_112eb 1000:12eb, sub_11384 1000:1384, sub_113a8 1000:13a8, sub_11429 1000:1429, sub_114f0 1000:14f0, sub_115fc 1000:15fc, sub_116d6 1000:16d6, sub_116df 1000:16df, sub_116fe 1000:16fe, sub_1171f 1000:171f, sub_11740 1000:1740, sub_1176c 1000:176c, sub_11783 1000:1783, sub_117ac 1000:17ac, sub_117d6 1000:17d6, sub_117f4 1000:17f4, sub_118a9 1000:18a9, sub_118c7 1000:18c7, sub_11993 1000:1993, sub_119c2 1000:19c2, sub_11a9e 1000:1a9e, sub_11b09 1000:1b09, sub_11b4a 1000:1b4a, sub_12e02 1000:2e02, sub_12f50 1000:2f50, sub_12fe8 1000:2fe8, sub_1300a 1000:300a, sub_13840 1000:3840, 
// tree: children of sub_110f3 1000:10f3: sub_110a0 1000:10a0, 
// tree: children of sub_11108 1000:1108: sub_10a51 1000:0a51, sub_10b58 1000:0b58, sub_11b57 1000:1b57, sub_11b80 1000:1b80, sub_11bb9 1000:1bb9, sub_11c33 1000:1c33, sub_11c56 1000:1c56, sub_11c78 1000:1c78, sub_11cd9 1000:1cd9, sub_11d1e 1000:1d1e, sub_13840 1000:3840, 
// tree: children of sub_112a7 1000:12a7: sub_11b57 1000:1b57, sub_11bb9 1000:1bb9, sub_11c33 1000:1c33, sub_12121 1000:2121, 
// tree: children of sub_112cb 1000:12cb: sub_11b57 1000:1b57, sub_11bb9 1000:1bb9, 
// tree: children of sub_112eb 1000:12eb: sub_107fd 1000:07fd, sub_10ad5 1000:0ad5, sub_110a0 1000:10a0, sub_11c0a 1000:1c0a, sub_12047 1000:2047, sub_12092 1000:2092, sub_120db 1000:20db, sub_12662 1000:2662, sub_13840 1000:3840, 
// tree: children of sub_11384 1000:1384: sub_11cd9 1000:1cd9, 
// tree: children of sub_113a8 1000:13a8: sub_107fd 1000:07fd, sub_10ad5 1000:0ad5, sub_110a0 1000:10a0, sub_11c0a 1000:1c0a, sub_120db 1000:20db, sub_120f0 1000:20f0, sub_12121 1000:2121, sub_13840 1000:3840, 
// tree: children of sub_11429 1000:1429: sub_107fd 1000:07fd, sub_110c6 1000:10c6, sub_120f0 1000:20f0, sub_12121 1000:2121, sub_13840 1000:3840, 
// tree: children of sub_114f0 1000:14f0: sub_107fd 1000:07fd, sub_110c6 1000:10c6, sub_11def 1000:1def, sub_12092 1000:2092, sub_120f0 1000:20f0, sub_12121 1000:2121, sub_12662 1000:2662, sub_12676 1000:2676, sub_13840 1000:3840, 
// tree: children of sub_115fc 1000:15fc: sub_107fd 1000:07fd, sub_110c6 1000:10c6, sub_12092 1000:2092, sub_13840 1000:3840, 
// tree: children of sub_116df 1000:16df: sub_110c6 1000:10c6, 
// tree: children of sub_116fe 1000:16fe: sub_110c6 1000:10c6, sub_12121 1000:2121, 
// tree: children of sub_1171f 1000:171f: sub_110c6 1000:10c6, sub_12121 1000:2121, 
// tree: children of sub_11740 1000:1740: sub_12121 1000:2121, 
// tree: children of sub_1176c 1000:176c: sub_110c6 1000:10c6, sub_12121 1000:2121, 
// tree: children of sub_11783 1000:1783: sub_110c6 1000:10c6, sub_12121 1000:2121, 
// tree: children of sub_117ac 1000:17ac: sub_110c6 1000:10c6, sub_11f0b 1000:1f0b, sub_12121 1000:2121, sub_1215b 1000:215b, 
// tree: children of sub_117d6 1000:17d6: sub_110c6 1000:10c6, sub_12005 1000:2005, sub_12121 1000:2121, sub_1215b 1000:215b, 
// tree: children of sub_117f4 1000:17f4: sub_110c6 1000:10c6, sub_12099 1000:2099, sub_13840 1000:3840, 
// tree: children of sub_118a9 1000:18a9: sub_110c6 1000:10c6, sub_11fba 1000:1fba, sub_12121 1000:2121, sub_1215b 1000:215b, 
// tree: children of sub_118c7 1000:18c7: sub_110c6 1000:10c6, sub_1196f 1000:196f, 
// tree: children of sub_1196f 1000:196f: sub_12121 1000:2121, 
// tree: children of sub_11993 1000:1993: sub_11a04 1000:1a04, 
// tree: children of sub_119c2 1000:19c2: sub_11a04 1000:1a04, 
// tree: children of sub_11a04 1000:1a04: sub_110c6 1000:10c6, 
// tree: children of sub_11a9e 1000:1a9e: sub_110c6 1000:10c6, sub_13840 1000:3840, 
// tree: children of sub_11b09 1000:1b09: sub_110c6 1000:10c6, sub_12b28 1000:2b28, sub_13840 1000:3840, 
// tree: children of sub_11b4a 1000:1b4a: sub_110a0 1000:10a0, 
// tree: children of sub_11b57 1000:1b57: sub_107fd 1000:07fd, sub_12121 1000:2121, 
// tree: children of sub_11bb9 1000:1bb9: sub_108ba 1000:08ba, 
// tree: children of sub_11c33 1000:1c33: sub_120f0 1000:20f0, sub_13840 1000:3840, 
// tree: children of sub_11c56 1000:1c56: sub_11c0a 1000:1c0a, sub_120db 1000:20db, sub_13840 1000:3840, 
// tree: children of sub_11cd9 1000:1cd9: sub_12121 1000:2121, 
// tree: children of sub_11d1e 1000:1d1e: sub_10b58 1000:0b58, sub_12121 1000:2121, 
// tree: children of sub_11def 1000:1def: sub_11e7d 1000:1e7d, 
// tree: children of sub_11e7d 1000:1e7d: sub_10b58 1000:0b58, sub_115fc 1000:15fc, sub_116d6 1000:16d6, sub_12121 1000:2121, 
// tree: children of sub_11f0b 1000:1f0b: sub_10b58 1000:0b58, sub_115fc 1000:15fc, sub_116d6 1000:16d6, sub_12121 1000:2121, 
// tree: children of sub_11fba 1000:1fba: sub_10b58 1000:0b58, sub_11429 1000:1429, sub_12121 1000:2121, 
// tree: children of sub_12005 1000:2005: sub_10b58 1000:0b58, sub_117f4 1000:17f4, 
// tree: children of sub_12047 1000:2047: sub_120a0 1000:20a0, sub_13840 1000:3840, 
// tree: children of sub_12092 1000:2092: sub_120a0 1000:20a0, 
// tree: children of sub_12099 1000:2099: sub_120a0 1000:20a0, 
// tree: children of sub_120db 1000:20db: sub_109b5 1000:09b5, sub_120f0 1000:20f0, sub_12676 1000:2676, 
// tree: children of sub_120f0 1000:20f0: sub_10b58 1000:0b58, 
// tree: children of sub_121dc 1000:21dc: sub_12200 1000:2200, sub_122b1 1000:22b1, sub_1264a 1000:264a, sub_12a7f 1000:2a7f, sub_12cea 1000:2cea, 
// tree: children of sub_12200 1000:2200: sub_1237c 1000:237c, sub_1250b 1000:250b, sub_12553 1000:2553, sub_1259b 1000:259b, 
// tree: children of sub_1220d 1000:220d: sub_1239b 1000:239b, sub_12464 1000:2464, sub_1252f 1000:252f, sub_12542 1000:2542, sub_12577 1000:2577, sub_1258a 1000:258a, sub_125bf 1000:25bf, sub_125d2 1000:25d2, sub_1269e 1000:269e, sub_12714 1000:2714, 
// tree: children of sub_122b1 1000:22b1: sub_122e1 1000:22e1, sub_122f9 1000:22f9, sub_12311 1000:2311, 
// tree: children of sub_122c1 1000:22c1: sub_12cea 1000:2cea, 
// tree: children of sub_122e1 1000:22e1: sub_12cea 1000:2cea, 
// tree: children of sub_122f9 1000:22f9: sub_12cea 1000:2cea, 
// tree: children of sub_12311 1000:2311: sub_12cea 1000:2cea, 
// tree: children of sub_12329 1000:2329: sub_12d9a 1000:2d9a, 
// tree: children of sub_1237c 1000:237c: sub_123d4 1000:23d4, sub_123ec 1000:23ec, sub_12404 1000:2404, sub_1241c 1000:241c, sub_12434 1000:2434, sub_1244c 1000:244c, 
// tree: children of sub_1239b 1000:239b: sub_12cea 1000:2cea, sub_13840 1000:3840, 
// tree: children of sub_123d4 1000:23d4: sub_12cea 1000:2cea, 
// tree: children of sub_123ec 1000:23ec: sub_12cea 1000:2cea, 
// tree: children of sub_12404 1000:2404: sub_12cea 1000:2cea, 
// tree: children of sub_1241c 1000:241c: sub_12cea 1000:2cea, 
// tree: children of sub_12434 1000:2434: sub_12cea 1000:2cea, 
// tree: children of sub_1244c 1000:244c: sub_12cea 1000:2cea, 
// tree: children of sub_12464 1000:2464: sub_12d9a 1000:2d9a, 
// tree: children of sub_1250b 1000:250b: sub_12cea 1000:2cea, 
// tree: children of sub_1252f 1000:252f: sub_125e3 1000:25e3, 
// tree: children of sub_12536 1000:2536: sub_125e3 1000:25e3, 
// tree: children of sub_12542 1000:2542: sub_12536 1000:2536, 
// tree: children of sub_12553 1000:2553: sub_12cea 1000:2cea, 
// tree: children of sub_12577 1000:2577: sub_125e3 1000:25e3, 
// tree: children of sub_1257e 1000:257e: sub_125e3 1000:25e3, 
// tree: children of sub_1258a 1000:258a: sub_1257e 1000:257e, 
// tree: children of sub_1259b 1000:259b: sub_12cea 1000:2cea, 
// tree: children of sub_125bf 1000:25bf: sub_125e3 1000:25e3, 
// tree: children of sub_125c6 1000:25c6: sub_125e3 1000:25e3, 
// tree: children of sub_125d2 1000:25d2: sub_125c6 1000:25c6, 
// tree: children of sub_1264a 1000:264a: sub_12714 1000:2714, 
// tree: children of sub_12662 1000:2662: sub_1269e 1000:269e, 
// tree: children of sub_12676 1000:2676: sub_1269e 1000:269e, 
// tree: children of sub_1268a 1000:268a: sub_1269e 1000:269e, 
// tree: children of sub_1269e 1000:269e: sub_122c1 1000:22c1, 
// tree: children of sub_12714 1000:2714: sub_12cea 1000:2cea, 
// tree: children of sub_12762 1000:2762: sub_10644 1000:0644, 
// tree: children of sub_1279f 1000:279f: sub_12809 1000:2809, sub_128da 1000:28da, 
// tree: children of sub_12809 1000:2809: sub_12872 1000:2872, 
// tree: children of sub_128da 1000:28da: sub_12907 1000:2907, sub_12959 1000:2959, 
// tree: children of sub_12907 1000:2907: sub_129ae 1000:29ae, 
// tree: children of sub_12959 1000:2959: sub_129ae 1000:29ae, 
// tree: children of sub_1296f 1000:296f: sub_129ae 1000:29ae, 
// tree: children of sub_129db 1000:29db+sync: sub_10541 1000:0541, sub_10674 1000:0674, sub_10b8e 1000:0b8e, sub_12a64 1000:2a64, sub_13383 1000:3383+sync, sub_13498 1000:3498, 
// tree: children of sub_12a64 1000:2a64: sub_1296f 1000:296f, 
// tree: children of sub_12a7f 1000:2a7f: sub_12cea 1000:2cea, 
// tree: children of sub_12b28 1000:2b28: sub_1269e 1000:269e, sub_12cea 1000:2cea, 
// tree: children of sub_12c07 1000:2c07: sub_12cea 1000:2cea, sub_12d9a 1000:2d9a, 
// tree: children of sub_12c45 1000:2c45: sub_12cea 1000:2cea, sub_12d9a 1000:2d9a, 
// tree: children of sub_12c9a 1000:2c9a: sub_12cc7 1000:2cc7, sub_12cea 1000:2cea, sub_12d9a 1000:2d9a, 
// tree: children of sub_12cc7 1000:2cc7: sub_12cea 1000:2cea, 
// tree: children of sub_12e02 1000:2e02: sub_11b80 1000:1b80, sub_12121 1000:2121, sub_13084 1000:3084, sub_1309d 1000:309d, sub_13840 1000:3840, 
// tree: children of sub_12f50 1000:2f50: sub_12121 1000:2121, sub_13059 1000:3059, 
// tree: children of sub_12fe8 1000:2fe8: sub_12121 1000:2121, 
// tree: children of sub_1300a 1000:300a: sub_12121 1000:2121, sub_13059 1000:3059, sub_13130 1000:3130, sub_13840 1000:3840, 
// tree: children of sub_13059 1000:3059: sub_1268a 1000:268a, 
// tree: children of sub_1309d 1000:309d: sub_10b58 1000:0b58, 
// tree: children of sub_13130 1000:3130: sub_1315e 1000:315e, sub_13170 1000:3170, sub_13181 1000:3181, sub_13191 1000:3191, 
// tree: children of sub_131a4 1000:31a4: sub_131e7 1000:31e7, sub_13209 1000:3209, 
// tree: children of sub_1333c 1000:333c+sync: sub_133b3 1000:33b3, sub_133d7 1000:33d7+sync, 
// tree: children of sub_13383 1000:3383+sync: sub_133d7 1000:33d7+sync, 
// tree: children of sub_13423 1000:3423+sync: sub_13383 1000:3383+sync, sub_133b3 1000:33b3, sub_13439 1000:3439, 
// tree: children of sub_13472 1000:3472+sync: sub_13291 1000:3291, sub_13383 1000:3383+sync, sub_133e5 1000:33e5, 
// tree: children of sub_13498 1000:3498: sub_13291 1000:3291, 
// tree: children of sub_134a8 1000:34a8: sub_135bc 1000:35bc, sub_136d4 1000:36d4, 
// tree: children of sub_135bc 1000:35bc: sub_136d4 1000:36d4, 
// tree: children of sub_136d4 1000:36d4: sub_13801 1000:3801, 
// tree: children of sub_13840 1000:3840: sub_13914 1000:3914, 
// tree: parents of sub_100a9 1000:00a9+sync: sub_10010 1000:0010+sync, 
// tree: parents of sub_100cf 1000:00cf+sync: sub_10010 1000:0010+sync, 
// tree: parents of sub_100fd 1000:00fd: sub_10010 1000:0010+sync, 
// tree: parents of sub_10103 1000:0103+sync: sub_100a9 1000:00a9+sync, sub_101c0 1000:01c0+sync, 
// tree: parents of sub_1019d 1000:019d: sub_10103 1000:0103+sync, 
// tree: parents of sub_101ad 1000:01ad+sync: sub_10103 1000:0103+sync, 
// tree: parents of sub_101c0 1000:01c0+sync: sub_100cf 1000:00cf+sync, sub_10103 1000:0103+sync, sub_101ad 1000:01ad+sync, 
// tree: parents of sub_1033b 1000:033b: sub_101c0 1000:01c0+sync, 
// tree: parents of sub_10442 1000:0442: sub_10010 1000:0010+sync, 
// tree: parents of sub_104a5 1000:04a5: sub_101c0 1000:01c0+sync, 
// tree: parents of sub_104f3 1000:04f3: sub_1033b 1000:033b, 
// tree: parents of sub_10529 1000:0529: sub_101c0 1000:01c0+sync, sub_1033b 1000:033b, 
// tree: parents of sub_10541 1000:0541: sub_129db 1000:29db+sync, 
// tree: parents of sub_10588 1000:0588: sub_10010 1000:0010+sync, 
// tree: parents of sub_10591 1000:0591: sub_10010 1000:0010+sync, 
// tree: parents of sub_105bc 1000:05bc: sub_101c0 1000:01c0+sync, 
// tree: parents of sub_105ec 1000:05ec: sub_10010 1000:0010+sync, 
// tree: parents of sub_10600 1000:0600: sub_10010 1000:0010+sync, 
// tree: parents of sub_10637 1000:0637: sub_10600 1000:0600, 
// tree: parents of sub_10644 1000:0644: sub_12762 1000:2762, 
// tree: parents of sub_1064d 1000:064d: sub_10637 1000:0637, sub_10644 1000:0644, 
// tree: parents of sub_10674 1000:0674: sub_129db 1000:29db+sync, 
// tree: parents of sub_1069a 1000:069a: sub_10da7 1000:0da7, sub_10dc0 1000:0dc0, sub_10e07 1000:0e07, sub_10e84 1000:0e84, 
// tree: parents of sub_107af 1000:07af: sub_1069a 1000:069a, 
// tree: parents of sub_107fd 1000:07fd: sub_112eb 1000:12eb, sub_113a8 1000:13a8, sub_11429 1000:1429, sub_114f0 1000:14f0, sub_115fc 1000:15fc, sub_11b57 1000:1b57, 
// tree: parents of sub_108ba 1000:08ba: sub_10e84 1000:0e84, sub_11bb9 1000:1bb9, 
// tree: parents of sub_1094a 1000:094a: sub_108ba 1000:08ba, 
// tree: parents of sub_109a4 1000:09a4: sub_10da7 1000:0da7, sub_10dc0 1000:0dc0, 
// tree: parents of sub_109b5 1000:09b5: sub_120db 1000:20db, 
// tree: parents of sub_109e9 1000:09e9: sub_108ba 1000:08ba, 
// tree: parents of sub_10a1b 1000:0a1b: sub_108ba 1000:08ba, sub_109b5 1000:09b5, 
// tree: parents of sub_10a51 1000:0a51: sub_11108 1000:1108, 
// tree: parents of sub_10ad5 1000:0ad5: sub_112eb 1000:12eb, sub_113a8 1000:13a8, 
// tree: parents of sub_10b58 1000:0b58: sub_1019d 1000:019d, sub_108ba 1000:08ba, sub_10e84 1000:0e84, sub_10f3c 1000:0f3c, sub_11108 1000:1108, sub_11d1e 1000:1d1e, sub_11e7d 1000:1e7d, sub_11f0b 1000:1f0b, sub_11fba 1000:1fba, sub_12005 1000:2005, sub_120f0 1000:20f0, sub_1309d 1000:309d, 
// tree: parents of sub_10b7c 1000:0b7c: sub_10d98 1000:0d98, sub_10e84 1000:0e84, sub_10f3c 1000:0f3c, 
// tree: parents of sub_10b8e 1000:0b8e: sub_100cf 1000:00cf+sync, sub_10103 1000:0103+sync, sub_129db 1000:29db+sync, 
// tree: parents of sub_10bc5 1000:0bc5: sub_1069a 1000:069a, 
// tree: parents of sub_10bdc 1000:0bdc: sub_10b8e 1000:0b8e, sub_10bc5 1000:0bc5, 
// tree: parents of sub_10c24 1000:0c24: sub_10bdc 1000:0bdc, 
// tree: parents of sub_10d98 1000:0d98: sub_10103 1000:0103+sync, 
// tree: parents of sub_10da7 1000:0da7: sub_100a9 1000:00a9+sync, sub_101c0 1000:01c0+sync, 
// tree: parents of sub_10dc0 1000:0dc0: sub_10fda 1000:0fda, 
// tree: parents of sub_10e07 1000:0e07: sub_10fda 1000:0fda, 
// tree: parents of sub_10e3d 1000:0e3d: sub_10da7 1000:0da7, sub_10dc0 1000:0dc0, sub_10e07 1000:0e07, 
// tree: parents of sub_10e84 1000:0e84: sub_10e3d 1000:0e3d, sub_10fda 1000:0fda, 
// tree: parents of sub_10f3c 1000:0f3c: sub_10fda 1000:0fda, 
// tree: parents of sub_10f9d 1000:0f9d: sub_10e84 1000:0e84, 
// tree: parents of sub_10fda 1000:0fda: sub_100cf 1000:00cf+sync, sub_10103 1000:0103+sync, 
// tree: parents of sub_110a0 1000:10a0: sub_110f3 1000:10f3, sub_112eb 1000:12eb, sub_113a8 1000:13a8, sub_11b4a 1000:1b4a, 
// tree: parents of sub_110c6 1000:10c6: sub_10fda 1000:0fda, sub_11429 1000:1429, sub_114f0 1000:14f0, sub_115fc 1000:15fc, sub_116df 1000:16df, sub_116fe 1000:16fe, sub_1171f 1000:171f, sub_1176c 1000:176c, sub_11783 1000:1783, sub_117ac 1000:17ac, sub_117d6 1000:17d6, sub_117f4 1000:17f4, sub_118a9 1000:18a9, sub_118c7 1000:18c7, sub_11a04 1000:1a04, sub_11a9e 1000:1a9e, sub_11b09 1000:1b09, 
// tree: parents of sub_110f3 1000:10f3: sub_10fda 1000:0fda, 
// tree: parents of sub_11108 1000:1108: sub_10fda 1000:0fda, 
// tree: parents of sub_112a7 1000:12a7: sub_10fda 1000:0fda, 
// tree: parents of sub_112cb 1000:12cb: sub_10fda 1000:0fda, 
// tree: parents of sub_112eb 1000:12eb: sub_10fda 1000:0fda, 
// tree: parents of sub_11384 1000:1384: sub_10fda 1000:0fda, 
// tree: parents of sub_113a8 1000:13a8: sub_10fda 1000:0fda, 
// tree: parents of sub_11429 1000:1429: sub_10fda 1000:0fda, sub_11fba 1000:1fba, 
// tree: parents of sub_114f0 1000:14f0: sub_10fda 1000:0fda, 
// tree: parents of sub_115fc 1000:15fc: sub_10fda 1000:0fda, sub_11e7d 1000:1e7d, sub_11f0b 1000:1f0b, 
// tree: parents of sub_116d6 1000:16d6: sub_10fda 1000:0fda, sub_11e7d 1000:1e7d, sub_11f0b 1000:1f0b, 
// tree: parents of sub_116df 1000:16df: sub_10fda 1000:0fda, 
// tree: parents of sub_116fe 1000:16fe: sub_10fda 1000:0fda, 
// tree: parents of sub_1171f 1000:171f: sub_10fda 1000:0fda, 
// tree: parents of sub_11740 1000:1740: sub_10fda 1000:0fda, 
// tree: parents of sub_1176c 1000:176c: sub_10fda 1000:0fda, 
// tree: parents of sub_11783 1000:1783: sub_10fda 1000:0fda, 
// tree: parents of sub_117ac 1000:17ac: sub_10fda 1000:0fda, 
// tree: parents of sub_117d6 1000:17d6: sub_10fda 1000:0fda, 
// tree: parents of sub_117f4 1000:17f4: sub_10fda 1000:0fda, sub_12005 1000:2005, 
// tree: parents of sub_118a9 1000:18a9: sub_10fda 1000:0fda, 
// tree: parents of sub_118c7 1000:18c7: sub_10fda 1000:0fda, 
// tree: parents of sub_1196f 1000:196f: sub_118c7 1000:18c7, 
// tree: parents of sub_11993 1000:1993: sub_10fda 1000:0fda, 
// tree: parents of sub_119c2 1000:19c2: sub_10fda 1000:0fda, 
// tree: parents of sub_11a04 1000:1a04: sub_11993 1000:1993, sub_119c2 1000:19c2, 
// tree: parents of sub_11a9e 1000:1a9e: sub_10fda 1000:0fda, 
// tree: parents of sub_11b09 1000:1b09: sub_10fda 1000:0fda, 
// tree: parents of sub_11b4a 1000:1b4a: sub_10fda 1000:0fda, 
// tree: parents of sub_11b57 1000:1b57: sub_10e84 1000:0e84, sub_11108 1000:1108, sub_112a7 1000:12a7, sub_112cb 1000:12cb, 
// tree: parents of sub_11b80 1000:1b80: sub_11108 1000:1108, sub_12e02 1000:2e02, 
// tree: parents of sub_11bb9 1000:1bb9: sub_11108 1000:1108, sub_112a7 1000:12a7, sub_112cb 1000:12cb, 
// tree: parents of sub_11c0a 1000:1c0a: sub_112eb 1000:12eb, sub_113a8 1000:13a8, sub_11c56 1000:1c56, 
// tree: parents of sub_11c33 1000:1c33: sub_11108 1000:1108, sub_112a7 1000:12a7, 
// tree: parents of sub_11c56 1000:1c56: sub_11108 1000:1108, 
// tree: parents of sub_11c78 1000:1c78: sub_11108 1000:1108, 
// tree: parents of sub_11cd9 1000:1cd9: sub_10e84 1000:0e84, sub_11108 1000:1108, sub_11384 1000:1384, 
// tree: parents of sub_11d1e 1000:1d1e: sub_11108 1000:1108, 
// tree: parents of sub_11def 1000:1def: sub_114f0 1000:14f0, 
// tree: parents of sub_11e7d 1000:1e7d: sub_11def 1000:1def, 
// tree: parents of sub_11f0b 1000:1f0b: sub_117ac 1000:17ac, 
// tree: parents of sub_11fba 1000:1fba: sub_118a9 1000:18a9, 
// tree: parents of sub_12005 1000:2005: sub_117d6 1000:17d6, 
// tree: parents of sub_12047 1000:2047: sub_112eb 1000:12eb, 
// tree: parents of sub_12092 1000:2092: sub_112eb 1000:12eb, sub_114f0 1000:14f0, sub_115fc 1000:15fc, 
// tree: parents of sub_12099 1000:2099: sub_117f4 1000:17f4, 
// tree: parents of sub_120a0 1000:20a0: sub_12047 1000:2047, sub_12092 1000:2092, sub_12099 1000:2099, 
// tree: parents of sub_120db 1000:20db: sub_112eb 1000:12eb, sub_113a8 1000:13a8, sub_11c56 1000:1c56, 
// tree: parents of sub_120f0 1000:20f0: sub_113a8 1000:13a8, sub_11429 1000:1429, sub_114f0 1000:14f0, sub_11c33 1000:1c33, sub_120db 1000:20db, 
// tree: parents of sub_12121 1000:2121: sub_1019d 1000:019d, sub_10e84 1000:0e84, sub_112a7 1000:12a7, sub_113a8 1000:13a8, sub_11429 1000:1429, sub_114f0 1000:14f0, sub_116fe 1000:16fe, sub_1171f 1000:171f, sub_11740 1000:1740, sub_1176c 1000:176c, sub_11783 1000:1783, sub_117ac 1000:17ac, sub_117d6 1000:17d6, sub_118a9 1000:18a9, sub_1196f 1000:196f, sub_11b57 1000:1b57, sub_11cd9 1000:1cd9, sub_11d1e 1000:1d1e, sub_11e7d 1000:1e7d, sub_11f0b 1000:1f0b, sub_11fba 1000:1fba, sub_12e02 1000:2e02, sub_12f50 1000:2f50, sub_12fe8 1000:2fe8, sub_1300a 1000:300a, 
// tree: parents of sub_1215b 1000:215b: sub_117ac 1000:17ac, sub_117d6 1000:17d6, sub_118a9 1000:18a9, 
// tree: parents of sub_121dc 1000:21dc: sub_100a9 1000:00a9+sync, sub_101c0 1000:01c0+sync, 
// tree: parents of sub_12200 1000:2200: sub_10e07 1000:0e07, sub_121dc 1000:21dc, 
// tree: parents of sub_1220d 1000:220d: sub_100cf 1000:00cf+sync, 
// tree: parents of sub_122b1 1000:22b1: sub_121dc 1000:21dc, 
// tree: parents of sub_122c1 1000:22c1: sub_1269e 1000:269e, 
// tree: parents of sub_122e1 1000:22e1: sub_122b1 1000:22b1, 
// tree: parents of sub_122f9 1000:22f9: sub_122b1 1000:22b1, 
// tree: parents of sub_12311 1000:2311: sub_122b1 1000:22b1, 
// tree: parents of sub_12329 1000:2329: sub_10e07 1000:0e07, 
// tree: parents of sub_1237c 1000:237c: sub_12200 1000:2200, 
// tree: parents of sub_1239b 1000:239b: sub_1220d 1000:220d, 
// tree: parents of sub_123d4 1000:23d4: sub_1237c 1000:237c, 
// tree: parents of sub_123ec 1000:23ec: sub_1237c 1000:237c, 
// tree: parents of sub_12404 1000:2404: sub_1237c 1000:237c, 
// tree: parents of sub_1241c 1000:241c: sub_1237c 1000:237c, 
// tree: parents of sub_12434 1000:2434: sub_1237c 1000:237c, 
// tree: parents of sub_1244c 1000:244c: sub_1237c 1000:237c, 
// tree: parents of sub_12464 1000:2464: sub_1220d 1000:220d, 
// tree: parents of sub_1250b 1000:250b: sub_12200 1000:2200, 
// tree: parents of sub_1252f 1000:252f: sub_1220d 1000:220d, 
// tree: parents of sub_12536 1000:2536: sub_12542 1000:2542, 
// tree: parents of sub_12542 1000:2542: sub_1220d 1000:220d, 
// tree: parents of sub_12553 1000:2553: sub_12200 1000:2200, 
// tree: parents of sub_12577 1000:2577: sub_1220d 1000:220d, 
// tree: parents of sub_1257e 1000:257e: sub_1258a 1000:258a, 
// tree: parents of sub_1258a 1000:258a: sub_1220d 1000:220d, 
// tree: parents of sub_1259b 1000:259b: sub_12200 1000:2200, 
// tree: parents of sub_125bf 1000:25bf: sub_1220d 1000:220d, 
// tree: parents of sub_125c6 1000:25c6: sub_125d2 1000:25d2, 
// tree: parents of sub_125d2 1000:25d2: sub_1220d 1000:220d, 
// tree: parents of sub_125e3 1000:25e3: sub_1252f 1000:252f, sub_12536 1000:2536, sub_12577 1000:2577, sub_1257e 1000:257e, sub_125bf 1000:25bf, sub_125c6 1000:25c6, 
// tree: parents of sub_1264a 1000:264a: sub_121dc 1000:21dc, 
// tree: parents of sub_12662 1000:2662: sub_112eb 1000:12eb, sub_114f0 1000:14f0, 
// tree: parents of sub_12676 1000:2676: sub_114f0 1000:14f0, sub_120db 1000:20db, 
// tree: parents of sub_1268a 1000:268a: sub_13059 1000:3059, 
// tree: parents of sub_1269e 1000:269e: sub_1220d 1000:220d, sub_12662 1000:2662, sub_12676 1000:2676, sub_1268a 1000:268a, sub_12b28 1000:2b28, 
// tree: parents of sub_12714 1000:2714: sub_1220d 1000:220d, sub_1264a 1000:264a, 
// tree: parents of sub_12762 1000:2762: sub_10010 1000:0010+sync, 
// tree: parents of sub_1279f 1000:279f: sub_10103 1000:0103+sync, 
// tree: parents of sub_12809 1000:2809: sub_1279f 1000:279f, 
// tree: parents of sub_12872 1000:2872: sub_12809 1000:2809, 
// tree: parents of sub_128da 1000:28da: sub_10103 1000:0103+sync, sub_1279f 1000:279f, 
// tree: parents of sub_12907 1000:2907: sub_128da 1000:28da, 
// tree: parents of sub_12959 1000:2959: sub_128da 1000:28da, 
// tree: parents of sub_1296f 1000:296f: sub_12a64 1000:2a64, 
// tree: parents of sub_129ae 1000:29ae: sub_12907 1000:2907, sub_12959 1000:2959, sub_1296f 1000:296f, 
// tree: parents of sub_129db 1000:29db+sync: sub_10103 1000:0103+sync, 
// tree: parents of sub_12a64 1000:2a64: sub_129db 1000:29db+sync, 
// tree: parents of sub_12a7f 1000:2a7f: sub_10dc0 1000:0dc0, sub_121dc 1000:21dc, 
// tree: parents of sub_12b28 1000:2b28: sub_11b09 1000:1b09, 
// tree: parents of sub_12c07 1000:2c07: sub_1033b 1000:033b, 
// tree: parents of sub_12c45 1000:2c45: sub_101c0 1000:01c0+sync, 
// tree: parents of sub_12c9a 1000:2c9a: sub_1033b 1000:033b, 
// tree: parents of sub_12cc7 1000:2cc7: sub_12c9a 1000:2c9a, 
// tree: parents of sub_12cea 1000:2cea: sub_121dc 1000:21dc, sub_122c1 1000:22c1, sub_122e1 1000:22e1, sub_122f9 1000:22f9, sub_12311 1000:2311, sub_1239b 1000:239b, sub_123d4 1000:23d4, sub_123ec 1000:23ec, sub_12404 1000:2404, sub_1241c 1000:241c, sub_12434 1000:2434, sub_1244c 1000:244c, sub_1250b 1000:250b, sub_12553 1000:2553, sub_1259b 1000:259b, sub_12714 1000:2714, sub_12a7f 1000:2a7f, sub_12b28 1000:2b28, sub_12c07 1000:2c07, sub_12c45 1000:2c45, sub_12c9a 1000:2c9a, sub_12cc7 1000:2cc7, 
// tree: parents of sub_12d9a 1000:2d9a: sub_12329 1000:2329, sub_12464 1000:2464, sub_12c07 1000:2c07, sub_12c45 1000:2c45, sub_12c9a 1000:2c9a, 
// tree: parents of sub_12ddc 1000:2ddc: sub_10f3c 1000:0f3c, 
// tree: parents of sub_12df6 1000:2df6: sub_10f3c 1000:0f3c, 
// tree: parents of sub_12e02 1000:2e02: sub_10fda 1000:0fda, 
// tree: parents of sub_12f50 1000:2f50: sub_10f3c 1000:0f3c, sub_10fda 1000:0fda, 
// tree: parents of sub_12fe8 1000:2fe8: sub_10fda 1000:0fda, 
// tree: parents of sub_1300a 1000:300a: sub_10fda 1000:0fda, 
// tree: parents of sub_13059 1000:3059: sub_12f50 1000:2f50, sub_1300a 1000:300a, 
// tree: parents of sub_13084 1000:3084: sub_12e02 1000:2e02, 
// tree: parents of sub_1309d 1000:309d: sub_12e02 1000:2e02, 
// tree: parents of sub_13130 1000:3130: sub_1300a 1000:300a, 
// tree: parents of sub_1315e 1000:315e: sub_13130 1000:3130, 
// tree: parents of sub_13170 1000:3170: sub_13130 1000:3130, 
// tree: parents of sub_13181 1000:3181: sub_13130 1000:3130, 
// tree: parents of sub_13191 1000:3191: sub_13130 1000:3130, 
// tree: parents of sub_131a4 1000:31a4: sub_100cf 1000:00cf+sync, 
// tree: parents of sub_131e7 1000:31e7: sub_131a4 1000:31a4, 
// tree: parents of sub_13209 1000:3209: sub_131a4 1000:31a4, 
// tree: parents of sub_13291 1000:3291: sub_13472 1000:3472+sync, sub_13498 1000:3498, 
// tree: parents of sub_132fe 1000:32fe: sub_100cf 1000:00cf+sync, 
// tree: parents of sub_1333c 1000:333c+sync: sub_10010 1000:0010+sync, 
// tree: parents of sub_13383 1000:3383+sync: sub_100cf 1000:00cf+sync, sub_10103 1000:0103+sync, sub_129db 1000:29db+sync, sub_13423 1000:3423+sync, sub_13472 1000:3472+sync, 
// tree: parents of sub_133b3 1000:33b3: sub_1333c 1000:333c+sync, sub_13423 1000:3423+sync, 
// tree: parents of sub_133d7 1000:33d7+sync: sub_1333c 1000:333c+sync, sub_13383 1000:3383+sync, 
// tree: parents of sub_133e5 1000:33e5: sub_13472 1000:3472+sync, 
// tree: parents of sub_13423 1000:3423+sync: sub_100a9 1000:00a9+sync, sub_101c0 1000:01c0+sync, 
// tree: parents of sub_13439 1000:3439: sub_13423 1000:3423+sync, 
// tree: parents of sub_13472 1000:3472+sync: sub_10103 1000:0103+sync, 
// tree: parents of sub_13498 1000:3498: sub_10103 1000:0103+sync, sub_129db 1000:29db+sync, 
// tree: parents of sub_134a8 1000:34a8: sub_100cf 1000:00cf+sync, 
// tree: parents of sub_135bc 1000:35bc: sub_134a8 1000:34a8, 
// tree: parents of sub_136d4 1000:36d4: sub_134a8 1000:34a8, sub_135bc 1000:35bc, 
// tree: parents of sub_13801 1000:3801: sub_136d4 1000:36d4, 
// tree: parents of sub_1382a 1000:382a: sub_10010 1000:0010+sync, 
// tree: parents of sub_13840 1000:3840: sub_101c0 1000:01c0+sync, sub_10fda 1000:0fda, sub_11108 1000:1108, sub_112eb 1000:12eb, sub_113a8 1000:13a8, sub_11429 1000:1429, sub_114f0 1000:14f0, sub_115fc 1000:15fc, sub_117f4 1000:17f4, sub_11a9e 1000:1a9e, sub_11b09 1000:1b09, sub_11c33 1000:1c33, sub_11c56 1000:1c56, sub_12047 1000:2047, sub_1239b 1000:239b, sub_12e02 1000:2e02, sub_1300a 1000:300a, 
// tree: parents of sub_13914 1000:3914: sub_13840 1000:3840, 
// tree: parents of sub_139a3 1000:39a3: sub_101c0 1000:01c0+sync, 
// tree: parents of sub_139b8 1000:39b8: sub_10103 1000:0103+sync, 
`
