// Converts assembly generated by Ghidra into compatible format

if (process.argv.length != 5)
  throw "No arguments"

var fs = require("fs");
const rFunction = "^;undefined (.*)\\(\\)$";
var curfunc = "";
var base = process.argv[4];
var lastInstruction = null;

var lines = fs.readFileSync(process.argv[2]).toString().split("\n").map(x=>{
  if (x.indexOf(";param_1") != -1)
    return "";

  l = x.substr(28).trim().toLowerCase();

  l = l.split("fun_"+base+"_").join("sub_");
  l = l.split("lab_"+base+"_").join("loc_");

  l = l.split("fun_3000_").join("sub_"); // todo!
  l = l.split("lab_3000_").join("loc_");


  var m = l.match(rFunction);
  if (m)
  {
    var prefix = "";
//    console.log("function: "+m[1]);
    if (curfunc != "")
    {
//      console.log(lastInstruction);
      var trail = curfunc + " endp";
      if (lastInstruction.substr(0, 3) != "ret" && lastInstruction.substr(0, 3) != "jmp")
        trail += " ; sp-analysis failed";
      lastInstruction = null; 
      prefix = trail + "\n\n";
    }
    curfunc = m[1];
    return prefix + curfunc+" proc near";
  }

  if (l.indexOf(";") != -1)
    l = l.substr(0,l.indexOf(";")).trim();
  if (l == "")
    return l;


  if (l.substr(-1) == ":")
  {
    if (lastInstruction.substr(0, 4) == "test")
      console.log(curfunc + ": " + l + " ; LOST TEST!")
  }

  if (lastInstruction && lastInstruction.substr(-1) == ":") // label
  {
    if (l.substr(0, 3) != "cmp" &&
        l.substr(0, 3) != "mov" &&
        l.substr(0, 3) != "ret" &&
        l.substr(0, 3) != "inc" &&
        l.substr(0, 3) != "add" &&
        l.substr(0, 3) != "and" &&
        l.substr(0, 3) != "dec" &&
        l.substr(0, 3) != "xor" &&
        l.substr(0, 3) != "neg" &&
        l.substr(0, 3) != "lod" &&
        l.substr(0, 3) != "sto" &&
        l.substr(0, 3) != "pop" &&
        l.substr(0, 3) != "jmp" &&
        l.substr(0, 3) != "cbw" &&
        l.substr(0, 4) != "push" &&
        l.substr(0, 2) != "or" &&
        l.substr(0, 3) != "sub" &&
        l.substr(0, 2) != "in" &&
        l.substr(0, 3) != "out" &&
        l.substr(0, 4) != "test" &&
        l.substr(0, 4) != "call" &&
        l.substr(0, 4) != "loop" &&
        l.substr(0, 4) != "xchg" &&
        l.substr(0, 3) != "clc" &&
        l.substr(0, 3) != "stc" &&
        l.substr(0, 3) != "sti" &&
        l.substr(0, 3) != "mul" &&
        l.substr(0, 3) != "shl" &&
        l.substr(0, 3) != "shr" &&
        l.substr(0, 3) != "not" &&
        l.substr(0, 3) != "cld" &&
        l.substr(0, 3) != "std" &&
        1
       )
    {
      console.log(curfunc + ": " + lastInstruction + " " + l);
    }
  }

  var db = l.match("\\?\\?\\s+([0-9A-Fa-f]{2}h)")
  if (db)
    l = "db " + db[1];

  while (l.indexOf("  ") != -1)
    l = l.split("  ").join(" ");
  l = l.split(",").join(", ");


  if (l == "lodsb si")
    l = "lodsb";
  if (l == "lodsw si")
    l = "lodsw";
  if (l == "stosw es:di")
    l = "stosw";
  if (l == "movsw es:di, si")
    l = "movsw";
  if (l == "stosb es:di")
    l = "stosb";
  if (l == "movsb es:di, si")
    l = "movsb";
  if (l == "cmpsb es:di, si")
    l = "cmpsb";
  if (l == "scasb.repne es:di")
    l = "repne scasb";
  if (l == "stosb.rep es:di")
    l = "rep stosb";
  if (l == "stosw.rep es:di")
    l = "rep stosw";
  if (l == "rol ax")
    l = "rol ax, 1";
  if (l == "xor eax, eax")
    l = "xor ax, ax";
  if (l == "movsw.rep es:di, si")
    l = "rep movsw";
  if (l == "xlat cs:, bx")
    l = "xlat cs";
  if (l == "xlat es:, bx")
    l = "xlat es";
  if (l == "xlat , bx")
    l = "xlat ds";
  if (l == "scasb es:di")
    l = "scasb";
  if (l == "movsb.rep es:di, si")
    l = "rep movsb";

  if (l.indexOf("param_") != -1)
    l = "db 00h; " + l;
  if (l.indexOf("local_") != -1)
    l = "db 00h; " + l;
  if (l.indexOf("jmpf") != -1)
    l = "db 00h; " + l;
  if (l.indexOf("callf") != -1)
    l = "db 00h; " + l;
  if (l.indexOf("efined") != -1)
    l = "db 00h; " + l;

  l = l.split(" + -").join("-");
  l = l.split(" + ").join("+");

  lastInstruction = l;
  return l[l.length-1] != ":" ? "  " + l : l;
});


var out = "seg001 segment	byte public 'CODE' use16\n";
out += lines.filter(l=>l.length).join("\n");

if (curfunc)
    out += "\n" + curfunc+" endp";
out += "\nseg001 ends";

fs.writeFileSync(process.argv[3], out);
/*
                            ;************************************************************************************************
                            ;*                                           FUNCTION                                           *
                            ;************************************************************************************************
                            ;undefined FUN_0100()
ram:0000:0100   bc6206          MOV         SP,0x662                                
ram:0000:0103   33c0            XOR         AX,AX                                   
ram:0000:0105   50              PUSH        AX                                      
ram:0000:0106   8d06bb02        LEA         AX,[0x2bb]                              
ram:0000:010a   50              PUSH        AX                                      
ram:0000:010b   90              NOP                                                  
ram:0000:010c   90              NOP                                                  
ram:0000:010d   90              NOP                                                  
*/